{"url": "https://api.github.com/repos/rust-lang/rust/issues/88930", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/88930/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/88930/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/88930/events", "html_url": "https://github.com/rust-lang/rust/issues/88930", "id": 995900844, "node_id": "I_kwDOAAsO6M47XD2s", "number": 88930, "title": "Unnecessary stack usage", "user": {"login": "newpavlov", "id": 329626, "node_id": "MDQ6VXNlcjMyOTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/329626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/newpavlov", "html_url": "https://github.com/newpavlov", "followers_url": "https://api.github.com/users/newpavlov/followers", "following_url": "https://api.github.com/users/newpavlov/following{/other_user}", "gists_url": "https://api.github.com/users/newpavlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/newpavlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/newpavlov/subscriptions", "organizations_url": "https://api.github.com/users/newpavlov/orgs", "repos_url": "https://api.github.com/users/newpavlov/repos", "events_url": "https://api.github.com/users/newpavlov/events{/privacy}", "received_events_url": "https://api.github.com/users/newpavlov/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2021-09-14T11:21:36Z", "updated_at": "2023-04-05T17:35:35Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I have the following simple SIMD-powered function which tests whether points are inside one of bounding boxes:\r\n```rust\r\npub unsafe fn foo(\r\n    x: &[__m256i; N],\r\n    y: &[__m256i; N],\r\n    z: &[__m256i; N],\r\n    bboxes: &[[__m256i; 6]],\r\n) -> [__m256i; N] {\r\n    let mut res = [_mm256_setzero_si256(); N];\r\n    for bbox in bboxes {\r\n        for i in 0..N {\r\n            let tx = _mm256_and_si256(\r\n                _mm256_cmpgt_epi32(x[i], bbox[0]),\r\n                _mm256_cmpgt_epi32(bbox[1], x[i]),\r\n            );\r\n            let ty = _mm256_and_si256(\r\n                _mm256_cmpgt_epi32(y[i], bbox[2]),\r\n                _mm256_cmpgt_epi32(bbox[3], y[i]),\r\n            );\r\n            let t = _mm256_and_si256(tx, ty);\r\n            let tz = _mm256_and_si256(\r\n                _mm256_cmpgt_epi32(z[i], bbox[4]),\r\n                _mm256_cmpgt_epi32(bbox[5], z[i]),\r\n            );\r\n            let t = _mm256_and_si256(t, tz);\r\n            res[i] = _mm256_or_si256(res[i], t);\r\n        }\r\n    }\r\n    res\r\n}\r\n```\r\nBy inspecting the [generated assembly](https://rust.godbolt.org/z/6fahjYKGP) we can see that for some reason it caches coordinates to stack and reads them from it each iteration instead of using the input pointers. The same behavior can be [observed](https://rust.godbolt.org/z/c5hGxsrvP) for a function which processes coordinate slices.  This caching looks quite redundant to me, especially considering that `noalias` is enabled (i.e. compiler should know that memory at which coordinates are stored can not change during function execution).\r\n\r\nIt looks like LLVM correctly moves coordinate loads from the inner loop using its infinite virtual registers. And it's exactly the behavior we want when there is enough physical registers. But when it's not true, it spills virtual register values to stack instead of relying on the original locations.\r\n\r\nOn Rust 1.51 code from the first link does not have this issue, but not from the second one.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/88930/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/88930/timeline", "performed_via_github_app": null, "state_reason": null}