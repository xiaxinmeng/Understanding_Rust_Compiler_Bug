{"url": "https://api.github.com/repos/rust-lang/rust/issues/83886", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/83886/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/83886/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/83886/events", "html_url": "https://github.com/rust-lang/rust/issues/83886", "id": 850341636, "node_id": "MDU6SXNzdWU4NTAzNDE2MzY=", "number": 83886, "title": "Array-bounds-less Idx wrapper struct?", "user": {"login": "leonardo-m", "id": 22328461, "node_id": "MDQ6VXNlcjIyMzI4NDYx", "avatar_url": "https://avatars.githubusercontent.com/u/22328461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/leonardo-m", "html_url": "https://github.com/leonardo-m", "followers_url": "https://api.github.com/users/leonardo-m/followers", "following_url": "https://api.github.com/users/leonardo-m/following{/other_user}", "gists_url": "https://api.github.com/users/leonardo-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/leonardo-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/leonardo-m/subscriptions", "organizations_url": "https://api.github.com/users/leonardo-m/orgs", "repos_url": "https://api.github.com/users/leonardo-m/repos", "events_url": "https://api.github.com/users/leonardo-m/events{/privacy}", "received_events_url": "https://api.github.com/users/leonardo-m/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2021-04-05T12:44:00Z", "updated_at": "2021-04-05T14:40:58Z", "closed_at": "2021-04-05T14:40:58Z", "author_association": "NONE", "active_lock_reason": null, "body": "This is the current version of my Idx wrapper. Surely this code can be further improved. Its purpose is similar to crates like https://crates.io/crates/index-ext , but its usage is cleaner. It just encodes that an index is in-bounds for an array. Each index gets tested when it is created. Then it's usable without bound tests for any array of the same length or longer. This is useful because LLVM is sometimes able to remove those tests at creation time, or it has to perform a test only once (and later the index is usable many times), or even much less than average once, as in the ArraySpan trait below, where you only need to test the two endpoints of a range, and then it creates many Idx without tests at all. This is especially handy when you have a data structure that needs to store array indexes. Later they can be used lots of times without any array bound tests. I have had real performance increase using this Idx (an example with the index-ext crate that can be translated to use Idx: https://github.com/HeroicKatora/index-ext/tree/master/examples ).\r\n\r\nA much better (and much more useful) alternative solution is to bite the bullet and add to Rust built-in ranged integers (as in Ada language). If they are well implemented and well integrated with the rest of the language (as they should be), then they can be used as bound-test-free on arrays too, as Idx.\r\n\r\n```rust\r\n#![feature(\r\n    const_evaluatable_checked,\r\n    const_fn,\r\n    const_generics,\r\n    const_panic,\r\n    const_trait_impl,\r\n    core_intrinsics,\r\n    step_trait,\r\n    step_trait_ext,\r\n)]\r\n#![allow(incomplete_features)]\r\n\r\nuse std::{\r\n    intrinsics::assume;\r\n    mem::size_of,\r\n    ops::{Index, IndexMut, RangeInclusive},\r\n};\r\n\r\n//---------------------\r\n\r\nmacro_rules! const_assert {\r\n    ($x:expr $(,)?) => {\r\n        const _: [(); 0 - !{ const ASSERT: bool = $x; ASSERT } as usize] = [];\r\n    };\r\n}\r\n\r\n//---------------------\r\n\r\npub trait ToFromUsize {\r\n    fn to_usize(self) -> usize;\r\n    fn from_usize(x: usize) -> Self;\r\n    const MAX: Self;\r\n}\r\nimpl const ToFromUsize for usize {\r\n    fn to_usize(self) -> usize { self }\r\n    fn from_usize(x: usize) -> Self { x }\r\n    const MAX: Self = Self::MAX;\r\n}\r\nimpl const ToFromUsize for u32 {\r\n    fn to_usize(self) -> usize {\r\n        const_assert!(size_of::<usize>() <= 8);\r\n        debug_assert!(self as u64 <= usize::MAX as u64);\r\n        self as usize\r\n    }\r\n    fn from_usize(x: usize) -> Self {\r\n        const_assert!(size_of::<usize>() <= 8);\r\n        debug_assert!(x as u64 <= Self::MAX as u64);\r\n        x as Self\r\n    }\r\n    const MAX: Self = Self::MAX;\r\n}\r\n\r\n//---------------------\r\n\r\npub const fn assert_nonzero(n: usize) -> usize {\r\n    assert!(n > 0);\r\n    n\r\n}\r\n\r\npub const fn is_contained(n: usize, m: usize) -> usize {\r\n    assert!(n <= m);\r\n    n\r\n}\r\n\r\npub const fn is_representable<Ti: ToFromUsize + Copy>(n: usize) -> usize {\r\n    assert!(n <= Ti::MAX.to_usize());\r\n    n\r\n}\r\n\r\nmod idx {\r\n    use std::iter::Step;\r\n    use super::{assert_nonzero, assume, ToFromUsize, is_representable};\r\n\r\n    #[derive(Debug, Copy, Clone, PartialOrd, PartialEq, Default)]\r\n    #[repr(transparent)]\r\n    pub struct Idx<Ti: ToFromUsize + Copy, const N: usize>(Ti)\r\n    where [(); assert_nonzero(N)]:,\r\n          [(); is_representable::<Ti>(N)]:;\r\n\r\n    // TODO Idx::new can't be const, see Issue #79898.\r\n    #[inline(always)]\r\n    pub(crate) const fn idx_new<Ti: ToFromUsize + Copy, const N: usize>(i: Ti) -> Option<Idx<Ti, N>>\r\n    where [(); assert_nonzero(N)]:,\r\n          [(); is_representable::<Ti>(N)]: {\r\n        if i.to_usize() < N { // Issue #79898\r\n            Some(Idx(i))\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    impl<Ti: ToFromUsize + Copy, const N: usize> Idx<Ti, N>\r\n    where [(); assert_nonzero(N)]:,\r\n          [(); is_representable::<Ti>(N)]: {\r\n        #[inline(always)]\r\n        pub /*const*/ fn new(i: Ti) -> Option<Idx<Ti, N>> { // Issue #79898.\r\n            if i.to_usize() < N {\r\n                Some(Idx(i))\r\n            } else {\r\n                None\r\n            }\r\n        }\r\n\r\n        #[inline(always)]\r\n        pub fn from_usize(i: usize) -> Option<Idx<Ti, N>> {\r\n            if i < N {\r\n                Some(Idx(Ti::from_usize(i)))\r\n            } else {\r\n                None\r\n            }\r\n        }\r\n\r\n        #[inline(always)]\r\n        pub const unsafe fn new_unchecked(i: Ti) -> Idx<Ti, N> {\r\n            Idx(i)\r\n        }\r\n\r\n        #[inline(always)]\r\n        pub fn get(&self) -> Ti {\r\n            unsafe { assume(self.0.to_usize() < N); } // Issue #79898\r\n            self.0\r\n        }\r\n    }\r\n\r\n    unsafe impl<Ti: ToFromUsize + Copy, const N: usize> Step for Idx<Ti, N>\r\n    where [(); assert_nonzero(N)]: ,\r\n          [(); is_representable::<Ti>(N)]: ,\r\n          Ti: PartialOrd + Clone {\r\n        fn steps_between(start: &Self, end: &Self) -> Option<usize> {\r\n            Some(end.0.to_usize() - start.0.to_usize())\r\n        }\r\n\r\n        fn forward_checked(start: Self, count: usize) -> Option<Self> {\r\n            Self::new(Ti::from_usize(start.0.to_usize() + count))\r\n        }\r\n\r\n        fn backward_checked(start: Self, count: usize) -> Option<Self> {\r\n            Some(Self(Ti::from_usize(start.0.to_usize().checked_sub(count)?)))\r\n        }\r\n    }\r\n}\r\n\r\nuse idx::{Idx, idx_new};\r\n\r\nimpl<Ti: ToFromUsize + Copy, T, const N: usize, const M: usize> Index<Idx<Ti, N>> for [T; M]\r\nwhere [(); assert_nonzero(N)]: ,\r\n      [(); is_contained(N, M)]:,\r\n      [(); is_representable::<Ti>(N)]: {\r\n    type Output = T;\r\n\r\n    #[inline(always)]\r\n    fn index(&self, i: Idx<Ti, N>) -> &Self::Output {\r\n        unsafe { self.get_unchecked(i.get().to_usize()) }\r\n    }\r\n}\r\n\r\nimpl<Ti: ToFromUsize + Copy, T, const N: usize, const M: usize> IndexMut<Idx<Ti, N>> for [T; M]\r\nwhere [(); assert_nonzero(N)]: ,\r\n      [(); is_contained(N, M)]:,\r\n      [(); is_representable::<Ti>(N)]: {\r\n    #[inline(always)]\r\n    fn index_mut(&mut self, i: Idx<Ti, N>) -> &mut Self::Output {\r\n        unsafe { self.get_unchecked_mut(i.get().to_usize()) }\r\n    }\r\n}\r\n\r\n// This is only usize to make type inference simpler at usage point.\r\ntrait ArraySpan<const N: usize>\r\nwhere [(); assert_nonzero(N)]: ,\r\n      [(); is_representable::<usize>(N)]: {\r\n    fn span(&self) -> RangeInclusive<Idx<usize, N>>;\r\n}\r\n\r\nimpl<T, const N: usize> const ArraySpan<N> for [T; N]\r\nwhere [(); assert_nonzero(N)]:,\r\n      [(); is_representable::<usize>(N)]: {\r\n    #[inline(always)]\r\n    fn span(&self) -> RangeInclusive<Idx<usize, N>> {\r\n        unsafe {\r\n            Idx::new_unchecked(0) ..= Idx::new_unchecked(N - 1)\r\n        }\r\n    }\r\n}\r\n\r\n//---------------------\r\n\r\nfn main() {}\r\n```\r\n", "closed_by": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/83886/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/83886/timeline", "performed_via_github_app": null, "state_reason": "completed"}