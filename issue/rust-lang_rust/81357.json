{"url": "https://api.github.com/repos/rust-lang/rust/issues/81357", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/81357/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/81357/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/81357/events", "html_url": "https://github.com/rust-lang/rust/issues/81357", "id": 792908131, "node_id": "MDU6SXNzdWU3OTI5MDgxMzE=", "number": 81357, "title": "File implementation on Windows has unsound methods", "user": {"login": "jstarks", "id": 9548354, "node_id": "MDQ6VXNlcjk1NDgzNTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/9548354?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jstarks", "html_url": "https://github.com/jstarks", "followers_url": "https://api.github.com/users/jstarks/followers", "following_url": "https://api.github.com/users/jstarks/following{/other_user}", "gists_url": "https://api.github.com/users/jstarks/gists{/gist_id}", "starred_url": "https://api.github.com/users/jstarks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jstarks/subscriptions", "organizations_url": "https://api.github.com/users/jstarks/orgs", "repos_url": "https://api.github.com/users/jstarks/repos", "events_url": "https://api.github.com/users/jstarks/events{/privacy}", "received_events_url": "https://api.github.com/users/jstarks/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 123109, "node_id": "MDU6TGFiZWwxMjMxMDk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/O-windows", "name": "O-windows", "color": "6e6ec0", "default": false, "description": "Operating system: Windows"}, {"id": 203429200, "node_id": "MDU6TGFiZWwyMDM0MjkyMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/P-high", "name": "P-high", "color": "eb6420", "default": false, "description": "High priority"}, {"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 267612997, "node_id": "MDU6TGFiZWwyNjc2MTI5OTc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-unsound", "name": "I-unsound", "color": "e11d21", "default": false, "description": "Issue: A soundness hole (worst kind of bug), see: https://en.wikipedia.org/wiki/Soundness"}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}, {"id": 2011781731, "node_id": "MDU6TGFiZWwyMDExNzgxNzMx", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs", "name": "T-libs", "color": "bfd4f2", "default": false, "description": "Relevant to the library team, which will review and decide on the PR/issue."}, {"id": 2238437210, "node_id": "MDU6TGFiZWwyMjM4NDM3MjEw", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-io", "name": "A-io", "color": "f7e101", "default": false, "description": "Area: std::io, std::fs, std::net and std::path"}], "state": "closed", "locked": false, "assignee": {"login": "rustbot", "id": 47979223, "node_id": "MDQ6VXNlcjQ3OTc5MjIz", "avatar_url": "https://avatars.githubusercontent.com/u/47979223?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rustbot", "html_url": "https://github.com/rustbot", "followers_url": "https://api.github.com/users/rustbot/followers", "following_url": "https://api.github.com/users/rustbot/following{/other_user}", "gists_url": "https://api.github.com/users/rustbot/gists{/gist_id}", "starred_url": "https://api.github.com/users/rustbot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rustbot/subscriptions", "organizations_url": "https://api.github.com/users/rustbot/orgs", "repos_url": "https://api.github.com/users/rustbot/repos", "events_url": "https://api.github.com/users/rustbot/events{/privacy}", "received_events_url": "https://api.github.com/users/rustbot/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "rustbot", "id": 47979223, "node_id": "MDQ6VXNlcjQ3OTc5MjIz", "avatar_url": "https://avatars.githubusercontent.com/u/47979223?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rustbot", "html_url": "https://github.com/rustbot", "followers_url": "https://api.github.com/users/rustbot/followers", "following_url": "https://api.github.com/users/rustbot/following{/other_user}", "gists_url": "https://api.github.com/users/rustbot/gists{/gist_id}", "starred_url": "https://api.github.com/users/rustbot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rustbot/subscriptions", "organizations_url": "https://api.github.com/users/rustbot/orgs", "repos_url": "https://api.github.com/users/rustbot/repos", "events_url": "https://api.github.com/users/rustbot/events{/privacy}", "received_events_url": "https://api.github.com/users/rustbot/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 8, "created_at": "2021-01-24T21:41:48Z", "updated_at": "2022-04-06T03:45:35Z", "closed_at": "2022-04-06T03:45:35Z", "author_association": "NONE", "active_lock_reason": null, "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\n\r\n`File`'s `read`, `write`, `seek_read`, and `seek_write` all have soundness issues in Windows under some conditions. In the below, I describe the problem and possible fixes for `seek_read` and `read`; the same problems and solutions apply to `seek_write` and `write`.\r\n\r\n## seek_read\r\n\r\nUsing `std::os::windows::fs::OpenOptionsExt::custom_flags`, we can open a `File` with `FILE_FLAG_OVERLAPPED`, which is a Win32 flag that indicates that IO should be performed asynchronously using `OVERLAPPED` structures to track the state of outstanding IO.\r\n\r\nWe can then use `std::os::windows::fs::FileExt::seek_read` to initiate an IO. Internally, this uses `ReadFile` and specifies an OVERLAPPED structure on the stack in order to specify the offset to read from. If the IO does not completely synchronously in the kernel, this call will return the error `ERROR_IO_PENDING`, indicating that the buffer and the `OVERLAPPED` structure are still referenced by the kernel. The kernel can write to these buffers at any time, but `seek_read` has already returned so the lifetime of both objects has expired.\r\n\r\nThis example shows how \r\n\r\n```rust\r\n#[test]\r\nfn unsound() {\r\n    use std::os::windows::prelude::*;\r\n    const FILE_FLAG_OVERLAPPED: u32 = 0x40000000;\r\n    const ERROR_IO_PENDING: i32 = 997;\r\n\r\n    let f = std::fs::OpenOptions::new()\r\n        .custom_flags(FILE_FLAG_OVERLAPPED)\r\n        .read(true)\r\n        .open(\"con\") // Open the console to guarantee the IO will pend.\r\n        .unwrap();\r\n\r\n    let mut buf = [0; 1];\r\n    // If this assertion fails, then the IO is still in flight has references to\r\n    // `buf` and to an already-gone `OVERLAPPED` value that was on the stack.\r\n    assert_ne!(\r\n        f.seek_read(&mut buf, 0)\r\n            .unwrap_err()\r\n            .raw_os_error()\r\n            .unwrap(),\r\n        ERROR_IO_PENDING\r\n    )\r\n}\r\n```\r\n\r\n## read\r\n\r\nThis can also be achieved with `read`, too, but it is harder to set up. `read` uses `ReadFile` without passing an `OVERLAPPED` structure, so `ReadFile` allocates one on the stack and handles `ERROR_IO_PENDING` internally by waiting on the file object for an IO to complete. However, `ReadFile` can still return with the IO in flight if there are multiple reads outstanding concurrently, since the IO completion notification will not necessarily wake up the right caller. Worse, this condition is not detectable--`ReadFile` returns a successful completion in this case (though with zero bytes written).\r\n\r\nTo demonstrate this, we need some unsafe code to create a named pipe server so that we can control IO completion timing. But this could be in a separate process or via an otherwise safe named pipe wrapper, so this does not mitigate the soundness issue in `read` itself. If you ignore this aspect, the result is more dramatic since we can demonstrate the unsound behavior in the form of a buffer magically changing contents across a sleep:\r\n\r\n```rust\r\n#[test]\r\nfn unsound_2() {\r\n    use std::io::{Read, Write};\r\n    use std::os::windows::prelude::*;\r\n    use std::sync::Arc;\r\n    use std::thread::sleep;\r\n    use std::time::Duration;\r\n\r\n    const FILE_FLAG_OVERLAPPED: u32 = 0x40000000;\r\n\r\n    fn create_pipe_server(path: &str) -> std::fs::File {\r\n        let mut path0 = path.as_bytes().to_owned();\r\n        path0.push(0);\r\n        extern \"system\" {\r\n            fn CreateNamedPipeA(\r\n                lpName: *const u8,\r\n                dwOpenMode: u32,\r\n                dwPipeMode: u32,\r\n                nMaxInstances: u32,\r\n                nOutBufferSize: u32,\r\n                nInBufferSize: u32,\r\n                nDefaultTimeOut: u32,\r\n                lpSecurityAttributes: *mut u8,\r\n            ) -> RawHandle;\r\n        }\r\n\r\n        unsafe {\r\n            let h = CreateNamedPipeA(\r\n                \"\\\\\\\\.\\\\pipe\\\\repro\\0\".as_ptr(),\r\n                3,\r\n                0,\r\n                1,\r\n                0,\r\n                0,\r\n                0,\r\n                std::ptr::null_mut(),\r\n            );\r\n            assert_ne!(h as isize, -1);\r\n            std::fs::File::from_raw_handle(h)\r\n        }\r\n    }\r\n\r\n    let path = \"\\\\\\\\.\\\\pipe\\\\repro\";\r\n    let mut server = create_pipe_server(path);\r\n\r\n    let client = Arc::new(\r\n        std::fs::OpenOptions::new()\r\n            .custom_flags(FILE_FLAG_OVERLAPPED)\r\n            .read(true)\r\n            .open(path)\r\n            .unwrap(),\r\n    );\r\n\r\n    let spawn_read = |is_first: bool| {\r\n        std::thread::spawn({\r\n            let f = client.clone();\r\n            move || {\r\n                let mut buf = [0xcc; 1];\r\n                let mut f = f.as_ref();\r\n                f.read(&mut buf).unwrap();\r\n                if is_first {\r\n                    assert_ne!(buf[0], 0xcc);\r\n                } else {\r\n                    let b = buf[0]; // capture buf[0]\r\n                    sleep(Duration::from_millis(200));\r\n                    assert_eq!(buf[0], b, \"whoa-oaaa, buf changed after sleeping!\");\r\n                }\r\n            }\r\n        })\r\n    };\r\n\r\n    let t1 = spawn_read(true);\r\n    sleep(Duration::from_millis(20));\r\n    let t2 = spawn_read(false);\r\n    sleep(Duration::from_millis(100));\r\n    server.write(b\"x\").unwrap();\r\n    sleep(Duration::from_millis(100));\r\n    server.write(b\"y\").unwrap();\r\n    t1.join().unwrap();\r\n    t2.join().unwrap();\r\n}\r\n```\r\n\r\n# Possible fixes\r\n\r\n## seek_read\r\n\r\nThere are multiple ways to fix `seek_read`. The options I can think of: if `ReadFile` fails with `ERROR_IO_PENDING`:\r\n1. Call `GetOverlappedResult()` in a loop until it succeeds or fails with something other than `ERROR_IO_INCOMPLETE`, or;\r\n2. Call `GetOverlappedResult()` once. If this fails with `ERROR_IO_INCOMPLETE`, call `abort()`, or;\r\n3. Call `abort()`.\r\n\r\nMy recommendation is to implement option 2. This is what `ReadFile` does if you don't pass an `OVERLAPPED` structure and so is what `read` does today (except ReadFile doesn't abort, it just returns--more about that below). Option 1 sounds appealing but it can easily lead to deadlocks due to some peculiarities about how IO completion signaling works in Windows. Fixing this would rely on Rust allocating a separate Windows event object for each thread issuing IO--I'm not certain this is worth the overhead.\r\n\r\nWe also need to fix `read`. Since it calls `ReadFile` without an `OVERLAPPED` structure, it can hit this same condition but with the kernel-referenced `OVERLAPPED` structure (actually an `IO_STATUS_BLOCK` at this layer of the stack) already popped of the stack. And since `ReadFile` returns success in this case, there's no way to reliably detect this and abort after the fact. You could argue this is a bug in Windows, but it's a bit late to fix it, especially in all the in-market releases. Calling `ReadFile` without an `OVERLAPPED` structure is not really safe unless you carefully control the handle's source.\r\n\r\nTo fix it, it's tempting to switch to allocating the `OVERLAPPED` structure on the stack and passing it to `ReadFile`, as is done in `seek_read`. Unfortunately, this is not possible to do with perfect fidelity. When you pass an `OVERLAPPED` structure, you have to provide an offset, but for `read` we want the _current_ file offset. When a file is opened _without_ `FILE_FLAG_OVERLAPPED`, -2 means to write at the current file offset, so we could pass that. But when the file is opened _with_ `FILE_FLAG_OVERLAPPED`, there is no current file position (in this case `read` only makes sense for streams, such as named pipes, where the offset is meaningless). In this case, -2 is considered an invalid value by the kernel, so we would probably want to pass 0 for most cases. Since we don't know which case we're in, we're stuck.\r\n\r\nBut ReadFile doesn't know what case it's in, either, so how does it solve this problem? Simple: it calls the lower-level system call `NtReadFile`, which allows NULL to be passed for the offset. This has exactly the behavior we want. `read` should be updated to use `NtReadFile` directly.\r\n\r\nAs an alternative to all this, `OpenOptionsExt::custom_flags` could strip or otherwise prohibit the use of `FILE_FLAG_OVERLAPPED`, but I suspect this would be a breaking change. This interface is probably used in various places to open async file handles for other uses (via `into_raw_handle()`). I'm pretty sure I've written such code. And of course using (unsafe) `from_raw_handle` it's still possible to get a `File` whose underlying file object has this flag set, so there's still a trap set for unsuspecting devs.\r\n\r\nSorry this is such a mess. The Windows IO model has some rough edges. We (the Windows OS team) have tried to smooth some of them out over the releases, but doing so while maintaining app compat has proven challenging.\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n`cargo +nightly --version --verbose`:\r\n```\r\ncargo 1.51.0-nightly (a73e5b7d5 2021-01-12)\r\nrelease: 1.51.0\r\ncommit-hash: a73e5b7d567c3036b296fc6b33ed52c5edcd882e\r\ncommit-date: 2021-01-12\r\n```\n\n<!-- TRIAGEBOT_START -->\n\n<!-- TRIAGEBOT_ASSIGN_START -->\nThis issue has been assigned to @sivadeilra via [this comment](https://github.com/rust-lang/rust/issues/81357#issuecomment-773386879).\n<!-- TRIAGEBOT_ASSIGN_DATA_START$${\"user\":\"sivadeilra\"}$$TRIAGEBOT_ASSIGN_DATA_END -->\n\n<!-- TRIAGEBOT_ASSIGN_END -->\n<!-- TRIAGEBOT_END -->", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/81357/reactions", "total_count": 8, "+1": 1, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 4, "rocket": 0, "eyes": 3}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/81357/timeline", "performed_via_github_app": null, "state_reason": "completed"}