{"url": "https://api.github.com/repos/rust-lang/rust/issues/64917", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/64917/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/64917/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/64917/events", "html_url": "https://github.com/rust-lang/rust/issues/64917", "id": 500203017, "node_id": "MDU6SXNzdWU1MDAyMDMwMTc=", "number": 64917, "title": "Two recursive trait strategies. Only one compiles.", "user": {"login": "jerry73204", "id": 7629150, "node_id": "MDQ6VXNlcjc2MjkxNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/7629150?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jerry73204", "html_url": "https://github.com/jerry73204", "followers_url": "https://api.github.com/users/jerry73204/followers", "following_url": "https://api.github.com/users/jerry73204/following{/other_user}", "gists_url": "https://api.github.com/users/jerry73204/gists{/gist_id}", "starred_url": "https://api.github.com/users/jerry73204/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jerry73204/subscriptions", "organizations_url": "https://api.github.com/users/jerry73204/orgs", "repos_url": "https://api.github.com/users/jerry73204/repos", "events_url": "https://api.github.com/users/jerry73204/events{/privacy}", "received_events_url": "https://api.github.com/users/jerry73204/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37544, "node_id": "MDU6TGFiZWwzNzU0NA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-typesystem", "name": "A-typesystem", "color": "f7e101", "default": false, "description": "Area: The type system"}, {"id": 13836860, "node_id": "MDU6TGFiZWwxMzgzNjg2MA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-traits", "name": "A-traits", "color": "f7e101", "default": false, "description": "Area: Trait system"}, {"id": 149689562, "node_id": "MDU6TGFiZWwxNDk2ODk1NjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-associated-items", "name": "A-associated-items", "color": "f7e101", "default": false, "description": "Area: Associated items such as associated types and consts."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2019-09-30T10:59:32Z", "updated_at": "2019-10-17T16:12:34Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "## Overview\r\n\r\nI made an example to define a list in type level, and wrote two ways to recursively insert a new typed key into the list. The complete example is in the gist link.\r\nhttps://gist.github.com/jerry73204/364c4b61d884c1150807cdcc9357890d\r\n\r\nIn brief, the first way is to define a vanilla recursive trait like this. Then, impl cases on _found the key_ termination step and _not the key_ non-terminating step. It compiles and works.\r\n```rust\r\npub trait Insert<NewKey, Target, Cnt>\r\nwhere\r\n    Cnt: Counter,\r\n    Self: TList,\r\n    Self::Output: TList,\r\n{\r\n    type Output;\r\n}\r\n\r\nimpl<...> Insert<NewKey, Target, Current> for Cons<Target, Tail> ... {...}\r\nimpl<...> Insert<NewKey, Target, Next<Index>> for Cons<NonTarget, Tail> ... {...}\r\n```\r\n\r\nThe second strategy is less straightforward. It defines a `Functor` trait such that any types with this trait works as type operator, which output is `<SomeType<Args> as Functor<Input>>::Output`.\r\n\r\nSimilarly, we define termination and non-terminating steps. However, it ends in `overflow evaluating` error.\r\n```rust\r\npub struct InsertFunctor<NewKey, Target, Index>\r\nwhere\r\n    Index: Counter,\r\n{\r\n    _phantom: PhantomData<(NewKey, Target, Index)>,\r\n}\r\nimpl<...> Functor<Cons<Target, Tail>> for InsertFunctor<NewKey, Target, Current> ... {...}\r\nimpl<...> Functor<Cons<NonTarget, Tail>> for InsertFunctor<NewKey, Target, Next<Index>> ... {...}\r\n```\r\n\r\n## Thoughts\r\nIn my naive observation, both ways have identical signatures in impl blocks. I would expect both compile or fail with same error. So I'm wondering what leads to the error, and the logic behind it.\r\n\r\nIf you're asking why functor indirection, I'm working on type level DSTs in a [little project](https://github.com/jerry73204/rust-type-freak), which allows users to wrap their own functor to apply on lists.\r\n\r\nEdit:\r\nSetup:\r\n- rustc: 1.40.0-nightly\r\n- cargo: 1.39.0-nightly \r\n- OS: Arch Linux", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/64917/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/64917/timeline", "performed_via_github_app": null, "state_reason": null}