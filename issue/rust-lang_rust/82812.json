{"url": "https://api.github.com/repos/rust-lang/rust/issues/82812", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/82812/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/82812/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/82812/events", "html_url": "https://github.com/rust-lang/rust/issues/82812", "id": 823371072, "node_id": "MDU6SXNzdWU4MjMzNzEwNzI=", "number": 82812, "title": "Performance degrades if stdlib function uses io::Error::new() with &'static str", "user": {"login": "Frago9876543210", "id": 13465245, "node_id": "MDQ6VXNlcjEzNDY1MjQ1", "avatar_url": "https://avatars.githubusercontent.com/u/13465245?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Frago9876543210", "html_url": "https://github.com/Frago9876543210", "followers_url": "https://api.github.com/users/Frago9876543210/followers", "following_url": "https://api.github.com/users/Frago9876543210/following{/other_user}", "gists_url": "https://api.github.com/users/Frago9876543210/gists{/gist_id}", "starred_url": "https://api.github.com/users/Frago9876543210/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Frago9876543210/subscriptions", "organizations_url": "https://api.github.com/users/Frago9876543210/orgs", "repos_url": "https://api.github.com/users/Frago9876543210/repos", "events_url": "https://api.github.com/users/Frago9876543210/events{/privacy}", "received_events_url": "https://api.github.com/users/Frago9876543210/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2021-03-05T19:55:28Z", "updated_at": "2021-03-27T13:05:21Z", "closed_at": "2021-03-27T13:05:21Z", "author_association": "NONE", "active_lock_reason": null, "body": "I am facing a problem while reading different kinds of binary formats. If you are going to read primitives like `i32` too often, then performance degrades. This is mainly due to the fact that `Error::new(kind, &'static str)` returns box. Also it does boxing **TWICE!**\r\n```rust\r\n//stdlib code\r\nenum Repr {\r\n    Os(i32),\r\n    Simple(ErrorKind),\r\n    Custom(Box<Custom>),\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct Custom {\r\n    kind: ErrorKind,\r\n    error: Box<dyn error::Error + Send + Sync>,\r\n}\r\n```\r\ndoc link: https://doc.rust-lang.org/std/io/struct.Error.html#method.new\r\n\r\nI wrote simple bench to show pref problem.\r\n```bash\r\ncargo new --vcs=none io-perf\r\ncd io-perf\r\nmkdir benches\r\ncat /dev/null > benches/read.rs\r\n# now you have to modify this file e.g. `subl benches/read.rs`\r\n```\r\n\r\nread.rs:\r\n```rust\r\n#![feature(test)]\r\n\r\nextern crate test;\r\n\r\nuse std::hint::black_box;\r\nuse std::io::{ErrorKind, Read, Result};\r\nuse test::Bencher;\r\n\r\npub trait CustomRead {\r\n    fn read_exact_fast(&mut self, buf: &mut [u8]) -> Result<()>;\r\n}\r\n\r\nimpl CustomRead for &[u8] {\r\n    /// Clone of `&[u8]::read_exact` without boxing `&'static str`\r\n    #[inline]\r\n    fn read_exact_fast(&mut self, buf: &mut [u8]) -> Result<()> {\r\n        if buf.len() > self.len() {\r\n            // [!] no message here:\r\n            return Err(ErrorKind::UnexpectedEof.into());\r\n        }\r\n        let (a, b) = self.split_at(buf.len());\r\n\r\n        if buf.len() == 1 {\r\n            buf[0] = a[0];\r\n        } else {\r\n            buf.copy_from_slice(a);\r\n        }\r\n\r\n        *self = b;\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl<R: CustomRead + ?Sized> CustomRead for &mut R {\r\n    #[inline]\r\n    fn read_exact_fast(&mut self, buf: &mut [u8]) -> Result<()> {\r\n        (**self).read_exact_fast(buf)\r\n    }\r\n}\r\n\r\nconst READ_SIZE: usize = 4; //e.g. reading int x1000 times\r\nconst LOOPS: usize = 1000;\r\n\r\n#[bench]\r\nfn bench_read_exact_std_err(b: &mut Bencher) {\r\n    b.iter(|| {\r\n        let mut buf = [0u8; READ_SIZE];\r\n        let mut r: &[u8] = &[]; //always would be error\r\n\r\n        for _ in 0..LOOPS {\r\n            black_box(Read::read_exact(&mut &*r, &mut buf).is_err());\r\n        }\r\n    });\r\n}\r\n\r\n#[bench]\r\nfn bench_read_exact_fast_err(b: &mut Bencher) {\r\n    b.iter(|| {\r\n        let mut buf = [0u8; READ_SIZE];\r\n        let mut r: &[u8] = &[]; //always would be error\r\n\r\n        for _ in 0..LOOPS {\r\n            black_box(CustomRead::read_exact_fast(&mut &*r, &mut buf).is_err());\r\n        }\r\n    });\r\n}\r\n\r\n#[bench]\r\nfn bench_read_exact_std_ok(b: &mut Bencher) {\r\n    b.iter(|| {\r\n        let mut buf = [0u8; READ_SIZE];\r\n        let mut r: &[u8] = &[0u8; READ_SIZE]; //always would be ok\r\n\r\n        for _ in 0..LOOPS {\r\n            black_box(Read::read_exact(&mut &*r, &mut buf).is_ok());\r\n        }\r\n    });\r\n}\r\n\r\n#[bench]\r\nfn bench_read_exact_fast_ok(b: &mut Bencher) {\r\n    b.iter(|| {\r\n        let mut buf = [0u8; READ_SIZE];\r\n        let mut r: &[u8] = &[0u8; READ_SIZE]; //always would be ok\r\n\r\n        for _ in 0..LOOPS {\r\n            black_box(CustomRead::read_exact_fast(&mut &*r, &mut buf).is_ok());\r\n        }\r\n    });\r\n}\r\n```\r\n\r\n### Results\r\nUse `cargo bench` to get it\r\n```\r\nrunning 4 tests\r\ntest bench_read_exact_fast_err ... bench:         255 ns/iter (+/- 239)\r\ntest bench_read_exact_fast_ok  ... bench:         256 ns/iter (+/- 9)\r\ntest bench_read_exact_std_err  ... bench:     164,789 ns/iter (+/- 11,572)\r\ntest bench_read_exact_std_ok   ... bench:         256 ns/iter (+/- 11)\r\n```\r\n\r\nWe can clearly see that performance is degrading. The more calls it takes to read, the worse the results will be.\r\n\r\n### Affected crates and stdlib itself\r\nThe first very popular crate that comes to mind is [byteorder](https://crates.io/crates/byteorder). \r\nhttps://github.com/BurntSushi/byteorder/blob/5d9d0386488d0763954f14a5cb02b1c0afccbdcb/src/io.rs#L84-L89\r\n\r\nIt mainly depends on the data format. But what if you need to receive data over the network? The attacker may abuse wrong data to make ton of pointless memory allocations.\r\n\r\nstdlib is also use `Error::new()` often enough. Let's run a simple bash to make sure of this\r\n```bash\r\ncd ~/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src\r\ngrep -r --include=\"*.rs\" -E \"ErrorKind::\\w+,\" -A 2 -B 2\r\n```\r\n\r\nIn many cases, you will see that it is used `&'static str`. stdlib sometimes create `io::Error` with `format!()` macro, however it doesn't happen very often.\r\n```\r\nrust/library/std/src/sys/unix/os.rs-            if path_len <= 1 {\r\nrust/library/std/src/sys/unix/os.rs-                return Err(io::Error::new(\r\nrust/library/std/src/sys/unix/os.rs:                    io::ErrorKind::Other,\r\nrust/library/std/src/sys/unix/os.rs-                    \"KERN_PROC_PATHNAME sysctl returned zero-length string\",\r\nrust/library/std/src/sys/unix/os.rs-                ));\r\n--\r\nrust/library/std/src/sys/unix/os.rs-        }\r\nrust/library/std/src/sys/unix/os.rs-        Err(io::Error::new(\r\nrust/library/std/src/sys/unix/os.rs:            io::ErrorKind::Other,\r\nrust/library/std/src/sys/unix/os.rs-            \"/proc/curproc/exe doesn't point to regular file.\",\r\nrust/library/std/src/sys/unix/os.rs-        ))\r\n```\r\n\r\n### Possible solutions\r\n- Consider adding a new static method such as `io::ErrorKind::with_message(_: &'static str)` and new internal `Repr` member of that's enum.\r\n- How about using something like `Cow`, but with static lifetime?\r\n\r\n### Meta\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.52.0-nightly (94736c434 2021-02-27)\r\nbinary: rustc\r\ncommit-hash: 94736c434ee154b30e2ec22ec112b79e3f6c5884\r\ncommit-date: 2021-02-27\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.52.0-nightly\r\nLLVM version: 11.0.1\r\n```\r\n\r\nUpdate 07.03.2021: Benchmarks have been improved as per the comment. This should show the problem better.\r\n", "closed_by": {"login": "Frago9876543210", "id": 13465245, "node_id": "MDQ6VXNlcjEzNDY1MjQ1", "avatar_url": "https://avatars.githubusercontent.com/u/13465245?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Frago9876543210", "html_url": "https://github.com/Frago9876543210", "followers_url": "https://api.github.com/users/Frago9876543210/followers", "following_url": "https://api.github.com/users/Frago9876543210/following{/other_user}", "gists_url": "https://api.github.com/users/Frago9876543210/gists{/gist_id}", "starred_url": "https://api.github.com/users/Frago9876543210/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Frago9876543210/subscriptions", "organizations_url": "https://api.github.com/users/Frago9876543210/orgs", "repos_url": "https://api.github.com/users/Frago9876543210/repos", "events_url": "https://api.github.com/users/Frago9876543210/events{/privacy}", "received_events_url": "https://api.github.com/users/Frago9876543210/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/82812/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/82812/timeline", "performed_via_github_app": null, "state_reason": "completed"}