{"url": "https://api.github.com/repos/rust-lang/rust/issues/89281", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/89281/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/89281/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/89281/events", "html_url": "https://github.com/rust-lang/rust/issues/89281", "id": 1007471815, "node_id": "I_kwDOAAsO6M48DMzH", "number": 89281, "title": "Optimize codegen scheduling", "user": {"login": "Sl1mb0", "id": 56142018, "node_id": "MDQ6VXNlcjU2MTQyMDE4", "avatar_url": "https://avatars.githubusercontent.com/u/56142018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sl1mb0", "html_url": "https://github.com/Sl1mb0", "followers_url": "https://api.github.com/users/Sl1mb0/followers", "following_url": "https://api.github.com/users/Sl1mb0/following{/other_user}", "gists_url": "https://api.github.com/users/Sl1mb0/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sl1mb0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sl1mb0/subscriptions", "organizations_url": "https://api.github.com/users/Sl1mb0/orgs", "repos_url": "https://api.github.com/users/Sl1mb0/repos", "events_url": "https://api.github.com/users/Sl1mb0/events{/privacy}", "received_events_url": "https://api.github.com/users/Sl1mb0/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234956, "node_id": "MDU6TGFiZWwyMzQ5NTY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-codegen", "name": "A-codegen", "color": "f7e101", "default": false, "description": "Area: Code generation"}, {"id": 650846969, "node_id": "MDU6TGFiZWw2NTA4NDY5Njk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-tracking-issue", "name": "C-tracking-issue", "color": "f5f1fd", "default": false, "description": "Category: A tracking issue for an RFC or an unstable feature."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2021-09-26T18:52:17Z", "updated_at": "2023-03-30T21:24:43Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Updated tracking issue for [#82685][OriginalIssue]\r\n\r\n## Overview\r\n\r\nThe original issue provides a great introduction to and overview of the problem, as well as a proposed solution to it; but there are relevant issues and detail missing from the issue that I would like to add, and I would like to bring it up to date and \r\norganize it so the issue can be addressed more cohesively to form a long-term solution.\r\n\r\nI'd like to thank @tgnottingham for all the posts and work he did on this, as they gave me a lot of insight into the overall issue and it's resolution. I'd also like to mention @wesleywiser for providing an apt [comparison][WesleyWiserQuote] \r\nto the [multiway partitioning problem][MultiWayPart]. The general solution lies in minimizing the \"make span\" of the problem (CGU compilation finish time), which can be achieved by minimizing the largest \"sum\" (CGU).\r\n\r\nHowever, before we can attempt to minimize the largest CGU we must address all of the issues that are currently plagueing CGU size in general. Monomorphization partitioning is the obvious candidate for consideration; and it's possible the issues regarding [inlining][InlineImplementation] and [drops][DropsInLLVM-IR] take place there. These issues may also be [related][DropsAlwaysInlined]. I am assuming that a lot of programs [use match statements to initialize struct fields][LLVMBloatStructInit]; so the code bloat there is something that should be looked into as well.\r\n\r\nMore importantly, there is the fact that while CGU scheduling is correctly organized by size, the metric used to gauge CGU size [is supposedly not correct][CGUSizeMetric]; which suggests that the first order of business is making it so. I plan on tackling this first, so any advice that can be offered in regards to that would be appreciated. Immensely.\r\n\r\n## Thoughts\r\n\r\nWhile it is possible that small improvements can be made over time to yield performance wins, these tweaks may not be be cohesive or consider other necessary parts of the compiler, which is why to address this effectively we need to organize all relevant information into one place, and create a roadmap that resolves these issues and gets us to the high-level general solution of simply minimizing the largest CGU. In general, we need collaboration.\r\n\r\n\r\n## Metrics\r\n\r\nWe need a way to track the metrics we are looking to optimize. In general, we need to track different size and time\r\nmetrics for individual CGU's from when they are initially partitioned, to when they are ready to be linked. We also need metrics for codegen in general, so we can see how size/time for individual CGU's affects codegen overall. Right now the\r\nonly metric I have thought of for tracking this is total time from partitioning to linking. We also need to be able to determine if a CGU is large because it started out large, or if it is large because it has been merged with other CGU's.\r\n\r\nMetric Types:\r\n  - CGU: metrics for individual CGU's\r\n  - CG: metrics for codegen in general\r\n\r\n| Type | Metric | Description | \r\n|------|-------| -------------|\r\n|  CGU |  size   |   Total LLVM instructions            |\r\n| CGU | compilation time |  Total time to translate LLVM-IR to a compiled CGU |\r\n| CGU | optimization time|  Total time to completely optimize a CGU |\r\n| CGU | total time | compilation time + optimization time |\r\n| CG | total time | Total time from partitioning to linking (when all compiled CGU's are ready to be linked, not when linking has finished) |\r\n\r\n## Road to Optimization\r\n\r\nThis is not permanent; I am hoping others offer suggestions and improvements.\r\n\r\n- [ ] Add per-CGU metrics to perf.r-l.o\r\n    - Map CGU's to a CGU ID\r\n    - Correct size metric; track CGU size\r\n    - Add support for determining if CGU's are large because they were\r\n       merged or if they began that way\r\n    - Should the metric simply be the number of LLVM instructions in a CGU?\r\n- [ ] Address inlining implementation\r\n    - Going to need a lot of help here\r\n- [ ] Address Drops always being inlined\r\n    - And here\r\n- [ ] Address LLVM bloat when using match struct-field initialization\r\n    - And here\r\n- [ ] Implement algorithm to identify largest CGU and minimize it\r\n    - Should the amount of CGU's minimized be determined by the amount of cores?\r\n\r\n# References\r\n\r\n[Original Issue][OriginalIssue]\r\n[CGU Size Metric][CGUSizeMetric]\r\n[CGU Organization][CGUOrganization]\r\n[CGU Compile Time][CGUCompileTime]\r\n[LLVM Bloat Match Statement][LLVMBloatStructInit]\r\n[Inline Implementation][InlineImplementation]\r\n[Drops Always Inlined][DropsAlwaysInlined]\r\n[Drops In LLVM IR][DropsInLLVM-IR]\r\n[Suboptimal Codegen Parallelism][SuboptimalCodegenParallelism]\r\n[Wesley Wiser Comparison][WesleyWiserQuote]\r\n[Multiway Partitioning][MultiWayPart]\r\n\r\n[OriginalIssue]:https://github.com/rust-lang/rust/issues/82685\r\n[CGUSizeMetric]:https://github.com/rust-lang/rust/issues/69382\r\n[CGUOrganization]:https://github.com/rust-lang/rust/pull/81736\r\n[CGUCompileTime]:https://github.com/rust-lang/rust/pull/81538\r\n[LLVMBloatStructInit]:https://github.com/rust-lang/rust/issues/68822\r\n[InlineImplementation]:https://github.com/rust-lang/rust/issues/14527\r\n[DropsAlwaysInlined]:https://github.com/rust-lang/rust/issues/64140\r\n[DropsInLLVM-IR]:https://github.com/rust-lang/rust/issues/38827\r\n[SuboptimalCodegenParallelism]:https://github.com/rust-lang/rust/issues/64913\r\n[WesleyWiserQuote]:https://github.com/rust-lang/rust/issues/82685#issuecomment-788964038\r\n[MultiWayPart]:https://en.wikipedia.org/wiki/Multiway_number_partitioning", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/89281/reactions", "total_count": 4, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 4, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/89281/timeline", "performed_via_github_app": null, "state_reason": null}