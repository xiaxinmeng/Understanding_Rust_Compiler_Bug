{"url": "https://api.github.com/repos/rust-lang/rust/issues/13623", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/13623/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/13623/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/13623/events", "html_url": "https://github.com/rust-lang/rust/issues/13623", "id": 31842517, "node_id": "MDU6SXNzdWUzMTg0MjUxNw==", "number": 13623, "title": "Bad performing code from `#[deriving(Eq)]` for enums", "user": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234956, "node_id": "MDU6TGFiZWwyMzQ5NTY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-codegen", "name": "A-codegen", "color": "f7e101", "default": false, "description": "Area: Code generation"}, {"id": 64037154, "node_id": "MDU6TGFiZWw2NDAzNzE1NA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-compiletime", "name": "I-compiletime", "color": "e11d21", "default": false, "description": "Problems and improvements with respect to compile times."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 9, "created_at": "2014-04-19T10:12:20Z", "updated_at": "2017-03-09T17:36:30Z", "closed_at": "2017-03-09T17:36:30Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "`#[deriving(Eq)]` generates nested matches for enums, like this:\n\n``` rust\n#[deriving(Eq)]\npub enum Foo { A1, A2, A3, }\n#[automatically_derived]\nimpl ::std::cmp::Eq for Foo {\n    #[inline]\n    fn eq(&self, __arg_0: &Foo) -> ::bool {\n        match *self {\n            A1 => match *__arg_0 { A1 => true, _ => false },\n            A2 => match *__arg_0 { A2 => true, _ => false },\n            A3 => match *__arg_0 { A3 => true, _ => false }\n        }\n    }\n    #[inline]\n    fn ne(&self, __arg_0: &Foo) -> ::bool {\n        match *self {\n            A1 => match *__arg_0 { A1 => false, _ => true },\n            A2 => match *__arg_0 { A2 => false, _ => true },\n            A3 => match *__arg_0 { A3 => false, _ => true }\n        }\n    }\n}\n```\n\nAlthough we emit range constraints for the loads, this doesn't get optimized to\na simple comparison but this:\n\n``` llvm\ndefine i8 @_ZN18Foo...std..cmp..Eq2eq20h9a2945fb10f6320blaa4v0.0E(i8* nocapture readonly, i8* nocapture readonly) unnamed_addr #0 {\nentry-block:\n  %2 = load i8* %0, align 1, !range !0\n  switch i8 %2, label %match_else [\n    i8 0, label %match_case\n    i8 1, label %match_case3\n  ]\n\nmatch_else:                                       ; preds = %entry-block\n  %3 = load i8* %1, align 1, !range !0\n  %cond20 = icmp eq i8 %3, 2\n  %. = zext i1 %cond20 to i8\n  br label %join18\n\nmatch_case:                                       ; preds = %entry-block\n  %4 = load i8* %1, align 1, !range !0\n  %cond19 = icmp eq i8 %4, 0\n  %.23 = zext i1 %cond19 to i8\n  br label %join18\n\nmatch_case3:                                      ; preds = %entry-block\n  %5 = load i8* %1, align 1, !range !0\n  %cond = icmp eq i8 %5, 1\n  %.24 = zext i1 %cond to i8\n  br label %join18\n\njoin18:                                           ; preds = %match_case3, %match_case, %match_else\n  %__make_return_pointer.0 = phi i8 [ %., %match_else ], [ %.23, %match_case ], [ %.24, %match_case3 ]\n  ret i8 %__make_return_pointer.0\n}\n```\n\nWhich gets a pretty straight-forward translation to assembly:\n\n``` asm\n    .globl  _ZN18Foo...std..cmp..Eq2eq20h9a2945fb10f6320blaa4v0.0E\n    .align  16, 0x90\n    .type   _ZN18Foo...std..cmp..Eq2eq20h9a2945fb10f6320blaa4v0.0E,@function\n_ZN18Foo...std..cmp..Eq2eq20h9a2945fb10f6320blaa4v0.0E:\n    .cfi_startproc\n    cmpq    %fs:112, %rsp\n    ja  .LBB0_2\n    movabsq $0, %r10\n    movabsq $0, %r11\n    callq   __morestack\n    retq\n.LBB0_2:\n    movb    (%rdi), %al\n    testb   %al, %al\n    jne .LBB0_3\n    cmpb    $0, (%rsi)\n    sete    %al\n    retq\n.LBB0_3:\n    movzbl  %al, %eax\n    cmpl    $1, %eax\n    jne .LBB0_4\n    movzbl  (%rsi), %eax\n    cmpl    $1, %eax\n    sete    %al\n    retq\n.LBB0_4:\n    movzbl  (%rsi), %eax\n    cmpl    $2, %eax\n    sete    %al\n    retq\n.Ltmp0:\n    .size   _ZN18Foo...std..cmp..Eq2eq20h9a2945fb10f6320blaa4v0.0E, .Ltmp0-_ZN18Foo...std..cmp..Eq2eq20h9a2945fb10f6320blaa4v0.0E\n    .cfi_endproc\n```\n\nFor C-style enums, we could maybe special case the deriving code generate something like this instead:\n\n``` rust\nfn eq(&self, rhs: &Foo) -> bool {\n    *self as u64 == *rhs as u64\n}\n```\n\nBut since the discriminant isn't exposed in the language (and is only virtual in case of e.g. Option<&int>), I don't see how to solve this for ADTs in general.\n\nExposing the discriminant through an intrinsic and doing an early equality check helps LLVM to generate better code, but it's still not optimal.\n\n``` rust\npub fn test1(a: &Foo, b: &Foo) -> bool {\n    let d1 = unsafe { std::intrinsics::get_disr(a) };\n    let d2 = unsafe { std::intrinsics::get_disr(b) };\n\n    if d1 != d2 {\n        return false;\n    }\n\n    match a {\n        &A1 => match b { &A1 => true, _ => false },\n        &A2 => match b { &A2 => true, _ => false },\n        &A3 => match b { &A3 => true, _ => false },\n    }\n}\n```\n\nGives:\n\n``` llvm\ndefine zeroext i1 @_ZN5test120h51356ea9d1622fa9haa4v0.0E(i8* nocapture readonly, i8* nocapture readonly) unnamed_addr #0 {\nentry-block:\n  %2 = load i8* %0, align 1, !range !0\n  %3 = load i8* %1, align 1, !range !0\n  %4 = icmp eq i8 %2, %3\n  br i1 %4, label %next-block, label %return\n\nnext-block:                                       ; preds = %entry-block\n  %5 = icmp ne i8 %2, 3\n  ret i1 %5\n\nreturn:                                           ; preds = %entry-block\n  ret i1 false\n}\n```\n\nAnd:\n\n``` asm\n    .globl  _ZN5test120h51356ea9d1622fa9haa4v0.0E\n    .align  16, 0x90\n    .type   _ZN5test120h51356ea9d1622fa9haa4v0.0E,@function\n_ZN5test120h51356ea9d1622fa9haa4v0.0E:\n    .cfi_startproc\n    cmpq    %fs:112, %rsp\n    ja  .LBB0_2\n    movabsq $0, %r10\n    movabsq $0, %r11\n    callq   __morestack\n    retq\n.LBB0_2:\n    movzbl  (%rdi), %eax\n    movzbl  (%rsi), %ecx\n    cmpl    %ecx, %eax\n    jne .LBB0_4\n    movzbl  %al, %eax\n    cmpl    $3, %eax\n    setne   %al\n    retq\n.LBB0_4:\n    xorl    %eax, %eax\n    retq\n.Ltmp0:\n    .size   _ZN5test120h51356ea9d1622fa9haa4v0.0E, .Ltmp0-_ZN5test120h51356ea9d1622fa9haa4v0.0E\n    .cfi_endproc\n```\n\nBut I don't think exposing the discriminant is such a great idea, and having to do the extra check is weird and not quite natural. So I wonder if there's a better way to handle this.\n\n---\n\nFun fact: Adding another variant to the enum (so we have `pub enum Foo { A1, A2, A3, A4 }`) makes LLVM generate better code for some reason:\n\n``` llvm\ndefine zeroext i1 @_ZN5test120ha73e87eb2055d3a4iaa4v0.0E(i8* nocapture readonly, i8* nocapture readonly) unnamed_addr #0 {\nentry-block:\n  %2 = load i8* %0, align 1, !range !0\n  %3 = load i8* %1, align 1, !range !0\n  %4 = icmp eq i8 %2, %3\n  br i1 %4, label %select.end, label %select.mid\n\nselect.mid:                                       ; preds = %entry-block\n  br label %select.end\n\nselect.end:                                       ; preds = %entry-block, %select.mid\n  %. = phi i1 [ true, %entry-block ], [ false, %select.mid ]\n  ret i1 %.\n}\n```\n\nAnd adding another round of `opt -O2` (LLVM seems to stop optimizing too early here) gives:\n\n``` llvm\ndefine zeroext i1 @_ZN5test120ha73e87eb2055d3a4iaa4v0.0E(i8* nocapture readonly, i8* nocapture readonly) unnamed_addr #0 {\nentry-block:\n  %2 = load i8* %0, align 1, !range !0\n  %3 = load i8* %1, align 1, !range !0\n  %4 = icmp eq i8 %2, %3\n  ret i1 %4\n}\n```\n\nEDIT: Forgot to mention that the code with the intrinsic is based upon my branch that uses `i1` for bools. Just to avoid any confusion...\n", "closed_by": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/13623/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/13623/timeline", "performed_via_github_app": null, "state_reason": "completed"}