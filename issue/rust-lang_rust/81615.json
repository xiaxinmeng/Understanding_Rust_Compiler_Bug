{"url": "https://api.github.com/repos/rust-lang/rust/issues/81615", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/81615/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/81615/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/81615/events", "html_url": "https://github.com/rust-lang/rust/issues/81615", "id": 797997517, "node_id": "MDU6SXNzdWU3OTc5OTc1MTc=", "number": 81615, "title": "Provide a means of turning iterators into fixed-size arrays", "user": {"login": "bstrie", "id": 865233, "node_id": "MDQ6VXNlcjg2NTIzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstrie", "html_url": "https://github.com/bstrie", "followers_url": "https://api.github.com/users/bstrie/followers", "following_url": "https://api.github.com/users/bstrie/following{/other_user}", "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions", "organizations_url": "https://api.github.com/users/bstrie/orgs", "repos_url": "https://api.github.com/users/bstrie/repos", "events_url": "https://api.github.com/users/bstrie/events{/privacy}", "received_events_url": "https://api.github.com/users/bstrie/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 630652267, "node_id": "MDU6TGFiZWw2MzA2NTIyNjc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-feature-request", "name": "C-feature-request", "color": "f5f1fd", "default": false, "description": "Category: A feature request, i.e: not implemented / a PR."}, {"id": 889209675, "node_id": "MDU6TGFiZWw4ODkyMDk2NzU=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-iterators", "name": "A-iterators", "color": "f7e101", "default": false, "description": "Area: Iterators"}, {"id": 3425147156, "node_id": "LA_kwDOAAsO6M7MJ5kU", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-array", "name": "A-array", "color": "f7e101", "default": false, "description": "Area: [T; N]"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 19, "created_at": "2021-02-01T06:04:20Z", "updated_at": "2023-03-07T05:33:16Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Now that min_const_generics is approaching there is a great deal of new support for working with fixed-sized arrays, such as `std::array::IntoIter`. But while converting from an array to an iterator is now well-supported, the reverse is lacking:\r\n```rust\r\nlet mut a = std::array::IntoIter::new([1,2,3]);\r\nlet b: [i32; 3] = a.collect(); // the trait `FromIterator<{integer}>` is not implemented for `[i32; 3]`\r\n```\r\nIt is roundaboutly possible to do the conversion by going through Vec:\r\n```rust\r\nlet mut a = std::array::IntoIter::new([1,2,3]);\r\nlet b: [i32; 3] = a.collect::<Vec<_>>().try_into().unwrap();\r\n```\r\nBut that isn't no_std compatible, and even with std there should be no need to allocate here.\r\n\r\nThe non-allocating way of converting the array presupposes a fair bit of familiarity with the stdlib, unsafe code, and unstable features:\r\n```rust\r\n#![feature(maybe_uninit_uninit_array)]\r\n#![feature(maybe_uninit_array_assume_init)]\r\nlet mut array: [MaybeUninit<T>; N] = MaybeUninit::uninit_array();\r\n\r\nfor i in 0..N {\r\n    array[i] = MaybeUninit::new(iter.next().unwrap());\r\n}\r\n\r\nlet array = unsafe {\r\n    MaybeUninit::array_assume_init(array)\r\n};\r\n```\r\n...which suggests this is a prime candidate for stdlib inclusion.\r\n\r\nThe first problem is what the signature should be. There's no way to statically guarantee that an iterator is any given length, so (assuming that you don't want to panic) what is the return type when the iterator might be too short?\r\n\r\n1. `-> [T; N]`: straightforward, but you'd have to have `T: Default`, which limits its usefulness. Furthermore this uses in-band signaling to mask what is probably an error (passing in a too-small iterator), which feels user-hostile. This seems little better than panicking.\r\n2. `-> [Option<T>; N]`: the obvious solution to indicate potentially-missing data, but likely annoying to work with in the success case. And sadly [the existing blanket impl](https://doc.rust-lang.org/std/iter/trait.FromIterator.html#impl-FromIterator%3COption%3CA%3E%3E) that ordinarily allows you `.collect` from from a collection of options into an option of a collection can't be leveraged here because you still don't have an impl of `FromIterator<T> for [T; N]`. So if you actually want a `[T; N]` you're left with manually iterating over what was returned, which is to say, you're no better off than having the iterator you started out with!\r\n3. `-> Option<[T; N]>`: the simplest solution that doesn't totally ignore errors. This would be consistent with `std::slice::array_windows` for producing None when a function cannot construct a fixed-size array due to a too-small iterator. However, it unfortunately seems less quite a bit less recoverable in the failure case than the previous approach.\r\n4. `-> Result<[T; N], U>`: same as the previous, though it's possible you could pass something useful back in the error slot. However, as long as the iterator is by-value and unless it's limited to ExactSizeIterators, it might be tricky to pass the data back.\r\n5. `-> ArrayVec<T, N>`: this would be a new type designed to have infallible conversion from `FromIterator`. Actually extracting the fixed-size array would be done through APIs on this type, which avoids some problems in the next section.\r\n\r\nIMO approaches 1 and 2 are non-starters.\r\n\r\nThe second problem is how to perform the conversion.\r\n\r\n1. `FromIterator`: the obvious approach, however, it cannot be used with return type 3 from the prior section. This is because of the aforementioned blanket impl for collecting a collection-of-options into an option-of-collections, which conflicts with any attempt to impl `FromIterator<T> for Option<[T; N]>`. I think even specialization can't solve this?\r\n2. `TryFrom`: theoretically you could forgo an impl of `FromIterator<T>` and instead impl `TryFrom<I: IntoIterator<Item=T>>`; hacky, but at least you're still using *some* standard conversion type. Sadly, https://github.com/rust-lang/rust/issues/50133 makes it impossible to actually write this impl; people claim that specialization could theoretically address that, but I don't know enough about the current implementation to know if it's sufficient for this case.\r\n3. Introduce a new `TryFromIterator` trait. This would work, but this also implies a new `TryIntoIterator` trait and `Iterator::try_collect`. Likely the most principled approach.\r\n4. A new `std::array::TryCollect` trait, impl'd for `I: IntoIterator`. Less principled than the prior approach but less machinery for if you happen to think `TryFromIterator` and `TryIntoIterator` wouldn't be broadly useful.\r\n5. A new `std::array::from_iter` function. The simplest and least general approach. Less consistent with `.collect` than the previous approach, but broadly consistent with `std::array::IntoIter` (although that itself is considered a temporary stopgap until `.into_iter` works on arrays). Similarly, could be an inherent associated function impl'd on `[T; N]`.\r\n6. Come up with some wacky const-generics shenanigans that would allow `FromIterator<T> for [T; N]` to Just Work, possibly via introducing a new const-generics aware version of ExactSizeIterator. If this could be done it would unquestionably be the most promising way to proceed, but I don't have the faintest idea where to begin.\r\n7. A new method `Iterator::collect_array` as a hardcoded alternative to collect. Similarly, an Iterator-specific equivalent of `slice::array_chunks` could fill the same role while also being potentially more flexible.\r\n\r\nAny other suggestions?", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/81615/reactions", "total_count": 61, "+1": 55, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 6, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/81615/timeline", "performed_via_github_app": null, "state_reason": null}