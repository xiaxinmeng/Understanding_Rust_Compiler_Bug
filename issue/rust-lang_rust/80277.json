{"url": "https://api.github.com/repos/rust-lang/rust/issues/80277", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/80277/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/80277/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/80277/events", "html_url": "https://github.com/rust-lang/rust/issues/80277", "id": 772536509, "node_id": "MDU6SXNzdWU3NzI1MzY1MDk=", "number": 80277, "title": "Suboptimal code generation when using read_exact() on &[u8]/Cursor<&[u8]>", "user": {"login": "adrian17", "id": 4729533, "node_id": "MDQ6VXNlcjQ3Mjk1MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4729533?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adrian17", "html_url": "https://github.com/adrian17", "followers_url": "https://api.github.com/users/adrian17/followers", "following_url": "https://api.github.com/users/adrian17/following{/other_user}", "gists_url": "https://api.github.com/users/adrian17/gists{/gist_id}", "starred_url": "https://api.github.com/users/adrian17/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adrian17/subscriptions", "organizations_url": "https://api.github.com/users/adrian17/orgs", "repos_url": "https://api.github.com/users/adrian17/repos", "events_url": "https://api.github.com/users/adrian17/events{/privacy}", "received_events_url": "https://api.github.com/users/adrian17/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 2238437210, "node_id": "MDU6TGFiZWwyMjM4NDM3MjEw", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-io", "name": "A-io", "color": "f7e101", "default": false, "description": "Area: std::io, std::fs, std::net and std::path"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-12-21T23:51:14Z", "updated_at": "2021-07-04T14:28:01Z", "closed_at": "2021-07-04T14:28:01Z", "author_association": "NONE", "active_lock_reason": null, "body": "This basically started with investigating byteorder's `read_u16`-style extensions. They are more or less meant to be used like this:\r\n\r\n```rust\r\nlet mut rdr = Cursor::new(vec![2, 5, 3, 0]);\r\nassert_eq!(517, rdr.read_u16::<BigEndian>().unwrap());\r\nassert_eq!(768, rdr.read_u16::<BigEndian>().unwrap());\r\n```\r\n\r\nYou can see that they are implemented in terms of `Read`'s `read_exact` method:\r\nhttps://github.com/BurntSushi/byteorder/blob/f10179b1c72f80d33f4bedf6ad3cf110ba2dac0a/src/io.rs#L110\r\nAnd similarly in other projects:\r\nhttps://github.com/image-rs/image-png/blob/ccd274fe028e5cb3247eaaf6d30ab83b5bde76e7/src/traits.rs#L7\r\n\r\nHowever, it seems like when used with `Cursor<&[u8]>` or just `&[u8]`, they are way slower than I'd expect them to be.\r\n\r\nWhen I build a test program, I encounter this bug: https://github.com/rust-lang/rust/issues/47321 which is pretty bad, especially as `read_exact` will call to `memcpy` for all sizes > 1 byte. This causes, in particular, noticeable overhead on wasm.\r\n\r\nWhen I build it as a lib (or benchmark), it appears that the functions get inlined, as I can't find any calls to `read_exact`, and there are no calls in inlined code except to `io::Error::new`. However, even when inlined, it appears that code is still suboptimal.\r\nNormally, I'd assume that `cursor.read_16()` does a range_check, then a 2-byte read, cursor increment and that's it. But here it appears that more work is being done, probably redundant slice range checks.\r\n\r\nHere is my base test case:\r\n\r\n```rust\r\n#[inline(never)]\r\npub fn sum_byteorder_cursor_impl(cursor: &mut Cursor<&[u8]>) -> io::Result<u64> {\r\n    let mut ret = 0;\r\n    ret += cursor.read_u8()? as u64;\r\n    ret += cursor.read_u8()? as u64;\r\n    ret += cursor.read_u16::<LittleEndian>()? as u64;\r\n    ret += cursor.read_u32::<LittleEndian>()? as u64;\r\n    Ok(ret)\r\n}\r\n```\r\n\r\nIn my benchmarks, it spends 7.5ns/call.\r\n\r\nBut when I manually extract slice range check out of the function, so that the compiler knows the slices will contain required number of bytes, for example:\r\n\r\n```rust\r\nret += cursor.read_u16::<LittleEndian>()? as u64;\r\n```\r\n\r\n->\r\n\r\n```rust\r\nif cursor.position() as usize + 1 >= cursor.get_ref().len() {\r\n    return Err(io::Error::new(io::ErrorKind::Other, \"failed to fill whole buffer\"));\r\n}\r\nlet mut data = &cursor.get_ref()[cursor.position() as usize..cursor.position() as usize + 2];\r\nret += data.read_u16::<LittleEndian>()? as u64;\r\ncursor.set_position(cursor.position()+2);\r\n```\r\n\r\nThe time improves to 5.3ns/call and AFAIK the behavior is identical (aside from different error kind).\r\n\r\nThis still generated range checks that seemed redundant (I may be wrong here), so after introducing `unsafe`:\r\n\r\n```rust\r\nret += cursor.read_u16::<LittleEndian>()? as u64;\r\n```\r\n\r\n->\r\n\r\n```rust\r\nif cursor.position() as usize + 1 >= cursor.get_ref().len() {\r\n    return Err(io::Error::new(io::ErrorKind::Other, \"failed to fill whole buffer\"));\r\n}\r\nlet mut data = unsafe { cursor.get_ref().get_unchecked(cursor.position() as usize..cursor.position() as usize + 2) };\r\nret += data.read_u16::<LittleEndian>()? as u64;\r\ncursor.set_position(cursor.position()+2);\r\n```\r\n\r\nTime improved even more, to 4.1ns/call. (This is also similar time to one I got in equivalent C++ program with a simple range check on every `read_u*` call)\r\n\r\nSimilar behavior occurs when I use a slice instead of a cursor. If I simply add a range check:\r\n\r\n```rust\r\n// data: &mut &[u8]\r\nret += data.read_u16::<LittleEndian>()? as u64;\r\n```\r\n->\r\n```rust\r\nif data.len() < 2 {\r\n    return Err(io::Error::new(io::ErrorKind::Other, \"failed to fill whole buffer\"));\r\n}\r\nret += data.read_u16::<LittleEndian>()? as u64;\r\n```\r\nThe iteration speed improves by nearly 2x.\r\n\r\n\r\nNow I don't really know how much this has to do with https://github.com/rust-lang/rust/issues/47321 , and how much with other optimizations. It's also a bit awkward that https://github.com/rust-lang/rust/issues/47321 triggers in the production code, so until that bug is fixed, I won't really see benefits from fixing this one anyway.\r\n\r\nI posted my benchmark on https://github.com/adrian17/rust-byteorder-benchmarks .\r\n", "closed_by": {"login": "adrian17", "id": 4729533, "node_id": "MDQ6VXNlcjQ3Mjk1MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4729533?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adrian17", "html_url": "https://github.com/adrian17", "followers_url": "https://api.github.com/users/adrian17/followers", "following_url": "https://api.github.com/users/adrian17/following{/other_user}", "gists_url": "https://api.github.com/users/adrian17/gists{/gist_id}", "starred_url": "https://api.github.com/users/adrian17/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adrian17/subscriptions", "organizations_url": "https://api.github.com/users/adrian17/orgs", "repos_url": "https://api.github.com/users/adrian17/repos", "events_url": "https://api.github.com/users/adrian17/events{/privacy}", "received_events_url": "https://api.github.com/users/adrian17/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/80277/reactions", "total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/80277/timeline", "performed_via_github_app": null, "state_reason": "completed"}