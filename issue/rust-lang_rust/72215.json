{"url": "https://api.github.com/repos/rust-lang/rust/issues/72215", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/72215/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/72215/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/72215/events", "html_url": "https://github.com/rust-lang/rust/issues/72215", "id": 618536779, "node_id": "MDU6SXNzdWU2MTg1MzY3Nzk=", "number": 72215, "title": "Miri interning: what to do with dangling pointers?", "user": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37234, "node_id": "MDU6TGFiZWwzNzIzNA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-cleanup", "name": "C-cleanup", "color": "f5f1fd", "default": false, "description": "Category: PRs that clean code up or issues documenting cleanup."}, {"id": 900795185, "node_id": "MDU6TGFiZWw5MDA3OTUxODU=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-const-eval", "name": "A-const-eval", "color": "f7e101", "default": false, "description": "Area: constant evaluation (mir interpretation)"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2020-05-14T21:08:31Z", "updated_at": "2021-01-03T13:11:51Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "What should the const interner do when encountering a pointer that doesn't point anywhere? Right now it does `throw_ub_format!`, but inside a const that is actually a lint that can be allowed. Also the error is not very informative as it doesn't say *where* in the const the dangling pointer is. With https://github.com/rust-lang/rust/pull/71665 it does `tcx.sess.span_err`, at least guaranteeing to hard error, but still with an unspecific error and actually in case of a dangling reference with a *duplicate* error as validation also complains (with a much better error message).\r\n\r\nIdeally we wouldn't have an error at all. We could either (1) make Miri+codegen not ICE on dangling `AllocId`, or (2) make the `AllocId` not dangling by creating \"fake\" allocations, or (3) adjust the interned allocation to not have a dangling pointer any more. There might be more options.\r\n\r\nIs (1) realistic? I am not sure. It might also not be great to put that burden on the rest of the compiler. (Note though that since we \"just\" show a hard error diagnostic in dangling `AllocId`, all parts of the compiler that still run after this must anyway be prepared to handle them properly.)\r\n\r\n(2) is honestly my personal favorite. The \"fake\" allocations would have the right alignment but size 1, and undefined content, and we could send them off to LLVM like that. However we'd have to make sure validation does not consider these \"fake\" allocations dereferencable (not even for size 0). So in some sense it might be easiest to create them only during codegen when getting `None` for a given `AllocId`... which kind of makes this a variant of (1), maybe? However we would have to ensure to still have alignment information in codegen.\r\n\r\nFor (3), the question is what exactly to replace them with. The easiest thing to do is to turn a pointer `allocN+x` into integer `align_of(allocN)+x`, which is at least a *possible* value for that pointer. @oli-obk [expressed a preference](https://github.com/rust-lang/rust/pull/71665/files#r424546054) for this option. However, I do not think this is a great idea. Consider the following program, which might actually run one day once we alllow more raw pointer stuff (currently it shouldn't run even with Miri unleashed):\r\n```rust\r\nconst NASTY: (bool, *const i32, *const i32) {\r\n  let x = 0; let y = 1;\r\n  let x = &x as *const _; let y = &y as *const _;\r\n  (x == y, x, y)\r\n}\r\n```\r\nIf we follow this variant of (3), the result will be `(false, 4, 4)`. IOW, it looks as if CTFE concluded that `4 != 4`... this is why I prefer (2).\r\n\r\nCc @rust-lang/wg-const-eval ", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/72215/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/72215/timeline", "performed_via_github_app": null, "state_reason": null}