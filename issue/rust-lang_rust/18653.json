{"url": "https://api.github.com/repos/rust-lang/rust/issues/18653", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/18653/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/18653/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/18653/events", "html_url": "https://github.com/rust-lang/rust/issues/18653", "id": 47828880, "node_id": "MDU6SXNzdWU0NzgyODg4MA==", "number": 18653, "title": "Generalization in type inference needs to generalize unbound type variables too", "user": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37544, "node_id": "MDU6TGFiZWwzNzU0NA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-typesystem", "name": "A-typesystem", "color": "f7e101", "default": false, "description": "Area: The type system"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2014-11-05T12:05:00Z", "updated_at": "2017-04-13T16:48:53Z", "closed_at": "2017-04-13T16:48:53Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I came across this subtle bug while working on the operator-dispatch branch. It has taken me quite some time to reduce it to a standalone test case. The fundamental problem is that, as currently implemented, when the type inferencer process a constraint like `&'_0 _1 <: _2`, where `'_0`, `_1`, and `_2` are variables, it will create a new region variable but leave the type variable alone, so that `_2` winds up being instantiated with `&'_3 _1`, where `_0 : _3`. That is good as far as it goes, but if `_1` winds up being instantiated with something that contains regions, we lose degrees of freedom. Imagine for example that `_1` winds up being instantiated with `&'_4 int`, then (substituting back to our original constraint), we have `&'_0 &'_4 int <: &'_3 &'_4 int` where `'_0 : '_3`. Again, this is true, but not as flexible we as we might like, since `'_4` appears on both sides, depriving the region inferencer the change to adjust them independently.\n\nTo actually make this bug have a problem you seem to need a lot of moving ingredients. Here is my reduced (but probably not maximally...) example of code that ought to compile but doesn't:\n\n``` rust\nuse std::cell::RefCell;\n\nenum Wrap<A> {\n    WrapSome(A),\n    WrapNone\n}\n\nstruct T;\nstruct U;\n\n// The Get trait. Key part here is that Get::get(X), where X has type\n// Wrap<_>, cannot be resolved immediately.\n\ntrait Get<Sized? T> {\n    fn get(&self) -> &T;\n}\n\nimpl Get<MyShow+'static> for Wrap<T> {\n    fn get(&self) -> &MyShow+'static {\n        static x: uint = 42;\n        &x\n    }\n}\n\nimpl Get<uint> for Wrap<U> {\n    fn get(&self) -> &uint {\n        static x: uint = 55;\n        &x\n    }\n}\n\n// The MyShow trait. In the original example, this was Show, but I\n// pulled it out to isolate the test from changes to libstd.\n\ntrait MyShow { fn dummy(&self) { } }\nimpl<'a> MyShow for &'a MyShow+'a { }\nimpl MyShow for uint { }\n\nfn constrain<'a>(rc: RefCell<&'a MyShow+'a>) { }\n\nfn main() {\n    // Here we do not know the full type of collection,\n    // so the type of `collection` is `Wrap<_#0>`.\n    let mut collection: Wrap<_> = WrapNone;\n\n    {\n        // ...and so we cannot resolve `Get::get` to a concrete\n        // instance. Hence the type of `__arg0` is just `&_#1`, and\n        // we know that `Wrap<_#0> : Get<_#1>`. Later `_#1` will be\n        // resolved to `&MyShow+'static`, but the inference doesn't\n        // know that yet.\n        let __arg0 = Get::get(&collection);\n\n        // Here we create a `RefCell`. This instantiates the type\n        // parameter of `RefCell::new` with a fresh variable (`_#2`)\n        // and then requires that `&'_3 _#1 <: _#2`. Because of the\n        // bug, this means that `_#2` is instantiated with `&'_4 _#1`\n        // (where `'_3 : '_4`). The important part is that only thing\n        // that changes is that a fresh region is created, `_#1` is\n        // carried though. (Without this bug, we would introduce a\n        // fresh type variable, and everything that follows woudl play\n        // out differently.)\n        let __args_cell = RefCell::new(__arg0);\n\n        // Finally we call `constrain`, whose argument is of type\n        // `RefCell<&'_5 MyShow+'_5>` (once bound regions are\n        // instantiated). Because `RefCell` is invariant, this means:\n        //\n        //     RefCell<_#2> <: RefCell<&'_5 MyShow+'_5>\n        //     RefCell<&'_4 _#1> <: RefCell<&'_5 MyShow+'_5> // ...expand _#2\n        //     &'_4 _#1 == &'_5 MyShow+'_5 // ...RefCell is invariant\n        //\n        // and hence:\n        //\n        //     '_4 == '_5\n        //     _#1 == MyShow+'_5\n        //\n        // Now, recall that the type of `__arg0` was `&'_3 _#1`. If we consider\n        // the various constraints we've accumulatd, then `__arg0` is now\n        // constrained to be `&'_3 MyShow+'_5` where `'_3 : '_4`.\n        constrain(__args_cell);\n    }\n\n    // Now we inform the inferencer that `_#0` is `Wrap<T>`. When\n    // trait inference runs, this will infer `_#1` to\n    // `MyShow+'static`. This in turn implies that the type of\n    // `__arg0` winds up as `&'static MyShow+'static`, and hence that\n    // `collections` must be borrowed for the static lifetime,\n    // yielding an error.\n    collection = WrapSome(T);\n}\n```\n\nI've spelled out what happens in comments. The fix for this is this simple patch:\n\n``` diff\ndiff --git a/src/librustc/middle/typeck/infer/combine.rs b/src/librustc/middle/typeck/infer/combine.rs\nindex e51eb33..5857c4d 100644\n--- a/src/librustc/middle/typeck/infer/combine.rs\n+++ b/src/librustc/middle/typeck/infer/combine.rs\n@@ -752,9 +752,14 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n                     self.cycle_detected = true;\n                     ty::mk_err()\n                 } else {\n-                    match self.infcx.type_variables.borrow().probe(vid) {\n-                        Some(u) => self.fold_ty(u),\n-                        None => t,\n+                    let result = self.infcx.type_variables.borrow().probe(vid);\n+                    match result {\n+                        Some(u) => {\n+                            return self.fold_ty(u);\n+                        }\n+                        None => {\n+                            self.infcx.next_ty_var()\n+                        }\n                     }\n                 }\n             }\n```\n\nwhich causes unbound variables to be replaced with fresh variables. I am unsure of the performance impact of this patch, though, and I want to test.\n", "closed_by": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/18653/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/18653/timeline", "performed_via_github_app": null, "state_reason": "completed"}