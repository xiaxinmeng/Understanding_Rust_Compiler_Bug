{"url": "https://api.github.com/repos/rust-lang/rust/issues/78542", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/78542/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/78542/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/78542/events", "html_url": "https://github.com/rust-lang/rust/issues/78542", "id": 732680860, "node_id": "MDU6SXNzdWU3MzI2ODA4NjA=", "number": 78542, "title": "MIR InstrumentCoverage - Can spans for `TerminatorKind::Goto` be improved to avoid special cases? ", "user": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 256133398, "node_id": "MDU6TGFiZWwyNTYxMzMzOTg=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-mir", "name": "A-mir", "color": "f7e101", "default": false, "description": "Area: Mid-level IR (MIR) - https://blog.rust-lang.org/2016/04/19/MIR.html"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-10-29T21:37:09Z", "updated_at": "2020-12-04T04:51:45Z", "closed_at": "2020-12-04T04:51:45Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Rust's LLVM InstrProf-based source code coverage implementation instruments Rust code via the MIR pass `InstrumentCoverage`. Most criteria for identifying coverage regions and counter locations are very general, based on Control Flow Graph (CFG) analysis of the MIR, and a fairly straightforward mapping of MIR `Statement`s and `Terminator`s to their source code regions (`Span`s). \r\n\r\n`TerminatorKind::Goto`s are an exception, requiring special handling.\r\n\r\nThis issue is created to highlight some of the unique requirements and issues addressed in the current coverage implementation, in case someone has ideas for improving things, to reduce the reliance on the `Goto`-specific logic, either by improving `InstrumentCoverage` if something was overlooked, or improving the `Goto` representation (such as refining its `Span` representation, or providing additional context that `InstrumentCoverage` might leverage).\r\n\r\n ### Current State\r\n\r\nOne of the first steps in the `InstrumentCoverage` process is to extract relevant code `Span`s from the MIR `Statement`s and `Terminator`s. (These `Span`s are later combined into sets of sequential statements and with contiguous source code regions that can be counted via a single counter; i.e., if any statement in the set was executed, all statements in the same set would also have been executed.)\r\n\r\n`bcb_to_initial_coverage_spans()` iterates through the `BasicBlock`s of the `CoverageGraph` (a subset of the MIR, essentially skipping panic/unwind paths), and their `Statement`s and `Terminator`s. Some `Statement`s and `Terminator`s are relevant to `Coverage`, and others are not. The `Statement` and `Terminator` filtering is handled by `filtered_statement_span()` and `filtered_terminator_span()`, respectively.\r\n\r\nIn almost all cases, if not filtered out, the initial coverage `Span` contributed by either a `Statement` or a `Terminator` is the `source_info.span` (within the function body) of the `Statement` or `Terminator`; because, in most cases, the source code span carried forward from the parsed source to its MIR representation is a fairly accurate mapping from intent to execution.\r\n\r\nFor example, `filtered_terminator_span()` uses the entire `source_info.span` for the following `TerminatorKind`s:\r\n\r\n```rust\r\nfn filtered_terminator_span(terminator: &'a Terminator<'tcx>, body_span: Span) -> Option<Span> {\r\n    match terminator.kind {\r\n...\r\n        // Retain spans from all other terminators\r\n        TerminatorKind::Resume\r\n        | TerminatorKind::Abort\r\n        | TerminatorKind::Return\r\n        | TerminatorKind::Call { .. }\r\n        | TerminatorKind::Yield { .. }\r\n        | TerminatorKind::GeneratorDrop\r\n        | TerminatorKind::FalseUnwind { .. }\r\n        | TerminatorKind::InlineAsm { .. } => {\r\n            Some(function_source_span(terminator.source_info.span, body_span))\r\n        }\r\n```\r\n\r\nAll other `TerminatorKind`s are filtered out, except for `Goto`.\r\n\r\n`Goto` terminators play an important role in the control flow, so they cannot be filtered out, but their `source_info.span` typically includes the `Span`s of the statements that precede it, making the `Span` redundant, in most cases.\r\n\r\n    One example: `Goto`s are often the targets of `SwitchInt` branches, and certain important optimizations to replace some `Counter`s with `Expression`s require a separate `BasicCoverageBlock` for each branch, to support the `Counter`, when needed.\r\n\r\nSince a `Goto`-based `CoverageSpan` still needs a span to indicate if a region of actual source code was executed or not, the span returned from `filtered_terminator_span()`, for `Goto`s, is an empty span, positioned at the `Goto` span's last byte position:\r\n\r\n```rust\r\nTerminatorKind::Goto { .. } => {\r\n    Some(function_source_span(terminator.source_info.span.shrink_to_hi(), body_span))\r\n}\r\n```\r\n\r\nThis byte position can--most often--be leveraged to contribute to a `CoverageSpan` for certain execution branches.\r\n\r\nFor example, an `if` block without an `else` shows the block was executed if the condition was `true`, but there would be no way to indicate coverage (or lack thereof) of the `false` branch without using the associated `Goto`s `hi()` byte position (which is expanded by one character to the left, for a non-empty `CoverageSpan`.\r\n\r\nHowever, in other cases, a visible `CoverageSpan` is not wanted, but the `Goto`\r\nblock must still be counted (for example, to contribute its count to an `Expression`\r\nthat reports the execution count for some other block). In these cases, the code region\r\nis set to `None`.\r\n\r\nThis decision (whether to include a one-character coverage span for a `Goto` or to count a `Goto` block without a code region) is handled in `inject_coverage_span_counters()`, beginning with the call to `is_code_region_redundant()`, which encapsulates the decision on how to handle these special cases.\r\n\r\nAt the time of this writing, the decision criteria is only looking for `Goto` terminators with spans that end at the last byte position in the file, because these `Goto` spans--if present--are redundant with the spans from every function's final `Return` terminator. When they are present, they can cause the function's last line to appear to have been executed twice, when it was only executed once.\r\n", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/78542/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/78542/timeline", "performed_via_github_app": null, "state_reason": "completed"}