{"url": "https://api.github.com/repos/rust-lang/rust/issues/30170", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/30170/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/30170/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/30170/events", "html_url": "https://github.com/rust-lang/rust/issues/30170", "id": 120024495, "node_id": "MDU6SXNzdWUxMjAwMjQ0OTU=", "number": 30170, "title": "if huge requested align, alloc_system heap::allocate on OS X returns unaligned values", "user": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 129836139, "node_id": "MDU6TGFiZWwxMjk4MzYxMzk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-allocators", "name": "A-allocators", "color": "f7e101", "default": false, "description": "Area: Custom and system allocators"}, {"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2015-12-02T20:04:48Z", "updated_at": "2017-07-28T03:16:14Z", "closed_at": "2017-07-28T03:16:14Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "While trying to isolate what kinds of preconditions the `Allocator` trait is going to require and post-conditions it ensures, I made a test program to explore what happens with our current pair of low-level allocators.\r\n\r\nAs far as I can tell so far, jemalloc always ensures that it never gives back an unaligned address.\r\n\r\nbut on OS X, the system allocator (linked via `extern crate alloc_system;`) can produce addresses that do not meet the alignment request, namely if you ask for values with starting addresses of alignment greater than or equal to `1 << 32`.  (Like i said, we're talking about _huge_ alignments here.)\r\n\r\n(on Linux, for both jemalloc and the system allocator, I never observed either returning non-null addresses that did not meet the alignment request.  In other words, they handled absurdly large alignments \"properly\")\r\n### What to do about this?\r\n\r\nI talk a little about this further in my Digression section below, but in summary, I think we should do _something_ about this.\r\n\r\nIt seems like an easy short term solution is this: We should be able to pre-determine which allocator + platform combinations fall victim to this problem, and for those cases, make the `allocate` (and `reallocate`, etc) methods validate their results. If validation fails, then we can just free the original address and return null. \r\n- The main problem with this is that it adds overhead to the allocation path.  (Admittedly a `%` (aka divide) and branch doesn't seem like much in the context of an allocation, but still...)\r\n\r\nAnyway, if you're interested in alternative ideas, see the Digression/Discussion section below\r\n### Digression and/or Discussion\r\n\r\nWhen Rust [originally merged](https://github.com/rust-lang/rust/commit/1b1ca6d5465ef4de12b1adf25cd4598f261c660d#diff-2020572c14fe23a6b11b55b5e113b4aaR36) the jemalloc support PR, it stated the following requirement on the `allocate` method:\r\n\r\n```\r\nalignment must be no larger than the largest supported page size on the platform.\r\n```\r\n- depending on what the phrase \"the largest supported page size\" is supposed to mean, perhaps even moderately sized values are not legal inputs for the alignment...\r\n- (was that phrase supposed to be something like \"allocated block size\" rather than \"page size\" ? The notion of more than one memory page size on a given platform is not something I'm familiar with...)\r\n\r\n... so arguably there has always been a precondition to not feed in ridiculously large values for alignment.   \r\n\r\nHowever, even if that is the case, here are some things to consider\r\n#### Requirements should be checkable\r\n\r\nif we want to continue to impose this precondition, then we _must_ provide the programmer with a way to query what the value of \"the largest supported page size on the platform\" actually _is_.\r\n\r\n(I didn't see a way to do this via a couple of greps of the code base, but it doesn't help that I don't understand what is actually meant by the above phrase.)\r\n- (I don't think the phrase is meant to denote the same thing as `::std::sys::os::page_size`; so I don't think that would be a way to query the actual value, though certainly it would provide a _bound_ that a programmer can use in the meantime...)\r\n- IMO, if we were to add a method to query the value of \"largest supported alignment\", it should be part of the low-level allocator interface (see [RFC 1183](https://github.com/rust-lang/rfcs/blob/master/text/1183-swap-out-jemalloc.md)), since presumably the largest supported value would be connected to the allocator implementation.\r\n#### Post-validation is not absurd\r\n\r\nGiven that at least _some_ alloc-crate + target combinations are not imposing the above requirement (in the sense that they return null when the given alignment is unsatisfiable), it seems somewhat reasonable to me to add the post-allocation check that I described above, as long as we do it in a conditionalized manner.\r\n- Instead of conditionalizing based on the target OS, we might be able to write the injected code in a way where the compiler can optimize away the check when the given alignment is known and falls beneath some reasonable bound, like `align <= 0x1000`, working under the assumptions that all allocators will behave properly with such an input.\r\n- (I suspect in a vast number of cases, the alignment is statically known, so this would probably be a fine solution.)\r\n\r\nAlso, the man page for `posix_memalign` on my version of OS X says nothing about an upper bound on the value for `alignment`. This to me indicates that this is a _bug_ in OS X itself, which we can report and workaround via post-validation in the short term. \r\n-  (If we did conditionalize based on target OS, then longer term, I don't know how we would best deal with trying to conditionally inject the post-validation in question; perhaps the default `#[allocator]` crate linking could choose between the two variants depending on which version of OS X is targetted.)\r\n### The Sample Program\r\n\r\nHere is that sample program (you can toggle the different allocates with `--cfg alloc_system` or `--cfg alloc_jemalloc`).  When you run it, the thing to look for is when there is an output line that has `rem: <value>` on the end, which is only printed for non-zero remainder (when one divides the address by the alignment).\r\n\r\n(Also, here's a [playpen](https://play.rust-lang.org/?gist=6fa7a76ab99380251920&version=nightly), though I repeat that the problematic behavior does not exhibit itself on versions of Linux that I have tried.) ((Updated to fit new [global allocator API](https://github.com/rust-lang/rust/issues/27389)))\r\n\r\n``` rust\r\n#![feature(alloc, allocator_api)]\r\n#![cfg_attr(alloc_jemalloc, feature(alloc_jemalloc))]\r\n#![cfg_attr(alloc_system, feature(alloc_system))]\r\nextern crate alloc;\r\n#[cfg(alloc_jemalloc)]\r\nextern crate alloc_jemalloc;\r\n#[cfg(alloc_system)]\r\nextern crate alloc_system;\r\nuse std::{isize, mem};\r\nconst PRINT_ALL: bool = false;\r\nfn main() {\r\n    use std::heap::{Alloc, System, Layout};\r\n    unsafe {\r\n        for i in 0 .. mem::size_of::<usize>()*8 {\r\n            let (mut v, a) = (Vec::new(), 1 << i);\r\n            let try_alloc = |j, s, a| {\r\n                let p = System.alloc(Layout::from_size_align(s, a).unwrap());\r\n                if let Ok(p) = p {\r\n                    let q = p as usize;\r\n                    let rem = q % a;\r\n                    if PRINT_ALL || rem != 0 {\r\n                        println!(\"(i,j,s):{ijs:>30} a:{a:>8}  =>  p:{p:20?}, rem: 0x{rem:x}\",\r\n                                 ijs=format!(\"({},{},0x{:x})\", i,j,s),\r\n                                 a=format!(\"1<<{}\", i),\r\n                                 p=p,\r\n                                 rem=rem);\r\n                    }\r\n                } else {\r\n                    println!(\"(i,j,s):{ijs:>30} a:{a:>8}  =>  alloc fail\",\r\n                             ijs=format!(\"({},{},0x{:x})\", i,j,s),\r\n                             a=format!(\"1<<{}\", i));\r\n                }\r\n                p\r\n            };\r\n                {\r\n                let mut alloc_loop = |init_s, start, limit| {\r\n                    let mut s = init_s;\r\n                    for j in start .. limit {\r\n                        if s > isize::MAX as usize {\r\n                            println!(\"breaking b/c s={} > isize::MAX={}\", s, isize::MAX);\r\n                            break;\r\n                        }\r\n                        let p = try_alloc(j, s, a);\r\n                        if let Ok(p) = p { v.push((p,s,a)); } else { break; }\r\n                        s += j;\r\n                    }\r\n                };\r\n\r\n                if i >= 8*mem::size_of::<usize>() { break; }\r\n                alloc_loop(10, 0, 10);\r\n                alloc_loop(a, 10, 20);\r\n            }\r\n\r\n            for (p,s,a) in v { System.dealloc(p, Layout::from_size_align(s, a).unwrap()); }\r\n        }\r\n    }\r\n}                                                                                            \r\n```\r\n#### Output on Mac OS X showing the erroneous value(s)\r\n\r\nSee following gist: https://gist.github.com/pnkfelix/535e8d4e810025331c77\r\n", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/30170/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/30170/timeline", "performed_via_github_app": null, "state_reason": "completed"}