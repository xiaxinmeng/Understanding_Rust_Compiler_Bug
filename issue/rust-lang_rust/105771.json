{"url": "https://api.github.com/repos/rust-lang/rust/issues/105771", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/105771/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/105771/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/105771/events", "html_url": "https://github.com/rust-lang/rust/issues/105771", "id": 1499946394, "node_id": "I_kwDOAAsO6M5ZZ12a", "number": 105771, "title": "`#[inline]` causes duplicated symbols in the final binary", "user": {"login": "EFanZh", "id": 2160692, "node_id": "MDQ6VXNlcjIxNjA2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/2160692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/EFanZh", "html_url": "https://github.com/EFanZh", "followers_url": "https://api.github.com/users/EFanZh/followers", "following_url": "https://api.github.com/users/EFanZh/following{/other_user}", "gists_url": "https://api.github.com/users/EFanZh/gists{/gist_id}", "starred_url": "https://api.github.com/users/EFanZh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/EFanZh/subscriptions", "organizations_url": "https://api.github.com/users/EFanZh/orgs", "repos_url": "https://api.github.com/users/EFanZh/repos", "events_url": "https://api.github.com/users/EFanZh/events{/privacy}", "received_events_url": "https://api.github.com/users/EFanZh/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2022-12-16T10:21:52Z", "updated_at": "2022-12-17T04:55:52Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I noticed that if a function is marked `#[inline]` in an upstream crate, then even if upstream have already generated a function instance, downstream creates will not reuse the existing instance, instead, they will generate their own instance, which causes duplicated symbols generated in the binary file, which causes size bloat.\r\n\r\nNote that this happens in the situation where a function is marked `#[inline]`, but not actually being inlined, so the function will have a symbol entry of its own.\r\n\r\nTo reproduce, you can make a project with the following dependency graph:\r\n\r\n```text\r\n    +----------+\r\n    | upstream |\r\n    +----------+\r\n      /  |  \\\r\n     /   |   \\\r\n+------+ | +-------+\r\n| left | | | right |\r\n+------+ | +-------+\r\n     \\   |   /\r\n      \\  |  /\r\n   +------------+\r\n   | downstream |\r\n   +------------+\r\n```\r\n\r\nwhere a fairly complex (to prevent being inlined) inline function is defined in `upstream` crate, and all `upstream`, `left` and `right` crates calls the inline function. `downstream` crate is for collecting all symbols generated in all the crates. I wrote a shell script for generating a such project locally (Usage: `<SCRIPT> <PROJECT PATH>`):\r\n\r\n```shell\r\n#!/bin/sh -ex\r\n\r\nmkdir -p \"$1\"\r\ncd \"$1\"\r\n\r\n# Upstream.\r\n\r\ncargo new --lib upstream\r\necho '#[inline]\r\npub fn inline_function(x: u32) {\r\n    if x != 42 {\r\n        if x % 2 == 0 {\r\n            inline_function(x / 2)\r\n        } else {\r\n            inline_function(x * 3 + 1)\r\n        }\r\n    }\r\n\r\n    std::hint::black_box(x);\r\n}\r\n\r\npub fn instance(n: u32) {\r\n    inline_function(n)\r\n}' > 'upstream/src/lib.rs'\r\n\r\n\r\n# Left and right.\r\n\r\nfor x in left right; do\r\n    cargo new --lib \"$x\"\r\n    cargo add --manifest-path \"$x/Cargo.toml\" --path upstream\r\n\r\n    echo 'pub fn instance(x: u32) {\r\n    upstream::inline_function(x)\r\n}' > \"$x/src/lib.rs\"\r\ndone\r\n\r\n# Downstream.\r\n\r\ncargo init\r\ncargo add --path 'upstream'\r\ncargo add --path 'left'\r\ncargo add --path 'right'\r\n\r\necho '#[no_mangle]\r\nextern \"C\" fn entry(x: u32) {\r\n    upstream::instance(x);\r\n    left::instance(x);\r\n    right::instance(x);\r\n}' > \"src/lib.rs\"\r\n\r\n# Build.\r\n\r\ncargo rustc --lib --crate-type cdylib --release\r\n```\r\n\r\nYou can inspect the result binary using `llvm-nm` and `llvm-objdump`. In my case, `llvm-nm` gives me the following output:\r\n\r\n```text\r\n0000000000003ee0 t __ZN3top15inline_function17hcd434eca693902bbE\r\n0000000000003f20 t __ZN3top15inline_function17hcd434eca693902bbE\r\n0000000000003f60 t __ZN3top15inline_function17hcd434eca693902bbE\r\n0000000000003f90 t __ZN3top8instance17hc175d5b93e3a6803E\r\n0000000000003f50 t __ZN4left8instance17h5cc7aa4e08943d83E\r\n0000000000003f10 t __ZN5right8instance17hcefb8e0167b5830aE\r\n0000000000003eb0 T _entry\r\n```\r\n\r\nNote the three duplicated `__ZN3top15inline_function17hcd434eca693902bbE` symbol. And using `llvm-objdump`, I got three pieces of duplicated assembly code:\r\n\r\n```text\r\n...\r\n0000000000003ee0 <__ZN3top15inline_function17hcd434eca693902bbE>:\r\n    3ee0: 55                           \tpushq\t%rbp\r\n    3ee1: 48 89 e5                     \tmovq\t%rsp, %rbp\r\n    3ee4: 53                           \tpushq\t%rbx\r\n    3ee5: 50                           \tpushq\t%rax\r\n    3ee6: 89 fb                        \tmovl\t%edi, %ebx\r\n    3ee8: 83 ff 2a                     \tcmpl\t$42, %edi\r\n    3eeb: 74 13                        \tje\t0x3f00 <__ZN3top15inline_function17hcd434eca693902bbE+0x20>\r\n...\r\n0000000000003f20 <__ZN3top15inline_function17hcd434eca693902bbE>:\r\n    3f20: 55                           \tpushq\t%rbp\r\n    3f21: 48 89 e5                     \tmovq\t%rsp, %rbp\r\n    3f24: 53                           \tpushq\t%rbx\r\n    3f25: 50                           \tpushq\t%rax\r\n    3f26: 89 fb                        \tmovl\t%edi, %ebx\r\n    3f28: 83 ff 2a                     \tcmpl\t$42, %edi\r\n    3f2b: 74 13                        \tje\t0x3f40 <__ZN3top15inline_function17hcd434eca693902bbE+0x20>\r\n...\r\n0000000000003f60 <__ZN3top15inline_function17hcd434eca693902bbE>:\r\n    3f60: 55                           \tpushq\t%rbp\r\n    3f61: 48 89 e5                     \tmovq\t%rsp, %rbp\r\n    3f64: 53                           \tpushq\t%rbx\r\n    3f65: 50                           \tpushq\t%rax\r\n    3f66: 89 fb                        \tmovl\t%edi, %ebx\r\n    3f68: 83 ff 2a                     \tcmpl\t$42, %edi\r\n    3f6b: 74 13                        \tje\t0x3f80 <__ZN3top15inline_function17hcd434eca693902bbE+0x20>\r\n...\r\n```\r\n\r\nAnd If I remove the `#[inline]` attribute in the `upstream` crate, there will be no duplicated symbols.\r\n\r\n`\"fat\"` LTO seems to be able to merge the duplicated symbols, but not all project can enable this option, so is it possible to fix this problem even if `\"fat\"` LTO is not used? Also, `codegen-units=1` does not seem to help.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/105771/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/105771/timeline", "performed_via_github_app": null, "state_reason": null}