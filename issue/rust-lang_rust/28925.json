{"url": "https://api.github.com/repos/rust-lang/rust/issues/28925", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/28925/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/28925/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/28925/events", "html_url": "https://github.com/rust-lang/rust/issues/28925", "id": 110600293, "node_id": "MDU6SXNzdWUxMTA2MDAyOTM=", "number": 28925, "title": "#[repr(C)] enum bit width determination algo does not match that of the C compiler", "user": {"login": "mzabaluev", "id": 1198919, "node_id": "MDQ6VXNlcjExOTg5MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1198919?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mzabaluev", "html_url": "https://github.com/mzabaluev", "followers_url": "https://api.github.com/users/mzabaluev/followers", "following_url": "https://api.github.com/users/mzabaluev/following{/other_user}", "gists_url": "https://api.github.com/users/mzabaluev/gists{/gist_id}", "starred_url": "https://api.github.com/users/mzabaluev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mzabaluev/subscriptions", "organizations_url": "https://api.github.com/users/mzabaluev/orgs", "repos_url": "https://api.github.com/users/mzabaluev/repos", "events_url": "https://api.github.com/users/mzabaluev/events{/privacy}", "received_events_url": "https://api.github.com/users/mzabaluev/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 45472092, "node_id": "MDU6TGFiZWw0NTQ3MjA5Mg==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-ffi", "name": "A-ffi", "color": "f7e101", "default": false, "description": "Area: Foreign Function Interface (FFI)"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 630652267, "node_id": "MDU6TGFiZWw2MzA2NTIyNjc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-feature-request", "name": "C-feature-request", "color": "f5f1fd", "default": false, "description": "Category: A feature request, i.e: not implemented / a PR."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2015-10-09T07:12:54Z", "updated_at": "2017-11-23T07:14:25Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "In C, support for enum determinants that cannot be represented by an `int` is implementation-defined. Many compilers choose a different basic type for representation, based on the types or the values of the determinants. This is where the algorithm currently used by Rust for `#[repr(C)]` enums may differ from the one used by the C compiler, although the difference can be observed in fairly marginal cases.\n\nGCC uses the types of the determinant expressions to find the best fit, so this is a 32-bit type on 64-bit Linux:\n\n``` c\ntypedef enum {\n    A = 0x80000001,\n    B = -0x80000000,\n} C;\n```\n\nYet this is 64-bit:\n\n``` c\ntypedef enum {\n    A = 0x80000001,\n    B = -2147483648  /* -0x80000000 */\n} C;\n```\n\nThis is because the type of [integer constant](http://en.cppreference.com/w/c/language/integer_constant) `0x80000000` is determined as `unsigned int` due to its hexadecimal notation, and the negation preserves the type.\n\nRust first coerces all discriminants to `isize` and then apparently works out the best fitting representation type from the value range, where fitting means that negative values are preserved as such. So this ends up being 64-bit:\n\n``` rust\n#[repr(C)]\nenum C {\n    A = 0x80000001,\n    B = -0x80000000,\n}\n\nfn main() {\n    println!(\"{}\", std::mem::size_of::<C>());\n}\n```\n\nI'm uncertain as to which approach is the best for fixing this. Trying to match the behavior of C compilers quirk-for-quirk does not seem to be feasible: there may be more than one compiler per target, and in fact the behavior even changes with compiler options, as e.g. the type of an integer constant is determined differently pre-C99 and post-C99. Perhaps a more conservative solution would be to lint on discriminant values that are out of the `libc::c_int` domain and suggest using fixed-width representations such as `#[repr(u32)]`.\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/28925/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/28925/timeline", "performed_via_github_app": null, "state_reason": null}