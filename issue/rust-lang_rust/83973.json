{"url": "https://api.github.com/repos/rust-lang/rust/issues/83973", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/83973/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/83973/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/83973/events", "html_url": "https://github.com/rust-lang/rust/issues/83973", "id": 852596300, "node_id": "MDU6SXNzdWU4NTI1OTYzMDA=", "number": 83973, "title": "Missing f32/f64 euclidean remainder with integral divisor", "user": {"login": "mqudsi", "id": 606923, "node_id": "MDQ6VXNlcjYwNjkyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/606923?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mqudsi", "html_url": "https://github.com/mqudsi", "followers_url": "https://api.github.com/users/mqudsi/followers", "following_url": "https://api.github.com/users/mqudsi/following{/other_user}", "gists_url": "https://api.github.com/users/mqudsi/gists{/gist_id}", "starred_url": "https://api.github.com/users/mqudsi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mqudsi/subscriptions", "organizations_url": "https://api.github.com/users/mqudsi/orgs", "repos_url": "https://api.github.com/users/mqudsi/repos", "events_url": "https://api.github.com/users/mqudsi/events{/privacy}", "received_events_url": "https://api.github.com/users/mqudsi/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 630652267, "node_id": "MDU6TGFiZWw2MzA2NTIyNjc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-feature-request", "name": "C-feature-request", "color": "f5f1fd", "default": false, "description": "Category: A feature request, i.e: not implemented / a PR."}, {"id": 2139259423, "node_id": "MDU6TGFiZWwyMTM5MjU5NDIz", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-floating-point", "name": "A-floating-point", "color": "f7e101", "default": false, "description": "Area: Floating point numbers and arithmetic"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2021-04-07T16:46:22Z", "updated_at": "2022-06-03T21:22:35Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I was writing some machine learning code and found that I was severely bottlenecked by some of the limitations of the available floating point operations in the rust standard library. In particular, rust currently only affords a euclidean remainder operation where both the dividend and the divisor are floating point values, however it is often the case that one has a floating point dividend but an integral divisor, the result of which can be calculated significantly faster and without using the floating point registers.\r\n\r\nI believe the following function is equivalent to `f64::rem_euclid()` for normal `f32`/`f64` values *where the truncated value of `self` can fit in an i64 value*:\r\n\r\n```rust\r\n#[inline]\r\nfn rem_i64(&self, divisor: i64) -> f64 {\r\n    let x = *self as i64;\r\n    if self.is_sign_positive() {\r\n        (x % divisor) as f64 + self.fract()\r\n    } else {\r\n        (x % divisor + divisor.abs()) as f64 + self.fract()\r\n    }\r\n}\r\n```\r\n\r\nThe compiler [optimizes the branch into a conditional move](https://godbolt.org/z/fM1GjjhMn). It can also be done explicitly via the one-liner:\r\n`(x % divisor + if self.is_sign_positive() { 0 } else { 1 } * divisor.abs()) as f64 + self.fract()`.\r\n\r\nWithout any parallelism increasing the contention for the limited floating point registers, `rem_i64` is approximately 35x faster than the default `rem_euclid()` calculation, so it's a very meaningful gain. The screenshots below show the result of a criterion benchmark comparing the calculation of `rem_i64()` to `rem_euclid()` on (identical) arrays of 2048 pre-generated random floating point values modulo a fixed integral value (360) on an AMD 1950X (similar results were observed on a Haswell Xeon):\r\n\r\n\r\n![image](https://user-images.githubusercontent.com/606923/113900569-91fa0380-9793-11eb-9dc0-40ea5972ba7a.png)\r\n![image](https://user-images.githubusercontent.com/606923/113900591-99b9a800-9793-11eb-834f-5b01477838bb.png)\r\n\r\n\r\nI *would* suggest having the compiler convert `f64::rem_euclid(foo, xxx.0)` to the above, but that is only possible if you can guarantee that `foo` is less than or equal to `i64::MAX`. It's probably still a win even if that requires a runtime conditional/branch (except in case of const operations) but it would obviously be desirable to explicitly opt into an i64 modulo operation and bypass that check for anyone that's saturating their processor's floating point capabilities, so there would have to be a separate method even if `f64::rem_euclid()` sometimes did also take the fast path depending on the values of `self` and `divisor`.\r\n\r\nSidenote: I'm not sure if directly composing an IEEE754 value from the integral and fractional components would be any faster than casting the integral value to an `f64` and adding the fractional component afterwards. If so, then possibly we need an `f64::from_parts(integral, fractional)` method?\r\n\r\n---\r\n\r\nJust for posterity/reference, this is what the same benchmark shows when using an equivalent `rem_i128()` method, in case you *did* want to add a conditional fast path to the existing `rem_euclid()` routine for values of `self` that were greater than `i64::MAX` but less than `i128::MAX`:\r\n\r\n![image](https://user-images.githubusercontent.com/606923/113902083-23b64080-9795-11eb-8dd3-6602f4fad818.png)\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/83973/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/83973/timeline", "performed_via_github_app": null, "state_reason": null}