{"url": "https://api.github.com/repos/rust-lang/rust/issues/85234", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/85234/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/85234/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/85234/events", "html_url": "https://github.com/rust-lang/rust/issues/85234", "id": 890371305, "node_id": "MDU6SXNzdWU4OTAzNzEzMDU=", "number": 85234, "title": "Improve Float Parsing Speeds by up to 99.94% Through Improvements to the Bellerophon Algorithm", "user": {"login": "Alexhuszagh", "id": 9440903, "node_id": "MDQ6VXNlcjk0NDA5MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/9440903?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexhuszagh", "html_url": "https://github.com/Alexhuszagh", "followers_url": "https://api.github.com/users/Alexhuszagh/followers", "following_url": "https://api.github.com/users/Alexhuszagh/following{/other_user}", "gists_url": "https://api.github.com/users/Alexhuszagh/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexhuszagh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexhuszagh/subscriptions", "organizations_url": "https://api.github.com/users/Alexhuszagh/orgs", "repos_url": "https://api.github.com/users/Alexhuszagh/repos", "events_url": "https://api.github.com/users/Alexhuszagh/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexhuszagh/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 2011781731, "node_id": "MDU6TGFiZWwyMDExNzgxNzMx", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs", "name": "T-libs", "color": "bfd4f2", "default": false, "description": "Relevant to the library team, which will review and decide on the PR/issue."}, {"id": 2139259423, "node_id": "MDU6TGFiZWwyMTM5MjU5NDIz", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-floating-point", "name": "A-floating-point", "color": "f7e101", "default": false, "description": "Area: Floating point numbers and arithmetic"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2021-05-12T18:26:43Z", "updated_at": "2021-07-17T15:26:25Z", "closed_at": "2021-07-17T15:26:25Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "# Summary\r\n\r\nWhen the fast-path algorithm cannot be used (see #85198), Rust defaults back to a the Bellerophon algorithm, based off this [paper](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.4152). Examples of floats that can be correctly parsed via the Bellerophon algorithm include `\"9007199254740992.0\"` (`1 << 53`), while near-halfway cases such `\"9007199254740992992e-3\"` must fall back to slower algorithms (just less than halfway of `(1 << 53) + 1`). Unfortunately, the current implementation of the Bellerophon algorithm requires the use of arbitrary-precision arithmetic, which can lead to a 10,000x performance penalty.\r\n\r\nPlease see the \"Sample Repository\" below for the exact specifics, or in order to replicate these changes. This is an [initial attempt](https://internals.rust-lang.org/t/implementing-a-fast-correct-float-parser/14670) as part of an ongoing effort to speed up float parsing in Rust, and aims to integrate algorithms I've implemented (currently used in nom and serde-json) back in the core library.\r\n\r\n# Issue\r\n\r\nWhen parsing floating-point numbers, if the number cannot be exactly parsed by the fast-path algorithm, it falls back to an extended-precision representation (often consisting of 64-bits for the significant digits, or mantissa, and 16-bits for the exponent). For a more detailed description of halfway cases, see the halfway cases section below.\r\n\r\nIf this extended-precision algorithm can be unambiguously rounded to the nearest native float, by showing that the max error is less than the different to the nearest halfway case, then we have an accurate representation and can skip slower algorithms.\r\n\r\nThese slower algorithms make use of arbitrary-precision arithmetic to exactly represent the significant digits of the float, and therefore round to the nearest native float. The current implementation of Bellerophon, however, generates the significant digits from a [big integer](https://github.com/rust-lang/rust/blob/28e2b29b8952485679367cc05699fb5154f4e5c3/library/core/src/num/dec2flt/algorithm.rs#L161-L178), which leads to significantly reduced performance.\r\n\r\nBy using a 64-bit representation of the significant digits parsed from the first 19-20 digits of the float, we can improve performance by orders of magnitude.\r\n\r\n# Halfway Cases\r\n\r\nWhen parsing floats, the most significant problem is determining how to round the resulting value. The IEEE-754 standard specifies rounding to nearest, then tie even.\r\n\r\nFor example, using this rounding scheme to decimal numbers:\r\n- `8.9` would round to `9.0`.\r\n- `9.1` would round to `9.0`.\r\n- `9.5` would round to `10.0`.\r\n- `10.5` would round to `10.0`.\r\n\r\nWith parsing from decimal strings to binary, fixed-width floating point numbers, we must round to the nearest float. This becomes tricky when values are near their halfway point. For example, with a single-precision float `f32`, we would round as follows:\r\n- `16777216.9` rounds to `16777216.0`\r\n- `16777217.0` rounds to `16777216.0`\r\n- `16777217.1` rounds to `16777218.0`\r\n\r\nThis is easier illustrated if we represent the float in binary. First, here's the layout of an IEEE-754 single-precision float as bits:\r\n\r\n\ud83d\udfe6\ud83d\udfe9\ud83d\udfe9\ud83d\udfe9\ud83d\udfe9\ud83d\udfe9\ud83d\udfe9\ud83d\udfe9\ud83d\udfe9\ud83d\udfea\ud83d\udfea\ud83d\udfea\ud83d\udfea\ud83d\udfea\ud83d\udfea\ud83d\udfea\ud83d\udfea\ud83d\udfea\ud83d\udfea\ud83d\udfea\ud83d\udfea\ud83d\udfea\ud83d\udfea\ud83d\udfea\ud83d\udfea\ud83d\udfea\ud83d\udfea\ud83d\udfea\ud83d\udfea\ud83d\udfea\ud83d\udfea\ud83d\udfea\r\n\r\nWhere:\r\n- \ud83d\udfe6 is the sign bit.\r\n- \ud83d\udfe9 are the exponent bits.\r\n- \ud83d\udfea are the mantissa, or significant digit, bits.\r\n\r\nWe'll ignore the exponent and sign bits right now, and only consider the mantissa, or significant digits. The lowest exponent bit, also called the hidden bit, is used as an implicit, extra bit of precision for normal floats, meaning we have 24-bits of precision. For 3 numbers, we would therefore have the following representations, where the last bit is truncated off:\r\n\r\n- `16777216.0` => `100000000000000000000000 0`\r\n- `16777217.0` => `100000000000000000000000 1`\r\n- `16777218.0` => `100000000000000000000001 0`\r\n\r\nTherefore, `16777217.0` is exactly halfway between `16777216.0` and `16777218.0`. Although solving these halfway cases can superficially seem easy, simple algorithms will fail even when parsing the shortest, accurate decimal representation.\r\n\r\n# Binary Sizes\r\n\r\nThese were compiled on a target of `x86_64-unknown-linux-gnu`, running kernel version `5.11.16-100`, on a Rust version of `rustc 1.53.0-nightly (132b4e5d1 2021-04-13)`. The sizes reflect the binary sizes reported by `ls -sh`, both before and after running the `strip` command. The debug profile was used for opt-levels `0` and `1`, and was as follows:\r\n\r\n```toml\r\n[profile.dev]\r\nopt-level = \"...\"\r\ndebug = true\r\nlto = false\r\n```\r\n\r\nThe release profile was used for opt-levels `2`, `3`, `s` and `z` and was as follows:\r\n\r\n```toml\r\n[profile.release]\r\nopt-level = \"...\"\r\ndebug = false\r\ndebug-assertions = false\r\nlto = true\r\n```\r\n\r\n**core**\r\n\r\nThese are the binary sizes prior to making changes.\r\n\r\nopt-level|size|size(stripped)\r\n|:-:|:-:|:-:|\r\n0|3.6M|360K\r\n1|3.5M|316K\r\n2|1.3M|236K\r\n3|1.3M|248K\r\ns|1.3M|244K\r\nz|1.3M|248K\r\n\r\n**moderate**\r\n\r\nThese are the binary sizes after making changes to speed up the Bellerophon algorithm.\r\n\r\nopt-level|size|size(stripped)\r\n|:-:|:-:|:-:|\r\n0|3.6M|364K\r\n1|3.5M|316K\r\n2|1.3M|248K\r\n3|1.3M|252K\r\ns|1.3M|244K\r\nz|1.3M|244K\r\n\r\n# Performance\r\n\r\nOverall, the changes to speed up Bellerophon algorithm led to a:\r\n- ~-79% change in performance for the `MODERATE` float.\r\n- ~-99.7% change in performance for the `LARGE` float.\r\n- ~-99.94% change in performance for the `DENORMAL` float.\r\n\r\nAnd it did not affect the performance of the fast-path algorithm.\r\n\r\nThese benchmarks were run on an `i7-6560U CPU @ 2.20GHz`, on a target of `x86_64-unknown-linux-gnu`, running kernel version `5.11.16-100`, on a Rust version of `rustc 1.53.0-nightly (132b4e5d1 2021-04-13)`. The performance CPU governor was used for all benchmarks, and were run on A/C power with only tmux and Sublime Text open for all benchmarks. The floats that were parsed are as follows:\r\n\r\n```rust\r\n// Example fast-path value.\r\nconst FAST: &str = \"1.2345e22\";\r\n// Example disguised fast-path value.\r\nconst DISGUISED: &str = \"1.2345e30\";\r\n// Example moderate path value: clearly not halfway `1 << 53`.\r\nconst MODERATE: &str = \"9007199254740992.0\";\r\n// Example exactly-halfway value `(1<<53) + 1`.\r\nconst HALFWAY: &str = \"9007199254740993.0\";\r\n// Example large, near-halfway value.\r\nconst LARGE: &str = \"8.988465674311580536566680e307\";\r\n// Example denormal, near-halfway value.\r\nconst DENORMAL: &str = \"8.442911973260991817129021e-309\";\r\n```\r\n\r\n**core**\r\n\r\nThese are the benchmarks prior to making changes.\r\n\r\n|float|speed|\r\n|:-:|:-:|\r\n|fast|32.952ns|\r\n|disguised|129.86ns|\r\n|moderate|237.08ns|\r\n|halfway|371.21ns|\r\n|large|287.81us|\r\n|denormal|122.36us|\r\n\r\n**moderate**\r\n\r\nThese are the binary sizes after making changes to speed up the Bellerophon algorithm.\r\n\r\n|float|speed|\r\n|:-:|:-:|\r\n|fast|26.668ns|\r\n|disguised|34.599ns|\r\n|moderate|49.378ns|\r\n|halfway|224.81ns|\r\n|large|796.34ns|\r\n|denormal|63.763ns|\r\n\r\n# Correctness Concerns\r\n\r\nThere are a few correctness concerns, since this uses a potentially truncated representation of the significant digits for error calculation. I've therefore made the error detection stricter, so it rejects more [halfway cases](https://github.com/Alexhuszagh/rust-dec2flt/blob/ad4596cc85ee3647cb20d594651a6061b16ca6a9/src/dec2flt/algorithm.rs#L168-L184) than before and correctly compounds error with truncated cases and [non-normalized representations](https://github.com/Alexhuszagh/rust-dec2flt/blob/ad4596cc85ee3647cb20d594651a6061b16ca6a9/src/dec2flt/algorithm.rs#L186-L188) after multiplication.\r\n\r\nIn practice, this only rejects a [handful of cases](https://github.com/Alexhuszagh/rust-dec2flt/blob/ad4596cc85ee3647cb20d594651a6061b16ca6a9/tests/bellerophon.rs) that would be normally accept by the algorithm, with a major benefit to overall performance.\r\n\r\nI've also extended the powers-of-10 to handle [denormal floats](https://github.com/Alexhuszagh/rust-dec2flt/blob/ad4596cc85ee3647cb20d594651a6061b16ca6a9/src/dec2flt/table.rs#L4-L6), as well as values that could lead to Infinity, and updated the internal logic to ensure correct rounding.\r\n\r\nThis passes all of Rust's float parsing [tests](https://github.com/rust-lang/rust/blob/master/src/etc/test-float-parse/runtests.py), as well as carefully crafted examples to try to detect errors, and therefore is unlikely to have any correctness issues.\r\n\r\n# Sample Repository\r\n\r\nI've created a simple, minimal repository tracking these changes on [rust-dec2flt](https://github.com/Alexhuszagh/rust-dec2flt), which has a [core branch](https://github.com/Alexhuszagh/rust-dec2flt/tree/core) that is identical to Rust's current implementation in the core library. The [moderate branch](https://github.com/Alexhuszagh/rust-dec2flt/tree/moderate) contains the changes to improve parsing speeds for Bellerophon algorithm.  This currently relies on changes made to [infer binary exponents](https://github.com/rust-lang/rust/issues/85214), however, can be trivially re-written to explicitly store them.", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/85234/reactions", "total_count": 6, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 3, "eyes": 3}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/85234/timeline", "performed_via_github_app": null, "state_reason": "completed"}