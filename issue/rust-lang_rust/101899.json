{"url": "https://api.github.com/repos/rust-lang/rust/issues/101899", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/101899/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/101899/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/101899/events", "html_url": "https://github.com/rust-lang/rust/issues/101899", "id": 1375921764, "node_id": "I_kwDOAAsO6M5SAuZk", "number": 101899, "title": "#95295 causes unsoundness in multiple existing crates", "user": {"login": "LegionMammal978", "id": 7880963, "node_id": "MDQ6VXNlcjc4ODA5NjM=", "avatar_url": "https://avatars.githubusercontent.com/u/7880963?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LegionMammal978", "html_url": "https://github.com/LegionMammal978", "followers_url": "https://api.github.com/users/LegionMammal978/followers", "following_url": "https://api.github.com/users/LegionMammal978/following{/other_user}", "gists_url": "https://api.github.com/users/LegionMammal978/gists{/gist_id}", "starred_url": "https://api.github.com/users/LegionMammal978/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LegionMammal978/subscriptions", "organizations_url": "https://api.github.com/users/LegionMammal978/orgs", "repos_url": "https://api.github.com/users/LegionMammal978/repos", "events_url": "https://api.github.com/users/LegionMammal978/events{/privacy}", "received_events_url": "https://api.github.com/users/LegionMammal978/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 262252628, "node_id": "MDU6TGFiZWwyNjIyNTI2Mjg=", "url": "https://api.github.com/repos/rust-lang/rust/labels/regression-from-stable-to-beta", "name": "regression-from-stable-to-beta", "color": "e4008a", "default": false, "description": "Performance or correctness regression from stable to beta."}, {"id": 267612997, "node_id": "MDU6TGFiZWwyNjc2MTI5OTc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-unsound", "name": "I-unsound", "color": "e11d21", "default": false, "description": "Issue: A soundness hole (worst kind of bug), see: https://en.wikipedia.org/wiki/Soundness"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": {"url": "https://api.github.com/repos/rust-lang/rust/milestones/97", "html_url": "https://github.com/rust-lang/rust/milestone/97", "labels_url": "https://api.github.com/repos/rust-lang/rust/milestones/97/labels", "id": 8274783, "node_id": "MI_kwDOAAsO6M4AfkNf", "number": 97, "title": "1.65.0", "description": null, "creator": {"login": "rustbot", "id": 47979223, "node_id": "MDQ6VXNlcjQ3OTc5MjIz", "avatar_url": "https://avatars.githubusercontent.com/u/47979223?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rustbot", "html_url": "https://github.com/rustbot", "followers_url": "https://api.github.com/users/rustbot/followers", "following_url": "https://api.github.com/users/rustbot/following{/other_user}", "gists_url": "https://api.github.com/users/rustbot/gists{/gist_id}", "starred_url": "https://api.github.com/users/rustbot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rustbot/subscriptions", "organizations_url": "https://api.github.com/users/rustbot/orgs", "repos_url": "https://api.github.com/users/rustbot/repos", "events_url": "https://api.github.com/users/rustbot/events{/privacy}", "received_events_url": "https://api.github.com/users/rustbot/received_events", "type": "User", "site_admin": false}, "open_issues": 3, "closed_issues": 953, "state": "closed", "created_at": "2022-08-06T12:29:11Z", "updated_at": "2023-04-12T04:50:01Z", "due_on": null, "closed_at": "2022-11-03T14:43:27Z"}, "comments": 28, "created_at": "2022-09-16T13:02:59Z", "updated_at": "2022-12-06T23:06:11Z", "closed_at": "2022-11-09T16:12:38Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I was recently looking through the draft release notes when I noticed #95295. While it makes sense for `Layout::from_size_align()` to restrict allocations to `isize::MAX` bytes, this restriction was also added to `Layout::from_size_align_unchecked()`, which is a public and widely used API. Some crates were sound under the previous overflow property, usually panicking or returning an error after checking the `Layout` against `isize::MAX`. However, these have become unsound under the new overflow property, since just constructing the overlarge `Layout` is now UB. Also, some crates created overlarge layouts for the sole purpose of feeding them into `handle_alloc_error()`. To list the instances I've found:\r\n\r\n- The provided `GlobalAlloc::realloc()` impl in `core`:\r\n  ```rust\r\n  use std::alloc::{GlobalAlloc, Layout, System};\r\n  struct Alloc;\r\n  // SAFETY: Wraps `System`'s methods.\r\n  unsafe impl GlobalAlloc for Alloc {\r\n      unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\r\n          System.alloc(layout)\r\n      }\r\n      unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\r\n          System.dealloc(ptr, layout)\r\n      }\r\n  }\r\n  let alloc = Alloc;\r\n  // SAFETY: The layout has non-zero size.\r\n  let ptr = unsafe { alloc.alloc(Layout::new::<u8>()) };\r\n  assert!(!ptr.is_null());\r\n  // SAFETY:\r\n  // - `ptr` is currently allocated from `alloc`.\r\n  // - The layout is the same layout used to allocate `ptr`.\r\n  // - The new size is greater than zero.\r\n  // - The new size, rounded up to the alignment, is less than `usize::MAX`.\r\n  unsafe { alloc.realloc(ptr, Layout::new::<u8>(), isize::MAX as usize + 1) };\r\n  // calls Layout::from_size_align_unchecked(isize::MAX as usize + 1, 1)\r\n  // at <Alloc as core::alloc::GlobalAlloc>::realloc()\r\n  ```\r\n- `semver` v1.0.14:\r\n  ```rust\r\n  // --target i686-unknown-linux-gnu\r\n  use semver::BuildMetadata;\r\n  let s = String::from_utf8(vec![b'0'; isize::MAX as usize - 4]).unwrap();\r\n  s.parse::<BuildMetadata>().unwrap();\r\n  // calls Layout::from_size_align_unchecked(isize::MAX as usize + 1, 1)\r\n  // at semver::identifier::Identifier::new_unchecked()\r\n  ```\r\n- `hashbrown` v0.12.3:\r\n  ```rust\r\n  // features = [\"raw\"]\r\n  use hashbrown::raw::RawTable;\r\n  assert!(cfg!(target_feature = \"sse2\"));\r\n  RawTable::<u8>::with_capacity(usize::MAX / 64 * 7 + 8);\r\n  // calls Layout::from_size_align_unchecked(isize::MAX as usize + 17, 16)\r\n  // at hashbrown::raw::TableLayout::calculate_layout_for()\r\n  ```\r\n- `rusqlite` v0.28.0 (admittedly contrived):\r\n  ```rust\r\n  // --target i686-unknown-linux-gnu\r\n  // features = [\"bundled\", \"vtab\"]\r\n  use rusqlite::{\r\n      ffi,\r\n      vtab::{\r\n          self, sqlite3_vtab, sqlite3_vtab_cursor, Context, IndexInfo, VTab, VTabConnection,\r\n          VTabCursor, Values,\r\n      },\r\n      Connection,\r\n  };\r\n  use std::os::raw::c_int;\r\n  #[repr(C)]\r\n  struct DummyTab { base: sqlite3_vtab }\r\n  // SAFETY: `DummyTab` is `repr(C)` and starts with a `sqlite3_vtab`.\r\n  unsafe impl<'vtab> VTab<'vtab> for DummyTab {\r\n      type Aux = ();\r\n      type Cursor = DummyCursor;\r\n      fn connect(\r\n          _: &mut VTabConnection,\r\n          _: Option<&Self::Aux>,\r\n          _: &[&[u8]],\r\n      ) -> rusqlite::Result<(String, Self)> {\r\n          let s = String::from_utf8(vec![b'\\x01'; isize::MAX as usize]).unwrap();\r\n          Err(rusqlite::Error::SqliteFailure(ffi::Error::new(0), Some(s)))\r\n      }\r\n      fn best_index(&self, _: &mut IndexInfo) -> rusqlite::Result<()> { unimplemented!() }\r\n      fn open(&'vtab mut self) -> rusqlite::Result<Self::Cursor> { unimplemented!() }\r\n  }\r\n  #[repr(C)]\r\n  struct DummyCursor { base: sqlite3_vtab_cursor }\r\n  // SAFETY: `DummyCursor` is `repr(C)` and starts with a `sqlite3_vtab_cursor`.\r\n  unsafe impl VTabCursor for DummyCursor {\r\n      fn filter(&mut self, _: c_int, _: Option<&str>, _: &Values<'_>) -> rusqlite::Result<()> { unimplemented!() }\r\n      fn next(&mut self) -> rusqlite::Result<()> { unimplemented!() }\r\n      fn eof(&self) -> bool { unimplemented!() }\r\n      fn column(&self, _: &mut Context, _: c_int) -> rusqlite::Result<()> { unimplemented!() }\r\n      fn rowid(&self) -> rusqlite::Result<i64> { unimplemented!() }\r\n  }\r\n  let conn = Connection::open_in_memory().unwrap();\r\n  let module = vtab::eponymous_only_module::<DummyTab>();\r\n  conn.create_module(\"dummy\", module, None).unwrap();\r\n  conn.execute(\"SELECT * FROM dummy\", ()).unwrap();\r\n  // calls Layout::from_size_align_unchecked(isize::MAX as usize + 1, 1)\r\n  // at rusqlite::util::sqlite_string::SqliteMallocString::from_str()\r\n  ```\r\n- `allocator_api` v0.6.0:\r\n  ```rust\r\n  use allocator_api::RawVec;\r\n  let mut raw_vec: RawVec<u8> = RawVec::new();\r\n  raw_vec.reserve(0, isize::MAX as usize + 1);\r\n  // calls Layout::from_size_align_unchecked(isize::MAX as usize + 1, 1)\r\n  // at <core::alloc::Layout as allocator_api::libcore::alloc::LayoutExt>::repeat()\r\n  // at <core::alloc::Layout as allocator_api::libcore::alloc::LayoutExt>::array::<u8>()\r\n  // at allocator_api::liballoc::raw_vec::RawVec::<u8, allocator_api::global::Global>::reserve_internal()\r\n  ```\r\n- `pyembed` v0.22.0:\r\n  ```rust\r\n  // pyo3 = \"0.16.5\"\r\n  use pyembed::{MainPythonInterpreter, MemoryAllocatorBackend, OxidizedPythonInterpreterConfig};\r\n  use pyo3::types::PyByteArray;\r\n  let interpreter = MainPythonInterpreter::new(OxidizedPythonInterpreterConfig {\r\n      allocator_backend: MemoryAllocatorBackend::Rust,\r\n      set_missing_path_configuration: false,\r\n      ..Default::default()\r\n  })\r\n  .unwrap();\r\n  interpreter.with_gil(|py| {\r\n      let array = PyByteArray::new(py, b\"\");\r\n      array.resize(isize::MAX as usize - 15).unwrap();\r\n  });\r\n  // calls Layout::from_size_align_unchecked(isize::MAX as usize - 14, 16)\r\n  // at pyembed::pyalloc::rust_malloc()\r\n  ```\r\n- `cap` v0.1.1:\r\n  ```rust\r\n  use cap::Cap;\r\n  use std::alloc::{GlobalAlloc, Layout, System};\r\n  let alloc = Cap::new(System, usize::MAX);\r\n  // SAFETY: The layout has non-zero size.\r\n  let ptr = unsafe { alloc.alloc(Layout::new::<u8>()) };\r\n  assert!(!ptr.is_null());\r\n  // SAFETY:\r\n  // - `ptr` is currently allocated from `alloc`.\r\n  // - The layout is the same layout used to allocate `ptr`.\r\n  // - The new size is greater than zero.\r\n  // - The new size, rounded up to the alignment, is less than `usize::MAX`.\r\n  unsafe { alloc.realloc(ptr, Layout::new::<u8>(), isize::MAX as usize + 1) };\r\n  // calls Layout::from_size_align_unchecked(isize::MAX as usize + 1, 1)\r\n  // at <cap::Cap<std::alloc::System> as core::alloc::GlobalAlloc>::realloc()\r\n  ```\r\n- `scoped-arena` v0.4.1:\r\n  ```rust\r\n  use scoped_arena::Scope;\r\n  Scope::new().to_scope_many::<u8>(0, 0);\r\n  // calls Layout::from_size_align_unchecked(usize::MAX - 1, 1)\r\n  // at scoped_arena::Scope::<'_, scoped_arena::allocator_api::Global>::to_scope_many::<u8>()\r\n  ```\r\n\r\nAlso, many more crates were sound under the condition that `alloc::alloc()` always fails on allocations larger than `isize::MAX` bytes, but likely unsound if it were to successfully return an allocated pointer. Before #95295, they would either panic, return an error, or call `handle_alloc_error()` from `alloc()` failing to satisfy the overlarge request. Many of these crates have now become unconditionally unsound after the change.\r\n\r\n<details>\r\n<summary>Now-unsound crates that depended on overlarge alloc() failing</summary>\r\n\r\n- `bumpalo` v3.11.0:\r\n  ```rust\r\n  // debug-assertions = false\r\n  use bumpalo::Bump;\r\n  Bump::try_with_capacity(isize::MAX as usize + 1).unwrap_err();\r\n  // calls Layout::from_size_align_unchecked(isize::MAX as usize + 1, 1)\r\n  // at bumpalo::layout_from_size_align()\r\n  // at bumpalo::Bump::try_with_capacity()\r\n  ```\r\n- `async-task` v4.3.0:\r\n  ```rust\r\n  // --target i686-unknown-linux-gnu\r\n  use std::{future, mem, task::Waker};\r\n  const SIZE: usize = isize::MAX as usize - mem::size_of::<Option<Waker>>() - 10;\r\n  let _ = async_task::spawn(future::pending::<[u8; SIZE]>(), |_| {});\r\n  // calls Layout::from_size_align_unchecked(isize::MAX as usize - 2, 4)\r\n  // at async_task::utils::Layout::into_std()\r\n  // at async_task::raw::RawTask::<core::future::Pending<[u8; {_}]>, [u8; {_}], {closure}>::eval_task_layout()\r\n  ```\r\n- `zerocopy` v0.6.1:\r\n  ```rust\r\n  // features = [\"alloc\"]\r\n  use zerocopy::FromBytes;\r\n  u8::new_box_slice_zeroed(isize::MAX as usize + 1);\r\n  // calls Layout::from_size_align_unchecked(isize::MAX as usize + 1, 1)\r\n  // at <u8 as zerocopy::FromBytes>::new_box_slice_zeroed()\r\n  ```\r\n- `memsec` v0.6.2:\r\n  ```rust\r\n  // --target x86_64-unknown-linux-gnu\r\n  // libc = \"0.2.64\"\r\n  use libc::_SC_PAGESIZE;\r\n  // SAFETY: `_SC_PAGESIZE` is a valid `sysconf` argument.\r\n  let page_size = unsafe { libc::sysconf(_SC_PAGESIZE) as usize };\r\n  assert!(page_size != usize::MAX);\r\n  let size = isize::MAX as usize - page_size * 5 - 13;\r\n  // SAFETY: No preconditions.\r\n  unsafe { memsec::malloc_sized(size) };\r\n  // calls Layout::from_size_align_unchecked(isize::MAX as usize - page_size + 1, page_size)\r\n  // at memsec::alloc::raw_alloc::alloc_aligned()\r\n  ```\r\n- `bevy_ecs` v0.8.1:\r\n  ```rust\r\n  // --target i686-unknown-linux-gnu\r\n  use bevy_ecs::component::{Component, Components};\r\n  #[derive(Component)]\r\n  #[component(storage = \"SparseSet\")]\r\n  struct Data([u8; usize::MAX / 128 + 1]);\r\n  Components::default().init_component::<Data>(&mut Default::default());\r\n  // calls Layout::from_size_align_unchecked(isize::MAX as usize + 1, 1)\r\n  // at bevy_ecs::storage::blob_vec::repeat_layout()\r\n  // at bevy_ecs::storage::blob_vec::array_layout()\r\n  // at bevy_ecs::storage::blob_vec::BlobVec::grow_exact()\r\n  ```\r\n- `lasso` v0.6.0:\r\n  ```rust\r\n  // debug-assertions = false\r\n  use lasso::{Capacity, Rodeo};\r\n  let bytes = (isize::MAX as usize + 1).try_into().unwrap();\r\n  let _: Rodeo = Rodeo::with_capacity(Capacity::new(0, bytes));\r\n  // calls Layout::from_size_align_unchecked(isize::MAX as usize + 1, 1)\r\n  // at lasso::arena::Bucket::with_capacity()\r\n  ```\r\n- `thin-dst` v1.1.0:\r\n  ```rust\r\n  use thin_dst::ThinBox;\r\n  struct DummyIter;\r\n  impl Iterator for DummyIter {\r\n      type Item = u8;\r\n      fn next(&mut self) -> Option<Self::Item> {\r\n          unimplemented!()\r\n      }\r\n  }\r\n  impl ExactSizeIterator for DummyIter {\r\n      fn len(&self) -> usize {\r\n          isize::MAX as usize + 1\r\n      }\r\n  }\r\n  ThinBox::new((), DummyIter);\r\n  // calls Layout::from_size_align_unchecked(isize::MAX as usize + 1, 1)\r\n  // at thin_dst::polyfill::alloc_layout_extra::repeat_layout()\r\n  // at thin_dst::polyfill::alloc_layout_extra::layout_array::<u8>()\r\n  // at thin_dst::ThinBox::<(), u8>::layout()\r\n  ```\r\n- `lightproc` v0.3.5:\r\n  ```rust\r\n  // --target i686-unknown-linux-gnu\r\n  use lightproc::lightproc::LightProc;\r\n  use std::{\r\n      future::Future,\r\n      pin::Pin,\r\n      task::{Context, Poll},\r\n  };\r\n  #[repr(align(4))]\r\n  struct Dummy;\r\n  impl Future for Dummy {\r\n      type Output = [u8; isize::MAX as usize - 2];\r\n      fn poll(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Self::Output> {\r\n          unimplemented!()\r\n      }\r\n  }\r\n  LightProc::build(Dummy, |_| {}, Default::default());\r\n  // calls Layout::from_size_align_unchecked(isize::MAX as usize - 2, 4)\r\n  // at lightproc::raw_proc::RawProc::<Dummy, [u8; {_}], {closure}>::proc_layout()\r\n  ```\r\n- `thin-vec` v0.2.8:\r\n  ```rust\r\n  // --target x86_64-unknown-linux-gnu\r\n  use thin_vec::ThinVec;\r\n  ThinVec::<u8>::with_capacity(isize::MAX as usize - 21);\r\n  // calls Layout::from_size_align_unchecked(isize::MAX as usize - 6, 8)\r\n  // at thin_vec::layout::<u8>()\r\n  // at thin_vec::header_with_capacity::<u8>()\r\n  ```\r\n- `bsn1` v0.4.0:\r\n  ```rust\r\n  // --target i686-unknown-linux-gnu\r\n  use bsn1::{Der, IdRef};\r\n  struct Iter<'a>(Option<&'a [u8]>);\r\n  impl Clone for Iter<'_> {\r\n      fn clone(&self) -> Self {\r\n          Self(Some(&[0; 7]))\r\n      }\r\n  }\r\n  impl<'a> Iterator for Iter<'a> {\r\n      type Item = &'a [u8];\r\n      fn next(&mut self) -> Option<Self::Item> {\r\n          self.0.take()\r\n      }\r\n  }\r\n  let vec = vec![0; isize::MAX as usize - 1];\r\n  Der::from_id_iterator(IdRef::eoc(), Iter(Some(&vec)));\r\n  // calls Layout::from_size_align_unchecked(isize::MAX as usize + 1, 1)\r\n  // at bsn1::buffer::Buffer::reserve()\r\n  ```\r\n- `seckey` v0.11.2:\r\n  ```rust\r\n  // default-features = false\r\n  // features = [\"use_std\"]\r\n  use seckey::SecBytes;\r\n  SecBytes::new(isize::MAX as usize + 1);\r\n  // calls Layout::from_size_align_unchecked(isize::MAX as usize + 1, 1)\r\n  // at seckey::bytes::alloc::malloc_sized()\r\n  ```\r\n- `slice-dst` v1.5.1:\r\n  ```rust\r\n  use slice_dst::SliceDst;\r\n  <[u8]>::layout_for(isize::MAX as usize + 1);\r\n  // calls Layout::from_size_align_unchecked(isize::MAX as usize + 1, 1)\r\n  // at slice_dst::layout_polyfill::repeat_layout()\r\n  // at slice_dst::layout_polyfill::layout_array::<u8>()\r\n  // at <[u8] as slice_dst::SliceDst>::layout_for()\r\n  ```\r\n- `stable-vec` v0.4.0:\r\n  ```rust\r\n  use stable_vec::ExternStableVec;\r\n  ExternStableVec::<u16>::with_capacity(usize::MAX / 4 + 1);\r\n  // calls Layout::from_size_align_unchecked(isize::MAX as usize, 2)\r\n  // at <stable_vec::core::bitvec::BitVecCore<u16> as stable_vec::core::Core<u16>>::realloc()\r\n  ```\r\n</details>", "closed_by": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/101899/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/101899/timeline", "performed_via_github_app": null, "state_reason": "completed"}