{"url": "https://api.github.com/repos/rust-lang/rust/issues/99359", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/99359/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/99359/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/99359/events", "html_url": "https://github.com/rust-lang/rust/issues/99359", "id": 1306974678, "node_id": "I_kwDOAAsO6M5N5tnW", "number": 99359, "title": "riscv codegen for asm! macro generates a runtime error", "user": {"login": "justinnoah", "id": 443413, "node_id": "MDQ6VXNlcjQ0MzQxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/443413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/justinnoah", "html_url": "https://github.com/justinnoah", "followers_url": "https://api.github.com/users/justinnoah/followers", "following_url": "https://api.github.com/users/justinnoah/following{/other_user}", "gists_url": "https://api.github.com/users/justinnoah/gists{/gist_id}", "starred_url": "https://api.github.com/users/justinnoah/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/justinnoah/subscriptions", "organizations_url": "https://api.github.com/users/justinnoah/orgs", "repos_url": "https://api.github.com/users/justinnoah/repos", "events_url": "https://api.github.com/users/justinnoah/events{/privacy}", "received_events_url": "https://api.github.com/users/justinnoah/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 46741598, "node_id": "MDU6TGFiZWw0Njc0MTU5OA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/E-needs-test", "name": "E-needs-test", "color": "02e10c", "default": false, "description": "Call for participation: writing correctness tests"}, {"id": 91598611, "node_id": "MDU6TGFiZWw5MTU5ODYxMQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-inline-assembly", "name": "A-inline-assembly", "color": "f7e101", "default": false, "description": "Area: inline asm!(..)"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}, {"id": 1210355734, "node_id": "MDU6TGFiZWwxMjEwMzU1NzM0", "url": "https://api.github.com/repos/rust-lang/rust/labels/O-riscv", "name": "O-riscv", "color": "6e6ec0", "default": false, "description": "Target: RISC-V architecture"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2022-07-17T03:20:51Z", "updated_at": "2023-03-19T23:19:27Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "<!--\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\nalong with any information you feel relevant to replicating the bug.\n-->\n\nI tried this code:\n\n\n```rust\n#![no_std]\n#![no_main]\n\nuse core::arch::asm;\nuse core::panic::PanicInfo;\n\n#[panic_handler]\nfn panic(_info: &PanicInfo) -> ! {\n    loop { }\n}\n\n#[no_mangle]\nfn _start() -> ! {\n    let x: u8 = 0x47; // G\n    unsafe {\n        asm!(\"li t4, 0x10000000\", \"mv t5, {}\", \"sb t5, 0(t4)\", in(reg)x, options(nostack));\n        // asm!(\"li t4, 0x10000000\", \"li t5, 0x47\", \"sb t5, 0(t4)\"); // WORKS\n    }\n    loop { }\n}\n```\nWith the following config files:\n<details><summary>Config Files</summary>\n<p>\n<b>.cargo/config.toml</b>\n\n```\n[build]\nrustflags = [\"-C\", \"link-args=-T ../linker_scripts/rv64-qemu-virt.ld --oformat elf64-riscvlittle\"]\ntarget = \"riscv64gc-unknown-none-elf\"\n\n[unstable]\nbuild-std-features = [\"compiler-builtins-mem\"]\nbuild-std = [\"core\", \"compiler_builtins\"]\n\n[target.riscv64gc-unknown-none-elf]\nrunner = \"qemu-system-riscv64 -M virt -serial mon:stdio -nographic -bios \"\n````\n</p>\n<p><b>Cargo.toml</b>\n\n```\n[package]\nname = \"toy\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[profile.release]\npanic = \"abort\"\nopt-level = 3\nlto = true\n\n[profile.dev]\npanic = \"abort\"\nopt-level = 0\nlto = false\n```\n</p>\n<p><b>rv64-qemu-virt.ld</b>\n\n```\n/* Script for -z combreloc */\n/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n   Copying and distribution of this script, with or without modification,\n   are permitted in any medium without royalty provided the copyright\n   notice and this notice are preserved.  */\nOUTPUT_FORMAT(\"elf64-littleriscv\", \"elf64-littleriscv\",\n\t      \"elf64-littleriscv\")\nOUTPUT_ARCH(riscv)\nENTRY(_start)\nSEARCH_DIR(\"/usr/lib/riscv64-unknown-elf/lib\");\nMEMORY\n{\n    ram (wxa) : ORIGIN = 0x80000000, LENGTH = 0x8020000\n}\nSECTIONS\n{\n  /* Read-only sections, merged into text segment: */\n  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x10000)); . = SEGMENT_START(\"text-segment\", 0x10000) + SIZEOF_HEADERS;\n  .interp         : { *(.interp) }\n  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n  .hash           : { *(.hash) }\n  .gnu.hash       : { *(.gnu.hash) }\n  .dynsym         : { *(.dynsym) }\n  .dynstr         : { *(.dynstr) }\n  .gnu.version    : { *(.gnu.version) }\n  .gnu.version_d  : { *(.gnu.version_d) }\n  .gnu.version_r  : { *(.gnu.version_r) }\n  .rela.dyn       :\n    {\n      *(.rela.init)\n      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n      *(.rela.fini)\n      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n      *(.rela.ctors)\n      *(.rela.dtors)\n      *(.rela.got)\n      *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*)\n      *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*)\n      *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*)\n      *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*)\n      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n      PROVIDE_HIDDEN (__rela_iplt_start = .);\n      *(.rela.iplt)\n      PROVIDE_HIDDEN (__rela_iplt_end = .);\n    }\n  .rela.plt       :\n    {\n      *(.rela.plt)\n    }\n  .init           :\n  {\n    KEEP (*(SORT_NONE(.init)))\n  }\n  .plt            : { *(.plt) }\n  .iplt           : { *(.iplt) }\n  .text           :\n  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n  .fini           :\n  {\n    KEEP (*(SORT_NONE(.fini)))\n  }\n  PROVIDE (__etext = .);\n  PROVIDE (_etext = .);\n  PROVIDE (etext = .);\n  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n  .rodata1        : { *(.rodata1) }\n  .sdata2         :\n  {\n    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n  }\n  .sbss2          : { *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*) }\n  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n  /* Adjust the address for the data segment.  We want to adjust up to\n     the same address within the page on the next page up.  */\n  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n  /* Exception handling  */\n  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n  /* Thread Local Storage sections  */\n  .tdata\t  :\n   {\n     PROVIDE_HIDDEN (__tdata_start = .);\n     *(.tdata .tdata.* .gnu.linkonce.td.*)\n   }\n  .tbss\t\t  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n  .preinit_array    :\n  {\n    PROVIDE_HIDDEN (__preinit_array_start = .);\n    KEEP (*(.preinit_array))\n    PROVIDE_HIDDEN (__preinit_array_end = .);\n  }\n  .init_array    :\n  {\n    PROVIDE_HIDDEN (__init_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n    PROVIDE_HIDDEN (__init_array_end = .);\n  }\n  .fini_array    :\n  {\n    PROVIDE_HIDDEN (__fini_array_start = .);\n    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n    PROVIDE_HIDDEN (__fini_array_end = .);\n  }\n  .ctors          :\n  {\n    /* gcc uses crtbegin.o to find the start of\n       the constructors, so we make sure it is\n       first.  Because this is a wildcard, it\n       doesn't matter if the user does not\n       actually link against crtbegin.o; the\n       linker won't look for a file to match a\n       wildcard.  The wildcard also means that it\n       doesn't matter which directory crtbegin.o\n       is in.  */\n    KEEP (*crtbegin.o(.ctors))\n    KEEP (*crtbegin?.o(.ctors))\n    /* We don't want to include the .ctor section from\n       the crtend.o file until after the sorted ctors.\n       The .ctor section from the crtend file contains the\n       end of ctors marker and it must be last */\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n    KEEP (*(SORT(.ctors.*)))\n    KEEP (*(.ctors))\n  }\n  .dtors          :\n  {\n    KEEP (*crtbegin.o(.dtors))\n    KEEP (*crtbegin?.o(.dtors))\n    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n    KEEP (*(SORT(.dtors.*)))\n    KEEP (*(.dtors))\n  }\n  .jcr            : { KEEP (*(.jcr)) }\n  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n  .dynamic        : { *(.dynamic) }\n  . = DATA_SEGMENT_RELRO_END (0, .);\n  .data           :\n  {\n    __DATA_BEGIN__ = .;\n    *(.data .data.* .gnu.linkonce.d.*)\n    SORT(CONSTRUCTORS)\n  }\n  .data1          : { *(.data1) }\n  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n  /* We want the small data sections together, so single-instruction offsets\n     can access them all, and initialized data all before uninitialized, so\n     we can shorten the on-disk segment size.  */\n  .sdata          :\n  {\n    __SDATA_BEGIN__ = .;\n    *(.srodata.cst16) *(.srodata.cst8) *(.srodata.cst4) *(.srodata.cst2) *(.srodata .srodata.*)\n    *(.sdata .sdata.* .gnu.linkonce.s.*)\n  }\n  _edata = .; PROVIDE (edata = .);\n  . = .;\n  __bss_start = .;\n  .sbss           :\n  {\n    *(.dynsbss)\n    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n    *(.scommon)\n  }\n  .bss            :\n  {\n   *(.dynbss)\n   *(.bss .bss.* .gnu.linkonce.b.*)\n   *(COMMON)\n   /* Align here to ensure that the .bss section occupies space up to\n      _end.  Align after .bss to ensure correct alignment even if the\n      .bss section disappears because there are no input sections.\n      FIXME: Why do we need it? When there is no .bss section, we do not\n      pad the .data section.  */\n   . = ALIGN(. != 0 ? 64 / 8 : 1);\n  }\n  . = ALIGN(64 / 8);\n  . = SEGMENT_START(\"ldata-segment\", .);\n  . = ALIGN(64 / 8);\n  __BSS_END__ = .;\n    __global_pointer$ = MIN(__SDATA_BEGIN__ + 0x800,\n\t\t            MAX(__DATA_BEGIN__ + 0x800, __BSS_END__ - 0x800));\n  _end = .; PROVIDE (end = .);\n  . = DATA_SEGMENT_END (.);\n  /* Stabs debugging sections.  */\n  .stab          0 : { *(.stab) }\n  .stabstr       0 : { *(.stabstr) }\n  .stab.excl     0 : { *(.stab.excl) }\n  .stab.exclstr  0 : { *(.stab.exclstr) }\n  .stab.index    0 : { *(.stab.index) }\n  .stab.indexstr 0 : { *(.stab.indexstr) }\n  .comment       0 : { *(.comment) }\n  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n  /* DWARF debug sections.\n     Symbols in the DWARF debugging sections are relative to the beginning\n     of the section so we begin them at 0.  */\n  /* DWARF 1 */\n  .debug          0 : { *(.debug) }\n  .line           0 : { *(.line) }\n  /* GNU DWARF 1 extensions */\n  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n  .debug_sfnames  0 : { *(.debug_sfnames) }\n  /* DWARF 1.1 and DWARF 2 */\n  .debug_aranges  0 : { *(.debug_aranges) }\n  .debug_pubnames 0 : { *(.debug_pubnames) }\n  /* DWARF 2 */\n  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n  .debug_abbrev   0 : { *(.debug_abbrev) }\n  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n  .debug_frame    0 : { *(.debug_frame) }\n  .debug_str      0 : { *(.debug_str) }\n  .debug_loc      0 : { *(.debug_loc) }\n  .debug_macinfo  0 : { *(.debug_macinfo) }\n  /* SGI/MIPS DWARF 2 extensions */\n  .debug_weaknames 0 : { *(.debug_weaknames) }\n  .debug_funcnames 0 : { *(.debug_funcnames) }\n  .debug_typenames 0 : { *(.debug_typenames) }\n  .debug_varnames  0 : { *(.debug_varnames) }\n  /* DWARF 3 */\n  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n  .debug_ranges   0 : { *(.debug_ranges) }\n  /* DWARF Extension.  */\n  .debug_macro    0 : { *(.debug_macro) }\n  .debug_addr     0 : { *(.debug_addr) }\n  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n}\n```\n</p>\n</details>\n\nI expected to see this happen:\n\nThe letter 'G' printed\n\nInstead, this happened:\n\nThe 'G' is never printed\n\n### Meta\n<!--\nIf you're using the stable version of the compiler, you should also check if the\nbug also exists in the beta or nightly versions.\n-->\n\n`rustc --version --verbose`:\n```\nrustc 1.64.0-nightly (38b72154d 2022-07-11)\nbinary: rustc\ncommit-hash: 38b72154ded23847cd08a796d0c6708b5efac265\ncommit-date: 2022-07-11\nhost: x86_64-unknown-linux-gnu\nrelease: 1.64.0-nightly\nLLVM version: 14.0.6\n\n```\n\n<!--\nInclude a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\nenvironment. E.g. `RUST_BACKTRACE=1 cargo build`.\n-->\n<summary>Disasm: The Culprit</summary>\n<p>\n\n```\naddi sp,sp,-16\nli a0, 71\nsb a0,15(sp)\nlui t4,0x10000\nmv t5,a0\nsb t5,0(t4)\n```\n\nThe third line, `sb a0, 15(sp)` is the line that causes issues, as in once the line is executed, $pc is set to 0x0 and no further execution occurs. While stepping through with gdb, if $pc is manipulated to skip that line, the program prints the letter G.\n\n</p>\n\n\n<!-- TRIAGEBOT_START -->\n\n<!-- TRIAGEBOT_ASSIGN_START -->\n\n<!-- TRIAGEBOT_ASSIGN_DATA_START$${\"user\":null}$$TRIAGEBOT_ASSIGN_DATA_END -->\n\n<!-- TRIAGEBOT_ASSIGN_END -->\n<!-- TRIAGEBOT_END -->", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/99359/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/99359/timeline", "performed_via_github_app": null, "state_reason": null}