{"url": "https://api.github.com/repos/rust-lang/rust/issues/40192", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/40192/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/40192/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/40192/events", "html_url": "https://github.com/rust-lang/rust/issues/40192", "id": 211232400, "node_id": "MDU6SXNzdWUyMTEyMzI0MDA=", "number": 40192, "title": "Regression in done-0.0.0-reserve on Rust 1.17", "user": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 147085028, "node_id": "MDU6TGFiZWwxNDcwODUwMjg=", "url": "https://api.github.com/repos/rust-lang/rust/labels/regression-from-stable-to-nightly", "name": "regression-from-stable-to-nightly", "color": "e4008a", "default": false, "description": "Performance or correctness regression from stable to nightly."}, {"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2017-03-01T22:43:53Z", "updated_at": "2017-03-14T21:27:23Z", "closed_at": "2017-03-14T21:26:57Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "```\r\nbrian@ip-10-145-43-250:/mnt2/dev/strcursor\u27eb rustc +nightly -Vv\r\nrustc 1.17.0-nightly (be760566c 2017-02-28)\r\nbinary: rustc\r\ncommit-hash: be760566cf938d11d34c2f6bd90d8fd0f67c2344\r\ncommit-date: 2017-02-28\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.17.0-nightly\r\nLLVM version: 3.9\r\n```\r\n\r\n\r\nThe source is hard to acquire so here's an equivalent test case:\r\n\r\n```\r\nmod list {\r\n    use task::Task;\r\n\r\n    use std::fmt;\r\n\r\n    pub struct List {\r\n        pub tasks: Vec<Task>,\r\n    }\r\n\r\n    impl List {\r\n        pub fn to_plaintext(&mut self) -> String {\r\n            self.tasks.sort();\r\n            self.tasks.iter()\r\n                .map(|task| task.to_plaintext())\r\n                .collect::<Vec<_>>()\r\n                .join(\"\\n\")\r\n        }\r\n    }\r\n\r\n    impl fmt::Display for List {\r\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\r\n            let mut list_string = String::new();\r\n            list_string.push_str(\"List(\\n\");\r\n            for task in self.tasks.iter() {\r\n                list_string.push_str(format!(\"{}\", task).as_str());\r\n            }\r\n            list_string.push_str(\"\\n)\");\r\n            write!(f, \"{}\", list_string)\r\n        }\r\n    }\r\n\r\n    #[cfg(test)]\r\n    mod tests {\r\n        use super::*;\r\n        use task::*;\r\n\r\n        #[test]\r\n        fn test_list_to_plaintext() {\r\n            let mut list = List {\r\n                tasks: vec![\r\n                    Task { name: \"done\".to_string(), state: TaskState::Done },\r\n                    Task { name: \"blocked\".to_string(), state: TaskState::Blocked },\r\n                    Task { name: \"backlog\".to_string(), state: TaskState::Backlog },\r\n                    Task { name: \"current\".to_string(), state: TaskState::Current },\r\n                ],\r\n            };\r\n\r\n            // Should sort and return in correct order\r\n            let expected_list_str =\r\n                \"~ current\\n\\\r\n                 - backlog\\n\\\r\n                 = blocked\\n\\\r\n                 + done\";\r\n\r\n            assert_eq!(list.to_plaintext(), expected_list_str);\r\n        }\r\n    }\r\n}\r\n\r\nmod task {\r\n    use std::cmp::Ordering;\r\n    use std::error::Error;\r\n    use std::fmt;\r\n\r\n    #[derive(Debug,PartialEq)]\r\n    pub enum TaskError {\r\n        InvalidState(char),\r\n        Malformed,\r\n    }\r\n\r\n    impl fmt::Display for TaskError {\r\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\r\n            let description = self.description();\r\n\r\n            match *self {\r\n                TaskError::InvalidState(token) => write!(\r\n                    f,\r\n                    \"{}: {}\",\r\n                    description,\r\n                    token),\r\n                TaskError::Malformed => write!(\r\n                    f,\r\n                    \"{}\",\r\n                    description),\r\n            }\r\n        }\r\n    }\r\n\r\n    impl Error for TaskError {\r\n        fn description(&self) -> &str {\r\n            match *self {\r\n                TaskError::InvalidState(_) => \"Invalid token for task state\",\r\n                TaskError::Malformed => \"Malformed definition\",\r\n            }\r\n        }\r\n\r\n        fn cause(&self) -> Option<&Error> {\r\n            match *self {\r\n                TaskError::InvalidState(_) => None,\r\n                TaskError::Malformed => None,\r\n            }\r\n        }\r\n    }\r\n\r\n    #[derive(Debug,Eq,PartialEq,PartialOrd)]\r\n    pub enum TaskState {\r\n        Current,\r\n        Backlog,\r\n        Blocked,\r\n        Done,\r\n    }\r\n\r\n    impl TaskState {\r\n        pub fn from_char(c: char) -> Result<TaskState, TaskError> {\r\n            match c {\r\n                '~' => Result::Ok(TaskState::Current),\r\n                '-' => Result::Ok(TaskState::Backlog),\r\n                '=' => Result::Ok(TaskState::Blocked),\r\n                '+' => Result::Ok(TaskState::Done),\r\n                token @ _ => Result::Err(TaskError::InvalidState(token))\r\n            }\r\n        }\r\n\r\n        pub fn to_char(&self) -> char {\r\n            match *self {\r\n                TaskState::Current => '~',\r\n                TaskState::Backlog => '-',\r\n                TaskState::Blocked => '=',\r\n                TaskState::Done    => '+',\r\n            }\r\n        }\r\n\r\n        fn order_value(&self) -> u8 {\r\n            match *self {\r\n                TaskState::Current => 0,\r\n                TaskState::Backlog => 1,\r\n                TaskState::Blocked => 2,\r\n                TaskState::Done    => 3,\r\n            }\r\n        }\r\n    }\r\n\r\n    impl Ord for TaskState {\r\n        fn cmp(&self, other: &TaskState) -> Ordering {\r\n            self.order_value().cmp(&other.order_value())\r\n        }\r\n    }\r\n\r\n    #[derive(Debug,Eq,PartialEq,PartialOrd)]\r\n    pub struct Task {\r\n        pub name: String,\r\n        pub state: TaskState,\r\n    }\r\n\r\n    impl Task {\r\n        pub fn new(task_str: &str) -> Result<Task, TaskError> {\r\n            let mut lines = task_str.lines();\r\n            if lines.clone().count() == 0 {\r\n                return Result::Err(TaskError::Malformed)\r\n            }\r\n\r\n            // First line should always be the task name\r\n            let main_line = lines.next().unwrap();\r\n            let mut main_line_chars = main_line.chars();\r\n\r\n            // First character must be symbol for state\r\n            let state = try!(TaskState::from_char(main_line_chars.next().unwrap()));\r\n\r\n            let mut passed_leading_whitespace = false;\r\n            let mut name = String::new();\r\n\r\n            for next_char in main_line_chars {\r\n                // Skip the leading whitespace\r\n                if !passed_leading_whitespace {\r\n                    if next_char.is_whitespace() {\r\n                        continue;\r\n                    } else {\r\n                        passed_leading_whitespace = true;\r\n                    }\r\n                }\r\n\r\n                name.push(next_char)\r\n            }\r\n\r\n            Result::Ok(Task {\r\n                name: name,\r\n                state: state,\r\n            })\r\n        }\r\n\r\n        pub fn to_plaintext(&self) -> String {\r\n            format!(\"{} {}\", self.state.to_char(), self.name)\r\n        }\r\n    }\r\n\r\n    impl fmt::Display for Task {\r\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\r\n            write!(f, \"Task(state: {}, name: {})\", self.state.to_char(), self.name)\r\n        }\r\n    }\r\n\r\n    impl Ord for Task {\r\n        fn cmp(&self, other: &Task) -> Ordering {\r\n            let state_order = self.state.cmp(&other.state);\r\n\r\n            match state_order {\r\n                Ordering::Equal => self.name.cmp(&other.name),\r\n                _ => state_order,\r\n            }\r\n        }\r\n    }\r\n\r\n    #[cfg(test)]\r\n    mod tests {\r\n        use std::cmp::Ordering;\r\n        use std::collections::HashMap;\r\n        use super::*;\r\n\r\n        #[test]\r\n        fn test_task_state_to_char() {\r\n            assert_eq!(TaskState::Current.to_char(), '~');\r\n            assert_eq!(TaskState::Backlog.to_char(), '-');\r\n            assert_eq!(TaskState::Blocked.to_char(), '=');\r\n            assert_eq!(TaskState::Done.to_char(), '+');\r\n        }\r\n\r\n        #[test]\r\n        fn test_task_state_from_char() {\r\n            assert_eq!(TaskState::from_char('~').unwrap(), TaskState::Current);\r\n            assert_eq!(TaskState::from_char('-').unwrap(), TaskState::Backlog);\r\n            assert_eq!(TaskState::from_char('=').unwrap(), TaskState::Blocked);\r\n            assert_eq!(TaskState::from_char('+').unwrap(), TaskState::Done);\r\n            assert!(TaskState::from_char('!').is_err());\r\n        }\r\n\r\n        #[test]\r\n        fn test_task_state_ord() {\r\n            assert_eq!(TaskState::Current.cmp(&TaskState::Backlog), Ordering::Less);\r\n            assert_eq!(TaskState::Backlog.cmp(&TaskState::Blocked), Ordering::Less);\r\n            assert_eq!(TaskState::Blocked.cmp(&TaskState::Done), Ordering::Less);\r\n        }\r\n\r\n        #[test]\r\n        fn test_task_new_states() {\r\n            let mut valid_tasks = HashMap::new();\r\n            valid_tasks.insert(\"~ current task\", Task {\r\n                name: \"current task\".to_string(),\r\n                state: TaskState::Current,\r\n            });\r\n            valid_tasks.insert(\"- backlog task\", Task {\r\n                name: \"backlog task\".to_string(),\r\n                state: TaskState::Backlog,\r\n            });\r\n            valid_tasks.insert(\"= blocked task\", Task {\r\n                name: \"blocked task\".to_string(),\r\n                state: TaskState::Blocked,\r\n            });\r\n            valid_tasks.insert(\"+ done task\", Task {\r\n                name: \"done task\".to_string(),\r\n                state: TaskState::Done,\r\n            });\r\n\r\n            for (task_str, task) in valid_tasks {\r\n                assert_eq!(Task::new(task_str).unwrap(), task);\r\n            }\r\n\r\n            let mut invalid_tasks = HashMap::new();\r\n            invalid_tasks.insert(\"! task name\", TaskError::InvalidState('!'));\r\n            invalid_tasks.insert(\"\", TaskError::Malformed);\r\n\r\n            for (task_str, task) in invalid_tasks {\r\n                assert_eq!(Task::new(task_str).err().unwrap(), task);\r\n            }\r\n        }\r\n\r\n        #[test]\r\n        fn test_task_to_plaintext() {\r\n            let task = Task {\r\n                name: \"task name\".to_string(),\r\n                state: TaskState::Current,\r\n            };\r\n\r\n            assert_eq!(task.to_plaintext(), \"~ task name\");\r\n        }\r\n\r\n        #[test]\r\n        fn test_task_ord() {\r\n            let current_task = Task { name: \"current\".to_string(), state: TaskState::Current };\r\n            let backlog_task = Task { name: \"backlog\".to_string(), state: TaskState::Backlog };\r\n            let blocked_task = Task { name: \"blocked\".to_string(), state: TaskState::Blocked };\r\n            let done_task = Task { name: \"done\".to_string(), state: TaskState::Done };\r\n\r\n            assert_eq!(current_task.cmp(&backlog_task), Ordering::Less);\r\n            assert_eq!(backlog_task.cmp(&blocked_task), Ordering::Less);\r\n            assert_eq!(blocked_task.cmp(&done_task), Ordering::Less);\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n```\r\nbrian@ip-10-145-43-250:~/dev\u27eb ./test\r\n\r\nrunning 7 tests\r\ntest task::tests::test_task_ord ... ok\r\ntest task::tests::test_task_new_states ... ok\r\ntest task::tests::test_task_state_from_char ... ok\r\ntest list::tests::test_list_to_plaintext ... FAILED\r\ntest task::tests::test_task_state_ord ... ok\r\ntest task::tests::test_task_state_to_char ... ok\r\ntest task::tests::test_task_to_plaintext ... ok\r\n\r\nfailures:\r\n\r\n---- list::tests::test_list_to_plaintext stdout ----\r\n        thread 'list::tests::test_list_to_plaintext' panicked at 'assertion failed: `(left == right)` (left: `\"- backlog\\n= blocked\\n~ current\\n+ done\"`, right: `\"~ current\\n- backlog\\n= blocked\\n+ done\"`)', test.rs:55\r\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\r\n\r\n\r\nfailures:\r\n    list::tests::test_list_to_plaintext\r\n\r\ntest result: FAILED. 6 passed; 1 failed; 0 ignored; 0 measured\r\n```\r\n\r\nNot on 1.16.\r\n", "closed_by": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/40192/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/40192/timeline", "performed_via_github_app": null, "state_reason": "completed"}