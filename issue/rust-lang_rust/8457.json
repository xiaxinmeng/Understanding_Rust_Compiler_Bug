{"url": "https://api.github.com/repos/rust-lang/rust/issues/8457", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/8457/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/8457/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/8457/events", "html_url": "https://github.com/rust-lang/rust/issues/8457", "id": 17918396, "node_id": "MDU6SXNzdWUxNzkxODM5Ng==", "number": 8457, "title": "Compiler failure on (invalid) lifetime annotation.", "user": {"login": "orenbenkiki", "id": 68190, "node_id": "MDQ6VXNlcjY4MTkw", "avatar_url": "https://avatars.githubusercontent.com/u/68190?v=4", "gravatar_id": "", "url": "https://api.github.com/users/orenbenkiki", "html_url": "https://github.com/orenbenkiki", "followers_url": "https://api.github.com/users/orenbenkiki/followers", "following_url": "https://api.github.com/users/orenbenkiki/following{/other_user}", "gists_url": "https://api.github.com/users/orenbenkiki/gists{/gist_id}", "starred_url": "https://api.github.com/users/orenbenkiki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/orenbenkiki/subscriptions", "organizations_url": "https://api.github.com/users/orenbenkiki/orgs", "repos_url": "https://api.github.com/users/orenbenkiki/repos", "events_url": "https://api.github.com/users/orenbenkiki/events{/privacy}", "received_events_url": "https://api.github.com/users/orenbenkiki/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1775993, "node_id": "MDU6TGFiZWwxNzc1OTkz", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-lifetimes", "name": "A-lifetimes", "color": "f7e101", "default": false, "description": "Area: lifetime related"}, {"id": 9618520, "node_id": "MDU6TGFiZWw5NjE4NTIw", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-ICE", "name": "I-ICE", "color": "e10c02", "default": false, "description": "Issue: The compiler panicked, giving an Internal Compilation Error (ICE) \u2744\ufe0f"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2013-08-11T21:34:32Z", "updated_at": "2013-12-18T23:36:14Z", "closed_at": "2013-12-18T23:36:14Z", "author_association": "NONE", "active_lock_reason": null, "body": "The following code will crash rust 0.8-pre (74efdf6 2013-08-09 08:17:04 -0700) on host: x86_64-unknown-linux-gnu:\n\n``` rust\n/// Interns are an efficient representation of a string (also known as\n/// \"interned strings\", \"atoms\", \"symbols\", ...). They allow efficient\n/// comparison for equality, use as keys, etc.\n///\n/// The implementation in this module relies on the program to create a global\n/// interner and pass it to all the tasks. This ensures interns created\n/// anywhere in the program will be compatible (like the Erlang atom\n/// mechanism). TODO: It would be nice to do this in a safer way without\n/// requiring the program's cooperation.\nmod intern {\n\n    use extra::arc::RWArc;\n    use std::hashmap::HashMap;\n    use std::local_data;\n\n    static KEY_ARC_INTERNER: local_data::Key<RWArc<Interner>> = &local_data::Key;\n\n    /// Set the task local ARC for the global interner. This assumes \"someone\"\n    /// creates a single global interner and hands it off to each task. Once\n    /// this is done, interns created anywhere will be compatible with each\n    /// other. If this isn't done, \"bad things will happen\".\n    pub fn set_task_local_arc_interner(arc_interner: RWArc<Interner>) {\n        local_data::set(KEY_ARC_INTERNER, arc_interner)\n    }\n\n    /// An interner holds all the known strings, ensuring re-interning the same\n    /// string will always return the same intern.\n    struct Interner {\n        str_to_intern: HashMap<~str, Intern>,\n        id_to_str: ~[~str],\n    }\n\n    impl Interner {\n        /// Create a new empty interner. TODO: This should really be a\n        /// singleton (though we do create instances in tests...).\n        pub fn new() -> Interner {\n            Interner {\n                str_to_intern: HashMap::new(),\n                id_to_str: ~[]\n            }\n        }\n    }\n\n    /// An intern is an efficient representation of a string, allowing\n    /// efficient comparison for equality, use as keys, etc.\n    struct Intern {\n        id: uint,\n    }\n\n    impl TotalEq for Intern {\n        fn equals(&self, other: &Intern) -> bool {\n            self.id == other.id\n        }\n    }\n\n    impl Eq for Intern {\n        fn eq(&self, other: &Intern) -> bool {\n            self.id == other.id\n        }\n        fn ne(&self, other: &Intern) -> bool {\n            self.id != other.id\n        }\n    }\n\n    impl ToStr for Intern {\n        fn to_str(&self) -> ~str {\n            do local_data::get(KEY_ARC_INTERNER) |maybe_arc_interner| {\n                match maybe_arc_interner {\n                    None => fail!(\"no interner set for task\"),\n                    Some(arc_interner) => {\n                        do arc_interner.read |interner| {\n                            interner.id_to_str[self.id].clone()\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /// Intern a string using the task local interner.\n    pub fn intern(burrowed: &str) -> Intern {\n        do local_data::get(KEY_ARC_INTERNER) |maybe_arc_interner| {\n            match maybe_arc_interner {\n                None => fail!(\"no task local ARC for global interner\"),\n                Some(arc_interner) => {\n                    // OOPS: It would have been really nice if there was a way\n                    // to write_upgrade a RWArc, instead of having to break up\n                    // the code this way.\n                    // OOPS: The compiler fails to deduce the lifetime here.\n                    // OOPS: Ok, &'self makes no sense, but it causes the\n                    // compiler to crash - this shouldn't happen.\n                    let maybe_intern: &'self Option<&Intern> = do arc_interner.write |interner| {\n                        interner.str_to_intern.find(&burrowed.to_str())\n                    };\n                    match maybe_intern {\n                        Some(intern) => *intern,\n                        None => {\n                            // TRICKY: If we didn't find it above, we need\n                            // to get a write lock and re-find it, to\n                            // ensure no other task sneaked in and added it\n                            // between the above find and obtaining the\n                            // write lock below. This sort of race\n                            // condition is why one shouldn't write code\n                            // using locks unless it is *really* necessary.\n                            do arc_interner.write |mut_interner: &mut Interner| {\n                                let intern = do mut_interner.str_to_intern.find_or_insert_with(burrowed.to_str()) |owned| {\n                                    mut_interner.id_to_str.push(owned.clone());\n                                    Intern { id: mut_interner.id_to_str.len() - 1 }\n                                };\n                                *intern\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    #[test]\n    fn intern_strings() {\n        // TODO: This leaves the interner in the task local data after the test\n        // is run. Provide a \"do with_test_interner { ... }\" function?\n        set_task_local_arc_interner(RWArc::new(Interner::new()));\n        let foo = intern(\"foo\");\n        let bar = intern(\"bar\");\n        let baz = intern(\"foo\");\n        assert!(foo != bar);\n        assert!(foo == baz);\n        assert!(foo.to_str() == ~\"foo\");\n    }\n}\n```\n\nThere are 3 issues here (each with its own \"OOPS\" comment). First, what I'd really want to do is to be able to invoke RWArc.write inside an RWArc.read. Currently this causes a deadlock, which is arguably correct; however there's no RWArc.write_upgrade function which would work around the issue.\n\nOk, so I just split the code into two parts, one getting the read lock and returning a result, then a second taking the write lock if needed. Not a big deal (in this specific case, and one should try to avoid the whole lock thing anyway). The second problem is that when I did that (same code as above but without the lifetime annotation), the compiler failed to deduce the lifetime of the maybe_intern variable. Specifically, it said:\n\n```\nsrc/anthill/intern.rs:93:24: 94:21 error: cannot infer an appropriate lifetime due to conflicting requirements\nsrc/anthill/intern.rs:93                         interner.str_to_intern.find(&burrowed.to_str())\nsrc/anthill/intern.rs:94                     };\nsrc/anthill/intern.rs:93:24: 93:46 note: first, the lifetime cannot outlive the expression at 93:24...\nsrc/anthill/intern.rs:93                         interner.str_to_intern.find(&burrowed.to_str())\n                                                 ^~~~~~~~~~~~~~~~~~~~~~\nsrc/anthill/intern.rs:93:24: 93:46 note: ...due to the following expression\nsrc/anthill/intern.rs:93                         interner.str_to_intern.find(&burrowed.to_str())\n                                                 ^~~~~~~~~~~~~~~~~~~~~~\nsrc/anthill/intern.rs:93:24: 94:21 note: but, the lifetime must be valid for the method call at 93:24...\nsrc/anthill/intern.rs:93                         interner.str_to_intern.find(&burrowed.to_str())\nsrc/anthill/intern.rs:94                     };\nsrc/anthill/intern.rs:93:24: 93:46 note: ...due to the following expression\nsrc/anthill/intern.rs:93                         interner.str_to_intern.find(&burrowed.to_str())\n                                                 ^~~~~~~~~~~~~~~~~~~~~~\nerror: aborting due to previous error\n```\n\nSo, I tried adding a lifetime annotation myself. Admittedly, `&'self` doesn't make sense here. Even so, one would expect an error message; instead I got (with RUST_LOG set as requested):\n\n```\ntask <unnamed> failed at 'assertion failed: rp.is_none()', /home/oren/Rust/rust/src/librustc/middle/typeck/collect.rs:1061\nerror: internal compiler error: unexpected failure\nnote: the compiler hit an unexpected failure path. this is a bug\nnote: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues\ntask <unnamed> failed at 'explicit failure', /home/oren/Rust/rust/src/librustc/rustc.rs:375\n```\n\nSo:\n- It would be nice if Rust had Erlang-like (global) atoms :-)\n- Can't upgrade RWArc read lock to a write lock (a library problem?)\n- Can't infer lifetime for a variable when it seems it should be able to (a compiler problem?)\n- Crash when given an (invalid) lifetime annotation (definitely a compiler problem)\n\nBTW, what _should_ I put in the lifetime annotation there? Rust newbie here :-)\n", "closed_by": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/8457/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/8457/timeline", "performed_via_github_app": null, "state_reason": "completed"}