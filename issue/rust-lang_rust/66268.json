{"url": "https://api.github.com/repos/rust-lang/rust/issues/66268", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/66268/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/66268/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/66268/events", "html_url": "https://github.com/rust-lang/rust/issues/66268", "id": 520593079, "node_id": "MDU6SXNzdWU1MjA1OTMwNzk=", "number": 66268, "title": "Iterator and compiler auto-vectorization issue", "user": {"login": "marmeladema", "id": 1629419, "node_id": "MDQ6VXNlcjE2Mjk0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1629419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marmeladema", "html_url": "https://github.com/marmeladema", "followers_url": "https://api.github.com/users/marmeladema/followers", "following_url": "https://api.github.com/users/marmeladema/following{/other_user}", "gists_url": "https://api.github.com/users/marmeladema/gists{/gist_id}", "starred_url": "https://api.github.com/users/marmeladema/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marmeladema/subscriptions", "organizations_url": "https://api.github.com/users/marmeladema/orgs", "repos_url": "https://api.github.com/users/marmeladema/repos", "events_url": "https://api.github.com/users/marmeladema/events{/privacy}", "received_events_url": "https://api.github.com/users/marmeladema/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 234956, "node_id": "MDU6TGFiZWwyMzQ5NTY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-codegen", "name": "A-codegen", "color": "f7e101", "default": false, "description": "Area: Code generation"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2019-11-10T12:14:22Z", "updated_at": "2022-07-06T01:50:24Z", "closed_at": "2022-07-06T01:50:24Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Hello everyone!\r\n\r\nI've been trying to understand how can a basic byte replace loop could be substantially faster when copying the input and replacing in the copy rather than just replacing in place:\r\n```Rust\r\n// In-place byte replace\r\npub fn replace1_mut(input: &mut [u8], from: u8, to: u8) {\r\n    input.iter_mut().for_each(|b| {\r\n        if *b == from {\r\n            *b = to\r\n        }\r\n    });\r\n}\r\n\r\n// Copy and byte replace\r\npub fn replace1(input: &[u8], from: u8, to: u8) -> Vec<u8> {\r\n    let mut replaced = Vec::with_capacity(input.len());\r\n    replaced.extend(\r\n        input\r\n            .iter()\r\n            .map(|&b| if b == from { to } else { b }),\r\n    );\r\n    replaced\r\n}\r\n```\r\n\r\nUsing `criterion` crate, i wrote some benchmarks, ran them on an isolated physical core of my laptop. With the in-place version, i get a throughput of `1.3274 GiB/s` whereas with the copy version, i get a throughput of `4.7559 GiB/s`. This is a huge difference. I tried rewriting the in-place version with a for-loop:\r\n```Rust\r\npub fn replace1_mut(input: &mut [u8], from: u8, to: u8) {\r\n    for b in input.iter_mut() {\r\n        if *b == from {\r\n            *b = to;\r\n        }\r\n    }\r\n}\r\n```\r\nBut performance did not change. I then looked at the assembly code using godbolt.\r\nIn-place version generates: https://rust.godbolt.org/z/h97_97\r\n```Assembly\r\nexample::replace1_mut:\r\n        test    rsi, rsi\r\n        je      .LBB0_41\r\n        mov     r9, rdi\r\n        cmp     rsi, 16\r\n        jb      .LBB0_37\r\n        mov     r8, rsi\r\n        and     r8, -16\r\n        lea     r9, [rdi + r8]\r\n        movzx   eax, dl\r\n        movd    xmm0, eax\r\n        punpcklbw       xmm0, xmm0\r\n        pshuflw xmm0, xmm0, 224\r\n        pshufd  xmm0, xmm0, 0\r\n        xor     r10d, r10d\r\n        jmp     .LBB0_3\r\n.LBB0_35:\r\n        add     r10, 16\r\n        cmp     r8, r10\r\n        je      .LBB0_36\r\n.LBB0_3:\r\n        movdqu  xmm1, xmmword ptr [rdi + r10]\r\n        pcmpeqb xmm1, xmm0\r\n        movd    r11d, xmm1\r\n        test    r11b, 1\r\n        jne     .LBB0_4\r\n        mov     eax, r11d\r\n        shr     eax, 8\r\n        test    al, 1\r\n        jne     .LBB0_6\r\n.LBB0_7:\r\n        mov     eax, r11d\r\n        shr     eax, 16\r\n        test    al, 1\r\n        jne     .LBB0_8\r\n.LBB0_9:\r\n        shr     r11d, 24\r\n        test    r11b, 1\r\n        jne     .LBB0_10\r\n.LBB0_11:\r\n        pextrw  eax, xmm1, 2\r\n        test    al, 1\r\n        jne     .LBB0_12\r\n.LBB0_13:\r\n        shr     eax, 8\r\n        test    al, 1\r\n        jne     .LBB0_14\r\n.LBB0_15:\r\n        pextrw  eax, xmm1, 3\r\n        test    al, 1\r\n        jne     .LBB0_16\r\n.LBB0_17:\r\n        shr     eax, 8\r\n        test    al, 1\r\n        jne     .LBB0_18\r\n.LBB0_19:\r\n        pextrw  eax, xmm1, 4\r\n        test    al, 1\r\n        jne     .LBB0_20\r\n.LBB0_21:\r\n        shr     eax, 8\r\n        test    al, 1\r\n        jne     .LBB0_22\r\n.LBB0_23:\r\n        pextrw  eax, xmm1, 5\r\n        test    al, 1\r\n        jne     .LBB0_24\r\n.LBB0_25:\r\n        shr     eax, 8\r\n        test    al, 1\r\n        jne     .LBB0_26\r\n.LBB0_27:\r\n        pextrw  eax, xmm1, 6\r\n        test    al, 1\r\n        jne     .LBB0_28\r\n.LBB0_29:\r\n        shr     eax, 8\r\n        test    al, 1\r\n        jne     .LBB0_30\r\n.LBB0_31:\r\n        pextrw  eax, xmm1, 7\r\n        test    al, 1\r\n        jne     .LBB0_32\r\n.LBB0_33:\r\n        shr     eax, 8\r\n        test    al, 1\r\n        je      .LBB0_35\r\n        jmp     .LBB0_34\r\n.LBB0_4:\r\n        mov     byte ptr [rdi + r10], cl\r\n        mov     eax, r11d\r\n        shr     eax, 8\r\n        test    al, 1\r\n        je      .LBB0_7\r\n.LBB0_6:\r\n        mov     byte ptr [rdi + r10 + 1], cl\r\n        mov     eax, r11d\r\n        shr     eax, 16\r\n        test    al, 1\r\n        je      .LBB0_9\r\n.LBB0_8:\r\n        mov     byte ptr [rdi + r10 + 2], cl\r\n        shr     r11d, 24\r\n        test    r11b, 1\r\n        je      .LBB0_11\r\n.LBB0_10:\r\n        mov     byte ptr [rdi + r10 + 3], cl\r\n        pextrw  eax, xmm1, 2\r\n        test    al, 1\r\n        je      .LBB0_13\r\n.LBB0_12:\r\n        mov     byte ptr [rdi + r10 + 4], cl\r\n        shr     eax, 8\r\n        test    al, 1\r\n        je      .LBB0_15\r\n.LBB0_14:\r\n        mov     byte ptr [rdi + r10 + 5], cl\r\n        pextrw  eax, xmm1, 3\r\n        test    al, 1\r\n        je      .LBB0_17\r\n.LBB0_16:\r\n        mov     byte ptr [rdi + r10 + 6], cl\r\n        shr     eax, 8\r\n        test    al, 1\r\n        je      .LBB0_19\r\n.LBB0_18:\r\n        mov     byte ptr [rdi + r10 + 7], cl\r\n        pextrw  eax, xmm1, 4\r\n        test    al, 1\r\n        je      .LBB0_21\r\n.LBB0_20:\r\n        mov     byte ptr [rdi + r10 + 8], cl\r\n        shr     eax, 8\r\n        test    al, 1\r\n        je      .LBB0_23\r\n.LBB0_22:\r\n        mov     byte ptr [rdi + r10 + 9], cl\r\n        pextrw  eax, xmm1, 5\r\n        test    al, 1\r\n        je      .LBB0_25\r\n.LBB0_24:\r\n        mov     byte ptr [rdi + r10 + 10], cl\r\n        shr     eax, 8\r\n        test    al, 1\r\n        je      .LBB0_27\r\n.LBB0_26:\r\n        mov     byte ptr [rdi + r10 + 11], cl\r\n        pextrw  eax, xmm1, 6\r\n        test    al, 1\r\n        je      .LBB0_29\r\n.LBB0_28:\r\n        mov     byte ptr [rdi + r10 + 12], cl\r\n        shr     eax, 8\r\n        test    al, 1\r\n        je      .LBB0_31\r\n.LBB0_30:\r\n        mov     byte ptr [rdi + r10 + 13], cl\r\n        pextrw  eax, xmm1, 7\r\n        test    al, 1\r\n        je      .LBB0_33\r\n.LBB0_32:\r\n        mov     byte ptr [rdi + r10 + 14], cl\r\n        shr     eax, 8\r\n        test    al, 1\r\n        je      .LBB0_35\r\n.LBB0_34:\r\n        mov     byte ptr [rdi + r10 + 15], cl\r\n        jmp     .LBB0_35\r\n.LBB0_36:\r\n        cmp     r8, rsi\r\n        je      .LBB0_41\r\n.LBB0_37:\r\n        add     rdi, rsi\r\n        lea     rax, [r9 + 1]\r\n        cmp     byte ptr [r9], dl\r\n        je      .LBB0_39\r\n.LBB0_40:\r\n        mov     r9, rax\r\n        cmp     rdi, rax\r\n        je      .LBB0_41\r\n.LBB0_38:\r\n        lea     rax, [r9 + 1]\r\n        cmp     byte ptr [r9], dl\r\n        jne     .LBB0_40\r\n.LBB0_39:\r\n        mov     byte ptr [r9], cl\r\n        mov     r9, rax\r\n        cmp     rdi, rax\r\n        jne     .LBB0_38\r\n.LBB0_41:\r\n        ret\r\n```\r\nwhereas copy version generates: https://godbolt.org/z/9-6p96\r\n```Assembly\r\nexample::replace1:\r\n        push    rbp\r\n        push    r15\r\n        push    r14\r\n        push    r12\r\n        push    rbx\r\n        sub     rsp, 32\r\n        mov     r12d, r8d\r\n        mov     ebp, ecx\r\n        mov     r15, rdx\r\n        mov     rbx, rsi\r\n        mov     r14, rdi\r\n        test    rdx, rdx\r\n        je      .LBB0_1\r\n        mov     esi, 1\r\n        mov     rdi, r15\r\n        call    qword ptr [rip + __rust_alloc@GOTPCREL]\r\n        test    rax, rax\r\n        jne     .LBB0_3\r\n        mov     esi, 1\r\n        mov     rdi, r15\r\n        call    qword ptr [rip + alloc::alloc::handle_alloc_error@GOTPCREL]\r\n        ud2\r\n.LBB0_1:\r\n        mov     eax, 1\r\n.LBB0_3:\r\n        mov     qword ptr [rsp + 8], rax\r\n        mov     qword ptr [rsp + 16], r15\r\n        mov     qword ptr [rsp + 24], 0\r\n        test    r15, r15\r\n        je      .LBB0_4\r\n        lea     r9, [rbx + r15]\r\n        movzx   edx, r12b\r\n        cmp     r15, 32\r\n        jae     .LBB0_7\r\n        mov     rsi, rbx\r\n        jmp     .LBB0_15\r\n.LBB0_4:\r\n        xor     r9d, r9d\r\n        jmp     .LBB0_18\r\n.LBB0_7:\r\n        mov     rsi, r15\r\n        and     rsi, -32\r\n        movzx   ecx, bpl\r\n        movd    xmm0, ecx\r\n        punpcklbw       xmm0, xmm0\r\n        pshuflw xmm0, xmm0, 224\r\n        pshufd  xmm0, xmm0, 0\r\n        movd    xmm1, edx\r\n        punpcklbw       xmm1, xmm1\r\n        pshuflw xmm1, xmm1, 224\r\n        pshufd  xmm1, xmm1, 0\r\n        lea     rdi, [rsi - 32]\r\n        mov     rcx, rdi\r\n        shr     rcx, 5\r\n        add     rcx, 1\r\n        mov     r8d, ecx\r\n        and     r8d, 1\r\n        test    rdi, rdi\r\n        je      .LBB0_8\r\n        sub     rcx, r8\r\n        xor     edi, edi\r\n.LBB0_10:\r\n        movdqu  xmm2, xmmword ptr [rbx + rdi]\r\n        movdqu  xmm3, xmmword ptr [rbx + rdi + 16]\r\n        movdqa  xmm4, xmm2\r\n        pcmpeqb xmm4, xmm0\r\n        movdqa  xmm5, xmm3\r\n        pcmpeqb xmm5, xmm0\r\n        movdqa  xmm6, xmm1\r\n        pand    xmm6, xmm4\r\n        pandn   xmm4, xmm2\r\n        por     xmm4, xmm6\r\n        movdqa  xmm2, xmm1\r\n        pand    xmm2, xmm5\r\n        pandn   xmm5, xmm3\r\n        por     xmm5, xmm2\r\n        movdqu  xmmword ptr [rax + rdi], xmm4\r\n        movdqu  xmmword ptr [rax + rdi + 16], xmm5\r\n        movdqu  xmm2, xmmword ptr [rbx + rdi + 32]\r\n        movdqu  xmm3, xmmword ptr [rbx + rdi + 48]\r\n        movdqa  xmm4, xmm2\r\n        pcmpeqb xmm4, xmm0\r\n        movdqa  xmm5, xmm3\r\n        pcmpeqb xmm5, xmm0\r\n        movdqa  xmm6, xmm1\r\n        pand    xmm6, xmm4\r\n        pandn   xmm4, xmm2\r\n        por     xmm4, xmm6\r\n        movdqa  xmm2, xmm1\r\n        pand    xmm2, xmm5\r\n        pandn   xmm5, xmm3\r\n        por     xmm5, xmm2\r\n        movdqu  xmmword ptr [rax + rdi + 32], xmm4\r\n        movdqu  xmmword ptr [rax + rdi + 48], xmm5\r\n        add     rdi, 64\r\n        add     rcx, -2\r\n        jne     .LBB0_10\r\n        test    r8, r8\r\n        je      .LBB0_13\r\n.LBB0_12:\r\n        movdqu  xmm2, xmmword ptr [rbx + rdi]\r\n        movdqu  xmm3, xmmword ptr [rbx + rdi + 16]\r\n        movdqa  xmm4, xmm2\r\n        pcmpeqb xmm4, xmm0\r\n        pcmpeqb xmm0, xmm3\r\n        movdqa  xmm5, xmm1\r\n        pand    xmm5, xmm4\r\n        pandn   xmm4, xmm2\r\n        por     xmm4, xmm5\r\n        pand    xmm1, xmm0\r\n        pandn   xmm0, xmm3\r\n        por     xmm0, xmm1\r\n        movdqu  xmmword ptr [rax + rdi], xmm4\r\n        movdqu  xmmword ptr [rax + rdi + 16], xmm0\r\n.LBB0_13:\r\n        cmp     rsi, r15\r\n        je      .LBB0_17\r\n        add     rax, rsi\r\n        add     rsi, rbx\r\n.LBB0_15:\r\n        sub     r15, rsi\r\n        add     r15, rbx\r\n        xor     ecx, ecx\r\n.LBB0_16:\r\n        movzx   edi, byte ptr [rsi + rcx]\r\n        cmp     dil, bpl\r\n        cmove   edi, edx\r\n        mov     byte ptr [rax + rcx], dil\r\n        add     rcx, 1\r\n        cmp     r15, rcx\r\n        jne     .LBB0_16\r\n.LBB0_17:\r\n        sub     r9, rbx\r\n.LBB0_18:\r\n        mov     qword ptr [rsp + 24], r9\r\n        mov     qword ptr [r14 + 16], r9\r\n        movups  xmm0, xmmword ptr [rsp + 8]\r\n        movups  xmmword ptr [r14], xmm0\r\n        mov     rax, r14\r\n        add     rsp, 32\r\n        pop     rbx\r\n        pop     r12\r\n        pop     r14\r\n        pop     r15\r\n        pop     rbp\r\n        ret\r\n.LBB0_8:\r\n        xor     edi, edi\r\n        test    r8, r8\r\n        jne     .LBB0_12\r\n        jmp     .LBB0_13\r\n``` \r\n`LBB0_10` and `LBB0_12` section correspond to the map call.\r\n\r\nIt seems to me than the in-place version does not get properly auto-vectorized by the compiler which leads to bad performance. I thougt at the beginning it could be a specific llvm issue but then i tried directly looking as assembly from a regular C impl compiled with clang: https://godbolt.org/z/rMD3z6 and it does get properly auto-vectorized.\r\n\r\nI don't know if its really a bug, or a known compiler limitation, but its has a real impact on perfornance.", "closed_by": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/66268/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/66268/timeline", "performed_via_github_app": null, "state_reason": "not_planned"}