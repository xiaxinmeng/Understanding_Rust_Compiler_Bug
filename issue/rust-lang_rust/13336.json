{"url": "https://api.github.com/repos/rust-lang/rust/issues/13336", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/13336/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/13336/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/13336/events", "html_url": "https://github.com/rust-lang/rust/issues/13336", "id": 30910368, "node_id": "MDU6SXNzdWUzMDkxMDM2OA==", "number": 13336, "title": "libnative does not handle fds with O_NONBLOCK", "user": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 34, "created_at": "2014-04-05T07:13:14Z", "updated_at": "2015-01-21T20:06:59Z", "closed_at": "2015-01-21T20:06:59Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "libnative does not detect when a read/write fails due to `O_NONBLOCK` being set on the fd. It makes the assumption that all of its files never have that flag set, because it never sets that flag on them. Unfortunately, this isn't necessarily the case. FIFOs and character device files (e.g. terminals) will actually share the `O_NONBLOCK` flag among all processes that have the same open file description (e.g. the underlying kernel object that backs the fd).\n\nUsing a tiny C program that uses `fcntl()` to set `O_NONBLOCK` on its stdout, a FIFO, and a Rust program that writes 32k of output to stdout, I can reproduce this issue 100% of the time. The invocation looks like\n\n```\n> (./mknblock; ./rust_program) > fifo\n```\n\nand on the reading side I just do\n\n```\n> (sleep 1; cat) < fifo\n```\n\nThis causes the rust program to return a \"Resource temporarily unavailable\" error from `stdout.write()` after writing 8k of output. Removing the call to `./mknblock` restores the expected behavior where the rust program will block until the reading side has started consuming input. And further, switching the rust program over to libgreen also causes it to block even with `./mknblock`.\n\n---\n\nThe C program looks like this:\n\n``` C\n#include <fcntl.h>\n#include <stdio.h>\n\nint main() {\n    if (fcntl(1, F_SETFL, O_NONBLOCK) == -1) {\n        perror(\"fcntl\");\n        return 1;\n    }\n    return 0;\n}\n```\n\nThe Rust program is a bit longer, mostly because it prints out information about stdout before it begins writing. It looks like this:\n\n``` rust\nextern crate green;\nextern crate rustuv;\n\nuse std::io;\nuse std::io::IoResult;\nuse std::libc;\nuse std::os;\nuse std::mem;\n\nstatic O_NONBLOCK: libc::c_int = 0x0004;\nstatic O_APPEND: libc::c_int = 0x0008;\nstatic O_ASYNC: libc::c_int = 0x0040;\n\nstatic F_GETFL: libc::c_int = 3;\n\nunsafe fn print_flags(fd: libc::c_int) -> IoResult<()> {\n    let mut stat: libc::stat = mem::uninit();\n    if libc::fstat(fd, &mut stat) < 0 {\n        try!(writeln!(&mut io::stderr(), \"fstat: {}\", os::last_os_error()));\n        libc::exit(1);\n    }\n\n    try!(writeln!(&mut io::stderr(), \"stdout: dev={}, ino={}\", stat.st_dev, stat.st_ino));\n\n    let flags = libc::fcntl(fd, F_GETFL);\n    if flags == -1 {\n        try!(writeln!(&mut io::stderr(), \"fcntl: {}\", os::last_os_error()));\n        libc::exit(1);\n    }\n\n    let mut v = Vec::new();\n    if flags & O_NONBLOCK != 0 {\n        v.push(\"nonblock\");\n    }\n    if flags & O_APPEND != 0 {\n        v.push(\"append\");\n    }\n    if flags & O_ASYNC != 0 {\n        v.push(\"async\");\n    }\n\n    try!(writeln!(&mut io::stderr(), \"flags: {}\", v.connect(\", \")));\n    Ok(())\n}\n\nfn run() -> IoResult<()> {\n    unsafe { try!(print_flags(1)); }\n\n    let mut out = io::stdio::stdout_raw();\n    for i in range(0u, 32) {\n        try!(writeln!(&mut io::stderr(), \"Writing chunk {}...\", i));\n        let mut buf = ['x' as u8, ..1024];\n        buf[1023] = '\\n' as u8;\n        match out.write(buf) {\n            Ok(()) => (),\n            Err(e) => {\n                try!(writeln!(&mut io::stderr(), \"Error writing chunk {}\", i));\n                return Err(e);\n            }\n        }\n    }\n    Ok(())\n}\n\nfn main() {\n    match run() {\n        Err(e) => {\n            (writeln!(&mut io::stderr(), \"Error: {}\", e)).unwrap();\n            os::set_exit_status(1);\n        }\n        Ok(()) => ()\n    }\n}\n\nunsafe fn arg_is_dash_g(arg: *u8) -> bool {\n    *arg == '-' as u8 &&\n        *arg.offset(1) == 'g' as u8 &&\n        *arg.offset(2) == 0\n}\n\n#[start]\nfn start(argc: int, argv: **u8) -> int {\n    if argc > 1 && unsafe { arg_is_dash_g(*argv.offset(1)) } {\n        green::start(argc, argv, rustuv::event_loop, main)\n    } else {\n        native::start(argc, argv, main)\n    }\n}\n```\n", "closed_by": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/13336/reactions", "total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 1, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/13336/timeline", "performed_via_github_app": null, "state_reason": "completed"}