{"url": "https://api.github.com/repos/rust-lang/rust/issues/54060", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/54060/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/54060/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/54060/events", "html_url": "https://github.com/rust-lang/rust/issues/54060", "id": 358303532, "node_id": "MDU6SXNzdWUzNTgzMDM1MzI=", "number": 54060, "title": "Treat closures as `move` when their type escapes their captures' scope.", "user": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 122406831, "node_id": "MDU6TGFiZWwxMjI0MDY4MzE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-closures", "name": "A-closures", "color": "f7e101", "default": false, "description": "Area: closures (`|args| { .. }`)"}, {"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2018-09-08T15:14:00Z", "updated_at": "2019-04-30T14:47:49Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "Unlike previously discussed *inference* of `move` from lifetimes (which has been deemed unfeasible/undesirable), we can completely ignore lifetime bounds and NLL analysis.\r\n\r\n*Note: everything discussed here \"trivially\" doesn't pass lifetime inference/checks currently, so allowing such code to compile should be entirely backwards-compatible.*\r\n\r\n<hr/>\r\n\r\nInstead, I think we should focus on expressions that had their types inferred to contain closure types, and compare their (lexical/\"drop\") scopes with the scopes the closure captures are declared in, e.g.:\r\n```rust\r\nlet x = String::new();\r\nlet f = {\r\n    let y = vec![0];\r\n    Some(|| (x.clone(), y.clone()))\r\n};\r\n```\r\n`typeof f` is `Option<closure>`, where the closure captures `x` and `y`, and *the only way* the closure could be capturing any of them by reference, is if their scopes contain the scope of `f`.\r\nThis is true for `x` (assuming `f` is as far as the closure escapes), but *not* `y`, and the closure should *therefore* capture `x` by value, allowing that code to compile without explicit `move`.\r\n\r\nAnother, perhaps more common example is `.flat_map(|x| (0..n).map(|i| x + i))` - the inner closure escapes the scope of `x` (by being returned from the outer closure).\r\n\r\n<hr/>\r\n\r\nIf the closure is turned into a trait object (e.g. `Box<dyn Fn(...) -> _>`) in the scope where it is created in (with all the captures in scope), we can't change anything there, since it'd require lifetime analysis.\r\n\r\nBut since the stabilization of `impl Trait`, it's becoming increasingly common to return various types that contain closures (such as iterators), and that case can be *readily* served by this change, e.g.:\r\n```rust\r\nfn compose<A, B, C>(\r\n    f: impl Fn(A) -> B,\r\n    g: impl Fn(B) -> C,\r\n) -> impl Fn(A) -> C {\r\n    // Currently requires `move`, but we can solve that.\r\n    /*move*/ |x| g(f(x))\r\n}\r\n```\r\n\r\n<hr/>\r\n\r\nThere's only one issue I could think of, with this approach: `Copy` by-value captures can have surprising outcomes, in that the capture leaves the original accessible, without a syntactical indication, e.g.:\r\n```rust\r\nlet outer_get_x = {\r\n    let mut x = 0;\r\n    let get_x = || x;\r\n    x += 1;\r\n    get_x\r\n};\r\nassert_eq!(outer_get_x(), 0);\r\n```\r\nIf `x` were to be declared before `outer_get_x`, then this code would not compile, as the closure would be borrowing it (which would conflict with `x += 1` mutating `x`), instead of holding onto a copy of it.\r\n\r\nWhat can we do? I think that ideally we'd treat the closure as capturing by borrow, but only in terms of preventing mutable access to `x` for the remainder of its scope, and otherwise capture a copy.\r\n(Then you could only observe a problem if you had a copyable type with interior mutability.)\r\n\r\nBut I'm not sure what the best implementation approach for that would be.\r\n\r\ncc @nikomatsakis @cramertj @withoutboats ", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/54060/reactions", "total_count": 3, "+1": 3, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/54060/timeline", "performed_via_github_app": null, "state_reason": null}