{"url": "https://api.github.com/repos/rust-lang/rust/issues/89657", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/89657/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/89657/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/89657/events", "html_url": "https://github.com/rust-lang/rust/issues/89657", "id": 1020604761, "node_id": "I_kwDOAAsO6M481TFZ", "number": 89657, "title": "Confusing interaction between associated types, `async fn` and `impl Future`", "user": {"login": "jpdoyle", "id": 1918771, "node_id": "MDQ6VXNlcjE5MTg3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1918771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jpdoyle", "html_url": "https://github.com/jpdoyle", "followers_url": "https://api.github.com/users/jpdoyle/followers", "following_url": "https://api.github.com/users/jpdoyle/following{/other_user}", "gists_url": "https://api.github.com/users/jpdoyle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jpdoyle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jpdoyle/subscriptions", "organizations_url": "https://api.github.com/users/jpdoyle/orgs", "repos_url": "https://api.github.com/users/jpdoyle/repos", "events_url": "https://api.github.com/users/jpdoyle/events{/privacy}", "received_events_url": "https://api.github.com/users/jpdoyle/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2021-10-08T02:03:04Z", "updated_at": "2021-10-08T02:05:02Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "With the following files:\r\n`Cargo.toml`:\r\n```toml\r\n[package]\r\nname = \"future_pin_issue\"\r\nversion = \"0.1.0\"\r\nauthors = [\"Joe Doyle <joethedoyle@protonmail.com>\"]\r\nedition = \"2018\"\r\n\r\n[dependencies]\r\nfutures = \"0.3.16\"\r\n\r\n[features]\r\nuse_async_fn = []\r\n```\r\n`src/main.rs`:\r\n```rust\r\nuse futures::Future;\r\nuse std::pin::Pin;\r\n\r\npub struct MyBackend<'a> {\r\n    _marker: std::marker::PhantomData<&'a ()>,\r\n}\r\n\r\nimpl<'a> Backend<'a> for MyBackend<'a> {\r\n    type MyStorage = AtomicStorage;\r\n}\r\n\r\npub trait Storage<'a> {}\r\n\r\npub struct AtomicStorage {}\r\nimpl<'a> Storage<'a> for AtomicStorage {}\r\n\r\npub trait Backend<'a>: Send {\r\n    type MyStorage: Storage<'a>;\r\n    fn store<F>(&mut self, _update: F) -> Pin<Box<dyn Future<Output = ()> + Send>>\r\n    where\r\n        F: Fn(Self::MyStorage),\r\n    {\r\n        unimplemented!()\r\n    }\r\n}\r\n\r\n// https://stackoverflow.com/questions/50547766/how-can-i-get-impl-trait-to-use-the-appropriate-lifetime-for-a-mutable-reference\r\npub trait Captures<'a> {}\r\nimpl<'a, T: ?Sized> Captures<'a> for T {}\r\n\r\n#[cfg(feature = \"use_async_fn\")]\r\npub async fn transfer<'a, B: 'a + Backend<'a> + Send + Sync>(backend: &mut B) {\r\n    backend.store(|_t| {}).await\r\n}\r\n\r\n#[cfg(not(feature = \"use_async_fn\"))]\r\npub fn transfer<'a, 'b, B: 'a + Backend<'a> + Send + Sync>(\r\n    backend: &'b mut B,\r\n) -> impl 'b + Captures<'a> + std::future::Future<Output = ()> + Send {\r\n    async move { backend.store(|_t| {}).await }\r\n}\r\n\r\n// This works\r\nfn _test1<'a>(mut backend: impl 'a + Backend<'a> + Send + Sync) {\r\n    let _: Pin<Box<dyn Send>> = Box::pin(async {\r\n        transfer(&mut backend).await;\r\n    });\r\n}\r\n\r\n// This doesn't\r\nfn _test2<'a>(mut backend: MyBackend<'a>) {\r\n    let _: Pin<Box<dyn Send>> = Box::pin(async {\r\n        transfer(&mut backend).await;\r\n    });\r\n}\r\n\r\nfn _hidemytype<'a>(backend: MyBackend<'a>) -> impl 'a + Backend<'a> + Send + Sync {\r\n    backend\r\n}\r\n\r\n// This does!\r\nfn _test3<'a>(backend: MyBackend<'a>) {\r\n    let _: Pin<Box<dyn Send>> = Box::pin(async {\r\n        transfer(&mut _hidemytype(backend)).await;\r\n    });\r\n}\r\n\r\n// And so does this\r\nfn _test4<'a>(backend: MyBackend<'a>) {\r\n    _test1(backend);\r\n}\r\n\r\nfn main() {}\r\n```\r\n\r\nIt succeeds with `cargo build` (using the second `transfer`), but if you use the first `transfer` by running `cargo build --features use_async_fn`, you get a very confusing error:\r\n```\r\n$ cargo build --features use_async_fn\r\n   Compiling future_pin_issue v0.1.0 (/home/joe/issue-test)\r\nerror: implementation of `Backend` is not general enough\r\n  --> src/main.rs:52:33\r\n   |\r\n52 |       let _: Pin<Box<dyn Send>> = Box::pin(async {\r\n   |  _________________________________^\r\n53 | |         transfer(&mut backend).await;\r\n54 | |     });\r\n   | |______^ implementation of `Backend` is not general enough\r\n   |\r\n   = note: `Backend<'1>` would have to be implemented for the type `MyBackend<'0>`, for any two lifetimes `'0` and `'1`...\r\n   = note: ...but `Backend<'2>` is actually implemented for the type `MyBackend<'2>`, for some specific lifetime `'2`\r\n\r\nerror: could not compile `future_pin_issue` due to previous error\r\n```\r\n\r\nThe second `transfer` implementation (used when `use_async_fn` is off) is a workaround based on the desugar of `async fn`, plus a `Captures` trait I found on stackoverflow.\r\n\r\nConfusingly, the error only ever occurs in `_test2`. `_test3` is especially concerning, because it means that \"forgetting\" information about the type makes the typechecking succeed somehow!\r\n\r\nRemoving the `Backend::<'a>::MyStorage` associated type, changing `store` to `store<F,MyStorage: Storage<'a>>`, and calling `backend.store::<_,AtomicStorage>(...)` rather than `backend.store(...)` also fixes the error.\r\n\r\nThis looks like a potential type inference bug, but it might be expected behavior. If it's expected, I think the error messages could use some work.\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n`rustc --version --verbose`:\r\n```\r\n$ rustc --version --verbose\r\nrustc 1.55.0 (c8dfcfe04 2021-09-06)\r\nbinary: rustc\r\ncommit-hash: c8dfcfe046a7680554bf4eb612bad840e7631c4b\r\ncommit-date: 2021-09-06\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.55.0\r\nLLVM version: 12.0.1\r\n```\r\n```\r\n$ cargo --version --verbose\r\ncargo 1.55.0 (32da73ab1 2021-08-23)\r\nrelease: 1.55.0\r\ncommit-hash: 32da73ab19417aa89686e1d85c1440b72fdf877d\r\ncommit-date: 2021-08-23\r\n```\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/89657/reactions", "total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/89657/timeline", "performed_via_github_app": null, "state_reason": null}