{"url": "https://api.github.com/repos/rust-lang/rust/issues/29745", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/29745/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/29745/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/29745/events", "html_url": "https://github.com/rust-lang/rust/issues/29745", "id": 116094008, "node_id": "MDU6SXNzdWUxMTYwOTQwMDg=", "number": 29745, "title": "docs: Explain the borrowing happening when matching data-variant enums within structs", "user": {"login": "thibault-ml", "id": 138014, "node_id": "MDQ6VXNlcjEzODAxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/138014?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thibault-ml", "html_url": "https://github.com/thibault-ml", "followers_url": "https://api.github.com/users/thibault-ml/followers", "following_url": "https://api.github.com/users/thibault-ml/following{/other_user}", "gists_url": "https://api.github.com/users/thibault-ml/gists{/gist_id}", "starred_url": "https://api.github.com/users/thibault-ml/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thibault-ml/subscriptions", "organizations_url": "https://api.github.com/users/thibault-ml/orgs", "repos_url": "https://api.github.com/users/thibault-ml/repos", "events_url": "https://api.github.com/users/thibault-ml/events{/privacy}", "received_events_url": "https://api.github.com/users/thibault-ml/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2015-11-10T12:03:58Z", "updated_at": "2016-01-04T17:36:13Z", "closed_at": "2016-01-04T17:36:13Z", "author_association": "NONE", "active_lock_reason": null, "body": "I believe the documentation, either in the \"Borrowing\" or the \"Enums\" section, could be a bit more explicit about what happens when using enums that have data components.\n\nThis bug reports just shows how I went along and tried to understand what was happening, and while all of it now makes sense, I believe it could be good to have the documentation explain what is happening a bit more.\n\nTake the following code:\n\n``` rust\n#[derive(Debug, Clone, Eq, PartialEq)]\nenum SessionStatus {\n    NeedInput,\n    NeedToWrite(String),\n}\n\nstruct Session {\n    status: SessionStatus,\n}\n\nimpl Session {\n    fn execute(mut self) -> Option<Self> {\n        match self.status {\n            SessionStatus::NeedToWrite(string_value) => {\n                println!(\"Need to write: {:?}\", string_value);\n            }\n            _ => {}\n        }\n        Some(self)\n    }\n}\n```\n\nThis generates the following compiler error:\n\n```\n/tmp/test-rust/test_enum.rs:20:14: 20:18 error: use of partially moved value: `self` [E0382]\n/tmp/test-rust/test_enum.rs:20         Some(self)\n                                            ^~~~\n/tmp/test-rust/test_enum.rs:20:14: 20:18 help: run `rustc --explain E0382` to see a detailed explanation\n/tmp/test-rust/test_enum.rs:14:40: 14:52 note: `(self.status:SessionStatus::NeedToWrite).0` moved here because it has type `collections::string::String`, which is moved by default\n/tmp/test-rust/test_enum.rs:14             SessionStatus::NeedToWrite(string_value) => {\n                                                                      ^~~~~~~~~~~~\n/tmp/test-rust/test_enum.rs:14:40: 14:52 help: if you would like to borrow the value instead, use a `ref` binding as shown:\n/tmp/test-rust/test_enum.rs:               SessionStatus::NeedToWrite(ref string_value) => {\nerror: aborting due to previous error\n```\n\nWhich, if I understand correctly, means `self` was moved (moved where or to what variable, I don't know), because the `String` owned by the `status` ivar was moved as well.\nI believe I now understand that this is because the `String` is owned by `self.status`, so the `String` value has to be borrowed via a `ref`, because it cannot just be \"moved out\" `self.status`.\n\nNow, let's say I've added the `ref`, and wanted to modify the status:\n\n``` rust\nimpl Session {\n    fn execute(mut self) -> Option<Self> {\n        match self.status {\n            SessionStatus::NeedToWrite(ref string_value) => {\n                println!(\"Need to write: {:?}\", string_value);\n                self.status = SessionStatus::NeedInput;\n            }\n            _ => {}\n        }\n        Some(self)\n    }\n}\n```\n\nThe compiler complains:\n\n```\n/tmp/test-rust/test_enum.rs:16:17: 16:55 error: cannot assign to `self.status` because it is borrowed\n/tmp/test-rust/test_enum.rs:16                 self.status = SessionStatus::NeedInput;\n                                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/test-rust/test_enum.rs:14:40: 14:56 note: borrow of `self.status` occurs here\n/tmp/test-rust/test_enum.rs:14             SessionStatus::NeedToWrite(ref string_value) => {\n                                                                      ^~~~~~~~~~~~~~~~\nerror: aborting due to previous error\n```\n\nThis code matches against `SessionStatus::NeedToWrite` and creates a variable `string_value` that is a reference to `(self.status:SessionStatus::NeedToWrite).0`, so we can't reassign `self.status` while a reference to it exists. This makes sense.\n\nNow, if I remove the `ref` but keep the assignment:\n\n``` rust\nimpl Session {\n    fn execute(mut self) -> Option<Self> {\n        match self.status {\n            SessionStatus::NeedToWrite(string_value) => {\n                println!(\"Need to write: {:?}\", string_value);\n                self.status = SessionStatus::NeedInput;\n            }\n            _ => {}\n        }\n        Some(self)\n    }\n}\n```\n\nThis now works! My understanding is the following:\nMoving the `String` contained by `SessionStatus::NeedToWrite` in `self.status` resulted in a partially moved value of `self`, because `self.status` was referring to an enum value whose data was moved. However, this code works because we are setting `self.status` to a new value, meaning `self.status` is not referring to a moved value anymore.\n\nAgain, this all make sense, and I now find this behaviour totally expected (and pretty awesome that it is checked), but I believe the documentation could do with a little clarification for new starters, because it may not be as obvious to everyone starting with Rust and struggling with references and the borrow checker.\n", "closed_by": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/29745/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/29745/timeline", "performed_via_github_app": null, "state_reason": "completed"}