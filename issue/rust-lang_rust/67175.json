{"url": "https://api.github.com/repos/rust-lang/rust/issues/67175", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/67175/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/67175/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/67175/events", "html_url": "https://github.com/rust-lang/rust/issues/67175", "id": 535005446, "node_id": "MDU6SXNzdWU1MzUwMDU0NDY=", "number": 67175, "title": "Strange cycles perfomance with generators and very slow `for` in `debug` build [on nightly]", "user": {"login": "olegnn", "id": 6822848, "node_id": "MDQ6VXNlcjY4MjI4NDg=", "avatar_url": "https://avatars.githubusercontent.com/u/6822848?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olegnn", "html_url": "https://github.com/olegnn", "followers_url": "https://api.github.com/users/olegnn/followers", "following_url": "https://api.github.com/users/olegnn/following{/other_user}", "gists_url": "https://api.github.com/users/olegnn/gists{/gist_id}", "starred_url": "https://api.github.com/users/olegnn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olegnn/subscriptions", "organizations_url": "https://api.github.com/users/olegnn/orgs", "repos_url": "https://api.github.com/users/olegnn/repos", "events_url": "https://api.github.com/users/olegnn/events{/privacy}", "received_events_url": "https://api.github.com/users/olegnn/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 679846574, "node_id": "MDU6TGFiZWw2Nzk4NDY1NzQ=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-generators", "name": "A-generators", "color": "f7e101", "default": false, "description": "Area: Generators"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2019-12-09T15:27:51Z", "updated_at": "2020-02-02T11:36:48Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Having following simple benchmark code:\r\n<details><summary> Very large code </summary>\r\n\r\n```rust\r\n#![feature(generators, generator_trait)]\r\n#![feature(trait_alias)]\r\n#![allow(while_true)]\r\n#![allow(clippy::print_literal)]\r\n\r\nuse std::marker::PhantomData;\r\nuse std::ops::{Add, Generator, GeneratorState::*};\r\nuse std::pin::Pin;\r\n\r\ntrait FibValue<T> = Add<Output = T> + From<u8> + Copy;\r\n\r\nstruct Fibs<T: FibValue<T>, G: Generator<Yield = T, Return = !> + Unpin>(\r\n    Pin<Box<G>>,\r\n    PhantomData<T>,\r\n);\r\n\r\nimpl<T: FibValue<T>, G: Generator<Yield = T, Return = !> + Unpin> Iterator for Fibs<T, G> {\r\n    type Item = T;\r\n\r\n    fn next(&mut self) -> Option<T> {\r\n        if let Yielded(element) = self.0.as_mut().resume() {\r\n            element.into()\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n}\r\n\r\nfn create_fibs_for_gen<T: FibValue<T>>() -> Fibs<T, impl Generator<Yield = T, Return = !> + Unpin> {\r\n    Fibs(\r\n        Box::pin(|| {\r\n            let mut previous: T = 0.into();\r\n            let mut current: T = 1.into();\r\n\r\n            yield previous;\r\n            yield current;\r\n\r\n            for _ in 0usize.. {\r\n                let element = current + previous;\r\n\r\n                previous = current;\r\n                current = element;\r\n\r\n                yield element\r\n            }\r\n\r\n            unreachable!()\r\n        }),\r\n        PhantomData,\r\n    )\r\n}\r\n\r\nfn create_fibs_loop_gen<T: FibValue<T>>() -> Fibs<T, impl Generator<Yield = T, Return = !> + Unpin>\r\n{\r\n    Fibs(\r\n        Box::pin(|| {\r\n            let mut previous: T = 0.into();\r\n            let mut current: T = 1.into();\r\n\r\n            yield previous;\r\n            yield current;\r\n\r\n            loop {\r\n                let element = current + previous;\r\n\r\n                previous = current;\r\n                current = element;\r\n\r\n                yield element\r\n            }\r\n        }),\r\n        PhantomData,\r\n    )\r\n}\r\n\r\nfn create_fibs_while_gen<T: FibValue<T>>() -> Fibs<T, impl Generator<Yield = T, Return = !> + Unpin>\r\n{\r\n    Fibs(\r\n        Box::pin(|| {\r\n            let mut previous: T = 0.into();\r\n            let mut current: T = 1.into();\r\n\r\n            yield previous;\r\n            yield current;\r\n\r\n            while true {\r\n                let element = current + previous;\r\n\r\n                previous = current;\r\n                current = element;\r\n\r\n                yield element\r\n            }\r\n\r\n            unreachable!()\r\n        }),\r\n        PhantomData,\r\n    )\r\n}\r\n\r\nfn generate_fibs_loop<T: FibValue<T>>(result: &mut Vec<T>) {\r\n    let fib_count = result.capacity();\r\n    let mut previous: T = 0.into();\r\n    let mut current: T = 1.into();\r\n    let mut num = 2;\r\n\r\n    if fib_count > 0 {\r\n        result.push(previous);\r\n        if fib_count > 1 {\r\n            result.push(current);\r\n        }\r\n    }\r\n\r\n    loop {\r\n        if fib_count <= num {\r\n            break;\r\n        } else {\r\n            num += 1;\r\n        }\r\n\r\n        let element = current + previous;\r\n\r\n        previous = current;\r\n        current = element;\r\n\r\n        result.push(element);\r\n    }\r\n}\r\n\r\nfn generate_fibs_for<T: FibValue<T>>(result: &mut Vec<T>) {\r\n    let fib_count = result.capacity();\r\n    let mut previous: T = 0.into();\r\n    let mut current: T = 1.into();\r\n\r\n    if fib_count > 0 {\r\n        result.push(previous);\r\n        if fib_count > 1 {\r\n            result.push(current);\r\n        }\r\n    }\r\n\r\n    for _ in 2..fib_count {\r\n        let element = current + previous;\r\n\r\n        previous = current;\r\n        current = element;\r\n\r\n        result.push(element);\r\n    }\r\n}\r\n\r\nfn generate_fibs_while<T: FibValue<T>>(result: &mut Vec<T>) {\r\n    let fib_count = result.capacity();\r\n    let mut previous: T = 0.into();\r\n    let mut current: T = 1.into();\r\n    let mut num = 2;\r\n\r\n    if fib_count > 0 {\r\n        result.push(previous);\r\n        if fib_count > 1 {\r\n            result.push(current);\r\n        }\r\n    }\r\n\r\n    while num < fib_count {\r\n        num += 1;\r\n\r\n        let element = current + previous;\r\n\r\n        previous = current;\r\n        current = element;\r\n\r\n        result.push(element);\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let mut fibs = Vec::with_capacity(10000);\r\n    let mut start_time = std::time::Instant::now();\r\n    generate_fibs_loop::<f64>(&mut fibs);\r\n    println!(\r\n        \"{} => {:?}, total count: {}, test value: {}\",\r\n        \"fib via `loop`!\",\r\n        std::time::Instant::now() - start_time,\r\n        fibs.len(),\r\n        fibs[500].log(std::f64::consts::PI)\r\n    );\r\n\r\n    fibs = Vec::with_capacity(10000);\r\n    start_time = std::time::Instant::now();\r\n    generate_fibs_for::<f64>(&mut fibs);\r\n    println!(\r\n        \"{} => {:?}, total count: {}, test value: {}\",\r\n        \"fib via `for`!\",\r\n        std::time::Instant::now() - start_time,\r\n        fibs.len(),\r\n        fibs[500].log(std::f64::consts::PI)\r\n    );\r\n\r\n    fibs = Vec::with_capacity(10000);\r\n    start_time = std::time::Instant::now();\r\n    generate_fibs_while::<f64>(&mut fibs);\r\n    println!(\r\n        \"{} => {:?}, total count: {}, test value: {}\",\r\n        \"fib via `while`!\",\r\n        std::time::Instant::now() - start_time,\r\n        fibs.len(),\r\n        fibs[500].log(std::f64::consts::PI)\r\n    );\r\n    \r\n    start_time = std::time::Instant::now();\r\n    fibs = create_fibs_loop_gen::<f64>()\r\n        .take(10000)\r\n        .collect::<Vec<f64>>();\r\n    println!(\r\n        \"{} => {:?}, total count: {}, test value: {}\",\r\n        \"fib via `loop` generator!\",\r\n        std::time::Instant::now() - start_time,\r\n        fibs.len(),\r\n        fibs[500].log(std::f64::consts::PI)\r\n    );\r\n\r\n    start_time = std::time::Instant::now();\r\n    fibs = create_fibs_for_gen::<f64>()\r\n        .take(10000)\r\n        .collect::<Vec<f64>>();\r\n    println!(\r\n        \"{} => {:?}, total count: {}, test value: {}\",\r\n        \"fib via `for` generator!\",\r\n        std::time::Instant::now() - start_time,\r\n        fibs.len(),\r\n        fibs[500].log(std::f64::consts::PI),\r\n    );\r\n\r\n    start_time = std::time::Instant::now();\r\n    fibs = create_fibs_while_gen::<f64>()\r\n        .take(10000)\r\n        .collect::<Vec<f64>>();\r\n    println!(\r\n        \"{} => {:?}, total count: {}, test value: {}\",\r\n        \"fib via `while` generator!\",\r\n        std::time::Instant::now() - start_time,\r\n        fibs.len(),\r\n        fibs[500].log(std::f64::consts::PI),\r\n    );\r\n}\r\n```\r\n\r\n</details>\r\n\r\n[**If increase benchmark number for every case, median time difference will become less significant**]\r\n\r\nBut for 1 iteration I got very strange results (with many recompilations and reruns, results are approx. the same): \r\n- Debug on my machine:\r\n```\r\nfib via `loop`! => 283.689\u00b5s, total count: 10000, test value: 209.48277540220764\r\nfib via `for`! => 1.037341ms, total count: 10000, test value: 209.48277540220764\r\nfib via `while`! => 363.379\u00b5s, total count: 10000, test value: 209.48277540220764\r\nfib via `loop` generator! => 911.265\u00b5s, total count: 10000, test value: 209.48277540220764\r\nfib via `for` generator! => 1.331597ms, total count: 10000, test value: 209.48277540220764\r\nfib via `while` generator! => 897.928\u00b5s, total count: 10000, test value: 209.48277540220764\r\n```\r\n- Debug on playground:\r\n```\r\nfib via `loop`! => 518.857\u00b5s, total count: 10000, test value: 209.48277540220764\r\nfib via `for`! => 1.706352ms, total count: 10000, test value: 209.48277540220764\r\nfib via `while`! => 621.504\u00b5s, total count: 10000, test value: 209.48277540220764\r\nfib via `loop` generator! => 1.53625ms, total count: 10000, test value: 209.48277540220764\r\nfib via `for` generator! => 2.30295ms, total count: 10000, test value: 209.48277540220764\r\nfib via `while` generator! => 1.276106ms, total count: 10000, test value: 209.48277540220764\r\n```\r\nCycle `for` is **up to 3 times slower**\r\n- Release on my machine:\r\n```\r\nfib via `loop`! => 67.293\u00b5s, total count: 10000, test value: 209.48277540220764\r\nfib via `for`! => 60.185\u00b5s, total count: 10000, test value: 209.48277540220764\r\nfib via `while`! => 17.95\u00b5s, total count: 10000, test value: 209.48277540220764\r\nfib via `loop` generator! => 55.928\u00b5s, total count: 10000, test value: 209.48277540220764\r\nfib via `for` generator! => 116.994\u00b5s, total count: 10000, test value: 209.48277540220764\r\nfib via `while` generator! => 48.887\u00b5s, total count: 10000, test value: 209.48277540220764\r\n```\r\n- Release on playground:\r\n```\r\nfib via `loop`! => 60.817\u00b5s, total count: 10000, test value: 209.48277540220764\r\nfib via `for`! => 67.948\u00b5s, total count: 10000, test value: 209.48277540220764\r\nfib via `while`! => 28.903\u00b5s, total count: 10000, test value: 209.48277540220764\r\nfib via `loop` generator! => 46.099\u00b5s, total count: 10000, test value: 209.48277540220764\r\nfib via `for` generator! => 158.023\u00b5s, total count: 10000, test value: 209.48277540220764\r\nfib via `while` generator! => 108.421\u00b5s, total count: 10000, test value: 209.48277540220764\r\n```\r\n`for` and `loop` are slower for some reasons. Also I know that generators aren't stable yet but they already work **very fast** and also are very convenient to use for some purposes. However this behaviour looks strange: `for` in generators is **up to 3 times** less performant than `loop` and `while true` (which's antipattern).\r\n\r\nIs this my fault or something wrong with the cycles compilation? I'm very scared... Thanks!\r\n\r\n[Playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=b4c2be76169f0f6dc03871055ada362b)", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/67175/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/67175/timeline", "performed_via_github_app": null, "state_reason": null}