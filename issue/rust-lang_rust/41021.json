{"url": "https://api.github.com/repos/rust-lang/rust/issues/41021", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/41021/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/41021/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/41021/events", "html_url": "https://github.com/rust-lang/rust/issues/41021", "id": 218781391, "node_id": "MDU6SXNzdWUyMTg3ODEzOTE=", "number": 41021, "title": "Why doesn't sync_channel use a more efficient implementation?", "user": {"login": "ghost", "id": 10137, "node_id": "MDQ6VXNlcjEwMTM3", "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ghost", "html_url": "https://github.com/ghost", "followers_url": "https://api.github.com/users/ghost/followers", "following_url": "https://api.github.com/users/ghost/following{/other_user}", "gists_url": "https://api.github.com/users/ghost/gists{/gist_id}", "starred_url": "https://api.github.com/users/ghost/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ghost/subscriptions", "organizations_url": "https://api.github.com/users/ghost/orgs", "repos_url": "https://api.github.com/users/ghost/repos", "events_url": "https://api.github.com/users/ghost/events{/privacy}", "received_events_url": "https://api.github.com/users/ghost/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-04-02T18:02:03Z", "updated_at": "2017-11-26T22:02:39Z", "closed_at": "2017-11-26T22:02:10Z", "author_association": "NONE", "active_lock_reason": null, "body": "The [implementation](https://github.com/rust-lang/rust/blob/master/src/libstd/sync/mpsc/sync.rs#L213) of `sync_channel` locks the mutex on every `send` and `recv`. Is there a reason why Dmitry Vyukov's [bounded MPMC queue](http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue) is not used instead? It should have noticeably better performance than a simple buffer protected by one big mutex.\r\n\r\nDmitry himself [experimented](https://docs.google.com/document/d/1yIAYmbvL3JxOKOjuCyon7JhW4cSv1wy5hC0ApeGMV9s/pub) with this algorithm for use in Go. The proposal to replace Go's channels with this algorithm ultimately didn't pan out - I believe because they didn't manage to fulfill certain fairness gurantees Go promised without resorting back to mutexes.\r\n\r\nThis brings me to an interesting safety problem... Dmitry's MPMC queue is actually used in several crates (and I bet @carllerche implemented it multiple times). One of those is [tokio-timer](https://github.com/tokio-rs/tokio-timer/blob/master/src/mpmc.rs#L7). I have a small concern with this algorithm. Please bear with me - you don't have to understand the nitty-gritty details. I just want to show a safety hazard.\r\n\r\nThe algorithm may run into data races.\r\n\r\n*(You can skip this part:)* The danger lies in [this compare-and-swap](https://github.com/tokio-rs/tokio-timer/blob/master/src/mpmc.rs#L76). Suppose that a thread wants to push a value. Just before the CAS other threads push and pop 2^64 (or 2^32 on 32-bit systems) elements into/from the queue (extremely unlikely!). Then our CAS succeeds and we start [writing our value](https://github.com/tokio-rs/tokio-timer/blob/master/src/mpmc.rs#L82) while some other thread may still be writing it's own value to the same slot! The gist of the story is that lower bits in `pos` are used to index into the buffer, while the upper bits in are used to distinguish between different \"laps\" around the ring buffer. The number of laps we're keeping track of is limited, of course. We're unlikely to run into a lap conflict, but if we do, data races may happen.\r\n\r\nThe likelihood of running into a data race is probably comparable to the likelihood of a random bit being flipped in RAM and corrupting your program. I guess. It also depends on the OS scheduler.\r\n\r\nWhile data races may happen in theory, they're unlikely to ever happen in practice. It's really really unlikely. But does that mean we're allowed to expose a safe interface around it? Do such algorithms qualify as \"safe\" under Rust's safety standards?\r\n\r\nAs a side note, [hazard pointers](https://en.wikipedia.org/wiki/Hazard_pointer) are usually tagged with [version numbers](https://en.wikipedia.org/wiki/ABA_problem#Tagged_state_reference) (a similar idea to laps) in order to get around the [ABA problem](https://en.wikipedia.org/wiki/ABA_problem). However, version numbers suffer from the same safety hazard. But they only suffer in theory, never in practice. :)\r\n\r\nMy questions are:\r\n\r\n1. Why is Dmitry's MPMC queue not used instead of the buffer-behind-mutex approach?\r\n2. Is there an interest in replacing our `sync_channel` with Dmitry's MPMC queue?\r\n3. Can we consider the MPMC implementation in `tokio-timer` to be safe, even though it's just *extremely* likely to be safe in practice?\r\n4. Would it be acceptable to have an algorithm in libstd that is *extremely* likely to be safe, but not exactly 100% safe in theory?\r\n\r\ncc @alexcrichton ", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/41021/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/41021/timeline", "performed_via_github_app": null, "state_reason": "completed"}