{"url": "https://api.github.com/repos/rust-lang/rust/issues/89832", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/89832/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/89832/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/89832/events", "html_url": "https://github.com/rust-lang/rust/issues/89832", "id": 1024474028, "node_id": "I_kwDOAAsO6M49EDus", "number": 89832, "title": "RwLock is `UnwindSafe` despite not poisoning on `read()`, can cause broken invariants", "user": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2021-10-12T21:55:34Z", "updated_at": "2021-11-06T07:34:08Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "`RwLock` only poisons on panic with `write()`, it explicitly does not poison on panic with `read()`. This makes sense for most types, but for types with interior mutability `read()` can expose that interior mutability and allow broken invariants to be witnessed without using `AssertUnwindSafe` or spawning threads.\r\n\r\nIf I understand this correctly, due to the lack of read poisoning, it really should only be `UnwindSafe where T: UnwindSafe` (and I believe `RefUnwindSafe where T: RefUnwindSafe`, though I'm not certain as I'm still struggling to properly conceptualize this.).\r\n\r\nOn a similar note, `RwLockReadGuard` is `UnwindSafe` and `RefUnwindSafe` without any conditions. So is `RwLockWriteGuard`, but that's the one that does poisoning so it's fine there. `RwLockReadGuard` should at least require `T: RefUnwindSafe` for it to be `UnwindSafe` and `RefUnwindSafe`. I believe that if `RwLock` is adjusted then `RwLockReadGuard` will pick it up automatically due to the auto trait rules, though in this case `RwLockWriteGuard` will need the manual implementations as it does poisoning.\r\n\r\n---\r\n\r\nI'm not sure if there's any quick go-to for testing unwind safety, but I wrote a simple type that maintains a logical invariant with interior mutability. Without `RwLock` I get the expected compiler error trying to pass a reference to it across a `catch_unwind` barrier. Wrapping it in `RwLock` gets rid of the compiler error without introducing poisoning, which then allows for observing a broken invariant. [Playground link](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=8183062573ba2f99799543457b215752)\r\n\r\n```rust\r\nuse std::cell::RefCell;\r\n\r\nstruct Foo {\r\n    // Invariant: inner is always Some, it's only teporarily None during transformation.\r\n    inner: RefCell<Option<String>>,\r\n}\r\n\r\nimpl Foo {\r\n    fn new() -> Self {\r\n        Foo {\r\n            inner: RefCell::new(Some(\"initial\".to_owned())),\r\n        }\r\n    }\r\n\r\n    fn transform(&self, f: impl FnOnce(String) -> String) {\r\n        let inner = self.inner.borrow_mut().take().unwrap();\r\n        *self.inner.borrow_mut() = Some(f(inner));\r\n    }\r\n\r\n    fn inner(&self) -> std::cell::Ref<str> {\r\n        std::cell::Ref::map(self.inner.borrow(), |inner| {\r\n            inner.as_deref().expect(\"broken invariant\")\r\n        })\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let foo = Foo::new();\r\n    \r\n    // Comment out the next two lines to get an unwind safety error\r\n    let foo = std::sync::RwLock::new(foo);\r\n    let foo = foo.read().unwrap();\r\n    \r\n    dbg!(foo.inner());\r\n    let result = std::panic::catch_unwind(|| {\r\n        foo.transform(|_| panic!());\r\n    });\r\n    let _ = dbg!(result);\r\n    dbg!(foo.inner());\r\n}\r\n```\r\n\r\nIn this code I'm passing the `RwLockReadGuard` across the `catch_unwind` barrier, but passing the `&RwLock` across and calling `.read().unwrap()` on each access produces the same results (meaning this can't just be fixed by changing `RwLockReadGuard`).\r\n\r\n### Meta\r\nPlayground rust version: Stable channel, 1.55.0\r\n\r\n### Additional context\r\nI discovered this when I was trying to figure out how to make a type with interior mutability safe to pass to something that requires `RefUnwindSafe`. I thought \"it has interior mutability, maybe I should just use a `RwLock` and only take reads on it\", at which point I discovered that this doesn't add poisoning despite being `RefUnwindSafe`. In retrospect, reading can't add poisoning (given that there can be concurrent reads, and you can't poison an extant guard) so I really do need a mutex, but the fact that `RwLock` makes the compiler happy here is a problem.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/89832/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/89832/timeline", "performed_via_github_app": null, "state_reason": null}