{"url": "https://api.github.com/repos/rust-lang/rust/issues/72895", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/72895/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/72895/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/72895/events", "html_url": "https://github.com/rust-lang/rust/issues/72895", "id": 628699951, "node_id": "MDU6SXNzdWU2Mjg2OTk5NTE=", "number": 72895, "title": "Investigation into ASCII ctype inherent methods performance with lookup table", "user": {"login": "CDirkx", "id": 11176562, "node_id": "MDQ6VXNlcjExMTc2NTYy", "avatar_url": "https://avatars.githubusercontent.com/u/11176562?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CDirkx", "html_url": "https://github.com/CDirkx", "followers_url": "https://api.github.com/users/CDirkx/followers", "following_url": "https://api.github.com/users/CDirkx/following{/other_user}", "gists_url": "https://api.github.com/users/CDirkx/gists{/gist_id}", "starred_url": "https://api.github.com/users/CDirkx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CDirkx/subscriptions", "organizations_url": "https://api.github.com/users/CDirkx/orgs", "repos_url": "https://api.github.com/users/CDirkx/repos", "events_url": "https://api.github.com/users/CDirkx/events{/privacy}", "received_events_url": "https://api.github.com/users/CDirkx/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 2011781731, "node_id": "MDU6TGFiZWwyMDExNzgxNzMx", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs", "name": "T-libs", "color": "bfd4f2", "default": false, "description": "Relevant to the library team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2020-06-01T20:19:50Z", "updated_at": "2021-06-19T19:09:39Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Prompted by https://github.com/rust-lang/rust/issues/68983#issuecomment-613753557, I started looking into whether the performance of methods like `is_ascii_alphabetic` could be improved by using a lookup table.\r\n\r\nThe full list of methods:\r\n- `is_ascii_alphabetic`\r\n- `is_ascii_alphanumeric`\r\n- `is_ascii_control`\r\n- `is_ascii_digit`\r\n- `is_ascii_graphic`\r\n- `is_ascii_hexdigit`\r\n- `is_ascii_lowercase`\r\n- `is_ascii_punctuation`\r\n- `is_ascii_uppercase`\r\n- `is_ascii_whitespace`\r\n\r\n## Implementations\r\nCurrently, all of these methods are implemented by [matching on characters/ranges](https://github.com/rust-lang/rust/blob/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src/libcore/num/mod.rs#L4657-L4659):\r\n```rust\r\n#[inline]\r\npub const fn is_ascii_alphabetic(&self) -> bool {\r\n    matches!(*self, b'A'..=b'Z' | b'a'..=b'z')\r\n}\r\n```\r\n\r\nI investigated two ways of implementing these functions with a lookup table:\r\n\r\nA lookup table for the entire `u8` range:  \r\n```rust\r\n#[inline]\r\npub const fn is_ascii_alphabetic(&self) -> bool {\r\n    const LOOKUP_TABLE : [bool; 258] = ...;\r\n    \r\n    LOOKUP_TABLE[*self as usize]\r\n}\r\n```\r\nA hybrid approach by checking if the byte is ascii first, reducing table size by half:\r\n```rust\r\n#[inline]\r\npub const fn is_ascii_alphabetic(&self) -> bool {\r\n    const LOOKUP_TABLE : [bool; 128] = ...;\r\n    \r\n    self.is_ascii() && LOOKUP_TABLE[*self as usize]\r\n}\r\n```\r\nI will be calling these implementations `branch`, `lookup` and `hybrid` respectively throughout the rest of this report.\r\n\r\nUsing the features `const_if_match` and `const_loop`, the lookup tables for `lookup` and `hybrid` can be easily generated:\r\n<details>\r\n\r\n```rust\r\nmacro lookup_table($condition:expr, $n:literal) {\r\n    {\r\n        const LOOKUP_TABLE: [bool; $n] = {\r\n            let mut lookup = [false; $n];\r\n\r\n            let mut i = 0;\r\n            while i < $n {\r\n                lookup[i] = $condition(&(i as u8));\r\n                i += 1;\r\n            }\r\n\r\n            lookup\r\n        };\r\n\r\n        LOOKUP_TABLE\r\n    }\r\n}\r\n\r\n#[inline]\r\npub const fn is_ascii_alphabetic_lookup(byte: &u8) -> bool {\r\n    lookup_table!(u8::is_ascii_alphabetic, 256)[*self as usize]\r\n}\r\n\r\n#[inline]\r\npub const fn is_ascii_alphabetic_hybrid(byte: &u8) -> bool {\r\n    byte.is_ascii() && lookup_table!(u8::is_ascii_alphabetic, 128)[*self as usize]\r\n}\r\n```\r\n</details>\r\n\r\nThe instructions these different implementations compile down to can be compared on [godbolt](https://rust.godbolt.org/z/aFnVi4).\r\n\r\n## Benchmark\r\n*Note: I do not have enough experience with benchmarking to know if this approach is fully representative, let me know if you know any way the benchmark can be improved.*\r\n\r\nThe task I used for benchmarking is iterating through the bytes of a source text and counting how many of them satisfy a condition, e.g. `is_ascii_alphabetic`: \r\n\r\n```rust\r\nconst SOURCE_TEXT : &'static str = ...;\r\n\r\n#[bench]\r\nfn is_ascii_alphabetic_branch {\r\n    $bench.iter(|| {\r\n        let mut total = 0;\r\n        for byte in SOURCE_TEXT.bytes() {\r\n            if byte.is_ascii_alphabetic { total += 1; }\r\n        }\r\n\r\n        assert_eq!(total, ...);\r\n    });\r\n}\r\n```\r\n\r\nThis results in a tight loop, which due to caching might be favorable to the lookup tables. However, some [quick searching](https://github.com/search?l=Rust&q=is_ascii_alphabetic&type=Code) for the use of the ascii methods in open source projects reveals at least a few instances of them being used in a loop or iterator filter, so the benchmark is representative of at least some real-world usage. \r\n\r\nAs a source text I used \"Hamlet, Prince of Denmark\", adapted from https://www.gutenberg.org/files/27761/27761-0.txt, a primarily ascii text of 4k+ lines:\r\n\r\n<details>\r\n<summary>Benchmark</summary>\r\n\r\n```rust\r\n#![feature(test)]\r\n#![feature(decl_macro)]\r\n#![feature(const_if_match)]\r\n#![feature(const_loop)]\r\n#![feature(const_ascii_ctype_on_intrinsics)]\r\n\r\nextern crate test;\r\n\r\n\r\nmacro lookup_table($condition:expr, $n:literal) {\r\n    {\r\n        const LOOKUP_TABLE: [bool; $ n] = {\r\n            let mut lookup_table = [false; $ n];\r\n\r\n            let mut i = 0;\r\n            while i < $ n {\r\n                lookup_table[i] = $ condition(&(i as u8));\r\n                i += 1;\r\n            }\r\n\r\n            lookup_table\r\n        };\r\n\r\n        LOOKUP_TABLE\r\n    }\r\n}\r\n\r\nmacro bench($condition:ident, $branch_ident:ident, $hybrid_ident:ident, $lookup_ident:ident, $expected:literal) {\r\n    #[bench]\r\n    fn $branch_ident(bench: &mut test::Bencher) {\r\n        bench_impl!(bench, u8::$condition, $expected);\r\n    }\r\n\r\n    #[bench]\r\n    fn $hybrid_ident(bench: &mut test::Bencher) {\r\n        #[inline]\r\n        fn condition(byte: &u8) -> bool {\r\n            byte.is_ascii() && lookup_table!(u8::$condition, 128)[*byte as usize]\r\n        }\r\n\r\n        bench_impl!(bench, condition, $expected);\r\n    }\r\n\r\n    #[bench]\r\n    fn $lookup_ident(bench: &mut test::Bencher) {\r\n        #[inline]\r\n        fn condition(byte: &u8) -> bool {\r\n            lookup_table!(u8::$condition, 256)[*byte as usize]\r\n        }\r\n\r\n        bench_impl!(bench, condition, $expected);\r\n    }\r\n}\r\n\r\nmacro bench_impl($bench:expr, $condition:expr, $expected:literal) {\r\n    $bench.iter(|| {\r\n        let mut total = 0;\r\n        for byte in SOURCE_TEXT.bytes() {\r\n            if $condition(&byte) { total += 1; }\r\n        }\r\n\r\n        assert_eq!(total, $expected);\r\n    });\r\n}\r\n\r\n\r\n// \"Hamlet, Prince of Denmark\", adapted from https://www.gutenberg.org/files/27761/27761-0.txt\r\nconst SOURCE_TEXT: &'static str = include_str!(\"hamlet.txt\");\r\n\r\nbench!(is_ascii_alphabetic, is_ascii_alphabetic_branch, is_ascii_alphabetic_hybrid, is_ascii_alphabetic_lookup, 83663);\r\nbench!(is_ascii_alphanumeric, is_ascii_alphanumeric_branch, is_ascii_alphanumeric_hybrid, is_ascii_alphanumeric_lookup, 83718);\r\nbench!(is_ascii_control, is_ascii_control_branch, is_ascii_control_hybrid, is_ascii_control_lookup, 8216);\r\nbench!(is_ascii_digit, is_ascii_digit_branch, is_ascii_digit_hybrid, is_ascii_digit_lookup, 55);\r\nbench!(is_ascii_graphic, is_ascii_graphic_branch, is_ascii_graphic_hybrid, is_ascii_graphic_lookup, 94284);\r\nbench!(is_ascii_hexdigit, is_ascii_hexdigit_branch, is_ascii_hexdigit_hybrid, is_ascii_hexdigit_lookup, 23825);\r\nbench!(is_ascii_lowercase, is_ascii_lowercase_branch, is_ascii_lowercase_hybrid, is_ascii_lowercase_lookup, 76787);\r\nbench!(is_ascii_punctuation, is_ascii_punctuation_branch, is_ascii_punctuation_hybrid, is_ascii_punctuation_lookup, 10566);\r\nbench!(is_ascii_uppercase, is_ascii_uppercase_branch, is_ascii_uppercase_hybrid, is_ascii_uppercase_lookup, 6876);\r\nbench!(is_ascii_whitespace, is_ascii_whitespace_branch, is_ascii_whitespace_hybrid, is_ascii_whitespace_lookup, 33893);\r\n```\r\n</details>\r\n\r\nFiles: [benches.zip](https://github.com/rust-lang/rust/files/4708850/benches.zip)\r\n\r\n### Results\r\n| method | `branch` | `hybrid` | `lookup` |\r\n|---|---|---|---|\r\n| `is_ascii_alphabetic` | 364,130 \u00b115,302 | 349,235 \u00b132,393 | 402,965 \u00b122,624 |\r\n| `is_ascii_alphanumeric` | 310,435 \u00b112,975 | 346,025 \u00b118,873 | 404,880 \u00b123,582 |\r\n| `is_ascii_control` | 154,802 \u00b117,761 | 105,160 \u00b110,883 | 197,493 \u00b173,893 |\r\n| `is_ascii_digit` | 96,971 \u00b1 23,020 | 98,597 \u00b1 9,754 | 97,051 \u00b1 4,354 |\r\n| `is_ascii_graphic` | 274,238 \u00b1 12,480 | 296,010 \u00b1 24,268 | 340,445 \u00b1 32,739 |\r\n| `is_ascii_hexdigit` | 358,390 \u00b1 21,165 | 280,170 \u00b1 17,197 | 309,484 \u00b19,983 |\r\n| `is_ascii_lowercase` | 329,840 \u00b1 45,032 | 334,270 \u00b121,637 | 398,315 \u00b118,173 |\r\n| `is_ascii_punctuation` | 372,600 \u00b1 22,126 | 157,147 \u00b17,353 | 173,555 \u00b119,918 |\r\n| `is_ascii_uppercase` | 131,011 \u00b126,059 | 135,658 \u00b119,618 | 142,463 \u00b119,191 |\r\n| `is_ascii_whitespace` | 232,675 \u00b140,710 | 292,750 \u00b161,629 | 350,440 \u00b156,609 |\r\n\r\nAdapted from the output of `cargo bench`, results are in ns.\r\n\r\n### Analysis\r\nIt seems the `hybrid` approach with the smaller lookup table was overall as fast or faster than `lookup`, even though it has to do an extra check (smaller table fits better in cache?).\r\n\r\nThe `hybrid` approach was significantly faster than the current `branch` implementation for:\r\n- `is_ascii_control` (105,160 \u00b110,883 vs. 154,802 \u00b117,761)\r\n- `is_ascii_hexdigit` (280,170 \u00b1 17,197 vs. 358,390 \u00b1 21,165)\r\n- `is_ascii_punctuation` (157,147 \u00b17,353 vs. 372,600 \u00b1 22,126)\r\n\r\nLooking at the current implementation for [is_ascii_hexdigit](https://github.com/rust-lang/rust/blob/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src/libcore/num/mod.rs#L4828-L4830) and [is_ascii_punctuation](https://github.com/rust-lang/rust/blob/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src/libcore/num/mod.rs#L4865-L4867) and [compiler output](https://rust.godbolt.org/z/TKDJws), these two methods have the most complex branches of all the ascii methods, indicating that there is indeed potential for a faster implementation using a lookup table.\r\n\r\nWhy the `hybrid` version of `is_ascii_control` is faster I can not say, maybe caching or an artifact of the way I benchmarked?\r\n\r\n### Conclusion\r\nFrom this preliminary investigation it seems that at least some of the ascii methods can be implemented faster, prompting further investigation. \r\n\r\nAs further steps I propose first evaluating the merits of this benchmark, and then conduct more. There are still a number of questions: are the results of this benchmark correct, or is another factor interfering with the results? Is the benchmark representative of real-world usage? Is the source text influencing the benchmark?  \r\n\r\nOnce we are sure our benchmarks are measuring what we want, we can proceed with the investigation: quantify the trade-off of speed vs. memory, and compare alternate implementations. This information will inform the discussion on whether it makes sense to change the current implementations. ", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/72895/reactions", "total_count": 2, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 2, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/72895/timeline", "performed_via_github_app": null, "state_reason": null}