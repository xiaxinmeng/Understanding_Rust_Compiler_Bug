{"url": "https://api.github.com/repos/rust-lang/rust/issues/83275", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/83275/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/83275/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/83275/events", "html_url": "https://github.com/rust-lang/rust/issues/83275", "id": 835225362, "node_id": "MDU6SXNzdWU4MzUyMjUzNjI=", "number": 83275, "title": "unsafe manual memory management influenced by \"print!\" or providing an explicit type signature", "user": {"login": "bluescreen303", "id": 16330, "node_id": "MDQ6VXNlcjE2MzMw", "avatar_url": "https://avatars.githubusercontent.com/u/16330?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluescreen303", "html_url": "https://github.com/bluescreen303", "followers_url": "https://api.github.com/users/bluescreen303/followers", "following_url": "https://api.github.com/users/bluescreen303/following{/other_user}", "gists_url": "https://api.github.com/users/bluescreen303/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluescreen303/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluescreen303/subscriptions", "organizations_url": "https://api.github.com/users/bluescreen303/orgs", "repos_url": "https://api.github.com/users/bluescreen303/repos", "events_url": "https://api.github.com/users/bluescreen303/events{/privacy}", "received_events_url": "https://api.github.com/users/bluescreen303/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2021-03-18T20:27:50Z", "updated_at": "2021-03-19T09:57:46Z", "closed_at": "2021-03-18T20:42:43Z", "author_association": "NONE", "active_lock_reason": null, "body": "I tried this code:\r\n\r\n```rust\r\nuse std::io::{self, SeekFrom, prelude::*};\r\nuse std::mem;\r\nuse std::ops::{Deref, DerefMut};\r\n\r\npub trait ReadSeek: Read + Seek {}\r\nimpl<T> ReadSeek for T where T: Read + Seek {}\r\n\r\npub trait StreamContext {\r\n    fn current_offset(&mut self) -> Result<u64, io::Error>;\r\n}\r\n\r\nimpl<S: Seek> StreamContext for S {\r\n    fn current_offset(&mut self) -> Result<u64, io::Error> {\r\n        self.seek(SeekFrom::Current(0))\r\n    }\r\n}\r\n\r\npub struct Droppy<T, F: FnOnce(&mut T)> {\r\n    inner: T,\r\n    dropfn: F,\r\n}\r\n\r\nimpl<T, F: FnOnce(&mut T)> Drop for Droppy<T, F> {\r\n    fn drop(&mut self) {\r\n        let dropfn = mem::replace(&mut self.dropfn, unsafe {\r\n            mem::MaybeUninit::uninit().assume_init()\r\n        });\r\n        let mut inner = mem::replace(&mut self.inner, unsafe {\r\n            mem::MaybeUninit::uninit().assume_init()\r\n        });\r\n        // remove this print statement to get double free error\r\n        print!(\"\");\r\n        dropfn(&mut inner);\r\n    }\r\n}\r\n\r\nimpl<T, F: FnOnce(&mut T)> Droppy<T, F> {\r\n    pub fn new(inner: T, dropfn: F) -> Self {\r\n        Droppy { inner, dropfn }\r\n    }\r\n    pub fn into_inner(mut self) -> T {\r\n        let dropfn = mem::replace(&mut self.dropfn, unsafe {\r\n            mem::MaybeUninit::uninit().assume_init()\r\n        });\r\n        let mut inner = mem::replace(&mut self.inner, unsafe {\r\n            mem::MaybeUninit::uninit().assume_init()\r\n        });\r\n        mem::forget(self);\r\n        dropfn(&mut inner);\r\n        inner\r\n    }\r\n\r\n    pub fn map<U, G: FnOnce(&mut U), X: FnOnce(T) -> U>(mut self, f: X, dropfn: G) -> Droppy<U, G> {\r\n        let _ = mem::replace(&mut self.dropfn, unsafe {\r\n            mem::MaybeUninit::uninit().assume_init()\r\n        });\r\n        let inner = mem::replace(&mut self.inner, unsafe {\r\n            mem::MaybeUninit::uninit().assume_init()\r\n        });\r\n        mem::forget(self);\r\n        Droppy {\r\n            inner: f(inner),\r\n            dropfn,\r\n        }\r\n    }\r\n\r\n    pub fn map_self<X: FnOnce(T) -> T>(mut self, f: X) -> Droppy<T, F> {\r\n        let dropfn = mem::replace(&mut self.dropfn, unsafe {\r\n            mem::MaybeUninit::uninit().assume_init()\r\n        });\r\n        let inner = mem::replace(&mut self.inner, unsafe {\r\n            mem::MaybeUninit::uninit().assume_init()\r\n        });\r\n        mem::forget(self);\r\n        Droppy {\r\n            inner: f(inner),\r\n            dropfn,\r\n        }\r\n    }\r\n}\r\n\r\nimpl<T, F: FnOnce(&mut T)> Deref for Droppy<T, F> {\r\n    type Target = T;\r\n\r\n    fn deref(&self) -> &Self::Target {\r\n        &self.inner\r\n    }\r\n}\r\n\r\nimpl<T, F: FnOnce(&mut T)> DerefMut for Droppy<T, F> {\r\n    fn deref_mut(&mut self) -> &mut Self::Target {\r\n        &mut self.inner\r\n    }\r\n}\r\n\r\npub struct EofGuard<R: Read>(Droppy<R, fn(&mut R)>);\r\n\r\nimpl<R: Read> EofGuard<R> {\r\n    pub fn new(inner: R) -> Self {\r\n        EofGuard(Droppy::new(inner, Self::destruct))\r\n    }\r\n    fn destruct(inner: &mut R) {\r\n        io::copy(inner, &mut io::sink())\r\n            .expect(\"EofGuard::destruct to be able to read the stream to the end\");\r\n    }\r\n    pub fn into_inner(self) -> R {\r\n        self.0.into_inner()\r\n    }\r\n    pub fn map<S: Read, F: FnOnce(R) -> S>(self, f: F) -> EofGuard<S> {\r\n        // without explicitly giving q's type, I get pointer errors\r\n        let q: Droppy<S, fn(&mut S)> = self.0.map(f, EofGuard::destruct);\r\n        EofGuard(q)\r\n    }\r\n}\r\n\r\nimpl<R: Read> Deref for EofGuard<R> {\r\n    type Target = Droppy<R, fn(&mut R)>;\r\n\r\n    fn deref(&self) -> &Self::Target {\r\n        &self.0\r\n    }\r\n}\r\n\r\nimpl<R: Read> DerefMut for EofGuard<R> {\r\n    fn deref_mut(&mut self) -> &mut Self::Target {\r\n        &mut self.0\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use std::io::BufReader;\r\n    use std::io::Cursor;\r\n\r\n    const SAMPLE_SIZE: usize = 64 * 1024;\r\n\r\n    #[derive(Clone, Copy)]\r\n    struct Num(u8);\r\n\r\n    #[test]\r\n    fn droppy1() -> Result<(), io::Error> {\r\n        let mut x: u8 = 0;\r\n        {\r\n            Droppy::new(Num(15), |Num(q)| x = *q);\r\n        }\r\n        assert_eq!(x, 15);\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn droppy2() -> Result<(), io::Error> {\r\n        let mut x: u8 = 0;\r\n        {\r\n            let d = Droppy::new(Num(15), |Num(q)| x = *q);\r\n            let Num(o) = d.into_inner();\r\n            assert_eq!(o, 15);\r\n        }\r\n        {\r\n            let d = Droppy::new(Num(16), |Num(q)| x = *q);\r\n            let Num(o) = d.into_inner();\r\n            assert_eq!(o, 16);\r\n        }\r\n        assert_eq!(x, 16);\r\n        Ok(())\r\n    }\r\n\r\n    fn drop_helper(foo: &mut Num) {\r\n        assert!(foo.0 > 10);\r\n        println!(\"drop_helper: {}\", foo.0);\r\n    }\r\n\r\n    #[test]\r\n    fn droppy3() -> Result<(), io::Error> {\r\n        {\r\n            let d = Droppy::new(Num(15), drop_helper);\r\n            let Num(o) = d.into_inner();\r\n            assert_eq!(o, 15);\r\n        }\r\n        {\r\n            let d = Droppy::new(Num(16), drop_helper);\r\n            let Num(o) = d.into_inner();\r\n            assert_eq!(o, 16);\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn droppy4() -> Result<(), io::Error> {\r\n        let mut x: u8 = 0;\r\n        {\r\n            let d = Droppy::new(Num(15), drop_helper);\r\n            let e = d.map(|Num(x)| x * 2, |q| x = *q);\r\n            let qq = e.into_inner();\r\n            assert_eq!(qq, 30);\r\n        }\r\n        assert_eq!(x, 30);\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn droppy5() -> Result<(), io::Error> {\r\n        let d = Droppy::new(Num(18), drop_helper);\r\n        let e = d.map(|Num(x)| Num(x * 2), drop_helper);\r\n        let Num(qq) = e.into_inner();\r\n        assert_eq!(qq, 36);\r\n        Ok(())\r\n    }\r\n\r\n    fn test_reader() -> impl ReadSeek {\r\n        Cursor::new(vec![0; SAMPLE_SIZE])\r\n    }\r\n\r\n    #[test]\r\n    fn eofguard1() -> Result<(), io::Error> {\r\n        let mut t = test_reader();\r\n        assert_eq!(t.current_offset()?, 0);\r\n\r\n        let mut buf = [0; 128];\r\n        t.read(&mut buf)?;\r\n        assert_eq!(t.current_offset()?, 128);\r\n        {\r\n            let mut g = EofGuard::new(&mut t);\r\n            assert_eq!(g.current_offset()?, 128);\r\n        }\r\n        assert_eq!(t.current_offset()?, SAMPLE_SIZE as u64);\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn eofguard2() -> Result<(), io::Error> {\r\n        let mut t = test_reader();\r\n        assert_eq!(t.current_offset()?, 0);\r\n\r\n        let mut buf = [0; 128];\r\n        t.read(&mut buf)?;\r\n        assert_eq!(t.current_offset()?, 128);\r\n        {\r\n            let mut g = EofGuard::new(t);\r\n            assert_eq!(g.current_offset()?, 128);\r\n            t = g.into_inner();\r\n        }\r\n        assert_eq!(t.current_offset()?, SAMPLE_SIZE as u64);\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn eofguard3() -> Result<(), io::Error> {\r\n        let mut t = test_reader();\r\n        assert_eq!(t.current_offset()?, 0);\r\n\r\n        let mut buf = [0; 128];\r\n        t.read(&mut buf)?;\r\n        assert_eq!(t.current_offset()?, 128);\r\n        let mut g = EofGuard::new(t);\r\n        assert_eq!(g.current_offset()?, 128);\r\n        t = g.into_inner();\r\n        assert_eq!(t.current_offset()?, SAMPLE_SIZE as u64);\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn eofguard4() -> Result<(), io::Error> {\r\n        let mut t = test_reader();\r\n        assert_eq!(t.current_offset()?, 0);\r\n\r\n        let mut buf = [0; 128];\r\n        t.read(&mut buf)?;\r\n        assert_eq!(t.current_offset()?, 128);\r\n        let g = EofGuard::new(&mut t);\r\n        {\r\n            let mut h = g.map(BufReader::new);\r\n            assert_eq!(h.current_offset()?, 128);\r\n        }\r\n        assert_eq!(t.current_offset()?, SAMPLE_SIZE as u64);\r\n        Ok(())\r\n    }\r\n}\r\n\r\nfn main() {\r\n    println!(\"Hello, world!\");\r\n}\r\n```\r\n\r\nIt's not a minimal example, but this way it's easier to understand goals/outcomes.\r\n`Droppy` is supposed to be a smart pointer to make sure some deconstruction takes place when a value goes out of scope (like `Drop`) but still allows explicitly getting the value out (as normally `Drop` types cannot be deconstructed).\r\n\r\n`EofGuard` is an example use for `Droppy`. It wraps a `Read`er and makes sure that no matter what, the stream will read to the end. This is sometimes useful when parsing things in a loop when next iteration of the loop expects the previous one to be consumed in full.\r\n\r\nNow, this code uses some `unsafe` tricks to forcefully deconstruct values. This is my first playing around with `unsafe` so I was very cautious that *double free* and *invalid pointer* errors would probably be caused by me. However, I'm pretty confident I never leak or double free memory.\r\n\r\nThe example - as is - now works fine when running `cargo test`. But only after I had to make 2 adjustments that totally don't make sense to me how they would influence the result. But they do, consistently.\r\n\r\nI would expect it to be OK to remove the *print* statement on line 32, but if I do and run `cargo test` I get\r\n```\r\ndouble free or corruption (out)\r\n```\r\n\r\nAlso, I would expect to be able to inline lines 111 and 112 into\r\n```rust\r\nEofGuard(self.0.map(f, EofGuard::destruct))\r\n```\r\nbut if I do and run `cargo test` I get\r\n```\r\nmunmap_chunk(): invalid pointer\r\n```\r\n\r\nSo I do not understand how these changes can cause this behaviour. And if my `unsafe` trickery is wrong, I don't understand how these changes would mask the problem. So I'm assuming these are bugs. \r\n\r\n### Meta\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.50.0 (cb75ad5db 2021-02-10)\r\nbinary: rustc\r\ncommit-hash: cb75ad5db02783e8b0222fee363c5f63f7e2cf5b\r\ncommit-date: 2021-02-10\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.50.0\r\n```\r\n", "closed_by": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/83275/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/83275/timeline", "performed_via_github_app": null, "state_reason": "completed"}