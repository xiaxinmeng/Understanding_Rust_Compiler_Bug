{"url": "https://api.github.com/repos/rust-lang/rust/issues/103763", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/103763/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/103763/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/103763/events", "html_url": "https://github.com/rust-lang/rust/issues/103763", "id": 1428855810, "node_id": "I_kwDOAAsO6M5VKpwC", "number": 103763, "title": "`Arc::ptr_eq` does not always return \"true if the two Arcs point to the same allocation\" as documented", "user": {"login": "rib", "id": 235361, "node_id": "MDQ6VXNlcjIzNTM2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/235361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rib", "html_url": "https://github.com/rib", "followers_url": "https://api.github.com/users/rib/followers", "following_url": "https://api.github.com/users/rib/following{/other_user}", "gists_url": "https://api.github.com/users/rib/gists{/gist_id}", "starred_url": "https://api.github.com/users/rib/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rib/subscriptions", "organizations_url": "https://api.github.com/users/rib/orgs", "repos_url": "https://api.github.com/users/rib/repos", "events_url": "https://api.github.com/users/rib/events{/privacy}", "received_events_url": "https://api.github.com/users/rib/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}, {"id": 919710011, "node_id": "MDU6TGFiZWw5MTk3MTAwMTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/disposition-merge", "name": "disposition-merge", "color": "008800", "default": false, "description": "This issue / PR is in PFCP or FCP with a disposition to merge it."}, {"id": 923282386, "node_id": "MDU6TGFiZWw5MjMyODIzODY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/finished-final-comment-period", "name": "finished-final-comment-period", "color": "f9e189", "default": false, "description": "The final comment period is finished for this PR / Issue."}], "state": "open", "locked": false, "assignee": {"login": "albertlarsan68", "id": 74931857, "node_id": "MDQ6VXNlcjc0OTMxODU3", "avatar_url": "https://avatars.githubusercontent.com/u/74931857?v=4", "gravatar_id": "", "url": "https://api.github.com/users/albertlarsan68", "html_url": "https://github.com/albertlarsan68", "followers_url": "https://api.github.com/users/albertlarsan68/followers", "following_url": "https://api.github.com/users/albertlarsan68/following{/other_user}", "gists_url": "https://api.github.com/users/albertlarsan68/gists{/gist_id}", "starred_url": "https://api.github.com/users/albertlarsan68/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/albertlarsan68/subscriptions", "organizations_url": "https://api.github.com/users/albertlarsan68/orgs", "repos_url": "https://api.github.com/users/albertlarsan68/repos", "events_url": "https://api.github.com/users/albertlarsan68/events{/privacy}", "received_events_url": "https://api.github.com/users/albertlarsan68/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "albertlarsan68", "id": 74931857, "node_id": "MDQ6VXNlcjc0OTMxODU3", "avatar_url": "https://avatars.githubusercontent.com/u/74931857?v=4", "gravatar_id": "", "url": "https://api.github.com/users/albertlarsan68", "html_url": "https://github.com/albertlarsan68", "followers_url": "https://api.github.com/users/albertlarsan68/followers", "following_url": "https://api.github.com/users/albertlarsan68/following{/other_user}", "gists_url": "https://api.github.com/users/albertlarsan68/gists{/gist_id}", "starred_url": "https://api.github.com/users/albertlarsan68/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/albertlarsan68/subscriptions", "organizations_url": "https://api.github.com/users/albertlarsan68/orgs", "repos_url": "https://api.github.com/users/albertlarsan68/repos", "events_url": "https://api.github.com/users/albertlarsan68/events{/privacy}", "received_events_url": "https://api.github.com/users/albertlarsan68/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 20, "created_at": "2022-10-30T15:22:19Z", "updated_at": "2023-01-05T16:12:42Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "\n<!--\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\nalong with any information you feel relevant to replicating the bug.\n-->\n**Edited: to account for an initial misunderstanding about how `dyn Trait` wide pointers are compared**\n\n_TL;DR_\n_The implementation of `Arc::ptr_eq` is implemented based on comparing pointers to the inner value (not something that the documentation suggests/requires), which may involve comparing wide pointer meta data that is not relevant to it's stated function - and could lead to false negatives_\n\n# How `Arc::ptr_eq` is documented, and current expectations:\n\nFor reference here this is the (I think concise) documentation for `Arc::ptr_eq`:\n> Returns true if the two Arcs point to the same allocation (in a vein similar to [ptr::eq](https://doc.rust-lang.org/std/ptr/fn.eq.html)).\n\nMy expectation from this is rather simple: the implementation will get the pointer for the `Box`/\"allocation\" that is allocated as the backing storage for two arcs (holding the reference count and inner value) and it will compare those pointers with `ptr::eq`.\n\n_Notably: the wrapped type should have no bearing on the implementation / semantics here, since it's the pointer of the \"allocation\" that is supposed (documented) to be compared._\n\nThis way you can create any number of references for a single `Arc` that wraps some inner value and cheaply determine whether two `Arc`s point back to the same state allocation.\n\nI've been relying on those semantics for `Arc::ptr_eq` across a number of projects for exactly that purpose.\n\nFor a few projects I should also note that I have generalized how I wrap state in an `Arc` as an aid for also exposing that state across FFI boundaries. I note this just to highlight the separation of concerns that I have relied on - namely that I assume I can use `Arc::ptr_eq` to check whether two Arcs point to the same state without having to worry about what kind of type is wrapped by the Arc.\n\n# Actual implementation of `Arc::ptr_eq`:\n\nInstead of comparing the pointers of the backing \"allocation\", the current implementation of `Arc::ptr_eq` instead figures out the offset pointer to the inner _value_ and does a comparison of those value pointers with semantics that could vary depending on what is wrapped by the Arc.\n\nI.e. it does `Arc::as_ptr(&a) == Arc::as_ptr(&b)`\n\n_**edited, to address an initial misunderstanding:**_\n~~In particular if an Arc contains a `dyn Trait` then the pointers would be wide/fat pointers and the comparison will compare the vtable pointer for those trait objects which could be equal even though the two `Arc`s are otherwise unrelated, not referencing the same \"allocation\". (I.e. it could return `true` for two Arcs that **don't** point to the same allocation)~~ \n\nIn particular if an Arc contains a `dyn Trait` then the pointers would be wide/fat pointers and the comparison will\ncheck that `target_a == target_b && vtable_a == vtable_b` which makes it possible for the comparison to return `false` for two `Arc`s that have the same allocations but differing vtables.\n\n# Example\n\nBased on https://github.com/rust-lang/rust/pull/80505#issuecomment-752977080\n```rust\nuse std::{sync::Arc, mem};\n\nstruct A(u8);\n#[repr(transparent)]\nstruct B(A);\n\ntrait T {\n    fn f(&self);\n}\nimpl T for A {\n    fn f(&self) { println!(\"A\") }\n}\nimpl T for B {\n    fn f(&self) { println!(\"B\") }\n}\n\n\nfn main() {\n    let b = Arc::new(B(A(92)));\n    let a = unsafe {\n        mem::transmute::<Arc<B>, Arc<A>>(b.clone())\n    };\n    \n    let a: Arc<dyn T> = a;\n    let b: Arc<dyn T> = b;\n    println!(\"{}\", Arc::ptr_eq(&a, &b));\n}\n```\n\n# Discussion\n\nI'm not sure what safety rules have been established for transmuting `Arc`s in such a way as to hit this but the more general consideration here is that Rust supports the notion of wide pointers with meta data whereby that meta data may affect pointer comparisons in various ways depending on the types involved.\n\nThe `Arc::ptr_eq` API is specifically documented to compare whether the \"allocation\" of two Arcs are the same and so I don't believe that the semantics for comparing any form of wide pointer to the inner value should be relevant here.\n\nAdditionally comparing meta data associated with the inner value poses a rather open-ended risk that this function may deviate from its documented function - something that might change further if new types of wide pointers + meta data are added to Rust in the future.\n\nEspecially in the context of state that's being shared over unsafe FFI boundaries I think the potential for deviation from the documentation could be rather dangerous.\n\nEven unrelated to FFI this breaks the basic notion that you can rely on this API compare whether two Arcs reference the same state which may easily break logical invariants that code relies on, for example to implement the `Eq` trait of a higher level type.\n\nAs it happens I discovered this in a project for Json Web Tokens after I introduced Clippy to the project's CI. There was some validation state that was wrapped in an `Arc` (closures that the application could add for validating a token) and discovering that the logic for comparing this validation state is broken by this was particularly concerning for me.\n\n\n# Duplicate issue\n\nThis issue has been discussed before as https://github.com/rust-lang/rust/pull/80505 but I think it was, perhaps, a mistake that the discussion focused on the question of consistency between `ptr::eq` and `Arc::ptr_eq` in terms of how wide pointers should be compared.\n\nThe documentation for `Arc::ptr_eq` gives no suggestion that it is comparing pointers to the wrapped type and so (imho) there is no cause for concern regarding the consistent handling of wide pointer comparisons.\n\nEven considering the mention of `ptr::eq` in the documentation where it says:\n> (in a vein similar to [ptr::eq](https://doc.rust-lang.org/std/ptr/fn.eq.html))\n\nthere is no implication that the inner type of the `Arc` affects what pointers are being compared.\n\n`ptr::eq` should conceptually be used to compare the pointers to the `Arc`s inner allocation, which should just be the raw (non-wide) pointer for the `Box` that encompasses the `Arc`s reference count. In this way the comparison is done \"in a vein similar to `ptr::eq`\" (it may literally use `ptr::eq` internally).\n\n\n# Previous agreement that this is a bug\n\nThe discussion for #80505 seemed to go around in circles but it seems important to highlight that the libraries team did discuss the issue and actually agreed that it was a bug https://github.com/rust-lang/rust/pull/80505#issuecomment-757141449 \n\nWith that agreement it's hard to understand why #80505 was closed. _(It looks like it was essentially closed since it was a pull request not an issue, and there had been some questions raised about the patch that maybe weren't addressed.)_\n\n\n### Meta\n<!--\nIf you're using the stable version of the compiler, you should also check if the\nbug also exists in the beta or nightly versions.\n-->\n\n`rustc --version --verbose`:\n```\nrustc 1.64.0 (a55dd71d5 2022-09-19)\nbinary: rustc\ncommit-hash: a55dd71d5fb0ec5a6a3a9e8c27b2127ba491ce52\ncommit-date: 2022-09-19\nhost: x86_64-pc-windows-msvc\nrelease: 1.64.0\nLLVM version: 14.0.6\n```\n\n\n\n\n<!-- TRIAGEBOT_START -->\n\n<!-- TRIAGEBOT_ASSIGN_START -->\n\n<!-- TRIAGEBOT_ASSIGN_DATA_START$${\"user\":\"albertlarsan68\"}$$TRIAGEBOT_ASSIGN_DATA_END -->\n\n<!-- TRIAGEBOT_ASSIGN_END -->\n<!-- TRIAGEBOT_END -->", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/103763/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/103763/timeline", "performed_via_github_app": null, "state_reason": null}