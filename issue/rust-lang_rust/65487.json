{"url": "https://api.github.com/repos/rust-lang/rust/issues/65487", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/65487/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/65487/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/65487/events", "html_url": "https://github.com/rust-lang/rust/issues/65487", "id": 508205754, "node_id": "MDU6SXNzdWU1MDgyMDU3NTQ=", "number": 65487, "title": "Frequent use of line 0 in debug info reduces effectiveness of Cachegrind", "user": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 203130, "node_id": "MDU6TGFiZWwyMDMxMzA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-debuginfo", "name": "A-debuginfo", "color": "f7e101", "default": false, "description": "Area: Debugging information in compiled programs (DWARF, PDB, etc.)"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 17, "created_at": "2019-10-17T03:09:27Z", "updated_at": "2023-06-14T21:15:06Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I frequently use Cachegrind (and Callgrind) to profile rustc and other Rust programs. Cachegrind attributes instruction counts (and possibly cache misses and branch mispredictions) to specific lines of code, like this:\r\n```\r\n      .               /// Maps a string to its interned representation.\r\n320,664 ( 0.27%)      pub fn intern(string: &str) -> Self {\r\n160,332 ( 0.14%)          with_interner(|interner| interner.intern(string))\r\n267,220 ( 0.23%)      }\r\n```\r\nBut when profiling rustc with Cachegrind, lots of instruction counts don't get attribute to a particular line, so we end up with output like this:\r\n```\r\n1,555,039 ( 1.33%)  <counts for unidentified lines in /home/njn/.cargo/registry/\r\nsrc/github.com-1ecc6299db9ec823/hashbrown-0.6.1/src/raw/mod.rs>\r\n```\r\nOften the fraction of executed instructions that don't get attributed to a particular line is 20%, 30%, or higher. That's a lot!\r\n\r\nThe way Cachegrind works is that the first time an instruction, X, from the binary is executed, Cachegrind gets X's file name and line number from debug info, and X's function name from the symbol table, and creates a (address, filename, fn_name, line_num) cost centre. Every time X is executed the cost centre is incremented appropriately.\r\n\r\nThe problem with the Rust code's debug info is that there are lots of instructions for which the debug info says the line number is 0. That means Cachegrind can't attribute a line, and all executions of such instructions count towards the \"unidentified lines\" entry. Notably, these instructions do have a valid filename.\r\n\r\nI grabbed some debugging output from Valgrind and matched it up with the binary code, as produced by `objdump -d`. What follows is for the function `syntax_pos::symbol::Interner::intern`. The machine code is on the left, and Valgrind's output for each instruction (its runtime address, filename, and line number) is on the right.\r\n```\r\n0000000001b742a0 <_ZN10syntax_pos6symbol8Interner6intern17h6c86044010aa5bfcE>:\r\n 1b742a0:  push   %rbp             # 0x65CF2A0 libsyntax_pos/symbol.rs:976\r\n 1b742a1:  push   %r15             # 0x65CF2A1 libsyntax_pos/symbol.rs:976\r\n 1b742a3:  push   %r14             # 0x65CF2A3 libsyntax_pos/symbol.rs:976\r\n 1b742a5:  push   %r13             # 0x65CF2A5 libsyntax_pos/symbol.rs:976\r\n 1b742a7:  push   %r12             # 0x65CF2A7 libsyntax_pos/symbol.rs:976\r\n 1b742a9:  push   %rbx             # 0x65CF2A9 libsyntax_pos/symbol.rs:976\r\n 1b742aa:  sub    $0x58,%rsp       # 0x65CF2AA libsyntax_pos/symbol.rs:976\r\n 1b742ae:  mov    %rsi,%r13        # 0x65CF2AE libsyntax_pos/symbol.rs:976\r\n 1b742b1:  movabs $0x517cc1b727220a95,%rax\r\n                                   # 0x65CF2B1 libsyntax_pos/symbol.rs:976\r\n 1b742bb:  cmp    $0x8,%rdx        # 0x65CF2BB rustc-hash-1.0.1/src/lib.rs:81\r\n 1b742bf:  jb     1b742e7 <_ZN10syntax_pos6symbol8Interner6intern17h6c86044010aa5bfcE+0x47>\r\n                                   # 0x65CF2BF rustc-hash-1.0.1/src/lib.rs:81\r\n 1b742c1:  lea    -0x8(%rdx),%r8   # 0x65CF2C1 rustc-hash-1.0.1/src/lib.rs:81\r\n 1b742c5:  mov    %r8,%rbp         # 0x65CF2C5 rustc-hash-1.0.1/src/lib.rs:81\r\n 1b742c8:  shr    $0x3,%rbp        # 0x65CF2C8 rustc-hash-1.0.1/src/lib.rs:81\r\n 1b742cc:  add    $0x1,%rbp        # 0x65CF2CC rustc-hash-1.0.1/src/lib.rs:81\r\n 1b742d0:  mov    %ebp,%ecx        # 0x65CF2D0 rustc-hash-1.0.1/src/lib.rs:81\r\n 1b742d2:  and    $0x3,%ecx        # 0x65CF2D2 rustc-hash-1.0.1/src/lib.rs:81\r\n 1b742d5:  cmp    $0x18,%r8        # 0x65CF2D5 rustc-hash-1.0.1/src/lib.rs:81\r\n 1b742d9:  jae    1b742fe <_ZN10syntax_pos6symbol8Interner6intern17h6c86044010aa5bfcE+0x5e>\r\n                                   # 0x65CF2D9 rustc-hash-1.0.1/src/lib.rs:81\r\n 1b742db:  xor    %ebx,%ebx        # 0x65CF2DB rustc-hash-1.0.1/src/lib.rs:0\r\n 1b742dd:  mov    %r13,%rsi        # 0x65CF2DD rustc-hash-1.0.1/src/lib.rs:0\r\n 1b742e0:  test   %rcx,%rcx        # 0x65CF2E0 rustc-hash-1.0.1/src/lib.rs:81\r\n 1b742e3:  jne    1b7434e <_ZN10syntax_pos6symbol8Interner6intern17h6c86044010aa5bfcE+0xae>(0x65CF2E3) -> 1b7434e\r\n                                   # 0x65CF2E3 rustc-hash-1.0.1/src/lib.rs:81\r\n ...                               # ...\r\n 1b7434e:  xor    %ebp,%ebp        # 0x65CF34E rustc-hash-1.0.1/src/lib.rs:0\r\n 1b74350:  rol    $0x5,%rbx        # 0x65CF350 libcore/num/mod.rs:2461\r\n 1b74354:  xor    (%rsi,%rbp,8),%rbx \r\n                                   # 0x65CF354 libcore/ops/bit.rs:306\r\n 1b74358:  imul   %rax,%rbx        # 0x65CF358 libcore/num/mod.rs:3096\r\n 1b7435c:  add    $0x1,%rbp        # 0x65CF35C rustc-hash-1.0.1/src/lib.rs:81\r\n 1b74360:  cmp    %rbp,%rcx        # 0x65CF360 rustc-hash-1.0.1/src/lib.rs:81\r\n 1b74363:  jne    1b74350 <_ZN10syntax_pos6symbol8Interner6intern17h6c86044010aa5bfcE+0xb0>\r\n                                   # 0x65CF363 rustc-hash-1.0.1/src/lib.rs:81\r\n 1b74365:  mov    %r8,%rsi         # 0x65CF365 rustc-hash-1.0.1/src/lib.rs:81\r\n 1b74368:  and    $0xfffffffffffffff8,%rsi\r\n                                   # 0x65CF368 rustc-hash-1.0.1/src/lib.rs:81\r\n 1b7436c:  lea    (%rsi,%r13,1),%rcx\r\n                                   # 0x65CF36C rustc-hash-1.0.1/src/lib.rs:81\r\n 1b74370:  add    $0x8,%rcx        # 0x65CF370 rustc-hash-1.0.1/src/lib.rs:81\r\n 1b74374:  sub    %rsi,%r8         # 0x65CF374 rustc-hash-1.0.1/src/lib.rs:81\r\n 1b74377:  cmp    $0x3,%r8         # 0x65CF377 rustc-hash-1.0.1/src/lib.rs:85\r\n 1b7437b:  jbe    1b74392 <_ZN10syntax_pos6symbol8Interner6intern17h6c86044010aa5bfcE+0xf2>\r\n                                   # 0x65CF37B rustc-hash-1.0.1/src/lib.rs:85\r\n ...                               # ...\r\n 1b74392:  cmp    $0x2,%r8         # 0x65CF392 rustc-hash-1.0.1/src/lib.rs:89\r\n 1b74396:  jae    1b7458b <_ZN10syntax_pos6symbol8Interner6intern17h6c86044010aa5bfcE+0x2eb>\r\n                                   # 0x65CF396 rustc-hash-1.0.1/src/lib.rs:89\r\n 1b7439c:  test   %r8,%r8          # 0x65CF39C rustc-hash-1.0.1/src/lib.rs:93\r\n 1b7439f:  je     1b743af <_ZN10syntax_pos6symbol8Interner6intern17h6c86044010aa5bfcE+0x10f>\r\n                                   # 0x65CF39F rustc-hash-1.0.1/src/lib.rs:93\r\n 1b743a1:  movzbl (%rcx),%ecx      # 0x65CF3A1 rustc-hash-1.0.1/src/lib.rs:94\r\n 1b743a4:  rol    $0x5,%rbx        # 0x65CF3A4 libcore/num/mod.rs:2461\r\n 1b743a8:  xor    %rcx,%rbx        # 0x65CF3A8 libcore/ops/bit.rs:306\r\n 1b743ab:  imul   %rax,%rbx        # 0x65CF3AB libcore/num/mod.rs:3096\r\n 1b743af:  lea    0x30(%rdi),%rcx  # 0x65CF3AF libsyntax_pos/symbol.rs:0\r\n 1b743b3:  mov    %rcx,0x20(%rsp)\r\n                                   # 0x65CF3B3 libsyntax_pos/symbol.rs:0\r\n 1b743b8:  rol    $0x5,%rbx        # 0x65CF3B8 libcore/num/mod.rs:2461\r\n 1b743bc:  xor    $0xff,%rbx       # 0x65CF3BC libcore/ops/bit.rs:306\r\n 1b743c3:  imul   %rax,%rbx        # 0x65CF3C3 libcore/num/mod.rs:3096\r\n 1b743c7:  mov    0x30(%rdi),%rcx\r\n                                   # 0x65CF3C7 hashbrown-0.6.1/src/raw/mod.rs:489\r\n 1b743cb:  mov    0x38(%rdi),%rsi  # 0x65CF3CB hashbrown-0.6.1/src/raw/mod.rs:0\r\n 1b743cf:  mov    %rbx,%rax        # 0x65CF3CF hashbrown-0.6.1/src/raw/mod.rs:0\r\n 1b743d2:  shr    $0x39,%rax       # 0x65CF3D2 hashbrown-0.6.1/src/raw/mod.rs:0\r\n 1b743d6:  movd   %eax,%xmm0       # 0x65CF3D6 hashbrown-0.6.1/src/raw/mod.rs:0\r\n 1b743da:  punpcklbw %xmm0,%xmm0   # 0x65CF3DA hashbrown-0.6.1/src/raw/mod.rs:0\r\n 1b743de:  pshuflw $0xe0,%xmm0,%xmm0\r\n                                   # 0x65CF3DE hashbrown-0.6.1/src/raw/mod.rs:0\r\n 1b743e3:  pshufd $0x0,%xmm0,%xmm1 # 0x65CF3E3 hashbrown-0.6.1/src/raw/mod.rs:0\r\n 1b743e8:  mov    %rdi,0x28(%rsp)  # 0x65CF3E8 hashbrown-0.6.1/src/raw/mod.rs:0\r\n 1b743ed:  mov    0x40(%rdi),%r12  # 0x65CF3ED hashbrown-0.6.1/src/raw/mod.rs:0\r\n 1b743f1:  xor    %ebp,%ebp        # 0x65CF3F1 hashbrown-0.6.1/src/raw/mod.rs:0\r\n 1b743f3:  pcmpeqd %xmm2,%xmm2     # 0x65CF3F3 hashbrown-0.6.1/src/raw/mod.rs:0\r\n 1b743f7:  mov    0x4a9b8a(%rip),%r14        # 201df88 <bcmp@GLIBC_2.2.5>\r\n                                   # 0x65CF3F7 hashbrown-0.6.1/src/raw/mod.rs:0\r\n 1b743fe:  and    %rcx,%rbx        # 0x65CF3FE hashbrown-0.6.1/src/raw/mod.rs:0\r\n 1b74401:  movdqu (%rsi,%rbx,1),%xmm3\r\n                                   # 0x65CF401 libcore/intrinsics.rs:1462\r\n```\r\nThe thing to notice is that the majority of the lines have a valid filename and line number. (The filenames jump around a lot due to inlining. That's fine.) But quite a few of them have a line number of zero. There is no obvious pattern to the zeroes; sometimes there are one or two in a sequence, sometimes there are more.\r\n\r\nIf we trace through these instructions once, here are the filename/linenum pairs that get instructions counted towards them:\r\n```\r\nlibsyntax_pos/symbol.rs:976        x 9\r\nrustc-hash-1.0.1/src/lib.rs:81     x 10\r\nrustc-hash-1.0.1/src/lib.rs:0              (0!)\r\nrustc-hash-1.0.1/src/lib.rs:81     x 2\r\nrustc-hash-1.0.1/src/lib.rs:0              (0!)\r\nlibcore/num/mod.rs:2461\r\nlibcore/ops/bit.rs:306\r\nlibcore/num/mod.rs:3096\r\nrustc-hash-1.0.1/src/lib.rs:81     x 8\r\nrustc-hash-1.0.1/src/lib.rs:85     x 2\r\nrustc-hash-1.0.1/src/lib.rs:89     x 2\r\nrustc-hash-1.0.1/src/lib.rs:93     x 2\r\nrustc-hash-1.0.1/src/lib.rs:94\r\nlibcore/num/mod.rs:2461\r\nlibcore/ops/bit.rs:306\r\nlibcore/num/mod.rs:3096\r\nlibsyntax_pos/symbol.rs:0          x 2     (0!)\r\nlibcore/num/mod.rs:2461\r\nlibcore/ops/bit.rs:306\r\nlibcore/num/mod.rs:3096\r\nhashbrown-0.6.1/src/raw/mod.rs:489\r\nhashbrown-0.6.1/src/raw/mod.rs:0   x 13    (0!)\r\nlibcore/intrinsics.rs:1462\r\n```\r\n47 instructions have a non-zero line number, and 17 have a zero line number.\r\n\r\nI haven't seen this problem occur with C and C++ code.\r\n\r\nI suspect the problem is that the production of debug info isn't rigorous enough in some fashion, and Cachegrind's requirements might be more onerous than other tools'. (Debug info is often not tested thoroughly.) Sometimes it can be non-obvious exactly which line of code an instruction should be attributed to. In that case, I'm not too fussed so long as it's attributed to something plausible and not zero.\r\n\r\ncc @julian-seward1", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/65487/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/65487/timeline", "performed_via_github_app": null, "state_reason": null}