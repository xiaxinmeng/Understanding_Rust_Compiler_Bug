{"url": "https://api.github.com/repos/rust-lang/rust/issues/87352", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/87352/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/87352/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/87352/events", "html_url": "https://github.com/rust-lang/rust/issues/87352", "id": 949948021, "node_id": "MDU6SXNzdWU5NDk5NDgwMjE=", "number": 87352, "title": "potential miscompile involving raw pointers", "user": {"login": "godmar", "id": 486389, "node_id": "MDQ6VXNlcjQ4NjM4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/486389?v=4", "gravatar_id": "", "url": "https://api.github.com/users/godmar", "html_url": "https://github.com/godmar", "followers_url": "https://api.github.com/users/godmar/followers", "following_url": "https://api.github.com/users/godmar/following{/other_user}", "gists_url": "https://api.github.com/users/godmar/gists{/gist_id}", "starred_url": "https://api.github.com/users/godmar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/godmar/subscriptions", "organizations_url": "https://api.github.com/users/godmar/orgs", "repos_url": "https://api.github.com/users/godmar/repos", "events_url": "https://api.github.com/users/godmar/events{/privacy}", "received_events_url": "https://api.github.com/users/godmar/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 17, "created_at": "2021-07-21T17:36:33Z", "updated_at": "2021-07-22T07:51:38Z", "closed_at": "2021-07-22T07:22:56Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Upfront, I will admit that I'm new to Rust and very hesitant to file this report as it involves raw pointers and a small amount of unsafe code.  However, there may be a small chance that the behavior I'm seeing is not desired or is not invoking UB, or that if it is suffering from UB, the UB may be unrelated to the behavior.\r\n\r\nSynopsis:\r\nI'm observing a case where the compiler performs an optimization such that the optimized code exhibits different behavior than the unoptimized code. (The unoptimized code completes as expected, the optimized code enters an infinite loop because the compiler assumed that a particular memory location didn't change, even though it is accessed and changed via a raw pointer.)\r\n\r\nIn short, the loop in question is:\r\n```rust\r\n    fn remove(this: *mut ListElem) {\r\n        unsafe {\r\n            (*(*this).prev).next = (*this).next;\r\n            (*(*this).next).prev = (*this).prev;\r\n        }\r\n    }\r\n...\r\n    fn pop_back(&self) {\r\n        ListElem::remove(self.tail.prev);                                     \r\n    }   \r\n    \r\n    #[inline(never)]                                                          \r\n    fn drain(&self) {\r\n        while self.head.next != ptr::addr_of!(self.tail) as *mut ListElem {   \r\n            self.pop_back();\r\n        }                                                                     \r\n    }\r\n```\r\nIf `pop_back()` is inlined (as it is under normal invocation with `-O`), then it will use the value of `self.tail.prev` as it was on entry to `drain()`, rather than reloading the value on each call to `pop_back()`. \r\nIn other words, `drain()` is compiled as if it had been written as:\r\n```rust\r\n    fn drain(&self) {\r\n        let tmp = self.tail.prev;\r\n        while self.head.next != ptr::addr_of!(self.tail) as *mut ListElem {\r\n            ListElem::remove(tmp);\r\n        }\r\n    }\r\n```\r\n\r\nI've verified this by examining the assembly code, and you may also add a `#[inline(never)]` to `pop_back()` and verify that the behavior under optimization changes.\r\n\r\n[Playground](https://play.rust-lang.org/?version=stable&mode=release&edition=2018&gist=c8201a65f9ee32724f4af273a2a2b560) (to reproduce timeout, compile with 'release')\r\n\r\nI tried this code (either via `rustc` or via `cargo`)\r\n\r\n```rust\r\n// testmin.rs\r\nuse std::ptr;\r\nuse std::boxed::Box;\r\nuse std::pin::Pin;\r\n\r\n#[derive(Debug)]\r\nstruct ListElem {\r\n    prev: *mut ListElem,\r\n    next: *mut ListElem,\r\n}\r\n\r\nimpl ListElem {\r\n    fn new() -> ListElem {\r\n        ListElem {\r\n            prev: ptr::null_mut(),\r\n            next: ptr::null_mut(),\r\n        }\r\n    }\r\n\r\n    fn remove(this: *mut ListElem) {\r\n        unsafe {\r\n            (*(*this).prev).next = (*this).next;\r\n            (*(*this).next).prev = (*this).prev;\r\n        }\r\n    }\r\n}\r\n\r\nstruct List {\r\n    head: ListElem,\r\n    tail: ListElem,\r\n}\r\n\r\nimpl <'a> List {\r\n    fn new() -> Pin<Box<List>> {\r\n        let mut list = Box::pin(List {\r\n            head: ListElem::new(),\r\n            tail: ListElem::new(),\r\n        });\r\n        list.head.next = ptr::addr_of!(list.tail) as *mut ListElem;\r\n        list.tail.prev = ptr::addr_of!(list.head) as *mut ListElem;\r\n        list\r\n    }\r\n\r\n    // if pop_back is inlined, drain is miscompiled because it assumes\r\n    // that `self.tail.prev` doesn't need to be reloaded between calls to\r\n    // self.pop_back()\r\n    //#[inline(never)]\r\n    fn pop_back(&self) {\r\n        ListElem::remove(self.tail.prev);\r\n    }\r\n\r\n    #[inline(never)]\r\n    fn drain(&self) {\r\n        while self.head.next != ptr::addr_of!(self.tail) as *mut ListElem {\r\n            self.pop_back();\r\n        }\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let mut l = List::new();\r\n\r\n    println!(\"part 1, build a list with 2 elements\");\r\n    let mut e1 = Box::pin(ListElem::new());\r\n    let ep1 : *mut ListElem = &mut *e1;\r\n\r\n    let mut e2 = Box::pin(ListElem::new());\r\n    let ep2 : *mut ListElem = &mut *e2;\r\n\r\n    unsafe {\r\n        // set forward pointers head -> e1 -> e2 -> tail\r\n        l.head.next = ep1;\r\n        (*ep1).next = ep2;\r\n        (*ep2).next = ptr::addr_of!(l.tail) as *mut ListElem;\r\n        // set backward pointers tail -> e2 -> e1 -> head\r\n        l.tail.prev = ep2;\r\n        (*ep2).prev = ep1;\r\n        (*ep1).prev = ptr::addr_of!(l.head) as *mut ListElem;\r\n    }\r\n\r\n    println!(\"trying to drain list\");\r\n    l.drain();\r\n    println!(\"complete\");\r\n}\r\n```\r\n\r\nI expected to see this happen: \r\n```\r\npart 1, build a list with 2 elements\r\ntrying to drain list\r\ncomplete\r\n```\r\n\r\nInstead, this happened: \r\n```\r\npart 1, build a list with 2 elements\r\ntrying to drain list\r\n```\r\n(program enters infinite loop)\r\n\r\n### Meta\r\nThis behavior occurs under \r\n\r\n```\r\nrustc 1.53.0 (53cb7b09b 2021-06-17)\r\nbinary: rustc\r\ncommit-hash: 53cb7b09b00cbea8754ffb78e7e3cb521cb8af4b\r\ncommit-date: 2021-06-17\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.53.0\r\nLLVM version: 12.0.1\r\n```\r\n\r\nas well as under nightly:\r\n```\r\nrustc 1.55.0-nightly (7a16cfcff 2021-07-11)\r\nbinary: rustc\r\ncommit-hash: 7a16cfcffc58cd6994984a2c014b0cc27ed8f66b\r\ncommit-date: 2021-07-11\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.55.0-nightly\r\nLLVM version: 12.0.1\r\n```\r\nIt occurs _only_ under `-O` and it doesn't depend on whether `-Z mutable-noalias=no` or `-Z mutable-noalias=yes` is given.\r\n\r\n<details><summary>Backtrace + Assembly</summary>\r\n<p>\r\n\r\n```\r\ngdb) bt\r\n#0  0x000055555555b77b in testmin::List::drain ()\r\n#1  0x000055555555b8b2 in testmin::main ()\r\n#2  0x000055555555b9b3 in std::sys_common::backtrace::__rust_begin_short_backtrace ()\r\n#3  0x000055555555b6f9 in std::rt::lang_start::_$u7b$$u7b$closure$u7d$$u7d$::h0eb3c70533b77608 ()\r\n#4  0x000055555556cd1a in core::ops::function::impls::{impl#2}::call_once<(), dyn core::ops::function::Fn<()>> ()\r\n    at /rustc/7a16cfcffc58cd6994984a2c014b0cc27ed8f66b/library/core/src/ops/function.rs:259\r\n#5  std::panicking::try::do_call<&dyn core::ops::function::Fn<()>, i32> () at library/std/src/panicking.rs:401\r\n#6  std::panicking::try<i32, &dyn core::ops::function::Fn<()>> () at library/std/src/panicking.rs:365\r\n#7  std::panic::catch_unwind<&dyn core::ops::function::Fn<()>, i32> () at library/std/src/panic.rs:434\r\n#8  std::rt::lang_start_internal::{closure#2} () at library/std/src/rt.rs:45\r\n#9  std::panicking::try::do_call<std::rt::lang_start_internal::{closure#2}, isize> () at library/std/src/panicking.rs:401\r\n#10 std::panicking::try<isize, std::rt::lang_start_internal::{closure#2}> () at library/std/src/panicking.rs:365\r\n#11 std::panic::catch_unwind<std::rt::lang_start_internal::{closure#2}, isize> () at library/std/src/panic.rs:434\r\n#12 std::rt::lang_start_internal () at library/std/src/rt.rs:45\r\n#13 0x000055555555b9a2 in main ()\r\n\r\n(gdb) disass\r\nDump of assembler code for function _ZN7testmin4List5drain17hed4c20055222af0aE:\r\n   0x000055555555b760 <+0>:\tlea    0x10(%rdi),%rax\r\n   0x000055555555b764 <+4>:\tcmp    %rax,0x8(%rdi)\r\n   0x000055555555b768 <+8>:\tje     0x55555555b78b <_ZN7testmin4List5drain17hed4c20055222af0aE+43>\r\n   0x000055555555b76a <+10>:\tmov    (%rax),%rcx\r\n   0x000055555555b76d <+13>:\tnopl   (%rax)\r\n   0x000055555555b770 <+16>:\tmov    (%rcx),%rdx\r\n   0x000055555555b773 <+19>:\tmov    0x8(%rcx),%rsi\r\n   0x000055555555b777 <+23>:\tmov    %rsi,0x8(%rdx)\r\n=> 0x000055555555b77b <+27>:\tmov    (%rcx),%rdx\r\n   0x000055555555b77e <+30>:\tmov    0x8(%rcx),%rsi\r\n   0x000055555555b782 <+34>:\tmov    %rdx,(%rsi)\r\n   0x000055555555b785 <+37>:\tcmp    %rax,0x8(%rdi)\r\n   0x000055555555b789 <+41>:\tjne    0x55555555b770 <_ZN7testmin4List5drain17hed4c20055222af0aE+16>\r\n   0x000055555555b78b <+43>:\tret    \r\n```\r\n</p>\r\nAbove, `0x10(%rdi)` contains `self.tail.prev` but it is not reloaded in the loop starting at 0x000055555555b770\r\n</details>\r\n\r\nIf the behavior is due to my invoking UB, I would appreciate a pointer to where the UB lies.\r\n\r\nI tried using MIRI which says:\r\n<details><summary>MIRI Output</summary>\r\n\r\n```\r\npart 1, build a list with 2 elements\r\ntrying to drain list\r\nerror: Undefined Behavior: not granting access to tag <untagged> because incompatible item is protected: [SharedReadOnly for <6195> (call 1791)]\r\n  --> src/bin/testmin.rs:22:13\r\n   |\r\n22 |             (*(*this).next).prev = (*this).prev;\r\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <untagged> because incompatible item is protected: [SharedReadOnly for <6195> (call 1791)]\r\n   |\r\n   = help: this indicates a potential bug in the program: it performed an invalid operation, but the rules it violated are still experimental\r\n   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\r\n           \r\n   = note: inside `ListElem::remove` at src/bin/testmin.rs:22:13\r\nnote: inside `List::pop_back` at src/bin/testmin.rs:48:9\r\n  --> src/bin/testmin.rs:48:9\r\n   |\r\n48 |         ListElem::remove(self.tail.prev);\r\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\nnote: inside `List::drain` at src/bin/testmin.rs:54:13\r\n  --> src/bin/testmin.rs:54:13\r\n   |\r\n54 |             self.pop_back();\r\n   |             ^^^^^^^^^^^^^^^\r\nnote: inside `main` at src/bin/testmin.rs:81:5\r\n  --> src/bin/testmin.rs:81:5\r\n   |\r\n81 |     l.drain();\r\n   |     ^^^^^^^^^\r\n```\r\nwhich is an error I do not understand. From discussions on the users forum it was my impression that Rust's aliasing rules do not apply to raw pointers, but I may have misunderstood.\r\n\r\nThe code itself is derived from a standard sentinel-based doubly linked list.\r\n</details>", "closed_by": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/87352/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/87352/timeline", "performed_via_github_app": null, "state_reason": "completed"}