{"url": "https://api.github.com/repos/rust-lang/rust/issues/26494", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/26494/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/26494/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/26494/events", "html_url": "https://github.com/rust-lang/rust/issues/26494", "id": 90019693, "node_id": "MDU6SXNzdWU5MDAxOTY5Mw==", "number": 26494, "title": "Rust should use registers more aggressively", "user": {"login": "reinerp", "id": 777239, "node_id": "MDQ6VXNlcjc3NzIzOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/777239?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reinerp", "html_url": "https://github.com/reinerp", "followers_url": "https://api.github.com/users/reinerp/followers", "following_url": "https://api.github.com/users/reinerp/following{/other_user}", "gists_url": "https://api.github.com/users/reinerp/gists{/gist_id}", "starred_url": "https://api.github.com/users/reinerp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reinerp/subscriptions", "organizations_url": "https://api.github.com/users/reinerp/orgs", "repos_url": "https://api.github.com/users/reinerp/repos", "events_url": "https://api.github.com/users/reinerp/events{/privacy}", "received_events_url": "https://api.github.com/users/reinerp/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 234956, "node_id": "MDU6TGFiZWwyMzQ5NTY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-codegen", "name": "A-codegen", "color": "f7e101", "default": false, "description": "Area: Code generation"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 14, "created_at": "2015-06-22T05:58:38Z", "updated_at": "2021-12-07T02:58:04Z", "closed_at": "2020-09-27T04:50:42Z", "author_association": "NONE", "active_lock_reason": null, "body": "Rust should pass more structs in registers. Consider these examples: ideally, both functions would execute entirely in registers and wouldn't touch memory:\n\n``` rust\n// Passing small structs by value.\npub fn parameters_by_value(v: (u64, u64)) -> u64 {                                                                                                                                                          \n  v.0 + v.1\n}\n\n// Returning small structs by value.\npub fn return_by_value() -> (u64, u64) {\n  (3, 4)\n}\n```\n\nRust, as of a recent 1.2.0-dev nightly, is unable to pass either of these in registers (see LLVM IR and ASM below). It would be pretty safe to pass and return small structs (ones that fit into <=2 registers) in registers, and is likely to improve performance on average. This is what the System V ABI does.\n\nIt would also be nice to exploit Rust's control over aliasing, and where possible also promote _reference_ arguments to registers, i.e. put the `u64` values in registers for the following functions:\n\n``` rust\n// Passing small structs by reference.\npub fn parameters_by_ref(v: &(u64, u64)) -> u64 {                                                                                                                                                           \n  v.0 + v.1\n}\n\n// Passing small structs by *mutable* reference.                                                                                                                                                            \npub fn mutable_parameters_by_ref(v: &mut (u64, u64)) {                                                                                                                                                      \n  v.0 += 1;\n  v.1 += 2;\n}\n```\n\nIn the `&mut` case, this would mean passing two `u64` values in registers as function parameters, and returning two `u64` values in registers as the return values (ideally we'd arrange for the parameter registers to match the return registers). Uniqueness of `&mut` makes this optimization valid, although we may have to give up on this optimization in cases such as when there are raw pointers present.\n\nHere's a more realistic example where I've wanted Rust to do this:\n\n``` rust\npub fn skip_whitespace(iter: &mut std::str::Chars) -> u64 {\n  // Reads as much whitespace as possible from the front of iter, then returns the number of\n  // characters read.                                                                                                                                                                                       \n  ...\n}\n```\n\nThis function is too large to justify inlining. I'd like the begin and end pointers of `iter` to be kept in registers across the function call.\n\nProbably not surprising to the compiler team, but for completeness here is the LLVM IR of the above snippets, as of today's Rust (1.2.0-dev), compiled in release mode / opt-level=3:\n\n``` llvm\ndefine i64 @_ZN19parameters_by_value20h3d287104250c57c4eaaE({ i64, i64 }* noalias nocapture dereferenceable(16)) unnamed_addr #0 {\nentry-block:\n  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i64 0, i32 0\n  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i64 0, i32 1\n  %3 = load i64, i64* %1, align 8\n  %4 = load i64, i64* %2, align 8\n  %5 = add i64 %4, %3\n  %6 = bitcast { i64, i64 }* %0 to i8*\n  tail call void @llvm.lifetime.end(i64 16, i8* %6)\n  ret i64 %5\n}\n\ndefine void @_ZN15return_by_value20h703d16a2e5f298d6saaE({ i64, i64 }* noalias nocapture sret dereferenceable(16)) unnamed_addr #0 {\nentry-block:\n  %1 = bitcast { i64, i64 }* %0 to i8*\n  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* bitcast ({ i64, i64 }* @const1285 to i8*), i64 16, i32 8, i1 false)\n  ret void\n}\n\ndefine i64 @_ZN17parameters_by_ref20hc9c548b23d173a1aBaaE({ i64, i64 }* noalias nocapture readonly dereferenceable(16)) unnamed_addr #2 {\nentry-block:\n  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i64 0, i32 0\n  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i64 0, i32 1\n  %3 = load i64, i64* %1, align 8\n  %4 = load i64, i64* %2, align 8\n  %5 = add i64 %4, %3\n  ret i64 %5\n}\n\ndefine void @_ZN25mutable_parameters_by_ref20h736bc2daba227c43QaaE({ i64, i64 }* noalias nocapture dereferenceable(16)) unnamed_addr #0 {\nentry-block:\n  %1 = bitcast { i64, i64 }* %0 to <2 x i64>*\n  %2 = load <2 x i64>, <2 x i64>* %1, align 8\n  %3 = add <2 x i64> %2, <i64 1, i64 2>\n  %4 = bitcast { i64, i64 }* %0 to <2 x i64>*\n  store <2 x i64> %3, <2 x i64>* %4, align 8\n  ret void\n}\n```\n\nand here is the ASM:\n\n``` asm\n_ZN19parameters_by_value20h3d287104250c57c4eaaE:\n        .cfi_startproc\n        movq    8(%rdi), %rax\n        addq    (%rdi), %rax\n        retq\n\n_ZN15return_by_value20h703d16a2e5f298d6saaE:\n        .cfi_startproc\n        movups  const1285(%rip), %xmm0\n        movups  %xmm0, (%rdi)\n        movq    %rdi, %rax\n        retq\n\n_ZN17parameters_by_ref20hc9c548b23d173a1aBaaE:\n        .cfi_startproc\n        movq    8(%rdi), %rax\n        addq    (%rdi), %rax\n        retq\n\n_ZN25mutable_parameters_by_ref20h736bc2daba227c43QaaE:\n        .cfi_startproc\n        movdqu  (%rdi), %xmm0\n        paddq   .LCPI3_0(%rip), %xmm0\n        movdqu  %xmm0, (%rdi)\n        retq\n```\n", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/26494/reactions", "total_count": 4, "+1": 4, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/26494/timeline", "performed_via_github_app": null, "state_reason": "completed"}