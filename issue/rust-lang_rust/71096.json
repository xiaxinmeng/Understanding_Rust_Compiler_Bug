{"url": "https://api.github.com/repos/rust-lang/rust/issues/71096", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/71096/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/71096/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/71096/events", "html_url": "https://github.com/rust-lang/rust/issues/71096", "id": 598910655, "node_id": "MDU6SXNzdWU1OTg5MTA2NTU=", "number": 71096, "title": "Missed optimization in i.div_euclid(power_of_two)", "user": {"login": "tspiteri", "id": 18604588, "node_id": "MDQ6VXNlcjE4NjA0NTg4", "avatar_url": "https://avatars.githubusercontent.com/u/18604588?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tspiteri", "html_url": "https://github.com/tspiteri", "followers_url": "https://api.github.com/users/tspiteri/followers", "following_url": "https://api.github.com/users/tspiteri/following{/other_user}", "gists_url": "https://api.github.com/users/tspiteri/gists{/gist_id}", "starred_url": "https://api.github.com/users/tspiteri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tspiteri/subscriptions", "organizations_url": "https://api.github.com/users/tspiteri/orgs", "repos_url": "https://api.github.com/users/tspiteri/repos", "events_url": "https://api.github.com/users/tspiteri/events{/privacy}", "received_events_url": "https://api.github.com/users/tspiteri/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 234956, "node_id": "MDU6TGFiZWwyMzQ5NTY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-codegen", "name": "A-codegen", "color": "f7e101", "default": false, "description": "Area: Code generation"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-04-13T14:09:30Z", "updated_at": "2020-04-14T01:17:36Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "If a signed integer is divided by a power of two using Euclidean division, it is equivalent to an arithmetic shift, but this is not caught. For example\r\n\r\n```rust\r\npub fn foo(a: i32) -> i32 {\r\n    a.div_euclid(4)\r\n}\r\n```\r\nproduces the assembly code\r\n```asm\r\nexample::foo:\r\n        mov     eax, edi\r\n        sar     eax, 31\r\n        shr     eax, 30\r\n        add     eax, edi\r\n        mov     ecx, eax\r\n        sar     ecx, 2\r\n        and     eax, -4\r\n        sub     edi, eax\r\n        sar     edi, 31\r\n        lea     eax, [rdi + rcx]\r\n        ret\r\n```\r\nwhile it could simply be\r\n```asm\r\nexample::foo:\r\n        mov     eax, edi\r\n        sar     eax, 2\r\n        ret\r\n```\r\n\r\n\r\nThe LLVM IR is\r\n```llvm\r\n\r\ndefine i32 @_ZN7example3foo17h28d3a223d67ddccdE(i32 %a) unnamed_addr #0 !dbg !6 {\r\nstart:\r\n  %q.i = sdiv i32 %a, 4, !dbg !9\r\n  %_11.i = srem i32 %a, 4, !dbg !16\r\n  %_11.lobit.i = ashr i32 %_11.i, 31, !dbg !18\r\n  %.0.i = add nsw i32 %_11.lobit.i, %q.i, !dbg !18\r\n  ret i32 %.0.i, !dbg !19\r\n}\r\n\r\nattributes #0 = { norecurse nounwind nonlazybind readnone uwtable \"probe-stack\"=\"__rust_probestack\" \"target-cpu\"=\"x86-64\" }\r\n\r\n```\r\nwhich I interpret to be something like\r\n```rust\r\npub fn foo_ir(a: i32) -> i32 {\r\n    let q = a / 4;\r\n    let r = a % 4;\r\n    let sign_r = if r < 0 { -1 } else { 0 };\r\n    sign_r + q\r\n}\r\n```\r\n(I did check that this function produces the same LLVM IR.)\r\n\r\nI don't know LLVM enough to know whether there is some kind of flooring division intrinsic that could be used to optimize this, or whether this a missed optimization in the LLVM side and LLVM can recognize that pattern into an arithmetic shift.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/71096/reactions", "total_count": 2, "+1": 2, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/71096/timeline", "performed_via_github_app": null, "state_reason": null}