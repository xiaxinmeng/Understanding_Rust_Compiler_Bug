{"url": "https://api.github.com/repos/rust-lang/rust/issues/55727", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/55727/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/55727/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/55727/events", "html_url": "https://github.com/rust-lang/rust/issues/55727", "id": 377974456, "node_id": "MDU6SXNzdWUzNzc5NzQ0NTY=", "number": 55727, "title": "Replace an occurrence of nearest_common_ancestor with is_direct_ancestor", "user": {"login": "jameshamm", "id": 10179936, "node_id": "MDQ6VXNlcjEwMTc5OTM2", "avatar_url": "https://avatars.githubusercontent.com/u/10179936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jameshamm", "html_url": "https://github.com/jameshamm", "followers_url": "https://api.github.com/users/jameshamm/followers", "following_url": "https://api.github.com/users/jameshamm/following{/other_user}", "gists_url": "https://api.github.com/users/jameshamm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jameshamm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jameshamm/subscriptions", "organizations_url": "https://api.github.com/users/jameshamm/orgs", "repos_url": "https://api.github.com/users/jameshamm/repos", "events_url": "https://api.github.com/users/jameshamm/events{/privacy}", "received_events_url": "https://api.github.com/users/jameshamm/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37234, "node_id": "MDU6TGFiZWwzNzIzNA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-cleanup", "name": "C-cleanup", "color": "f5f1fd", "default": false, "description": "Category: PRs that clean code up or issues documenting cleanup."}, {"id": 171502053, "node_id": "MDU6TGFiZWwxNzE1MDIwNTM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-borrow-checker", "name": "A-borrow-checker", "color": "f7e101", "default": false, "description": "Area: The borrow checker"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-11-06T18:21:03Z", "updated_at": "2023-01-28T14:48:46Z", "closed_at": "2023-01-28T14:48:46Z", "author_association": "NONE", "active_lock_reason": null, "body": "In a [blog post](https://blog.mozilla.org/nnethercote/2018/04/30/how-to-speed-up-the-rust-compiler-in-2018/) concerned with the performance of the rust compiler, it mentions nearest_common_ancestor (in [region.rs](https://github.com/rust-lang/rust/blob/master/src/librustc/middle/region.rs#L605)) is a hot section of code.\r\n\r\nTo see where the function is used, I grepped the repo for the function name, which gave 3 results. They are the function definition and two uses of it in [mod.rs](https://github.com/rust-lang/rust/blob/master/src/librustc/infer/lexical_region_resolve/mod.rs).\r\n\r\n```\r\n$ grep -r \"nearest_common_ancestor\"\r\nsrc/librustc/infer/lexical_region_resolve/mod.rs:                    .nearest_common_ancestor(fr_scope, s_id);\r\nsrc/librustc/infer/lexical_region_resolve/mod.rs:                    .nearest_common_ancestor(a_id, b_id);\r\nsrc/librustc/middle/region.rs:    pub fn nearest_common_ancestor(&self, scope_a: Scope, scope_b: Scope) -> Scope {\r\n```\r\n\r\nThe first use of it checks if the nearest common ancestor is the first of the two checked nodes (scopes in this case).\r\n\r\n```\r\nlet r_id = self.region_rels\r\n    .region_scope_tree\r\n    .nearest_common_ancestor(fr_scope, s_id);\r\nif r_id == fr_scope {\r\n    ...\r\n}\r\n```\r\nThe current implementation is overkill as this is equivalent to checking if the first parameter is the same as the second parameter, or is a direct ancestor of the second. Checking if a node is an ancestor of another would hopefully be much simpler and more performant.\r\n\r\n```\r\nlet region_scope_tree = self.region_rels.region_scope_tree;\r\nif region_scope_tree.is_direct_ancestor(fr_scope, s_id) {\r\n   ...\r\n}\r\n```\r\n\r\nAn example implementation of the proposed function could look something like a modified version of the current code for nearest common ancestor\r\n\r\n```\r\npub fn is_direct_ancestor(&self, scope_a: Scope, scope_b: Scope) -> bool {\r\n    if scope_a == scope_b { return true; }\r\n\r\n    let mut a = scope_a;\r\n\r\n    // If `a` has no parent it must be the root, which guarantees\r\n    // it must be a direct ancestor of `b`.\r\n    let (parent_a, parent_a_depth) = match self.parent_map.get(&a) {\r\n        Some(pd) => *pd,\r\n        None => return true,\r\n    };\r\n\r\n    let mut b = scope_b;\r\n\r\n    // If `b` has no parent it must be the root.\r\n    // As they are not the same scope, `a` is not a direct ancestor.\r\n    let (parent_b, parent_b_depth) = match self.parent_map.get(&b) {\r\n        Some(pd) => *pd,\r\n        None => return false,\r\n    };\r\n\r\n    if parent_a_depth >= parent_b_depth {\r\n        // `a` is lower than or the same height as `b`, so it cannot be a direct ancestor. \r\n        return false;\r\n    }\r\n    \r\n    // Walk `b` up the tree until it is at the same depth as `a`.\r\n    b = parent_b;\r\n    for _ in 0..(parent_b_depth - parent_a_depth - 1) {\r\n        b = self.parent_map.get(&b).unwrap().0;\r\n    }\r\n\r\n    // If they are not the same node when at the same depth, then `a` is not an ancestor of `b`\r\n    return a == b;\r\n}\r\n```\r\n\r\nThis could do less work if the function is to return false, and roughly the same if it is true. If maintaining the parent_map used to get the parent id and depth is too costly, another implementation could be a copy of \"is_descendant_of\" from [another section of the compiler](https://github.com/rust-lang/rust/blob/master/src/libsyntax_pos/hygiene.rs#L136) modified to work on scopes.\r\n\r\nSince I don't have performance numbers (or any other metrics to back me up), take the above with a grain of salt.", "closed_by": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/55727/reactions", "total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/55727/timeline", "performed_via_github_app": null, "state_reason": "completed"}