{"url": "https://api.github.com/repos/rust-lang/rust/issues/39930", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/39930/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/39930/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/39930/events", "html_url": "https://github.com/rust-lang/rust/issues/39930", "id": 208650794, "node_id": "MDU6SXNzdWUyMDg2NTA3OTQ=", "number": 39930, "title": "proposal: add compile-time version of unimplemented!()", "user": {"login": "jonhoo", "id": 176295, "node_id": "MDQ6VXNlcjE3NjI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/176295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonhoo", "html_url": "https://github.com/jonhoo", "followers_url": "https://api.github.com/users/jonhoo/followers", "following_url": "https://api.github.com/users/jonhoo/following{/other_user}", "gists_url": "https://api.github.com/users/jonhoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonhoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonhoo/subscriptions", "organizations_url": "https://api.github.com/users/jonhoo/orgs", "repos_url": "https://api.github.com/users/jonhoo/repos", "events_url": "https://api.github.com/users/jonhoo/events{/privacy}", "received_events_url": "https://api.github.com/users/jonhoo/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-02-18T16:08:38Z", "updated_at": "2017-02-19T20:18:37Z", "closed_at": "2017-02-19T20:18:37Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "# Proposal: add compile-time checked version of `unimplemented!()`\r\n\r\nWe all know and love the `unimplemented!()` macro for keeping track of things we haven't yet gotten around to. However, it is only checked at runtime if a certain code path is encountered. This is fine in many cases, but when writing new code from scratch (especially when porting), refactoring large amounts of code, or building comprehensive new features, you often have segments of code that you haven't implemented yet, **but you know you'll have to**.\r\n\r\nAt least for me, it is common to write a chunk of code, but leaving out some annoying edge cases, or maybe logic (like generating a unique identifier) that I want to deal with alter. I *know* that I will have to complete that block of code before the program does something useful, but I want to do it later. This can be either because I want to complete the main logical flow of the code first, because I haven't figured out how to do that part yet, or simply because I want to see if the rest of my code compiles correctly.\r\n\r\nIt would be extremely useful to have a variant of `unimplemented!()` that would generate a compile-time error if present in my code. Something like `incomplete!()`. However, it should have some properties that I believe mean it can't be implemented without some help from the compiler:\r\n\r\n 1. It should be usable as an expression of any type (similar to `!` for `unimplemented!()`)\r\n 2. It should only error if the program compiles correctly. Or rather, it should not prevent any *other* errors from being printed. In essence, all passes of the compiler (including the borrow checker) should run despite the presence of `incomplete!()`.\r\n 3. It should *not* emit warnings about dead code or unused variables following it (which using `unimplemented!()` does).\r\n\r\nThe closest I've been able to come up with on my own is the following\r\n\r\n```rust\r\nmacro_rules! incomplete {\r\n    () => {{\r\n        #[deny(non_snake_case)]\r\n        let _mustBeImplemented = ();\r\n        loop {}\r\n    }}\r\n}\r\n```\r\n\r\nThis will only error out after all compiler passes (2), and since it returns `!`, it is sort of usable in place of any expression (1). However, it does not fit (3), because the infinite loop makes the compiler believe that all code following it is dead. Furthermore, the error it produces is obviously not appropriate for what the macro's intent is.", "closed_by": {"login": "jonhoo", "id": 176295, "node_id": "MDQ6VXNlcjE3NjI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/176295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonhoo", "html_url": "https://github.com/jonhoo", "followers_url": "https://api.github.com/users/jonhoo/followers", "following_url": "https://api.github.com/users/jonhoo/following{/other_user}", "gists_url": "https://api.github.com/users/jonhoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonhoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonhoo/subscriptions", "organizations_url": "https://api.github.com/users/jonhoo/orgs", "repos_url": "https://api.github.com/users/jonhoo/repos", "events_url": "https://api.github.com/users/jonhoo/events{/privacy}", "received_events_url": "https://api.github.com/users/jonhoo/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/39930/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/39930/timeline", "performed_via_github_app": null, "state_reason": "completed"}