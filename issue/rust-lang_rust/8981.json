{"url": "https://api.github.com/repos/rust-lang/rust/issues/8981", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/8981/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/8981/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/8981/events", "html_url": "https://github.com/rust-lang/rust/issues/8981", "id": 19007632, "node_id": "MDU6SXNzdWUxOTAwNzYzMg==", "number": 8981, "title": "switch to a more efficient vector/string representation", "user": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": {"url": "https://api.github.com/repos/rust-lang/rust/milestones/20", "html_url": "https://github.com/rust-lang/rust/milestone/20", "labels_url": "https://api.github.com/repos/rust-lang/rust/milestones/20/labels", "id": 452034, "node_id": "MDk6TWlsZXN0b25lNDUyMDM0", "number": 20, "title": "1.0", "description": "This will be the first major release of Rust, where we offer some guaranteed level of support and backwards compatibility.\r\n\r\nThe significant criteria for this release are:\r\n\r\n* Language backwards compatibility - All major features are in, and in their final form. Generally, the only new language features added after this milestone must be backwards compatible, or to fix soundness holes, though we do expect to have some leeway to make small incompatible fixes that have low impact on existing code bases.\r\n\r\n* Library stability - We have a system of measuring and ensuring the stability of API's, and a significant portion of the standard library is declared stable. Stable API's will not change. Large portions of the standard library need to be stable for 1.0, including primitive types, vectors, strings, option, numerics, collections, some I/O and concurrency.\r\n\r\n* User experience - The system is polished and the presentation is complete and professional. New users have a clear path to using and learning the system. This encompasses the web site, documentation, installation, and tooling.\r\n", "creator": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "open_issues": 0, "closed_issues": 376, "state": "closed", "created_at": "2013-10-10T18:48:33Z", "updated_at": "2016-08-28T23:13:24Z", "due_on": "2015-05-15T07:00:00Z", "closed_at": "2015-05-21T20:59:13Z"}, "comments": 11, "created_at": "2013-09-04T22:34:02Z", "updated_at": "2014-03-02T02:04:29Z", "closed_at": "2014-01-28T13:34:40Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "They are currently represented them as `*{ length, capacity, data[] }`. It means we have to handle trickier `uint` overflow cases, which increases cost size a fair bit. It also means even an empty vector always requires a heap allocation.\n\nC++ represents a vector as `{ length, capacity, *data }`, so a fresh empty vector simply as a `null` data pointer. Unlike the `OptVec` optimization, it does not require an extra branch in every method. Calling `realloc` on a null pointer is well-defined, so you can ignore the special case.\n\nThis has the drawback of making a move involve a 3-word copy, not 1-word. However, passing around unique vectors by-move rather than slices is not common enough to be a very relevant performance issue.\n\nBenchmarks on x86_64 Linux (linux 3.11.5, glibc 2.18):\n\n| Comparison | ~[T] | Proposal |\n| --- | --- | --- |\n| Empty | 29 ns/iter (+/- 1) | 2 ns/iter (+/- 0) |\n| Push 10k, starting at 16 capacity | 45528 ns/iter (+/- 2584) | 7611 ns/iter (+/- 407) |\n| Push 10k, starting at 10k capacity | 43783 ns/iter (+/- 1429) | 6876 ns/iter (+/- 320) |\n| Size | `size_of::<uint>` | `3 * size_of::<uint>` |\n| Empty heap allocation size | minimum `2 * size_of::<uint>` | n/a |\n| 4 element heap allocation size | `2 * size_of::<uint> +  4 * size_of::<T>` | `4 * size_of::<T>` |\n\nNote that since jemalloc is very clever, at some sizes preallocating has next to no advantage for the new proposed vector too.\n\nImplementation:\n\n``` rust\n#[allow(ctypes)];\n\n#[cfg(test)]\nextern mod extra;\n\nuse std::mem::size_of;\nuse std::cast::transmute;\nuse std::unstable::raw::Slice;\nuse std::unstable::intrinsics::move_val_init;\nuse std::ptr::read_ptr;\n\n// redefine these to use `*mut` ...\n\nextern {\n    fn malloc(size: uint) -> *mut u8;\n    fn realloc(ptr: *mut u8, size: uint) -> *mut u8;\n    fn free(ptr: *mut u8);\n    fn abort() -> !;\n}\n\n#[fixed_stack_segment]\nunsafe fn malloc_raw(size: uint) -> *mut u8 {\n    let ptr = malloc(size);\n    if ptr.is_null() {\n        abort()\n    }\n    ptr\n}\n\n#[fixed_stack_segment]\nunsafe fn realloc_raw(ptr: *mut u8, size: uint) -> *mut u8 {\n    let ptr = realloc(ptr, size);\n    if ptr.is_null() {\n        abort()\n    }\n    ptr\n}\n\n#[fixed_stack_segment]\nunsafe fn free_raw(ptr: *mut u8) {\n    free(ptr)\n}\n\nstruct Vec<T> {\n    priv len: uint,\n    priv cap: uint,\n    priv ptr: *mut T\n}\n\nimpl<T> Vec<T> {\n    #[inline]\n    fn new() -> Vec<T> {\n        Vec { len: 0, cap: 0, ptr: 0 as *mut T }\n    }\n\n    #[inline]\n    fn with_capacity(capacity: uint) -> Vec<T> {\n        let size = capacity.checked_mul(&size_of::<T>()).unwrap();\n        unsafe {\n            Vec { len: 0, cap: capacity, ptr: malloc_raw(size) as *mut T }\n        }\n    }\n\n    #[inline]\n    fn shrink_to_fit(&mut self) {\n        unsafe {\n            self.cap = self.len;\n            if self.len == 0 {\n                free_raw(self.ptr as *mut u8);\n                self.ptr = 0 as *mut T;\n            } else {\n                self.ptr = realloc_raw(self.ptr as *mut u8, self.cap * size_of::<T>()) as *mut T;\n            }\n        }\n    }\n\n    #[inline]\n    fn push(&mut self, value: T) {\n        unsafe {\n            if self.len == self.cap {\n                if self.cap == 0 { self.cap += 2 }\n                let old_size = self.cap * size_of::<T>();\n                self.cap = self.cap * 2;\n                let size = old_size.checked_mul(&2).unwrap();\n                self.ptr = realloc_raw(self.ptr as *mut u8, size) as *mut T;\n            }\n\n            let end = self.ptr.offset(self.len as int);\n            move_val_init(&mut *end, value);\n            self.len += 1;\n        }\n    }\n\n    #[inline]\n    fn as_slice<'r>(&'r self) -> &'r [T] {\n        let slice = Slice { data: self.ptr as *T, len: self.len };\n        unsafe { transmute(slice) }\n    }\n\n    #[inline]\n    fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n        let slice = Slice { data: self.ptr as *T, len: self.len };\n        unsafe { transmute(slice) }\n    }\n}\n\n#[unsafe_destructor]\nimpl<T> Drop for Vec<T> {\n    fn drop(&mut self) {\n        unsafe {\n            for x in self.as_mut_slice().mut_iter() {\n                read_ptr(x);\n            }\n            free_raw(self.ptr as *mut u8)\n        }\n    }\n}\n\n#[cfg(test)]\nmod bench {\n    use std;\n    use super::Vec;\n    use extra::test::BenchHarness;\n\n    #[bench]\n    fn empty(bh: &mut BenchHarness) {\n        do bh.iter() {\n            let _xs: Vec<int> = Vec::new();\n        }\n    }\n\n    #[bench]\n    fn empty_std(bh: &mut BenchHarness) {\n        do bh.iter() {\n            let _xs: ~[int] = ~[];\n        }\n    }\n\n    static size: uint = 10000;\n\n    #[bench]\n    fn push(bh: &mut BenchHarness) {\n        do bh.iter() {\n            let mut xs = Vec::with_capacity(16);\n            for i in range(0, size) {\n                xs.push(i);\n            }\n        }\n    }\n\n    #[bench]\n    fn push_std(bh: &mut BenchHarness) {\n        do bh.iter() {\n            let mut xs = std::vec::with_capacity(16);\n            for i in range(0, size) {\n                xs.push(i);\n            }\n        }\n    }\n\n    #[bench]\n    fn push_preallocated(bh: &mut BenchHarness) {\n        do bh.iter() {\n            let mut xs = Vec::with_capacity(size);\n            for i in range(0, size) {\n                xs.push(i);\n            }\n        }\n    }\n\n    #[bench]\n    fn push_preallocated_std(bh: &mut BenchHarness) {\n        do bh.iter() {\n            let mut xs = std::vec::with_capacity(size);\n            for i in range(0, size) {\n                xs.push(i);\n            }\n        }\n    }\n}\n\n#[test]\nfn push() {\n    let mut xs = Vec::new();\n    for x in std::iter::range_step(0, 100, 5) {\n        xs.push(x)\n    }\n    let expected = std::iter::range_step(0, 100, 5).to_owned_vec();\n    assert_eq!(xs.as_slice(), expected.as_slice());\n}\n```\n", "closed_by": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/8981/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/8981/timeline", "performed_via_github_app": null, "state_reason": "completed"}