{"url": "https://api.github.com/repos/rust-lang/rust/issues/88737", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/88737/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/88737/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/88737/events", "html_url": "https://github.com/rust-lang/rust/issues/88737", "id": 990665561, "node_id": "MDU6SXNzdWU5OTA2NjU1NjE=", "number": 88737, "title": "`thread_local!` dtor registration can pass wrong `__dso_handle` if dynamically linked", "user": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 632886930, "node_id": "MDU6TGFiZWw2MzI4ODY5MzA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-thread-locals", "name": "A-thread-locals", "color": "f7e101", "default": false, "description": "Area: Thread local storage (TLS)"}, {"id": 2011781731, "node_id": "MDU6TGFiZWwyMDExNzgxNzMx", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs", "name": "T-libs", "color": "bfd4f2", "default": false, "description": "Relevant to the library team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2021-09-08T03:53:07Z", "updated_at": "2022-10-27T18:10:49Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "On linux and some other platforms, libstd uses `__cxa_thread_atexit_impl` to register destructors for thread locals.\r\n\r\nhttps://github.com/rust-lang/rust/blob/fdf65053e99e8966f9bd83b5a8491326cb33d638/library/std/src/sys/unix/thread_local_dtor.rs#L39\r\n\r\nThe last argument to this is `&__dso_handle`, but this is only correct for threadlocals which are inside libstd, or are in code that is statically linked with libstd.\r\n\r\n`__dso_handle` is a magic symbol which has a value that is unique to whatever DSO is references it. That is, if `libfoo.so` and `libbar.so` both look at `__dso_handle` (or `&__dso_handle`, which is really the value you use), it will have a different value in each.\r\n\r\nYes, I know this isn't how things usually work, this is the entire point of `__dso_handle` (technically, it behaves as if a symbol with \"hidden\" visibility named `__dso_handle` were declared inside each DSO automatically, see https://itanium-cxx-abi.github.io/cxx-abi/abi.html#dso-dtor-runtime-api, although this is clearly a hack).\r\n\r\nIt's behaves very slightly differently depending on a number of moving pieces (libdl, libc, libcxxabi, the linker, the runtime loader, ... \u2014\u00a0collectively I'm going to call these \"the runtime\"), and shows up in a couple different APIs, but here it's being used to remember that that DSO has a pending thread-local dtor, which prevents the DSO from being unloaded until after the said dtors are all run (when all the threads in question are closed).\r\n\r\nSo, to the point: `libstd` always registers this using a `__dso_handle` which is linked from inside itself. This defeats the point of the symbol, as now \"the runtime\" believes that the DSO containing `libstd` is the one responsible for the dtor. This can cause problems in scanarios where libstd is dynamically linked, and dlopen/dlclose is used to dynamically load rust code. (See \"Memory unsafe scenario\" for why)\r\n\r\nI believe the ideal fix here is to have `thread_local!` expand to contain the extern for `__dso_handle` on these systems. Then, `&__dso_handle` would be passed in as an argument to the call to `unix::thread_local_dtor::register_dtor`. I don't know how this interacts with weak symbols, but I'm sure this can be made to work.\r\n\r\n(This is... inconvenient, but it's not that surprising \u2014 if library code *could* be the source for this value, there'd be no need for it to get passed in)\r\n\r\n## Memory unsafe scenario\r\n\r\nConcretely, I think this can lead to a concerning memory unsafety problem in the following scenario:\r\n\r\n1. libstd is dynamically linked into a program.\r\n\r\n2. Some rust library (which also dynamically links libstd) is loaded via dlopen. Let's call this `libmycrate.so` for concreteness.\r\n\r\n3. `libmycrate.so` contains a `thread_local!` (`mycrate::THE_THREAD_LOCAL`) that needs its dtor to be registered.\r\n\r\n4. A thread `T0` is spawned, and `T0` calls some function in `libcrate.so`.\r\n\r\n5. This function references `mycrate::THE_THREAD_LOCAL`, which causes the destructor is registered via `__cxa_thread_atexit_impl` (inside `std::sys::unix::register_dtor`)\r\n    - Note: In this hypothetical, no other threads have registered dtors for `mycrate::THE_THREAD_LOCAL`.\r\n\r\n6. The library `libcrate.so` is unloaded via `dlclose`. This is prior to `T0` ending, and it is not the last Rust crate to be unloaded.\r\n\r\n7. Later `T0` is joined, which runs the thread-specific destructors. This includes `mycrate::THE_THREAD_LOCAL`'s dtor, despite the fact that it has been unloaded.\r\n    - That is, the memory for the dtor function (and internal functions it calls) may be unmapped/freed/in use as something else.\r\n    - Any static data accessed and the like may similarly be no longer alive\r\n\r\n*Note: between 6 and 7, some time may have to pass; `dlclose` is often performed in the background. Also, I'm assuming in this situation that `libmycrate.so` hasn't done anything else to prevent being unloaded. Finally, often the memory from the library is pushed onto a free list for later use, rather than actually being unmapped.*\r\n\r\nAnyway, this is concerning because:\r\n- The situation I described is convoluted but not unthinkably so \u2014\u00a0the most unrealistic situation here is libstd being dynamically linked, and someone using dlopen to work with a Rust crate in this manner.\r\n- It's a use-after-free where we call a function on freed memory, which could lead to problems (for example, if that memory gets returned to the allocator, and then used to allocate something that a potentially-hostile attacker has some control over).\r\n\r\n---\r\n\r\nOn the other hand, this doesn't exist from purely safe stdlib APIs \u2014\u00a0someone had to `unsafe`ly call `dlclose` (perhaps by `Drop`ing a `libloading::Library`), so it's on them.\r\n\r\nWhile I don't find this style of argument compelling, it unfortunately *has* to be the answer to some extent. We can't fix this everywhere, as only some platforms allow defending against this by accepting an equivalent to `&__dso_handle`.\r\n\r\nThat said, this is clearly an example of us passing the wrong value, and I suspect there aren't really great arguments against fixing it. I think this is actually quite a bit of a footgun on platforms where it can't be addressed, but probably the solution is to somehow let people know that `dlclose` (and equivalent) are extremely spooky.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/88737/reactions", "total_count": 2, "+1": 1, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 1}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/88737/timeline", "performed_via_github_app": null, "state_reason": null}