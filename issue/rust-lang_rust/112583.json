{"url": "https://api.github.com/repos/rust-lang/rust/issues/112583", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/112583/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/112583/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/112583/events", "html_url": "https://github.com/rust-lang/rust/issues/112583", "id": 1754769828, "node_id": "I_kwDOAAsO6M5ol6mk", "number": 112583, "title": "Fulfilling trait bound with blanket impl can cause associated type mismatch", "user": {"login": "urben1680", "id": 55257931, "node_id": "MDQ6VXNlcjU1MjU3OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/55257931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urben1680", "html_url": "https://github.com/urben1680", "followers_url": "https://api.github.com/users/urben1680/followers", "following_url": "https://api.github.com/users/urben1680/following{/other_user}", "gists_url": "https://api.github.com/users/urben1680/gists{/gist_id}", "starred_url": "https://api.github.com/users/urben1680/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urben1680/subscriptions", "organizations_url": "https://api.github.com/users/urben1680/orgs", "repos_url": "https://api.github.com/users/urben1680/repos", "events_url": "https://api.github.com/users/urben1680/events{/privacy}", "received_events_url": "https://api.github.com/users/urben1680/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 149689562, "node_id": "MDU6TGFiZWwxNDk2ODk1NjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-associated-items", "name": "A-associated-items", "color": "f7e101", "default": false, "description": "Area: Associated items such as associated types and consts."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}, {"id": 4172483496, "node_id": "LA_kwDOAAsO6M74swuo", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-types", "name": "T-types", "color": "bfd4f2", "default": false, "description": "Relevant to the types team, which will review and decide on the PR/issue."}, {"id": 5260993605, "node_id": "LA_kwDOAAsO6M8AAAABOZRkRQ", "url": "https://api.github.com/repos/rust-lang/rust/labels/fixed-by-next-solver", "name": "fixed-by-next-solver", "color": "93CE7D", "default": false, "description": "Fixed by the next-generation trait solver, `-Ztrait-solver=next`"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2023-06-13T12:28:08Z", "updated_at": "2023-06-13T17:58:06Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "Hello,\r\nI have two traits, one that is to be manually implemented by the user and the other, if the first was implemented in a valid way, is automatically blanket implemented on the same type.\r\n\r\nIf I bound that the first trait must also implement the second, so the compiler points out invalid implementations of it, certain situations can cause associated types to mismatches when they are actually the same.\r\n\r\nMinimal code to replicate:\r\n```rs\r\ntrait Foo: Bar {\r\n    type X;\r\n    fn take_x(x: Self::X);\r\n}\r\n\r\ntrait Bar {\r\n    type Y;\r\n    fn take_y(y: Self::Y);\r\n}\r\n\r\nimpl<T> Bar for T\r\nwhere\r\n    T: Foo, /*and other bounds to validate Foo impl*/\r\n{\r\n    type Y = T::X;\r\n    fn take_y(y: Self::Y) {\r\n        T::take_x(y);\r\n    }\r\n}\r\n```\r\nCauses this error:\r\n\r\n```\r\nCompiling playground v0.0.1 (/playground)\r\nerror[[E0308]](https://doc.rust-lang.org/stable/error_codes/E0308.html): mismatched types\r\n  --> src/lib.rs:17:19\r\n   |\r\n17 |         T::take_x(y);\r\n   |         --------- ^ expected `Foo::X`, found `Bar::Y`\r\n   |         |\r\n   |         arguments to this function are incorrect\r\n   |\r\n   = note: expected associated type `<T as Foo>::X`\r\n              found associated type `<T as Bar>::Y`\r\n   = note: an associated type was expected, but a different one was found\r\nnote: associated function defined here\r\n  --> src/lib.rs:3:8\r\n   |\r\n3  |     fn take_x(x: Self::X);\r\n   |        ^^^^^^\r\n```\r\n\r\n[On the Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=b19a9623a2dba94ec7439da221026924), while the result is the same on Nightly as well.\r\n\r\n<hr>\r\n\r\n### Workaround 1: Bound at caller site instead\r\n\r\n<details>\r\n\r\nOne fix is to not bound `Bar` on `Foo`.\r\n\r\n```rs\r\ntrait Foo/*: Bar*/ {\r\n    type X;\r\n    fn take_x(x: Self::X);\r\n}\r\n```\r\n\r\n[On the playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=94e5833b02ab2407b8a3338650ce8118). \r\n\r\nThat has the downside that the compiler cannot point out invalid implementations of `Foo` before one attempts to use the type somewhere, where now the additional bound with `+ Bar` has to be enforced. \r\n</details>\r\n\r\n<hr>\r\n\r\n### Workaround 2: Impl detail to trait bound\r\n\r\n<details>\r\n\r\nAnother is to bound the types to match in the `Foo` bound already:\r\n\r\n```rs\r\ntrait Foo: Bar<Y = Self::X> {\r\n    type X;\r\n    fn take_x(x: Self::X);\r\n}\r\n\r\n//...\r\n```\r\n\r\n[On the playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=c9915619380677c650a1cc3577358c9a).\r\nThis compiles and might be a solution for some, depending how the actual bounds look like.\r\nThis also limits users who want to manually implement `Bar` for their type where the associated types are not equal.\r\n</details>\r\n\r\n<hr>\r\n\r\n### Failing workaround 1: Another generic in the impl\r\n\r\n<details>\r\n\r\nOne could attempt to bring in another generic into the implementation, but this makes the compiler complain as well and also suggest a solution that is not valid Rust:\r\n\r\n```rs\r\n//...\r\n\r\nimpl<T, U> Bar for T\r\nwhere\r\n    T: Foo<X = U>, /*and other bounds to validate Foo impl*/\r\n{\r\n    type Y = U;\r\n    fn take_y(y: Self::Y) {\r\n        T::take_x(y);\r\n    }\r\n}\r\n```\r\n```\r\nCompiling playground v0.0.1 (/playground)\r\nerror[[E0308]](https://doc.rust-lang.org/stable/error_codes/E0308.html): mismatched types\r\n  --> src/lib.rs:17:19\r\n   |\r\n11 | impl<T, U> Bar for T\r\n   |         - this type parameter\r\n...\r\n17 |         T::take_x(y);\r\n   |         --------- ^ expected type parameter `U`, found associated type\r\n   |         |\r\n   |         arguments to this function are incorrect\r\n   |\r\n   = note: expected type parameter `U`\r\n             found associated type `<T as Bar>::Y`\r\nnote: associated function defined here\r\n  --> src/lib.rs:3:8\r\n   |\r\n3  |     fn take_x(x: Self::X);\r\n   |        ^^^^^^\r\nhelp: consider further restricting this bound\r\n   |\r\n13 |     T: Foo<X = U> + <Y = U>, /*and other bounds to validate Foo impl*/\r\n   |                   +++++++++\r\n```\r\n[On the Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=37869bd7c6227c1117e6570e42cfed46) and [here with the invalid suggestion](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=ec51b53856b67bfeadf2557ca97be183). The behavior is again the same on Nightly here.\r\n</details>\r\n\r\n<hr>\r\n\r\n### Failing workaround 2: Supertrait\r\n\r\n<details>\r\n\r\nAnother attempt is using a super trait, but bounding `Foo` causes a cyclic recursion again, and bounding only `Bar` results in the super trait to be basically an alias of the top code with the same error.\r\n\r\n```rs\r\npub trait FooAndBar: Foo + Bar {}\r\nimpl<T> FooAndBar for T where T: Foo + Bar {}\r\n\r\ntrait Foo: FooAndBar {\r\n    type X;\r\n    fn take_x(x: Self::X);\r\n}\r\n\r\n//...\r\n```\r\n\r\nIf one moves the bounds of the super trait to the impl, it compiles, but lacks the ability to access the implementations of `Foo` and `Bar` now. One would have to mirror both traits in here and [this will cause the initial problem again](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=7a896311fb43d8887352b12fb93f4bda), now in this third trait.\r\n</details>\r\n\r\n<hr>\r\n\r\nMy assumption is that the compiler within the blanket impl assumes that the trait is already implemented and calling `T::take_x(y);` considers an unspecific implementation where the types might not match.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/112583/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/112583/timeline", "performed_via_github_app": null, "state_reason": null}