{"url": "https://api.github.com/repos/rust-lang/rust/issues/66897", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/66897/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/66897/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/66897/events", "html_url": "https://github.com/rust-lang/rust/issues/66897", "id": 530554698, "node_id": "MDU6SXNzdWU1MzA1NTQ2OTg=", "number": 66897, "title": "Unaligned access on aarch64 wih \"+strict-align\" on debug using enum", "user": {"login": "christophcharles", "id": 23055925, "node_id": "MDQ6VXNlcjIzMDU1OTI1", "avatar_url": "https://avatars.githubusercontent.com/u/23055925?v=4", "gravatar_id": "", "url": "https://api.github.com/users/christophcharles", "html_url": "https://github.com/christophcharles", "followers_url": "https://api.github.com/users/christophcharles/followers", "following_url": "https://api.github.com/users/christophcharles/following{/other_user}", "gists_url": "https://api.github.com/users/christophcharles/gists{/gist_id}", "starred_url": "https://api.github.com/users/christophcharles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/christophcharles/subscriptions", "organizations_url": "https://api.github.com/users/christophcharles/orgs", "repos_url": "https://api.github.com/users/christophcharles/repos", "events_url": "https://api.github.com/users/christophcharles/events{/privacy}", "received_events_url": "https://api.github.com/users/christophcharles/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}, {"id": 3940166907, "node_id": "LA_kwDOAAsO6M7q2iz7", "url": "https://api.github.com/repos/rust-lang/rust/labels/O-AArch64", "name": "O-AArch64", "color": "6e6ec0", "default": false, "description": "Armv8-A or later processors in AArch64 mode"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2019-11-30T09:17:53Z", "updated_at": "2023-01-22T22:39:53Z", "closed_at": "2023-01-22T22:39:53Z", "author_association": "NONE", "active_lock_reason": null, "body": "I may have stumbled on a bug regarding aligned access on aarch64: when using enum as return values, in some cases, the rust compiler produces code accessing 64-bit value with 32-bit alignement only, even if \"+string-align\" is selected. The problem is difficult to catch as it really is an issue only if the MMU is disabled (so bare-metal code).\r\n\r\nThis is the minimal code I was able to produce that shows the problem:\r\n\r\n```\r\nenum Result {\r\n    Ok(u32),\r\n    Err(ErrorTest)\r\n}\r\n\r\npub enum ErrorTest {\r\n    InvalidPin,\r\n    Err2\r\n}\r\n\r\nfn test(reg: u32, pin: u32) -> Result {\r\n    if pin < 32 {\r\n        return Result::Ok(reg);\r\n    }\r\n    Result::Err(ErrorTest::InvalidPin)\r\n}\r\n\r\nfn main() {\r\n    let _ = test(0, 14);\r\n}\r\n```\r\nIt is directly inspired from bare metal code that I want to run on aarch64 without the MMU enabled. As such, I am compiling in debug, using \"+strict-align\". Using the target `aarch64-unknown-linux-gnu`, this produces the following assembly for the function`test`:\r\n\r\n```\r\n_ZN12rust_unalign4test17ha1e5255e8972d19dE:\r\n    3bb4:\tff 83 00 d1 \tsub\tsp, sp, #32\r\n    3bb8:\te0 0f 00 b9 \tstr\tw0, [sp, #12]\r\n    3bbc:\te1 13 00 b9 \tstr\tw1, [sp, #16]\r\n    3bc0:\te8 13 40 b9 \tldr\tw8, [sp, #16]\r\n    3bc4:\t1f 81 00 71 \tcmp\tw8, #32\r\n    3bc8:\t63 01 00 54 \tb.lo\t#44 <_ZN12rust_unalign4test17ha1e5255e8972d19dE+0x40>\r\n    3bcc:\t08 00 80 52 \tmov\tw8, #0\r\n    3bd0:\te8 7f 00 39 \tstrb\tw8, [sp, #31]\r\n    3bd4:\te9 53 00 91 \tadd\tx9, sp, #20\r\n    3bd8:\te8 7f 40 39 \tldrb\tw8, [sp, #31]\r\n    3bdc:\t2a 00 80 52 \tmov\tw10, #1\r\n    3be0:\t08 01 0a 0a \tand\tw8, w8, w10\r\n    3be4:\t28 05 00 39 \tstrb\tw8, [x9, #1]\r\n    3be8:\t28 00 80 52 \tmov\tw8, #1\r\n    3bec:\te8 53 00 39 \tstrb\tw8, [sp, #20]\r\n    3bf0:\t05 00 00 14 \tb\t#20 <_ZN12rust_unalign4test17ha1e5255e8972d19dE+0x50>\r\n    3bf4:\te8 0f 40 b9 \tldr\tw8, [sp, #12]\r\n    3bf8:\te8 1b 00 b9 \tstr\tw8, [sp, #24]\r\n    3bfc:\t08 00 80 52 \tmov\tw8, #0\r\n    3c00:\te8 53 00 39 \tstrb\tw8, [sp, #20]\r\n    3c04:\te0 43 41 f8 \tldur\tx0, [sp, #20]\r\n    3c08:\tff 83 00 91 \tadd\tsp, sp, #32\r\n    3c0c:\tc0 03 5f d6 \tret\r\n```\r\nThe instruction at `3c04` is the problematic one as it is accessing a 64-bit value at a 32-bit aligned address (sp is 8-byte aligned).\r\n\r\nThe only way I was able to reproduce this, but I am not sure my search was extensive enough, was by using `enum`. If the discriminant and the stored value naturally fit in two 32-bit fields, rust seems to pack them into a single 64-bit register but forgets to correctly align the access. `struct` does not seem to have this problem.\r\n\r\nThe problem already appears in the llvm-ir produced by `cargo rustc --target aarch64-unknown-linux-gnu -- --emit=llvm-ir`:\r\n```\r\ndefine internal i64 @_ZN12rust_unalign4test17ha1e5255e8972d19dE(i32, i32) unnamed_addr #0 !dbg !13 {\r\nstart:\r\n  %_6 = alloca i8, align 1\r\n  %_0 = alloca %Result, align 4\r\n  %pin = alloca i32, align 4\r\n  %reg = alloca i32, align 4\r\n  store i32 %0, i32* %reg, align 4\r\n  call void @llvm.dbg.declare(metadata i32* %reg, metadata !31, metadata !DIExpression()), !dbg !32\r\n  store i32 %1, i32* %pin, align 4\r\n  call void @llvm.dbg.declare(metadata i32* %pin, metadata !33, metadata !DIExpression()), !dbg !32\r\n  %2 = load i32, i32* %pin, align 4, !dbg !34\r\n  %3 = icmp ult i32 %2, 32, !dbg !34\r\n  br i1 %3, label %bb2, label %bb1, !dbg !35\r\n\r\nbb1:                                              ; preds = %start\r\n  store i8 0, i8* %_6, align 1, !dbg !36\r\n  %4 = bitcast %Result* %_0 to %\"Result::Err\"*, !dbg !37\r\n  %5 = getelementptr inbounds %\"Result::Err\", %\"Result::Err\"* %4, i32 0, i32 1, !dbg !37\r\n  %6 = load i8, i8* %_6, align 1, !dbg !37, !range !38\r\n  %7 = trunc i8 %6 to i1, !dbg !37\r\n  %8 = zext i1 %7 to i8, !dbg !37\r\n  store i8 %8, i8* %5, align 1, !dbg !37\r\n  %9 = bitcast %Result* %_0 to i8*, !dbg !37\r\n  store i8 1, i8* %9, align 4, !dbg !37\r\n  br label %bb3, !dbg !39\r\n\r\nbb2:                                              ; preds = %start\r\n  %10 = load i32, i32* %reg, align 4, !dbg !40\r\n  %11 = bitcast %Result* %_0 to %\"Result::Ok\"*, !dbg !41\r\n  %12 = getelementptr inbounds %\"Result::Ok\", %\"Result::Ok\"* %11, i32 0, i32 1, !dbg !41\r\n  store i32 %10, i32* %12, align 4, !dbg !41\r\n  %13 = bitcast %Result* %_0 to i8*, !dbg !41\r\n  store i8 0, i8* %13, align 4, !dbg !41\r\n  br label %bb3, !dbg !42\r\n\r\nbb3:                                              ; preds = %bb1, %bb2\r\n  %14 = bitcast %Result* %_0 to i64*, !dbg !39\r\n  %15 = load i64, i64* %14, align 4, !dbg !39\r\n  ret i64 %15, !dbg !39\r\n}\r\n```\r\nHere we can see that the return value is loaded through an ```i64``` with 4-byte alignement which translates to the wrong alignement in the final assembly.\r\n\r\nHere is a link to the source to reproduce the bug:\r\n[https://github.com/christophcharles/rust_unalign](https://github.com/christophcharles/rust_unalign)\r\nI have put the assembly outputs of various stages and platforms in the asm folder.\r\n\r\nI am not savvy enough to dabble into the rust source code but it seems to affect both stable and nightly rust. All the examples here though are using stable.\r\n\r\n## Meta\r\n\r\n`rustc --version --verbose` (used for these outputs):\r\n```rustc 1.39.0 (4560ea788 2019-11-04)\r\nbinary: rustc\r\ncommit-hash: 4560ea788cb760f0a34127156c78e2552949f734\r\ncommit-date: 2019-11-04\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.39.0\r\nLLVM version: 9.0```\r\n\r\n", "closed_by": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/66897/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/66897/timeline", "performed_via_github_app": null, "state_reason": "completed"}