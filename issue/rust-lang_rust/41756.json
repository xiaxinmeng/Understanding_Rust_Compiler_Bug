{"url": "https://api.github.com/repos/rust-lang/rust/issues/41756", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/41756/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/41756/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/41756/events", "html_url": "https://github.com/rust-lang/rust/issues/41756", "id": 226393877, "node_id": "MDU6SXNzdWUyMjYzOTM4Nzc=", "number": 41756, "title": "Reordering where clauses can change program behavior", "user": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 13836860, "node_id": "MDU6TGFiZWwxMzgzNjg2MA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-traits", "name": "A-traits", "color": "f7e101", "default": false, "description": "Area: Trait system"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}, {"id": 4172483496, "node_id": "LA_kwDOAAsO6M74swuo", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-types", "name": "T-types", "color": "bfd4f2", "default": false, "description": "Relevant to the types team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 15, "created_at": "2017-05-04T20:07:28Z", "updated_at": "2023-04-05T17:39:37Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "Here's a contrived example:\r\n\r\n```rust\r\nuse std::fmt::Debug;\r\n\r\ntrait Left<T> {}\r\ntrait Right<T> {}\r\n\r\ntrait Join<U> {\r\n    fn test();\r\n}\r\n\r\n// With the reordering,\r\n//   impl<T, U> Join<U> for T where T: Right<U>, T: Left<U>, U: Default + Debug {\r\n// you'll get a different output\r\nimpl<T, U> Join<U> for T where T: Left<U>, T: Right<U>, U: Default + Debug {\r\n    fn test() {\r\n        println!(\"{:?}\", U::default())\r\n    }\r\n}\r\n\r\nimpl<T, U: Default + Debug> Left<U> for T {}\r\nimpl<T, U: Default + Debug> Right<U> for T {}\r\n\r\nfn try_it<T: Default + Debug>() where T: Left<bool>, T: Right<()> {\r\n    <T as Join<_>>::test()\r\n}\r\n\r\nfn main() {\r\n    try_it::<u8>() // the type here is irrelevant\r\n}\r\n```\r\n\r\nIn the order given, the output is `false`. If you swap the order as suggested in the comment, the output is `()`.\r\n\r\nWhat's happening here is a combination of a few things. The `Join` impl creates obligations in order of its where clauses, and the solution to each obligation informs inference, which affects future obligations. At the same time, when it comes time to show `T: Left<U>`, for example, it can be proved either by virtue of the blanket impl or the where clause on `try_it`. We currently give preference to the where clause, which then drives inference.\r\n\r\nThe same mechanisms also lead to cases where:\r\n\r\n1. Adding a valid where clause can cause code to stop compiling.\r\n2. Adding a where clause can change program behavior.\r\n\r\nThese issues seem fairly fundamental to the where clause preference approach, which is something we likely cannot change backwards compatibly (and there were good reasons for it in the first place). So it's possible that we will just have to live with these consequences. But I wanted to file a bug for posterity.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/41756/reactions", "total_count": 9, "+1": 0, "-1": 0, "laugh": 8, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 1}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/41756/timeline", "performed_via_github_app": null, "state_reason": null}