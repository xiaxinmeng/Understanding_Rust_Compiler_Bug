{"url": "https://api.github.com/repos/rust-lang/rust/issues/45988", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/45988/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/45988/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/45988/events", "html_url": "https://github.com/rust-lang/rust/issues/45988", "id": 273906983, "node_id": "MDU6SXNzdWUyNzM5MDY5ODM=", "number": 45988, "title": "three-point error messages in borrowck", "user": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 693664741, "node_id": "MDU6TGFiZWw2OTM2NjQ3NDE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/E-needs-mentor", "name": "E-needs-mentor", "color": "02e10c", "default": false, "description": "Call for participation: This issue is in need of a mentor."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2017-11-14T19:06:12Z", "updated_at": "2017-12-21T02:05:37Z", "closed_at": "2017-12-21T02:05:37Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "The NLL RFC goes to some lengths to discuss [how to phrase NLL error messages](https://github.com/nikomatsakis/nll-rfc/blob/master/0000-nonlexical-lifetimes.md#how-we-teach-this). In particular, we want to adopt the so-called \"three point\" style:\r\n\r\n```\r\nerror[E0506]: cannot write to `i` while borrowed\r\n --> <anon>:4:5\r\n   |\r\n 3 |     let x = &i;\r\n   |              - (shared) borrow of `i` occurs here\r\n 4 |     i += 1;\r\n   |     ^^^^^^ write to `i` occurs here, while borrow is still active\r\n 5 |     println!(\"{}\", x);\r\n   |                    - borrow is later used here\r\n```\r\n\r\nThis is going to require a bit of work. Right now, we easily have two of those points: the borrow checker has identified a borrow, and it knows where it occurred (that's the \"borrow occurs here\" point). It has also identified an access, and it knows where *that* occurs (that's the \"write occurs here\" point). What it does not know is the \"borrow is later used here\" point. That's a bit harder for us to find.\r\n\r\nRight now, what we have *readily* available is just the region of the borrow. This indicates all the points in the control-flow graph where the borrow is still \"live\" (potentially in use), but it does not indicate **why** the borrow is potentially in use. It's the **why** (i.e., what use caused us to consider this point as part of the region) that we are interested in here.\r\n\r\nStill, we have all the information we theoretically need. We have the region inference context, which contains the full set of constraints that we used to find the regions, and we have the MIR itself. (This is intentional: in the lexical checker, we only kept the final results of inference, and not the constraints that led to those results, which sometimes hobbled our ability to issue errors we wanted.)\r\n\r\nHowever, it's still a bit of an open question how best to make use of those constraints to find the point in question. We could probably do some kind of graph-search heuristics that would lead us to the right point most of the time. I've also been considering another idea: we could re-run inference, but this time use different data structures. Rather than treating regions as simple sets of points, we would consider a region to be a set of `(P, U)` tuples. Here `P` is the liveness point, but `U` is some use of a variable (i.e., probably itself a pair `(Pu, X)` of a point of use and a variable name). The idea is that the region `R` contains the point `P` because of the use `U`.  We'd have to extend liveness to track not only which variables are live, but what *use* `U` makes them live at that point. \r\n\r\nThe rest of inference is effectively unchanged, except that we track these pairs, so that whenever we add a point to a region, we also track the variable that made that point live (ultimately, every point in any region stems from some live use). This would be more expensive -- more data! -- but we're only doing it in the case of error. We could also do a more targeted form of inference, limiting ourselves to the regions that are in some way connected to the borrow region.\r\n\r\nIf we did that, then ultimately the borrow region would be inferred to contain some number of `(P, U)` tuples where `P` is the point of access and the use `U` is the third point we want to highlight.\r\n\r\nWhat is appealing about this is that it is a very precise, very general analysis. What is unappealing is that it requires reproducing a lot of code. But we might be able to factor out most of it with generics so that it's not so much re-use.\r\n\r\nIf we don't do this, I'm not sure quite sure what else we would do. I can imagine some heuristics search -- basically making a graph that shows which regions are connected to what and then searching for a use of some variable X that contains a region P that is connected in some way to the borrow region -- but I haven't thought of anything else that yields the right results without essentially reproducing the analysis in some way. That heuristic search might or might not be good enough; I'd really prefer not to give wrong results to the user.", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/45988/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/45988/timeline", "performed_via_github_app": null, "state_reason": "completed"}