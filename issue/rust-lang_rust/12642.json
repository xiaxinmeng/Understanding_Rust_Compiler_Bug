{"url": "https://api.github.com/repos/rust-lang/rust/issues/12642", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/12642/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/12642/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/12642/events", "html_url": "https://github.com/rust-lang/rust/issues/12642", "id": 28556182, "node_id": "MDU6SXNzdWUyODU1NjE4Mg==", "number": 12642, "title": "Idea: \"compact\" enums and structs", "user": {"login": "glaebhoerl", "id": 1216629, "node_id": "MDQ6VXNlcjEyMTY2Mjk=", "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glaebhoerl", "html_url": "https://github.com/glaebhoerl", "followers_url": "https://api.github.com/users/glaebhoerl/followers", "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}", "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}", "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions", "organizations_url": "https://api.github.com/users/glaebhoerl/orgs", "repos_url": "https://api.github.com/users/glaebhoerl/repos", "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}", "received_events_url": "https://api.github.com/users/glaebhoerl/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2014-03-01T12:33:09Z", "updated_at": "2014-09-24T05:00:42Z", "closed_at": "2014-09-24T05:00:42Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "TL;DR By optionally taking away interior references, enums and structs can be represented much more compactly, potentially taking over most of the current use cases for manual bit twiddling code.\n\n---\n\nRust leaves the layout of its enum types undefined for optimization purposes, but in practice most optimization possibilities are ruled out by the fact that interior references need to work. For instance, if you have an enum which contains another enum, you may want to collapse their discriminants together into a single field:\n\n```\nenum X { Foo(Option<bool>), Bar(bool) }\n```\n\nHere we could use a single discrimant field for both `X` and `Option`, so that it ranges 0..2, e.g. 0 => `Foo(None)`, 1 => `Foo(Some)`, 2 => `Bar`. Going further, we could pack in the `bool`s as well, and represent `X` as a single `u8`: 0 => `Foo(None)`, 1 => `Foo(Some(false))`, 2 => `Foo(Some(true))`, 3 => `Bar(false)`, 4 => `Bar(true)`. But in both cases, this makes interior references, e.g. `match some_x { Foo(ref opt_bool) => ..., _ => ... }` impossible, so we must refrain.\n\nThe idea would be to allow annotating an enum as \"compact\", in which case interior references are made illegal (but see below), and these optimization possibilities are opened back up: the compiler would be free to use any magic it wants to make the representation of the enum as compact as it is able, combining discriminants as above, taking advantage of tag bits in pointers, [NaN-boxing](http://evilpie.github.io/sayrer-fatval-backup/cache.aspx.htm), and so on. When generating code, the compiler would insert the necessary bit twiddling operations to pack the original values into this representation, and to take them back out again.\n\nThe same thing is possible for structs. For instance, a struct of `bool`s could be represented as a bunch of bits:\n\n```\ncompact struct Flags { \n    is_big: bool,\n    is_red: bool,\n    is_quick: bool,\n    is_hungry: bool,\n    ...\n}\n```\n\nNow `size_of::<Flags>()` == `size_of::<u8>()`! If we let our imagination run further ahead, given types like `i31`, `i30` and so on, we could also take advantage of those extra bits.\n\n(It's important to note that this \"compactifying\" could always be _deep_, because the restriction against interior references would also be deep. If we have a non-compact struct type and store it in a compact one, references to the interior of the inner struct would likewise be forbidden, so it could be compacted as well. The example from above of representing `enum X` as a single `u8` also relies on this property.)\n\nI think this feature could be a much nicer solution for most of the use cases where manual bit twiddling code is currently necessary (and also most of the use cases for bitfields in C).\n\n---\n\nUp until now, for simplicity's sake I've been assuming that interior references would  be forbidden. But it may be possible to allow them. The idea is that when you take an interior reference:\n\n```\nlet hungry: &bool = &my_flags.is_hungry;\n```\n\nthe value would first be copied out onto the stack (only physically, not semantically!), and then the reference would point to the stack value. This is not dissimilar to what happens if you write `let nine = &9;`. Because `&` is an immutable reference, the difference would not be observable.\n\nGoing deeper into the woods, assuming #12624, `&mut` borrows could also be represented by copying out the value at the beginning of the borrow, _and then copying it back_ at the end. Again, because `&mut` would have exclusive access to the given object, the difference should not be observable. \n\nI'm not sure if this would _definitely_ work, but it seems like it might. Whether this is feasible has repercussions for syntax: if compact enums/structs are semantically identical to normal ones, and differ only in representation and performance, `#[compact]` could just be an attribute. If, however, the semantics differ, it would be more appropriate to use actual syntax to mark the difference.\n", "closed_by": {"login": "rust-highfive", "id": 7378925, "node_id": "MDQ6VXNlcjczNzg5MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/7378925?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rust-highfive", "html_url": "https://github.com/rust-highfive", "followers_url": "https://api.github.com/users/rust-highfive/followers", "following_url": "https://api.github.com/users/rust-highfive/following{/other_user}", "gists_url": "https://api.github.com/users/rust-highfive/gists{/gist_id}", "starred_url": "https://api.github.com/users/rust-highfive/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rust-highfive/subscriptions", "organizations_url": "https://api.github.com/users/rust-highfive/orgs", "repos_url": "https://api.github.com/users/rust-highfive/repos", "events_url": "https://api.github.com/users/rust-highfive/events{/privacy}", "received_events_url": "https://api.github.com/users/rust-highfive/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/12642/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/12642/timeline", "performed_via_github_app": null, "state_reason": "completed"}