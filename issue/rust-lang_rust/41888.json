{"url": "https://api.github.com/repos/rust-lang/rust/issues/41888", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/41888/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/41888/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/41888/events", "html_url": "https://github.com/rust-lang/rust/issues/41888", "id": 227727017, "node_id": "MDU6SXNzdWUyMjc3MjcwMTc=", "number": 41888, "title": "program segfaults when compiled with opt-level>0", "user": {"login": "dwrensha", "id": 495768, "node_id": "MDQ6VXNlcjQ5NTc2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/495768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dwrensha", "html_url": "https://github.com/dwrensha", "followers_url": "https://api.github.com/users/dwrensha/followers", "following_url": "https://api.github.com/users/dwrensha/following{/other_user}", "gists_url": "https://api.github.com/users/dwrensha/gists{/gist_id}", "starred_url": "https://api.github.com/users/dwrensha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dwrensha/subscriptions", "organizations_url": "https://api.github.com/users/dwrensha/orgs", "repos_url": "https://api.github.com/users/dwrensha/repos", "events_url": "https://api.github.com/users/dwrensha/events{/privacy}", "received_events_url": "https://api.github.com/users/dwrensha/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 100522, "node_id": "MDU6TGFiZWwxMDA1MjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-crash", "name": "I-crash", "color": "e10c02", "default": false, "description": "Issue: The compiler crashes (SIGSEGV, SIGABRT, etc). Use I-ICE instead when the compiler panics."}, {"id": 203429200, "node_id": "MDU6TGFiZWwyMDM0MjkyMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/P-high", "name": "P-high", "color": "eb6420", "default": false, "description": "High priority"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 262252840, "node_id": "MDU6TGFiZWwyNjIyNTI4NDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/regression-from-stable-to-stable", "name": "regression-from-stable-to-stable", "color": "e4008a", "default": false, "description": "Performance or correctness regression from one stable version to another."}], "state": "closed", "locked": false, "assignee": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 13, "created_at": "2017-05-10T15:50:47Z", "updated_at": "2017-05-28T14:27:03Z", "closed_at": "2017-05-28T14:27:03Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "The following program (reduced from https://github.com/shepmaster/fuzzy-pickles/issues/62) segfaults when compiled with optimizations in `panic=abort` mode using beta or nightly `rustc`.\r\n\r\n<details>\r\n<summary> code </summary>\r\n\r\n```rust\r\n// parse.rs\r\n\r\nfn main() {\r\n    let tokens = &[Token::Ident, Token::AmpersandEquals, Token::Ident];\r\n    let _ = expression(Point::new(tokens));\r\n}\r\n\r\nstruct Progress<'s, T> {\r\n    point: Point<'s>,\r\n    status: Result<T, ()>,\r\n}\r\n\r\nimpl<'s, T> Progress<'s, T> {\r\n    pub fn success(point: Point<'s>, val: T) -> Self {\r\n        Progress { point: point, status: Ok(val) }\r\n    }\r\n\r\n    pub fn failure(point: Point<'s>) -> Self {\r\n        Progress { point: point, status: Err(()) }\r\n    }\r\n\r\n    pub fn map<F, T2>(self, f: F) -> Progress<'s, T2>\r\n        where F: FnOnce(T) -> T2\r\n    {\r\n        Progress { point: self.point, status: self.status.map(f) }\r\n    }\r\n}\r\n\r\n#[derive(Copy, Clone)]\r\nenum Token {\r\n    AmpersandEquals,\r\n    Ident,\r\n}\r\n\r\nimpl Token {\r\n    fn into_ident(self) -> Option<Extent> {\r\n        match self {\r\n            Token::Ident => Some((0,0)),\r\n            _ => None,\r\n        }\r\n    }\r\n\r\n    fn into_ampersand_equals(self) -> Option<Extent> {\r\n        match self {\r\n            Token::AmpersandEquals => Some((0,0)),\r\n            _ => None,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Copy, Clone)]\r\nstruct Point<'s> {\r\n    pub offset: usize,\r\n    pub s: &'s [Token],\r\n}\r\n\r\nimpl<'s> Point<'s> {\r\n    fn new(slice: &'s [Token]) -> Self {\r\n        Point {\r\n            offset: 0,\r\n            s: slice,\r\n        }\r\n    }\r\n\r\n    fn advance_by(&self, offset: usize) -> Self {\r\n        Point {\r\n            offset: self.offset + offset,\r\n            s: &self.s[offset..],\r\n        }\r\n    }\r\n}\r\n\r\npub type Extent = (usize, usize);\r\n\r\nenum Expression {\r\n    AsType(AsType),\r\n    Binary(Binary),\r\n    Call(Call),\r\n    FieldAccess(FieldAccess),\r\n    Slice(Slice),\r\n    Value(Value),\r\n}\r\n\r\nstruct FieldAccess {\r\n    target: Box<Expression>,\r\n}\r\n\r\npub struct Value;\r\n\r\npub struct Call {\r\n    extent: Extent,\r\n    target: Box<Expression>,\r\n    args: Vec<Expression>,\r\n}\r\n\r\npub struct Binary {\r\n    lhs: Box<Expression>,\r\n    rhs: Box<Expression>,\r\n}\r\n\r\nstruct AsType {\r\n    extent: Extent,\r\n    target: Box<Expression>,\r\n}\r\n\r\nstruct Slice {\r\n    target: Box<Expression>,\r\n    index: Box<Expression>,\r\n}\r\n\r\nfn token<'s, F, T>(token_convert: F, pt: Point<'s>) ->\r\n    Progress<'s, T>\r\n    where F: Fn(Token) -> Option<T>,\r\n{\r\n    let original_token = match pt.s.first() {\r\n        Some(&token) => token,\r\n        None => return Progress::failure(pt),\r\n    };\r\n\r\n    match token_convert(original_token) {\r\n        Some(v) => {\r\n            Progress::success(pt.advance_by(1), v)\r\n        }\r\n        None => {\r\n            Progress::failure(pt)\r\n        }\r\n    }\r\n}\r\n\r\nenum OperatorInfix {\r\n    BitwiseAndAssign(Extent),\r\n}\r\n\r\nenum OperatorPostfix {\r\n    AsType { typ: () },\r\n    Call { args: Vec<Expression> },\r\n    FieldAccess { field: () },\r\n    Slice { index: Expression },\r\n}\r\n\r\nenum OperatorKind {\r\n    Infix(OperatorInfix),\r\n    Postfix(OperatorPostfix),\r\n}\r\n\r\nimpl OperatorKind {\r\n    fn precedence(&self) -> u8 {\r\n        match *self {\r\n            OperatorKind::Infix(_) => 10,\r\n            OperatorKind::Postfix(OperatorPostfix::Call { .. }) => 10,\r\n            OperatorKind::Postfix(_) => 20,\r\n        }\r\n    }\r\n}\r\n\r\nenum InfixOrPostfix {\r\n    Infix(OperatorInfix),\r\n    Postfix(OperatorPostfix),\r\n}\r\n\r\nstruct ShuntCar<'s, T> {\r\n    value: T,\r\n    spt: Point<'s>,\r\n    ept: Point<'s>,\r\n}\r\n\r\nstruct ShuntingYard<'s> {\r\n    operators: Vec<ShuntCar<'s, OperatorKind>>,\r\n    result: Vec<ShuntCar<'s, Expression>>,\r\n}\r\n\r\ntype PointRange<'s> = std::ops::Range<Point<'s>>;\r\ntype ExprResult<'s, T> = std::result::Result<T, Point<'s>>;\r\n\r\nimpl<'s> ShuntingYard<'s> {\r\n    fn add_infix(&mut self, op: OperatorInfix, spt: Point<'s>, ept: Point<'s>) -> ExprResult<'s, ()>\r\n    {\r\n        let op = OperatorKind::Infix(op);\r\n        self.apply_precedence(&op)?;\r\n        self.operators.push(ShuntCar { value: op, spt, ept });\r\n        Ok(())\r\n    }\r\n\r\n    fn apply_precedence(&mut self, operator: &OperatorKind) -> ExprResult<'s, ()>  {\r\n        let op_precedence = operator.precedence();\r\n        while self.operators.last().map_or(false, |&ShuntCar { value: ref top, .. }| top.precedence() > op_precedence) {\r\n            let ShuntCar { value: _, spt, ept } = self.operators.pop().unwrap();\r\n            self.apply_binary(spt..ept)?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    fn apply_all(&mut self) -> ExprResult<'s, ()> {\r\n        while let Some(ShuntCar { value: _, spt, ept }) = self.operators.pop() {\r\n            self.apply_binary(spt..ept)?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    fn apply_infix<F>(&mut self, op_range: PointRange<'s>, f: F) ->\r\n        ExprResult<'s, ()>\r\n        where F: FnOnce(Expression, Expression) -> Expression\r\n    {\r\n        let ShuntCar { value: rhs, ept: rexpr_ept, .. } = self.pop_expression(op_range.end)?;\r\n        let ShuntCar { value: lhs, spt: lexpr_spt, .. } = self.pop_expression(op_range.start)?;\r\n        let new_expr = f(lhs, rhs);\r\n        self.result.push(ShuntCar { value: new_expr, spt: lexpr_spt, ept: rexpr_ept });\r\n        Ok(())\r\n    }\r\n\r\n    fn apply_binary(&mut self, op_range: PointRange<'s>) ->\r\n        ExprResult<'s, ()>\r\n    {\r\n        self.apply_infix(op_range, |lhs, rhs| {\r\n            Expression::Binary(Binary {\r\n                lhs: Box::new(lhs),\r\n                rhs: Box::new(rhs),\r\n            })\r\n        })\r\n    }\r\n\r\n    fn pop_expression(&mut self, location: Point<'s>) ->\r\n        ExprResult<'s, ShuntCar<'s, Expression>>\r\n    {\r\n        self.result.pop().ok_or(location)\r\n    }\r\n}\r\n\r\nenum ExpressionState {\r\n    Prefix, // Also \"beginning of expression\"\r\n    Infix,\r\n    Atom,\r\n}\r\n\r\nfn expression<'s>(pt: Point<'s>) -> Progress<'s, Expression> {\r\n    match expression_x(pt) {\r\n        Ok(ShuntCar { value: expr, ept, .. }) => Progress::success(ept, expr),\r\n        Err(failure_point) => Progress::failure(failure_point),\r\n    }\r\n}\r\n\r\nfn expression_x<'s>(mut pt: Point<'s>) ->\r\n    ExprResult<'s, ShuntCar<'s, Expression>>\r\n{\r\n    let mut shunting_yard = ShuntingYard { operators: Vec::new(), result: Vec::new() };\r\n    let mut state = ExpressionState::Prefix;\r\n    loop {\r\n        println!(\"expression_x loop\");\r\n        match state {\r\n            ExpressionState::Prefix |\r\n            ExpressionState::Infix => {\r\n                println!(\"branch 1\");\r\n                let Progress { point, .. } =\r\n                    token(Token::into_ident, pt).map(|_| Value).map(Expression::Value);\r\n                state = ExpressionState::Atom;\r\n                pt = point;\r\n            }\r\n            ExpressionState::Atom => {\r\n                println!(\"branch 2\");\r\n                match token(Token::into_ampersand_equals, pt)\r\n                    .map(OperatorInfix::BitwiseAndAssign).map(InfixOrPostfix::Infix) {\r\n                    Progress { status: Ok(infix_or_postfix), point } => {\r\n                        match infix_or_postfix {\r\n                            InfixOrPostfix::Infix(op) => {\r\n                                shunting_yard.add_infix(op, pt, point)?;\r\n                                state = ExpressionState::Infix;\r\n                            }\r\n                            InfixOrPostfix::Postfix(_) => unimplemented!(),\r\n                        }\r\n                        pt = point;\r\n                    }\r\n                    _ => shunting_yard.apply_all()?,\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n```\r\n$ rustc --version\r\nrustc 1.18.0-beta.1 (4dce67253 2017-04-25)\r\n $ rustc -C opt-level=1 -C panic=abort parse.rs \r\n[...]\r\n$ ./parse\r\nexpression_x loop\r\nbranch 1\r\nexpression_x loop\r\nbranch 2\r\nexpression_x loop\r\nbranch 1\r\nexpression_x loop\r\nbranch 2\r\nSegmentation fault\r\n\r\n```\r\n\r\n</details>", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/41888/reactions", "total_count": 3, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 3, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/41888/timeline", "performed_via_github_app": null, "state_reason": "completed"}