{"url": "https://api.github.com/repos/rust-lang/rust/issues/101775", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/101775/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/101775/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/101775/events", "html_url": "https://github.com/rust-lang/rust/issues/101775", "id": 1371924952, "node_id": "I_kwDOAAsO6M5RxenY", "number": 101775, "title": "Aggressive optimizations lead to incorrect or unexpected results using `thread::scope()` with closed-over variables instead of local `static mut` variables.", "user": {"login": "mqudsi", "id": 606923, "node_id": "MDQ6VXNlcjYwNjkyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/606923?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mqudsi", "html_url": "https://github.com/mqudsi", "followers_url": "https://api.github.com/users/mqudsi/followers", "following_url": "https://api.github.com/users/mqudsi/following{/other_user}", "gists_url": "https://api.github.com/users/mqudsi/gists{/gist_id}", "starred_url": "https://api.github.com/users/mqudsi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mqudsi/subscriptions", "organizations_url": "https://api.github.com/users/mqudsi/orgs", "repos_url": "https://api.github.com/users/mqudsi/repos", "events_url": "https://api.github.com/users/mqudsi/events{/privacy}", "received_events_url": "https://api.github.com/users/mqudsi/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 9695584, "node_id": "MDU6TGFiZWw5Njk1NTg0", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-concurrency", "name": "A-concurrency", "color": "f7e101", "default": false, "description": "Area: Concurrency related issues."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2022-09-13T19:42:31Z", "updated_at": "2022-09-14T02:21:34Z", "closed_at": "2022-09-14T02:21:33Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "With the recent stabilization of `std::thread::scope()`, I expect we'll see a number of users try to port some code using global/local `static` variables in conjunction with `std::thread::spawn()` to using regular local, mutable variables and `std::thread::scope()` instead. Unfortunately, while the revised approach may be sound in theory, in practice it may be untenable due to aggressive optimizations making assumptions about what local, mutable (non-`static`) variables can or can't change before being read by the scoped thread.\r\n\r\nPlease note that I am not saying this is necessarily a bug caused by over-eager optimizations - I am merely reporting my observations and suggesting that _something_ should be done about this, whether it is to expand the documentation for `std::thread::scope()` to make it clear that closing over mutable variables is not a panacea/general stand-in for using `static mut` or if it is to try to work reduce the aggressiveness of optimizations that take place regarding closed-over variables accessed or modified in `std::thread::scope()` closures.\r\n\r\nIn this specific case, I was attempting to revise the README example for a crate that I maintain [that implements thread signals/events \u00e0 la WIN32 events](https://github.com/neosmart/rsevents). The original code used a local `static mut` variable w/ `std::thread::spawn()` and worked fine (though it was not re-entrant or thread-safe) and the revised code attempted to fix that by using local `let mut ...` vars closed over in the closure passed to `std::thread::scope()` instead, but the aggressive optimizations led the compiler to incorrectly infer that variables were never changed before being read, leading to incorrect results (something that it does not assume when `static mut` is used instead).\r\n\r\nIn the code sample below, `rsevents::AutoResetEvent` is a thread synchronization primitive that, when signalled, wakes one (and only one) waiting thread and also guarantees (via memory ordering semantics) that all writes prior to the signalling (via a `set()` call) will be visible to the awakened thread coming out of a `wait()` call. The code sample intentionally uses unsafe raw pointer reads/writes and does not use `Sync` or `Send` wrappers to illustrate the memory safety guarantees provided the `AutoResetEvent`.\r\n\r\n**This issue would affect any code relying on thread synchronization primitives that don't wrap/own the shared data (so it would not replicate with `Mutex<T>`, `RwLock<T>`, etc.) such as the `rsevents` reset events, a semaphore, etc.** It's most likely to be encountered with low-level library code rather than high-level applications.\r\n\r\nThis is the original sample code, utilizing `static mut` and `std::thread::spawn()`, which works as expected:\r\n\r\n```rust\r\nuse rsevents::{AutoResetEvent, Awaitable, EventState};\r\nuse std::time::Duration;\r\n\r\n#[derive(Clone, Copy, Debug)]\r\nenum ThreadMessage {\r\n    /// Used in lieu of wrapping `ThreadMessage` in an `Option`\r\n    None,\r\n    /// Hands off a value to a worker thread for processing\r\n    Input(u32),\r\n}\r\n\r\n// Events are cheap: each one is only a single byte!\r\nstatic TASK_READY: AutoResetEvent = AutoResetEvent::new(EventState::Unset);\r\nstatic DISPATCHED: AutoResetEvent = AutoResetEvent::new(EventState::Unset);\r\n\r\npub fn main() {\r\n    // The events above synchronize access to this !Sync, !Send shared state\r\n    static mut SHARED: ThreadMessage = ThreadMessage::None;\r\n\r\n    const THREAD_COUNT: usize = 3;\r\n    let mut threads = Vec::with_capacity(THREAD_COUNT);\r\n    for thread_idx in 0..THREAD_COUNT {\r\n        let join_handle = std::thread::spawn(move || {\r\n            loop {\r\n                // Wait efficiently for the main thread to signal _one_ (and\r\n                // only one) worker thread at a time.\r\n                if !TASK_READY.wait_for(Duration::from_millis(500)) {\r\n                    // When there's not enough work, let the thread pool drain\r\n                    break;\r\n                }\r\n\r\n                // This is safe because our events guarantee that\r\n                // * one thread will be accessing this variable at a time\r\n                // * shared memory will be consistent betwixt a call to\r\n                //   event.set() from one thread and a call to event.wait()\r\n                //   from another.\r\n                let work_msg = unsafe { *(&SHARED as *const ThreadMessage) };\r\n\r\n                // Signal to the main thread that we've taken the value and that\r\n                // it can overwrite `shared` at its leisure. Afterwards,\r\n                // processing can take as long as it needs.\r\n                DISPATCHED.set();\r\n\r\n                match work_msg {\r\n                    ThreadMessage::None => {\r\n                        unreachable!(\"The AutoResetEvent guarantees against this\")\r\n                    }\r\n                    ThreadMessage::Input(value) => {\r\n                        eprintln!(\"Thread {thread_idx} handling value {value}\")\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        threads.push(join_handle);\r\n    }\r\n\r\n    // Generate some \"random\" values at an interval, dispatching each exactly\r\n    // once to exactly one worker thread.\r\n    for value in [4, 8, 15, 16, 23, 42] {\r\n        unsafe {\r\n            // It's perfectly safe to access - and even write - to SHARED here\r\n            // because our two events guarantee exclusive access (as\r\n            // AutoResetEvents wake one thread at a time) and take care of\r\n            // synchronizing the memory plus any cache coherence issues between\r\n            // the writing thread (this one) and the reading worker thread.\r\n            *(&mut SHARED as *mut _) = ThreadMessage::Input(value);\r\n        }\r\n\r\n        // Signal a currently idle or the next idle worker thread to handle this\r\n        // value.\r\n        TASK_READY.set();\r\n\r\n        // Remember that work is usually dispatched faster than it can be\r\n        // handled!\r\n        // Wait for a worker thread to signal it has received the payload and we\r\n        // can stomp the `SHARED` value and dispatch work to the next worker.\r\n        DISPATCHED.wait();\r\n    }\r\n\r\n    // Wait for the thread pool to drain and exit\r\n    for jh in threads {\r\n        jh.join().expect(\"Worker thread panicked!\");\r\n    }\r\n    eprintln!(\"All work completed - exiting!\")\r\n}\r\n```\r\n\r\nIt prints the following output then exits:\r\n\r\n```\r\nThread 0 handling value 4\r\nThread 0 handling value 15\r\nThread 0 handling value 16\r\nThread 0 handling value 23\r\nThread 1 handling value 8\r\nThread 2 handling value 42\r\nAll work completed - exiting!\r\n```\r\n\r\nWhen modified to use `std::thread::scope()` and take advantage of its semantics to use a local mutable variable instead of a `static mut` variable (only one variable (`SHARED`) is changed from `static mut` to `let mut` to minimize the changes for this demonstration, but all the `static` variables could also be moved into the closure as well), the code no longer works correctly:\r\n\r\n```rust\r\nuse rsevents::{AutoResetEvent, Awaitable, EventState};\r\nuse std::time::Duration;\r\n\r\n#[derive(Clone, Copy, Debug)]\r\nenum ThreadMessage {\r\n    /// Used in lieu of wrapping `ThreadMessage` in an `Option`\r\n    None,\r\n    /// Hands off a value to a worker thread for processing\r\n    Input(u32),\r\n}\r\n\r\n// Events are cheap: each one is only a single byte!\r\nstatic TASK_READY: AutoResetEvent = AutoResetEvent::new(EventState::Unset);\r\nstatic DISPATCHED: AutoResetEvent = AutoResetEvent::new(EventState::Unset);\r\n\r\npub fn main() {\r\n    const THREAD_COUNT: usize = 3;\r\n    std::thread::scope(|scope| {\r\n        // The events above synchronize access to this !Sync, !Send shared state\r\n        let mut SHARED: ThreadMessage = ThreadMessage::None;\r\n\r\n        for thread_idx in 0..THREAD_COUNT {\r\n            scope.spawn(move || {\r\n                // This is here to cause panic messages to not collide w/ one another\r\n                std::thread::sleep_ms(thread_idx as u32 * 100);\r\n\r\n                loop {\r\n                    // Wait efficiently for the main thread to signal _one_ (and\r\n                    // only one) worker thread at a time.\r\n                    if !TASK_READY.wait_for(Duration::from_millis(500)) {\r\n                        // When there's not enough work, let the thread pool drain\r\n                        break;\r\n                    }\r\n\r\n                    // This is safe because our events guarantee that\r\n                    // * one thread will be accessing this variable at a time\r\n                    // * shared memory will be consistent betwixt a call to\r\n                    //   event.set() from one thread and a call to event.wait()\r\n                    //   from another.\r\n                    let work_msg = unsafe { *(&SHARED as *const ThreadMessage) };\r\n\r\n                    // Signal to the main thread that we've taken the value and that\r\n                    // it can overwrite `shared` at its leisure. Afterwards,\r\n                    // processing can take as long as it needs.\r\n                    DISPATCHED.set();\r\n\r\n                    match work_msg {\r\n                        ThreadMessage::None => {\r\n                            unreachable!(\"The AutoResetEvent guarantees against this\")\r\n                        }\r\n                        ThreadMessage::Input(value) => {\r\n                            eprintln!(\"Thread {thread_idx} handling value {value}\")\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        // Generate some \"random\" values at an interval, dispatching each exactly\r\n        // once to exactly one worker thread.\r\n        for value in [4, 8, 15, 16, 23, 42] {\r\n            unsafe {\r\n                // It's perfectly safe to access - and even write - to SHARED here\r\n                // because our two events guarantee exclusive access (as\r\n                // AutoResetEvents wake one thread at a time) and take care of\r\n                // synchronizing the memory plus any cache coherence issues between\r\n                // the writing thread (this one) and the reading worker thread.\r\n                *(&mut SHARED as *mut _) = ThreadMessage::Input(value);\r\n            }\r\n\r\n            // Signal a currently idle or the next idle worker thread to handle this\r\n            // value.\r\n            TASK_READY.set();\r\n\r\n            // Remember that work is usually dispatched faster than it can be\r\n            // handled!\r\n            // Wait for a worker thread to signal it has received the payload and we\r\n            // can stomp the `SHARED` value and dispatch work to the next worker.\r\n            DISPATCHED.wait();\r\n        }\r\n\r\n        // All spawned threads are automatically joined when the scope is dropped.\r\n    });\r\n\r\n    eprintln!(\"All work completed - exiting!\")\r\n}\r\n```\r\n\r\nThe code fails its sanity checks because the optimizer replaces the read value of `SHARED` with the initial value it was initialized with (`ThreadMessage::None`), thinking that it couldn't possibly be modified before being read:\r\n\r\n```\r\nthread '<unnamed>' panicked at 'internal error: entered unreachable code: The AutoResetEvent guarantees against this', examples/readme.rs:54:29\r\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\r\nthread '<unnamed>' panicked at 'internal error: entered unreachable code: The AutoResetEvent guarantees against this', examples/readme.rs:54:29\r\nthread '<unnamed>' panicked at 'internal error: entered unreachable code: The AutoResetEvent guarantees against this', examples/readme.rs:54:29\r\n```\r\n\r\nThe code samples above have a dependency on `rsevents` version `0.3.1` (which itself has no dependencies other than `parking_lot_core`).\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.65.0-nightly (015a824f2 2022-08-22)\r\nbinary: rustc\r\ncommit-hash: 015a824f2dffe32707fceb59c47effaf7b73486c\r\ncommit-date: 2022-08-22\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.65.0-nightly\r\nLLVM version: 15.0.0\r\n```\r\n\r\n@rustbot label +A-concurrency +T-compiler", "closed_by": {"login": "mqudsi", "id": 606923, "node_id": "MDQ6VXNlcjYwNjkyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/606923?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mqudsi", "html_url": "https://github.com/mqudsi", "followers_url": "https://api.github.com/users/mqudsi/followers", "following_url": "https://api.github.com/users/mqudsi/following{/other_user}", "gists_url": "https://api.github.com/users/mqudsi/gists{/gist_id}", "starred_url": "https://api.github.com/users/mqudsi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mqudsi/subscriptions", "organizations_url": "https://api.github.com/users/mqudsi/orgs", "repos_url": "https://api.github.com/users/mqudsi/repos", "events_url": "https://api.github.com/users/mqudsi/events{/privacy}", "received_events_url": "https://api.github.com/users/mqudsi/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/101775/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/101775/timeline", "performed_via_github_app": null, "state_reason": "completed"}