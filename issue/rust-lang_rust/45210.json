{"url": "https://api.github.com/repos/rust-lang/rust/issues/45210", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/45210/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/45210/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/45210/events", "html_url": "https://github.com/rust-lang/rust/issues/45210", "id": 264680400, "node_id": "MDU6SXNzdWUyNjQ2ODA0MDA=", "number": 45210, "title": "[incremental] introduce `ensure()` operation", "user": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 67766349, "node_id": "MDU6TGFiZWw2Nzc2NjM0OQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/E-mentor", "name": "E-mentor", "color": "02E10C", "default": false, "description": "Call for participation: This issue has a mentor. Use RustcContributor::new on Zulip for discussion."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 693665681, "node_id": "MDU6TGFiZWw2OTM2NjU2ODE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/WG-incr-comp", "name": "WG-incr-comp", "color": "c2e0c6", "default": false, "description": "Working group: incremental compilation"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-10-11T17:59:39Z", "updated_at": "2017-10-15T16:27:43Z", "closed_at": "2017-10-15T16:27:43Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "As part of https://github.com/rust-lang/rust/issues/45208, we would like to introduce a first-class `ensure()` operation. Invoking `Q::ensure(K)` for some query `Q` with key `K` is semantically equivalent to introducing a fresh query `Q1` that has a return type of unit and a provider like:\r\n\r\n```rust\r\nfn Q1(tcx, key: K) {\r\n    Q(tcx, key); // discard result\r\n}\r\n```\r\n\r\nIn other words, it executes the query `Q` but does not use the result. This is worthwhile because it avoids the need to load the result from disk (or execute the provider, if we are not storing the results of Q to disk).\r\n\r\nIn order to introduce `ensure()`, we want to modify the [plumbing macros for the query infrastructure](https://github.com/rust-lang/rust/blob/72d65019c789138f555c7cf7139508d2f9f0dffe/src/librustc/ty/maps/plumbing.rs). I think we could add an accessor called `ensure`, [somewhat like `try_get`](https://github.com/rust-lang/rust/blob/72d65019c789138f555c7cf7139508d2f9f0dffe/src/librustc/ty/maps/plumbing.rs#L421-L427). It would look something like this:\r\n\r\n```rust\r\n/// Ensures that the query's result for `key` is up-to-date,\r\n/// without necessarily executing the query. In particular, if all the inputs\r\n/// to the query are green, then the query will not be re-executed. If however\r\n/// some inputs have changed, then the query will be re-executed, and its\r\n/// results cached (after being compared against the hash of the previous results).\r\n///\r\n/// This function is particularly useful when executing passes for their side-effects --\r\n/// e.g., in order to report errors for erroneous programs.\r\n///\r\n/// Because the query will not execute unless it has changed, and hence the result\r\n/// may not actually be available, this function returns unit. \r\npub fn ensure(\r\n    tcx: TyCtxt<'a, $tcx, 'lcx>,\r\n    key: $K)\r\n{\r\n    let dep_node = Self::to_dep_node(tcx, &key);\r\n\r\n    // Ensuring an \"input\" query makes no sense, nor anonymous queries:\r\n    assert!(!dep_node.kind.is_anon());\r\n    assert!(!dep_node.kind.is_input());\r\n\r\n    // if this node has no color, then try to mark it green\r\n    if tcx.dep_graph.node_color(&dep_node).is_none() {\r\n        // This is an adapted variant on [this code] -- the only difference is that it does not invoke\r\n        // `load_from_disk_and_cache_in_memory` when done. It probably makes sense to extract\r\n        // a helper function.\r\n        //\r\n        // [this code]: https://github.com/rust-lang/rust/blob/72d65019c789138f555c7cf7139508d2f9f0dffe/src/librustc/ty/maps/plumbing.rs#L313-L335\r\n        if let Some(DepNodeColor::Green(dep_node_index)) = tcx.dep_graph.node_color(&dep_node) {\r\n            profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\r\n            tcx.dep_graph.read_index(dep_node_index);\r\n            return; \r\n        }\r\n\r\n        debug!(\"ty::queries::{}::try_get_with(key={:?}) - running try_mark_green\",\r\n            stringify!($name),\r\n            key);\r\n\r\n        if let Some(dep_node_index) = tcx.dep_graph.try_mark_green(tcx, &dep_node) {\r\n            debug_assert!(tcx.dep_graph.is_green(dep_node_index));\r\n            profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\r\n            tcx.dep_graph.read_index(dep_node_index);\r\n        return;\r\n    }\r\n\r\n    // If the node is not green, or we could not make it green,\r\n    // just execute the query normally and discard the result:\r\n    tcx.$name(key);\r\n}\r\n```\r\n\r\nNext, just to *use* this function somewhere, we can convert the code in `librustc_typeck` to use `ensure`. Notably, change [this line](https://github.com/rust-lang/rust/blob/72d65019c789138f555c7cf7139508d2f9f0dffe/src/librustc_typeck/check/mod.rs#L731) from `self.tcx.typeck_tables_of(body_owner_def_id)` to `ty::maps::queries::typeck_tables_of::ensure(self.tcx, body_owner_def_id)`.\r\n\r\n(This last step is not enough to skip type-checking, since there are other uses of `typeck_tables_of`, but it's a necessary precondition.)", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/45210/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/45210/timeline", "performed_via_github_app": null, "state_reason": "completed"}