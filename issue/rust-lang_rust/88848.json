{"url": "https://api.github.com/repos/rust-lang/rust/issues/88848", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/88848/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/88848/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/88848/events", "html_url": "https://github.com/rust-lang/rust/issues/88848", "id": 993783456, "node_id": "MDU6SXNzdWU5OTM3ODM0NTY=", "number": 88848, "title": "#[bench] may generate very different result when modifying something unrelated to the bench function.", "user": {"login": "Neutron3529", "id": 26130174, "node_id": "MDQ6VXNlcjI2MTMwMTc0", "avatar_url": "https://avatars.githubusercontent.com/u/26130174?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Neutron3529", "html_url": "https://github.com/Neutron3529", "followers_url": "https://api.github.com/users/Neutron3529/followers", "following_url": "https://api.github.com/users/Neutron3529/following{/other_user}", "gists_url": "https://api.github.com/users/Neutron3529/gists{/gist_id}", "starred_url": "https://api.github.com/users/Neutron3529/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Neutron3529/subscriptions", "organizations_url": "https://api.github.com/users/Neutron3529/orgs", "repos_url": "https://api.github.com/users/Neutron3529/repos", "events_url": "https://api.github.com/users/Neutron3529/events{/privacy}", "received_events_url": "https://api.github.com/users/Neutron3529/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2021-09-11T08:19:49Z", "updated_at": "2021-12-13T03:40:23Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\n\r\nThis bug report may mainly talk about, how to perform benchmark correctly. I use both code from cargo book and from internet searching, the result is quite different among them.\r\n\r\nI tried to implement a stable binary search function since the original function may slower than expected, the code is  =shown below and I got a strange result:\r\n\r\n```rust\r\n#![feature(test)]\r\nextern crate test;\r\n\r\nstruct BS<'a,T:Ord>(&'a[T]);\r\nimpl<'a,T:Ord> BS<'a,T>{\r\n    #[inline(always)]\r\n    fn get(&'a self,idx:usize)->Option<&'a T>{self.0.get(idx)}\r\n    #[inline(always)]\r\n    fn len(&'a self)->usize{self.0.len()}\r\n    #[inline(always)]\r\n    unsafe fn get_unchecked(&'a self,idx:usize)->&T{self.0.get_unchecked(idx)}\r\n    pub fn binary_search_stable(&self,x:&T)-> Result<usize, usize>{\r\n        let idx=self.binary_search_stable_unwrap(x);\r\n        if self.get(idx)==Some(x){Ok(idx)}else{Err(idx)}\r\n    }\r\n    #[inline(always)]\r\n    pub fn binary_search_stable_unwrap(&self,x:&T)-> usize{\r\n      self.binary_search_bool(|p|p<x)\r\n    }\r\n    #[inline]\r\n    pub fn binary_search_bool<F>(&'a self,mut f:F)->usize where F: FnMut(&'a T)->bool{\r\n        let mut size = self.len();\r\n        let mut left = usize::MAX;\r\n        let mut right = size;\r\n        let mut mid = size/2;\r\n        while size>1 {\r\n            // SAFETY: the call is made safe by the following invariants:\r\n            // - `mid >= 0`\r\n            // - `mid < size`: `mid` is limited by `[left; right)` bound.\r\n            if f(unsafe { self.get_unchecked(mid) }){\r\n                left = mid; // stop at rightmost false\r\n            } else {\r\n                right = mid; // stop at leftmost true\r\n            }\r\n            size = right.wrapping_sub(left);\r\n            mid = left.wrapping_add(size / 2);\r\n        }\r\n        right\r\n    }\r\n\r\n    #[inline]\r\n    pub fn binary_search_by<F>(&'a self, mut f: F) -> usize\r\n    where\r\n        F: FnMut(&'a T) -> bool,\r\n    {\r\n        let mut size = self.len();\r\n        let mut left = 0;\r\n        let mut right = size;\r\n        while left < right {\r\n            let mid = left + size / 2;\r\n\r\n            // SAFETY: the call is made safe by the following invariants:\r\n            // - `mid >= 0`\r\n            // - `mid < size`: `mid` is limited by `[left; right)` bound.\r\n            if f(unsafe { self.get_unchecked(mid) }) {\r\n                left = mid + 1; // stop at leftmost true\r\n            } else {\r\n                right = mid; // stop at leftmost true\r\n            }\r\n            size = right - left;\r\n        }\r\n        left\r\n    }\r\n}\r\n\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use test::Bencher;\r\n    const N:i32=1<<20;\r\n    #[test]\r\n    fn it_works() {\r\n        let a:Vec<i32>=(0..N).collect();\r\n        let b=BS(&a);\r\n        for i in 0..N+1{\r\n            assert_eq!(b.binary_search_stable_unwrap(&i),i as usize);\r\n        }\r\n    }\r\n\r\n    #[bench]\r\n    fn bench_stable_no_unwrap(b: &mut Bencher) {\r\n        let a:Vec<i32>=(0..N).collect();\r\n        let v=BS(&a);\r\n        b.iter(||{\r\n            (0..N).map(|i|v.binary_search_stable(&i).is_ok() as i32).sum::<i32>()\r\n        });\r\n    }\r\n    #[bench]\r\n    fn bench_default(b: &mut Bencher) {\r\n        let a:Vec<i32>=(0..N).collect();\r\n        b.iter(||{\r\n            (0..N).map(|i|a.binary_search(&i).is_ok() as i32).sum::<i32>()\r\n        });\r\n    }\r\n\r\n    #[bench]\r\n    fn bench_stable_unwrap(b: &mut Bencher) {\r\n        let a:Vec<i32>=(0..N).collect();\r\n        let v=BS(&a);\r\n        b.iter(||{\r\n            (0..N).map(|i|v.binary_search_stable_unwrap(&i) as i32).sum::<i32>()\r\n        });\r\n    }\r\n\r\n    #[bench]\r\n    fn bench_stable_binary_search_by(b: &mut Bencher) {\r\n        let a:Vec<i32>=(0..N).collect();\r\n        let v=BS(&a);\r\n        b.iter(||{\r\n            (0..N).map(|i|v.binary_search_by(|p|p<&i) as i32).sum::<i32>()\r\n        });\r\n    }\r\n}\r\n```\r\nas you could see, `bench_stable_no_unwrap` calls `binary_search`, which calls `binary_search_stable_unwrap` later, it should be slower than `bench_stable_unwrap` that calls `bench_stable_unwrap` directly, but what I found is that, bench_stable_unwrap is even slower than the default implementation.\r\n\r\n```\r\n$ taskset 101 cargo bench\r\n   Compiling bs v0.1.0 (/me/bs)\r\n    Finished bench [optimized] target(s) in 0.88s\r\n     Running unittests (target/release/deps/bs-87733d5a7d9aaccf)\r\n\r\nrunning 5 tests\r\ntest tests::it_works ... ignored\r\ntest tests::bench_default                 ... bench:  88,739,510 ns/iter (+/- 788,330)\r\ntest tests::bench_stable_binary_search_by ... bench:  82,799,862 ns/iter (+/- 640,729)\r\ntest tests::bench_stable_no_unwrap        ... bench:  75,848,750 ns/iter (+/- 429,334)\r\ntest tests::bench_stable_unwrap           ... bench:  89,021,057 ns/iter (+/- 925,888)\r\n\r\ntest result: ok. 0 passed; 0 failed; 1 ignored; 4 measured; 0 filtered out; finished in 101.20s\r\n```\r\nThis is not the end since the return type is different between `bench_stable_no_unwrap` and `bench_stable_unwrap`, strange things occurs when I tried to make `bench_stable_no_unwrap` faster:\r\n\r\nas the bencher shows, `bench_stable_binary_search_by` is faster than bench_stable_unwrap, thus I decided to swap the name between `pub fn binary_search_bool`(my hand-optimized version) and `pub fn binary_search_by`(most of its code comes from the function whti the same name defined in `Slice`).\r\n\r\n```\r\n$ taskset 101 cargo bench\r\n   Compiling bs v0.1.0 (/me/bs)\r\n    Finished bench [optimized] target(s) in 0.88s\r\n     Running unittests (target/release/deps/bs-87733d5a7d9aaccf)\r\n\r\nrunning 5 tests\r\ntest tests::it_works ... ignored\r\ntest tests::bench_default                 ... bench:  86,528,922 ns/iter (+/- 1,090,946)\r\ntest tests::bench_stable_binary_search_by ... bench:  89,192,326 ns/iter (+/- 1,174,563)\r\ntest tests::bench_stable_no_unwrap        ... bench:  83,804,643 ns/iter (+/- 885,088)\r\ntest tests::bench_stable_unwrap           ... bench:  82,742,413 ns/iter (+/- 1,103,926)\r\n\r\ntest result: ok. 0 passed; 0 failed; 1 ignored; 4 measured; 0 filtered out; finished in 103.27s\r\n```\r\n\r\nI'm not surprised that `bench_stable_no_unwrap` takes more time to finish since I do change the implementation of `bench_stable_no_unwrap`\r\n\r\nI'm surprised at, the benchmark of `bench_default` is changed.\r\n\r\nactually, I does not modify any code belongs to `bench_default`, but its benchmark changes signaficantly.\r\n(86528922+1090946=87619868<87951180=88739510-788330)\r\n\r\nIt is said that, this bug is something belongs to microcode or cache in the CPU, but rust does not provide any detail about that.\r\n\r\nI have run bench in both code several times, and the result does not change very much.\r\n\r\n---\r\n\r\nI also tried using `black_box` to unify the overhead, which also generate similar results with swap the function names. `bench_default` does not changed a lot, but I also got that `tests::bench_stable_no_unwrap` is faster than `tests::bench_stable_unwrap`.\r\n\r\n```rust\r\n#![feature(test)]\r\nextern crate test;\r\n// this is the code after the function name have been swapped with black_box is used.\r\nstruct BS<'a,T:Ord>(&'a[T]);\r\nimpl<'a,T:Ord> BS<'a,T>{\r\n    #[inline(always)]\r\n    fn get(&'a self,idx:usize)->Option<&'a T>{self.0.get(idx)}\r\n    #[inline(always)]\r\n    fn len(&'a self)->usize{self.0.len()}\r\n    #[inline(always)]\r\n    unsafe fn get_unchecked(&'a self,idx:usize)->&T{self.0.get_unchecked(idx)}\r\n    pub fn binary_search_stable(&self,x:&T)-> Result<usize, usize>{\r\n        let idx=self.binary_search_stable_unwrap(x);\r\n        if self.get(idx)==Some(x){Ok(idx)}else{Err(idx)}\r\n    }\r\n    #[inline(always)]\r\n    pub fn binary_search_stable_unwrap(&self,x:&T)-> usize{\r\n      self.binary_search_bool(|p|p<x)\r\n    }\r\n    #[inline]\r\n    pub fn binary_search_by<F>(&'a self,mut f:F)->usize where F: FnMut(&'a T)->bool{\r\n        let mut size = self.len();\r\n        let mut left = usize::MAX;\r\n        let mut right = size;\r\n        let mut mid = size/2;\r\n        while size>1 {\r\n            // SAFETY: the call is made safe by the following invariants:\r\n            // - `mid >= 0`\r\n            // - `mid < size`: `mid` is limited by `[left; right)` bound.\r\n            if f(unsafe { self.get_unchecked(mid) }){\r\n                left = mid; // stop at rightmost false\r\n            } else {\r\n                right = mid; // stop at leftmost true\r\n            }\r\n            size = right.wrapping_sub(left);\r\n            mid = left.wrapping_add(size / 2);\r\n        }\r\n        right\r\n    }\r\n\r\n    #[inline]\r\n    pub fn binary_search_bool<F>(&'a self, mut f: F) -> usize\r\n    where\r\n        F: FnMut(&'a T) -> bool,\r\n    {\r\n        let mut size = self.len();\r\n        let mut left = 0;\r\n        let mut right = size;\r\n        while left < right {\r\n            let mid = left + size / 2;\r\n\r\n            // SAFETY: the call is made safe by the following invariants:\r\n            // - `mid >= 0`\r\n            // - `mid < size`: `mid` is limited by `[left; right)` bound.\r\n            if f(unsafe { self.get_unchecked(mid) }) {\r\n                left = mid + 1; // stop at leftmost true\r\n            } else {\r\n                right = mid; // stop at leftmost true\r\n            }\r\n            size = right - left;\r\n        }\r\n        left\r\n    }\r\n}\r\n\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use test::{Bencher, black_box};\r\n    const N:i32=1<<20;\r\n    #[test]\r\n    fn it_works() {\r\n        let a:Vec<i32>=(0..N).collect();\r\n        let b=BS(&a);\r\n        for i in 0..N+1{\r\n            assert_eq!(b.binary_search_stable_unwrap(&i),i as usize);\r\n        }\r\n    }\r\n\r\n    #[bench]\r\n    fn bench_stable_no_unwrap(b: &mut Bencher) {\r\n        let a:Vec<i32>=(0..N).collect();\r\n        let v=BS(&a);\r\n        b.iter(||for i in 0..N{\r\n            black_box(v.binary_search_stable(&i));\r\n        });\r\n    }\r\n    #[bench]\r\n    fn bench_default(b: &mut Bencher) {\r\n        let a:Vec<i32>=(0..N).collect();\r\n        b.iter(||for i in 0..N{\r\n            black_box(a.binary_search(&i));\r\n        });\r\n    }\r\n\r\n    #[bench]\r\n    fn bench_stable_unwrap(b: &mut Bencher) {\r\n        let a:Vec<i32>=(0..N).collect();\r\n        let v=BS(&a);\r\n        b.iter(||for i in 0..N{\r\n            black_box(v.binary_search_stable_unwrap(&i));\r\n        });\r\n    }\r\n\r\n    #[bench]\r\n    fn bench_stable_binary_search_by(b: &mut Bencher) {\r\n        let a:Vec<i32>=(0..N).collect();\r\n        let v=BS(&a);\r\n        b.iter(||for i in 0..N{\r\n            black_box(v.binary_search_by(|p|p<&i));\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n```\r\n$ cargo bench\r\nwarning: unused `Result` that must be used\r\n  --> src/lib.rs:86:13\r\n   |\r\n86 |             black_box(v.binary_search_stable(&i));\r\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n   |\r\n   = note: `#[warn(unused_must_use)]` on by default\r\n   = note: this `Result` may be an `Err` variant, which should be handled\r\n\r\nwarning: unused `Result` that must be used\r\n  --> src/lib.rs:93:13\r\n   |\r\n93 |             black_box(a.binary_search(&i));\r\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n   |\r\n   = note: this `Result` may be an `Err` variant, which should be handled\r\n\r\nwarning: `bs` (lib test) generated 2 warnings\r\n    Finished bench [optimized] target(s) in 0.00s\r\n     Running unittests (target/release/deps/bs-87733d5a7d9aaccf)\r\n\r\nrunning 5 tests\r\ntest tests::it_works ... ignored\r\ntest tests::bench_default                 ... bench:  72,920,405 ns/iter (+/- 1,426,574)\r\ntest tests::bench_stable_binary_search_by ... bench:  85,951,033 ns/iter (+/- 1,350,663)\r\ntest tests::bench_stable_no_unwrap        ... bench:  98,202,388 ns/iter (+/- 1,154,955)\r\ntest tests::bench_stable_unwrap           ... bench:  78,576,276 ns/iter (+/- 1,268,575)\r\n\r\ntest result: ok. 0 passed; 0 failed; 1 ignored; 4 measured; 0 filtered out; finished in 99.48s\r\n```\r\n\r\n```\r\n$ cargo bench # with swap the name\r\n   Compiling bs v0.1.0 (/me/bs)\r\nwarning: unused `Result` that must be used\r\n  --> src/lib.rs:86:13\r\n   |\r\n86 |             black_box(v.binary_search_stable(&i));\r\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n   |\r\n   = note: `#[warn(unused_must_use)]` on by default\r\n   = note: this `Result` may be an `Err` variant, which should be handled\r\n\r\nwarning: unused `Result` that must be used\r\n  --> src/lib.rs:93:13\r\n   |\r\n93 |             black_box(a.binary_search(&i));\r\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n   |\r\n   = note: this `Result` may be an `Err` variant, which should be handled\r\n\r\nwarning: `bs` (lib test) generated 2 warnings\r\n    Finished bench [optimized] target(s) in 0.81s\r\n     Running unittests (target/release/deps/bs-87733d5a7d9aaccf)\r\n\r\nrunning 5 tests\r\ntest tests::it_works ... ignored\r\ntest tests::bench_default                 ... bench:  72,258,721 ns/iter (+/- 872,076)\r\ntest tests::bench_stable_binary_search_by ... bench:  78,523,318 ns/iter (+/- 662,576)\r\ntest tests::bench_stable_no_unwrap        ... bench:  83,015,499 ns/iter (+/- 913,204)\r\ntest tests::bench_stable_unwrap           ... bench:  85,404,380 ns/iter (+/- 828,932)\r\n\r\ntest result: ok. 0 passed; 0 failed; 1 ignored; 4 measured; 0 filtered out; finished in 95.93s\r\n```\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n`rustc --version --verbose`:\r\n```\r\n$ rustc --version --verbose\r\nrustc 1.57.0-nightly (fdf65053e 2021-09-07)\r\nbinary: rustc\r\ncommit-hash: fdf65053e99e8966f9bd83b5a8491326cb33d638\r\ncommit-date: 2021-09-07\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.57.0-nightly\r\nLLVM version: 13.0.0\r\n```\r\n\r\n<!--\r\nInclude a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\r\nenvironment. E.g. `RUST_BACKTRACE=1 cargo build`.\r\n-->\r\n<details><summary>Backtrace</summary>\r\n<p>\r\n\r\nsystem information:\r\n\r\n```\r\n$ uname -a\r\nLinux DR722 5.13.12-1-MANJARO #1 SMP PREEMPT Wed Aug 18 08:06:42 UTC 2021 x86_64 GNU/Linux\r\n$ cat /sys/devices/system/cpu/intel_pstate/no_turbo\r\n1\r\n$ cat /proc/cpuinfo | tail -n 28\r\nprocessor       : 15\r\nvendor_id       : GenuineIntel\r\ncpu family      : 6\r\nmodel           : 141\r\nmodel name      : 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz\r\nstepping        : 1\r\nmicrocode       : 0x2c\r\ncpu MHz         : 2299.963\r\ncache size      : 24576 KB\r\nphysical id     : 0\r\nsiblings        : 16\r\ncore id         : 7\r\ncpu cores       : 8\r\napicid          : 15\r\ninitial apicid  : 15\r\nfpu             : yes\r\nfpu_exception   : yes\r\ncpuid level     : 27\r\nwp              : yes\r\nflags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf tsc_known_freq pni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb cat_l2 invpcid_single cdp_l2 ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid rdt_a avx512f avx512dq rdseed adx smap avx512ifma clflushopt clwb intel_pt avx512cd sha_ni avx512bw avx512vl xsaveopt xsavec xgetbv1 xsaves split_lock_detect dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp hwp_pkg_req avx512vbmi umip pku ospke avx512_vbmi2 gfni vaes vpclmulqdq avx512_vnni avx512_bitalg avx512_vpopcntdq rdpid movdiri movdir64b fsrm avx512_vp2intersect md_clear flush_l1d arch_capabilities\r\nvmx flags       : vnmi preemption_timer posted_intr invvpid ept_x_only ept_ad ept_1gb flexpriority apicv tsc_offset vtpr mtf vapic ept vpid unrestricted_guest vapic_reg vid ple pml ept_mode_based_exec tsc_scaling\r\nbugs            : spectre_v1 spectre_v2 spec_store_bypass swapgs\r\nbogomips        : 4609.00\r\nclflush size    : 64\r\ncache_alignment : 64\r\naddress sizes   : 39 bits physical, 48 bits virtual\r\npower management:\r\n```\r\n\r\n\r\n(may not related  to this bug)\r\n```\r\n$ RUST_BACKTRACE=1 cargo build\r\n   Compiling bs v0.1.0 (/me/bs)\r\nwarning: struct is never constructed: `BS`\r\n --> src/lib.rs:4:8\r\n  |\r\n4 | struct BS<'a,T:Ord>(&'a[T]);\r\n  |        ^^\r\n  |\r\n  = note: `#[warn(dead_code)]` on by default\r\n\r\nwarning: associated function is never used: `get`\r\n --> src/lib.rs:7:8\r\n  |\r\n7 |     fn get(&'a self,idx:usize)->Option<&'a T>{self.0.get(idx)}\r\n  |        ^^^\r\n\r\nwarning: associated function is never used: `len`\r\n --> src/lib.rs:9:8\r\n  |\r\n9 |     fn len(&'a self)->usize{self.0.len()}\r\n  |        ^^^\r\n\r\nwarning: associated function is never used: `get_unchecked`\r\n  --> src/lib.rs:11:15\r\n   |\r\n11 |     unsafe fn get_unchecked(&'a self,idx:usize)->&T{self.0.get_unchecked(idx)}\r\n   |               ^^^^^^^^^^^^^\r\n\r\nwarning: associated function is never used: `binary_search_stable`\r\n  --> src/lib.rs:12:12\r\n   |\r\n12 |     pub fn binary_search_stable(&self,x:&T)-> Result<usize, usize>{\r\n   |            ^^^^^^^^^^^^^^^^^^^^\r\n\r\nwarning: associated function is never used: `binary_search_stable_unwrap`\r\n  --> src/lib.rs:17:12\r\n   |\r\n17 |     pub fn binary_search_stable_unwrap(&self,x:&T)-> usize{\r\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nwarning: associated function is never used: `binary_search_bool`\r\n  --> src/lib.rs:21:12\r\n   |\r\n21 |     pub fn binary_search_bool<F>(&'a self,mut f:F)->usize where F: FnMut(&'a T)->bool{\r\n   |            ^^^^^^^^^^^^^^^^^^\r\n\r\nwarning: associated function is never used: `binary_search_by`\r\n  --> src/lib.rs:42:12\r\n   |\r\n42 |     pub fn binary_search_by<F>(&'a self, mut f: F) -> usize\r\n   |            ^^^^^^^^^^^^^^^^\r\n\r\nwarning: `bs` (lib) generated 8 warnings\r\n    Finished dev [unoptimized + debuginfo] target(s) in 0.17s\r\n```\r\n\r\n</p>\r\n</details>\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/88848/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/88848/timeline", "performed_via_github_app": null, "state_reason": null}