{"url": "https://api.github.com/repos/rust-lang/rust/issues/60715", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/60715/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/60715/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/60715/events", "html_url": "https://github.com/rust-lang/rust/issues/60715", "id": 442898678, "node_id": "MDU6SXNzdWU0NDI4OTg2Nzg=", "number": 60715, "title": "Request: Make `std::marker::Freeze` pub again", "user": {"login": "mtak-", "id": 6643140, "node_id": "MDQ6VXNlcjY2NDMxNDA=", "avatar_url": "https://avatars.githubusercontent.com/u/6643140?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mtak-", "html_url": "https://github.com/mtak-", "followers_url": "https://api.github.com/users/mtak-/followers", "following_url": "https://api.github.com/users/mtak-/following{/other_user}", "gists_url": "https://api.github.com/users/mtak-/gists{/gist_id}", "starred_url": "https://api.github.com/users/mtak-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mtak-/subscriptions", "organizations_url": "https://api.github.com/users/mtak-/orgs", "repos_url": "https://api.github.com/users/mtak-/repos", "events_url": "https://api.github.com/users/mtak-/events{/privacy}", "received_events_url": "https://api.github.com/users/mtak-/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 630652267, "node_id": "MDU6TGFiZWw2MzA2NTIyNjc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-feature-request", "name": "C-feature-request", "color": "f5f1fd", "default": false, "description": "Category: A feature request, i.e: not implemented / a PR."}, {"id": 1089771154, "node_id": "MDU6TGFiZWwxMDg5NzcxMTU0", "url": "https://api.github.com/repos/rust-lang/rust/labels/needs-rfc", "name": "needs-rfc", "color": "fceb9f", "default": false, "description": "This change is large or controversial enough that it should have an (e-)RFC accepted before doing it"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 27, "created_at": "2019-05-10T21:19:39Z", "updated_at": "2020-06-13T04:05:51Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I had heard tell of `Freeze` but didn't really know what it was until today. [`swym`](https://github.com/mtak-/swym/blob/1dcf0a9d7d61be3bd3cbb6993d5d27bda2874e6d/src/tx.rs#L228), a hybrid transactional memory library, has an accidental reimplementation of `Freeze` using `optin_builtin_traits`. Unfortunately `optin_builtin_traits` is the only feature keeping `swym` on nightly.\r\n\r\nThe [ticket](https://github.com/rust-lang/rust/issues/12683) that removed `Freeze` doesn't have much of an explanation for why it was removed so I'm assuming it was a lack of motivating use cases.\r\n\r\n### Use Case\r\n[`swym::tcell::TCell::borrow`](https://docs.rs/swym/0.1.0-preview/swym/tcell/struct.TCell.html#method.borrow) returns snapshots of data - shallow `memcpy`s - that are guaranteed to not be torn, and be valid for the duration of the transaction. Those snapshots hold on to the lifetime of the `TCell` in order to act like a true reference, without blocking updates to the `TCell` from other threads. Other threads promise to not mutate the value that had its snapshot taken until the transaction has finished, but are permitted to move the value in memory.\r\n\r\nThis works great for a lot of types, but fails miserably when `UnsafeCell`s are directly stored in the type.\r\n\r\n```rust\r\nlet x = TCell::new(Mutex::new(\"hello there\".to_owned()));\r\n\r\n// ..  inside a transaction\r\nlet shallow_copy = x.borrow(tx, Default::default())?;\r\n// locking a shallow copy of a lock... is not really a lock at all!\r\n*shallow_copy.lock().unwrap() = \"uh oh\".to_owned();\r\n```\r\n\r\nEven if `Mutex` internally had a pointer to the \"actual\" mutex data structure, the above example would still be broken because the `String` is deallocated through the shallow copy. The `String` contained in the `TCell` would point to freed memory.\r\n\r\nNote that having `TCell::borrow` require `Sync` would still allow the above broken example to compile.\r\n\r\n### Freeze\r\n\r\nIf `swym::tcell::TCell::borrow` could require `Freeze` then this would not be an issue as the `Mutex` type is definitely not `Freeze`.\r\n\r\n```rust\r\npub(crate) unsafe auto trait Freeze {}\r\n\r\nimpl<T: ?Sized> !Freeze for UnsafeCell<T> {}\r\nunsafe impl<T: ?Sized> Freeze for PhantomData<T> {}\r\nunsafe impl<T: ?Sized> Freeze for *const T {}\r\nunsafe impl<T: ?Sized> Freeze for *mut T {}\r\nunsafe impl<T: ?Sized> Freeze for &T {}\r\nunsafe impl<T: ?Sized> Freeze for &mut T {}\r\n```\r\n\r\nShallow immutability is all that is required for `TCell::borrow` to work. `Sync` is only necessary to make `TCell` `Sync`.\r\n * `TCell<String>` - should be permitted.\r\n * `TCell<Mutex<String>>` - should be forbidden.\r\n * `TCell<Box<Mutex<String>>>` - should be permitted.\r\n\r\n### Alternatives\r\n- A manually implemented marker trait _could_ work, but is actually very dangerous in practice. In the below example, assume that the impl of `MyFreeze` was correct when it was written. Everytime the author of `MyType` updates their dependency on `other_crate` they must recheck that `OtherType` still has no direct interior mutability or risk unsoundness.\r\n```rust\r\nstruct MyType { value: other_crate::OtherType }\r\nunsafe impl MyFreeze for MyType {}\r\n```\r\n\r\n- Add a `T: Copy` bound on `TCell::<T>::borrow`. This would definitely work but leaves a lot of types out.\r\n\r\n- Wait for [OIBIT](https://github.com/rust-lang/rust/issues/13231)s to stabilize (assuming it will be stabilized).\r\n\r\n- Have `TCell` store a `Box<T>` internally, and only work with heap allocated data where interior mutability is of no concern. This would be pretty effective, and if the type is small enough and `Copy`, the `Box` could be elided. While not as good as stabilizing `Freeze`, I think this is the best alternative.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/60715/reactions", "total_count": 8, "+1": 8, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/60715/timeline", "performed_via_github_app": null, "state_reason": null}