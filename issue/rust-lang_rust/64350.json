{"url": "https://api.github.com/repos/rust-lang/rust/issues/64350", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/64350/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/64350/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/64350/events", "html_url": "https://github.com/rust-lang/rust/issues/64350", "id": 491661777, "node_id": "MDU6SXNzdWU0OTE2NjE3Nzc=", "number": 64350, "title": "sender Cannot exit while using nested", "user": {"login": "linkwik", "id": 42795519, "node_id": "MDQ6VXNlcjQyNzk1NTE5", "avatar_url": "https://avatars.githubusercontent.com/u/42795519?v=4", "gravatar_id": "", "url": "https://api.github.com/users/linkwik", "html_url": "https://github.com/linkwik", "followers_url": "https://api.github.com/users/linkwik/followers", "following_url": "https://api.github.com/users/linkwik/following{/other_user}", "gists_url": "https://api.github.com/users/linkwik/gists{/gist_id}", "starred_url": "https://api.github.com/users/linkwik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/linkwik/subscriptions", "organizations_url": "https://api.github.com/users/linkwik/orgs", "repos_url": "https://api.github.com/users/linkwik/repos", "events_url": "https://api.github.com/users/linkwik/events{/privacy}", "received_events_url": "https://api.github.com/users/linkwik/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2019-09-10T13:08:07Z", "updated_at": "2019-09-11T09:41:51Z", "closed_at": "2019-09-11T09:41:51Z", "author_association": "NONE", "active_lock_reason": null, "body": "When I crawled the web pages with rust and curl, I needed to handle the redirected connections, so I created channels to handle the target, but when all the channels were finished, the program didn't quit and was still waiting\r\n\r\nI tried drop(), but it didn't work\r\n\r\nthe code:\r\n\r\n```rust\r\nextern crate serde;\r\nextern crate serde_json;\r\nextern crate curl;\r\nuse curl::easy::Easy;\r\n#[macro_use]\r\nextern crate serde_derive;\r\n\r\nuse std::thread;\r\nuse std::sync::mpsc::{channel, Receiver, Sender};\r\nuse std::fs::File;\r\nuse std::io::Read;\r\nuse std::time::Duration;\r\n\r\n#[derive(Serialize, Deserialize)]\r\nstruct Target {\r\n    name: String,\r\n    domain: String\r\n}\r\n\r\n\r\nstruct ResultTarget {\r\n    name: String,\r\n    domain: String,\r\n    status_code: u32,\r\n    banner: String,\r\n    ip: String\r\n}\r\n\r\nfn main() {\r\n    let (task_send, task_rece) = channel();\r\n    let (redict_send, redict_rece) = channel();\r\n\r\n    let gen_task = thread::spawn(move|| gen_target(\"target.json\".to_string(), task_send, redict_rece));\r\n    let run_task = thread::spawn(move|| {\r\n        for i in task_rece {\r\n            get_html(i.name, i.domain, redict_send.clone());\r\n        }\r\n    });\r\n\r\n    run_task.join().unwrap();\r\n    gen_task.join().unwrap();\r\n\r\n}\r\n\r\n\r\nfn gen_target(filename:String, task_send: Sender<Target>, redict_rece:Receiver<Target>) {\r\n    let mut data = String::new();\r\n\r\n    let mut files = File::open(filename).ok().expect(\"ERROR: [read_files] Open file Error!\");\r\n    files.read_to_string(&mut data).ok().expect(\"ERROR: [read_files] Read to string!\");\r\n\r\n    // let mut target_list = Vec::new();\r\n    for i in data.lines() {\r\n        if i.eq(\"[\") || i.eq(\"]\") {\r\n            continue;\r\n        }\r\n        let i = i.trim_end_matches(',');\r\n\r\n        println!(\"{}\", i);\r\n        let t: Target = serde_json::from_str(&i).ok().expect(\"ERROR: [read_file] Serialize error!\");\r\n        task_send.send(t).unwrap();\r\n    }\r\n\r\n\r\n    for i in redict_rece {\r\n        task_send.send(i).unwrap();\r\n    }\r\n}\r\n\r\n\r\nfn get_html(name:String, domain: String, redict_send: Sender<Target>) {\r\n\r\n    let mut dst = Vec::new();\r\n    let mut c = Easy::new();\r\n    // let url = gen_url(domain, urlprefix, urlsuffix);\r\n\r\n    let url = domain;\r\n\r\n    c.url(&url);\r\n    c.show_header(true).ok().expect(\"Show Header Error!\");\r\n    c.timeout(Duration::new(20, 0));\r\n\r\n    {\r\n        let mut t = c.transfer();\r\n        t.write_function(|data| {\r\n            dst.extend_from_slice(data);\r\n            Ok(data.len())\r\n        }).ok().expect(\"ERROR: transfer\");\r\n        match t.perform() {\r\n            Ok(_) => {},\r\n            Err(_) => {\r\n                println!(\"[DEBUG] ERROR: run perform\");\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    let s;\r\n    match String::from_utf8(dst) {\r\n        Ok(v) => {s = v.to_string()},\r\n        Err(_) => {\r\n            println!(\"FromUtf8Error\");\r\n            return;\r\n        }\r\n    };\r\n\r\n    let peer_ip = match c.primary_ip().unwrap() {\r\n        Some(e) => {e.to_string()},\r\n        None => {String::from(\"0.0.0.0\")},\r\n    };\r\n\r\n    let redirect_url = match c.redirect_url().unwrap() {\r\n        Some(v) => v.to_string(),\r\n        None => \"\".to_string()\r\n    };\r\n\r\n\r\n    if !redirect_url.is_empty() {\r\n        let t = Target {\r\n            name:  name.clone(),\r\n            domain: redirect_url.clone(),\r\n        };\r\n        redict_send.send(t).unwrap();\r\n    }\r\n\r\n    let status_code = c.response_code().ok().expect(\"ERROR: response_code\");\r\n\r\n    let data = ResultTarget{\r\n        name: name.to_owned(),\r\n        domain: url.to_owned(),\r\n        status_code: status_code.to_owned(),\r\n        banner: s.to_owned(),\r\n        ip: peer_ip.to_owned(),\r\n    };\r\n\r\n    println!(\"name: {}, domain: {}, status_code: {}, ip:{}\", data.name, data.domain, data.status_code, data.ip);\r\n}\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=5df8459d891e6e4e020f12becf7a8434))\r\n\r\n// target.json\r\n```\r\n[\r\n  {\"name\": \"google\", \"domain\": \"www.google.com\"},\r\n  {\"name\": \"rust-lang\", \"domain\": \"doc.rust-lang.org\"},\r\n  {\"name\": \"rust-lang\", \"domain\": \"rust-lang.org\"}\r\n]\r\n```", "closed_by": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/64350/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/64350/timeline", "performed_via_github_app": null, "state_reason": "completed"}