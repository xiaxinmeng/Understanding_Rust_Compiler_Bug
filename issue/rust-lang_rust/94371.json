{"url": "https://api.github.com/repos/rust-lang/rust/issues/94371", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/94371/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/94371/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/94371/events", "html_url": "https://github.com/rust-lang/rust/issues/94371", "id": 1150822966, "node_id": "I_kwDOAAsO6M5EmCo2", "number": 94371, "title": "mem::swap behaves incorrectly in CTFE (and Miri)", "user": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2022-02-25T20:09:55Z", "updated_at": "2022-04-05T22:33:33Z", "closed_at": "2022-04-05T19:05:54Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "Since https://github.com/rust-lang/rust/pull/94212, `mem::swap` behaves incorrectly during CTFE (where it is unstably accessible) and in Miri. This is demonstrated by the following code failing to build:\r\n```rust\r\n#![feature(const_swap)]\r\n#![feature(const_mut_refs)]\r\n\r\nuse std::borrow::Cow;\r\n\r\npub enum NamePadding {\r\n    PadNone,\r\n    PadOnRight,\r\n}\r\n\r\npub enum TestName {\r\n    StaticTestName(&'static str),\r\n    DynTestName(String),\r\n    AlignedTestName(Cow<'static, str>, NamePadding),\r\n}\r\n\r\npub enum ShouldPanic {\r\n    No,\r\n    Yes,\r\n    YesWithMessage(&'static str),\r\n}\r\n\r\npub enum TestType {\r\n    UnitTest,\r\n    IntegrationTest,\r\n    DocTest,\r\n    Unknown,\r\n}\r\n\r\npub struct TestDesc {\r\n    pub name: TestName,\r\n    pub ignore: bool,\r\n    pub should_panic: ShouldPanic,\r\n    pub compile_fail: bool,\r\n    pub no_run: bool,\r\n    pub test_type: TestType,\r\n}\r\n\r\npub struct Bencher;\r\n\r\npub enum TestFn {\r\n    StaticTestFn(fn()),\r\n    StaticBenchFn(fn(&mut Bencher)),\r\n    DynTestFn(Box<dyn FnOnce() + Send>),\r\n    DynBenchFn(Box<dyn Fn(&mut Bencher) + Send>),\r\n}\r\n\r\npub struct TestDescAndFn {\r\n    pub desc: TestDesc,\r\n    pub testfn: TestFn,\r\n}\r\n\r\npub struct TestId(pub usize);\r\n\r\ntype T = (TestId, TestDescAndFn);\r\n\r\nconst C: (T, T) = {\r\n    let mut x = (\r\n        TestId(0),\r\n        TestDescAndFn {\r\n            desc: TestDesc {\r\n                name: TestName::StaticTestName(\"name\"),\r\n                ignore: true,\r\n                should_panic: ShouldPanic::Yes,\r\n                compile_fail: false,\r\n                no_run: false,\r\n                test_type: TestType::UnitTest,\r\n            },\r\n            testfn: TestFn::StaticTestFn(|| {}),\r\n        },\r\n    );\r\n    let mut y = (\r\n        TestId(0),\r\n        TestDescAndFn {\r\n            desc: TestDesc {\r\n                name: TestName::StaticTestName(\"name\"),\r\n                ignore: true,\r\n                should_panic: ShouldPanic::Yes,\r\n                compile_fail: false,\r\n                no_run: false,\r\n                test_type: TestType::UnitTest,\r\n            },\r\n            testfn: TestFn::StaticTestFn(|| {}),\r\n        },\r\n    );\r\n    std::mem::swap(&mut x, &mut y);\r\n    (x, y)\r\n};\r\n\r\nfn main() {}\r\n```\r\nThe error is:\r\n```\r\nerror[E0080]: it is undefined behavior to use this value\r\n  --> swap2.rs:57:1\r\n   |\r\n57 | / const C: (T, T) = {\r\n58 | |   let mut x = (\r\n59 | |             TestId(0),\r\n60 | |             TestDescAndFn {\r\n...  |\r\n87 | |   (x, y)\r\n88 | | };\r\n   | |__^ type validation failed at .1.1.desc.name.<enum-tag>: encountered uninitialized bytes, but expected initialized plain (non-pointer) bytes\r\n   |\r\n   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\r\n   = note: the raw bytes of the constant (size: 208, align: 8) {\r\n               0x00 \u2502 00 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __ \u2502 .........\u2591\u2591\u2591\u2591\u2591\u2591\u2591\r\n               0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc14\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\r\n               0x20 \u2502 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ \u2502 \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\r\n               0x30 \u2502 01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __ \u2502 ........\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\r\n               0x40 \u2502 __ __ __ __ __ __ __ __ 01 00 00 00 __ __ __ __ \u2502 \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591....\u2591\u2591\u2591\u2591\r\n               0x50 \u2502 00 00 00 00 00 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc18\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ........\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\r\n               0x60 \u2502 __ __ __ __ __ __ __ __ 00 00 00 00 00 00 00 00 \u2502 \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591........\r\n               0x70 \u2502 __ __ __ __ __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\r\n               0x80 \u2502 04 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __ \u2502 ........\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\r\n               0x90 \u2502 __ __ __ __ __ __ __ __ 01 00 00 00 00 00 00 00 \u2502 \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591........\r\n               0xa0 \u2502 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ \u2502 \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\r\n               0xb0 \u2502 __ __ __ __ __ __ __ __ 00 00 00 00 00 00 00 00 \u2502 \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591........\r\n               0xc0 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c __ __ __ __ __ __ __ __ \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\r\n           }\r\n```\r\n\r\nThe underlying reason for this is https://github.com/rust-lang/rust/issues/69488: the new `swap` copies the data in chunks of `MaybeUninit<usize>`, but this is implemented incorrectly in CTFE and Miri in the sense that if *any* of the bytes in the source of such a value is uninit, then the *entire value* becomes uninit after the copy.\r\n\r\nThis reproduces only with very particular types that hit certain code paths in `swap`; my attempts at writing a smaller example from scratch failed so instead I extracted this from the test harness where the problem originally occurred in Miri.\r\n\r\nAlso, even a fix https://github.com/rust-lang/rust/issues/69488 would not fully resolve the problem: if data contains pointers at *unaligned* positions, then the `usize` chunking might attempt to copy a *part* of a pointer, which CTFE and Miri do not support (that's https://github.com/rust-lang/rust/issues/87184, and it is a lot harder to fix than https://github.com/rust-lang/rust/issues/69488). This was in theory already a problem with the previous implementation of `swap`, but there the chunks were bigger so pointers were less likely to cross the chunk boundary. I don't know if this is ever a problem in practice though. Miri/CTFE will halt when such a partial pointer copy is attempted, so we should know if/when that happens.", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/94371/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/94371/timeline", "performed_via_github_app": null, "state_reason": "completed"}