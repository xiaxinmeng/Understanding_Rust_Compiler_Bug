{"url": "https://api.github.com/repos/rust-lang/rust/issues/8613", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/8613/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/8613/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/8613/events", "html_url": "https://github.com/rust-lang/rust/issues/8613", "id": 18226341, "node_id": "MDU6SXNzdWUxODIyNjM0MQ==", "number": 8613, "title": "rustc loop forever in case of polymorphic recursion", "user": {"login": "NawfelBgh", "id": 1393737, "node_id": "MDQ6VXNlcjEzOTM3Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/1393737?v=4", "gravatar_id": "", "url": "https://api.github.com/users/NawfelBgh", "html_url": "https://github.com/NawfelBgh", "followers_url": "https://api.github.com/users/NawfelBgh/followers", "following_url": "https://api.github.com/users/NawfelBgh/following{/other_user}", "gists_url": "https://api.github.com/users/NawfelBgh/gists{/gist_id}", "starred_url": "https://api.github.com/users/NawfelBgh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/NawfelBgh/subscriptions", "organizations_url": "https://api.github.com/users/NawfelBgh/orgs", "repos_url": "https://api.github.com/users/NawfelBgh/repos", "events_url": "https://api.github.com/users/NawfelBgh/events{/privacy}", "received_events_url": "https://api.github.com/users/NawfelBgh/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2013-08-19T07:39:32Z", "updated_at": "2015-01-23T01:57:00Z", "closed_at": "2015-01-23T01:57:00Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello,\nrustc goes into an infinite loop when compiling this\n\n``` rust\nenum Dequelette<T> {\n    Deque1(T),\n    Deque2(T, T),\n    Deque3(T, T, T),\n    Deque4(T, T, T, T)\n}\n\n// this is a purely functional deque implemented with a finger tree\n// different versions are supposed to share nodes\n// that is why i used @\nenum Deque<T> {\n    Empty,\n    Single(T),\n    Multi(@Dequelette<T>, @Deque<Dequelette<T>>, @Dequelette<T>)\n}\n\ntrait IDeque<T> {\n    fn enque_right(&self, T) -> @Self;\n    fn enque_left (&self, T) -> @Self;\n    fn deque_right(&self) -> @Self;\n    fn deque_left (&self) -> @Self;\n    fn peek_right (&self) -> T;\n    fn peek_left  (&self) -> T;\n    fn is_empty    (&self) -> bool;\n}\n\nimpl<T> IDeque<T> for Deque<T> {\n    fn is_empty(&self) -> bool {\n        match self {\n            &Empty => true,\n            _ => false\n        }\n    }\n\n    fn enque_right(&self, e: T) -> @Deque<T> {\n        match self {\n            &Empty => @Single(e),\n            &Single(v) => @Multi(@Deque1(v), @Empty, @Deque1(e)),\n\n            &Multi(left, inner_deque, @Deque1(a))\n            => @Multi(left, inner_deque, @Deque2(a, e)),\n\n            &Multi(left, inner_deque, @Deque2(a, b))\n            => @Multi(left, inner_deque, @Deque3(a, b, e)),\n\n            &Multi(left, inner_deque, @Deque3(a, b, c))\n            => @Multi(left, inner_deque, @Deque4(a, b, c, e)),\n\n            // inner_deque.enque_right(...)  <--- polymorphic recursion\n            &Multi(left, inner_deque, @Deque4(a, b, c, d))\n            => @Multi(left, inner_deque.enque_right(Deque3(a, b, c)), @Deque2(d, e))\n        }\n    }\n\n    fn enque_left (&self, e: T) -> @Deque<T> {\n        match self {\n            &Empty => @Single(e),\n            &Single(v) => @Multi(@Deque1(e), @Empty, @Deque1(v)),\n\n            &Multi(@Deque1(a), inner_deque, right)\n            => @Multi(@Deque2(e, a), inner_deque, right),\n\n            &Multi(@Deque2(a, b), inner_deque, right)\n            => @Multi(@Deque3(e, a, b), inner_deque, right),\n\n            &Multi(@Deque3(a, b, c), inner_deque, right)\n            => @Multi(@Deque4(e, a, b, c), inner_deque, right),\n\n            // inner_deque.enque_left(...)  <--- polymorphic recursion\n            &Multi(@Deque4(a, b, c, d), inner_deque, right)\n            => @Multi(@Deque2(e, a), inner_deque.enque_left(Deque3(b, c, d)), right)\n        }\n    }\n    fn deque_right(&self) -> @Deque<T> {\n        match self {\n            &Empty => { fail!(~\"empty deque\") }\n            &Single(_) => @Empty,\n\n            &Multi(left, inner_deque, @Deque2(a, _))\n            => @Multi(left, inner_deque, @Deque1(a)),\n\n            &Multi(left, inner_deque, @Deque3(a, b, _))\n            => { @Multi(left, inner_deque, @Deque2(a, b)) }\n\n            &Multi(left, inner_deque, @Deque4(a, b, c, _))\n            => @Multi(left, inner_deque, @Deque3(a, b, c)),\n\n            &Multi(@Deque1(v), @Empty, @Deque1(_))\n            => @Single(v),\n\n            &Multi(@Deque2(a, b), @Empty, @Deque1(_))\n            => @Multi(@Deque1(a), @Empty, @Deque1(b)),\n\n            &Multi(@Deque3(a, b, c), @Empty, @Deque1(_))\n            => { @Multi(@Deque2(a, b), @Empty, @Deque1(c)) },\n\n            &Multi(@Deque4(a, b, c, d), @Empty, @Deque1(_))\n            => @Multi(@Deque2(a, b), @Empty, @Deque2(c, d)),\n\n            &Multi(left, inner_deque, @Deque1(_))\n            => {\n                let dequelette =  inner_deque.peek_right();\n                @Multi(left, inner_deque.deque_right(), @dequelette) // <-- polymorphic recursion\n            }\n        }\n    }\n    fn deque_left (&self) -> @Deque<T> {\n        match self {\n            &Empty => fail!(~\"empty deque\"),\n            &Single(_) => @Empty,\n\n            &Multi(@Deque2(_, b), inner_deque, right)\n            => @Multi(@Deque1(b), inner_deque, right),\n\n            &Multi(@Deque3(_, b, c), inner_deque, right)\n            => @Multi(@Deque2(b, c), inner_deque, right),\n\n            &Multi(@Deque4(_, b, c, d), inner_deque, right)\n            => @Multi(@Deque3(b, c, d), inner_deque, right),\n\n            &Multi(@Deque1(_), @Empty, @Deque1(v))\n            => @Single(v),\n\n            &Multi(@Deque1(_), @Empty, @Deque2(a, b))\n            => @Multi(@Deque1(a), @Empty, @Deque1(b)),\n\n            &Multi(@Deque1(_), @Empty, @Deque3(a, b, c))\n            => @Multi(@Deque1(a), @Empty, @Deque2(b, c)),\n\n            &Multi(@Deque1(_), @Empty, @Deque4(a, b, c, d))\n            => @Multi(@Deque2(a, b), @Empty, @Deque2(c, d)),\n\n            &Multi(@Deque1(_), inner_deque, right)\n            => {\n                let dequelette = inner_deque.peek_left();\n                @Multi(@dequelette, inner_deque.deque_left(), right) // <-- polymorphic recursion\n            }\n        }\n    }\n\n    fn peek_right (&self) -> T {\n        match self {\n            &Empty => fail!(~\"empty deque\"),\n            &Single(v) => v,\n            &Multi(_, _, right_dequelette) => match (right_dequelette) {\n                @Deque1(v) => v,\n                @Deque2(_, v) => v,\n                @Deque3(_, _, v) => v,\n                @Deque4(_, _, _, v) => v\n            }\n        }\n    }\n\n    fn peek_left  (&self) -> T {\n        match self {\n            &Empty => fail!(~\"empty deque\"),\n            &Single(v) => v,\n            &Multi(left_dequelette, _, _) => match (left_dequelette) {\n                @Deque1(v) => v,\n                @Deque2(v, _) => v,\n                @Deque3(v, _, _) => v,\n                @Deque4(v, _, _, _) => v\n            }\n        }\n    }\n}\n\nfn main() {\n    let mut q: @Deque<int> = @Empty;\n    q = q.enque_right(0).enque_right(1).enque_right(2).enque_left(3);\n    assert!(q.peek_left() == 3);\n    q = q.deque_left();\n    assert!(q.peek_left() == 0);\n    q = q.deque_left();\n    assert!(q.peek_left() == 1);\n    q = q.deque_left();\n    assert!(q.peek_left() == 2);\n    q = q.deque_left();\n    assert!(q.is_empty());\n}\n```\n\nhere is what i was doing \n1. http://blogs.msdn.com/b/ericlippert/archive/2008/02/12/immutability-in-c-part-eleven-a-working-double-ended-queue.aspx\n2. http://www.soi.city.ac.uk/~ross/papers/FingerTree.pdf\n3. https://docs.google.com/file/d/0B9nStCiu3GXxdzhsMEgtdE54NW8/edit?usp=sharing\n\nI think that the problem is that Rust does not support polymorphic recursion which is <b>undecidable and requires the use of a semi-algorithm or programmer supplied type annotations</b> according to this http://en.wikipedia.org/wiki/Polymorphic_recursion -> http://dl.acm.org/citation.cfm?doid=169701.169692\n\ni found the info about this polymorphic recursion thing in the link 2 (FingerTree.pdf)\n\n`rustc` should identify the problem and report an error rather than looping forever\n\nOne more question: is it feasible to support this kind of things in Rust ?\n\nThanks\n", "closed_by": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/8613/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/8613/timeline", "performed_via_github_app": null, "state_reason": "completed"}