{"url": "https://api.github.com/repos/rust-lang/rust/issues/18148", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/18148/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/18148/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/18148/events", "html_url": "https://github.com/rust-lang/rust/issues/18148", "id": 46191310, "node_id": "MDU6SXNzdWU0NjE5MTMxMA==", "number": 18148, "title": "Consider compiling SIMD-from-SIMD initialisation directly to a shuffle", "user": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234956, "node_id": "MDU6TGFiZWwyMzQ5NTY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-codegen", "name": "A-codegen", "color": "f7e101", "default": false, "description": "Area: Code generation"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2014-10-19T00:08:59Z", "updated_at": "2017-03-23T16:57:04Z", "closed_at": "2017-03-23T16:57:04Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "``` rust\n#![crate_type = \"lib\"]\n#![feature(tuple_indexing)]\n\nuse std::simd::f32x4;\n\npub fn foo(x: f32x4) -> f32x4 {\n    f32x4(x.0, x.2, x.3, x.1)\n}\n```\n\nbecomes, with no optimisations:\n\n``` llvm\ndefine <4 x float> @_ZN3foo20h2254f602671f886ceaaE(<4 x float>) unnamed_addr #0 {\nentry-block:\n  %sret_slot = alloca <4 x float>\n  %x = alloca <4 x float>\n  store <4 x float> %0, <4 x float>* %x\n  %1 = getelementptr inbounds <4 x float>* %sret_slot, i32 0, i32 0\n  %2 = getelementptr inbounds <4 x float>* %x, i32 0, i32 0\n  %3 = load float* %2\n  store float %3, float* %1\n  %4 = getelementptr inbounds <4 x float>* %sret_slot, i32 0, i32 1\n  %5 = getelementptr inbounds <4 x float>* %x, i32 0, i32 2\n  %6 = load float* %5\n  store float %6, float* %4\n  %7 = getelementptr inbounds <4 x float>* %sret_slot, i32 0, i32 2\n  %8 = getelementptr inbounds <4 x float>* %x, i32 0, i32 3\n  %9 = load float* %8\n  store float %9, float* %7\n  %10 = getelementptr inbounds <4 x float>* %sret_slot, i32 0, i32 3\n  %11 = getelementptr inbounds <4 x float>* %x, i32 0, i32 1\n  %12 = load float* %11\n  store float %12, float* %10\n  %13 = load <4 x float>* %sret_slot\n  ret <4 x float> %13\n}\n```\n\nwith optimisations it becomes\n\n``` llvm\ndefine <4 x float> @_ZN3foo20h2254f602671f886ceaaE(<4 x float>) unnamed_addr #0 {\nentry-block:\n  %sret_slot.12.vec.insert = shufflevector <4 x float> %0, <4 x float> undef, <4 x i32> <i32 0, i32 2, i32 3, i32 1>\n  ret <4 x float> %sret_slot.12.vec.insert\n}\n```\n\nWe could detect when a SIMD vector is being created directly from elements of another (pair of*) SIMD vector(s) and convert it directly into the appropriate shuffle instruction. This will save allocas and LLVM doing work, and probably guarantees it more than LLVM currently does. This should even work for vectors of different lengths, as long as the elements are the same.\n\n(This is just a bug since it's an implementation detail.)\n\n*[`shufflevector`](http://llvm.org/docs/LangRef.html#shufflevector-instruction) actually takes two operands, so `f32x2(x.0, y.0, x.1, y.1)` can also directly become a shuffle.\n", "closed_by": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/18148/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/18148/timeline", "performed_via_github_app": null, "state_reason": "completed"}