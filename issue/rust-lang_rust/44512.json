{"url": "https://api.github.com/repos/rust-lang/rust/issues/44512", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/44512/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/44512/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/44512/events", "html_url": "https://github.com/rust-lang/rust/issues/44512", "id": 256878356, "node_id": "MDU6SXNzdWUyNTY4NzgzNTY=", "number": 44512, "title": "mpsc stream is currently a pessimization", "user": {"login": "JLockerman", "id": 15097355, "node_id": "MDQ6VXNlcjE1MDk3MzU1", "avatar_url": "https://avatars.githubusercontent.com/u/15097355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JLockerman", "html_url": "https://github.com/JLockerman", "followers_url": "https://api.github.com/users/JLockerman/followers", "following_url": "https://api.github.com/users/JLockerman/following{/other_user}", "gists_url": "https://api.github.com/users/JLockerman/gists{/gist_id}", "starred_url": "https://api.github.com/users/JLockerman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JLockerman/subscriptions", "organizations_url": "https://api.github.com/users/JLockerman/orgs", "repos_url": "https://api.github.com/users/JLockerman/repos", "events_url": "https://api.github.com/users/JLockerman/events{/privacy}", "received_events_url": "https://api.github.com/users/JLockerman/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-09-12T00:13:02Z", "updated_at": "2017-10-11T21:55:26Z", "closed_at": "2017-10-11T21:55:26Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "**TLDR**\r\nAs of `rustc 1.22.0-nightly (981ce7d8d 2017-09-03)` cloning a `mpsc::Sender` speeds up spsc workloads. My benchmarking seems to indicate that this is due to:\r\n\r\n1. Contention on shared counters in the node cache ([push](https://github.com/rust-lang/rust/blob/26d4308c6acbbde642be4621f5e3487b24ed8bd1/src/libstd/sync/mpsc/spsc_queue.rs#L184), [pop](https://github.com/rust-lang/rust/blob/26d4308c6acbbde642be4621f5e3487b24ed8bd1/src/libstd/sync/mpsc/spsc_queue.rs#L139)).\r\n\r\n2. False sharing between the [producer](https://github.com/rust-lang/rust/blob/26d4308c6acbbde642be4621f5e3487b24ed8bd1/src/libstd/sync/mpsc/spsc_queue.rs#L61) and [consumer](https://github.com/rust-lang/rust/blob/26d4308c6acbbde642be4621f5e3487b24ed8bd1/src/libstd/sync/mpsc/spsc_queue.rs#L57) fields in the underlying queue.\r\n\r\n3. False sharing or contention in the [wakeup code](https://github.com/rust-lang/rust/blob/26d4308c6acbbde642be4621f5e3487b24ed8bd1/src/libstd/sync/mpsc/stream.rs#L46).\r\n\r\n2 can be fixed by simply changing the alignment of the offending members so that the producer and consumer parts are on separate cache lines. 1 can be fixed with a small rewrite so that the queue only tracks its cache size at the consumer (a version of this code can be found [here](https://github.com/JLockerman/std_spsc_is_slow/blob/16d4548c63ef9faf3ec0130f4439698e8b774180/src/spsc2.rs#L190)). 3 can be mitigated by reworking the alignment, but I am not sure if it's a full fix, rewriting the the send and recv logic so that no counter may also fix the issue (a version of the code that does this can be found \\([here](https://github.com/JLockerman/std_spsc_is_slow/blob/16d4548c63ef9faf3ec0130f4439698e8b774180/src/stream2.rs#L240) and [here](https://github.com/JLockerman/std_spsc_is_slow/blob/16d4548c63ef9faf3ec0130f4439698e8b774180/src/stream2.rs#L288)\\), but it is not complete).\r\n\r\n---\r\n\r\nIn the following benchmark:\r\n\r\n```rust\r\nfn bench_mpsc_stream() -> f64 {\r\n    let (sender, reciever) = channel();\r\n    bench_spsc(sender, reciever)\r\n}\r\n\r\nfn bench_mpsc_shared() -> f64 {\r\n    let (sender, reciever) = channel();\r\n    // this clone forces the queue into shared mode and makes the benchmark faster\r\n    let _clone = sender.clone();\r\n    bench_spsc(sender, reciever)\r\n}\r\n\r\nconst COUNT: u64 = 10_000_000;\r\n\r\nfn bench_spsc(tx: Sender<u64>, rx: Receiver<u64>) -> f64 {\r\n    // ensure that the channel is not in Once mode\r\n    tx.send(0).unwrap();\r\n    tx.send(0).unwrap();\r\n    rx.recv().unwrap();\r\n    rx.recv().unwrap();\r\n\r\n    let start = ::std::time::Instant::now();\r\n    scope(|scope| {\r\n        scope.spawn(move || {\r\n            for x in 0..(COUNT*2) {\r\n                let _ = black_box(tx.send(x));\r\n            }\r\n        });\r\n\r\n        for _i in 0..(COUNT*2) {\r\n            let _ = black_box(rx.recv().unwrap());\r\n        }\r\n    });\r\n    let d = start.elapsed();\r\n\r\n    nanos(d) / ((COUNT*2) as f64)\r\n}\r\n```\r\n\\(derived from [crossbeam](https://github.com/crossbeam-rs/crossbeam/blob/2b03f1fd8c6dd5a045f3b77a0d2bbebff4776ade/src/bin/bench.rs), full code can be found [in this repo](https://github.com/JLockerman/std_spsc_is_slow)\\)\r\n\r\non an early 2014 Intel i5 running macos, using `rustc 1.22.0-nightly (981ce7d8d 2017-09-03)` or `rustc 1.20.0 (f3d6973f4 2017-08-27)`, `stream` runs at roughly `201 ns/send` while `shared` runs at `134 ns/send`.\r\nRunning on linux on EC2 and a raspberry pi show similar behavior.\r\n\r\nThe underlying datastructures show some difference in performance (`spsc queue 75 ns/send`, `mpsc 59 ns/send`), though not enough to fully explain the difference. Though I have not yet looked enough into the `mpsc` code enough to be sure of the difference, I did find potential improvements for `spsc`:\r\n\r\n|    SPSC Performance    | Unaligned    | Cache Aligned  |\r\n|------------------------|--------------|----------------|\r\n| Default Cache          | 75 `ns/send` |  97 `ns/send`  |\r\n| No Cache               | 46 `ns/send` |  47 `ns/send`  |\r\n| Unbounded Cache        | 30 `ns/send` |  12 `ns/send`  |\r\n| Low Contention Cache   | 35 `ns/send` |   9 `ns/send`  |\r\n\r\nWhere Unaligned is the current struct layout, Cache Aligned aligns the [consumer fields](https://github.com/rust-lang/rust/blob/26d4308c6acbbde642be4621f5e3487b24ed8bd1/src/libstd/sync/mpsc/spsc_queue.rs#L57) and [producer fields](https://github.com/rust-lang/rust/blob/26d4308c6acbbde642be4621f5e3487b24ed8bd1/src/libstd/sync/mpsc/spsc_queue.rs#L61) to their own cache line (code is [here](https://github.com/JLockerman/std_spsc_is_slow/blob/16d4548c63ef9faf3ec0130f4439698e8b774180/src/spsc.rs#L26)\\).\r\nDefault cache is the current node cache implementation in std, No Cache disables the Node cache entirely \\([producer code](https://github.com/JLockerman/std_spsc_is_slow/blob/16d4548c63ef9faf3ec0130f4439698e8b774180/src/spsc.rs#L238), [consumer code](https://github.com/JLockerman/std_spsc_is_slow/blob/16d4548c63ef9faf3ec0130f4439698e8b774180/src/spsc.rs#L284)\\), and Unbounded Cache should be self explanatory.\r\n\r\nLow Contention Cache rewrites the cache bounding logic to be done entirely on the consumer side.\r\nInstead of keeping a count of how many nodes are in the cache, it keeps track of how many nodes\r\nare marked as _eligible_ to be cached, and only and always caches those nodes so marked \\(code for this can be found [here](https://github.com/JLockerman/std_spsc_is_slow/blob/16d4548c63ef9faf3ec0130f4439698e8b774180/src/spsc2.rs#L190), my experimental implementation stores the eligible flag in the [node](https://github.com/JLockerman/std_spsc_is_slow/blob/16d4548c63ef9faf3ec0130f4439698e8b774180/src/spsc2.rs#L16), though it could also be done by stealing a bit from the pointer\\).\r\n\r\nSome of these performance improvements translate to the full `stream` structure:\r\n\r\n|   Stream Performance   |   Unaligned   | Cache Aligned  |\r\n|------------------------|---------------|----------------|\r\n| Default Cache          | 205 `ns/send` |  212 `ns/send` |\r\n| No Cache               | 103 `ns/send` |   91 `ns/send` |\r\n| Low Contention Cache   | 179 `ns/send` |  102 `ns/send` |\r\n\r\nBut to fully see the benefits, contention with the [wakeup](https://github.com/rust-lang/rust/blob/26d4308c6acbbde642be4621f5e3487b24ed8bd1/src/libstd/sync/mpsc/stream.rs#L46) state needs to be removed\r\n\r\n|  Stream2 Performance   |   Unaligned   | Cache Aligned  |\r\n|------------------------|---------------|----------------|\r\n| Default Cache          | 131 `ns/send` |  112 `ns/send` |\r\n| No Cache               |  91 `ns/send` |   58 `ns/send` |\r\n| Low Contention Cache   | 103 `ns/send` |   27 `ns/send` |\r\n\r\n\\(The numbers were collected from a version of stream that [does not a counter at all](https://github.com/rust-lang/rust/blob/26d4308c6acbbde642be4621f5e3487b24ed8bd1/src/libstd/sync/mpsc/stream.rs#L46) I've gotten similar numbers from simply putting every field in stream on their own cache line. I _think_ there should be a layout which uses exactly 2 lines, one for the producer and one for the consumer, with similar performance, but I have not done enough benchmarking to confirm it yet\\).\r\n\r\nAll the code code to reproduce these numbers can be found in [this repo](https://github.com/JLockerman/std_spsc_is_slow), along with the number for a raspberry pi.\r\nNote that the raspberry pi seemed to be undergoing throttling as the benchmark ran, so numbers gathered later in the run are significantly worse than the one gathered at the beginning.\r\n\r\nMy apologies for the length and quality of writing.\r\n\r\ncc @alexcrichton I believe.\r\n", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/44512/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/44512/timeline", "performed_via_github_app": null, "state_reason": "completed"}