{"url": "https://api.github.com/repos/rust-lang/rust/issues/82445", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/82445/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/82445/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/82445/events", "html_url": "https://github.com/rust-lang/rust/issues/82445", "id": 814619918, "node_id": "MDU6SXNzdWU4MTQ2MTk5MTg=", "number": 82445, "title": " LLVM ERROR: Invalid encoding", "user": {"login": "davidspies", "id": 25523854, "node_id": "MDQ6VXNlcjI1NTIzODU0", "avatar_url": "https://avatars.githubusercontent.com/u/25523854?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidspies", "html_url": "https://github.com/davidspies", "followers_url": "https://api.github.com/users/davidspies/followers", "following_url": "https://api.github.com/users/davidspies/following{/other_user}", "gists_url": "https://api.github.com/users/davidspies/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidspies/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidspies/subscriptions", "organizations_url": "https://api.github.com/users/davidspies/orgs", "repos_url": "https://api.github.com/users/davidspies/repos", "events_url": "https://api.github.com/users/davidspies/events{/privacy}", "received_events_url": "https://api.github.com/users/davidspies/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2021-02-23T16:23:40Z", "updated_at": "2023-04-05T17:35:21Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\n\r\nThe code is the same as in this issue https://github.com/rust-lang/rust/issues/82406\r\nbut I added `--release` to the command-line arguments\r\n\r\n```\r\n$ cargo build --release --verbose\r\n       Fresh lazy_fields v0.1.0 (https://github.com/davidspies/lazy-fields?branch=main#79d2e45d)\r\n       Fresh dc2 v0.1.0 (https://github.com/davidspies/dc2?branch=main#9e1fb2ea)\r\n   Compiling boolsatr v0.1.0 (/home/david/projects/boolsatr)\r\n     Running `rustc --crate-name boolsatr --edition=2018 src/main.rs --error-format=json --json=diagnostic-rendered-ansi --crate-type bin --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C metadata=c54a8525119404e2 -C extra-filename=-c54a8525119404e2 --out-dir /home/david/projects/boolsatr/target/release/deps -L dependency=/home/david/projects/boolsatr/target/release/deps --extern dc2=/home/david/projects/boolsatr/target/release/deps/libdc2-3565d5356584d424.rlib --extern lazy_fields=/home/david/projects/boolsatr/target/release/deps/liblazy_fields-a3780a936ab6c673.rlib`\r\nwarning: variant is never constructed: `Leaf`\r\n<...>\r\nLLVM ERROR: Invalid encoding\r\nerror: could not compile `boolsatr`\r\n\r\nCaused by:\r\n  process didn't exit successfully: `rustc --crate-name boolsatr --edition=2018 src/main.rs --error-format=json --json=diagnostic-rendered-ansi --crate-type bin --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C metadata=c54a8525119404e2 -C extra-filename=-c54a8525119404e2 --out-dir /home/david/projects/boolsatr/target/release/deps -L dependency=/home/david/projects/boolsatr/target/release/deps --extern dc2=/home/david/projects/boolsatr/target/release/deps/libdc2-3565d5356584d424.rlib --extern lazy_fields=/home/david/projects/boolsatr/target/release/deps/liblazy_fields-a3780a936ab6c673.rlib` (exit code: 101)\r\n```\r\n\r\nI tried this code:\r\n\r\n<details><summary>Code</summary>\r\n\r\n```rust\r\nmod collection_ops {\r\n    use crate::tuple::{snd, swap};\r\n    use dc2::{key::Key, monoid::Monoid, Collection, Op, Relation};\r\n    use std::ops::Mul;\r\n\r\n    pub trait SemiJoinOn<'a, D1: Key, D2, R: Monoid> {\r\n        fn semijoin_on<F: Fn(&D1) -> D2 + 'static, C2: Op<D = D2, R = R>>(\r\n            self,\r\n            other: Relation<'a, C2>,\r\n            f: F,\r\n        ) -> Collection<'a, D1, R>;\r\n    }\r\n\r\n    impl<'a, D1: Key, D2: Key, R: Monoid + Mul<R, Output = R>, C: Op<D = D1, R = R>>\r\n        SemiJoinOn<'a, D1, D2, R> for Relation<'a, C>\r\n    {\r\n        fn semijoin_on<F: Fn(&D1) -> D2 + 'static, C2: Op<D = D2, R = R>>(\r\n            self,\r\n            other: Relation<'a, C2>,\r\n            f: F,\r\n        ) -> Collection<'a, D1, R> {\r\n            self.map(move |val| (f(&val), val))\r\n                .semijoin(other)\r\n                .map(snd)\r\n                .collect()\r\n        }\r\n    }\r\n\r\n    pub trait SemiJoinOnSnd<'a, D1: Key, D2: Key, R: Monoid> {\r\n        fn semijoin_on_snd<C2: Op<D = D2, R = R>>(\r\n            self,\r\n            other: Relation<'a, C2>,\r\n        ) -> Collection<'a, (D1, D2), R>;\r\n    }\r\n\r\n    impl<'a, D1: Key, D2: Key, R: Monoid + Mul<R, Output = R>, C: Op<D = (D1, D2), R = R>>\r\n        SemiJoinOnSnd<'a, D1, D2, R> for Relation<'a, C>\r\n    {\r\n        fn semijoin_on_snd<C2: Op<D = D2, R = R>>(\r\n            self,\r\n            other: Relation<'a, C2>,\r\n        ) -> Collection<'a, (D1, D2), R> {\r\n            self.map(swap).semijoin(other).map(swap).collect()\r\n        }\r\n    }\r\n}\r\nmod ops {\r\n    use std::hash::{Hash, Hasher};\r\n    use std::ops::Deref;\r\n    use std::rc::Rc;\r\n\r\n    #[derive(Debug)]\r\n    pub struct RcRaw<T>(pub Rc<T>);\r\n\r\n    impl<T> Clone for RcRaw<T> {\r\n        fn clone(&self) -> Self {\r\n            RcRaw(Rc::clone(&self.0))\r\n        }\r\n    }\r\n\r\n    impl<T> PartialEq for RcRaw<T> {\r\n        fn eq(&self, other: &Self) -> bool {\r\n            Rc::ptr_eq(&self.0, &other.0)\r\n        }\r\n    }\r\n\r\n    impl<T> Eq for RcRaw<T> {}\r\n\r\n    impl<T> Hash for RcRaw<T> {\r\n        fn hash<H: Hasher>(&self, state: &mut H) {\r\n            Rc::as_ptr(&self.0).hash(state);\r\n        }\r\n    }\r\n\r\n    impl<T> Deref for RcRaw<T> {\r\n        type Target = T;\r\n        fn deref(&self) -> &T {\r\n            Rc::deref(&self.0)\r\n        }\r\n    }\r\n}\r\nmod primitives {\r\n    use std::cmp::Ordering;\r\n    use std::ops::Not;\r\n    #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]\r\n    pub struct Assig(isize);\r\n    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Hash)]\r\n    pub struct Var(isize);\r\n    pub type MicroLevel = usize;\r\n    impl Assig {\r\n        pub fn var(self) -> Var {\r\n            Var(self.0.abs())\r\n        }\r\n    }\r\n    impl Not for Assig {\r\n        type Output = Assig;\r\n        fn not(self) -> Self::Output {\r\n            Assig(-self.0)\r\n        }\r\n    }\r\n    impl PartialOrd for Assig {\r\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\r\n            Some(self.cmp(other))\r\n        }\r\n    }\r\n    impl Ord for Assig {\r\n        fn cmp(&self, other: &Self) -> Ordering {\r\n            match self.0.abs().cmp(&other.0.abs()) {\r\n                Ordering::Equal => self.0.cmp(&other.0),\r\n                res => res,\r\n            }\r\n        }\r\n    }\r\n    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Hash)]\r\n    pub struct RuleIndex(usize);\r\n}\r\nmod program {\r\n    use crate::primitives::{Assig, RuleIndex, Var};\r\n    use dc2::Collection;\r\n\r\n    #[derive(Clone)]\r\n    pub struct RulesCollections {\r\n        pub rule_index: Collection<'static, RuleIndex>,\r\n        pub rule: Collection<'static, (RuleIndex, Assig)>,\r\n        pub vars: Collection<'static, Var>,\r\n    }\r\n}\r\nmod solver {\r\n    mod binary {\r\n        use super::learnt::RefRule;\r\n        use super::primitives::DecisionLevel;\r\n        use super::SolverCollections;\r\n        use crate::collection_ops::{SemiJoinOn, SemiJoinOnSnd};\r\n        use crate::primitives::{Assig, RuleIndex, Var};\r\n        use crate::tuple::{fst, snd, swap};\r\n        use dc2::key::Key;\r\n        use dc2::map::{AssertOnes, VecMap};\r\n        use dc2::{\r\n            Arrangement, Collection, CreationContext, Input, MapMapArrangement, MappingArrangement,\r\n        };\r\n        use std::collections::hash_map::DefaultHasher;\r\n        use std::collections::{BTreeMap, HashMap};\r\n        use std::hash::{Hash, Hasher};\r\n        pub struct Binary {\r\n            pub binary_input: Input<((Assig, Assig), (RefRule, DecisionLevel))>,\r\n            pub binary_output: MapMapArrangement<Assig, (Assig, Path)>,\r\n            pub binary_by_level: MapMapArrangement<DecisionLevel, ((Assig, Assig), RefRule)>,\r\n            pub closure: MappingArrangement<(Assig, Assig), usize>,\r\n            pub self_implied: Arrangement<\r\n                (usize, (Var, Assig)),\r\n                isize,\r\n                BTreeMap<usize, HashMap<Var, HashMap<Assig, isize>>>,\r\n            >,\r\n            pub other_un_impls: MapMapArrangement<Var, (Assig, RuleIndex)>,\r\n            pub other_bin_impls: MapMapArrangement<(Assig, Assig), RuleIndex>,\r\n        }\r\n        #[derive(Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\r\n        pub enum Path {\r\n            Direct(RuleIndex),\r\n            Indirect(RefRule),\r\n        }\r\n        impl SolverCollections<'_> {\r\n            pub fn make_binary(&self) -> Binary {\r\n                let active = self.active.get();\r\n                let rule_sizes = self.rule_sizes.get().clone();\r\n                let binary_rule_inds = rule_sizes\r\n                    .filter(|&(_key, count)| count == 2)\r\n                    .map(fst)\r\n                    .named(\"binary_rule_inds\");\r\n                let binary_rules = active\r\n                    .rule\r\n                    .clone()\r\n                    .semijoin(binary_rule_inds)\r\n                    .reduce(|_i, xs: &HashMap<Assig, isize>| {\r\n                        let mut iter = xs.iter().assert_ones();\r\n                        let &x = iter.next().expect(\"No assigs\");\r\n                        let &y = iter.next().expect(\"Only 1 assig\");\r\n                        assert!(iter.next().is_none(), \"More than 2 assigs\");\r\n                        VecMap::new(vec![((!x, y), 1), ((!y, x), 1)])\r\n                    })\r\n                    .map(|(i, imp)| (imp, Path::Direct(i)))\r\n                    .named(\"binary_rules\");\r\n                let (binary_input, binary_manual) = self.context.borrow().create_input();\r\n                let binary_manual = binary_manual.split().named(\"binary_manual\");\r\n                let binary_by_level: MapMapArrangement<DecisionLevel, ((Assig, Assig), RefRule)> =\r\n                    binary_manual\r\n                        .clone()\r\n                        .map(|(xy, (i, dl))| (dl, (xy, i)))\r\n                        .dynamic()\r\n                        .named(\"binary_by_level\")\r\n                        .get_arrangement(&self.context.borrow());\r\n                let verts = self.rem_lits.get();\r\n                let binary = binary_rules\r\n                    .concat(\r\n                        binary_manual\r\n                            .semijoin_on(verts.clone(), |&((x, _), _)| x)\r\n                            .semijoin_on(verts.clone(), |&((_, y), _)| y)\r\n                            .map(|(xy, (i, _))| (xy, Path::Indirect(i))),\r\n                    )\r\n                    .split()\r\n                    .named(\"binary\");\r\n                let closure_raw = transitive_closure(\r\n                    &mut self.context.borrow_mut(),\r\n                    verts.clone(),\r\n                    binary.clone().map(fst).collect(),\r\n                )\r\n                .named(\"closure_raw\");\r\n                let (closure, closure_output) =\r\n                    closure_raw.assert_1to1_with_output(&self.context.borrow());\r\n                let closure = closure.split().named(\"closure\");\r\n                let self_implied = closure\r\n                    .clone()\r\n                    .flat_map(|((x, y), d)| {\r\n                        if y == !x {\r\n                            Some((d, (y.var(), y)))\r\n                        } else {\r\n                            None\r\n                        }\r\n                    })\r\n                    .dynamic()\r\n                    .named(\"self_implied\");\r\n                let rule_sizes = self.rule_sizes.get();\r\n                let chosen_rule_index = rule_sizes\r\n                    .clone()\r\n                    .flat_map(|(i, rs)| if rs >= 3 { Some(i) } else { None })\r\n                    .named(\"chosen_rule_index\");\r\n                let chosen_rule = active\r\n                    .rule\r\n                    .clone()\r\n                    .semijoin(chosen_rule_index)\r\n                    .split()\r\n                    .named(\"chosen_rule\");\r\n                let pairings = chosen_rule\r\n                    .clone()\r\n                    .map(move |(i, x)| {\r\n                        let mut h = DefaultHasher::new();\r\n                        (i, x).hash(&mut h);\r\n                        (i, (h.finish(), x))\r\n                    })\r\n                    .reduce(|_, xs: &BTreeMap<(u64, Assig), isize>| {\r\n                        let mut iter = xs.iter().assert_ones();\r\n                        let &(_, x) = iter.next().expect(\"Empty rule\");\r\n                        let &(_, y) = iter.next().expect(\"Unary rule\");\r\n                        let &(_, z) = iter.next().expect(\"Binary rule\");\r\n                        VecMap::new(vec![((x, y), 1), ((x, z), 1), ((y, z), 1)])\r\n                    })\r\n                    .split()\r\n                    .named(\"pairings\");\r\n                let implied = closure.map(fst).split().named(\"implied\");\r\n                let both_implied = pairings\r\n                    .clone()\r\n                    .map(snd)\r\n                    .triangles(implied.clone(), implied.clone())\r\n                    .map(|(x, y, z)| ((x, y), z))\r\n                    .named(\"both_implied\");\r\n                let candidates = pairings\r\n                    .map(swap)\r\n                    .join(both_implied)\r\n                    .map(snd)\r\n                    .distinct()\r\n                    .named(\"candidates\");\r\n                let impl_count = chosen_rule\r\n                    .clone()\r\n                    .join(candidates)\r\n                    .dynamic() // TODO Why does removing this cause the compiler to hang?\r\n                    .semijoin_on_snd(implied.clone())\r\n                    .map(|(i, (_, y))| (i, y))\r\n                    .counts()\r\n                    .map(|((i, y), c)| {\r\n                        assert!(c >= 2);\r\n                        (i, (y, c))\r\n                    })\r\n                    .named(\"impl_count\");\r\n                let critical = impl_count\r\n                    .join(rule_sizes.clone())\r\n                    .flat_map(|(i, ((y, c), rs))| if c >= rs - 1 { Some((i, y)) } else { None })\r\n                    .split()\r\n                    .named(\"critical\");\r\n                let new_binary = chosen_rule\r\n                    .join(critical.clone())\r\n                    .map(swap)\r\n                    .antijoin(implied.clone())\r\n                    .map(|((x, y), i)| ((!x, y), i))\r\n                    .split()\r\n                    .named(\"new_binary\");\r\n                let new_unary = critical\r\n                    .map(swap)\r\n                    .concat(new_binary.clone().map(|((_, y), i)| (y, i)).negate())\r\n                    .named(\"new_unary\");\r\n                let context = self.context.borrow();\r\n                Binary {\r\n                    binary_input,\r\n                    binary_output: binary\r\n                        .map(|((x, y), i)| (x, (y, i)))\r\n                        .dynamic()\r\n                        .named(\"binary_output\")\r\n                        .get_arrangement(&context),\r\n                    binary_by_level,\r\n                    closure: Box::new(closure_output),\r\n                    self_implied: self_implied.get_arrangement(&context),\r\n                    other_un_impls: new_unary\r\n                        .map(|(x, i)| (x.var(), (x, i)))\r\n                        .dynamic()\r\n                        .named(\"other_un_impls\")\r\n                        .get_arrangement(&context),\r\n                    other_bin_impls: new_binary\r\n                        .antijoin(implied)\r\n                        .dynamic()\r\n                        .named(\"other_bin_impls\")\r\n                        .get_arrangement(&context),\r\n                }\r\n            }\r\n        }\r\n        fn transitive_closure<T: Key>(\r\n            context: &mut CreationContext,\r\n            verts: Collection<T>,\r\n            edges: Collection<(T, T)>,\r\n        ) -> Collection<'static, ((T, T), usize)> {\r\n            let mut subcontext = context.subgraph::<usize>();\r\n            let (var, c) = subcontext.variable();\r\n            let c = c.named(\"c\");\r\n            let nextdists = verts\r\n                .map(|x| ((x.clone(), x), 0))\r\n                .enter()\r\n                .concat(\r\n                    c.map(|(d, (x, y))| (y, (x, d)))\r\n                        .join(edges.enter())\r\n                        .map(|(_, ((x, d), y))| ((x, y), d + 1)),\r\n                )\r\n                .group_min()\r\n                .split()\r\n                .named(\"nextdists\");\r\n            var.set(nextdists.clone().map(swap));\r\n            nextdists.leave(&subcontext.finish()).collect()\r\n        }\r\n    }\r\n    pub mod collections {\r\n        use super::Binary;\r\n        use crate::primitives::{Assig, RuleIndex};\r\n        use crate::program::RulesCollections;\r\n        use dc2::{Collection, CreationContext};\r\n        use lazy_fields::{self, with_lazy_fields, LazyField};\r\n        use std::cell::RefCell;\r\n        type PField<'a, T> = LazyField<'a, SolverCollections<'a>, T>;\r\n        type RuleSizesCollection = Collection<'static, (RuleIndex, isize)>;\r\n        pub struct SolverCollections<'a> {\r\n            pub context: RefCell<CreationContext>,\r\n            pub all_lits: PField<'a, Collection<'static, Assig>>,\r\n            pub base: PField<'a, RulesCollections>,\r\n            pub active_base: PField<'a, RulesCollections>,\r\n            pub rem_lits: PField<'a, Collection<'static, Assig>>,\r\n            pub active: PField<'a, RulesCollections>,\r\n            pub rule_sizes: PField<'a, RuleSizesCollection>,\r\n            pub binary: PField<'a, Binary>,\r\n        }\r\n        impl<'a> SolverCollections<'a> {\r\n            pub fn new() -> Self {\r\n                with_lazy_fields(\r\n                    move |r: &mut lazy_fields::Register<'a, SolverCollections<'a>>| {\r\n                        SolverCollections {\r\n                            context: RefCell::new(CreationContext::new()),\r\n                            base: r.field(SolverCollections::make_base),\r\n                            all_lits: r.field(SolverCollections::make_all_lits),\r\n                            active_base: r.field(SolverCollections::make_active_base),\r\n                            rem_lits: r.field(SolverCollections::make_rem_lits),\r\n                            active: r.field(SolverCollections::make_active),\r\n                            rule_sizes: r.field(SolverCollections::make_rule_sizes),\r\n                            binary: r.field(SolverCollections::make_binary),\r\n                        }\r\n                    },\r\n                )\r\n            }\r\n            fn make_all_lits(&self) -> Collection<'static, Assig> {\r\n                unimplemented!()\r\n            }\r\n            fn make_rem_lits(&self) -> Collection<'static, Assig> {\r\n                unimplemented!()\r\n            }\r\n            fn make_base(&self) -> RulesCollections {\r\n                unimplemented!()\r\n            }\r\n            fn make_active_base(&self) -> RulesCollections {\r\n                unimplemented!()\r\n            }\r\n            fn make_active(&self) -> RulesCollections {\r\n                unimplemented!()\r\n            }\r\n            fn make_rule_sizes(&self) -> RuleSizesCollection {\r\n                unimplemented!()\r\n            }\r\n        }\r\n    }\r\n    mod learnt {\r\n        use crate::ops::RcRaw;\r\n        use crate::primitives::{Assig, RuleIndex};\r\n        use std::cell::RefCell;\r\n        use std::cmp::Ordering;\r\n        use std::collections::HashMap;\r\n        #[derive(Clone, PartialEq, Eq, Hash, Debug)]\r\n        pub struct RefRule(RcRaw<RefCell<RuleBuilder>>);\r\n        #[derive(Debug)]\r\n        enum RuleBuilder {\r\n            Leaf(RuleIndex),\r\n            Node(RefRule, HashMap<Assig, RefRule>),\r\n        }\r\n        impl PartialOrd for RefRule {\r\n            fn partial_cmp(&self, _other: &Self) -> Option<Ordering> {\r\n                unimplemented!()\r\n            }\r\n        }\r\n        impl Ord for RefRule {\r\n            fn cmp(&self, _other: &Self) -> Ordering {\r\n                unimplemented!()\r\n            }\r\n        }\r\n    }\r\n    mod primitives {\r\n        use super::learnt::RefRule;\r\n        use crate::primitives::{MicroLevel, RuleIndex};\r\n        pub type DecisionLevel = usize;\r\n        #[derive(Clone, Debug, PartialEq, Eq, Hash)]\r\n        pub struct AssignInfo {\r\n            pub decision_level: DecisionLevel,\r\n            pub cause: Cause,\r\n            pub micro_level: MicroLevel,\r\n        }\r\n        #[derive(Clone, Debug, PartialEq, Eq, Hash)]\r\n        pub enum Cause {\r\n            Decision,\r\n            InferredFrom(RuleIndex),\r\n            Pure,\r\n            BinaryChains(RefRule),\r\n        }\r\n    }\r\n    use self::binary::Binary;\r\n    use self::collections::SolverCollections;\r\n}\r\nmod tuple {\r\n    pub fn fst<A, B>((a, _): (A, B)) -> A {\r\n        a\r\n    }\r\n    pub fn snd<A, B>((_, b): (A, B)) -> B {\r\n        b\r\n    }\r\n    pub fn swap<A, B>((a, b): (A, B)) -> (B, A) {\r\n        (b, a)\r\n    }\r\n}\r\n\r\nuse self::solver::collections::SolverCollections;\r\n\r\nfn main() {\r\n    SolverCollections::new();\r\n}\r\n```\r\n</details>\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.52.0-nightly (07194ffcd 2021-02-10)\r\nbinary: rustc\r\ncommit-hash: 07194ffcd25b0871ce560b9f702e52db27ac9f77\r\ncommit-date: 2021-02-10\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.52.0-nightly\r\nLLVM version: 11.0.1\r\n```\r\n\r\n<!--\r\nInclude a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\r\nenvironment. E.g. `RUST_BACKTRACE=1 cargo build`.\r\n-->\r\n<details><summary>Backtrace</summary>\r\n<p>\r\n\r\n`RUST_BACKTRACE=1` didn't produce any backtrace\r\n\r\n</p>\r\n</details>\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/82445/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/82445/timeline", "performed_via_github_app": null, "state_reason": null}