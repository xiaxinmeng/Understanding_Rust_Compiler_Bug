{"url": "https://api.github.com/repos/rust-lang/rust/issues/66740", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/66740/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/66740/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/66740/events", "html_url": "https://github.com/rust-lang/rust/issues/66740", "id": 528125169, "node_id": "MDU6SXNzdWU1MjgxMjUxNjk=", "number": 66740, "title": "Stabilize the `#[alloc_error_handler]` attribute (for no_std + liballoc)", "user": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 129836139, "node_id": "MDU6TGFiZWwxMjk4MzYxMzk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-allocators", "name": "A-allocators", "color": "f7e101", "default": false, "description": "Area: Custom and system allocators"}, {"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 246778137, "node_id": "MDU6TGFiZWwyNDY3NzgxMzc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/B-unstable", "name": "B-unstable", "color": "d304cb", "default": false, "description": "Implemented in the nightly compiler and unstable."}, {"id": 880020421, "node_id": "MDU6TGFiZWw4ODAwMjA0MjE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/WG-embedded", "name": "WG-embedded", "color": "c2e0c6", "default": false, "description": "Of interest to the embedded Working Group"}, {"id": 919710011, "node_id": "MDU6TGFiZWw5MTk3MTAwMTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/disposition-merge", "name": "disposition-merge", "color": "008800", "default": false, "description": "This issue / PR is in PFCP or FCP with a disposition to merge it."}, {"id": 923282386, "node_id": "MDU6TGFiZWw5MjMyODIzODY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/finished-final-comment-period", "name": "finished-final-comment-period", "color": "f9e189", "default": false, "description": "The final comment period is finished for this PR / Issue."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 33, "created_at": "2019-11-25T14:30:55Z", "updated_at": "2020-07-29T19:14:28Z", "closed_at": "2020-07-29T19:14:27Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "## Summary\r\n\r\nThis issue formally proposes stabilizing the `#[alloc_error_handler]` attribute as-is, after adding some documentation.\r\n\r\nTracking issue: https://github.com/rust-lang/rust/issues/51540\r\n\r\nNormally the tracking issue is where we propose FCP to stabilize, but this one already has many comments that go into a number of sub-topics. Since the feature did not originally go through the RFC process, this proposal is loosely structured after the RFC template.\r\n\r\n\r\n## Background\r\n\r\n### Heap memory in `libstd`\r\n\r\nMany parts of the standard library rely on a global heap memory allocator. For example `Box::new` takes a single parameter, the value to be boxed, and returns a struct that wraps a pointer to newly-allocated heap memory. The allocator is not part this API (on many platforms it defaults to `malloc`) and neither is the possibility that allocation fails: the return value always contains a valid pointer.\r\n\r\nAllocation can in fact fail (`malloc` can return a null pointer), but in practice this is uncommon enough and hard enough to recover from that `Box::new` and many other APIs make the choice of not propagating that error to callers. We call these APIs \u201cinfallible\u201d because allocation failure is not a concern of the caller (as opposed to \u201cfallible\u201d APIs like `Vec::try_reserve` which return a `Result`). \u201cInfallible\u201d APIs deal with failures by calling the `handle_alloc_error(Layout) -> !` function, which never returns. The current behavior in `libstd` is to print an error message and abort the process. Any low-level code that makes allocations and wants to expose an infallible API is expected to call this function. For example a custom container library could look like:\r\n\r\n```rust\r\nuse std::alloc::{Layout, alloc, handle_alloc_error};\r\nuse std::ptr::NonNull;\r\n\r\nimpl<T> MyBox<T> {\r\n    pub fn new(x: T) -> Self {\r\n        let layout = Layout::new::<T>();\r\n        assert!(layout.size() > 0); // Not dealing with the zero-size case for example brevity\r\n        let maybe_null = unsafe { alloc(layout) };\r\n        let ptr = NonNull::new(maybe_null)\r\n            .unwrap_or_else(|| handle_alloc_error(layout));\r\n        Self(ptr.cast())\r\n    }\r\n}\r\n```\r\n\r\n\r\n### `no_std` and `liballoc`\r\n\r\nThe Rust standard library is split into three crates (that are relevant to this issue): `core`, `alloc`, and `std`.\r\n\r\n* `std` expects much functionality to be provided by the underlying operating system or environment: a filesystem, threads, a network stack, \u2026 and relevant here: a memory allocator and a way to abort the current process. Large parts of its code are target-specific. Porting it to a new target can take non-trivial efforts.\r\n\r\n* `core` contains the subset of `std` that has almost no such requirement. A crate can use the `#![no_std]` attribute to opt into having its implicit dependency to `std` replaced by an implicit dependency to `core`. When all crates in an application do this, this enables porting to a target that might not have `std` at all. Notably, @rust-embedded does this with micro-controllers that do not have an operating system.\r\n\r\n* `alloc` is in-between. It depends on `core` and `std` depends on it. It contains the subset of `std` that relies on heap memory allocation, but makes no other external requirements over those of `core`. Specifically, using `alloc` requires:\r\n\r\n  * A heap memory allocator, that provides an implementation of the `alloc` function and related functions.\r\n  * An allocation error handler, that provides an implementation of the `handle_alloc_error` function.\r\n\r\n  The `std` crate provides both of these, so linking it in an application (having any crate in the dependency graph that doesn\u2019t have `#![no_std]`, or has `extern crate std;`) is sufficient to use `alloc`. Of course this doesn\u2019t work for targets/environments where `std` is not available.\r\n\r\n\r\n### `#[panic_handler]`\r\n\r\n`core` does have an external requirement: a way to handle panics. `std` normally provides this by printing a message to stderr, optionally with a stack trace, and unwinding the thread. In a `no_std` application however there may not be an stderr to print to, and unwinding may not be supported. Such apps can therefore provide a handler:\r\n\r\n```rust\r\n#[panic_handler]\r\nfn panic(panic_info: &core::panic::PanicInfo) -> ! {\r\n    // \u2026\r\n}\r\n```\r\n\r\n(See also [in the Nomicon](https://doc.rust-lang.org/nomicon/panic-handler.html).)\r\n\r\nThe attribute is effectively a procedural macro that checks the signature of the function and turns it into an `extern \"Rust\" fn` with a known symbol name, so that it can be called without going through Rust\u2019s usual crate/module/path name resolution.\r\n\r\nThe compiler also checks for \u201ctop-level\u201d compilations (executables, `cdylib`s, etc.) that there is exactly one panic handler in the whole crate dependency graph. `std` (effectively) provides one, so the attribute is both necessary for `no_std` applications and can only be used there.\r\n\r\n\r\n### `#[global_allocator]`\r\n\r\nDepending on the workload, an alternative allocator may be more performant than the platform\u2019s default. In earlier versions of Rust, the standard library used jemalloc. In order to leave that choice to users, Rust 1.28 stabilized [the `GlobalAlloc` trait](https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html) and [`#[global_allocator]` attribute](http://localhost/rust/std/alloc/index.html#the-global_allocator-attribute), and changed the standard library\u2019s default to the system\u2019s allocator.\r\n\r\nThis incidentally enabled (in Nightly) the use of `alloc` in `no_std` applications which can now provide an allocator implementation not just to be used instead of `std`\u2019s default, but where `std` is not necessarily available at all. However such applications still require Rust Nightly in order to fulfil `alloc`\u2019s second requirement: the allocation error handler.\r\n\r\n`#[global_allocator]` is similar to `#[panic_handler]`: it also expands to `extern \"Rust\" fn` function definitions that can be called by a crate (this time `alloc` instead of `core`) that doesn\u2019t have a Cargo-level dependency on the crate that contains the definition, and in that the compiler checks for \u201ctop-level\u201d compilation that it isn\u2019t used twice. (It differs in that it can be used when `std` is linked, and overrides `std`\u2019s default.)\r\n\r\n\r\n## Motivation\r\n\r\nAs of Rust 1.36, specifying an allocation error handler is the only requirement for using the `alloc` crate in `no_std` environments (i.e. without the `std` crate being also linked in the program) that cannot be fulfilled by users on the Stable release channel.\r\n\r\nStabilizing `#[alloc_error_handler]` as the way to fulfil this requirement would allow:\r\n\r\n* `no_std` + `liballoc` applications to start running on the Stable channel\r\n* `no_std` applications that run on Stable to start using `liballoc`\r\n\r\n\r\n## Guide-level explanation\r\n\r\nMany of the APIs in the `alloc` crate that allocate memory are said to be \u201cinfallible\u201d. Allocation appears to always succeed as far as their signatures are concerned. When allocation does fail, they call `alloc::alloc::handle_alloc_error` which never returns. For example, `Vec::reserve` is said to be infallible while `Vec::try_reserve` is fallible (and returns a `Result`). Other libraries who want to expose this infallible style of API may also call `handle_alloc_error`.\r\n\r\nWe call an application `no_std` if it doesn\u2019t link the `std` crate. That is, if all crates in its dependency graph have the `#![no_std]` attribute and (after `cfg`-expansion) do not contain `extern crate std;`.\r\n\r\nA `no_std` application may use the standard library\u2019s `alloc` crate if and only if it specifies both a global allocator with the `#[global_allocator]` attribute, and an allocation error handler with the `#[alloc_error_handler]` attribute. Each may only be defined once in the crate dependency graph. They can be defined anywhere, not necessarily in the top-level crate. The handler defines what to do when `handle_alloc_error` is called. It must be a function with the signature as follows:\r\n\r\n```rust\r\n#[alloc_error_handler]\r\nfn my_example_handler(layout: core::alloc::Layout) -> ! {\r\n    panic!(\"memory allocation of {} bytes failed\", layout.size())\r\n}\r\n```\r\n\r\nThe handler is given the `Layout` of the allocation that failed, for diagnostics purpose. As it is called in cases that are considered not recoverable, it may not return. `std` achieves this by aborting the process. In a `no_std` environment \u2212 which might not have processes in the first place \u2212 panicking calls the `#[panic_handler]` which is also required to not return.\r\n\r\n\r\n## Reference-level explanation\r\n\r\n`#[alloc_error_handler]` is very similar to `#[panic_handler]`: it locally checks that it used on a function with the appropriate signature and turns it into an `extern \"Rust\" fn` with a known symbol name, so that `alloc::alloc::handle_alloc_error` can call it.\r\n\r\nLike with the panic handler, the compiler also checks for \u201ctop-level\u201d compilations (executables, `cdylib`s, etc.) that there is exactly one allocation error handler in the whole crate dependency graph. `std` [literally](https://github.com/rust-lang/rust/blob/582a4eaee6b3674a34aeefaa5ecad0207bac9b4b/src/libstd/alloc.rs#L204-L218) provides one, so the attribute is both necessary for `no_std` applications and can only be used there.\r\n\r\nThe above is already implemented, although not well documented. This issue is about deciding to stabilize the attribute. If we find consensus on this direction, documentation should come before or with a stabilization PR. The `alloc` crate\u2019s doc-comment could be a good place for this documentation, which could be based on the guide-level explanation above.\r\n\r\n`#[panic_handler]` is already stable, so the Rust project is already committed to maintaining this style of attribute.\r\n\r\n\r\n## Alternatives\r\n\r\n* The status quo is that `no_std` + `alloc` requires Nightly\r\n\r\n* Despite already having one with `panic_handler`, such ad-hoc attributes could be considered inelegant or otherwise problematic compared to a more general mechanism. This is not my opinion: even if `alloc_error_handler` is not the last such attribute that the standard library will even need, I don\u2019t expect them to proliferate in large number.\r\n\r\n  * [RFC 2492 Existential types with external definition](https://github.com/rust-lang/rfcs/pull/2492) proposed a general mechanism but was [was postponed](https://github.com/rust-lang/rfcs/pull/2492#issuecomment-486996239).\r\n\r\n  * [A comment in the `alloc_error_handler` tracking issue](https://github.com/rust-lang/rust/issues/51540#issuecomment-556018701) proposed a less ambitious general mechanism limited to functions. I personally feel that even that proposal has enough design questions to resolve that it would warrant an RFC.\r\n\r\n* Instead of stabilizing a way to fulfil the requirement to define a handler, another way to unlock the `no_std` + `liballoc` on Stable use case could be [to remove that requirement: when no handler is defined, the compiler could inject a default handler that panics](https://github.com/rust-lang/rust/issues/66741) (similar to the example handler in the guide-level explanation above).", "closed_by": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/66740/reactions", "total_count": 8, "+1": 4, "-1": 0, "laugh": 0, "hooray": 2, "confused": 0, "heart": 2, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/66740/timeline", "performed_via_github_app": null, "state_reason": "completed"}