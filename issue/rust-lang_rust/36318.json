{"url": "https://api.github.com/repos/rust-lang/rust/issues/36318", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/36318/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/36318/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/36318/events", "html_url": "https://github.com/rust-lang/rust/issues/36318", "id": 175468574, "node_id": "MDU6SXNzdWUxNzU0Njg1NzQ=", "number": 36318, "title": "Overhaul std collections and algorithm documentation", "user": {"login": "gnzlbg", "id": 904614, "node_id": "MDQ6VXNlcjkwNDYxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/904614?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gnzlbg", "html_url": "https://github.com/gnzlbg", "followers_url": "https://api.github.com/users/gnzlbg/followers", "following_url": "https://api.github.com/users/gnzlbg/following{/other_user}", "gists_url": "https://api.github.com/users/gnzlbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/gnzlbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gnzlbg/subscriptions", "organizations_url": "https://api.github.com/users/gnzlbg/orgs", "repos_url": "https://api.github.com/users/gnzlbg/repos", "events_url": "https://api.github.com/users/gnzlbg/events{/privacy}", "received_events_url": "https://api.github.com/users/gnzlbg/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 431251592, "node_id": "MDU6TGFiZWw0MzEyNTE1OTI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-docs", "name": "A-docs", "color": "f7e101", "default": false, "description": "Area: documentation for any part of the project, including the compiler, standard library, and tools"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 28, "created_at": "2016-09-07T10:32:07Z", "updated_at": "2017-08-30T19:18:38Z", "closed_at": "2017-08-30T19:18:38Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "The documentation of the `std::collections`:\n-  lacks enough rigor to make good informed decisions about using the collections and their methods as well as most algorithms. \n- some of the information is there, but it is not easy to get to it from a particular method (e.g. if I want to find the complexity of some container insert method googling for \"Rust HashSet insert\" would lead me to the documentation of the insert function, but this information is in a performance table in the main page of the collection API.\n- the place for rigor is in the docs and not in the book. The docs are the reference.\n\nI really think that being more thorough with the documentation will help both find and fix bugs in the documentation and make the std library way better.\n\nThe solution I propose is to make all the relevant information accessible from all the methods. \n\nThe first thing to do would be to achieve consensus on which information should be available for each method. Taking inspiration from the C++ standard, and to kickstart the discussion, I would propose that each method / algorithm / function documentation comment should contain the following \"fields\" below the short and long descriptions. If a field doesn't make sense for some particular method, I would propose to still have it there but explicitly leave it blank.\n- **Algorithmic complexity**: with big O in terms of the relevant operations (which can be multiple: copies/moves in terms of the number of elements, number of swaps, number of comparisons, hashing...), with exact number of operations when guaranteed (performs _exactly_ N moves, performs _exactly_ M - N swaps, ...), and for those methods that have amortized/expected complexity it should contain both the complexity in the amortized case as well as the worst case (and maybe best case), and under which conditions they trigger. \n  - Example: `Vec::push(t)`: amortized O(1): _exactly_ 1 move/copy of `t` if `Vec::size() < Vec::capacity()`, otherwise worst case O(N): _exactly_ `N + 1` moves/copies where `N == Vec::size()`.\n  - Example: `Vec::reserve(M)`: O(1) time if `M <= Vec::capacity()`, O(N) otherwise: _exactly_ N moves/copies where `N == Vec::size()`. \n- **Memory complexity**: does it use O(1) stack space? Is it recursive and it uses O(logN) stack space? Does it allocate memory using an allocator? If so how much? \n  - Example: `Vec::push(t)`: amortized O(1) stack space, otherwise worst case O(1) stack space and a single memory allocation of O(k*N) where k is an implementation-defined growth factor independent of `N` and where `N == Vec::size()`. \n  - Example: `Vec::reserve(M)`: O(1) stack space if `M <= Vec::capacity()`, otherwise a _single_ allocation of `O(k*N)` where k is an implementation-defined growth factor independent of `N` and `N == Vec::size()`. \n- **Effects**: What are the effects of the operation?\n  - Example: `Vec::push(t)`: Before: `size() == N`, `capacity == M`, After: `size() == N + 1`, `capacity() == M` (amortized case) or `capacity() == k*M` (worst case, where `k` is an implementation defined growth factor), `pop() == Some(t)`.\n  - Example: `Vec::reserve(N)`: Before: `capacity() == M`, After: `capacity() == max(N, M)`.\n- **Panics**: When is an operation supposed to panic?\n  - Example: `Vec::push(t)` panics if OOM or if a copy of t is performed and copying panics.\n  - Example: `Vec::size()` never panics.\n\nI consider this the bare minimum level of \"formalization\" that at least the basic collections and algorithms in the standard library should have, but as you can see things become extremely verbose so one might want to explore how to factor out some parts of the documentation (e.g. that for `Vec` the growth-factor is a constant independent of the number of elements or the capacity of the vector) that are to be repeated in a lot of comments. \n\nSo that's for my strawman proposal. I guess the steps to follow (please correct me if I'm wrong):\n- [ ] Achieve consensus on how to document the methods of the std library algorithms and collections. Maybe through an RFC? Or isn't an RFC required here?\n- [ ] Explore if there is an easy way to reuse some documentation bits (e.g. OOM panics, never panics, explanation for amortized / expected complexity).\n- [ ] Go (again) through all methods and document them rigorously (i.e. actually implement this).\n- [ ] Orthogonal to this, since not all collections are mentioned in the main collections page (e.g. HashSet), probably we want to go over the main collection page and overhaul it as well.\n\nFor a feeling of the current state of things: \n- `HashMap::insert` doesn't mention that insertions are O(1) so if one lands there (e.g. via google) one is on its own. Relevant information should be visible right away.\n- `vec::insert`: in the amortized case requires O(1) stack memory and will perform exactly O(end - pos) moves but in the worst case it requires O(kN) memory and O(N) moves. None of this is \"obvious\" from the docs. We should make it obvious.\n- `std::slice::sort` complexity is O(NlogN) in the number of elements, but it mentions that it allocates approximately \"2*n\" elements. Does that mean at worst 2N? Can it be more? While this is better documented than other methods, it is still extremely vague. In particular, trivial stable sort implementations require 1/2N extra memory, a bad one at least N, and the good ones are in place (e.g. GrailSort requires O(1)). The rust standard library doesn't have an inplace unstable sorting algorithm (AFAIK), but the documentation of one implemented with something quicksort-based like intro-sort should say that it uses O(logN) stack space in some cases (I did not have any examples above with anything but O(1) stack space, but basically every recursive algorithm requires something different than O(1)).\n\ncc @GuillaumeGomez \n", "closed_by": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/36318/reactions", "total_count": 2, "+1": 2, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/36318/timeline", "performed_via_github_app": null, "state_reason": "completed"}