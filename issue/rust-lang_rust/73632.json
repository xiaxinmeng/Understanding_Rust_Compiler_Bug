{"url": "https://api.github.com/repos/rust-lang/rust/issues/73632", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/73632/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/73632/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/73632/events", "html_url": "https://github.com/rust-lang/rust/issues/73632", "id": 643352932, "node_id": "MDU6SXNzdWU2NDMzNTI5MzI=", "number": 73632, "title": "Formal support for linking rlibs using a non-Rust linker", "user": {"login": "adetaylor", "id": 145740, "node_id": "MDQ6VXNlcjE0NTc0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/145740?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adetaylor", "html_url": "https://github.com/adetaylor", "followers_url": "https://api.github.com/users/adetaylor/followers", "following_url": "https://api.github.com/users/adetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/adetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/adetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adetaylor/subscriptions", "organizations_url": "https://api.github.com/users/adetaylor/orgs", "repos_url": "https://api.github.com/users/adetaylor/repos", "events_url": "https://api.github.com/users/adetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/adetaylor/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37547, "node_id": "MDU6TGFiZWwzNzU0Nw==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-linkage", "name": "A-linkage", "color": "f7e101", "default": false, "description": "Area: linking into static, shared libraries and binaries"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 90, "created_at": "2020-06-22T20:51:06Z", "updated_at": "2023-05-25T20:22:45Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I'm working on a major existing C++ project which hopes to dip its toes into the Rusty waters. We:\r\n  \r\n- Use a non-Cargo build system with static dependency rules (and 40000+ targets)\r\n- Sometimes build a single big binary; sometimes lots of shared objects, unit test executables, etc. - each containing various parts of our dependency tree.\r\n- Perform final linking using an existing C++ toolchain (based on LLVM 11 as it happens)\r\n- Want to have a few Rust components scattered throughout a very deep dependency tree, which may eventually roll up into one or multiple binaries\r\n\r\nWe can't:\r\n- Switch from our existing linker to `rustc` for final linking. C++ is the boss in our codebase; we're not ready to make the commitment to put Rust in charge of our final linking.\r\n- Create a Rust `staticlib` for each of our Rust components. This works if we're using Rust in only one place. For any binary containing several Rust components, there would be binary bloat and potentially violations of the one-definition-rule, by duplication of the Rust stdlib and any diamond dependencies.\r\n- Create a single Rust `staticlib` containing all our Rust components, then link that into every binary. That monster static library would depend on many C++ symbols, which wouldn't be present in some circumstances.\r\n\r\nWe can either:\r\n1. Create a Rust `staticlib` for each of our _output_ binaries, using `rustc` and an auto-generated `.rs` file containing lots of `extern crate` statements. Or,\r\n2. Pass the `rlib` for each Rust component directly into the final C++ linking procedure.\r\n\r\nThe first approach is officially supported, but is hard because:\r\n- We need to create a Rust `staticlib` as part of our _C++_ tool invocations. This is awkward in our build system. Our C++ targets don't keep track of Rust compiler flags (`--target`, etc.) and in general it just feels weird to be doing Rust stuff in C++ targets.\r\n- Specifically, we need to invoke a Python wrapper script to consider invoking `rustc` to make a `staticlib` for every single one of our C++ link targets. For most of our targets (especially unit test targets) there will be no `rlibs` in their dependency tree, so it will be a no-op. But the presence of this wrapper script will make Rust adoption appear intrusive, and of course will have some small actual performance cost.\r\n- For those link targets which _do_ include Rust code, we'll delay invocation of the main linker whilst we build a Rust static library.\r\n\r\nThe second approach is not officially supported. An `rlib` is an internal implementation format within Rust, and its only client is `rustc`. It is naughty to pass them directly into our own linker command line.\r\n\r\nBut it does, currently, work. It makes our build process much simpler and makes use of Rust less disruptive.\r\n\r\nBecause external toolchains are not expected to consume `rlib`s, some magic is required:\r\n- The final C++ linker needs to pull in all the Rust stdlib `rlib`s, which would be easy apart from the fact they contain the symbol metadata hash in their names.\r\n- We need to remap `__rust_alloc` to `__rdl_alloc` etc.\r\n\r\nBut obviously the bigger concern is that this is not a supported model, and Rust is free to break the `rlib` format at any moment.\r\n\r\nIs there any appetite for making this a supported model for those with mixed C/C++/Rust codebases?\r\n\r\nI'm assuming the answer may be 'no' because it would tie Rust's hands for future `rlib` format changes. But just in case: how's about the following steps?\r\n\r\n1. [The Linkage section of the Rust reference](https://doc.rust-lang.org/reference/linkage.html) is enhanced to list the two _current_ strategies for linking C++ and Rust. Either:\r\n   - Use `rustc` as the final linker; or\r\n   - Build a Rust `staticlib` or `cdylib` then pass that to your existing final linker\r\n(I think this would be worth explicitly explaining anyway, so unless anyone objects, I may raise a PR)\r\n2. A new `rustc --print stdrlibs` (or similar) which will output the names of all the standard library rlibs (not just their directory, which is already possible with `target-libdir`)\r\n3. Some kind of new `rustc` option which generates a `rust-dynamic-symbols.o` file (or similar) containing the codegen which is otherwise done by `rustc` at final link-time (e.g. symbols to call `__rdl_alloc` from `__rust_alloc`, etc.)\r\n4. The Linkage section of the book is enhanced to list this as a third supported workflow. (You can use whatever linker you want, but make sure you link to `rust-dynamic-symbols.o` and everything output by `rustc --print stdrlibs`)\r\n5. Somehow, we add some tests to ensure this workflow doesn't break.\r\n\r\nA few related issues:\r\n* #64191 wants to split the compile and link phases of rustc. This discussion has spawned from there.\r\n* @dtolnay's marvellous https://github.com/dtolnay/cxx is not quite as optimal as it could be, because users can't use `-Wl,--start-group`, `-Wl,--end-group` on the linker line. (Per https://github.com/rust-lang/rust/issues/64191#issuecomment-629418541)\r\n* the difficulties of using the `staticlib`-per-C++-target model happen to be magnified by #73047\r\n\r\n@japaric @alexcrichton @retep998 @dtolnay I believe this may be the sort of thing you may wish to comment upon! I'm sure you'll come up with reasons why this is even harder than I already think. Thanks very much in advance.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/73632/reactions", "total_count": 12, "+1": 12, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/73632/timeline", "performed_via_github_app": null, "state_reason": null}