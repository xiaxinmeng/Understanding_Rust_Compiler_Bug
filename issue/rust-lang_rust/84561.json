{"url": "https://api.github.com/repos/rust-lang/rust/issues/84561", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/84561/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/84561/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/84561/events", "html_url": "https://github.com/rust-lang/rust/issues/84561", "id": 867103845, "node_id": "MDU6SXNzdWU4NjcxMDM4NDU=", "number": 84561, "title": "function-like macros, esp. with internal branching, produce unintuitive coverage results", "user": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2021-04-25T20:16:33Z", "updated_at": "2021-05-01T09:59:52Z", "closed_at": "2021-05-01T09:59:52Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "When compiling with `-Zinstrument-coverage`, Rust code that uses functions like `trace!(\"some trace message\");` or `assert_eq!(val1, val2;` results in unintuitive coverage results.\r\n\r\nMacros are not fully supported by the Rust `-Zinstrument-coverage` option because coverage regions are generated during a MIR pass only (`InstrumentCoverage`). The MIR includes the `BasicBlocks` (statements, terminators, and branching) from the expanded source *AFTER* processing the macros, and the coverage regions, shown in a function's coverage report, must relate to the source region of the visible source (including the macro invocations).\r\n\r\nAn invoked macro's source is not visible from the invoking function, so there is no practical way to map branching spans in a macro to the function's coverage regions.\r\n\r\nAs explained below, it is difficult to imagine a general solution to this problem, since macro syntax is so fluid.\r\n\r\n## Possible workaround\r\n\r\nPerhaps a workaround would be to consider a macro invocation as if it was a function call, and ignore all MIR statements with the same span as the first statement encountered within the expanded macro. \r\n\r\n## Examples\r\n\r\nFor instance, if `trace!(\"a message\")` equates to `if trace_is_enabled() { println!(\"a message\"); }` then it's possible that the condition (the call to, and result from, `trace_is_enabled()`) will be executed more often than the `println!(...)`. There should be two different coverage regions, but `trace!(\"a message\")` only represents one coverage region for both `BasicBlock`s.\r\n\r\nDue to the way MIR `InstrumentCoverage` works, the inner most condition will determine whether the macro invocation appears covered; that is, if `trace_is_enabled()`, the span for `trace!(\"a message\")` will appear covered, and if `trace` is not enabled, the span for `trace!(\"a message\")` will appear uncovered (zero executions).\r\n\r\n`trace!(\"a message\")` looks like a function call (similar to `some_function(\"a message\")`, but it is not a function call. With `some_function(...)`, there is no condition, and no branching, so if the function is reached, then entire span is covered. When `trace!(\"a message\")` is reached, clearly we cannot say the entire hidden span (the internal expansion of `trace!` macro is covered, so this may appear non-intuitive when compared to an actual function.\r\n\r\n`assert_eq(val1, val2)` is another example. If the optional failure message is included, `assert_eq(val1, val2, \"they are not equal\")` for example, the issue is similar to the problem with `trace!()`. It might be nice to associate the macro's internal condition (probably something like, `val1 == val2`) with the span `val1, val2` within the macro, but there is no general way to make that association, that I know of.\r\n\r\nBut the `assert_eq(val1, val2)` also exposes another non-intuitive coverage behavior. Take the example:\r\n\r\n```rust\r\n#[derive(Debug, PartialEq, Eq)]\r\nstruct Foo(u32);\r\n\r\nfn main() {\r\n    let bar = Foo(1);\r\n    assert_eq!(bar, Foo(1));\r\n    let baz = Foo(0);\r\n    assert_ne!(baz, Foo(1));\r\n    println!(\"{:?}\", Foo(1));\r\n    println!(\"{:?}\", bar);\r\n    println!(\"{:?}\", baz);\r\n\r\n    assert_eq!(Foo(1), Foo(1));\r\n    assert_ne!(Foo(0), Foo(1));\r\n    assert_eq!(Foo(2), Foo(2));\r\n    let bar = Foo(1);\r\n    assert_ne!(Foo(0), Foo(3));\r\n    assert_ne!(Foo(0), Foo(4));\r\n    assert_eq!(Foo(3), Foo(3));\r\n    assert_ne!(Foo(0), Foo(5));\r\n    println!(\"{:?}\", bar);\r\n    println!(\"{:?}\", Foo(1));\r\n}\r\n```\r\n\r\nThis partial coverage result (starting from the `main()`) shows something unexpected:\r\n\r\n```\r\n    4|      1|fn main() {\r\n    5|      1|    let bar = Foo(1);\r\n    6|      0|    assert_eq!(bar, Foo(1));\r\n    7|      1|    let baz = Foo(0);\r\n    8|      0|    assert_ne!(baz, Foo(1));\r\n    9|      1|    println!(\"{:?}\", Foo(1));\r\n   10|      1|    println!(\"{:?}\", bar);\r\n   11|      1|    println!(\"{:?}\", baz);\r\n   12|       |\r\n   13|      1|    assert_eq!(Foo(1), Foo(1));\r\n   14|      1|    assert_ne!(Foo(0), Foo(1));\r\n   15|      0|    assert_eq!(Foo(2), Foo(2));\r\n   16|      1|    let bar = Foo(1);\r\n   17|      1|    assert_ne!(Foo(0), Foo(3));\r\n   18|      1|    assert_ne!(Foo(0), Foo(4));\r\n   19|      1|    assert_eq!(Foo(3), Foo(3));\r\n   20|      0|    assert_ne!(Foo(0), Foo(5));\r\n   21|      1|    println!(\"{:?}\", bar);\r\n   22|      1|    println!(\"{:?}\", Foo(1));\r\n   23|      1|}\r\n```\r\n\r\nThe `assert_...` invocations on lines 6 and 8 show as uncovered, which is unintuitive, but for the same reason that `trace!()` appears uncovered if trace is not enabled: The condition (comparison) is checked, but it returns false (because the assertion does not fail), so the internal block (the `panic`) is not executed, and internal blocks win the coverage battle when the spans are the same (in this case, all statements related to comparing the values and optionally panicking have the same span, because there's no general way to map the condition check to one part of the macro, and the optional panic block to a different part of the macro invocation.\r\n\r\nBut also see lines 13 and 14.\r\n\r\nThese invocations of `assert_eq!()` and `assert_ne!()` ***appear covered***?\r\n\r\nThis is a slightly different problem, and maybe there is a general way to improve this, but I'm describing the problem here in this same issue because \"improving\" the result for lines 13 and 14 would at best be to make them consistent with lines 6 and 8, and the consistency is not particularly helpful. A workaround, therefore, may be a waste of time, depending on how we might someday improve macro handling in general.\r\n\r\nThe reason lines 13 and 14 appear covered is because those `assert_*` invocations occur immediately before one more `assert_eq!()` on line 15 (which appears uncovered).\r\n\r\ncompiler/rustc_mir/src/transform/coverage/spans.rs generates a reduced set of coverage regions (see `to_refined_spans()`, for example, by combining contiguous spans from the same `BasicCoverageBlock`. The algorithm works well for MIR statements based on actual source lines in the function.\r\n\r\nThe `assert_*` macro invocations on lines 13 and 14 have different spans from line 15, to put it simply, the existence of a different `assert_*` macro on a successive line (line 14, for line 13, and line 15 for line 14) allows a different coverage span to be generated that can be counted. (Debug logging for this module can help understand the exact logic.) As a result, if two or more `assert_*` macros are executed, contiguously, only the last one will appear uncovered (assuming all assertions were `true`).", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/84561/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/84561/timeline", "performed_via_github_app": null, "state_reason": "completed"}