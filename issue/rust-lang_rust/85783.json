{"url": "https://api.github.com/repos/rust-lang/rust/issues/85783", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/85783/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/85783/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/85783/events", "html_url": "https://github.com/rust-lang/rust/issues/85783", "id": 905318891, "node_id": "MDU6SXNzdWU5MDUzMTg4OTE=", "number": 85783, "title": "Consider enabling unstable fingerprint check for cache-loaded query results too", "user": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 307747675, "node_id": "MDU6TGFiZWwzMDc3NDc2NzU=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-incr-comp", "name": "A-incr-comp", "color": "f7e101", "default": false, "description": "Area: Incremental compilation"}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}, {"id": 2420759390, "node_id": "MDU6TGFiZWwyNDIwNzU5Mzkw", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-query-system", "name": "A-query-system", "color": "f7e101", "default": false, "description": "Area: The rustc query system (https://rustc-dev-guide.rust-lang.org/query.html)"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2021-05-28T12:31:20Z", "updated_at": "2021-06-05T22:42:08Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "Correctness of incremental compilation relies on the assumption that a query always yields the same result for the same set of inputs, i.e. that queries are deterministic functions. We recently discovered that checking fingerprint stability of query results can detect violations of this assumption and that breaking this assumption can lead to miscompilations (see https://github.com/rust-lang/rust/issues/84970).\r\n\r\n**This issue argues that a similar set of circumstances can arise in the code path where we have not yet enabled the fingerprint stability check by default.** \r\n\r\nFirst some background on how miscompilations can happen: When the query system is asked to execute a query `Q` in incremental mode it will first walk the dependency graph of the query, trying to mark `Q`'s dep-node as green. If all of `Q`'s inputs are green, `Q` itself is green too and the system assumes that its result is the same as in the previous compilation session. While walking the graph for marking, all the nodes encountered are also marked as green -- however, their corresponding queries are not necessarily executed. Only later if another query actually needs the result of one such intermediate query `Q_i`, it will be executed. If at that point the already green query yields a different result than what we previously relied on, we end up with an inconsistent (and therefore dangerous) state: Some dependents of `Q_i` have loaded their result from the cache under the assumption that `Q_i`'s result was the same as in the previous session; but other dependents of `Q_i` have computed their own result with a different value for `Q_i` as input:\r\n\r\n```\r\n                 +-------- Q1 (assumes Q_i == x)\r\n                 |\r\n                 v \r\n(...) <-------- Q_i \r\n                 ^\r\n                 |\r\n                 +-------- Q2 (computes its result with Q_i == x' as input)\r\n```\r\nAssuming for example that `Q1` is a vtable layout with methods in the order `m1, m2, m3` and `Q2` is an indirect method call to `m2` -- assuming that `m2` is at index `0` because `Q_i` yielded the vtable order `m2, m3, m1` when re-executed -- then we can see how this can lead to a miscompilation where the method call that `Q2` represents calls the wrong method.\r\n\r\nNow, https://github.com/rust-lang/rust/pull/83007 turned on fingerprint stability checks for all cases where a query is re-executed by the query system. This will catch violations of the query determinism assumption because we compare the fingerprint on disk (corresponding to `Q_i == x`) to the fingerprint of the newly computed value (corresponding to `Q_i == x'`). If the fingerprints differ we know there is a dangerous mismatch and abort the compilation session.\r\n\r\nNote, however, that the same kind of mismatch can occur when the value for `Q_i` is loaded from disk: if `Q_i` is marked as green and `Q1` thus loads its result from disk under the assumption that `Q_i == x` but then we later load the result of `Q_i` from disk and -- because of a bug in query result serialization -- we get `Q_i == x'`, then we can end up with the same kind of dangerous inconsistency as in the other case. The diagram above would apply to this case too, no modification needed.\r\n\r\nIn summary: both unstable query provider implementations and buggy query result (de-)serialization can lead to the same kind of dangerous inconsistencies during incremental compilation, but we currently only have a safety check for the first of the two cases.\r\n\r\nI personally believe that the risk of buggy serialization code is smaller than the risk of unstable query provider implementations but I still think it is prudent to check both cases.\r\n\r\n@Aaron1011, do you agree with my analysis of the situation?\r\n\r\ncc @rust-lang/compiler", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/85783/reactions", "total_count": 2, "+1": 2, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/85783/timeline", "performed_via_github_app": null, "state_reason": null}