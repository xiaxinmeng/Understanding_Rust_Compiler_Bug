{"url": "https://api.github.com/repos/rust-lang/rust/issues/71299", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/71299/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/71299/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/71299/events", "html_url": "https://github.com/rust-lang/rust/issues/71299", "id": 602529562, "node_id": "MDU6SXNzdWU2MDI1Mjk1NjI=", "number": 71299, "title": "Tracking Issue for 'Janitorial RAII'", "user": {"login": "DeanRoddey", "id": 45377887, "node_id": "MDQ6VXNlcjQ1Mzc3ODg3", "avatar_url": "https://avatars.githubusercontent.com/u/45377887?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DeanRoddey", "html_url": "https://github.com/DeanRoddey", "followers_url": "https://api.github.com/users/DeanRoddey/followers", "following_url": "https://api.github.com/users/DeanRoddey/following{/other_user}", "gists_url": "https://api.github.com/users/DeanRoddey/gists{/gist_id}", "starred_url": "https://api.github.com/users/DeanRoddey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DeanRoddey/subscriptions", "organizations_url": "https://api.github.com/users/DeanRoddey/orgs", "repos_url": "https://api.github.com/users/DeanRoddey/repos", "events_url": "https://api.github.com/users/DeanRoddey/events{/privacy}", "received_events_url": "https://api.github.com/users/DeanRoddey/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 650846969, "node_id": "MDU6TGFiZWw2NTA4NDY5Njk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-tracking-issue", "name": "C-tracking-issue", "color": "f5f1fd", "default": false, "description": "Category: A tracking issue for an RFC or an unstable feature."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2020-04-18T19:04:34Z", "updated_at": "2020-04-18T19:05:46Z", "closed_at": "2020-04-18T19:05:46Z", "author_association": "NONE", "active_lock_reason": null, "body": "I'm not sure if this is the appropriate place for this but it's the closest I could find. Send me elsewhere if not...\r\n\r\nI would like to make the case that Rust is missing a fundamental capability that C++ has which is a very powerful and simple means to avoid logic errors. That is the concept of 'janitorial RAII'. Unlike 'normal' RAII, which Rust has obviously, where an object cleans itself up on Drop, janitors are designed to apply some change to a member of 'self' on a scoped basis, possibly in a nested fashion.  \r\n\r\nSo something like:\r\n\r\n    struct Foo\r\n    {\r\n         exploder_mode : bool;\r\n    }\r\n    \r\n    impl Foo\r\n    {\r\n         pub fn SomeCall()\r\n         {\r\n               // some stuff\r\n              {\r\n                   // Enter exploder mode for this scope\r\n                   let exploder_jan : BoolJan = BoolJan::new(&mut exploder_mode, true);\r\n    \r\n                  // Exploder mode gets put back to original value here\r\n               }\r\n         }\r\n    }\r\n\r\nThis is seemingly fundamentally impossible in Rust as it stands, because such an object requires mutable access and keeps it until it itself is dropped. That leaves the called structure inaccessible and hence useless.\r\n\r\nI think that this could be dealt with without any undue craziness, and it would be such a benefit. Such a type can only do three things. It can have associated functions to create it, it can implement Drop, and it can 'orphan' whatever it's been given (so it does nothing on Drop.)\r\n\r\nAll that is needed is an indication to the compiler than this object takes a mutable reference but cannot use until it is destroyed. Orphaning doesn't require access to the object being 'sanitized'. The only use of the mutable reference will be in the Drop. \r\n\r\nSo that would provide a straightforward way to allow this, but to still insure at compile time that the object legally has mutable access, since the compiler knows exactly when it will be dropped. So it would be no different than anything else attempting to get a mutable ref at that point.\r\n\r\nThere are endless applications for this concept. In my very large C++ code base I use them all over the place to excellent effect. Given that Rust has decided (unwisely IMO) to not support exceptions, anything that requires undoing local changes is a huge burden because it means no more use of ? style convenient error returns, since there's no way to undo these types of scoped changes if that is used. And the manual error propagation of Rust is brutally tedious.\r\n\r\nGiven that Rust is all about making it hard to do the wrong thing, this simple concept avoids a whole raft of possible logic errors where changes made and intended to be undone are not.  \r\n\r\nNo other scheme I can think of would be anywhere near as straightforward to use. You could jump through a bunch of hoops to do it in some way using what's there now, but it would be hacky at best. Keep in mind that it must support nested applications as well, so some of those hacky methods won't evne work in that case. A nested scope may create a janitor object for the same method, or a call from method A (which creates one)  to method B may create one and A has no way to know that.\r\n\r\nThis simple scheme makes all those problems go away.\r\n\r\nAnother simple variation of this that would work via the same principle is the opposite of this, which is the 'Committer' type object, which will store up changes and commit them on Drop, unless it is orphaned before then. The two could easily be represented via a pair of trivial traits. \r\n\r\nI guess the primary issue is whether there's a means to limit a type implementing these traits to just that very fundamental functionality. Even if it required a new 'lang-item' I think it would be worth it and not one of the particularly complex ones.\r\n", "closed_by": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/71299/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/71299/timeline", "performed_via_github_app": null, "state_reason": "completed"}