{"url": "https://api.github.com/repos/rust-lang/rust/issues/75504", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/75504/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/75504/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/75504/events", "html_url": "https://github.com/rust-lang/rust/issues/75504", "id": 678764390, "node_id": "MDU6SXNzdWU2Nzg3NjQzOTA=", "number": 75504, "title": "AVR: interrupt code broken by unused alloca", "user": {"login": "couchand", "id": 793969, "node_id": "MDQ6VXNlcjc5Mzk2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/793969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/couchand", "html_url": "https://github.com/couchand", "followers_url": "https://api.github.com/users/couchand/followers", "following_url": "https://api.github.com/users/couchand/following{/other_user}", "gists_url": "https://api.github.com/users/couchand/gists{/gist_id}", "starred_url": "https://api.github.com/users/couchand/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/couchand/subscriptions", "organizations_url": "https://api.github.com/users/couchand/orgs", "repos_url": "https://api.github.com/users/couchand/repos", "events_url": "https://api.github.com/users/couchand/events{/privacy}", "received_events_url": "https://api.github.com/users/couchand/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}, {"id": 1472563007, "node_id": "MDU6TGFiZWwxNDcyNTYzMDA3", "url": "https://api.github.com/repos/rust-lang/rust/labels/requires-nightly", "name": "requires-nightly", "color": "76dcde", "default": false, "description": "This issue requires a nightly compiler in some way."}, {"id": 1884641928, "node_id": "MDU6TGFiZWwxODg0NjQxOTI4", "url": "https://api.github.com/repos/rust-lang/rust/labels/O-AVR", "name": "O-AVR", "color": "6e6ec0", "default": false, "description": "Target: AVR processors (ATtiny, ATmega, etc.)"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2020-08-13T22:12:54Z", "updated_at": "2020-10-04T08:56:04Z", "closed_at": "2020-10-02T21:44:44Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I've run into an issue with code that uses interrupts on AVR.  I'm not sure if this applies to any other platform.\r\n\r\nI've attempted to minimize the example, but there's still a fair amount here, largely because I'm having trouble coming up with good, simple ways to observe the chip's behavior.  It's written for the ATmega2560 (and specifically the Arduino Mega2560 board), but should be easily adapted to other AVR MCUs.\r\n\r\nThis code works fine, flashing the built-in LED on my Arduino Mega2560:\r\n\r\n```rust\r\n#![no_std]\r\n#![no_main]\r\n#![feature(abi_avr_interrupt, llvm_asm)]\r\n\r\nextern crate panic_halt;\r\nuse core::cell::UnsafeCell;\r\nuse avr_device::atmega2560;\r\n\r\nstatic FAIL: RacyUnsafeCell<Result<(), ()>> = RacyUnsafeCell::new(Err(()));\r\n\r\n#[repr(transparent)]\r\npub struct RacyUnsafeCell<T>(UnsafeCell<T>);\r\n\r\nunsafe impl<T: Sync> Sync for RacyUnsafeCell<T> {}\r\n\r\nimpl<T> RacyUnsafeCell<T> {\r\n    pub const fn new(x: T) -> Self {\r\n        RacyUnsafeCell(UnsafeCell::new(x))\r\n    }\r\n\r\n    pub fn get(&self) -> *mut T {\r\n        self.0.get()\r\n    }\r\n}\r\n\r\n#[no_mangle]\r\npub unsafe extern \"avr-interrupt\" fn __vector_9() {\r\n    match *FAIL.get() {\r\n        Ok(t) => t,\r\n        Err(_) => unwrap_failed(&()),\r\n    }\r\n}\r\n\r\nfn unwrap_failed(error: &dyn core::fmt::Debug) -> ! {\r\n    panic!(\"{:?}\", error)\r\n}\r\n\r\n#[export_name = \"main\"]\r\npub extern \"C\" fn main() -> ! {\r\n    unsafe {\r\n        *FAIL.get() = Ok(());\r\n    }\r\n\r\n    let dp = atmega2560::Peripherals::take().unwrap();\r\n\r\n    // output for LED & PCINT0\r\n    dp.PORTB.ddrb.write(|w| unsafe { w.bits(0b1000_0001) });\r\n    dp.PORTB.portb.write(|w| unsafe { w.bits(0b1000_0001) });\r\n\r\n    // enable PCINT0\r\n    dp.EXINT.pcicr.write(|w| w.pcie().bits(1));\r\n    dp.EXINT.pcmsk0.write(|w| w.pcint().bits(1));\r\n\r\n    unsafe {\r\n        llvm_asm!(\"sei\" :::: \"volatile\");\r\n    }\r\n\r\n    loop {\r\n        for _ in 0..50 {\r\n            let mut u = 0xffff;\r\n            unsafe {\r\n                llvm_asm!(\r\n                    \"1: sbiw $0,1\\n\\tbrne 1b\"\r\n                    : \"=w\"(u)\r\n                    : \"0\"(u)\r\n                    :\r\n                    : \"volatile\"\r\n                );\r\n            }\r\n        }\r\n\r\n        dp.PORTB.portb.write(|w| unsafe { w.bits(0) });\r\n\r\n        for _ in 0..50 {\r\n            let mut u = 0xffff;\r\n            unsafe {\r\n                llvm_asm!(\r\n                    \"1: sbiw $0,1\\n\\tbrne 1b\"\r\n                    : \"=w\"(u)\r\n                    : \"0\"(u)\r\n                    :\r\n                    : \"volatile\"\r\n                );\r\n            }\r\n        }\r\n\r\n        dp.PORTB.portb.write(|w| unsafe { w.bits(0b1000_0001) });\r\n    }\r\n}\r\n```\r\n\r\nMaking a single change to unwrap the actual error causes it to fail.  It now turns the LED on once and then makes no further discernible progress.  Notably, that means it's not even reaching the first update to the PCINT0 pin, which is mystifying.\r\n\r\n```\r\n$ diff examples/min-repro-working.rs examples/min-repro-broken.rs \r\n30c30\r\n<         Err(_) => unwrap_failed(&()),\r\n---\r\n>         Err(e) => unwrap_failed(&e),\r\n```\r\n\r\nThe function `unwrap_failed` *shouldn't* ever be called, as the interrupts are not enabled until after `Ok(())` is written to the static.  (`RacyUnsafeCell` is used here just to prove that there's no shenanigans).\r\n\r\nI don't have any fancy in-circuit debugging tools, so it's hard for me to know what's happening on the metal, but I do have `diff`, which I've ran against the LLVM IR from these two programs.  As far as I can tell, the only meaningful difference is that the broken program issues an alloca at the start of the ISR:\r\n\r\n```llvm\r\n; Function Attrs: nofree norecurse nounwind optsize\r\ndefine avr_signalcc  void @__vector_9() unnamed_addr addrspace(1) #0 {\r\nstart:\r\n  %e = alloca {}, align 1\r\n  %.b = load i1, i1* @_ZN16min_repro_broken4FAIL17h1f0c05d9b688f3e0E.0.0, align 1\r\n  br i1 %.b, label %bb4, label %bb2\r\n\r\nbb2:                                              ; preds = %start\r\n; call min_repro_broken::unwrap_failed\r\n  call fastcc addrspace(1) void @_ZN16min_repro_broken13unwrap_failed17h382387c4357ef48cE({}* nonnull align 1 %e)\r\n  unreachable\r\n\r\nbb4:                                              ; preds = %start\r\n  ret void\r\n}\r\n```\r\n\r\nversus\r\n\r\n```llvm\r\n; Function Attrs: nofree norecurse nounwind optsize\r\ndefine avr_signalcc  void @__vector_9() unnamed_addr addrspace(1) #0 {\r\nstart:\r\n  %.b = load i1, i1* @_ZN17min_repro_working4FAIL17h3f0200d99301bf56E.0.0, align 1\r\n  br i1 %.b, label %bb4, label %bb2\r\n\r\nbb2:                                              ; preds = %start\r\n; call min_repro_working::unwrap_failed\r\n  tail call fastcc addrspace(1) void @_ZN17min_repro_working13unwrap_failed17h0e47ae32571d11baE()\r\n  unreachable\r\n\r\nbb4:                                              ; preds = %start\r\n  ret void\r\n}\r\n```\r\n\r\nI've pretty much run out of places I know to look for what could be causing this issue, or ways to productively continue investigating.  Any pointers would be greatly appreciated!\r\n\r\nMy nightly was previously a few weeks old, I've updated to latest and the issue persists.\r\n", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/75504/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/75504/timeline", "performed_via_github_app": null, "state_reason": "completed"}