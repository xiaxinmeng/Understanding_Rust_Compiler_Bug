{"url": "https://api.github.com/repos/rust-lang/rust/issues/55059", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/55059/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/55059/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/55059/events", "html_url": "https://github.com/rust-lang/rust/issues/55059", "id": 369878915, "node_id": "MDU6SXNzdWUzNjk4Nzg5MTU=", "number": 55059, "title": "Miscompilation of SIMD when crossing target_feature boundaries", "user": {"login": "raphlinus", "id": 242367, "node_id": "MDQ6VXNlcjI0MjM2Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/242367?v=4", "gravatar_id": "", "url": "https://api.github.com/users/raphlinus", "html_url": "https://github.com/raphlinus", "followers_url": "https://api.github.com/users/raphlinus/followers", "following_url": "https://api.github.com/users/raphlinus/following{/other_user}", "gists_url": "https://api.github.com/users/raphlinus/gists{/gist_id}", "starred_url": "https://api.github.com/users/raphlinus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/raphlinus/subscriptions", "organizations_url": "https://api.github.com/users/raphlinus/orgs", "repos_url": "https://api.github.com/users/raphlinus/repos", "events_url": "https://api.github.com/users/raphlinus/events{/privacy}", "received_events_url": "https://api.github.com/users/raphlinus/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2018-10-14T08:07:46Z", "updated_at": "2018-10-21T01:06:46Z", "closed_at": "2018-10-21T01:06:46Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "This is a reduced example of a problem I've run into trying to make safe SIMD wrappers. The idea here is to have a newtype that can only be constructed when the capability is dynamically detected. However, the compiler seems to get confused about calling conventions when calling into code with `target_feature` enabled from code that doesn't.\r\n\r\n```rust\r\n#[cfg(target_arch = \"x86_64\")]\r\nuse std::arch::x86_64::*;\r\n\r\n#[target_feature(enable = \"avx\")]\r\nunsafe fn avx_mul(a: __m256, b: __m256) -> __m256 {\r\n    _mm256_mul_ps(a, b)\r\n}\r\n\r\n#[target_feature(enable = \"avx\")]\r\nunsafe fn avx_store(p: *mut f32, a: __m256) {\r\n    _mm256_storeu_ps(p, a)\r\n}\r\n\r\n#[target_feature(enable = \"avx\")]\r\nunsafe fn avx_setr(a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, g: f32, h: f32) -> __m256 {\r\n    _mm256_setr_ps(a, b, c, d, e, f, g, h)\r\n}\r\n\r\n#[target_feature(enable = \"avx\")]\r\nunsafe fn avx_set1(a: f32) -> __m256 {\r\n    _mm256_set1_ps(a)\r\n}\r\n\r\nstruct Avx(__m256);\r\n\r\nfn mul(a: Avx, b: Avx) -> Avx {\r\n    unsafe { Avx(avx_mul(a.0, b.0)) }\r\n}\r\n\r\nfn set1(a: f32) -> Avx {\r\n    unsafe { Avx(avx_set1(a)) }\r\n}\r\n\r\nfn setr(a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, g: f32, h: f32) -> Avx {\r\n    unsafe { Avx(avx_setr(a, b, c, d, e, f, g, h)) }\r\n}\r\n\r\nunsafe fn store(p: *mut f32, a: Avx) {\r\n    avx_store(p, a.0);\r\n}\r\n\r\npub fn main() {\r\n    let mut result = [0.0f32; 8];\r\n    let a = mul(setr(0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0), set1(0.25));\r\n    unsafe { store(result.as_mut_ptr(), a)}\r\n    println!(\"{:?}\", result);\r\n}\r\n\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=stable&mode=release&edition=2015&gist=385b6ea5622ac948e6e46842a64a7579))\r\n\r\nOutput:\r\n\r\n```\r\n[0.0, 5.0, 12.0, 21.0, 0.0, 0.0, 0.0, 0.0]\r\n\r\n```\r\n\r\nErrors:\r\n\r\n```\r\n   Compiling playground v0.0.1 (file:///playground)\r\n    Finished release [optimized] target(s) in 0.59s\r\n     Running `target/release/playground`\r\n\r\n```\r\n\r\nIn a debug build, the answer is `[0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75]` as expected. Notice that the first 3 values of the miscompiled version are [0, 1, 2, 3] * [4, 5, 6, 7], suggesting that the halves are getting scrambled (and this is confirmed by looking at the generated asm).\r\n\r\nAlso, this just crashes on Windows.\r\n\r\nSame miscompilation happens if I move the Avx() newtype wrapper up into the top four functions.\r\n\r\nIt's possible I don't understand the rules for what's safe to do in SIMD. If that's the case, the limitations on passing values across function boundaries should be documented.", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/55059/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/55059/timeline", "performed_via_github_app": null, "state_reason": "completed"}