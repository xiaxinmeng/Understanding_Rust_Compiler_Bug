{"url": "https://api.github.com/repos/rust-lang/rust/issues/44459", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/44459/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/44459/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/44459/events", "html_url": "https://github.com/rust-lang/rust/issues/44459", "id": 256457760, "node_id": "MDU6SXNzdWUyNTY0NTc3NjA=", "number": 44459, "title": "Extern \"C\" is ill formatted when #[repr(C)] struct is a parameter", "user": {"login": "danielpclark", "id": 319081, "node_id": "MDQ6VXNlcjMxOTA4MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/319081?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielpclark", "html_url": "https://github.com/danielpclark", "followers_url": "https://api.github.com/users/danielpclark/followers", "following_url": "https://api.github.com/users/danielpclark/following{/other_user}", "gists_url": "https://api.github.com/users/danielpclark/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielpclark/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielpclark/subscriptions", "organizations_url": "https://api.github.com/users/danielpclark/orgs", "repos_url": "https://api.github.com/users/danielpclark/repos", "events_url": "https://api.github.com/users/danielpclark/events{/privacy}", "received_events_url": "https://api.github.com/users/danielpclark/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-09-09T18:40:54Z", "updated_at": "2017-09-10T07:07:43Z", "closed_at": "2017-09-10T07:07:43Z", "author_association": "NONE", "active_lock_reason": null, "body": "I've thoroughly tested and researched this but when my custom struct with `#[repr(C)]` is required as a parameter the `#[no_mangle]` compiled function is not valid for linking as dynamic/static library.  It's perfectly fine to have the struct as an output type, just not as input.\r\n\r\nHere's the struct object I've been using in my project for a year now (without implementing memory freeing) and it's worked well with Ruby and Ruby's FFI.\r\n\r\n```rust\r\nuse libc;\r\nuse std::mem;\r\n\r\n#[repr(C)]\r\npub struct RubyArray {\r\n  len: libc::size_t,\r\n  data: *const libc::c_void,\r\n}\r\n\r\nimpl RubyArray {\r\n  #[allow(dead_code)]\r\n  pub fn from_vec<T>(vec: Vec<T>) -> RubyArray {\r\n    let array = RubyArray {\r\n      data: vec.as_ptr() as *const libc::c_void,\r\n        len: vec.len() as libc::size_t\r\n    };  \r\n    mem::forget(vec);\r\n    array\r\n  }\r\n}\r\n```\r\nBut as I've been learning much I have been and am endeavoring to properly free the resources memory whether it's in Ruby, or in Rust.  I've been successful in implementing this with strings with this code:\r\n\r\n```rust\r\nuse libc::c_char;\r\nuse std::ffi::CString;\r\n\r\n#[no_mangle]\r\npub extern \"C\" fn free_string(s: *mut c_char) {\r\n  unsafe {\r\n    if s.is_null() { return }\r\n    CString::from_raw(s)\r\n  };\r\n} \r\n```\r\n\r\nI have Ruby call this method from FFI's AutoPointer and it works well.\r\n\r\n### The Problem Area\r\n\r\nBut when I implement the same kind of freeing method for my RubyArray struct with either:\r\n\r\n```rust\r\nuse ruby_array::RubyArray;\r\n\r\n#[no_mangle]\r\npub extern \"C\" fn free_array(ptr: *mut RubyArray) {\r\n  if ptr.is_null() { return }\r\n  unsafe { Box::from_raw(ptr); }\r\n}\r\n```\r\n\r\n### - OR -\r\n\r\n```rust\r\nuse ruby_array::RubyArray;\r\nuse std::mem::transmute;\r\n\r\n#[no_mangle]\r\npub extern \"C\" fn free_array(ra: *mut RubyArray) {\r\n  let _ra: Box<RubyArray> = unsafe{ transmute(ra) };\r\n}\r\n```\r\n\r\nI was unable to get FFI to access the method as it raised the error:\r\n\r\n```\r\nFunction 'free_array' not found in [/libfaster_path.so] (FFI::NotFoundError)\r\n```\r\n\r\nI have more than a dozen methods written in Rust that are called from Ruby and they all work.  This was implemented in the same way yet I was unable to link the method.\r\n\r\nAt first I thought it was a possible naming conflict so I tried many other names.  Same error.  I've searched and studied for many hours on this from\r\n\r\n* reading source code/wikis for FFI (Ruby & C)\r\n* existing Rust projects usages of extern\r\n* reading source and tests for integrating Ruby & Rust (ruru, ruby-sys, Helix)\r\n* blog posts (not just Ruby, but other languages as well)\r\n* the online books\r\n* the pre-ordered O`Reilly Rust book (pointers/FFI)\r\n* \u2026you get the idea\r\n\r\n*During this I've tried working around needing that specific method implementation.*\r\n\r\nI though perhaps Rust just overlooked putting it into the binary?  So I grepped through the binary and I was wrong about that\u2026 Rust did indeed have just as many references to my `free_array` method as my `free_string` method.\r\n\r\nThen I thought this might be an issue with FFI.  So I re-implemented the code for freeing memory with Ruby's Fiddle library and it likewise only worked with the methods that FFI worked with and still claimed that the `free_array` method was unable to be found in the binary/library.\r\n\r\nSo with two Ruby sources proving parity of behavior between each other and them both complaining that the method can't be found, and with the binary containing the method name, I've come to the likely conclusion that what Rust produced in the binary is ill-formatted for a C type method call.\r\n\r\n---\r\n\r\nTo help others learn how to do this and reproduce the same issue I'll put example code slices here along with some alternate implementation examples.\r\n\r\n**A**) The working code before attempting to implement memory freeing has this template:\r\n\r\n```ruby\r\n# RUBY CODE\r\nrequire \"ffi\"\r\nmodule FasterPath\r\n  FFI_LIBRARY = begin\r\n    prefix = Gem.win_platform? ? \"\" : \"lib\"\r\n    \"#{File.expand_path(\"../target/release/\", __dir__)}/#{prefix}faster_path.#{FFI::Platform::LIBSUFFIX}\"\r\n  end\r\n\r\n  def self.entries(pth)\r\n    Array(Rust.entries(pth))\r\n  end\r\n\r\n  module Rust\r\n    extend FFI::Library\r\n    ffi_lib ::FasterPath::FFI_LIBRARY\r\n\r\n    class FromRustArray < FFI::Struct\r\n      layout :len,    :size_t, # dynamic array layout\r\n             :data,   :pointer #\r\n\r\n      def to_a\r\n        self[:data].get_array_of_string(0, self[:len]).compact\r\n      end\r\n    end\r\n\r\n  attach_function :entries, [ :string ], FromRustArray.by_value\r\nend\r\n```\r\n\r\n```rust\r\n// RUST CODE\r\nuse libc::c_char;\r\nuse std::ffi::{CStr,CString};\r\nuse std::{str,fs};\r\nuse ruby_array::RubyArray;\r\n\r\n#[no_mangle]\r\npub extern \"C\" fn entries(string: *const c_char) -> RubyArray {\r\n  let c_str = unsafe {\r\n    assert!(!string.is_null());\r\n\r\n    CStr::from_ptr(string)\r\n  };  \r\n\r\n  let r_str = str::from_utf8(c_str.to_bytes()).unwrap();\r\n\r\n  let files = fs::read_dir(r_str).unwrap();\r\n  let mut files_vec = vec![];\r\n\r\n  files_vec.push(CString::new(\".\").unwrap().into_raw());\r\n  files_vec.push(CString::new(\"..\").unwrap().into_raw());\r\n\r\n  for file in files {\r\n    let file_name_str = file.unwrap().file_name().into_string().unwrap();\r\n    let file_name_cstr = CString::new(file_name_str).unwrap().into_raw();\r\n    files_vec.push(file_name_cstr);\r\n  }\r\n\r\n  RubyArray::from_vec(files_vec)\r\n}\r\n```\r\n\r\n**B**) The code above can also be done with `*mut RubyArray` in Rust but you'd need to set the method as `unsafe`.  The two lines that would change are:\r\n\r\n```rust\r\npub unsafe extern \"C\" fn entries(string: *const c_char) -> *mut RubyArray {\r\n // ...\r\n Box::into_raw(Box::new(RubyArray::from_vec(files_vec))) as *mut RubyArray\r\n}\r\n```\r\nRuby's FFI treats these as the same thing.\r\n\r\n## Desired Ruby Implementation to Call Free\r\n\r\nTo have FFI automatically free the struct after it's done with it we need to change it from a `FFI::Struct` to a `FFI::ManagedStruct` and put the method call to free the memory in the release method.  It should look like this:\r\n\r\n```ruby\r\n# FFI\r\nmodule FasterPath\r\n\r\n  #  ... code snipped ...\r\n\r\n  module Rust\r\n    class FromRustArray < FFI::ManagedStruct\r\n      layout :len,    :size_t, # dynamic array layout\r\n             :data,   :pointer #\r\n\r\n      def to_a\r\n        self[:data].get_array_of_string(0, self[:len]).compact\r\n      end\r\n\r\n      def self.release(ptr)\r\n        Rust.free_array(ptr)\r\n      end\r\n    end\r\n\r\n    attach_function :entries, [ :string ], FromRustArray.by_value\r\n    attach_function :free_array, [ :pointer ], :void\r\n  end\r\n```\r\n\r\nThis is where FFI raised the error `Function 'free_array' not found in [/libfaster_path.so] (FFI::NotFoundError)` .  If you'd like to try Fiddle as well to free the memory you can change the above to:\r\n\r\n```ruby\r\n# FFI with FIDDLE\r\nmodule FasterPath\r\n\r\n  #  ... code snipped ...\r\n\r\n  module Rust\r\n    class FromRustArray < FFI::ManagedStruct\r\n      layout :len,    :size_t, # dynamic array layout\r\n             :data,   :pointer #\r\n\r\n      def to_a\r\n        self[:data].get_array_of_string(0, self[:len]).compact\r\n      end\r\n\r\n      def self.release(ptr)\r\n        Fiddle.free_array(ptr)\r\n      end\r\n\r\n      module Fiddle\r\n        require 'fiddle'\r\n        require 'fiddle/import'\r\n        extend ::Fiddle::Importer\r\n        dlload ::FasterPath::FFI_LIBRARY\r\n        extern 'void free_array(size_t)'\r\n      end\r\n    end\r\n\r\n    attach_function :entries, [ :string ], FromRustArray.by_value\r\n  end\r\n```\r\nGives a similar error saying the same thing, that the **free_array** method wasn't found in the library.\r\n\r\n---\r\n\r\nAnd that's it.  This is what has lead me to conclude Rust isn't creating a valid method signature for other libraries to recognize when a parameter is a struct with the `#[repr(C)]` flag.\r\n\r\n**- Alternative implementation attempt -**\r\n\r\nI've tried creating a pointer first in Ruby for Rust to write to and that way Ruby would take care of garbage collecting it when it's done.  I may have been close, but I couldn't get past the segfault situation.  But this \"issue\" isn't about getting my code to work rather than the likeliness that Rust has a bug for this particular `extern \"C\"` format. _(Not that I wouldn't totally appreciate wisdom here that would help me to learn and achieve my goals.)_\r\n\r\n## Meta\r\n\r\n`rustc --version --verbose`:\r\n\r\n```\r\nrustc 1.21.0-nightly (7eeac1b81 2017-08-30)\r\nbinary: rustc\r\ncommit-hash: 7eeac1b81446c6327f1827ef334eca2db7fe28f7\r\ncommit-date: 2017-08-30\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.21.0-nightly\r\nLLVM version: 4.0\r\n```", "closed_by": {"login": "danielpclark", "id": 319081, "node_id": "MDQ6VXNlcjMxOTA4MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/319081?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielpclark", "html_url": "https://github.com/danielpclark", "followers_url": "https://api.github.com/users/danielpclark/followers", "following_url": "https://api.github.com/users/danielpclark/following{/other_user}", "gists_url": "https://api.github.com/users/danielpclark/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielpclark/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielpclark/subscriptions", "organizations_url": "https://api.github.com/users/danielpclark/orgs", "repos_url": "https://api.github.com/users/danielpclark/repos", "events_url": "https://api.github.com/users/danielpclark/events{/privacy}", "received_events_url": "https://api.github.com/users/danielpclark/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/44459/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/44459/timeline", "performed_via_github_app": null, "state_reason": "completed"}