{"url": "https://api.github.com/repos/rust-lang/rust/issues/58895", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/58895/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/58895/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/58895/events", "html_url": "https://github.com/rust-lang/rust/issues/58895", "id": 416527593, "node_id": "MDU6SXNzdWU0MTY1Mjc1OTM=", "number": 58895, "title": "Use `copyfile` for `std::fs::copy` on MacOS", "user": {"login": "ebarnard", "id": 1059683, "node_id": "MDQ6VXNlcjEwNTk2ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1059683?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebarnard", "html_url": "https://github.com/ebarnard", "followers_url": "https://api.github.com/users/ebarnard/followers", "following_url": "https://api.github.com/users/ebarnard/following{/other_user}", "gists_url": "https://api.github.com/users/ebarnard/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebarnard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebarnard/subscriptions", "organizations_url": "https://api.github.com/users/ebarnard/orgs", "repos_url": "https://api.github.com/users/ebarnard/repos", "events_url": "https://api.github.com/users/ebarnard/events{/privacy}", "received_events_url": "https://api.github.com/users/ebarnard/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 123111, "node_id": "MDU6TGFiZWwxMjMxMTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/O-macos", "name": "O-macos", "color": "6e6ec0", "default": false, "description": "Operating system: macOS"}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2019-03-03T15:24:52Z", "updated_at": "2019-03-16T17:52:28Z", "closed_at": "2019-03-16T17:52:28Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "`copyfile` on MacOS is similar to `CopyFileEx` on Windows. It supports copying resource forks/alternate data streams, extended attributes, and file ACLs, none of which are copied by the current generic unix implementation.\r\n\r\n<details>\r\n<summary>copyfile man page</summary>\r\n    p { margin-top: 0; margin-bottom: 0; } pre { margin-top: 0; margin-bottom: 0; } table { margin-top: 0; margin-bottom: 0; }  \r\n\r\nCOPYFILE(3) BSD Library Functions Manual COPYFILE(3)\r\n\r\n**NAME**\r\n\r\n**copyfile**, **fcopyfile**, **copyfile\\_state\\_alloc**, **copyfile\\_state\\_free**, **copyfile\\_state\\_get**, **copyfile\\_state\\_set** \u2014 copy a file\r\n\r\n**LIBRARY**\r\n\r\nStandard C\u00a0Library (libc, \u2212lc)\r\n\r\n**SYNOPSIS**\r\n\r\n**#include <copyfile.h>**\r\n\r\n_int_\r\n\r\n**copyfile**(_const\u00a0char\u00a0\\*from_, _const\u00a0char\u00a0\\*to_, _copyfile\\_state\\_t\u00a0state_, _copyfile\\_flags\\_t\u00a0flags_);\r\n\r\n_int_\r\n\r\n**fcopyfile**(_int\u00a0from_, _int\u00a0to_, _copyfile\\_state\\_t\u00a0state_, _copyfile\\_flags\\_t\u00a0flags_);\r\n\r\n_copyfile\\_state\\_t_\r\n\r\n**copyfile\\_state\\_alloc**(_void_);\r\n\r\n_int_\r\n\r\n**copyfile\\_state\\_free**(_copyfile\\_state\\_t\u00a0state_);\r\n\r\n_int_\r\n\r\n**copyfile\\_state\\_get**(_copyfile\\_state\\_t\u00a0state_, _uint32\\_t\u00a0flag_, _void\u00a0\\*\u00a0dst_);\r\n\r\n_int_\r\n\r\n**copyfile\\_state\\_set**(_copyfile\\_state\\_t\u00a0state_, _uint32\\_t\u00a0flag_, _const\u00a0void\u00a0\\*\u00a0src_);\r\n\r\n_typedef int_\r\n\r\n**(\\*copyfile\\_callback\\_t)**(_int\u00a0what_, _int\u00a0stage_, _copyfile\\_state\\_t\u00a0state_, _const\u00a0char\u00a0\\*\u00a0src_, _const\u00a0char\u00a0\\*\u00a0dst_, _void\u00a0\\*\u00a0ctx_);\r\n\r\n**DESCRIPTION**\r\n\r\nThese functions are used to copy a file\u2019s data and/or metadata. (Metadata consists of permissions, extended attributes, access control lists, and so forth.)\r\n\r\nThe **copyfile\\_state\\_alloc**() function initializes a _copyfile\\_state\\_t_ object (which is an opaque data type). This object can be passed to **copyfile**() and **fcopyfile**(); **copyfile\\_state\\_get**() and **copyfile\\_state\\_set**() can be used to manipulate the state (see below). The **copyfile\\_state\\_free**() function is used to deallocate the object and its contents.\r\n\r\nThe **copyfile**() function can copy the named _from_ file to the named _to_ file; the **fcopyfile**() function does the same, but using the file descriptors of already-opened files. If the _state_ parameter is the return value from **copyfile\\_state\\_alloc**(), then **copyfile**() and **fcopyfile**() will use the information from the state object; if it is NULL, then both functions will work normally, but less control will be available to the caller. The _flags_ parameter controls which contents are copied:\r\n\r\nCOPYFILE\\_ACL\r\n\r\nCopy the source file\u2019s access control lists.\r\n\r\nCOPYFILE\\_STAT\r\n\r\nCopy the source file\u2019s POSIX information (mode, modification time, etc.).\r\n\r\nCOPYFILE\\_XATTR\r\n\r\nCopy the source file\u2019s extended attributes.\r\n\r\nCOPYFILE\\_DATA\r\n\r\nCopy the source file\u2019s data.\r\n\r\nThese values may be or\u2019d together; several convenience macros are provided:\r\n\r\nCOPYFILE\\_SECURITY\r\n\r\nCopy the source file\u2019s POSIX and ACL information; equivalent to (COPYFILE\\_STAT|COPYFILE\\_ACL).\r\n\r\nCOPYFILE\\_METADATA\r\n\r\nCopy the metadata; equivalent to (COPYFILE\\_SECURITY|COPYFILE\\_XATTR).\r\n\r\nCOPYFILE\\_ALL\r\n\r\nCopy the entire file; equivalent to (COPYFILE\\_METADATA|COPYFILE\\_DATA).\r\n\r\nThe **copyfile**() and **fcopyfile**() functions can also have their behavior modified by the following flags:\r\n\r\nCOPYFILE\\_RECURSIVE\r\n\r\nCauses **copyfile**() to recursively copy a hierarchy. This flag is not used by **fcopyfile**(); see below for more information.\r\n\r\nCOPYFILE\\_CHECK\r\n\r\nReturn a bitmask (corresponding to the _flags_ argument) indicating which contents would be copied; no data are actually copied. (E.g., if _flags_ was set to COPYFILE\\_CHECK|COPYFILE\\_METADATA, and the _from_ file had extended attributes but no ACLs, the return value would be COPYFILE\\_XATTR .)\r\n\r\nCOPYFILE\\_PACK\r\n\r\nSerialize the _from_ file. The _to_ file is an AppleDouble-format file.\r\n\r\nCOPYFILE\\_UNPACK\r\n\r\nUnserialize the _from_ file. The _from_ file is an AppleDouble-format file; the _to_ file will have the extended attributes, ACLs, resource fork, and FinderInfo data from the _to_ file, regardless of the _flags_ argument passed in.\r\n\r\nCOPYFILE\\_EXCL\r\n\r\nFail if the _to_ file already exists. (This is only applicable for the **copyfile**() function.)\r\n\r\nCOPYFILE\\_NOFOLLOW\\_SRC\r\n\r\nDo not follow the _from_ file, if it is a symbolic link. (This is only applicable for the **copyfile**() function.)\r\n\r\nCOPYFILE\\_NOFOLLOW\\_DST\r\n\r\nDo not follow the _to_ file, if it is a symbolic link. (This is only applicable for the **copyfile**() function.)\r\n\r\nCOPYFILE\\_MOVE\r\n\r\nUnlink (using remove(3)) the _from_ file. (This is only applicable for the **copyfile**() function.) No error is returned if remove(3) fails. Note that remove(3) removes a symbolic link itself, not the target of the link.\r\n\r\nCOPYFILE\\_UNLINK\r\n\r\nUnlink the _to_ file before starting. (This is only applicable for the **copyfile**() function.)\r\n\r\nCOPYFILE\\_CLONE\\_FORCE\r\n\r\nClone the file instead. This is a force flag i.e. if cloning fails, an error is returned. This flag is equivalent to (COPYFILE\\_EXCL | COPYFILE\\_ACL | COPYFILE\\_STAT | COPYFILE\\_XATTR | COPYFILE\\_DATA | COPYFILE\\_NOFOLLOW\\_SRC). Note that if cloning is successful, progress callbacks will not be invoked. Note also that there is no support for cloning directories: if a directory is provided as the source, an error will be returned. (This is only applicable for the **copyfile**() function.)\r\n\r\nCOPYFILE\\_CLONE\r\n\r\nTry to clone the file instead. This is a best try flag i.e. if cloning fails, fallback to copying the file. This flag is equivalent to (COPYFILE\\_EXCL | COPYFILE\\_ACL | COPYFILE\\_STAT | COPYFILE\\_XATTR | COPYFILE\\_DATA | COPYFILE\\_NOFOLLOW\\_SRC). Note that if cloning is successful, progress callbacks will not be invoked. Note also that there is no support for cloning directories: if a directory is provided as the source and COPYFILE\\_CLONE\\_FORCE is not passed, this will instead copy the directory. Recursive copying however is supported, see below for more information. (This is only applicable for the **copyfile**() function.)\r\n\r\nCOPYFILE\\_DATA\\_SPARSE\r\n\r\nCopy a file sparsely. This requires that the source and destination file systems support sparse files with hole sizes at least as large as their block sizes. This also requires that the source file is sparse, and for **fcopyfile**() the source file descriptor\u2019s offset be a multiple of the minimum hole size. If COPYFILE\\_DATA is also specified, this will fall back to a full copy if sparse copying cannot be performed for any reason; otherwise, an error is returned.\r\n\r\nCOPYFILE\\_NOFOLLOW\r\n\r\nThis is a convenience macro, equivalent to (COPYFILE\\_NOFOLLOW\\_DST | COPYFILE\\_NOFOLLOW\\_SRC).\r\n\r\nCOPYFILE\\_RUN\\_IN\\_PLACE\r\n\r\nIf the src file has quarantine information, add the QTN\\_FLAG\\_DO\\_NOT\\_TRANSLOCATE flag to the quarantine information of the dst file. This allows a bundle to run in place instead of being translocated.\r\n\r\nThe **copyfile\\_state\\_get**() and **copyfile\\_state\\_set**() functions can be used to manipulate the _copyfile\\_state\\_t_ object returned by **copyfile\\_state\\_alloc**(). In both functions, the _dst_ parameter\u2019s type depends on the _flag_ parameter that is passed in.\r\n\r\nCOPYFILE\\_STATE\\_SRC\\_FD  \r\nCOPYFILE\\_STATE\\_DST\\_FD\r\n\r\nGet or set the file descriptor associated with the source (or destination) file. If this has not been initialized yet, the value will be -2. The _dst_ (for **copyfile\\_state\\_get**()) and _src_ (for **copyfile\\_state\\_set**()) parameters are pointers to _int_.\r\n\r\nCOPYFILE\\_STATE\\_SRC\\_FILENAME  \r\nCOPYFILE\\_STATE\\_DST\\_FILENAME\r\n\r\nGet or set the filename associated with the source (or destination) file. If it has not been initialized yet, the value will be NULL. For **copyfile\\_state\\_set**(), the _src_ parameter is a pointer to a C string (i.e., _char\\* );_ **copyfile\\_state\\_set**() makes a private copy of this string. For **copyfile\\_state\\_get**() function, the _dst_ parameter is a pointer to a pointer to a C string (i.e., _char\\*\\* );_ the returned value is a pointer to the _state \u2019s_ copy, and must not be modified or released.\r\n\r\nCOPYFILE\\_STATE\\_STATUS\\_CB\r\n\r\nGet or set the callback status function (currently only used for recursive copies; see below for details). The _src_ parameter is a pointer to a function of type _copyfile\\_callback\\_t_ (see above).\r\n\r\nCOPYFILE\\_STATE\\_STATUS\\_CTX\r\n\r\nGet or set the context parameter for the status call-back function (see below for details). The _src_ parameter is a _void\u00a0\\*_.\r\n\r\nCOPYFILE\\_STATE\\_QUARANTINE\r\n\r\nGet or set the quarantine information with the source file. The _src_ parameter is a pointer to an opaque object (type _void\u00a0\\*_ ).\r\n\r\nCOPYFILE\\_STATE\\_COPIED\r\n\r\nGet the number of data bytes copied so far. (Only valid for **copyfile\\_state\\_get**(); see below for more details about callbacks.) If a COPYFILE\\_CLONE or COPYFILE\\_CLONE\\_FORCE operation successfully cloned the requested objects, then this value will be 0. The _dst_ parameter is a pointer to _off\\_t_ (type _off\\_t\u00a0\\* )._\r\n\r\nCOPYFILE\\_STATE\\_XATTRNAME\r\n\r\nGet the name of the extended attribute during a callback for COPYFILE\\_COPY\\_XATTR (see below for details). This field cannot be set, and may be NULL.\r\n\r\nCOPYFILE\\_STATE\\_WAS\\_CLONED\r\n\r\nTrue if a COPYFILE\\_CLONE or COPYFILE\\_CLONE\\_FORCE operation successfully cloned the requested objects. The _dst_ parameter is a pointer to _bool_ (type _bool\u00a0\\* )._\r\n\r\n**Recursive Copies**\r\n\r\nWhen given the COPYFILE\\_RECURSIVE flag, **copyfile**() (but not **fcopyfile**()) will use the fts(3) functions to recursively descend into the source file-system object. It then calls **copyfile**() on each of the entries it finds that way. If a call-back function is given (using **copyfile\\_state\\_set**() and COPYFILE\\_STATE\\_STATUS\\_CB ), the call-back function will be called four times for each directory object, and twice for all other objects. (Each directory will be examined twice, once on entry -- before copying each of the objects contained in the directory -- and once on exit -- after copying each object contained in the directory, in order to perform some final cleanup.)\r\n\r\nThe call-back function will have one of the following values as the first argument, indicating what is being copied:\r\n\r\nCOPYFILE\\_RECURSE\\_FILE\r\n\r\nThe object being copied is a file (or, rather, something other than a directory).\r\n\r\nCOPYFILE\\_RECURSE\\_DIR\r\n\r\nThe object being copied is a directory, and is being entered. (That is, none of the filesystem objects contained within the directory have been copied yet.)\r\n\r\nCOPYFILE\\_RECURSE\\_DIR\\_CLEANUP\r\n\r\nThe object being copied is a directory, and all of the objects contained have been copied. At this stage, the destination directory being copied will have any extra permissions that were added to allow the copying will be removed.\r\n\r\nCOPYFILE\\_RECURSE\\_ERROR\r\n\r\nThere was an error in processing an element of the source hierarchy; this happens when fts(3) returns an error or unknown file type. (Currently, the second argument to the call-back function will always be COPYFILE\\_ERR in this case.)\r\n\r\nThe second argument to the call-back function will indicate the stage of the copy, and will be one of the following values:\r\n\r\nCOPYFILE\\_START\r\n\r\nBefore copying has begun. The third parameter will be a newly-created _copyfile\\_state\\_t_ object with the call-back function and context pre-loaded.\r\n\r\nCOPYFILE\\_FINISH\r\n\r\nAfter copying has successfully finished.\r\n\r\nCOPYFILE\\_ERR\r\n\r\nIndicates an error has happened at some stage. If the first argument to the call-back function is COPYFILE\\_RECURSE\\_ERROR, then an error occurred while processing the source hierarchy; otherwise, it will indicate what type of object was being copied, and errno will be set to indicate the error.\r\n\r\nThe fourth and fifth parameters are the source and destination paths that are to be copied (or have been copied, or failed to copy, depending on the second argument).\r\n\r\nThe last argument to the call-back function will be the value set by COPYFILE\\_STATE\\_STATUS\\_CTX, if any.\r\n\r\nThe call-back function is required to return one of the following values:\r\n\r\nCOPYFILE\\_CONTINUE\r\n\r\nThe copy will continue as expected.\r\n\r\nCOPYFILE\\_SKIP\r\n\r\nThis object will be skipped, and the next object will be processed. (Note that, when entering a directory. returning COPYFILE\\_SKIP from the call-back function will prevent the contents of the directory from being copied.)\r\n\r\nCOPYFILE\\_QUIT\r\n\r\nThe entire copy is aborted at this stage. Any filesystem objects created up to this point will remain. **copyfile**() will return -1, but errno will be unmodified.\r\n\r\nThe call-back function must always return one of the values listed above; if not, the results are undefined.\r\n\r\nThe call-back function will be called twice for each object (and an additional two times for directory cleanup); the first call will have a _stage_ parameter of COPYFILE\\_START; the second time, that value will be either COPYFILE\\_FINISH or COPYFILE\\_ERR to indicate a successful completion, or an error during processing. In the event of an error, the errno value will be set appropriately.\r\n\r\nNote that recursive cloning is also supported with the COPYFILE\\_CLONE flag (but not the COPYFILE\\_CLONE\\_FORCE flag). A recursive clone operation invokes **copyfile**() with COPYFILE\\_CLONE on every entry found in the source file-system object. Because **copyfile**() does not allow the cloning of directories, a recursive clone will instead copy any directory it finds (while cloning its contents). As symbolic links may point to directories, they are not followed during recursive clones even if the source is a symbolic link. Additionally, because the COPYFILE\\_CLONE flag implies the COPYFILE\\_EXCL flag, recursive clones require a nonexistent destination.\r\n\r\nThe COPYFILE\\_PACK, COPYFILE\\_UNPACK, COPYFILE\\_MOVE, and COPYFILE\\_UNLINK flags are not used during a recursive copy, and will result in an error being returned.\r\n\r\n**Progress Callback**\r\n\r\nIn addition to the recursive callbacks described above, **copyfile**() and **fcopyfile**() will also use a callback to report data (e.g., COPYFILE\\_DATA) progress. If given, the callback will be invoked on each write(2) call. The first argument to the callback function will be COPYFILE\\_COPY\\_DATA. The second argument will either be COPYFILE\\_PROGRESS (indicating that the write was successful), or COPYFILE\\_ERR (indicating that there was an error of some sort).\r\n\r\nThe amount of data bytes copied so far can be retrieved using **copyfile\\_state\\_get**(), with the COPYFILE\\_STATE\\_COPIED requestor (the argument type is a pointer to _off\\_t )._\r\n\r\nWhen copying extended attributes, the first argument to the callback function will be COPYFILE\\_COPY\\_XATTR. The other arguments will be as described for COPYFILE\\_COPY\\_DATA; the name of the extended attribute being copied may be retrieved using **copyfile\\_state\\_get**() and the parameter COPYFILE\\_STATE\\_XATTRNAME. When using COPYFILE\\_PACK, the callback may be called with COPYFILE\\_START for each of the extended attributes first, followed by COPYFILE\\_PROGRESS before getting and packing the data for each individual attribute, and then COPYFILE\\_FINISH when finished with each individual attribute. (That is, COPYFILE\\_START may be called for all of the extended attributes, before the first callback with COPYFILE\\_PROGRESS is invoked.) Any attribute skipped by returning COPYFILE\\_SKIP from the COPYFILE\\_START callback will not be placed into the packed output file.\r\n\r\nThe return value for the data callback must be one of\r\n\r\nCOPYFILE\\_CONTINUE\r\n\r\nThe copy will continue as expected. (In the case of error, it will attempt to write the data again.)\r\n\r\nCOPYFILE\\_SKIP\r\n\r\nThe data copy will be aborted, but without error.\r\n\r\nCOPYFILE\\_QUIT\r\n\r\nThe data copy will be aborted; in the case of COPYFILE\\_PROGRESS, errno will be set to ECANCELED.\r\n\r\nWhile the _src_ and _dst_ parameters will be passed in, they may be NULL in the case of **fcopyfile**().\r\n\r\nNote that progress callbacks are not invoked when a clone is requested (e.g. COPYFILE\\_CLONE) unless the clone cannot be performed and a copy is performed instead.\r\n\r\n**RETURN VALUES**\r\n\r\nExcept when given the COPYFILE\\_CHECK flag, **copyfile**() and **fcopyfile**() return less than 0 on error, and 0 on success. All of the other functions return 0 on success, and less than 0 on error.\r\n\r\n**WARNING**\r\n\r\nBoth **copyfile**() and **fcopyfile**() can copy symbolic links; there is a gap between when the source link is examined and the actual copy is started, and this can be a potential security risk, especially if the process has elevated privileges.\r\n\r\nWhen performing a recursive copy, if the source hierarchy changes while the copy is occurring, the results are undefined.\r\n\r\n**fcopyfile**() does not reset the seek position for either source or destination. This can result in the destination file being a different size than the source file.\r\n\r\n**ERRORS**\r\n\r\n**copyfile**() and **fcopyfile**() will fail if:\r\n\r\n\\[EINVAL\\]\r\n\r\nAn invalid flag was passed in with COPYFILE\\_RECURSIVE.\r\n\r\n\\[EINVAL\\]\r\n\r\nThe _from_ or _to_ parameter to **copyfile**() was a NULL pointer.\r\n\r\n\\[EINVAL\\]\r\n\r\nThe _from_ or _to_ parameter to **fcopyfile**() was a negative number.\r\n\r\n\\[ENOMEM\\]\r\n\r\nA memory allocation failed.\r\n\r\n\\[ENOTSUP\\]\r\n\r\nThe source file was not a directory, symbolic link, or regular file.\r\n\r\n\\[ENOTSUP\\]\r\n\r\nCOPYFILE\\_CLONE\\_FORCE was specified and file cloning is not supported.\r\n\r\n\\[ENOTSUP\\]\r\n\r\nCOPYFILE\\_DATA\\_SPARSE was specified, sparse copying is not supported, and COPYFILE\\_DATA was not specified.\r\n\r\n\\[ECANCELED\\]\r\n\r\nThe copy was cancelled by callback.\r\n\r\n\\[EEXIST\\]\r\n\r\nThe _to_ parameter to **copyfile**() already existed and was passed in with COPYFILE\\_EXCL.\r\n\r\n\\[ENOENT\\]\r\n\r\nThe _from_ parameter to **copyfile**() did not exist.\r\n\r\n\\[EACCES\\]\r\n\r\nSearch permission is denied for a component of the path prefix for the _from_ or _to_ parameters.\r\n\r\n\\[EACCES\\]\r\n\r\nWrite permission is denied for a component of the path prefix for the _to_ parameter.\r\n\r\nIn addition, both functions may set errno via an underlying library or system call.\r\n\r\n**EXAMPLES**\r\n\r\n/\\* Initialize a state variable \\*/  \r\ncopyfile\\_state\\_t s;  \r\ns = copyfile\\_state\\_alloc();  \r\n/\\* Copy the data and extended attributes of one file to another \\*/  \r\ncopyfile(\"/tmp/f1\", \"/tmp/f2\", s, COPYFILE\\_DATA | COPYFILE\\_XATTR);  \r\n/\\* Convert a file to an AppleDouble file for serialization \\*/  \r\ncopyfile(\"/tmp/f2\", \"/tmp/tmpfile\", NULL, COPYFILE\\_ALL | COPYFILE\\_PACK);  \r\n/\\* Release the state variable \\*/  \r\ncopyfile\\_state\\_free(s);  \r\n/\\* A more complex way to call copyfile() \\*/  \r\ns = copyfile\\_state\\_alloc();  \r\ncopyfile\\_state\\_set(s, COPYFILE\\_STATE\\_SRC\\_FILENAME, \"/tmp/foo\");  \r\n/\\* One of src or dst must be set... rest can come from the state \\*/  \r\ncopyfile(NULL, \"/tmp/bar\", s, COPYFILE\\_ALL);  \r\n/\\* Now copy the same source file to another destination file \\*/  \r\ncopyfile(NULL, \"/tmp/car\", s, COPYFILE\\_ALL);  \r\ncopyfile\\_state\\_free(s);  \r\n/\\* Remove extended attributes from a file \\*/  \r\ncopyfile(\"/dev/null\", \"/tmp/bar\", NULL, COPYFILE\\_XATTR);\r\n\r\n**SEE ALSO**\r\n\r\nlistxattr(2), getxattr(2), setxattr(2), acl(3)\r\n\r\n**BUGS**\r\n\r\nBoth **copyfile**() functions lack a way to set the input or output block size.\r\n\r\nRecursive copies do not honor hard links.\r\n\r\n**HISTORY**\r\n\r\nThe **copyfile**() API was introduced in Mac OS X 10.5.\r\n\r\nBSD August\u00a030, 2017 BSD\r\n\r\n* * *\r\n</details>", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/58895/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/58895/timeline", "performed_via_github_app": null, "state_reason": "completed"}