{"url": "https://api.github.com/repos/rust-lang/rust/issues/84824", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/84824/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/84824/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/84824/events", "html_url": "https://github.com/rust-lang/rust/issues/84824", "id": 873968584, "node_id": "MDU6SXNzdWU4NzM5Njg1ODQ=", "number": 84824, "title": "rustdoc: allow searching by trait bounds", "user": {"login": "pickfire", "id": 4687791, "node_id": "MDQ6VXNlcjQ2ODc3OTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4687791?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pickfire", "html_url": "https://github.com/pickfire", "followers_url": "https://api.github.com/users/pickfire/followers", "following_url": "https://api.github.com/users/pickfire/following{/other_user}", "gists_url": "https://api.github.com/users/pickfire/gists{/gist_id}", "starred_url": "https://api.github.com/users/pickfire/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pickfire/subscriptions", "organizations_url": "https://api.github.com/users/pickfire/orgs", "repos_url": "https://api.github.com/users/pickfire/repos", "events_url": "https://api.github.com/users/pickfire/events{/privacy}", "received_events_url": "https://api.github.com/users/pickfire/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 203738, "node_id": "MDU6TGFiZWwyMDM3Mzg=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-rustdoc", "name": "T-rustdoc", "color": "bfd4f2", "default": false, "description": "Relevant to the rustdoc team, which will review and decide on the PR/issue."}, {"id": 630652267, "node_id": "MDU6TGFiZWw2MzA2NTIyNjc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-feature-request", "name": "C-feature-request", "color": "f5f1fd", "default": false, "description": "Category: A feature request, i.e: not implemented / a PR."}, {"id": 2432552396, "node_id": "MDU6TGFiZWwyNDMyNTUyMzk2", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-rustdoc-search", "name": "A-rustdoc-search", "color": "f7e101", "default": false, "description": "Area: Rustdoc's search feature"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2021-05-02T15:20:42Z", "updated_at": "2021-12-15T00:08:42Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "https://docs.rs/hyper/0.14.7/hyper/client/conn/struct.Builder.html\r\n\r\n![image](https://user-images.githubusercontent.com/4687791/116817839-f776bf80-ab9a-11eb-996f-f33848462768.png)\r\n\r\nSome libraries have trait bounds more complicated and more that one items, some of it could be automatically-derived or some could be specifically implemented for a certain structs/enums. Other libraries such as diesel also make use of trait bounds extensively.\r\n\r\n```rust\r\npub fn handshake<T, B>(\r\n    &self,\r\n    io: T\r\n) -> impl Future<Output = Result<(SendRequest<B>, Connection<T, B>)>> where\r\n    T: AsyncRead + AsyncWrite + Unpin + Send + 'static,\r\n    B: HttpBody + 'static,\r\n    B::Data: Send,\r\n    B::Error: Into<Box<dyn StdError + Send + Sync>>, \r\n```\r\n\r\nIf the user wants to find out which type can they used within the trait bound. According to the context above that they want to find out what can they use for `T`, they had to click on `AsyncRead`, capture all the implementations in mind and then go back and click on `AsyncWrite` and see which types appear again since trait bound is additive, it needs to satisfy all the traits.\r\n\r\nIf the user implemented a struct/enum that implemented all the specified trait bound then they know which is it, but if the user is using a third party library, chances are they will easily get lost or take some time to figure out what can `T` be without implementing it themselves. Without examples of the function, it would be require some time to go through and understand all the traits and their respective implementations.\r\n\r\nMaybe we could have a way for user to know what could possibly be the types that they can use for `T` without going through the whole codebase? Behaving like goto implementation of language server, except now it can show what types satisfies all the specified trait bounds?\r\n\r\nOf course the solution may not need to be perfect. I can think it may not work well with auto-traits since it could be hard to do that. Two solutions I can think of, we can have a `implementations` section within the search tab that shows all the types that satisfies the trait bounds specified, like `AsyncRead + AsyncWrite` (but not sure if we can also do it for `Unpin` or `Send`, maybe we couldn't cover lifetime at all). Another thing I can think of is that we can maybe provide some information when one clicks/hover on `io` or `T` then it will show the types that implement it, similar to the auto-traits section within the doc page.\r\n\r\nNot sure if it is feasible, just an idea. Maybe we even had to have another search index if we can't reuse the existing one and not sure if it's worth it, or maybe we could make it lazily loaded only when they reached the tab. One issue I see is that types being shown may not be able to show standard library types and that may be an issue.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/84824/reactions", "total_count": 3, "+1": 3, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/84824/timeline", "performed_via_github_app": null, "state_reason": null}