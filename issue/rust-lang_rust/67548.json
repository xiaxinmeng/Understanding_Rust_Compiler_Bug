{"url": "https://api.github.com/repos/rust-lang/rust/issues/67548", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/67548/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/67548/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/67548/events", "html_url": "https://github.com/rust-lang/rust/issues/67548", "id": 541522391, "node_id": "MDU6SXNzdWU1NDE1MjIzOTE=", "number": 67548, "title": "Don't emit \"value assigned to ... is never read\" for each instance?", "user": {"login": "mqudsi", "id": 606923, "node_id": "MDQ6VXNlcjYwNjkyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/606923?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mqudsi", "html_url": "https://github.com/mqudsi", "followers_url": "https://api.github.com/users/mqudsi/followers", "following_url": "https://api.github.com/users/mqudsi/following{/other_user}", "gists_url": "https://api.github.com/users/mqudsi/gists{/gist_id}", "starred_url": "https://api.github.com/users/mqudsi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mqudsi/subscriptions", "organizations_url": "https://api.github.com/users/mqudsi/orgs", "repos_url": "https://api.github.com/users/mqudsi/repos", "events_url": "https://api.github.com/users/mqudsi/events{/privacy}", "received_events_url": "https://api.github.com/users/mqudsi/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 235791, "node_id": "MDU6TGFiZWwyMzU3OTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-diagnostics", "name": "A-diagnostics", "color": "f7e101", "default": false, "description": "Area: Messages for errors, warnings, and lints"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 1659943986, "node_id": "MDU6TGFiZWwxNjU5OTQzOTg2", "url": "https://api.github.com/repos/rust-lang/rust/labels/D-verbose", "name": "D-verbose", "color": "c9f7a3", "default": false, "description": "Too much output caused by a single piece of incorrect code"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2019-12-23T00:37:38Z", "updated_at": "2020-01-15T19:10:58Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Scrolling through warnings when compiling projects during the early development stages can be a bit of a chore, but there's not much the compiler can do about it as it doesn't know whether you just haven't gotten around to something or if you forgot about it. I typically add `#![allow(unused_code)]` and `#![allow(dead_code)]` to new projects and take them out when the codebase nears completion of v1, but it occurs to me that there's no real value in emitting repeated warnings for unused assignments of the same variable.\r\n\r\ne.g. \r\n\r\n![image](https://user-images.githubusercontent.com/606923/71329250-8c1dd780-24e8-11ea-9dc3-3b39a21b1d6f.png)\r\n\r\nThere are different heuristics here depending on how important it is to generate all warnings in advance, including\r\n\r\n* a bloom filter for the variable (by ast path, not name) with the corresponding buckets filled when the first warning is emitted\r\n\r\nThis means code like \r\n\r\n```rust\r\n{\r\n    let foo = bar;\r\n    let foo = bar;\r\n}\r\n```\r\n\r\ncontinues to emit two warnings as they are two different variables being unread, *but* this wouldn't emit two warnings:\r\n\r\n```rust\r\n{ \r\n    let mut foo = \"bar\";\r\n    foo = \"baz\";\r\n}\r\n```\r\n\r\nas we are deduplicating by variable and not by unread write so only the first assignment will generate the warning, which is *probably* ok since addressing that error by adding either of \r\n\r\n```rust\r\n{\r\n    let mut foo = \"bar\";\r\n    if (foo == \"bar\") { ... }\r\n    foo = \"baz\";\r\n}\r\n```\r\n\r\nor \r\n\r\n```rust\r\n{\r\n    let mut foo = \"bar\";\r\n    foo = \"baz\";\r\n    if (foo == \"bar\") { ... }\r\n}\r\n```\r\n\r\nwill go back to generating the warning for the other instance of unused write.\r\n\r\n* actually tracking individual code paths for each variable and only warning for writes that are not provably exclusive:\r\n\r\n```rust\r\n{ \r\n    let mut foo = \"bar\";\r\n    foo = \"baz\";\r\n}\r\n```\r\n\r\nThe above would continue to generate two warnings, but the following would generate only one:\r\n\r\n```rust\r\nlet mut bar;\r\nlet foo = \"hello\";\r\nmatch foo {\r\n    \"bar\" => foo = \"bar\",\r\n    \"baz\" => foo = \"qux\",\r\n}\r\n```\r\n\r\nas no value was overwritten at any point and a single read would suffice to address both instances of unused writes.\r\n\r\nPersonally, I think the latter is overkill and might slow things down and increase memory usage in the compiler without much benefit. The former is both fast and easy (with no allocations and predetermined memory consumption based off the size of the bloom filter).", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/67548/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/67548/timeline", "performed_via_github_app": null, "state_reason": null}