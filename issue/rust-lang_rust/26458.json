{"url": "https://api.github.com/repos/rust-lang/rust/issues/26458", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/26458/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/26458/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/26458/events", "html_url": "https://github.com/rust-lang/rust/issues/26458", "id": 89798809, "node_id": "MDU6SXNzdWU4OTc5ODgwOQ==", "number": 26458, "title": "SIGSEGV and SIGBUS cause an exit signal of SIGILL", "user": {"login": "geofft", "id": 74644, "node_id": "MDQ6VXNlcjc0NjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/74644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geofft", "html_url": "https://github.com/geofft", "followers_url": "https://api.github.com/users/geofft/followers", "following_url": "https://api.github.com/users/geofft/following{/other_user}", "gists_url": "https://api.github.com/users/geofft/gists{/gist_id}", "starred_url": "https://api.github.com/users/geofft/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geofft/subscriptions", "organizations_url": "https://api.github.com/users/geofft/orgs", "repos_url": "https://api.github.com/users/geofft/repos", "events_url": "https://api.github.com/users/geofft/events{/privacy}", "received_events_url": "https://api.github.com/users/geofft/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2015-06-20T18:10:38Z", "updated_at": "2015-08-11T01:17:35Z", "closed_at": "2015-08-11T01:17:35Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "[As demonstrated on Playpen](http://is.gd/QRIaZ5):\n\n``` rust\nfn main() {\n    unsafe {*(0 as *mut u32) = 0};\n}\n```\n\n```\nplaypen: application terminated abnormally with signal 4 (Illegal instruction)\n```\n\nThe reason for this is that, when a UNIX signal is being handled, UNIX blocks that signal while the handler is running, by default. However, [this particular signal handler](https://github.com/rust-lang/rust/blob/master/src/libstd/sys/unix/stack_overflow.rs#L66) tries to re-raise the signal when it's done with processing. This doesn't do anything since the handler is still running, so execution continues with the next line, `intrinsics::abort()`, which induces `SIGILL`. (The code tries to reset the _signal disposition_ to avoid re-entering the same handler, but that's not enough; the _mask of blocked signals_ also needs to be cleared.)\n\nThere are a couple of possible solutions to this. The straightforward one is to cause the signal not to be masked. I have a [patch for this](https://github.com/geofft/rust/commit/unmask-sigsegv) that depends on my signal-FFI-bindings refactoring in #25784; I can submit it as a PR once that lands.\n\nAnother one, which I prefer, is to just let the handler terminate instead of re-raising. There was [discussion about this previously](https://github.com/rust-lang/rust/pull/16388#discussion_r19097299), where it was noted that glibc's manual says this is undefined for \"program error signals\" like `SIGSEGV` and `SIGBUS`. POSIX agrees with that. However, most platforms in practice define this behavior, and allow you to return from these handlers, so that you can do things like userspace page-fault handling.\n\nFor example,\n- Google's Breakpad crash-handling library returns from `SIGSEGV` [on Linux](https://code.google.com/p/google-breakpad/source/browse/trunk/src/client/linux/handler/exception_handler.cc#317) and [on Solaris](https://code.google.com/p/google-breakpad/source/browse/trunk/src/client/solaris/handler/exception_handler.cc#168). (On Darwin they use Mach exceptions.)\n- The Oracle JVM [relies on being able to return from a `SIGSEGV` handler](http://www.oracle.com/technetwork/java/javase/signals-139944.html): they use it as a trick for stop-the-world pauses with low overhead. (Periodically each thread will do a single read from a special page, which is ~one instruction. If the GC wants to stop the world, it'll unmap the page to cause each thread to fault, and once it's ready to continue the world, it'll remap the page and make all threads return from their signal handlers.) So any UNIX platform where the JVM works should support this.\n- [GNU libsigsegv](http://www.gnu.org/software/libsigsegv/) is a library for doing things like userspace paging, and it's predicated on the assumption that returning from `SIGSEGV` is possible. The [PORTING file](http://git.savannah.gnu.org/cgit/libsigsegv.git/tree/PORTING) has a wide list of supported platforms, including Linux, Darwin, FreeBSD, OpenBSD, NetBSD, Solaris, and MinGW.\n\nSo I think that it's merely the case that returning from a program error handler is unspecified in POSIX, but just about all actual OSes we care about support it.\n\nThis has the advantage that the exact signal is re-delivered to kill the program, with the right siginfo (indicating it died because of a memory error, not because someone manually sent `SIGSEGV`), so the last frame in a coredump is right, `dmesg` prints a line, etc. We can keep the re-raise for unknown platforms, but for platforms where we know that returning from the handler works, that seems both simpler and better. (Breakpad takes this approach for the same reasons.)\n\nThe final option is just to remove this code. What it does, as far as I see, is to print an error message and die if the segfault was on the guard page, and just die otherwise. I don't think there's a compelling reason to print a message for stack overflow, especially as caught by `SIGSEGV` (it makes more sense if it's caught by stack probes or `morestack`). In any other systems language, overflowing the stack just gets you killed with `SIGSEGV`, and installing a special handler doesn't seem to match the runtime-removal philosophy. It made sense in the `librustrt` world, but I'd argue it's not useful now. But if other people are finding the handler / the error message useful, that's fine.\n\nCc @Zoxc for advice, as the original author of the segfault handling code.\n", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/26458/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/26458/timeline", "performed_via_github_app": null, "state_reason": "completed"}