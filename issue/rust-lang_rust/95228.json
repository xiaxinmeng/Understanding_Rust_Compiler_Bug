{"url": "https://api.github.com/repos/rust-lang/rust/issues/95228", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/95228/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/95228/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/95228/events", "html_url": "https://github.com/rust-lang/rust/issues/95228", "id": 1177550298, "node_id": "I_kwDOAAsO6M5GL_3a", "number": 95228, "title": "Tracking Issue for strict_provenance", "user": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 650846969, "node_id": "MDU6TGFiZWw2NTA4NDY5Njk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-tracking-issue", "name": "C-tracking-issue", "color": "f5f1fd", "default": false, "description": "Category: A tracking issue for an RFC or an unstable feature."}, {"id": 3983786342, "node_id": "LA_kwDOAAsO6M7tc8Fm", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-strict-provenance", "name": "A-strict-provenance", "color": "f7e101", "default": false, "description": "Area: Strict provenance for raw pointers"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 145, "created_at": "2022-03-23T03:32:07Z", "updated_at": "2023-04-14T23:02:16Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "<!--\r\nThank you for creating a tracking issue!\r\n\r\nTracking issues are for tracking a feature from implementation to stabilization.\r\n\r\nMake sure to include the relevant RFC for the feature if it has one.\r\n\r\nIf the new feature is small, it may be fine to skip the RFC process. In that\r\ncase, you can use use `issue = \"none\"` in your initial implementation PR. The\r\nreviewer will ask you to open a tracking issue if they agree your feature can be\r\nadded without an RFC.\r\n-->\r\n\r\nFeature gate: `#![feature(strict_provenance)]`\r\n\r\n[read the docs](https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance)\r\n\r\n[get the stable polyfill](https://crates.io/crates/sptr)\r\n\r\n[subtasks](https://github.com/rust-lang/rust/labels/A-strict-provenance)\r\n\r\nThis is a tracking issue for the `strict_provenance` feature. This is a standard library feature that governs the following APIs:\r\n\r\n* [`pointer::addr`](https://doc.rust-lang.org/nightly/core/primitive.pointer.html#method.addr)\r\n* [`pointer::with_addr`](https://doc.rust-lang.org/nightly/core/primitive.pointer.html#method.with_addr)\r\n* [`pointer::map_addr`](https://doc.rust-lang.org/nightly/core/primitive.pointer.html#method.map_addr)\r\n* [`core::ptr::invalid`](https://doc.rust-lang.org/nightly/core/ptr/fn.invalid.html)\r\n* [`core::ptr::invalid_mut`](https://doc.rust-lang.org/nightly/core/ptr/fn.invalid.html)\r\n\r\n> **IMPORTANT:** This is purely a set of library APIs to make your code more clear/reliable, so that we can better understand what Rust code is *actually* trying to do and what it *actually* needs help with. It is overwhelmingly framed as *a memory model* because we are doing a bit of Roleplay here. We are roleplaying that this is a real memory model and seeing what code doesn't conform to it already. Then we are seeing how trivial it is to make that code \"conform\".\r\n>\r\n> This cannot and will not \"break your code\" because the lang and compiler teams are wholy uninvolved with this. Your code cannot be \"run under strict provenance\" because there isn't a compiler flag for \"enabling\" it. Although it would be nice to have a lint to make it easier to quickly migrate code that wants to play along.\r\n\r\nThis is an unofficial experiment to see How Bad it would be if Rust had extremely strict pointer provenance rules that require you to *always* dynamically preserve provenance information. Which is to say if you ever want to treat something as a Real Pointer that can be Offset and Dereferenced, **there must be an unbroken chain of custody from that pointer to the original allocation you are trying to access _using only pointer->pointer operations_**. If at any point you turn a pointer into an integer, that integer cannot be turned back into a pointer. This includes `usize as ptr`, `transmute`, type punning with raw pointer reads/writes, whatever. Just assume the memory \"knows\" it contains a pointer and that writing to it as a non-pointer makes it forget (because this is quite literally true on CHERI and miri, which are *immediate* beneficiaries of doing this).\r\n\r\nA secondary goal of this project is to try to disambiguate the many meanings of `ptr as usize`, in the hopes that it might make it plausible/tolerable to **allow `usize` to be redefined to be an *address*-sized integer instead of a *pointer*-sized integer**. This would allow for Rust to more natively support platforms where `sizeof(size_t) < sizeof(intptr_t)`, and effectively redefine `usize` from `intptr_t` to `size_t`/`ptrdiff_t`/`ptraddr_t` (it would still generally conflate *those* concepts, absent a motivation to do otherwise). To the best of my knowledge this would not have a practical effect on any currently supported platforms, and just allow for more platforms to be supported (certainly true for our tier 1 platforms).\r\n\r\nA tertiary goal of this project is to more clearly answer the question \"hey **what's the deal with Rust on architectures that are pretty harvard-y like AVR and WASM** (platforms which treat function pointers and data pointers non-uniformly)\". There is... *weirdness* in the language because it's difficult to talk about \"some\" function pointer generically/opaquely and that encourages you to turn them into data pointers and then maybe that does Wrong Things.\r\n\r\nThe mission statement of this experiment is: **assume it will and _must_ work, try to make code conform to it, smash face-first into really nasty problems that need special consideration, and try to actually figure out how to handle those situations.** We *want* the evil shit you do with pointers to work [but the current situation leads to incredibly broken results](https://www.ralfj.de/blog/2020/12/14/provenance.html), so *something* has to give.\r\n\r\n\r\n\r\n<!--\r\nInclude a short description of the feature.\r\n-->\r\n\r\n### Public API\r\n\r\n<!--\r\nFor most library features, it'd be useful to include a summarized version of the public API.\r\n(E.g. just the public function signatures without their doc comments or implementation.)\r\n-->\r\n\r\nThis design is roughly based on the article [Rust's Unsafe Pointer Types Need An Overhaul](https://gankra.github.io/blah/fix-rust-pointers/#distinguish-pointers-and-addresses), which is itself based on the APIs that CHERI exposes for dynamically maintaining provenance information even under Fun Bit Tricks.\r\n\r\nThe core piece that makes this at all plausible is `pointer::with_addr(self, usize) -> Self` which dynamically re-establishes the provenance chain of custody. Everything else introduced is sugar or alternatives to `as` casts that better express intent.\r\n\r\nMore APIs may be introduced as we explore the feature space.\r\n\r\n```rust\r\n// core::ptr\r\npub fn invalid<T>(addr: usize) -> *const T;\r\npub fn invalid_mut<T>(addr: usize) -> *mut T;\r\n\r\n// core::pointer\r\npub fn addr(self) -> usize;\r\npub fn with_addr(self, addr: usize) -> Self;\r\npub fn map_addr(self, f: impl FnOnce(usize) -> usize) -> Self;\r\n```\r\n\r\n### Steps / History\r\n\r\n<!--\r\nFor larger features, more steps might be involved.\r\nIf the feature is changed later, please add those PRs here as well.\r\n-->\r\n\r\n- [x] Implementation: #95241\r\n- [ ] Final comment period (FCP)\r\n- [ ] Stabilization PR\r\n\r\n<!--\r\nOnce the feature has gone through a few release cycles and there are no\r\nunresolved questions left, the feature might be ready for stabilization.\r\n\r\nIf this feature didn't go through the RFC process, a final comment period\r\n(FCP) is always needed before stabilization. This works as follows:\r\n\r\nA library API team member can kick off the stabilization process, at which point\r\nthe rfcbot will ask all the team members to verify they agree with\r\nstabilization. Once enough members agree and there are no concerns, the final\r\ncomment period begins: this issue will be marked as such and will be listed\r\nin the next This Week in Rust newsletter. If no blocking concerns are raised in\r\nthat period of 10 days, a stabilzation PR can be opened by anyone.\r\n-->\r\n\r\n### Unresolved Questions\r\n\r\n<!--\r\nInclude any open questions that need to be answered before the feature can be\r\nstabilised. If multiple (unrelated) big questions come up, it can be a good idea\r\nto open a separate issue for each, to make it easier to keep track of the\r\ndiscussions.\r\n\r\nIt's useful to link any relevant discussions and conclusions (whether on GitHub,\r\nZulip, or the internals forum) here.\r\n-->\r\n\r\n- How Bad Is This?\r\n\r\n- How Good Is This?\r\n\r\n- What's Problematic (And Should Work)?\r\n  - [ ] Hardcoded MMIO address stuff\r\n      - We should define a platform-specific way to do this, possibly requiring that you only use `volatile` access\r\n  - [ ] Opaque Function Pointers - architectures like AVR and WASM treat function pointers special, they're normal pointers.\r\n      - We should really define a `#[repr(transparent)] OpaqueFnPtr(fn() -> ())` type in std, need a way to talk about e.g. dlopen.\r\n  - [ ] libc interop for bad APIs that pun integers and pointers\r\n      - Use a union to make the pun explicit?\r\n  - [ ] passing shared pointers over IPC?\r\n      - At worst you can rederive from your SHMEM?\r\n  - [ ] downcasting to subclasses?\r\n      - Would be nice if you could create a reference *without* shrinking its provenance to allow for ergonomic references to a baseclass that can be (unsafely) cast to a reference to a subclass.\r\n  - [ ] memcpy operations conceptually say \"all this memory is just u8's\" which would trash provenance\r\n      - it's pretty standard to carve out exceptions for memcpy, but it would be good to know if this can be done more rigorously \r\nwith something like [llvm's proposed byte type](https://gist.github.com/georgemitenkov/3def898b8845c2cc161bd216cbbdb81f)\r\n  - [ ] AtomicPtr - AtomicPtr has a very limited API, so lots of people use AtomicUsize to do the equivalent of wrapping_add\r\n      - Morally this is fine, unclear if the right compiler intrinsics exist to express this without \"dropping\" provenance. \r\n\r\n- What's Problematic (And Might Be Impossible)?\r\n  - [ ] High-bit Tagging - rustc::ty does this because it makes common addressing modes Free Untagging Realestate\r\n     - Technically this is \"fine\" but CHERI might get upset about it, needs investigation.\r\n  - [ ] Pointer Compression - V8 and JVM like compressing pointers, involving massive truncations.\r\n     - Can a Sufficiently Smart Union handle this?\r\n  - [ ] Unrestricted XOR-list - XORing pointers to make an even more jacked up linked list \r\n     - You must allocate all your nodes in a Vec/Arena to be able to reconstitute ptrs. At that point, use indices.\r\n\r\n- APIs We Want To Add/Change?\r\n  - A lot of uses of .addr() are for alignment checks, `.is_aligned()`, `.is_aligned_to(usize)`?\r\n  - An API to make ZST alloc forging explicit, `exists_zst(usize)`?\r\n  - `.addr()` should arguably work on a DST, if you use `.addr()` you are ostensibly saying \"I know this doesn't roundtrip\"\r\n  - Explicit conveniences for low-bit tagging? `.with_tag(TAG)`?\r\n  - `expose_addr`/`from_exposed_addr` are slightly unfortunate names since it's not the *address* that gets exposed, it's the *provenance*. What would be better names? Please discuss [on Zulip](https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/Strict.20provenance.20naming.20bikeshed).\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/95228/reactions", "total_count": 133, "+1": 19, "-1": 0, "laugh": 0, "hooray": 15, "confused": 1, "heart": 60, "rocket": 8, "eyes": 30}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/95228/timeline", "performed_via_github_app": null, "state_reason": null}