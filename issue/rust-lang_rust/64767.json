{"url": "https://api.github.com/repos/rust-lang/rust/issues/64767", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/64767/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/64767/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/64767/events", "html_url": "https://github.com/rust-lang/rust/issues/64767", "id": 498375245, "node_id": "MDU6SXNzdWU0OTgzNzUyNDU=", "number": 64767, "title": "move of mutably borrowed content results in a 'use-after-move' bug", "user": {"login": "mversic", "id": 45123125, "node_id": "MDQ6VXNlcjQ1MTIzMTI1", "avatar_url": "https://avatars.githubusercontent.com/u/45123125?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mversic", "html_url": "https://github.com/mversic", "followers_url": "https://api.github.com/users/mversic/followers", "following_url": "https://api.github.com/users/mversic/following{/other_user}", "gists_url": "https://api.github.com/users/mversic/gists{/gist_id}", "starred_url": "https://api.github.com/users/mversic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mversic/subscriptions", "organizations_url": "https://api.github.com/users/mversic/orgs", "repos_url": "https://api.github.com/users/mversic/repos", "events_url": "https://api.github.com/users/mversic/events{/privacy}", "received_events_url": "https://api.github.com/users/mversic/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2019-09-25T15:51:41Z", "updated_at": "2019-09-25T16:19:08Z", "closed_at": "2019-09-25T16:14:33Z", "author_association": "NONE", "active_lock_reason": null, "body": "Having played around with rust I encountered something I consider to be violating rust's ownership rules and manifests as a dreaded _use-after-move_ bug. \r\n\r\nI managed to reduce the error to the next example of a linked list where use-after-move manifests as an endless loop. Maybe an example can be made where this bug results in some variant of the **SegmentationFault** so the priority of this issue could be very high.\r\n```\r\nuse std::fmt::Debug;\r\n\r\ntype Link<T> = Option<Box<Node<T>>>;\r\n\r\nstruct Node<T> {\r\n    data: T,\r\n    next: Link<T>,\r\n}\r\n\r\nstruct List<T> {\r\n    head: Link<T>,\r\n}\r\n\r\nimpl<T> Node<T> {\r\n    fn new(data: T, next: Link<T>) -> Self {\r\n        Node {data, next}\r\n    }\r\n}\r\n\r\nimpl<T> List<T> {\r\n    fn new() -> Self {\r\n        List {head: None}\r\n    }\r\n\r\n    fn push(&mut self, data: T) {\r\n        self.head = Some(Box::new(Node::new(data, self.head.take())));\r\n    }\r\n}\r\n\r\nstruct Iter<'a, T>(Option<&'a Node<T>>);\r\n\r\nimpl<'a, T: Debug> IntoIterator for &'a List<T> {\r\n    type Item = &'a T;\r\n\r\n    type IntoIter = Iter<'a, T>;\r\n    fn into_iter(self) -> Self::IntoIter {\r\n        Iter(self.head.as_ref().map(|n| n.as_ref()))\r\n    }\r\n}\r\n\r\nimpl<'a, T> Iterator for Iter<'a, T> {\r\n    type Item = &'a T;\r\n\r\n    fn next(&mut self) -> Option<Self::Item> {\r\n        if let Some(node) = self.0 {\r\n            if let Some(next) = &node.next {\r\n                self.0 = Some(next.as_ref());\r\n            }\r\n\r\n            return Some(&node.data);\r\n        }\r\n\r\n        None\r\n    }\r\n}\r\n\r\nimpl<T> Drop for List<T> {\r\n    fn drop(&mut self) {\r\n        let mut node = self.head.take();\r\n\r\n        while let Some(n) = node {\r\n            node = n.next;\r\n        }\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let mut list = List::new();\r\n    list.push(42);\r\n\r\n    for e in &list {\r\n        println!(\"List: {:?}\", e);\r\n    }\r\n}\r\n```\r\n\r\n### Compiler bug description\r\nWhen run, this code results in an endless loop. Experienced rustacean will probably notice that this code has a bug in the first line of the implementation of the Iterator trait. On that line there is a move of mutably borrowed content which to my knowledge is violating ownership rules. This bug gives access to the value `self.0`(in the next step of the iteration) after that value was moved. This should be a compile error, and it actually is in all other examples I came up with.\r\n\r\n### Manifestation of the bug (_use-after-move_)\r\nThe bug results in an endless loop since the iterator value is never replaced with `None` to end the iteration. The above implementation of linked list iterator can be fixed by assigning `None` explicitly like: \r\n```\r\nimpl<'a, T> Iterator for Iter<'a, T> {\r\n    type Item = &'a T;\r\n\r\n    fn next(&mut self) -> Option<Self::Item> {\r\n        if let Some(node) = self.0 {\r\n            if let Some(next) = &node.next {\r\n                self.0 = Some(next.as_ref());\r\n            } else {\r\n                self.0 = None;\r\n            }\r\n\r\n            return Some(&node.data);\r\n        }\r\n\r\n        None\r\n    }\r\n}\r\n```\r\nwhich is just a workaround for the compiler bug and wouldn't even be allowed if the compiler bug is fixed. \r\n\r\nor using `Option::take` like: \r\n```\r\nimpl<'a, T> Iterator for Iter<'a, T> {\r\n    type Item = &'a T;\r\n\r\n    fn next(&mut self) -> Option<Self::Item> {\r\n        if let Some(node) = self.0.take() {\r\n            if let Some(next) = &node.next {\r\n                self.0 = Some(next.as_ref());\r\n            }\r\n\r\n            return Some(&node.data);\r\n        }\r\n\r\n        None\r\n    }\r\n}\r\n```\r\nwhich is a proper solution.\r\n\r\n## Meta\r\n```\r\nrustc 1.37.0 (eae3437df 2019-08-13)\r\nbinary: rustc\r\ncommit-hash: eae3437dfe991621e8afdc82734f4a172d7ddf9b\r\ncommit-date: 2019-08-13\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.37.0\r\nLLVM version: 8.0\r\n```", "closed_by": {"login": "mversic", "id": 45123125, "node_id": "MDQ6VXNlcjQ1MTIzMTI1", "avatar_url": "https://avatars.githubusercontent.com/u/45123125?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mversic", "html_url": "https://github.com/mversic", "followers_url": "https://api.github.com/users/mversic/followers", "following_url": "https://api.github.com/users/mversic/following{/other_user}", "gists_url": "https://api.github.com/users/mversic/gists{/gist_id}", "starred_url": "https://api.github.com/users/mversic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mversic/subscriptions", "organizations_url": "https://api.github.com/users/mversic/orgs", "repos_url": "https://api.github.com/users/mversic/repos", "events_url": "https://api.github.com/users/mversic/events{/privacy}", "received_events_url": "https://api.github.com/users/mversic/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/64767/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/64767/timeline", "performed_via_github_app": null, "state_reason": "completed"}