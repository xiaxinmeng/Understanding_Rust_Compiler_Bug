{"url": "https://api.github.com/repos/rust-lang/rust/issues/105266", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/105266/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/105266/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/105266/events", "html_url": "https://github.com/rust-lang/rust/issues/105266", "id": 1475084180, "node_id": "I_kwDOAAsO6M5X6_-U", "number": 105266, "title": "Iterator's .sum() and .product() should mention that they work on iterators over Result<T,E> and Option<T>", "user": {"login": "mday64", "id": 39891728, "node_id": "MDQ6VXNlcjM5ODkxNzI4", "avatar_url": "https://avatars.githubusercontent.com/u/39891728?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mday64", "html_url": "https://github.com/mday64", "followers_url": "https://api.github.com/users/mday64/followers", "following_url": "https://api.github.com/users/mday64/following{/other_user}", "gists_url": "https://api.github.com/users/mday64/gists{/gist_id}", "starred_url": "https://api.github.com/users/mday64/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mday64/subscriptions", "organizations_url": "https://api.github.com/users/mday64/orgs", "repos_url": "https://api.github.com/users/mday64/repos", "events_url": "https://api.github.com/users/mday64/events{/privacy}", "received_events_url": "https://api.github.com/users/mday64/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 431251592, "node_id": "MDU6TGFiZWw0MzEyNTE1OTI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-docs", "name": "A-docs", "color": "f7e101", "default": false, "description": "Area: documentation for any part of the project, including the compiler, standard library, and tools"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2022-12-04T18:53:41Z", "updated_at": "2023-03-21T14:32:56Z", "closed_at": "2023-03-21T14:32:56Z", "author_association": "NONE", "active_lock_reason": null, "body": "### Summary\r\nIt would be helpful if `Iterator`'s `.sum()` method would explicitly document that it can sum an iterator of `Result<T,E>` and produce a `Result<T,E>` as output, and that it stops consuming the iterator when it hits the first error.  To compound things, my mental model was a little off, and I didn't understand the compiler's diagnostics well enough to get nudged in the right direction.\r\n\r\nLikewise, it would be helpful to also document summing an `Option<T>`.  Similarly, for `.product()` and `Result<T,E>` or `Option<T>`.  I'm not sure if there are other Iterator methods that also handle `Result` and `Option` similarly.\r\n\r\n### Steps to Reproduce\r\nIf I go to the standard library documentation at <https://doc.rust-lang.org/std/index.html>, and then search for `sum`, then click on `std::iter::Iterator::sum` it gives an example of summing some integers.  It would be helpful if this part of the documentation mentioned that you can also sum an iterator of `Result<T,E>`, which produces a `Result<T,E>` where the `Ok()` variant contains the sum (if there were no errors), or the `Err()` variant contains the first error.  It would also be helpful to mention that it stops consuming the iterator once it encounters the first error.\r\n\r\nIf I click on `Sum` in the declaration, it takes me to documentation of the `Sum` trait.  In the Implementors section, there is a long list of implementations for various numeric types, their `Wrapping` variants, their references, `Wrapping` variants of references, SIMD stuff.  At that point, my eyes glazed over, and I missed this one buried near the end:\r\n```Rust\r\n\timpl<T, U, E> Sum<Result<U, E>> for Result<T, E>\r\n\twhere\r\n\t    T: Sum<U>\r\n```\r\nIf I click the \"source\" link to the right of the above impl, the doc comments describe the behavior, and there is even an example (yay!).  As far as I can tell, those doc comments aren't rendered on the documentation page for either the `Sum` trait, or the `.sum()` method.  It would probably be helpful to render them on the page for the `Sum` trait, and add a sentence or two to the documentation for `.sum()` (perhaps link to the `Sum` documentation if you don't want to repeat it all).\r\n\r\n### Background\r\nThis came about from the Advent of Code 2022, Day 1.  See <https://adventofcode.com/2022/day/1>.  The input is some text with groups of integers.  The groups are separated by blank lines.  Start by reading the input:\r\n\r\n```Rust\r\n    let input = std::fs::read_to_string(\"src/bin/day01/input.txt\")\r\n        .expect(\"Can't open input.txt\");\r\n```\r\n\r\nNow build a Vec<u32> where each element is the sum of the numbers in one group:\r\n\r\n```Rust\r\n    let mut elf_totals: Vec<u32> = input.split(\"\\n\\n\").map(|s|\r\n        // s is the numbers for one elf\r\n        s.split_terminator('\\n').map(|n|\r\n            // n is one number for the current elf\r\n            n.parse::<u32>().expect(\"invalid number\")\r\n        ).sum()\r\n    ).collect();\r\n```\r\n\r\nThat works, but I'd like to do a better job of handling errors.  First step is to change the function (`main` in this case) to return a `Result<(), Box<dyn Error>>`, and add an `OK(())` at the end of the function.\r\n\r\nNow, let's replace the .expect(...) with a question mark.  My intent (for now) is to return from the function, not just the closure.  I'm using VSCode with rust-analyzer.  In the Problems tab, it says:\r\n```\r\n    the `?` operator can only be used in a closure that returns `Result` or `Option`...\r\n    the trait `FromResidual<Result<Infallible, ParseIntError>>` is not implemented for `u32`\r\n    main.rs[Ln 8, Col 38]: this function should return `Result` or `Option` to accept `?`\r\n```\r\nMy first thought is that my function (main) *does* return Result.  Oh, that last message is talking about the closure I'm passing to `.map()`.  OK, let's try `return` instead:\r\n```Rust\r\n            let x = n.parse::<u32>();\r\n            if let Err(e) = x {\r\n                return Err(e);\r\n            } else {\r\n                x.unwrap()\r\n            }\r\n```\r\nLots of errors.  First one says \"closure bodies that contain statements must be surrounded by braces.\"  I can do that (there's even a Quick Fix that adds them for me!).  Now there are only 3 errors:\r\n```\r\n\tthe trait bound `u32: Sum<Result<_, ParseIntError>>` is not satisfied\r\n\tthe following other types implement trait `Sum<A>`:\r\n\t\t...\r\n\texpected Result<{unknown}, ParseIntError>, found u32\r\n\tmismatched types\r\n\texpected enum `Result<_, ParseIntError>`\r\n\tfound type `u32`\r\n```\r\nFor that last error, it suggests wrapping the expression in `Ok()`.  Let the Quick Fix do that.  It wrapped the entire if-else inside `Ok()`.  That still leaves the first error message:\r\n```\r\n\tthe trait bound `u32: Sum<Result<_, ParseIntError>>` is not satisfied\r\n\tthe following other types implement trait `Sum<A>`:\r\n\t\t...\r\n```\r\nIt never occurred to me that the closure could return a `Result`.  After all, I'm trying to sum integers, so I assume my closure has to return an integer.  That return statement I just added is returning from the _closure_, not the _function_.  I go off to Google ways to return from a function from within a closure.  I didn't find anything that looked promising.\r\n\r\nI take a different approach.  Instead of using nested closures, I use nested `for` loops.  Since it's not inside a closure any more, I can use the question mark to return from the function:\r\n```Rust\r\n    let mut elf_totals: Vec<u32> = Vec::new();\r\n    for group in input.split(\"\\n\\n\") {\r\n        let mut total: u32 = 0;\r\n        for line in group.lines() {\r\n            total += line.parse::<u32>()?;\r\n        }\r\n        elf_totals.push(total);\r\n    }\r\n```\r\nThat works, but there's got to be a better way.  I figured out how to write a function that sums an iterator of `Result<T,E>` and produces a `Result<T,E>`, and short circuits on the first error.  I didn't know that `.sum()` could already do this.\r\n\r\n```Rust\r\nfn try_sum<I,T,E>(iter: I) -> Result<T,E>\r\n    where T: Default + AddAssign, I: Iterator<Item=Result<T,E>>\r\n{\r\n    let mut result = T::default();\r\n    for x in iter {\r\n        result += x?;\r\n    }\r\n    Ok(result)\r\n}\r\n```\r\nI figured out how to turn that into a generic trait so I could use it as a method (like the methods in the Itertools trait).  That took a bunch of fiddling with generics and bounds, but I was able to work through it (in large part because the diagnostics nudged me in the right direction).  The final piece was figuring out how to write the `impl` block so I could replace `.sum()` with my new `.try_sum()` method.\r\n\r\n```Rust\r\ntrait TrySum: Iterator {\r\n    fn try_sum<T,E>(&mut self) -> Result<T,E>\r\n    where   Self: Iterator<Item=Result<T,E>>,\r\n            T: Default + AddAssign,\r\n    {\r\n        let mut answer = T::default();\r\n        for x in self {\r\n            answer += x?;\r\n        }\r\n        Ok(answer)\r\n    }\r\n}\r\n\r\nimpl<T> TrySum for T where T: Iterator {}\r\n```\r\n\r\nI knew that `.collect()` could transform an iterator over `Result<T,E>` into `Result<Vec<T>, E>`, and therefore I can put a question mark or `.expect()` after `.collect()`.\r\n```Rust\r\n    let mut elf_totals = input.split(\"\\n\\n\").map(|s| {\r\n        // s is the numbers for one elf\r\n        s.split_terminator('\\n').map(|n|\r\n            // n is one number for the current elf\r\n            n.parse::<u32>()\r\n        ).try_sum()\r\n    }).collect::<Result<Vec<u32>,_>>()?;\r\n```\r\nMy implementation required the type I'm summing to implement `Default` and `AddAssign`.  Can I get rid of the need for `Default`?  Should I depend on `Add` instead of `AddAssign`?  I start digging through the implementation of `.sum()` in the standard library to see if it does anything special that my implementation should.  I ended up finding that `sum` (and other methods, like `product`) share a general purpose mechanism to handle iteration over `Result<T,E>.`  That means that `.sum()` already does what my `.try_sum()` does.  I replace `.try_sum()` with `.sum()` and ... it works!", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/105266/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/105266/timeline", "performed_via_github_app": null, "state_reason": "completed"}