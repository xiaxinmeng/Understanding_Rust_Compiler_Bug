{"url": "https://api.github.com/repos/rust-lang/rust/issues/57965", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/57965/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/57965/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/57965/events", "html_url": "https://github.com/rust-lang/rust/issues/57965", "id": 404082916, "node_id": "MDU6SXNzdWU0MDQwODI5MTY=", "number": 57965, "title": "Make the `unconditional_recursion` lint work across function calls", "user": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 235137, "node_id": "MDU6TGFiZWwyMzUxMzc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-lint", "name": "A-lint", "color": "f7e101", "default": false, "description": "Area: Lints (warnings about flaws in source code) such as unused_mut."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 256133398, "node_id": "MDU6TGFiZWwyNTYxMzMzOTg=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-mir", "name": "A-mir", "color": "f7e101", "default": false, "description": "Area: Mid-level IR (MIR) - https://blog.rust-lang.org/2016/04/19/MIR.html"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2019-01-29T01:34:58Z", "updated_at": "2022-04-21T16:38:19Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "The lint for unconditional recursion currently only handles the case where a function calls itself *directly*, which means that many useful cases are missed:\r\n\r\n* https://github.com/rust-lang/rust/issues/40437\r\n* https://github.com/rust-lang/rust/issues/57633\r\n* https://github.com/rust-lang/rust/issues/57299\r\n* https://github.com/rust-lang/rust/issues/45838\r\n* (+ lots of duplicates)\r\n\r\nI've talked to @eddyb about this and it seems like they've come up with a workable solution that might also benefit other MIR passes:\r\n\r\n<details>\r\n  <summary>IRC log</summary>\r\n  <p>\r\n\r\n```\r\n22:32 <eddyb> anyway, consider building a callgraph where you're only considering calls that are unconditional to some extent, i.e. if the function returns, they *must* have happened\r\n22:32 <eddyb> then just fine cycles in it\r\n22:32 <eddyb> *find\r\n22:33 <eddyb> the current analysis is most likely that but limited to self-cycles\r\n22:33 <jschievink> hmm, yeah. sounds like I need to determine postdominators then\r\n22:33 <eddyb> jschievink: the monomorphization collector is actually perfect for this - or would be, if it recorded the source of a call :P\r\n22:34 <eddyb> but, like, you do care about call targets post-Instance::resolve\r\n22:34 <eddyb> (I just had an idea, heh)\r\n22:34 <eddyb> (an optimization for the monomorphization collector)\r\n22:36 <jschievink> so you want to run the lint on monomorphized MIR instead?\r\n22:36 <eddyb> jschievink: the lint already kind of does this by taking parameters into account, it's just polymorphically doing it\r\n22:37 <eddyb> (\"monomorphized MIR\" is not a thing that is actually stored anywhere, we monomorphize on the fly)\r\n22:37 <jschievink> yeah, I didn't know the existing lint did that\r\n22:37 <jschievink> it seemed so limited\r\n22:38 <eddyb> I mean, all it does is it knows whether something can refer back to itself despite being a trait impl method\r\n22:38 <eddyb> you only need to consider partial/full monomorphization if you look at the whole callgraph\r\n22:38 <eddyb> to be able to construct it in the first place, I mean\r\n22:39 <eddyb> basically you should \"expand\" callers of trait methods, transitively, until nothing actually can still hit trait dispatch\r\n22:39 <eddyb> so it's actually the opposite of the collector, lol\r\n22:40 <jschievink> wow\r\n22:40 <eddyb> since you want to demand as little specificity as possible, while still ending up with a callgraph with only function bodies (and, well, dynamic dispatch)\r\n22:41 <eddyb> so e.g. `foo<T>` calls `bar<Vec<T>>` and `bar<X>` calls `X::default()`\r\n22:43 <eddyb> so you start with `<Self as Default>::default`, unknown `Self`, look at its callers (which hopefully is easy on a graph), and find that `Self` could be `X` of `bar<X>`\r\n22:44 <eddyb> you recurse, with `bar<X>`, unknown `X`, and in its callers you find that `X` could be `Vec<T>` from `foo<T>`\r\n22:45 <eddyb> therefore, `Self` could be `Vec<_>`, and that's the first type which is enough to resolve the implementation (of `<Vec<_> as Default>::default`)\r\n22:46 <eddyb> this means that you can ignore the fact that `foo<T>` has even a million callers, all with different `T`, and not expand `bar` or `Default::default` further (especially since `Vec<T>: Default` doesn't require `T: Default`)\r\n22:46 <eddyb> jschievink: this seems like a viable strategy for any callgraph-based analysis, not just infinite recursion lints\r\n22:47 <eddyb> maybe someone should note it somewhere, before I forget :P\r\n22:47  * eddyb does need to get back to work though\r\n22:47 <jschievink> ah, so you could use the same approach in the collector?\r\n22:49 <eddyb> jschievink: uhhhh\r\n22:49 <eddyb> jschievink: the collector actually needs to monomorphize a million `foo`, `bar` and `<Vec<_> as Default>::default` (even if we might alleviate this in the future)\r\n22:50 <eddyb> jschievink: hmm maybe you can do this collection in the forward direction too, with a bit of precomputation\r\n22:53 <eddyb> jschievink: ah, no, it doesn't work forward because you'd need to actually gather the *transitive* set of callers\r\n22:53 <eddyb> i.e. know that `foo<T>` calls `Vec<T>::default`, transitively\r\n22:57 <jschievink> how would this analysis start, given that I need the call graph in the first place in order to find all callers of a method?\r\n22:58 <eddyb> jschievink: at the end of the day, monomorphization wants to know all the static call targets (potentially ignoring some type parameters?), whereas this callgraph analysis thing wants to know all the definitions involved, with no finer granularity. they could be related but I have a hard time thinking about it\r\n22:58 <eddyb> jschievink: you can build a callgraph that refers to `Default::default`\r\n23:00 <jschievink> ah, so you'd build the callgraph \"normally\" and then expand references to trait methods?\r\n23:00 <eddyb> you should mark it as unresolved though, to distinguish it from \"default trait method body\" (which has the same `DefId`)\r\n23:00 <eddyb> jschievink: yupp\r\n23:00 <eddyb> you'd build the callgraph fully generic, perhaps with Substs on the edges\r\n```\r\n  </p>\r\n\r\n</details>\n\n<!-- TRIAGEBOT_START -->\n\n<!-- TRIAGEBOT_ASSIGN_START -->\n\n<!-- TRIAGEBOT_ASSIGN_DATA_START$${\"user\":\"jonas-schievink\"}$$TRIAGEBOT_ASSIGN_DATA_END -->\n\n<!-- TRIAGEBOT_ASSIGN_END -->\n<!-- TRIAGEBOT_END -->", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/57965/reactions", "total_count": 5, "+1": 4, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 1, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/57965/timeline", "performed_via_github_app": null, "state_reason": null}