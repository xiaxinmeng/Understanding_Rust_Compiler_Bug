{"url": "https://api.github.com/repos/rust-lang/rust/issues/47490", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/47490/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/47490/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/47490/events", "html_url": "https://github.com/rust-lang/rust/issues/47490", "id": 288876923, "node_id": "MDU6SXNzdWUyODg4NzY5MjM=", "number": 47490, "title": "missed optimization: enum move of the active variant", "user": {"login": "gnzlbg", "id": 904614, "node_id": "MDQ6VXNlcjkwNDYxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/904614?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gnzlbg", "html_url": "https://github.com/gnzlbg", "followers_url": "https://api.github.com/users/gnzlbg/followers", "following_url": "https://api.github.com/users/gnzlbg/following{/other_user}", "gists_url": "https://api.github.com/users/gnzlbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/gnzlbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gnzlbg/subscriptions", "organizations_url": "https://api.github.com/users/gnzlbg/orgs", "repos_url": "https://api.github.com/users/gnzlbg/repos", "events_url": "https://api.github.com/users/gnzlbg/events{/privacy}", "received_events_url": "https://api.github.com/users/gnzlbg/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-01-16T11:40:59Z", "updated_at": "2020-04-20T22:53:32Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "This code performs a memcpy of 2064 bytes when 32 bytes would suffice. [See it live @godbolt](https://godbolt.org/g/4A7jmF):\r\n\r\n```rust\r\n#![feature(test)] \r\n#![feature(rustc_private)]\r\nextern crate smallvec;\r\nextern crate test;\r\nuse smallvec::SmallVec;\r\n\r\n#[inline(never)]\r\nfn clobber<T>(x: T) { test::black_box(x); }\r\n\r\npub fn bar() { \r\n    // Capacity for 256 `f64`s on the stack.\r\n    // The stack size of `SmallVec` is 256 * 8 + 8 (len) + 8 (discriminant) = 2064 bytes\r\n    let mut v = SmallVec::<[f64; 256]>::new();\r\n    let size = ::std::mem::size_of::<SmallVec<[f64; 256]>>();\r\n    clobber(size);\r\n    for _ in 0..300 {\r\n        v.push(3.14);\r\n    }\r\n    // The vector reallocates to the heap, the size of the active variant\r\n    // is 8 (len) + 8 (capacity) + 8 (ptr) + 8 (discriminant) = 32 bytes\r\n    clobber(v); // memcpy's 2064 bytes instead of 32bytes...\r\n}\r\n```\r\n\r\ngenerates this assembly for the second call to `clobber`:\r\n\r\n```asm\r\n  mov edx, 2064\r\n  mov rdi, rbx\r\n  call memcpy@PLT\r\n  mov rdi, rbx\r\n  call example::clobber\r\n```\r\n\r\nThe layout of `SmallVec` is:\r\n\r\n```rust\r\npub struct SmallVec<A: Array> {\r\n    len: usize,\r\n    data: SmallVecData<A>,\r\n}\r\nenum SmallVecData<A: Array> {\r\n    Inline { array: A },\r\n    Heap { ptr: *mut A::Item, capacity: usize },\r\n}\r\n```\r\n\r\n> Note: If `NonZero` would be stable, `SmallVecData` could use it here to remove the 8 bytes of the discriminant. \r\n\r\nSo I guess that the problem is that moving an enum just naively generates a memcpy of the whole enum.  I think this is a good default for small enums. When enums get large, they might contain many small variants, and maybe some large ones. \r\n\r\nI don't know if there is an optimal way to solve this problem since adding branches to `memcpy` only some variants might incur a performance cost (unless LLVM knows the value of the active variants and can optimize the branches away). \r\n\r\nWe should probably at least always `memcpy` small enums up to some size (16bytes? 256 bytes?) and for larger enums have some heuristic like:\r\n\r\n- are all variants approximately equally sized? Then just `memcpy` the whole enum\r\n- are some variants small and some variants large? How many \"size classes\" are there? Generate as few branches as possible here (ideally two, one for small and one for large variants, but might require more). \r\n\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/47490/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/47490/timeline", "performed_via_github_app": null, "state_reason": null}