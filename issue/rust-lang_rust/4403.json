{"url": "https://api.github.com/repos/rust-lang/rust/issues/4403", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/4403/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/4403/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/4403/events", "html_url": "https://github.com/rust-lang/rust/issues/4403", "id": 9816022, "node_id": "MDU6SXNzdWU5ODE2MDIy", "number": 4403, "title": "Literal vec notation is less efficient than vec::from_elem", "user": {"login": "bstrie", "id": 865233, "node_id": "MDQ6VXNlcjg2NTIzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstrie", "html_url": "https://github.com/bstrie", "followers_url": "https://api.github.com/users/bstrie/followers", "following_url": "https://api.github.com/users/bstrie/following{/other_user}", "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions", "organizations_url": "https://api.github.com/users/bstrie/orgs", "repos_url": "https://api.github.com/users/bstrie/repos", "events_url": "https://api.github.com/users/bstrie/events{/privacy}", "received_events_url": "https://api.github.com/users/bstrie/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234956, "node_id": "MDU6TGFiZWwyMzQ5NTY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-codegen", "name": "A-codegen", "color": "f7e101", "default": false, "description": "Area: Code generation"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2013-01-09T18:43:04Z", "updated_at": "2013-05-19T20:15:26Z", "closed_at": "2013-05-19T20:15:26Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I'm updating a benchmark and noting performance differences. Here's one version (perlin-mut.rs):\n\n```\nstruct Vec2 {\n    x: f32,\n    y: f32,\n}\n\nfn lerp(a: f32, b: f32, v: f32) -> f32 {\n    a * (1f32 - v) + b * v\n}\n\nfn smooth(v: f32) -> f32 {\n    v * v * (3f32 - 2f32 * v)\n}\n\nfn random_gradient(r: rand::Rng) -> Vec2 {\n    let v = r.gen_float() * float::consts::pi * 2.0;\n    Vec2{\n        x: float::cos(v) as f32,\n        y: float::sin(v) as f32,\n    }\n}\n\nfn gradient(orig: Vec2, grad: Vec2, p: Vec2) -> f32 {\n    let sp = Vec2{x: p.x - orig.x, y: p.y - orig.y};\n    grad.x * sp.x + grad.y + sp.y\n}\n\nstruct Noise2DContext {\n    rgradients: ~[Vec2],\n    permutations: ~[int],\n}\n\nfn Noise2DContext() -> ~Noise2DContext {\n    let r = rand::Rng();\n    let rgradients = do vec::from_fn(256) |_i| { random_gradient(r) };\n    let mut permutations = do vec::from_fn(256) |i| { i as int };\n    r.shuffle_mut(permutations);\n\n    ~Noise2DContext{\n        rgradients: move rgradients,\n        permutations: move permutations,\n    }\n}\n\nimpl Noise2DContext {\n    fn get_gradient(x: int, y: int) -> Vec2 {\n        let idx = self.permutations[x & 255] + self.permutations[y & 255];\n        self.rgradients[idx & 255]\n    }\n\n    fn get_gradients(gradients: &[mut Vec2 * 4], origins: &[mut Vec2 * 4], x: f32, y: f32) {\n        let x0f = float::floor(x as libc::c_double) as f32;\n        let y0f = float::floor(y as libc::c_double) as f32;\n        let x0 = x0f as int;\n        let y0 = y0f as int;\n        let x1 = x0 + 1;\n        let y1 = y0 + 1;\n\n        gradients[0] = self.get_gradient(x0, y0);\n        gradients[1] = self.get_gradient(x1, y0);\n        gradients[2] = self.get_gradient(x0, y1);\n        gradients[3] = self.get_gradient(x1, y1);\n\n        origins[0] = Vec2{x: x0f + 0f32, y: y0f + 0f32};\n        origins[1] = Vec2{x: x0f + 1f32, y: y0f + 0f32};\n        origins[2] = Vec2{x: x0f + 0f32, y: y0f + 1f32};\n        origins[3] = Vec2{x: x0f + 1f32, y: y0f + 1f32};\n    }\n\n    fn get(x: f32, y: f32) -> f32 {\n        let p = Vec2{x: x, y: y};\n        let gradients: [mut Vec2 * 4] = [mut\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n        ];\n        let origins: [mut Vec2 * 4] = [mut\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n        ];\n        self.get_gradients(&gradients, &origins, x, y);\n        let v0 = gradient(origins[0], gradients[0], p);\n        let v1 = gradient(origins[1], gradients[1], p);\n        let v2 = gradient(origins[2], gradients[2], p);\n        let v3 = gradient(origins[3], gradients[3], p);\n        let fx = smooth(x - origins[0].x);\n        let vx0 = lerp(v0, v1, fx);\n        let vx1 = lerp(v2, v3, fx);\n        let fy = smooth(y - origins[0].y);\n        lerp(vx0, vx1, fy)\n    }\n}\n\nfn main() {\n    let symbols = [\" \", \"\u2591\", \"\u2592\", \"\u2593\", \"\u2588\", \"\u2588\"];\n    let mut pixels = vec::from_elem(256*256, 0f32);\n    let n2d = Noise2DContext();\n    for int::range(0, 100) |_i| {\n        for int::range(0, 256) |y| {\n            for int::range(0, 256) |x| {\n                let v = n2d.get(\n                    x as f32 * 0.1f32,\n                    y as f32 * 0.1f32\n                ) * 0.5f32 + 0.5f32;\n                pixels[y*256+x] = v;\n            };\n        };\n    };\n\n    for int::range(0, 256) |y| {\n        for int::range(0, 256) |x| {\n            io::print(symbols[pixels[y*256+x] / 0.2f32 as int]);\n        }\n        io::println(\"\");\n    }\n}\n```\n\nHere's a version that's had the following line altered: `let mut pixels = vec::from_elem(256*256, 0f32);` becomes `let mut pixels = ~[0f32, ..65536];`. For reproducibility, here's the whole file (perlin-mut-literal-tilde.rs):\n\n```\nstruct Vec2 {\n    x: f32,\n    y: f32,\n}\n\nfn lerp(a: f32, b: f32, v: f32) -> f32 {\n    a * (1f32 - v) + b * v\n}\n\nfn smooth(v: f32) -> f32 {\n    v * v * (3f32 - 2f32 * v)\n}\n\nfn random_gradient(r: rand::Rng) -> Vec2 {\n    let v = r.gen_float() * float::consts::pi * 2.0;\n    Vec2{\n        x: float::cos(v) as f32,\n        y: float::sin(v) as f32,\n    }\n}\n\nfn gradient(orig: Vec2, grad: Vec2, p: Vec2) -> f32 {\n    let sp = Vec2{x: p.x - orig.x, y: p.y - orig.y};\n    grad.x * sp.x + grad.y + sp.y\n}\n\nstruct Noise2DContext {\n    rgradients: ~[Vec2],\n    permutations: ~[int],\n}\n\nfn Noise2DContext() -> ~Noise2DContext {\n    let r = rand::Rng();\n    let rgradients = do vec::from_fn(256) |_i| { random_gradient(r) };\n    let mut permutations = do vec::from_fn(256) |i| { i as int };\n    r.shuffle_mut(permutations);\n\n    ~Noise2DContext{\n        rgradients: move rgradients,\n        permutations: move permutations,\n    }\n}\n\nimpl Noise2DContext {\n    fn get_gradient(x: int, y: int) -> Vec2 {\n        let idx = self.permutations[x & 255] + self.permutations[y & 255];\n        self.rgradients[idx & 255]\n    }\n\n    fn get_gradients(gradients: &[mut Vec2 * 4], origins: &[mut Vec2 * 4], x: f32, y: f32) {\n        let x0f = float::floor(x as libc::c_double) as f32;\n        let y0f = float::floor(y as libc::c_double) as f32;\n        let x0 = x0f as int;\n        let y0 = y0f as int;\n        let x1 = x0 + 1;\n        let y1 = y0 + 1;\n\n        gradients[0] = self.get_gradient(x0, y0);\n        gradients[1] = self.get_gradient(x1, y0);\n        gradients[2] = self.get_gradient(x0, y1);\n        gradients[3] = self.get_gradient(x1, y1);\n\n        origins[0] = Vec2{x: x0f + 0f32, y: y0f + 0f32};\n        origins[1] = Vec2{x: x0f + 1f32, y: y0f + 0f32};\n        origins[2] = Vec2{x: x0f + 0f32, y: y0f + 1f32};\n        origins[3] = Vec2{x: x0f + 1f32, y: y0f + 1f32};\n    }\n\n    fn get(x: f32, y: f32) -> f32 {\n        let p = Vec2{x: x, y: y};\n        let gradients: [mut Vec2 * 4] = [mut\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n        ];\n        let origins: [mut Vec2 * 4] = [mut\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n        ];\n        self.get_gradients(&gradients, &origins, x, y);\n        let v0 = gradient(origins[0], gradients[0], p);\n        let v1 = gradient(origins[1], gradients[1], p);\n        let v2 = gradient(origins[2], gradients[2], p);\n        let v3 = gradient(origins[3], gradients[3], p);\n        let fx = smooth(x - origins[0].x);\n        let vx0 = lerp(v0, v1, fx);\n        let vx1 = lerp(v2, v3, fx);\n        let fy = smooth(y - origins[0].y);\n        lerp(vx0, vx1, fy)\n    }\n}\n\nfn main() {\n    let symbols = [\" \", \"\u2591\", \"\u2592\", \"\u2593\", \"\u2588\", \"\u2588\"];\n    //let mut pixels = vec::from_elem(256*256, 0f32);\n    let mut pixels = ~[0f32, ..65536];\n    let n2d = Noise2DContext();\n    for int::range(0, 100) |_i| {\n        for int::range(0, 256) |y| {\n            for int::range(0, 256) |x| {\n                let v = n2d.get(\n                    x as f32 * 0.1f32,\n                    y as f32 * 0.1f32\n                ) * 0.5f32 + 0.5f32;\n                pixels[y*256+x] = v;\n            };\n        };\n    };\n\n    for int::range(0, 256) |y| {\n        for int::range(0, 256) |x| {\n            io::print(symbols[pixels[y*256+x] / 0.2f32 as int]);\n        }\n        io::println(\"\");\n    }\n}\n```\n\nBoth programs were compiled with `rustc --opt-level=3` and profiled as follows:\n\n```\n$ (perf stat -r 10 perlin-mut) 2> mut3.txt\n$ (perf stat -r 10 perlin-mut-literal-tilde) 2> mut-literal-tilde2.txt\n```\n\nmut3.txt:\n\n```\n Performance counter stats for 'perlin-mut' (10 runs):\n\n    1346.376055  task-clock-msecs         #      0.982 CPUs    ( +-   0.136% )\n             74  context-switches         #      0.000 M/sec   ( +-   4.013% )\n              1  CPU-migrations           #      0.000 M/sec   ( +-   9.091% )\n            738  page-faults              #      0.001 M/sec   ( +-   0.047% )\n   166000485913  cycles                   # 123294.295 M/sec   ( +-   3.857% )\n   166000485913  instructions             #      1.000 IPC     ( +-   3.857% )\n   166000485913  branches                 # 123294.295 M/sec   ( +-   3.857% )\n   166000485913  branch-misses            #    100.000 %       ( +-   3.857% )\n   166000485913  cache-references         # 123294.295 M/sec   ( +-   3.857% )\n   166000485913  cache-misses             # 123294.295 M/sec   ( +-   3.857% )\n\n    1.371346350  seconds time elapsed   ( +-   0.181% )\n```\n\nmut-literal-tilde2.txt:\n\n```\n Performance counter stats for 'perlin-mut-literal-tilde' (10 runs):\n\n    1376.394325  task-clock-msecs         #      0.986 CPUs    ( +-   0.145% )\n            111  context-switches         #      0.000 M/sec   ( +-   8.048% )\n              1  CPU-migrations           #      0.000 M/sec   ( +-   9.091% )\n            738  page-faults              #      0.001 M/sec   ( +-   0.036% )\n   238800181546  cycles                   # 173496.924 M/sec   ( +-   7.465% )\n   238800181546  instructions             #      1.000 IPC     ( +-   7.465% )\n   238800181546  branches                 # 173496.924 M/sec   ( +-   7.465% )\n   238800181546  branch-misses            #    100.000 %       ( +-   7.465% )\n   238800181546  cache-references         # 173496.924 M/sec   ( +-   7.465% )\n   238800181546  cache-misses             # 173496.924 M/sec   ( +-   7.465% )\n\n    1.395384346  seconds time elapsed   ( +-   0.311% )\n```\n\nIt's not a large difference, but intuitively I feel that the literal version ought to actually be much faster than the builder function; @graydon feels the same:\n\n```\n <@graydon> the literal should be much faster. if we're doing our work properly\n            it should be malloc + memcpy from const. which should then hit the\n            SSE/AVX paths and go very fast indeed.\n```\n\nI'm also worried that any slight disadvantage to using literals will result in horrifying best-practices such as \"use `vec::from_elem` instead of the literal vector syntax\".\n", "closed_by": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/4403/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/4403/timeline", "performed_via_github_app": null, "state_reason": "completed"}