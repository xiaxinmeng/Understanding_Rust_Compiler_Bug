{"url": "https://api.github.com/repos/rust-lang/rust/issues/80416", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/80416/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/80416/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/80416/events", "html_url": "https://github.com/rust-lang/rust/issues/80416", "id": 775074769, "node_id": "MDU6SXNzdWU3NzUwNzQ3Njk=", "number": 80416, "title": "Iterator-based approach performs 10x worse than manual implementation", "user": {"login": "bradleyharden", "id": 15747147, "node_id": "MDQ6VXNlcjE1NzQ3MTQ3", "avatar_url": "https://avatars.githubusercontent.com/u/15747147?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bradleyharden", "html_url": "https://github.com/bradleyharden", "followers_url": "https://api.github.com/users/bradleyharden/followers", "following_url": "https://api.github.com/users/bradleyharden/following{/other_user}", "gists_url": "https://api.github.com/users/bradleyharden/gists{/gist_id}", "starred_url": "https://api.github.com/users/bradleyharden/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bradleyharden/subscriptions", "organizations_url": "https://api.github.com/users/bradleyharden/orgs", "repos_url": "https://api.github.com/users/bradleyharden/repos", "events_url": "https://api.github.com/users/bradleyharden/events{/privacy}", "received_events_url": "https://api.github.com/users/bradleyharden/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 23, "created_at": "2020-12-27T17:13:21Z", "updated_at": "2021-01-04T21:01:24Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "I'm not sure if this qualifies as a bug or not.\r\n\r\nIn short, the following two functions give the same output, but `fft` performs about 10x worse than `fft_manaul`.\r\n\r\n```rust\r\nconst LUT: [i16; 8] = [0, 1, 2, 3, 4, 5, 6, 7];\r\n\r\npub fn fft(samples: &[i16; 16]) -> (i32, i32) {\r\n    let sin = LUT.iter().cycle();\r\n    let cos = LUT.iter().cycle().skip(LUT.len() / 4);\r\n    sin.zip(cos).zip(samples).fold(\r\n        (0, 0), |(mut real, mut imag), ((sin, cos), &sample)| {\r\n            real += sample as i32 * (*cos as i32);\r\n            imag += sample as i32 * (*sin as i32);\r\n            (real, imag)\r\n    })\r\n}\r\n```\r\n\r\n```rust\r\nconst LUT: [i16; 8] = [0, 1, 2, 3, 4, 5, 6, 7];\r\n\r\npub fn fft_manual(samples: &[i16; 16]) -> (i32, i32) {\r\n    const LUT_LEN: usize = LUT.len();\r\n    let mut real = 0;\r\n    let mut imag = 0;\r\n    for i in 0..(samples.len() / LUT_LEN) {\r\n        for j in 0..LUT_LEN {\r\n            let sin = LUT[j];\r\n            let cos = LUT[(j + (LUT_LEN / 4)) % LUT_LEN];\r\n            let sample = samples[i * LUT_LEN + j];\r\n            real += sample as i32 * (cos as i32);\r\n            imag += sample as i32 * (sin as i32);\r\n        }\r\n    }\r\n    (real, imag)\r\n}\r\n```\r\n\r\nI originally ran into this in an embedded context, targeting `thumbv7em-none-eabihf`. The original function took a `GenericArray` and used fixed-point types from the `fixed` crate, but I was able to reproduce the issue using only primitive types targetting `x86_64-pc-windows-msvc`.\r\n\r\nHere are the results of benchmarks from selected `nightly` versions from the past 18 months. The benchmarks were run using the code [here](https://github.com/bradleyharden/fft_iter_bench).\r\n\r\n\r\n| Version | Results |\r\n| -------- | -------- |\r\n| nightly-2020-12-21 | test tests::bench_fft        ... bench:          63 ns/iter (+/- 16) <br> test tests::bench_fft_manual ... bench:           5 ns/iter (+/- 1) |\r\n| nightly-2020-06-01 | test tests::bench_fft        ... bench:          36 ns/iter (+/- 15) <br> test tests::bench_fft_manual ... bench:           4 ns/iter (+/- 2) |\r\n| nightly-2020-01-02 | test tests::bench_fft        ... bench:          45 ns/iter (+/- 20) <br> test tests::bench_fft_manual ... bench:           5 ns/iter (+/- 1) |\r\n| nightly-2019-06-01 <br> (with `#![feature(const_slice_len)]`) | test tests::bench_fft        ... bench:          52 ns/iter (+/- 23) <br> test tests::bench_fft_manual ... bench:           5 ns/iter (+/- 1) |\r\n\r\nI took a look at the output of `cargo asm` for each version. The output of `fft` has 28 branch instructions, while the output of `fft_manual` has none. I guess the compiler is able to completely unroll the loop when it's written manually, but not when it's written using `Iterator`s.\r\n\r\nUnfortunately, this is about the limit of my debugging ability currently. With some guidance, I might be able to do more of the leg work on my own.\r\n\r\nIs this a known/expected performance difference? I hope not. I was really impressed at the elegance of the `Iterator`-based approach. I would be disappointed if the performance is really that bad.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/80416/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/80416/timeline", "performed_via_github_app": null, "state_reason": null}