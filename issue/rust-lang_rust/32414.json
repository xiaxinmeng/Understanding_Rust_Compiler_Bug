{"url": "https://api.github.com/repos/rust-lang/rust/issues/32414", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/32414/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/32414/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/32414/events", "html_url": "https://github.com/rust-lang/rust/issues/32414", "id": 142504294, "node_id": "MDU6SXNzdWUxNDI1MDQyOTQ=", "number": 32414, "title": "Conditions using bitwise OR on booleans may produce de-optimized code", "user": {"login": "mzabaluev", "id": 1198919, "node_id": "MDQ6VXNlcjExOTg5MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1198919?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mzabaluev", "html_url": "https://github.com/mzabaluev", "followers_url": "https://api.github.com/users/mzabaluev/followers", "following_url": "https://api.github.com/users/mzabaluev/following{/other_user}", "gists_url": "https://api.github.com/users/mzabaluev/gists{/gist_id}", "starred_url": "https://api.github.com/users/mzabaluev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mzabaluev/subscriptions", "organizations_url": "https://api.github.com/users/mzabaluev/orgs", "repos_url": "https://api.github.com/users/mzabaluev/repos", "events_url": "https://api.github.com/users/mzabaluev/events{/privacy}", "received_events_url": "https://api.github.com/users/mzabaluev/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2016-03-21T23:54:25Z", "updated_at": "2017-05-02T11:56:02Z", "closed_at": "2017-05-02T11:56:02Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "When writing optimization-friendly code, sometimes it might seem like a good idea to unroll branches by hand by performing multi-step computations optimistically, while keeping tabs on possible failures of intermediate steps as booleans. These failure flags are then combined using bitwise logic when the validity of the result is finally checked. Here's an example of how it might work with checked arithmetics, inspired by some code in `std::hash`:\n\n``` rust\nfn calculate_size(elem_size: usize,\n                  length: usize,\n                  offset: usize)\n                  -> Option<usize> {\n    let (acc, oflo1) = elem_size.overflowing_mul(length);\n    let (acc, oflo2) = acc.overflowing_add(offset);\n    if oflo1 | oflo2 {\n        None\n    } else {\n        Some(acc)\n    }\n}\n```\n\nHowever, in optimized code generation at least on x86-64, the bitwise OR for booleans is sometimes decomposed into a series of checks and branches, defeating the whole purpose. Here's a condensed benchmark comparing boolean OR with integer bitwise OR, where the results of both are used as the condition for branching.\n\n``` rust\n#![feature(test)]\n\nextern crate test;\n\nuse test::Bencher;\n\n#[inline(never)]\nfn or_bools(a: bool, b: bool, c: bool) -> Option<u64> {\n    if a | b | c { Some(1) } else { None }\n}\n\n#[inline(never)]\nfn or_bytes(a: u8, b: u8, c: u8) -> Option<u64> {\n    if (a | b | c) != 0 { Some(1) } else { None }\n}\n\n#[bench]\nfn bench_or_bools(b: &mut Bencher) {\n    const DATA: [(bool, bool, bool); 4]\n              = [(false, false, false),\n                 (true , false, false),\n                 (false, true , false),\n                 (false, false, true)];\n    b.iter(|| {\n        for i in 0 .. 4 {\n            let (a, b, c) = DATA[i];\n            test::black_box(or_bools(a, b, c));\n        }\n    })\n}\n\n#[bench]\nfn bench_or_bytes(b: &mut Bencher) {\n    const DATA: [(u8, u8, u8); 4]\n              = [(0u8, 0u8, 0u8),\n                 (1u8, 0u8, 0u8),\n                 (0u8, 1u8, 0u8),\n                 (0u8, 0u8, 1u8)];\n    b.iter(|| {\n        for i in 0 .. 4 {\n            let (a, b, c) = DATA[i];\n            test::black_box(or_bytes(a, b, c));\n        }\n    })\n}\n```\n\nThe de-optimization looks like work of LLVM, as the IR for `or_bools` preserves the original intent:\n\n```\n; Function Attrs: noinline norecurse nounwind uwtable\ndefine internal fastcc void @_ZN8or_bools20h51bacbaed15b22f4gaaE(%\"2.core::option::Option<u64>\"* noalias nocapture dereferenceable(16), i1 zeroext, i1 zeroext, i1 zeroext) unnamed_addr #0 {\nentry-block:\n  %4 = or i1 %1, %2\n  %5 = or i1 %4, %3\n  %6 = bitcast %\"2.core::option::Option<u64>\"* %0 to i8*\n  br i1 %5, label %then-block-26-, label %else-block\n\nthen-block-26-:                                   ; preds = %entry-block\n  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* nonnull bitcast ({ i64, i64, [0 x i8] }* @const5784 to i8*), i64 16, i32 8, i1 false)\n  br label %join\n\nelse-block:                                       ; preds = %entry-block\n  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* nonnull bitcast ({ i64, [8 x i8] }* @const5785 to i8*), i64 16, i32 8, i1 false)\n  br label %join\n\njoin:                                             ; preds = %else-block, %then-block-26-\n  ret void\n}\n```\n", "closed_by": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/32414/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/32414/timeline", "performed_via_github_app": null, "state_reason": "completed"}