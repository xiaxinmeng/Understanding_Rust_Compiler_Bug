{"url": "https://api.github.com/repos/rust-lang/rust/issues/98209", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/98209/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/98209/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/98209/events", "html_url": "https://github.com/rust-lang/rust/issues/98209", "id": 1275371587, "node_id": "I_kwDOAAsO6M5MBKBD", "number": 98209, "title": "process::Command doesn't close unused pipe endpoints when it should", "user": {"login": "jgoerzen", "id": 112925, "node_id": "MDQ6VXNlcjExMjkyNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/112925?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgoerzen", "html_url": "https://github.com/jgoerzen", "followers_url": "https://api.github.com/users/jgoerzen/followers", "following_url": "https://api.github.com/users/jgoerzen/following{/other_user}", "gists_url": "https://api.github.com/users/jgoerzen/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgoerzen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgoerzen/subscriptions", "organizations_url": "https://api.github.com/users/jgoerzen/orgs", "repos_url": "https://api.github.com/users/jgoerzen/repos", "events_url": "https://api.github.com/users/jgoerzen/events{/privacy}", "received_events_url": "https://api.github.com/users/jgoerzen/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2022-06-17T19:06:10Z", "updated_at": "2022-06-22T16:26:58Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "I am debugging a problem where I use process::Command to establish pipes between various commands.  I have been experiencing occasional (roughly 0.1% of invocations) deadlocks while those deadlocks are not present when the same pipeline is created from a bash script.\r\n\r\nIn examining the behavior with strace, I have noticed at least one suspicious behavior: when piping data in to a child process's stdin, I see this pattern.  Here PID 230999 is the parent and PID 231002 is the child.  I am trying to include only relevant bits of the strace log:\r\n\r\n```\r\n230999 pipe2([5, 6], O_CLOEXEC)         = 0\r\n...\r\n230999 write(2, \"DEBUG filespooler::exec: Preparing to run \\\"hd\\\" with params []\\n\", 62) = 62\r\n230999 clone(child_stack=0x7f1c3eb69ff0, flags=CLONE_VM|CLONE_VFORK|SIGCHLD <unfinished ...>\r\n231002 dup2(5, 0)                       = 0\r\n230999 write(2, \"DEBUG filespooler::exec: Command PID 231002 started successfully\\n\", 65 <unfinished ...>\r\n231002 exit_group(0)                    = ?\r\n231002 +++ exited with 0 +++\r\n230999 <... wait4 resumed>[{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0, NULL) = 231002\r\n230999 --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=231002, si_uid=1000, si_status=0, si_utime=0, si_stime=0} ---\r\n230999 write(2, \"DEBUG filespooler::exec: Command exited successfully with status ExitStatus(ExitStatus(0))\\n\", 91) = 91\r\n230999 close(5)                         = 0\r\n```\r\n\r\nThe suspicious thing here is that the parent didn't close the reading side of the pipe (fd 5) until after it has waited for the child process to exit.  This is an issue; see this from pipe(7) on Linux:\r\n\r\n       If  all  file descriptors referring to the write end of a pipe have been\r\n       closed, then an attempt to read(2) from the pipe  will  see  end-of-file\r\n       (read(2)  will return 0).  If all file descriptors referring to the read\r\n       end of a pipe have been closed, then a write(2)  will  cause  a  SIGPIPE\r\n       signal  to be generated for the calling process.  If the calling process\r\n       is ignoring this signal, then write(2) fails with the error  EPIPE.   An\r\n       application  that  uses pipe(2) and fork(2) should use suitable close(2)\r\n       calls to close unnecessary duplicate file descriptors; this ensures that\r\n       end-of-file and SIGPIPE/EPIPE are delivered when appropriate.\r\n\r\nThe circumstances around this suggest to me that may not be my precise issue, though I am having difficulty figuring out what else may be.\r\n\r\nAn any case, the result of this is that when piping from one process to another, the first process will hang indefinitely until the Rust program waits on the second.  Here fd 5 should have been closed on the parent side immediately after the fork/clone, before returning anything back to the caller, since it is no longer needed there.\r\n\r\nPresumably the unused fds on the child side (post-dup2) were closed due to the use of O_CLOEXEC, but I would argue it is somewhat bad form to just not even bother to do it.\r\n\r\nThe relevant code is at and around https://salsa.debian.org/jgoerzen/filespooler/-/blob/v1.1.0/src/exec.rs#L47 \r\n\r\nIn this case, payload is of type `ChildStdout`.\r\n\r\nElsewhere, it gets things a bit better.  Here fd 4 is a File that had been opened in the parent process, and is now the stdin for the child, and fds 5 and 6 are used to obtain the stdout FROM the child.  This also happens to be the place where the first command is spawned (whose stdout will be the stdin for the second command listed above); the pipe2 call shown here is the same one shown above.\r\n\r\n```\r\n230999 write(2, \"DEBUG with_decoder{decoder=\\\"cat\\\"}: filespooler::jobqueue: Preparing to invoke decoder: \\\"/bin/bash\\\" [\"..., 113) = 113\r\n230999 pipe2([5, 6], O_CLOEXEC)         = 0\r\n230999 clone(child_stack=0x7f1c3eb69ff0, flags=CLONE_VM|CLONE_VFORK|SIGCHLD <unfinished ...>\r\n231001 dup2(4, 0)                       = 0\r\n231001 dup2(6, 1)                       = 1\r\n230999 close(6 <unfinished ...>\r\n230999 <... close resumed>)             = 0\r\n230999 close(4)                         = 0\r\n230999 write(2, \"DEBUG with_decoder{decoder=\\\"cat\\\"}: filespooler::jobqueue: Decoder PID 231001 started successfully\\n\", 98 <unfinished ...>\r\n```\r\n\r\nHere it closes the unnecessary fds (4 and 6) on the parent before returning to the caller.  That's what it should do.  Why it does that for a File piped to stdin and not for a ChildStdout piped to stdin, I don't know.  (Recall that the fd 5 here later becomes stdin for the second spawned command as shown above, and is not closed by the parent until after the second child exits)\r\n\r\nThis trace corresponds to the code at https://salsa.debian.org/jgoerzen/filespooler/-/blob/v1.1.0/src/jobqueue.rs#L258 and here input is a File.\r\n\r\n\r\n### Meta\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.56.1 (59eed8a2a 2021-11-01)\r\nbinary: rustc\r\ncommit-hash: 59eed8a2aac0230a8b53e89d4e99d55912ba6b35\r\ncommit-date: 2021-11-01\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.56.1\r\nLLVM version: 13.0.0\r\n\r\n```\r\n\r\n\r\n</p>\r\n</details>\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/98209/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/98209/timeline", "performed_via_github_app": null, "state_reason": null}