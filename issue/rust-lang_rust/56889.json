{"url": "https://api.github.com/repos/rust-lang/rust/issues/56889", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/56889/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/56889/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/56889/events", "html_url": "https://github.com/rust-lang/rust/issues/56889", "id": 391499833, "node_id": "MDU6SXNzdWUzOTE0OTk4MzM=", "number": 56889, "title": "Write::write_all erroring when encountering Ok(0) interacts poorly with the contract of Write::write", "user": {"login": "marshallpierce", "id": 575695, "node_id": "MDQ6VXNlcjU3NTY5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/575695?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marshallpierce", "html_url": "https://github.com/marshallpierce", "followers_url": "https://api.github.com/users/marshallpierce/followers", "following_url": "https://api.github.com/users/marshallpierce/following{/other_user}", "gists_url": "https://api.github.com/users/marshallpierce/gists{/gist_id}", "starred_url": "https://api.github.com/users/marshallpierce/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marshallpierce/subscriptions", "organizations_url": "https://api.github.com/users/marshallpierce/orgs", "repos_url": "https://api.github.com/users/marshallpierce/repos", "events_url": "https://api.github.com/users/marshallpierce/events{/privacy}", "received_events_url": "https://api.github.com/users/marshallpierce/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 178802147, "node_id": "MDU6TGFiZWwxNzg4MDIxNDc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-needs-decision", "name": "I-needs-decision", "color": "e11d21", "default": false, "description": "Issues in need of decision."}, {"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 22, "created_at": "2018-12-16T20:01:41Z", "updated_at": "2023-02-01T18:22:02Z", "closed_at": "2021-08-11T20:00:02Z", "author_association": "NONE", "active_lock_reason": null, "body": "The documentation of `write` (emphasis added) specifies that returning `Ok(0)` is a valid thing to do, albeit with a possible implementation-specific \"this writer is dead\" meaning:\r\n\r\n>  A return value of 0 **typically** means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.\r\n\r\nDespite the above, `Write::write_all`'s current implementation returns an error when an underlying `write` returns `Ok(0)`, effectively making this a forbidden return value for implementations of `Write`. However, in cases where a `Write` is transforming or buffering data, it can be useful to return `Ok(0)` to avoid violating this other, more firmly worded, requirement of `write`:\r\n\r\n> A call to `write` represents *at most one* attempt to write to any wrapped object.\r\n\r\nI came across this issue while working on a streaming base64 encoder `Write` for the `base64` crate, and subsequently found other cases where these features have clashed (hat tip to `jebrosen` on IRC).\r\n\r\nIn the case of base64, suppose a user constructs a base64 writer with an internal buffer that delegates to, say, stdout. The user calls `write` with a 6-byte input, which is base64 encoded into 8 bytes in the internal buffer, and subsequently written to the delegate (stdout). The delegate writes 5 bytes, and the remaining 3 bytes are kept in the buffer. On the next call to `write` from the user, I want to consume no input (and therefore return `Ok(0)`), but rather simply try again to write the remaining 3 bytes to the delegate. (Even with a different implementation that does consume as much input as can be encoded and still fit within the buffer, eventually that buffer will fill, and we're back to returning `Ok(0)`.) \r\n\r\nThe same issue [affects flate2](https://github.com/alexcrichton/flate2-rs/blob/master/src/zio.rs#L207):\r\n\r\n```\r\n// miniz isn't guaranteed to actually write any of the buffer provided,\r\n// it may be in a flushing mode where it's just giving us data before\r\n// we're actually giving it any data. We don't want to spuriously return\r\n// `Ok(0)` when possible as it will cause calls to write_all() to fail.\r\n// As a result we execute this in a loop to ensure that we try our\r\n// darndest to write the data.\r\n```\r\n\r\nThat violates the \"at most one write\" part of `write`, but it could be avoided if returning `Ok(0)` wasn't going to break `write_all`.\r\n\r\n`BufWriter` in the std lib [has a similar problem](https://doc.rust-lang.org/nightly/src/std/io/buffered.rs.html#576):\r\n\r\n```rust\r\nimpl<W: Write> Write for BufWriter<W> {\r\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\r\n        if self.buf.len() + buf.len() > self.buf.capacity() {\r\n            self.flush_buf()?;\r\n        }\r\n        if buf.len() >= self.buf.capacity() {\r\n            self.panicked = true;\r\n            let r = self.inner.as_mut().unwrap().write(buf);\r\n            self.panicked = false;\r\n            r\r\n        } else {\r\n            Write::write(&mut self.buf, buf)\r\n        }\r\n    }\r\n...\r\n```\r\n\r\nIf `BufWriter::write` is called when its buffer is nonempty with an input that won't fit in the buffer, the second `if` leads to two calls to the delegate writer for one `BufWriter::write` call, which violates the contract of `write`. Similarly, returning `Ok(0)` there would solve the issue: the caller could then retry with the same buffer, which would be passed to the delegate writer untouched.\r\n\r\nNo doubt there are complexities I don't see yet, but given that `write_all`'s documentation doesn't say anything about erroring on `Ok(0)`, is it feasible to simply continue looping instead of erroring on `Ok(0)`? If the concept of \"writer exhaustion\" the \"typically...\" clause in `write`'s docs is referring to needs to be represented, could that not be an `ErrorKind`?", "closed_by": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/56889/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/56889/timeline", "performed_via_github_app": null, "state_reason": "completed"}