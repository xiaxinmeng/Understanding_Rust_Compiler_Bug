{"url": "https://api.github.com/repos/rust-lang/rust/issues/39916", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/39916/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/39916/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/39916/events", "html_url": "https://github.com/rust-lang/rust/issues/39916", "id": 208553673, "node_id": "MDU6SXNzdWUyMDg1NTM2NzM=", "number": 39916, "title": "proposal: make fuzzing a first class citizen", "user": {"login": "kcc", "id": 1789297, "node_id": "MDQ6VXNlcjE3ODkyOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1789297?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kcc", "html_url": "https://github.com/kcc", "followers_url": "https://api.github.com/users/kcc/followers", "following_url": "https://api.github.com/users/kcc/following{/other_user}", "gists_url": "https://api.github.com/users/kcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/kcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kcc/subscriptions", "organizations_url": "https://api.github.com/users/kcc/orgs", "repos_url": "https://api.github.com/users/kcc/repos", "events_url": "https://api.github.com/users/kcc/events{/privacy}", "received_events_url": "https://api.github.com/users/kcc/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2017-02-17T20:58:40Z", "updated_at": "2020-07-24T07:03:53Z", "closed_at": "2017-06-23T14:33:33Z", "author_association": "NONE", "active_lock_reason": null, "body": "# Proposal: make fuzzing a first class citizen\r\n\r\nThere were many successful attempts to use [AFL](http://lcamtuf.coredump.cx/afl/) with Rust programs, see e.g. @frewsxcv's [afl.rs](https://github.com/frewsxcv/afl.rs). We can go one step further and make guided fuzzing a common way to test Rust code. \r\n\r\n## Instrumentation\r\nGuided fuzzing requires code instrumentation so that the fuzzing engines get feedback from the code execution and can *guide* a) mutations and b) corpus expansion. Since Rust is based on LLVM, there is such instrumentation available already:\r\nhttps://clang.llvm.org/docs/SanitizerCoverage.html#tracing-pcs-with-guards (control flow feedback)\r\nhttps://clang.llvm.org/docs/SanitizerCoverage.html#tracing-data-flow (data flow feedback)\r\nWe may need to make some LLVM flags available via the Rust frontend, that's it. \r\n\r\n## Fuzzing engines\r\nThis LLVM instrumentation is already supported by at least [AFL](http://lcamtuf.coredump.cx/afl/), [libFuzzer](http://libfuzzer.info) and [honggfuzz](https://github.com/google/honggfuzz). We expect more engines to appear in near future and it's important to keep them plug compatible. This way using a new engine on a vast body of code will be trivial. \r\n\r\nAnd by fuzzing engine we should understand a wider class of tools, including e.g. [concolic execution](https://en.wikipedia.org/wiki/Concolic_testing) tools.\r\n\r\n## Interface\r\nIn C/C++ we use the following interface for *things that need fuzzing* (we call these things [**fuzz targets**](libfuzzer.info#fuzz-target)):\r\n```\r\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {\r\n  DoSomethingInterestingWithMyAPI(Data, Size);\r\n  return 0;  // Non-zero return values are reserved for future use.\r\n}\r\n```\r\nAt least as a start I propose to have something similar in (safe) Rust.\r\nThe interface should not depend on any particular fuzzing engine -- engines should be interchangeable. \r\nThe interface should also allow for both in-process and out-of-process engines. \r\n\r\n## In-process fuzzing\r\nWith some rare exceptions fuzzing needs to be in-process, i.e. the code under test and the fuzzing engine should co-exist in the same process. This typically speeds up fuzzing by 1-2 orders of magnitude and often makes deployment simpler. libFuzzer is in-process, AFL has in-process (aka persistent) [mode](https://lcamtuf.blogspot.com/2015/06/new-in-afl-persistent-mode.html), same for [hoggfuzz](https://github.com/google/honggfuzz/blob/master/docs/PersistentFuzzing.md)\r\n\r\n## Structured fuzzing\r\nA frequent question about fuzzing is how to fuzz the input consisting of several chunks of data, or even tree-like data structures. One of the possible answers is [fuzzing protobufs](https://github.com/google/libprotobuf-mutator). This can be discussed later and separately from this proposal. \r\n\r\n## Fuzzing for equivalence\r\nOne interesting special case is fuzzing for equivalence (e.g. to compare Rust and C implementations of the same thing). See my [recent write up](https://moderncrypto.org/mail-archive/hacs/2017/000001.html). This might be especially interesting for projects that re-implement commonly used C libraries, such as https://github.com/briansmith/ring. \r\n\r\n## Continuous fuzzing\r\nFuzzing is often useful as a one-off effort, but it really shines if used continuously. \r\nOne of the services that provide infrastructure for continuous fuzzing is https://github.com/google/oss-fuzz and we'd like to see important Rust projects there. \r\n\r\n## See also\r\n* It should be possible to combine fuzzing with sanitizers (https://github.com/rust-lang/rust/pull/31605) to catch bugs in unsafe rust and to catch leaks in safe Rust. \r\n* A similar discussion in Go: https://github.com/golang/go/issues/19109", "closed_by": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/39916/reactions", "total_count": 70, "+1": 49, "-1": 0, "laugh": 0, "hooray": 7, "confused": 0, "heart": 14, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/39916/timeline", "performed_via_github_app": null, "state_reason": "completed"}