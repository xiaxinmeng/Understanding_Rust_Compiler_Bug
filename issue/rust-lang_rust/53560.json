{"url": "https://api.github.com/repos/rust-lang/rust/issues/53560", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/53560/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/53560/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/53560/events", "html_url": "https://github.com/rust-lang/rust/issues/53560", "id": 352507975, "node_id": "MDU6SXNzdWUzNTI1MDc5NzU=", "number": 53560, "title": "Experiment with a hybrid bitfield + range encoding for Span / DefId.", "user": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 307747675, "node_id": "MDU6TGFiZWwzMDc3NDc2NzU=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-incr-comp", "name": "A-incr-comp", "color": "f7e101", "default": false, "description": "Area: Incremental compilation"}, {"id": 630799571, "node_id": "MDU6TGFiZWw2MzA3OTk1NzE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-compilemem", "name": "I-compilemem", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to memory usage during compilation."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2018-08-21T12:02:09Z", "updated_at": "2018-08-22T05:37:24Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "Roughly, if you have a \"container\" (file/crate/etc.), and sequential indices in it:\r\n* you can use `(container_index, intra_container_index)` (but that takes 2x space)\r\n* you can split an integer's *bitwidth* into two bitfields, one for each half of the pair above\r\n  * the point where you choose to split is a tradeoff and you can run out of either half\r\n* you can split an integer's *range*, with each container having its sequential range\r\n  * `Span` does this currently, where the files are effectively \"concatenated\"\r\n  * requires binary search to translate into the pair representation\r\n\r\nAn improvement on all of those is to choose an arbitrary chunk size (e.g. `2^17 = 128kB` for files), and then split each container into a number of chunks (ideally just 1 in the common case).\r\nYou can then use bitfields for `(chunk, intra_chunk_index)` (e.g. `15` and `17` bits of `u32`).\r\n\r\nThe difference is that to translate `chunk` to `container`, we *don't need* to use binary search, because `chunk` is several orders of magnitude smaller than the index space as a whole, and we can use arrays.\r\n\r\nThat is, `chunk -> container` can be an array, but also, if there is per-container data that would be accessed through `chunk`, we can optimize that by building a `chunk -> Rc<ContainerData>` array.\r\n\r\nTranslating `intra_chunk_index` to `intra_container_index` is similarly easy, if you can look up per-container data, you can subtract its overall start (if each container is a contiguous range of chunks).\r\n\r\n<hr/>\r\n\r\nAnother reason this might be useful is translating (an unified) `DefId` or `Span` between crates or between incremental (re)compilation sessions - we can have a bitset of changed chunks: if a chunk is unchanged, the index is identical, otherwise we can have an intra-chunk/container binary search for changed ranges (or just a map of changes).\r\n\r\nWe can grow the number indices within the last chunk of a container, and if we run out of space, we can relocate the container's chunks without a significant cost. Alternatively, another tradeoff we can make is to fragment a container's chunks.\r\n\r\n<hr/>\r\n\r\nThe first step in experimenting with this would have to be take `Span`, and round up the start/end of each file's range to a multiple of a power of `2` (e.g. `2^17` - but an optimal value would require gathering some real-world file-size statistics).\r\nThis way we can see if there's a negative performance impact from having unused gaps in the index space, everything else should be an improvement.\r\nWe can also try to replace the binary searches to find the `SourceFile` a `Span` is from.\r\n\r\ncc @nikomatsakis @michaelwoerister ", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/53560/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/53560/timeline", "performed_via_github_app": null, "state_reason": null}