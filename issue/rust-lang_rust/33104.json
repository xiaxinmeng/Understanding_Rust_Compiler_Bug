{"url": "https://api.github.com/repos/rust-lang/rust/issues/33104", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/33104/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/33104/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/33104/events", "html_url": "https://github.com/rust-lang/rust/issues/33104", "id": 149719631, "node_id": "MDU6SXNzdWUxNDk3MTk2MzE=", "number": 33104, "title": "Can we get a decorate-sort-undecorate sorting in the standard libaries?", "user": {"login": "mwm", "id": 328444, "node_id": "MDQ6VXNlcjMyODQ0NA==", "avatar_url": "https://avatars.githubusercontent.com/u/328444?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mwm", "html_url": "https://github.com/mwm", "followers_url": "https://api.github.com/users/mwm/followers", "following_url": "https://api.github.com/users/mwm/following{/other_user}", "gists_url": "https://api.github.com/users/mwm/gists{/gist_id}", "starred_url": "https://api.github.com/users/mwm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mwm/subscriptions", "organizations_url": "https://api.github.com/users/mwm/orgs", "repos_url": "https://api.github.com/users/mwm/repos", "events_url": "https://api.github.com/users/mwm/events{/privacy}", "received_events_url": "https://api.github.com/users/mwm/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2016-04-20T09:54:30Z", "updated_at": "2017-01-01T00:51:13Z", "closed_at": "2017-01-01T00:51:13Z", "author_association": "NONE", "active_lock_reason": null, "body": "The decorate-sort-undecorate idiom makes for much faster key-based sorts, especially when key calculation is  expensive. My implementation for vectors (as I needed those rather than slices) looks like:\n\n``` rust\nfn decorated_sort<F, E, K>(v: &Vec<E>, key: F) -> Vec<&E>\n    where F: Fn(&E) -> K, K: Ord + Clone, E: Clone {\n        let v: Vec<(K, &E)> = v.iter().map(|m| (key(m), m)).collect();\n        v.clone().sort_by_key(|t| t.0.clone());\n        v.iter().map(|t| t.1).collect::<Vec<_>>()\n    }\n```\n\nThe quick test for timing for the case I was interested in looks like:\n\n``` rust\n    println!(\"sort_by_key: {:.2}\",\n             timeit(&mut || v.sort_by_key(|m| do_eval(&mut b.clone(), &m))));\n    println!(\"DSU: {:.2}\",\n             timeit(&mut || {decorated_sort(&v, |m| do_eval(&mut b.clone(), &m));}));\n```\n\nThe decorated version runs six times faster on even the relatively short lists (72 elements) I was using, decorated_sort ran six times faster than the sort_by_key.\n", "closed_by": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/33104/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/33104/timeline", "performed_via_github_app": null, "state_reason": "completed"}