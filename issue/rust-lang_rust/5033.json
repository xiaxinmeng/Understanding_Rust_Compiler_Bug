{"url": "https://api.github.com/repos/rust-lang/rust/issues/5033", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/5033/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/5033/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/5033/events", "html_url": "https://github.com/rust-lang/rust/issues/5033", "id": 11159592, "node_id": "MDU6SXNzdWUxMTE1OTU5Mg==", "number": 5033, "title": "RFC: trait-declared associated type synonyms", "user": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37544, "node_id": "MDU6TGFiZWwzNzU0NA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-typesystem", "name": "A-typesystem", "color": "f7e101", "default": false, "description": "Area: The type system"}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 13836860, "node_id": "MDU6TGFiZWwxMzgzNjg2MA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-traits", "name": "A-traits", "color": "f7e101", "default": false, "description": "Area: Trait system"}, {"id": 60344715, "node_id": "MDU6TGFiZWw2MDM0NDcxNQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/P-medium", "name": "P-medium", "color": "eb6420", "default": false, "description": "Medium priority"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 14, "created_at": "2013-02-19T16:15:39Z", "updated_at": "2014-09-24T05:03:30Z", "closed_at": "2014-09-24T05:03:30Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "Rust's type system reflects many advances in the state of the art.\n\nHowever, there is one feature (offered by C++ and ML) that is not present in Rust: The ability to declare within a trait a named type (and then each impl item would be obligated to bind that name to an appropriate type for the implementation).\n\nRelated work: See [Garcia et al. 2003](http://www.osl.iu.edu/publications/prints/2003/comparing_generic_programming03.pdf), especially section 6.2, 10.2, and 10.3.  Another useful reference is [Chakravarty et al 2005](http://www.cse.unsw.edu.au/~chak/papers/CKP05.html)\n\nThe Haskell community calls such a construct an \"associated type synonym.\"\n\nHere is an small example to illustrate the idea.\n\nFirst, the easy part: how such a feature would look at the level of trait and impl items:\n\n``` rust\ntrait Graph {\n  pub type Node;   // Graphs are composed of vertices\n  pub type Edge;   // and arcs between the vertices.\n  pub fn src(&self, edge: Edge) -> Node;\n  pub fn tgt(&self, edge: Edge) -> Node;\n}\n\n\n// A vector of (source,target) pairs is a graph where the edges\n// indices into the vector\nimpl<T : Copy> &[(T,T)] : Graph {\n  pub type Node = T;    // Here we satisfy the obligation to provide Node\n  pub type Edge = uint;  // and Edge implementation types.\n  pub fn src(&self, edge: Edge) -> Node { let (s,_) = self[edge]; s }\n  pub fn tgt(&self, edge: Edge) -> Node { let (_,t) = self[edge]; t }\n}\n```\n\nIdeally one would extract the type from a trait by using a path, using a type parameter as a path component.  So for example:\n\n``` rust\ntrait IncidenceGraph : Graph {\n  pub fn out_degree(&self, node: self::Node) -> uint;\n  pub fn out_edges(&self, node: self::Node, it: fn(self::Edge) -> bool);\n}\n\nfn children<G:IncidenceGraph>(&g:G, &n: G::Node) -> ~[G::Node] {\n  let result = ~[];\n  for g.out_edges(n) |e| {\n    ret.push(g.tgt(n))\n  }\n  ret\n}\n```\n\nNote: I am aware that one can express currently express type synonyms in much the same way that one does in Java (or C#, or Eiffel; see Garcia et al paper): by making them a type-parameter of the trait itself.  Rust's type-inference system does make that workaround more palatable, but it seems natural to enable the developer to express what they mean more directly: These types are obligations of the implementation, much like the functions declared in the trait, and thus it makes sense to express them the same way.\n\n---\n\nThere are various issues to consider: e.g.:\n- Do we allow bounds on the type declarations in the trait,\n- Is there is any potential ambiguity with module names introduced by allowing traits (or rather, type parameters implementing a trait) to appear as path components in paths that are used in a type-expression context.\n- Are there any gotcha's or generalizations that have been uncovered by the broader PL community that we would want to address.   (For example, GHC has [indexed data families](http://www.haskell.org/haskellwiki/GHC/Type_families#Associated_family_declarations), with which I am not familiar but seem to be a generalization with some potential gotchas.  Caveat: I am not a Haskell programmer.)\n\nDespite the above issues, this seems like a relatively straightforward change to the language (especially since one can already encode the pattern, so adding it should not inject e..g any type soundness bugs, right?).\n", "closed_by": {"login": "rust-highfive", "id": 7378925, "node_id": "MDQ6VXNlcjczNzg5MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/7378925?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rust-highfive", "html_url": "https://github.com/rust-highfive", "followers_url": "https://api.github.com/users/rust-highfive/followers", "following_url": "https://api.github.com/users/rust-highfive/following{/other_user}", "gists_url": "https://api.github.com/users/rust-highfive/gists{/gist_id}", "starred_url": "https://api.github.com/users/rust-highfive/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rust-highfive/subscriptions", "organizations_url": "https://api.github.com/users/rust-highfive/orgs", "repos_url": "https://api.github.com/users/rust-highfive/repos", "events_url": "https://api.github.com/users/rust-highfive/events{/privacy}", "received_events_url": "https://api.github.com/users/rust-highfive/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/5033/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/5033/timeline", "performed_via_github_app": null, "state_reason": "completed"}