{"url": "https://api.github.com/repos/rust-lang/rust/issues/100562", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/100562/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/100562/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/100562/events", "html_url": "https://github.com/rust-lang/rust/issues/100562", "id": 1338562160, "node_id": "I_kwDOAAsO6M5PyNZw", "number": 100562, "title": "Different (suboptimal) assembly generated for `match` expr vs `if`-`else if`s", "user": {"login": "sharnoff", "id": 29154784, "node_id": "MDQ6VXNlcjI5MTU0Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/29154784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sharnoff", "html_url": "https://github.com/sharnoff", "followers_url": "https://api.github.com/users/sharnoff/followers", "following_url": "https://api.github.com/users/sharnoff/following{/other_user}", "gists_url": "https://api.github.com/users/sharnoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/sharnoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sharnoff/subscriptions", "organizations_url": "https://api.github.com/users/sharnoff/orgs", "repos_url": "https://api.github.com/users/sharnoff/repos", "events_url": "https://api.github.com/users/sharnoff/events{/privacy}", "received_events_url": "https://api.github.com/users/sharnoff/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2022-08-15T05:34:24Z", "updated_at": "2023-04-05T17:33:54Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Possibly an LLVM issue instead of rustc. Godbolt: https://godbolt.org/z/WqMqEn13v\r\n\r\nThe following two functions *should* be identical, and small:\r\n\r\n```rust\r\npub fn switch_a(x: i32, y: i32) {\r\n    match x.cmp(&y) {\r\n        Ordering::Less => lt(),\r\n        Ordering::Equal => eq(),\r\n        Ordering::Greater => gt(),\r\n    }\r\n}\r\n\r\npub fn switch_b(x: i32, y: i32) {\r\n    let o = x.cmp(&y);\r\n    if o == Ordering::Less {\r\n        lt()\r\n    } else if o == Ordering::Equal {\r\n        eq()\r\n    } else {\r\n        gt()\r\n    }\r\n}\r\n```\r\n\r\n(with `fn lt()`, `fn eq()`, and `fn gt()` are defined elsewhere, and not inlined)\r\n\r\nHowever, the `if` version, on x86-64 generates much better assembly than the one using `match`:\r\n\r\n```asm\r\n$crate::switch_a:\r\n        xor     ecx, ecx\r\n        cmp     edi, esi\r\n        setne   cl\r\n        mov     eax, 255\r\n        cmovge  eax, ecx\r\n        cmp     al, -1\r\n        je      .LBB0_3\r\n        test    al, al\r\n        jne     .LBB0_2\r\n        jmp     $crate::eq\r\n.LBB0_3:\r\n        jmp     $crate::lt\r\n.LBB0_2:\r\n        jmp     $crate::gt\r\n\r\n$crate::switch_b:\r\n        cmp     edi, esi\r\n        jge     .LBB1_1\r\n        jmp     $crate::lt\r\n.LBB1_1:\r\n        jne     .LBB1_4\r\n        jmp     $crate::eq\r\n.LBB1_4:\r\n        jmp     $crate::gt\r\n```\r\n\r\nI also tried manually inlining the `Ord::cmp` implementation into `switch_a`, but that had no effect on the generate assembly; AFAICT it's just a `match` vs `if` issue.\r\n\r\nI wasn't sure if the LLVM IR would also be helpful, so I've attached that here just in case:\r\n\r\n<details>\r\n<summary>LLVM IR for <code>switch_a</code> (slow)</summary>\r\n<pre>\r\n; playground::switch_a\r\n; Function Attrs: noinline nonlazybind uwtable\r\ndefine internal void @_ZN10playground8switch_a17h9d37c1318c71046dE(i32 %0, i32 %1) unnamed_addr #0 !dbg !383 {\r\nstart:\r\n  %_3 = alloca i8, align 1\r\n  %y = alloca i32, align 4\r\n  %x = alloca i32, align 4\r\n  store i32 %0, i32* %x, align 4\r\n  store i32 %1, i32* %y, align 4\r\n  call void @llvm.dbg.declare(metadata i32* %x, metadata !387, metadata !DIExpression()), !dbg !389\r\n  call void @llvm.dbg.declare(metadata i32* %y, metadata !388, metadata !DIExpression()), !dbg !390\r\n; call core::cmp::impls::<impl core::cmp::Ord for i32>::cmp\r\n  %2 = call i8 @\"_ZN4core3cmp5impls48_$LT$impl$u20$core..cmp..Ord$u20$for$u20$i32$GT$3cmp17h798939cb199721aeE\"(i32* align 4 %x, i32* align 4 %y), !dbg !391, !range !154\r\n  store i8 %2, i8* %_3, align 1, !dbg !391\r\n  br label %bb1, !dbg !391\r\n\r\nbb1:                                              ; preds = %start\r\n  %_7 = load i8, i8* %_3, align 1, !dbg !391, !range !154, !noundef !23\r\n  switch i8 %_7, label %bb3 [\r\n    i8 -1, label %bb4\r\n    i8 0, label %bb5\r\n    i8 1, label %bb2\r\n  ], !dbg !392\r\n\r\nbb3:                                              ; preds = %bb1\r\n  unreachable, !dbg !391\r\n\r\nbb4:                                              ; preds = %bb1\r\n; call playground::lt\r\n  call void @_ZN10playground2lt17h10d091da8f223c9fE(), !dbg !393\r\n  br label %bb6, !dbg !393\r\n\r\nbb5:                                              ; preds = %bb1\r\n; call playground::eq\r\n  call void @_ZN10playground2eq17hea0ed2e3f5d44bfbE(), !dbg !394\r\n  br label %bb6, !dbg !394\r\n\r\nbb2:                                              ; preds = %bb1\r\n; call playground::gt\r\n  call void @_ZN10playground2gt17hb40089beada6c920E(), !dbg !395\r\n  br label %bb6, !dbg !395\r\n\r\nbb6:                                              ; preds = %bb4, %bb5, %bb2\r\n  ret void, !dbg !396\r\n}\r\n</pre>\r\n</details>\r\n\r\n<details>\r\n<summary>LLVM IR for <code>switch_b</code> (fast)</summary>\r\n<pre>\r\n; playground::switch_b\r\n; Function Attrs: noinline nonlazybind uwtable\r\ndefine internal void @_ZN10playground8switch_b17h0a86fcae9cdc33d1E(i32 %0, i32 %1) unnamed_addr #0 !dbg !397 {\r\nstart:\r\n  %o = alloca i8, align 1\r\n  %y = alloca i32, align 4\r\n  %x = alloca i32, align 4\r\n  store i32 %0, i32* %x, align 4\r\n  store i32 %1, i32* %y, align 4\r\n  call void @llvm.dbg.declare(metadata i32* %x, metadata !399, metadata !DIExpression()), !dbg !403\r\n  call void @llvm.dbg.declare(metadata i32* %y, metadata !400, metadata !DIExpression()), !dbg !404\r\n  call void @llvm.dbg.declare(metadata i8* %o, metadata !401, metadata !DIExpression()), !dbg !405\r\n; call core::cmp::impls::<impl core::cmp::Ord for i32>::cmp\r\n  %2 = call i8 @\"_ZN4core3cmp5impls48_$LT$impl$u20$core..cmp..Ord$u20$for$u20$i32$GT$3cmp17h798939cb199721aeE\"(i32* align 4 %x, i32* align 4 %y), !dbg !406, !range !154\r\n  store i8 %2, i8* %o, align 1, !dbg !406\r\n  br label %bb1, !dbg !406\r\n\r\nbb1:                                              ; preds = %start\r\n; call <core::cmp::Ordering as core::cmp::PartialEq>::eq\r\n  %_7 = call zeroext i1 @\"_ZN60_$LT$core..cmp..Ordering$u20$as$u20$core..cmp..PartialEq$GT$2eq17h3c0a27209002f6f2E\"(i8* align 1 %o, i8* align 1 getelementptr inbounds (<{ [1 x i8] }>, <{ [1 x i8] }>* @alloc36, i32 0, i32 0, i32 0)), !dbg !407\r\n  br label %bb2, !dbg !407\r\n\r\nbb2:                                              ; preds = %bb1\r\n  br i1 %_7, label %bb3, label %bb4, !dbg !407\r\n\r\nbb4:                                              ; preds = %bb2\r\n; call <core::cmp::Ordering as core::cmp::PartialEq>::eq\r\n  %_10 = call zeroext i1 @\"_ZN60_$LT$core..cmp..Ordering$u20$as$u20$core..cmp..PartialEq$GT$2eq17h3c0a27209002f6f2E\"(i8* align 1 %o, i8* align 1 getelementptr inbounds (<{ [1 x i8] }>, <{ [1 x i8] }>* @alloc38, i32 0, i32 0, i32 0)), !dbg !408\r\n  br label %bb5, !dbg !408\r\n\r\nbb3:                                              ; preds = %bb2\r\n; call playground::lt\r\n  call void @_ZN10playground2lt17h10d091da8f223c9fE(), !dbg !409\r\n  br label %bb8, !dbg !409\r\n\r\nbb8:                                              ; preds = %bb7, %bb6, %bb3\r\n  ret void, !dbg !410\r\n\r\nbb5:                                              ; preds = %bb4\r\n  br i1 %_10, label %bb6, label %bb7, !dbg !408\r\n\r\nbb7:                                              ; preds = %bb5\r\n; call playground::gt\r\n  call void @_ZN10playground2gt17hb40089beada6c920E(), !dbg !411\r\n  br label %bb8, !dbg !411\r\n\r\nbb6:                                              ; preds = %bb5\r\n; call playground::eq\r\n  call void @_ZN10playground2eq17hea0ed2e3f5d44bfbE(), !dbg !412\r\n  br label %bb8, !dbg !412\r\n}\r\n</pre>\r\n</details>", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/100562/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/100562/timeline", "performed_via_github_app": null, "state_reason": null}