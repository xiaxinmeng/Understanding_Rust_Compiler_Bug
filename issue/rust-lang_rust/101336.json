{"url": "https://api.github.com/repos/rust-lang/rust/issues/101336", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/101336/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/101336/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/101336/events", "html_url": "https://github.com/rust-lang/rust/issues/101336", "id": 1360477103, "node_id": "I_kwDOAAsO6M5RFzuv", "number": 101336, "title": "Commit to safety rules for dyn trait upcasting", "user": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 178802147, "node_id": "MDU6TGFiZWwxNzg4MDIxNDc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-needs-decision", "name": "I-needs-decision", "color": "e11d21", "default": false, "description": "Issues in need of decision."}, {"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 919710011, "node_id": "MDU6TGFiZWw5MTk3MTAwMTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/disposition-merge", "name": "disposition-merge", "color": "008800", "default": false, "description": "This issue / PR is in PFCP or FCP with a disposition to merge it."}, {"id": 923282386, "node_id": "MDU6TGFiZWw5MjMyODIzODY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/finished-final-comment-period", "name": "finished-final-comment-period", "color": "f9e189", "default": false, "description": "The final comment period is finished for this PR / Issue."}, {"id": 1648796597, "node_id": "MDU6TGFiZWwxNjQ4Nzk2NTk3", "url": "https://api.github.com/repos/rust-lang/rust/labels/F-trait_upcasting", "name": "F-trait_upcasting", "color": "f9c0cc", "default": false, "description": "`#![feature(trait_upcasting)]`"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 25, "created_at": "2022-09-02T18:02:48Z", "updated_at": "2022-09-22T15:10:29Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "This issue proposes a resolution to the last outstanding question blocking `dyn` upcast. It is also available on [the initiative repository](https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/upcast-safety-3.html).\r\n\r\n## Background\r\n\r\nWe are trying to enable \"upcasts\" from a `dyn Trait` to its supertraits:\r\n\r\n```rust\r\ntrait Foo {\r\n    fn foo_method(&self);\r\n}\r\ntrait Bar: Foo {\r\n    fn bar_method(&self);\r\n}\r\n\r\nlet x: &dyn Bar = /* ... */;\r\nlet y: &dyn Foo = x; // compiles\r\n```\r\n\r\nThe key factor for these upcasts is that they require adjusting the vtable. The current implementation strategy is that the vtables for the `Bar` trait embed pointers to a `Foo` vtable within them:\r\n\r\n```\r\n+----------------------------+\r\n| Bar vtable for some type T |\r\n|----------------------------|\r\n| Foo vtable                 | ----------> +------------------+\r\n| foo_method                 | -----+      | Foo vtable for T |\r\n| bar_method                 | --+  |      |------------------|\r\n+----------------------------+   |  |      | foo_method       | ---+\r\n                                 |  |      +------------------+    |\r\n                                 |  |                              |\r\n                                 |  +---> <T as Foo>::foo_method <-+\r\n                                 v\r\n                     <T as Bar>::bar_method\r\n                 \r\n(this diagram is only meant to convey the general idea of the vtable\r\n layout, and doesn't represent the exact offsets we would use etc;\r\n in fact, with the current implementation,\r\n the first supertrait is stored 'inline' and hence no load is required)\r\n```\r\n\r\nThis way, given a `&dyn Bar` object, we convert its `Bar` vtable to the appropriate `Foo` vtable by loading the appropriate field.\r\n\r\nAlthough we don't want to commit to a particular implementation strategy, we do want to leave room for this strategy. One implication is that performing an upcast may require loading from the vtable, which implies that the vtable must be a valid pointer to an actual Rust vtable. Although `&dyn Bar` references would always contain a valid vtable, the same is not necessarily true for a raw pointer like `*const dyn Bar` or `*mut dyn Bar`. \r\n\r\nIn the language today, we only support \"noop upcasts\" that don't affect the vtable, and these are safe (e.g., converting from `*const dyn Foo + Send` to `*const dyn Foo`). If we extend the set of upcasts to permit vtable-adjusting upcasts, like `*const dyn Bar` to `*const dyn Foo`, this implies that, for safe code at least, all `*const dyn Trait` values must have a valid vtable, so that we know we can safely load the required field and perform the upcast.\r\n\r\nOn the other hand, we do not generally require raw `*mut T` pointers to point to valid data. In fact, we explicitly permit them to have any value, including null, and only require that they point to valid data when they are dereferenced. Because dereferencing a raw pointer is an unsafe operation, it has always been considered safe to expose an arbitrary raw pointer to unsafe code -- the unsafety arises when you take a raw pointer from an unknown source and dereference it, since unless you can trace the origin of that pointer you can't possible guarantee that it is valid to dereference.\r\n\r\nThis brings us to the conflict:\r\n\r\n* It has historically been safe to \"release\" a raw pointer to safe code, but not safe to receive one (since you cannot know if it is valid).\r\n* It has historically been safe to upcast `*const dyn` values (e.g., `*const dyn Foo + Send` to `*const dyn Foo`). \r\n    * Unlike the upcasts we are considering now, this upcast does not require changing the vtable at runtime, but the distinction is subtle for end-users.\r\n    * Moreover, there are future extensions (e.g., upcasting `*const dyn Foo + Bar` to `*const dyn Foo`) that would require adjusting the vtable much like the upcasts currently being stabilized. \r\n\r\n## Related future consideration: virtual method calls on raw pointers\r\n\r\nThere have been requests to extend traits with the option to include raw pointer methods:\r\n\r\n```rust\r\ntrait PtrLike {\r\n    fn is_null(v: *const Self) -> bool;\r\n}\r\n```\r\n\r\nThese methods would be useful when writing unsafe code because having an `&self` method requires satisfying the validity conditions of an `&`-reference, which may not be possible. If we did have such methods, however, it raises the question of whether it would be safe to invoke `is_null` on a `*const dyn PtrLike` reference. Just as with upcasting, invoking a method from the vtable requires loading from the vtable, and hence requires a valid vtable generated by the compiler.\r\n\r\nThe solution we propose in this document also resolves this future dilemma.\r\n\r\n## Definitions: validity vs safety invariant\r\n\r\nWe adopt the terms *validity* and *safety* invariant from the [unsafe code guidelines](https://rust-lang.github.io/unsafe-code-guidelines/glossary.html):\r\n\r\n> The *validity invariant* is an invariant that all data must uphold any time it is accessed or copied in a typed manner. This invariant is known to the compiler and exploited by optimizations such as improved enum layout or eliding in-bounds checks.\r\n>\r\n> The *safety invariant* is an invariant that safe code may assume all data to uphold. This invariant is used to justify which operations safe code can perform. The safety invariant can be temporarily violated by unsafe code, but must always be upheld when interfacing with unknown safe code. It is not relevant when arguing whether some program has UB, but it is relevant when arguing whether some code safely encapsulates its unsafety -- in other words, it is relevant when arguing whether some library is sound.\r\n\r\nIn short, the *validity invariant* defines a condition that must always be true, even in unsafe code, and the *safety invariant* defines an invariant that unsafe code must guarantee before a value can be released to be used by arbitrary code.\r\n\r\n## Contours of the solution space\r\n\r\nWe can fix this conflict in one of two basic ways:\r\n\r\nFirst, **we could make vtable-adjusting upcasts casts (and `*Self` method calls) unsafe**. This is  difficult to implement and would require changes to the `Coerce` trait, which is already excessively complicated. In exchange, it offers at best marginal benefit: raw `*dyn` pointers can be released to safe code, but safe code can't do anything interesting with them. For this reason, we do not recommend this option.\r\n\r\nIf vtable-adjusting casts (and `*Self` method calls) are safe, then the **safety invariant** for `*dyn` types must be that their metadata points to a **fully valid vtable** (i.e., a vtable created by the compiler). This ensures safe code can perform upcasts or dynamic dispatch. This also implies that `std::ptr::null` (which is safe) cannot be extended to `T` where `T: ?Sized` unless further changes are made, since we would need to provide a valid vtable (it would be possible to permit a sentinel value, like null, to be used, but that would imply that upcasting must have a branch, making it less efficient).\r\n\r\nThere are, however, various options for the **validity invariant**, ranging from no invariant to requiring a fully valid vtable at all times. The strict invariants offer some benefits, such as the ability to have a niche for `*dyn` pointers. We survey the options here:\r\n\r\n| Validity invariant for `*dyn` metadata | Supports niche | Can be initialized with `std::mem::zeroed` | Constant initializer |\r\n| -------------------------------------- | -------------- | ------------------------------------------ | -------------------- |\r\n| None                                   |                | \u2705                                         | \u2705                   |\r\n| Word-aligned                           | \u2705             | \u2705                                         | \u2705                   |\r\n| Word-aligned, non-null                 | \u2705             |                                            | \u2705                   |\r\n| Valid vtable                           | \u2705             |                                            |                      |\r\n\r\nExplanations for the column titles:\r\n\r\n* Validity invariant for `*dyn` metadata -- describes the invariant that applies to the metadata for a `*dyn` value.\r\n* Supports niche -- true if there is a niche value so that `sizeof(Option<*const dyn Foo>) == sizeof(*const dyn Foo)`.\r\n* Can be initialized with `std::mem::zeroed` -- true if `std::mem::zeroed` can be used to create a valid value (very convenient). This makes it trivial to innitialize a `*const dyn` with a dummy value, though the value cannot be released to safe code.\r\n* Constant initializer -- true if there is some constant value for `*const dyn Foo` that satisfies the validity invariant, no matter the trait `Foo`. This makes it easy to initialize a `*const dyn` with a dummy value, though the value cannot be released to safe code.\r\n\r\nOther points:\r\n\r\n* `*dyn` values [currently have a niche](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=bcd18cd3870ba98e2c59b527418f8f68).\r\n* Other pointer-like values (such as `fn` and `&`-references) are expected to have a validity invariant of word-aligned, non-null.\r\n* Whichever option we use, we can backwards-compatibly move \"up the table\" and adopt a less-strict validity invariant without introducing UB into any extant programs.\r\n\r\n## Proposal\r\n\r\nThe proposal is as follows:\r\n\r\n* Vtable-adjusting upcasts are **safe operations**. The upcast is UB if performed on a value without a valid vtable\r\n* As such, the \"safety invariant\" requires a **fully valid vtable**.\r\n* The \"validity invariant\" requires `*dyn` metadata to be **word-aligned and non-null**.\r\n\r\nVtable-adjusting upcasts are defined as:\r\n\r\n* Trait upcasts that alter the set of methods that can be invoked on the resulting value at runtime (e.g., `dyn Bar` to `dyn Foo` from the introduction). In particular, upcasts that simply add or remove auto-traits are not vtable-adjusting (e.g., `dyn Debug + Send` to `dyn Debug`).\r\n\r\nThis approach...\r\n\r\n* permits safe upcasting (and method calls, in the future);\r\n* preserves the existing niche for `*const dyn`;\r\n* is consistent with other validity requirements for \"pointer-like\" things such as `fn`;\r\n\r\nThe rules also imply that...\r\n\r\n* valid (i.e., compiler-generated) vtables are only required for a `*dyn` pointer when\r\n    * the `*dyn` pointer is upcast (or invoke methods);\r\n    * or, when the `*dyn` pointer is released to arbitrary code, because that code may upcast (or invoke methods).\r\n        * By implication, extending [`std::ptr::null`](https://doc.rust-lang.org/std/ptr/fn.null.html) to permit `T: ?Sized` would not be safe.\r\n\r\n## Possible future changes\r\n\r\nIt may be possible to weaken the validity or safety invariants later, but we risk finding that people have written unsafe code that relies on them. For example, people could build data structures using unions that assume that the vtable pointer is non-null. If we then later permitted a null value, this code could create UB. This is particularly problematic for changes to the safety invariant, since the assumption is that one can take a value which meets the safety invariant and give it to arbitrary code without creating UB (if the value only meets the validity invariant, and not the safety invariant, then you are supposed to audit and control all the code which uses that value, so this is less of a problem).\r\n\r\n## Prior links\r\n\r\n* [Dyn safety write-up](https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/upcast-safety-2.html), which includes links to prior write-ups\r\n* [Exhaustive set of validity invariants considered](./upcast-safety-3-options.md)", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/101336/reactions", "total_count": 2, "+1": 0, "-1": 0, "laugh": 0, "hooray": 2, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/101336/timeline", "performed_via_github_app": null, "state_reason": null}