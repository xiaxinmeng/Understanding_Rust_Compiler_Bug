{"url": "https://api.github.com/repos/rust-lang/rust/issues/74372", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/74372/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/74372/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/74372/events", "html_url": "https://github.com/rust-lang/rust/issues/74372", "id": 657508398, "node_id": "MDU6SXNzdWU2NTc1MDgzOTg=", "number": 74372, "title": "Tracking issue for WebAssembly SIMD support", "user": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 474645165, "node_id": "MDU6TGFiZWw0NzQ2NDUxNjU=", "url": "https://api.github.com/repos/rust-lang/rust/labels/O-wasm", "name": "O-wasm", "color": "6e6ec0", "default": false, "description": "Target: WASM (WebAssembly), http://webassembly.org/"}, {"id": 631737389, "node_id": "MDU6TGFiZWw2MzE3MzczODk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-simd", "name": "A-simd", "color": "f7e101", "default": false, "description": "Area: SIMD (Single Instruction Multiple Data)"}, {"id": 650846969, "node_id": "MDU6TGFiZWw2NTA4NDY5Njk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-tracking-issue", "name": "C-tracking-issue", "color": "f5f1fd", "default": false, "description": "Category: A tracking issue for an RFC or an unstable feature."}, {"id": 919710011, "node_id": "MDU6TGFiZWw5MTk3MTAwMTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/disposition-merge", "name": "disposition-merge", "color": "008800", "default": false, "description": "This issue / PR is in PFCP or FCP with a disposition to merge it."}, {"id": 923282386, "node_id": "MDU6TGFiZWw5MjMyODIzODY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/finished-final-comment-period", "name": "finished-final-comment-period", "color": "f9e189", "default": false, "description": "The final comment period is finished for this PR / Issue."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 44, "created_at": "2020-07-15T17:00:30Z", "updated_at": "2021-07-30T10:14:05Z", "closed_at": "2021-06-11T07:44:57Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "I'm opening this as a tracking issue for the SIMD intrinsics in the `{std,core}::arch::wasm32` module. Eventually we're going to want to stabilize these intrinsics for the WebAssembly target, so I think it's good to have a canonical place to talk about them! I'm also going to update the `#![unstable]` annotations to point to this issue to direct users here if they want to use these intrinsics.\r\n\r\nThe WebAssembly [simd proposal](https://github.com/webassembly/simd) is [currently in \"phase 3\"](https://github.com/webassembly/proposals). I would say that we probably don't want to consider stabilizing these intrinsics until the proposal has at least reached \"phase 4\" where it's being standardized, because there are still changes to the proposal happening over time (small ones at this point, though). As a brief overview, the WebAssembly simd proposal adds a new type, `v128`, and a suite of instructions to perform data processing with this type. The intention is that this is readily portable to a lot of architectures so usage of SIMD can be fast in lots of places.\r\n\r\nFor rust stabilization purposes the code for all these intrinsics lives in the rust-lang/stdarch git repository. All code lives in `crates/core_arch/src/wasm32/simd128.rs`. I've got a [large refactoring and sync](https://github.com/rust-lang/stdarch/pull/874) queued up for that module, so I'm going to be writing this issue with the assumption that it will land mostly as designed there.\r\n\r\nCurrently the design principles for the SIMD intrinsics are:\r\n\r\n* Like the existing `memory_size`, `memory_grow` and `unreachable` intrinsics, most intrinsics are named after the instruction that it represents. There is generally a 1:1 mapping with new instructions added to WebAssembly and intrinsics in the module.\r\n* The type signature of each intrinsic is intended to match [the textual description of each intrinsic](https://github.com/WebAssembly/simd/blob/master/proposals/simd/SIMD.md)\r\n* Each intrinsic has `#[target_feature(enable = \"simd128\")]` which forces them all to be `unsafe`\r\n* Some gotchas for specific intrinsics are:\r\n  * `v128.const` is exposed through a suite of `const` functions, one for each vector type (but not unsigned, just signed integers). Additionally the arguments are not actually required to be constant, so it's expected that the compiler will make the best choice about how to generate a runtime vector.\r\n  * Instructions using lane indices, such as `v8x16_shuffle` and `*_{extract,replace}_lane` use const generics to represent constant arguments. This is different from x86_64 which uses the older `#[rustc_args_required_const]` attribute.\r\n  * Shuffles are provided for `v16x8`, `v32x4`, and `v64x2` as conveniences instead of only providing `v8x16_shuffle`. All of them are implemented in terms of the `v8x16.shuffle` instruction, however.\r\n* There is a singular `v128` type, not a type for each size of vector that intrinsics operate with\r\n* The `extract_lane` intrinsics return the value type associated with the intrinsic name, they do not all return `i32` unlike the actual WebAssembly instruction. This means that we do not have `extract_lane_s` and `extract_lane_u` intrinsics because the compiler will select the appropriate one depending on the context.\r\n\r\nIt's important to note that [clang has an implementation of these intrinsics in the `wasm_simd128.h` header](https://github.com/llvm/llvm-project/blob/master/clang/lib/Headers/wasm_simd128.h). The current design of the Rust `wasm32` module is different in that:\r\n\r\n* The prefix `wasm_*` isn't used.\r\n* Only one datatype, `v128`, is exposed instead of types for each size/kind of vector\r\n* Naming can be different depending on the intrinsic. For example clang has `wasm_i16x8_load_8x8` and `wasm_u16x8_load_8x8` while Rust has `i16x8_load8x8_s` and `i16x8_load8x8_u`.\r\n\r\nMost of these differences are largely stylistic, but there are some that are conveniences (like other forms of shuffles) which might be nice to expose in Rust as well. All the conveniences still compile down to one instruction, it's just different how users specify in code how the instruction is generated. I believe it should be possible for conveniences to live outside the standard library as well, however.\r\n\r\n## How SIMD will be used\r\n\r\nIf the SIMD proposal were to move to stage 4 today I think we're in a really good spot for stabilization. https://github.com/rust-lang/rust/issues/74320 is a pretty serious bug we will want to fix before full stabilization but I don't believe the fix will be hard to land in LLVM (I've already talked with some folks on that side).\r\n\r\nOther than that SIMD-in-wasm is different from other platforms where a binary with SIMD will refuse to run on engines that do not have SIMD support. In that sense there is no runtime feature detection available to SIMD consumers. (at least not natively)\r\n\r\nAfter https://github.com/rust-lang/stdarch/pull/874 lands programs will simply use `#[target_feature(enable = \"...\")]` or `RUSTFLAGS` and everything should work. The SIMD intrinsics will always be exposed from the standard library (but the standard library itself will not use them) and available to users. If programs don't use the intrinsics then SIMD won't get emitted, otherwise when used the binary will use `v128`. \r\n\r\n## Open Questions\r\n\r\nA set of things we'll need to settle on before stabilizing (and this will likely expand over time) is:\r\n\r\n* [ ] Handle the difference between Clang and Rust. This could come in a number of forms such as accepting the difference or trying to unify the two. Either way the standard itself, unlike for x86, does not nor do I think will it provide a standard convention of how to expose these instructions in languages.\r\n* [x] Audit and confirm the types of pointers in various `*_load_*` and `*_store_*` instructions. Primarily the instructions that load 64 bits (8x8, 16x4, ...) I'm unsure of on the types of their pointer arguments.\r\n* [x] Figure out if the usage of const generics is ok for `v8x16_shuffle` and lane managment instructions.\r\n* [ ] Confirm the deviation of not having `i8x16_extract_lane_s` is ok (e.g. having `i8x16_extract_lane` returning `i8` is all we need), same for `i16x8`.\r\n* [ ] Consider relaxing `#[target_feature]` \"requires unsafe\" rules for these WebAssembly intrinsics. Intrinsic like `f32x4_splat` have no fundamental reason they need to be `unsafe`. The only reason they're unsafe is because `#[target_feature]` is used on them to ensure that SIMD instructions are generated in LLVM.\r\n* [x] Consider switching `*_{any,all}_true` to returning a `bool`\r\n* [x] A general audit of intrinsic names and signatures to ensure they match the specification.", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/74372/reactions", "total_count": 10, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 10, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/74372/timeline", "performed_via_github_app": null, "state_reason": "completed"}