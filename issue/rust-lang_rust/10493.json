{"url": "https://api.github.com/repos/rust-lang/rust/issues/10493", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/10493/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/10493/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/10493/events", "html_url": "https://github.com/rust-lang/rust/issues/10493", "id": 22698391, "node_id": "MDU6SXNzdWUyMjY5ODM5MQ==", "number": 10493, "title": "Support 1:1 Scheduling", "user": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 36953, "node_id": "MDU6TGFiZWwzNjk1Mw==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-runtime", "name": "A-runtime", "color": "f7e101", "default": false, "description": "Area: std's runtime and \"pre-main\" init for handling backtraces, unwinds, stack overflows"}, {"id": 37977651, "node_id": "MDU6TGFiZWwzNzk3NzY1MQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/metabug", "name": "metabug", "color": "5319e7", "default": false, "description": "Issues about issues themselves (\"bugs about bugs\")"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 15, "created_at": "2013-11-14T22:28:58Z", "updated_at": "2013-12-27T05:27:41Z", "closed_at": "2013-12-27T05:27:41Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "Rust currently supports M:N scheduling through the runtime's `Scheduler` type. The standard library should _also_ support 1:1 scheduling. This is obviously a lofty goal, and not quite as easy as just changing a few lines of code here and there.\n\nIn my opinion, this ticket can be closed when this code runs:\n\n``` rust\nuse std::comm::stream;\n\n#[start]\nfn main(_: int, _: **u8) -> int {\n  let (port1, chan1) = stream();\n  let (port2, chan2) = stream();\n  do spawn {\n    println!(\"{}\", port1.recv());\n    chan2.send(0);\n  }\n  chan1.send(2);\n  port2.recv()\n}\n```\n\nThe main point of this code is that we have lots of basic runtime services working _without_ \"booting the runtime.\"\n\nI believe that the best way to achieve this goal is to sort out what exactly needs to be changed and start moving everything in the right direction. At its core, a 1:1 scheduling mode means that there is no `Scheduler` interface. Once we remove this, there are a few implications for runtime:\n- All libuv-based I/O does not work\n- No `comm` can be used without the scheduler\n- Task spawning is very closely tied to the scheduler\n\nFor each of these items, however, there are clear correspondences in a 1:1 world:\n- Thread-blocking I/O (just use the normal posix apis)\n- communication pthreads cvar/mutex for blocking\n- Task spawning corresponds to thread spawning\n\nIn addition to having differences, I believe that the to scheduling modes share a core idea which is that of a local `Task`. This task encapsulates information such as garbage collection, its name, stdio/logger handles, etc.\n\nHere are my personal thoughts about going about doing this.\n## I/O\n\nThis story is actually pretty much set as-is. You can use `println!` without booting the runtime today, and everything works just fine. The reason for this is that I/O is multiplexed over libuv/native implementation via the `EventLoop` and `IoFactory` traits. The major workhorse is the `IoFactory` trait, but the idea is that by default all rust code uses the \"native I/O\" factory which issues thread-blocking posix-like calls by default.\n\nI believe that this component of 1:1 scheduling can be considered done. The reason for this is that the `std::io` primitives all \"just work\" in both a libuv-backed and native-backed environment (assuming they both have filled-out implementations). I'm sure that there are remaining rough edges around the IoFactory and such, but the ideas are all there and running today.\n## Communication\n\nCurrently all of the `std::comm` primitives, implemented in `std::rt::comm`, are very tightly integrated to the `Scheduler`. This does not allow them to be used at all when the runtime is not present.\n\nMost of their implementation would be the same between a 1:1 and M:N model, except for the two concepts of \"I would like to block\" and \"wake up this task\". One could imagine code along the lines of:\n\n``` rust\nif have_local_scheduler() {\n  scheduler.block_on(&mutex);\n} else {\n  cond_wait(&my_cond, &mutex);\n}\n```\n\nThis would work, but I believe that there is a better solution. In the solution for I/O, there is one \"central dispatch\" point which has the \"if local_scheduler\" check, and I like how that has turned out, so it seems like something could also be used for communication primitives.\n\nI believe that the only way to do this today would be to use trait objects. The `Chan` and `Port` types would have an underlying `~RtioChan` and `~RtioPort` object (stealing names from I/O). There are two downsides to this approach:\n1. This forces an allocation. I don't think that this is really that much of a problem b/c you're already allocating other things for the channel/port, I don't think that they're ever going to be 0-allocations except for this trait object boundary.\n2. This forces virtual dispatch. I'm comfortable saying that this is perfectly reasonable for I/O because I/O is the bottleneck, not a jmp to a register. For communication primitives, however, this may not be the case. My gut tells me that one virtual jmp is nothing compared to the number of atomic instructions which need to happen, but I do not have numbers to back up that claim.\n\nRegardless, let's say that we're not going to litter all methods with `if in_scheduler() { ... }`. There is then the question of where does this decision go? For I/O, this is currently solved at Scheduler-creation time. The I/O implementation is selected by a factory located in the crate map. This may also be a good place for a `CommunicationFactory` and it's related set of functions? I would be wary of putting too many \"factories\" all over the place, however. To me, though, this seems to be a sufficiently configurable location for where to place the channel/port factory type.\n## Tasks\n\nTask spawning is a similar problem to the communication types. There is currently a nice interface defined by the `std::task` module for spawning new tasks. I'm not intimately familiar with the interface, but I believe that it's mostly building up configuration, then hitting the go button. This means that the abstraction's api is basically firing off some configuration along with a `proc` and letting it run.\n\nThis sounds to me a lot like another factory, and a lot like another slot in the crate map. I don't want to go too overboard with these factories, though. I believe that the scheduler is also very tightly coupled to the \"task factory\" because 1:1 would just call Thread::start while M:N would have to start dealing with the local scheduler. I'll talk a little more about booting the runtime later, but I want to control the explosion of \"trait factories\" that we have if we decide to pursue this change.\n## A local task\n\nI believe that it's necessary to _always_ in all rust code have the concept of a local task. This task contains common functionality to all scheduling systems which allows many other components of libstd to work. This includes things like `std::local_data`, efficient `println`, pretty failure, etc.\n\nI think that this task will also always be stored in OS-level TLS, so I don't think that there's much to worry about here. This would just require a refactoring of the current `Task` type stored in TLS (perhaps).\n## Intermingling M:N and 1:1\n\nI can imagine intermingling these two scheduling modes could become very interesting. For example, let's say that I create a (port, chan) pair. If the runtime were super smart, it would not block the thread when the port called recv() in an M:N situation, but it would block the thread in a 1:1 situation. Basically communication across boundaries would \"do the right thing\".\n\nI don't like the sound of that, and I think it may be just too much of a burden to maintain. I think that the idea of a thread pool is still a useful thing to have, but perhaps you should be forced to resort to custom communication between yourself and the thread pool. I could be wrong about the utility of this mode, however, and we may want to design around it as well.\n## Booting the runtime\n\nIn 1:1 situations, there's no need to boot the runtime. Everything is always available to you at all times. In an M:N situation, however, we must boot the runtime because the threadpool has to be started at some point. I'm willing to chalk this up to \"well, that's M:N for you\" in the sense that we don't need to specially accommodate use cases beyond a nice `mton::boot` function (or something like that)\n## Conclusion\n\nThere's still not a whole lot that's concrete in this proposal, and that's partly intentional. I want to discuss this strategy and how things are working out, and then the concrete proposal can come next. I hope to have enough actionable content here to move forward to a proposal after some discussion, however.\n", "closed_by": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/10493/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/10493/timeline", "performed_via_github_app": null, "state_reason": "completed"}