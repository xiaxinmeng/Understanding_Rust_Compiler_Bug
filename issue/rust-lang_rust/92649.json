{"url": "https://api.github.com/repos/rust-lang/rust/issues/92649", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/92649/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/92649/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/92649/events", "html_url": "https://github.com/rust-lang/rust/issues/92649", "id": 1096436169, "node_id": "I_kwDOAAsO6M5BWknJ", "number": 92649, "title": "Tracking Issue for `panic::update_hook`", "user": {"login": "Badel2", "id": 15879619, "node_id": "MDQ6VXNlcjE1ODc5NjE5", "avatar_url": "https://avatars.githubusercontent.com/u/15879619?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Badel2", "html_url": "https://github.com/Badel2", "followers_url": "https://api.github.com/users/Badel2/followers", "following_url": "https://api.github.com/users/Badel2/following{/other_user}", "gists_url": "https://api.github.com/users/Badel2/gists{/gist_id}", "starred_url": "https://api.github.com/users/Badel2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Badel2/subscriptions", "organizations_url": "https://api.github.com/users/Badel2/orgs", "repos_url": "https://api.github.com/users/Badel2/repos", "events_url": "https://api.github.com/users/Badel2/events{/privacy}", "received_events_url": "https://api.github.com/users/Badel2/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 650846969, "node_id": "MDU6TGFiZWw2NTA4NDY5Njk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-tracking-issue", "name": "C-tracking-issue", "color": "f5f1fd", "default": false, "description": "Category: A tracking issue for an RFC or an unstable feature."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2022-01-07T15:48:49Z", "updated_at": "2023-02-02T21:39:56Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Feature gate: `#![feature(panic_update_hook)]`\r\n\r\nThis is a tracking issue for the `panic::update_hook` function.\r\n\r\nThis function allows creating panic hooks that forward the call to the previously set panic hook, without race conditions. It works by taking a closure that receives the old panic hook and the panic info, and it is atomically set as the panic hook by ensuring that during the execution of `panic::update_hook` no other thread can modify the panic hook.\r\n\r\nThis common use case:\r\n\r\n```rust\r\nlet prev = panic::take_hook();\r\npanic::set_hook(Box::new(move |info| {\r\n    println!(\"panic handler A\");\r\n    prev(info);\r\n}));\r\n```\r\n\r\nBecomes:\r\n\r\n```rust\r\npanic::update_hook(|prev, info| {\r\n    println!(\"panic handler A\");\r\n    prev(info);\r\n});\r\n```\r\n\r\nUsing the old approach is fine if there is some guarantee that there are no other threads trying to change the panic hook. The main goal of this feature is to enable the use case of safely adding panic hooks after the application has been initialized, because the existing functions `panic::set_hook` and `panic::take_hook` are not enough to implement that, consider this case:\r\n\r\n*    Thread A calls `panic::take_hook()`\r\n*    Thread B calls `panic::take_hook()`\r\n*    Thread A calls `panic::set_hook()`\r\n*    Thread B calls `panic::set_hook()`\r\n\r\nAnd the result is that the original panic hook has been lost, as well as the panic hook set by thread A. The resulting panic hook will be the one set by thread B, which forwards to the default panic hook. Using the new `panic::update_hook` function, this race condition is impossible, and the result will be either `A, B, original` or `B, A, original`.\r\n\r\n### Public API\r\n\r\n```rust\r\n// std::panic\r\n\r\npub fn update_hook<F>(hook_fn: F)\r\nwhere\r\n    F: Fn(&(dyn Fn(&PanicInfo<'_>) + Send + Sync + 'static), &PanicInfo<'_>)\r\n        + Sync\r\n        + Send\r\n        + 'static,\r\n```\r\n\r\n### Steps / History\r\n\r\n- [x] Implementation: #92598\r\n- [ ] Final comment period (FCP)\r\n- [ ] Stabilization PR\r\n\r\n### Unresolved Questions\r\n\r\n\r\n- Is the API flexible enough for most use cases? For example it is not possible to drop the previous handler, but if the user wanted to replace the old handler they could just use `panic::set_hook`. An alternative implementation is to take a closure that creates a panic handler, like this (available in commit 8bdf5c3de6c6e4e01f7f6241cd0f2a606c7486df):\r\n\r\n```rust\r\npanic::update_hook(|prev| {\r\n    Box::new(move |info| {\r\n        println!(\"panic handler A\");\r\n        prev(info);\r\n    })\r\n});\r\n```\r\n\r\nThat approach should be more flexible because it transfers ownership to the closure, but if the outermost closure panics the error message is \"panicked while processing panic\" which is not nice. This is a consequence of holding the `HOOK_LOCK` while executing the closure. Could be avoided using catch_unwind?", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/92649/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/92649/timeline", "performed_via_github_app": null, "state_reason": null}