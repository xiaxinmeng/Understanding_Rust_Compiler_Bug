{"url": "https://api.github.com/repos/rust-lang/rust/issues/99504", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/99504/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/99504/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/99504/events", "html_url": "https://github.com/rust-lang/rust/issues/99504", "id": 1310787999, "node_id": "I_kwDOAAsO6M5OIQmf", "number": 99504, "title": "Bug: Very inefficient code generated for async functions setup (and likely for generators in general)", "user": {"login": "schreter", "id": 40718699, "node_id": "MDQ6VXNlcjQwNzE4Njk5", "avatar_url": "https://avatars.githubusercontent.com/u/40718699?v=4", "gravatar_id": "", "url": "https://api.github.com/users/schreter", "html_url": "https://github.com/schreter", "followers_url": "https://api.github.com/users/schreter/followers", "following_url": "https://api.github.com/users/schreter/following{/other_user}", "gists_url": "https://api.github.com/users/schreter/gists{/gist_id}", "starred_url": "https://api.github.com/users/schreter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/schreter/subscriptions", "organizations_url": "https://api.github.com/users/schreter/orgs", "repos_url": "https://api.github.com/users/schreter/repos", "events_url": "https://api.github.com/users/schreter/events{/privacy}", "received_events_url": "https://api.github.com/users/schreter/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 1927601458, "node_id": "MDU6TGFiZWwxOTI3NjAxNDU4", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-mir-opt", "name": "A-mir-opt", "color": "f7e101", "default": false, "description": "Area: MIR optimizations"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 18, "created_at": "2022-07-20T10:06:17Z", "updated_at": "2022-08-17T16:02:25Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "What we see in our project using also larger `Future`s is *a lot* of unnecessary memory copying. These memcpy() calls are the hottest function in the profile (and I mean, in some cases, very dominant, like 90%, even with optimization level 3). I searched for similar issues, but found none, so here we go:\r\n\r\nWhat happens:\r\n\r\n- Calling an async function in fact calls a stub producing a `Future` (which is in fact a generator, which is later polled). This `Future` is stored in the callers's async function \"stack\" (i.e., it's `Future`), so the caller's `Future` is the aggregate of the parent function state and the called function's `Future` (with some layout optimizations if calling multiple async function in independent blocks).\r\n- Unfortunately, instead of telling the `Future` generator to materialize the `Future` directly into the proper place in the caller's state, the `Future` is first materialized on the regular stack and then *copied* from the stack to the caller's `Future`.\r\n- Now, we have a loop calling a request handler which supports various request types (dispatched by a `match` statement) where one or more of them produce a large `Future`. Then, the call to the request handler materializes a `Future` by writing a few words to the stack and then this (practically empty) space is copied in full from the stack to the caller's `Future` (i.e., including the uninitialized space - it's simply a binary move).\r\n\r\nThis wastes cycles like there is no tomorrow - instead of materializing the callee's `Future` on the stack, async functions should materialize the callee's `Future` directly in-place in the caller's `Future`. That would save the copying (and, especially, copying of still uninitialized space!).\r\n\r\nA minimal example in compiler explorer is here: https://godbolt.org/z/b45MTex3e. You can see that `callee().await` first materializes the `Future` on stack and then it's copied into proper place.\r\n\r\nGenerated instructions (Intel):\r\n\r\n```\r\n        sub     rsp, 520    # in function prelude, reserve space for temporaries\r\n...\r\n        mov     r15, rdi    # in function prelude, arg0 (&mut Future) of the caller\r\n...\r\n        mov     rbx, rsp    # the address of a temporary for callee's Future\r\n        mov     rdi, rbx    # set as arg0 of the stub generating the Future\r\n        call    qword ptr [rip + example::callee@GOTPCREL]\r\n        mov     edx, 516    # size of the callee's Future (including any uninitialized stuff)\r\n        mov     rdi, r15    # position of the callee's Future inside of caller's Future\r\n        mov     rsi, rbx    # temporary variable with callee's Future\r\n        call    qword ptr [rip + memcpy@GOTPCREL]\r\n```\r\n\r\nWhat I'd expect to see:\r\n\r\n```\r\n        (no space reservation for the temporary of callee's Future)\r\n...\r\n        mov     r15, rdi    # in function prelude, arg0 (&mut Future) of the caller\r\n...\r\n        mov     rdi, r15    # set as arg0 of the stub generating the Future to the proper position\r\n        call    qword ptr [rip + example::callee@GOTPCREL]\r\n        (no memcpy, since the callee's Future is already materialized in the right place)\r\n```\r\n\r\nThis might be related to #97540, I also posted it there first.\r\n\r\nInterestingly, the same problem does NOT happen when calling a function producing a large result and storing it in a variable in the async closure, subsequently using that variable later. In that case, the function producing a large result produces the value directly in future's state. This is also true when storing the large generated future in a variable, pinning it explicitly and awaiting it (as demonstrated via https://godbolt.org/z/dWzoqEjh1).\r\n\r\nWe found some temporary workarounds for the problem, boxing some especially large futures and/or the abovementioned workaround. This helps improve the performance somewhat, but memory allocation is also not particularly cheap. Further, hunting down these issues requires a lot of analysis time (since it's also not possible to set a warning level to warn about large futures). Therefore, these are not practicable.\r\n\r\nReal solution to the problem, removing unnecessary memcpy, would be very desirable, since that would help performance in async code in general. It looks like some move optimization is missing.\r\n\r\nBTW, I tried to post this directly as a bug, but the \"Submit new issue\" was grayed out. Therefore, I'm submitting it as a blank issue.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/99504/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/99504/timeline", "performed_via_github_app": null, "state_reason": null}