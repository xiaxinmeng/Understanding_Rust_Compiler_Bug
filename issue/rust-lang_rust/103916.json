{"url": "https://api.github.com/repos/rust-lang/rust/issues/103916", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/103916/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/103916/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/103916/events", "html_url": "https://github.com/rust-lang/rust/issues/103916", "id": 1434329265, "node_id": "I_kwDOAAsO6M5VfiCx", "number": 103916, "title": "lock free ringbuffer can't work on --release mode", "user": {"login": "soloist-v", "id": 61590877, "node_id": "MDQ6VXNlcjYxNTkwODc3", "avatar_url": "https://avatars.githubusercontent.com/u/61590877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/soloist-v", "html_url": "https://github.com/soloist-v", "followers_url": "https://api.github.com/users/soloist-v/followers", "following_url": "https://api.github.com/users/soloist-v/following{/other_user}", "gists_url": "https://api.github.com/users/soloist-v/gists{/gist_id}", "starred_url": "https://api.github.com/users/soloist-v/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/soloist-v/subscriptions", "organizations_url": "https://api.github.com/users/soloist-v/orgs", "repos_url": "https://api.github.com/users/soloist-v/repos", "events_url": "https://api.github.com/users/soloist-v/events{/privacy}", "received_events_url": "https://api.github.com/users/soloist-v/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 10, "created_at": "2022-11-03T09:10:24Z", "updated_at": "2022-11-04T08:34:40Z", "closed_at": "2022-11-03T11:09:17Z", "author_association": "NONE", "active_lock_reason": null, "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\n\r\nI tried this code:\r\n\r\n```rust\r\nuse std::path::Display;\r\nuse std::sync::Arc;\r\n\r\n\r\n#[derive(Debug)]\r\npub struct RingBuffer<T, const m_size: usize> {\r\n    idx_head: usize,\r\n    idx_tail: usize,\r\n    m_data: [T; m_size],\r\n}\r\n\r\npub trait Queue<T> {\r\n    fn new_empty() -> Self;\r\n    fn push(&mut self, value: T) -> bool;\r\n    fn pop(&mut self) -> Option<&T>;\r\n    fn is_full(&self) -> bool;\r\n    fn is_empty(&self) -> bool;\r\n}\r\n\r\npub trait Init<T, F: FnMut(usize) -> T> {\r\n    fn new(initializer: F) -> Self;\r\n}\r\n\r\nimpl<T, const Size: usize, F: FnMut(usize) -> T> Init<T, F> for RingBuffer<T, Size> {\r\n    fn new(initializer: F) -> Self {\r\n        RingBuffer::<T, Size> {\r\n            idx_head: 0,\r\n            idx_tail: 0,\r\n            m_data: array_init::array_init(initializer),\r\n        }\r\n    }\r\n}\r\n\r\nimpl<T, const Size: usize> Queue<T> for RingBuffer<T, Size>\r\n{\r\n    fn new_empty() -> Self {\r\n        RingBuffer::<T, Size> {\r\n            idx_head: 0,\r\n            idx_tail: 0,\r\n            m_data: array_init::array_init(|_| {\r\n                unsafe {\r\n                    std::mem::zeroed()\r\n                }\r\n            }),\r\n        }\r\n    }\r\n\r\n    fn push(&mut self, value: T) -> bool {\r\n        let mut head = self.idx_head + 1;\r\n        if head == Size {\r\n            head = 0;\r\n        }\r\n        if head == self.idx_tail {\r\n            return false;\r\n        }\r\n        self.m_data[self.idx_head] = value;\r\n        self.idx_head = head;\r\n        return true;\r\n    }\r\n\r\n    fn pop(&mut self) -> Option<&T> {\r\n        let mut tail = self.idx_tail;\r\n        if self.idx_head == tail {\r\n            return None;\r\n        }\r\n        let res = &self.m_data[tail];\r\n        tail += 1;\r\n        if tail == Size {\r\n            tail = 0;\r\n        }\r\n        self.idx_tail = tail;\r\n        return Some(res);\r\n    }\r\n\r\n    fn is_full(&self) -> bool {\r\n        self.idx_tail == (self.idx_head + 1) % Size\r\n    }\r\n\r\n    fn is_empty(&self) -> bool {\r\n        self.idx_head == self.idx_tail\r\n    }\r\n}\r\n\r\nimpl<T, const Size: usize> RingBuffer<T, Size> {\r\n    pub fn clear(&mut self) {\r\n        self.m_data = array_init::array_init(|_| {\r\n            unsafe {\r\n                std::mem::zeroed()\r\n            }\r\n        });\r\n        self.idx_head = 0;\r\n        self.idx_tail = 0;\r\n    }\r\n    pub fn front(&self) -> usize {\r\n        self.idx_head\r\n    }\r\n    pub fn rear(&self) -> usize {\r\n        self.idx_tail\r\n    }\r\n    pub fn size() -> usize {\r\n        Size\r\n    }\r\n}\r\n\r\n\r\npub struct SharedRingBuffer<T, const m_size: usize> {\r\n    pub ringbuffer: Arc<RingBuffer<T, m_size>>,\r\n}\r\n\r\nimpl<T, const Size: usize> Clone for SharedRingBuffer<T, Size> {\r\n    fn clone(&self) -> Self {\r\n        // println!(\"clone before: {:p}\", &(self.ringbuffer.idx_head));\r\n        let res = Self {\r\n            ringbuffer: self.ringbuffer.clone(),\r\n        };\r\n        // println!(\"clone after: {:p}\", &res.ringbuffer.idx_head);\r\n        res\r\n    }\r\n}\r\n\r\nimpl<T, const Size: usize, F: FnMut(usize) -> T> Init<T, F> for SharedRingBuffer<T, Size> {\r\n    fn new(initializer: F) -> Self {\r\n        Self {\r\n            ringbuffer: Arc::new(RingBuffer::<T, Size>::new(initializer)),\r\n        }\r\n    }\r\n}\r\n\r\nimpl<T, const Size: usize, > Queue<T> for SharedRingBuffer<T, Size> {\r\n    fn new_empty() -> Self {\r\n        Self {\r\n            ringbuffer: Arc::new(RingBuffer::<T, Size>::new_empty()),\r\n        }\r\n    }\r\n\r\n    fn push(&mut self, value: T) -> bool {\r\n        unsafe {\r\n            (*Arc::get_mut_unchecked(&mut self.ringbuffer)).push(value)\r\n        }\r\n    }\r\n\r\n    fn pop(&mut self) -> Option<&T> {\r\n        unsafe {\r\n            (*Arc::get_mut_unchecked(&mut self.ringbuffer)).pop()\r\n        }\r\n    }\r\n\r\n    fn is_full(&self) -> bool {\r\n        self.ringbuffer.is_full()\r\n    }\r\n\r\n    fn is_empty(&self) -> bool {\r\n        self.ringbuffer.is_empty()\r\n    }\r\n}\r\n//////////////////////////////////TEST///////////////////////////////////////////\r\nfn test_speed1() {\r\n    let mut q: SharedRingBuffer<i32, 8> = SharedRingBuffer::new_empty();\r\n    let mut t0 = std::time::SystemTime::now();\r\n    let t = {\r\n        let mut q = q.clone();\r\n        std::thread::spawn(move || {\r\n            loop {\r\n                let t = match q.pop() {\r\n                    None => {\r\n                        // std::thread::sleep(Duration::from_millis(10)); // if enable this. Everything will be ok.\r\n                        continue;\r\n                    }\r\n                    Some(res) => res\r\n                };\r\n                if *t == -1 {\r\n                    break;\r\n                }\r\n                std::thread::sleep(Duration::from_millis(1));\r\n            }\r\n            let now = std::time::SystemTime::now();\r\n            println!(\"res: {}\", now.duration_since(t0).unwrap().as_millis());\r\n        })\r\n    };\r\n    for i in 0..99 {\r\n        loop {\r\n            if q.push(i) {\r\n                // std::thread::sleep(Duration::from_millis(10)); // if enable this. Everything will be ok.\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    q.push(-1);\r\n    t.join().unwrap();\r\n}\r\n\r\n```\r\nIn debug mode, it can work well.\r\nBut in release mode, it is blocked forever.\r\n\r\nI expected to see this happen: *explanation*\r\n\r\n*It should be print 'res:  deltatime '*\r\n\r\nInstead, this happened: *explanation*\r\n\r\n*Aactually it is blocked forever.*\r\nNote: If you addition any print code or time-consuming code it will work well.\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.67.0-nightly (95a3a7277 2022-10-31)\r\nbinary: rustc\r\ncommit-hash: 95a3a7277b44bbd2dd3485703d9a05f64652b60e\r\ncommit-date: 2022-10-31\r\nhost: x86_64-pc-windows-msvc\r\nrelease: 1.67.0-nightly\r\nLLVM version: 15.0.4\r\n```\r\n\r\n<!--\r\nInclude a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\r\nenvironment. E.g. `RUST_BACKTRACE=1 cargo build`.\r\n-->\r\n<details><summary>Backtrace</summary>\r\n<p>\r\n\r\n```\r\n<backtrace>\r\n```\r\n\r\n</p>\r\n</details>\r\n", "closed_by": {"login": "soloist-v", "id": 61590877, "node_id": "MDQ6VXNlcjYxNTkwODc3", "avatar_url": "https://avatars.githubusercontent.com/u/61590877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/soloist-v", "html_url": "https://github.com/soloist-v", "followers_url": "https://api.github.com/users/soloist-v/followers", "following_url": "https://api.github.com/users/soloist-v/following{/other_user}", "gists_url": "https://api.github.com/users/soloist-v/gists{/gist_id}", "starred_url": "https://api.github.com/users/soloist-v/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/soloist-v/subscriptions", "organizations_url": "https://api.github.com/users/soloist-v/orgs", "repos_url": "https://api.github.com/users/soloist-v/repos", "events_url": "https://api.github.com/users/soloist-v/events{/privacy}", "received_events_url": "https://api.github.com/users/soloist-v/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/103916/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/103916/timeline", "performed_via_github_app": null, "state_reason": "completed"}