{"url": "https://api.github.com/repos/rust-lang/rust/issues/52874", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/52874/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/52874/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/52874/events", "html_url": "https://github.com/rust-lang/rust/issues/52874", "id": 345908327, "node_id": "MDU6SXNzdWUzNDU5MDgzMjc=", "number": 52874, "title": "Variadic C function calls don't decay references to pointers as other function types do", "user": {"login": "TheDan64", "id": 3749239, "node_id": "MDQ6VXNlcjM3NDkyMzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3749239?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TheDan64", "html_url": "https://github.com/TheDan64", "followers_url": "https://api.github.com/users/TheDan64/followers", "following_url": "https://api.github.com/users/TheDan64/following{/other_user}", "gists_url": "https://api.github.com/users/TheDan64/gists{/gist_id}", "starred_url": "https://api.github.com/users/TheDan64/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TheDan64/subscriptions", "organizations_url": "https://api.github.com/users/TheDan64/orgs", "repos_url": "https://api.github.com/users/TheDan64/repos", "events_url": "https://api.github.com/users/TheDan64/events{/privacy}", "received_events_url": "https://api.github.com/users/TheDan64/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 45472092, "node_id": "MDU6TGFiZWw0NTQ3MjA5Mg==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-ffi", "name": "A-ffi", "color": "f7e101", "default": false, "description": "Area: Foreign Function Interface (FFI)"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-07-30T19:47:29Z", "updated_at": "2019-01-27T19:37:39Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "It seems like calling a variadic C function doesn't hold the exact same rules for reference to pointer conversions as does calling a regular function:\r\n\r\n```rust\r\nfn bar(_a: *mut i32, _b: *mut i32) {}\r\nextern \"C\" fn bar2(_a: *mut i32, _b: *mut i32) {}\r\n\r\nextern crate libc; // 0.2.42\r\n\r\nextern \"C\" {\r\n    #[no_mangle]\r\n    fn sscanf(_: *const libc::c_char, _: *const libc::c_char, ...) -> libc::c_int;\r\n}\r\n\r\nfn main() {\r\n    let mut i: libc::c_int = 1i32;\r\n    let k: *mut libc::c_int = &mut i;\r\n    let mut l: [libc::c_int; 2] = [0; 2];\r\n\r\n    unsafe {\r\n        sscanf(k as *const libc::c_char,\r\n               b\"%u,%u\\x00\" as *const u8 as *const libc::c_char,\r\n               &mut l[0usize],\r\n               &mut l[1usize]); // Err\r\n    }\r\n\r\n    let mut x = 1;\r\n    bar(&mut x, &mut x); // Ok\r\n    bar(&mut l[0], &mut l[1]); // Ok\r\n    bar2(&mut l[0], &mut l[1]); // Ok\r\n}\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?gist=caa2db63af71f98f07b969e272a844fe&version=stable&mode=debug&edition=2015))\r\n\r\nErrors:\r\n\r\n```rust\r\n   Compiling playground v0.0.1 (file:///playground)\r\nerror[E0499]: cannot borrow `l[..]` as mutable more than once at a time\r\n  --> src/main.rs:20:21\r\n   |\r\n19 |                &mut l[0usize],\r\n   |                     --------- first mutable borrow occurs here\r\n20 |                &mut l[1usize]);\r\n   |                     ^^^^^^^^^- first borrow ends here\r\n   |                     |\r\n   |                     second mutable borrow occurs here\r\n\r\nerror: aborting due to previous error\r\n\r\nFor more information about this error, try `rustc --explain E0499`.\r\nerror: Could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n\r\n```\r\n\r\nIn this example, calls to `bar` (rust fn) and `bar2` (extern \"C\" fn) will convert the mutable references to pointers implicitly, and so they succeed at compiling even though they would not normally if the signature took mutable references per rust's standard rules.\r\n\r\nObviously because `sscanf` is variadic, it doesn't specify pointer types in its signature. I nevertheless expected the call to compile because `sscanf` is extern \"C\" and rust references should decay to C pointers.\r\n\r\nThe work around is to explicitly cast the `sscanf` references to pointers.\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/52874/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/52874/timeline", "performed_via_github_app": null, "state_reason": null}