{"url": "https://api.github.com/repos/rust-lang/rust/issues/66586", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/66586/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/66586/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/66586/events", "html_url": "https://github.com/rust-lang/rust/issues/66586", "id": 526227629, "node_id": "MDU6SXNzdWU1MjYyMjc2Mjk=", "number": 66586, "title": "possible bug in rust compiler", "user": {"login": "cscccl", "id": 58010135, "node_id": "MDQ6VXNlcjU4MDEwMTM1", "avatar_url": "https://avatars.githubusercontent.com/u/58010135?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cscccl", "html_url": "https://github.com/cscccl", "followers_url": "https://api.github.com/users/cscccl/followers", "following_url": "https://api.github.com/users/cscccl/following{/other_user}", "gists_url": "https://api.github.com/users/cscccl/gists{/gist_id}", "starred_url": "https://api.github.com/users/cscccl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cscccl/subscriptions", "organizations_url": "https://api.github.com/users/cscccl/orgs", "repos_url": "https://api.github.com/users/cscccl/repos", "events_url": "https://api.github.com/users/cscccl/events{/privacy}", "received_events_url": "https://api.github.com/users/cscccl/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2019-11-20T21:32:37Z", "updated_at": "2019-11-20T21:43:12Z", "closed_at": "2019-11-20T21:40:54Z", "author_association": "NONE", "active_lock_reason": null, "body": "/* I am new to Rust and was trying to create an implementation of Lisp style\r\n   linked lists, just for the sake of understanding Rust memory management.\r\n   The code here compiles, but goes into an infinite loop.  The culprit\r\n   is the line\r\n\r\n     p = cdr(p);\r\n\r\n   in the *length* function.  However, if this line is replaced by the\r\n   commented-out match statement beneath it, then the function works\r\n   as expected.  I do not understand why that is, because the match\r\n   does the same thing as the cdr function.  Perhaps it's something about\r\n   'deref coercion' that I don't understand well enough, but then it\r\n   shouldn't have compiled...  Thus I think it is a possible bug.\r\n*/\r\n\r\n```rust\r\n#![allow(dead_code)]\r\n// Generic version of non-destructable linked lists of types\r\n// that implements Copy trait (interface)\r\n\r\n// An enum is like a discriminated union, allows pattern matching.\r\n// But these are not like Scala case classes (not likely to be expandable)\r\nenum Lst<T:Copy> {  // withou :Copy, must treat T as possible pointer\r\n  Nil,\r\n  Cell(T,Box<Lst<T>>)\r\n}\r\n\r\nfn cons<T:Copy>(h:T, t:Lst<T>) -> Lst<T>\r\n{  Lst::Cell(h,Box::new(t)) }\r\n\r\nfn car<T:Copy>(m:&Lst<T>) -> T\r\n{\r\n   match *m {\r\n     Lst::Cell(x,_) => x,  //without *m, x is of type ref i32, need *x here\r\n     Lst::Nil => panic!(\"no car in empty list\")\r\n   }\r\n}\r\n\r\nfn cdr<T:Copy>(m:&Lst<T>) -> &Lst<T>\r\n{\r\n   match m {       // don't need to say *m or &*m, it's already borrowed\r\n     Lst::Cell(_,t) => t,   // no need to put &t here because of type of m\r\n     Lst::Nil => panic!(\"nil has no cdr\")\r\n     //Lst::Cell(_,ref t) => t,   // equivalent to above, even without ref\r\n   }\r\n}\r\n\r\nfn nil<T:Copy>() -> Lst<T>  // let nil = Lst:Nil can have only one type\r\n{ Lst::Nil }                // but this fn is polymorphic\r\n\r\nfn isnil<T:Copy>(m:&Lst<T>) -> bool\r\n{\r\n  match m {\r\n    Lst::Nil => true,\r\n    Lst::Cell(_,_) => false\r\n    }\r\n}\r\n\r\n// No tail-recursion optimization in Rust, must use loop:\r\nfn length<T:Copy>(m:&Lst<T>) -> i32\r\n{\r\n   let mut cx = 0;  // length counter\r\n   let mut p = m;  // type inferred for p is &Lst<T>, a borrow\r\n   \r\n   while !isnil(p)\r\n   {\r\n      cx+=1;\r\n      /////////////////////////////////////////////////////////////////////\r\n      p = cdr(m);  // compiles but causes infinite loop\r\n      /////////////////////////////////////////////////////////////////////      \r\n      /*   ////////// The following works if uncommented and replaces above\r\n      match p {\r\n        Lst::Cell(_,t) => {p=t;}, // ok because p is of type &Lst<T>\r\n        Lst::Nil => {}\r\n      }\r\n      */\r\n   }//while\r\n   cx\r\n}//length\r\n\r\n\r\nfn main()\r\n{\r\n   let mut m = cons(2,cons(3,cons(5,Lst::Nil)));\r\n   println!(\"{}\",car(&m));\r\n   println!(\"{}\",car(cdr(&m)));\r\n   println!(\"{}\",car(cdr(cdr(&m))));\r\n   println!(\"length {}\",length(&m));\r\n\r\n   m = cons(7,m);  // ownership returned by cons, so we can dealloc it\r\n   println!(\"{}\",car(cdr(cdr(&m))));\r\n\r\n   //let _mm = &m;  // this was allowed when using cargo build,\r\n                    // because _mm was not used below (commented out below)\r\n   let m2 = cons(11,m);   // can't use m anymore after this, owner moved\r\n   //println!(\"{}\",car(&m));   \r\n   let _m = cdr(&m2); // can have a pointer to the original m\r\n   println!(\"{}\",car(cdr(_m)));\r\n   //println!(\"{}\",car(_mm)); // can't use borrowed ref to m after owner moved\r\n   println!(\"{}\",car(&m2));\r\n// The entire list is deallocated later, not just the front cell, because\r\n// the front cell owns the next cell, which owns the next cell, etc.\r\n\r\n   // It's not possible with the version of lists to have two\r\n   // lists with different cars but same cdr, because cons does not\r\n   // take a ref, and using * will move list \"out of borrowed context\"\r\n\r\n   // let ref m = ... is same as let m = &...\r\n   let ref ms = cons(\"abc\",cons(\"xyz\",nil()));\r\n   println!(\"{}\",car(cdr(ms)));\r\n\r\n   let ref m3 = cons(10,cons(20,cons(30,nil())));\r\n   let ref m2m3 = cons(&m2,cons(m3,nil())); // a list of lists, refs are :Copy\r\n   println!(\"caadr {}\",car(car(cdr(m2m3))));\r\n\r\n   // but who owns the list if all I have is a ref?\r\n\r\n   //let realmp = *m2m3; //get \"cannot move out of borrowed content, use &*..\"\r\n   // in other words, if something's already been borrowed, then can't\r\n   // get a hold of the real thing anymore, because the borrow-pointer\r\n   // mp will then be pointing to something that's moved, meaning\r\n   // that ownership has changed.\r\n\r\n}//main\r\n```", "closed_by": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/66586/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/66586/timeline", "performed_via_github_app": null, "state_reason": "completed"}