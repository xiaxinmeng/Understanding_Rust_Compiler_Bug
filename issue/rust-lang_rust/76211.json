{"url": "https://api.github.com/repos/rust-lang/rust/issues/76211", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/76211/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/76211/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/76211/events", "html_url": "https://github.com/rust-lang/rust/issues/76211", "id": 690362925, "node_id": "MDU6SXNzdWU2OTAzNjI5MjU=", "number": 76211, "title": "associated functions don't seem to be working as intended for cdylib, but works for dylib", "user": {"login": "sarvi", "id": 1296825, "node_id": "MDQ6VXNlcjEyOTY4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1296825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sarvi", "html_url": "https://github.com/sarvi", "followers_url": "https://api.github.com/users/sarvi/followers", "following_url": "https://api.github.com/users/sarvi/following{/other_user}", "gists_url": "https://api.github.com/users/sarvi/gists{/gist_id}", "starred_url": "https://api.github.com/users/sarvi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sarvi/subscriptions", "organizations_url": "https://api.github.com/users/sarvi/orgs", "repos_url": "https://api.github.com/users/sarvi/repos", "events_url": "https://api.github.com/users/sarvi/events{/privacy}", "received_events_url": "https://api.github.com/users/sarvi/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 45472092, "node_id": "MDU6TGFiZWw0NTQ3MjA5Mg==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-ffi", "name": "A-ffi", "color": "f7e101", "default": false, "description": "Area: Foreign Function Interface (FFI)"}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2020-09-01T18:43:00Z", "updated_at": "2020-09-01T21:31:54Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\nThe suspicion on the RUST forum is that assocaited functions are not working correctly for cdylib\r\nAssociated RUST forum thread\r\nhttps://users.rust-lang.org/t/ld-preload-works-as-dylib-and-doesnt-as-cdylib-which-is-the-right-choice/48174\r\n\r\nI am building an LD_PRELOAD library.\r\nIt was recommended  in the rust forum that I use cdylib as crate type to build the Rust LD_PRELOAD shared library I am working with. I was using dylib before that.\r\nMy reading of other threads i this group also backsup his recommendation\r\nhttps://users.rust-lang.org/t/what-is-the-difference-between-dylib-and-cdylib/28847\r\n\r\nInterestingly enough dylib was working for me. I then switched cdylib and the LD_PRELOAD intercept portion stopped working. Though the .so still gets exectued as shown below.\r\n\r\nHere is an example rust shared library code I used for testing. It intercepts readlink to print some debug print messages and continues to the original readlink.\r\n```\r\nextern crate core;\r\nextern crate libc;\r\n#[macro_use]\r\nextern crate ctor; \r\n\r\n\r\nuse libc::{c_void,c_char,c_int,size_t,ssize_t};\r\n\r\nuse std::sync::atomic;\r\n\r\n#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\r\npub mod dyld_insert_libraries;\r\n\r\n/* Some Rust library functionality (e.g., jemalloc) initializes\r\n * lazily, after the hooking library has inserted itself into the call\r\n * path. If the initialization uses any hooked functions, this will lead\r\n * to an infinite loop. Work around this by running some initialization\r\n * code in a static constructor, and bypassing all hooks until it has\r\n * completed. */\r\n\r\nstatic INIT_STATE: atomic::AtomicBool = atomic::AtomicBool::new(false);\r\n\r\npub fn initialized() -> bool {\r\n    INIT_STATE.load(atomic::Ordering::SeqCst)\r\n}\r\n\r\n#[ctor]\r\nfn initialize() {\r\n    Box::new(0u8);\r\n    INIT_STATE.store(true, atomic::Ordering::SeqCst);\r\n    println!(\"Constructor\");\r\n}\r\n\r\n\r\n#[link(name = \"dl\")]\r\nextern \"C\" {\r\n    fn dlsym(handle: *const c_void, symbol: *const c_char) -> *const c_void;\r\n}\r\n\r\nconst RTLD_NEXT: *const c_void = -1isize as *const c_void;\r\n\r\npub unsafe fn dlsym_next(symbol: &'static str) -> *const u8 {\r\n    let ptr = dlsym(RTLD_NEXT, symbol.as_ptr() as *const c_char);\r\n    if ptr.is_null() {\r\n        panic!(\"redhook: Unable to find underlying function for {}\", symbol);\r\n    }\r\n    ptr as *const u8\r\n}\r\n\r\n\r\n#[allow(non_camel_case_types)]\r\npub struct readlink {__private_field: ()}\r\n#[allow(non_upper_case_globals)]\r\nstatic readlink: readlink = readlink {__private_field: ()};\r\n\r\nimpl readlink {\r\n    fn get(&self) -> unsafe extern fn (path: *const c_char, buf: *mut c_char, bufsiz: size_t) -> ssize_t  {\r\n        use ::std::sync::Once;\r\n\r\n        static mut REAL: *const u8 = 0 as *const u8;\r\n        static mut ONCE: Once = Once::new();\r\n\r\n        unsafe {\r\n            ONCE.call_once(|| {\r\n                REAL = dlsym_next(concat!(\"readlink\", \"\\0\"));\r\n            });\r\n            ::std::mem::transmute(REAL)\r\n        }\r\n    }\r\n\r\n    #[no_mangle]\r\n    pub unsafe extern \"C\" fn readlink(path: *const c_char, buf: *mut c_char, bufsiz: size_t) -> ssize_t {\r\n        println!(\"readlink\");\r\n        if initialized() {\r\n            println!(\"initialized\");\r\n            ::std::panic::catch_unwind(|| my_readlink ( path, buf, bufsiz )).ok()\r\n        } else {\r\n            println!(\"not initialized\");\r\n            None\r\n        }.unwrap_or_else(|| readlink.get() ( path, buf, bufsiz ))\r\n    }\r\n}\r\n\r\npub unsafe fn my_readlink(path: *const c_char, buf: *mut c_char, bufsiz: size_t) -> ssize_t {\r\n    println!(\"my_readlink\");\r\n    readlink.get()(path, buf, bufsiz)\r\n}\r\n\r\n```\r\nMy Cargo.toml looks like this\r\n```\r\n[package]\r\nname = \"readlink\"\r\nversion = \"0.1.0\"\r\nauthors = [\"Saravanan Shanmugham <sarvi@cisco.com>\"]\r\n\r\n[lib]\r\nname = \"readlink\"\r\ncrate_type = [\"dylib\"]\r\n\r\n[dependencies]\r\nlibc = \"0.2\"\r\nctor = \"0.1.15\"\r\n```\r\nAnd this works. I see the constructor executing, and my_readlink which is my itnercept function and ls -al /tmp/link works and shows the symlink as expected, so the original readlink was executed as well. So all is well here\r\n```\r\nbash-4.4$ LD_PRELOAD=target/debug/libreadlink.so ls -al /tmp/link \r\nConstructor\r\nreadlink\r\ninitialized\r\nmy_readlink\r\nlrwxrwxrwx 1 sarvi eng 9 Aug 31 11:11 /tmp/link -> /tmp/file\r\nbash-4.4$ \r\n```\r\n\r\nI then changed \r\n```crate_type = [\"dylib\"]```\r\nto \r\n```crate_type = [\"cdylib\"]```\r\nAnd I see this. Only the constructor of libreadlink.so gets executed. But none of the interception happens.\r\n```\r\nbash-4.4$ LD_PRELOAD=target/debug/libreadlink.so ls -al /tmp/link \r\nConstructor\r\nlrwxrwxrwx 1 sarvi eng 9 Aug 31 11:11 /tmp/link -> /tmp/file\r\nbash-4.4$ \r\n```\r\n\r\nIs cdylib the right choice? and why doesnt my interception not work as the recommended cdylib but works as a dylib ?\r\nConsidering dylib is supposed to be smaller and is working. Can I continue as dylib? Or should I be worried about any other pitfalls for dylibs exposing C externs for calls from other C programs?\r\n\r\n\r\n```rust\r\n<code>\r\n```\r\n\r\nI expected to see this happen: *explanation*\r\n\r\nInstead, this happened: *explanation*\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n`rustc --version --verbose`:\r\n```\r\nbash-4.4$ rustc -vV\r\nrustc 1.47.0-nightly (7e6d6e5f5 2020-08-16)\r\nbinary: rustc\r\ncommit-hash: 7e6d6e5f535321c2223f044caba16f97b825009c\r\ncommit-date: 2020-08-16\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.47.0-nightly\r\nLLVM versio\r\n```\r\n\r\n<!--\r\nInclude a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\r\nenvironment. E.g. `RUST_BACKTRACE=1 cargo build`.\r\n-->\r\n<details><summary>Backtrace</summary>\r\n<p>\r\n\r\n```\r\n<backtrace>\r\n```\r\n\r\n</p>\r\n</details>\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/76211/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/76211/timeline", "performed_via_github_app": null, "state_reason": null}