{"url": "https://api.github.com/repos/rust-lang/rust/issues/55107", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/55107/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/55107/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/55107/events", "html_url": "https://github.com/rust-lang/rust/issues/55107", "id": 370399347, "node_id": "MDU6SXNzdWUzNzAzOTkzNDc=", "number": 55107, "title": "float rounding is slow", "user": {"login": "raphlinus", "id": 242367, "node_id": "MDQ6VXNlcjI0MjM2Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/242367?v=4", "gravatar_id": "", "url": "https://api.github.com/users/raphlinus", "html_url": "https://github.com/raphlinus", "followers_url": "https://api.github.com/users/raphlinus/followers", "following_url": "https://api.github.com/users/raphlinus/following{/other_user}", "gists_url": "https://api.github.com/users/raphlinus/gists{/gist_id}", "starred_url": "https://api.github.com/users/raphlinus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/raphlinus/subscriptions", "organizations_url": "https://api.github.com/users/raphlinus/orgs", "repos_url": "https://api.github.com/users/raphlinus/repos", "events_url": "https://api.github.com/users/raphlinus/events{/privacy}", "received_events_url": "https://api.github.com/users/raphlinus/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 2139259423, "node_id": "MDU6TGFiZWwyMTM5MjU5NDIz", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-floating-point", "name": "A-floating-point", "color": "f7e101", "default": false, "description": "Area: Floating point numbers and arithmetic"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 25, "created_at": "2018-10-16T01:05:55Z", "updated_at": "2021-04-09T20:56:20Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "The scalar fallback for the sinewave benchmark in [fearless_simd](https://github.com/raphlinus/fearless_simd/blob/1cb5202e4c96233a90a170ba183aed1b64aa2fb1/README.md) is very slow as of the current commit, and the reason is the f32::round() operation. When that's changed to (x + 0.5).floor() it goes from 1622ns to 347ns, and 205ns with target_cpu=haswell. With default x86_64 cpu, floorf() is a function call, but it's an efficient one. The asm of roundf() that I looked at was very unoptimized (it moved the float value into int registers and did bit fiddling there). In addition, round() doesn't get auto-vectorized, but floor() does.\r\n\r\nI think there's a rich and sordid history behind this. The C standard library has 3 different functions for rounding: [`round`](http://www.cplusplus.com/reference/cmath/round/), [`rint`](http://www.cplusplus.com/reference/cmath/rint/), and [`nearbyint`](http://www.cplusplus.com/reference/cmath/nearbyint/). Of these, the first rounds values with a 0.5 fraction away from zero, and the other two use the stateful rounding direction mode. This last is arguably a wart on C and it's a good thing the idea doesn't exist in Rust. In any case, the _default_ value is FE_TONEAREST, which rounds these values to the nearest even integer (see [Gnu libc documentation](https://www.gnu.org/software/libc/manual/html_node/Rounding.html) and [Wikipedia](https://en.wikipedia.org/wiki/Rounding#Round_half_to_even); the latter does a reasonably good job of motivating why you'd want to do this, the tl;dr is that it avoids some biases).\r\n\r\nThe [implementation](https://doc.rust-lang.org/src/std/f32.rs.html#51) of [f32::floor](https://doc.rust-lang.org/std/primitive.f32.html#method.floor) is usually intrinsics::floorf32 (but it's intrinsics::floorf64 on msvc, for reasons described there). That in turn is [llvm.floor.f32](https://github.com/rust-lang/rust/blob/b8b4150c042b06c46e29a9d12101f91fe13996e0/src/librustc_codegen_llvm/intrinsic.rs#L67). Generally the other round functions are similar, til it gets to llvm. Inside llvm, one piece of evidence that \"round\" is special is that it's not listed in the [list of instrinsics that get auto-vectorized](https://llvm.org/docs/Vectorizers.html#vectorization-of-function-calls).\r\n\r\nNeither the C standard library nor llvm intrinsics have a function that rounds with \"round half to even\" behavior. This is arguably a misfeature. A case can be made that Rust should have this function; in cases where a recent Intel CPU is set as target_cpu or target_feature, it compiles to `roundps $8` (analogous to `$9` and `$a` for floor and ceil, respectively), and in compatibility mode the asm shouldn't be any slower than the existing code. I haven't investigated non-x86 architectures though.\r\n\r\nFor signal processing (the main use case of fearless_simd) I don't care much about the details of rounding of exactly 0.5 fraction values, and just want rounding to be fast. Thus, I think I'll use the _mm_round intrinsics in simd mode (with round half to even behavior) and (x + 0.5).floor() in fallback mode (with round half up behavior). It's not the case now (where I call f32::round) that the rounding behavior matches the SIMD case anyway. If there were a function with \"round half to even\" behavior, it would match the SIMD, would auto-vectorize well, and would have dramatically better performance with modern target_cpu.\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/55107/reactions", "total_count": 13, "+1": 13, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/55107/timeline", "performed_via_github_app": null, "state_reason": null}