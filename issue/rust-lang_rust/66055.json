{"url": "https://api.github.com/repos/rust-lang/rust/issues/66055", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/66055/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/66055/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/66055/events", "html_url": "https://github.com/rust-lang/rust/issues/66055", "id": 516832096, "node_id": "MDU6SXNzdWU1MTY4MzIwOTY=", "number": 66055, "title": "Setting O_NONBLOCK on stdin causes application to crash", "user": {"login": "hrvolapeter", "id": 6537500, "node_id": "MDQ6VXNlcjY1Mzc1MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/6537500?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hrvolapeter", "html_url": "https://github.com/hrvolapeter", "followers_url": "https://api.github.com/users/hrvolapeter/followers", "following_url": "https://api.github.com/users/hrvolapeter/following{/other_user}", "gists_url": "https://api.github.com/users/hrvolapeter/gists{/gist_id}", "starred_url": "https://api.github.com/users/hrvolapeter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hrvolapeter/subscriptions", "organizations_url": "https://api.github.com/users/hrvolapeter/orgs", "repos_url": "https://api.github.com/users/hrvolapeter/repos", "events_url": "https://api.github.com/users/hrvolapeter/events{/privacy}", "received_events_url": "https://api.github.com/users/hrvolapeter/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2019-11-03T14:04:05Z", "updated_at": "2019-12-06T18:56:40Z", "closed_at": "2019-12-06T18:56:40Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "After setting stdin to nonblocking (instead of waiting returns error EAGAIN) cause program to crash without any reported error.\r\n\r\nE.g `fcntl(0, FcntlArg::F_SETFL(OFlag::O_NONBLOCK))?;`\r\n\r\nThat wouldn't be so surprising since rust doesn't really support non-blocking I/O. However, more surprising fact is that it even crashes when writing to stdout without touching stdin at all.\r\n\r\n<details>\r\n<summary>Expand</summary>\r\n\r\n``` rust\r\nuse failure::Error;\r\nuse nix::fcntl::fcntl;\r\nuse nix::fcntl::FcntlArg;\r\nuse nix::fcntl::OFlag;\r\nuse nix::poll::poll;\r\nuse nix::poll::PollFd;\r\nuse nix::poll::PollFlags;\r\nuse nix::unistd::dup2;\r\nuse nix::unistd::execv;\r\nuse nix::unistd::pipe;\r\nuse nix::unistd::read;\r\nuse nix::unistd::write;\r\nuse nix::unistd::{fork, ForkResult};\r\nuse std::ffi::CString;\r\nuse std::io::Read;\r\nuse std::io::Write;\r\nuse std::sync::atomic::{AtomicBool, Ordering};\r\nuse std::sync::Arc;\r\n\r\nconst BUF_SIZE_BYTES: usize = 8 * 1024;\r\n\r\n\r\npub fn main() -> Result<(), Error> {\r\n    let (parent_read, child_write) = pipe()?;\r\n    let (child_read, parent_write) = pipe()?;\r\n    fcntl(parent_read, FcntlArg::F_SETFL(OFlag::O_NONBLOCK))?;\r\n    fcntl(0, FcntlArg::F_SETFL(OFlag::O_NONBLOCK))?;\r\n\r\n    let should_terminate: Arc<AtomicBool> = Arc::new(AtomicBool::new(false));\r\n    let r = should_terminate.clone();\r\n\r\n    ctrlc::set_handler(move || {\r\n        debug!(\"received Ctrl+C!\");\r\n        if r.load(Ordering::SeqCst) {\r\n            debug!(\"received Ctrl+C second time\");\r\n            info!(\"Ungraceful exit\");\r\n            std::process::exit(1);\r\n        }\r\n        r.store(true, Ordering::SeqCst);\r\n    })?;\r\n\r\n    match fork()? {\r\n        ForkResult::Parent { child: _ } => {\r\n            let mut flags = PollFlags::all();\r\n            flags.remove(PollFlags::POLLOUT);\r\n            flags.remove(PollFlags::POLLWRNORM);\r\n            flags.remove(PollFlags::POLLWRBAND);\r\n            let read_poold = PollFd::new(child_write, flags);\r\n            let mut read_buf = [0; BUF_SIZE_BYTES];\r\n\r\n            let _write_poold = PollFd::new(parent_write, PollFlags::all());\r\n            let mut write_buf = [0; BUF_SIZE_BYTES];\r\n\r\n            let stdin_poold = PollFd::new(0, flags);\r\n            let mut stdout = std::io::stdout();\r\n            debug!(\"{}\", flags.bits());\r\n            loop {\r\n                poll(&mut [read_poold, stdin_poold], -1)?;\r\n                debug!(\"Received interrupt\");\r\n                // Wait for either read or write availability\r\n                if should_terminate.load(Ordering::SeqCst) {\r\n                    write(parent_write, b\"exit\")?;\r\n                    debug!(\"Child stopped\");\r\n                    break;\r\n                }\r\n                while {\r\n                    debug!(\"Attempting read\");\r\n                    let bytes_read = read(parent_read, &mut read_buf);\r\n                    match bytes_read {\r\n                        Ok(bytes_read) => {\r\n                            debug!(\"Read {} byes from child, writing to stdout\", bytes_read);\r\n// CRASHES HERE\r\n                            stdout.write_all(&read_buf[0..bytes_read-1])?;\r\n                            stdout.flush()?;\r\n                            debug!(\"Done writing read data to parent stdout\");\r\n                            bytes_read != 0\r\n                        }\r\n                        err@Err(nix::Error::Sys(nix::errno::Errno::EAGAIN)) => {\r\n                            debug!(\"Reading failed with {:?}, trying again later\", err);\r\n                            false\r\n                        }\r\n                        Err(err) => {\r\n                            return Err(err.into());\r\n                        }\r\n                    }\r\n                } {\r\n                    debug!(\"reading...\");\r\n                }\r\n\r\n            }\r\n        }\r\n        ForkResult::Child => run_child(child_write, child_read)?,\r\n    }\r\n    Ok(())\r\n}\r\n\r\nfn run_child(write_fd: i32, read_fd: i32) -> Result<(), Error> {\r\n    debug!(\"Runnig child\");\r\n    dup2(read_fd, 0)?;\r\n    dup2(write_fd, 1)?;\r\n    execv(\r\n        &CString::new(\"/usr/bin/ssh\").unwrap(),\r\n        &[\r\n            CString::new(\"ssh\").unwrap(),\r\n            CString::new(\"host\").unwrap(),\r\n            CString::new(\"-T\").unwrap(),\r\n        ],\r\n    )?;\r\n    Ok(())\r\n}\r\n```\r\n</details>\r\n\r\nNow fix to this is questionable. Even documenting this behaviour could be enough or alternatively properly handle non-blocking files ", "closed_by": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/66055/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/66055/timeline", "performed_via_github_app": null, "state_reason": "completed"}