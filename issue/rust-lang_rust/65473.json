{"url": "https://api.github.com/repos/rust-lang/rust/issues/65473", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/65473/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/65473/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/65473/events", "html_url": "https://github.com/rust-lang/rust/issues/65473", "id": 507886151, "node_id": "MDU6SXNzdWU1MDc4ODYxNTE=", "number": 65473, "title": "Support index size != pointer width", "user": {"login": "nw0", "id": 13434501, "node_id": "MDQ6VXNlcjEzNDM0NTAx", "avatar_url": "https://avatars.githubusercontent.com/u/13434501?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nw0", "html_url": "https://github.com/nw0", "followers_url": "https://api.github.com/users/nw0/followers", "following_url": "https://api.github.com/users/nw0/following{/other_user}", "gists_url": "https://api.github.com/users/nw0/gists{/gist_id}", "starred_url": "https://api.github.com/users/nw0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nw0/subscriptions", "organizations_url": "https://api.github.com/users/nw0/orgs", "repos_url": "https://api.github.com/users/nw0/repos", "events_url": "https://api.github.com/users/nw0/events{/privacy}", "received_events_url": "https://api.github.com/users/nw0/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37544, "node_id": "MDU6TGFiZWwzNzU0NA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-typesystem", "name": "A-typesystem", "color": "f7e101", "default": false, "description": "Area: The type system"}, {"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 630652267, "node_id": "MDU6TGFiZWw2MzA2NTIyNjc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-feature-request", "name": "C-feature-request", "color": "f5f1fd", "default": false, "description": "Category: A feature request, i.e: not implemented / a PR."}, {"id": 1089771154, "node_id": "MDU6TGFiZWwxMDg5NzcxMTU0", "url": "https://api.github.com/repos/rust-lang/rust/labels/needs-rfc", "name": "needs-rfc", "color": "fceb9f", "default": false, "description": "This change is large or controversial enough that it should have an (e-)RFC accepted before doing it"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 13, "created_at": "2019-10-16T14:23:08Z", "updated_at": "2022-08-31T13:40:38Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "## Preliminaries\r\n`usize` is the pointer-sized unsigned integer type [1].\r\nIt is also Rust's index type for slices and loops; this definition works well when pointer size corresponds to the space of indexable objects (most targets today). Informally, `uintptr_t == size_t`.\r\n\r\nNote that the target pointer width is indisputably set by the LLVM data layout string.\r\nIt would be correct to say that it is currently impossible to have `usize` different to `target_pointer_width` without breaking numerous assumptions in rustc [2, 3].\r\n\r\nUnfortunately, `uintptr_t == size_t` doesn't hold for all architectures. For context, I've worked toward (not active) compiling Rust for MIPS/CHERI (CHERI128) [4]. This target has 128-bit capability pointers (as in layout string), and a 64-bit processor and address space.\r\n\r\nI also assume that we don't want programmers messing with pointers in Safe Rust, and that they shouldn't have to care how a pointer (or reference) is represented/manipulated by an architecture.\r\n\r\n## Problem\r\nI think that more than one type is necessary here, to distinguish between the \"index\" or \"size\" component of a pointer (a la `size_t`), and the space required to contain a pointer (`uintptr_t`).\r\n\r\nTo me, the ideal solution is to change `usize` to be in line with `size_t` and not `uintptr_t`. As @briansmith [notes](https://github.com/rust-lang/rfcs/issues/1748#issuecomment-475368575), this would be a breaking semantic change. I claim that this is only problematic on architectures where `uintptr_t != size_t`. As such, code breakage from changing this assumption is constrained to targets where the code was _already_ broken.\r\n\r\nWhy not have a 128-bit `usize`? This _is_ technically feasible, and it's the basis of my compilation of Rust for CHERI. But:\r\n* Bounds checks explode from 2 instructions to 7. Yes, this occurs with optimisation on, but no, I haven't profiled it on real-world applications.\r\n* rustc tries to index into LLVM intrinsics such as `memcpy` with 128-bit integers. This isn't defined in the backend, and _arguably shouldn't be defined_. I will not be the last person to wonder why `memcpy` doesn't generate any instructions.\r\n* The address space is 64 bits. `ptr as int` gives an LLVM `i64`, which can't be cast/isn't comparable to an `i128`; again there is no good reason to manipulate 128-bit integers here. Likewise when calling `inttoptr`, which is a valid instruction even if the result can't be dereferenced [5].\r\n\r\nIt may not be necessary to define and expose a `uintptr_t` type. It's optionally defined in C; I'm not sure programmers want to use such a type, and it could be relegated to the compiler. I haven't thought about this seriously, though.\r\n\r\n**The key issue is the conflict between index size and pointer width.** How can we resolve this conflict, and support architectures with index size != pointer width? (or: why isn't this a problem at all?)\r\n\r\n## Other questions\r\n**Is this a better kind of broken?** I don't know, that's what this issue is for. What is certain is that lots of libc-using code probably depends on `usize == uintptr_t == size_t` and that these will break in either case.\r\n\r\n**Is provenance a problem?** From my experience with the Rust compiler, no [6]. Integers (`usize`) are never cast back to pointers and dereferenced. We already know this at some level (rust-lang/unsafe-code-guidelines#52). This suggests no fundamental link between indexing (i.e. `usize`) and pointer width.\r\n\r\n**Will we really see 128-bit pointers in our lifetime?** I don't speak with authority on CHERI, but 64 bits definitely isn't enough for the \"usual\" 48-bit address space there [7].\r\n\r\n**But CHERI breaks the C specification; how can we discuss this issue in terms of C types?** This issue really isn't about CHERI [8], or C. I won't speculate on the C specification or whether it's helpful for Rust. I use C types as the people likely to engage with this issue are familiar with them.\r\n\r\n**What about LLVM address spaces?** This is a whole new can of worms. I believe rustc will only use one LLVM address space, and in particular won't support two address spaces with different pointer widths. This is an issue for CHERI in hybrid capability mode, but also of supporting any architecture with multiple address spaces.  [AVR-Rust](https://github.com/avr-rust/) probably cares about address spaces and may have some expertise here.\r\n\r\n## Related\r\n* The question of whether `usize == uintptr_t` (rust-lang/libc#1400)\r\n* Assuming that `usize` == `size_t` will break C FFI code (rust-lang/unsafe-code-guidelines#99). This isn't a problem _per se_, but we almost encourage wrong assumptions in unsafe code.\r\n* The problem of `usize` being linked to the bitness of the architecture (rust-lang/unsafe-code-guidelines#152)\r\n* This very fragile code to print out pointer width demonstrates the level of assumption in the Rust codebase (rust-lang/rust#56567); also related: rust-lang/rfcs#1748\r\n\r\n## Notes\r\n[1] From https://doc.rust-lang.org/std/primitive.usize.html\r\n[2] As remarked by @gnzlbg in https://github.com/rust-lang/libc/issues/1400#issuecomment-502308097; this related problem is a bit subtle and quite complex.\r\n[3] It isn't clear (to me!) whether this is primarily a compiler implementation problem or a semantic problem, but that is not the subject of this issue.\r\n[4] This issue does not motivate support of a particular architecture, though there has been community interest in CHERI.\r\n[5] This is relevant when finding out the size of an object, for example. While generating instructions to extend or truncate the integers is possible, this seems a silly use of cycles at compile time (and possibly runtime).\r\n[6] My experience is limited to rustc (c. 1.35 nightly), libcompiler_builtins, libcore, and liballoc. Some modification was needed to make this work, but no egregious violations.\r\n[7] See [CHERI Concentrate](https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/2019tc-cheri-concentrate.pdf) for an overview of the considerations.\r\n[8] In particular I'm not asking for help in porting Rust to CHERI, or any other platform. However, _I would like support for other architectures to be technically possible_.\r\n\r\n_(edits because I accidentally posted early)_", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/65473/reactions", "total_count": 15, "+1": 13, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 2, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/65473/timeline", "performed_via_github_app": null, "state_reason": null}