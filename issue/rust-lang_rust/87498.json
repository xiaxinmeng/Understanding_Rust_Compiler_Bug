{"url": "https://api.github.com/repos/rust-lang/rust/issues/87498", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/87498/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/87498/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/87498/events", "html_url": "https://github.com/rust-lang/rust/issues/87498", "id": 953373551, "node_id": "MDU6SXNzdWU5NTMzNzM1NTE=", "number": 87498, "title": "[Missed Optimization] Checked and overflowing shifts don't unify", "user": {"login": "Kixiron", "id": 25047011, "node_id": "MDQ6VXNlcjI1MDQ3MDEx", "avatar_url": "https://avatars.githubusercontent.com/u/25047011?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kixiron", "html_url": "https://github.com/Kixiron", "followers_url": "https://api.github.com/users/Kixiron/followers", "following_url": "https://api.github.com/users/Kixiron/following{/other_user}", "gists_url": "https://api.github.com/users/Kixiron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kixiron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kixiron/subscriptions", "organizations_url": "https://api.github.com/users/Kixiron/orgs", "repos_url": "https://api.github.com/users/Kixiron/repos", "events_url": "https://api.github.com/users/Kixiron/events{/privacy}", "received_events_url": "https://api.github.com/users/Kixiron/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2021-07-26T23:44:31Z", "updated_at": "2021-07-26T23:44:31Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "These functions are functionally (heh) identical, and as such they should at least produce the same code and ideally be unified (only output a single function to serve both invocations)\r\n\r\n```rust\r\npub fn checked(x: u32, y: u32) -> u32 {\r\n    x.checked_shl(y).unwrap_or(0)\r\n}\r\n\r\npub fn overflowing(x: u32, y: u32) -> u32 {\r\n    let (ret, overflowed) = x.overflowing_shl(y);\r\n\r\n    if overflowed {\r\n        0\r\n    } else {\r\n        ret\r\n    }\r\n}\r\n\r\n```\r\n\r\nAs I said, these functions are both identical: They shift by the given number of bits and if a shift overflow occurs they zero all bits. However, instead of producing the same assembly they produce *slightly* different asm ([godbolt](https://godbolt.org/z/5z39zj9Kx))\r\n\r\n```asm\r\nexample::checked:\r\n        mov     ecx, esi\r\n        shl     edi, cl\r\n        xor     eax, eax\r\n        cmp     esi, 31  ; <- These two lines differ\r\n        cmovbe  eax, edi ; <-\r\n        ret\r\n\r\nexample::overflowing:\r\n        mov     ecx, esi\r\n        shl     edi, cl\r\n        xor     eax, eax\r\n        cmp     esi, 32  ; `checked` has 31 instead of 32\r\n        cmovb   eax, edi ; `checked` has `cmovbe` instead of `cmovb`\r\n        ret\r\n```\r\n\r\nThe core of the issue seems to be the LLVM IR that's generated ([godbolt](https://godbolt.org/z/Ecv69Y3bv), truncated here for brevity)\r\n\r\n```llvm\r\ndefine i32 @_ZN7example7checked17h533a5075a491de55E(i32 %x, i32 %y) unnamed_addr #0 !dbg !6 {\r\n    %_4.i.i.i = and i32 %y, 31, !dbg !10\r\n    %0 = shl i32 %x, %_4.i.i.i, !dbg !21\r\n    %_6.i.i = icmp ugt i32 %y, 31, !dbg !22            ; Uses `ugt` here!\r\n    %.0.i = select i1 %_6.i.i, i32 0, i32 %0, !dbg !23\r\n    ret i32 %.0.i, !dbg !29\r\n}\r\n\r\ndefine i32 @_ZN7example11overflowing17h0cfef1404f390c77E(i32 %x, i32 %y) unnamed_addr #0 !dbg !30 {\r\n    %_4.i.i = and i32 %y, 31, !dbg !31\r\n    %0 = shl i32 %x, %_4.i.i, !dbg !34\r\n    %_6.i = icmp ult i32 %y, 32, !dbg !35              ; Uses `ult` here!\r\n    %.0 = select i1 %_6.i, i32 %0, i32 0, !dbg !36\r\n    ret i32 %.0, !dbg !37\r\n}\r\n```\r\n\r\nThe checked function compiles down to an unsigned greater than while the overflowing function compiles down to an unsigned less than, which is kinda funky. My best guess is that it's because of how switches vs. how matches are compiled from MIR to LLVM IR, the MIR seems to have [chosen to use a switch](https://godbolt.org/z/cor9cq5P6) in the `overflowing` case while dispatching to the un-inlined `Option::unwrap_or()` function in the `checked` case\r\n\r\nInterestingly, I decided to add a third function `manually_checked` that manually checks if the option is some and decides to use zero based on that ([godbolt](https://godbolt.org/z/eoWrncv6v))\r\n\r\n```rust\r\npub fn manually_checked(x: u32, y: u32) -> u32 {\r\n    let result = x.checked_shl(y);\r\n\r\n    if result.is_some() {\r\n        result.unwrap()\r\n    } else {\r\n        0\r\n    }\r\n}\r\n```\r\n\r\nAnd it manages to generate the same code as the `checked` case.\r\n\r\n```asm\r\nexample::manually_checked:\r\n        mov     ecx, esi\r\n        shl     edi, cl\r\n        xor     eax, eax\r\n        cmp     esi, 32\r\n        cmovb   eax, edi\r\n        ret\r\n```\r\n\r\nIt's also interesting to note that this does happen for the [`shr` case as well](https://godbolt.org/z/bjT1Psq5z), not just `shl`\r\n\r\n### Meta\r\n\r\nThis seems to happen on 1.53.0, nightly and beta all the way back to (at least) 1.7.0", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/87498/reactions", "total_count": 3, "+1": 1, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 2}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/87498/timeline", "performed_via_github_app": null, "state_reason": null}