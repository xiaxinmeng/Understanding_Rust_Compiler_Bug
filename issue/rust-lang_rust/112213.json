{"url": "https://api.github.com/repos/rust-lang/rust/issues/112213", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/112213/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/112213/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/112213/events", "html_url": "https://github.com/rust-lang/rust/issues/112213", "id": 1738482461, "node_id": "I_kwDOAAsO6M5nnyMd", "number": 112213, "title": "Heisen-misoptimisation on x86_64", "user": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 60344715, "node_id": "MDU6TGFiZWw2MDM0NDcxNQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/P-medium", "name": "P-medium", "color": "eb6420", "default": false, "description": "Medium priority"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 267612997, "node_id": "MDU6TGFiZWwyNjc2MTI5OTc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-unsound", "name": "I-unsound", "color": "e11d21", "default": false, "description": "Issue: A soundness hole (worst kind of bug), see: https://en.wikipedia.org/wiki/Soundness"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2023-06-02T16:24:34Z", "updated_at": "2023-06-12T09:27:55Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Fuzzer generated code, minimised and rewritten into surface Rust. Miri reports no UB under either aliasing models. The only `unsafe` here are for mutating the static mut hasher and a pointer write on a not-taken branch (the pointer happens to be dangling, so it would've been UB had the branch been taken).\r\n\r\n```rust\r\n#![feature(const_hash)]\r\nuse std::collections::hash_map::DefaultHasher;\r\nuse std::hash::{Hash, Hasher};\r\nuse std::ptr;\r\nstatic mut H: DefaultHasher = DefaultHasher::new();\r\n\r\nfn dump_var<T: Hash, U: Hash, V: Hash, W: Hash>(val0: T, val1: U, val2: V, val3: W) {\r\n    unsafe {\r\n        val0.hash(&mut H);\r\n        val1.hash(&mut H);\r\n        val2.hash(&mut H);\r\n        val3.hash(&mut H);\r\n    }\r\n}\r\npub fn fn0(mut _2: [isize; 7], mut _3: usize, mut _4: i32, mut _5: u64) -> [isize; 2] {\r\n    let mut _13: ([bool; 1],) = ([false; 1],);\r\n    let mut _14: [isize; 6] = [0; 6];\r\n    let mut _29: [isize; 6] = [0; 6];\r\n    let ret: [isize; 2] = [13; 2];\r\n    let _6 = fn1(_2);\r\n    fn5(ret, _2, _3, _2, _2, _4, _6);\r\n    dump_var(_4, _5, 0, 0);\r\n    dump_var([-112; 6], _13.0, 0, (4, 10));\r\n    _14 = [(-9223372036854775808_isize); 6];\r\n    dump_var((), (), _29, _14);\r\n    return ret;\r\n}\r\n\r\npub fn fn1(mut _10: [isize; 7]) -> *mut isize {\r\n    let arr = [0; 3];\r\n    let mut _21: (u8, u128, [u64; 3], isize, i16) = (0, 0, arr, 0, 0);\r\n    let mut _24: (u8, u128, [u64; 3], isize, i16) = (0, 0, arr, 0, 0);\r\n    dump_var(_10, _10, 0, 0);\r\n    unsafe {\r\n        _24.hash(&mut H);\r\n        _21.hash(&mut H);\r\n    }\r\n    return core::ptr::addr_of_mut!(_21.3);\r\n}\r\nfn fn5(\r\n    mut _2: [isize; 2],\r\n    mut _6: [isize; 7],\r\n    mut _7: usize,\r\n    mut _9: [isize; 7],\r\n    mut _10: [isize; 7],\r\n    mut _12: i32,\r\n    mut _16: *mut isize,\r\n) {\r\n    let mut _23: (\r\n        *const usize,\r\n        (usize, u8),\r\n        (char, i32, (i64,), u64),\r\n        char,\r\n        (\r\n            (f64, i64, i8),\r\n            [f32; 1],\r\n            (usize, u8),\r\n            i8,\r\n            (isize, i64),\r\n            [f32; 1],\r\n        ),\r\n        *const u8,\r\n    ) = (\r\n        ptr::null(),\r\n        (0, 0),\r\n        ('a', 0, (0,), 0),\r\n        'a',\r\n        ((0., 0, 0), [0.; 1], (0, 0), 0, (0, 0), [0.; 1]),\r\n        ptr::null(),\r\n    );\r\n    let mut _27: ((f64, i64, i8),) = Default::default();\r\n    loop {\r\n        _9 = _6;\r\n        let mut _20 = (-9223372036854775808_isize) as i128;\r\n        let mut _21 = (0,);\r\n        loop {\r\n            _23.0 = core::ptr::addr_of!(_23.1 .0);\r\n            _23.4 .0 = (f64::NAN, (-1102345069964335552_i64), 9_i8);\r\n            dump_var(0, 0, _6, _27.0 .1);\r\n            _27.0 = _23.4 .0;\r\n            match _27.0 .2 {\r\n                9 => {\r\n                    dump_var(_9, _21, _20, _12);\r\n                    dump_var(_2, _10, _6, _7);\r\n                    return;\r\n                }\r\n                1 => break,\r\n                _ => unsafe {\r\n                    (*_16) = 88_isize;\r\n                },\r\n            }\r\n        }\r\n    }\r\n}\r\npub fn main() {\r\n    println!(\r\n        \"{:?}\",\r\n        fn0(\r\n            [(-56_isize); 7],\r\n            15609822513776909592_usize,\r\n            -652623562_i32,\r\n            18399139786288871729_u64\r\n        )\r\n    );\r\n    unsafe {\r\n        println!(\"hash: {}\", H.finish());\r\n    }\r\n}\r\n```\r\n\r\nThe correct hash should be 12326103344558250442, which Miri agrees\r\n```console\r\n$ rustc -Zmir-opt-level=3 -Copt-level=1 repro.rs && ./repro\r\n[13, 13]\r\nhash: 12326103344558250442\r\n```\r\n\r\nWith `-Zmir-opt-level>=3` and `-Copt-level>=2`, it prints something different\r\n```console\r\n$ rustc -Zmir-opt-level=3 -Copt-level=2 repro.rs && ./repro\r\n[13, 13]\r\nhash: 5661618040229725087\r\n```\r\n\r\nI'm fairly certain that the bug is in LLVM, because in this alternative version where `fn5` is written in custom MIR, the miscompilation can be triggered with `-Zmir-opt-level=0`\r\n```console\r\n$ rustc -Zmir-opt-level=0 -Copt-level=1 repro-alt.rs && ./repro-alt\r\n[13, 13]\r\nhash: 17317577282543711276 # right\r\n$ rustc -Zmir-opt-level=0 -Copt-level=2 repro-alt.rs && ./repro-alt\r\n[13, 13]\r\nhash: 469181360651188025 # wrong\r\n```\r\n<details>\r\n<summary>repro-alt.rs</summary>\r\n\r\n```rust\r\n#![feature(const_hash)]\r\n#![feature(custom_mir, core_intrinsics)]\r\nextern crate core;\r\nuse core::intrinsics::mir::*;\r\nuse std::collections::hash_map::DefaultHasher;\r\nuse std::hash::{Hash, Hasher};\r\nstatic mut H: DefaultHasher = DefaultHasher::new();\r\nfn dump_var<T: Hash, U: Hash, V: Hash, W: Hash>(val0: T, val1: U, val2: V, val3: W) {\r\n    unsafe {\r\n        val0.hash(&mut H);\r\n        val1.hash(&mut H);\r\n        val2.hash(&mut H);\r\n        val3.hash(&mut H);\r\n    }\r\n}\r\npub fn fn0(mut _2: [isize; 7], mut _3: usize, mut _4: i32, mut _5: u64) -> [isize; 2] {\r\n    let mut _13: ([bool; 1],) = ([false; 1],);\r\n    let mut _14: [isize; 6] = [0; 6];\r\n    let mut _29: [isize; 6] = [0; 6];\r\n    let ret: [isize; 2] = [13; 2];\r\n    let _6 = fn1(_2);\r\n    fn5(ret, _2, _3, _2, _2, _4, _6);\r\n    dump_var(_4, _5, 0, 0);\r\n    dump_var([-112; 6], _13.0, 0, (4, 10));\r\n    _14 = [(-9223372036854775808_isize); 6];\r\n    _29 = [9223372036854775807_isize; 6];\r\n    dump_var((), (), _29, _14);\r\n    return ret;\r\n}\r\npub fn fn1(mut _10: [isize; 7]) -> *mut isize {\r\n    let arr = [0; 3];\r\n    let mut _21: (u8, u128, [u64; 3], isize, i16) = (0, 0, arr, 0, 0);\r\n    let mut _24: (u8, u128, [u64; 3], isize, i16) = (0, 0, arr, 0, 0);\r\n    dump_var(_10, _10, 0, 0);\r\n    unsafe {\r\n        _24.hash(&mut H);\r\n        _21.hash(&mut H);\r\n    }\r\n    return core::ptr::addr_of_mut!(_21.3);\r\n}\r\n#[custom_mir(dialect = \"runtime\", phase = \"initial\")]\r\nfn fn5(\r\n    mut _2: [isize; 2],\r\n    mut _6: [isize; 7],\r\n    mut _7: usize,\r\n    mut _9: [isize; 7],\r\n    mut _10: [isize; 7],\r\n    mut _12: i32,\r\n    mut _16: *mut isize,\r\n) {\r\n    mir! {\r\n    let _20: i128;\r\n    let _21: (i64,);\r\n    let _23: (*const usize, (usize, u8), (char, i32, (i64,), u64), char, ((f64, i64, i8), [f32; 1], (usize, u8), i8, (isize, i64), [f32; 1]), *const u8);\r\n    let _27: ((f64, i64, i8), [f32; 1], (usize, u8), i8, (isize, i64), [f32; 1]);\r\n    let _36: ();\r\n    {\r\n    Goto(bb7)\r\n    }\r\n    bb7 = {\r\n    _9 = _6;\r\n    _20 = (-9223372036854775808_isize) as i128;\r\n    _21 = (0,);\r\n    Goto(bb9)\r\n    }\r\n    bb9 = {\r\n    _23.0 = core::ptr::addr_of!(_23.1.0);\r\n    _23.4.0 = (f64::NAN, (-1102345069964335552_i64), 9_i8);\r\n    _27.0.1 = _7 as i64;\r\n    Call(_36, bb11, dump_var(0,0, _6, _27.0.1))\r\n    }\r\n    bb11 = {\r\n    _27.0 = _23.4.0;\r\n    match _27.0.2 {\r\n    1 => bb7,\r\n    9 => bb17,\r\n    _ => bb15\r\n    }\r\n    }\r\n    bb15 = {\r\n    (*_16) = 88_isize;\r\n    Goto(bb9)\r\n    }\r\n    bb17 = {\r\n    Call(_36, bb18, dump_var(Move(_9), Move(_21), Move(_20), Move(_12)))\r\n    }\r\n    bb18 = {\r\n    Call(_36, bb19, dump_var(Move(_2), Move(_10), Move(_6), Move(_7)))\r\n    }\r\n    bb19 = {\r\n    Return()\r\n    }\r\n    }\r\n}\r\npub fn main() {\r\n    println!(\r\n        \"{:?}\",\r\n        fn0(\r\n            std::hint::black_box([(-56_isize); 7]),\r\n            std::hint::black_box(15609822513776909592_usize),\r\n            std::hint::black_box(-652623562_i32),\r\n            std::hint::black_box(18399139786288871729_u64)\r\n        )\r\n    );\r\n    unsafe {\r\n        println!(\"hash: {}\", H.finish());\r\n    }\r\n}\r\n```\r\n\r\n</details>\r\n\r\nUnfortunately this is a Heisenbug: if you replace `dump_var` to something that debug-prints its arguments, the misoptimisation goes away, so I don't know which variable got the wrong value\r\n\r\nRecent LLVM miscompilation fixes (https://github.com/llvm/llvm-project/commit/e506bfa7aedb4611db861b89d45d6ece53c42aae and https://github.com/llvm/llvm-project/commit/97f0e7b06e6b76fd85fb81b8c12eba2255ff1742) do not fix this.\r\n\r\nI can only reproduce this on x86_64 Linux, not Apple Silicon\r\n\r\ncc @nikic ", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/112213/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/112213/timeline", "performed_via_github_app": null, "state_reason": null}