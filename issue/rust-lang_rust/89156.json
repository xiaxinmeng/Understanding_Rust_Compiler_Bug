{"url": "https://api.github.com/repos/rust-lang/rust/issues/89156", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/89156/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/89156/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/89156/events", "html_url": "https://github.com/rust-lang/rust/issues/89156", "id": 1003177566, "node_id": "I_kwDOAAsO6M47y0Ze", "number": 89156, "title": "Type mismatch errors in a inferrence context could provide more information about how a type is inferred", "user": {"login": "Lucretiel", "id": 1823405, "node_id": "MDQ6VXNlcjE4MjM0MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/1823405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lucretiel", "html_url": "https://github.com/Lucretiel", "followers_url": "https://api.github.com/users/Lucretiel/followers", "following_url": "https://api.github.com/users/Lucretiel/following{/other_user}", "gists_url": "https://api.github.com/users/Lucretiel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lucretiel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lucretiel/subscriptions", "organizations_url": "https://api.github.com/users/Lucretiel/orgs", "repos_url": "https://api.github.com/users/Lucretiel/repos", "events_url": "https://api.github.com/users/Lucretiel/events{/privacy}", "received_events_url": "https://api.github.com/users/Lucretiel/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 235791, "node_id": "MDU6TGFiZWwyMzU3OTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-diagnostics", "name": "A-diagnostics", "color": "f7e101", "default": false, "description": "Area: Messages for errors, warnings, and lints"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 604454086, "node_id": "MDU6TGFiZWw2MDQ0NTQwODY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-inference", "name": "A-inference", "color": "f7e101", "default": false, "description": "Area: Type inference"}, {"id": 1596122130, "node_id": "MDU6TGFiZWwxNTk2MTIyMTMw", "url": "https://api.github.com/repos/rust-lang/rust/labels/D-papercut", "name": "D-papercut", "color": "c9f7a3", "default": false, "description": "Diagnostic error that needs small tweaks"}, {"id": 1839565265, "node_id": "MDU6TGFiZWwxODM5NTY1MjY1", "url": "https://api.github.com/repos/rust-lang/rust/labels/D-terse", "name": "D-terse", "color": "c9f7a3", "default": false, "description": "A diagnostic that doesn't give enough information about the problem at hand"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2021-09-21T19:58:17Z", "updated_at": "2021-09-24T10:15:00Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Consider this code*:\r\n\r\n```rust\r\nfn use_string(s: String) {\r\n    todo!()\r\n}\r\n\r\nfn use_str(s: &str) {\r\n    todo!()\r\n}\r\n\r\nfn build_something<T>() -> T {\r\n    todo!()\r\n}\r\n\r\nfn example_failure(branch: bool) {\r\n    let value = build_something();  // 1\r\n\r\n    match branch {\r\n        false => {\r\n            use_string(value);  // 2\r\n        }\r\n        true => {\r\n            use_str(&value);  // 3\r\n            use_string(value);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThis code is correct and compiles successfully. At (1), we create an object of some generic type `T`. This type is inferred to be `String` because of (2). The `use_str` call at (3) then succeeds because `String: Deref<Target=str>`.\r\n\r\nNow, consider this variation:\r\n\r\n```rust\r\nfn example_failure(branch: bool) {\r\n    let value = build_something();\r\n\r\n    match branch {\r\n        true => {\r\n            use_str(&value);\r\n            use_string(value);\r\n        }\r\n        false => {\r\n            use_string(value);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThis is identical except that the branch arms are swapped. Intuitively, this should be fine; Rust's `match` doesn't have any fallthrough or other control flow complexity, so branch order shouldn't matter (except in the case of wildcard matching, but that doesn't change the fact that exactly one branch will only and always be executed).\r\n\r\nHowever, we instead get this error:\r\n\r\n```\r\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\r\n  --> src/lib.rs:13:9\r\n   |\r\n13 |     let value = build_something();\r\n   |         ^^^^^ doesn't have a size known at compile-time\r\n   |\r\n   = help: the trait `Sized` is not implemented for `str`\r\n   = note: all local variables must have a statically known size\r\n   = help: unsized locals are gated as an unstable feature\r\n\r\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\r\n  --> src/lib.rs:13:17\r\n   |\r\n8  | fn build_something<T>() -> T {\r\n   |                    - required by this bound in `build_something`\r\n...\r\n13 |     let value = build_something();\r\n   |                 ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\r\n   |\r\n   = help: the trait `Sized` is not implemented for `str`\r\nhelp: consider relaxing the implicit `Sized` restriction\r\n   |\r\n8  | fn build_something<T: ?Sized>() -> T {\r\n   |                     ^^^^^^^^\r\n\r\nerror[E0308]: mismatched types\r\n  --> src/lib.rs:18:24\r\n   |\r\n18 |             use_string(value);\r\n   |                        ^^^^^\r\n   |                        |\r\n   |                        expected struct `String`, found `str`\r\n   |                        help: try using a conversion method: `value.to_string()`\r\n\r\nerror[E0308]: mismatched types\r\n  --> src/lib.rs:21:24\r\n   |\r\n21 |             use_string(value);\r\n   |                        ^^^^^\r\n   |                        |\r\n   |                        expected struct `String`, found `str`\r\n   |                        help: try using a conversion method: `value.to_string()`\r\n\r\nerror: aborting due to 4 previous errors\r\n\r\nSome errors have detailed explanations: E0277, E0308.\r\nFor more information about an error, try `rustc --explain E0277`.\r\nerror: could not compile `rust-crate`\r\n```\r\n\r\nThis ended up being very confusing, because I couldn't see for a long time why `T` was being inferred as `str`. Intuitively, it didn't seem like switching the branch order should affect it, so I was looking in other places (like trying to find a misplaced `impl AsRef<str>`, for example) and it was a while before I scrutinized the branches and realized that `use_str` being first in lexical AST order is what was causing it.\r\n\r\nThis ticket isn't about that behavior; instead, I'd like to focus on the diagnostic. It would have been very helpful here to learn *why* `T` was inferred to be `str`. I'd formalize the rule like this: in the case where the type is generic *at the variable binding initialization site*, then type errors related to that value should gain an additional `Info` line describing where exactly the type inference occurred. For instance:\r\n\r\n```rust\r\nfn foo1(iter: impl Iterator<Item=i32>) -> Vec<i64> {\r\n    // No additional diagnistics needed here, since the type is concrete\r\n    // at initialization site\r\n    let vec: Vec<i32> = iter.collect();\r\n    vec\r\n}\r\n\r\nfn get_vec() -> Vec<i32> { todo!() }\r\n\r\nfn foo2(iter: impl Iterator<Item=i32>) -> Vec<i64> {\r\n    // No additional diagnistics needed here either, since the\r\n    // type is immediately fully inferred by the init expression\r\n    let vec = get_vec()\r\n    vec\r\n}\r\n\r\nfn foo3(iter: impl Iterator<Item=i32>) -> Vec<i64> {\r\n    // Now we're in trouble. We're going to get an error about Vec<i64>\r\n    // being incompatible here; it would be helpful to include a diagnostic\r\n    // highlighting the return type of `foo3` saying \"T was inferred to be\r\n    // Vec<i64> here\"\r\n    let vec = iter.collect();\r\n    vec\r\n}\r\n```\r\n\r\nThis error appears in both current stable (1.55) and current nightly (1.57, 2021-09-19 5ecc8ad8462574354a55).\r\n\r\n\\* This is slight simplification of a real world case where I ran into this issue, here: https://github.com/Lucretiel/kaydle/blob/4f0344a4ccfb0d0768c5c14c8e57bafe0395208d/kaydle/src/serde/de.rs#L958-L969", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/89156/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/89156/timeline", "performed_via_github_app": null, "state_reason": null}