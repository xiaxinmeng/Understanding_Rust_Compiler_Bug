{"url": "https://api.github.com/repos/rust-lang/rust/issues/106539", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/106539/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/106539/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/106539/events", "html_url": "https://github.com/rust-lang/rust/issues/106539", "id": 1522960090, "node_id": "I_kwDOAAsO6M5axoba", "number": 106539, "title": "Iterator::max with reference-type items cannot leverage SIMD instructions, resulting in low performance", "user": {"login": "jfaixo", "id": 14348252, "node_id": "MDQ6VXNlcjE0MzQ4MjUy", "avatar_url": "https://avatars.githubusercontent.com/u/14348252?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jfaixo", "html_url": "https://github.com/jfaixo", "followers_url": "https://api.github.com/users/jfaixo/followers", "following_url": "https://api.github.com/users/jfaixo/following{/other_user}", "gists_url": "https://api.github.com/users/jfaixo/gists{/gist_id}", "starred_url": "https://api.github.com/users/jfaixo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jfaixo/subscriptions", "organizations_url": "https://api.github.com/users/jfaixo/orgs", "repos_url": "https://api.github.com/users/jfaixo/repos", "events_url": "https://api.github.com/users/jfaixo/events{/privacy}", "received_events_url": "https://api.github.com/users/jfaixo/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2023-01-06T18:11:43Z", "updated_at": "2023-04-05T17:32:53Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "When manipulating array of numbers, it is pretty common to have to find the min/max/sum/... of it. While discussing about internals with fellow developers, someone pointed out that the C# max method leverages SIMD. By curiosity I checked for both C++ and Rust.\r\n\r\nMy findings are as follow:\r\n- LLVM is able to auto vectorize this kind of stuff\r\n- the C++ STL max_element function leverages that\r\n- my custom implementation is able to leverages that\r\n- the Rust Iter functions (max, min) cannot\r\n\r\nThis last bullet is due to the fact that the implementation does not expect the type to implement the Copy trait, and operates over references, and not actual type of the array.\r\n\r\n```Rust\r\nlet my_array = (0..ITEM_COUNT).collect::<Vec<_>>();\r\n\r\n// This is slow\r\n#[inline(never)]\r\npub fn stdlib_max<T: Ord + Copy>(a: &[T]) -> Option<T> {\r\n    a.iter().max().copied()\r\n}\r\n\r\n// This is fast\r\n#[inline(never)]\r\npub fn custom_max<T: Ord + Copy>(a: &[T]) -> Option<T> {\r\n    let first = *a.first()?;\r\n    Some(a.iter().fold(first, |x, y| std::cmp::max(x, *y)))\r\n}\r\n```\r\n\r\n=> Still, as an end user, I would have expected that the \"rust way\" to do the thing (with iterator) would be optimal, and it is not.\r\n\r\nI link a small repository with a sample and bench pointing the issue:\r\n\r\n[https://github.com/jfaixo/rust-max-bench]\r\n\r\nFor finding the max of a `[i32; 100_000]` array :\r\n\r\n```bash\r\n\u276f rustc -vV\r\nrustc 1.68.0-nightly (388538fc9 2023-01-05)\r\nbinary: rustc\r\ncommit-hash: 388538fc963e07a94e3fc3ac8948627fd2d28d29\r\ncommit-date: 2023-01-05\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.68.0-nightly\r\nLLVM version: 15.0.6\r\n\r\n\u276f cargo bench\r\n    Finished bench [optimized] target(s) in 0.00s\r\n     Running unittests src/lib.rs (target/release/deps/rust_max_bench-a5d988f9520f9dde)\r\n\r\nrunning 0 tests\r\n\r\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\r\n\r\n     Running benches/bench.rs (target/release/deps/bench-cf556ddbd1b864fb)\r\n\r\nrunning 3 tests\r\ntest custom    ... bench:       8,052 ns/iter (+/- 385)\r\ntest itertools ... bench:      94,027 ns/iter (+/- 816)\r\ntest stdlib    ... bench:      94,477 ns/iter (+/- 1,545)\r\n\r\ntest result: ok. 0 passed; 0 failed; 0 ignored; 3 measured; 0 filtered out; finished in 2.40s\r\n```\r\n\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/106539/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/106539/timeline", "performed_via_github_app": null, "state_reason": null}