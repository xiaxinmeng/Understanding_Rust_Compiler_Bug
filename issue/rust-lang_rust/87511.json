{"url": "https://api.github.com/repos/rust-lang/rust/issues/87511", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/87511/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/87511/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/87511/events", "html_url": "https://github.com/rust-lang/rust/issues/87511", "id": 953881157, "node_id": "MDU6SXNzdWU5NTM4ODExNTc=", "number": 87511, "title": "v0 mangling should avoid backrefs when they're not shorter than their target.", "user": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37547, "node_id": "MDU6TGFiZWwzNzU0Nw==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-linkage", "name": "A-linkage", "color": "f7e101", "default": false, "description": "Area: linking into static, shared libraries and binaries"}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 1049491442, "node_id": "MDU6TGFiZWwxMDQ5NDkxNDQy", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-heavy", "name": "I-heavy", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to binary size of generated code."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2021-07-27T13:24:09Z", "updated_at": "2022-08-05T14:25:53Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "While working on #61486 / #87194 I came across backrefs in byte array values (with repeating elements), which I hadn't thought about (in terms of implications on optimizing the length of a symbol), but which is otherwise entirely expected. In order to demonstrate an edge case, I encoded `some...longer...path::<{ &[0, 0, 0, 0] }>` to get `KRAh0_B12_B12_B12_E`, which is parsed as follows:\r\n```rust\r\nK       // const generic\r\n R      //  &\r\n  A     //   [\r\n   h0_  //    0u8\r\n   B12_ //    backref to \"h0_\" / `0u8`\r\n   B12_ //    backref to \"h0_\" / `0u8`\r\n   B12_ //    backref to \"h0_\" / `0u8`\r\n  E     //   ]\r\n```\r\n\r\nBecause this is a long enough symbol, the backrefs end up being (at least) 4 bytes each (to encode positions greater than 62), whereas an integer leaf constant with a `0..=15` value gets encoded as 3 bytes, so the backrefs are each adding an extra byte (and making more pointless work for the demangler).\r\n\r\nWe could avoid this by tracking the range, not just the start, of an encoded path/type/const, and one of:\r\n* skip caching the backref position when encoding that position would require more bytes than the inline size\r\n* record the range and make `print_backref` decide between actually printing the backref, and duplicating the contents of that range, inline, depending on which would be shorter\r\n\r\n<hr/>\r\n\r\nHowever, this isn't an urgent concern IMO because of the combination of these aspects:\r\n* the encoder gets to choose whether to use a backref or to repeat the encoding inline, we don't have to update decoders if we change our backref generation heuristic\r\n* most backrefs are either 3 or 4 bytes (for positions up to `62` or `62\u00b2 = 3844`, respectively)\r\n* we already special-case one-character leaves, to never record themselves for backrefs, so only less-trivial path/type/const syntax, which will produce 2 bytes or more, is relevant\r\n* paths have to include a crate root leaf (at least ~16 bytes) or a backref (at least 3 bytes), so the shortest possible paths are 5 bytes (e.g. inherent `impl` on a builtin type, using a backref for the `impl` parent module)\r\n  * this further implies that only types/consts that *don't* reference paths can be 2-3 bytes (e.g. `&str` is `Re`, `[u8]` is `Sh`, `fn()` is `FEu`, etc.)\r\n\r\nIt might be interesting to measure the size difference across some larger projects (including `rustc` and Cargo), by making this change (even inefficiently), after v0 becomes the default, but I don't expect a difference bigger than a handful of bytes per symbol, if that.\r\n\r\ncc @michaelwoerister ", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/87511/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/87511/timeline", "performed_via_github_app": null, "state_reason": null}