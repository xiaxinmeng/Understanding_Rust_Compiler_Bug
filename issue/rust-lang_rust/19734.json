{"url": "https://api.github.com/repos/rust-lang/rust/issues/19734", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/19734/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/19734/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/19734/events", "html_url": "https://github.com/rust-lang/rust/issues/19734", "id": 51705652, "node_id": "MDU6SXNzdWU1MTcwNTY1Mg==", "number": 19734, "title": "Unexpected compiler panic", "user": {"login": "th0114nd", "id": 1399455, "node_id": "MDQ6VXNlcjEzOTk0NTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1399455?v=4", "gravatar_id": "", "url": "https://api.github.com/users/th0114nd", "html_url": "https://github.com/th0114nd", "followers_url": "https://api.github.com/users/th0114nd/followers", "following_url": "https://api.github.com/users/th0114nd/following{/other_user}", "gists_url": "https://api.github.com/users/th0114nd/gists{/gist_id}", "starred_url": "https://api.github.com/users/th0114nd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/th0114nd/subscriptions", "organizations_url": "https://api.github.com/users/th0114nd/orgs", "repos_url": "https://api.github.com/users/th0114nd/repos", "events_url": "https://api.github.com/users/th0114nd/events{/privacy}", "received_events_url": "https://api.github.com/users/th0114nd/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 9618520, "node_id": "MDU6TGFiZWw5NjE4NTIw", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-ICE", "name": "I-ICE", "color": "e10c02", "default": false, "description": "Issue: The compiler panicked, giving an Internal Compilation Error (ICE) \u2744\ufe0f"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2014-12-11T16:16:16Z", "updated_at": "2014-12-15T14:08:04Z", "closed_at": "2014-12-15T14:08:04Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "The version of rust I was using was\n\n```\nrustc 0.13.0-nightly (8bca470c5 2014-12-08 00:12:30 +0000)\nbinary: rustc\ncommit-hash: 8bca470c5acf13aa20022a2c462a89f72de721fc\ncommit-date: 2014-12-08 00:12:30 +0000\nhost: x86_64-apple-darwin\nrelease: 0.13.0-nightly\n```\n\nThe file I was compiling was \n\n```\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nuse std::ascii::AsciiExt;\n\nuse dom::attr::Attr;\nuse dom::attr::AttrHelpers;\nuse dom::bindings::codegen::Bindings::AttrBinding::AttrMethods;\nuse dom::bindings::codegen::Bindings::HTMLScriptElementBinding;\nuse dom::bindings::codegen::Bindings::HTMLScriptElementBinding::HTMLScriptElementMethods;\nuse dom::bindings::codegen::Bindings::NodeBinding::NodeMethods;\nuse dom::bindings::codegen::InheritTypes::{HTMLScriptElementDerived, HTMLScriptElementCast};\nuse dom::bindings::codegen::InheritTypes::{ElementCast, HTMLElementCast, NodeCast};\nuse dom::bindings::js::{JSRef, Temporary, OptionalRootable};\nuse dom::bindings::utils::{Reflectable, Reflector};\nuse dom::document::Document;\nuse dom::element::{HTMLScriptElementTypeId, Element, AttributeHandlers};\nuse dom::element::{ElementCreator, ParserCreated};\nuse dom::eventtarget::{EventTarget, NodeTargetTypeId};\nuse dom::htmlelement::HTMLElement;\nuse dom::node::{Node, NodeHelpers, ElementNodeTypeId, window_from_node, CloneChildrenFlag};\nuse dom::virtualmethods::VirtualMethods;\nuse dom::window::WindowHelpers;\n\nuse encoding::all::UTF_8;\nuse encoding::types::{Encoding, DecodeReplace};\nuse servo_net::resource_task::load_whole_resource;\nuse servo_util::str::{DOMString, HTML_SPACE_CHARACTERS, StaticStringVec};\nuse std::cell::Cell;\nuse string_cache::Atom;\nuse url::UrlParser;\n\n#[dom_struct]\npub struct HTMLScriptElement {\n    htmlelement: HTMLElement,\n\n    /// https://html.spec.whatwg.org/multipage/scripting.html#already-started\n    already_started: Cell<bool>,\n\n    /// https://html.spec.whatwg.org/multipage/scripting.html#parser-inserted\n    parser_inserted: Cell<bool>,\n\n    /// https://html.spec.whatwg.org/multipage/scripting.html#non-blocking\n    ///\n    /// (currently unused)\n    non_blocking: Cell<bool>,\n\n    /// https://html.spec.whatwg.org/multipage/scripting.html#ready-to-be-parser-executed\n    ///\n    /// (currently unused)\n    ready_to_be_parser_executed: Cell<bool>,\n}\n\nimpl HTMLScriptElementDerived for EventTarget {\n    fn is_htmlscriptelement(&self) -> bool {\n        *self.type_id() == NodeTargetTypeId(ElementNodeTypeId(HTMLScriptElementTypeId))\n    }\n}\n\nimpl HTMLScriptElement {\n    fn new_inherited(localName: DOMString, prefix: Option<DOMString>, document: JSRef<Document>,\n                     creator: ElementCreator) -> HTMLScriptElement {\n        HTMLScriptElement {\n            htmlelement: HTMLElement::new_inherited(HTMLScriptElementTypeId, localName, prefix, document),\n            already_started: Cell::new(false),\n            parser_inserted: Cell::new(creator == ParserCreated),\n            non_blocking: Cell::new(creator != ParserCreated),\n            ready_to_be_parser_executed: Cell::new(false),\n        }\n    }\n\n    #[allow(unrooted_must_root)]\n    pub fn new(localName: DOMString, prefix: Option<DOMString>, document: JSRef<Document>,\n               creator: ElementCreator) -> Temporary<HTMLScriptElement> {\n        let element = HTMLScriptElement::new_inherited(localName, prefix, document, creator);\n        Node::reflect_node(box element, document, HTMLScriptElementBinding::Wrap)\n    }\n}\n\npub trait HTMLScriptElementHelpers {\n    /// Prepare a script (<http://www.whatwg.org/html/#prepare-a-script>)\n    fn prepare(self);\n\n    /// Prepare a script, steps 6 and 7.\n    fn is_javascript(self) -> bool;\n\n    /// Set the \"already started\" flag (<https://whatwg.org/html/#already-started>)\n    fn mark_already_started(self);\n}\n\n/// Supported script types as defined by\n/// <http://whatwg.org/html/#support-the-scripting-language>.\nstatic SCRIPT_JS_MIMES: StaticStringVec = &[\n    \"application/ecmascript\",\n    \"application/javascript\",\n    \"application/x-ecmascript\",\n    \"application/x-javascript\",\n    \"text/ecmascript\",\n    \"text/javascript\",\n    \"text/javascript1.0\",\n    \"text/javascript1.1\",\n    \"text/javascript1.2\",\n    \"text/javascript1.3\",\n    \"text/javascript1.4\",\n    \"text/javascript1.5\",\n    \"text/jscript\",\n    \"text/livescript\",\n    \"text/x-ecmascript\",\n    \"text/x-javascript\",\n];\n\nimpl<'a> HTMLScriptElementHelpers for JSRef<'a, HTMLScriptElement> {\n    fn prepare(self) {\n        // https://html.spec.whatwg.org/multipage/scripting.html#prepare-a-script\n        // Step 1.\n        if self.already_started.get() {\n            return;\n        }\n        // Step 2.\n        let was_parser_inserted = self.parser_inserted.get();\n        self.parser_inserted.set(false);\n\n        // Step 3.\n        let element: JSRef<Element> = ElementCast::from_ref(self);\n        if was_parser_inserted && element.has_attribute(&atom!(\"async\")) {\n            self.non_blocking.set(true);\n        }\n        // Step 4.\n        let text = self.Text();\n        if text.len() == 0 && !element.has_attribute(&atom!(\"src\")) {\n            return;\n        }\n        // Step 5.\n        let node: JSRef<Node> = NodeCast::from_ref(self);\n        if !node.is_in_doc() {\n            return;\n        }\n        // Step 6, 7.\n        if !self.is_javascript() {\n            return;\n        }\n        // Step 8.\n        if was_parser_inserted {\n            self.parser_inserted.set(true);\n            self.non_blocking.set(false);\n        }\n        // Step 9.\n        self.already_started.set(true);\n\n        // Step 10.\n        // TODO: If the element is flagged as \"parser-inserted\", but the element's node document is\n        // not the Document of the parser that created the element, then abort these steps.\n        if self.parser_inserted.get() && document.from_root(node) != self. \n\n        // Step 11.\n        // TODO: If scripting is disabled for the script element, then the user agent must abort\n        // these steps at this point. The script is not executed.\n\n        // Step 12.\n        // TODO: If the script element has an `event` attribute and a `for` attribute, then run\n        // these substeps...\n        if (element.has_attribute(&atom!(\"event\")) && element.has_attribute(&atom!(\"for\"))) {\n            event_attr = element.get_string_attribute(&atom!(\"event\")).trim().to_ascii_lower();\n            if event_attr != \"window\" {\n                return\n            }\n            for_attr = element.get_string_attribute(&atom!(\"for\")).trim().to_ascii_lower();\n            if for_attr != \"onload\" && for_attr != \"onload()\" {\n                return\n            }\n\n        }\n\n        // Step 13.\n        // TODO: If the script element has a `charset` attribute, then let the script block's\n        // character encoding for this script element be the result of getting an encoding from the\n        // value of the `charset` attribute.\n\n        // Step 14 and 15.\n        // TODO: Add support for the `defer` and `async` attributes.  (For now, we fetch all\n        // scripts synchronously and execute them immediately.)\n        let window = window_from_node(self).root();\n        let page = window.page();\n        let base_url = page.get_url();\n\n        let (source, url) = match element.get_attribute(ns!(\"\"), &atom!(\"src\")).root() {\n            Some(src) => {\n                if src.deref().Value().is_empty() {\n                    // TODO: queue a task to fire a simple event named `error` at the element\n                    return;\n                }\n                match UrlParser::new().base_url(&base_url).parse(src.deref().Value().as_slice()) {\n                    Ok(url) => {\n                        // TODO: Do a potentially CORS-enabled fetch with the mode being the current\n                        // state of the element's `crossorigin` content attribute, the origin being\n                        // the origin of the script element's node document, and the default origin\n                        // behaviour set to taint.\n                        match load_whole_resource(&page.resource_task, url) {\n                            Ok((metadata, bytes)) => {\n                                // TODO: use the charset from step 13.\n                                let source = UTF_8.decode(bytes.as_slice(), DecodeReplace).unwrap();\n                                (source, metadata.final_url)\n                            }\n                            Err(_) => {\n                                error!(\"error loading script {}\", src.deref().Value());\n                                return;\n                            }\n                        }\n                    }\n                    Err(_) => {\n                        // TODO: queue a task to fire a simple event named `error` at the element\n                        error!(\"error parsing URL for script {}\", src.deref().Value());\n                        return;\n                    }\n                }\n            }\n            None => (text, base_url)\n        };\n\n        window.evaluate_script_with_result(source.as_slice(), url.serialize().as_slice());\n    }\n\n    fn is_javascript(self) -> bool {\n        let element: JSRef<Element> = ElementCast::from_ref(self);\n        match element.get_attribute(ns!(\"\"), &atom!(\"type\")).root().map(|s| s.Value()) {\n            Some(ref s) if s.is_empty() => {\n                // type attr exists, but empty means js\n                debug!(\"script type empty, inferring js\");\n                true\n            },\n            Some(ref s) => {\n                debug!(\"script type={:s}\", *s);\n                SCRIPT_JS_MIMES.contains(&s.to_ascii_lower().as_slice().trim_chars(HTML_SPACE_CHARACTERS))\n            },\n            None => {\n                debug!(\"no script type\");\n                match element.get_attribute(ns!(\"\"), &atom!(\"language\"))\n                             .root()\n                             .map(|s| s.Value()) {\n                    Some(ref s) if s.is_empty() => {\n                        debug!(\"script language empty, inferring js\");\n                        true\n                    },\n                    Some(ref s) => {\n                        debug!(\"script language={:s}\", *s);\n                        SCRIPT_JS_MIMES.contains(&format!(\"text/{}\", s).to_ascii_lower().as_slice())\n                    },\n                    None => {\n                        debug!(\"no script type or language, inferring js\");\n                        true\n                    }\n                }\n            }\n        }\n    }\n\n    fn mark_already_started(self) {\n        self.already_started.set(true);\n    }\n}\n\nimpl<'a> VirtualMethods for JSRef<'a, HTMLScriptElement> {\n    fn super_type<'a>(&'a self) -> Option<&'a VirtualMethods> {\n        let htmlelement: &JSRef<HTMLElement> = HTMLElementCast::from_borrowed_ref(self);\n        Some(htmlelement as &VirtualMethods)\n    }\n\n    fn after_set_attr(&self, attr: JSRef<Attr>) {\n        match self.super_type() {\n            Some(ref s) => s.after_set_attr(attr),\n            _ => (),\n        }\n        let node: JSRef<Node> = NodeCast::from_ref(*self);\n        if attr.local_name() == &atom!(\"src\") && !self.parser_inserted.get() && node.is_in_doc() {\n            self.prepare();\n        }\n    }\n\n    fn child_inserted(&self, child: JSRef<Node>) {\n        match self.super_type() {\n            Some(ref s) => s.child_inserted(child),\n            _ => (),\n        }\n        let node: JSRef<Node> = NodeCast::from_ref(*self);\n        if !self.parser_inserted.get() && node.is_in_doc() {\n            self.prepare();\n        }\n    }\n\n    fn bind_to_tree(&self, tree_in_doc: bool) {\n        match self.super_type() {\n            Some(ref s) => s.bind_to_tree(tree_in_doc),\n            _ => ()\n        }\n\n        if tree_in_doc && !self.parser_inserted.get() {\n            self.prepare();\n        }\n    }\n\n    fn cloning_steps(&self, copy: JSRef<Node>, maybe_doc: Option<JSRef<Document>>,\n                     clone_children: CloneChildrenFlag) {\n        match self.super_type() {\n            Some(ref s) => s.cloning_steps(copy, maybe_doc, clone_children),\n            _ => (),\n        }\n\n        // https://whatwg.org/html/#already-started\n        if self.already_started.get() {\n            let copy_elem: JSRef<HTMLScriptElement> = HTMLScriptElementCast::to_ref(copy).unwrap();\n            copy_elem.mark_already_started();\n        }\n    }\n}\n\nimpl<'a> HTMLScriptElementMethods for JSRef<'a, HTMLScriptElement> {\n    make_url_getter!(Src)\n\n    make_setter!(SetSrc, \"src\")\n\n    // http://www.whatwg.org/html/#dom-script-text\n    fn Text(self) -> DOMString {\n        let node: JSRef<Node> = NodeCast::from_ref(self);\n        Node::collect_text_contents(node.children())\n    }\n\n    // http://www.whatwg.org/html/#dom-script-text\n    fn SetText(self, value: DOMString) {\n        let node: JSRef<Node> = NodeCast::from_ref(self);\n        node.SetTextContent(Some(value))\n    }\n}\n\nimpl Reflectable for HTMLScriptElement {\n    fn reflector<'a>(&'a self) -> &'a Reflector {\n        self.htmlelement.reflector()\n    }\n}\n```\n\nThe error reported was\n\n```\nhtmlscriptelement.rs:126:58: 126:62 error: macro undefined: 'atom!'\nhtmlscriptelement.rs:126         if was_parser_inserted && element.has_attribute(&atom!(\"async\")) {\n                                                                                  ^~~~\nhtmlscriptelement.rs:131:55: 131:59 error: macro undefined: 'atom!'\nhtmlscriptelement.rs:131         if text.len() == 0 && !element.has_attribute(&atom!(\"src\")) {\n                                                                               ^~~~\nhtmlscriptelement.rs:163:36: 163:40 error: macro undefined: 'atom!'\nhtmlscriptelement.rs:163         if (element.has_attribute(&atom!(\"event\")) && element.has_attribute(&atom!(\"for\"))) {\n                                                            ^~~~\nhtmlscriptelement.rs:163:78: 163:82 error: macro undefined: 'atom!'\nhtmlscriptelement.rs:163         if (element.has_attribute(&atom!(\"event\")) && element.has_attribute(&atom!(\"for\"))) {\n                                                                                                      ^~~~\nhtmlscriptelement.rs:164:56: 164:60 error: macro undefined: 'atom!'\nhtmlscriptelement.rs:164             event_attr = element.get_string_attribute(&atom!(\"event\")).trim().to_ascii_lower();\n                                                                                ^~~~\nhtmlscriptelement.rs:168:54: 168:58 error: macro undefined: 'atom!'\nhtmlscriptelement.rs:168             for_attr = element.get_string_attribute(&atom!(\"for\")).trim().to_ascii_lower();\n                                                                              ^~~~\nhtmlscriptelement.rs:187:57: 187:59 error: macro undefined: 'ns!'\nhtmlscriptelement.rs:187         let (source, url) = match element.get_attribute(ns!(\"\"), &atom!(\"src\")).root() {\n                                                                                 ^~\nhtmlscriptelement.rs:187:67: 187:71 error: macro undefined: 'atom!'\nhtmlscriptelement.rs:187         let (source, url) = match element.get_attribute(ns!(\"\"), &atom!(\"src\")).root() {\n                                                                                           ^~~~\nhtmlscriptelement.rs:206:33: 206:38 error: macro undefined: 'error!'\nhtmlscriptelement.rs:206                                 error!(\"error loading script {}\", src.deref().Value());\n                                                         ^~~~~\nhtmlscriptelement.rs:213:25: 213:30 error: macro undefined: 'error!'\nhtmlscriptelement.rs:213                         error!(\"error parsing URL for script {}\", src.deref().Value());\n                                                 ^~~~~\nhtmlscriptelement.rs:226:37: 226:39 error: macro undefined: 'ns!'\nhtmlscriptelement.rs:226         match element.get_attribute(ns!(\"\"), &atom!(\"type\")).root().map(|s| s.Value()) {\n                                                             ^~\nhtmlscriptelement.rs:226:47: 226:51 error: macro undefined: 'atom!'\nhtmlscriptelement.rs:226         match element.get_attribute(ns!(\"\"), &atom!(\"type\")).root().map(|s| s.Value()) {\n                                                                       ^~~~\nhtmlscriptelement.rs:229:17: 229:22 error: macro undefined: 'debug!'\nhtmlscriptelement.rs:229                 debug!(\"script type empty, inferring js\");\n                                         ^~~~~\nhtmlscriptelement.rs:233:17: 233:22 error: macro undefined: 'debug!'\nhtmlscriptelement.rs:233                 debug!(\"script type={:s}\", *s);\n                                         ^~~~~\nhtmlscriptelement.rs:237:17: 237:22 error: macro undefined: 'debug!'\nhtmlscriptelement.rs:237                 debug!(\"no script type\");\n                                         ^~~~~\nhtmlscriptelement.rs:238:45: 238:47 error: macro undefined: 'ns!'\nhtmlscriptelement.rs:238                 match element.get_attribute(ns!(\"\"), &atom!(\"language\"))\n                                                                     ^~\nhtmlscriptelement.rs:238:55: 238:59 error: macro undefined: 'atom!'\nhtmlscriptelement.rs:238                 match element.get_attribute(ns!(\"\"), &atom!(\"language\"))\n                                                                               ^~~~\nhtmlscriptelement.rs:242:25: 242:30 error: macro undefined: 'debug!'\nhtmlscriptelement.rs:242                         debug!(\"script language empty, inferring js\");\n                                                 ^~~~~\nhtmlscriptelement.rs:246:25: 246:30 error: macro undefined: 'debug!'\nhtmlscriptelement.rs:246                         debug!(\"script language={:s}\", *s);\n                                                 ^~~~~\nhtmlscriptelement.rs:250:25: 250:30 error: macro undefined: 'debug!'\nhtmlscriptelement.rs:250                         debug!(\"no script type or language, inferring js\");\n                                                 ^~~~~\nhtmlscriptelement.rs:275:34: 275:38 error: macro undefined: 'atom!'\nhtmlscriptelement.rs:275         if attr.local_name() == &atom!(\"src\") && !self.parser_inserted.get() && node.is_in_doc() {\n                                                          ^~~~\nhtmlscriptelement.rs:318:5: 318:20 error: macro undefined: 'make_url_getter!'\nhtmlscriptelement.rs:318     make_url_getter!(Src)\n                             ^~~~~~~~~~~~~~~\nerror: internal compiler error: tried to pop without a push\nnote: the compiler unexpectedly panicked. this is a bug.\nnote: we would appreciate a bug report: http://doc.rust-lang.org/complement-bugreport.html\nnote: run with `RUST_BACKTRACE=1` for a backtrace\n```\n\nAnd the backtrace was \n\n```\ntask 'rustc' panicked at 'Box<Any>', /Users/rustbuild/src/rust-buildbot/slave/nightly-mac/build/src/libsyntax/diagnostic.rs:180\n\nstack backtrace:\n   1:        0x10f854380 - rt::backtrace::imp::write::hbe4d08f138d707c0Lsy\n   2:        0x10f857590 - failure::on_fail::h868d2af5cb92d796nQy\n   3:        0x10faaa9f5 - unwind::begin_unwind_inner::h8e9132cd5161ca28lJc\n   4:        0x10f0128d7 - unwind::begin_unwind::h7562983727733833076\n   5:        0x10f01328f - diagnostic::Handler::bug::hdce737e54ea4c046ubG\n   6:        0x10f0efad8 - ext::base::ExtCtxt<'a>::bug::h7311b9eddc579b283r8\n   7:        0x10f0b943e - ext::base::ExtCtxt<'a>::bt_pop::h70ba23420105c926mo8\n   8:        0x10f1575b9 - ext::expand::MacroExpander<'a, 'b>.Folder::fold_method::h4d254140b60e7bf9qRf\n   9:        0x10f151336 - ext::expand::MacroExpander<'a, 'b>.Folder::fold_item_underscore::h0d0ee757905cce1c6Pf\n  10:        0x10f14f3d4 - fold::noop_fold_item::closure.54564\n  11:        0x10f0023df - ptr::P<T>::map::h5441013841086107152\n  12:        0x10f14b341 - ext::expand::expand_item::h1b2b3e29ee635969x4e\n  13:        0x10f155527 - fold::noop_fold_mod::closure.54593\n  14:        0x10f001b7f - iter::IteratorExt::collect::h17670113594715964984\n  15:        0x10f150152 - ext::expand::MacroExpander<'a, 'b>.Folder::fold_item_underscore::h0d0ee757905cce1c6Pf\n  16:        0x10f14f3d4 - fold::noop_fold_item::closure.54564\n  17:        0x10f0023df - ptr::P<T>::map::h5441013841086107152\n  18:        0x10f14b034 - ext::expand::expand_item::h1b2b3e29ee635969x4e\n  19:        0x10f191f45 - ext::expand::expand_crate::hea92d1a095b00bf1cTf\n  20:        0x10c24f6e2 - driver::phase_2_configure_and_expand::closure.16967\n  21:        0x10c20c84f - driver::phase_2_configure_and_expand::he62365fef9b99479Qha\n  22:        0x10c1ff67f - driver::compile_input::h9621f58ee716cb79pba\n  23:        0x10c29720d - run_compiler::h6d3de3a676f705b7z4b\n  24:        0x10c295c6e - run::closure.21247\n  25:        0x10c2a70ce - task::TaskBuilder::try_future::closure.22695\n  26:        0x10f82d713 - task::TaskBuilder::spawn_internal::closure.31212\n  27:        0x10faa859d - task::Task::spawn::closure.5610\n  28:        0x10fb1210c - rust_try_inner\n  29:        0x10fb120f6 - rust_try\n  30:        0x10faa8677 - unwind::try::h0dc7caf9a65e998fExc\n  31:        0x10faa844c - task::Task::run::h986874b42196d947rMb\n  32:        0x10faa814f - task::Task::spawn::closure.5586\n  33:        0x10faa9a57 - thread::thread_start::hd43c648d26329b09u4b\n  34:     0x7fff8dbc82fc - _pthread_body\n  35:     0x7fff8dbc8279 - _pthread_body\n```\n", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/19734/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/19734/timeline", "performed_via_github_app": null, "state_reason": "completed"}