{"url": "https://api.github.com/repos/rust-lang/rust/issues/74870", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/74870/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/74870/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/74870/events", "html_url": "https://github.com/rust-lang/rust/issues/74870", "id": 667001559, "node_id": "MDU6SXNzdWU2NjcwMDE1NTk=", "number": 74870, "title": "Feature request: Add a way to capture a formatter that can be passed to format helper functions", "user": {"login": "LionsAd", "id": 354804, "node_id": "MDQ6VXNlcjM1NDgwNA==", "avatar_url": "https://avatars.githubusercontent.com/u/354804?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LionsAd", "html_url": "https://github.com/LionsAd", "followers_url": "https://api.github.com/users/LionsAd/followers", "following_url": "https://api.github.com/users/LionsAd/following{/other_user}", "gists_url": "https://api.github.com/users/LionsAd/gists{/gist_id}", "starred_url": "https://api.github.com/users/LionsAd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LionsAd/subscriptions", "organizations_url": "https://api.github.com/users/LionsAd/orgs", "repos_url": "https://api.github.com/users/LionsAd/repos", "events_url": "https://api.github.com/users/LionsAd/events{/privacy}", "received_events_url": "https://api.github.com/users/LionsAd/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 630652267, "node_id": "MDU6TGFiZWw2MzA2NTIyNjc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-feature-request", "name": "C-feature-request", "color": "f5f1fd", "default": false, "description": "Category: A feature request, i.e: not implemented / a PR."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-07-28T11:34:36Z", "updated_at": "2020-08-17T21:26:48Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "### Motivation\r\n\r\nThe Display trait allows lazy formatting of data. The formatter is passed in and used by the implemented `fmt` function for the struct. Often however applications and libraries want to expose helper functions to compose the display parts of a complex struct.\r\n\r\nThere are several ways to solve that:\r\n\r\n1. Return helper structs from each of those helper functions and implement display for each of them\r\n2. Use a buffer to write the data and pass in a Vec! (but loose all formatting parameters that way)\r\n3. Use internal functions within the fmt() function itself\r\n\r\n1) is not always feasible, 2) does use a wasteful extra buffer (which fmt avoids), 3) is possible when the helper functions should be private.\r\n\r\nThe motivation however here is that not only the Display::fmt function can be called by the user, but also the helper functions to format just parts of the struct (in our use-case different statistics).\r\n\r\nThe signature of the helper functions is the same as of fmt in the Display trait:\r\n\r\n```rust\r\npub fn fmt_xyz(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\r\n  writeln!(fmt, '{}', self.field_1);\r\n}\r\n```\r\n\r\nBut it is not possible to construct a formatter manually.\r\n\r\nThe only way to be able to call the helper function is to use:\r\n\r\nThe format crate or a helper Fmt() struct, which can capture the formatter passed in.\r\n\r\n### Proposed resolution\r\n\r\nTo solve that I am arguing that either a macro or a Fmt helper trait should be available in core rust so that there exists no function that you just can't call as a user (without an extra crate or helper trait).\r\n\r\nThe usage looks for example like this:\r\n\r\n```\r\nformat!(\"{}\", Fmt(|fmt| my_struct.fmt_xyz(fmt)));\r\n```\r\n\r\nThe implementation of Fmt is as follows:\r\n\r\n```rust\r\npub struct Fmt<F>(pub F) where F: Fn(&mut fmt::Formatter) -> fmt::Result;\r\n\r\nimpl<F> fmt::Debug for Fmt<F>\r\n    where F: Fn(&mut fmt::Formatter) -> fmt::Result\r\n{\r\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\r\n        (self.0)(f)\r\n    }\r\n}\r\n```\r\n(from: https://users.rust-lang.org/t/reusing-an-fmt-formatter/8531/3)\r\n\r\n### Discussion\r\n\r\nI am not sure if `Fmt` is the right name as it feels a little bit weird.\r\n\r\nAlternative proposals are like the `format` crate does it using a macro:\r\n\r\n```\r\nlazy_format!(\"{}\", |fmt| my_struct.fmt_xyz(fmt));\r\n```\r\n\r\nOr what would be great if via some compiler magic a closure could directly work:\r\n\r\n```\r\nformat!(\"{}\", |fmt| my_struct.fmt_xyz(fmt));\r\n```\r\n\r\nFrom a user experience perspective the last version feels ideal, but I am not sure how difficult it would be to implement that.\r\n\r\n### Next steps\r\n\r\n- [ ] Discuss if it's possible to add this to rust stdlib\r\n- [ ] Discuss the name / implementation details\r\n- [ ] Create a PR\r\n\r\n### Related issues\r\n\r\n- As a bug report, but has no detailed implementation plan: https://github.com/rust-lang/rust/issues/46591\r\n\r\n### Change scope\r\n\r\nThe scope is a small addition and hence seemed to not need a RFC per the guide lines.\r\n\r\n----------\r\n\r\nIf this has a chance of going in, I am happy to provide a PR.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/74870/reactions", "total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/74870/timeline", "performed_via_github_app": null, "state_reason": null}