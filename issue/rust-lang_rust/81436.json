{"url": "https://api.github.com/repos/rust-lang/rust/issues/81436", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/81436/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/81436/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/81436/events", "html_url": "https://github.com/rust-lang/rust/issues/81436", "id": 795090258, "node_id": "MDU6SXNzdWU3OTUwOTAyNTg=", "number": 81436, "title": "Rust cannot resolve trait bound for associated type", "user": {"login": "MarinPostma", "id": 28804882, "node_id": "MDQ6VXNlcjI4ODA0ODgy", "avatar_url": "https://avatars.githubusercontent.com/u/28804882?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MarinPostma", "html_url": "https://github.com/MarinPostma", "followers_url": "https://api.github.com/users/MarinPostma/followers", "following_url": "https://api.github.com/users/MarinPostma/following{/other_user}", "gists_url": "https://api.github.com/users/MarinPostma/gists{/gist_id}", "starred_url": "https://api.github.com/users/MarinPostma/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MarinPostma/subscriptions", "organizations_url": "https://api.github.com/users/MarinPostma/orgs", "repos_url": "https://api.github.com/users/MarinPostma/repos", "events_url": "https://api.github.com/users/MarinPostma/events{/privacy}", "received_events_url": "https://api.github.com/users/MarinPostma/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2021-01-27T13:13:21Z", "updated_at": "2021-01-27T13:13:21Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "I am trying to implement the Family design pattern as per [this post by Luka](http://lukaskalbertodt.github.io/2018/08/03/solving-the-generalized-streaming-iterator-problem-without-gats.html) and [this one by Niko](http://smallcultfollowing.com/babysteps/blog/2016/11/03/associated-type-constructors-part-2-family-traits/#introducing-type-families).\r\n\r\nMy goal is to abstract db transactions thanks to a `Db` trait that exposes read and write transaction. The `Db` trait have 2 associated types, `Writer` and `Reader` that define the operations that can be done on them. Ultimately, by being generic over the `Reader` and `Writer` types, I hope to be able to mock the actual db operations.\r\n\r\n\r\n\r\nI tried this code:\r\n\r\nThis is what I have come up with: \r\n<details><summary>Code</summary>\r\n<p>\r\n\r\n```rust\r\nuse std::marker::PhantomData;\r\nuse std::error::Error;\r\n\r\n/// The `Db` trait represent an interaction with a transactional database.\r\npub trait Db {\r\n    /// A writer representing the writable operation that can be operated on a database\r\n    type Writer: for<'a> TxnFamily<'a>;\r\n    /// A reader representing the readable operation that can be operated on a database\r\n    type Reader: for<'a> TxnFamily<'a>;\r\n\r\n    /// Provide the user with a writer representing a transaction. This function should commit if\r\n    /// txn return Ok(_), an abort otherwise.\r\n    fn write<'a, F, T, E>(&'a self, txn: F) -> anyhow::Result<Result<T, E>>\r\n        where F: FnOnce(&mut <Self::Writer as TxnFamily<'a>>::Out) -> Result<T, E>,\r\n              E: Error;\r\n\r\n    /// Provide a reader representing a transaction.\r\n    fn read<'a, F, T, E>(&'a self, txn: F) -> anyhow::Result<Result<T, E>>\r\n        where F: FnOnce(&<Self::Reader as TxnFamily<'a>>::Out) -> Result<T, E>,\r\n              E: Error;\r\n}\r\n\r\npub trait TxnFamily<'a> { type Out; }\r\n\r\npub trait KvStoreDbWriter {\r\n    fn put_key(&self, key: String, value: u64) -> anyhow::Result<()>;\r\n}\r\n\r\nimpl<'a> KvStoreDbWriter for MapKvStoreDbWriter<'a> {\r\n    fn put_key(&self, key: String, value: u64) -> anyhow::Result<()> {\r\n        todo!()\r\n    }\r\n}\r\n\r\nimpl<'a> KvStoreDbReader for MapKvStoreDbReader<'a> {\r\n    fn get_key(&self, key: &str) -> anyhow::Result<Option<u64>> {\r\n        todo!()\r\n    }\r\n}\r\n\r\npub trait KvStoreDbReader {\r\n    fn get_key(&self, key: &str) -> anyhow::Result<Option<u64>>;\r\n}\r\n\r\n// it doesn't matter wha this do either, but it is parametric\r\n// over a lifetime for the length of the transaction.\r\npub struct MapKvStoreDbReader<'a>(PhantomData<&'a ()>);\r\npub struct MapKvStoreDbWriter<'a>(PhantomData<&'a ()>);\r\n\r\n\r\n// What the MapKvStore actually do is irelevant,\r\n// we want to be able to mock it a some point.\r\npub struct MapKvStoreDb;\r\n\r\npub struct MapKvStoreDbWriterTxn;\r\nimpl<'a> TxnFamily<'a> for MapKvStoreDbWriterTxn {\r\n    type Out = MapKvStoreDbWriter<'a>;\r\n}\r\n\r\npub struct MapKvStoreDbReaderTxn;\r\nimpl<'a> TxnFamily<'a> for MapKvStoreDbReaderTxn {\r\n    type Out = MapKvStoreDbReader<'a>;\r\n}\r\n\r\nimpl Db for MapKvStoreDb {\r\n    type Writer = MapKvStoreDbWriterTxn;\r\n    type Reader = MapKvStoreDbReaderTxn;\r\n    fn write<'a, F, T, E>(&'a self, _txn: F) -> anyhow::Result<Result<T, E>>\r\n        where F: FnOnce(&mut MapKvStoreDbWriter<'a>) -> Result<T, E>,\r\n              E: Error {\r\n                  todo!()\r\n              }\r\n\r\n    fn read<'a, F, T, E>(&'a self, _txn: F) -> anyhow::Result<Result<T, E>>\r\n        where F: FnOnce(&MapKvStoreDbReader<'a>) -> Result<T, E>,\r\n              E: Error {\r\n                  todo!()\r\n              }\r\n}\r\n\r\nstruct KvStore<M> {\r\n    store: M\r\n}\r\n\r\nimpl<M> KvStore<M>\r\nwhere\r\n    M: Db,\r\n    for<'a> <M::Reader as TxnFamily<'a>>::Out: KvStoreDbReader,\r\n    for<'a> <M::Writer as TxnFamily<'a>>::Out: KvStoreDbWriter,\r\n    \r\n{\r\n   fn new(store: M) -> Self {\r\n       Self { store }\r\n   } \r\n}\r\n\r\nfn main() { \r\n    let store = MapKvStoreDb;\r\n    let kv_store = KvStore::new(store);\r\n}\r\n```\r\n</p>\r\n</details>\r\n\r\nand there on the playground https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=01bba28ff362a5f59da198b38a127d0e\r\n\r\nI expect it to compile without error, since `MapKvStoreDb` implements `Db<Writer = MapKvStoreDbWriterTxn, Reader = MapKvStoreDbReaderTxn>`, and `MapKvStoreDbReaderTxn` implement `TxnFamily` whose `Out` implements `KvStoreDbReader`, and same for ` MapKvStoreDbWriterTxn`.\r\n\r\nInstead, I get this error:\r\n```\r\n   Compiling playground v0.0.1 (/playground)\r\nerror[E0599]: no function or associated item named `new` found for struct `KvStore<_>` in the current scope\r\n  --> src/main.rs:99:29\r\n   |\r\n81 | struct KvStore<M> {\r\n   | ----------------- function or associated item `new` not found for this\r\n...\r\n99 |     let kv_store = KvStore::new(store);\r\n   |                             ^^^ function or associated item not found in `KvStore<_>`\r\n   |\r\n   = note: the method `new` exists but the following trait bounds were not satisfied:\r\n           `<_ as TxnFamily<'a>>::Out: KvStoreDbReader`\r\n           `<_ as TxnFamily<'a>>::Out: KvStoreDbWriter`\r\n```\r\n\r\n\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/81436/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/81436/timeline", "performed_via_github_app": null, "state_reason": null}