{"url": "https://api.github.com/repos/rust-lang/rust/issues/80118", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/80118/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/80118/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/80118/events", "html_url": "https://github.com/rust-lang/rust/issues/80118", "id": 770071076, "node_id": "MDU6SXNzdWU3NzAwNzEwNzY=", "number": 80118, "title": "Compiler performance when compiling built-in derives is worse than desired", "user": {"login": "rylev", "id": 1327285, "node_id": "MDQ6VXNlcjEzMjcyODU=", "avatar_url": "https://avatars.githubusercontent.com/u/1327285?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rylev", "html_url": "https://github.com/rylev", "followers_url": "https://api.github.com/users/rylev/followers", "following_url": "https://api.github.com/users/rylev/following{/other_user}", "gists_url": "https://api.github.com/users/rylev/gists{/gist_id}", "starred_url": "https://api.github.com/users/rylev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rylev/subscriptions", "organizations_url": "https://api.github.com/users/rylev/orgs", "repos_url": "https://api.github.com/users/rylev/repos", "events_url": "https://api.github.com/users/rylev/events{/privacy}", "received_events_url": "https://api.github.com/users/rylev/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 64037154, "node_id": "MDU6TGFiZWw2NDAzNzE1NA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-compiletime", "name": "I-compiletime", "color": "e11d21", "default": false, "description": "Problems and improvements with respect to compile times."}, {"id": 132910982, "node_id": "MDU6TGFiZWwxMzI5MTA5ODI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-macros", "name": "A-macros", "color": "f7e101", "default": false, "description": "Area: All kinds of macros (custom derive, macro_rules!, proc macros, ..)"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2020-12-17T14:05:46Z", "updated_at": "2020-12-17T14:09:05Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "This is a follow-up issue to #80050 which was closed due to the implementation not being 100% correct. \r\n\r\nCurrently, adding `#[derive]` annotations for built-in traits such as a `PartialOrd` or `Debug` causes slower compile times than if the user implements these traits by hand. We should aim for getting these derives to be as close to \"free\" as possible when it comes to amount of time it takes to compile the code. \r\n\r\n## The Current State \r\n\r\nWe currently track the performance of derives in the [rustc-perf \"derives\" benchmark](https://github.com/rust-lang/rustc-perf/blob/e095f5021bf01cf3800f50b3a9f14a9683eb3e4e/collector/benchmarks/derive/src/lib.rs). \r\n\r\n`PartialOrd` is by far the most expensive to derive of the traits in std. The derive benchmark with `#[derive(PartialEq, PartialOrd)]` takes 9.1s on my machine while just `#[derive(PartialEq)]` takes 1.9s. \r\n\r\nThe following is a short experiment where we create a struct with one field 10,000 times and benchmark what happens when the structs have various derives on them. The code is generated using the following ruby script:\r\n```ruby\r\nFile.open('src/lib.rs', 'w') do |file|\r\n  0..10_000.times do |n|\r\n      file.write(\"pub struct MyType#{n} { pub field: i32 }\\n\")\r\n  end\r\nend\r\n```\r\n* Base (i.e., no derives): 061.s\r\n* `#[derive(Debug)]`: 13.33s\r\n* `#[derive(PartialEq)]`: 9.78s\r\n* `#[derive(PartialEq, PartialOrd)]`: **47.46s**\r\n* `#[derive(Clone)]`: 6.32s\r\n*  `#[derive(Clone, Copy)]`: 5.32s\r\n* `#[derive(PartialEq, Eq)]`: 14.13s\r\n* `#[derive(Default)]`: 4.33s\r\n* `#[derive(Hash)]`: 6.52s\r\n\r\nIt should be noted that it does not appear that any of the overhead is coming from the code expansion itself. When compiling the traits with the code copy/pasted from output from `cargo expand`, the performance is comparable to deriving the traits. \r\n\r\nHowever, there's definitely some wiggle room beyond \"just making compilation in general faster, will make derives faster\". I manually implemented `Debug` and ran the test again, and it compiles 10% faster. \r\n\r\nIt seems like the plurality of time (~13%)  for most of these derives is being spent in type checking though a deeper investigation into each class of derive is warranted. You can see a `summarize` comparison of `derive` vs. expanded vs manually implemented [here](https://gist.github.com/rylev/14430d2e1ea384b1f10efae6b5c385f2). \r\n\r\n## Discussion\r\n\r\nThis topic is already being discussed [on Zulip](https://rust-lang.zulipchat.com/#narrow/stream/247081-t-compiler.2Fperformance/topic/Slow.20Builtin.20Derives). \r\n\r\nSome discussion has suggested we might want to look into MIR shims as a possible solution but since MIR still needs to undergo type checking and we're spending most of the time in type checking, this probably won't help. ", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/80118/reactions", "total_count": 5, "+1": 5, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/80118/timeline", "performed_via_github_app": null, "state_reason": null}