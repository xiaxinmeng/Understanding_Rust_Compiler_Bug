{"url": "https://api.github.com/repos/rust-lang/rust/issues/50488", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/50488/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/50488/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/50488/events", "html_url": "https://github.com/rust-lang/rust/issues/50488", "id": 320635164, "node_id": "MDU6SXNzdWUzMjA2MzUxNjQ=", "number": 50488, "title": "Matching Vector Patterns in Image Processing", "user": {"login": "sgudim", "id": 39036727, "node_id": "MDQ6VXNlcjM5MDM2NzI3", "avatar_url": "https://avatars.githubusercontent.com/u/39036727?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sgudim", "html_url": "https://github.com/sgudim", "followers_url": "https://api.github.com/users/sgudim/followers", "following_url": "https://api.github.com/users/sgudim/following{/other_user}", "gists_url": "https://api.github.com/users/sgudim/gists{/gist_id}", "starred_url": "https://api.github.com/users/sgudim/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sgudim/subscriptions", "organizations_url": "https://api.github.com/users/sgudim/orgs", "repos_url": "https://api.github.com/users/sgudim/repos", "events_url": "https://api.github.com/users/sgudim/events{/privacy}", "received_events_url": "https://api.github.com/users/sgudim/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-05-06T22:32:55Z", "updated_at": "2018-05-07T01:55:20Z", "closed_at": "2018-05-07T01:55:20Z", "author_association": "NONE", "active_lock_reason": null, "body": "Hello,\r\n\r\nI am trying to implement a boolean image (background pixels (1)/ foreground pixels (0)) filter that identifies right corner of the foreground pixels.  I want the image to be scanned with a 3 x 3 moving window so that each pixel and its eight neighbours can be checked for a matching pattern that I want. Four possible patterns in a 3 x 3 window can make a up a right corner. These patterns are illustrated on the following webpage http://homepages.inf.ed.ac.uk/rbf/HIPR2/hitmiss.htm. I have most of the code for my tool ready, but I want to see what other people can suggest that I do to match the patterns. this is not the entire code but here is the part I need help with. This code was taken from a tool that performs line thinning so it follows similar logic and only a few things need to be changed. Thanks!!\r\n\r\n```\r\nlet num_procs = num_cpus::get() as isize;\r\n        let (tx, rx) = mpsc::channel();\r\n        for tid in 0..num_procs {\r\n            let input = input.clone();\r\n            let tx = tx.clone();\r\n            thread::spawn(move || {\r\n                for row in (0..rows).filter(|r| r % num_procs == tid) {\r\n                    let mut data: Vec<f64> = vec![nodata; columns as usize];\r\n                    for col in 0..columns {\r\n                        if input[(row, col)] > 0.0 && input[(row, col)] != nodata {\r\n                            data[col as usize] = 1.0;\r\n                        } else if input[(row, col)] == 0.0 {\r\n                            data[col as usize] = 0.0;\r\n                        }\r\n                    }\r\n                    tx.send((row, data)).unwrap();\r\n                }\r\n            });\r\n        }\r\n\r\n        let mut output = Raster::initialize_using_file(&output_file, &input);\r\n        for r in 0..rows {\r\n            let (row, data) = rx.recv().unwrap();\r\n            output.set_row_data(row, data);\r\n            \r\n            if verbose {\r\n                progress = (100.0_f64 * r as f64 / (rows - 1) as f64) as usize;\r\n                if progress != old_progress {\r\n                    println!(\"Initializing output: {}%\", progress);\r\n                    old_progress = progress;\r\n                }\r\n            }\r\n        }\r\n\r\n        let mut did_something = true;\r\n        let mut loop_num = 0;\r\n        let dx = [ 1, 1, 1, 0, -1, -1, -1, 0 ];\r\n        let dy = [ -1, 0, 1, 1, 1, 0, -1, -1 ];\r\n        let elements = vec![ vec![ 6, 7, 0, 4, 3, 2 ], vec![ 7, 0, 1, 3, 5 ], \r\n            vec![ 0, 1, 2, 4, 5, 6 ], vec![ 1, 2, 3, 5, 7 ], \r\n            vec![ 2, 3, 4, 6, 7, 0 ], vec![ 3, 4, 5, 7, 1 ], \r\n            vec![ 4, 5, 6, 0, 1, 2 ], vec![ 5, 6, 7, 1, 3 ] ];\r\n\r\n        let vals = vec![ vec![ 0f64, 0f64, 0f64, 1f64, 1f64, 1f64 ], vec![ 0f64, 0f64, 0f64, 1f64, 1f64 ], \r\n            vec![ 0f64, 0f64, 0f64, 1f64, 1f64, 1f64 ], vec![ 0f64, 0f64, 0f64, 1f64, 1f64 ],\r\n            vec![ 0f64, 0f64, 0f64, 1f64, 1f64, 1f64 ], vec![ 0f64, 0f64, 0f64, 1f64, 1f64 ],\r\n            vec![ 0f64, 0f64, 0f64, 1f64, 1f64, 1f64 ], vec![ 0f64, 0f64, 0f64, 1f64, 1f64 ] ];\r\n        \r\n        let mut neighbours = [0.0; 8];\r\n        let mut pattern_match: bool;\r\n        let mut z: f64;\r\n        while did_something {\r\n            loop_num += 1;\r\n            did_something = false;\r\n            for a in 0..8 {\r\n                for row in 0..rows {\r\n                    for col in 0..columns {\r\n                        z = output[(row, col)];\r\n                        if z > 0.0 && z != nodata {\r\n                            // fill the neighbours array\r\n                            for i in 0..8 {\r\n                                neighbours[i] = output[(row + dy[i], col + dx[i])];\r\n                            }\r\n                            \r\n                            // scan through element\r\n                            pattern_match = true;\r\n                            for i in 0..elements[a].len() {\r\n                                if neighbours[elements[a][i]] != vals[a][i] {\r\n                                    pattern_match = false;\r\n                                }\r\n                            }\r\n                            if pattern_match {\r\n                                output[(row, col)] = 0.0;\r\n                                did_something = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n```\r\n", "closed_by": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/50488/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/50488/timeline", "performed_via_github_app": null, "state_reason": "completed"}