{"url": "https://api.github.com/repos/rust-lang/rust/issues/46043", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/46043/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/46043/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/46043/events", "html_url": "https://github.com/rust-lang/rust/issues/46043", "id": 274593709, "node_id": "MDU6SXNzdWUyNzQ1OTM3MDk=", "number": 46043, "title": "Tracking issue for `safe_packed_borrows` compatibility lint", "user": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 246778137, "node_id": "MDU6TGFiZWwyNDY3NzgxMzc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/B-unstable", "name": "B-unstable", "color": "d304cb", "default": false, "description": "Implemented in the nightly compiler and unstable."}, {"id": 630636017, "node_id": "MDU6TGFiZWw2MzA2MzYwMTc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-future-compatibility", "name": "C-future-compatibility", "color": "f5f1fd", "default": false, "description": "Category: future compatibility lints"}, {"id": 650846969, "node_id": "MDU6TGFiZWw2NTA4NDY5Njk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-tracking-issue", "name": "C-tracking-issue", "color": "f5f1fd", "default": false, "description": "Category: A tracking issue for an RFC or an unstable feature."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 42, "created_at": "2017-11-16T17:10:34Z", "updated_at": "2021-03-28T10:56:47Z", "closed_at": "2021-03-27T22:19:06Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "## What is this warning about\r\n\r\nFields of structs with the `#[repr(packed)]` attribute might be unaligned. Even if a field has a valid offset (e.g. 0) within the struct, the struct itself might be unaligned.\r\n\r\nOn the other hand, safe references (`&T` and `&mut T`) must always have valid alignment (even when they are just created) - not only will *dereferencing* these references cause segfaults on architectures such as Sparc, but the compiler is allowed to optimize based on that assumption (e.g. in a future version of rustc, it might use the \"free\" alignment bits to represent enum discriminants), so even just *creating* an unaligned reference is Undefined Behavior and might cause the program to behave in unexpected ways.\r\n\r\nTherefore, borrowing a field in the interior of a packed structure with alignment other than 1 is unsafe - if the reference is not *known* to be aligned, the borrow must be done to an unsafe pointer.\r\n\r\nNote that borrowing a field with alignment 1 is always safe.\r\n\r\nFor example, consider the common `struct Unaligned`:\r\n```Rust\r\n#[repr(packed)]\r\npub struct Unaligned<T>(pub T);\r\n```\r\n\r\nThat struct can be placed inside a bigger struct at an unaligned offset:\r\n```Rust\r\npub struct Foo {\r\n    start: u8,\r\n    data: Unaligned<u32>,\r\n}\r\n```\r\n\r\nIn that case, a borrow of a field of the struct would be Undefined Behavior (UB), and therefore is made unsafe:\r\n```Rust\r\nlet x = Foo { start: 0, data: Unaligned(1) };\r\nlet y = &x.data.0; // UB, also future-compatibility warning\r\nprintln!(\"{}\", x.data.0); // this borrows `x.data.0`, so UB + future-compat warning\r\nuse(y);\r\n```\r\n\r\nThis used to be left unchecked by the compiler - issue #27060.\r\n\r\n## How to fix this warning/error\r\n\r\nThe most common ways to fix this warnings are:\r\n1. remove the `#[repr(packed)]` attribute if it is not actually needed. A few crates had unnecessary `#[repr(packed)]` annotations - for example, [tendril].\r\n2. copy the fields to a local first. When accessing a field of a packed struct directly without using a borrow, the compiler will make sure the access is done correctly even when the field is unaligned. The then-aligned local can then be freely used. For example:\r\n    ```Rust\r\n    let x = Foo { start: 0, data: Unaligned(1) };\r\n    let temp = x.data.0;\r\n    println!(\"{}\", temp); // works\r\n    // or, to the same effect, using an `{x}` block:\r\n    println!(\"{}\", {x.data.0}); // works\r\n    use(y);\r\n    ````\r\n\r\nIn some cases, it might be necessary to borrow the fields as raw pointers and use `read_unaligned`/`write_unaligned` to access them, but I haven't encountered such a case.\r\n\r\n### Derives\r\n\r\nOne annoying case where this problem can appear is if a packed struct has builtin derives, e.g.\r\n```Rust\r\n#[derive(PartialEq, ...)]\r\n#[repr(packed)]\r\npub struct Unaligned<T>(pub T);\r\n```\r\n\r\nWhich essentially expands to this:\r\n```Rust\r\nimpl<T: PartialEq> PartialEq for Unaligned<T> {\r\n    fn eq(&self, other: &Self) -> bool {\r\n        PartialEq::eq(&self.0, &other.0) // this is UB and unsafe\r\n    }\r\n}\r\n```\r\n\r\nIf your struct already derives `Copy` and has no generics, the compiler will generate code that copies the fields to locals and will therefore work. Otherwise, you'll have to write the `derive` implementations manually.\r\n\r\nFor example, you might want to add a `T: Copy` bound and copy things out:\r\n\r\n```Rust\r\n#[repr(packed)]\r\npub struct Unaligned<T: Copy>(pub T);\r\n\r\nimpl<T: Copy + PartialEq> PartialEq for Unaligned<T> {\r\n    fn eq(&self, other: &Self) -> bool {\r\n        ({self.0}) == ({other.0}) // this copies fields to temps, and works\r\n    }\r\n}\r\n```\r\n\r\n[tendril]: https://github.com/servo/tendril/issues/29", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/46043/reactions", "total_count": 8, "+1": 8, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/46043/timeline", "performed_via_github_app": null, "state_reason": "completed"}