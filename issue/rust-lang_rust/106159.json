{"url": "https://api.github.com/repos/rust-lang/rust/issues/106159", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/106159/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/106159/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/106159/events", "html_url": "https://github.com/rust-lang/rust/issues/106159", "id": 1511178548, "node_id": "I_kwDOAAsO6M5aEsE0", "number": 106159, "title": "Weighted trial simulator with modifiable behaviours and probabilities", "user": {"login": "MrMisc", "id": 100022747, "node_id": "U_kgDOBfY52w", "avatar_url": "https://avatars.githubusercontent.com/u/100022747?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MrMisc", "html_url": "https://github.com/MrMisc", "followers_url": "https://api.github.com/users/MrMisc/followers", "following_url": "https://api.github.com/users/MrMisc/following{/other_user}", "gists_url": "https://api.github.com/users/MrMisc/gists{/gist_id}", "starred_url": "https://api.github.com/users/MrMisc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MrMisc/subscriptions", "organizations_url": "https://api.github.com/users/MrMisc/orgs", "repos_url": "https://api.github.com/users/MrMisc/repos", "events_url": "https://api.github.com/users/MrMisc/events{/privacy}", "received_events_url": "https://api.github.com/users/MrMisc/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 9618520, "node_id": "MDU6TGFiZWw5NjE4NTIw", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-ICE", "name": "I-ICE", "color": "e10c02", "default": false, "description": "Issue: The compiler panicked, giving an Internal Compilation Error (ICE) \u2744\ufe0f"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}, {"id": 1359848690, "node_id": "MDU6TGFiZWwxMzU5ODQ4Njkw", "url": "https://api.github.com/repos/rust-lang/rust/labels/E-needs-mcve", "name": "E-needs-mcve", "color": "02e10c", "default": false, "description": "Call for participation: This issue needs a Minimal Complete and Verifiable Example"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2022-12-26T19:24:07Z", "updated_at": "2023-01-08T22:38:54Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "<!--\r\nThank you for finding an Internal Compiler Error! \ud83e\uddca  If possible, try to provide\r\na minimal verifiable example. You can read \"Rust Bug Minimization Patterns\" for\r\nhow to create smaller examples.\r\n\r\nhttp://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\r\n\r\n-->\r\n\r\n### Code\r\n\r\n```Rust\r\nextern crate serde;\r\nextern crate serde_json;\r\nuse serde::Deserialize;\r\nuse serde_json::json;\r\nuse std::fs::File;\r\nuse std::fs::OpenOptions;\r\nuse std::io::Read;\r\nuse std::io::Write;\r\nuse std::time::{Duration, Instant};\r\nuse std::{fs, io, process};\r\n\r\n#[derive(Deserialize)]\r\npub struct Entry {\r\n    simulation1: simulation,\r\n    simulation2: simulation,\r\n    trials: u64,\r\n}\r\n\r\n#[derive(Deserialize)]\r\npub struct simulation {\r\n    method: u8,\r\n    runs: u32,\r\n    starting_point: i32,\r\n    probability: Vec<String>,\r\n    moneytree: Vec<f64>,\r\n    falsecap: u32,\r\n}\r\n\r\nmod trial {\r\n    use rand::distributions::Uniform;\r\n    use rand::{thread_rng, Rng};\r\n\r\n    pub fn trial(prob: f64) -> bool {\r\n        let mut rng = thread_rng();\r\n        let roll = Uniform::new(0.0, 1.0);\r\n        let rollnumber: f64 = rng.sample(roll);\r\n        rollnumber < prob\r\n    }\r\n    // Note that we are going to have to examine each run\r\n    //This programme will require a pure list of probabilities for the listofprobs variable input\r\n    // it is also going to need *s to indicate which levels are secure and insecure\r\n    pub fn runs(\r\n        method: u8,\r\n        lastrun_orig: i32,\r\n        listofprobs: Vec<&str>,\r\n        money_tree: &[f64],\r\n        money_in: f64,\r\n        number_of_runs: u32,\r\n        mut laststate_in: bool,\r\n        mut secondlaststate_in: bool,\r\n        falsecap: u32,\r\n    ) -> (i32, u32, f64, bool, bool, bool) {\r\n        let mut lastrun: i32 = lastrun_orig.clone(); //level you are at\r\n        let terminate: i32 = listofprobs.len().try_into().unwrap();\r\n        let mut money: f64 = money_in;\r\n        let mut listoffixables: Vec<u32> = Vec::new();\r\n        let mut listofprobs_f: Vec<f64> = Vec::new();\r\n        let mut booms0: Vec<u32> = Vec::new();\r\n        let mut booms1: Vec<u32> = Vec::new();\r\n        let mut booms2: Vec<u32> = Vec::new();\r\n        let mut boomclap: Vec<u32> = Vec::new();\r\n        let mut countable: u32 = 0;\r\n        for i in listofprobs {\r\n            if i.contains(\"*\") {\r\n                listofprobs_f.push(\r\n                    i.replace(\"*\", \"\")\r\n                        .replace(\",\", \"\")\r\n                        .replace(\" \", \"\")\r\n                        .parse::<f64>()\r\n                        .unwrap(),\r\n                );\r\n                listoffixables.push(countable);\r\n            } else if i.contains(\"k\") {\r\n                // if you fail, you fall to first level\r\n                listofprobs_f.push(\r\n                    i.replace(\"k\", \"\")\r\n                        .replace(\",\", \"\")\r\n                        .replace(\" \", \"\")\r\n                        .parse::<f64>()\r\n                        .unwrap(),\r\n                );\r\n                booms0.push(countable);\r\n            } else if i.contains(\"j\") {\r\n                // if you fail, you fall to second level\r\n                listofprobs_f.push(\r\n                    i.replace(\"j\", \"\")\r\n                        .replace(\",\", \"\")\r\n                        .replace(\" \", \"\")\r\n                        .parse::<f64>()\r\n                        .unwrap(),\r\n                );\r\n                booms1.push(countable);\r\n            } else if i.contains(\"h\") {\r\n                // if you fail, you fall to third level\r\n                listofprobs_f.push(\r\n                    i.replace(\"h\", \"\")\r\n                        .replace(\",\", \"\")\r\n                        .replace(\" \", \"\")\r\n                        .parse::<f64>()\r\n                        .unwrap(),\r\n                );\r\n                booms2.push(countable);\r\n            } else if i.contains(\"T\") {\r\n                // if you fail, you fall 2 levels -> to compoundly simulate boom stages that you can also fall from failing at\r\n                listofprobs_f.push(\r\n                    i.replace(\"T\", \"\")\r\n                        .replace(\",\", \"\")\r\n                        .replace(\" \", \"\")\r\n                        .parse::<f64>()\r\n                        .unwrap(),\r\n                );\r\n                boomclap.push(countable);\r\n            } else {\r\n                listofprobs_f.push(i.replace(\",\", \"\").replace(\" \", \"\").parse::<f64>().unwrap());\r\n            }\r\n            countable += 1\r\n        }\r\n        countable = 0; //reset countable to just record number of sit down rolls until termination of session\r\n        let mut falsecount: u32 = 0;\r\n        loop {\r\n            //breaking conditions\r\n            if lastrun >= terminate {\r\n                break;\r\n            } else if method % 10 == 1 && countable >= number_of_runs {\r\n                break;\r\n            } else if method % 10 == 2 && falsecount >= number_of_runs {\r\n                break;\r\n            } else if method % 10 == 3 && countable >= number_of_runs && lastrun <= lastrun_orig {\r\n                break;\r\n            } else if method % 10 == 3 && countable >= number_of_runs && lastrun > lastrun_orig {\r\n                if falsecount >= falsecap {\r\n                    break;\r\n                }\r\n            }\r\n            //Methods 1-3 use * to denote 'unfallable' stages.\r\n            let ref_lastrun: usize = lastrun.clone() as usize; //turning level parameter into usable index for vector\r\n            money += money_tree[ref_lastrun];\r\n            if !secondlaststate_in && !laststate_in && method <= 10 {\r\n                //pity system revoked for methods above 10.\r\n                laststate_in = true;\r\n                secondlaststate_in = false;\r\n                countable += 1;\r\n            } else {\r\n                secondlaststate_in = laststate_in;\r\n                laststate_in = trial(listofprobs_f[ref_lastrun]);\r\n                if laststate_in {\r\n                    //if level success AND it is not a compounding boom test level\r\n                    //determine if this is on a compounding stage (\"boom test\")\r\n                    lastrun += 1;\r\n                    if (booms0.contains(&(lastrun as u32))\r\n                        || booms1.contains(&(lastrun as u32))\r\n                        || booms2.contains(&(lastrun as u32)))\r\n                        == false\r\n                    {\r\n                        countable += 1; //negate this counting as a level completion/attempt/success\r\n                    }\r\n                } else if listoffixables.contains(&(lastrun as u32)) {\r\n                    lastrun += 0;\r\n                    falsecount += 1;\r\n                    countable += 1;\r\n                    //At this stage, the last roll laststate_in is a False on teh trial\r\n                    //cheat the system and make sure pity system is not triggered at fixed stage (change second last state to true). Otherwise getting unlucky at fixed spot is exploited\r\n                    //This is only to maintain the specific game scenario that we are depicting so lim to methods 1,2,3\r\n                    if method < 5 {\r\n                        secondlaststate_in = true;\r\n                    }\r\n                } else if booms0.contains(&(lastrun as u32)) {\r\n                    lastrun = 0;\r\n                    falsecount += 1;\r\n                    countable += 1;\r\n                    //when you boom, there is no extra stage bonus from pity system\r\n                    if method < 5 {\r\n                        secondlaststate_in = true;\r\n                    }\r\n                } else if booms1.contains(&(lastrun as u32)) {\r\n                    lastrun = 1;\r\n                    falsecount += 1;\r\n                    countable += 1;\r\n                    if method < 5 {\r\n                        secondlaststate_in = true;\r\n                    }\r\n                } else if booms2.contains(&(lastrun as u32)) {\r\n                    lastrun = 2;\r\n                    falsecount += 1;\r\n                    countable += 1;\r\n                    if method < 5 {\r\n                        secondlaststate_in = true;\r\n                    }\r\n                } else if boomclap.contains(&(lastrun as u32)) {\r\n                    //to compensate for the fact that we are using 2 stages in a compound manner to represent a trial with 3 outcomes instead of\r\n                    lastrun -= 2;\r\n                    falsecount += 1;\r\n                    countable += 1;\r\n                } else if lastrun > 0 {\r\n                    lastrun -= 1;\r\n                    falsecount += 1;\r\n                    countable += 1;\r\n                } else {\r\n                    lastrun += 0;\r\n                    falsecount += 1;\r\n                    countable += 1;\r\n                    if method < 5 {\r\n                        secondlaststate_in = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        (\r\n            lastrun,\r\n            countable,\r\n            money,\r\n            laststate_in,\r\n            secondlaststate_in,\r\n            lastrun == terminate,\r\n        )\r\n    }\r\n\r\n    pub fn simulate(\r\n        method: u8,\r\n        number_of_runs: u32,\r\n        starting_point: i32,\r\n        listofprobs: Vec<&str>,\r\n        money_tree: Vec<f64>,\r\n        falsecap: u32,\r\n    ) -> (i32, u32, f64) {\r\n        let mut run_meter: i32 = 0; //starting value for lastrun_orig in runs\r\n        let mut result_table: (i32, u32, f64, bool, bool, bool) =\r\n            (starting_point, 0, 0.0, true, true, false);\r\n        while !result_table.5 {\r\n            let copied_listofprobs: Vec<&str> = listofprobs.clone();\r\n            let copied_moneytree: &[f64] = &money_tree;\r\n            let result_table2: (i32, u32, f64, bool, bool, bool) = runs(\r\n                method,\r\n                result_table.0,\r\n                copied_listofprobs,\r\n                copied_moneytree,\r\n                result_table.2,\r\n                number_of_runs,\r\n                result_table.3,\r\n                result_table.4,\r\n                falsecap,\r\n            );\r\n            result_table = (\r\n                result_table2.0,\r\n                result_table.1 + result_table2.1,\r\n                result_table2.2,\r\n                result_table2.3,\r\n                result_table2.4,\r\n                result_table2.5,\r\n            ); //only addition here is to add the number of rolls taken inside the countable output var\r\n            run_meter += 1;\r\n        }\r\n        (run_meter, result_table.1, result_table.2) //(number of sessions, number of taps, money spent)\r\n    }\r\n\r\n    pub fn simulate_doublethread(\r\n        method: [u8; 2],\r\n        number_of_runs: [u32; 2],\r\n        starting_point: [i32; 2],\r\n        listofprobs: [Vec<&str>; 2],\r\n        money_tree: [Vec<f64>; 2],\r\n        falsecap: [u32; 2],\r\n    ) -> [(i32, u32, f64); 2] {\r\n        use std::sync::{Arc, Mutex};\r\n        use std::thread;\r\n        let prob1 = Arc::new(Mutex::new(listofprobs[0].clone()));\r\n        let prob2 = Arc::new(Mutex::new(listofprobs[1].clone()));\r\n        let money1 = Arc::new(Mutex::new(money_tree[0].clone()));\r\n        let money2 = Arc::new(Mutex::new(money_tree[1].clone()));\r\n        // let mut handles = vec![];\r\n        // let empty: [(i32, u32, f64); 2] = [(1, 1, 1.0), (1, 1, 1.0)];\r\n        // let e1: (i32, u32, f64) = (1, 1, 1.0);\r\n        // let e2: (i32, u32, f64) = (1, 1, 1.0);\r\n        thread::scope(|s| {\r\n            let probability = Arc::clone(&prob1);\r\n            let money = Arc::clone(&money1);\r\n            let thread1 = s.spawn(move || {\r\n                let prob = probability.lock().unwrap();\r\n                let mon = money.lock().unwrap();\r\n                simulate(\r\n                    method[0],\r\n                    number_of_runs[0],\r\n                    starting_point[0],\r\n                    prob.to_vec(),\r\n                    mon.to_vec(),\r\n                    falsecap[0],\r\n                )\r\n            });\r\n            let probability = Arc::clone(&prob2);\r\n            let money = Arc::clone(&money2);\r\n            let thread2 = s.spawn(move || {\r\n                let prob = probability.lock().unwrap();\r\n                let mon = money.lock().unwrap();\r\n                simulate(\r\n                    method[1],\r\n                    number_of_runs[1],\r\n                    starting_point[1],\r\n                    prob.to_vec(),\r\n                    mon.to_vec(),\r\n                    falsecap[1],\r\n                )\r\n                // println!(\"simulation 2 {} attempts at {}\",e2.1, e2.2 );\r\n                // println!(\"Final:{:?}\", empty);\r\n            });\r\n            [thread1.join().unwrap(), thread2.join().unwrap()]\r\n        })\r\n    }\r\n\r\n}\r\n\r\nfn main() {\r\n\r\n    //file input\r\n    let mut file = File::open(\"./output.json\").unwrap();\r\n    let mut buff = String::new();\r\n    file.read_to_string(&mut buff).unwrap();\r\n\r\n    let data: Entry = serde_json::from_str(&buff).unwrap();\r\n    let method_input = [data.simulation1.method, data.simulation2.method];\r\n    let runs_input = [data.simulation1.runs, data.simulation2.runs];\r\n    let start_input = [\r\n        data.simulation1.starting_point,\r\n        data.simulation2.starting_point,\r\n    ];\r\n    let probs_input = [\r\n        data.simulation1\r\n            .probability\r\n            .iter()\r\n            .map(|s| s as &str)\r\n            .collect(),\r\n        data.simulation2\r\n            .probability\r\n            .iter()\r\n            .map(|s| s as &str)\r\n            .collect(),\r\n    ];\r\n    let moneytree_input = [\r\n        (*data.simulation1.moneytree).to_vec(),\r\n        (*data.simulation2.moneytree).to_vec(),\r\n    ];\r\n    let falsecap_input = [data.simulation1.falsecap, data.simulation2.falsecap];\r\n    let mut trials = data.trials;\r\n    let duration = Instant::now();\r\n    if trials < 1000000 {\r\n        for _i in 0..trials {\r\n            let entries = trial::simulate_doublethread(\r\n                method_input,\r\n                runs_input,\r\n                start_input,\r\n                probs_input.clone(),\r\n                moneytree_input.clone(),\r\n                falsecap_input,\r\n            );\r\n            // dbg!(entries);\r\n            // println!{\"For simulation 1, {} spent to attempt a total of {} times\", entries[0].2, entries[0].1};\r\n            // println!{\"For simulation 2, {} spent to attempt a total of {} times\", entries[1].2, entries[1].1};\r\n            println!(\r\n                \"{} {} {:.3} {} {} {:.3}\",\r\n                entries[0].0, entries[0].1, entries[0].2, entries[1].0, entries[1].1, entries[1].2\r\n            )\r\n        }\r\n    } else {\r\n        trials /= 8;\r\n        std::thread::scope(|s| {\r\n            let probably = probs_input.clone();\r\n            let money_ = moneytree_input.clone();\r\n            let _thread1 = s.spawn(move || {\r\n                let probs = &probably;\r\n                let moneyy = &money_;\r\n                for _i in 0..trials {\r\n                    let entries = trial::simulate_doublethread(\r\n                        method_input,\r\n                        runs_input,\r\n                        start_input,\r\n                        probs.clone(),\r\n                        moneyy.clone(),\r\n                        falsecap_input,\r\n                    );\r\n                    println!(\r\n                        \"{} {} {:.3} {} {} {:.3}\",\r\n                        entries[0].0,\r\n                        entries[0].1,\r\n                        entries[0].2,\r\n                        entries[1].0,\r\n                        entries[1].1,\r\n                        entries[1].2\r\n                    )\r\n                }\r\n            });\r\n            let probably = probs_input.clone();\r\n            let money_ = moneytree_input.clone();\r\n            let _thread2 = s.spawn(move || {\r\n                for _i in 0..trials {\r\n                    let probs2 = &probably;\r\n                    let moneyy2 = &money_;\r\n                    let entries = trial::simulate_doublethread(\r\n                        method_input,\r\n                        runs_input,\r\n                        start_input,\r\n                        probs2.clone(),\r\n                        moneyy2.clone(),\r\n                        falsecap_input,\r\n                    );\r\n                    println!(\r\n                        \"{} {} {:.3} {} {} {:.3}\",\r\n                        entries[0].0,\r\n                        entries[0].1,\r\n                        entries[0].2,\r\n                        entries[1].0,\r\n                        entries[1].1,\r\n                        entries[1].2\r\n                    )\r\n                }\r\n            });\r\n            let probably = probs_input.clone();\r\n            let money_ = moneytree_input.clone();\r\n            let _thread2 = s.spawn(move || {\r\n                for _i in 0..trials {\r\n                    let probs2 = &probably;\r\n                    let moneyy2 = &money_;\r\n                    let entries = trial::simulate_doublethread(\r\n                        method_input,\r\n                        runs_input,\r\n                        start_input,\r\n                        probs2.clone(),\r\n                        moneyy2.clone(),\r\n                        falsecap_input,\r\n                    );\r\n                    println!(\r\n                        \"{} {} {:.3} {} {} {:.3}\",\r\n                        entries[0].0,\r\n                        entries[0].1,\r\n                        entries[0].2,\r\n                        entries[1].0,\r\n                        entries[1].1,\r\n                        entries[1].2\r\n                    )\r\n                }\r\n            });\r\n            let probably = probs_input.clone();\r\n            let money_ = moneytree_input.clone();\r\n            let _thread2 = s.spawn(move || {\r\n                for _i in 0..trials {\r\n                    let probs2 = &probably;\r\n                    let moneyy2 = &money_;\r\n                    let entries = trial::simulate_doublethread(\r\n                        method_input,\r\n                        runs_input,\r\n                        start_input,\r\n                        probs2.clone(),\r\n                        moneyy2.clone(),\r\n                        falsecap_input,\r\n                    );\r\n                    println!(\r\n                        \"{} {} {:.3} {} {} {:.3}\",\r\n                        entries[0].0,\r\n                        entries[0].1,\r\n                        entries[0].2,\r\n                        entries[1].0,\r\n                        entries[1].1,\r\n                        entries[1].2\r\n                    )\r\n                }\r\n            });\r\n            let probably = probs_input.clone();\r\n            let money_ = moneytree_input.clone();\r\n            let _thread2 = s.spawn(move || {\r\n                for _i in 0..trials {\r\n                    let probs2 = &probably;\r\n                    let moneyy2 = &money_;\r\n                    let entries = trial::simulate_doublethread(\r\n                        method_input,\r\n                        runs_input,\r\n                        start_input,\r\n                        probs2.clone(),\r\n                        moneyy2.clone(),\r\n                        falsecap_input,\r\n                    );\r\n                    println!(\r\n                        \"{} {} {:.3} {} {} {:.3}\",\r\n                        entries[0].0,\r\n                        entries[0].1,\r\n                        entries[0].2,\r\n                        entries[1].0,\r\n                        entries[1].1,\r\n                        entries[1].2\r\n                    )\r\n                }\r\n            });\r\n            let probably = probs_input.clone();\r\n            let money_ = moneytree_input.clone();\r\n            let _thread2 = s.spawn(move || {\r\n                for _i in 0..trials {\r\n                    let probs2 = &probably;\r\n                    let moneyy2 = &money_;\r\n                    let entries = trial::simulate_doublethread(\r\n                        method_input,\r\n                        runs_input,\r\n                        start_input,\r\n                        probs2.clone(),\r\n                        moneyy2.clone(),\r\n                        falsecap_input,\r\n                    );\r\n                    println!(\r\n                        \"{} {} {:.3} {} {} {:.3}\",\r\n                        entries[0].0,\r\n                        entries[0].1,\r\n                        entries[0].2,\r\n                        entries[1].0,\r\n                        entries[1].1,\r\n                        entries[1].2\r\n                    )\r\n                }\r\n            });\r\n            let probably = probs_input.clone();\r\n            let money_ = moneytree_input.clone();\r\n            let _thread2 = s.spawn(move || {\r\n                for _i in 0..trials {\r\n                    let probs2 = &probably;\r\n                    let moneyy2 = &money_;\r\n                    let entries = trial::simulate_doublethread(\r\n                        method_input,\r\n                        runs_input,\r\n                        start_input,\r\n                        probs2.clone(),\r\n                        moneyy2.clone(),\r\n                        falsecap_input,\r\n                    );\r\n                    println!(\r\n                        \"{} {} {:.3} {} {} {:.3}\",\r\n                        entries[0].0,\r\n                        entries[0].1,\r\n                        entries[0].2,\r\n                        entries[1].0,\r\n                        entries[1].1,\r\n                        entries[1].2\r\n                    )\r\n                }\r\n            });\r\n            let probably = probs_input.clone();\r\n            let money_ = moneytree_input.clone();\r\n            let _thread2 = s.spawn(move || {\r\n                for _i in 0..trials {\r\n                    let probs2 = &probably;\r\n                    let moneyy2 = &money_;\r\n                    let entries = trial::simulate_doublethread(\r\n                        method_input,\r\n                        runs_input,\r\n                        start_input,\r\n                        probs2.clone(),\r\n                        moneyy2.clone(),\r\n                        falsecap_input,\r\n                    );\r\n                    println!(\r\n                        \"{} {} {:.3} {} {} {:.3}\",\r\n                        entries[0].0,\r\n                        entries[0].1,\r\n                        entries[0].2,\r\n                        entries[1].0,\r\n                        entries[1].1,\r\n                        entries[1].2\r\n                    )\r\n                }\r\n            });\r\n            // [thread1.join().unwrap(), thread2.join().unwrap()]\r\n        })\r\n    }\r\n    //parameters printed at end\r\n    println!(\r\n        \"{} {} {} {} {} {}\",\r\n        method_input[0],\r\n        runs_input[0],\r\n        falsecap_input[0],\r\n        method_input[1],\r\n        runs_input[1],\r\n        falsecap_input[1]\r\n    ); // So we share as the last output string... method number - max number of runs - falsecap\r\n\r\n    let timethink = duration.elapsed();\r\n    let duration1 = timethink.as_secs();\r\n    let extra_time_info = timethink.subsec_nanos();\r\n    // let DUR = {export {time:duration1}};\r\n    let dur = json!({\r\n        \"Time\":duration1,\r\n        \"Extended Time Details\":extra_time_info\r\n    });\r\n\r\n    fs::remove_file(\"duration.json\").expect(\"File delete failed!\");\r\n    let mut file = OpenOptions::new()\r\n        .write(true)\r\n        .create(true)\r\n        .open(\"duration.json\")\r\n        .unwrap();\r\n    write!(file, \"{}\", dur).unwrap();\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.66.0 (69f9c33d7 2022-12-12)\r\nbinary: rustc\r\ncommit-hash: 69f9c33d71c871fc16ac445211281c6e7a340943\r\ncommit-date: 2022-12-12\r\nhost: x86_64-pc-windows-msvc\r\nrelease: 1.66.0\r\nLLVM version: 15.0.2\r\n```\r\n\r\n### Error output\r\n\r\n```\r\nthread 'rustc' panicked at 'index out of bounds: the len is 136 but the index is 4294442753', compiler\\rustc_mir_transform\\src\\simplify.rs:294:23\r\nstack backtrace:\r\n   0:     0x7ffb9c099a62 - <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt::h9cc3e6a011dc5132\r\n   1:     0x7ffb9c0d56db - core::fmt::write::he89cb226c02070d2\r\n   2:     0x7ffb9c08c18a - <std::io::IoSlice as core::fmt::Debug>::fmt::he6d632f855112fd0\r\n   3:     0x7ffb9c0997ab - std::sys::common::alloc::realloc_fallback::h5c3ecd12fe3d9457\r\n   4:     0x7ffb9c09d109 - std::panicking::default_hook::h36863ea1fc1fbdbc\r\n   5:     0x7ffb9c09cd8a - std::panicking::default_hook::h36863ea1fc1fbdbc\r\n   6:     0x7ffb826af2ee - rustc_driver[fb77b091dfe5599]::describe_lints\r\n   7:     0x7ffb9c09da60 - std::panicking::rust_panic_with_hook::h7149e2a5386188c7\r\n   8:     0x7ffb9c09d7bd - <std::panicking::begin_panic_handler::StrPanicPayload as core::panic::BoxMeUp>::get::h3b76bab2bd4570c6\r\n   9:     0x7ffb9c09a76f - <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt::h9cc3e6a011dc5132\r\n  10:     0x7ffb9c09d480 - rust_begin_unwind\r\n  11:     0x7ffb9c10b5f5 - core::panicking::panic_fmt::h94563f1a4f8281d4\r\n  12:     0x7ffb9c10b767 - core::panicking::panic_bounds_check::h676803aa0dfb5c32\r\n  13:     0x7ffb81a35d83 - rustc_mir_transform[179d2fb7acce9b1d]::simplify::simplify_cfg\r\n  14:     0x7ffb81a17657 - <rustc_mir_transform[179d2fb7acce9b1d]::lower_intrinsics::LowerIntrinsics as rustc_middle[c20b2465f7a6944a]::mir::MirPass>::run_pass\r\n  15:     0x7ffb808c3fc2 - <rustc_const_eval[4286574e399b7d2d]::transform::check_consts::resolver::State as core[4b49762e6f6b0070]::clone::Clone>::clone_from\r\n  16:     0x7ffb8093cc65 - <&rustc_index[7ec95dcc88bc60fe]::vec::IndexVec<rustc_middle[c20b2465f7a6944a]::mir::Promoted, rustc_middle[c20b2465f7a6944a]::mir::Body> as rustc_serialize[a88a1d0641a15ead]::serialize::Decodable<rustc_query_impl[c73565597e9fd6ef]::on_disk_cache::CacheDecoder>>::decode\r\n  17:     0x7ffb8205d17d - <rustc_span[5f13167172344a94]::def_id::DefId as rustc_serialize[a88a1d0641a15ead]::serialize::Encodable<rustc_query_impl[c73565597e9fd6ef]::on_disk_cache::CacheEncoder>>::encode\r\n  18:     0x7ffb81f89817 - <rustc_query_impl[c73565597e9fd6ef]::Queries as rustc_middle[c20b2465f7a6944a]::ty::query::QueryEngine>::as_any\r\n  19:     0x7ffb81a18f59 - <rustc_mir_transform[179d2fb7acce9b1d]::lower_intrinsics::LowerIntrinsics as rustc_middle[c20b2465f7a6944a]::mir::MirPass>::run_pass\r\n  20:     0x7ffb808c4132 - <rustc_const_eval[4286574e399b7d2d]::transform::check_consts::resolver::State as core[4b49762e6f6b0070]::clone::Clone>::clone_from\r\n  21:     0x7ffb8093d3bd - <&rustc_index[7ec95dcc88bc60fe]::vec::IndexVec<rustc_middle[c20b2465f7a6944a]::mir::Promoted, rustc_middle[c20b2465f7a6944a]::mir::Body> as rustc_serialize[a88a1d0641a15ead]::serialize::Decodable<rustc_query_impl[c73565597e9fd6ef]::on_disk_cache::CacheDecoder>>::decode\r\n  22:     0x7ffb8205f0d0 - <rustc_span[5f13167172344a94]::def_id::DefId as rustc_serialize[a88a1d0641a15ead]::serialize::Encodable<rustc_query_impl[c73565597e9fd6ef]::on_disk_cache::CacheEncoder>>::encode\r\n  23:     0x7ffb81f89e00 - <rustc_query_impl[c73565597e9fd6ef]::Queries as rustc_middle[c20b2465f7a6944a]::ty::query::QueryEngine>::as_any\r\n  24:     0x7ffb81d02514 - <rustc_mir_build[771e95a1e5fa463b]::build::expr::as_place::PlaceBuilder as core[4b49762e6f6b0070]::convert::From<rustc_middle[c20b2465f7a6944a]::mir::Local>>::from\r\n  25:     0x7ffb81d01f08 - <rustc_mir_build[771e95a1e5fa463b]::build::expr::as_place::PlaceBuilder as core[4b49762e6f6b0070]::convert::From<rustc_middle[c20b2465f7a6944a]::mir::Local>>::from\r\n  26:     0x7ffb808c57d8 - <rustc_const_eval[4286574e399b7d2d]::transform::check_consts::resolver::State as core[4b49762e6f6b0070]::clone::Clone>::clone_from\r\n  27:     0x7ffb809467b5 - <&rustc_index[7ec95dcc88bc60fe]::vec::IndexVec<rustc_middle[c20b2465f7a6944a]::mir::Promoted, rustc_middle[c20b2465f7a6944a]::mir::Body> as rustc_serialize[a88a1d0641a15ead]::serialize::Decodable<rustc_query_impl[c73565597e9fd6ef]::on_disk_cache::CacheDecoder>>::decode\r\n  28:     0x7ffb8206cefc - <rustc_span[5f13167172344a94]::def_id::DefId as rustc_serialize[a88a1d0641a15ead]::serialize::Encodable<rustc_query_impl[c73565597e9fd6ef]::on_disk_cache::CacheEncoder>>::encode\r\n  29:     0x7ffb81f8ba85 - <rustc_query_impl[c73565597e9fd6ef]::Queries as rustc_middle[c20b2465f7a6944a]::ty::query::QueryEngine>::as_any\r\n  30:     0x7ffb80df61e0 - once_cell[f5d6077c0d8fa878]::imp::initialize_or_wait\r\n  31:     0x7ffb7ff0de8c - rustc_interface[e6bd4287da1da916]::passes::analysis\r\n  32:     0x7ffb7fefd542 - rustc_interface[e6bd4287da1da916]::passes::analysis\r\n  33:     0x7ffb808c6f3e - <rustc_const_eval[4286574e399b7d2d]::transform::check_consts::resolver::State as core[4b49762e6f6b0070]::clone::Clone>::clone_from\r\n  34:     0x7ffb80966839 - <&rustc_index[7ec95dcc88bc60fe]::vec::IndexVec<rustc_middle[c20b2465f7a6944a]::mir::Promoted, rustc_middle[c20b2465f7a6944a]::mir::Body> as rustc_serialize[a88a1d0641a15ead]::serialize::Decodable<rustc_query_impl[c73565597e9fd6ef]::on_disk_cache::CacheDecoder>>::decode\r\n  35:     0x7ffb80a3cb4e - <&rustc_index[7ec95dcc88bc60fe]::vec::IndexVec<rustc_middle[c20b2465f7a6944a]::mir::Promoted, rustc_middle[c20b2465f7a6944a]::mir::Body> as rustc_serialize[a88a1d0641a15ead]::serialize::Decodable<rustc_query_impl[c73565597e9fd6ef]::on_disk_cache::CacheDecoder>>::decode\r\n  36:     0x7ffb80a8c1f6 - <&rustc_index[7ec95dcc88bc60fe]::vec::IndexVec<rustc_middle[c20b2465f7a6944a]::mir::Promoted, rustc_middle[c20b2465f7a6944a]::mir::Body> as rustc_serialize[a88a1d0641a15ead]::serialize::Decodable<rustc_query_impl[c73565597e9fd6ef]::on_disk_cache::CacheDecoder>>::decode\r\n  37:     0x7ffb7feabd44 - <unknown>\r\n  38:     0x7ffb7febc588 - <rustc_middle[c20b2465f7a6944a]::ty::SymbolName as core[4b49762e6f6b0070]::fmt::Display>::fmt\r\n  39:     0x7ffb7febb6dd - rustc_driver[fb77b091dfe5599]::args::arg_expand_all\r\n  40:     0x7ffb7feac809 - <unknown>\r\n  41:     0x7ffb7fea3990 - <unknown>\r\n  42:     0x7ffb9c0aeabc - std::sys::windows::thread::Thread::new::h699a5ea60124709c\r\n  43:     0x7ffc3b9f7614 - BaseThreadInitThunk\r\n  44:     0x7ffc3c3026a1 - RtlUserThreadStart\r\n\r\nerror: internal compiler error: unexpected panic\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/issues/new?labels=C-bug%2C+I-ICE%2C+T-compiler&template=ice.md\r\n\r\nnote: rustc 1.66.0 (69f9c33d7 2022-12-12) running on x86_64-pc-windows-msvc\r\n\r\nnote: compiler flags: --crate-type bin -C embed-bitcode=no -C debuginfo=2 -C incremental=[REDACTED]\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\n#0 [mir_const] preparing `main` for borrow checking\r\n#1 [mir_promoted] processing MIR for `main`\r\n#2 [mir_borrowck] borrow-checking `main`\r\n#3 [analysis] running analysis passes on this crate\r\nend of query stack\r\n```\r\n\r\n<!--\r\nInclude a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\r\nenvironment. E.g. `RUST_BACKTRACE=1 cargo build`.\r\n-->\r\n<details><summary><strong>Backtrace</strong></summary>\r\n<p>\r\n\r\n```\r\n<backtrace>\r\n```\r\n\r\n</p>\r\n</details>\r\n\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/106159/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/106159/timeline", "performed_via_github_app": null, "state_reason": null}