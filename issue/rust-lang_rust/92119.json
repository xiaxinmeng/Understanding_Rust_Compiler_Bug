{"url": "https://api.github.com/repos/rust-lang/rust/issues/92119", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/92119/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/92119/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/92119/events", "html_url": "https://github.com/rust-lang/rust/issues/92119", "id": 1084393235, "node_id": "I_kwDOAAsO6M5AoocT", "number": 92119, "title": "Strange ASM pessimizations as a result of algorithmic optimization", "user": {"login": "HadrienG2", "id": 1305080, "node_id": "MDQ6VXNlcjEzMDUwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1305080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HadrienG2", "html_url": "https://github.com/HadrienG2", "followers_url": "https://api.github.com/users/HadrienG2/followers", "following_url": "https://api.github.com/users/HadrienG2/following{/other_user}", "gists_url": "https://api.github.com/users/HadrienG2/gists{/gist_id}", "starred_url": "https://api.github.com/users/HadrienG2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HadrienG2/subscriptions", "organizations_url": "https://api.github.com/users/HadrienG2/orgs", "repos_url": "https://api.github.com/users/HadrienG2/repos", "events_url": "https://api.github.com/users/HadrienG2/events{/privacy}", "received_events_url": "https://api.github.com/users/HadrienG2/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234956, "node_id": "MDU6TGFiZWwyMzQ5NTY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-codegen", "name": "A-codegen", "color": "f7e101", "default": false, "description": "Area: Code generation"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2021-12-20T06:03:24Z", "updated_at": "2021-12-22T19:54:47Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "So, I was trying to sum a slice of f32s quickly on stable Rust.\r\n\r\nBut like pretty much all floating-point reductions, the naive algorithm (`floats.iter().sum::<f32>()`) does not autovectorize because its \"natural\" summation order introduces a serial dependency between successive sums. Which makes SIMD parallelization illegal in the eye of a compiler that guarantees bitwise floating point reproducibility like rustc does. Fair enough.\r\n\r\nI saw this as a good motivation to move to explicit SIMD programming, but did not want to lose hardware portability (or, more precisely, wanted to keep it easy), so I tried to see how close I could get to `stdsimd` on stable Rust with only autovectorization and a pinch of hardware-specific vector size tuning.\r\n\r\n---\r\n\r\n[Some hours of trial and error later, I got into a reasonably satisfactory state.](https://play.rust-lang.org/?version=stable&mode=release&edition=2021&gist=52a46d6b0e19e727942b73b69e0a2905) In particular, the core of the algorithm...\r\n\r\n```rust\r\n    // Perform concurrent SIMD accumulation\r\n    let mut accumulators = [SimdF32::default(); CONCURRENCY];\r\n    for chunk in chunks {\r\n        for (accumulator, &vector) in accumulators.iter_mut().zip(chunk) {\r\n            *accumulator += vector;\r\n        }\r\n    }\r\n\r\n    // Merge the SIMD accumulators into one\r\n    let mut stride = CONCURRENCY / 2;\r\n    while stride > 0 {\r\n        for i in 0..stride {\r\n            accumulators[i] += accumulators[i + stride];\r\n        }\r\n        stride /= 2;\r\n    }\r\n    let mut accumulator = accumulators[0];\r\n```\r\n\r\n...translated pretty much into the assembly that I would have written by hand, which made me very happy...\r\n\r\n```asm\r\n.LBB0_17:\r\n\taddps\t(%rdi), %xmm1\r\n\taddps\t16(%rdi), %xmm3\r\n\taddps\t32(%rdi), %xmm2\r\n\taddps\t48(%rdi), %xmm4\r\n\taddq\t$64, %rdi\r\n\taddq\t$4, %rcx\r\n\tjne\t.LBB0_17\r\n\tjmp\t.LBB0_18\r\n\r\n...\r\n\r\n.LBB0_18:\r\n\taddps\t%xmm4, %xmm3\r\n\taddps\t%xmm2, %xmm1\r\n\taddps\t%xmm3, %xmm1\r\n```\r\n\r\n---\r\n\r\nNitpicky as I am, however, I was still a little bit unhappy about the part afterwards, which introduced a chain of serial dependencies that could become a bit long if I were to use a lot of accumulators...\r\n\r\n```rust\r\n    for &vector in remainder {\r\n        accumulator += vector;\r\n    }\r\n```\r\n```asm\r\n.LBB0_31:\r\n\taddps\t(%rcx), %xmm1\r\n\taddq\t$16, %rcx\r\n\tincq\t%rax\r\n\tjne\t.LBB0_31\r\n```\r\n\r\n...because I knew that in this particular case, there should be an easy way to avoid that, which is to interleave the SIMD accumulator merging with the summation of remaining data.\r\n\r\n```rust\r\n    // Reinterprete input as aligned SIMD vectors + some extra floats.\r\n    let (peel, mut vectors, tail) = unsafe { input.align_to::<SimdF32>() };\r\n    \r\n    // Perform concurrent SIMD accumulation, starting at maximal concurrency and\r\n    // decreasing once the number of input vectors gets too small\r\n    let mut accumulators = [SimdF32::default(); MAX_CONCURRENCY];\r\n    let mut concurrency = MAX_CONCURRENCY;\r\n    while concurrency > 0 {\r\n        // Set up accumulators and chunked SIMD data according to current concurrency\r\n        let accumulators = &mut accumulators[..concurrency];\r\n        let chunks = vectors.chunks_exact(concurrency);\r\n        let remainder = chunks.remainder();\r\n\r\n        // Perform concurrent SIMD accumulation\r\n        for chunk in chunks {\r\n            for (accumulator, &vector) in accumulators.iter_mut().zip(chunk) {\r\n                *accumulator += vector;\r\n            }\r\n        }\r\n        \r\n        // Halve SIMD concurrency to accumulate remaining data\r\n        concurrency /= 2;\r\n        for i in 0..concurrency {\r\n            accumulators[i] += accumulators[i+concurrency];\r\n        }\r\n        vectors = remainder;\r\n    }\r\n    let accumulator = accumulators[0];\r\n```\r\n\r\nHowever, much to my surprise, [performing this algorithmic optimization leads rustc to heavily pessimize the inner loop code](https://play.rust-lang.org/?version=stable&mode=release&edition=2021&gist=b8bf035b9f4f72d119dbee68146a47a9) by spilling all but one accumulator on every iteration:\r\n\r\n```asm\r\n.LBB0_16:\r\n\taddps\t(%rax), %xmm1\r\n\tmovaps\t16(%rsp), %xmm2\r\n\tmovaps\t32(%rsp), %xmm3\r\n\tmovaps\t48(%rsp), %xmm4\r\n\taddps\t16(%rax), %xmm2\r\n\tmovaps\t%xmm2, 16(%rsp)\r\n\taddps\t32(%rax), %xmm3\r\n\taddps\t48(%rax), %xmm4\r\n\tmovaps\t%xmm3, 32(%rsp)\r\n\tmovaps\t%xmm4, 48(%rsp)\r\n\taddq\t$64, %rax\r\n\taddq\t$4, %rdi\r\n\tjne\t.LBB0_16\r\n```\r\n\r\nWhy would that happen? The only explanation I have is that rustc is somehow unable to prove that the `accumulators` slice does not alias with the `vectors`/`remainder` slices, and thus spills to memory just in case accumulator changes would affect the input of the next computations.\r\n\r\nBut this sounds like a bug to me: given that I have an &mut to the accumulators, my understanding is that rustc should be able to infer that no other code can see the accumulators, and thus they can remain resident in registers for the entire duration of the accumulation loop.\r\n\r\nCan someone with more knowledge of how rustc and LLVM do their optimization magic cross-check this and tell if my understanding is correct or if the register spills are truly necessary to preserve the semantics of my code?\r\n\r\n---\r\n\r\nAlso, this is on stable release 1.57.0. On beta and nightly, the generated code becomes even stranger:\r\n\r\n```asm\r\n.LBB0_16:\r\n\tmovq\t(%rdx), %rcx\r\n\tmovq\t8(%rdx), %rbx\r\n\tmovd\t%ebx, %xmm5\r\n\tshrq\t$32, %rbx\r\n\tmovd\t%ecx, %xmm6\r\n\tshrq\t$32, %rcx\r\n\tmovd\t%ecx, %xmm7\r\n\tpunpckldq\t%xmm6, %xmm7\r\n\tmovd\t%ebx, %xmm6\r\n\tpunpckldq\t%xmm5, %xmm6\r\n\tpunpcklqdq\t%xmm7, %xmm6\r\n\taddps\t%xmm6, %xmm2\r\n\taddps\t16(%rdx), %xmm1\r\n\taddps\t32(%rdx), %xmm4\r\n\taddps\t48(%rdx), %xmm3\r\n\taddq\t$64, %rdx\r\n\taddq\t$4, %rax\r\n\tjne\t.LBB0_16\r\n```\r\n\r\nHere, rustc generates the code I would expect for the last three accumulators, but then it goes crazy with the first accumulator and generates the least efficient SSE load I have ever seen.\r\n\r\nSo it seems the aliasing issue got resolved, but was replaced by another issue beyond my comprehension... Here again, compiler expert help would be useful.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/92119/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/92119/timeline", "performed_via_github_app": null, "state_reason": null}