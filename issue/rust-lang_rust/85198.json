{"url": "https://api.github.com/repos/rust-lang/rust/issues/85198", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/85198/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/85198/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/85198/events", "html_url": "https://github.com/rust-lang/rust/issues/85198", "id": 888827487, "node_id": "MDU6SXNzdWU4ODg4Mjc0ODc=", "number": 85198, "title": "Improved Performance for Disguised Fast-Path Cases in Float Parsing", "user": {"login": "Alexhuszagh", "id": 9440903, "node_id": "MDQ6VXNlcjk0NDA5MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/9440903?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexhuszagh", "html_url": "https://github.com/Alexhuszagh", "followers_url": "https://api.github.com/users/Alexhuszagh/followers", "following_url": "https://api.github.com/users/Alexhuszagh/following{/other_user}", "gists_url": "https://api.github.com/users/Alexhuszagh/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexhuszagh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexhuszagh/subscriptions", "organizations_url": "https://api.github.com/users/Alexhuszagh/orgs", "repos_url": "https://api.github.com/users/Alexhuszagh/repos", "events_url": "https://api.github.com/users/Alexhuszagh/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexhuszagh/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 2011781731, "node_id": "MDU6TGFiZWwyMDExNzgxNzMx", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs", "name": "T-libs", "color": "bfd4f2", "default": false, "description": "Relevant to the library team, which will review and decide on the PR/issue."}, {"id": 2139259423, "node_id": "MDU6TGFiZWwyMTM5MjU5NDIz", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-floating-point", "name": "A-floating-point", "color": "f7e101", "default": false, "description": "Area: Floating point numbers and arithmetic"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2021-05-11T21:59:17Z", "updated_at": "2021-07-17T15:26:24Z", "closed_at": "2021-07-17T15:26:24Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "# Summary\r\n\r\nRust's float-parsing algorithm dec2flt uses a slower parsing algorithm than necessary than required to parse numbers like `\"1.2345e30\"`, which can slow down parsing times by nearly 300%. Adding trivial changes to dec2flt leads to dramatically improved parsing times, without increasing binary sizes, or slowing down other parse cases. Please see the \"Sample Repository\" below for the exact specifics, or in order to replicate these changes. This is an [initial attempt](https://internals.rust-lang.org/t/implementing-a-fast-correct-float-parser/14670) as part of an ongoing effort to speed up float parsing in Rust, and aims to integrate algorithms I've implemented (currently used in nom and serde-json) back in the core library.\r\n\r\n# Issue\r\n\r\nWhen parsing floating-point numbers, there is a fast-path algorithm that uses native floats to parse the float if applicable. This only occurs if:\r\n- The significant digits of the float, or mantissa, can be represented in `mantissa_size+1` bits.\r\n- The exponent can be exactly represented, or the absolute value is less than `\u230a(mantissa_size+1) / log2(5) \u230b`.\r\n\r\nPlease note that this is the exponent relative to the significant digits, for example, for `\"1.2345e5\"`, this exponent would be `1`, but for `\"12345e5\"` this exponent would be `5`.\r\n\r\nThe reason why we use `mantissa_size+1` is due to the implicit, hidden bit of the float. A longer post detailing the attempts to improve float parsing on rust-internals can be found [here](https://internals.rust-lang.org/t/implementing-a-fast-correct-float-parser/14670). The exact values for `f32` are as follows:\r\n\r\n**f32:**\r\n- significant digit bits: 24\r\n- exponent range: `[-10, 10]`\r\n\r\n**f64:**\r\n- significant digit bits: 53\r\n- exponent range: `[-22, 22]`\r\n\r\nHowever, there is an exception: if the value has less significant bits than the maximum, but has an exponent larger than our range, we can shift powers-of-10 from the exponent to the significant digits. For example, `\"1.2345e30\"` would have significant digits of `12345` and an exponent of `26`, which is outside our range of `[-22, 22]`. However, if we shift `10^4` from the exponent to the significant digits, we get significant digits of `123450000` and an exponent of `22`, which is a valid fast-path case. This leads to a massive performance improvement with a large number of real-world float cases, and has an insignificant impact on other cases.\r\n\r\n# Binary Sizes\r\n\r\nThese were compiled on a target of `x86_64-unknown-linux-gnu`, running kernel version `5.11.16-100`, on a Rust version of `rustc 1.53.0-nightly (132b4e5d1 2021-04-13)`. The sizes reflect the binary sizes reported by `ls -sh`, both before and after running the `strip` command. The debug profile was used for opt-levels `0` and `1`, and was as follows:\r\n\r\n```toml\r\n[profile.dev]\r\nopt-level = \"...\"\r\ndebug = true\r\nlto = false\r\n```\r\n\r\nThe release profile was used for opt-levels `2`, `3`, `s` and `z` and was as follows:\r\n\r\n```toml\r\n[profile.release]\r\nopt-level = \"...\"\r\ndebug = false\r\ndebug-assertions = false\r\nlto = true\r\n```\r\n\r\n**core**\r\n\r\nThese are the binary sizes prior to making changes.\r\n\r\nopt-level|size|size(stripped)\r\n|:-:|:-:|:-:|\r\n0|3.6M|360K\r\n1|3.5M|316K\r\n2|1.3M|236K\r\n3|1.3M|248K\r\ns|1.3M|244K\r\nz|1.3M|248K\r\n\r\n**disguised**\r\n\r\nThese are the binary sizes after making changes to speed up disguised fast-path cases.\r\n\r\nopt-level|size|size(stripped)\r\n|:-:|:-:|:-:|\r\n0|3.6M|360K\r\n1|3.5M|316K\r\n2|1.3M|236K\r\n3|1.3M|248K\r\ns|1.3M|252K\r\nz|1.3M|248K\r\n\r\n# Performance\r\n\r\nOverall, the changes to speed up disguised fast-path cases led to ~-75% change in performance relative to core, without impacting any other benchmarks.\r\n\r\nThese benchmarks were run on an `i7-6560U CPU @ 2.20GHz`, on a target of `x86_64-unknown-linux-gnu`, running kernel version `5.11.16-100`, on a Rust version of `rustc 1.53.0-nightly (132b4e5d1 2021-04-13)`. The performance CPU governor was used for all benchmarks, and were run consecutively on A/C power with only tmux and Sublime Text open for all benchmarks. The floats that were parsed are as follows:\r\n\r\n```rust\r\n// Example fast-path value.\r\nconst FAST: &str = \"1.2345e22\";\r\n// Example disguised fast-path value.\r\nconst DISGUISED: &str = \"1.2345e30\";\r\n// Example moderate path value: clearly not halfway `1 << 53`.\r\nconst MODERATE: &str = \"9007199254740992.0\";\r\n// Example exactly-halfway value `(1<<53) + 1`.\r\nconst HALFWAY: &str = \"9007199254740993.0\";\r\n// Example large, near-halfway value.\r\nconst LARGE: &str = \"8.988465674311580536566680e307\";\r\n// Example denormal, near-halfway value.\r\nconst DENORMAL: &str = \"8.442911973260991817129021e-309\";\r\n```\r\n\r\n**core**\r\n\r\nThese are the benchmarks prior to making changes.\r\n\r\n|float|speed|\r\n|:-:|:-:|\r\n|fast|32.952ns|\r\n|disguised|129.86ns|\r\n|moderate|237.08ns|\r\n|halfway|371.21ns|\r\n|large|287.81us|\r\n|denormal|122.36us|\r\n\r\n**disguised**\r\n\r\nThese are the benchmarks after making changes to speed up disguised fast-path cases.\r\n\r\n|float|speed|\r\n|:-:|:-:|\r\n|fast|32.572ns|\r\n|disguised|33.813ns|\r\n|moderate|233.03ns|\r\n|halfway|350.99ns|\r\n|large|300.29us|\r\n|denormal|129.36us|\r\n\r\n# Correctness Concerns\r\n\r\nNone, since this merely transfer powers-of-10 from the exponent to the significant digits, using integer multiplication, and therefore can trivially be verified for correctness.\r\n\r\n# Changes\r\n\r\nThe diff, which would be relative to `library/core/src/num`, is as follows:\r\n\r\n```diff\r\ndiff --git a/src/dec2flt/algorithm.rs b/src/dec2flt/algorithm.rs\r\nindex 2b0b4cb..76d8105 100644\r\n--- a/src/dec2flt/algorithm.rs\r\n+++ b/src/dec2flt/algorithm.rs\r\n@@ -110,7 +110,7 @@ mod fpu_precision {\r\n ///\r\n /// This is extracted into a separate function so that it can be attempted before constructing\r\n /// a bignum.\r\n-pub fn fast_path<T: RawFloat>(integral: &[u8], fractional: &[u8], e: i64) -> Option<T> {\r\n+pub fn fast_path<T: RawFloat>(integral: &[u8], fractional: &[u8], mut e: i64) -> Option<T> {\r\n     let num_digits = integral.len() + fractional.len();\r\n     // log_10(f64::MAX_SIG) ~ 15.95. We compare the exact value to MAX_SIG near the end,\r\n     // this is just a quick, cheap rejection (and also frees the rest of the code from\r\n@@ -118,14 +118,29 @@ pub fn fast_path<T: RawFloat>(integral: &[u8], fractional: &[u8], e: i64) -> Opt\r\n     if num_digits > 16 {\r\n         return None;\r\n     }\r\n-    if e.abs() >= T::CEIL_LOG5_OF_MAX_SIG as i64 {\r\n+    let max_exp = T::FLOOR_LOG5_OF_MAX_SIG as i64;\r\n+    let min_exp = -max_exp;\r\n+    let shift_exp = T::FLOOR_LOG10_OF_MAX_SIG as i64;\r\n+    let disguised_exp = max_exp + shift_exp;\r\n+    if e < min_exp || e > disguised_exp {\r\n         return None;\r\n     }\r\n-    let f = num::from_str_unchecked(integral.iter().chain(fractional.iter()));\r\n+    let mut f = num::from_str_unchecked(integral.iter().chain(fractional.iter()));\r\n     if f > T::MAX_SIG {\r\n         return None;\r\n     }\r\n \r\n+    // Handle a disguised fast path case here.\r\n+    if e > max_exp {\r\n+        let shift = e - max_exp;\r\n+        let value = f.checked_mul(T::short_int_pow10(shift as usize))?;\r\n+        if value > T::MAX_SIG {\r\n+            return None;\r\n+        }\r\n+        f = value;\r\n+        e = max_exp;\r\n+    }\r\n+\r\n     // The fast path crucially depends on arithmetic being rounded to the correct number of bits\r\n     // without any intermediate rounding. On x86 (without SSE or SSE2) this requires the precision\r\n     // of the x87 FPU stack to be changed so that it directly rounds to 64/32 bit.\r\ndiff --git a/src/dec2flt/rawfp.rs b/src/dec2flt/rawfp.rs\r\nindex a3acf3d..15a5839 100644\r\n--- a/src/dec2flt/rawfp.rs\r\n+++ b/src/dec2flt/rawfp.rs\r\n@@ -73,13 +73,21 @@ pub trait RawFloat:\r\n     /// represented, the other code in this module makes sure to never let that happen.\r\n     fn from_int(x: u64) -> Self;\r\n \r\n+    fn short_int_pow10(e: usize) -> u64 {\r\n+        table::SHORT_POWERS[e]\r\n+    }\r\n+\r\n     /// Gets the value 10<sup>e</sup> from a pre-computed table.\r\n-    /// Panics for `e >= CEIL_LOG5_OF_MAX_SIG`.\r\n+    /// Panics for `e >= FLOOR_LOG5_OF_MAX_SIG`.\r\n     fn short_fast_pow10(e: usize) -> Self;\r\n \r\n     /// What the name says. It's easier to hard code than juggling intrinsics and\r\n     /// hoping LLVM constant folds it.\r\n-    const CEIL_LOG5_OF_MAX_SIG: i16;\r\n+    const FLOOR_LOG5_OF_MAX_SIG: i16;\r\n+\r\n+    /// What the name says. It's easier to hard code than juggling intrinsics and\r\n+    /// hoping LLVM constant folds it.\r\n+    const FLOOR_LOG10_OF_MAX_SIG: i16;\r\n \r\n     // A conservative bound on the decimal digits of inputs that can't produce overflow or zero or\r\n     /// subnormals. Probably the decimal exponent of the maximum normal value, hence the name.\r\n@@ -147,7 +155,8 @@ impl RawFloat for f32 {\r\n \r\n     const SIG_BITS: u8 = 24;\r\n     const EXP_BITS: u8 = 8;\r\n-    const CEIL_LOG5_OF_MAX_SIG: i16 = 11;\r\n+    const FLOOR_LOG5_OF_MAX_SIG: i16 = 10;\r\n+    const FLOOR_LOG10_OF_MAX_SIG: i16 = 7;\r\n     const MAX_NORMAL_DIGITS: usize = 35;\r\n     const INF_CUTOFF: i64 = 40;\r\n     const ZERO_CUTOFF: i64 = -48;\r\n@@ -196,7 +205,8 @@ impl RawFloat for f64 {\r\n \r\n     const SIG_BITS: u8 = 53;\r\n     const EXP_BITS: u8 = 11;\r\n-    const CEIL_LOG5_OF_MAX_SIG: i16 = 23;\r\n+    const FLOOR_LOG5_OF_MAX_SIG: i16 = 22;\r\n+    const FLOOR_LOG10_OF_MAX_SIG: i16 = 15;\r\n     const MAX_NORMAL_DIGITS: usize = 305;\r\n     const INF_CUTOFF: i64 = 310;\r\n     const ZERO_CUTOFF: i64 = -326;\r\ndiff --git a/src/dec2flt/table.rs b/src/dec2flt/table.rs\r\nindex 97b497e..bd9e53d 100644\r\n--- a/src/dec2flt/table.rs\r\n+++ b/src/dec2flt/table.rs\r\n@@ -1234,6 +1234,30 @@ pub static POWERS: ([u64; 611], [i16; 611]) = (\r\n     ],\r\n );\r\n \r\n+#[rustfmt::skip]\r\n+pub const SHORT_POWERS: [u64; 20] = [\r\n+    1,\r\n+    10,\r\n+    100,\r\n+    1000,\r\n+    10000,\r\n+    100000,\r\n+    1000000,\r\n+    10000000,\r\n+    100000000,\r\n+    1000000000,\r\n+    10000000000,\r\n+    100000000000,\r\n+    1000000000000,\r\n+    10000000000000,\r\n+    100000000000000,\r\n+    1000000000000000,\r\n+    10000000000000000,\r\n+    100000000000000000,\r\n+    1000000000000000000,\r\n+    10000000000000000000,\r\n+];\r\n+\r\n #[rustfmt::skip]\r\n pub const F32_SHORT_POWERS: [f32; 11] = [\r\n     1e0,\r\n```\r\n\r\nI'd be happy to submit a pull request with these changes, if they are satisfactory to you.\r\n\r\n# Sample Repository\r\n\r\nI've created a simple, minimal repository tracking these changes on [rust-dec2flt](https://github.com/Alexhuszagh/rust-dec2flt), which has a [core branch](https://github.com/Alexhuszagh/rust-dec2flt/tree/core) that is identical to Rust's current implementation in the core library. The [disguised branch](https://github.com/Alexhuszagh/rust-dec2flt/tree/disguised) contains the changes to improve parsing speeds for disguised fast-path cases. I will also, if there is interest, gradually be making changes for the moderate and slow-path algorithms.", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/85198/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/85198/timeline", "performed_via_github_app": null, "state_reason": "completed"}