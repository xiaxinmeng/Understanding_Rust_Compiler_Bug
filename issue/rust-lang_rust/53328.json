{"url": "https://api.github.com/repos/rust-lang/rust/issues/53328", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/53328/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/53328/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/53328/events", "html_url": "https://github.com/rust-lang/rust/issues/53328", "id": 350271403, "node_id": "MDU6SXNzdWUzNTAyNzE0MDM=", "number": 53328, "title": "\"invert\" borrow computation", "user": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 60344715, "node_id": "MDU6TGFiZWw2MDM0NDcxNQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/P-medium", "name": "P-medium", "color": "eb6420", "default": false, "description": "Medium priority"}, {"id": 64037154, "node_id": "MDU6TGFiZWw2NDAzNzE1NA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-compiletime", "name": "I-compiletime", "color": "e11d21", "default": false, "description": "Problems and improvements with respect to compile times."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 604489711, "node_id": "MDU6TGFiZWw2MDQ0ODk3MTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-NLL", "name": "A-NLL", "color": "f7e101", "default": false, "description": "Area: Non Lexical Lifetimes (NLL)"}, {"id": 849077850, "node_id": "MDU6TGFiZWw4NDkwNzc4NTA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/WG-compiler-performance", "name": "WG-compiler-performance", "color": "c2e0c6", "default": false, "description": "Working group: Compiler Performance"}, {"id": 867466241, "node_id": "MDU6TGFiZWw4Njc0NjYyNDE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/NLL-performant", "name": "NLL-performant", "color": "f799ea", "default": false, "description": "Working towards the \"performance is good\" goal"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 9, "created_at": "2018-08-14T03:50:48Z", "updated_at": "2019-11-29T19:01:41Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I think we can make the process of checking borrows more efficient. Right now, we use a dataflow computation to compute the \"borrows in scope\" at each point. Then we walk over the MIR. At each point, whenever we access a path `P1`, we execute over the borrows in scope and look for any which conflict with `P1`. If we find any, we report an error.\r\n\r\nI think what we should do instead is this: walk over all the borrows. For each borrow, do a DFS from the point of the borrow. Stop the DFS when we either (a) exit the borrow region or (b) detect that the path which was borrowed was overwritten. (We already do a very similar computation.) During that DFS, we look at the paths that are accessed by each statement we traverse, and check if they conflict with the borrow. (This will require us to efficiently index the paths that are accessed by a given location.)\r\n\r\nThis is a non-trivial amount of refactoring but I think it will be a win. We're already doing the DFS as part of the `precompute_borrows_out_of_scope` routine -- the only difference is that now we'll be checking the paths accessed by each statement as we go. But we can make that efficient by using a simple hashing scheme like the one described in #53159.\r\n\r\nIn exchange, we get to avoid doing an extra dataflow computation. This means one less dataflow to do and also one less thing to update.\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/53328/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/53328/timeline", "performed_via_github_app": null, "state_reason": null}