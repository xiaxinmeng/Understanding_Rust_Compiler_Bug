{"url": "https://api.github.com/repos/rust-lang/rust/issues/1861", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/1861/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/1861/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/1861/events", "html_url": "https://github.com/rust-lang/rust/issues/1861", "id": 3263082, "node_id": "MDU6SXNzdWUzMjYzMDgy", "number": 1861, "title": "Support for custom build logic in Cargo", "user": {"login": "thoughtpolice", "id": 3416, "node_id": "MDQ6VXNlcjM0MTY=", "avatar_url": "https://avatars.githubusercontent.com/u/3416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thoughtpolice", "html_url": "https://github.com/thoughtpolice", "followers_url": "https://api.github.com/users/thoughtpolice/followers", "following_url": "https://api.github.com/users/thoughtpolice/following{/other_user}", "gists_url": "https://api.github.com/users/thoughtpolice/gists{/gist_id}", "starred_url": "https://api.github.com/users/thoughtpolice/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thoughtpolice/subscriptions", "organizations_url": "https://api.github.com/users/thoughtpolice/orgs", "repos_url": "https://api.github.com/users/thoughtpolice/repos", "events_url": "https://api.github.com/users/thoughtpolice/events{/privacy}", "received_events_url": "https://api.github.com/users/thoughtpolice/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2012-02-17T04:41:56Z", "updated_at": "2013-02-16T21:30:39Z", "closed_at": "2013-02-16T21:30:39Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "The metaticket is #1850.\n\nSummary: invariably, due to wanting to keep packages self contained, write wrappers for C++ code, invoke configuration-based build logic (i.e. I want to invoke some transparent compression, providing `zlib` is on the system, etc.) or any number of things, there is often going a need for a more complicated build system than what the crate mechanism provides. Specifically, libraries which do things like foreign bindings are extremely prone to needing this in my experience a lot of times, and requiring arduous - sometimes totally manual - installation on the users part is incredibly unsatisfactory.\n\nAs of right now, Cargo only manually looks for crates in the source directory, followed by hitting them with `rustc`. I envision a world where most of the time - this is all that's needed. Cargo should not be responsible for complex code building logic. \n\nHowever, it most certainly needs support for allowing library creators to defer to a build system to run if the simple case doesn't cut it. The compression example is a real one - in writing Haskell bindings for LevelDB, I found it very nice that I could use autoconf to detect if the `snappy` compression library was available, and compile the LevelDB source code inline with that assumption if it was.\n\nI like the homebrew approach. Any build system it wants - but you express the build in Ruby as a 'formula' for building it, using system commands. So you can have cmake based software, autoconf based, just something with a makefile, etc. The formula merely invokes system commands and fails if they err. One thing to note here is that Homebrew _does_ expect you to respect the installation prefix normally, so it gives ruby scripts a 'prefix' variable you can pass on, etc.\n\nI envision something similar for Cargo - just a way to run commands for a build. A nice aspect of this is Cargo still doesn't really do any building on its own, you just give it commands. If your actual package build is handled in an `autoconf` and `makefile` like style, you can always just build like that during development. The metadata is only need to inform Cargo _how to_ run a build at installation time.\n\nWith the running LevelDB example, let's say I have a package, just called `leveldb`. It has a file structure like this:\n\n```\n./configure\n./Makefile\n./leveldb.rc\n./leveldb.rs\n./build.cargo\n```\n\nName is arbitrary, but `build.cargo` contains a list of commands to run - it's basically the trigger for custom configuration logic. In fact, you could just say it's any arbitrary executable script, e.g:\n\n```\n#!/bin/sh\n./configure --prefix=$(CARGO_PREFIX)\nmake\nmake install\n```\n\nand `make` would take care of calling `gcc` and `rustc` on the crate, etc. This example in particular is kind of half-assed, but you get the gist. Ultimately, I think Cargo should always defer the responsibility of building onto a build system, and not say \"you must have a configure script\" or \"must use a makefile.\" `build.cargo` is just some script - you could write it in Perl or ruby/etc. But there are downsides to this approach:\n- Per #1768, rust should eventually work with `msvc`, and robustly on windows so people will need a way to specify builds for different platforms, particularly windows. I have no idea what this looks like.\n- It adds the caveat all libraries must respect installation prefixes, especially since cargo is local by default.\n\nThis does allow even the simplest of build systems to work, though. As an aside, this, along with support for something like #612 would most certainly make it very possible to bind a lot of packages, especially when you want autoconf-style feature detection at configuration time.\n\nSo I am personally a fan of this method or something like it. Does anybody have objections to something like this? Thoughts? I'm particularly hazy on saying something as flat out as \"`build.cargo` is executable, just do it\", but it is simple and flexible.\n", "closed_by": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/1861/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/1861/timeline", "performed_via_github_app": null, "state_reason": "completed"}