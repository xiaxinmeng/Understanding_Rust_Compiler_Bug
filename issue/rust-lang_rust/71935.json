{"url": "https://api.github.com/repos/rust-lang/rust/issues/71935", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/71935/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/71935/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/71935/events", "html_url": "https://github.com/rust-lang/rust/issues/71935", "id": 612973071, "node_id": "MDU6SXNzdWU2MTI5NzMwNzE=", "number": 71935, "title": "Missed LLVM array bound test elision with for+step_by loop", "user": {"login": "leonardo-m", "id": 22328461, "node_id": "MDQ6VXNlcjIyMzI4NDYx", "avatar_url": "https://avatars.githubusercontent.com/u/22328461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/leonardo-m", "html_url": "https://github.com/leonardo-m", "followers_url": "https://api.github.com/users/leonardo-m/followers", "following_url": "https://api.github.com/users/leonardo-m/following{/other_user}", "gists_url": "https://api.github.com/users/leonardo-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/leonardo-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/leonardo-m/subscriptions", "organizations_url": "https://api.github.com/users/leonardo-m/orgs", "repos_url": "https://api.github.com/users/leonardo-m/repos", "events_url": "https://api.github.com/users/leonardo-m/events{/privacy}", "received_events_url": "https://api.github.com/users/leonardo-m/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 3425147156, "node_id": "LA_kwDOAAsO6M7MJ5kU", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-array", "name": "A-array", "color": "f7e101", "default": false, "description": "Area: [T; N]"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-05-06T00:22:27Z", "updated_at": "2023-05-22T13:40:14Z", "closed_at": "2023-05-22T13:40:13Z", "author_association": "NONE", "active_lock_reason": null, "body": "This code implements two times a basic Eratosthenes Sieve, in the first one there's an inner while loop plus increment, and in the second there is a for loop that uses step_by:\r\n```rust\r\n#![feature(slice_fill, const_generics)]\r\n#![allow(incomplete_features)]\r\n\r\n#[inline(never)]\r\npub fn eratosthenes_sieve_bools1<const M: usize>(primes: &mut [bool; M]) {\r\n    if M < 2 { return; }\r\n    primes.fill(true);\r\n    primes[0] = false;\r\n    primes[1] = false;\r\n\r\n    for i in 2 .. (M as f64).sqrt() as usize + 1 {\r\n        if primes[i] {\r\n            let mut j = i * i;\r\n            while j < M {\r\n                if primes[j] {\r\n                    primes[j] = false;\r\n                }\r\n                j += i;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n#[inline(never)]\r\npub fn eratosthenes_sieve_bools2<const M: usize>(primes: &mut [bool; M]) {\r\n    if M < 2 { return; }\r\n    primes.fill(true);\r\n    primes[0] = false;\r\n    primes[1] = false;\r\n\r\n    for i in 2 .. (M as f64).sqrt() as usize + 1 {\r\n        if primes[i] {\r\n            for j in (i * i .. M).step_by(i) {\r\n                if primes[j] {\r\n                    primes[j] = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn main() {\r\n    const N: usize = 1000;\r\n    let mut primes = [false; N];\r\n    eratosthenes_sieve_bools1(&mut primes);\r\n    eratosthenes_sieve_bools2(&mut primes);\r\n}\r\n```\r\nCompiled with `-C opt-level=3 --emit asm`:\r\n```asm\r\neratosthenes_sieve_bools1:\r\n    pushq   %r14\r\n    pushq   %rsi\r\n    pushq   %rdi\r\n    pushq   %rbx\r\n    subq    $40, %rsp\r\n    movq    %rcx, %r14\r\n    addq    $2, %rcx\r\n    movl    $998, %r8d\r\n    movb    $1, %dl\r\n    callq   memset\r\n    movw    $0, (%r14)\r\n    leaq    4(%r14), %rbx\r\n    movl    $2, %edi\r\n    movl    $5, %ecx\r\n    movq    %rdi, %rsi\r\n    addq    $1, %rdi\r\n    cmpb    $0, (%r14,%rsi)\r\n    jne .LBB4_2\r\n    .p2align    4, 0x90\r\n.LBB4_7:\r\n    addq    %rcx, %rbx\r\n    addq    $2, %rcx\r\n    cmpq    $32, %rdi\r\n    je  .LBB4_8\r\n    movq    %rdi, %rsi\r\n    addq    $1, %rdi\r\n    cmpb    $0, (%r14,%rsi)\r\n    je  .LBB4_7\r\n.LBB4_2:\r\n    movq    %rsi, %rdx\r\n    imulq   %rsi, %rdx\r\n    cmpq    $999, %rdx\r\n    ja  .LBB4_7\r\n    movq    %rbx, %rax\r\n    cmpb    $0, (%rax)\r\n    jne .LBB4_5\r\n    .p2align    4, 0x90\r\n.LBB4_6:\r\n    addq    %rsi, %rdx\r\n    addq    %rsi, %rax\r\n    cmpq    $1000, %rdx\r\n    jae .LBB4_7\r\n.LBB4_4:\r\n    cmpb    $0, (%rax)\r\n    je  .LBB4_6\r\n.LBB4_5:\r\n    movb    $0, (%rax)\r\n    addq    %rsi, %rdx\r\n    addq    %rsi, %rax\r\n    cmpq    $1000, %rdx\r\n    jb  .LBB4_4\r\n    jmp .LBB4_7\r\n.LBB4_8:\r\n    addq    $40, %rsp\r\n    popq    %rbx\r\n    popq    %rdi\r\n    popq    %rsi\r\n    popq    %r14\r\n    retq\r\n\r\n\r\neratosthenes_sieve_bools2:\r\n    pushq   %rsi\r\n    subq    $32, %rsp\r\n    movq    %rcx, %rsi\r\n    addq    $2, %rcx\r\n    movl    $998, %r8d\r\n    movb    $1, %dl\r\n    callq   memset\r\n    movw    $0, (%rsi)\r\n    movl    $2, %r8d\r\n    cmpb    $0, (%rsi,%r8)\r\n    jne .LBB5_2\r\n    .p2align    4, 0x90\r\n.LBB5_5:\r\n    addq    $1, %r8\r\n    cmpq    $32, %r8\r\n    je  .LBB5_6\r\n    cmpb    $0, (%rsi,%r8)\r\n    je  .LBB5_5\r\n.LBB5_2:\r\n    movq    %r8, %rcx\r\n    imulq   %r8, %rcx\r\n    leaq    -1(%r8), %r9\r\n    xorl    %eax, %eax\r\n    .p2align    4, 0x90\r\n.LBB5_3:\r\n    testb   $1, %al\r\n    je  .LBB5_4\r\n.LBB5_7:\r\n    addq    %r9, %rcx\r\n    jb  .LBB5_5\r\n    cmpq    $999, %rcx\r\n    ja  .LBB5_5\r\n    ja  .LBB5_13\r\n    movq    %rcx, %rdx\r\n    leaq    1(%rdx), %rcx\r\n    movb    $1, %al\r\n    cmpb    $0, (%rsi,%rdx)\r\n    je  .LBB5_3\r\n    jmp .LBB5_12\r\n    .p2align    4, 0x90\r\n.LBB5_4:\r\n    movq    %rcx, %rdx\r\n    cmpq    $1000, %rcx\r\n    jae .LBB5_5\r\n    leaq    1(%rdx), %rcx\r\n    movb    $1, %al\r\n    cmpb    $0, (%rsi,%rdx)\r\n    je  .LBB5_3\r\n.LBB5_12:\r\n    movb    $0, (%rsi,%rdx)\r\n    testb   $1, %al\r\n    jne .LBB5_7\r\n    jmp .LBB5_4\r\n.LBB5_6:\r\n    addq    $32, %rsp\r\n    popq    %rsi\r\n    retq\r\n.LBB5_13:\r\n    leaq    .L__unnamed_2(%rip), %r8\r\n    movl    $1000, %edx\r\n    callq   _ZN4core9panicking18panic_bounds_check17h61d4154b3fc3aa60E\r\n    ud2\r\n```\r\nUsing:\r\n```\r\nrustc 1.45.0-nightly (2454a68cf 2020-05-04)\r\nbinary: rustc\r\ncommit-hash: 2454a68cfbb63aa7b8e09fe05114d5f98b2f9740\r\ncommit-date: 2020-05-04\r\nhost: x86_64-pc-windows-gnu\r\nrelease: 1.45.0-nightly\r\nLLVM version: 9.0\r\n```\r\nIf you notice if I use a step_by LLVM stops being able to infer that all array accesses are in-bound. In this simple program this isn't too much bad, but in another larger program step_by has stopped a vectorization from happening, and this has caused a slower computational kernel for a critical inner loop. I am now avoiding step_by in some inner loops.", "closed_by": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/71935/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/71935/timeline", "performed_via_github_app": null, "state_reason": "completed"}