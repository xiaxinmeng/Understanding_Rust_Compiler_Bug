{"url": "https://api.github.com/repos/rust-lang/rust/issues/88140", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/88140/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/88140/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/88140/events", "html_url": "https://github.com/rust-lang/rust/issues/88140", "id": 973796564, "node_id": "MDU6SXNzdWU5NzM3OTY1NjQ=", "number": 88140, "title": "Stabilize reserved prefixes", "user": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 919710011, "node_id": "MDU6TGFiZWw5MTk3MTAwMTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/disposition-merge", "name": "disposition-merge", "color": "008800", "default": false, "description": "This issue / PR is in PFCP or FCP with a disposition to merge it."}, {"id": 923282386, "node_id": "MDU6TGFiZWw5MjMyODIzODY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/finished-final-comment-period", "name": "finished-final-comment-period", "color": "f9e189", "default": false, "description": "The final comment period is finished for this PR / Issue."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 10, "created_at": "2021-08-18T15:21:14Z", "updated_at": "2022-07-16T21:52:06Z", "closed_at": "2022-07-16T21:52:05Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "# Reserved prefixes stabilization report\r\n\r\n## Links\r\n\r\n* [RFC](https://github.com/rust-lang/rfcs/pull/3101)\r\n* [Tracking issue](https://github.com/rust-lang/rust/issues/84978)\r\n* Rust reference PR -- missing?\r\n* [Implementation PR](https://github.com/rust-lang/rust/issues/84599)\r\n\r\n## Summary\r\n\r\n- `any_identifier#`, `any_identifier\"...\"`, and `any_identifier'...'` are now reserved\r\n  syntax, and no longer tokenize.\r\n- This is mostly relevant to macros. E.g. `quote!{ #a#b }` is no longer accepted.\r\n- It doesn't treat keywords specially, so e.g. `match\"...\" {}` is no longer accepted.\r\n- Insert whitespace between the identifier and the subsequent `#`, `\"`, or `'`\r\n  to avoid errors.\r\n- Edition migrations will help you insert whitespace in such cases.\r\n\r\n\r\n## Details\r\n\r\nTo make space for new syntax in the future, we've decided to reserve syntax for prefixed identifiers and literals: `prefix#identifier`, `prefix\"string\"`, `prefix'c'`, and `prefix#123`, where `prefix` can be any identifier. (Except those prefixes that already have a meaning, such as `b'...'` (byte strings) and `r\"...\"` (raw strings).)\r\n\r\nThis provides syntax we can expand into in the future without requiring an edition boundary. We may use this for temporary syntax until the next edition, or for permanent syntax if appropriate.\r\n\r\nWithout an edition, this would be a breaking change, since macros can currently accept syntax such as `hello\"world\"`, which they will see as two separate tokens: `hello` and `\"world\"`. The (automatic) fix is simple though: just insert a space: `hello \"world\"`. Likewise, `prefix#ident` should become `prefix #ident`. Edition migrations will help with this fix.\r\n\r\nOther than turning these into a tokenization error, [the RFC][10] does not attach a meaning to any prefix yet. Assigning meaning to specific prefixes is left to future proposals, which will now&mdash;thanks to reserving these prefixes&mdash;not be breaking changes.\r\n\r\nSome new prefixes you might potentially see in the future (though we haven't\r\ncommitted to any of them yet):\r\n\r\n- `k#keyword` to allow writing keywords that don't exist yet in the current edition. For example, while `async` is not a keyword in edition 2015, this prefix would've allowed us to accept `k#async` in edition 2015 without having to wait for edition 2018 to reserve `async` as a keyword.\r\n- `f\"\"` as a short-hand for a format string. For example, `f\"hello {name}\"` as a short-hand for the equivalent `format!()` invocation.\r\n- `s\"\"` for `String` literals.\r\n- `c\"\"` or `z\"\"` for null-terminated C strings.\r\n\r\n[10]: https://github.com/rust-lang/rfcs/pull/3101\r\n\r\n## How unresolved questions were resolved and other interesting developments\r\n\r\n### Where and how to enforce prefixes\r\n\r\nThe biggest question was where to enforce the prefixes and emit errors. **We ultimately opted to emit errors in the lexer, which meant that the lexer had to become aware of the current edition.** There was an alternative of using \"jointness\" and enforcing the conditions in the parser. The idea was to leverage the fact that Rust tokens (at least some subset of them) record not only their content but whether they are separated by whitespace from the next token. This was intended to enable compound operators like `<<` to be parsed as two `<` tokens in some parts \u00f8f the parser (types) and as a single token elsewhere (expressions), without the lexer having to know what state the parser was in. This same approach could conceptually be used so that the lexer doesn't have to know the *edition*.\r\n\r\nAs [described in detail in this writeup](https://hackmd.io/YLe7viGLTu2PfE5sQO4v0w), however, the jointness approach had several downsides. For example, it meant that [lexing of literals was independent of prefix](https://hackmd.io/YLe7viGLTu2PfE5sQO4v0w?view#JOINTNESS-would-require-lexing-to-be-independent-of-prefix): we might like `f\"{foo(\"bar\")}\"` to be lexed a a string, but that is not possible unless the lexer knows that an `f` string can contain embedded expressions. Similarly, which escape codes the lexer accepts depends on the prefix (e.g. \\x for b\"\"). (This is especially relevant for raw strings: whether `fr\"\\\"` is accepted or not depends on what meaning we assign to `fr`.) Jointness also had [forwards compatbility hazards with macro arm ordering](https://hackmd.io/YLe7viGLTu2PfE5sQO4v0w?view#Forwards-compat-hazard-with-JOINTNESS-due-to-macro-rules-arm-ordering). Finally, the lexer-based approach can be converted to a jointness-based approach later, as it currently gives errors much earlier in the process.\r\n\r\nThere were also advantages to jointness: it would allow more procedural macro prototyping, and it means that the lexer would remain independent of edition.\r\n\r\n### Edition used for procedural macro APIs\r\n\r\nThere are some procedural macro APIs that lex tokens from strings. Those APIs have not traditionally taken a span or other information from which an edition can be derived. Those APIs will be documented with the Edition that they use to do lexing. In the future we may wish to add new APIs that take a Span or other parameter and use that to derive the Edition.", "closed_by": {"login": "joshtriplett", "id": 162737, "node_id": "MDQ6VXNlcjE2MjczNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162737?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joshtriplett", "html_url": "https://github.com/joshtriplett", "followers_url": "https://api.github.com/users/joshtriplett/followers", "following_url": "https://api.github.com/users/joshtriplett/following{/other_user}", "gists_url": "https://api.github.com/users/joshtriplett/gists{/gist_id}", "starred_url": "https://api.github.com/users/joshtriplett/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joshtriplett/subscriptions", "organizations_url": "https://api.github.com/users/joshtriplett/orgs", "repos_url": "https://api.github.com/users/joshtriplett/repos", "events_url": "https://api.github.com/users/joshtriplett/events{/privacy}", "received_events_url": "https://api.github.com/users/joshtriplett/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/88140/reactions", "total_count": 8, "+1": 4, "-1": 0, "laugh": 0, "hooray": 3, "confused": 0, "heart": 0, "rocket": 1, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/88140/timeline", "performed_via_github_app": null, "state_reason": "completed"}