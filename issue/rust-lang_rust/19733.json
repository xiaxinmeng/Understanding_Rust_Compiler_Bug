{"url": "https://api.github.com/repos/rust-lang/rust/issues/19733", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/19733/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/19733/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/19733/events", "html_url": "https://github.com/rust-lang/rust/issues/19733", "id": 51703197, "node_id": "MDU6SXNzdWU1MTcwMzE5Nw==", "number": 19733, "title": "Mutable Pointer Aliasing Rules are Unclear for Unsafe Code", "user": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 60344715, "node_id": "MDU6TGFiZWw2MDM0NDcxNQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/P-medium", "name": "P-medium", "color": "eb6420", "default": false, "description": "Medium priority"}, {"id": 178802147, "node_id": "MDU6TGFiZWwxNzg4MDIxNDc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-needs-decision", "name": "I-needs-decision", "color": "e11d21", "default": false, "description": "Issues in need of decision."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 15, "created_at": "2014-12-11T15:56:41Z", "updated_at": "2016-08-25T16:30:01Z", "closed_at": "2016-08-25T16:30:01Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "As I rub against the boundaries of unsafe and undefined behaviour more and more It's becoming less \"obvious\" to me what is or isn't allowed. To demonstrate this I've whipped up a few examples of safe and unsafe code that does basically the same thing. Some of them are clearly defined or clearly undefined in my mental model, but I really have no idea at this point.\n\n`a` is clearly defined, as it uses no unsafe code. We re-loan a mutable reference to a different variable temporarily. At any given point there's clear ownership of the value.\n\n``` rust\nfn a() -> u32 {\n    // totally safe mutable aliasing\n    let a = &mut 1u32;\n    {\n        let b = &mut *a;\n        *b += 1;\n    }\n    *a += 1;\n    *a\n}\n```\n\n`b` does the exact same thing, but through a `*mut` instead of an `&mut`. Ownership is still \"clear\" to the compiler, but we mutate through the `*mut`, and then later through the `&mut`. It wouldn't be unreasonable to consider this undefined behaviour. We mutated something \"owned\" by an `&mut` through something other than that `&mut`, and then worked with the value through the `&mut`.\n\n``` rust\nfn b() -> u32 {\n    // same mutable aliasing, but with a raw ptr\n    let a = &mut 1u32;\n    unsafe {\n        let b = a as *mut _;\n        *b += 1;\n    }\n    *a += 1;\n    *a\n}\n```\n\n`c` does the exact same things as `b`, but explicitly constructs an &'static mut to mutate through unsafely. Here we have created two &mut's to the same value, which in my mental mode is clearly invoking undefined behaviour as I understand it. You cannot have two &mut's to the same value.\n\n``` rust\nfn c() -> u32 {\n    // same unsafe aliasing, but by explicitly making an &mut from a *mut\n    let a = &mut 1u32;\n    unsafe {\n        let b = &mut *((&mut *a) as *mut _);\n        *b += 1;\n    }\n    *a += 1;\n    *a\n}\n```\n\n`d` is basically the same as `a`, but we've added a box in the way. This adds a rawptr between the `&mut` and the actual data. Semantically the data is still \"owned\" by the `&mut`, but is the `*mut` in-between important or just an implementation detail? Regardless this is all safe, so this must be defined.\n\n``` rust\nfn d() -> u32 {\n    // totally safe mutable aliasing, but through a box \n    // (and therefore a raw ptr)\n    let mut a = box 1u32;\n    {\n        let b = &mut *a;\n        *b += 1;\n    }\n    *a += 1;\n    *a\n}\n```\n\n`e` is the same as `d`, but we've added a `*mut` again. This time we mutate the data inside the box while the box is owned. However the box _is_ a `*mut`, so really we've just mutated data behind a rawptr with another rawptr. Now it really matters if the box's representation is defined or not! Critically I believe that the defined-ness of this case effects whether DList is sound or not. It mixes boxes, `*mut`s, and `&mut`s pretty freely. What is or isn't allowed is important.\n\n``` rust\nfn e() -> u32 {\n    // same mutable aliasing, but with another raw ptr\n    let mut a = box 1u32;\n    unsafe {\n        let b = (&mut *a) as *mut _;\n        *b += 1;\n    }\n    *a += 1;\n    *a\n}\n```\n\nFinally `f` is a special case of unsafe mutable aliasing. Here we construct a `*mut` to a subfield of a composite structure. Then we capture the whole structure with an `&mut`. We mutate the subfield while the whole struct is owned, but then only use the ownership to mutate a _different_ subfield. At no point do we read the \"unsafely\" mutated field. Then we relinquish ownership to the \"parent\" owner which, presumably, must assume that all fields may have been mutated since it loaned the structure out. Is this defined behaviour? I honestly have no clue.\n\n``` rust\nfn f() -> u32 {\n    // mutable aliasing with a raw ptr, but on an unaccessed field\n    // until ownership is \"returned\" to the parent\n    let mut x = (1u32, 10u32);\n    let b = (&mut x.1) as *mut _;\n    {\n        let a = &mut x;\n        unsafe {\n            *b += 1;\n        }\n        a.0 += 1;\n    }\n    x.0 + x.1\n}\n```\n", "closed_by": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/19733/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/19733/timeline", "performed_via_github_app": null, "state_reason": "completed"}