{"url": "https://api.github.com/repos/rust-lang/rust/issues/10444", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/10444/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/10444/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/10444/events", "html_url": "https://github.com/rust-lang/rust/issues/10444", "id": 22542003, "node_id": "MDU6SXNzdWUyMjU0MjAwMw==", "number": 10444, "title": "Refactor arena API to permit reuse, play nicely with new", "user": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2013-11-12T19:00:40Z", "updated_at": "2015-01-20T20:10:26Z", "closed_at": "2015-01-20T20:10:26Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "For a variety of reasons, I think the arena API should be restructured. This is part of a larger plan to better enable smart pointers and I didn't intend to start by writing out about arenas, but my hand was forced by #10390 where I found myself elaborating on the arena plan in a comment, so let me go ahead and write this down.\n\nGoals of this plan:\n- Enable arena allocations to be [safely reused](http://dl.acm.org/citation.cfm?id=582421), lowering total memory use\n- Enable arenas to play nicely with a hypothetical `new(arena) ...` operator\n- Avoid unsafe transmutes that work around the type system\n\nIn a nutshell, I would like to change arena's signature from:\n\n```\nstruct Arena { ... }\nimpl Arena {\n    fn new() -> Arena { }\n    fn alloc<'a, T>(&'a self, x: T) -> &'a T { }\n}\n```\n\nto:\n\n```\nstruct MemoryPool { ... }\nstruct Arena<'pool> { pool: &'pool mut MemoryPool, .. }\nstruct ArenaAlloc<'pool, T> { ptr: &'pool mut T }\nimpl<'pool> Arena<'pool> {\n    fn init(pool: &'pool mut MemoryPool) { ... }\n    fn alloc<T>(&mut self) -> ArenaAlloc<'pool, T> {\n        // consult a free list, else alloc from pool\n    }\n    fn free<T>(&mut self, alloc: ArenaAlloc<'pool, T>) {\n        // use a free list\n    }\n}\n\n// ArenaAlloc is a smart pointer that acts like an owned pointer\nimpl<'pool, T> Deref<T> for ArenaAlloc<'pool, T> { ... }\nimpl<'pool, T> MutDeref<T> for ArenaAlloc<'pool, T> { ... }\nimpl Drop for ArenaAlloc<'pool, T> { fn drop(&mut self) { } }\n```\n\nThe memory pool would be the thing that holds the memory. When it is destroyed, the memory is freed. The arena is the allocator itself. distinction between the memory pool and the arena is kind of meaningless and unfortunate. The end goal is to have the arena type be parameterized by a lifetime (`'pool`) that corresponds to the lifetime of the returned values, rather than having the lifetime of the returned values be derived from the lifetime of the `self` pointer in the `alloc()` call. At the moment, this requires another object to tie the lifetime to, hence the \"memory pool\".\n\nThe motivations for this change are:\n1. It allows us to remove the unsafe code that makes an arena artificially mutable.\n2. It will play better with a future `new(arena) Expr` operator, because it allows us to fit in with a (higher-kinded) allocator trait that looks something like:\n   \n   trait Allocator<Ptr> { // Ptr :: \\* => *\n       fn alloc<T>(&mut self) -> Ptr<T>;\n   }\n\nThe implementation would look something like this (waving hands wildly with respect to syntax):\n\n```\nimpl<'pool> Allocator<ArenaAlloc<'pool, ..>> for Arena<'pool> {\n    fn alloc<T>(&mut self) -> ArenaAlloc<'pool, T> { ... }\n}\n```\n\n`ArenaAlloc` would be smart pointer that acts like an owned pointer.\n\nThe downside of this is that to create an arena, at least today -- and pending the resolution of #3511 -- you would have to do two steps:\n\n```\nlet mut pool = MemoryPool::init();\nlet mut arena = Arena::init(&mut pool);\n// now I can use arena\n```\n\nIf we resolve #3511 in favor of inference, one could write:\n\n```\nlet mut arena = Arena::init(&mut MemoryPool::init());\n```\n\nbut it is still necessary for the `MemoryPool` to be created by the caller, so that the caller can free it.\n\nTo solve this without a distinct object, we'd need a different kind of lifetime: more or less the `'self` people sometime ask for, a lifetime that is associated with a struct and means \"as long as it lives\". This is a separate feature request and I'll open an issue about it, but I'm a bit handwavy on how it will work.\n\ncc @pnkfelix (per our discussion about reaps)\n", "closed_by": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/10444/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/10444/timeline", "performed_via_github_app": null, "state_reason": "completed"}