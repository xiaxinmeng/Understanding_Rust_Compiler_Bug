{"url": "https://api.github.com/repos/rust-lang/rust/issues/19864", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/19864/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/19864/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/19864/events", "html_url": "https://github.com/rust-lang/rust/issues/19864", "id": 51948673, "node_id": "MDU6SXNzdWU1MTk0ODY3Mw==", "number": 19864, "title": "Poor performance returning enums larged than a word. Possibly poor code generation?", "user": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 15, "created_at": "2014-12-15T04:43:59Z", "updated_at": "2023-05-24T06:50:10Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I've discovered an issue with `IoError`, and really returning any enums that are larger than 1 word, are running an order of magnitude slower than returning an error enum that's 1 word size. Here's my test case:\n\n``` rust\nextern crate test;\n\nuse std::mem;\nuse std::vec;\nuse std::io;\n\nconst BUFFER_SIZE: uint = 128;\n\n//////////////////////////////////////////////////////////////////////////////\n\ntrait Error {\n    fn is_eof(&self) -> bool;\n}\n\nimpl Error for io::IoError {\n    fn is_eof(&self) -> bool {\n        self.kind == io::EndOfFile\n    }\n}\n\n#[deriving(Show, PartialEq, Eq)]\nenum MyError {\n    EndOfFile,\n    Error,\n    _Error1,\n}\n\nimpl Error for MyError {\n    fn is_eof(&self) -> bool {\n        *self == MyError::EndOfFile\n    }\n}\n\n#[deriving(Show, PartialEq, Eq)]\nenum MyError2 {\n    EndOfFile,\n    Error,\n    _Error1(uint),\n}\n\nimpl Error for MyError2 {\n    fn is_eof(&self) -> bool {\n        *self == MyError2::EndOfFile\n    }\n}\n\nimpl Error for () {\n    fn is_eof(&self) -> bool {\n        true\n    }\n}\n\nimpl Error for Box<MyError> {\n    fn is_eof(&self) -> bool {\n        **self == MyError::EndOfFile\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nfn generate_bytes() -> Vec<u8> {\n    let mut bytes = Vec::new();\n\n    for i in range(0i, 1024) {\n        bytes.push(i as u8);\n    }\n\n    bytes\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nstruct Foo11<'a, E> {\n    iter: vec::MoveItems<u8>,\n    f: |&mut Vec<u8>|: 'a -> Result<(), E>,\n}\n\nimpl<'a, E: Error> Foo11<'a, E> {\n    fn new<'a>(f: |&mut Vec<u8>|: 'a -> Result<(), E>) -> Foo11<'a, E> {\n        let buf = Vec::with_capacity(BUFFER_SIZE);\n\n        Foo11 {\n            iter: buf.into_iter(),\n            f: f,\n        }\n    }\n\n    fn fill_buf(&mut self) -> Result<bool, E> {\n        let mut iter = Vec::new().into_iter();\n        mem::swap(&mut iter, &mut self.iter);\n        let mut buf = iter.into_inner();\n        buf.clear();\n\n        try!((self.f)(&mut buf));\n\n        if buf.is_empty() {\n            Ok(false)\n        } else {\n            self.iter = buf.into_iter();\n            Ok(true)\n        }\n    }\n}\n\nimpl<'a, E: Error> Iterator<Result<u8, E>> for Foo11<'a, E> {\n    fn next(&mut self) -> Option<Result<u8, E>> {\n        loop {\n            match self.iter.next() {\n                Some(value) => { return Some(Ok(value)); }\n                None => {\n                    match self.fill_buf() {\n                        Ok(false) => { return None; }\n                        Ok(true) => { }\n                        Err(err) => { return Some(Err(err)); }\n                    }\n                }\n            }\n        }\n    }\n}\n\n#[bench]\nfn bench_foo11_ioerror(b: &mut test::Bencher) {\n    let bytes = generate_bytes();\n    b.bytes = bytes.len() as u64;\n\n    b.iter(|| {\n        let mut rdr = bytes.as_slice();\n        let iter = Foo11::new(|buf| -> Result<(), io::IoError> {\n            match rdr.push(BUFFER_SIZE, buf) {\n                Ok(_) => Ok(()),\n                Err(io::IoError { kind: io::EndOfFile, .. }) => Ok(()),\n                Err(err) => Err(err),\n            }\n        });\n\n        for (idx, item) in iter.enumerate() {\n            assert_eq!(idx as u8, item.unwrap());\n        }\n    })\n}\n\n#[bench]\nfn bench_foo11_enum_one_word(b: &mut test::Bencher) {\n    let bytes = generate_bytes();\n    b.bytes = bytes.len() as u64;\n\n    b.iter(|| {\n        let mut rdr = bytes.as_slice();\n        let iter = Foo11::new(|buf| -> Result<(), MyError> {\n            match rdr.push(BUFFER_SIZE, buf) {\n                Ok(_) => Ok(()),\n                Err(io::IoError { kind: io::EndOfFile, .. }) => Ok(()),\n                Err(_) => Err(MyError::Error),\n            }\n        });\n\n        for (idx, item) in iter.enumerate() {\n            assert_eq!(idx as u8, item.unwrap());\n        }\n    })\n}\n\n#[bench]\nfn bench_foo11_null(b: &mut test::Bencher) {\n    let bytes = generate_bytes();\n    b.bytes = bytes.len() as u64;\n\n    b.iter(|| {\n        let mut rdr = bytes.as_slice();\n        let iter = Foo11::new(|buf| -> Result<(), ()> {\n            match rdr.push(BUFFER_SIZE, buf) {\n                Ok(_) => Ok(()),\n                Err(io::IoError { kind: io::EndOfFile, .. }) => Ok(()),\n                Err(_) => Ok(()), //{ panic!() }\n            }\n        });\n\n        for (idx, item) in iter.enumerate() {\n            assert_eq!(idx as u8, item.unwrap());\n        }\n    })\n}\n\n#[bench]\nfn bench_foo11_enum_2_words(b: &mut test::Bencher) {\n    let bytes = generate_bytes();\n    b.bytes = bytes.len() as u64;\n\n    b.iter(|| {\n        let mut rdr = bytes.as_slice();\n        let iter = Foo11::new(|buf| -> Result<(), MyError2> {\n            match rdr.push(BUFFER_SIZE, buf) {\n                Ok(_) => Ok(()),\n                Err(io::IoError { kind: io::EndOfFile, .. }) => Ok(()),\n                Err(_) => Err(MyError2::Error),\n            }\n        });\n\n        for (idx, item) in iter.enumerate() {\n            assert_eq!(idx as u8, item.unwrap());\n        }\n    })\n}\n\n#[bench]\nfn bench_foo11_boxed(b: &mut test::Bencher) {\n    let bytes = generate_bytes();\n    b.bytes = bytes.len() as u64;\n\n    b.iter(|| {\n        let mut rdr = bytes.as_slice();\n        let iter = Foo11::new(|buf| -> Result<(), Box<MyError>> {\n            match rdr.push(BUFFER_SIZE, buf) {\n                Ok(_) => Ok(()),\n                Err(io::IoError { kind: io::EndOfFile, .. }) => Ok(()),\n                Err(_) => Err(box MyError::Error),\n            }\n        });\n\n        for (idx, item) in iter.enumerate() {\n            assert_eq!(idx as u8, item.unwrap());\n        }\n    })\n}\n```\n\nHere are the results:\n\n```\ntest bench_foo11_boxed             ... bench:     13754 ns/iter (+/- 4222) = 74 MB/s\ntest bench_foo11_enum_2_words      ... bench:     15027 ns/iter (+/- 4318) = 68 MB/s\ntest bench_foo11_enum_one_word     ... bench:      1550 ns/iter (+/- 417) = 660 MB/s\ntest bench_foo11_ioerror           ... bench:     25003 ns/iter (+/- 8007) = 40 MB/s\ntest bench_foo11_null              ... bench:       817 ns/iter (+/- 206) = 1253 MB/s\n```\n\nOn a related note, @alexcrichton just found a similar case with:\n\n``` rust\nextern crate test;\n\nuse std::iter::repeat;\n\nconst N: uint = 100000;\n\n#[deriving(Clone)]\nstruct Foo;\n#[deriving(Clone)]\nstruct Bar {\n    name: &'static str,\n    desc: Option<String>,\n    other: Option<String>,\n}\n\n#[bench]\nfn b1(b: &mut test::Bencher) {\n    b.iter(|| {\n        let r: Result<u8, Foo> = Ok(1u8);\n        repeat(r).take(N).map(|x| test::black_box(x)).count()\n    });\n}\n\n#[bench]\nfn b2(b: &mut test::Bencher) {\n    b.iter(|| {\n        let r: Result<u8, Bar> = Ok(1u8);\n        repeat(r).take(N).map(|x| test::black_box(x)).count()\n    });\n}\n```\n\nThe assembly for `b1` is about 3 instructions, but the assembly for `b2` has a ton of `mov` instructions.\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/19864/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/19864/timeline", "performed_via_github_app": null, "state_reason": null}