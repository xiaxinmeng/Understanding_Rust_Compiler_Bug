{"url": "https://api.github.com/repos/rust-lang/rust/issues/17151", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/17151/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/17151/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/17151/events", "html_url": "https://github.com/rust-lang/rust/issues/17151", "id": 42454707, "node_id": "MDU6SXNzdWU0MjQ1NDcwNw==", "number": 17151, "title": "Conflicting method names in the same trait hierachy can only ever be called with UFCS syntax", "user": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37544, "node_id": "MDU6TGFiZWwzNzU0NA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-typesystem", "name": "A-typesystem", "color": "f7e101", "default": false, "description": "Area: The type system"}, {"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 630652267, "node_id": "MDU6TGFiZWw2MzA2NTIyNjc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-feature-request", "name": "C-feature-request", "color": "f5f1fd", "default": false, "description": "Category: A feature request, i.e: not implemented / a PR."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2014-09-10T20:09:54Z", "updated_at": "2019-03-02T18:11:13Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "During the writing of this issue I reached the conclusion that the current semantic is probably the best solution to this problem already, but I'm opening this issue anyway to encourage discussion or at least getting confirmation from official site that this is the intended behavior.\n\n---\n\nRight now, you can use the same method name in different traits, even if they exist in a inheritance relation, eg this compiles:\n\n``` rust\nmod foo {\n    pub trait Foo {\n        fn foo(&self) {}\n    }\n\n    pub trait Bar: Foo {\n        fn foo(&self) {}\n    }\n\n    impl Foo for uint{}\n    impl Bar for uint{}\n    impl Foo for int{}\n    impl Bar for int{}\n}\n```\n\nThis is currently possible to prevent a _fragile base class_ problem: A library maintainer providing a supertrait should be able to add an new method without breaking downstream code.\n\nHowever, even if you don't explicitly import `Foo` or `Bar`, any place where you try to use the `foo()` method of `Bar` you get a \"conflicting methods in scope\" error, because super traits are automatically brought in scope for method resolution:\n\nIn generics:\n\n``` rust\nfn gen<T: foo::Bar>(t: T) {\n    t.foo();\n}\n```\n\n```\n<anon>:18:5: 18:12 error: multiple applicable methods in scope [E0034]\n<anon>:18     t.foo();\n              ^~~~~~~\n<anon>:18:5: 18:12 note: candidate #1 derives from the bound `foo::Bar`\n<anon>:18     t.foo();\n              ^~~~~~~\n<anon>:18:5: 18:12 note: candidate #2 derives from the bound `foo::Foo`\n<anon>:18     t.foo();\n              ^~~~~~~\n```\n\nIn trait objects:\n\n``` rust\nfn main() {\n    let y = vec![box 0u as Box<foo::Bar>, box 0i as Box<foo::Bar>];\n    for e in y.iter() {\n        e.foo();\n    }\n}\n```\n\n```\n<anon>:24:9: 24:16 error: multiple applicable methods in scope [E0034]\n<anon>:24         e.foo();\n                  ^~~~~~~\n<anon>:24:9: 24:16 note: candidate #1 derives from the type of the receiver, which is the trait `foo::Bar`\n<anon>:24         e.foo();\n                  ^~~~~~~\n<anon>:24:9: 24:16 note: candidate #2 derives from the type of the receiver, which is the trait `foo::Foo`\n<anon>:24         e.foo();\n                  ^~~~~~~\n```\n\nWhich means in practice you'd run into this problem anyway.\n\nCalling associated functions works though, so you could use UFCS to differentiate the methods:\n\n```\nfn gen<T: foo::Bar>(t: T) {\n    foo::Foo::foo(&t);\n    foo::Bar::foo(&t);\n}\n```\n\nHowever, a conflict like this still forces a code change decision on the provider of the trait and all downstream users:\n- Changing all code calling the method to the UFCS syntax. (forced for downstream users because else they get conflicting methods errors)\n- Renaming the method and all its uses in the sub trait (Can lead to downstream users accidentally calling the new super trait method instead)\n\nBoth options are approximately equally big changes for downstream users, and none of them allows conflicting method names to be used with the original dot syntax, so the question is if this is working as intended, or whether it might be improved upon.\n\nAt the very least, it might be a good idea to implement a warn-per-default lint for the conflicting method name in the sub trait definition.\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/17151/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/17151/timeline", "performed_via_github_app": null, "state_reason": null}