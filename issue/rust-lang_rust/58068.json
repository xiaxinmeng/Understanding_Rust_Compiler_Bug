{"url": "https://api.github.com/repos/rust-lang/rust/issues/58068", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/58068/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/58068/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/58068/events", "html_url": "https://github.com/rust-lang/rust/issues/58068", "id": 405938180, "node_id": "MDU6SXNzdWU0MDU5MzgxODA=", "number": 58068, "title": "Recursive Drop causes stack overflow even for object trees", "user": {"login": "slaymaker1907", "id": 12125553, "node_id": "MDQ6VXNlcjEyMTI1NTUz", "avatar_url": "https://avatars.githubusercontent.com/u/12125553?v=4", "gravatar_id": "", "url": "https://api.github.com/users/slaymaker1907", "html_url": "https://github.com/slaymaker1907", "followers_url": "https://api.github.com/users/slaymaker1907/followers", "following_url": "https://api.github.com/users/slaymaker1907/following{/other_user}", "gists_url": "https://api.github.com/users/slaymaker1907/gists{/gist_id}", "starred_url": "https://api.github.com/users/slaymaker1907/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/slaymaker1907/subscriptions", "organizations_url": "https://api.github.com/users/slaymaker1907/orgs", "repos_url": "https://api.github.com/users/slaymaker1907/repos", "events_url": "https://api.github.com/users/slaymaker1907/events{/privacy}", "received_events_url": "https://api.github.com/users/slaymaker1907/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 43009118, "node_id": "MDU6TGFiZWw0MzAwOTExOA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-destructors", "name": "A-destructors", "color": "f7e101", "default": false, "description": "Area: destructors (Drop, ..)"}, {"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 431251592, "node_id": "MDU6TGFiZWw0MzEyNTE1OTI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-docs", "name": "A-docs", "color": "f7e101", "default": false, "description": "Area: documentation for any part of the project, including the compiler, standard library, and tools"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 9, "created_at": "2019-02-02T02:27:34Z", "updated_at": "2022-11-03T20:06:54Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "The issue seems to be that the way Drop is currently compiled is fatally flawed for recursive data structures.\r\n\r\nThe following code doesn't seem to have an fundamental issues that would cause it to fail, but it ends up causing a stack overflow, even for the version which uses Box instead of CustomBox.\r\n\r\n```rust\r\nuse std::alloc::{alloc, dealloc, Layout, handle_alloc_error};\r\nuse std::ptr::{NonNull, drop_in_place, write};\r\nuse std::mem::drop;\r\nuse std::borrow::Borrow;\r\n\r\nstruct CustomBox<T> {\r\n    wrapped: NonNull<T>\r\n}\r\n\r\nimpl<T> CustomBox<T> {\r\n    fn new(data: T) -> CustomBox<T> {\r\n        let wrapped = unsafe {\r\n            let layout = Layout::new::<T>();\r\n            let memory = alloc(layout);\r\n            if memory.is_null() {\r\n                handle_alloc_error(layout);\r\n            }\r\n            let result = NonNull::new_unchecked(memory as *mut T);\r\n            write(result.as_ptr(), data);\r\n            result\r\n        };\r\n        CustomBox {\r\n            wrapped\r\n        }\r\n    }\r\n\r\n    fn borrow(&self) -> &T {\r\n        unsafe {\r\n            self.wrapped.as_ref()\r\n        }\r\n    }\r\n}\r\n\r\n\r\nimpl<T> Drop for CustomBox<T> {\r\n    fn drop(&mut self) {\r\n        let layout = Layout::new::<T>();\r\n        unsafe {\r\n            drop_in_place(self.wrapped.as_ptr());\r\n            dealloc(self.wrapped.as_ptr() as *mut u8, layout);\r\n        }\r\n    }\r\n}\r\n\r\nmacro_rules! create_linked_list {\r\n    ($name:ident, $box_type:ident) => {\r\n        struct $name {\r\n            data: u32,\r\n            next: Option<$box_type<$name>>\r\n        }\r\n\r\n        impl $name {\r\n            fn new(size: usize) -> Option<$box_type<$name>> {\r\n                let mut result: Option<$box_type<$name>> = None;\r\n                for i in 0..size {\r\n                    let new_node = $box_type::new($name {\r\n                        data: i as u32,\r\n                        next: result.take()\r\n                    });\r\n\r\n                    result = Some(new_node);\r\n                }\r\n\r\n                result\r\n            }\r\n\r\n            fn sum(mut list: &Option<$box_type<$name>>) -> u64 {\r\n                let mut result = 0;\r\n                while let Some(node) = list.as_ref() {\r\n                    let node_ref: &$name = node.borrow();\r\n                    result += node_ref.data as u64;\r\n                    list = &node_ref.next;\r\n                }\r\n                result\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\ncreate_linked_list!(LinkedList, CustomBox);\r\ncreate_linked_list!(BoxLinkedList, Box);\r\n\r\n\r\nfn main() {\r\n    let list = BoxLinkedList::new(10_000_000);\r\n    println!(\"{}\", BoxLinkedList::sum(&list));\r\n    println!(\"Trying to drop normal Box\");\r\n    drop(list);\r\n    println!(\"Dropped successfully.\");\r\n\r\n    let list = LinkedList::new(10_000_000);\r\n    println!(\"{}\", LinkedList::sum(&list));\r\n    println!(\"Trying to drop CustomBox\");\r\n    drop(list);\r\n    println!(\"Dropped successfully.\");\r\n}\r\n```\r\n\r\nI expected to see this happen: It should have run this code sample and printed each println.\r\n\r\nInstead, this happened: It crashes when drop(list) is called the first time.\r\n\r\nCurrently, the LinkedList implementation in `std::collections` seems to explicitly deal with deallocating nodes without recursion so it is not affected.\r\n\r\nI'm not sure if this was an intentional design decision or not, but if it it was intentional, it should be better documented, there isn't much indication in the [official docs](https://doc.rust-lang.org/std/ops/trait.Drop.html) that dropping is actually done as non-tail call recursive functions.\r\n\r\nOne way to potentially fix this could be to make a `lazy_drop_in_place ` macro which has the same signature as `drop_in_place`, except that instead of immediately dropping that item, it instead saves these pointers at the top of the stack (which is why this should be a macro instead of a function) in a static sized buffer.\r\n\r\nThis API would not allow variable size deallocations, but it would solve the problem since then then the compiler could avoid recursion for things like linked lists.\r\n\r\n## Meta\r\n\r\n`rustc --version --verbose`:\r\n\r\n```\r\nrustc 1.33.0-nightly (e2f221c75 2019-01-15)\r\nbinary: rustc\r\ncommit-hash: e2f221c75932de7a29845c8d6f1f73536ad00c41\r\ncommit-date: 2019-01-15\r\nhost: x86_64-pc-windows-msvc\r\nrelease: 1.33.0-nightly\r\nLLVM version: 8.0\r\n```\r\n\r\nBacktrace:\r\n\r\n```\r\n   Compiling large-stack-drop v0.1.0 (C:\\codedump\\alloc-serialize\\large-stack-drop)\r\n    Finished release [optimized] target(s) in 0.43s\r\n     Running `target\\release\\large-stack-drop.exe`\r\n49999995000000\r\nTrying to drop normal Box\r\n\r\nthread 'main' has overflowed its stack\r\nerror: process didn't exit successfully: `target\\release\\large-stack-drop.exe` (exit code: 0xc00000fd, STATUS_STACK_OVERFLOW)\r\n```", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/58068/reactions", "total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 1}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/58068/timeline", "performed_via_github_app": null, "state_reason": null}