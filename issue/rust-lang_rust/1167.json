{"url": "https://api.github.com/repos/rust-lang/rust/issues/1167", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/1167/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/1167/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/1167/events", "html_url": "https://github.com/rust-lang/rust/issues/1167", "id": 2196639, "node_id": "MDU6SXNzdWUyMTk2NjM5", "number": 1167, "title": "Native pointer vectors", "user": {"login": "jwise", "id": 87427, "node_id": "MDQ6VXNlcjg3NDI3", "avatar_url": "https://avatars.githubusercontent.com/u/87427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwise", "html_url": "https://github.com/jwise", "followers_url": "https://api.github.com/users/jwise/followers", "following_url": "https://api.github.com/users/jwise/following{/other_user}", "gists_url": "https://api.github.com/users/jwise/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwise/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwise/subscriptions", "organizations_url": "https://api.github.com/users/jwise/orgs", "repos_url": "https://api.github.com/users/jwise/repos", "events_url": "https://api.github.com/users/jwise/events{/privacy}", "received_events_url": "https://api.github.com/users/jwise/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 45472092, "node_id": "MDU6TGFiZWw0NTQ3MjA5Mg==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-ffi", "name": "A-ffi", "color": "f7e101", "default": false, "description": "Area: Foreign Function Interface (FFI)"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 16, "created_at": "2011-11-10T10:40:32Z", "updated_at": "2011-11-30T00:01:50Z", "closed_at": "2011-11-30T00:01:50Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "# Native pointer vectors\n\nThis bug is a _request for comment_.  I am but a novice Rust developer, but I suspect that this would be a strong addition to the language.\n\nThe exact mechanics were fleshed out further in this bug; read down for more on what actually was implemented.\n## Motivation\n\nWhile working on bindings for FFTW (the Fastest Fourier Transform in the West), I ran into the hairy issue that it doesn't seem possible to have Rust hold vector pointers to the outside world.  What do I mean by this -- and why do we care?  Well, I'll provide (a distilled version of) the FFTW APIs in question, by way of example:\n\n``` c\ndouble *fftw_malloc(size_t sz);\nfftw_plan_t *fftw_plan_fft(size_t n, double *in, double *out, int flags); /* morally */\nvoid fftw_execute(fftw_plan_t *plan);\n```\n\nThe general course of action when using FFTW is to use `fftw_malloc` to get a chunk of space to store your inputs and outputs, then create a \"plan\" with `fftw_plan` (a potentially expensive operation, but if you intend to run many FFTs, ultimately time-saving), and then finally execute the plan with `fftw_execute` when you've populated your buffers.  You can `fftw_execute` the same plan many times (and, in fact, if you can, you should!) after refilling the buffers and taking data out.\n\nIn FFTW-land, `fftw_malloc` is not strictly necessary as the only way to get memory, but it's a Damn Good Idea -- and as I'll discuss in a moment, not using it doesn't save us.  `fftw_malloc` goes out of its way to obtain memory that has \"nice\" properties; for instance, it tries hard to align things not just to `double` boundaries, but also to cache lines, depending on how much memory you ask for.  If it knows anything else interesting about your system, it takes that into account.  So, it's not fatal to not use it, if that's the only thing you can do ... but it sure does hurt.\n\nCurrently, in Rust, there is no way to import a pointer from the outside world and use it mutably, nor is there a way to tell Rust that this pointer may be written to by an outside API.  The closest thing that Rust has is `vec::unsafe::from_buf`, which in turn calls `rustrt::vec_from_buf_shared`, but the first thing that `vec_from_buf_shared` does is _allocate a new space and copy the memory away_!  This makes it unsuitable for referencing both the `in` and the `out` pointers; changing a pointer that has been imported through this mechanism will cause changes not to get written back to the outside world, and executing a transform to (and overwriting the contents of) a pointer that has been imported through this mechanism will cause Rust to not see the changes that happen after the copy.\n\nIn this case, we have another option, though.  We could create a vector inside Rust, and use `vec::unsafe::to_ptr` to create a pointer to it.  This will work, but it is dangerously broken (violates safety) in three ways.  In the first, Rust is not in control of the lifecycle of the external reference; Rust cannot know when the external reference no longer exists, and may prematurely garbage collect the vector.  This can happen, for instance, in the case in which a reference to the `out` pointer is still live, and a reference to the plan is still live, but the reference to the `in` pointer is dead; calling `fftw_execute` on this `plan` will result in doing accesses to the dead `in` vector, which may have been garbage collected.\n\nIn the second, Rust may reallocate memory out from under the external application.  The vector can be appended to, which may cause a reallocation to occur.  The external application's pointer will not be updated, and when it goes to access that pointer, that memory will be dead.  In the case of a \"correct\" usage, this will not occur (i.e., the programmer can be instructed not to do that), but this violates safety; at the very least, `+=` now becomes an `unsafe` operation.\n\nIn the third, perhaps most compellingly, this locks Rust into a world in which it is not permissible to have a copying garbage collector.  Right now, Rust does ref-counting and garbage collection with free()... but this need not always be the case!  Another implementation of Rust could very conceivably experiment with garbage collection schemes for better performance.  If the behavior of pointers were already specified, it would be one story, but currently that behavior is not -- and I argue, for the better.\n\nIn short, the language's existing capabilities for this are not sufficient to operate with at least one API.\n## Use cases\n\nThe FFTW API is not the only system in which the current capabilities for referring to native memory are insufficient.  Consider also:\n- A framebuffer interface, in which an external resource has `mmap()`ed some memory.  Accesses must go to exactly those addresses; none else will do.\n- A command queue interface, in which a set of commands are provided for an external device (say, a graphics card) to DMA to and from chunks of memory.  (This is how modern graphics cards operate.)  Accesses must go to some prescribed address, usually managed through a remote resource manager (DRI, et al); no other address will do.\n\nThese are both examples of requiring a specific address... recall, however, that there are surely many applications that require some mutable chunk of memory, any mutable chunk at all!  Consider, for instance, the `ioctl()` interface on Linux, which has a similar \"combination input/output buffer\".\n\nThe FFTW API is one of many cases that require mutable memory accessible to the native system.\n## Proposed solution\n\nI propose the addition of a vector qualifier, `[native T]`.  The type `[native T]` does not unify with `[T]`; it is mainly distinct from the normal vector, but that dereferencing indexes in it and iterating over it both work.\n\nThe type `[native T]` has one introduction form:\n\n``` rust\nunsafe fn std::vec::unsafe::native<T>(ptr: *T, elts: uint) -> [native T];\n```\n\nThe following elimination forms of vectors function for native vectors:\n- `v[a]` as an expression (with size checking)\n- `v[a]` as an lvalue (with size checking)\n- `for t: T in v` as a loop construct\n\nNotably, the following form does not function:\n- `v += vp` as an append\n\nWhen a native vector goes out of scope, the native memory pointed to is not modified or otherwise operated upon.\n\nThese are the basic rules for a native vector.\n## Implementation\n\nA native vector has the following internal representation:\n\n`type native_repr<T> = { len: uint, data: *T };`\n\nIt is distinct in the type system because it does not share a representation with a Rust vector.  This choice was made to avoid the performance cost of having to check at run time whether any given vector is a Rust vector or a native vector before accessing it.\n\nTranslation is presumably very similar to Rust vectors.\n\nIt could be the case that no `rustrt` support is needed for this, since the `native_repr` type can be constructed purely in Rust, and then can be `reinterpret_cast`ed into a native vector.\n## Extensions\n\nThe above describes a basic semantics for a native vector.  It provides a semantics sufficient to behave safely, but missing are two potentially useful extensions.  These are optional, and certainly not required for a first pass implementation, but would make the native vector substantially more usable.\n### `[native? T]` unification\n\nThere is currently a substantial vector library built up to operate on Rust vectors.  Just because some operations do not apply, it does not make sense to have to duplicate the ones that do.  For that, I propose the `[native? T]` qualifier, similar to `[mutable? T]`.  Presumably a separate code path would have to be emitted at translate time.  I do not know enough about the inner workings of `mutable?` to comment on how similar this might be, and how possible this might be given the existing Rust codebase.\n### Built in destructors\n\nIt can be potentially useful to have Rust take over lifecycle management of memory, if the FFI binding builder is careful.  Classically, the mechanism by which one might do this is as such:\n\n``` rust\ntype mem = {\n  vec : [native f64],\n  dtor : @mem_res\n};\n\nfn malloc(n : uint) -> mem {\n  let mem = fftw_native::fftw_malloc(n * 8u);\n  ret { vec: unsafe { vec::unsafe::native(mem as *f64, n) }, dtor: @mem_res(mem) };\n}\n\nresource mem_res(mem: fftw_native::mem) {\n  fftw_native::fftw_free(mem);\n}\n```\n\nThis has the unfortunate downside that a user of the API can extract the `vec` from the `type mem`, and let the `type mem` itself go out of scope (or otherwise become dead).  When the `type mem` itself becomes dead, the resource can immediately be freed, even though the native vector may still be live; this can violate safety.\n\nA native vector, then, may wish to have an introduction form that includes a resource pointer associated with it, for built-in cleanup.\n## Conclusion\n\nIn this document, I describe a new form of vector called the native vector.  The native vector allows Rust to safely interact with external memory.  The introduction form is unsafe, so although it would permit inter-task shared memory communication, it does not do so in a particularly novel fashion.  This proposed solution addresses all of the mentioned use cases in what seems (to the untrained eye!) like an elegant, Rust-like fashion.\n\nThoughts?\n", "closed_by": {"login": "jwise", "id": 87427, "node_id": "MDQ6VXNlcjg3NDI3", "avatar_url": "https://avatars.githubusercontent.com/u/87427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwise", "html_url": "https://github.com/jwise", "followers_url": "https://api.github.com/users/jwise/followers", "following_url": "https://api.github.com/users/jwise/following{/other_user}", "gists_url": "https://api.github.com/users/jwise/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwise/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwise/subscriptions", "organizations_url": "https://api.github.com/users/jwise/orgs", "repos_url": "https://api.github.com/users/jwise/repos", "events_url": "https://api.github.com/users/jwise/events{/privacy}", "received_events_url": "https://api.github.com/users/jwise/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/1167/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/1167/timeline", "performed_via_github_app": null, "state_reason": "completed"}