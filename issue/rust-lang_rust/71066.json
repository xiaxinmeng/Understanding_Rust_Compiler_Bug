{"url": "https://api.github.com/repos/rust-lang/rust/issues/71066", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/71066/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/71066/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/71066/events", "html_url": "https://github.com/rust-lang/rust/issues/71066", "id": 598526536, "node_id": "MDU6SXNzdWU1OTg1MjY1MzY=", "number": 71066, "title": "Filling short slices is slow even if they are provably short", "user": {"login": "LingMan", "id": 18645382, "node_id": "MDQ6VXNlcjE4NjQ1Mzgy", "avatar_url": "https://avatars.githubusercontent.com/u/18645382?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LingMan", "html_url": "https://github.com/LingMan", "followers_url": "https://api.github.com/users/LingMan/followers", "following_url": "https://api.github.com/users/LingMan/following{/other_user}", "gists_url": "https://api.github.com/users/LingMan/gists{/gist_id}", "starred_url": "https://api.github.com/users/LingMan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LingMan/subscriptions", "organizations_url": "https://api.github.com/users/LingMan/orgs", "repos_url": "https://api.github.com/users/LingMan/repos", "events_url": "https://api.github.com/users/LingMan/events{/privacy}", "received_events_url": "https://api.github.com/users/LingMan/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 889209675, "node_id": "MDU6TGFiZWw4ODkyMDk2NzU=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-iterators", "name": "A-iterators", "color": "f7e101", "default": false, "description": "Area: Iterators"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2020-04-12T16:54:56Z", "updated_at": "2020-04-12T17:04:57Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Take this method as baseline ([playground](https://play.rust-lang.org/?version=stable&mode=release&edition=2018&gist=6eed91dbb458e8eef083d0d24a958182)):\r\n```rust\r\npub fn add_padding(input_len: usize, output: &mut [u8]) -> usize {\r\n    let rem = input_len % 3;\r\n    let padding_length = (3 - rem) % 3;\r\n    for i in 0..padding_length {\r\n        output[i] = b'=';\r\n    }\r\n\r\n    padding_length\r\n}\r\n```\r\npadding_length can take on values in the rage [0, 2], so we have to write either zero, one, or two bytes into our slice.\r\nBenchmarking all three cases gives us these timings:\r\n```\r\n0: time:   [2.8673 ns 2.8692 ns 2.8714 ns]\r\n1: time:   [3.2384 ns 3.2411 ns 3.2443 ns]\r\n2: time:   [3.7454 ns 3.7478 ns 3.7507 ns]\r\n```\r\nChasing more idiomatic code we switch to iterators for the loop ([playground](https://play.rust-lang.org/?version=stable&mode=release&edition=2018&gist=d39fbb7d5c5bd2914ae14e538e589460)):\r\n```rust\r\npub fn add_padding(input_len: usize, output: &mut [u8]) -> usize {\r\n    let rem = input_len % 3;\r\n    let padding_length = (3 - rem) % 3;\r\n    for byte in output[..padding_length].iter_mut() {\r\n        *byte = b'=';\r\n    }\r\n\r\n    padding_length\r\n}\r\n```\r\nGiven that this loop barely does any iterations and has thus not much performance potential in avoiding bounds checks, we expect about the same runtime.\r\n```\r\nabsolute:\r\n0: time:   [3.2053 ns 3.2074 ns 3.2105 ns]\r\n1: time:   [5.4453 ns 5.4475 ns 5.4501 ns]\r\n2: time:   [6.0211 ns 6.0254 ns 6.0302 ns]\r\n\r\nrelative compared to baseline:\r\n0: time:   [+11.561% +11.799% +12.030%]\r\n1: time:   [+67.946% +68.287% +68.647%]\r\n2: time:   [+60.241% +60.600% +60.932%]\r\n```\r\nOof, up to 68% slower...\r\n\r\n**Let's see what's happening**\r\n\r\nThe baseline version copies one byte at a time, which isn't that bad when you copy at most two bytes:\r\n```assembly\r\nplayground::add_padding:\r\n\tpushq\t%rax\r\n\tmovq\t%rdx, %rcx\r\n\tmovabsq\t$-6148914691236517205, %r8\r\n\tmovq\t%rdi, %rax\r\n\tmulq\t%r8\r\n\tshrq\t%rdx\r\n\tleaq\t(%rdx,%rdx,2), %rax\r\n\tsubq\t%rax, %rdi\r\n\txorq\t$3, %rdi\r\n\tmovq\t%rdi, %rax\r\n\tmulq\t%r8\r\n\tshrq\t%rdx\r\n\tleaq\t(%rdx,%rdx,2), %rax\r\n\tsubq\t%rax, %rdi\r\n\tje\t.LBB0_4\r\n\txorl\t%eax, %eax\r\n\r\n.LBB0_2:\r\n\tcmpq\t%rax, %rcx\r\n\tje\t.LBB0_5\r\n\tmovb\t$61, (%rsi,%rax)\r\n\taddq\t$1, %rax\r\n\tcmpq\t%rdi, %rax\r\n\tjb\t.LBB0_2\r\n\r\n.LBB0_4:\r\n\tmovq\t%rdi, %rax\r\n\tpopq\t%rcx\r\n\tretq\r\n\r\n[snip panic code]\r\n```\r\nIn comparison the iterator version does a full memset:\r\n```assembly\r\nplayground::add_padding:\r\n\tpushq\t%rbx\r\n\tmovq\t%rdx, %rcx\r\n\tmovq\t%rdi, %rbx\r\n\tmovabsq\t$-6148914691236517205, %rdi\r\n\tmovq\t%rbx, %rax\r\n\tmulq\t%rdi\r\n\tshrq\t%rdx\r\n\tleaq\t(%rdx,%rdx,2), %rax\r\n\tsubq\t%rax, %rbx\r\n\txorq\t$3, %rbx\r\n\tmovq\t%rbx, %rax\r\n\tmulq\t%rdi\r\n\tshrq\t%rdx\r\n\tleaq\t(%rdx,%rdx,2), %rax\r\n\tsubq\t%rax, %rbx\r\n\tcmpq\t%rcx, %rbx\r\n\tja\t.LBB0_4\r\n\ttestq\t%rbx, %rbx\r\n\tje\t.LBB0_3\r\n\tmovq\t%rsi, %rdi\r\n\tmovl\t$61, %esi\r\n\tmovq\t%rbx, %rdx\r\n\tcallq\t*memset@GOTPCREL(%rip)\r\n\r\n.LBB0_3:\r\n\tmovq\t%rbx, %rax\r\n\tpopq\t%rbx\r\n\tretq\r\n\r\n[snip panic code]\r\n```\r\nFor long slices memset would be a good choice but for just a few bytes the overhead is simply too big. When using a constant range for testing, we see the compiler emitting different combinations of `movb`, `movw`, `movl`, `movabsq`,`movaps+movups` up to a length of 256 byte. Only for slices longer than that a memset is used.\r\n\r\nAt some point the compiler already realizes that `padding_length` is always `< 3` as an `assert!(padding_length < 3);` gets optimized out completely. Whether this information is not available at the right place or is simply not utilized, I can't tell.\r\n\r\nWrapping the iterator version's loop in a `match` results in two things - the fastest version and a monstrosity ([playground](https://play.rust-lang.org/?version=stable&mode=release&edition=2018&gist=afa4e27d8e035a1419f784fb0b889a5a)).\r\n```rust\r\npub fn add_padding(input_len: usize, output: &mut [u8]) -> usize {\r\n    let rem = input_len % 3;\r\n    let padding_length = (3 - rem) % 3;\r\n    \r\n    match padding_length {\r\n        0 => {\r\n            for byte in output[..padding_length].iter_mut() {\r\n                *byte = b'=';\r\n            }\r\n        },\r\n        1 => {\r\n            for byte in output[..padding_length].iter_mut() {\r\n                *byte = b'=';\r\n            }\r\n        }\r\n        2 => {\r\n            for byte in output[..padding_length].iter_mut() {\r\n                *byte = b'=';\r\n            }\r\n        },\r\n        _ => unreachable!()\r\n    }\r\n    \r\n\r\n    padding_length\r\n}\r\n```\r\n```\r\nabsolute:\r\n0: time:  [2.8705 ns 2.8749 ns 2.8797 ns]\r\n1: time:  [3.2446 ns 3.2470 ns 3.2499 ns]\r\n2: time:  [3.4626 ns 3.4753 ns 3.4894 ns]\r\n\r\nrelative compared to baseline:\r\n0: time:  [-0.1432% +0.0826% +0.3052%]\r\n1: time:  [+0.0403% +0.2527% +0.4629%]\r\n2: time:  [-7.6693% -7.3060% -6.9496%]\r\n```\r\nIt uses a `movw` when writing two bytes, which explains why this version is faster than baseline only in that case.\r\n\r\nAll measurements taken with criterion.rs and Rust 1.42.0 on an i5-3450. Care has been taken to ensure a low noise environment with reproducible results.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/71066/reactions", "total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 1, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/71066/timeline", "performed_via_github_app": null, "state_reason": null}