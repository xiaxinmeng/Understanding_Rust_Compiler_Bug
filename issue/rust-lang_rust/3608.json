{"url": "https://api.github.com/repos/rust-lang/rust/issues/3608", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/3608/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/3608/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/3608/events", "html_url": "https://github.com/rust-lang/rust/issues/3608", "id": 7195792, "node_id": "MDU6SXNzdWU3MTk1Nzky", "number": 3608, "title": "Freestanding (runtime-less) Rust", "user": {"login": "bstrie", "id": 865233, "node_id": "MDQ6VXNlcjg2NTIzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstrie", "html_url": "https://github.com/bstrie", "followers_url": "https://api.github.com/users/bstrie/followers", "following_url": "https://api.github.com/users/bstrie/following{/other_user}", "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions", "organizations_url": "https://api.github.com/users/bstrie/orgs", "repos_url": "https://api.github.com/users/bstrie/repos", "events_url": "https://api.github.com/users/bstrie/events{/privacy}", "received_events_url": "https://api.github.com/users/bstrie/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 36953, "node_id": "MDU6TGFiZWwzNjk1Mw==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-runtime", "name": "A-runtime", "color": "f7e101", "default": false, "description": "Area: std's runtime and \"pre-main\" init for handling backtraces, unwinds, stack overflows"}, {"id": 234876, "node_id": "MDU6TGFiZWwyMzQ4NzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/E-hard", "name": "E-hard", "color": "02e10c", "default": false, "description": "Call for participation: Experience needed to fix: Hard / a lot"}, {"id": 37977651, "node_id": "MDU6TGFiZWwzNzk3NzY1MQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/metabug", "name": "metabug", "color": "5319e7", "default": false, "description": "Issues about issues themselves (\"bugs about bugs\")"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 15, "created_at": "2012-09-27T19:57:06Z", "updated_at": "2013-10-24T02:55:45Z", "closed_at": "2013-10-24T02:55:45Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Right now, if you want to do any of the following:\n- Write libraries in Rust that can be called from other languages\n- Write Linux kernel modules in Rust\n- Write the Rust runtime in Rust\n\nyou are thwarted by the inability of Rust code to escape the Rust runtime. This ticket is intended to centralize discussion of how this could be done.\n\nSome old random comments:\n\n> \"This might be useful for other things too, such as drivers or libraries to be embedded into other software. (The latter is obviously of interest to us at Mozilla.) Rust programs compiled in this mode would disable the task system, would be vulnerable to stack overflow (although we might be able to mitigate that with guard pages), and would require extra work to avoid leaks, but would be able to run without a runtime.\" ~ @pcwalton\n> \n> \"Rust does currently depend on a language runtime which expects to control the execution of all Rust code (in particular managing the task scheduler), and the runtime does not have an embedding story yet. Even with an embeddable runtime though, the process would be more involved than loading a library through `dlopen` and executing a function.\n> \"As part of the effort to rewrite the remaining bits of C++ runtime code in Rust (almost all of Rust is written in Rust), there are further plans to make Rust code runnable without an underlying runtime and without split stacks.\" ~ @brson\n\n```\n<pcwalton> well, we'd need to do something about stack growth\n<pcwalton> a crate-level attribute to disable it, I guess\n<pcwalton> also I guess we'd probably want to convert all the residual upcalls to lang items.\n<pcwalton> and the ability to disable linking against librustrt\n<pcwalton> but yeah, those are quite easy\n<pcwalton> disabling stack growth is the big one. that would also be useful if you want to write dynamic libraries in pure Rust callable from C\n<pcwalton> I *think* if you do that, and you avoid @ boxes, and you don't use the task system, and your entry points are extern \"C\", and we change the exchange heap to be allocable without a task pointer, then you are probably OK\n```\n\n> \"The runtime does three things: (a) set up the initial task and allocates new tasks when a task runs out of stack; (b) schedules tasks; (c) provides a few implementations of magic functions that aren't written in Rust yet.\n> \"For (a), this is because we have segmented stacks, and there needs to be some hooks to set this up. Eventually this magic should be written in Rust, not in C++. (We needed C++ to bootstrap.) (b) is basically the same story; note that the language itself knows nothing about tasks and they're solely in the standard library. And for (c), the number of these functions is dwindling and more of them are being moved into the standard library.\" ~ pcwalton\n\n```\n< dylukes> How feasible do you guys think a Rust -> JS compiler is at this stage?\n< dylukes> (restatement: how pluggable is the backend of rustc)\n< dylukes> (last time I went through the code it was pretty well divided into front/middle/back)\n<@nmatsakis> the right approach is not to change rustc\n<@nmatsakis> but rather to use emscripten\n<@nmatsakis> this is basically dependent on the runtime-less rust\n<@nmatsakis> efforts\n< dylukes> Oh that's true. I forgot about emscripten.\n< dylukes> Alternatively you provide a runtime in JS.\n< dylukes> I assume emscripten converts calls to external functions to javascript calls, so you'd just have\n           to stub out the runtime, no?\n< dylukes> Or you know, compile the runtime with emscripten as well...\n<@pcwalton> you'd need to write a new runtime\n<@nmatsakis> it's conceivable we could write a very minimal runtime that just fails if you enter the hard\n             parts.\n<@nmatsakis> \"runtime-less rust\" is clearly the \"right way\"\n```\n\n```\n<@nmatsakis> array bound checks would presumably still be present in a standalone Rust\n<@nmatsakis> we have to decide what failure means though\n<@pcwalton> probably abort()\n<@nmatsakis> :(\n<@nmatsakis> that's not how I was thinking of it\n<@nmatsakis> that is, I was thinking that all rust programs would be standalone, basically\n<@nmatsakis> but things like tasks would be an optional library\n<@nmatsakis> as a long term goal I guess\n<@pcwalton> oh sure, I mean it would be a call to upcall_fail() or whatever\n<@nmatsakis> a separate mode would be a good place to start\n< bstrie> how would a program that uses tasks call into a standalone program if the latter has split stacks\n          disabled?\n<@pcwalton> but in the standalone RT it would just call abort()\n<@nmatsakis> currently, we throw a C++ exception (except on Windows, I know)\n<@nmatsakis> that would be quite tolerable\n<@nmatsakis> actually it'd be nice if upcall_fail() were pluggable\n<@nmatsakis> perhaps some minimal set of upcalls could be given virtually\n<@pcwalton> nmatsakis: it has to be a separate mode to some degree because of the current llvm all-or-nothing\n                  support for split stacks\n<@pcwalton> although that should be changed\n<@nmatsakis> pcwalton: I was assuming that we'd always keep split-stacks, and we'd just have the \"top\" of the\n                   stack be initialized to infinity or what have you.  We can presumably compile C-invokable\n                   wrappers for the external interface points.  In any case, there are plenty of details to be\n                   worked out....\n```\n", "closed_by": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/3608/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/3608/timeline", "performed_via_github_app": null, "state_reason": "completed"}