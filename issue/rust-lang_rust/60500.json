{"url": "https://api.github.com/repos/rust-lang/rust/issues/60500", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/60500/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/60500/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/60500/events", "html_url": "https://github.com/rust-lang/rust/issues/60500", "id": 439878361, "node_id": "MDU6SXNzdWU0Mzk4NzgzNjE=", "number": 60500, "title": "Rustc crash when compile", "user": {"login": "QuantumBear", "id": 580410, "node_id": "MDQ6VXNlcjU4MDQxMA==", "avatar_url": "https://avatars.githubusercontent.com/u/580410?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuantumBear", "html_url": "https://github.com/QuantumBear", "followers_url": "https://api.github.com/users/QuantumBear/followers", "following_url": "https://api.github.com/users/QuantumBear/following{/other_user}", "gists_url": "https://api.github.com/users/QuantumBear/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuantumBear/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuantumBear/subscriptions", "organizations_url": "https://api.github.com/users/QuantumBear/orgs", "repos_url": "https://api.github.com/users/QuantumBear/repos", "events_url": "https://api.github.com/users/QuantumBear/events{/privacy}", "received_events_url": "https://api.github.com/users/QuantumBear/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2019-05-03T04:10:17Z", "updated_at": "2019-05-03T13:48:16Z", "closed_at": "2019-05-03T13:48:16Z", "author_association": "NONE", "active_lock_reason": null, "body": "Code is from learn rust with lists.\r\n\r\n```\r\nuse std::rc::Rc;\r\nuse std::cell::{Ref, RefCell, RefMut};\r\n\r\npub struct List<T> {\r\n    head: Link<T>,\r\n    tail: Link<T>,\r\n}\r\n\r\ntype Link<T> = Option<Rc<RefCell<Node<T>>>>;\r\n\r\nstruct Node<T> {\r\n    elem: T,\r\n    next: Link<T>,\r\n    prev: Link<T>,\r\n}\r\n\r\nimpl<T> Node<T> {\r\n    fn new(elem : T) -> Rc<RefCell<Self>> {\r\n        Rc::new(RefCell::new(Node{elem: elem, next: None, prev: None}))\r\n    }\r\n}\r\n\r\npub struct IntoIter<T>(List<T>);\r\n\r\nimpl<T> List<T> {\r\n    pub fn new() -> Self {\r\n        List { head: None, tail: None}\r\n    }\r\n\r\n    pub fn push_front(&mut self, elem: T) {\r\n        let new_head = Node::new(elem);\r\n        match self.head.take() {\r\n            Some(old_head) => {\r\n                old_head.borrow_mut().prev = Some(new_head.clone());\r\n                new_head.borrow_mut().next = Some(old_head.clone());\r\n                self.head = Some(new_head);\r\n            }\r\n            None => {\r\n                self.tail = Some(new_head.clone());\r\n                self.head = Some(new_head);\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn push_back(&mut self, elem: T) {\r\n        let new_tail = Node::new(elem);\r\n        match self.tail.take() {\r\n            Some(old_tail) => {\r\n                old_tail.borrow_mut().next = Some(new_tail.clone());\r\n                new_tail.borrow_mut().prev = Some(old_tail.clone());\r\n                self.tail = Some(new_tail);\r\n            }\r\n            None => {\r\n                self.head = Some(new_tail.clone());\r\n                self.tail = Some(new_tail);\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn pop_front(&mut self) -> Option<T> {\r\n        self.head.take().map(|old_head| {\r\n            match old_head.borrow_mut().next.take() {\r\n                Some(new_head) => {\r\n                    new_head.borrow_mut().prev.take();\r\n                    self.head = Some(new_head);\r\n                }\r\n                None => {\r\n                    self.tail.take();\r\n                }\r\n            }\r\n            Rc::try_unwrap(old_head).ok().unwrap().into_inner().elem\r\n        })    \r\n    }\r\n\r\n    pub fn pop_back(&mut self) -> Option<T> {\r\n        self.tail.take().map(|old_tail| {\r\n            match old_tail.borrow_mut().prev.take() {\r\n                Some(new_tail) => {\r\n                    new_tail.borrow_mut().next.take();\r\n                    self.tail = Some(new_tail);\r\n                }\r\n                None => {\r\n                    self.head.take();\r\n                }\r\n            }\r\n            Rc::try_unwrap(old_tail).ok().unwrap().into_inner().elem\r\n        }) \r\n    }\r\n\r\n    pub fn peek_front(&self) -> Option<Ref<T>> {\r\n        self.head.as_ref().map(|node| {\r\n            Ref::map(node.borrow(),|node| &node.elem)\r\n        })\r\n    }\r\n\r\n    pub fn peek_back(&self) -> Option<Ref<T>> {\r\n        self.tail.as_ref().map(|node| {\r\n            Ref::map(node.borrow(),|node| &node.elem)\r\n        })\r\n    }\r\n\r\n    pub fn peek_front_mut(&mut self) -> Option<RefMut<T>> {\r\n        self.head.as_mut().map(|node| {\r\n            RefMut::map(node.borrow_mut(),|node| &mut node.elem)\r\n        })\r\n    }\r\n\r\n    pub fn peek_back_mut(&mut self) -> Option<RefMut<T>> {\r\n        self.tail.as_mut().map(|node| {\r\n            RefMut::map(node.borrow_mut(),|node| &mut node.elem)\r\n        })\r\n    }\r\n\r\n    pub fn into_iter(self) -> IntoIter<T> {\r\n        IntoIter(self)\r\n    }\r\n}\r\n\r\nimpl<T> Iterator for IntoIter<T> {\r\n    type Item = T;\r\n    fn next(&mut self) -> Option<Self::Item> {\r\n        self.0.pop_front()\r\n    }\r\n}\r\n\r\nimpl<T> DoubleEndedIterator for IntoIter<T> {\r\n    fn next_back(&mut self) -> Option<T> {\r\n        self.0.pop_back()\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use super::List;\r\n\r\n    #[test]\r\n    fn basics() {\r\n        let mut list = List::new();\r\n\r\n        // Check empty list behaves right\r\n        assert_eq!(list.pop_front(), None);\r\n\r\n        // Populate list\r\n        list.push_front(1);\r\n        list.push_front(2);\r\n        list.push_front(3);\r\n\r\n        // Check normal removal\r\n        assert_eq!(list.pop_front(), Some(3));\r\n        assert_eq!(list.pop_front(), Some(2));\r\n\r\n        // Push some more just to make sure nothing's corrupted\r\n        list.push_front(4);\r\n        list.push_front(5);\r\n\r\n        // Check normal removal\r\n        assert_eq!(list.pop_front(), Some(5));\r\n        assert_eq!(list.pop_front(), Some(4));\r\n\r\n        // Check exhaustion\r\n        assert_eq!(list.pop_front(), Some(1));\r\n        assert_eq!(list.pop_front(), None);\r\n\r\n        // ---- back -----\r\n\r\n        // Check empty list behaves right\r\n        assert_eq!(list.pop_back(), None);\r\n\r\n        // Populate list\r\n        list.push_back(1);\r\n        list.push_back(2);\r\n        list.push_back(3);\r\n\r\n        // Check normal removal\r\n        assert_eq!(list.pop_back(), Some(3));\r\n        assert_eq!(list.pop_back(), Some(2));\r\n\r\n        // Push some more just to make sure nothing's corrupted\r\n        list.push_back(4);\r\n        list.push_back(5);\r\n\r\n        // Check normal removal\r\n        assert_eq!(list.pop_back(), Some(5));\r\n        assert_eq!(list.pop_back(), Some(4));\r\n\r\n        // Check exhaustion\r\n        assert_eq!(list.pop_back(), Some(1));\r\n        assert_eq!(list.pop_back(), None);\r\n    }\r\n\r\n    #[test]\r\n    fn peek() {\r\n        let mut list = List::new();\r\n        assert!(list.peek_front().is_none());\r\n        assert!(list.peek_back().is_none());\r\n        assert!(list.peek_front_mut().is_none());\r\n        assert!(list.peek_back_mut().is_none());\r\n\r\n        list.push_front(1); list.push_front(2); list.push_front(3);\r\n\r\n        assert_eq!(&*list.peek_front().unwrap(), &3);\r\n        assert_eq!(&mut *list.peek_front_mut().unwrap(), &mut 3);\r\n        assert_eq!(&*list.peek_back().unwrap(), &1);\r\n        assert_eq!(&mut *list.peek_back_mut().unwrap(), &mut 1);\r\n    }\r\n\r\n    #[test]\r\n    fn into_iter() {\r\n        let mut list = List::new();\r\n        list.push_front(1); list.push_front(2); list.push_front(3);\r\n\r\n        let mut iter = list.into_iter();\r\n        assert_eq!(iter.next(), Some(3));\r\n        assert_eq!(iter.next_back(), Some(1));\r\n        assert_eq!(iter.next(), Some(2));\r\n        assert_eq!(iter.next_back(), None);\r\n        assert_eq!(iter.next(), None);\r\n    }\r\n}\r\n```\r\n\r\n## meta\r\n```\r\nrustc 1.36.0-nightly (5d20ff4d2 2019-04-18)\r\nbinary: rustc\r\ncommit-hash: 5d20ff4d2718c820632b38c1e49d4de648a9810b\r\ncommit-date: 2019-04-18\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.36.0-nightly\r\nLLVM version: 8.0\r\n```\r\nAnd I set #![feature(nll)] in the lib.rs, maybe this is a issue.\r\n\r\nThe backtrace:\r\n\r\n```\r\n   0: std::sys::unix::backtrace::tracing::imp::unwind_backtrace\r\n             at src/libstd/sys/unix/backtrace/tracing/gcc_s.rs:39\r\n   1: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:71\r\n   2: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n             at src/libstd/panicking.rs:197\r\n   3: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:211\r\n   4: rustc::util::common::panic_hook\r\n   5: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:478\r\n   6: std::panicking::continue_panic_fmt\r\n             at src/libstd/panicking.rs:381\r\n   7: rust_begin_unwind\r\n             at src/libstd/panicking.rs:308\r\n   8: core::panicking::panic_fmt\r\n             at src/libcore/panicking.rs:85\r\n   9: core::option::expect_failed\r\n             at src/libcore/option.rs:1036\r\n  10: serialize::serialize::Decoder::read_map\r\n  11: serialize::serialize::Decoder::read_map\r\n  12: serialize::serialize::Decoder::read_struct\r\n  13: <T as serialize::serialize::Decodable>::decode\r\n  14: rustc::ty::query::on_disk_cache::OnDiskCache::try_load_query_result\r\n  15: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  16: rustc::traits::specialize::find_associated_item\r\n  17: rustc::ty::instance::Instance::resolve\r\n  18: <rustc_mir::monomorphize::collector::MirNeighborCollector as rustc::mir::visit::Visitor>::visit_rvalue\r\n  19: rustc_mir::monomorphize::collector::collect_items_rec\r\n  20: rustc_mir::monomorphize::collector::collect_items_rec\r\n  21: rustc_mir::monomorphize::collector::collect_items_rec\r\n  22: rustc_mir::monomorphize::collector::collect_crate_mono_items::{{closure}}\r\n  23: rustc::util::common::time\r\n  24: rustc_mir::monomorphize::collector::collect_crate_mono_items\r\n  25: rustc::util::common::time\r\n  26: rustc_mir::monomorphize::partitioning::collect_and_partition_mono_items\r\n  27: rustc::ty::query::__query_compute::collect_and_partition_mono_items\r\n  28: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::collect_and_partition_mono_items>::compute\r\n  29: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  30: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  31: rustc_codegen_ssa::base::codegen_crate\r\n  32: <rustc_codegen_llvm::LlvmCodegenBackend as rustc_codegen_utils::codegen_backend::CodegenBackend>::codegen_crate\r\n  33: rustc::util::common::time\r\n  34: rustc_interface::passes::start_codegen\r\n  35: rustc::ty::context::tls::enter_global\r\n  36: rustc_interface::passes::BoxedGlobalCtxt::access::{{closure}}\r\n  37: rustc_interface::passes::create_global_ctxt::{{closure}}\r\n  38: rustc_interface::passes::BoxedGlobalCtxt::enter\r\n  39: rustc_interface::queries::Query<T>::compute\r\n  40: rustc_interface::queries::<impl rustc_interface::interface::Compiler>::ongoing_codegen\r\n  41: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  42: std::thread::local::LocalKey<T>::with\r\n  43: scoped_tls::ScopedKey<T>::set\r\n  44: syntax::with_globals\r\nquery stack during panic:\r\n#0 [specialization_graph_of] processing `std::fmt::Debug`\r\n#1 [collect_and_partition_mono_items] collect_and_partition_mono_items\r\nend of query stack\r\n```", "closed_by": {"login": "QuantumBear", "id": 580410, "node_id": "MDQ6VXNlcjU4MDQxMA==", "avatar_url": "https://avatars.githubusercontent.com/u/580410?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuantumBear", "html_url": "https://github.com/QuantumBear", "followers_url": "https://api.github.com/users/QuantumBear/followers", "following_url": "https://api.github.com/users/QuantumBear/following{/other_user}", "gists_url": "https://api.github.com/users/QuantumBear/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuantumBear/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuantumBear/subscriptions", "organizations_url": "https://api.github.com/users/QuantumBear/orgs", "repos_url": "https://api.github.com/users/QuantumBear/repos", "events_url": "https://api.github.com/users/QuantumBear/events{/privacy}", "received_events_url": "https://api.github.com/users/QuantumBear/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/60500/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/60500/timeline", "performed_via_github_app": null, "state_reason": "completed"}