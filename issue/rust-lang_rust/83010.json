{"url": "https://api.github.com/repos/rust-lang/rust/issues/83010", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/83010/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/83010/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/83010/events", "html_url": "https://github.com/rust-lang/rust/issues/83010", "id": 828989801, "node_id": "MDU6SXNzdWU4Mjg5ODk4MDE=", "number": 83010, "title": "Closures in generic code can create duplicate monomorphizations", "user": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37544, "node_id": "MDU6TGFiZWwzNzU0NA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-typesystem", "name": "A-typesystem", "color": "f7e101", "default": false, "description": "Area: The type system"}, {"id": 64037154, "node_id": "MDU6TGFiZWw2NDAzNzE1NA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-compiletime", "name": "I-compiletime", "color": "e11d21", "default": false, "description": "Problems and improvements with respect to compile times."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 1049491442, "node_id": "MDU6TGFiZWwxMDQ5NDkxNDQy", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-heavy", "name": "I-heavy", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to binary size of generated code."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2021-03-11T09:58:29Z", "updated_at": "2021-07-11T19:34:30Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "### Summary\r\n\r\nWhen a closure is defined in a generic context like a generic function or a method of a generic class, its type includes, in some sense or another, the parent's generic parameters. If the closure doesn't depend on some of those generic parameters, it can lead to the instantiation of mono items which are functionally identical, but distinct by virtue of false dependencies on unused generic parameters of the parent. I'll call these mono items \"duplicates\".\r\n\r\nThese duplicates create needless work and code bloat. At the very least, they go through the codegen and optimization pipeline, and if not optimized away, are included in the binary. I imagine there is other overhead, such as creation of more distinct types.\r\n\r\n### Example 1\r\n\r\n```rust\r\nfn foo<T: std::fmt::Display>(t: T) {\r\n    let _ = vec![\"hello\".to_string()].iter().map(|x| x);\r\n    println!(\"{}\", t);\r\n}\r\n\r\nfn main() {\r\n    foo(0i32);\r\n    foo(0i64);\r\n}\r\n```\r\n\r\nThe `map` call is passed a closure `|x| x` which does not depend the parent function's generic parameter `T`. The code for that closure is identical in both `foo::<i32>` and `foo::<i64>`, so we should be able to only generate one `map` instantiation and `Map` type (the return type of `map`, which is generic over the closure that `map` was passed), and use it in both `foo` instances. Yet this creates two `map` instantiations, and two `Map::new` instantiations, because the closure type is polluted by the parent's `T` parameter, which, again, the closure doesn't use in any way.\r\n\r\nExcerpt from `-Z print-mono-items=lazy`:\r\n\r\n```\r\nMONO_ITEM fn <std::slice::Iter<std::string::String> as std::iter::Iterator>::map::<&std::string::String, [closure@src/main.rs:2:50: 2:55]> @@ lzylnwmetevawv6[External]\r\nMONO_ITEM fn <std::slice::Iter<std::string::String> as std::iter::Iterator>::map::<&std::string::String, [closure@src/main.rs:2:50: 2:55]> @@ lzylnwmetevawv6[External]\r\n\r\nMONO_ITEM fn std::iter::Map::<std::slice::Iter<std::string::String>, [closure@src/main.rs:2:50: 2:55]>::new @@ 290s40pyalavf195[External]\r\nMONO_ITEM fn std::iter::Map::<std::slice::Iter<std::string::String>, [closure@src/main.rs:2:50: 2:55]>::new @@ 290s40pyalavf195[External]\r\n```\r\n\r\n(I don't know why, but there weren't any mono items in the output for the closure itself in this example.)\r\n\r\nIf we actually did anything interesting with the `Map`s, it would create yet more duplicate instantiations. And if the closure captured anything by value that needed dropping, it would create duplicate `drop_in_place` instantiations for the closure and `Map` types.\r\n\r\n### Example 2\r\n\r\nThis isn't a rare event. Here's an example from the standard library which was quickly and easily found. This case is different, because the parent generics come from the struct for which the function is implemented:\r\n\r\n```rust\r\n\r\nimpl<K, V, S> PartialEq for HashMap<K, V, S>\r\nwhere\r\n    K: Eq + Hash,\r\n    V: PartialEq,\r\n    S: BuildHasher,\r\n{\r\n    fn eq(&self, other: &HashMap<K, V, S>) -> bool {\r\n        if self.len() != other.len() {\r\n            return false;\r\n        }\r\n\r\n        self.iter().all(|(key, value)| other.get(key).map_or(false, |v| *value == *v))\r\n    }\r\n}\r\n```\r\n\r\nThe closure passed to `map_or` really only depends on `V`, yet it has false dependencies on `K` and `S`. Creating two `HashMap`s with the same value type will cause duplicate mono items to be created for this closure and `map_or`:\r\n\r\n```rust\r\nuse std::collections::HashMap;\r\n\r\nfn main() {\r\n    let m1 = HashMap::<String, u8>::new();\r\n    assert_eq!(m1, m1);\r\n\r\n    let m2 = HashMap::<i32, u8>::new();\r\n    assert_eq!(m2, m2);\r\n}\r\n```\r\n\r\nExcerpt from `-Z print-mono-items=lazy`:\r\n\r\n```\r\nMONO_ITEM fn <std::collections::HashMap<i32, u8> as std::cmp::PartialEq>::eq::{closure#0}::{closure#0} @@ i6hou2d2a3r4xaf[External]\r\nMONO_ITEM fn <std::collections::HashMap<std::string::String, u8> as std::cmp::PartialEq>::eq::{closure#0}::{closure#0} @@ i6hou2d2a3r4xaf[External]\r\n\r\nMONO_ITEM fn std::option::Option::<&u8>::map_or::<bool, [closure@<std::collections::HashMap<i32, u8> as std::cmp::PartialEq>::eq::{closure#0}::{closure#0}]> @@ 583fmf0zweyhx5vp[External]\r\nMONO_ITEM fn std::option::Option::<&u8>::map_or::<bool, [closure@<std::collections::HashMap<std::string::String, u8> as std::cmp::PartialEq>::eq::{closure#0}::{closure#0}]> @@ 583fmf0zweyhx5vp[External]\r\n```\r\n\r\n### Impact\r\n\r\nOkay, so there are some duplicate mono items. Maybe even a lot in a real codebase. But is it impactful? I haven't measured, but I suspect it is. Take a look at the Rust and assembly for `Option::map_or` (for the above closure) in debug mode, and consider the above example:\r\n\r\n```rust\r\n    pub fn map_or<U, F: FnOnce(T) -> U>(self, default: U, f: F) -> U {\r\n        match self {\r\n            Some(t) => f(t),\r\n            None => default,\r\n        }\r\n    }\r\n```\r\n\r\n<details>\r\n<summary>Assembly</summary>\r\n\r\n```asm\r\n<<core::option::Option<&u8>>::map_or::<bool, <std::collections::hash::map::HashMap<alloc::string::String, u8> as core::cmp::PartialEq>::eq::{closure#0}::{closure#0}>>:\r\n\t                sub    $0x58,%rsp\r\n\t                mov    %rdi,0x18(%rsp)\r\n\t                mov    %sil,%al\r\n\t                and    $0x1,%al\r\n\t                mov    %al,0x37(%rsp)\r\n\t                mov    %rdx,0x38(%rsp)\r\n\t                movb   $0x0,0x36(%rsp)\r\n\t                movb   $0x0,0x35(%rsp)\r\n\t                movb   $0x1,0x36(%rsp)\r\n\t                movb   $0x1,0x35(%rsp)\r\n\t                mov    0x18(%rsp),%rcx\r\n\t                test   %rcx,%rcx\r\n\t                setne  %al\r\n\t                movzbl %al,%r8d\r\n\t                mov    %r8d,%ecx\r\n\t                mov    %rdx,0x10(%rsp)\r\n\t                mov    %sil,0xf(%rsp)\r\n\t         /----- je     <<core::option::Option<&u8>>::map_or::<bool, <std::collections::hash::map::HashMap<alloc::string::String, u8> as core::cmp::PartialEq>::eq::{closure#0}::{closure#0}>+0x4d>\r\n\t         |  /-- jmp    <<core::option::Option<&u8>>::map_or::<bool, <std::collections::hash::map::HashMap<alloc::string::String, u8> as core::cmp::PartialEq>::eq::{closure#0}::{closure#0}>+0x4b>\r\n\t      /--|--\\-X jmp    <<core::option::Option<&u8>>::map_or::<bool, <std::collections::hash::map::HashMap<alloc::string::String, u8> as core::cmp::PartialEq>::eq::{closure#0}::{closure#0}>+0x60>\r\n\t      |  \\----> movb   $0x0,0x36(%rsp)\r\n\t      |         mov    0xf(%rsp),%al\r\n\t      |         and    $0x1,%al\r\n\t      |         mov    %al,0x27(%rsp)\r\n\t/-----|-------- jmp    <<core::option::Option<&u8>>::map_or::<bool, <std::collections::hash::map::HashMap<alloc::string::String, u8> as core::cmp::PartialEq>::eq::{closure#0}::{closure#0}>+0xac>\r\n\t|     |         ud2    \r\n\t|     \\-------> mov    0x18(%rsp),%rax\r\n\t|               mov    %rax,0x40(%rsp)\r\n\t|               movb   $0x0,0x35(%rsp)\r\n\t|               mov    %rax,0x28(%rsp)\r\n\t|               mov    0x28(%rsp),%rsi\r\n\t|               mov    0x10(%rsp),%rdi\r\n\t|               callq  <<std::collections::hash::map::HashMap<alloc::string::String, u8> as core::cmp::PartialEq>::eq::{closure#0}::{closure#0}>\r\n\t|               mov    %al,0xe(%rsp)\r\n\t|           /-- jmp    <<core::option::Option<&u8>>::map_or::<bool, <std::collections::hash::map::HashMap<alloc::string::String, u8> as core::cmp::PartialEq>::eq::{closure#0}::{closure#0}>+0x89>\r\n\t|           \\-> mov    0xe(%rsp),%al\r\n\t|               and    $0x1,%al\r\n\t|               mov    %al,0x27(%rsp)\r\n\t+-------------- jmp    <<core::option::Option<&u8>>::map_or::<bool, <std::collections::hash::map::HashMap<alloc::string::String, u8> as core::cmp::PartialEq>::eq::{closure#0}::{closure#0}>+0xac>\r\n\t|  /----------> testb  $0x1,0x36(%rsp)\r\n\t|  |  /-------- jne    <<core::option::Option<&u8>>::map_or::<bool, <std::collections::hash::map::HashMap<alloc::string::String, u8> as core::cmp::PartialEq>::eq::{closure#0}::{closure#0}>+0xb5>\r\n\t|  |  |  /----> mov    0x27(%rsp),%al\r\n\t|  |  |  |      and    $0x1,%al\r\n\t|  |  |  |      movzbl %al,%eax\r\n\t|  |  |  |      add    $0x58,%rsp\r\n\t|  |  |  |      retq   \r\n\t|  +--|--|--/-X jmp    <<core::option::Option<&u8>>::map_or::<bool, <std::collections::hash::map::HashMap<alloc::string::String, u8> as core::cmp::PartialEq>::eq::{closure#0}::{closure#0}>+0x95>\r\n\t\\--|--|--|--|-> testb  $0x1,0x35(%rsp)\r\n\t   |  |  |  \\-- jne    <<core::option::Option<&u8>>::map_or::<bool, <std::collections::hash::map::HashMap<alloc::string::String, u8> as core::cmp::PartialEq>::eq::{closure#0}::{closure#0}>+0xaa>\r\n\t   \\--|--|----- jmp    <<core::option::Option<&u8>>::map_or::<bool, <std::collections::hash::map::HashMap<alloc::string::String, u8> as core::cmp::PartialEq>::eq::{closure#0}::{closure#0}>+0x95>\r\n\t      \\--\\----X jmp    <<core::option::Option<&u8>>::map_or::<bool, <std::collections::hash::map::HashMap<alloc::string::String, u8> as core::cmp::PartialEq>::eq::{closure#0}::{closure#0}>+0x9c>\r\n\t         /--/-X jmp    <<core::option::Option<&u8>>::map_or::<bool, <std::collections::hash::map::HashMap<alloc::string::String, u8> as core::cmp::PartialEq>::eq::{closure#0}::{closure#0}>+0xc0>\r\n\t      /--|--|-> testb  $0x1,0x36(%rsp)\r\n\t      |  |  \\-- jne    <<core::option::Option<&u8>>::map_or::<bool, <std::collections::hash::map::HashMap<alloc::string::String, u8> as core::cmp::PartialEq>::eq::{closure#0}::{closure#0}>+0xb7>\r\n\t      |  \\----> mov    0x48(%rsp),%rdi\r\n\t      |         callq  <_Unwind_Resume@plt>\r\n\t      |         ud2    \r\n\t      |         mov    %rax,0x48(%rsp)\r\n\t      |         mov    %edx,0x50(%rsp)\r\n\t      \\-------- jmp    <<core::option::Option<&u8>>::map_or::<bool, <std::collections::hash::map::HashMap<alloc::string::String, u8> as core::cmp::PartialEq>::eq::{closure#0}::{closure#0}>+0xb9>\r\n\t                nopw   0x0(%rax,%rax,1)\r\n```\r\n\r\n(Wow, that's surprisingly complicated.)\r\n</details>\r\n\r\nIn debug mode, this code is included in the binary twice, once for each closure. In release mode, the code may be optimized out, but it's still processed for some part of compilation. This was a trivial example. Imagine if `map_or` was a complicated function!\r\n\r\nIf there are hundreds or thousands of duplicate mono items in moderate to large codebases, which seems quite possible, then this may have a noticeable impact on compile times and binary sizes.\r\n\r\n### Solution\r\n\r\nIf possible, we should make closure types depend only on the parent generics which they actually use.\r\n\r\nThe `ClosureSubsts` [comment](https://github.com/rust-lang/rust/pull/27087/files#diff-8780054cdf09361c4ac2540c7f544ecfdc52a9e610822aabb8bcd2964affcb1cR1849) explains why parent generics are included:\r\n\r\n```rust\r\n/// All right, you say, but why include the type parameters from the\r\n/// original function then? The answer is that codegen may need them\r\n/// when monomorphizing, and they may not appear in the upvars. A\r\n/// closure could capture no variables but still make use of some\r\n/// in-scope type parameter with a bound (e.g., if our example above\r\n/// had an extra `U: Default`, and the closure called `U::default()`).\r\n///\r\n/// There is another reason. This design (implicitly) prohibits\r\n/// closures from capturing themselves (except via a trait\r\n/// object). This simplifies closure inference considerably, since it\r\n/// means that when we infer the kind of a closure or its upvars, we\r\n/// don't have to handle cycles where the decisions we make for\r\n/// closure C wind up influencing the decisions we ought to make for\r\n/// closure C (which would then require fixed point iteration to\r\n/// handle). Plus it fixes an ICE. :P\r\n```\r\n\r\nSee #27087, where this was introduced. #27086 may also be relevant. [Here](https://github.com/rust-lang/rust/pull/27087/files#diff-74378250470044ff124ddc0388ef332e18fad35333b3c641ed63b6b975894369R99) and [here](https://github.com/rust-lang/rust/pull/27087/files#diff-87f69f2447d51d81814af3ce78bec8975956a7315e2846fa80f8f745e6fa5670R1847) are FIXMEs for that issue, later removed.\r\n\r\nI have a feeling the case where the parent generics come from a generic struct on which the function including the closure is defined (example 2) may be harder to solve.\r\n\r\n@rustbot label T-compiler A-typesystem I-compiletime I-heavy", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/83010/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/83010/timeline", "performed_via_github_app": null, "state_reason": null}