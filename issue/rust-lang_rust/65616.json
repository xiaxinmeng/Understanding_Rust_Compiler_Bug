{"url": "https://api.github.com/repos/rust-lang/rust/issues/65616", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/65616/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/65616/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/65616/events", "html_url": "https://github.com/rust-lang/rust/issues/65616", "id": 509551114, "node_id": "MDU6SXNzdWU1MDk1NTExMTQ=", "number": 65616, "title": "Compiler diagnostics for missing methods in generated code are unreadable", "user": {"login": "lopopolo", "id": 860434, "node_id": "MDQ6VXNlcjg2MDQzNA==", "avatar_url": "https://avatars.githubusercontent.com/u/860434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lopopolo", "html_url": "https://github.com/lopopolo", "followers_url": "https://api.github.com/users/lopopolo/followers", "following_url": "https://api.github.com/users/lopopolo/following{/other_user}", "gists_url": "https://api.github.com/users/lopopolo/gists{/gist_id}", "starred_url": "https://api.github.com/users/lopopolo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lopopolo/subscriptions", "organizations_url": "https://api.github.com/users/lopopolo/orgs", "repos_url": "https://api.github.com/users/lopopolo/repos", "events_url": "https://api.github.com/users/lopopolo/events{/privacy}", "received_events_url": "https://api.github.com/users/lopopolo/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 235791, "node_id": "MDU6TGFiZWwyMzU3OTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-diagnostics", "name": "A-diagnostics", "color": "f7e101", "default": false, "description": "Area: Messages for errors, warnings, and lints"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 1659943986, "node_id": "MDU6TGFiZWwxNjU5OTQzOTg2", "url": "https://api.github.com/repos/rust-lang/rust/labels/D-verbose", "name": "D-verbose", "color": "c9f7a3", "default": false, "description": "Too much output caused by a single piece of incorrect code"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2019-10-20T06:01:34Z", "updated_at": "2022-12-28T01:52:27Z", "closed_at": "2022-12-28T01:51:30Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I was incorrectly using a struct in some bindgen-produced code. I do not run rustfmt on bindgen output, so the source is one line of Rust code.\r\n\r\nThe compiler diagnostics fill my terminal with output making it toilsome to find the error being reported.\r\n\r\n```\r\n\u25b6 cargo build\r\nwarning: couldn't execute `llvm-config --prefix` (error: No such file or directory (os error 2))\r\nwarning: set the LLVM_CONFIG_PATH environment variable to a valid `llvm-config` executable\r\n   Compiling artichoke-backend v0.1.0 (/Users/lopopolo/dev/artichoke/artichoke/artichoke-backend)\r\nerror[E0599]: no method named `map` found for type `sys::ffi::mrb_value` in the current scope\r\n  --> artichoke-backend/src/extn/core/string.rs:68:18\r\n   |\r\n68 |                 .map(|block| Value::new(&interp, block))\r\n   |                  ^^^\r\n   |\r\n  ::: /Users/lopopolo/dev/artichoke/artichoke/target/debug/build/artichoke-backend-57f4f1bd41d3f126/out/ffi.rs:3:16993\r\n   |\r\n3  | # [ repr ( C ) ] # [ derive ( Copy , Clone , Debug , Default , Eq , Hash , Ord , PartialEq , PartialOrd ) ] pub struct __BindgenBitfieldUnit < Storage , Align > { storage : Storage , align : [ Align ; 0 ] , } impl < Storage , Align > __BindgenBitfieldUnit < Storage , Align > { # [ inline ] pub const fn new ( storage : Storage ) -> Self { Self { storage , align : [ ] } } } impl < Storage , Align > __BindgenBitfieldUnit < Storage , Align > where Storage : AsRef < [ u8 ] > + AsMut < [ u8 ] >, { # [ inline ] pub fn get_bit ( & self , index : usize ) -> bool { debug_assert ! ( index / 8 < self . storage . as_ref ( ) . len ( ) ) ; let byte_index = index / 8 ; let byte = self . storage . as_ref ( ) [ byte_index ] ; let bit_index = if cfg ! ( target_endian = \"big\" ) { 7 - ( index % 8 ) } else { index % 8 } ; let mask = 1 << bit_index ; byte & mask == mask } # [ inline ] pub fn set_bit ( & mut self , index : usize , val : bool ) { debug_assert ! ( index / 8 < self . storage . as_ref ( ) . len ( ) ) ; let byte_index = index / 8 ; let byte = & mut self . storage . as_mut ( ) [ byte_index ] ; let bit_index = if cfg ! ( target_endian = \"big\" ) { 7 - ( index % 8 ) } else { index % 8 } ; let mask = 1 << bit_index ; if val { * byte |= mask ; } else { * byte &= ! mask ; } } # [ inline ] pub fn get ( & self , bit_offset : usize , bit_width : u8 ) -> u64 { debug_assert ! ( bit_width <= 64 ) ; debug_assert ! ( bit_offset / 8 < self . storage . as_ref ( ) . len ( ) ) ; debug_assert ! ( ( bit_offset + ( bit_width as usize ) ) / 8 <= self . storage . as_ref ( ) . len ( ) ) ; let mut val = 0 ; for i in 0 .. ( bit_width as usize ) { if self . get_bit ( i + bit_offset ) { let index = if cfg ! ( target_endian = \"big\" ) { bit_width as usize - 1 - i } else { i } ; val |= 1 << index ; } } val } # [ inline ] pub fn set ( & mut self , bit_offset : usize , bit_width : u8 , val : u64 ) { debug_assert ! ( bit_width <= 64 ) ; debug_assert ! ( bit_offset / 8 < self . storage . as_ref ( ) . len ( ) ) ; debug_assert ! ( ( bit_offset + ( bit_width as usize ) ) / 8 <= self . storage . as_ref ( ) . len ( ) ) ; for i in 0 .. ( bit_width as usize ) { let mask = 1 << i ; let val_bit_is_set = val & mask == mask ; let index = if cfg ! ( target_endian = \"big\" ) { bit_width as usize - 1 - i } else { i } ; self . set_bit ( index + bit_offset , val_bit_is_set ) ; } } } # [ repr ( C ) ] # [ derive ( Default ) ] pub struct __IncompleteArrayField < T > ( :: std :: marker :: PhantomData < T > , [ T ; 0 ] ) ; impl < T > __IncompleteArrayField < T > { # [ inline ] pub const fn new ( ) -> Self { __IncompleteArrayField ( :: std :: marker :: PhantomData , [ ] ) } # [ inline ] pub unsafe fn as_ptr ( & self ) -> * const T { :: std :: mem :: transmute ( self ) } # [ inline ] pub unsafe fn as_mut_ptr ( & mut self ) -> * mut T { :: std :: mem :: transmute ( self ) } # [ inline ] pub unsafe fn as_slice ( & self , len : usize ) -> & [ T ] { :: std :: slice :: from_raw_parts ( self . as_ptr ( ) , len ) } # [ inline ] pub unsafe fn as_mut_slice ( & mut self , len : usize ) -> & mut [ T ] { :: std :: slice :: from_raw_parts_mut ( self . as_mut_ptr ( ) , len ) } } impl < T > :: std :: fmt :: Debug for __IncompleteArrayField < T > { fn fmt ( & self , fmt : & mut :: std :: fmt :: Formatter < '_ > ) -> :: std :: fmt :: Result { fmt . write_str ( \"__IncompleteArrayField\" ) } } impl < T > :: std :: clone :: Clone for __IncompleteArrayField < T > { # [ inline ] fn clone ( & self ) -> Self { Self :: new ( ) } } pub const MRB_INT_BIT : u32 = 64 ; pub const MRB_PRIo : & 'static [ u8 ; 4usize ] = b\"llo\\0\" ; pub const MRB_PRId : & 'static [ u8 ; 4usize ] = b\"lld\\0\" ; pub const MRB_PRIx : & 'static [ u8 ; 4usize ] = b\"llx\\0\" ; pub const MRB_FL_OBJ_IS_FROZEN : u32 = 1048576 ; pub const MRB_FIXNUM_SHIFT : u32 = 0 ; pub const MRB_SYMBOL_MAX : u32 = 4294967295 ; pub const MRB_EACH_OBJ_OK : u32 = 0 ; pub const MRB_EACH_OBJ_BREAK : u32 = 1 ; pub const MRB_GC_ARENA_SIZE : u32 = 100 ; pub const MRUBY_RUBY_VERSION : & 'static [ u8 ; 4usize ] = b\"2.0\\0\" ; pub const MRUBY_RUBY_ENGINE : & 'static [ u8 ; 6usize ] = b\"mruby\\0\" ; pub const MRUBY_RELEASE_MAJOR : u32 = 2 ; pub const MRUBY_RELEASE_MINOR : u32 = 0 ; pub const MRUBY_RELEASE_TEENY : u32 = 1 ; pub const MRUBY_RELEASE_NO : u32 = 20001 ; pub const MRUBY_RELEASE_YEAR : u32 = 2019 ; pub const MRUBY_RELEASE_MONTH : u32 = 4 ; pub const MRUBY_RELEASE_DAY : u32 = 4 ; pub const MRUBY_BIRTH_YEAR : u32 = 2010 ; pub const MRUBY_AUTHOR : & 'static [ u8 ; 17usize ] = b\"mruby developers\\0\" ; pub const MRB_FIXED_STATE_ATEXIT_STACK_SIZE : u32 = 5 ; pub const MRB_METHOD_CACHE_SIZE : u32 = 128 ; pub const MRB_ARY_EMBED_MASK : u32 = 7 ; pub const MRB_ARY_SHARED : u32 = 256 ; pub const MRB_FL_CLASS_IS_PREPENDED : u32 = 524288 ; pub const MRB_FL_CLASS_IS_ORIGIN : u32 = 262144 ; pub const MRB_FL_CLASS_IS_INHERITED : u32 = 131072 ; pub const MRB_INSTANCE_TT_MASK : u32 = 255 ; pub const MRB_PARSER_TOKBUF_MAX : u32 = 65534 ; pub const MRB_PARSER_TOKBUF_SIZE : u32 = 256 ; pub const MRB_ISEQ_NO_FREE : u32 = 1 ; pub const MRB_DUMP_OK : u32 = 0 ; pub const MRB_DUMP_GENERAL_FAILURE : i32 = -1 ; pub const MRB_DUMP_WRITE_FAULT : i32 = -2 ; pub const MRB_DUMP_READ_FAULT : i32 = -3 ; pub const MRB_DUMP_CRC_ERROR : i32 = -4 ; pub const MRB_DUMP_INVALID_FILE_HEADER : i32 = -5 ; pub const MRB_DUMP_INVALID_IREP : i32 = -6 ; pub const MRB_DUMP_INVALID_ARGUMENT : i32 = -7 ; pub const MRB_DUMP_NULL_SYM_LEN : u32 = 65535 ; pub const MRB_DUMP_DEFAULT_STR_LEN : u32 = 128 ; pub const MRB_HASH_DEFAULT : u32 = 1 ; pub const MRB_HASH_PROC_DEFAULT : u32 = 2 ; pub const MRB_ENV_STACK_UNSHARED : u32 = 1048576 ; pub const MRB_PROC_CFUNC_FL : u32 = 128 ; pub const MRB_PROC_STRICT : u32 = 256 ; pub const MRB_PROC_ORPHAN : u32 = 512 ; pub const MRB_PROC_ENVSET : u32 = 1024 ; pub const MRB_PROC_SCOPE : u32 = 2048 ; pub const MRB_METHOD_FUNC_FL : u32 = 1 ; pub const MRB_METHOD_NOARG_FL : u32 = 2 ; pub const REGEXP_CLASS : & 'static [ u8 ; 7usize ] = b\"Regexp\\0\" ; pub const MRB_STR_SHARED : u32 = 1 ; pub const MRB_STR_FSHARED : u32 = 2 ; pub const MRB_STR_NOFREE : u32 = 4 ; pub const MRB_STR_EMBED : u32 = 8 ; pub const MRB_STR_POOL : u32 = 16 ; pub const MRB_STR_ASCII : u32 = 32 ; pub const MRB_STR_EMBED_LEN_SHIFT : u32 = 6 ; pub const MRB_STR_EMBED_LEN_BITSIZE : u32 = 5 ; pub const MRB_STR_EMBED_LEN_MASK : u32 = 1984 ; pub const MRB_STR_TYPE_MASK : u32 = 15 ; pub type va_list = __builtin_va_list ; pub type mrb_sym = u32 ; pub type mrb_bool = u8 ; pub type mrb_int = i64 ; extern \"C\" { pub fn mrb_float_read ( arg1 : * const :: std :: os :: raw :: c_char , arg2 : * mut * mut :: std :: os :: raw :: c_char ) -> f64 ; } pub type mrb_float = f64 ; # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum mrb_vtype { MRB_TT_FALSE = 0 , MRB_TT_TRUE = 1 , MRB_TT_FLOAT = 2 , MRB_TT_FIXNUM = 3 , MRB_TT_SYMBOL = 4 , MRB_TT_UNDEF = 5 , MRB_TT_CPTR = 6 , MRB_TT_FREE = 7 , MRB_TT_OBJECT = 8 , MRB_TT_CLASS = 9 , MRB_TT_MODULE = 10 , MRB_TT_ICLASS = 11 , MRB_TT_SCLASS = 12 , MRB_TT_PROC = 13 , MRB_TT_ARRAY = 14 , MRB_TT_HASH = 15 , MRB_TT_STRING = 16 , MRB_TT_RANGE = 17 , MRB_TT_EXCEPTION = 18 , MRB_TT_FILE = 19 , MRB_TT_ENV = 20 , MRB_TT_DATA = 21 , MRB_TT_FIBER = 22 , MRB_TT_ISTRUCT = 23 , MRB_TT_BREAK = 24 , MRB_TT_MAXDEFINE = 25 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RBasic { pub c : * mut RClass , pub gcnext : * mut RBasic , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_padding_0 : u32 , } # [ test ] fn bindgen_test_layout_RBasic ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RBasic > ( ) , 24usize , concat ! ( \"Size of: \" , stringify ! ( RBasic ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RBasic > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( RBasic ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RBasic > ( ) ) ) . c as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RBasic ) , \"::\" , stringify ! ( c ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RBasic > ( ) ) ) . gcnext as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( RBasic ) , \"::\" , stringify ! ( gcnext ) ) ) ; } impl RBasic { # [ inline ] pub fn tt ( & self ) -> mrb_vtype { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_tt ( & mut self , val : mrb_vtype ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn color ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_color ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 3u8 , val as u64 ) } } # [ inline ] pub fn flags ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 21u8 ) as u32 ) } } # [ inline ] pub fn set_flags ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 21u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tt : mrb_vtype , color : u32 , flags : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let tt : u32 = unsafe { :: std :: mem :: transmute ( tt ) } ; tt as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 3u8 , { let color : u32 = unsafe { :: std :: mem :: transmute ( color ) } ; color as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 21u8 , { let flags : u32 = unsafe { :: std :: mem :: transmute ( flags ) } ; flags as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RObject { pub c : * mut RClass , pub gcnext : * mut RBasic , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub iv : * mut iv_tbl , } # [ test ] fn bindgen_test_layout_RObject ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RObject > ( ) , 32usize , concat ! ( \"Size of: \" , stringify ! ( RObject ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RObject > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( RObject ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RObject > ( ) ) ) . c as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RObject ) , \"::\" , stringify ! ( c ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RObject > ( ) ) ) . gcnext as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( RObject ) , \"::\" , stringify ! ( gcnext ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RObject > ( ) ) ) . iv as * const _ as usize } , 24usize , concat ! ( \"Offset of field: \" , stringify ! ( RObject ) , \"::\" , stringify ! ( iv ) ) ) ; } impl RObject { # [ inline ] pub fn tt ( & self ) -> mrb_vtype { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_tt ( & mut self , val : mrb_vtype ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn color ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_color ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 3u8 , val as u64 ) } } # [ inline ] pub fn flags ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 21u8 ) as u32 ) } } # [ inline ] pub fn set_flags ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 21u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tt : mrb_vtype , color : u32 , flags : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let tt : u32 = unsafe { :: std :: mem :: transmute ( tt ) } ; tt as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 3u8 , { let color : u32 = unsafe { :: std :: mem :: transmute ( color ) } ; color as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 21u8 , { let flags : u32 = unsafe { :: std :: mem :: transmute ( flags ) } ; flags as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RFiber { pub c : * mut RClass , pub gcnext : * mut RBasic , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub cxt : * mut mrb_context , } # [ test ] fn bindgen_test_layout_RFiber ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RFiber > ( ) , 32usize , concat ! ( \"Size of: \" , stringify ! ( RFiber ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RFiber > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( RFiber ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RFiber > ( ) ) ) . c as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RFiber ) , \"::\" , stringify ! ( c ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RFiber > ( ) ) ) . gcnext as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( RFiber ) , \"::\" , stringify ! ( gcnext ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RFiber > ( ) ) ) . cxt as * const _ as usize } , 24usize , concat ! ( \"Offset of field: \" , stringify ! ( RFiber ) , \"::\" , stringify ! ( cxt ) ) ) ; } impl RFiber { # [ inline ] pub fn tt ( & self ) -> mrb_vtype { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_tt ( & mut self , val : mrb_vtype ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn color ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_color ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 3u8 , val as u64 ) } } # [ inline ] pub fn flags ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 21u8 ) as u32 ) } } # [ inline ] pub fn set_flags ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 21u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tt : mrb_vtype , color : u32 , flags : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let tt : u32 = unsafe { :: std :: mem :: transmute ( tt ) } ; tt as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 3u8 , { let color : u32 = unsafe { :: std :: mem :: transmute ( color ) } ; color as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 21u8 , { let flags : u32 = unsafe { :: std :: mem :: transmute ( flags ) } ; flags as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union mrb_value_union { pub f : mrb_float , pub p : * mut :: std :: os :: raw :: c_void , pub i : mrb_int , pub sym : mrb_sym , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_mrb_value_union ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mrb_value_union > ( ) , 8usize , concat ! ( \"Size of: \" , stringify ! ( mrb_value_union ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mrb_value_union > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( mrb_value_union ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_value_union > ( ) ) ) . f as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_value_union ) , \"::\" , stringify ! ( f ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_value_union > ( ) ) ) . p as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_value_union ) , \"::\" , stringify ! ( p ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_value_union > ( ) ) ) . i as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_value_union ) , \"::\" , stringify ! ( i ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_value_union > ( ) ) ) . sym as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_value_union ) , \"::\" , stringify ! ( sym ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct mrb_value { pub value : mrb_value_union , pub tt : mrb_vtype , } # [ test ] fn bindgen_test_layout_mrb_value ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mrb_value > ( ) , 16usize , concat ! ( \"Size of: \" , stringify ! ( mrb_value ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mrb_value > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( mrb_value ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_value > ( ) ) ) . value as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_value ) , \"::\" , stringify ! ( value ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_value > ( ) ) ) . tt as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_value ) , \"::\" , stringify ! ( tt ) ) ) ; } pub type mrb_each_object_callback = :: std :: option :: Option < unsafe extern \"C\" fn ( mrb : * mut mrb_state , obj : * mut RBasic , data : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; extern \"C\" { pub fn mrb_objspace_each_objects ( mrb : * mut mrb_state , callback : mrb_each_object_callback , data : * mut :: std :: os :: raw :: c_void ) ; } extern \"C\" { pub fn mrb_free_context ( mrb : * mut mrb_state , c : * mut mrb_context ) ; } pub const mrb_gc_state_MRB_GC_STATE_ROOT : mrb_gc_state = 0 ; pub const mrb_gc_state_MRB_GC_STATE_MARK : mrb_gc_state = 1 ; pub const mrb_gc_state_MRB_GC_STATE_SWEEP : mrb_gc_state = 2 ; pub type mrb_gc_state = u32 ; # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct mrb_heap_page { pub freelist : * mut RBasic , pub prev : * mut mrb_heap_page , pub next : * mut mrb_heap_page , pub free_next : * mut mrb_heap_page , pub free_prev : * mut mrb_heap_page , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub objects : __IncompleteArrayField < * mut :: std :: os :: raw :: c_void > , } # [ test ] fn bindgen_test_layout_mrb_heap_page ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mrb_heap_page > ( ) , 48usize , concat ! ( \"Size of: \" , stringify ! ( mrb_heap_page ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mrb_heap_page > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( mrb_heap_page ) ) ) ; } impl mrb_heap_page { # [ inline ] pub fn old ( & self ) -> mrb_bool { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_old ( & mut self , val : mrb_bool ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( old : mrb_bool ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let old : u8 = unsafe { :: std :: mem :: transmute ( old ) } ; old as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mrb_gc { pub heaps : * mut mrb_heap_page , pub sweeps : * mut mrb_heap_page , pub free_heaps : * mut mrb_heap_page , pub live : usize , pub arena : * mut * mut RBasic , pub arena_capa : :: std :: os :: raw :: c_int , pub arena_idx : :: std :: os :: raw :: c_int , pub state : mrb_gc_state , pub current_white_part : :: std :: os :: raw :: c_int , pub gray_list : * mut RBasic , pub atomic_gray_list : * mut RBasic , pub live_after_mark : usize , pub threshold : usize , pub interval_ratio : :: std :: os :: raw :: c_int , pub step_ratio : :: std :: os :: raw :: c_int , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub majorgc_old_threshold : usize , } # [ test ] fn bindgen_test_layout_mrb_gc ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mrb_gc > ( ) , 112usize , concat ! ( \"Size of: \" , stringify ! ( mrb_gc ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mrb_gc > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( mrb_gc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_gc > ( ) ) ) . heaps as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_gc ) , \"::\" , stringify ! ( heaps ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_gc > ( ) ) ) . sweeps as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_gc ) , \"::\" , stringify ! ( sweeps ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_gc > ( ) ) ) . free_heaps as * const _ as usize } , 16usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_gc ) , \"::\" , stringify ! ( free_heaps ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_gc > ( ) ) ) . live as * const _ as usize } , 24usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_gc ) , \"::\" , stringify ! ( live ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_gc > ( ) ) ) . arena as * const _ as usize } , 32usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_gc ) , \"::\" , stringify ! ( arena ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_gc > ( ) ) ) . arena_capa as * const _ as usize } , 40usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_gc ) , \"::\" , stringify ! ( arena_capa ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_gc > ( ) ) ) . arena_idx as * const _ as usize } , 44usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_gc ) , \"::\" , stringify ! ( arena_idx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_gc > ( ) ) ) . state as * const _ as usize } , 48usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_gc ) , \"::\" , stringify ! ( state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_gc > ( ) ) ) . current_white_part as * const _ as usize } , 52usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_gc ) , \"::\" , stringify ! ( current_white_part ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_gc > ( ) ) ) . gray_list as * const _ as usize } , 56usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_gc ) , \"::\" , stringify ! ( gray_list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_gc > ( ) ) ) . atomic_gray_list as * const _ as usize } , 64usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_gc ) , \"::\" , stringify ! ( atomic_gray_list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_gc > ( ) ) ) . live_after_mark as * const _ as usize } , 72usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_gc ) , \"::\" , stringify ! ( live_after_mark ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_gc > ( ) ) ) . threshold as * const _ as usize } , 80usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_gc ) , \"::\" , stringify ! ( threshold ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_gc > ( ) ) ) . interval_ratio as * const _ as usize } , 88usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_gc ) , \"::\" , stringify ! ( interval_ratio ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_gc > ( ) ) ) . step_ratio as * const _ as usize } , 92usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_gc ) , \"::\" , stringify ! ( step_ratio ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_gc > ( ) ) ) . majorgc_old_threshold as * const _ as usize } , 104usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_gc ) , \"::\" , stringify ! ( majorgc_old_threshold ) ) ) ; } impl mrb_gc { # [ inline ] pub fn iterating ( & self ) -> mrb_bool { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_iterating ( & mut self , val : mrb_bool ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn disabled ( & self ) -> mrb_bool { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_disabled ( & mut self , val : mrb_bool ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn full ( & self ) -> mrb_bool { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_full ( & mut self , val : mrb_bool ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn generational ( & self ) -> mrb_bool { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_generational ( & mut self , val : mrb_bool ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn out_of_memory ( & self ) -> mrb_bool { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_out_of_memory ( & mut self , val : mrb_bool ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( iterating : mrb_bool , disabled : mrb_bool , full : mrb_bool , generational : mrb_bool , out_of_memory : mrb_bool ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let iterating : u8 = unsafe { :: std :: mem :: transmute ( iterating ) } ; iterating as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let disabled : u8 = unsafe { :: std :: mem :: transmute ( disabled ) } ; disabled as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let full : u8 = unsafe { :: std :: mem :: transmute ( full ) } ; full as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let generational : u8 = unsafe { :: std :: mem :: transmute ( generational ) } ; generational as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let out_of_memory : u8 = unsafe { :: std :: mem :: transmute ( out_of_memory ) } ; out_of_memory as u64 } ) ; __bindgen_bitfield_unit } } extern \"C\" { pub fn mrb_object_dead_p ( mrb : * mut mrb_state , object : * mut RBasic ) -> mrb_bool ; } pub type mrb_code = u8 ; pub type mrb_aspec = u32 ; pub type mrb_allocf = :: std :: option :: Option < unsafe extern \"C\" fn ( mrb : * mut mrb_state , arg1 : * mut :: std :: os :: raw :: c_void , arg2 : usize , ud : * mut :: std :: os :: raw :: c_void ) -> * mut :: std :: os :: raw :: c_void > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mrb_callinfo { pub mid : mrb_sym , pub proc_ : * mut RProc , pub stackent : * mut mrb_value , pub ridx : u16 , pub epos : u16 , pub env : * mut REnv , pub pc : * const mrb_code , pub err : * const mrb_code , pub argc : :: std :: os :: raw :: c_int , pub acc : :: std :: os :: raw :: c_int , pub target_class : * mut RClass , } # [ test ] fn bindgen_test_layout_mrb_callinfo ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mrb_callinfo > ( ) , 72usize , concat ! ( \"Size of: \" , stringify ! ( mrb_callinfo ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mrb_callinfo > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( mrb_callinfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_callinfo > ( ) ) ) . mid as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_callinfo ) , \"::\" , stringify ! ( mid ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_callinfo > ( ) ) ) . proc_ as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_callinfo ) , \"::\" , stringify ! ( proc_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_callinfo > ( ) ) ) . stackent as * const _ as usize } , 16usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_callinfo ) , \"::\" , stringify ! ( stackent ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_callinfo > ( ) ) ) . ridx as * const _ as usize } , 24usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_callinfo ) , \"::\" , stringify ! ( ridx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_callinfo > ( ) ) ) . epos as * const _ as usize } , 26usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_callinfo ) , \"::\" , stringify ! ( epos ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_callinfo > ( ) ) ) . env as * const _ as usize } , 32usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_callinfo ) , \"::\" , stringify ! ( env ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_callinfo > ( ) ) ) . pc as * const _ as usize } , 40usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_callinfo ) , \"::\" , stringify ! ( pc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_callinfo > ( ) ) ) . err as * const _ as usize } , 48usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_callinfo ) , \"::\" , stringify ! ( err ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_callinfo > ( ) ) ) . argc as * const _ as usize } , 56usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_callinfo ) , \"::\" , stringify ! ( argc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_callinfo > ( ) ) ) . acc as * const _ as usize } , 60usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_callinfo ) , \"::\" , stringify ! ( acc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_callinfo > ( ) ) ) . target_class as * const _ as usize } , 64usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_callinfo ) , \"::\" , stringify ! ( target_class ) ) ) ; } pub const mrb_fiber_state_MRB_FIBER_CREATED : mrb_fiber_state = 0 ; pub const mrb_fiber_state_MRB_FIBER_RUNNING : mrb_fiber_state = 1 ; pub const mrb_fiber_state_MRB_FIBER_RESUMED : mrb_fiber_state = 2 ; pub const mrb_fiber_state_MRB_FIBER_SUSPENDED : mrb_fiber_state = 3 ; pub const mrb_fiber_state_MRB_FIBER_TRANSFERRED : mrb_fiber_state = 4 ; pub const mrb_fiber_state_MRB_FIBER_TERMINATED : mrb_fiber_state = 5 ; pub type mrb_fiber_state = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mrb_context { pub prev : * mut mrb_context , pub stack : * mut mrb_value , pub stbase : * mut mrb_value , pub stend : * mut mrb_value , pub ci : * mut mrb_callinfo , pub cibase : * mut mrb_callinfo , pub ciend : * mut mrb_callinfo , pub rescue : * mut u16 , pub rsize : u16 , pub ensure : * mut * mut RProc , pub esize : u16 , pub eidx : u16 , pub status : mrb_fiber_state , pub vmexec : mrb_bool , pub fib : * mut RFiber , } # [ test ] fn bindgen_test_layout_mrb_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mrb_context > ( ) , 104usize , concat ! ( \"Size of: \" , stringify ! ( mrb_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mrb_context > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( mrb_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_context > ( ) ) ) . prev as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_context ) , \"::\" , stringify ! ( prev ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_context > ( ) ) ) . stack as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_context ) , \"::\" , stringify ! ( stack ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_context > ( ) ) ) . stbase as * const _ as usize } , 16usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_context ) , \"::\" , stringify ! ( stbase ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_context > ( ) ) ) . stend as * const _ as usize } , 24usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_context ) , \"::\" , stringify ! ( stend ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_context > ( ) ) ) . ci as * const _ as usize } , 32usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_context ) , \"::\" , stringify ! ( ci ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_context > ( ) ) ) . cibase as * const _ as usize } , 40usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_context ) , \"::\" , stringify ! ( cibase ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_context > ( ) ) ) . ciend as * const _ as usize } , 48usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_context ) , \"::\" , stringify ! ( ciend ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_context > ( ) ) ) . rescue as * const _ as usize } , 56usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_context ) , \"::\" , stringify ! ( rescue ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_context > ( ) ) ) . rsize as * const _ as usize } , 64usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_context ) , \"::\" , stringify ! ( rsize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_context > ( ) ) ) . ensure as * const _ as usize } , 72usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_context ) , \"::\" , stringify ! ( ensure ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_context > ( ) ) ) . esize as * const _ as usize } , 80usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_context ) , \"::\" , stringify ! ( esize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_context > ( ) ) ) . eidx as * const _ as usize } , 82usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_context ) , \"::\" , stringify ! ( eidx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_context > ( ) ) ) . status as * const _ as usize } , 84usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_context ) , \"::\" , stringify ! ( status ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_context > ( ) ) ) . vmexec as * const _ as usize } , 88usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_context ) , \"::\" , stringify ! ( vmexec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_context > ( ) ) ) . fib as * const _ as usize } , 96usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_context ) , \"::\" , stringify ! ( fib ) ) ) ; } pub type mrb_func_t = :: std :: option :: Option < unsafe extern \"C\" fn ( mrb : * mut mrb_state , self_ : mrb_value ) -> mrb_value > ; pub type mrb_method_t = usize ; pub type mrb_atexit_func = :: std :: option :: Option < unsafe extern \"C\" fn ( arg1 : * mut mrb_state ) > ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct mrb_state { pub jmp : * mut mrb_jmpbuf , pub allocf : mrb_allocf , pub allocf_ud : * mut :: std :: os :: raw :: c_void , pub c : * mut mrb_context , pub root_c : * mut mrb_context , pub globals : * mut iv_tbl , pub exc : * mut RObject , pub top_self : * mut RObject , pub object_class : * mut RClass , pub class_class : * mut RClass , pub module_class : * mut RClass , pub proc_class : * mut RClass , pub string_class : * mut RClass , pub array_class : * mut RClass , pub hash_class : * mut RClass , pub range_class : * mut RClass , pub float_class : * mut RClass , pub fixnum_class : * mut RClass , pub true_class : * mut RClass , pub false_class : * mut RClass , pub nil_class : * mut RClass , pub symbol_class : * mut RClass , pub kernel_module : * mut RClass , pub gc : mrb_gc , pub symidx : mrb_sym , pub symtbl : * mut symbol_name , pub symhash : [ mrb_sym ; 256usize ] , pub symcapa : usize , pub symbuf : [ :: std :: os :: raw :: c_char ; 8usize ] , pub eException_class : * mut RClass , pub eStandardError_class : * mut RClass , pub nomem_err : * mut RObject , pub stack_err : * mut RObject , pub ud : * mut :: std :: os :: raw :: c_void , pub atexit_stack : * mut mrb_atexit_func , pub atexit_stack_len : u16 , pub ecall_nest : u16 , } # [ test ] fn bindgen_test_layout_mrb_state ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mrb_state > ( ) , 1408usize , concat ! ( \"Size of: \" , stringify ! ( mrb_state ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mrb_state > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( mrb_state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . jmp as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( jmp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . allocf as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( allocf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . allocf_ud as * const _ as usize } , 16usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( allocf_ud ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . c as * const _ as usize } , 24usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( c ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . root_c as * const _ as usize } , 32usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( root_c ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . globals as * const _ as usize } , 40usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( globals ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . exc as * const _ as usize } , 48usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( exc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . top_self as * const _ as usize } , 56usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( top_self ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . object_class as * const _ as usize } , 64usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( object_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . class_class as * const _ as usize } , 72usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( class_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . module_class as * const _ as usize } , 80usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( module_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . proc_class as * const _ as usize } , 88usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( proc_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . string_class as * const _ as usize } , 96usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( string_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . array_class as * const _ as usize } , 104usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( array_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . hash_class as * const _ as usize } , 112usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( hash_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . range_class as * const _ as usize } , 120usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( range_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . float_class as * const _ as usize } , 128usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( float_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . fixnum_class as * const _ as usize } , 136usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( fixnum_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . true_class as * const _ as usize } , 144usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( true_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . false_class as * const _ as usize } , 152usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( false_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . nil_class as * const _ as usize } , 160usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( nil_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . symbol_class as * const _ as usize } , 168usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( symbol_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . kernel_module as * const _ as usize } , 176usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( kernel_module ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . gc as * const _ as usize } , 184usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( gc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . symidx as * const _ as usize } , 296usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( symidx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . symtbl as * const _ as usize } , 304usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( symtbl ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . symhash as * const _ as usize } , 312usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( symhash ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . symcapa as * const _ as usize } , 1336usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( symcapa ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . symbuf as * const _ as usize } , 1344usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( symbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . eException_class as * const _ as usize } , 1352usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( eException_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . eStandardError_class as * const _ as usize } , 1360usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( eStandardError_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . nomem_err as * const _ as usize } , 1368usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( nomem_err ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . stack_err as * const _ as usize } , 1376usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( stack_err ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . ud as * const _ as usize } , 1384usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( ud ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . atexit_stack as * const _ as usize } , 1392usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( atexit_stack ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . atexit_stack_len as * const _ as usize } , 1400usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( atexit_stack_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_state > ( ) ) ) . ecall_nest as * const _ as usize } , 1402usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_state ) , \"::\" , stringify ! ( ecall_nest ) ) ) ; } extern \"C\" { pub fn mrb_define_class ( mrb : * mut mrb_state , name : * const :: std :: os :: raw :: c_char , super_ : * mut RClass ) -> * mut RClass ; } extern \"C\" { pub fn mrb_define_module ( mrb : * mut mrb_state , name : * const :: std :: os :: raw :: c_char ) -> * mut RClass ; } extern \"C\" { pub fn mrb_singleton_class ( mrb : * mut mrb_state , val : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_include_module ( mrb : * mut mrb_state , cla : * mut RClass , included : * mut RClass ) ; } extern \"C\" { pub fn mrb_prepend_module ( mrb : * mut mrb_state , cla : * mut RClass , prepended : * mut RClass ) ; } extern \"C\" { pub fn mrb_define_method ( mrb : * mut mrb_state , cla : * mut RClass , name : * const :: std :: os :: raw :: c_char , func : mrb_func_t , aspec : mrb_aspec ) ; } extern \"C\" { pub fn mrb_define_class_method ( mrb : * mut mrb_state , cla : * mut RClass , name : * const :: std :: os :: raw :: c_char , fun : mrb_func_t , aspec : mrb_aspec ) ; } extern \"C\" { pub fn mrb_define_singleton_method ( mrb : * mut mrb_state , cla : * mut RObject , name : * const :: std :: os :: raw :: c_char , fun : mrb_func_t , aspec : mrb_aspec ) ; } extern \"C\" { pub fn mrb_define_module_function ( mrb : * mut mrb_state , cla : * mut RClass , name : * const :: std :: os :: raw :: c_char , fun : mrb_func_t , aspec : mrb_aspec ) ; } extern \"C\" { pub fn mrb_define_const ( mrb : * mut mrb_state , cla : * mut RClass , name : * const :: std :: os :: raw :: c_char , val : mrb_value ) ; } extern \"C\" { pub fn mrb_undef_method ( mrb : * mut mrb_state , cla : * mut RClass , name : * const :: std :: os :: raw :: c_char ) ; } extern \"C\" { pub fn mrb_undef_method_id ( arg1 : * mut mrb_state , arg2 : * mut RClass , arg3 : mrb_sym ) ; } extern \"C\" { pub fn mrb_undef_class_method ( mrb : * mut mrb_state , cls : * mut RClass , name : * const :: std :: os :: raw :: c_char ) ; } extern \"C\" { pub fn mrb_obj_new ( mrb : * mut mrb_state , c : * mut RClass , argc : mrb_int , argv : * const mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_class_new ( mrb : * mut mrb_state , super_ : * mut RClass ) -> * mut RClass ; } extern \"C\" { pub fn mrb_module_new ( mrb : * mut mrb_state ) -> * mut RClass ; } extern \"C\" { pub fn mrb_class_defined ( mrb : * mut mrb_state , name : * const :: std :: os :: raw :: c_char ) -> mrb_bool ; } extern \"C\" { pub fn mrb_class_get ( mrb : * mut mrb_state , name : * const :: std :: os :: raw :: c_char ) -> * mut RClass ; } extern \"C\" { pub fn mrb_exc_get ( mrb : * mut mrb_state , name : * const :: std :: os :: raw :: c_char ) -> * mut RClass ; } extern \"C\" { pub fn mrb_class_defined_under ( mrb : * mut mrb_state , outer : * mut RClass , name : * const :: std :: os :: raw :: c_char ) -> mrb_bool ; } extern \"C\" { pub fn mrb_class_get_under ( mrb : * mut mrb_state , outer : * mut RClass , name : * const :: std :: os :: raw :: c_char ) -> * mut RClass ; } extern \"C\" { pub fn mrb_module_get ( mrb : * mut mrb_state , name : * const :: std :: os :: raw :: c_char ) -> * mut RClass ; } extern \"C\" { pub fn mrb_module_get_under ( mrb : * mut mrb_state , outer : * mut RClass , name : * const :: std :: os :: raw :: c_char ) -> * mut RClass ; } extern \"C\" { pub fn mrb_notimplement ( arg1 : * mut mrb_state ) ; } extern \"C\" { pub fn mrb_notimplement_m ( arg1 : * mut mrb_state , arg2 : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_obj_dup ( mrb : * mut mrb_state , obj : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_obj_respond_to ( mrb : * mut mrb_state , c : * mut RClass , mid : mrb_sym ) -> mrb_bool ; } extern \"C\" { pub fn mrb_define_class_under ( mrb : * mut mrb_state , outer : * mut RClass , name : * const :: std :: os :: raw :: c_char , super_ : * mut RClass ) -> * mut RClass ; } extern \"C\" { pub fn mrb_define_module_under ( mrb : * mut mrb_state , outer : * mut RClass , name : * const :: std :: os :: raw :: c_char ) -> * mut RClass ; } pub type mrb_args_format = * const :: std :: os :: raw :: c_char ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mrb_kwargs { pub num : u32 , pub values : * mut mrb_value , pub table : * const * const :: std :: os :: raw :: c_char , pub required : u32 , pub rest : * mut mrb_value , } # [ test ] fn bindgen_test_layout_mrb_kwargs ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mrb_kwargs > ( ) , 40usize , concat ! ( \"Size of: \" , stringify ! ( mrb_kwargs ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mrb_kwargs > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( mrb_kwargs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_kwargs > ( ) ) ) . num as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_kwargs ) , \"::\" , stringify ! ( num ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_kwargs > ( ) ) ) . values as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_kwargs ) , \"::\" , stringify ! ( values ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_kwargs > ( ) ) ) . table as * const _ as usize } , 16usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_kwargs ) , \"::\" , stringify ! ( table ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_kwargs > ( ) ) ) . required as * const _ as usize } , 24usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_kwargs ) , \"::\" , stringify ! ( required ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_kwargs > ( ) ) ) . rest as * const _ as usize } , 32usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_kwargs ) , \"::\" , stringify ! ( rest ) ) ) ; } extern \"C\" { pub fn mrb_get_args ( mrb : * mut mrb_state , format : mrb_args_format , ... ) -> mrb_int ; } extern \"C\" { pub fn mrb_get_argc ( mrb : * mut mrb_state ) -> mrb_int ; } extern \"C\" { pub fn mrb_get_argv ( mrb : * mut mrb_state ) -> * mut mrb_value ; } extern \"C\" { pub fn mrb_funcall ( mrb : * mut mrb_state , val : mrb_value , name : * const :: std :: os :: raw :: c_char , argc : mrb_int , ... ) -> mrb_value ; } extern \"C\" { pub fn mrb_funcall_argv ( mrb : * mut mrb_state , val : mrb_value , name : mrb_sym , argc : mrb_int , argv : * const mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_funcall_with_block ( mrb : * mut mrb_state , val : mrb_value , name : mrb_sym , argc : mrb_int , argv : * const mrb_value , block : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_intern_cstr ( mrb : * mut mrb_state , str : * const :: std :: os :: raw :: c_char ) -> mrb_sym ; } extern \"C\" { pub fn mrb_intern ( arg1 : * mut mrb_state , arg2 : * const :: std :: os :: raw :: c_char , arg3 : usize ) -> mrb_sym ; } extern \"C\" { pub fn mrb_intern_static ( arg1 : * mut mrb_state , arg2 : * const :: std :: os :: raw :: c_char , arg3 : usize ) -> mrb_sym ; } extern \"C\" { pub fn mrb_intern_str ( arg1 : * mut mrb_state , arg2 : mrb_value ) -> mrb_sym ; } extern \"C\" { pub fn mrb_check_intern_cstr ( arg1 : * mut mrb_state , arg2 : * const :: std :: os :: raw :: c_char ) -> mrb_value ; } extern \"C\" { pub fn mrb_check_intern ( arg1 : * mut mrb_state , arg2 : * const :: std :: os :: raw :: c_char , arg3 : usize ) -> mrb_value ; } extern \"C\" { pub fn mrb_check_intern_str ( arg1 : * mut mrb_state , arg2 : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_sym_name ( arg1 : * mut mrb_state , arg2 : mrb_sym ) -> * const :: std :: os :: raw :: c_char ; } extern \"C\" { pub fn mrb_sym_name_len ( arg1 : * mut mrb_state , arg2 : mrb_sym , arg3 : * mut mrb_int ) -> * const :: std :: os :: raw :: c_char ; } extern \"C\" { pub fn mrb_sym_dump ( arg1 : * mut mrb_state , arg2 : mrb_sym ) -> * const :: std :: os :: raw :: c_char ; } extern \"C\" { pub fn mrb_sym_str ( arg1 : * mut mrb_state , arg2 : mrb_sym ) -> mrb_value ; } extern \"C\" { pub fn mrb_malloc ( arg1 : * mut mrb_state , arg2 : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern \"C\" { pub fn mrb_calloc ( arg1 : * mut mrb_state , arg2 : usize , arg3 : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern \"C\" { pub fn mrb_realloc ( arg1 : * mut mrb_state , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern \"C\" { pub fn mrb_realloc_simple ( arg1 : * mut mrb_state , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern \"C\" { pub fn mrb_malloc_simple ( arg1 : * mut mrb_state , arg2 : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern \"C\" { pub fn mrb_obj_alloc ( arg1 : * mut mrb_state , arg2 : mrb_vtype , arg3 : * mut RClass ) -> * mut RBasic ; } extern \"C\" { pub fn mrb_free ( arg1 : * mut mrb_state , arg2 : * mut :: std :: os :: raw :: c_void ) ; } extern \"C\" { pub fn mrb_str_new ( mrb : * mut mrb_state , p : * const :: std :: os :: raw :: c_char , len : usize ) -> mrb_value ; } extern \"C\" { pub fn mrb_str_new_cstr ( arg1 : * mut mrb_state , arg2 : * const :: std :: os :: raw :: c_char ) -> mrb_value ; } extern \"C\" { pub fn mrb_str_new_static ( mrb : * mut mrb_state , p : * const :: std :: os :: raw :: c_char , len : usize ) -> mrb_value ; } extern \"C\" { pub fn mrb_obj_freeze ( arg1 : * mut mrb_state , arg2 : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_open ( ) -> * mut mrb_state ; } extern \"C\" { pub fn mrb_open_allocf ( f : mrb_allocf , ud : * mut :: std :: os :: raw :: c_void ) -> * mut mrb_state ; } extern \"C\" { pub fn mrb_open_core ( f : mrb_allocf , ud : * mut :: std :: os :: raw :: c_void ) -> * mut mrb_state ; } extern \"C\" { pub fn mrb_close ( mrb : * mut mrb_state ) ; } extern \"C\" { pub fn mrb_default_allocf ( arg1 : * mut mrb_state , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : usize , arg4 : * mut :: std :: os :: raw :: c_void ) -> * mut :: std :: os :: raw :: c_void ; } extern \"C\" { pub fn mrb_top_self ( mrb : * mut mrb_state ) -> mrb_value ; } extern \"C\" { pub fn mrb_run ( mrb : * mut mrb_state , proc_ : * mut RProc , self_ : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_top_run ( mrb : * mut mrb_state , proc_ : * mut RProc , self_ : mrb_value , stack_keep : :: std :: os :: raw :: c_uint ) -> mrb_value ; } extern \"C\" { pub fn mrb_vm_run ( mrb : * mut mrb_state , proc_ : * mut RProc , self_ : mrb_value , stack_keep : :: std :: os :: raw :: c_uint ) -> mrb_value ; } extern \"C\" { pub fn mrb_vm_exec ( mrb : * mut mrb_state , proc_ : * mut RProc , iseq : * const mrb_code ) -> mrb_value ; } extern \"C\" { pub fn mrb_p ( arg1 : * mut mrb_state , arg2 : mrb_value ) ; } extern \"C\" { pub fn mrb_obj_id ( obj : mrb_value ) -> mrb_int ; } extern \"C\" { pub fn mrb_obj_to_sym ( mrb : * mut mrb_state , name : mrb_value ) -> mrb_sym ; } extern \"C\" { pub fn mrb_obj_eq ( mrb : * mut mrb_state , a : mrb_value , b : mrb_value ) -> mrb_bool ; } extern \"C\" { pub fn mrb_obj_equal ( mrb : * mut mrb_state , a : mrb_value , b : mrb_value ) -> mrb_bool ; } extern \"C\" { pub fn mrb_equal ( mrb : * mut mrb_state , obj1 : mrb_value , obj2 : mrb_value ) -> mrb_bool ; } extern \"C\" { pub fn mrb_convert_to_integer ( mrb : * mut mrb_state , val : mrb_value , base : mrb_int ) -> mrb_value ; } extern \"C\" { pub fn mrb_Integer ( mrb : * mut mrb_state , val : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_Float ( mrb : * mut mrb_state , val : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_inspect ( mrb : * mut mrb_state , obj : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_eql ( mrb : * mut mrb_state , obj1 : mrb_value , obj2 : mrb_value ) -> mrb_bool ; } extern \"C\" { pub fn mrb_cmp ( mrb : * mut mrb_state , obj1 : mrb_value , obj2 : mrb_value ) -> mrb_int ; } extern \"C\" { pub fn mrb_garbage_collect ( arg1 : * mut mrb_state ) ; } extern \"C\" { pub fn mrb_full_gc ( arg1 : * mut mrb_state ) ; } extern \"C\" { pub fn mrb_incremental_gc ( arg1 : * mut mrb_state ) ; } extern \"C\" { pub fn mrb_gc_mark ( arg1 : * mut mrb_state , arg2 : * mut RBasic ) ; } extern \"C\" { pub fn mrb_field_write_barrier ( arg1 : * mut mrb_state , arg2 : * mut RBasic , arg3 : * mut RBasic ) ; } extern \"C\" { pub fn mrb_write_barrier ( arg1 : * mut mrb_state , arg2 : * mut RBasic ) ; } extern \"C\" { pub fn mrb_check_convert_type ( mrb : * mut mrb_state , val : mrb_value , type_ : mrb_vtype , tname : * const :: std :: os :: raw :: c_char , method : * const :: std :: os :: raw :: c_char ) -> mrb_value ; } extern \"C\" { pub fn mrb_any_to_s ( mrb : * mut mrb_state , obj : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_obj_classname ( mrb : * mut mrb_state , obj : mrb_value ) -> * const :: std :: os :: raw :: c_char ; } extern \"C\" { pub fn mrb_obj_class ( mrb : * mut mrb_state , obj : mrb_value ) -> * mut RClass ; } extern \"C\" { pub fn mrb_class_path ( mrb : * mut mrb_state , c : * mut RClass ) -> mrb_value ; } extern \"C\" { pub fn mrb_convert_type ( mrb : * mut mrb_state , val : mrb_value , type_ : mrb_vtype , tname : * const :: std :: os :: raw :: c_char , method : * const :: std :: os :: raw :: c_char ) -> mrb_value ; } extern \"C\" { pub fn mrb_obj_is_kind_of ( mrb : * mut mrb_state , obj : mrb_value , c : * mut RClass ) -> mrb_bool ; } extern \"C\" { pub fn mrb_obj_inspect ( mrb : * mut mrb_state , self_ : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_obj_clone ( mrb : * mut mrb_state , self_ : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_exc_new ( mrb : * mut mrb_state , c : * mut RClass , ptr : * const :: std :: os :: raw :: c_char , len : usize ) -> mrb_value ; } extern \"C\" { pub fn mrb_exc_raise ( mrb : * mut mrb_state , exc : mrb_value ) ; } extern \"C\" { pub fn mrb_raise ( mrb : * mut mrb_state , c : * mut RClass , msg : * const :: std :: os :: raw :: c_char ) ; } extern \"C\" { pub fn mrb_raisef ( mrb : * mut mrb_state , c : * mut RClass , fmt : * const :: std :: os :: raw :: c_char , ... ) ; } extern \"C\" { pub fn mrb_name_error ( mrb : * mut mrb_state , id : mrb_sym , fmt : * const :: std :: os :: raw :: c_char , ... ) ; } extern \"C\" { pub fn mrb_frozen_error ( mrb : * mut mrb_state , frozen_obj : * mut :: std :: os :: raw :: c_void ) ; } extern \"C\" { pub fn mrb_warn ( mrb : * mut mrb_state , fmt : * const :: std :: os :: raw :: c_char , ... ) ; } extern \"C\" { pub fn mrb_bug ( mrb : * mut mrb_state , fmt : * const :: std :: os :: raw :: c_char , ... ) ; } extern \"C\" { pub fn mrb_print_backtrace ( mrb : * mut mrb_state ) ; } extern \"C\" { pub fn mrb_print_error ( mrb : * mut mrb_state ) ; } extern \"C\" { pub fn mrb_vformat ( mrb : * mut mrb_state , format : * const :: std :: os :: raw :: c_char , ap : * mut __va_list_tag ) -> mrb_value ; } extern \"C\" { pub fn mrb_yield ( mrb : * mut mrb_state , b : mrb_value , arg : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_yield_argv ( mrb : * mut mrb_state , b : mrb_value , argc : mrb_int , argv : * const mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_yield_with_class ( mrb : * mut mrb_state , b : mrb_value , argc : mrb_int , argv : * const mrb_value , self_ : mrb_value , c : * mut RClass ) -> mrb_value ; } extern \"C\" { pub fn mrb_yield_cont ( mrb : * mut mrb_state , b : mrb_value , self_ : mrb_value , argc : mrb_int , argv : * const mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_gc_protect ( mrb : * mut mrb_state , obj : mrb_value ) ; } extern \"C\" { pub fn mrb_gc_register ( mrb : * mut mrb_state , obj : mrb_value ) ; } extern \"C\" { pub fn mrb_gc_unregister ( mrb : * mut mrb_state , obj : mrb_value ) ; } extern \"C\" { pub fn mrb_to_int ( mrb : * mut mrb_state , val : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_to_str ( mrb : * mut mrb_state , val : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_check_type ( mrb : * mut mrb_state , x : mrb_value , t : mrb_vtype ) ; } extern \"C\" { pub fn mrb_define_alias ( mrb : * mut mrb_state , c : * mut RClass , a : * const :: std :: os :: raw :: c_char , b : * const :: std :: os :: raw :: c_char ) ; } extern \"C\" { pub fn mrb_class_name ( mrb : * mut mrb_state , klass : * mut RClass ) -> * const :: std :: os :: raw :: c_char ; } extern \"C\" { pub fn mrb_define_global_const ( mrb : * mut mrb_state , name : * const :: std :: os :: raw :: c_char , val : mrb_value ) ; } extern \"C\" { pub fn mrb_attr_get ( mrb : * mut mrb_state , obj : mrb_value , id : mrb_sym ) -> mrb_value ; } extern \"C\" { pub fn mrb_respond_to ( mrb : * mut mrb_state , obj : mrb_value , mid : mrb_sym ) -> mrb_bool ; } extern \"C\" { pub fn mrb_obj_is_instance_of ( mrb : * mut mrb_state , obj : mrb_value , c : * mut RClass ) -> mrb_bool ; } extern \"C\" { pub fn mrb_func_basic_p ( mrb : * mut mrb_state , obj : mrb_value , mid : mrb_sym , func : mrb_func_t ) -> mrb_bool ; } extern \"C\" { pub fn mrb_fiber_resume ( mrb : * mut mrb_state , fib : mrb_value , argc : mrb_int , argv : * const mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_fiber_yield ( mrb : * mut mrb_state , argc : mrb_int , argv : * const mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_fiber_alive_p ( mrb : * mut mrb_state , fib : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_stack_extend ( arg1 : * mut mrb_state , arg2 : mrb_int ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mrb_pool { _unused : [ u8 ; 0 ] , } extern \"C\" { pub fn mrb_pool_open ( arg1 : * mut mrb_state ) -> * mut mrb_pool ; } extern \"C\" { pub fn mrb_pool_close ( arg1 : * mut mrb_pool ) ; } extern \"C\" { pub fn mrb_pool_alloc ( arg1 : * mut mrb_pool , arg2 : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern \"C\" { pub fn mrb_pool_realloc ( arg1 : * mut mrb_pool , arg2 : * mut :: std :: os :: raw :: c_void , oldlen : usize , newlen : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern \"C\" { pub fn mrb_pool_can_realloc ( arg1 : * mut mrb_pool , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : usize ) -> mrb_bool ; } extern \"C\" { pub fn mrb_alloca ( mrb : * mut mrb_state , arg1 : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern \"C\" { pub fn mrb_state_atexit ( mrb : * mut mrb_state , func : mrb_atexit_func ) ; } extern \"C\" { pub fn mrb_show_version ( mrb : * mut mrb_state ) ; } extern \"C\" { pub fn mrb_show_copyright ( mrb : * mut mrb_state ) ; } extern \"C\" { pub fn mrb_format ( mrb : * mut mrb_state , format : * const :: std :: os :: raw :: c_char , ... ) -> mrb_value ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mrb_shared_array { pub refcnt : :: std :: os :: raw :: c_int , pub len : mrb_int , pub ptr : * mut mrb_value , } # [ test ] fn bindgen_test_layout_mrb_shared_array ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mrb_shared_array > ( ) , 24usize , concat ! ( \"Size of: \" , stringify ! ( mrb_shared_array ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mrb_shared_array > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( mrb_shared_array ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_shared_array > ( ) ) ) . refcnt as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_shared_array ) , \"::\" , stringify ! ( refcnt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_shared_array > ( ) ) ) . len as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_shared_array ) , \"::\" , stringify ! ( len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_shared_array > ( ) ) ) . ptr as * const _ as usize } , 16usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_shared_array ) , \"::\" , stringify ! ( ptr ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct RArray { pub c : * mut RClass , pub gcnext : * mut RBasic , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub as_ : RArray__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union RArray__bindgen_ty_1 { pub heap : RArray__bindgen_ty_1__bindgen_ty_1 , pub ary : [ * mut :: std :: os :: raw :: c_void ; 3usize ] , _bindgen_union_align : [ u64 ; 3usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct RArray__bindgen_ty_1__bindgen_ty_1 { pub len : mrb_int , pub aux : RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , pub ptr : * mut mrb_value , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { pub capa : mrb_int , pub shared : * mut mrb_shared_array , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( \"Size of: \" , stringify ! ( RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . capa as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) , \"::\" , stringify ! ( capa ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . shared as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) , \"::\" , stringify ! ( shared ) ) ) ; } # [ test ] fn bindgen_test_layout_RArray__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RArray__bindgen_ty_1__bindgen_ty_1 > ( ) , 24usize , concat ! ( \"Size of: \" , stringify ! ( RArray__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RArray__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( RArray__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RArray__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . len as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RArray__bindgen_ty_1__bindgen_ty_1 ) , \"::\" , stringify ! ( len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RArray__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . aux as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( RArray__bindgen_ty_1__bindgen_ty_1 ) , \"::\" , stringify ! ( aux ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RArray__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . ptr as * const _ as usize } , 16usize , concat ! ( \"Offset of field: \" , stringify ! ( RArray__bindgen_ty_1__bindgen_ty_1 ) , \"::\" , stringify ! ( ptr ) ) ) ; } # [ test ] fn bindgen_test_layout_RArray__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RArray__bindgen_ty_1 > ( ) , 24usize , concat ! ( \"Size of: \" , stringify ! ( RArray__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RArray__bindgen_ty_1 > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( RArray__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RArray__bindgen_ty_1 > ( ) ) ) . heap as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RArray__bindgen_ty_1 ) , \"::\" , stringify ! ( heap ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RArray__bindgen_ty_1 > ( ) ) ) . ary as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RArray__bindgen_ty_1 ) , \"::\" , stringify ! ( ary ) ) ) ; } # [ test ] fn bindgen_test_layout_RArray ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RArray > ( ) , 48usize , concat ! ( \"Size of: \" , stringify ! ( RArray ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RArray > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( RArray ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RArray > ( ) ) ) . c as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RArray ) , \"::\" , stringify ! ( c ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RArray > ( ) ) ) . gcnext as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( RArray ) , \"::\" , stringify ! ( gcnext ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RArray > ( ) ) ) . as_ as * const _ as usize } , 24usize , concat ! ( \"Offset of field: \" , stringify ! ( RArray ) , \"::\" , stringify ! ( as_ ) ) ) ; } impl RArray { # [ inline ] pub fn tt ( & self ) -> mrb_vtype { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_tt ( & mut self , val : mrb_vtype ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn color ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_color ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 3u8 , val as u64 ) } } # [ inline ] pub fn flags ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 21u8 ) as u32 ) } } # [ inline ] pub fn set_flags ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 21u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tt : mrb_vtype , color : u32 , flags : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let tt : u32 = unsafe { :: std :: mem :: transmute ( tt ) } ; tt as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 3u8 , { let color : u32 = unsafe { :: std :: mem :: transmute ( color ) } ; color as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 21u8 , { let flags : u32 = unsafe { :: std :: mem :: transmute ( flags ) } ; flags as u64 } ) ; __bindgen_bitfield_unit } } extern \"C\" { pub fn mrb_ary_decref ( arg1 : * mut mrb_state , arg2 : * mut mrb_shared_array ) ; } extern \"C\" { pub fn mrb_ary_modify ( arg1 : * mut mrb_state , arg2 : * mut RArray ) ; } extern \"C\" { pub fn mrb_ary_new_capa ( arg1 : * mut mrb_state , arg2 : mrb_int ) -> mrb_value ; } extern \"C\" { pub fn mrb_ary_new ( mrb : * mut mrb_state ) -> mrb_value ; } extern \"C\" { pub fn mrb_ary_new_from_values ( mrb : * mut mrb_state , size : mrb_int , vals : * const mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_assoc_new ( mrb : * mut mrb_state , car : mrb_value , cdr : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_ary_concat ( mrb : * mut mrb_state , self_ : mrb_value , other : mrb_value ) ; } extern \"C\" { pub fn mrb_ary_splat ( mrb : * mut mrb_state , value : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_ary_push ( mrb : * mut mrb_state , array : mrb_value , value : mrb_value ) ; } extern \"C\" { pub fn mrb_ary_pop ( mrb : * mut mrb_state , ary : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_ary_ref ( mrb : * mut mrb_state , ary : mrb_value , n : mrb_int ) -> mrb_value ; } extern \"C\" { pub fn mrb_ary_set ( mrb : * mut mrb_state , ary : mrb_value , n : mrb_int , val : mrb_value ) ; } extern \"C\" { pub fn mrb_ary_replace ( mrb : * mut mrb_state , self_ : mrb_value , other : mrb_value ) ; } extern \"C\" { pub fn mrb_ensure_array_type ( mrb : * mut mrb_state , self_ : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_check_array_type ( mrb : * mut mrb_state , self_ : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_ary_unshift ( mrb : * mut mrb_state , self_ : mrb_value , item : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_ary_entry ( ary : mrb_value , offset : mrb_int ) -> mrb_value ; } extern \"C\" { pub fn mrb_ary_splice ( mrb : * mut mrb_state , self_ : mrb_value , head : mrb_int , len : mrb_int , rpl : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_ary_shift ( mrb : * mut mrb_state , self_ : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_ary_clear ( mrb : * mut mrb_state , self_ : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_ary_join ( mrb : * mut mrb_state , ary : mrb_value , sep : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_ary_resize ( mrb : * mut mrb_state , ary : mrb_value , new_len : mrb_int ) -> mrb_value ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RClass { pub c : * mut RClass , pub gcnext : * mut RBasic , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub iv : * mut iv_tbl , pub mt : * mut kh_mt , pub super_ : * mut RClass , } # [ test ] fn bindgen_test_layout_RClass ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RClass > ( ) , 48usize , concat ! ( \"Size of: \" , stringify ! ( RClass ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RClass > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( RClass ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RClass > ( ) ) ) . c as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RClass ) , \"::\" , stringify ! ( c ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RClass > ( ) ) ) . gcnext as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( RClass ) , \"::\" , stringify ! ( gcnext ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RClass > ( ) ) ) . iv as * const _ as usize } , 24usize , concat ! ( \"Offset of field: \" , stringify ! ( RClass ) , \"::\" , stringify ! ( iv ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RClass > ( ) ) ) . mt as * const _ as usize } , 32usize , concat ! ( \"Offset of field: \" , stringify ! ( RClass ) , \"::\" , stringify ! ( mt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RClass > ( ) ) ) . super_ as * const _ as usize } , 40usize , concat ! ( \"Offset of field: \" , stringify ! ( RClass ) , \"::\" , stringify ! ( super_ ) ) ) ; } impl RClass { # [ inline ] pub fn tt ( & self ) -> mrb_vtype { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_tt ( & mut self , val : mrb_vtype ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn color ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_color ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 3u8 , val as u64 ) } } # [ inline ] pub fn flags ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 21u8 ) as u32 ) } } # [ inline ] pub fn set_flags ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 21u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tt : mrb_vtype , color : u32 , flags : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let tt : u32 = unsafe { :: std :: mem :: transmute ( tt ) } ; tt as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 3u8 , { let color : u32 = unsafe { :: std :: mem :: transmute ( color ) } ; color as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 21u8 , { let flags : u32 = unsafe { :: std :: mem :: transmute ( flags ) } ; flags as u64 } ) ; __bindgen_bitfield_unit } } extern \"C\" { pub fn mrb_define_class_id ( arg1 : * mut mrb_state , arg2 : mrb_sym , arg3 : * mut RClass ) -> * mut RClass ; } extern \"C\" { pub fn mrb_define_module_id ( arg1 : * mut mrb_state , arg2 : mrb_sym ) -> * mut RClass ; } extern \"C\" { pub fn mrb_vm_define_class ( arg1 : * mut mrb_state , arg2 : mrb_value , arg3 : mrb_value , arg4 : mrb_sym ) -> * mut RClass ; } extern \"C\" { pub fn mrb_vm_define_module ( arg1 : * mut mrb_state , arg2 : mrb_value , arg3 : mrb_sym ) -> * mut RClass ; } extern \"C\" { pub fn mrb_define_method_raw ( arg1 : * mut mrb_state , arg2 : * mut RClass , arg3 : mrb_sym , arg4 : mrb_method_t ) ; } extern \"C\" { pub fn mrb_define_method_id ( mrb : * mut mrb_state , c : * mut RClass , mid : mrb_sym , func : mrb_func_t , aspec : mrb_aspec ) ; } extern \"C\" { pub fn mrb_alias_method ( arg1 : * mut mrb_state , c : * mut RClass , a : mrb_sym , b : mrb_sym ) ; } extern \"C\" { pub fn mrb_method_search_vm ( arg1 : * mut mrb_state , arg2 : * mut * mut RClass , arg3 : mrb_sym ) -> mrb_method_t ; } extern \"C\" { pub fn mrb_method_search ( arg1 : * mut mrb_state , arg2 : * mut RClass , arg3 : mrb_sym ) -> mrb_method_t ; } extern \"C\" { pub fn mrb_class_real ( cl : * mut RClass ) -> * mut RClass ; } extern \"C\" { pub fn mrb_instance_new ( mrb : * mut mrb_state , cv : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_class_name_class ( arg1 : * mut mrb_state , arg2 : * mut RClass , arg3 : * mut RClass , arg4 : mrb_sym ) ; } extern \"C\" { pub fn mrb_const_name_p ( arg1 : * mut mrb_state , arg2 : * const :: std :: os :: raw :: c_char , arg3 : mrb_int ) -> mrb_bool ; } extern \"C\" { pub fn mrb_class_find_path ( arg1 : * mut mrb_state , arg2 : * mut RClass ) -> mrb_value ; } extern \"C\" { pub fn mrb_gc_mark_mt ( arg1 : * mut mrb_state , arg2 : * mut RClass ) ; } extern \"C\" { pub fn mrb_gc_mark_mt_size ( arg1 : * mut mrb_state , arg2 : * mut RClass ) -> usize ; } extern \"C\" { pub fn mrb_gc_free_mt ( arg1 : * mut mrb_state , arg2 : * mut RClass ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mrbc_context { pub syms : * mut mrb_sym , pub slen : :: std :: os :: raw :: c_int , pub filename : * mut :: std :: os :: raw :: c_char , pub lineno : u16 , pub partial_hook : :: std :: option :: Option < unsafe extern \"C\" fn ( arg1 : * mut mrb_parser_state ) -> :: std :: os :: raw :: c_int > , pub partial_data : * mut :: std :: os :: raw :: c_void , pub target_class : * mut RClass , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub parser_nerr : usize , } # [ test ] fn bindgen_test_layout_mrbc_context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mrbc_context > ( ) , 72usize , concat ! ( \"Size of: \" , stringify ! ( mrbc_context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mrbc_context > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( mrbc_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrbc_context > ( ) ) ) . syms as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrbc_context ) , \"::\" , stringify ! ( syms ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrbc_context > ( ) ) ) . slen as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( mrbc_context ) , \"::\" , stringify ! ( slen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrbc_context > ( ) ) ) . filename as * const _ as usize } , 16usize , concat ! ( \"Offset of field: \" , stringify ! ( mrbc_context ) , \"::\" , stringify ! ( filename ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrbc_context > ( ) ) ) . lineno as * const _ as usize } , 24usize , concat ! ( \"Offset of field: \" , stringify ! ( mrbc_context ) , \"::\" , stringify ! ( lineno ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrbc_context > ( ) ) ) . partial_hook as * const _ as usize } , 32usize , concat ! ( \"Offset of field: \" , stringify ! ( mrbc_context ) , \"::\" , stringify ! ( partial_hook ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrbc_context > ( ) ) ) . partial_data as * const _ as usize } , 40usize , concat ! ( \"Offset of field: \" , stringify ! ( mrbc_context ) , \"::\" , stringify ! ( partial_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrbc_context > ( ) ) ) . target_class as * const _ as usize } , 48usize , concat ! ( \"Offset of field: \" , stringify ! ( mrbc_context ) , \"::\" , stringify ! ( target_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrbc_context > ( ) ) ) . parser_nerr as * const _ as usize } , 64usize , concat ! ( \"Offset of field: \" , stringify ! ( mrbc_context ) , \"::\" , stringify ! ( parser_nerr ) ) ) ; } impl mrbc_context { # [ inline ] pub fn capture_errors ( & self ) -> mrb_bool { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_capture_errors ( & mut self , val : mrb_bool ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dump_result ( & self ) -> mrb_bool { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_dump_result ( & mut self , val : mrb_bool ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn no_exec ( & self ) -> mrb_bool { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_no_exec ( & mut self , val : mrb_bool ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn keep_lv ( & self ) -> mrb_bool { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_keep_lv ( & mut self , val : mrb_bool ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn no_optimize ( & self ) -> mrb_bool { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_no_optimize ( & mut self , val : mrb_bool ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn on_eval ( & self ) -> mrb_bool { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_on_eval ( & mut self , val : mrb_bool ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( capture_errors : mrb_bool , dump_result : mrb_bool , no_exec : mrb_bool , keep_lv : mrb_bool , no_optimize : mrb_bool , on_eval : mrb_bool ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let capture_errors : u8 = unsafe { :: std :: mem :: transmute ( capture_errors ) } ; capture_errors as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let dump_result : u8 = unsafe { :: std :: mem :: transmute ( dump_result ) } ; dump_result as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let no_exec : u8 = unsafe { :: std :: mem :: transmute ( no_exec ) } ; no_exec as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let keep_lv : u8 = unsafe { :: std :: mem :: transmute ( keep_lv ) } ; keep_lv as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let no_optimize : u8 = unsafe { :: std :: mem :: transmute ( no_optimize ) } ; no_optimize as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let on_eval : u8 = unsafe { :: std :: mem :: transmute ( on_eval ) } ; on_eval as u64 } ) ; __bindgen_bitfield_unit } } extern \"C\" { pub fn mrbc_context_new ( mrb : * mut mrb_state ) -> * mut mrbc_context ; } extern \"C\" { pub fn mrbc_context_free ( mrb : * mut mrb_state , cxt : * mut mrbc_context ) ; } extern \"C\" { pub fn mrbc_filename ( mrb : * mut mrb_state , c : * mut mrbc_context , s : * const :: std :: os :: raw :: c_char ) -> * const :: std :: os :: raw :: c_char ; } extern \"C\" { pub fn mrbc_partial_hook ( mrb : * mut mrb_state , c : * mut mrbc_context , partial_hook : :: std :: option :: Option < unsafe extern \"C\" fn ( arg1 : * mut mrb_parser_state ) -> :: std :: os :: raw :: c_int > , data : * mut :: std :: os :: raw :: c_void ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mrb_ast_node { pub car : * mut mrb_ast_node , pub cdr : * mut mrb_ast_node , pub lineno : u16 , pub filename_index : u16 , } # [ test ] fn bindgen_test_layout_mrb_ast_node ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mrb_ast_node > ( ) , 24usize , concat ! ( \"Size of: \" , stringify ! ( mrb_ast_node ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mrb_ast_node > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( mrb_ast_node ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_ast_node > ( ) ) ) . car as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_ast_node ) , \"::\" , stringify ! ( car ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_ast_node > ( ) ) ) . cdr as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_ast_node ) , \"::\" , stringify ! ( cdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_ast_node > ( ) ) ) . lineno as * const _ as usize } , 16usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_ast_node ) , \"::\" , stringify ! ( lineno ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_ast_node > ( ) ) ) . filename_index as * const _ as usize } , 18usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_ast_node ) , \"::\" , stringify ! ( filename_index ) ) ) ; } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum mrb_lex_state_enum { EXPR_BEG = 0 , EXPR_END = 1 , EXPR_ENDARG = 2 , EXPR_ENDFN = 3 , EXPR_ARG = 4 , EXPR_CMDARG = 5 , EXPR_MID = 6 , EXPR_FNAME = 7 , EXPR_DOT = 8 , EXPR_CLASS = 9 , EXPR_VALUE = 10 , EXPR_MAX_STATE = 11 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mrb_parser_message { pub lineno : u16 , pub column : :: std :: os :: raw :: c_int , pub message : * mut :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_mrb_parser_message ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mrb_parser_message > ( ) , 16usize , concat ! ( \"Size of: \" , stringify ! ( mrb_parser_message ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mrb_parser_message > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( mrb_parser_message ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_message > ( ) ) ) . lineno as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_message ) , \"::\" , stringify ! ( lineno ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_message > ( ) ) ) . column as * const _ as usize } , 4usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_message ) , \"::\" , stringify ! ( column ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_message > ( ) ) ) . message as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_message ) , \"::\" , stringify ! ( message ) ) ) ; } pub const mrb_string_type_str_not_parsing : mrb_string_type = 0 ; pub const mrb_string_type_str_squote : mrb_string_type = 1 ; pub const mrb_string_type_str_dquote : mrb_string_type = 3 ; pub const mrb_string_type_str_regexp : mrb_string_type = 7 ; pub const mrb_string_type_str_sword : mrb_string_type = 41 ; pub const mrb_string_type_str_dword : mrb_string_type = 43 ; pub const mrb_string_type_str_ssym : mrb_string_type = 17 ; pub const mrb_string_type_str_ssymbols : mrb_string_type = 49 ; pub const mrb_string_type_str_dsymbols : mrb_string_type = 51 ; pub const mrb_string_type_str_heredoc : mrb_string_type = 65 ; pub const mrb_string_type_str_xquote : mrb_string_type = 131 ; pub type mrb_string_type = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mrb_parser_heredoc_info { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub type_ : mrb_string_type , pub term : * const :: std :: os :: raw :: c_char , pub term_len : :: std :: os :: raw :: c_int , pub doc : * mut mrb_ast_node , } # [ test ] fn bindgen_test_layout_mrb_parser_heredoc_info ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mrb_parser_heredoc_info > ( ) , 32usize , concat ! ( \"Size of: \" , stringify ! ( mrb_parser_heredoc_info ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mrb_parser_heredoc_info > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( mrb_parser_heredoc_info ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_heredoc_info > ( ) ) ) . type_ as * const _ as usize } , 4usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_heredoc_info ) , \"::\" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_heredoc_info > ( ) ) ) . term as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_heredoc_info ) , \"::\" , stringify ! ( term ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_heredoc_info > ( ) ) ) . term_len as * const _ as usize } , 16usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_heredoc_info ) , \"::\" , stringify ! ( term_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_heredoc_info > ( ) ) ) . doc as * const _ as usize } , 24usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_heredoc_info ) , \"::\" , stringify ! ( doc ) ) ) ; } impl mrb_parser_heredoc_info { # [ inline ] pub fn allow_indent ( & self ) -> mrb_bool { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_allow_indent ( & mut self , val : mrb_bool ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn line_head ( & self ) -> mrb_bool { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_line_head ( & mut self , val : mrb_bool ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( allow_indent : mrb_bool , line_head : mrb_bool ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let allow_indent : u8 = unsafe { :: std :: mem :: transmute ( allow_indent ) } ; allow_indent as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let line_head : u8 = unsafe { :: std :: mem :: transmute ( line_head ) } ; line_head as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct mrb_parser_state { pub mrb : * mut mrb_state , pub pool : * mut mrb_pool , pub cells : * mut mrb_ast_node , pub s : * const :: std :: os :: raw :: c_char , pub send : * const :: std :: os :: raw :: c_char , pub cxt : * mut mrbc_context , pub filename_sym : mrb_sym , pub lineno : u16 , pub column : :: std :: os :: raw :: c_int , pub lstate : mrb_lex_state_enum , pub lex_strterm : * mut mrb_ast_node , pub cond_stack : :: std :: os :: raw :: c_uint , pub cmdarg_stack : :: std :: os :: raw :: c_uint , pub paren_nest : :: std :: os :: raw :: c_int , pub lpar_beg : :: std :: os :: raw :: c_int , pub in_def : :: std :: os :: raw :: c_int , pub in_single : :: std :: os :: raw :: c_int , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub locals : * mut mrb_ast_node , pub pb : * mut mrb_ast_node , pub tokbuf : * mut :: std :: os :: raw :: c_char , pub buf : [ :: std :: os :: raw :: c_char ; 256usize ] , pub tidx : :: std :: os :: raw :: c_int , pub tsiz : :: std :: os :: raw :: c_int , pub all_heredocs : * mut mrb_ast_node , pub heredocs_from_nextline : * mut mrb_ast_node , pub parsing_heredoc : * mut mrb_ast_node , pub lex_strterm_before_heredoc : * mut mrb_ast_node , pub ylval : * mut :: std :: os :: raw :: c_void , pub nerr : usize , pub nwarn : usize , pub tree : * mut mrb_ast_node , pub _bitfield_2 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub error_buffer : [ mrb_parser_message ; 10usize ] , pub warn_buffer : [ mrb_parser_message ; 10usize ] , pub filename_table : * mut mrb_sym , pub filename_table_length : u16 , pub current_filename_index : u16 , pub jmp : * mut mrb_jmpbuf , } # [ test ] fn bindgen_test_layout_mrb_parser_state ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mrb_parser_state > ( ) , 808usize , concat ! ( \"Size of: \" , stringify ! ( mrb_parser_state ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mrb_parser_state > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( mrb_parser_state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . mrb as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( mrb ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . pool as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( pool ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . cells as * const _ as usize } , 16usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( cells ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . s as * const _ as usize } , 24usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . send as * const _ as usize } , 32usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( send ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . cxt as * const _ as usize } , 40usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( cxt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . filename_sym as * const _ as usize } , 48usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( filename_sym ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . lineno as * const _ as usize } , 52usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( lineno ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . column as * const _ as usize } , 56usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( column ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . lstate as * const _ as usize } , 60usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( lstate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . lex_strterm as * const _ as usize } , 64usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( lex_strterm ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . cond_stack as * const _ as usize } , 72usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( cond_stack ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . cmdarg_stack as * const _ as usize } , 76usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( cmdarg_stack ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . paren_nest as * const _ as usize } , 80usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( paren_nest ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . lpar_beg as * const _ as usize } , 84usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( lpar_beg ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . in_def as * const _ as usize } , 88usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( in_def ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . in_single as * const _ as usize } , 92usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( in_single ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . locals as * const _ as usize } , 104usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( locals ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . pb as * const _ as usize } , 112usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( pb ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . tokbuf as * const _ as usize } , 120usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( tokbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . buf as * const _ as usize } , 128usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . tidx as * const _ as usize } , 384usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( tidx ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . tsiz as * const _ as usize } , 388usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( tsiz ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . all_heredocs as * const _ as usize } , 392usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( all_heredocs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . heredocs_from_nextline as * const _ as usize } , 400usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( heredocs_from_nextline ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . parsing_heredoc as * const _ as usize } , 408usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( parsing_heredoc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . lex_strterm_before_heredoc as * const _ as usize } , 416usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( lex_strterm_before_heredoc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . ylval as * const _ as usize } , 424usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( ylval ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . nerr as * const _ as usize } , 432usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( nerr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . nwarn as * const _ as usize } , 440usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( nwarn ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . tree as * const _ as usize } , 448usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( tree ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . error_buffer as * const _ as usize } , 464usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( error_buffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . warn_buffer as * const _ as usize } , 624usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( warn_buffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . filename_table as * const _ as usize } , 784usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( filename_table ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . filename_table_length as * const _ as usize } , 792usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( filename_table_length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . current_filename_index as * const _ as usize } , 794usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( current_filename_index ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_parser_state > ( ) ) ) . jmp as * const _ as usize } , 800usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_parser_state ) , \"::\" , stringify ! ( jmp ) ) ) ; } impl mrb_parser_state { # [ inline ] pub fn cmd_start ( & self ) -> mrb_bool { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_cmd_start ( & mut self , val : mrb_bool ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( cmd_start : mrb_bool ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let cmd_start : u8 = unsafe { :: std :: mem :: transmute ( cmd_start ) } ; cmd_start as u64 } ) ; __bindgen_bitfield_unit } # [ inline ] pub fn no_optimize ( & self ) -> mrb_bool { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_no_optimize ( & mut self , val : mrb_bool ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn on_eval ( & self ) -> mrb_bool { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_on_eval ( & mut self , val : mrb_bool ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn capture_errors ( & self ) -> mrb_bool { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_capture_errors ( & mut self , val : mrb_bool ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_2 ( no_optimize : mrb_bool , on_eval : mrb_bool , capture_errors : mrb_bool ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let no_optimize : u8 = unsafe { :: std :: mem :: transmute ( no_optimize ) } ; no_optimize as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let on_eval : u8 = unsafe { :: std :: mem :: transmute ( on_eval ) } ; on_eval as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let capture_errors : u8 = unsafe { :: std :: mem :: transmute ( capture_errors ) } ; capture_errors as u64 } ) ; __bindgen_bitfield_unit } } extern \"C\" { pub fn mrb_parser_new ( arg1 : * mut mrb_state ) -> * mut mrb_parser_state ; } extern \"C\" { pub fn mrb_parser_free ( arg1 : * mut mrb_parser_state ) ; } extern \"C\" { pub fn mrb_parser_parse ( arg1 : * mut mrb_parser_state , arg2 : * mut mrbc_context ) ; } extern \"C\" { pub fn mrb_parser_set_filename ( arg1 : * mut mrb_parser_state , arg2 : * const :: std :: os :: raw :: c_char ) ; } extern \"C\" { pub fn mrb_parser_get_filename ( arg1 : * mut mrb_parser_state , idx : u16 ) -> mrb_sym ; } extern \"C\" { pub fn mrb_parse_string ( arg1 : * mut mrb_state , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut mrbc_context ) -> * mut mrb_parser_state ; } extern \"C\" { pub fn mrb_parse_nstring ( arg1 : * mut mrb_state , arg2 : * const :: std :: os :: raw :: c_char , arg3 : usize , arg4 : * mut mrbc_context ) -> * mut mrb_parser_state ; } extern \"C\" { pub fn mrb_generate_code ( arg1 : * mut mrb_state , arg2 : * mut mrb_parser_state ) -> * mut RProc ; } extern \"C\" { pub fn mrb_load_exec ( mrb : * mut mrb_state , p : * mut mrb_parser_state , c : * mut mrbc_context ) -> mrb_value ; } extern \"C\" { pub fn mrb_load_string ( mrb : * mut mrb_state , s : * const :: std :: os :: raw :: c_char ) -> mrb_value ; } extern \"C\" { pub fn mrb_load_nstring ( mrb : * mut mrb_state , s : * const :: std :: os :: raw :: c_char , len : usize ) -> mrb_value ; } extern \"C\" { pub fn mrb_load_string_cxt ( mrb : * mut mrb_state , s : * const :: std :: os :: raw :: c_char , cxt : * mut mrbc_context ) -> mrb_value ; } extern \"C\" { pub fn mrb_load_nstring_cxt ( mrb : * mut mrb_state , s : * const :: std :: os :: raw :: c_char , len : usize , cxt : * mut mrbc_context ) -> mrb_value ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mrb_data_type { pub struct_name : * const :: std :: os :: raw :: c_char , pub dfree : :: std :: option :: Option < unsafe extern \"C\" fn ( mrb : * mut mrb_state , arg1 : * mut :: std :: os :: raw :: c_void ) > , } # [ test ] fn bindgen_test_layout_mrb_data_type ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mrb_data_type > ( ) , 16usize , concat ! ( \"Size of: \" , stringify ! ( mrb_data_type ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mrb_data_type > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( mrb_data_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_data_type > ( ) ) ) . struct_name as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_data_type ) , \"::\" , stringify ! ( struct_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_data_type > ( ) ) ) . dfree as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_data_type ) , \"::\" , stringify ! ( dfree ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RData { pub c : * mut RClass , pub gcnext : * mut RBasic , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub iv : * mut iv_tbl , pub type_ : * const mrb_data_type , pub data : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_RData ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RData > ( ) , 48usize , concat ! ( \"Size of: \" , stringify ! ( RData ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RData > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( RData ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RData > ( ) ) ) . c as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RData ) , \"::\" , stringify ! ( c ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RData > ( ) ) ) . gcnext as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( RData ) , \"::\" , stringify ! ( gcnext ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RData > ( ) ) ) . iv as * const _ as usize } , 24usize , concat ! ( \"Offset of field: \" , stringify ! ( RData ) , \"::\" , stringify ! ( iv ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RData > ( ) ) ) . type_ as * const _ as usize } , 32usize , concat ! ( \"Offset of field: \" , stringify ! ( RData ) , \"::\" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RData > ( ) ) ) . data as * const _ as usize } , 40usize , concat ! ( \"Offset of field: \" , stringify ! ( RData ) , \"::\" , stringify ! ( data ) ) ) ; } impl RData { # [ inline ] pub fn tt ( & self ) -> mrb_vtype { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_tt ( & mut self , val : mrb_vtype ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn color ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_color ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 3u8 , val as u64 ) } } # [ inline ] pub fn flags ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 21u8 ) as u32 ) } } # [ inline ] pub fn set_flags ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 21u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tt : mrb_vtype , color : u32 , flags : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let tt : u32 = unsafe { :: std :: mem :: transmute ( tt ) } ; tt as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 3u8 , { let color : u32 = unsafe { :: std :: mem :: transmute ( color ) } ; color as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 21u8 , { let flags : u32 = unsafe { :: std :: mem :: transmute ( flags ) } ; flags as u64 } ) ; __bindgen_bitfield_unit } } extern \"C\" { pub fn mrb_data_object_alloc ( mrb : * mut mrb_state , klass : * mut RClass , datap : * mut :: std :: os :: raw :: c_void , type_ : * const mrb_data_type ) -> * mut RData ; } extern \"C\" { pub fn mrb_data_check_type ( mrb : * mut mrb_state , arg1 : mrb_value , arg2 : * const mrb_data_type ) ; } extern \"C\" { pub fn mrb_data_get_ptr ( mrb : * mut mrb_state , arg1 : mrb_value , arg2 : * const mrb_data_type ) -> * mut :: std :: os :: raw :: c_void ; } extern \"C\" { pub fn mrb_data_check_get_ptr ( mrb : * mut mrb_state , arg1 : mrb_value , arg2 : * const mrb_data_type ) -> * mut :: std :: os :: raw :: c_void ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mrb_locals { pub name : mrb_sym , pub r : u16 , } # [ test ] fn bindgen_test_layout_mrb_locals ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mrb_locals > ( ) , 8usize , concat ! ( \"Size of: \" , stringify ! ( mrb_locals ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mrb_locals > ( ) , 4usize , concat ! ( \"Alignment of \" , stringify ! ( mrb_locals ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_locals > ( ) ) ) . name as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_locals ) , \"::\" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_locals > ( ) ) ) . r as * const _ as usize } , 4usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_locals ) , \"::\" , stringify ! ( r ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mrb_irep { pub nlocals : u16 , pub nregs : u16 , pub flags : u8 , pub iseq : * const mrb_code , pub pool : * mut mrb_value , pub syms : * mut mrb_sym , pub reps : * mut * mut mrb_irep , pub lv : * mut mrb_locals , pub debug_info : * mut mrb_irep_debug_info , pub ilen : u16 , pub plen : u16 , pub slen : u16 , pub rlen : u16 , pub refcnt : u32 , } # [ test ] fn bindgen_test_layout_mrb_irep ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mrb_irep > ( ) , 72usize , concat ! ( \"Size of: \" , stringify ! ( mrb_irep ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mrb_irep > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( mrb_irep ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_irep > ( ) ) ) . nlocals as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_irep ) , \"::\" , stringify ! ( nlocals ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_irep > ( ) ) ) . nregs as * const _ as usize } , 2usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_irep ) , \"::\" , stringify ! ( nregs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_irep > ( ) ) ) . flags as * const _ as usize } , 4usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_irep ) , \"::\" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_irep > ( ) ) ) . iseq as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_irep ) , \"::\" , stringify ! ( iseq ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_irep > ( ) ) ) . pool as * const _ as usize } , 16usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_irep ) , \"::\" , stringify ! ( pool ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_irep > ( ) ) ) . syms as * const _ as usize } , 24usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_irep ) , \"::\" , stringify ! ( syms ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_irep > ( ) ) ) . reps as * const _ as usize } , 32usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_irep ) , \"::\" , stringify ! ( reps ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_irep > ( ) ) ) . lv as * const _ as usize } , 40usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_irep ) , \"::\" , stringify ! ( lv ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_irep > ( ) ) ) . debug_info as * const _ as usize } , 48usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_irep ) , \"::\" , stringify ! ( debug_info ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_irep > ( ) ) ) . ilen as * const _ as usize } , 56usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_irep ) , \"::\" , stringify ! ( ilen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_irep > ( ) ) ) . plen as * const _ as usize } , 58usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_irep ) , \"::\" , stringify ! ( plen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_irep > ( ) ) ) . slen as * const _ as usize } , 60usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_irep ) , \"::\" , stringify ! ( slen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_irep > ( ) ) ) . rlen as * const _ as usize } , 62usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_irep ) , \"::\" , stringify ! ( rlen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_irep > ( ) ) ) . refcnt as * const _ as usize } , 64usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_irep ) , \"::\" , stringify ! ( refcnt ) ) ) ; } extern \"C\" { pub fn mrb_add_irep ( mrb : * mut mrb_state ) -> * mut mrb_irep ; } extern \"C\" { pub fn mrb_load_irep ( arg1 : * mut mrb_state , arg2 : * const u8 ) -> mrb_value ; } extern \"C\" { pub fn mrb_load_irep_buf ( arg1 : * mut mrb_state , arg2 : * const :: std :: os :: raw :: c_void , arg3 : usize ) -> mrb_value ; } extern \"C\" { pub fn mrb_load_irep_cxt ( arg1 : * mut mrb_state , arg2 : * const u8 , arg3 : * mut mrbc_context ) -> mrb_value ; } extern \"C\" { pub fn mrb_load_irep_buf_cxt ( arg1 : * mut mrb_state , arg2 : * const :: std :: os :: raw :: c_void , arg3 : usize , arg4 : * mut mrbc_context ) -> mrb_value ; } extern \"C\" { pub fn mrb_irep_free ( arg1 : * mut mrb_state , arg2 : * mut mrb_irep ) ; } extern \"C\" { pub fn mrb_irep_incref ( arg1 : * mut mrb_state , arg2 : * mut mrb_irep ) ; } extern \"C\" { pub fn mrb_irep_decref ( arg1 : * mut mrb_state , arg2 : * mut mrb_irep ) ; } extern \"C\" { pub fn mrb_irep_cutref ( arg1 : * mut mrb_state , arg2 : * mut mrb_irep ) ; } extern \"C\" { pub fn mrb_irep_remove_lv ( mrb : * mut mrb_state , irep : * mut mrb_irep ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mrb_insn_data { pub insn : u8 , pub a : u16 , pub b : u16 , pub c : u8 , } # [ test ] fn bindgen_test_layout_mrb_insn_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mrb_insn_data > ( ) , 8usize , concat ! ( \"Size of: \" , stringify ! ( mrb_insn_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mrb_insn_data > ( ) , 2usize , concat ! ( \"Alignment of \" , stringify ! ( mrb_insn_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_insn_data > ( ) ) ) . insn as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_insn_data ) , \"::\" , stringify ! ( insn ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_insn_data > ( ) ) ) . a as * const _ as usize } , 2usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_insn_data ) , \"::\" , stringify ! ( a ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_insn_data > ( ) ) ) . b as * const _ as usize } , 4usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_insn_data ) , \"::\" , stringify ! ( b ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_insn_data > ( ) ) ) . c as * const _ as usize } , 6usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_insn_data ) , \"::\" , stringify ! ( c ) ) ) ; } extern \"C\" { pub fn mrb_decode_insn ( pc : * const mrb_code ) -> mrb_insn_data ; } extern \"C\" { pub fn mrb_dump_irep ( mrb : * mut mrb_state , irep : * mut mrb_irep , flags : u8 , bin : * mut * mut u8 , bin_size : * mut usize ) -> :: std :: os :: raw :: c_int ; } extern \"C\" { pub fn mrb_read_irep ( arg1 : * mut mrb_state , arg2 : * const u8 ) -> * mut mrb_irep ; } extern \"C\" { pub fn mrb_read_irep_buf ( arg1 : * mut mrb_state , arg2 : * const :: std :: os :: raw :: c_void , arg3 : usize ) -> * mut mrb_irep ; } extern \"C\" { pub fn mrb_sys_fail ( mrb : * mut mrb_state , mesg : * const :: std :: os :: raw :: c_char ) ; } extern \"C\" { pub fn mrb_exc_new_str ( mrb : * mut mrb_state , c : * mut RClass , str : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_make_exception ( mrb : * mut mrb_state , argc : mrb_int , argv : * const mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_exc_backtrace ( mrb : * mut mrb_state , exc : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_get_backtrace ( mrb : * mut mrb_state ) -> mrb_value ; } extern \"C\" { pub fn mrb_no_method_error ( mrb : * mut mrb_state , id : mrb_sym , args : mrb_value , fmt : * const :: std :: os :: raw :: c_char , ... ) ; } extern \"C\" { pub fn mrb_f_raise ( arg1 : * mut mrb_state , arg2 : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_protect ( mrb : * mut mrb_state , body : mrb_func_t , data : mrb_value , state : * mut mrb_bool ) -> mrb_value ; } extern \"C\" { pub fn mrb_ensure ( mrb : * mut mrb_state , body : mrb_func_t , b_data : mrb_value , ensure : mrb_func_t , e_data : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_rescue ( mrb : * mut mrb_state , body : mrb_func_t , b_data : mrb_value , rescue : mrb_func_t , r_data : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_rescue_exceptions ( mrb : * mut mrb_state , body : mrb_func_t , b_data : mrb_value , rescue : mrb_func_t , r_data : mrb_value , len : mrb_int , classes : * mut * mut RClass ) -> mrb_value ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RHash { pub c : * mut RClass , pub gcnext : * mut RBasic , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub iv : * mut iv_tbl , pub ht : * mut htable , } # [ test ] fn bindgen_test_layout_RHash ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RHash > ( ) , 40usize , concat ! ( \"Size of: \" , stringify ! ( RHash ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RHash > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( RHash ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RHash > ( ) ) ) . c as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RHash ) , \"::\" , stringify ! ( c ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RHash > ( ) ) ) . gcnext as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( RHash ) , \"::\" , stringify ! ( gcnext ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RHash > ( ) ) ) . iv as * const _ as usize } , 24usize , concat ! ( \"Offset of field: \" , stringify ! ( RHash ) , \"::\" , stringify ! ( iv ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RHash > ( ) ) ) . ht as * const _ as usize } , 32usize , concat ! ( \"Offset of field: \" , stringify ! ( RHash ) , \"::\" , stringify ! ( ht ) ) ) ; } impl RHash { # [ inline ] pub fn tt ( & self ) -> mrb_vtype { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_tt ( & mut self , val : mrb_vtype ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn color ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_color ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 3u8 , val as u64 ) } } # [ inline ] pub fn flags ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 21u8 ) as u32 ) } } # [ inline ] pub fn set_flags ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 21u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tt : mrb_vtype , color : u32 , flags : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let tt : u32 = unsafe { :: std :: mem :: transmute ( tt ) } ; tt as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 3u8 , { let color : u32 = unsafe { :: std :: mem :: transmute ( color ) } ; color as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 21u8 , { let flags : u32 = unsafe { :: std :: mem :: transmute ( flags ) } ; flags as u64 } ) ; __bindgen_bitfield_unit } } extern \"C\" { pub fn mrb_hash_new_capa ( mrb : * mut mrb_state , capa : mrb_int ) -> mrb_value ; } extern \"C\" { pub fn mrb_ensure_hash_type ( mrb : * mut mrb_state , hash : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_check_hash_type ( mrb : * mut mrb_state , hash : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_hash_new ( mrb : * mut mrb_state ) -> mrb_value ; } extern \"C\" { pub fn mrb_hash_set ( mrb : * mut mrb_state , hash : mrb_value , key : mrb_value , val : mrb_value ) ; } extern \"C\" { pub fn mrb_hash_get ( mrb : * mut mrb_state , hash : mrb_value , key : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_hash_fetch ( mrb : * mut mrb_state , hash : mrb_value , key : mrb_value , def : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_hash_delete_key ( mrb : * mut mrb_state , hash : mrb_value , key : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_hash_keys ( mrb : * mut mrb_state , hash : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_hash_key_p ( mrb : * mut mrb_state , hash : mrb_value , key : mrb_value ) -> mrb_bool ; } extern \"C\" { pub fn mrb_hash_empty_p ( mrb : * mut mrb_state , self_ : mrb_value ) -> mrb_bool ; } extern \"C\" { pub fn mrb_hash_values ( mrb : * mut mrb_state , hash : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_hash_clear ( mrb : * mut mrb_state , hash : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_hash_size ( mrb : * mut mrb_state , hash : mrb_value ) -> mrb_int ; } extern \"C\" { pub fn mrb_hash_dup ( mrb : * mut mrb_state , hash : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_hash_merge ( mrb : * mut mrb_state , hash1 : mrb_value , hash2 : mrb_value ) ; } extern \"C\" { pub fn mrb_gc_mark_hash ( arg1 : * mut mrb_state , arg2 : * mut RHash ) ; } extern \"C\" { pub fn mrb_gc_mark_hash_size ( arg1 : * mut mrb_state , arg2 : * mut RHash ) -> usize ; } extern \"C\" { pub fn mrb_gc_free_hash ( arg1 : * mut mrb_state , arg2 : * mut RHash ) ; } pub type mrb_hash_foreach_func = :: std :: option :: Option < unsafe extern \"C\" fn ( mrb : * mut mrb_state , key : mrb_value , val : mrb_value , data : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; extern \"C\" { pub fn mrb_hash_foreach ( mrb : * mut mrb_state , hash : * mut RHash , func : mrb_hash_foreach_func , p : * mut :: std :: os :: raw :: c_void ) ; } pub type khint_t = u32 ; extern \"C\" { pub fn mrb_flo_to_fixnum ( mrb : * mut mrb_state , val : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_fixnum_to_str ( mrb : * mut mrb_state , x : mrb_value , base : mrb_int ) -> mrb_value ; } extern \"C\" { pub fn mrb_float_to_str ( mrb : * mut mrb_state , x : mrb_value , fmt : * const :: std :: os :: raw :: c_char ) -> mrb_value ; } extern \"C\" { pub fn mrb_to_flo ( mrb : * mut mrb_state , x : mrb_value ) -> mrb_float ; } extern \"C\" { pub fn mrb_int_value ( mrb : * mut mrb_state , f : mrb_float ) -> mrb_value ; } extern \"C\" { pub fn mrb_num_plus ( mrb : * mut mrb_state , x : mrb_value , y : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_num_minus ( mrb : * mut mrb_state , x : mrb_value , y : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_num_mul ( mrb : * mut mrb_state , x : mrb_value , y : mrb_value ) -> mrb_value ; } pub const mrb_insn_OP_NOP : mrb_insn = 0 ; pub const mrb_insn_OP_MOVE : mrb_insn = 1 ; pub const mrb_insn_OP_LOADL : mrb_insn = 2 ; pub const mrb_insn_OP_LOADI : mrb_insn = 3 ; pub const mrb_insn_OP_LOADINEG : mrb_insn = 4 ; pub const mrb_insn_OP_LOADI__1 : mrb_insn = 5 ; pub const mrb_insn_OP_LOADI_0 : mrb_insn = 6 ; pub const mrb_insn_OP_LOADI_1 : mrb_insn = 7 ; pub const mrb_insn_OP_LOADI_2 : mrb_insn = 8 ; pub const mrb_insn_OP_LOADI_3 : mrb_insn = 9 ; pub const mrb_insn_OP_LOADI_4 : mrb_insn = 10 ; pub const mrb_insn_OP_LOADI_5 : mrb_insn = 11 ; pub const mrb_insn_OP_LOADI_6 : mrb_insn = 12 ; pub const mrb_insn_OP_LOADI_7 : mrb_insn = 13 ; pub const mrb_insn_OP_LOADSYM : mrb_insn = 14 ; pub const mrb_insn_OP_LOADNIL : mrb_insn = 15 ; pub const mrb_insn_OP_LOADSELF : mrb_insn = 16 ; pub const mrb_insn_OP_LOADT : mrb_insn = 17 ; pub const mrb_insn_OP_LOADF : mrb_insn = 18 ; pub const mrb_insn_OP_GETGV : mrb_insn = 19 ; pub const mrb_insn_OP_SETGV : mrb_insn = 20 ; pub const mrb_insn_OP_GETSV : mrb_insn = 21 ; pub const mrb_insn_OP_SETSV : mrb_insn = 22 ; pub const mrb_insn_OP_GETIV : mrb_insn = 23 ; pub const mrb_insn_OP_SETIV : mrb_insn = 24 ; pub const mrb_insn_OP_GETCV : mrb_insn = 25 ; pub const mrb_insn_OP_SETCV : mrb_insn = 26 ; pub const mrb_insn_OP_GETCONST : mrb_insn = 27 ; pub const mrb_insn_OP_SETCONST : mrb_insn = 28 ; pub const mrb_insn_OP_GETMCNST : mrb_insn = 29 ; pub const mrb_insn_OP_SETMCNST : mrb_insn = 30 ; pub const mrb_insn_OP_GETUPVAR : mrb_insn = 31 ; pub const mrb_insn_OP_SETUPVAR : mrb_insn = 32 ; pub const mrb_insn_OP_JMP : mrb_insn = 33 ; pub const mrb_insn_OP_JMPIF : mrb_insn = 34 ; pub const mrb_insn_OP_JMPNOT : mrb_insn = 35 ; pub const mrb_insn_OP_JMPNIL : mrb_insn = 36 ; pub const mrb_insn_OP_ONERR : mrb_insn = 37 ; pub const mrb_insn_OP_EXCEPT : mrb_insn = 38 ; pub const mrb_insn_OP_RESCUE : mrb_insn = 39 ; pub const mrb_insn_OP_POPERR : mrb_insn = 40 ; pub const mrb_insn_OP_RAISE : mrb_insn = 41 ; pub const mrb_insn_OP_EPUSH : mrb_insn = 42 ; pub const mrb_insn_OP_EPOP : mrb_insn = 43 ; pub const mrb_insn_OP_SENDV : mrb_insn = 44 ; pub const mrb_insn_OP_SENDVB : mrb_insn = 45 ; pub const mrb_insn_OP_SEND : mrb_insn = 46 ; pub const mrb_insn_OP_SENDB : mrb_insn = 47 ; pub const mrb_insn_OP_CALL : mrb_insn = 48 ; pub const mrb_insn_OP_SUPER : mrb_insn = 49 ; pub const mrb_insn_OP_ARGARY : mrb_insn = 50 ; pub const mrb_insn_OP_ENTER : mrb_insn = 51 ; pub const mrb_insn_OP_KEY_P : mrb_insn = 52 ; pub const mrb_insn_OP_KEYEND : mrb_insn = 53 ; pub const mrb_insn_OP_KARG : mrb_insn = 54 ; pub const mrb_insn_OP_RETURN : mrb_insn = 55 ; pub const mrb_insn_OP_RETURN_BLK : mrb_insn = 56 ; pub const mrb_insn_OP_BREAK : mrb_insn = 57 ; pub const mrb_insn_OP_BLKPUSH : mrb_insn = 58 ; pub const mrb_insn_OP_ADD : mrb_insn = 59 ; pub const mrb_insn_OP_ADDI : mrb_insn = 60 ; pub const mrb_insn_OP_SUB : mrb_insn = 61 ; pub const mrb_insn_OP_SUBI : mrb_insn = 62 ; pub const mrb_insn_OP_MUL : mrb_insn = 63 ; pub const mrb_insn_OP_DIV : mrb_insn = 64 ; pub const mrb_insn_OP_EQ : mrb_insn = 65 ; pub const mrb_insn_OP_LT : mrb_insn = 66 ; pub const mrb_insn_OP_LE : mrb_insn = 67 ; pub const mrb_insn_OP_GT : mrb_insn = 68 ; pub const mrb_insn_OP_GE : mrb_insn = 69 ; pub const mrb_insn_OP_ARRAY : mrb_insn = 70 ; pub const mrb_insn_OP_ARRAY2 : mrb_insn = 71 ; pub const mrb_insn_OP_ARYCAT : mrb_insn = 72 ; pub const mrb_insn_OP_ARYPUSH : mrb_insn = 73 ; pub const mrb_insn_OP_ARYDUP : mrb_insn = 74 ; pub const mrb_insn_OP_AREF : mrb_insn = 75 ; pub const mrb_insn_OP_ASET : mrb_insn = 76 ; pub const mrb_insn_OP_APOST : mrb_insn = 77 ; pub const mrb_insn_OP_INTERN : mrb_insn = 78 ; pub const mrb_insn_OP_STRING : mrb_insn = 79 ; pub const mrb_insn_OP_STRCAT : mrb_insn = 80 ; pub const mrb_insn_OP_HASH : mrb_insn = 81 ; pub const mrb_insn_OP_HASHADD : mrb_insn = 82 ; pub const mrb_insn_OP_HASHCAT : mrb_insn = 83 ; pub const mrb_insn_OP_LAMBDA : mrb_insn = 84 ; pub const mrb_insn_OP_BLOCK : mrb_insn = 85 ; pub const mrb_insn_OP_METHOD : mrb_insn = 86 ; pub const mrb_insn_OP_RANGE_INC : mrb_insn = 87 ; pub const mrb_insn_OP_RANGE_EXC : mrb_insn = 88 ; pub const mrb_insn_OP_OCLASS : mrb_insn = 89 ; pub const mrb_insn_OP_CLASS : mrb_insn = 90 ; pub const mrb_insn_OP_MODULE : mrb_insn = 91 ; pub const mrb_insn_OP_EXEC : mrb_insn = 92 ; pub const mrb_insn_OP_DEF : mrb_insn = 93 ; pub const mrb_insn_OP_ALIAS : mrb_insn = 94 ; pub const mrb_insn_OP_UNDEF : mrb_insn = 95 ; pub const mrb_insn_OP_SCLASS : mrb_insn = 96 ; pub const mrb_insn_OP_TCLASS : mrb_insn = 97 ; pub const mrb_insn_OP_DEBUG : mrb_insn = 98 ; pub const mrb_insn_OP_ERR : mrb_insn = 99 ; pub const mrb_insn_OP_EXT1 : mrb_insn = 100 ; pub const mrb_insn_OP_EXT2 : mrb_insn = 101 ; pub const mrb_insn_OP_EXT3 : mrb_insn = 102 ; pub const mrb_insn_OP_STOP : mrb_insn = 103 ; pub type mrb_insn = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct REnv { pub c : * mut RClass , pub gcnext : * mut RBasic , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub stack : * mut mrb_value , pub cxt : * mut mrb_context , pub mid : mrb_sym , } # [ test ] fn bindgen_test_layout_REnv ( ) { assert_eq ! ( :: std :: mem :: size_of :: < REnv > ( ) , 48usize , concat ! ( \"Size of: \" , stringify ! ( REnv ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < REnv > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( REnv ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < REnv > ( ) ) ) . c as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( REnv ) , \"::\" , stringify ! ( c ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < REnv > ( ) ) ) . gcnext as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( REnv ) , \"::\" , stringify ! ( gcnext ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < REnv > ( ) ) ) . stack as * const _ as usize } , 24usize , concat ! ( \"Offset of field: \" , stringify ! ( REnv ) , \"::\" , stringify ! ( stack ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < REnv > ( ) ) ) . cxt as * const _ as usize } , 32usize , concat ! ( \"Offset of field: \" , stringify ! ( REnv ) , \"::\" , stringify ! ( cxt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < REnv > ( ) ) ) . mid as * const _ as usize } , 40usize , concat ! ( \"Offset of field: \" , stringify ! ( REnv ) , \"::\" , stringify ! ( mid ) ) ) ; } impl REnv { # [ inline ] pub fn tt ( & self ) -> mrb_vtype { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_tt ( & mut self , val : mrb_vtype ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn color ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_color ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 3u8 , val as u64 ) } } # [ inline ] pub fn flags ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 21u8 ) as u32 ) } } # [ inline ] pub fn set_flags ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 21u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tt : mrb_vtype , color : u32 , flags : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let tt : u32 = unsafe { :: std :: mem :: transmute ( tt ) } ; tt as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 3u8 , { let color : u32 = unsafe { :: std :: mem :: transmute ( color ) } ; color as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 21u8 , { let flags : u32 = unsafe { :: std :: mem :: transmute ( flags ) } ; flags as u64 } ) ; __bindgen_bitfield_unit } } extern \"C\" { pub fn mrb_env_unshare ( arg1 : * mut mrb_state , arg2 : * mut REnv ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct RProc { pub c : * mut RClass , pub gcnext : * mut RBasic , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub body : RProc__bindgen_ty_1 , pub upper : * mut RProc , pub e : RProc__bindgen_ty_2 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union RProc__bindgen_ty_1 { pub irep : * mut mrb_irep , pub func : mrb_func_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_RProc__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RProc__bindgen_ty_1 > ( ) , 8usize , concat ! ( \"Size of: \" , stringify ! ( RProc__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RProc__bindgen_ty_1 > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( RProc__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RProc__bindgen_ty_1 > ( ) ) ) . irep as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RProc__bindgen_ty_1 ) , \"::\" , stringify ! ( irep ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RProc__bindgen_ty_1 > ( ) ) ) . func as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RProc__bindgen_ty_1 ) , \"::\" , stringify ! ( func ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union RProc__bindgen_ty_2 { pub target_class : * mut RClass , pub env : * mut REnv , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_RProc__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RProc__bindgen_ty_2 > ( ) , 8usize , concat ! ( \"Size of: \" , stringify ! ( RProc__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RProc__bindgen_ty_2 > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( RProc__bindgen_ty_2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RProc__bindgen_ty_2 > ( ) ) ) . target_class as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RProc__bindgen_ty_2 ) , \"::\" , stringify ! ( target_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RProc__bindgen_ty_2 > ( ) ) ) . env as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RProc__bindgen_ty_2 ) , \"::\" , stringify ! ( env ) ) ) ; } # [ test ] fn bindgen_test_layout_RProc ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RProc > ( ) , 48usize , concat ! ( \"Size of: \" , stringify ! ( RProc ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RProc > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( RProc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RProc > ( ) ) ) . c as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RProc ) , \"::\" , stringify ! ( c ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RProc > ( ) ) ) . gcnext as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( RProc ) , \"::\" , stringify ! ( gcnext ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RProc > ( ) ) ) . body as * const _ as usize } , 24usize , concat ! ( \"Offset of field: \" , stringify ! ( RProc ) , \"::\" , stringify ! ( body ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RProc > ( ) ) ) . upper as * const _ as usize } , 32usize , concat ! ( \"Offset of field: \" , stringify ! ( RProc ) , \"::\" , stringify ! ( upper ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RProc > ( ) ) ) . e as * const _ as usize } , 40usize , concat ! ( \"Offset of field: \" , stringify ! ( RProc ) , \"::\" , stringify ! ( e ) ) ) ; } impl RProc { # [ inline ] pub fn tt ( & self ) -> mrb_vtype { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_tt ( & mut self , val : mrb_vtype ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn color ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_color ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 3u8 , val as u64 ) } } # [ inline ] pub fn flags ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 21u8 ) as u32 ) } } # [ inline ] pub fn set_flags ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 21u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tt : mrb_vtype , color : u32 , flags : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let tt : u32 = unsafe { :: std :: mem :: transmute ( tt ) } ; tt as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 3u8 , { let color : u32 = unsafe { :: std :: mem :: transmute ( color ) } ; color as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 21u8 , { let flags : u32 = unsafe { :: std :: mem :: transmute ( flags ) } ; flags as u64 } ) ; __bindgen_bitfield_unit } } extern \"C\" { pub fn mrb_proc_new ( arg1 : * mut mrb_state , arg2 : * mut mrb_irep ) -> * mut RProc ; } extern \"C\" { pub fn mrb_closure_new ( arg1 : * mut mrb_state , arg2 : * mut mrb_irep ) -> * mut RProc ; } extern \"C\" { pub fn mrb_proc_new_cfunc ( arg1 : * mut mrb_state , arg2 : mrb_func_t ) -> * mut RProc ; } extern \"C\" { pub fn mrb_closure_new_cfunc ( mrb : * mut mrb_state , func : mrb_func_t , nlocals : :: std :: os :: raw :: c_int ) -> * mut RProc ; } extern \"C\" { pub fn mrb_proc_copy ( a : * mut RProc , b : * mut RProc ) ; } extern \"C\" { pub fn mrb_proc_arity ( p : * const RProc ) -> mrb_int ; } extern \"C\" { pub fn mrb_f_send ( mrb : * mut mrb_state , self_ : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_proc_new_cfunc_with_env ( mrb : * mut mrb_state , func : mrb_func_t , argc : mrb_int , argv : * const mrb_value ) -> * mut RProc ; } extern \"C\" { pub fn mrb_proc_cfunc_env_get ( mrb : * mut mrb_state , idx : mrb_int ) -> mrb_value ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct kh_mt { pub n_buckets : khint_t , pub size : khint_t , pub n_occupied : khint_t , pub ed_flags : * mut u8 , pub keys : * mut mrb_sym , pub vals : * mut mrb_method_t , } # [ test ] fn bindgen_test_layout_kh_mt ( ) { assert_eq ! ( :: std :: mem :: size_of :: < kh_mt > ( ) , 40usize , concat ! ( \"Size of: \" , stringify ! ( kh_mt ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < kh_mt > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( kh_mt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < kh_mt > ( ) ) ) . n_buckets as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( kh_mt ) , \"::\" , stringify ! ( n_buckets ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < kh_mt > ( ) ) ) . size as * const _ as usize } , 4usize , concat ! ( \"Offset of field: \" , stringify ! ( kh_mt ) , \"::\" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < kh_mt > ( ) ) ) . n_occupied as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( kh_mt ) , \"::\" , stringify ! ( n_occupied ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < kh_mt > ( ) ) ) . ed_flags as * const _ as usize } , 16usize , concat ! ( \"Offset of field: \" , stringify ! ( kh_mt ) , \"::\" , stringify ! ( ed_flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < kh_mt > ( ) ) ) . keys as * const _ as usize } , 24usize , concat ! ( \"Offset of field: \" , stringify ! ( kh_mt ) , \"::\" , stringify ! ( keys ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < kh_mt > ( ) ) ) . vals as * const _ as usize } , 32usize , concat ! ( \"Offset of field: \" , stringify ! ( kh_mt ) , \"::\" , stringify ! ( vals ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct mrb_range_edges { pub beg : mrb_value , pub end : mrb_value , } # [ test ] fn bindgen_test_layout_mrb_range_edges ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mrb_range_edges > ( ) , 32usize , concat ! ( \"Size of: \" , stringify ! ( mrb_range_edges ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mrb_range_edges > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( mrb_range_edges ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_range_edges > ( ) ) ) . beg as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_range_edges ) , \"::\" , stringify ! ( beg ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_range_edges > ( ) ) ) . end as * const _ as usize } , 16usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_range_edges ) , \"::\" , stringify ! ( end ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RRange { pub c : * mut RClass , pub gcnext : * mut RBasic , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub edges : * mut mrb_range_edges , pub excl : mrb_bool , } # [ test ] fn bindgen_test_layout_RRange ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RRange > ( ) , 40usize , concat ! ( \"Size of: \" , stringify ! ( RRange ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RRange > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( RRange ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RRange > ( ) ) ) . c as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RRange ) , \"::\" , stringify ! ( c ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RRange > ( ) ) ) . gcnext as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( RRange ) , \"::\" , stringify ! ( gcnext ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RRange > ( ) ) ) . edges as * const _ as usize } , 24usize , concat ! ( \"Offset of field: \" , stringify ! ( RRange ) , \"::\" , stringify ! ( edges ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RRange > ( ) ) ) . excl as * const _ as usize } , 32usize , concat ! ( \"Offset of field: \" , stringify ! ( RRange ) , \"::\" , stringify ! ( excl ) ) ) ; } impl RRange { # [ inline ] pub fn tt ( & self ) -> mrb_vtype { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_tt ( & mut self , val : mrb_vtype ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn color ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_color ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 3u8 , val as u64 ) } } # [ inline ] pub fn flags ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 21u8 ) as u32 ) } } # [ inline ] pub fn set_flags ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 21u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tt : mrb_vtype , color : u32 , flags : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let tt : u32 = unsafe { :: std :: mem :: transmute ( tt ) } ; tt as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 3u8 , { let color : u32 = unsafe { :: std :: mem :: transmute ( color ) } ; color as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 21u8 , { let flags : u32 = unsafe { :: std :: mem :: transmute ( flags ) } ; flags as u64 } ) ; __bindgen_bitfield_unit } } extern \"C\" { pub fn mrb_range_ptr ( mrb : * mut mrb_state , range : mrb_value ) -> * mut RRange ; } extern \"C\" { pub fn mrb_range_new ( mrb : * mut mrb_state , start : mrb_value , end : mrb_value , exclude : mrb_bool ) -> mrb_value ; } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum mrb_range_beg_len { MRB_RANGE_TYPE_MISMATCH = 0 , MRB_RANGE_OK = 1 , MRB_RANGE_OUT = 2 , } extern \"C\" { pub fn mrb_range_beg_len ( mrb : * mut mrb_state , range : mrb_value , begp : * mut mrb_int , lenp : * mut mrb_int , len : mrb_int , trunc : mrb_bool ) -> mrb_range_beg_len ; } extern \"C\" { pub fn mrb_get_values_at ( mrb : * mut mrb_state , obj : mrb_value , olen : mrb_int , argc : mrb_int , argv : * const mrb_value , func : :: std :: option :: Option < unsafe extern \"C\" fn ( arg1 : * mut mrb_state , arg2 : mrb_value , arg3 : mrb_int ) -> mrb_value > ) -> mrb_value ; } extern \"C\" { pub fn mrb_gc_mark_range ( mrb : * mut mrb_state , r : * mut RRange ) ; } extern \"C\" { pub static mut mrb_digitmap : [ :: std :: os :: raw :: c_char ; 0usize ] ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct RString { pub c : * mut RClass , pub gcnext : * mut RBasic , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub as_ : RString__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union RString__bindgen_ty_1 { pub heap : RString__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : [ u64 ; 3usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct RString__bindgen_ty_1__bindgen_ty_1 { pub len : mrb_int , pub aux : RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , pub ptr : * mut :: std :: os :: raw :: c_char , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { pub capa : mrb_int , pub shared : * mut mrb_shared_string , pub fshared : * mut RString , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( \"Size of: \" , stringify ! ( RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . capa as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) , \"::\" , stringify ! ( capa ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . shared as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) , \"::\" , stringify ! ( shared ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . fshared as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) , \"::\" , stringify ! ( fshared ) ) ) ; } # [ test ] fn bindgen_test_layout_RString__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RString__bindgen_ty_1__bindgen_ty_1 > ( ) , 24usize , concat ! ( \"Size of: \" , stringify ! ( RString__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RString__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( RString__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RString__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . len as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RString__bindgen_ty_1__bindgen_ty_1 ) , \"::\" , stringify ! ( len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RString__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . aux as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( RString__bindgen_ty_1__bindgen_ty_1 ) , \"::\" , stringify ! ( aux ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RString__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . ptr as * const _ as usize } , 16usize , concat ! ( \"Offset of field: \" , stringify ! ( RString__bindgen_ty_1__bindgen_ty_1 ) , \"::\" , stringify ! ( ptr ) ) ) ; } # [ test ] fn bindgen_test_layout_RString__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RString__bindgen_ty_1 > ( ) , 24usize , concat ! ( \"Size of: \" , stringify ! ( RString__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RString__bindgen_ty_1 > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( RString__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RString__bindgen_ty_1 > ( ) ) ) . heap as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RString__bindgen_ty_1 ) , \"::\" , stringify ! ( heap ) ) ) ; } # [ test ] fn bindgen_test_layout_RString ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RString > ( ) , 48usize , concat ! ( \"Size of: \" , stringify ! ( RString ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RString > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( RString ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RString > ( ) ) ) . c as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( RString ) , \"::\" , stringify ! ( c ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RString > ( ) ) ) . gcnext as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( RString ) , \"::\" , stringify ! ( gcnext ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RString > ( ) ) ) . as_ as * const _ as usize } , 24usize , concat ! ( \"Offset of field: \" , stringify ! ( RString ) , \"::\" , stringify ! ( as_ ) ) ) ; } impl RString { # [ inline ] pub fn tt ( & self ) -> mrb_vtype { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_tt ( & mut self , val : mrb_vtype ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn color ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_color ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 3u8 , val as u64 ) } } # [ inline ] pub fn flags ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 21u8 ) as u32 ) } } # [ inline ] pub fn set_flags ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 21u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tt : mrb_vtype , color : u32 , flags : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let tt : u32 = unsafe { :: std :: mem :: transmute ( tt ) } ; tt as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 3u8 , { let color : u32 = unsafe { :: std :: mem :: transmute ( color ) } ; color as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 21u8 , { let flags : u32 = unsafe { :: std :: mem :: transmute ( flags ) } ; flags as u64 } ) ; __bindgen_bitfield_unit } } extern \"C\" { pub fn mrb_str_strlen ( arg1 : * mut mrb_state , arg2 : * mut RString ) -> mrb_int ; } extern \"C\" { pub fn mrb_gc_free_str ( arg1 : * mut mrb_state , arg2 : * mut RString ) ; } extern \"C\" { pub fn mrb_str_modify ( mrb : * mut mrb_state , s : * mut RString ) ; } extern \"C\" { pub fn mrb_str_modify_keep_ascii ( mrb : * mut mrb_state , s : * mut RString ) ; } extern \"C\" { pub fn mrb_str_index ( mrb : * mut mrb_state , str : mrb_value , p : * const :: std :: os :: raw :: c_char , len : mrb_int , offset : mrb_int ) -> mrb_int ; } extern \"C\" { pub fn mrb_str_concat ( mrb : * mut mrb_state , self_ : mrb_value , other : mrb_value ) ; } extern \"C\" { pub fn mrb_str_plus ( mrb : * mut mrb_state , a : mrb_value , b : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_ptr_to_str ( mrb : * mut mrb_state , p : * mut :: std :: os :: raw :: c_void ) -> mrb_value ; } extern \"C\" { pub fn mrb_obj_as_string ( mrb : * mut mrb_state , obj : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_str_resize ( mrb : * mut mrb_state , str : mrb_value , len : mrb_int ) -> mrb_value ; } extern \"C\" { pub fn mrb_str_substr ( mrb : * mut mrb_state , str : mrb_value , beg : mrb_int , len : mrb_int ) -> mrb_value ; } extern \"C\" { pub fn mrb_ensure_string_type ( mrb : * mut mrb_state , str : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_check_string_type ( mrb : * mut mrb_state , str : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_string_type ( mrb : * mut mrb_state , str : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_str_new_capa ( mrb : * mut mrb_state , capa : usize ) -> mrb_value ; } extern \"C\" { pub fn mrb_str_buf_new ( mrb : * mut mrb_state , capa : usize ) -> mrb_value ; } extern \"C\" { pub fn mrb_string_cstr ( mrb : * mut mrb_state , str : mrb_value ) -> * const :: std :: os :: raw :: c_char ; } extern \"C\" { pub fn mrb_string_value_cstr ( mrb : * mut mrb_state , str : * mut mrb_value ) -> * const :: std :: os :: raw :: c_char ; } extern \"C\" { pub fn mrb_string_value_ptr ( mrb : * mut mrb_state , str : mrb_value ) -> * const :: std :: os :: raw :: c_char ; } extern \"C\" { pub fn mrb_string_value_len ( mrb : * mut mrb_state , str : mrb_value ) -> mrb_int ; } extern \"C\" { pub fn mrb_str_dup ( mrb : * mut mrb_state , str : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_str_intern ( mrb : * mut mrb_state , self_ : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_str_to_inum ( mrb : * mut mrb_state , str : mrb_value , base : mrb_int , badcheck : mrb_bool ) -> mrb_value ; } extern \"C\" { pub fn mrb_cstr_to_inum ( mrb : * mut mrb_state , s : * const :: std :: os :: raw :: c_char , base : mrb_int , badcheck : mrb_bool ) -> mrb_value ; } extern \"C\" { pub fn mrb_str_to_dbl ( mrb : * mut mrb_state , str : mrb_value , badcheck : mrb_bool ) -> f64 ; } extern \"C\" { pub fn mrb_cstr_to_dbl ( mrb : * mut mrb_state , s : * const :: std :: os :: raw :: c_char , badcheck : mrb_bool ) -> f64 ; } extern \"C\" { pub fn mrb_str_to_str ( mrb : * mut mrb_state , str : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_str_equal ( mrb : * mut mrb_state , str1 : mrb_value , str2 : mrb_value ) -> mrb_bool ; } extern \"C\" { pub fn mrb_str_cat ( mrb : * mut mrb_state , str : mrb_value , ptr : * const :: std :: os :: raw :: c_char , len : usize ) -> mrb_value ; } extern \"C\" { pub fn mrb_str_cat_cstr ( mrb : * mut mrb_state , str : mrb_value , ptr : * const :: std :: os :: raw :: c_char ) -> mrb_value ; } extern \"C\" { pub fn mrb_str_cat_str ( mrb : * mut mrb_state , str : mrb_value , str2 : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_str_append ( mrb : * mut mrb_state , str : mrb_value , str2 : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_str_cmp ( mrb : * mut mrb_state , str1 : mrb_value , str2 : mrb_value ) -> :: std :: os :: raw :: c_int ; } extern \"C\" { pub fn mrb_str_to_cstr ( mrb : * mut mrb_state , str : mrb_value ) -> * mut :: std :: os :: raw :: c_char ; } extern \"C\" { pub fn mrb_str_pool ( mrb : * mut mrb_state , str : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_str_hash ( mrb : * mut mrb_state , str : mrb_value ) -> u32 ; } extern \"C\" { pub fn mrb_str_dump ( mrb : * mut mrb_state , str : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_str_inspect ( mrb : * mut mrb_state , str : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_str_beg_len ( str_len : mrb_int , begp : * mut mrb_int , lenp : * mut mrb_int ) -> mrb_bool ; } extern \"C\" { pub fn mrb_str_byte_subseq ( mrb : * mut mrb_state , str : mrb_value , beg : mrb_int , len : mrb_int ) -> mrb_value ; } extern \"C\" { pub fn mrb_utf8_len ( str : * const :: std :: os :: raw :: c_char , byte_len : mrb_int ) -> mrb_int ; } pub type jmp_buf = [ :: std :: os :: raw :: c_int ; 37usize ] ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct mrb_jmpbuf { pub impl_ : jmp_buf , } # [ test ] fn bindgen_test_layout_mrb_jmpbuf ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mrb_jmpbuf > ( ) , 148usize , concat ! ( \"Size of: \" , stringify ! ( mrb_jmpbuf ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mrb_jmpbuf > ( ) , 4usize , concat ! ( \"Alignment of \" , stringify ! ( mrb_jmpbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < mrb_jmpbuf > ( ) ) ) . impl_ as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( mrb_jmpbuf ) , \"::\" , stringify ! ( impl_ ) ) ) ; } extern \"C\" { pub fn mrb_vm_special_get ( arg1 : * mut mrb_state , arg2 : mrb_sym ) -> mrb_value ; } extern \"C\" { pub fn mrb_vm_special_set ( arg1 : * mut mrb_state , arg2 : mrb_sym , arg3 : mrb_value ) ; } extern \"C\" { pub fn mrb_vm_cv_get ( arg1 : * mut mrb_state , arg2 : mrb_sym ) -> mrb_value ; } extern \"C\" { pub fn mrb_vm_cv_set ( arg1 : * mut mrb_state , arg2 : mrb_sym , arg3 : mrb_value ) ; } extern \"C\" { pub fn mrb_vm_const_get ( arg1 : * mut mrb_state , arg2 : mrb_sym ) -> mrb_value ; } extern \"C\" { pub fn mrb_vm_const_set ( arg1 : * mut mrb_state , arg2 : mrb_sym , arg3 : mrb_value ) ; } extern \"C\" { pub fn mrb_const_get ( arg1 : * mut mrb_state , arg2 : mrb_value , arg3 : mrb_sym ) -> mrb_value ; } extern \"C\" { pub fn mrb_const_set ( arg1 : * mut mrb_state , arg2 : mrb_value , arg3 : mrb_sym , arg4 : mrb_value ) ; } extern \"C\" { pub fn mrb_const_defined ( arg1 : * mut mrb_state , arg2 : mrb_value , arg3 : mrb_sym ) -> mrb_bool ; } extern \"C\" { pub fn mrb_const_remove ( arg1 : * mut mrb_state , arg2 : mrb_value , arg3 : mrb_sym ) ; } extern \"C\" { pub fn mrb_iv_name_sym_p ( mrb : * mut mrb_state , sym : mrb_sym ) -> mrb_bool ; } extern \"C\" { pub fn mrb_iv_name_sym_check ( mrb : * mut mrb_state , sym : mrb_sym ) ; } extern \"C\" { pub fn mrb_obj_iv_get ( mrb : * mut mrb_state , obj : * mut RObject , sym : mrb_sym ) -> mrb_value ; } extern \"C\" { pub fn mrb_obj_iv_set ( mrb : * mut mrb_state , obj : * mut RObject , sym : mrb_sym , v : mrb_value ) ; } extern \"C\" { pub fn mrb_obj_iv_defined ( mrb : * mut mrb_state , obj : * mut RObject , sym : mrb_sym ) -> mrb_bool ; } extern \"C\" { pub fn mrb_iv_get ( mrb : * mut mrb_state , obj : mrb_value , sym : mrb_sym ) -> mrb_value ; } extern \"C\" { pub fn mrb_iv_set ( mrb : * mut mrb_state , obj : mrb_value , sym : mrb_sym , v : mrb_value ) ; } extern \"C\" { pub fn mrb_iv_defined ( arg1 : * mut mrb_state , arg2 : mrb_value , arg3 : mrb_sym ) -> mrb_bool ; } extern \"C\" { pub fn mrb_iv_remove ( mrb : * mut mrb_state , obj : mrb_value , sym : mrb_sym ) -> mrb_value ; } extern \"C\" { pub fn mrb_iv_copy ( mrb : * mut mrb_state , dst : mrb_value , src : mrb_value ) ; } extern \"C\" { pub fn mrb_const_defined_at ( mrb : * mut mrb_state , mod_ : mrb_value , id : mrb_sym ) -> mrb_bool ; } extern \"C\" { pub fn mrb_gv_get ( mrb : * mut mrb_state , sym : mrb_sym ) -> mrb_value ; } extern \"C\" { pub fn mrb_gv_set ( mrb : * mut mrb_state , sym : mrb_sym , val : mrb_value ) ; } extern \"C\" { pub fn mrb_gv_remove ( mrb : * mut mrb_state , sym : mrb_sym ) ; } extern \"C\" { pub fn mrb_cv_get ( mrb : * mut mrb_state , mod_ : mrb_value , sym : mrb_sym ) -> mrb_value ; } extern \"C\" { pub fn mrb_mod_cv_set ( mrb : * mut mrb_state , c : * mut RClass , sym : mrb_sym , v : mrb_value ) ; } extern \"C\" { pub fn mrb_cv_set ( mrb : * mut mrb_state , mod_ : mrb_value , sym : mrb_sym , v : mrb_value ) ; } extern \"C\" { pub fn mrb_cv_defined ( mrb : * mut mrb_state , mod_ : mrb_value , sym : mrb_sym ) -> mrb_bool ; } extern \"C\" { pub fn mrb_obj_iv_inspect ( arg1 : * mut mrb_state , arg2 : * mut RObject ) -> mrb_value ; } extern \"C\" { pub fn mrb_obj_iv_set_force ( mrb : * mut mrb_state , obj : * mut RObject , sym : mrb_sym , v : mrb_value ) ; } extern \"C\" { pub fn mrb_mod_constants ( mrb : * mut mrb_state , mod_ : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_f_global_variables ( mrb : * mut mrb_state , self_ : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_obj_instance_variables ( arg1 : * mut mrb_state , arg2 : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_mod_class_variables ( arg1 : * mut mrb_state , arg2 : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_mod_cv_get ( mrb : * mut mrb_state , c : * mut RClass , sym : mrb_sym ) -> mrb_value ; } extern \"C\" { pub fn mrb_mod_cv_defined ( mrb : * mut mrb_state , c : * mut RClass , sym : mrb_sym ) -> mrb_bool ; } extern \"C\" { pub fn mrb_ident_p ( s : * const :: std :: os :: raw :: c_char , len : mrb_int ) -> mrb_bool ; } extern \"C\" { pub fn mrb_gc_mark_gv ( arg1 : * mut mrb_state ) ; } extern \"C\" { pub fn mrb_gc_free_gv ( arg1 : * mut mrb_state ) ; } extern \"C\" { pub fn mrb_gc_mark_iv ( arg1 : * mut mrb_state , arg2 : * mut RObject ) ; } extern \"C\" { pub fn mrb_gc_mark_iv_size ( arg1 : * mut mrb_state , arg2 : * mut RObject ) -> usize ; } extern \"C\" { pub fn mrb_gc_free_iv ( arg1 : * mut mrb_state , arg2 : * mut RObject ) ; } pub type mrb_iv_foreach_func = :: std :: option :: Option < unsafe extern \"C\" fn ( arg1 : * mut mrb_state , arg2 : mrb_sym , arg3 : mrb_value , arg4 : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; extern \"C\" { pub fn mrb_iv_foreach ( mrb : * mut mrb_state , obj : mrb_value , func : mrb_iv_foreach_func , p : * mut :: std :: os :: raw :: c_void ) ; } extern \"C\" { pub fn mrb_sys_value_is_nil ( value : mrb_value ) -> bool ; } extern \"C\" { pub fn mrb_sys_value_is_false ( value : mrb_value ) -> bool ; } extern \"C\" { pub fn mrb_sys_value_is_true ( value : mrb_value ) -> bool ; } extern \"C\" { pub fn mrb_sys_range_excl ( mrb : * mut mrb_state , value : mrb_value ) -> bool ; } extern \"C\" { pub fn mrb_sys_obj_frozen ( mrb : * mut mrb_state , value : mrb_value ) -> bool ; } extern \"C\" { pub fn mrb_sys_fixnum_to_cint ( value : mrb_value ) -> mrb_int ; } extern \"C\" { pub fn mrb_sys_float_to_cdouble ( value : mrb_value ) -> mrb_float ; } extern \"C\" { pub fn mrb_sys_cptr_ptr ( value : mrb_value ) -> * mut :: std :: os :: raw :: c_void ; } extern \"C\" { pub fn mrb_sys_basic_ptr ( value : mrb_value ) -> * mut RBasic ; } extern \"C\" { pub fn mrb_sys_obj_ptr ( value : mrb_value ) -> * mut RObject ; } extern \"C\" { pub fn mrb_sys_proc_ptr ( value : mrb_value ) -> * mut RProc ; } extern \"C\" { pub fn mrb_sys_class_ptr ( value : mrb_value ) -> * mut RClass ; } extern \"C\" { pub fn mrb_sys_class_to_rclass ( value : mrb_value ) -> * mut RClass ; } extern \"C\" { pub fn mrb_sys_class_of_value ( mrb : * mut mrb_state , value : mrb_value ) -> * mut RClass ; } extern \"C\" { pub fn mrb_sys_nil_value ( ) -> mrb_value ; } extern \"C\" { pub fn mrb_sys_false_value ( ) -> mrb_value ; } extern \"C\" { pub fn mrb_sys_true_value ( ) -> mrb_value ; } extern \"C\" { pub fn mrb_sys_fixnum_value ( value : mrb_int ) -> mrb_value ; } extern \"C\" { pub fn mrb_sys_float_value ( mrb : * mut mrb_state , value : mrb_float ) -> mrb_value ; } extern \"C\" { pub fn mrb_sys_cptr_value ( mrb : * mut mrb_state , ptr : * mut :: std :: os :: raw :: c_void ) -> mrb_value ; } extern \"C\" { pub fn mrb_sys_obj_value ( p : * mut :: std :: os :: raw :: c_void ) -> mrb_value ; } extern \"C\" { pub fn mrb_sys_class_value ( klass : * mut RClass ) -> mrb_value ; } extern \"C\" { pub fn mrb_sys_module_value ( module : * mut RClass ) -> mrb_value ; } extern \"C\" { pub fn mrb_sys_data_value ( data : * mut RData ) -> mrb_value ; } extern \"C\" { pub fn mrb_sys_proc_value ( mrb : * mut mrb_state , proc_ : * mut RProc ) -> mrb_value ; } extern \"C\" { pub fn mrb_sys_symbol_name ( mrb : * mut mrb_state , value : mrb_value ) -> * const :: std :: os :: raw :: c_char ; } extern \"C\" { pub fn mrb_sys_new_symbol ( mrb : * mut mrb_state , string : * const :: std :: os :: raw :: c_char , len : usize ) -> mrb_value ; } extern \"C\" { pub fn mrb_sys_set_instance_tt ( class : * mut RClass , type_ : mrb_vtype ) ; } extern \"C\" { pub fn mrb_sys_data_init ( value : * mut mrb_value , ptr : * mut :: std :: os :: raw :: c_void , type_ : * const mrb_data_type ) ; } extern \"C\" { pub fn mrb_sys_raise ( mrb : * mut mrb_state , eclass : * const :: std :: os :: raw :: c_char , msg : * const :: std :: os :: raw :: c_char ) ; } extern \"C\" { pub fn mrb_sys_raise_current_exception ( mrb : * mut mrb_state ) ; } extern \"C\" { pub fn mrb_sys_value_debug_str ( mrb : * mut mrb_state , value : mrb_value ) -> mrb_value ; } extern \"C\" { pub fn mrb_sys_ary_len ( value : mrb_value ) -> mrb_int ; } extern \"C\" { pub fn mrb_sys_gc_arena_save ( mrb : * mut mrb_state ) -> :: std :: os :: raw :: c_int ; } extern \"C\" { pub fn mrb_sys_gc_arena_restore ( mrb : * mut mrb_state , arena_index : :: std :: os :: raw :: c_int ) ; } extern \"C\" { pub fn mrb_sys_gc_disable ( mrb : * mut mrb_state ) -> bool ; } extern \"C\" { pub fn mrb_sys_gc_enable ( mrb : * mut mrb_state ) -> bool ; } extern \"C\" { pub fn mrb_sys_value_is_dead ( _mrb : * mut mrb_state , value : mrb_value ) -> bool ; } extern \"C\" { pub fn mrb_sys_gc_live_objects ( mrb : * mut mrb_state ) -> :: std :: os :: raw :: c_int ; } extern \"C\" { pub fn mrb_init_mrbgems ( mrb : * mut mrb_state ) ; } pub type __builtin_va_list = [ __va_list_tag ; 1usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __va_list_tag { pub gp_offset : :: std :: os :: raw :: c_uint , pub fp_offset : :: std :: os :: raw :: c_uint , pub overflow_arg_area : * mut :: std :: os :: raw :: c_void , pub reg_save_area : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout___va_list_tag ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __va_list_tag > ( ) , 24usize , concat ! ( \"Size of: \" , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __va_list_tag > ( ) , 8usize , concat ! ( \"Alignment of \" , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . gp_offset as * const _ as usize } , 0usize , concat ! ( \"Offset of field: \" , stringify ! ( __va_list_tag ) , \"::\" , stringify ! ( gp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . fp_offset as * const _ as usize } , 4usize , concat ! ( \"Offset of field: \" , stringify ! ( __va_list_tag ) , \"::\" , stringify ! ( fp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . overflow_arg_area as * const _ as usize } , 8usize , concat ! ( \"Offset of field: \" , stringify ! ( __va_list_tag ) , \"::\" , stringify ! ( overflow_arg_area ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . reg_save_area as * const _ as usize } , 16usize , concat ! ( \"Offset of field: \" , stringify ! ( __va_list_tag ) , \"::\" , stringify ! ( reg_save_area ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct iv_tbl { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct symbol_name { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mrb_irep_debug_info { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct htable { pub _address : u8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mrb_shared_string { pub _address : u8 , }\r\n   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -------------------- method `map` not found for this\r\n   |\r\n   = note: the method `map` exists but the following trait bounds were not satisfied:\r\n           `&mut sys::ffi::mrb_value : std::iter::Iterator`\r\n   = help: items from traits can only be used if the trait is implemented and in scope\r\n   = note: the following trait defines an item `map`, perhaps you need to implement it:\r\n           candidate #1: `std::iter::Iterator`\r\n\r\nerror: aborting due to previous error\r\n\r\nFor more information about this error, try `rustc --explain E0599`.\r\nThe following warnings were emitted during compilation:\r\n\r\nwarning: couldn't execute `llvm-config --prefix` (error: No such file or directory (os error 2))\r\nwarning: set the LLVM_CONFIG_PATH environment variable to a valid `llvm-config` executable\r\n\r\nerror: Could not compile `artichoke-backend`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```", "closed_by": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/65616/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/65616/timeline", "performed_via_github_app": null, "state_reason": "completed"}