{"url": "https://api.github.com/repos/rust-lang/rust/issues/73156", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/73156/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/73156/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/73156/events", "html_url": "https://github.com/rust-lang/rust/issues/73156", "id": 635013521, "node_id": "MDU6SXNzdWU2MzUwMTM1MjE=", "number": 73156, "title": "Handle source code coverage in const eval", "user": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 900795185, "node_id": "MDU6TGFiZWw5MDA3OTUxODU=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-const-eval", "name": "A-const-eval", "color": "f7e101", "default": false, "description": "Area: constant evaluation (mir interpretation)"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2020-06-09T00:09:21Z", "updated_at": "2020-10-15T14:35:49Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "One open question around source code coverage instrumentation (#34701 / https://github.com/rust-lang/compiler-team/issues/278) is how to handle code that is only run during const eval. For example:\r\n\r\n```rust\r\nconst fn compute_foo(x: bool) -> i32 {\r\n  if x {\r\n    42\r\n  } else {\r\n    11\r\n  }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n  #[test]\r\n  fn test_foo() {\r\n    assert_eq!(compute_foo(false), 11);\r\n    assert_eq!(compute_foo(true), 42);\r\n  }\r\n}\r\n```\r\n\r\nIn a coverage report, we don't want the code in `compute_foo` to show as not being covered by tests because it was only \"run\" at compile time.\r\n\r\n# Approaches\r\n\r\nI've talked about this with @petrhosek a couple times, he raised two possible approaches for both rustc and clang. I'll do my best to communicate them, but any mistakes are mine.\r\n\r\n## Emit a coverage profile at compile time\r\n\r\nWhen code coverage instrumentation is enabled, another option can be specified which causes a profile to be emitted at compile time (in the same format as the profiles generated at runtime). This would include every counter hit while evaluating MIR during const eval. The profile could then be combined with profiles collected during runtime (which I believe tooling already exists for).\r\n\r\nOne benefit of this approach is that it allows us to handle counters hit at compile time differently from those hit at runtime. I can see this being useful e.g. if we were to use those counters for some kind of PGO pass in the MIR, though I'm not sure if that's a realistic use for them. There might be other reasons to differentiate.\r\n\r\nA challenge with the approach is that we'll have to produce the profile format ourselves (we won't get the benefit of LLVM instrumentation doing it for us, like we do in the final binary).\r\n\r\n## Initialize runtime counters with compile time counts\r\n\r\nSimilar to before, we would count how many times each source code coverage region was evaluated during compile time. Instead of emitting a profile at compile time, we can simply initialize the (static) counter in the final binary to this value. So if that counter was evaluated 42 times, every profile emitted by the binary would start at 42 (and go up from there if the same counter were also hit at runtime). We might need to extend LLVM to support something like this.\r\n\r\nThe main benefit of this is simplicity: there are less \"moving parts\" for someone who wants to use source code coverage. We also don't have to teach the compiler how to emit coverage profiles.\r\n\r\nOne possible issue with this approach is how it might interact with linker garbage collection. We wouldn't want the linker to remove nonzero counters for never being referenced from any code in the binary.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/73156/reactions", "total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 1, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/73156/timeline", "performed_via_github_app": null, "state_reason": null}