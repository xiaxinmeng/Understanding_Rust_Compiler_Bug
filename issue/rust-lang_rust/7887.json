{"url": "https://api.github.com/repos/rust-lang/rust/issues/7887", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/7887/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/7887/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/7887/events", "html_url": "https://github.com/rust-lang/rust/issues/7887", "id": 16944638, "node_id": "MDU6SXNzdWUxNjk0NDYzOA==", "number": 7887, "title": "RFC: Boxes vs Containers - Naming schemes for element access", "user": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 28, "created_at": "2013-07-18T21:25:12Z", "updated_at": "2013-10-12T01:32:40Z", "closed_at": "2013-10-12T01:32:40Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "Right now there is much confusion and inconsistency about the naming of functions that deal with elements in types that wrap one or more of them. We need to find a consistent way to deal with that.\n\nFirst, some terminology:\n- Container - Can contain at most N elements (with N effectively infinite).  \n  Examples: Vector, Hash Map, Linked List.\n- Box - Can contain at most 1 element.  \n  Examples: Option, Cell, ~T, ARC.\n\nI'm also defining a elementary set of operations you can perform on containers and boxes in regard to an arbitrary chosen element `E` (named in all-caps to differentiate from actual function names below):\n- REF: Return a reference to the element - `(&'a self) -> &'a E`\n- REF_MUT: Return a mutable reference to the element - `(&'a mut self) -> &'a mut E`\n- TAKE: Return a element, removing it from the type - `(&mut self) -> E`\n- UNWRAP: Return a element, destroying the type in the process - `(self) -> E`\n\nIn regard to naming schemes, I see a number of possibilities:\n### Unify boxes and containers\n\nThis would be the globally most consistent and reusable way, but also the most ugly one. We define a set of functions for working with an arbitrary 'next' element on an container. For example in stack-terminology:\n- `fn top(&'a self) -> &'a E` - REF, fail if empty\n- `fn peek(&'a self) -> Option<&'a E>` - REF or None\n- `fn top_mut(&'a mut self) -> &'a mut E` - REF_MUT, fail if empty\n- `fn peek_mut(&'a mut self) -> Option<&'a mut E>` - REF_MUT or None\n- `fn pop(&mut self) -> E` - TAKE, fail if empty\n- `fn pop_opt(&mut self) -> Option<E>` - TAKE or None\n- `fn pop_consume(self) -> E` - UNWRAP, fail if empty\n- `fn pop_consume_opt(self) -> Option<E>` - UNWRAP or None.\n### Separate boxes and containers, consistent box naming scheme\n\nContainers and Boxes are separate concepts. Containers are build around a terminology and operations that make most sense to them. They probably wouldn't support UNWRAP and might not support the others either, depending on their specific semantics.\n\nBoxes gain their own more concise and strictly consistent terminology, based around the box metaphor:\n- \"Get a reference to the content, but keep it in the box\"  \n  - `fn get(&'a self) -> &'a E` - REF, fail if empty\n  - `fn get_opt(&'a self) -> Option<&'a E>` - REF or None\n  - `fn get_mut(&'a mut self) -> &'a mut E` - REF_MUT, fail if empty\n  - `fn get_mut_opt(&'a mut self) -> Option<&'a mut E>` - REF_MUT or None\n- \"Take the content out of the box, keeping the box intact but empty\"\n  - `fn take(&mut self) -> E` - TAKE, fail if empty\n  - `fn take_opt(&mut self) -> Option<E>` - TAKE or None\n- \"Destructively unwrap the box to get to the content\"\n  - `fn unwrap(self) -> E` - UNWRAP, fail if empty\n  - `fn unwrap_opt(self) -> Option<E>` - UNWRAP or None.\n### Separate boxes and containers, convenient box naming scheme\n\nThis one is quite similar to the prior one, but shuffles names and definitions around to provide a nicer set of function names for the common operations:\n- \"Get a reference to the content, but keep it in the box\"  \n  - `fn get(&'a self) -> &'a E` - REF, fail if empty\n  - `fn get_opt(&'a self) -> Option<&'a E>` - REF or None\n  - `fn get_mut(&'a mut self) -> &'a mut E` - REF_MUT, fail if empty\n  - `fn get_mut_opt(&'a mut self) -> Option<&'a mut E>` - REF_MUT or None\n- \"Take the content out of the box if any, keeping the box intact but empty\"\n  - `fn take(&mut self) -> Option<E>` - TAKE or None\n- \"Destructively unwrap the box to get to the content\"\n  - `fn unwrap(self) -> E` - UNWRAP, fail if empty\n\n---\n\nThe last one is probably the most convenient as it's optimized for common \"I know it is not `None`\" `Option` usecases:\n- `opt.get()` - \" Do something with the content of a Option, but keep it in place.\"\n- `opt.unwrap()` - \"Move the content out of a Option, throw the Option away\"\n- `opt.clone().unwrap()` or `opt.get().clone()` - \"Get a copy of the content\"\n- `opt.take().unwrap()` - \"Move the content out of a Option, replace the Option with None\"\n\n---\n\nHm, this writeup is only half as comprehensive and cohesive as I wanted it to be, I hope it's still understandable.\n", "closed_by": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/7887/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/7887/timeline", "performed_via_github_app": null, "state_reason": "completed"}