{"url": "https://api.github.com/repos/rust-lang/rust/issues/93740", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/93740/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/93740/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/93740/events", "html_url": "https://github.com/rust-lang/rust/issues/93740", "id": 1126186957, "node_id": "I_kwDOAAsO6M5DID_N", "number": 93740, "title": "Tracking issue for improving std::sync::{Mutex, RwLock, Condvar}", "user": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 9695584, "node_id": "MDU6TGFiZWw5Njk1NTg0", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-concurrency", "name": "A-concurrency", "color": "f7e101", "default": false, "description": "Area: Concurrency related issues."}, {"id": 650846969, "node_id": "MDU6TGFiZWw2NTA4NDY5Njk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-tracking-issue", "name": "C-tracking-issue", "color": "f5f1fd", "default": false, "description": "Category: A tracking issue for an RFC or an unstable feature."}, {"id": 2011781731, "node_id": "MDU6TGFiZWwyMDExNzgxNzMx", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs", "name": "T-libs", "color": "bfd4f2", "default": false, "description": "Relevant to the library team, which will review and decide on the PR/issue."}, {"id": 4434017660, "node_id": "LA_kwDOAAsO6M8AAAABCEm9fA", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-atomic", "name": "A-atomic", "color": "f7e101", "default": false, "description": "Area: atomics, barriers, and sync primitives"}], "state": "closed", "locked": false, "assignee": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 109, "created_at": "2022-02-07T16:04:01Z", "updated_at": "2023-04-04T14:37:23Z", "closed_at": "2023-01-20T20:45:55Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "A few weeks ago, on January 12th, the @rust-lang/libs team discussed a plan to improve `std::sync::Mutex`, `std::sync::Condvar`, and `std::sync::RwLock`.\r\n\r\nOn most platforms, these structures are currently wrappers around their `pthread` equivalent, such as `pthread_mutex_t`. These types are not movable, however, forcing us to wrap them in a `Box`, resulting in an allocation and indirection for our lock types. This also gets in the way of a `const` constructor for these types, which makes `static` locks more complicated than necessary.\r\n\r\n@Amanieu presented his library, `parking_lot`, which implements [the 'parking lot' structure from WebKit](https://webkit.org/blog/6161/locking-in-webkit/). Rather than letting the operating system handle any waiting queues, this manages the queues in user space in a global hash table indexed by the address of the lock. This allows for flexible 1-byte mutexes with almost no restrictions.\r\n\r\nThere has been [an attempt at merging `parking_lot` into std](https://github.com/rust-lang/rust/pull/56410), as a replacement for the implementation of std's locking primitives. However, many different blockers came up and that PR did not get merged. (See also [my RustConf talk](https://www.youtube.com/watch?v=DnYQKWs_7EA) for some of this history.) Many of these blockers have been resolved since.\r\n\r\nOne of the problems with replacing std's lock implementations by `parking_lot` is that `parking_lot` allocates memory for its global hash table. A Rust program can define its own custom allocator, and such a custom allocator will likely use the standard library's locks, creating a cyclic dependency problem where you can't allocate memory without locking, but you can't lock without first allocating the hash table.\r\n\r\nA possible solution is to use a `static` table with a fixed number of entries, which does not scale with the number of threads. This could work well in many situations, but can become problematic in highly parallel programs and systems. Another possible solution is to skip the global allocator and directly allocate this hash table with a native system API such as `mmap` on Unix. (See [this thread](https://github.com/Amanieu/parking_lot/pull/305) for some discussion.)\r\n\r\nIn our meeting, we discussed what's natively available on various operating systems/platforms:\r\n\r\n- On Windows, we have already switched to Windows SRW locks, which do not require allocation as they can be moved. They are small (32-bit), efficient, and `const` constructible. Just for Windows, there does not seem much advantage to switching to `parking_lot`, although there might be some (small) performance difference.\r\n\r\n- On both Linux and some BSDs there's a native `futex()` syscall, which provides functionality similar (but more primitive) than a parking lot. Nearly equivalent functionality [is available in Wasm](https://github.com/WebAssembly/threads/blob/main/proposals/threads/Overview.md#wait-and-notify-operators). While not trivial, it's possible to implement our synchronization primitives directly based on such a futex. This makes all the primitives small (32-bit), efficient, and `const` constructible.\r\n\r\n- On macOS and some other Unixes there doesn't seem to be anything that's similar futex syscall. ([`parking_lot` uses `pthread` for its thread parking operations on those platforms](https://github.com/Amanieu/parking_lot/blob/a75875b0bf904287a9749e8eabea919b5e9dd8a9/core/src/thread_parker/unix.rs#L30-L31).)\r\n\r\n- [Some smaller platforms](https://github.com/rust-lang/rust/tree/master/library/std/src/sys) that are (partially) supported by the standard library have [their own non-trivial implementation](https://github.com/rust-lang/rust/tree/master/library/std/src/sys/sgx/waitqueue) of the standard locks, which are hard to maintain and have not gotten much validation.\r\n\r\nAfter some discussion, the consensus was to providing the locks as 'thinnest possible wrapper' around the native lock APIs as long as they are still small, efficient, and `const` constructible. This means [SRW locks](https://docs.microsoft.com/en-us/windows/win32/sync/slim-reader-writer--srw--locks) on Windows, and futex-based locks on Linux, some BSDs, and Wasm. And for other platforms without suitable native APIs, a `parking_lot`-based implementation using one of the possible workarounds for the allocation problem.\r\n\r\nThis means that on platforms like Linux and Windows, the operating system will be responsible for managing the waiting queues of the locks, such that any kernel improvements and features like debugging facilities in this area are directly available for Rust programs.\r\n\r\nIt also means that porting the standard library to a new platform will be easier, and maintainance of the std implementation for the less common platforms will become easier. These platforms will now only have to implement [a thread parker](https://github.com/Amanieu/parking_lot/blob/a75875b0bf904287a9749e8eabea919b5e9dd8a9/core/src/thread_parker/mod.rs#L4) and can rely on a performant and correct implementation of the standard locks on top of that.\r\n\r\nUpdate: We've decided to not directly use parking lot's one-byte (two bit) locks, but instead use the equivalent of its internal `WordLock` or Windows' SRW locks, which are one pointer in size and require no global state in the program. That solves the allocation problem.\r\n\r\nUpdate 2: To maintain priority inheritance of the native locks (e.g. on macOS), we've kept using pthread locks on non-futex unix platforms, at least for now. Using https://github.com/rust-lang/rust/pull/97647, we've made it possible for the locks to have `const fn new`.\r\n\r\n---\r\n\r\nPrimary goals:\r\n\r\n- [x] Efficient non-allocating locks\r\n    - [x] Windows\r\n    - [x] Linux\r\n    - [ ] ~~macOS~~\r\n      - We can't avoid pthread if we want to keep features of the OS' native locks, like priority iniheritance.\r\n    - [x] {Free, Open}BSD\r\n- [x] Turn `std::sync::{Mutex, Condvar, RwLock}::new` into `const` functions: https://github.com/rust-lang/rust/pull/97791\r\n- [x] Resolve some bugs around pthreads\r\n    - [x] https://github.com/rust-lang/rust/issues/85434\r\n    - [x] https://github.com/rust-lang/rust/issues/94564#issuecomment-1098942913\r\n\r\nPossible later goals:\r\n\r\n- Add a `Condvar::wait_rwlock` to make `Condvar` usable with `RwLock`s?\r\n- Allow `Send`ing `MutexGuard`s to other threads?\r\n\r\n---\r\n\r\nTo do:\r\n\r\n- [x] Relax `Condvar` requirements to allow for unboxed mutexes. https://github.com/rust-lang/rust/pull/76932\r\n- [x] Use unboxed SRW locks on Windows.\r\n    - [x] Make Microsoft promise that SRW locks are indeed movable. https://github.com/MicrosoftDocs/sdk-api/pull/447\r\n    - [x] https://github.com/rust-lang/rust/pull/76645\r\n    - [x] Refactor `sys_common::Mutex` to have a separate `MovableMutex` type to allow unboxing on some platforms. https://github.com/rust-lang/rust/pull/77147\r\n    - [x] Remove the `Box`es in `Mutex` and `Condvar` on Windows and Wasm. https://github.com/rust-lang/rust/pull/77380\r\n    - [x] Remove the `Box` from `RwLock` on Windows and Wasm. https://github.com/rust-lang/rust/pull/84687\r\n    - [x] (Start using `WaitOnAddress` and `NtWaitForKeyedEvent` in the standard library.) https://github.com/rust-lang/rust/pull/77618\r\n        - This unblocks usage of these APIs in `parking_lot` if we want to use that on Windows too. But if we just use SRW locks, this was not necessary to unblock the lock improvements.\r\n- [x] Use futex-based locks on Linux.\r\n    - [x] Start using the futex syscall to get some experience with it in the standard library. https://github.com/rust-lang/rust/pull/76919\r\n    - [x] Implement the `futex()` syscall in Miri to allow Miri to run standard library tests. https://github.com/rust-lang/miri/pull/1568\r\n        - [x] Also implement the bitset futex operations in Miri. https://github.com/rust-lang/miri/pull/2054\r\n    - [x] Implement `Mutex` and `Condvar` using `futex()`.\r\n        - [x] Design these.\r\n            - [x] Experimentation: https://github.com/m-ou-se/futex-lock-experiment/\r\n            - [x] Investigate other implementations (glibc, musl, Windows, etc.)\r\n                - [x] musl: https://github.com/rust-lang/rust/issues/93740#issuecomment-1041391284\r\n                - [x] glibc\r\n                    - [x] Mutexes: https://github.com/rust-lang/rust/issues/93740#issuecomment-1041572651\r\n                    - [x] Condition variables: https://github.com/rust-lang/rust/issues/93740#issuecomment-1048886597\r\n                    - [x] Reader-writer locks: https://github.com/rust-lang/rust/issues/93740#issuecomment-1055354913\r\n                - [x] Boost: https://github.com/rust-lang/rust/issues/93740#issuecomment-1064286563\r\n                - [x] Windows' SRW locks: https://github.com/rust-lang/rust/issues/93740#issuecomment-1064139337\r\n                - [x] Wine's SRW locks: https://github.com/rust-lang/rust/issues/93740#issuecomment-1055672041\r\n                - [x] Apple Darwin libpthread: https://github.com/rust-lang/rust/issues/93740#issuecomment-1069240178\r\n                - [x] FreeBSD's libpthread: https://github.com/rust-lang/rust/issues/93740#issuecomment-1069265943\r\n            - [x] Make some design decisions: https://github.com/rust-lang/rust/issues/93740#issuecomment-1070696128\r\n        - [x] Implementation: https://github.com/rust-lang/rust/pull/95035\r\n    - [x] Implement `ReentrantMutex` using `futex()`: https://github.com/rust-lang/rust/pull/95727\r\n    - [x] Implement `RwLock` using `futex()`: https://github.com/rust-lang/rust/pull/95801\r\n- [x] Use the same `ReentrantMutex` on all platforms: https://github.com/rust-lang/rust/pull/96042\r\n- [x] Use futex-based locks on \\*BSD.\r\n    - [x] Add NetBSD's FUTEX_* constants to the libc crate. https://github.com/rust-lang/libc/pull/2762\r\n    - [x] Add OpenBSD's futex() to the libc crate. https://github.com/rust-lang/libc/pull/2761\r\n    - [x] Add FreeBSD umtx functions and constants to the libc crate. https://github.com/rust-lang/libc/pull/2770\r\n    - [x] Add DragonFlyBSD's umtx_* functions to the libc crate. https://github.com/rust-lang/libc/pull/2763\r\n    - [x] Switch *BSD over to the same futex locks as on Linux. https://github.com/rust-lang/rust/pull/96510\r\n- [x] Use futex based locks on all other platforms that support a futex-like API.\r\n    - [x] Use futex based locks on Emscripten. https://github.com/rust-lang/rust/pull/96205\r\n    - [x] Use `atomic.wait`/`atomic.notify` based locks on Wasm. https://github.com/rust-lang/rust/pull/96206\r\n    - [ ] Use [zx_futex_wait](https://fuchsia.dev/fuchsia-src/reference/syscalls/futex_wait) based locks on Fuchsia.\r\n       - (Tier 2 platform.)\r\n    - [ ] Use [syscall::call::futex](https://docs.rs/redox_syscall/latest/syscall/call/fn.futex.html) based locks on Redox.\r\n       - (Tier 3 platform.)\r\n    - [x] Use futexes on Hermit. https://github.com/rust-lang/rust/pull/101475\r\n- [x] Lazily allocate on platforms where we still use pthread: https://github.com/rust-lang/rust/pull/97647\r\n    - [x] macOS\r\n    - [x] NetBSD, other unix\r\n- [x] Make the `new` functions `const`. https://github.com/rust-lang/rust/pull/97791\r\n- [ ] [future / nice to have] Use 'WordLock' (aka SRW lock, aka 'user space linked-list queue lock') on other platforms.\r\n    - [x] Remove locks from `Instant::now()`, to avoid a cyclic dependency. \r\n    - [x] Stop using `std::sync::{Mutex, Condvar}` in std::sys's thread parker, to avoid a cyclic dependency. https://github.com/rust-lang/rust/pull/96393\r\n    - [ ] Implement this type of locks, and replace the lock implementations of non-futex platforms by it.\r\n- [x] Mark this issue as fixed: https://github.com/rust-lang/rust/issues/85434\r\n- [ ] ~~Write some blog post about all this.~~ (https://github.com/rust-lang/rust/issues/93740#issuecomment-1398913130)\r\n- [x] Celebrate. :tada:", "closed_by": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/93740/reactions", "total_count": 123, "+1": 0, "-1": 0, "laugh": 0, "hooray": 78, "confused": 0, "heart": 45, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/93740/timeline", "performed_via_github_app": null, "state_reason": "completed"}