{"url": "https://api.github.com/repos/rust-lang/rust/issues/84019", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/84019/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/84019/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/84019/events", "html_url": "https://github.com/rust-lang/rust/issues/84019", "id": 854015575, "node_id": "MDU6SXNzdWU4NTQwMTU1NzU=", "number": 84019, "title": "Namespace the `asm!` macro", "user": {"login": "bstrie", "id": 865233, "node_id": "MDQ6VXNlcjg2NTIzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstrie", "html_url": "https://github.com/bstrie", "followers_url": "https://api.github.com/users/bstrie/followers", "following_url": "https://api.github.com/users/bstrie/following{/other_user}", "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions", "organizations_url": "https://api.github.com/users/bstrie/orgs", "repos_url": "https://api.github.com/users/bstrie/repos", "events_url": "https://api.github.com/users/bstrie/events{/privacy}", "received_events_url": "https://api.github.com/users/bstrie/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 91598611, "node_id": "MDU6TGFiZWw5MTU5ODYxMQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-inline-assembly", "name": "A-inline-assembly", "color": "f7e101", "default": false, "description": "Area: inline asm!(..)"}, {"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 2046313052, "node_id": "MDU6TGFiZWwyMDQ2MzEzMDUy", "url": "https://api.github.com/repos/rust-lang/rust/labels/F-asm", "name": "F-asm", "color": "f9c0cc", "default": false, "description": "`#![feature(asm)]` (not `llvm_asm`)"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 12, "created_at": "2021-04-08T23:29:09Z", "updated_at": "2021-07-19T12:40:40Z", "closed_at": "2021-07-19T12:40:40Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "### Click [here](https://github.com/rust-lang/rust/issues/84019#issuecomment-875101919) for the final summary report.\r\n\r\nOriginal issue preserved below:\r\n\r\n---\r\n\r\nAs of today, most macros in Rust, despite being declared by the stdlib, are not properly namespaced in the sense that every other type, function, and trait in the stdlib is namespaced. Instead, historically, macros \"live\" in the crate root due to the technical limitations of Rust 1.0, which did not support namespacing for macros. This is distinct from items such as `Option` or `Vec` which are merely available as though they live in the crate root (via the prelude), but are actually defined at `std::option::Option` and `std::vec::Vec`. This has two primary downsides:\r\n\r\n1. The stdlib API index is polluted by a wall of random, unrelated macros, many of which are relatively unimportant or irrelevant: https://doc.rust-lang.org/std/index.html#macros\r\n2. Defining an item in the crate root is tantamount to exporting that item from the prelude, which means that adding a macro there totally bypasses the discussion of whether the macro *should* be exported from the prelude.\r\n\r\nIn Rust 1.51, [`ptr::addr_of`](https://doc.rust-lang.org/std/ptr/macro.addr_of.html) became the first stable macro to not be defined in the crate root. The machinery exists to namespace macros, and there seems to be at least loose consensus that this is worth using for new macros in the stdlib.\r\n\r\nOne of the last remaining open questions for [the stabilization of the `asm` macro](https://github.com/rust-lang/rust/issues/72016) is where it should live. Given the above, and the history of prior discussion on this topic, there are two options for consideration:\r\n\r\n1. `core::arch::asm`\r\n2. `core::arch::foo64::asm`, where `foo64` is *every* architecture supported by the `asm` macro.\r\n\r\n(For conciseness I will only be referring to `asm` in this document, but this decision also applies to any and all related macros, such as `global_asm`.)\r\n\r\nFirst, the non-advantages of either option:\r\n\r\n1. Compile-time rejection of unsupported platforms: while `arch::foo64::asm` makes it immediately and syntactically obvious that a given platform is unsupported by dint of a nonexistent symbol, using `arch::asm` on an unsupported platform is still a compiler error.\r\n2. Inclusion in the prelude: while `arch::asm` is straightforwardly obvious to export from the prelude, `arch::foo64::asm` and friends could still possibly be exported from the prelude via `#cfg`.\r\n3. Architecture-dependent behavior: even aside from the literal assembly code itself, it is possible for the `asm` macro to have slightly different semantics on different architectures, e.g. architecture-specific register classes or clobbering behavior. While `arch::foo64::asm` is more explicit about this potential difference, it is not necessary for enabling such behavior.\r\n4. Target-specific stabilization or deprecation: while `arch::foo64::asm` is more straightforward to deprecate/stabilize on a per-target basis, `#cfg` can be used to the same effect even for `arch::asm`.\r\n\r\nThe relevant differences between the the two options:\r\n\r\n1. Importing the symbol: even assuming that `asm` is not added to the prelude, `arch::asm` would still be trivial to `use` in architecture-dependent code. Conversely, without a prelude addition, `arch::foo64::asm` would have to fall back on a few patterns when writing architecture-dependent code, some of which are more verbose than others. Below, Pattern #4 is the one that comes closest to the ergonomics of `arch::asm`, but it may be non-obvious, and it involves using a glob-import, which some may find distasteful (or even be linting against):\r\n```rust\r\n// Pattern #1 ----------------------------------------\r\n// fully-qualified names\r\n#[cfg(foo64)]\r\nfn qux() {\r\n    std::arch::foo64::asm!(...);\r\n}\r\n#[cfg(bar64)]\r\nfn qux() {\r\n    std::arch::bar64::asm!(...);\r\n}\r\n// Pattern #2 ----------------------------------------\r\n// doubled #cfg attributes\r\n#[cfg(foo64)]\r\nuse std::arch::foo64::asm;\r\n#[cfg(bar64)]\r\nuse std::arch::bar64::asm;\r\n\r\n#[cfg(foo64)]\r\nfn qux() {\r\n    asm!(...);\r\n}\r\n#[cfg(bar64)]\r\nfn qux() {\r\n    asm!(...);\r\n}\r\n// Pattern #3 ----------------------------------------\r\n// context-local use\r\n#[cfg(foo64)]\r\nfn qux() {\r\n    use std::arch::foo64::asm;\r\n    asm!(...);\r\n}\r\n#[cfg(bar64)]\r\nfn qux() {\r\n    use std::arch::bar64::asm;\r\n    asm!(...);\r\n}\r\n// Pattern #4 ----------------------------------------\r\n// glob import\r\nuse std::arch::*;\r\n\r\n#[cfg(foo64)]\r\nfn qux() {\r\n    foo64::asm!(...);\r\n}\r\n#[cfg(bar64)]\r\nfn qux() {\r\n    bar64::asm!(...);\r\n}\r\n```\r\n2. Documentation: the documentation of `arch::asm` would have to document all architecture-dependent behavior, which could make it unwieldy. `arch::foo64::asm` would isolate architecture-dependent documentation, however, every module would be forced to duplicate all *non*-architecture-dependent `asm` documentation, which seems unfortunate in its own way.\r\n3. Error reporting in the event of unguarded `asm`: having `arch::asm`, or else having `arch::foo64::asm` but having `asm` in the prelude, increases the chances that someone will write an `asm!` invocation that is not guarded by any `#cfg` directive or any other mention of the original author's platform. Such an unguarded invocation would probably give unhelpful errors if the code is ever compiled for a platform that supports `asm` in general but was not considered by this specific `asm` invocation. Even worse, the code could compile but have unintended behavior. Conversely, `arch::foo64::asm` essentially guarantees that an author's code will have to mention their intended platform somewhere, either in a `use` or in an expression, and users on different platforms will receive obvious \"cannot find value `foo64::asm` in this scope\" errors when attempting to compile it. However, this benefit *requires* that `asm` never be added to the prelude (and never adding any other way of circumventing the need to mention a platform, e.g. having *both* `arch::asm` and `arch::foo64::asm`).\r\n4. Module proliferation: currently, `asm` supports architectures that do not have a corresponding module under `std::arch`. The `arch::foo64::asm` approach would require a module for all supported architectures going forward. This includes adding modules for targets that may not ever be supported by rustc itself (e.g. SPIR-V), but are supported by the `asm!` macro for the benefit of alternative backends. However, in either scenario alternative backends would still need to provide a patch to support new targets in `asm!`, and adding a new module for any unstably-supported target doesn't seem like a particularly onerous part of that process. However, given enough time (and enough alternative backends, e.g. a GCC one) this could lead to quite a few submodules under `arch::`, although to some degree that is the point of the `arch` module.\r\n5. Platform-agnostic assembly: it is possible for a single `asm!` invocation to properly support multiple targets. This is the flipside of point 3 stated above: where `arch::asm` is maximally permissive, `arch::foo64::asm` is maximally strict. With `arch::foo64::asm`, writing platform-agnostic assembly would require a pattern like the following:\r\n```rust\r\n#[cfg(foo64)]\r\nuse std::arch::foo64 as fooish;\r\n#[cfg(foo32)]\r\nuse std::arch::foo32 as fooish;\r\n\r\nfn qux() {\r\n    fooish::asm!(...);\r\n}\r\n```\r\n\r\n**TL;DR**: the benefits of either approach are fairly small. `arch::asm` is easier to use, but only if `asm` is not added to the prelude. `arch::foo64::asm` could lead to better error messages in some cases, but likewise only if `asm` is not added to the prelude. If the decision is made to add `asm` to the prelude, then there is essentially no advantage to either option.\r\n", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/84019/reactions", "total_count": 2, "+1": 2, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/84019/timeline", "performed_via_github_app": null, "state_reason": "completed"}