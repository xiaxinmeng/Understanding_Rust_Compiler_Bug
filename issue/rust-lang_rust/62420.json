{"url": "https://api.github.com/repos/rust-lang/rust/issues/62420", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/62420/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/62420/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/62420/events", "html_url": "https://github.com/rust-lang/rust/issues/62420", "id": 464745379, "node_id": "MDU6SXNzdWU0NjQ3NDUzNzk=", "number": 62420, "title": "align_offset guarantees", "user": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 900795185, "node_id": "MDU6TGFiZWw5MDA3OTUxODU=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-const-eval", "name": "A-const-eval", "color": "f7e101", "default": false, "description": "Area: constant evaluation (mir interpretation)"}, {"id": 1244499056, "node_id": "MDU6TGFiZWwxMjQ0NDk5MDU2", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-miri", "name": "A-miri", "color": "f7e101", "default": false, "description": "Area: The miri tool"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 23, "created_at": "2019-07-05T18:58:35Z", "updated_at": "2021-04-19T16:18:44Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "The [documentation for `align_offset`](https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.align_offset) says\r\n\r\n> If it is not possible to align the pointer, the implementation returns usize::max_value().\r\n\r\nIt does not give any details of when it might not be possible to perform the alignment. My reading of that is that the user must always be prepared for failure to happen. In accordance with that, a while ago I adjusted the [docs for `align_to`](https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.align_to) (the preferred way to use `align_offset`) to say\r\n\r\n> This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix slice. The method does a best effort to make the middle slice the greatest length possible for a given type and input slice, but only your algorithm's performance should depend on that, not its correctness.\r\n\r\nIn practice, returning `max_value` happens when `p as usize & (gcd - 1) != 0` (whatever exactly this means, this is taken from the implementation) -- and when running in Miri, which will always return `max_value`.\r\n\r\nHistorically, Miri did this because it had no notion of the \"integer address\" of an allocation, so there literally was no way to offset a pointer to get a particular alignment. This is changing now, Miri is getting the support for this. So maybe we should note some conditions under which `align_offset` will definitely succeed. A motivation for this is https://github.com/rust-lang/rust/pull/61339, which implicitly made the assumption that aligning with `size_of::<T>() == 1` will always succeed.\r\n\r\nOn the other hand, the current contract for `align_offset` lets Miri do more reliable alignment checking. This is off-by-default but can be enabled with `-Zmiri-symbolic-alignment-check`: when checking whether some pointer `p` that points to offset `o` inside an allocation with alignment `a`, we have the option to consider only `a` and `o` and *not* the integer value of `p`. This allows us to reliably detect alignment problems in code such as:\r\n```rust\r\nfn main() {\r\n    let x = &mut [0u8; 3];\r\n    let base_addr = x as *mut _ as usize;\r\n    let u16_ref = &mut *(base_addr as *mut u16);\r\n    *u16_ref = 2;\r\n    println!(\"{:?}\", x);\r\n}\r\n```\r\nIf we were to take the actual integer value of `p` into account, the program might get \"lucky\" and actually run successfully in Miri because `base_addr` happens to be even. In contrast, by *not* doing this, Miri can offer a flag where the bug in the program above is definitely caught. With this flag, the user can be *sure* that none of the accesses in the program are aligned \"by chance\".\r\n\r\nHowever, this also means that when this flag is set, the following code will *not* pass:\r\n```rust\r\nfn main() {\r\n    let x = &mut [0u8; 3];\r\n    let base_addr = x as *mut _ as usize;\r\n    let u16_ref = unsafe { if base_addr % 2 == 0 {\r\n        &mut *(base_addr as *mut u16)\r\n    } else {\r\n        &mut *((base_addr+1) as *mut u16)\r\n    } };\r\n    *u16_ref = 2;\r\n    println!(\"{:?}\", x);\r\n}\r\n```\r\nMiri cannot know that you actually did your homework and checked the integer address. This program is basically indistinguishable from the bad program above.\r\n\r\nCurrently there does not seem to be much code that operates like the last example above -- code will instead use `align_to`, which will (when run in Miri with symbolic alignment checking) make the middle part empty, and thus the \"higher-aligned\" accesses just don't happen. This means the vast majority of code works fine in the better-alignment-checking mode. If we force `align_offset` to not fail like https://github.com/rust-lang/rust/pull/61339 expects, then suddenly `align_to` will return non-empty middle parts in Miri as well, and `-Zmiri-symbolic-alignment-check` will basically be useless. There will be false positives when any method using `align_to` is called, which includes a few fundamental methods in libcore.\r\n\r\nSo, here's the trade-off: either Miri has a mode that can reliably detect alignment problems, or `align_offset` guarantees success under certain conditions. I don't think we can have both. Which one do we pick?\r\n\r\n(The particular PR https://github.com/rust-lang/rust/pull/61339 that triggered this might be fixable to work with the contract Miri needs, I don't know. But this discussion will probably come up again.)\r\n\r\nCc @rust-lang/libs @rust-lang/wg-unsafe-code-guidelines ", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/62420/reactions", "total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 1, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/62420/timeline", "performed_via_github_app": null, "state_reason": null}