{"url": "https://api.github.com/repos/rust-lang/rust/issues/78944", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/78944/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/78944/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/78944/events", "html_url": "https://github.com/rust-lang/rust/issues/78944", "id": 740760641, "node_id": "MDU6SXNzdWU3NDA3NjA2NDE=", "number": 78944, "title": "#[inline(never)] causes major improvements in codegen compared to default hints", "user": {"login": "Urcra", "id": 9095312, "node_id": "MDQ6VXNlcjkwOTUzMTI=", "avatar_url": "https://avatars.githubusercontent.com/u/9095312?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Urcra", "html_url": "https://github.com/Urcra", "followers_url": "https://api.github.com/users/Urcra/followers", "following_url": "https://api.github.com/users/Urcra/following{/other_user}", "gists_url": "https://api.github.com/users/Urcra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Urcra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Urcra/subscriptions", "organizations_url": "https://api.github.com/users/Urcra/orgs", "repos_url": "https://api.github.com/users/Urcra/repos", "events_url": "https://api.github.com/users/Urcra/events{/privacy}", "received_events_url": "https://api.github.com/users/Urcra/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 234956, "node_id": "MDU6TGFiZWwyMzQ5NTY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-codegen", "name": "A-codegen", "color": "f7e101", "default": false, "description": "Area: Code generation"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-11-11T13:19:11Z", "updated_at": "2022-07-23T01:26:36Z", "closed_at": "2022-07-23T01:26:35Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "In fooling around with some benchmarks I found a peculiar event, where adding `#[inline(never)]` caused a major speedup due to better code generation. It seems quite counter-intuitive that inlining a rather trivial function with no side effects would cause the final assembly to be less optimized.\r\n\r\nI reproduced the effect with the following minimal example:\r\n\r\n\r\n```rust\r\nuse std::time::SystemTime;\r\n\r\n#[inline(never)]\r\nfn trivial_never(count: u64) -> u64 {\r\n    trivial_no_hint(count)\r\n}\r\n\r\n\r\nfn trivial_no_hint(count: u64) -> u64 {\r\n    let mut a = 0u64;\r\n    for c in 0..count {\r\n        if c < 1 {\r\n            a += 1;\r\n        }\r\n    }\r\n    a\r\n}\r\n\r\n\r\nfn main() {\r\n    let now = SystemTime::now();\r\n    for _ in 0..1000_000 {\r\n        if trivial_never(150) != 1 {\r\n            return;\r\n        }\r\n    }\r\n    println!(\"trivial_never took: {:?} \", now.elapsed());\r\n    \r\n    let now = SystemTime::now();\r\n    for _ in 0..1000_000 {\r\n        if trivial_no_hint(150) != 1 {\r\n            return;\r\n        }\r\n    }\r\n    println!(\"trivial_no_hint took: {:?} \", now.elapsed());\r\n}\r\n```\r\n\r\nInspecting the assembly code generated for the `main` function(without timing/printing). We see that when the code is never inlined the loop invariant is correctly detected and moved out of the loop. However when the code is inlined the loop invariant detection seems to fail here and we end up having to recalculate the value every iteration\r\n\r\nThe loop invariant code motion starts at `opt-level=2`\r\n```nasm\r\nexample::main:\r\n        push    rax\r\n        mov     edi, 150\r\n        call    qword ptr [rip + example::trivial_never@GOTPCREL] ; Loop invariant precalculated\r\n        mov     ecx, 1000001\r\n.LBB2_1:\r\n        add     ecx, -1\r\n        je      .LBB2_2\r\n        cmp     rax, 1\r\n        je      .LBB2_1 ; Only jumps to start of for loop without recalculating loop invariant\r\n        jmp     .LBB2_8\r\n.LBB2_2:\r\n        xor     eax, eax\r\n.LBB2_3:\r\n        cmp     eax, 1000000\r\n        je      .LBB2_8\r\n        mov     edx, 150\r\n        xor     ecx, ecx\r\n.LBB2_5:\r\n        xor     esi, esi\r\n        cmp     rdx, 150\r\n        sete    sil\r\n        add     rcx, rsi\r\n        add     rdx, -6\r\n        jne     .LBB2_5\r\n        add     eax, 1\r\n        cmp     rcx, 1\r\n        je      .LBB2_3 ; Jumps to the start of the for loop and recalculates the loop invariant\r\n.LBB2_8:\r\n        pop     rax\r\n        ret\r\n```\r\nAt `opt-level=3` the entire loop is skipped and the `if` statement is only executed once\r\n```nasm\r\nexample::main:\r\n        push    rax\r\n        mov     edi, 150\r\n        call    qword ptr [rip + example::trivial_never@GOTPCREL] ; Loop invariant precalculated\r\n        cmp     rax, 1\r\n        jne     .LBB2_6\r\n        xor     eax, eax ; Entire loop skipped \r\n.LBB2_2:\r\n        cmp     eax, 1000000\r\n        je      .LBB2_6\r\n        mov     edx, 150\r\n        xor     ecx, ecx\r\n.LBB2_4:\r\n        xor     esi, esi\r\n        cmp     rdx, 150\r\n        sete    sil\r\n        add     rcx, rsi\r\n        add     rdx, -6\r\n        jne     .LBB2_4\r\n        add     eax, 1\r\n        cmp     rcx, 1\r\n        je      .LBB2_2  ; Jumps to the start of the for loop and recalculates the loop invariant\r\n.LBB2_6:\r\n        pop     rax\r\n        ret\r\n```\r\nFull assembly: https://rust.godbolt.org/z/vaqzqj\r\n\r\nThis effect of having a speed up by using `#[inline(never)]` seems to have happened since rustc 1.25. Note it's not a regression it's just that before 1.25 using `#[inline(never)]` would not cause a loop invariant optimization.\r\n\r\nThis peculiarity of `#[inline(never)]` seems to suggest that we could hint better to LLVM about the reachability of variables, such that even after inlining it should still be possible for LLVM to perform a trivial reachability analysis, and conclude that the code could be moved.", "closed_by": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/78944/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/78944/timeline", "performed_via_github_app": null, "state_reason": "completed"}