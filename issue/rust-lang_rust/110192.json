{"url": "https://api.github.com/repos/rust-lang/rust/issues/110192", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/110192/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/110192/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/110192/events", "html_url": "https://github.com/rust-lang/rust/issues/110192", "id": 1662822844, "node_id": "I_kwDOAAsO6M5jHKm8", "number": 110192, "title": "Relocatable section in no_std binary", "user": {"login": "jfgoog", "id": 83229348, "node_id": "MDQ6VXNlcjgzMjI5MzQ4", "avatar_url": "https://avatars.githubusercontent.com/u/83229348?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jfgoog", "html_url": "https://github.com/jfgoog", "followers_url": "https://api.github.com/users/jfgoog/followers", "following_url": "https://api.github.com/users/jfgoog/following{/other_user}", "gists_url": "https://api.github.com/users/jfgoog/gists{/gist_id}", "starred_url": "https://api.github.com/users/jfgoog/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jfgoog/subscriptions", "organizations_url": "https://api.github.com/users/jfgoog/orgs", "repos_url": "https://api.github.com/users/jfgoog/repos", "events_url": "https://api.github.com/users/jfgoog/events{/privacy}", "received_events_url": "https://api.github.com/users/jfgoog/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37547, "node_id": "MDU6TGFiZWwzNzU0Nw==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-linkage", "name": "A-linkage", "color": "f7e101", "default": false, "description": "Area: linking into static, shared libraries and binaries"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}, {"id": 4434124801, "node_id": "LA_kwDOAAsO6M8AAAABCEtgAQ", "url": "https://api.github.com/repos/rust-lang/rust/labels/O-bare-metal", "name": "O-bare-metal", "color": "6e6ec0", "default": false, "description": "Target: Rust without an operating system"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2023-04-11T16:06:15Z", "updated_at": "2023-04-13T18:30:45Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "While experimenting with no_std, I came across a possible bug when using an external crate. I say \"possible\" because when I discussed with a couple of folks more knowledgeable than myself, they weren't sure if it's a rustc bug, a poorly chosen default, or a case of \"yeah, linkers are like that\"\r\n\r\nThe attached code, [no_std_hello.zip](https://github.com/rust-lang/rust/files/11202283/no_std_hello.zip), is a no_std program that depends on an external crate ([ufmt](https://docs.rs/ufmt/latest/ufmt/), which provides formatted output without allocations). It requires an x86_64 Linux machine.\r\n\r\nWhen run, it segfaults:\r\n\r\n```\r\n$ cargo run -q --target x86_64-unknown-none\r\nSegmentation fault\r\n```\r\n\r\nThis can be fixed with `-C relocation-model=static`:\r\n\r\n```\r\n$ RUSTFLAGS=\"-C relocation-model=static\" cargo run -q --target x86_64-unknown-none\r\n42\r\n```\r\n\r\nLooking at the version compiled without RUSTFLAGS (i.e. the one that segfaults), we see that it contains relocatable code, as indicated by the DYNAMIC ELF program header:\r\n\r\n```\r\n$ readelf -l -W target/x86_64-unknown-none/debug/no_std_hello\r\n\r\nElf file type is DYN (Position-Independent Executable file)\r\nEntry point 0x1c6c\r\nThere are 7 program headers, starting at offset 64\r\n\r\nProgram Headers:\r\n  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\r\n  PHDR           0x000040 0x0000000000000040 0x0000000000000040 0x000188 0x000188 R   0x8\r\n  LOAD           0x000000 0x0000000000000000 0x0000000000000000 0x00081a 0x00081a R   0x1000\r\n  LOAD           0x000820 0x0000000000001820 0x0000000000001820 0x001d70 0x001d70 R E 0x1000\r\n  LOAD           0x002590 0x0000000000004590 0x0000000000004590 0x0002e0 0x0002e0 RW  0x1000\r\n  DYNAMIC        0x002710 0x0000000000004710 0x0000000000004710 0x0000e0 0x0000e0 RW  0x8\r\n  GNU_RELRO      0x002590 0x0000000000004590 0x0000000000004590 0x0002e0 0x000a70 R   0x1\r\n  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0\r\n\r\n Section to Segment mapping:\r\n  Segment Sections...\r\n   00\r\n   01     .dynsym .gnu.hash .hash .dynstr .rela.dyn .rodata\r\n   02     .text\r\n   03     .data.rel.ro .dynamic .got\r\n   04     .dynamic\r\n   05     .data.rel.ro .dynamic .got\r\n   06\r\n```\r\n\r\nAnd, indeed, some examination with lldb shows that it segfaults when trying to call a function in a relocatable section. The relocatable section seems to exist because it's a (non-inlined) call to a function in the external crate (ufmt), which is compiled separately and then linked to produce the final binary:\r\n\r\n```\r\n(lldb) bt\r\n* thread #1, name = 'no_std_hello', stop reason = signal SIGSEGV: address not mapped to object (fault address: 0x0)\r\n  * frame #0: 0x0000000000000000\r\n    frame #1: 0x00007ffff7ffbc59 no_std_hello`ufmt::impls::ixx::_$LT$impl$u20$ufmt..uDebug$u20$for$u20$i32$GT$::fmt::h8e97f3b1fc52378d(self=0x00007ffff7ffa5bc, f=0x00007fffffffd5b8) at ixx.rs:94:21\r\n    frame #2: 0x00007ffff7ffbbe7 no_std_hello`no_std_hello::main::_$u7b$$u7b$closure$u7d$$u7d$::h6aa378adeec3265e [inlined] ufmt::impls::ixx::_$LT$impl$u20$ufmt..uDisplay$u20$for$u20$i32$GT$::fmt::hd4a7d095957703c9(self=0x00007ffff7ffa5bc, f=0x00007fffffffd5b8) at ixx.rs:115:9\r\n    frame #3: 0x00007ffff7ffbbe2 no_std_hello`no_std_hello::main::_$u7b$$u7b$closure$u7d$$u7d$::h6aa378adeec3265e(f=0x00007fffffffd5b8) at main.rs:85:5\r\n    frame #4: 0x00007ffff7ffbbac no_std_hello`_$LT$W$u20$as$u20$ufmt..UnstableDoAsFormatter$GT$::do_as_formatter::haa451b76a7c159d9(self=0x00007fffffffd668, f={closure_env#0} @ 0x00007fffffffd5d0) at lib.rs:417:9\r\n    frame #5: 0x00007ffff7ffbf85 no_std_hello`main(_stack_top=\"\\U00000001\") at main.rs:85:5\r\n    frame #6: 0x00007ffff7ffbc74 no_std_hello`_start + 8\r\n```\r\n\r\nThe relevant section from `objdump -d target/x86_64-unknown-none/debug/no_std_hello` shows that we are indeed calling a relocatable function: (I also confirmed in lldb that the call to this function is what's causing the crash, not something else)\r\n\r\n```\r\n0000000000001c10 <_ZN4ufmt5impls3ixx46_$LT$impl$u20$ufmt..uDebug$u20$for$u20$i32$GT$3fmt17h8e97f3b1fc52378dE>:\r\n    1c10:       48 83 ec 38             sub    $0x38,%rsp\r\n    1c14:       48 89 74 24 08          mov    %rsi,0x8(%rsp)\r\n    1c19:       48 89 7c 24 20          mov    %rdi,0x20(%rsp)\r\n    1c1e:       48 89 74 24 28          mov    %rsi,0x28(%rsp)\r\n    1c23:       8a 4c 24 37             mov    0x37(%rsp),%cl\r\n    1c27:       48 8d 44 24 15          lea    0x15(%rsp),%rax\r\n    1c2c:       0f b6 c9                movzbl %cl,%ecx\r\n    1c2f:       48 ba 01 01 01 01 01    movabs $0x101010101010101,%rdx\r\n    1c36:       01 01 01\r\n    1c39:       48 0f af ca             imul   %rdx,%rcx\r\n    1c3d:       48 89 08                mov    %rcx,(%rax)\r\n    1c40:       89 48 07                mov    %ecx,0x7(%rax)\r\n    1c43:       48 63 3f                movslq (%rdi),%rdi\r\n    1c46:       48 8b 05 d3 2b 00 00    mov    0x2bd3(%rip),%rax        # 4820 <_DYNAMIC+0x110>\r\n    1c4d:       48 8d 74 24 15          lea    0x15(%rsp),%rsi\r\n    1c52:       ba 0b 00 00 00          mov    $0xb,%edx\r\n    1c57:       ff d0                   call   *%rax\r\n    1c59:       48 8b 7c 24 08          mov    0x8(%rsp),%rdi\r\n    1c5e:       48 89 c6                mov    %rax,%rsi\r\n    1c61:       e8 ca 03 00 00          call   2030 <_ZN4ufmt18Formatter$LT$W$GT$9write_str17h70e7e896fe1e8040E>\r\n    1c66:       48 83 c4 38             add    $0x38,%rsp\r\n    1c6a:       c3                      ret\r\n    1c6b:       cc                      int3\r\n```\r\n\r\nMy (rudimentary) understanding of ELF files is that when you have relocatable code (either because of a separate shared library or, as in this case, in the program itself), you would expect to see an INTERP header that invokes ld.so to fix up the relocatable addresses. In this case, however, with `--target x86_64-unknown-none`, it would be wrong (not to mention impossible) to construct such a header because we have no idea what the operating system is.\r\n\r\nSo...is this a bug? Or does no_std come with an expectation that you need to understand and customize how your program is linked? If it's not a bug, would a warning message be appropriate?", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/110192/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/110192/timeline", "performed_via_github_app": null, "state_reason": null}