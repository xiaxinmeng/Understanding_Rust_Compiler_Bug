{"url": "https://api.github.com/repos/rust-lang/rust/issues/5801", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/5801/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/5801/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/5801/events", "html_url": "https://github.com/rust-lang/rust/issues/5801", "id": 12974263, "node_id": "MDU6SXNzdWUxMjk3NDI2Mw==", "number": 5801, "title": "region/type inference bug with method", "user": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 36956, "node_id": "MDU6TGFiZWwzNjk1Ng==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-frontend", "name": "A-frontend", "color": "f7e101", "default": false, "description": "Area: frontend (errors, parsing and HIR)"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 9, "created_at": "2013-04-09T14:40:10Z", "updated_at": "2014-04-02T05:26:40Z", "closed_at": "2014-04-02T05:26:40Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "**Update**: I can confirm this is definitely related to regions. An iterator without region annotations doesn't run into this problem.\n\n**Update two**: I've added a  much simpler test case in a comment below.\n\nI'll see if I can cut this down to a simpler test case later. For now, here's a snippet I added to `treemap.rs`:\n\n``` rust\npub trait Iterator<T> {\n    fn next(iter: &mut Self) -> Option<T>;\n}\n\nimpl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V> {\n    fn next(iter: &mut TreeMapIterator<'self, K, V>) -> Option<(&'self K, &'self V)> {\n        map_next(iter)\n    }\n}\n\nimpl<'self, T> Iterator<&'self T> for TreeSetIterator<'self, T> {\n    fn next<'r>(iter: &mut TreeSetIterator<'r, T>) -> Option<&'r T> {\n        set_next(iter)\n    }\n}\n\npub struct ZipIterator<T, U> {\n    priv a: T,\n    priv b: U\n}\n\npub impl<A, B, T: Iterator<A>, U: Iterator<B>> ZipIterator<T, U> {\n    fn new(a: T, b: U) -> ZipIterator<T, U> {\n        ZipIterator{a: a, b: b}\n    }\n}\n\nimpl<A, B, T: Iterator<A>, U: Iterator<B>> Iterator<(A, B)> for ZipIterator<T, U> {\n    fn next(iter: &mut ZipIterator<T, U>) -> Option<(A, B)> {\n        let x = Iterator::next(&mut iter.a);\n        let y = Iterator::next(&mut iter.b);\n        match (x, y) {\n            (Some(a), Some(b)) => Some((a, b)),\n            _ => None\n        }\n    }\n}\n```\n\nand a test case (which compiles and works as it is here):\n\n``` rust\n#[test]\nfn test_zip() {\n    let mut x = TreeSet::new();\n    x.insert(5u);\n    x.insert(12u);\n    x.insert(11u);\n\n    let mut y = TreeSet::new();\n    y.insert(\"foo\");\n    y.insert(\"bar\");\n\n    let x = x;\n    let y = y;\n    let mut z = ZipIterator::new(x.iter(), y.iter());\n\n    // this needs a type hint to compile...\n    let result: Option<(&uint, & &'static str)> = Iterator::next(&mut z);\n    assert!(result.unwrap() == (&5, & &\"bar\"));\n\n    let result: Option<(&uint, & &'static str)> = Iterator::next(&mut z);\n    assert!(result.unwrap() == (&11, & &\"foo\"));\n\n    let result: Option<(&uint, & &'static str)> = Iterator::next(&mut z);\n    assert!(result.is_none());\n}\n```\n\nRemoving the type hint from `result` causes this integer literal inference error:\n\n```\ntreemap.rs:1274:21: 1274:35 error: expected Iterator<&int>, but found Iterator<&uint> (expected int but found uint)\ntreemap.rs:1274         let result = Iterator::next(&mut z);\n                                     ^~~~~~~~~~~~~~\ntreemap.rs:1274:21: 1274:35 error: expected Iterator<&uint>, but found Iterator<&int> (expected uint but found int)\ntreemap.rs:1274         let result = Iterator::next(&mut z);\n                                     ^~~~~~~~~~~~~~\nerror: aborting due to 2 previous errors\n```\n\nSo I tried a workaround like this:\n\n``` rust\n    let result = Iterator::next(&mut z);\n    assert!(result.unwrap() == (&5u, & &\"bar\"));\n```\n\nwhich hits what appears to be a borrow checking bug:\n\n```\ntreemap.rs:1275:37: 1275:39 error: illegal borrow: borrowed value does not live long enough\ntreemap.rs:1275         assert!(result.unwrap() == (&5u, & &\"bar\"));\n                                                     ^~\n<core-macros>:46:4: 57:5 note: in expansion of assert!\ntreemap.rs:1275:8: 1275:52 note: expansion site\ntreemap.rs:1259:18: 1282:5 note: borrowed pointer must be valid for the block at 1259:18...\ntreemap.rs:1259     fn test_zip() {\ntreemap.rs:1260         let mut x = TreeSet::new();\ntreemap.rs:1261         x.insert(5u);\ntreemap.rs:1262         x.insert(12u);\ntreemap.rs:1263         x.insert(11u);\ntreemap.rs:1264 \n                ...\ntreemap.rs:1275:8: 1275:52 note: ...but borrowed value is only valid for the statement at 1275:8\ntreemap.rs:1275         assert!(result.unwrap() == (&5u, & &\"bar\"));\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ntreemap.rs:1275:43: 1275:49 error: illegal borrow: borrowed value does not live long enough\ntreemap.rs:1275         assert!(result.unwrap() == (&5u, & &\"bar\"));\n                                                           ^~~~~~\n<core-macros>:46:4: 57:5 note: in expansion of assert!\ntreemap.rs:1275:8: 1275:52 note: expansion site\ntreemap.rs:1259:18: 1282:5 note: borrowed pointer must be valid for the block at 1259:18...\ntreemap.rs:1259     fn test_zip() {\ntreemap.rs:1260         let mut x = TreeSet::new();\ntreemap.rs:1261         x.insert(5u);\ntreemap.rs:1262         x.insert(12u);\ntreemap.rs:1263         x.insert(11u);\ntreemap.rs:1264 \n                ...\ntreemap.rs:1275:8: 1275:52 note: ...but borrowed value is only valid for the statement at 1275:8\ntreemap.rs:1275         assert!(result.unwrap() == (&5u, & &\"bar\"));\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nerror: aborting due to 2 previous errors\nzsh: exit 101   ~/projects/rust/x86_64-unknown-linux-gnu/stage2/bin/rustc --test treemap.rs\n```\n\nI thought this might be related to `==` being broken in some ways, but yet another error happens with `match`, unless the explicit type hint is used:\n\n``` rust\n    let result = Iterator::next(&mut z);\n\n    match result.unwrap() {\n        (&5u, & &\"bar\") => (),\n        _ => fail!()\n    }\n```\n\n```\ntreemap.rs:1278:13: 1278:17 error: the type of this value must be known in this context\ntreemap.rs:1278             (&5u, & &\"bar\") => (),\n                             ^~~~\ntreemap.rs:1278:13: 1278:17 error: mismatched types: expected `[type error]` found borrowed pointer\ntreemap.rs:1278             (&5u, & &\"bar\") => (),\n                             ^~~~\n```\n\n@nikomatsakis\n", "closed_by": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/5801/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/5801/timeline", "performed_via_github_app": null, "state_reason": "completed"}