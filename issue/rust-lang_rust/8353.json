{"url": "https://api.github.com/repos/rust-lang/rust/issues/8353", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/8353/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/8353/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/8353/events", "html_url": "https://github.com/rust-lang/rust/issues/8353", "id": 17715565, "node_id": "MDU6SXNzdWUxNzcxNTU2NQ==", "number": 8353, "title": "Ability to automatically derive traits on newtypes", "user": {"login": "Seldaek", "id": 183678, "node_id": "MDQ6VXNlcjE4MzY3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/183678?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Seldaek", "html_url": "https://github.com/Seldaek", "followers_url": "https://api.github.com/users/Seldaek/followers", "following_url": "https://api.github.com/users/Seldaek/following{/other_user}", "gists_url": "https://api.github.com/users/Seldaek/gists{/gist_id}", "starred_url": "https://api.github.com/users/Seldaek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Seldaek/subscriptions", "organizations_url": "https://api.github.com/users/Seldaek/orgs", "repos_url": "https://api.github.com/users/Seldaek/repos", "events_url": "https://api.github.com/users/Seldaek/events{/privacy}", "received_events_url": "https://api.github.com/users/Seldaek/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 13, "created_at": "2013-08-06T21:15:49Z", "updated_at": "2014-11-24T22:06:33Z", "closed_at": "2014-11-24T22:06:33Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "## Disclaimer\n\nPlease bear with me, this contains long code samples but you can skip through most of them until the last one if you are only mildly interested, they're just there to illustrate my point.\n## Problem\n\nWhile [adding comments on `rand::rng()`](https://github.com/mozilla/rust/pull/8349/files#L0R613) I figured that it would be a lot better if the function would return a generic \"interface\" type for Rngs instead of returning the type of the particular struct it uses at the moment. However after discussing this with @kballard and @cmr on IRC, it seems that it is now pretty much impossible to achieve.\n\nI'll go through the variants I researched, and then propose a solution (which may not be realistic, I have no clue about rustc internals, but I hope it is).\n## Failed attempt 1: Returning traits as a makeshift interface\n\nThis failed miserably because it's just not how the language works at all, and I got that now, but it's included for completeness.\n\n``` rust\nuse std::rand::{IsaacRng, XorShiftRng, RngUtil, Rng};\n\nfn main() {\n    let rng = rng();\n    printfln!(rng.gen_bytes(10));\n}\n\npub fn rng<T: Rng + RngUtil>() -> T {\n    IsaacRng::new()\n}\n\npub fn weak_rng<T: Rng + RngUtil>() -> T {\n    XorShiftRng::new()\n}\n```\n\n```\ntest.rs:6:4: 7:1 error: mismatched types: expected `T` but found `std::rand::IsaacRng` (expected type parameter but found struct std::rand::IsaacRng)\ntest.rs:6     IsaacRng::new()\ntest.rs:7 }\ntest.rs:10:4: 11:1 error: mismatched types: expected `T` but found `std::rand::XorShiftRng` (expected type parameter but found struct std::rand::XorShiftRng)\ntest.rs:10     XorShiftRng::new()\ntest.rs:11 }\ntest.rs:15:14: 15:31 error: the type of this value must be known in this context\ntest.rs:15     printfln!(rng.gen_bytes(10));\n                         ^~~~~~~~~~~~~~~~~\n```\n## Failed attempt 2: Using newtypes to \"hide\" the real implementation\n\nThis would be an ok workaround, it's not perfect but it seems to be workable given the constraints of the language and isn't too crazy, however it fails because it is missing the proper implementations:\n\n``` rust\nuse std::rand::{IsaacRng, XorShiftRng, RngUtil, Rng};\n\nfn main() {\n    let rng = rng();\n    printfln!(rng.gen_bytes(10));\n}\n\nstruct StrongRng(IsaacRng);\n\npub fn rng() -> StrongRng {\n    StrongRng(IsaacRng::new())\n}\n\nstruct WeakRng(XorShiftRng);\n\npub fn weak_rng() -> WeakRng {\n    WeakRng(XorShiftRng::new())\n}\n```\n\n```\ntest.rs:19:14: 19:31 error: failed to find an implementation of trait std::rand::Rng for StrongRng\ntest.rs:19     printfln!(rng.gen_bytes(10));\n                         ^~~~~~~~~~~~~~~~~\n```\n## Failed attempt 3: Implementing a decorator newtype\n\nThis probably is workable unless I don't get how to work around the compiler errors that are left, but I assume it's not a dead end. The problem though is that it is extremely verbose and seriously painful to write all this boilerplate just to have a straight decorator wrapping the underlying struct.\n\n``` rust\nuse std::rand::{IsaacRng, XorShiftRng, RngUtil, Rng, Weighted, Rand};\n\nfn main() {\n    let rng = rng();\n    printfln!(rng.gen_bytes(10));\n}\n\nstruct StrongRng(IsaacRng);\nimpl Rng for StrongRng {\n    pub fn next(&mut self) -> u32 {\n        return (**self).next();\n    }\n}\nimpl RngUtil for StrongRng {\n    fn gen<T:Rand>(&mut self) -> T {\n        return (**self).gen();\n    }\n    fn gen_int_range(&mut self, start: int, end: int) -> int {\n        return (**self).gen_int_range(start, end);\n    }\n    fn gen_uint_range(&mut self, start: uint, end: uint) -> uint {\n        return (**self).gen_uint_range(start, end);\n    }\n    fn gen_char_from(&mut self, chars: &str) -> char {\n        return (**self).gen_char_from(chars);\n    }\n    fn gen_weighted_bool(&mut self, n: uint) -> bool {\n        return (**self).gen_weighted_bool(n);\n    }\n    fn gen_str(&mut self, len: uint) -> ~str {\n        return (**self).gen_str(len);\n    }\n    fn gen_bytes(&mut self, len: uint) -> ~[u8] {\n        return (**self).gen_bytes(len);\n    }\n    fn choose<T:Clone>(&mut self, values: &[T]) -> T {\n        return (**self).choose(values);\n    }\n    fn choose_option<T:Clone>(&mut self, values: &[T]) -> Option<T> {\n        return (**self).choose_option(values);\n    }\n    fn choose_weighted<T:Clone>(&mut self, v : &[Weighted<T>]) -> T {\n        return (**self).choose_weighted(v);\n    }\n    fn choose_weighted_option<T:Clone>(&mut self, v: &[Weighted<T>]) -> Option<T> {\n        return (**self).choose_weighted_option(v);\n    }\n    fn weighted_vec<T:Clone>(&mut self, v: &[Weighted<T>]) -> ~[T] {\n        return (**self).weighted_vec(v);\n    }\n    fn shuffle<T:Clone>(&mut self, values: &[T]) -> ~[T] {\n        return (**self).shuffle(values);\n    }\n    fn shuffle_mut<T>(&mut self, values: &mut [T]) {\n        (**self).shuffle_mut(values);\n    }\n}\n\npub fn rng() -> StrongRng {\n    StrongRng(IsaacRng::new())\n}\n\nstruct WeakRng(XorShiftRng);\nimpl Rng for WeakRng {\n    pub fn next(&mut self) -> u32 {\n        return (**self).next();\n    }\n}\nimpl RngUtil for WeakRng {\n    fn gen<T:Rand>(&mut self) -> T {\n        return (**self).gen();\n    }\n    fn gen_int_range(&mut self, start: int, end: int) -> int {\n        return (**self).gen_int_range(start, end);\n    }\n    fn gen_uint_range(&mut self, start: uint, end: uint) -> uint {\n        return (**self).gen_uint_range(start, end);\n    }\n    fn gen_char_from(&mut self, chars: &str) -> char {\n        return (**self).gen_char_from(chars);\n    }\n    fn gen_weighted_bool(&mut self, n: uint) -> bool {\n        return (**self).gen_weighted_bool(n);\n    }\n    fn gen_str(&mut self, len: uint) -> ~str {\n        return (**self).gen_str(len);\n    }\n    fn gen_bytes(&mut self, len: uint) -> ~[u8] {\n        return (**self).gen_bytes(len);\n    }\n    fn choose<T:Clone>(&mut self, values: &[T]) -> T {\n        return (**self).choose(values);\n    }\n    fn choose_option<T:Clone>(&mut self, values: &[T]) -> Option<T> {\n        return (**self).choose_option(values);\n    }\n    fn choose_weighted<T:Clone>(&mut self, v : &[Weighted<T>]) -> T {\n        return (**self).choose_weighted(v);\n    }\n    fn choose_weighted_option<T:Clone>(&mut self, v: &[Weighted<T>]) -> Option<T> {\n        return (**self).choose_weighted_option(v);\n    }\n    fn weighted_vec<T:Clone>(&mut self, v: &[Weighted<T>]) -> ~[T] {\n        return (**self).weighted_vec(v);\n    }\n    fn shuffle<T:Clone>(&mut self, values: &[T]) -> ~[T] {\n        return (**self).shuffle(values);\n    }\n    fn shuffle_mut<T>(&mut self, values: &mut [T]) {\n        (**self).shuffle_mut(values);\n    }\n}\npub fn weak_rng() -> WeakRng {\n    WeakRng(XorShiftRng::new())\n}\n```\n\n```\ntest.rs:70:14: 70:31 error: multiple applicable methods in scope\ntest.rs:70     printfln!(rng.gen_bytes(10));\n                         ^~~~~~~~~~~~~~~~~\nnote: in expansion of fmt!\n<std-macros>:226:20: 226:37 note: expansion site\n<std-macros>:224:4: 231:5 note: in expansion of printfln!\ntest.rs:70:4: 70:33 note: expansion site\ntest.rs:98:4: 100:5 note: candidate #1 is `__extensions__::gen_bytes`\ntest.rs:98     fn gen_bytes(&mut self, len: uint) -> ~[u8] {\ntest.rs:99         return (**self).gen_bytes(len);\ntest.rs:100     }\ntest.rs:70:14: 70:31 note: candidate #2 is `std::rand::__extensions__::gen_bytes`\ntest.rs:70     printfln!(rng.gen_bytes(10));\n                         ^~~~~~~~~~~~~~~~~\nnote: in expansion of fmt!\n<std-macros>:226:20: 226:37 note: expansion site\n<std-macros>:224:4: 231:5 note: in expansion of printfln!\ntest.rs:70:4: 70:33 note: expansion site\ntest.rs:79:0: 122:1 error: multiple applicable methods in scope\ntest.rs:79 impl RngUtil for StrongRng {\ntest.rs:80     fn gen<T:Rand>(&mut self) -> T {\ntest.rs:81         return (**self).gen();\ntest.rs:82     }\ntest.rs:83     fn gen_int_range(&mut self, start: int, end: int) -> int {\ntest.rs:84         return (**self).gen_int_range(start, end);\n           ...\ntest.rs:134:0: 177:1 error: multiple applicable methods in scope\ntest.rs:134 impl RngUtil for WeakRng {\ntest.rs:135     fn gen<T:Rand>(&mut self) -> T {\ntest.rs:136         return (**self).gen();\ntest.rs:137     }\ntest.rs:138     fn gen_int_range(&mut self, start: int, end: int) -> int {\ntest.rs:139         return (**self).gen_int_range(start, end);\n            ...\nerror: aborting due to 3 previous errors\n```\n## Proposal\n\nThe ideal way would be to allow the newtype to derive traits, so that making a decorator is not a PITA anymore. As you see right now it fails because the derive can't find the right impl, but I think it should just create it on the fly instead of complaining. That way we get explicit \"interface\" definition by defining which traits are implemented on the newtype, and we can return that and avoid a BC fiasco when we need to change the underlying RNG (see #8349 for more info on that).\n\nI'd be happy to try and help implement this feature because I strongly believe this is needed, but to be honest I have no clue where to even start so pointers would be nice if the consensus is that it is a good thing and that it is at all feasible :)\n\n``` rust\nuse std::rand::{IsaacRng, XorShiftRng, RngUtil, Rng};\n\nfn main() {\n    let rng = rng();\n    printfln!(rng.gen_bytes(10));\n}\n\n#[derive(Rng, RngUtil)]\nstruct StrongRng(IsaacRng);\n\npub fn rng() -> StrongRng {\n    StrongRng(IsaacRng::new())\n}\n\n#[derive(Rng, RngUtil)]\nstruct WeakRng(XorShiftRng);\n\npub fn weak_rng() -> WeakRng {\n    WeakRng(XorShiftRng::new())\n}\n```\n\n```\ntest.rs:70:14: 70:31 error: failed to find an implementation of trait std::rand::Rng for StrongRng\ntest.rs:70     printfln!(rng.gen_bytes(10));\n                         ^~~~~~~~~~~~~~~~~\nnote: in expansion of fmt!\n```\n", "closed_by": {"login": "rust-highfive", "id": 7378925, "node_id": "MDQ6VXNlcjczNzg5MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/7378925?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rust-highfive", "html_url": "https://github.com/rust-highfive", "followers_url": "https://api.github.com/users/rust-highfive/followers", "following_url": "https://api.github.com/users/rust-highfive/following{/other_user}", "gists_url": "https://api.github.com/users/rust-highfive/gists{/gist_id}", "starred_url": "https://api.github.com/users/rust-highfive/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rust-highfive/subscriptions", "organizations_url": "https://api.github.com/users/rust-highfive/orgs", "repos_url": "https://api.github.com/users/rust-highfive/repos", "events_url": "https://api.github.com/users/rust-highfive/events{/privacy}", "received_events_url": "https://api.github.com/users/rust-highfive/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/8353/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/8353/timeline", "performed_via_github_app": null, "state_reason": "completed"}