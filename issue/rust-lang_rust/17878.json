{"url": "https://api.github.com/repos/rust-lang/rust/issues/17878", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/17878/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/17878/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/17878/events", "html_url": "https://github.com/rust-lang/rust/issues/17878", "id": 45317012, "node_id": "MDU6SXNzdWU0NTMxNzAxMg==", "number": 17878, "title": "boxed iterators cause a stack overflow", "user": {"login": "BurntSushi", "id": 456674, "node_id": "MDQ6VXNlcjQ1NjY3NA==", "avatar_url": "https://avatars.githubusercontent.com/u/456674?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BurntSushi", "html_url": "https://github.com/BurntSushi", "followers_url": "https://api.github.com/users/BurntSushi/followers", "following_url": "https://api.github.com/users/BurntSushi/following{/other_user}", "gists_url": "https://api.github.com/users/BurntSushi/gists{/gist_id}", "starred_url": "https://api.github.com/users/BurntSushi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BurntSushi/subscriptions", "organizations_url": "https://api.github.com/users/BurntSushi/orgs", "repos_url": "https://api.github.com/users/BurntSushi/repos", "events_url": "https://api.github.com/users/BurntSushi/events{/privacy}", "received_events_url": "https://api.github.com/users/BurntSushi/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2014-10-09T01:16:06Z", "updated_at": "2014-10-09T01:23:53Z", "closed_at": "2014-10-09T01:23:03Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "This code used to work (I'm not sure when it stopped working, but it was in the last few weeks I think):\n\n``` rust\ntrait MyIter<A> : Iterator<A> {}\nimpl<A, I: Iterator<A>> MyIter<A> for I {}\n\nimpl<A> Iterator<A> for Box<MyIter<A>+'static> {\n    fn next(&mut self) -> Option<A> { self.next() }\n}\n\nfn main() {\n    let xs = vec![0u, 1, 2, 3];\n    let mut boxed_iter = box xs.into_iter() as Box<MyIter<uint>+'static>;\n    for x in boxed_iter { println!(\"{}\", x); }\n}\n```\n\nWhen I compile and run that, I get:\n\n``` rust\n[andrew@Liger rust] rustc -g scratch.rs && ./scratch\ntask '<main>' has overflowed its stack\nIllegal instruction (core dumped)\n```\n\n`valgrind` shows that it's getting stuck in an infinite loop inside `next`:\n\n``` rust\n[andrew@Liger rust] rustc -g scratch.rs && ./scratch\ntask '<main>' has overflowed its stack\nIllegal instruction (core dumped)\n[andrew@Liger rust] rustc -g scratch.rs && valgrind ./scratch\n==20580== Memcheck, a memory error detector\n==20580== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.\n==20580== Using Valgrind-3.10.0 and LibVEX; rerun with -h for copyright info\n==20580== Command: ./scratch\n==20580== \ntask '<main>' has overflowed its stack\n==20580== valgrind: Unrecognised instruction at address 0x15acf0.\n==20580==    at 0x15ACF0: rust_stack_exhausted (in /home/andrew/tmp/rust/scratch)\n==20580==    by 0x1139A0: ??? (in /home/andrew/tmp/rust/scratch)\n==20580==    by 0x113890: Box$LT$MyIter$LT$A$GT$$x2b$x20$x27static$GT$.Iterator$LT$A$GT$::next::h9056361317304617949 (scratch.rs:6)\n==20580==    by 0x113890: Box$LT$MyIter$LT$A$GT$$x2b$x20$x27static$GT$.Iterator$LT$A$GT$::next::h9056361317304617949 (scratch.rs:6)\n==20580==    by 0x113890: Box$LT$MyIter$LT$A$GT$$x2b$x20$x27static$GT$.Iterator$LT$A$GT$::next::h9056361317304617949 (scratch.rs:6)\n==20580==    by 0x113890: Box$LT$MyIter$LT$A$GT$$x2b$x20$x27static$GT$.Iterator$LT$A$GT$::next::h9056361317304617949 (scratch.rs:6)\n==20580==    by 0x113890: Box$LT$MyIter$LT$A$GT$$x2b$x20$x27static$GT$.Iterator$LT$A$GT$::next::h9056361317304617949 (scratch.rs:6)\n==20580==    by 0x113890: Box$LT$MyIter$LT$A$GT$$x2b$x20$x27static$GT$.Iterator$LT$A$GT$::next::h9056361317304617949 (scratch.rs:6)\n==20580==    by 0x113890: Box$LT$MyIter$LT$A$GT$$x2b$x20$x27static$GT$.Iterator$LT$A$GT$::next::h9056361317304617949 (scratch.rs:6)\n==20580==    by 0x113890: Box$LT$MyIter$LT$A$GT$$x2b$x20$x27static$GT$.Iterator$LT$A$GT$::next::h9056361317304617949 (scratch.rs:6)\n==20580==    by 0x113890: Box$LT$MyIter$LT$A$GT$$x2b$x20$x27static$GT$.Iterator$LT$A$GT$::next::h9056361317304617949 (scratch.rs:6)\n==20580==    by 0x113890: Box$LT$MyIter$LT$A$GT$$x2b$x20$x27static$GT$.Iterator$LT$A$GT$::next::h9056361317304617949 (scratch.rs:6)\n==20580== Your program just tried to execute an instruction that Valgrind\n==20580== did not recognise.  There are two possible reasons for this.\n==20580== 1. Your program has a bug and erroneously jumped to a non-code\n==20580==    location.  If you are running Memcheck and you just saw a\n==20580==    warning about a bad jump, it's probably your program's fault.\n==20580== 2. The instruction is legitimate but Valgrind doesn't handle it,\n==20580==    i.e. it's Valgrind's fault.  If you think this is the case or\n==20580==    you are not sure, please let us know and we'll try to fix it.\n==20580== Either way, Valgrind will now raise a SIGILL signal which will\n==20580== probably kill your program.\n==20580== \n==20580== Process terminating with default action of signal 4 (SIGILL)\n==20580==  Illegal opcode at address 0x15ACF0\n==20580==    at 0x15ACF0: rust_stack_exhausted (in /home/andrew/tmp/rust/scratch)\n==20580==    by 0x1139A0: ??? (in /home/andrew/tmp/rust/scratch)\n==20580==    by 0x113890: Box$LT$MyIter$LT$A$GT$$x2b$x20$x27static$GT$.Iterator$LT$A$GT$::next::h9056361317304617949 (scratch.rs:6)\n==20580==    by 0x113890: Box$LT$MyIter$LT$A$GT$$x2b$x20$x27static$GT$.Iterator$LT$A$GT$::next::h9056361317304617949 (scratch.rs:6)\n==20580==    by 0x113890: Box$LT$MyIter$LT$A$GT$$x2b$x20$x27static$GT$.Iterator$LT$A$GT$::next::h9056361317304617949 (scratch.rs:6)\n==20580==    by 0x113890: Box$LT$MyIter$LT$A$GT$$x2b$x20$x27static$GT$.Iterator$LT$A$GT$::next::h9056361317304617949 (scratch.rs:6)\n==20580==    by 0x113890: Box$LT$MyIter$LT$A$GT$$x2b$x20$x27static$GT$.Iterator$LT$A$GT$::next::h9056361317304617949 (scratch.rs:6)\n==20580==    by 0x113890: Box$LT$MyIter$LT$A$GT$$x2b$x20$x27static$GT$.Iterator$LT$A$GT$::next::h9056361317304617949 (scratch.rs:6)\n==20580==    by 0x113890: Box$LT$MyIter$LT$A$GT$$x2b$x20$x27static$GT$.Iterator$LT$A$GT$::next::h9056361317304617949 (scratch.rs:6)\n==20580==    by 0x113890: Box$LT$MyIter$LT$A$GT$$x2b$x20$x27static$GT$.Iterator$LT$A$GT$::next::h9056361317304617949 (scratch.rs:6)\n==20580==    by 0x113890: Box$LT$MyIter$LT$A$GT$$x2b$x20$x27static$GT$.Iterator$LT$A$GT$::next::h9056361317304617949 (scratch.rs:6)\n==20580==    by 0x113890: Box$LT$MyIter$LT$A$GT$$x2b$x20$x27static$GT$.Iterator$LT$A$GT$::next::h9056361317304617949 (scratch.rs:6)\n==20580== \n==20580== HEAP SUMMARY:\n==20580==     in use at exit: 592 bytes in 9 blocks\n==20580==   total heap usage: 11 allocs, 2 frees, 640 bytes allocated\n==20580== \n==20580== LEAK SUMMARY:\n==20580==    definitely lost: 0 bytes in 0 blocks\n==20580==    indirectly lost: 0 bytes in 0 blocks\n==20580==      possibly lost: 0 bytes in 0 blocks\n==20580==    still reachable: 592 bytes in 9 blocks\n==20580==         suppressed: 0 bytes in 0 blocks\n==20580== Rerun with --leak-check=full to see details of leaked memory\n==20580== \n==20580== For counts of detected and suppressed errors, rerun with: -v\n==20580== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\nIllegal instruction (core dumped)\n```\n\nSo did something change that affects the resolution of `self.next()`?\n\nFYI, `quickcheck` uses this trick to define an [`Arbitrary`](https://github.com/BurntSushi/quickcheck/blob/master/src/arbitrary.rs#L106-L111) trait. Maybe there's another way?\n", "closed_by": {"login": "BurntSushi", "id": 456674, "node_id": "MDQ6VXNlcjQ1NjY3NA==", "avatar_url": "https://avatars.githubusercontent.com/u/456674?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BurntSushi", "html_url": "https://github.com/BurntSushi", "followers_url": "https://api.github.com/users/BurntSushi/followers", "following_url": "https://api.github.com/users/BurntSushi/following{/other_user}", "gists_url": "https://api.github.com/users/BurntSushi/gists{/gist_id}", "starred_url": "https://api.github.com/users/BurntSushi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BurntSushi/subscriptions", "organizations_url": "https://api.github.com/users/BurntSushi/orgs", "repos_url": "https://api.github.com/users/BurntSushi/repos", "events_url": "https://api.github.com/users/BurntSushi/events{/privacy}", "received_events_url": "https://api.github.com/users/BurntSushi/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/17878/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/17878/timeline", "performed_via_github_app": null, "state_reason": "completed"}