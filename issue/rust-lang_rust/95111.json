{"url": "https://api.github.com/repos/rust-lang/rust/issues/95111", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/95111/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/95111/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/95111/events", "html_url": "https://github.com/rust-lang/rust/issues/95111", "id": 1174268372, "node_id": "I_kwDOAAsO6M5F_enU", "number": 95111, "title": "Async Tokio Endpoint packet receiver returning compiler error", "user": {"login": "seun-ja", "id": 34725212, "node_id": "MDQ6VXNlcjM0NzI1MjEy", "avatar_url": "https://avatars.githubusercontent.com/u/34725212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seun-ja", "html_url": "https://github.com/seun-ja", "followers_url": "https://api.github.com/users/seun-ja/followers", "following_url": "https://api.github.com/users/seun-ja/following{/other_user}", "gists_url": "https://api.github.com/users/seun-ja/gists{/gist_id}", "starred_url": "https://api.github.com/users/seun-ja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seun-ja/subscriptions", "organizations_url": "https://api.github.com/users/seun-ja/orgs", "repos_url": "https://api.github.com/users/seun-ja/repos", "events_url": "https://api.github.com/users/seun-ja/events{/privacy}", "received_events_url": "https://api.github.com/users/seun-ja/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 9618520, "node_id": "MDU6TGFiZWw5NjE4NTIw", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-ICE", "name": "I-ICE", "color": "e10c02", "default": false, "description": "Issue: The compiler panicked, giving an Internal Compilation Error (ICE) \u2744\ufe0f"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2022-03-19T13:41:30Z", "updated_at": "2022-03-19T13:41:30Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "<!--\r\nThank you for finding an Internal Compiler Error! \ud83e\uddca  If possible, try to provide\r\na minimal verifiable example. You can read \"Rust Bug Minimization Patterns\" for\r\nhow to create smaller examples.\r\n\r\nhttp://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\r\n\r\n-->\r\n\r\n### Code\r\n\r\n```Rust\r\n#[tokio::main]\r\nasync fn run(options: Opt) -> Result<()> {\r\n    let url = options.url;\r\n    let remote = (url.host_str().unwrap(), url.port().unwrap_or(4433))\r\n        .to_socket_addrs()?\r\n        .next()\r\n        .ok_or_else(|| anyhow!(\"couldn't resolve to an address\"))?;\r\n\r\n    let mut roots = rustls::RootCertStore::empty();\r\n    if let Some(ca_path) = options.ca {\r\n        roots.add(&rustls::Certificate(fs::read(&ca_path)?))?;\r\n    } else {\r\n        match fs::read(Path::new(\"resources/certs/cert.der\")) {\r\n            Ok(cert) => {\r\n                roots.add(&rustls::Certificate(cert))?;\r\n            }\r\n            Err(ref e) if e.kind() == io::ErrorKind::NotFound => {\r\n                info!(\"local server certificate not found\");\r\n            }\r\n            Err(e) => {\r\n                error!(\"failed to open local server certificate: {}\", e);\r\n            }\r\n        }\r\n    }\r\n    let mut client_crypto = rustls::ClientConfig::builder()\r\n        .with_safe_defaults()\r\n        .with_root_certificates(roots)\r\n        .with_no_client_auth();\r\n\r\n    client_crypto.alpn_protocols = common::ALPN_QUIC_HTTP.iter().map(|&x| x.into()).collect();\r\n    if options.keylog {\r\n        client_crypto.key_log = Arc::new(rustls::KeyLogFile::new());\r\n    }\r\n\r\n    let mut endpoint = quinn::Endpoint::client(\"[::]:0\".parse().unwrap())?;\r\n    let mut config =quinn::ClientConfig::new(Arc::new(client_crypto));\r\n\r\n    Arc::get_mut(&mut config.transport)\r\n        .unwrap()\r\n        .max_idle_timeout(Some(IdleTimeout::try_from(Duration::from_secs(120)).unwrap()))\r\n        .max_concurrent_uni_streams(100000_u32.into())\r\n        .keep_alive_interval(Some(Duration::from_secs(60)));\r\n\r\n    endpoint.set_default_client_config(config);\r\n\r\n    let request = format!(\"GET {}\\r\\n\", url.path());\r\n    eprintln!(\"REQUEST DETAILS : {:?} \",request);\r\n    let start = Instant::now();\r\n    let rebind = options.rebind;\r\n    let host = options\r\n        .host\r\n        .as_ref()\r\n        .map_or_else(|| url.host_str(), |x| Some(x))\r\n        .ok_or_else(|| anyhow!(\"no hostname specified\"))?;\r\n\r\n    eprintln!(\"connecting to {} at {}\", host, remote);\r\n    let new_conn = endpoint\r\n        .connect(remote, host)?\r\n        .await\r\n        .map_err(|e| anyhow!(\"failed to connect: {}\", e))?;\r\n    eprintln!(\"connected at {:?}\", start.elapsed());\r\n    let quinn::NewConnection {\r\n        connection: conn, ..\r\n    } = new_conn;\r\n    let (mut send, recv) = conn\r\n        .open_bi()\r\n        .await\r\n        .map_err(|e| anyhow!(\"failed to open stream: {}\", e))?;\r\n    if rebind {\r\n        let socket = std::net::UdpSocket::bind(\"[::]:0\").unwrap();\r\n        let addr = socket.local_addr().unwrap();\r\n        eprintln!(\"rebinding to {}\", addr);\r\n        endpoint.rebind(socket).expect(\"rebind failed\");\r\n    }\r\n\r\n    send.write_all(request.as_bytes())\r\n        .await\r\n        .map_err(|e| anyhow!(\"failed to send request: {}\", e))?;\r\n    send.finish()\r\n        .await\r\n        .map_err(|e| anyhow!(\"failed to shutdown stream: {}\", e))?;\r\n    let response_start = Instant::now();\r\n    eprintln!(\"request sent at {:?}\", response_start - start);\r\n    let resp = recv\r\n        .read_to_end(usize::MAX)\r\n        .await\r\n        .map_err(|e| anyhow!(\"failed to read response: {}\", e))?;\r\n    let duration = response_start.elapsed();\r\n    eprintln!(\r\n        \"response received in {:?} - {} KiB/s\",\r\n        duration,\r\n        resp.len() as f32 / (duration_secs(&duration) * 1024.0)\r\n    );\r\n    io::stdout().write_all(&resp).unwrap();\r\n    io::stdout().flush().unwrap();\r\n    eprintln!(\r\n        \"response received in {:?} - {} KiB/s\",\r\n        duration,\r\n        resp.len() as f32 / (duration_secs(&duration) * 1024.0)\r\n    );\r\n\r\n    conn.close(0u32.into(), b\"done\");\r\n\r\n    // Give the server a fair chance to receive the close packet\r\n    endpoint.wait_idle().await;\r\n\r\n    Ok(())\r\n}\r\n```\r\n\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.60.0-nightly (bfe156467 2022-01-22)\r\nbinary: rustc\r\ncommit-hash: bfe15646761a75f0259e204cab071565eed2b1e5\r\ncommit-date: 2022-01-22\r\nhost: aarch64-apple-darwin\r\nrelease: 1.60.0-nightly\r\nLLVM version: 13.0.0\r\n```\r\n\r\n### Error output\r\n\r\n```\r\nerror: internal compiler error: compiler/rustc_mir_transform/src/generator.rs:755:13: Broken MIR: generator contains type rustls::ClientConfig in MIR, but typeck only knows about {ResumeTy, Url, std::net::SocketAddr, RootCertStore, Endpoint, String, std::time::Instant, bool, &str, &Endpoint, ControlFlow<Result<Infallible, ConnectError>, Connecting>, Connecting, (), NewConnection, quinn::Connection, &quinn::Connection, OpenBi, SendStream, RecvStream, &String, &[u8], quinn::send_stream::WriteAll, quinn::send_stream::Finish, usize, ReadToEnd, Vec<u8>, Duration, impl Future<Output = ()>} and [&bool, url::Url, &std::option::Option<std::string::String>, std::option::Option<std::path::PathBuf>, &bool]\r\n   --> src/bin/client.rs:64:42\r\n    |\r\n64  |   async fn run(options: Opt) -> Result<()> {\r\n    |  __________________________________________^\r\n65  | |     let url = options.url;\r\n66  | |     let remote = (url.host_str().unwrap(), url.port().unwrap_or(4433))\r\n67  | |         .to_socket_addrs()?\r\n...   |\r\n169 | |     Ok(())\r\n170 | | }\r\n    | |_^\r\n```\r\n\r\n<!--\r\nInclude a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\r\nenvironment. E.g. `RUST_BACKTRACE=1 cargo build`.\r\n-->\r\n<details><summary><strong>Backtrace</strong></summary>\r\n<p>\r\n\r\n```\r\n<backtrace>\r\n```\r\n\r\n</p>\r\n</details>\r\n\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/95111/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/95111/timeline", "performed_via_github_app": null, "state_reason": null}