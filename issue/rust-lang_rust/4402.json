{"url": "https://api.github.com/repos/rust-lang/rust/issues/4402", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/4402/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/4402/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/4402/events", "html_url": "https://github.com/rust-lang/rust/issues/4402", "id": 9814324, "node_id": "MDU6SXNzdWU5ODE0MzI0", "number": 4402, "title": "Extra level of indirection with explicit self", "user": {"login": "bstrie", "id": 865233, "node_id": "MDQ6VXNlcjg2NTIzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstrie", "html_url": "https://github.com/bstrie", "followers_url": "https://api.github.com/users/bstrie/followers", "following_url": "https://api.github.com/users/bstrie/following{/other_user}", "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions", "organizations_url": "https://api.github.com/users/bstrie/orgs", "repos_url": "https://api.github.com/users/bstrie/repos", "events_url": "https://api.github.com/users/bstrie/events{/privacy}", "received_events_url": "https://api.github.com/users/bstrie/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234956, "node_id": "MDU6TGFiZWwyMzQ5NTY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-codegen", "name": "A-codegen", "color": "f7e101", "default": false, "description": "Area: Code generation"}, {"id": 13836860, "node_id": "MDU6TGFiZWwxMzgzNjg2MA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-traits", "name": "A-traits", "color": "f7e101", "default": false, "description": "Area: Trait system"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2013-01-09T17:50:15Z", "updated_at": "2013-07-10T05:59:21Z", "closed_at": "2013-07-10T05:59:21Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I found a multi-language benchmark online (https://gist.github.com/1170424) whose Rust version was outdated. I decided to update it.\n\nHere's the original code:\n\n```\nstruct Vec2 {\n    x: f32,\n    y: f32,\n}\n\nfn lerp(a: f32, b: f32, v: f32) -> f32 {\n    a * (1f32 - v) + b * v\n}\n\nfn smooth(v: f32) -> f32 {\n    v * v * (3f32 - 2f32 * v)\n}\n\nfn random_gradient(r: rand::Rng) -> Vec2 {\n    let v = r.gen_float() * float::consts::pi * 2.0;\n    Vec2{\n        x: float::cos(v) as f32,\n        y: float::sin(v) as f32,\n    }\n}\n\nfn gradient(orig: Vec2, grad: Vec2, p: Vec2) -> f32 {\n    let sp = Vec2{x: p.x - orig.x, y: p.y - orig.y};\n    grad.x * sp.x + grad.y + sp.y\n}\n\nstruct Noise2DContext {\n    rgradients: ~[Vec2],\n    permutations: ~[int],\n}\n\nfn Noise2DContext() -> ~Noise2DContext {\n    let r = rand::Rng();\n    let rgradients = do vec::from_fn(256) |_i| { random_gradient(r) };\n    let mut permutations = do vec::from_fn(256) |i| { i as int };\n    r.shuffle_mut(permutations);\n\n    ~Noise2DContext{\n        rgradients: move rgradients,\n        permutations: move permutations,\n    }\n}\n\nimpl Noise2DContext {\n    fn get_gradient(x: int, y: int) -> Vec2 {\n        let idx = self.permutations[x & 255] + self.permutations[y & 255];\n        self.rgradients[idx & 255]\n    }\n\n    fn get_gradients(gradients: &[mut Vec2 * 4], origins: &[mut Vec2 * 4], x: f32, y: f32) {\n        let x0f = float::floor(x as libc::c_double) as f32;\n        let y0f = float::floor(y as libc::c_double) as f32;\n        let x0 = x0f as int;\n        let y0 = y0f as int;\n        let x1 = x0 + 1;\n        let y1 = y0 + 1;\n\n        gradients[0] = self.get_gradient(x0, y0);\n        gradients[1] = self.get_gradient(x1, y0);\n        gradients[2] = self.get_gradient(x0, y1);\n        gradients[3] = self.get_gradient(x1, y1);\n\n        origins[0] = Vec2{x: x0f + 0f32, y: y0f + 0f32};\n        origins[1] = Vec2{x: x0f + 1f32, y: y0f + 0f32};\n        origins[2] = Vec2{x: x0f + 0f32, y: y0f + 1f32};\n        origins[3] = Vec2{x: x0f + 1f32, y: y0f + 1f32};\n    }\n\n    fn get(x: f32, y: f32) -> f32 {\n        let p = Vec2{x: x, y: y};\n        let gradients: [mut Vec2 * 4] = [mut\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n        ];\n        let origins: [mut Vec2 * 4] = [mut\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n        ];\n        self.get_gradients(&gradients, &origins, x, y);\n        let v0 = gradient(origins[0], gradients[0], p);\n        let v1 = gradient(origins[1], gradients[1], p);\n        let v2 = gradient(origins[2], gradients[2], p);\n        let v3 = gradient(origins[3], gradients[3], p);\n        let fx = smooth(x - origins[0].x);\n        let vx0 = lerp(v0, v1, fx);\n        let vx1 = lerp(v2, v3, fx);\n        let fy = smooth(y - origins[0].y);\n        lerp(vx0, vx1, fy)\n    }\n}\n\nfn main() {\n    let symbols = [\" \", \"\u2591\", \"\u2592\", \"\u2593\", \"\u2588\", \"\u2588\"];\n    let pixels = vec::to_mut(vec::from_elem(256*256, 0f32));\n    let n2d = Noise2DContext();\n    for int::range(0, 100) |_i| {\n        for int::range(0, 256) |y| {\n            for int::range(0, 256) |x| {\n                let v = n2d.get(\n                    x as f32 * 0.1f32,\n                    y as f32 * 0.1f32\n                ) * 0.5f32 + 0.5f32;\n                pixels[y*256+x] = v;\n            };\n        };\n    };\n\n    for int::range(0, 256) |y| {\n        for int::range(0, 256) |x| {\n            io::print(symbols[pixels[y*256+x] / 0.2f32 as int]);\n        }\n        io::println(\"\");\n    }\n}\n```\n\nI noticed that updating this code to use explicit self causes a noticeable perf hit, even though nmatsakis assures me that the semantics should be the same. For posterity, here's the updated version (the only difference is that the three methods are using explicit `&self` parameters):\n\n```\nstruct Vec2 {\n    x: f32,\n    y: f32,\n}\n\nfn lerp(a: f32, b: f32, v: f32) -> f32 {\n    a * (1f32 - v) + b * v\n}\n\nfn smooth(v: f32) -> f32 {\n    v * v * (3f32 - 2f32 * v)\n}\n\nfn random_gradient(r: rand::Rng) -> Vec2 {\n    let v = r.gen_float() * float::consts::pi * 2.0;\n    Vec2{\n        x: float::cos(v) as f32,\n        y: float::sin(v) as f32,\n    }\n}\n\nfn gradient(orig: Vec2, grad: Vec2, p: Vec2) -> f32 {\n    let sp = Vec2{x: p.x - orig.x, y: p.y - orig.y};\n    grad.x * sp.x + grad.y + sp.y\n}\n\nstruct Noise2DContext {\n    rgradients: ~[Vec2],\n    permutations: ~[int],\n}\n\nfn Noise2DContext() -> ~Noise2DContext {\n    let r = rand::Rng();\n    let rgradients = do vec::from_fn(256) |_i| { random_gradient(r) };\n    let mut permutations = do vec::from_fn(256) |i| { i as int };\n    r.shuffle_mut(permutations);\n\n    ~Noise2DContext{\n        rgradients: move rgradients,\n        permutations: move permutations,\n    }\n}\n\nimpl Noise2DContext {\n    fn get_gradient(&self, x: int, y: int) -> Vec2 {\n        let idx = self.permutations[x & 255] + self.permutations[y & 255];\n        self.rgradients[idx & 255]\n    }\n\n    fn get_gradients(&self, gradients: &[mut Vec2 * 4], origins: &[mut Vec2 * 4], x: f32, y: f32) {\n        let x0f = float::floor(x as libc::c_double) as f32;\n        let y0f = float::floor(y as libc::c_double) as f32;\n        let x0 = x0f as int;\n        let y0 = y0f as int;\n        let x1 = x0 + 1;\n        let y1 = y0 + 1;\n\n        gradients[0] = self.get_gradient(x0, y0);\n        gradients[1] = self.get_gradient(x1, y0);\n        gradients[2] = self.get_gradient(x0, y1);\n        gradients[3] = self.get_gradient(x1, y1);\n\n        origins[0] = Vec2{x: x0f + 0f32, y: y0f + 0f32};\n        origins[1] = Vec2{x: x0f + 1f32, y: y0f + 0f32};\n        origins[2] = Vec2{x: x0f + 0f32, y: y0f + 1f32};\n        origins[3] = Vec2{x: x0f + 1f32, y: y0f + 1f32};\n    }\n\n    fn get(&self, x: f32, y: f32) -> f32 {\n        let p = Vec2{x: x, y: y};\n        let gradients: [mut Vec2 * 4] = [mut\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n        ];\n        let origins: [mut Vec2 * 4] = [mut\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n            Vec2{x:0f32, y:0f32},\n        ];\n        self.get_gradients(&gradients, &origins, x, y);\n        let v0 = gradient(origins[0], gradients[0], p);\n        let v1 = gradient(origins[1], gradients[1], p);\n        let v2 = gradient(origins[2], gradients[2], p);\n        let v3 = gradient(origins[3], gradients[3], p);\n        let fx = smooth(x - origins[0].x);\n        let vx0 = lerp(v0, v1, fx);\n        let vx1 = lerp(v2, v3, fx);\n        let fy = smooth(y - origins[0].y);\n        lerp(vx0, vx1, fy)\n    }\n}\n\nfn main() {\n    let symbols = [\" \", \"\u2591\", \"\u2592\", \"\u2593\", \"\u2588\", \"\u2588\"];\n    let pixels = vec::to_mut(vec::from_elem(256*256, 0f32));\n    let n2d = Noise2DContext();\n    for int::range(0, 100) |_i| {\n        for int::range(0, 256) |y| {\n            for int::range(0, 256) |x| {\n                let v = n2d.get(\n                    x as f32 * 0.1f32,\n                    y as f32 * 0.1f32\n                ) * 0.5f32 + 0.5f32;\n                pixels[y*256+x] = v;\n            };\n        };\n    };\n\n    for int::range(0, 256) |y| {\n        for int::range(0, 256) |x| {\n            io::print(symbols[pixels[y*256+x] / 0.2f32 as int]);\n        }\n        io::println(\"\");\n    }\n}\n```\n\nBoth versions were compiled with `rustc --opt-level=3` and profiled as follows:\n\n```\n$ (perf stat -r 10 perlin-orig) 2> orig.txt\n$ (perf stat -r 10 perlin-expself) 2> expself.txt\n```\n\norig.txt:\n\n```\n Performance counter stats for 'perlin-orig' (10 runs):\n\n    1352.872451  task-clock-msecs         #      0.983 CPUs    ( +-   0.177% )\n             97  context-switches         #      0.000 M/sec   ( +-   5.580% )\n              1  CPU-migrations           #      0.000 M/sec   ( +-   9.091% )\n            738  page-faults              #      0.001 M/sec   ( +-   0.036% )\n   209379655582  cycles                   # 154766.738 M/sec   ( +-   5.099% )\n   209379655582  instructions             #      1.000 IPC     ( +-   5.099% )\n   209379655582  branches                 # 154766.738 M/sec   ( +-   5.099% )\n   209379655582  branch-misses            #    100.000 %       ( +-   5.099% )\n   209379655582  cache-references         # 154766.738 M/sec   ( +-   5.099% )\n   209379655582  cache-misses             # 154766.738 M/sec   ( +-   5.099% )\n\n    1.376399979  seconds time elapsed   ( +-   0.213% )\n```\n\nexpself.txt:\n\n```\n Performance counter stats for 'perlin-expself' (10 runs):\n\n    1389.736506  task-clock-msecs         #      0.983 CPUs    ( +-   0.096% )\n            103  context-switches         #      0.000 M/sec   ( +-   7.792% )\n              1  CPU-migrations           #      0.000 M/sec   ( +-  11.111% )\n            738  page-faults              #      0.001 M/sec   ( +-   0.049% )\n   224626789476  cycles                   # 161632.646 M/sec   ( +-   6.994% )\n   224626789476  instructions             #      1.000 IPC     ( +-   6.994% )\n   224626789476  branches                 # 161632.646 M/sec   ( +-   6.994% )\n   224626789476  branch-misses            #    100.000 %       ( +-   6.994% )\n   224626789476  cache-references         # 161632.646 M/sec   ( +-   6.994% )\n   224626789476  cache-misses             # 161632.646 M/sec   ( +-   6.994% )\n\n    1.413482586  seconds time elapsed   ( +-   0.240% )\n```\n\n@nikomatsakis has a theory:\n\n```\n< bstrie> why is explicit self slower than implicit self :(\n<@nmatsakis> bstrie: the trans for that is kind of bad... I wonder if it's\n             introducing extra indirections or something\n<@nmatsakis> the trans of self in general needs to be reworked\n```\n", "closed_by": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/4402/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/4402/timeline", "performed_via_github_app": null, "state_reason": "completed"}