{"url": "https://api.github.com/repos/rust-lang/rust/issues/43539", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/43539/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/43539/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/43539/events", "html_url": "https://github.com/rust-lang/rust/issues/43539", "id": 246514517, "node_id": "MDU6SXNzdWUyNDY1MTQ1MTc=", "number": 43539, "title": "How to handle join when it's called from the associated thread?", "user": {"login": "BusyJay", "id": 1701473, "node_id": "MDQ6VXNlcjE3MDE0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/1701473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BusyJay", "html_url": "https://github.com/BusyJay", "followers_url": "https://api.github.com/users/BusyJay/followers", "following_url": "https://api.github.com/users/BusyJay/following{/other_user}", "gists_url": "https://api.github.com/users/BusyJay/gists{/gist_id}", "starred_url": "https://api.github.com/users/BusyJay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BusyJay/subscriptions", "organizations_url": "https://api.github.com/users/BusyJay/orgs", "repos_url": "https://api.github.com/users/BusyJay/repos", "events_url": "https://api.github.com/users/BusyJay/events{/privacy}", "received_events_url": "https://api.github.com/users/BusyJay/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-07-29T10:47:35Z", "updated_at": "2019-12-10T15:04:20Z", "closed_at": "2019-12-10T15:04:19Z", "author_association": "NONE", "active_lock_reason": null, "body": "Considering following snippets:\r\n\r\n```\r\nuse std::thread::{self, JoinHandle};\r\nuse std::sync::mpsc;\r\n\r\nfn main() {\r\n    let (tx, rx) = mpsc::channel::<JoinHandle<()>>();\r\n    let j = thread::spawn(move || {\r\n        while let Ok(h) = rx.recv() {\r\n            h.join().unwrap();\r\n        }\r\n    });\r\n    tx.send(j).unwrap();\r\n    thread::sleep_ms(1000);\r\n}\r\n```\r\n\r\nCurrently on linux, the spawned thread will just panic at option unwrap which happen inside std library:\r\n\r\n```\r\nthread '<unnamed>' panicked at 'called `Option::unwrap()` on a `None` value', /checkout/src/libcore/option.rs:335\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\nstack backtrace:\r\n   0: std::sys::imp::backtrace::tracing::imp::unwind_backtrace\r\n             at /checkout/src/libstd/sys/unix/backtrace/tracing/gcc_s.rs:49\r\n   1: std::sys_common::backtrace::_print\r\n             at /checkout/src/libstd/sys_common/backtrace.rs:71\r\n   2: std::panicking::default_hook::{{closure}}\r\n             at /checkout/src/libstd/sys_common/backtrace.rs:60\r\n             at /checkout/src/libstd/panicking.rs:355\r\n   3: std::panicking::default_hook\r\n             at /checkout/src/libstd/panicking.rs:371\r\n   4: std::panicking::rust_panic_with_hook\r\n             at /checkout/src/libstd/panicking.rs:549\r\n   5: std::panicking::begin_panic\r\n             at /checkout/src/libstd/panicking.rs:511\r\n   6: std::panicking::begin_panic_fmt\r\n             at /checkout/src/libstd/panicking.rs:495\r\n   7: rust_begin_unwind\r\n             at /checkout/src/libstd/panicking.rs:471\r\n   8: core::panicking::panic_fmt\r\n             at /checkout/src/libcore/panicking.rs:69\r\n   9: core::panicking::panic\r\n             at /checkout/src/libcore/panicking.rs:49\r\n  10: <core::option::Option<T>>::unwrap\r\n  11: <std::thread::JoinInner<T>>::join\r\n  12: <std::thread::JoinHandle<T>>::join\r\n  13: testjoin::main::{{closure}}\r\n```\r\n\r\nIt makes no sense to call join inside the associated thread, but a meaningless panic is sure not the good way to handle this situation. Maybe we should return an error which contains the join handle, so the caller can recover the failure. If panic is preferred, then a more friendly message should be good for users.", "closed_by": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/43539/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/43539/timeline", "performed_via_github_app": null, "state_reason": "completed"}