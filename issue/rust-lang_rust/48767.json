{"url": "https://api.github.com/repos/rust-lang/rust/issues/48767", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/48767/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/48767/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/48767/events", "html_url": "https://github.com/rust-lang/rust/issues/48767", "id": 302586375, "node_id": "MDU6SXNzdWUzMDI1ODYzNzU=", "number": 48767, "title": "It's possible to impose generic bounds that later make type inference recurse infinitely", "user": {"login": "solb", "id": 1214534, "node_id": "MDQ6VXNlcjEyMTQ1MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1214534?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solb", "html_url": "https://github.com/solb", "followers_url": "https://api.github.com/users/solb/followers", "following_url": "https://api.github.com/users/solb/following{/other_user}", "gists_url": "https://api.github.com/users/solb/gists{/gist_id}", "starred_url": "https://api.github.com/users/solb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solb/subscriptions", "organizations_url": "https://api.github.com/users/solb/orgs", "repos_url": "https://api.github.com/users/solb/repos", "events_url": "https://api.github.com/users/solb/events{/privacy}", "received_events_url": "https://api.github.com/users/solb/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 149689562, "node_id": "MDU6TGFiZWwxNDk2ODk1NjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-associated-items", "name": "A-associated-items", "color": "f7e101", "default": false, "description": "Area: Associated items such as associated types and consts."}, {"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 604454086, "node_id": "MDU6TGFiZWw2MDQ0NTQwODY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-inference", "name": "A-inference", "color": "f7e101", "default": false, "description": "Area: Type inference"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-03-06T07:03:32Z", "updated_at": "2018-05-21T09:00:00Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "I wrote this wrapper type (e.g. for integers):\r\n```Rust\r\nstruct Wrapped<T> (T);\r\n\r\nimpl<'a, T> Add for &'a Wrapped<T>\r\nwhere &'a T: Add<Output = T> {\r\n        type Output = Wrapped<T>; \r\n                \r\n        fn add(self, other: Self) -> Self::Output {\r\n                Wrapped (&self.0 + &other.0)\r\n        }\r\n}\r\n```\r\n\r\nIt works fine, but plays *really poorly* with any helper function definitions of this form:\r\n```Rust\r\nfn add<'a, T: 'a>(left: &'a T, right: &'a T) -> T\r\nwhere &'a T: Add<Output = T> {\r\n        left + right\r\n}\r\n```\r\n\r\nThe problem doesn't occur until the function is actually used in a way that triggers type inference.  For example:\r\n```\r\nerror[E0275]: overflow evaluating the requirement `<&_ as std::ops::Add>::Output`\r\n  --> src/main.rs:16:24\r\n   |\r\n31 |         add(&1, &2);\r\n   |         ^^^\r\n   |\r\n   = help: consider adding a `#![recursion_limit=\"128\"]` attribute to your crate\r\n   = note: required because of the requirements on the impl of `std::ops::Add` for `&Wrapped<_>`\r\n   = note: required because of the requirements on the impl of `std::ops::Add` for `&Wrapped<Wrapped<_>>`\r\n   = note: required because of the requirements on the impl of `std::ops::Add` for `&Wrapped<Wrapped<Wrapped<_>>>`\r\n   = note: required because of the requirements on the impl of `std::ops::Add` for `&Wrapped<Wrapped<Wrapped<Wrapped<_>>>>`\r\n...\r\n   = note: required by `add`\r\n```\r\n\r\nNotice that this call site doesn't even make use of the type `Wrapped<T>`: it's just impossible to perform type inference on the `add()` helper function at all.\r\n\r\nInterestingly, `add::<i32>(&1, &2)` doesn't generate the error, but even something as simple as `add(&1i32, &2i32)` does.\r\n\r\n@gpm helped me investigate the problem and its implications, and noticed that type inference for the function\r\n```Rust\r\nfn add<T, R>(left: T, right: T) -> R\r\nwhere T: Add<Output = R> {\r\n    left + right\r\n}\r\n```\r\nisn't broken.  But this doesn't help you if some library crate has defined a type with the problematic impl and you now need to define a function that adds by references instead of moves...\r\n\r\n```\r\n$ rustc --version --verbose\r\nrustc 1.23.0\r\nbinary: rustc\r\ncommit-hash: unknown\r\ncommit-date: unknown\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.23.0\r\nLLVM version: 4.0\r\n```", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/48767/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/48767/timeline", "performed_via_github_app": null, "state_reason": null}