{"url": "https://api.github.com/repos/rust-lang/rust/issues/17566", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/17566/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/17566/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/17566/events", "html_url": "https://github.com/rust-lang/rust/issues/17566", "id": 44096027, "node_id": "MDU6SXNzdWU0NDA5NjAyNw==", "number": 17566, "title": "Arena defers destroying allocated objects adding inefficiency", "user": {"login": "NawfelBgh", "id": 1393737, "node_id": "MDQ6VXNlcjEzOTM3Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/1393737?v=4", "gravatar_id": "", "url": "https://api.github.com/users/NawfelBgh", "html_url": "https://github.com/NawfelBgh", "followers_url": "https://api.github.com/users/NawfelBgh/followers", "following_url": "https://api.github.com/users/NawfelBgh/following{/other_user}", "gists_url": "https://api.github.com/users/NawfelBgh/gists{/gist_id}", "starred_url": "https://api.github.com/users/NawfelBgh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/NawfelBgh/subscriptions", "organizations_url": "https://api.github.com/users/NawfelBgh/orgs", "repos_url": "https://api.github.com/users/NawfelBgh/repos", "events_url": "https://api.github.com/users/NawfelBgh/events{/privacy}", "received_events_url": "https://api.github.com/users/NawfelBgh/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2014-09-26T19:08:11Z", "updated_at": "2014-10-09T06:24:57Z", "closed_at": "2014-10-09T06:24:30Z", "author_association": "NONE", "active_lock_reason": null, "body": "From http://doc.rust-lang.org/arena/struct.Arena.html\n\n> For each allocated object, the arena stores a pointer to the type descriptor followed by the object (potentially with alignment padding after each element). When the arena is destroyed, it iterates through all of its chunks, and uses the tydesc information to trace through the objects, calling the destructors on them. One subtle point that needs to be addressed ....\n\nAs i understand it, the point from having arena is to fast allocate objects and then reclaim all the allocated memory at once. So, i don't see any benefit from the current implementation which defers allocated objects destruction. It only adds complexity to the implementation.\n\nI propose the following redesign which supports _allocating objects of different types_ and _doesn't need reflection_:\n- `a.alloc` where `a` is arena returns the `ArenaPtr<'a, T>` smart pointer\n- `ArenaPtr<'a, T>` impleents deref traits. It is bound by the lifetime of  `a` so it can't be used outside the lifetime of the arena.\n- `ArenaPtr<'a, T>` has a destructor which destroys the object pointed to. That object was allocated inside the arena. It is destroyed but it's memory isn't reclaimed\n- `Arena` has a destructor which reclaim the whole allocated memory\n\nHere is a possible implementation:\n\n``` rust\n#![feature(unsafe_destructor)]\nextern crate alloc;\n\nuse std::mem::size_of;\nuse std::mem::min_align_of;\nuse std::mem::drop;\nuse std::mem::uninitialized;\nuse std::cmp::max;\nuse std::ptr::replace;\nuse std::ptr::null_mut;\nuse alloc::heap::allocate;\nuse alloc::heap::deallocate;\nuse std::intrinsics::forget;\nuse std::intrinsics::transmute;\nuse std::kinds::marker::ContravariantLifetime;\n\npub struct ArenaPtr<'a, T> {\n    dummy: ContravariantLifetime<'a>,\n    ptr: *mut T\n}\n\nimpl<'a, T> Deref<T> for ArenaPtr<'a, T> {\n    fn deref<'b>(&'b self) -> &'b T {\n        unsafe { transmute(self.ptr) }\n    }\n}\n\nimpl<'a, T> DerefMut<T> for ArenaPtr<'a, T> {\n    fn deref_mut<'b>(&'b mut self) -> &'b mut T {\n        unsafe { transmute(self.ptr) }\n    }\n}\n\n#[unsafe_destructor]\nimpl<'a, T> Drop for ArenaPtr<'a, T> {\n    fn drop(&mut self) {\n        drop(unsafe { replace(self.ptr, uninitialized()) });\n    }\n}\n\nstruct Chunk {\n    base: *mut u8,\n    size: uint,\n    align: uint,\n    ptr: *mut u8\n}\n\n#[unsafe_destructor]\nimpl Drop for Chunk {\n    fn drop(&mut self) {\n        println!(\"Dealocating a chunk of {} Bytes\", self.size);\n        unsafe { deallocate(self.base, self.size, self.align); }\n    }\n}\n\nimpl Chunk {\n    fn new(size: uint, align: uint) -> Chunk {\n        let ptr = unsafe { allocate(size, align) };\n        if ptr == null_mut::<u8>() { fail!(\"allocation failed\"); }\n        Chunk { base: ptr, size: size, align: align, ptr: ptr }\n    }\n}\n\npub struct Arena {\n    chunks: Vec<Chunk>,\n    chunk_size: uint,\n    chunk_align: uint\n}\n\nimpl Arena {\n    pub fn new() -> Arena {\n        Arena { chunks: vec!(), chunk_size: 4096, chunk_align: 2 }\n    }\n\n    pub fn alloc<'a, T>(&'a mut self, object: T) -> ArenaPtr<'a, T> {\n        let size = size_of::<T>();\n        let align = min_align_of::<T>();\n\n        let last_chunk: &mut Chunk =\n            if self.chunks.len() == 0 {\n                let chunk = Chunk::new(\n                    max(size, self.chunk_size),\n                    max(align, self.chunk_align)\n                );\n                self.chunks.push(chunk);\n                self.chunks.last_mut().unwrap()\n            } else {\n                let space_available = {\n                    let chunk = self.chunks.last_mut().unwrap();\n                    if chunk.ptr as uint % align != 0 {\n                        chunk.ptr = (chunk.ptr as uint + align - (chunk.ptr as uint % align)) as *mut u8;\n                    }\n                    chunk.ptr as uint + size < chunk.base as uint + chunk.size\n                };\n\n                if space_available {\n                    self.chunks.last_mut().unwrap()\n                } else {\n                    let chunk = Chunk::new(\n                        max(size, self.chunk_size),\n                        max(align, self.chunk_align)\n                    );\n                    self.chunks.push(chunk);\n                    self.chunks.last_mut().unwrap()\n                }\n            };\n\n        let ptr: *mut T = unsafe {\n            let p = last_chunk.ptr as *mut T;\n            forget(replace(p, object));\n            last_chunk.ptr = last_chunk.ptr.offset(size as int);\n            p\n        };\n\n        ArenaPtr { ptr: ptr, dummy: ContravariantLifetime }\n    }\n}\n\n#[deriving(Show)]\nstruct S {\n    value: uint\n}\n\n#[unsafe_destructor]\nimpl Drop for S {\n    fn drop(&mut self) {\n        println!(\"dropping {}\", self);\n    }\n}\n\n// test\nfn main () {\n    let mut arena = Arena::new();\n    for i in range(1u, 1000) {\n        let s = arena.alloc(S { value: i });\n        println!(\"printing {}\", &*s);\n    }\n}\n\n```\n", "closed_by": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/17566/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/17566/timeline", "performed_via_github_app": null, "state_reason": "completed"}