{"url": "https://api.github.com/repos/rust-lang/rust/issues/52529", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/52529/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/52529/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/52529/events", "html_url": "https://github.com/rust-lang/rust/issues/52529", "id": 342649020, "node_id": "MDU6SXNzdWUzNDI2NDkwMjA=", "number": 52529, "title": "Implement limit-based binary search on slice", "user": {"login": "sicking", "id": 1831914, "node_id": "MDQ6VXNlcjE4MzE5MTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1831914?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sicking", "html_url": "https://github.com/sicking", "followers_url": "https://api.github.com/users/sicking/followers", "following_url": "https://api.github.com/users/sicking/following{/other_user}", "gists_url": "https://api.github.com/users/sicking/gists{/gist_id}", "starred_url": "https://api.github.com/users/sicking/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sicking/subscriptions", "organizations_url": "https://api.github.com/users/sicking/orgs", "repos_url": "https://api.github.com/users/sicking/repos", "events_url": "https://api.github.com/users/sicking/events{/privacy}", "received_events_url": "https://api.github.com/users/sicking/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 630652267, "node_id": "MDU6TGFiZWw2MzA2NTIyNjc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-feature-request", "name": "C-feature-request", "color": "f5f1fd", "default": false, "description": "Category: A feature request, i.e: not implemented / a PR."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2018-07-19T09:26:09Z", "updated_at": "2019-01-27T21:40:51Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "The current `binary_search_*` API on slice is very flexible in that it both allows searching for items in the slice, as well as the ranges \"between\" the items.\r\n\r\nHowever this flexibility comes at the cost in situations where the values in the array acts as limits, rather than items to search for. I.e. where you don't care if the searched for value falls between two items, or exactly on one of the items.\r\n\r\nSpecifically, to search for the first item greater than a given value neither solution below is particularly obvious or pleasant to type:\r\n```rust\r\nuse std::cmp::Ordering::{Greater, Less}\r\nslice.binary_search_by(|&x| if x > 5 { Greater } else { Less }).unwrap_err()\r\n// or\r\nslice.binary_search(&5).map(|x| x+1).unwrap_or_else(|x| x)\r\n```\r\n\r\nTo search for the first item greater than, or equal to, a given value is easier but isn't an obvious modification from the above.\r\n```rust\r\nslice.binary_search(&5).unwrap_or_else(|x| x)\r\n```\r\n\r\nIn both of these situations it felt easy enough to have off-by-one errors that I ended writing small test cases and manually testing all edge cases until I felt that I used the right math.\r\n\r\nThe problem is that in these situations both the returned type (`Ordering`) from the closure is a poor fit, since you really just have two different results (too small or too large). Additionally the return type from the the `binary_search_*` function isn't a good fit since you just need a `usize`.\r\n\r\nI propose (and will attach a PR for) that we add a `slice.binary_search_limit_by` function directly returns a `usize`, and which takes a closure which maps from an item to a bool in order to do the search.\r\n\r\nWe should probably also add `slice.binary_search_limit` which finds the first item larger than (or larger than or equal to) the given value, as well as `slice.binary_search_limit_by_key` which does the same using a key mapping function. Unfortunately these feel a bit more awkward since we have to choose if these do a \"find first item larger\" or a \"find first item larger or equal\" search.\r\n\r\nI'm not sure if this change is large enough or controversial to require an RFC?", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/52529/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/52529/timeline", "performed_via_github_app": null, "state_reason": null}