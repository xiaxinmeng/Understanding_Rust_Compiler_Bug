{"url": "https://api.github.com/repos/rust-lang/rust/issues/42657", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/42657/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/42657/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/42657/events", "html_url": "https://github.com/rust-lang/rust/issues/42657", "id": 235956453, "node_id": "MDU6SXNzdWUyMzU5NTY0NTM=", "number": 42657, "title": "Output code bloat when programming with a functional style", "user": {"login": "DominusCarnufex", "id": 18592176, "node_id": "MDQ6VXNlcjE4NTkyMTc2", "avatar_url": "https://avatars.githubusercontent.com/u/18592176?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DominusCarnufex", "html_url": "https://github.com/DominusCarnufex", "followers_url": "https://api.github.com/users/DominusCarnufex/followers", "following_url": "https://api.github.com/users/DominusCarnufex/following{/other_user}", "gists_url": "https://api.github.com/users/DominusCarnufex/gists{/gist_id}", "starred_url": "https://api.github.com/users/DominusCarnufex/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DominusCarnufex/subscriptions", "organizations_url": "https://api.github.com/users/DominusCarnufex/orgs", "repos_url": "https://api.github.com/users/DominusCarnufex/repos", "events_url": "https://api.github.com/users/DominusCarnufex/events{/privacy}", "received_events_url": "https://api.github.com/users/DominusCarnufex/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 256133398, "node_id": "MDU6TGFiZWwyNTYxMzMzOTg=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-mir", "name": "A-mir", "color": "f7e101", "default": false, "description": "Area: Mid-level IR (MIR) - https://blog.rust-lang.org/2016/04/19/MIR.html"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 9, "created_at": "2017-06-14T17:40:07Z", "updated_at": "2021-03-13T20:16:50Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "I have been wanting to experiment writing some code in Rust with a more \u201cpure functional / Haskelly\u201d style. To explain things more clearly, let\u2019s say you have this type.\r\n\r\n```rust\r\n#[derive(Debug)]\r\nstruct Type {\r\n    field1 : u64,\r\n    field2 : u32,\r\n    field3 : Vec<u32>,\r\n}\r\n```\r\n\r\nA very simple method to modify `field2` would be written so in everyday Rust.\r\n\r\n```rust\r\nimpl Type   {\r\n    #[no_mangle]\r\n    #[inline(never)]\r\n    fn mut_update(&mut self, field2 : u32) -> &mut Self {\r\n        self.field2 = field2;\r\n        self\r\n    }\r\n}\r\n```\r\n\r\nThe `&mut Self` as return value is here so that one can chain such method calls. Now here is a more \u201cpure functional\u201d way of doing it.\r\n\r\n```rust\r\nimpl Type   {\r\n    #[no_mangle]\r\n    #[inline(never)]\r\n    fn func_update(self, field2 : u32) -> Self  {\r\n        Type { field2 : field2, .. self }\r\n    }\r\n}\r\n```\r\n\r\nAnd once optimized out, these two functions should be perfectly identical, because `func_update` takes the property of `self` and never returns it, so the memory can be safely reused.\r\n\r\nSo I tested it out with this basic code.\r\n\r\n```rust\r\nfn main()   {\r\n    let mut var = Type { field1 : 42, field2 : 0, field3 : vec![12] };\r\n\r\n    let _ = var.mut_update(79);\r\n    let _other = var.func_update(112);\r\n}\r\n```\r\n\r\nBut no\u2026 This is the assembly generated for `mut_update`\r\n\r\n```nasm\r\nmut_update:\r\n\t.cfi_startproc\r\n\tmov\tdword ptr [rdi + 32], 79\r\n\tret\r\n```\r\n\r\nAnd this is the one generated for `func_update`.\r\n\r\n```nasm\r\nfunc_update:\r\n\t.cfi_startproc\r\n\tmov\trax, qword ptr [rsi]\r\n\tmov\tqword ptr [rdi], rax\r\n\tmov\tdword ptr [rdi + 32], 112\r\n\tmov\trax, qword ptr [rsi + 24]\r\n\tmov\tqword ptr [rdi + 24], rax\r\n\tmovups\txmm0, xmmword ptr [rsi + 8]\r\n\tmovups\txmmword ptr [rdi + 8], xmm0\r\n\tmov\trax, rdi\r\n\tret\r\n```\r\n\r\nAs you can see, the whole memory occupied by `self` is copied to another location, a pointer to which is returned by the function. And here is the LLVM IR for these two functions.\r\n\r\n```llvm\r\n; Function Attrs: noinline norecurse nounwind uwtable\r\ndefine internal fastcc void @mut_update(%Type* nocapture dereferenceable(40)) unnamed_addr #0 {\r\nstart:\r\n  %1 = getelementptr inbounds %Type, %Type* %0, i64 0, i32 4\r\n  store i32 79, i32* %1, align 4\r\n  ret void\r\n}\r\n\r\n; Function Attrs: noinline nounwind uwtable\r\ndefine internal fastcc void @func_update(%Type* noalias nocapture sret dereferenceable(40), %Type* noalias nocapture readonly dereferenceable(40)) unnamed_addr #1 {\r\nstart:\r\n  %self.sroa.0.0..sroa_idx = getelementptr inbounds %Type, %Type* %1, i64 0, i32 0\r\n  %self.sroa.0.0.copyload = load i64, i64* %self.sroa.0.0..sroa_idx, align 8\r\n  %self.sroa.4.0..sroa_idx = getelementptr inbounds %Type, %Type* %1, i64 0, i32 2\r\n  %self.sroa.4.0..sroa_cast2 = bitcast %\"collections::vec::Vec<u32>\"* %self.sroa.4.0..sroa_idx to i8*\r\n  %2 = getelementptr inbounds %Type, %Type* %0, i64 0, i32 0\r\n  store i64 %self.sroa.0.0.copyload, i64* %2, align 8\r\n  %3 = getelementptr inbounds %Type, %Type* %0, i64 0, i32 4\r\n  store i32 112, i32* %3, align 8\r\n  %self.sroa.4.8..sroa_idx = getelementptr inbounds %Type, %Type* %0, i64 0, i32 2\r\n  %self.sroa.4.8..sroa_cast = bitcast %\"collections::vec::Vec<u32>\"* %self.sroa.4.8..sroa_idx to i8*\r\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %self.sroa.4.8..sroa_cast, i8* %self.sroa.4.0..sroa_cast2, i64 24, i32 8, i1 false)\r\n  ret void\r\n}\r\n```\r\n\r\nThe \u201cfunctional\u201d variant is already bloated at this point, so the problem comes form rustc itself.\r\n\r\nThat\u2019s the first problem. The other is in the `main` function: look at what happens between the call to the two functions.\r\n\r\n```nasm\r\n\tmov\tdword ptr [rax], 12\r\n\tmov\tqword ptr [rsp + 8], 42\r\n\tmov\tdword ptr [rsp + 40], 0\r\n\tmov\tqword ptr [rsp + 16], rax\r\n\tmov\tqword ptr [rsp + 24], 1\r\n\tmov\tqword ptr [rsp + 32], 1\r\n\tlea\trdi, [rsp + 8]\r\n\tcall\tmut_update\r\n\tmov\trax, qword ptr [rsp + 40]\r\n\tmov\tqword ptr [rsp + 80], rax\r\n\tmovups\txmm0, xmmword ptr [rsp + 8]\r\n\tmovups\txmm1, xmmword ptr [rsp + 24]\r\n\tmovaps\txmmword ptr [rsp + 64], xmm1\r\n\tmovaps\txmmword ptr [rsp + 48], xmm0\r\n\tlea\trdi, [rsp + 96]\r\n\tlea\trsi, [rsp + 48]\r\n\tcall\tfunc_update\r\n```\r\n\r\nYes, you read it right: the whole memory space containing `var` is being copied to another place *before* the next function is even called. So it is copied twice: immediately before the `call` and immediately after.\r\n\r\nHere is the LLVM IR for the `main` function.\r\n\r\n```llvm\r\n; Function Attrs: uwtable\r\ndefine internal void @_ZN4opti4main17ha95f343356fbf6f4E() unnamed_addr #2 personality i32 (i32, i32, i64, %\"unwind::libunwind::_Unwind_Exception\"*, %\"unwind::libunwind::_Unwind_Context\"*)* @rust_eh_personality {\r\nstart:\r\n  %_9 = alloca %Type, align 8\r\n  %_other = alloca %Type, align 8\r\n  %var = alloca %Type, align 8\r\n  %0 = bitcast %Type* %var to i8*\r\n  call void @llvm.lifetime.start(i64 40, i8* nonnull %0)\r\n  %1 = tail call i8* @__rust_allocate(i64 4, i64 4) #4\r\n  %2 = icmp eq i8* %1, null\r\n  br i1 %2, label %bb5.i, label %bb5\r\n\r\nbb5.i:                                            ; preds = %start\r\n  tail call void @_ZN5alloc3oom3oom17h5b02814f1abf9784E()\r\n  unreachable\r\n\r\nbb5:                                              ; preds = %start\r\n  %3 = bitcast i8* %1 to i32*\r\n  store i32 12, i32* %3, align 4\r\n  %4 = getelementptr inbounds %Type, %Type* %var, i64 0, i32 0\r\n  store i64 42, i64* %4, align 8\r\n  %5 = getelementptr inbounds %Type, %Type* %var, i64 0, i32 4\r\n  store i32 0, i32* %5, align 8\r\n  %_2.sroa.0.0..sroa_idx = getelementptr inbounds %Type, %Type* %var, i64 0, i32 2, i32 0, i32 0, i32 0, i32 0\r\n  %6 = bitcast i32** %_2.sroa.0.0..sroa_idx to i8**\r\n  store i8* %1, i8** %6, align 8\r\n  %_2.sroa.4.0..sroa_idx11 = getelementptr inbounds %Type, %Type* %var, i64 0, i32 2, i32 0, i32 2\r\n  store i64 1, i64* %_2.sroa.4.0..sroa_idx11, align 8\r\n  %_2.sroa.5.0..sroa_idx13 = getelementptr inbounds %Type, %Type* %var, i64 0, i32 2, i32 2\r\n  store i64 1, i64* %_2.sroa.5.0..sroa_idx13, align 8\r\n  call fastcc void @mut_update(%Type* nonnull dereferenceable(40) %var)\r\n  %7 = bitcast %Type* %_other to i8*\r\n  call void @llvm.lifetime.start(i64 40, i8* nonnull %7)\r\n  %8 = bitcast %Type* %_9 to i8*\r\n  call void @llvm.lifetime.start(i64 40, i8* nonnull %8)\r\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %8, i8* nonnull %0, i64 40, i32 8, i1 false)\r\n  call fastcc void @func_update(%Type* noalias nocapture nonnull sret dereferenceable(40) %_other, %Type* noalias nocapture nonnull dereferenceable(40) %_9)\r\n  call void @llvm.lifetime.end(i64 40, i8* nonnull %8)\r\n  %9 = getelementptr inbounds %Type, %Type* %_other, i64 0, i32 2, i32 0, i32 2\r\n  %10 = load i64, i64* %9, align 8\r\n  %not..i.i.i.i = icmp eq i64 %10, 0\r\n  br i1 %not..i.i.i.i, label %bb6, label %bb6.i.i.i.i\r\n\r\nbb6.i.i.i.i:                                      ; preds = %bb5\r\n  %11 = getelementptr inbounds %Type, %Type* %_other, i64 0, i32 2\r\n  %12 = shl i64 %10, 2\r\n  %13 = bitcast %\"collections::vec::Vec<u32>\"* %11 to i8**\r\n  %_3.sroa.0.0.copyload3.i1.i.i.i.i = load i8*, i8** %13, align 8, !alias.scope !1\r\n  tail call void @__rust_deallocate(i8* %_3.sroa.0.0.copyload3.i1.i.i.i.i, i64 %12, i64 4) #4\r\n  br label %bb6\r\n\r\nbb6:                                              ; preds = %bb6.i.i.i.i, %bb5\r\n  call void @llvm.lifetime.end(i64 40, i8* nonnull %7)\r\n  call void @llvm.lifetime.end(i64 40, i8* nonnull %0)\r\n  ret void\r\n}\r\n```\r\n\r\nI know next to nothing about LLVM IR, so I don\u2019t really understand what is going on in there. But I guess that this line is responsible for the unnecessary copy.\r\n\r\n```llvm\r\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %8, i8* nonnull %0, i64 40, i32 8, i1 false)\r\n```\r\n\r\nI hope you people find a solution to this, because it is a huge loss in processor time to do almost thrice as much memory access as would be needed. And even if it is not relevant on such small a code, with a bigger code base, it must surely bloat memory usage compared to C for instance.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/42657/reactions", "total_count": 3, "+1": 3, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/42657/timeline", "performed_via_github_app": null, "state_reason": null}