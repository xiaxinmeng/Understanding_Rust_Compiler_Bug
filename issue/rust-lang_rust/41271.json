{"url": "https://api.github.com/repos/rust-lang/rust/issues/41271", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/41271/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/41271/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/41271/events", "html_url": "https://github.com/rust-lang/rust/issues/41271", "id": 221599969, "node_id": "MDU6SXNzdWUyMjE1OTk5Njk=", "number": 41271, "title": "Code wrongly optimized away", "user": {"login": "th0rex", "id": 6771282, "node_id": "MDQ6VXNlcjY3NzEyODI=", "avatar_url": "https://avatars.githubusercontent.com/u/6771282?v=4", "gravatar_id": "", "url": "https://api.github.com/users/th0rex", "html_url": "https://github.com/th0rex", "followers_url": "https://api.github.com/users/th0rex/followers", "following_url": "https://api.github.com/users/th0rex/following{/other_user}", "gists_url": "https://api.github.com/users/th0rex/gists{/gist_id}", "starred_url": "https://api.github.com/users/th0rex/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/th0rex/subscriptions", "organizations_url": "https://api.github.com/users/th0rex/orgs", "repos_url": "https://api.github.com/users/th0rex/repos", "events_url": "https://api.github.com/users/th0rex/events{/privacy}", "received_events_url": "https://api.github.com/users/th0rex/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2017-04-13T15:33:08Z", "updated_at": "2017-04-13T20:26:04Z", "closed_at": "2017-04-13T20:22:26Z", "author_association": "NONE", "active_lock_reason": null, "body": "Sorry for the lack of a better title, I really don't know how to describe this in a short way.\r\n\r\nI'm trying to set the `__malloc_hook` global variable from libc to a custom function written in Rust, so that I can track memory allocations. On a debug build, everything is fine, but on a release build that is a bit different. If I add random `println!` the release build is fine, if I don't the release build is broken (that means the generated assembly code is wrong/not generated).\r\n\r\nThis is my code:\r\n```rust\r\n#[macro_use]\r\nextern crate lazy_static;\r\nextern crate libc;\r\n\r\nuse std::sync::Mutex;\r\nuse std::os::raw::c_void;\r\n\r\ntype Malloc = extern \"C\" fn(size: usize) -> *mut c_void;\r\n\r\nextern \"C\" {\r\n    static mut __malloc_hook: Malloc;\r\n\r\n    fn malloc(size: usize) -> *mut c_void;\r\n}\r\n\r\n#[derive(Clone, PartialEq)]\r\nstruct HookState {\r\n    malloc: Malloc,\r\n}\r\n\r\nimpl HookState {\r\n    fn from_current() -> HookState {\r\n        HookState {\r\n            malloc: unsafe { __malloc_hook },\r\n        }\r\n    }\r\n\r\n    fn from_overrides() -> HookState {\r\n        HookState {\r\n            malloc: my_malloc,\r\n        }\r\n    }\r\n\r\n    fn to_globals(&self) {\r\n        unsafe {\r\n            __malloc_hook = self.malloc;\r\n        }\r\n    }\r\n}\r\n\r\nlazy_static! {\r\n    static ref ORIGINAL_STATE: Mutex<HookState> = Mutex::new(HookState::from_overrides());\r\n}\r\n\r\n#[no_mangle]\r\npub extern \"C\" fn heap_iter_static_init() {\r\n    let mut state = ORIGINAL_STATE.lock().unwrap();\r\n    *state = HookState::from_current();\r\n    // Setup hooks\r\n    HookState::from_overrides().to_globals();\r\n}\r\n\r\nextern \"C\" fn my_malloc(size: usize) -> *mut c_void {\r\n    let state = ORIGINAL_STATE.lock().unwrap();\r\n    // Restore original hooks\r\n    state.to_globals();\r\n    let p = unsafe { malloc(size) };\r\n    //println!(\"malloc(size={})={:?}\", size, p);\r\n    //println!(\"wtf\");\r\n    HookState::from_overrides().to_globals();\r\n    p\r\n}\r\n```\r\nI set the cratetype to `cdylib` in `Cargo.toml` so that a shared object file is generated.\r\n\r\nThe function `heap_iter_static_init` is called by another shared object and just saves the current hooks and sets them to my custom functions. \r\n\r\n`my_malloc` then first restores the hooks, does the malloc, and overrides the hooks again. In debug builds this is working fine. In release builds the hooks are NOT restored (even tho my code restores them), which results in `my_malloc` getting called again by the call to `malloc` and thus a deadlock. \r\n\r\nHowever, if I uncomment any of the two `println!` lines in the `my_malloc` function, the code does work and the hooks are actually restored to their old state. I really don't know how to further debug this.\r\n\r\nI also looked at the assembly output. I won't include the debug assembly, because that is fine.\r\n\r\nThe working version refers to the version with any of the two `println!` lines uncommented and compiling in release mode and the non working version refers to the version with no `println!` after the malloc and compiling in release mode. The assembly code is taken from a nightly compiler.\r\n\r\nThis is the relevant assembly of the non working version: [not working](https://ibb.co/dnMyD5)\r\nThis is the relevant assembly of the working version: [working](https://ibb.co/kxJjmQ)\r\n\r\nNote the additional lines\r\n```asm\r\nmov rax, qword [rbp + arg_10h]\r\nmov rbx, qword [reloc.__cxa_finalize_184]\r\nmov qword[rbx], rax\r\n```\r\nin the working version right before the call to `malloc`, which are completly missing in the non working version and those are the instructions that actually set the `__malloc_hook` variable.\r\n\r\nSo to summarize this:\r\n* debug build: everything fine\r\n* release build without the println: code not generated\r\n* release build with the println: code is generated, everything fine\r\n\r\nI thus guess that either llvm is broken or the rust compiler is broken (or my code actually is wrong/not valid), but I have no idea where to start figuring out what actually causes this.\r\n\r\n## Meta\r\nThis was tested with the following compilers:\r\n1. Kinda old nightly\r\n```\r\nrustc 1.18.0-nightly (2564711e8 2017-04-04)\r\nbinary: rustc\r\ncommit-hash: 2564711e803f62e04bebf10408cc1c11297c0caf\r\ncommit-date: 2017-04-04\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.18.0-nightly\r\nLLVM version: 3.9\r\n```\r\n2. Current nightly version I can download (as `rustup update` seems to be broken)\r\n```\r\nrustc 1.18.0-nightly (3b5754e5c 2017-04-10)\r\nbinary: rustc\r\ncommit-hash: 3b5754e5ce73d24c6684b3ed0c68a557dfdd2f52\r\ncommit-date: 2017-04-10\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.18.0-nightly\r\nLLVM version: 3.9\r\n```\r\n3. Stable\r\n```\r\nrustc 1.16.0 (30cf806ef 2017-03-10)\r\nbinary: rustc\r\ncommit-hash: 30cf806ef8881c41821fbd43e5cf3699c5290c16\r\ncommit-date: 2017-03-10\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.16.0\r\nLLVM version: 3.9\r\n```\r\nAll 3 versions have the same behaviour.", "closed_by": {"login": "th0rex", "id": 6771282, "node_id": "MDQ6VXNlcjY3NzEyODI=", "avatar_url": "https://avatars.githubusercontent.com/u/6771282?v=4", "gravatar_id": "", "url": "https://api.github.com/users/th0rex", "html_url": "https://github.com/th0rex", "followers_url": "https://api.github.com/users/th0rex/followers", "following_url": "https://api.github.com/users/th0rex/following{/other_user}", "gists_url": "https://api.github.com/users/th0rex/gists{/gist_id}", "starred_url": "https://api.github.com/users/th0rex/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/th0rex/subscriptions", "organizations_url": "https://api.github.com/users/th0rex/orgs", "repos_url": "https://api.github.com/users/th0rex/repos", "events_url": "https://api.github.com/users/th0rex/events{/privacy}", "received_events_url": "https://api.github.com/users/th0rex/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/41271/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/41271/timeline", "performed_via_github_app": null, "state_reason": "completed"}