{"url": "https://api.github.com/repos/rust-lang/rust/issues/106300", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/106300/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/106300/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/106300/events", "html_url": "https://github.com/rust-lang/rust/issues/106300", "id": 1514705700, "node_id": "I_kwDOAAsO6M5aSJMk", "number": 106300, "title": "premature underflow in division and powi on arm32 softfloat.", "user": {"login": "plugwash", "id": 3199425, "node_id": "MDQ6VXNlcjMxOTk0MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/3199425?v=4", "gravatar_id": "", "url": "https://api.github.com/users/plugwash", "html_url": "https://github.com/plugwash", "followers_url": "https://api.github.com/users/plugwash/followers", "following_url": "https://api.github.com/users/plugwash/following{/other_user}", "gists_url": "https://api.github.com/users/plugwash/gists{/gist_id}", "starred_url": "https://api.github.com/users/plugwash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/plugwash/subscriptions", "organizations_url": "https://api.github.com/users/plugwash/orgs", "repos_url": "https://api.github.com/users/plugwash/repos", "events_url": "https://api.github.com/users/plugwash/events{/privacy}", "received_events_url": "https://api.github.com/users/plugwash/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}, {"id": 2139259423, "node_id": "MDU6TGFiZWwyMTM5MjU5NDIz", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-floating-point", "name": "A-floating-point", "color": "f7e101", "default": false, "description": "Area: Floating point numbers and arithmetic"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2022-12-30T18:22:57Z", "updated_at": "2023-01-27T07:42:43Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "This bug started as a test failure of the num-rational crate on Debian armel https://github.com/rust-num/num-rational/issues/111 . Briefly the results from the num-rational crate was correct, but the result of 2f64.powi(MIN_EXP - 1) which was used as an \"expected value in the test returned zero.\r\n\r\npowi has pretty much no documentation as to what values it can be expected to work over, so I decided to write my own \"naive\" powi implementation. Unfortunately I had the same issue with that. After some further experimentation, I came to the conclusion that division was underflowing prematurely. To demonstrate this I wrote the following test code.\r\n\r\n```rust\r\nfn main() {\r\n    println!(\"Normal   {:016x} {:?}\",f64::MIN_POSITIVE.to_bits(),f64::MIN_POSITIVE);\r\n    println!(\"Denormal {:016x} {:?}\",1,f64::from_bits(1));\r\n\r\n    let mut mnz:f64 = 0.0;\r\n    let mut res:f64 = 1.0;\r\n    let mut p = 0;\r\n    while res > 0.0 {\r\n       mnz = res;\r\n       p -= 1;\r\n       res = 2.0_f64.powi(p);\r\n    }\r\n    println!(\"powineg  {:016x} {:?}\",mnz.to_bits(),mnz);\r\n\r\n    let mut mnz:f64 = 0.0;\r\n    let mut res:f64 = 1.0;\r\n    let mut p = 0;\r\n    while res > 0.0 {\r\n       mnz = res;\r\n       p += 1;\r\n       res = 0.5_f64.powi(p);\r\n    }\r\n    println!(\"powipos  {:016x} {:?}\",mnz.to_bits(),mnz);\r\n\r\n\r\n    let mut mnz:f64 = 0.0;\r\n    let mut res:f64 = 1.0;\r\n    while res > 0.0 {\r\n       mnz = res;\r\n       res /= 2.0;\r\n    }\r\n\r\n    println!(\"divide   {:016x} {:?}\",mnz.to_bits(),mnz);\r\n\r\n    let mut mnz:f64 = 0.0;\r\n    let mut res:f64 = 1.0;\r\n    while res > 0.0 {\r\n       mnz = res;\r\n       res *= 0.5;\r\n    }\r\n    println!(\"multiply {:016x} {:?}\",mnz.to_bits(),mnz);\r\n}\r\n```\r\n\r\nThis prints (in both hexadecimal bit pattern form and in standard floating point debug output form) the smallest positive normal and subnormal values, along with the smallest values that can be produced by.\r\n\r\n1. Raising 2 to a large negative power using powi.\r\n2. Raising 0.5 to a large positive power using powi\r\n3. Starting with 1 and repeatedly dividing by 2.\r\n4. Starting with 2 and repeatedly multiplying by 0.5.\r\n\r\nOn x86-64 and arm32 hardfloat I get the following.\r\n\r\n    Normal   0010000000000000 2.2250738585072014e-308\r\n    Denormal 0000000000000001 5e-324\r\n    powineg  0008000000000000 1.1125369292536007e-308\r\n    powipos  0000000000000001 5e-324\r\n    divide   0000000000000001 5e-324\r\n    multiply 0000000000000001 5e-324\r\n\r\nThis is unsurprising, multiplication, division and raising to a positive power all make it down to the smallest possible subnormal number. Raising to a negative power stops with a larger but still subnormal number, I suspect this is because it raises to a positive power first and then performs a reciprocal and the raising to a positive power overflows.\r\n\r\nHowever when I run it on arm32 soft-float I get.\r\n\r\nNormal   0010000000000000 2.2250738585072014e-308\r\nDenormal 0000000000000001 5e-324\r\npowineg  0020000000000000 4.450147717014403e-308\r\npowipos  0000000000000001 5e-324\r\ndivide   0020000000000000 4.450147717014403e-308\r\nmultiply 0000000000000001 5e-324\r\n\r\nThe smallest number that can be reached by multiplication and by raising to a positive power is still the smallest possible subnormal value. However the smallest number that can be reached by division or raising to a negative power is much larger, it's twice the minimum possible normal value.\r\n\r\nI have obvserved this failure with the following combinations of rustc version and triplet.\r\n\r\nrustc 1.68.0-nightly (ad8ae0504 2022-12-29) arm-unknown-linux-gnueabi\r\nrustc 1.63.0 (debian) armv5te-unknown-linux-gnueabi\r\n\r\nI expected to see this happen: *explanation*\r\n\r\nInstead, this happened: *explanation*\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n`rustc --version --verbose`:\r\n```\r\n<version>\r\n```\r\n\r\n<!--\r\nInclude a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\r\nenvironment. E.g. `RUST_BACKTRACE=1 cargo build`.\r\n-->\r\n<details><summary>Backtrace</summary>\r\n<p>\r\n\r\n```\r\n<backtrace>\r\n```\r\n\r\n</p>\r\n</details>\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/106300/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/106300/timeline", "performed_via_github_app": null, "state_reason": null}