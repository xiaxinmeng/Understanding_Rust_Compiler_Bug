{"url": "https://api.github.com/repos/rust-lang/rust/issues/87479", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/87479/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/87479/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/87479/events", "html_url": "https://github.com/rust-lang/rust/issues/87479", "id": 952936723, "node_id": "MDU6SXNzdWU5NTI5MzY3MjM=", "number": 87479, "title": "GATs: Decide whether to have defaults for `where Self: 'a`", "user": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 919710011, "node_id": "MDU6TGFiZWw5MTk3MTAwMTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/disposition-merge", "name": "disposition-merge", "color": "008800", "default": false, "description": "This issue / PR is in PFCP or FCP with a disposition to merge it."}, {"id": 923282386, "node_id": "MDU6TGFiZWw5MjMyODIzODY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/finished-final-comment-period", "name": "finished-final-comment-period", "color": "f9e189", "default": false, "description": "The final comment period is finished for this PR / Issue."}, {"id": 1485960423, "node_id": "MDU6TGFiZWwxNDg1OTYwNDIz", "url": "https://api.github.com/repos/rust-lang/rust/labels/F-generic_associated_types", "name": "F-generic_associated_types", "color": "f9c0cc", "default": false, "description": "`#![feature(generic_associated_types)]` a.k.a. GATs"}, {"id": 3307663436, "node_id": "MDU6TGFiZWwzMzA3NjYzNDM2", "url": "https://api.github.com/repos/rust-lang/rust/labels/GATs-triaged", "name": "GATs-triaged", "color": "e88000", "default": false, "description": "Issues using the `generic_associated_types` feature that have been triaged"}, {"id": 3455727362, "node_id": "LA_kwDOAAsO6M7N-jcC", "url": "https://api.github.com/repos/rust-lang/rust/labels/GATs-blocking", "name": "GATs-blocking", "color": "e88000", "default": false, "description": "Issues using the `generic_associated_types` feature that block stabilization"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 47, "created_at": "2021-07-26T14:00:27Z", "updated_at": "2023-06-09T05:14:41Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "## Coming from the \"missing required bounds\" error?\r\n\r\nThe \"missing required bounds\" error that was emitted is intended to ensure that current code is forwards-compatible with potential future changes. We'll provide a brief summary of the why the bounds are required, the potential future changes, and a workaround if the required bounds are too restrictive. We would appreciate any feedback for this issue.\r\n\r\n### Why are these bounds required\r\n\r\nLet's start by imagining a trait:\r\n\r\n```rust\r\ntrait Iterable {\r\n    type Item<'x>;\r\n    fn iter<'a>(&'a self) -> Self::Item<'a>;\r\n}\r\n```\r\n\r\nAs-is, nothing looks wrong about this; without the \"missing required bounds\" error, this would compile. However, let's try to add an impl:\r\n\r\n```rust\r\nimpl<T> Iterable for T {\r\n    type Item<'a> = &'a T;\r\n    fn iter<'a>(&'a self) -> Self::Item<'a> { self }\r\n}\r\n```\r\n\r\nThis definition of `Item<'a> = &'a T` is invalid, since we don't know that `T` outlives `'a`. So, our first thought might be to modify the definition to add a `where Self: 'a` clause. This is what we *want*. However, impls are not allowed to have more where clauses than the trait.\r\n\r\nLuckily, we can detect in a trait when this type of problem might occur. To do this, we look at the trait methods that *construct* the GAT. There, we find the bounds that *we know* and require that those bounds be written on the GAT itself.\r\n\r\nHere, on the `Iterable` trait, we construct the GAT `Self::Item<'a>` in the `iter` method. There, we have an argument `&'a self`, which allows us to know `Self: 'a`. Therefore, we require the `where Self: 'a` bound on the GAT.\r\n\r\n### Potential future changes\r\n\r\nFollowing the above logic, if we know all the required bounds when the trait is written, *why require them at all*? In fact, allowed these bounds to be *implied* is a potential future change. However, to make this change in a backwards-compatible manner, we must require the bounds now that we want to eventually imply. At that time, the written bounds will be redundant and can be removed.\r\n\r\n### This breaks my code. Workaround?\r\n\r\nFirst, if any code breaks from adding the required bounds, we *really* want feedback. Second, the workaround is to move the GAT into a super trait. Using the example above, our new code would look like:\r\n\r\n```rust\r\ntrait IterableSuper {\r\n    type Item<'x>;\r\n}\r\ntrait Iterable: IterableSuper {\r\n    fn iter<'a>(&'a self) -> Self::Item<'a>;\r\n}\r\n```\r\n\r\n## Previous discussion\r\n\r\n### What is this bug?\r\n\r\nWe are moving towards stabilizing GATs (tracking issue: https://github.com/rust-lang/rust/issues/44265) but there is one major ergonomic hurdle that we should decide how to manage before we go forward. In particular, a great many GAT use cases require a surprising where clause to be well-typed; this typically has the form `where Self: 'a`. It might be useful if we were to create some rules to add this rule by default. Once we stabilize, changing defaults will be more difficult, and could require an edition, therefore it's better to evaluate the rules now.\r\n\r\n### I have an opinion! What should I do?\r\n\r\nTo make this decision in an informed way, **what we need most are real-world examples and experience reports**. If you are experimenting with GATs, for example, how often do you use `where Self: 'a` and how did you find out that it is necessary? Would the default proposals described below work for you? If not, can you describe the trait so we can understand why they would not work?\r\n\r\nOf great use would be example usages that do NOT require `where Self: 'a`. It'd be good to be able to evaluate the various defaulting schemes and see whether they would interfere with the trait. Knowing the trait and a rough sketch of the impls would be helpful.\r\n### Background: what where clause now?\r\n\r\nConsider the typical \"lending iterator\" example. The idea here is to have an iterator that produces values that may have references into the **iterator itself** (as opposed to references into the collection being iterated over). In other words, given a `next` method like `fn next<'a>(&'a mut self)`, the returned items have to be able to reference `'a`. The typical `Iterator` trait cannot express that, but GATs can:\r\n\r\n```rust\r\ntrait LendingIterator {\r\n    type Item<'a>;\r\n\r\n    fn next<'b>(&'b mut self) -> Self::Item<'b>;\r\n}\r\n```\r\n\r\nUnfortunately, this trait definition turns out to be not quite right in practice. Consider an example like this, an iterator that yields a reference to the same item over and over again (note that it owns the item it is referencing):\r\n\r\n```rust\r\nstruct RefOnce<T> {\r\n    my_data: T    \r\n}\r\n\r\nimpl<T> LendingIterator for RefOnce<T> {\r\n    type Item<'a> where Self: 'a = &'a T;\r\n\r\n    fn next<'b>(&'b mut self) -> Self::Item<'b> {\r\n        &self.my_data\r\n    }\r\n}\r\n```\r\n\r\nHere, the type `type Item<'a> = &'a T` declaration is actually illegal. Why is that? The assumption when authoring the trait was that `'a` would always be the lifetime of the `self` reference in the `next` function, of course, but that is not in fact *required*. People can reference `Item` with any lifetime they want. For example, what if somebody wrote the type `<SomeType<T> as LendingIterator>::Item<'static>`? In this case, `T: 'static` would have to be true, but `T` may in fact contain borrowed references. This is why the compiler gives you a \"T may not outlive `'a`\" error ([playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=821e30ee635326a22fc19cd940bbaf62)). \r\n\r\nWe can encode the constraint that \"`'a` is meant to be the lifetime of the `self` reference\" by adding a `where Self: 'a` clause to the `type Item` declaration. This is saying \"you can only use a `'a` that could be a reference to `Self`\". If you make this change, you'll find that the code compiles ([playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=87cb2430ee76ece77499d3c6605874df)): \r\n\r\n```rust\r\ntrait LendingIterator {\r\n    type Item<'a> where Self: 'a;\r\n\r\n    fn next<'b>(&'b mut self) -> Self::Item<'b>;\r\n}\r\n```\r\n\r\n### When would you NOT want the where clause `Self: 'a`?\r\n\r\nIf the associated type cannot refer to data that comes from the `Self` type, then the `where Self: 'a` is unnecessary, and is in fact somewhat constraining. As an example, consider:\r\n\r\nXXX finish this\r\n\r\n### What could we do about it?\r\n\r\nThere are a few options. Here is the list of ideas we've had so far.\r\n\r\n1. Status quo: require that people add the `where Self: 'a` bounds, and try to do better with diagnostics.\r\n2. Simple, limited default: If a GAT has exactly one lifetime parameter `'a`, add `where Self: 'a` to both traits and impls. Need some way to opt out.\r\n3. More extensive defaults: e.g., for *every* lifetime parameter `'a` to a GAT, add `where Self: 'a`, and maybe `where T: 'a` for type parameters too. Need some way to opt out.\r\n4. Add a syntactic sugar for this common case, e.g. `type Foo<'self>`. This could be added later.\r\n5. self-oriented defaults: Given some GAT `Foo<'a>`, if each use `Self::Foo<'b>` within the trait methods references a `'b` that is the lifetime parameter for `self`, then add `where Self: 'b`. While kind of complex to explain, this captures the intuition that `'a` is meant to be the \"lifetime of the self reference\" in practice. We probably *still* want a way to opt out (though maybe not; maybe that way is \"don't use `&'a self` notation\").\r\n6. Even smarter defaults A: Look at the method signatures in the trait. If we find that each use of `Self::Item<'b>` is associated with a lifetime `'b` where `Self: 'b` is implied by the method arguments, *then* infer that `where Self: 'b`. This is a more extensive, general version of *self-oriented defaults*. We probably *still* want a way to opt out (though maybe not).\r\n\r\nIn general, once we stabilize GATs, we likely cannot add defaults, except via an edition -- although we may be able to get away with it in this instance if the defaults are smart enough.", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/87479/reactions", "total_count": 33, "+1": 18, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 7, "rocket": 0, "eyes": 8}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/87479/timeline", "performed_via_github_app": null, "state_reason": "reopened"}