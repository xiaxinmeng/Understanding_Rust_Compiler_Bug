{"url": "https://api.github.com/repos/rust-lang/rust/issues/89904", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/89904/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/89904/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/89904/events", "html_url": "https://github.com/rust-lang/rust/issues/89904", "id": 1027119898, "node_id": "I_kwDOAAsO6M49OJsa", "number": 89904, "title": "rustc can produce non-deterministic crates that can't be mixed together", "user": {"login": "Fuuzetsu", "id": 893115, "node_id": "MDQ6VXNlcjg5MzExNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/893115?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Fuuzetsu", "html_url": "https://github.com/Fuuzetsu", "followers_url": "https://api.github.com/users/Fuuzetsu/followers", "following_url": "https://api.github.com/users/Fuuzetsu/following{/other_user}", "gists_url": "https://api.github.com/users/Fuuzetsu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Fuuzetsu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Fuuzetsu/subscriptions", "organizations_url": "https://api.github.com/users/Fuuzetsu/orgs", "repos_url": "https://api.github.com/users/Fuuzetsu/repos", "events_url": "https://api.github.com/users/Fuuzetsu/events{/privacy}", "received_events_url": "https://api.github.com/users/Fuuzetsu/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}, {"id": 1508600909, "node_id": "MDU6TGFiZWwxNTA4NjAwOTA5", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-reproducibility", "name": "A-reproducibility", "color": "f7e101", "default": false, "description": "Area: Reproducible / Deterministic builds"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2021-10-15T06:21:21Z", "updated_at": "2021-10-18T03:27:12Z", "closed_at": "2021-10-18T03:27:12Z", "author_association": "NONE", "active_lock_reason": null, "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\n\r\nWe're using [`nix`](https://nixos.org/manual/nix/stable/#ch-about-nix) to build rust crates and benefit from binary caches which are usually populated by our CI. I'll assume a slightly familiarity but I can elaborate when necessary. The details are not too important but it means that the following scenario can happen:\r\n\r\nConsider a crate `C` that depends on crate `B` that depends on crate `A` (that depends on `std`). Now, the following sequence of events happens.\r\n\r\n* Start with empty binary cache\r\n* Developer hacks on code and ends up building only crate `A` locally. Let's call this build result `A-local`. This goes into the `/nix/store` and `A` is never rebuilt again (it is in immutable location) and is always reused when all the inputs (sources, dependencies) are identical.\r\n* Developer is happy and pushes his code. CI starts.\r\n* CI does a run wanting to build the more of the project which in our case is crates `A`, `B` and `C`. CI is also using nix and binary cache is currently empty.\r\n* CI builds `A`: this has exactly the same inputs and so is given exactly same hash. Let's call it `A-cache`. It pushes pushes `A-cache` to some binary cache (in S3 for example).\r\n* CI also builds `B` using the `A-cache` it _just_ built, let's say it's called `B-cache`. It pushes it to binary cache too.\r\n* Lastly, CI builds `C` as `C-cache` and pushes to binary cache. Everything is great, CI is green.\r\n* The developer now wants `C` on local machine, perhaps it is a binary crate . However, the developer first makes some changes to `C` source code, maybe added some debug info. So what do we have to build?\r\n  * `A` doesn't need building: it's already stored locally as `A-local` in local `/nix/store`\r\n  * `B` is needed to build `C`: luckily `B` exists in a binary cache as `B-cache` so we just download it.\r\n  * `C` source code changed so we have to build it, we have `A-local` and `B-cache` in the dependency tree now.\r\n  \r\nDoes the build succeed? Most of the time, yes. But sometimes, it fails if rustc produced two incompatible results for `A`: that is, if `A-local` and `A-cache` differ, we're in trouble. The developer can't use `A-local` with `B-cache`: only `A-cache` is usable.\r\n\r\nAn error message might look like:\r\n\r\n```\r\nerror[E0460]: found possibly newer version of crate `parse_display` which `trader` depends on\r\n  --> src/c/foo.rs:21:5\r\n   |\r\n21 | use b::something;\r\n   |     ^^^^^^\r\n   |\r\n   = note: perhaps that crate needs to be recompiled?\r\n   = note: the following crate versions were found:\r\n           crate `a`: /nix/store/a-local-input-hash/lib/liba-local-38cc57346a.rlib\r\n           crate `b`: /nix/store/b-local-input-hash/lib/libb-local-f69511fec1.rlib\r\n\r\nerror: aborting due to previous error\r\n```\r\n\r\nIn my real case, `A` is `parse_display` create, `B` is our local crate called `trader` and `C` was another crate in the workspace that depended on `trader`.  As `B` (trader) came from binary cache, it is binary-identical and we only have to focus on `A`.\r\n\r\n## Investigation\r\n\r\nFirst, let's see what rustc says:\r\n```\r\n INFO rustc_metadata::creader resolving dep crate parse_display hash: `5963747a8c8f099e` extra filename: `-38cc57346a`\r\n INFO rustc_metadata::creader resolving crate `parse_display`\r\n INFO rustc_metadata::creader falling back to a load\r\n INFO rustc_metadata::locator lib candidate: target/deps/libparse_display-38cc57346a.rlib\r\n INFO rustc_metadata::locator rlib reading metadata from: /nix/store/pfy5c0x8jbx44xfnsrqb5yp5sz5ahpxx-rust_parse-display-0.5.2-lib/lib/libparse_display-38cc57346a.rlib\r\n INFO rustc_metadata::locator Rejecting via hash: expected 5963747a8c8f099e got 5f612fa7f4240092\r\n```\r\n\r\nLooks like the hash it expects is not what it gets. Back to this later. Let's try to look for something obvious in the `.rlib`.\r\n\r\n```\r\n$ sha256sum libparse_display-38cc57346a.rlib /nix/store/pfy5c0x8jbx44xfnsrqb5yp5sz5ahpxx-rust_parse-display-0.5.2-lib/lib/libparse_display-38cc57346a.rlib\r\nc26bf883248419284608aa1595043e67a9a8a137a62e345172cd87fc112e32a2  libparse_display-38cc57346a.rlib\r\n05af37f3ed3bd95c001f0754e5102589e2d03640de4c65b33093dfcac63b7f2f  /nix/store/pfy5c0x8jbx44xfnsrqb5yp5sz5ahpxx-rust_parse-display-0.5.2-lib/lib/libparse_display-38cc57346a.rlib\r\n```\r\n\r\n```\r\n$ diff <(nm ./libparse_display-38cc57346a.rlib) <(nm /nix/store/pfy5c0x8jbx44xfnsrqb5yp5sz5ahpxx-rust_parse-display-0.5.2-lib/lib/libparse_display-38cc57346a.rlib)\r\nnm: lib.rmeta: no symbols\r\nnm: lib.rmeta: no symbols\r\n\r\n[shana@aya:/tmp/foo]$ diff <(objdump -x ./libparse_display-38cc57346a.rlib) <(objdump -x /nix/store/pfy5c0x8jbx44xfnsrqb5yp5sz5ahpxx-rust_parse-display-0.5.2-lib/lib/libparse_display-38cc57346a.rlib)\r\n1c1\r\n< In archive ./libparse_display-38cc57346a.rlib:\r\n---\r\n> In archive /nix/store/pfy5c0x8jbx44xfnsrqb5yp5sz5ahpxx-rust_parse-display-0.5.2-lib/lib/libparse_display-38cc57346a.rlib:\r\n155c155\r\n<   0 .rmeta        000096d9  0000000000000000  0000000000000000  00000040  2**0\r\n---\r\n>   0 .rmeta        000096da  0000000000000000  0000000000000000  00000040  2**0\r\n\r\n[shana@aya:/tmp/foo]$ diff <(strings ./libparse_display-38cc57346a.rlib) <(strings /nix/store/pfy5c0x8jbx44xfnsrqb5yp5sz5ahpxx-rust_parse-display-0.5.2-lib/lib/libparse_display-38cc57346a.rlib)\r\n```\r\n\r\nIf I compare binaries side-by-side, it looks like the two files are 1 byte misaligned in first section and have minor differences later on. I will include both files for your own inspection too.\r\n\r\n```\r\n 228   \u2502 000038c0: 635f 756e 7769 6e64 94d9 ef8b cdb7 abd5 5600 0111 2d30 3666 3031 6163 3235 3738 6264 6139 3409 6f6e 6365 5f63 656c 6cd2 8bbc ec86 a5dc ab8b 0100 020b 2d35 6636  c_unwind........V...-06f01ac2578bda94.once_cell.............-5f6             000038c0: 635f 756e 7769 6e64 94d9 ef8b cdb7 abd5 5600 0111 2d30 3666 3031 6163 3235 3738 6264 6139 3409 6f6e 6365 5f63 656c 6cd2 8bbc ec86 a5dc ab8b 0100 020b 2d35 6636  c_unwind........V...-06f01ac2578bda94.once_cell.............-5f6\r\n 229   \u2502 00003900: 3138 6161 3539 6605 7265 6765 78a2 84b8 b4ed bbff 9332 0002 0b2d 6230 3132 3039 6331 6531 0c72 6567 6578 5f73 796e 7461 788b a4cc c6c0 ddf3 a7de 0100 020b 2d35  18aa59f.regex........2...-b01209c1e1.regex_syntax.............-5             00003900: 3138 6161 3539 6605 7265 6765 78a2 84b8 b4ed bbff 9332 0002 0b2d 6230 3132 3039 6331 6531 0c72 6567 6578 5f73 796e 7461 788b a4cc c6c0 ddf3 a7de 0100 020b 2d35  18aa59f.regex........2...-b01209c1e1.regex_syntax.............-5\r\n 230   \u2502 00003940: 3238 3233 6265 3866 380c 6168 6f5f 636f 7261 7369 636b 9aca c888 a2e8 82ca 2c00 020b 2d35 3438 6335 3563 3461 3606 6d65 6d63 6872 c7f1 a28d f4a2 84c0 0a00 020b  2823be8f8.aho_corasick........,...-548c55c4a6.memchr............             00003940: 3238 3233 6265 3866 380c 6168 6f5f 636f 7261 7369 636b 9aca c888 a2e8 82ca 2c00 020b 2d35 3438 6335 3563 3461 3606 6d65 6d63 6872 c7f1 a28d f4a2 84c0 0a00 020b  2823be8f8.aho_corasick........,...-548c55c4a6.memchr............\r\n 231   \u2502 00003980: 2d31 3331 6563 3830 6434 3114 7061 7273 655f 6469 7370 6c61 795f 6465 7269 7665 ce9a f3ad b9c0 86a2 8b01 0000 0b2d 6335 6132 6166 3538 3438 0000 001d 2f90 b8af  -131ec80d41.parse_display_derive.............-c5a2af5848..../...           | 00003980: 2d31 3331 6563 3830 6434 3114 7061 7273 655f 6469 7370 6c61 795f 6465 7269 7665 9fda dfa4 e3d3 f580 1700 000b 2d63 3561 3261 6635 3834 3800 0000 1d2f 90b8 af64  -131ec80d41.parse_display_derive............-c5a2af5848..../...d\r\n 232   \u2502 000039c0: 6448 ea7a e3a5 752d 3bbf 2d01 0001 001d 2f90 b8af 6448 eaa4 cc8c bfdb f1b9 2301 0003 0373 7464 001d 2f90 b8af 6448 eaee aad1 d9c3 701f 6101 0001 011d 2f90 b8af  dH.z..u-;.-...../...dH........#....std../...dH......p.a...../...           | 000039c0: 48ea 7ae3 a575 2d3b bf2d 0100 0100 1d2f 90b8 af64 48ea a4cc 8cbf dbf1 b923 0100 0303 7374 6400 1d2f 90b8 af64 48ea eeaa d1d9 c370 1f61 0100 0101 1d2f 90b8 af64  H.z..u-;.-...../...dH........#....std../...dH......p.a...../...d\r\n 233   \u2502 00003a00: 6448 ea6f ff54 d9ae a053 9f01 0001 021d 2f90 b8af 6448 eaa0 3fcf ee88 19b8 c901 0001 031d 2f90 b8af 6448 eae6 0668 5fbb d337 7901 0001 041d 2f90 b8af 6448 ea21  dH.o.T...S....../...dH..?.........../...dH...h_..7y...../...dH.!           | 00003a00: 48ea 6fff 54d9 aea0 539f 0100 0102 1d2f 90b8 af64 48ea a03f cfee 8819 b8c9 0100 0103 1d2f 90b8 af64 48ea e606 685f bbd3 3779 0100 0104 1d2f 90b8 af64 48ea 2185  H.o.T...S....../...dH..?.........../...dH...h_..7y...../...dH.!.\r\n```\r\n\r\nOf course, it's very difficult to tell anything by just looking at raw binary. I tried to add extra information to `rustc` itself so that I could see during the hashing what values it's getting: if hash inputs were different, we'd see which ones and be able to go backwards from there. Looking around, I think `crate_hash` function is the point to change\r\n\r\n```diff\r\ndiff --git a/compiler/rustc_middle/src/hir/map/mod.rs b/compiler/rustc_middle/src/hir/map/mod.rs\r\nindex 392372fad53..dafd15b5a46 100644\r\n--- a/compiler/rustc_middle/src/hir/map/mod.rs\r\n+++ b/compiler/rustc_middle/src/hir/map/mod.rs\r\n@@ -968,6 +968,7 @@ pub(super) fn index_hir<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> &'tcx IndexedHir<'tc\r\n pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\r\n     assert_eq!(crate_num, LOCAL_CRATE);\r\n \r\n+    tracing::info!(\"Starting to hash {:?}\", crate_num);\r\n     // We can access untracked state since we are an eval_always query.\r\n     let mut hcx = tcx.create_stable_hashing_context();\r\n \r\n@@ -984,7 +985,9 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\r\n             Some((def_path_hash, hasher.finish()))\r\n         })\r\n         .collect();\r\n+    tracing::info!(\"pre-sort {:?}: {:?}\", crate_num, hir_body_nodes);\r\n     hir_body_nodes.sort_unstable_by_key(|bn| bn.0);\r\n+    tracing::info!(\"post-sort {:?}: {:?}\", crate_num, hir_body_nodes);\r\n \r\n     let node_hashes = hir_body_nodes.iter().fold(\r\n         Fingerprint::ZERO,\r\n@@ -992,8 +995,11 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\r\n             combined_fingerprint.combine(def_path_hash.0.combine(fingerprint))\r\n         },\r\n     );\r\n+    tracing::info!(\"node_hashes {:?}: {:?}\", crate_num, node_hashes);\r\n+\r\n \r\n     let upstream_crates = upstream_crates(tcx);\r\n+    tracing::info!(\"upstream_crates {:?}: {:?}\", crate_num, upstream_crates);\r\n \r\n     // We hash the final, remapped names of all local source files so we\r\n     // don't have to include the path prefix remapping commandline args.\r\n@@ -1009,17 +1015,26 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\r\n         .map(|source_file| source_file.name_hash)\r\n         .collect();\r\n \r\n+    tracing::info!(\"source_file_names before {:?}: {:?}\", crate_num, source_file_names);\r\n     source_file_names.sort_unstable();\r\n+    tracing::info!(\"source_file_names after {:?}: {:?}\", crate_num, source_file_names);\r\n \r\n     let mut stable_hasher = StableHasher::new();\r\n+    tracing::info!(\"node_hashes {:?}: {:?}\", crate_num, node_hashes);\r\n     node_hashes.hash_stable(&mut hcx, &mut stable_hasher);\r\n+    tracing::info!(\"upstream_crates {:?}: {:?}\", crate_num, upstream_crates);\r\n     upstream_crates.hash_stable(&mut hcx, &mut stable_hasher);\r\n+    tracing::info!(\"source_file_names {:?}: {:?}\", crate_num, source_file_names);\r\n     source_file_names.hash_stable(&mut hcx, &mut stable_hasher);\r\n+    tracing::info!(\"opts {:?}: {:?}\", crate_num, tcx.sess.opts.dep_tracking_hash(true));\r\n     tcx.sess.opts.dep_tracking_hash(true).hash_stable(&mut hcx, &mut stable_hasher);\r\n+    tracing::info!(\"local_stable_crate_id {:?}: {:?}\", crate_num, tcx.sess.local_stable_crate_id());\r\n     tcx.sess.local_stable_crate_id().hash_stable(&mut hcx, &mut stable_hasher);\r\n+    tracing::info!(\"non_exported_macro_attrs {:?}: {:?}\", crate_num, tcx.untracked_crate.non_exported_macro_attrs);\r\n     tcx.untracked_crate.non_exported_macro_attrs.hash_stable(&mut hcx, &mut stable_hasher);\r\n \r\n     let crate_hash: Fingerprint = stable_hasher.finish();\r\n+    tracing::info!(\"crate_hash {:?}: {:?}\", crate_num, crate_hash);\r\n     Svh::new(crate_hash.to_smaller_hash())\r\n }\r\n\r\n```\r\n\r\n```diff\r\n# Includes one of the default files in src/bootstrap/defaults\r\nprofile = \"compiler\"\r\nchangelog-seen = 2\r\n[rust]\r\nchannel = \"stable\"\r\n```\r\n\r\nSadly, this doesn't work for ironically similar reason: building this compiler locally gives a new `std` hash which means I can't re-invoke original `rustc` command with the original `.rlibs` as those depend on `std` which has the wrong hash...\r\n\r\nAt this point I decided to open this ticket: how can I debug this further? At this point I am more or less getting ready to try to gut `rustc` to the point that I can call `crate_hash` myself or the rlibs directly but it seems like a lot of work and I'm not confident it's even going to work. I didn't find any tool to read `rlib` files either.\r\n\r\nIf we can find what the difference between the two files it, presumably we can work backwards and find why `rustc` produced two different results.\r\n\r\nHere are the files: [different_rlibs.tar.gz](https://github.com/rust-lang/rust/files/7351300/different_rlibs.tar.gz). `local` was one I built locally and `cache` is from the binary cache, built by CI machine.\r\n\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.55.0 (c8dfcfe04 2021-09-06)\r\n```\r\n\r\nI originally suspected that codegen-units may be the culprit: some concurrent resource getting non-deterministically modified, such as to hand out some Ids or something that made it to the code. But no, the issue occurred even with codegen-units=1.\r\n\r\nIt is difficult to verify or replicate the bug because it happens fairly rarely so it seems like looking at the rlibs I attached above is probably the fastest way to figure something out.", "closed_by": {"login": "Fuuzetsu", "id": 893115, "node_id": "MDQ6VXNlcjg5MzExNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/893115?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Fuuzetsu", "html_url": "https://github.com/Fuuzetsu", "followers_url": "https://api.github.com/users/Fuuzetsu/followers", "following_url": "https://api.github.com/users/Fuuzetsu/following{/other_user}", "gists_url": "https://api.github.com/users/Fuuzetsu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Fuuzetsu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Fuuzetsu/subscriptions", "organizations_url": "https://api.github.com/users/Fuuzetsu/orgs", "repos_url": "https://api.github.com/users/Fuuzetsu/repos", "events_url": "https://api.github.com/users/Fuuzetsu/events{/privacy}", "received_events_url": "https://api.github.com/users/Fuuzetsu/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/89904/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/89904/timeline", "performed_via_github_app": null, "state_reason": "completed"}