{"url": "https://api.github.com/repos/rust-lang/rust/issues/55352", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/55352/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/55352/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/55352/events", "html_url": "https://github.com/rust-lang/rust/issues/55352", "id": 374067936, "node_id": "MDU6SXNzdWUzNzQwNjc5MzY=", "number": 55352, "title": "Rustc adds line-number information for unhittable panic handlers", "user": {"login": "bossmc", "id": 1073983, "node_id": "MDQ6VXNlcjEwNzM5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1073983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bossmc", "html_url": "https://github.com/bossmc", "followers_url": "https://api.github.com/users/bossmc/followers", "following_url": "https://api.github.com/users/bossmc/following{/other_user}", "gists_url": "https://api.github.com/users/bossmc/gists{/gist_id}", "starred_url": "https://api.github.com/users/bossmc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bossmc/subscriptions", "organizations_url": "https://api.github.com/users/bossmc/orgs", "repos_url": "https://api.github.com/users/bossmc/repos", "events_url": "https://api.github.com/users/bossmc/events{/privacy}", "received_events_url": "https://api.github.com/users/bossmc/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 203130, "node_id": "MDU6TGFiZWwyMDMxMzA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-debuginfo", "name": "A-debuginfo", "color": "f7e101", "default": false, "description": "Area: Debugging information in compiled programs (DWARF, PDB, etc.)"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 4, "created_at": "2018-10-25T18:11:31Z", "updated_at": "2023-04-05T17:45:54Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "_First off, root issue I was investigating was kcov producing bad coverage information for Rust binaries.  I've worked out why kcov is producing the results it is and they're \"correct\" given what Rustc is doing.  I'm not sure where the fix (if any) needs to be made, but I'm starting with Rustc as kcov's strategy looks sound._\r\n\r\nConsider the following code:\r\n\r\n```\r\nstruct Person {\r\n  name: String,\r\n  age: u32,\r\n}\r\n\r\nfn get_age() -> u32 {\r\n  42\r\n}\r\n\r\nfn create_bob() -> Person {\r\n  Person {\r\n    name: \"Bob\".to_string(),\r\n    age: get_age(),\r\n  }  // Uncovered\r\n}\r\n\r\nfn main() {\r\n  let b = create_bob();\r\n}\r\n```\r\n\r\nKcov will mark the \"Uncovered\" line as unhit.  This is surprising, as that line was definitely passed during the execution of the program.  Lines can be omitted from kcov coverage (with `// KCOV_EXCL_LINE`) but this leads to hundreds of those markers scattered around the code, potentially hiding real coverage lapses/lowering maintainability of the codebase.\r\n\r\n----\r\n\r\nKcov determines coverage by looking at the `.debug_lines` section of the binary, which contains a mapping from address in the binary to line of code.  It then sets a break point at every listed address before running the program.  Each time a break point is hit, kcov marks the associated line of code as hit, and clears the breakpoint (as hitting it again tells us nothing, and breakpoints are slow).  After the process completes, any lines remaining were not hit.\r\n\r\nThis means that kcov's \"was this line hit\" logic is pretty solid, assuming the `.debug_lines` section is accurate.\r\n\r\n----\r\n\r\nWhen Rust generates a block that calls any function after creating any binding to a type with a `Drop` implementation, it also generates a unwind-cleanup block to call that `drop()` in the event of the function `panic`-ing.  In the above case, the generated code is something like (assuming Rust had exceptions):\r\n\r\n```\r\nfn create_bob() -> Person {\r\n  let name = \"Bob\".to_string();\r\n  try {\r\n    let age = get_age();\r\n  } catch e {\r\n    drop(name);\r\n    throw e;\r\n  }\r\n  Person {\r\n    name,\r\n    age,\r\n  }\r\n}\r\n```\r\n\r\nThis makes sense, if there is a panic (which might get handled up the stack somewhere) we should delete bindings that are memory-safe (yay Rust!) to free up memory that's not going to be accessible any more.  \r\n\r\n----\r\n\r\nUnfortunately:\r\n\r\n* The cleanup code is associated with the \"end of block\" marker (the `}` line marked above) so unless `get_age` panics, this code won't be hit.\r\n* The marked line is not associated with any other generated machine code, so nothing else will cause kcov to consider it hit\r\n* `get_age` never panics so this cleanup code can't be hit (without changing the `get_age()` function at least)\r\n\r\nIn a release build, the cleanup handler is stripped because LLVM notices that there's no way for anything in the `try` block to panic, so the handler is not needed.  In a debug build, it doesn't do this optimisation and leaves genuinely unhittable code in the binary, but associates it with a line of code, causing many false positives in kcov's output (especially as kcov uses debug builds to prevent dead-code elimination removing untested code).\r\n\r\n----\r\n\r\nWhat to do differently?  I'm not sure, but here are some ideas:\r\n\r\n* Associate the cleanup of a binding with the line that created the binding, rather than the end of the block.  Might be confusing if you are actually debugging a panic cleanup.\r\n* Don't associate the cleanup code with any lines of code.  Definitely unhelpful in panic debugging.\r\n* Enhance Kcov to ignore cleanup landing pads.  Isn't really fair, as in a language like C++ exceptions are fairly common and cleanup is important.  Also, landing pads are language-specific (see eh_personality and friends) so it's tricky to get this right.\r\n* Somehow perform minimal dead-code elimination even in debug builds (or test builds more accurately) that only removes unnecessary cleanup code.  Not sure how plausible this is, nor how likely it is to create false positives.\r\n* Something else...?", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/55352/reactions", "total_count": 6, "+1": 5, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 1, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/55352/timeline", "performed_via_github_app": null, "state_reason": null}