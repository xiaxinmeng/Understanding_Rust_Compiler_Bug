{"url": "https://api.github.com/repos/rust-lang/rfcs/issues/3006", "repository_url": "https://api.github.com/repos/rust-lang/rfcs", "labels_url": "https://api.github.com/repos/rust-lang/rfcs/issues/3006/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rfcs/issues/3006/comments", "events_url": "https://api.github.com/repos/rust-lang/rfcs/issues/3006/events", "html_url": "https://github.com/rust-lang/rfcs/issues/3006", "id": 725923061, "node_id": "MDU6SXNzdWU3MjU5MjMwNjE=", "number": 3006, "title": "Feature request: Preventing dropping fields of a dropped struct for better C++ interoperability", "user": {"login": "Volker-Weissmann", "id": 39418860, "node_id": "MDQ6VXNlcjM5NDE4ODYw", "avatar_url": "https://avatars.githubusercontent.com/u/39418860?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Volker-Weissmann", "html_url": "https://github.com/Volker-Weissmann", "followers_url": "https://api.github.com/users/Volker-Weissmann/followers", "following_url": "https://api.github.com/users/Volker-Weissmann/following{/other_user}", "gists_url": "https://api.github.com/users/Volker-Weissmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/Volker-Weissmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Volker-Weissmann/subscriptions", "organizations_url": "https://api.github.com/users/Volker-Weissmann/orgs", "repos_url": "https://api.github.com/users/Volker-Weissmann/repos", "events_url": "https://api.github.com/users/Volker-Weissmann/events{/privacy}", "received_events_url": "https://api.github.com/users/Volker-Weissmann/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 16, "created_at": "2020-10-18T07:14:13Z", "updated_at": "2020-10-22T14:32:41Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "I'm currently working on bindgen. The goal is to let rust code use C++ libraries as nicely as possible. There is one crucial element missing in Rust to achieve this:\r\n\r\nQuote from [the docs](https://doc.rust-lang.org/nomicon/destructors.html):\r\n\r\n> After drop is run, Rust will recursively try to drop all of the fields of self.\r\n>\r\n> There is no stable way to prevent this behavior in Rust 1.0.\r\n\r\nWe need a way to prevent this and here is why:\r\n\r\nLet's say your library looks something like this:\r\n```c++\r\nclass Inner {\r\n    public:\r\n    ~Inner(){}\r\n};\r\nclass Outer {\r\n    public:\r\n    Inner i;\r\n    ~Outer(){}\r\n};\r\n```\r\nUsing [godbolt](godbolt), we find that gcc compiles this to\r\n```asm\r\nOuter::~Outer() [base object destructor]:\r\n        push    rbp\r\n        mov     rbp, rsp\r\n        sub     rsp, 16\r\n        mov     QWORD PTR [rbp-8], rdi\r\n        mov     rax, QWORD PTR [rbp-8]\r\n        mov     rdi, rax\r\n        call    Inner::~Inner() [complete object destructor]\r\n        nop\r\n        leave\r\n        ret\r\n```\r\nThe important part here is that calling ~Outer() calls ~Inner() and afaik there is no standard conform way to change this.\r\n\r\nIf we now want to use this library from Rust the naive way to do it would be\r\n\r\n```rust\r\n#[repr(C)]\r\nstruct Inner {\t\r\n}\r\n#[repr(C)]\r\nstruct Outer {\r\n\tinvar: Inner,\r\n}\r\nimpl Drop for Inner {\r\n\tfn drop(&mut self) {\r\n\t\textern_c_destructor_inner(&mut self);\r\n\t}\r\n}\r\nimpl Drop for Outer {\r\n\tfn drop(&mut self) {\r\n\t\textern_c_destructor_outer(&mut self);\r\n\t}\r\n}\r\n```\r\nThe problem here is that `extern_c_destructor_outer(&mut self)` calls `extern_c_destructor_inner` (as we saw in godbolts output), and the recursive field dropping will call `extern_c_destructor_inner()` again. Calling a destructor twice is UB.\r\n\r\nHow can we prevent this? One way would be not impl Drop and just call the destructors manually, but I think we all know how incredibly tedious that would be.  The second obvious way would be to use Options, similarly to how the [nomicon](https://doc.rust-lang.org/nomicon/destructors.html) does it, but this does not for us, because we rely on the structure having the same size as the C++ equivalent.\r\n\r\nAnother way you might suggest is wrapping it in ManuallyDrop:\r\n```rust\r\n#[repr(C)]\r\nstruct Inner {\t\r\n}\r\n#[repr(C)]\r\nstruct Outer {\r\n\tinvar: ManuallyDrop::<Inner>,\r\n}\r\nimpl Drop for Inner {\r\n\tfn drop(&mut self) {\r\n\t\textern_c_destructor_inner(&mut self);\r\n\t}\r\n}\r\nimpl Drop for Outer {\r\n\tfn drop(&mut self) {\r\n\t\textern_c_destructor_outer(&mut self);\r\n\t}\r\n}\r\n```\r\nBut if for example, you want to reassign invar, you got a Problem, because this\r\n```rust\r\nlet mut o = Outer{ invar:ManuallyDrop::new(Inner{})};\r\no.invar = ManuallyDrop::new(Inner{})\r\n```\r\nhas not only a terrible syntax, but also leaks memory if Inner allocates memory. Everytime you want to assign you would need to drop it manually and this can't be automated nicely, because you cannot overload the assignment operator in Rust. The last possible way would be to not make member variables public and use getters and setters. This would theoretically, but if the goal is to make the Syntax of using a C++ library as nice as possible and as close to the C++ original as possible this is not a good option.\r\n\r\nThe only good option I could think of is to add a feature to Rustc that lets you disable the recursive dropping. Then you could write:\r\n\r\n```rust\r\n#[repr(C)]\r\n#[no_field_dropping]\r\nstruct Inner {\t\r\n}\r\n#[repr(C)]\r\n#[no_field_dropping]\r\nstruct Outer {\r\n\tinvar: Inner,\r\n}\r\nimpl Drop for Inner {\r\n\tfn drop(&mut self) {\r\n\t\textern_c_destructor_inner(&mut self);\r\n\t}\r\n}\r\nimpl Drop for Outer {\r\n\tfn drop(&mut self) {\r\n\t\textern_c_destructor_outer(&mut self);\r\n\t}\r\n}\r\n```\r\n\r\nAnd the `#[no_field_dropping]` before `struct Outer` would tell rustc to not drop `invar` when dropping outer.\r\n\r\nI think this should be zero-runtime memory and cycles cost and very limited compile time memory and cycles cost. If I'm not mistaken, Rustc currently generates the calls to all destructors when a variable goes out of scope. If `#[no_field_dropping]` is set Rustc needs to only generate the call to the destructor of the struct, but not the calls to the destructors of the fields.\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rfcs/issues/3006/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rfcs/issues/3006/timeline", "performed_via_github_app": null, "state_reason": null}