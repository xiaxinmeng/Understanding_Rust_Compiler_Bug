{"url": "https://api.github.com/repos/rust-lang/rust/issues/81146", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/81146/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/81146/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/81146/events", "html_url": "https://github.com/rust-lang/rust/issues/81146", "id": 787834189, "node_id": "MDU6SXNzdWU3ODc4MzQxODk=", "number": 81146, "title": "Generated Result propagation code is needlessly complex", "user": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 2238600090, "node_id": "MDU6TGFiZWwyMjM4NjAwMDkw", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-result-option", "name": "A-result-option", "color": "f7e101", "default": false, "description": "Area: Result and Option combinators"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2021-01-18T00:36:29Z", "updated_at": "2021-01-23T22:23:20Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "This case was found in #80463. Replacing some infallible code with code that needed to propagate `Result`s led to some performance issues. It looked like the `Result` propagation code was less efficient than it could be. The code below approximately reproduces the original issue.\r\n\r\n```rust\r\nuse std::fs::File;\r\nuse std::io::Write;\r\n\r\n#[derive(Debug)]\r\nenum Error {\r\n    A(u32),\r\n    B(u64),\r\n}\r\n\r\n#[inline(never)]\r\nfn println() {\r\n    println!();\r\n}\r\n\r\n#[inline(never)]\r\nfn bar() -> Result<(), Error> {\r\n    let mut file = File::create(\"x.bin\").unwrap();\r\n    let result = file.write_all(&[1]);\r\n\r\n    if let Err(err) = result {\r\n        if err.to_string().len() == 0 {\r\n            return Err(Error::A(10))\r\n        }\r\n    }\r\n\r\n    return Ok(())\r\n}\r\n\r\n#[inline(never)]\r\nfn foo() -> Result<(), Error> {\r\n    bar()?;\r\n    println();\r\n    Ok(())\r\n}\r\n\r\nfn main() {\r\n    foo().unwrap();\r\n}\r\n```\r\n\r\nThe assembly for `foo` (release build for x86_64 Linux target) is what we're interested in:\r\n\r\n```asm\r\n<x::foo>:\r\n\t       push   %rbx              ; We'll be using rbx, and it's callee-save, so save it\r\n\t       callq  <x::bar>          ; Call bar\r\n\t       mov    %rax,%rbx         ; Preserve rax before println\r\n\t       cmp    $0x2,%ebx         ; Did bar return Ok?\r\n\t   /-- jne                      ; If not, take jump\r\n\t   |   callq  <x::println>      ; Otherwise, call println\r\n\t/--|-- jmp                      ; And jump\r\n\t|  \\-> mov    %rbx,%rcx         ; Silliness ensues\r\n\t|      shrd   $0x20,%rdx,%rcx\r\n\t|      shr    $0x20,%rdx\r\n\t\\----> shld   $0x20,%rcx,%rdx\r\n\t       shl    $0x20,%rcx\r\n\t       mov    %ebx,%eax\r\n\t       or     %rcx,%rax         ; rax and rdx now contain Result to return\r\n\t       pop    %rbx              ; Restore rbx\r\n\t       retq                     ; Return\r\n```\r\n\r\nI believe this could optimize down to something like this instead:\r\n\r\n```asm\r\n<x::foo>:\r\n\t       push   %rcx              ; Ensure 16 byte stack alignment for calls\r\n\t       callq  <x::bar>\r\n\t       cmp    $0x2,%eax\r\n\t   /-- jne\r\n\t   |   callq  <x::println>\r\n\t   |   move   %0x2,%eax\r\n\t   \\-> pop    %rcx\r\n\t       retq   \r\n```\r\n\r\nWhen `bar` returns an `Err`, all we need to do is propagate the 16 byte `Result`, already contained in `rax` and `rdx`, which is exactly where `foo` needs to return it from.\r\n\r\nWhen `bar` succeeds, all we need to do is call `println` and then return `Result::Ok` (set the appropriate enum tag in `rax`).\r\n\r\nYou can step through the original assembly and see that this all happens, but that it's done in a really convoluted way:\r\n\r\n* In the `bar` returns `Err` case, the shifting, etc. is such that `rax` and `rdx` contain the same `Err` value returned by `bar`, as desired. But `rax` and `rdx` *already* contained those values after the `bar` call, so all of that shifting, etc. was extra work.\r\n\r\n* In the `bar` returns `Ok` case, we do set the enum tag to that of the `Ok` variant by way of `mov %ebx, %eax`, but we also modify `rdx` needlessly (in the `Err(value)` case, `rdx` contains the `value`, but it's not needed in `Ok` case), and we modify `rcx` and `or` it into `rax` needlessly (`rcx` contains junk in this case, but `or`ing it in doesn't affect the tag value, since the lower bits of `rcx` have been shifted out). All of this could have been replaced with a `mov $0x2,%eax`.\r\n\r\nLLVM is either missing the optimization or we are not providing enough information to enable it to do the optimization.\r\n\r\n<details>\r\n<summary>LLVM IR after optimization passes</summary>\r\n\r\n```llvm\r\n; main::foo\r\n; Function Attrs: noinline nonlazybind uwtable\r\ndefine internal fastcc i128 @_ZN4main3foo17h790eccd96863c176E() unnamed_addr #0 {\r\nstart:\r\n; call main::bar\r\n  %0 = tail call fastcc i128 @_ZN4main3bar17h12f571ad2d6bd47aE()\r\n  %.sroa.020.0.extract.trunc = trunc i128 %0 to i32\r\n  %1 = icmp eq i32 %.sroa.020.0.extract.trunc, 2\r\n  br i1 %1, label %bb3, label %bb5\r\n\r\nbb3:                                              ; preds = %start\r\n; call main::println\r\n  tail call fastcc void @_ZN4main7println17h4b182729f4c1c974E()\r\n  br label %bb9\r\n\r\nbb5:                                              ; preds = %start\r\n  %.sroa.4.0.extract.shift33 = lshr i128 %0, 32\r\n  %.sroa.4.0.extract.trunc34 = trunc i128 %.sroa.4.0.extract.shift33 to i96\r\n  br label %bb9\r\n\r\nbb9:                                              ; preds = %bb3, %bb5\r\n  %.sroa.3.sroa.0.0 = phi i96 [ undef, %bb3 ], [ %.sroa.4.0.extract.trunc34, %bb5 ]\r\n  %.sroa.3.0.insert.ext = zext i96 %.sroa.3.sroa.0.0 to i128\r\n  %.sroa.3.0.insert.shift = shl nuw i128 %.sroa.3.0.insert.ext, 32\r\n  %.sroa.0.0.insert.ext = and i128 %0, 4294967295\r\n  %.sroa.0.0.insert.insert = or i128 %.sroa.3.0.insert.shift, %.sroa.0.0.insert.ext\r\n  ret i128 %.sroa.0.0.insert.insert\r\n}\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>LLVM IR before optimization passes</summary>\r\n\r\n```llvm\r\n; main::foo\r\n; Function Attrs: noinline nonlazybind uwtable\r\ndefine internal i128 @_ZN4main3foo17h790eccd96863c176E() unnamed_addr #2 {\r\nstart:\r\n  %0 = alloca i128, align 8\r\n  %1 = alloca i128, align 8\r\n  %2 = alloca i128, align 8\r\n  %3 = alloca i128, align 8\r\n  %_6 = alloca %Error, align 8\r\n  %_5 = alloca %Error, align 8\r\n  %err = alloca %Error, align 8\r\n  %_2 = alloca %\"std::result::Result<(), Error>\", align 8\r\n  %_1 = alloca %\"std::result::Result<(), Error>\", align 8\r\n  %4 = alloca %\"std::result::Result<(), Error>\", align 8\r\n  %5 = bitcast %\"std::result::Result<(), Error>\"* %_1 to i8*\r\n  call void @llvm.lifetime.start.p0i8(i64 16, i8* %5)\r\n  %6 = bitcast %\"std::result::Result<(), Error>\"* %_2 to i8*\r\n  call void @llvm.lifetime.start.p0i8(i64 16, i8* %6)\r\n; call main::bar\r\n  %7 = call i128 @_ZN4main3bar17h12f571ad2d6bd47aE()\r\n  %8 = bitcast i128* %3 to i8*\r\n  call void @llvm.lifetime.start.p0i8(i64 16, i8* %8)\r\n  store i128 %7, i128* %3, align 8\r\n  %9 = bitcast %\"std::result::Result<(), Error>\"* %_2 to i8*\r\n  %10 = bitcast i128* %3 to i8*\r\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %10, i64 16, i1 false)\r\n  %11 = bitcast i128* %3 to i8*\r\n  call void @llvm.lifetime.end.p0i8(i64 16, i8* %11)\r\n  br label %bb1\r\n\r\nbb1:                                              ; preds = %start\r\n; call <core::result::Result<T,E> as core::ops::try::Try>::into_result\r\n  %12 = call i128 @\"_ZN73_$LT$core..result..Result$LT$T$C$E$GT$$u20$as$u20$core..ops..try..Try$GT$11into_result17hef5a3592992010b5E\"(%\"std::result::Result<(), Error>\"* noalias nocapture dereferenceable(16) %_2)\r\n  %13 = bitcast i128* %2 to i8*\r\n  call void @llvm.lifetime.start.p0i8(i64 16, i8* %13)\r\n  store i128 %12, i128* %2, align 8\r\n  %14 = bitcast %\"std::result::Result<(), Error>\"* %_1 to i8*\r\n  %15 = bitcast i128* %2 to i8*\r\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %14, i8* align 8 %15, i64 16, i1 false)\r\n  %16 = bitcast i128* %2 to i8*\r\n  call void @llvm.lifetime.end.p0i8(i64 16, i8* %16)\r\n  br label %bb2\r\n\r\nbb2:                                              ; preds = %bb1\r\n  %17 = bitcast %\"std::result::Result<(), Error>\"* %_2 to i8*\r\n  call void @llvm.lifetime.end.p0i8(i64 16, i8* %17)\r\n  %18 = bitcast %\"std::result::Result<(), Error>\"* %_1 to i32*\r\n  %19 = load i32, i32* %18, align 8, !range !11\r\n  %20 = sub i32 %19, 2\r\n  %21 = icmp eq i32 %20, 0\r\n  %_3 = select i1 %21, i64 0, i64 1\r\n  switch i64 %_3, label %bb4 [\r\n    i64 0, label %bb3\r\n    i64 1, label %bb5\r\n  ]\r\n\r\nbb3:                                              ; preds = %bb2\r\n  %22 = bitcast %\"std::result::Result<(), Error>\"* %_1 to i8*\r\n  call void @llvm.lifetime.end.p0i8(i64 16, i8* %22)\r\n; call main::println\r\n  call void @_ZN4main7println17h4b182729f4c1c974E()\r\n  br label %bb8\r\n\r\nbb4:                                              ; preds = %bb2\r\n  unreachable\r\n\r\nbb5:                                              ; preds = %bb2\r\n  %23 = bitcast %Error* %err to i8*\r\n  call void @llvm.lifetime.start.p0i8(i64 16, i8* %23)\r\n  %24 = bitcast %\"std::result::Result<(), Error>\"* %_1 to %\"std::result::Result<(), Error>::Err\"*\r\n  %25 = bitcast %\"std::result::Result<(), Error>::Err\"* %24 to %Error*\r\n  %26 = bitcast %Error* %err to i8*\r\n  %27 = bitcast %Error* %25 to i8*\r\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %26, i8* align 8 %27, i64 16, i1 false)\r\n  %28 = bitcast %Error* %_5 to i8*\r\n  call void @llvm.lifetime.start.p0i8(i64 16, i8* %28)\r\n  %29 = bitcast %Error* %_6 to i8*\r\n  call void @llvm.lifetime.start.p0i8(i64 16, i8* %29)\r\n  %30 = bitcast %Error* %_6 to i8*\r\n  %31 = bitcast %Error* %err to i8*\r\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %30, i8* align 8 %31, i64 16, i1 false)\r\n; call <T as core::convert::From<T>>::from\r\n  %32 = call i128 @\"_ZN50_$LT$T$u20$as$u20$core..convert..From$LT$T$GT$$GT$4from17h9c2936a7ad0bb0a3E\"(%Error* noalias nocapture dereferenceable(16) %_6)\r\n  %33 = bitcast i128* %1 to i8*\r\n  call void @llvm.lifetime.start.p0i8(i64 16, i8* %33)\r\n  store i128 %32, i128* %1, align 8\r\n  %34 = bitcast %Error* %_5 to i8*\r\n  %35 = bitcast i128* %1 to i8*\r\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %34, i8* align 8 %35, i64 16, i1 false)\r\n  %36 = bitcast i128* %1 to i8*\r\n  call void @llvm.lifetime.end.p0i8(i64 16, i8* %36)\r\n  br label %bb6\r\n\r\nbb6:                                              ; preds = %bb5\r\n  %37 = bitcast %Error* %_6 to i8*\r\n  call void @llvm.lifetime.end.p0i8(i64 16, i8* %37)\r\n; call <core::result::Result<T,E> as core::ops::try::Try>::from_error\r\n  %38 = call i128 @\"_ZN73_$LT$core..result..Result$LT$T$C$E$GT$$u20$as$u20$core..ops..try..Try$GT$10from_error17hc0c7c23bfd8ab5f4E\"(%Error* noalias nocapture dereferenceable(16) %_5)\r\n  %39 = bitcast i128* %0 to i8*\r\n  call void @llvm.lifetime.start.p0i8(i64 16, i8* %39)\r\n  store i128 %38, i128* %0, align 8\r\n  %40 = bitcast %\"std::result::Result<(), Error>\"* %4 to i8*\r\n  %41 = bitcast i128* %0 to i8*\r\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %40, i8* align 8 %41, i64 16, i1 false)\r\n  %42 = bitcast i128* %0 to i8*\r\n  call void @llvm.lifetime.end.p0i8(i64 16, i8* %42)\r\n  br label %bb7\r\n\r\nbb7:                                              ; preds = %bb6\r\n  %43 = bitcast %Error* %_5 to i8*\r\n  call void @llvm.lifetime.end.p0i8(i64 16, i8* %43)\r\n  %44 = bitcast %Error* %err to i8*\r\n  call void @llvm.lifetime.end.p0i8(i64 16, i8* %44)\r\n  %45 = bitcast %\"std::result::Result<(), Error>\"* %_1 to i8*\r\n  call void @llvm.lifetime.end.p0i8(i64 16, i8* %45)\r\n  br label %bb9\r\n\r\nbb8:                                              ; preds = %bb3\r\n  %46 = bitcast %\"std::result::Result<(), Error>\"* %4 to %\"std::result::Result<(), Error>::Ok\"*\r\n  %47 = bitcast %\"std::result::Result<(), Error>::Ok\"* %46 to {}*\r\n  %48 = bitcast %\"std::result::Result<(), Error>\"* %4 to i32*\r\n  store i32 2, i32* %48, align 8\r\n  br label %bb9\r\n\r\nbb9:                                              ; preds = %bb8, %bb7\r\n  %49 = bitcast %\"std::result::Result<(), Error>\"* %4 to i128*\r\n  %50 = load i128, i128* %49, align 8\r\n  ret i128 %50\r\n}\r\n```\r\n</details>\r\n\r\nAlso, replacing `?` with manual propagation makes a difference, though it still produces less than optimal code:\r\n\r\n```rust\r\n#[inline(never)]\r\nfn foo() -> Result<(), Error> {\r\n    let r = bar();\r\n\r\n    if r.is_err() {\r\n        return r;\r\n    }\r\n\r\n    println();\r\n    Ok(())\r\n}\r\n```\r\n\r\n```asm\r\n<x::foo>:\r\n\t    push   %r14\r\n\t    push   %rbx\r\n\t    push   %rax\r\n\t    callq  <x::bar>\r\n\t    mov    %rax,%rbx\r\n\t    mov    %rdx,%r14\r\n\t    cmp    $0x2,%ebx\r\n\t/-- jne    <x::foo+0x19>\r\n\t|   callq  <x::println>\r\n\t\\-> mov    %rbx,%rax\r\n\t    mov    %r14,%rdx\r\n\t    add    $0x8,%rsp\r\n\t    pop    %rbx\r\n\t    pop    %r14\r\n\t    retq   \r\n```\r\n\r\n```\r\nrustc 1.49.0 (e1884a8e3 2020-12-29)\r\nbinary: rustc\r\ncommit-hash: e1884a8e3c3e813aada8254edfa120e85bf5ffca\r\ncommit-date: 2020-12-29\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.49.0\r\n```\r\n\r\n@rustbot label T-compiler A-LLVM I-slow", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/81146/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/81146/timeline", "performed_via_github_app": null, "state_reason": null}