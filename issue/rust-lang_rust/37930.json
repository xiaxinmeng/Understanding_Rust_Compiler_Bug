{"url": "https://api.github.com/repos/rust-lang/rust/issues/37930", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/37930/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/37930/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/37930/events", "html_url": "https://github.com/rust-lang/rust/issues/37930", "id": 190912451, "node_id": "MDU6SXNzdWUxOTA5MTI0NTE=", "number": 37930, "title": "Future::and_then and other adapters are not always zero cost", "user": {"login": "japaric", "id": 5018213, "node_id": "MDQ6VXNlcjUwMTgyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5018213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/japaric", "html_url": "https://github.com/japaric", "followers_url": "https://api.github.com/users/japaric/followers", "following_url": "https://api.github.com/users/japaric/following{/other_user}", "gists_url": "https://api.github.com/users/japaric/gists{/gist_id}", "starred_url": "https://api.github.com/users/japaric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/japaric/subscriptions", "organizations_url": "https://api.github.com/users/japaric/orgs", "repos_url": "https://api.github.com/users/japaric/repos", "events_url": "https://api.github.com/users/japaric/events{/privacy}", "received_events_url": "https://api.github.com/users/japaric/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 234956, "node_id": "MDU6TGFiZWwyMzQ5NTY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-codegen", "name": "A-codegen", "color": "f7e101", "default": false, "description": "Area: Code generation"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 12, "created_at": "2016-11-22T05:42:16Z", "updated_at": "2023-04-05T17:38:45Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "I expected these two code snippets to produce the same (or very similar) code\r\nwhen fully optimized (release+LTO) but they don't:\r\n\r\n``` rust\r\nlet tx = busy_wait(tx.write(4));\r\nbusy_wait(tx.write(2));\r\n```\r\n\r\n``` rust\r\nbusy_wait(tx.write(4).and_then(|tx| tx.write(2)));\r\n```\r\n\r\nThe first is `panic!`-free but the second is not; it still contains calls to\r\n`panic!(\"cannot poll a chained future twice\")` even though it never polls either\r\nfuture after it has yielded its value.\r\n\r\n### STR\r\n\r\n``` rust\r\n// src/main.rs\r\n#![feature(lang_items)]\r\n#![feature(never_type)]\r\n#![no_main]\r\n#![no_std]\r\n\r\nextern crate futures;\r\n\r\nuse core::{fmt, ptr};\r\n\r\nuse futures::{Async, Future};\r\n\r\n// entry point\r\n#[no_mangle]\r\npub fn _start() -> ! {\r\n    let tx = Tx { _0: () };\r\n\r\n    busy_wait(tx.write(4).and_then(|tx| tx.write(2)));\r\n\r\n    loop {}\r\n}\r\n\r\nstruct Tx {\r\n    _0: (),\r\n}\r\n\r\nimpl Tx {\r\n    fn write(self, byte: u8) -> Write {\r\n        Write {\r\n            tx: Some(self),\r\n            byte: byte,\r\n        }\r\n    }\r\n}\r\n\r\nstruct Write {\r\n    byte: u8,\r\n    tx: Option<Tx>,\r\n}\r\n\r\nimpl Future for Write {\r\n    type Error = !;\r\n    type Item = Tx;\r\n\r\n    fn poll(&mut self) -> Result<Async<Tx>, !> {\r\n        unsafe {\r\n            let tx = self.tx.take().expect(\"cannot poll `write` twice\");\r\n\r\n            // NOTE `0x0` and `0x4` emulate memory mapped IO registers\r\n            // Can we send data yet?\r\n            if ptr::read_volatile(0x0 as *const bool) {\r\n                // Send one byte of data\r\n                ptr::write_volatile(0x4 as *mut u8, self.byte);\r\n                Ok(Async::Ready(tx))\r\n            } else {\r\n                self.tx = Some(tx);\r\n                Ok(Async::NotReady)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn busy_wait<F>(mut f: F) -> F::Item\r\n    where F: Future<Error = !>\r\n{\r\n    loop {\r\n        if let Ok(Async::Ready(t)) = f.poll() {\r\n            return t;\r\n        }\r\n    }\r\n}\r\n\r\n#[lang = \"panic_fmt\"]\r\nextern \"C\" fn panic_fmt(_fmt: fmt::Arguments,\r\n                        _file: &'static str,\r\n                        _line: u32)\r\n                        -> ! {\r\n    // HACK to keep the `_file` string in the final binary\r\n    unsafe { ptr::write_volatile(0x8 as *mut _, _file) }\r\n    loop {}\r\n}\r\n```\r\n\r\n```\r\n$ head -n7 Cargo.toml\r\n[dependencies.futures]\r\ndefault-features = false\r\nversion = \"0.1.3\"\r\n\r\n[profile.release]\r\nlto = true\r\npanic = \"abort\"\r\n\r\n$ cargo rustc --release --verbose -- -C link-arg=-nostartfiles\r\n```\r\n\r\n``` asm\r\n$ objdump -Cd target/release/foo\r\n00000000000002c0 <_start>:\r\n 2c0:   b0 04                   mov    $0x4,%al\r\n 2c2:   31 c9                   xor    %ecx,%ecx\r\n 2c4:   66 66 66 2e 0f 1f 84    data16 data16 nopw %cs:0x0(%rax,%rax,1)\r\n 2cb:   00 00 00 00 00\r\n 2d0:   80 f9 01                cmp    $0x1,%cl\r\n 2d3:   74 3b                   je     310 <_start+0x50>\r\n 2d5:   66 66 2e 0f 1f 84 00    data16 nopw %cs:0x0(%rax,%rax,1)\r\n 2dc:   00 00 00 00\r\n 2e0:   f6 04 25 00 00 00 00    testb  $0x1,0x0\r\n 2e7:   01\r\n 2e8:   74 f6                   je     2e0 <_start+0x20>\r\n 2ea:   88 04 25 04 00 00 00    mov    %al,0x4\r\n 2f1:   84 c9                   test   %cl,%cl\r\n 2f3:   75 3d                   jne    332 <_start+0x72>\r\n 2f5:   b1 01                   mov    $0x1,%cl\r\n 2f7:   b0 02                   mov    $0x2,%al\r\n 2f9:   f6 04 25 00 00 00 00    testb  $0x1,0x0\r\n 300:   01\r\n 301:   74 cd                   je     2d0 <_start+0x10>\r\n 303:   c6 04 25 04 00 00 00    movb   $0x2,0x4\r\n 30a:   02\r\n 30b:   eb 23                   jmp    330 <_start+0x70>\r\n 30d:   0f 1f 00                nopl   (%rax)\r\n 310:   f6 04 25 00 00 00 00    testb  $0x1,0x0\r\n 317:   01\r\n 318:   74 f6                   je     310 <_start+0x50>\r\n 31a:   88 04 25 04 00 00 00    mov    %al,0x4\r\n 321:   66 66 66 66 66 66 2e    data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)\r\n 328:   0f 1f 84 00 00 00 00\r\n 32f:   00\r\n 330:   eb fe                   jmp    330 <_start+0x70>\r\n 332:   50                      push   %rax\r\n 333:   e8 38 00 00 00          callq  370 <core::panicking::panic::h194ce5d68a8f28a1>\r\n 338:   0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)\r\n 33f:   00\r\n\r\n0000000000000340 <core::panicking::panic_fmt::h561c5ee168a3d2cb>:\r\n(..)\r\n```\r\n\r\n```\r\n$ objcopy -O binary target/release/foo foo.bin\r\n\r\n$ strings foo.bin\r\n(..)\r\n/home/japaric/.cargo/registry/src/github.com-1ecc6299db9ec823/futures-0.1.3/src/chain.rs\r\n```\r\n\r\nIf the program is changed to the no-`and_then` variant, the disassembly looks\r\nlike this:\r\n\r\n``` asm\r\n$ objdump -Cd target/release/foo\r\n0000000000000280 <_start>:\r\n 280:   f6 04 25 00 00 00 00    testb  $0x1,0x0\r\n 287:   01\r\n 288:   74 f6                   je     280 <_start>\r\n 28a:   c6 04 25 04 00 00 00    movb   $0x4,0x4\r\n 291:   04\r\n 292:   66 66 66 66 66 2e 0f    data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)\r\n 299:   1f 84 00 00 00 00 00\r\n 2a0:   f6 04 25 00 00 00 00    testb  $0x1,0x0\r\n 2a7:   01\r\n 2a8:   74 f6                   je     2a0 <_start+0x20>\r\n 2aa:   c6 04 25 04 00 00 00    movb   $0x2,0x4\r\n 2b1:   02\r\n 2b2:   66 66 66 66 66 2e 0f    data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)\r\n 2b9:   1f 84 00 00 00 00 00\r\n 2c0:   eb fe                   jmp    2c0 <_start+0x40>\r\n```\r\n\r\nThere are no `panic_fmt` calls in it.\r\n\r\n### Meta\r\n\r\n```\r\n$ rustc -V\r\nrustc 1.15.0-nightly (43006fcea 2016-11-15)\r\n```\r\n\r\n---\r\n\r\nI don't think this is a problem with the implementation of `AndThen`/`Chain` in\r\nthe futures crate because I have tried to re-implement `Future` in a few\r\ndifferent ways e.g. without error-handling, sprinkling #[inline] everywhere but\r\nnone of that helps.\r\n\r\nCode like this:\r\n\r\n``` rust\r\nbusy_wait(futures::done(Ok(42)).and_then(|x| futures::done(Ok(x))));\r\n```\r\n\r\noptimizes the same as the \"split\" version and in that case LLVM evaluates the\r\nexpression at compile time and replaces it with `42`. So LLVM can actually lower\r\n`and_then` to `panic!` free code; it just doesn't optimize well this particular\r\ncase (perhaps, because of the volatile memory operations?)\r\n\r\n`join` is another adapter that has the same issue.\r\n\r\ncc @alexcrichton @eddyb", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/37930/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/37930/timeline", "performed_via_github_app": null, "state_reason": null}