{"url": "https://api.github.com/repos/rust-lang/rust/issues/4419", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/4419/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/4419/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/4419/events", "html_url": "https://github.com/rust-lang/rust/issues/4419", "id": 9861962, "node_id": "MDU6SXNzdWU5ODYxOTYy", "number": 4419, "title": "Scheduler rewrite with I/O event loop", "user": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 36953, "node_id": "MDU6TGFiZWwzNjk1Mw==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-runtime", "name": "A-runtime", "color": "f7e101", "default": false, "description": "Area: std's runtime and \"pre-main\" init for handling backtraces, unwinds, stack overflows"}, {"id": 37977651, "node_id": "MDU6TGFiZWwzNzk3NzY1MQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/metabug", "name": "metabug", "color": "5319e7", "default": false, "description": "Issues about issues themselves (\"bugs about bugs\")"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": {"url": "https://api.github.com/repos/rust-lang/rust/milestones/20", "html_url": "https://github.com/rust-lang/rust/milestone/20", "labels_url": "https://api.github.com/repos/rust-lang/rust/milestones/20/labels", "id": 452034, "node_id": "MDk6TWlsZXN0b25lNDUyMDM0", "number": 20, "title": "1.0", "description": "This will be the first major release of Rust, where we offer some guaranteed level of support and backwards compatibility.\r\n\r\nThe significant criteria for this release are:\r\n\r\n* Language backwards compatibility - All major features are in, and in their final form. Generally, the only new language features added after this milestone must be backwards compatible, or to fix soundness holes, though we do expect to have some leeway to make small incompatible fixes that have low impact on existing code bases.\r\n\r\n* Library stability - We have a system of measuring and ensuring the stability of API's, and a significant portion of the standard library is declared stable. Stable API's will not change. Large portions of the standard library need to be stable for 1.0, including primitive types, vectors, strings, option, numerics, collections, some I/O and concurrency.\r\n\r\n* User experience - The system is polished and the presentation is complete and professional. New users have a clear path to using and learning the system. This encompasses the web site, documentation, installation, and tooling.\r\n", "creator": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "open_issues": 0, "closed_issues": 376, "state": "closed", "created_at": "2013-10-10T18:48:33Z", "updated_at": "2016-08-28T23:13:24Z", "due_on": "2015-05-15T07:00:00Z", "closed_at": "2015-05-21T20:59:13Z"}, "comments": 5, "created_at": "2013-01-10T22:08:39Z", "updated_at": "2014-12-08T22:12:43Z", "closed_at": "2013-12-17T01:25:27Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "In order to better integrate async I/O, we are going to make it responsible for driving the scheduler event loop. I think we should take this opportunity to rewrite the scheduler in Rust, which takes us a long way toward rewriting the entire runtime in Rust and enabling freestanding Rust.\n# Links\n\n`rt` module: https://github.com/brson/rust/blob/io/src/libcore/rt/mod.rs\n`io` module: https://github.com/brson/rust/blob/io/src/libcore/rt/io/mod.rs\n`sched` module: https://github.com/brson/rust/blob/io/src/libcore/rt/sched.rs\n- August 2013 status update: https://mail.mozilla.org/pipermail/rust-dev/2013-August/005158.html\n- June 2013 status update and work items: https://mail.mozilla.org/pipermail/rust-dev/2013-May/004305.html\n- Initial pull with exposition: https://github.com/mozilla/rust/pull/5022\n- Scheduler performance update: https://mail.mozilla.org/pipermail/rust-dev/2013-May/004127.html\n- Early mailing list thread about I/O design: https://mail.mozilla.org/pipermail/rust-dev/2013-April/003746.html\n- I/O design: https://github.com/mozilla/rust/wiki/Lib-io (not updated)\n- Discussion about conditions and `Option`: http://www.reddit.com/r/rust/comments/1fod5c/io_and_condition_handlers/\n# Current work items\n\n**Scheduler**\n- [x] #3095 Add work stealing\n- [x] #4877 Write a parallel deque\n- [x] #6855 Fix design so we can have non-green thread tasks\n- [ ] SchedulerPolicy\n- [x] Add the SchedHandle type\n- [x] #6933 Add 'pinned tasks'\n- [x] #6934 Add 'task forwarding'\n- [ ] #6842 Figure out how to select on multiple events\n- [ ] #6210 Fix design to avoid unsafe aliased, mutable pointers.\n- [x] #6837 Lock-free message queue\n- [x] #6838 Lock-free sleeper list\n- [ ] #6856 Extract single-threaded coroutine features from the multithreaded scheduler\n- [ ] #6926 Monitoring task transfer and remote debugging\n- [x] #7011 Scheduler phantom types\n\n**I/O related**\n- [ ] #4248 Redesign I/O library **(more subtasks under this one)**\n- [x] #6843 I/O scheduler affinity.\n- [x] #5019 Move core::rt::uv to its own crate\n- [x] #5192 Fix ~object\n- [x] #6846 stdin/out/err\n- [x] #6850 Port libs to new I/O\n\n**Runtime porting**\n- [x] #5018 Port pipes to new scheduler\n- [x] #5021 Rewrite logging\n- [x] Add box annihilator\n- [x] #6844 Port segmented stacks\n- [x] #1226 Add no_split_stack attribute to LLVM\n- [x] #6280 Port random numbers\n- [x] #6377 `unkillable` etc.\n- [x] #6579 SharedChan\n- [x] #6587 Remove C++ scheduler\n- [x] #7666 #7667 Pipes compiler porting\n# Constraints\n- I/O is provided per-scheduler (per-thread) by libuv and schedulers are driven by the event loop.\n- I/O handles are tied to the event loop (and therefore thread/scheduler) on which they were created. They have 'scheduler affinity'. Because tasks may migrate threads and I/O handles may move between tasks, before every I/O operation a task must arrange to be running on the correct scheduler.\n- We must be able to allocate an entire scheduler (thread) exclusively to a single task (called \"1:1 scheduling\"). This is important for making blocking calls and for getting better, more predictable scheduling by relying on the OS.\n- We want to try a [work stealing](https://github.com/mozilla/rust/issues/4877) scheduling strategy. Under work stealing, tasks are scheduled greedily, as soon as they are available to run, on the thread that is trying to schedule them. Descheduled tasks are 'stolen' and executed by other threads. Work stealing appears to be widely accepted as a simple but well-performing way to schedule green threads. Should be good for data locality and require minimal locking.\n# Concepts\n- `Task` - The current state of a task. An owned type that is passed between schedulers and other runtime objects. It mostly provides task-local runtime services that are exposed through the language and core API's, e.g. local heap, logging , GC, unwinding, TLS. Unlike the previous scheduler, Task's do not need to be scheduled as coroutines.\n- `Scheduler` - Schedulers provide the mechanism for scheduling and descheduling Tasks within a single thread. The runtime may consist of multiple threads, each one with a Scheduler. A Scheduler instance is (almost) always accessible via thread-local storage.\n- `Coroutine` - The stored CPU context and the stack of a single task, executed by Schedulers. Not sure this is the best name yet. Would also like to use this for task-local coroutines that have no task state of their own.\n- `SchedHandle` - A handle for communicating to remote Schedulers. For task forwarding, probably also to wake up sleeping schedulers when new work becomes available.\n- _Task pinning_ - A pinned task is one that must always run on a specific scheduler. A task that is pinned contains a SchedHandle which, when scheduling, must be used to first send the task to the scheduler it is pinned to. This is for creating 1:1 relationships between tasks and schedulers, also for pinning to the platform thread.\n- _Task forwarding_ - Again, for 1:1 task/schedulers. Schedulers can be configured to _only_ run tasks which are pinned to them. In these cases, the Scheduler contains a SchedHandle to some other Scheduler, and when scheduling a task which is not pinned it must send the task elsewhere.\n- _I/O scheduler affinity_ - I/O objects that are tied to a scheduler must similarly contain a SchedHandle and arrange to run on the correct thread before executing.\n- _Sleeping_ - Schedulers that cannot obtain a task to schedule goes to _sleep_. A sleeping scheduler must be woken by other schedulers to resume scheduling tasks.\n# Scheduler multithreading\n\nMost of the thread synchronization in Rust should be performed in Rust tasks, using pipes. The Scheduler itself should do as little as it can.\n\nTasks are owned types. When they are running their `~Task` pointer is stored in thread local storage. When they are not running they are owned by whatever object they are blocked on. Scheduling a task means acquiring ownership of a `~Task`, then passing ownership to a `Scheduler`. Blocking a task means taking ownership of a `~Task` from thread-local storage, stuffing it somewhere else and context switching.\n\nThere are several places where schedulers need to synchronize with the outside world.\n- `WorkQueue` - work stealing deque\n- `MessageQueue` - message passing between schedulers\n- `WorkList` - The shared list of `WorkQueue`s of active schedulers and `SchedHandle`s of sleeping schedulers.\n- `SleeperList` - The shared collection (currently a stack) of sleeping schedulers.\n\nThe first is the `WorkQueue`, which is a work-stealing deque. Tasks can be pushed onto or popped from the front of the queue by a single thread. Tasks can be popped from the back of the queue (stolen) by an arbitrary number of threads. The WorkQueue is the primary mechanism for distributing tasks across threads. Importantly, under the work stealing strategy, most of the burden of distributing tasks to threads is put on those threads that otherwise are not working. The local scheduler just drops work into the (lock-free) queue and goes about its business.\n\nThe second is the `MessageQueue` through which tasks are forwarded from other schedulers. Tasks can be popped from the front of the queue by a single thread (the local Scheduler). Tasks can be pushed onto the back of the queue by an arbitrary number of threads. Sends to the MessageQueue are performed with the SchedHandle and are accompanied by a signal to wake up the Scheduler if it is asleep.\n\nThe MessageQueue is higher priority than the WorkQueue, as the former contains tasks that must specifically be acted on by the associated Scheduler, while the later contains work that can be stolen by other threads. An example of where messages should probably be checked is before spawning - some other thread can create the task, but no other thread can handle the message.\n\nThe SchedHandle also serves as a reference count keeping schedulers running. Schedulers exit when there are no remaining I/O events, no available tasks to run, and no outstanding SchedHandles.\n# Work stealing\n\nSee https://github.com/mozilla/rust/issues/3095#issuecomment-17769438\n\nTODO\n- Signalling and waking up schedulers\n\nHow do sleeping schedulers become aware that there is new work to be stolen? This needs to impose minimum synchronization on the non-sleeping schedulers. Papers seem to imply busy-waiting.\n# Risks\n- The combination of task pinning and I/O affinity could lead to tricky situations where a task is pinned to one scheduler but has I/O affinity for a different scheduler.\n- I still don't have a solution for `select`-like behavior.\n# Scheduler policy and operations\n\nTODO\n- Impact of I/O\n- Work stealing vs. work sharing\n- 1:1 scheduling\n# Alternatives\n- If I/O handles were not sendable then the logic for keeping I/O-bound tasks on the right thread would be simpler and less error-prone.\n- It may be possible to not implement task pinning if we can successfully implement tasks as threads, entirely without the scheduler, _and_ if we can live without having an event loop on the 'platform thread' (the C main thread). This wouldn't remove the need for the message queue though, because of I/O.\n", "closed_by": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/4419/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/4419/timeline", "performed_via_github_app": null, "state_reason": "completed"}