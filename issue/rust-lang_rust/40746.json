{"url": "https://api.github.com/repos/rust-lang/rust/issues/40746", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/40746/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/40746/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/40746/events", "html_url": "https://github.com/rust-lang/rust/issues/40746", "id": 216219378, "node_id": "MDU6SXNzdWUyMTYyMTkzNzg=", "number": 40746, "title": "migrate all \"incremental tasks\" to \"on-demand queries\"", "user": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 307747675, "node_id": "MDU6TGFiZWwzMDc3NDc2NzU=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-incr-comp", "name": "A-incr-comp", "color": "f7e101", "default": false, "description": "Area: Incremental compilation"}, {"id": 650846969, "node_id": "MDU6TGFiZWw2NTA4NDY5Njk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-tracking-issue", "name": "C-tracking-issue", "color": "f5f1fd", "default": false, "description": "Category: A tracking issue for an RFC or an unstable feature."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-03-22T21:51:04Z", "updated_at": "2017-09-15T18:18:42Z", "closed_at": "2017-09-15T18:18:42Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "As part of the plan to adopt the [red-green algorithm for incremental](https://github.com/rust-lang/rust-roadmap/issues/4), we want to make it so that users don't spawn tasks themselves (i.e., with `in_task` and `with_task`). Rather, they perform **queries** (via the new on-demand query mechanism). To this end, we have to migrate all of the existing tasks into queries.\r\n\r\nI've started going through the full list of tasks (derived by `rg \\.{in,with}_task\\(`) and making notes on how to migrate each one. This issue is intended to serve as a \"punchlist\" for these migrations. Note that the filenames and line-numbers cited here may have changed.\r\n\r\n# Queries that compute shared values\r\n\r\nThese are tasks that ought to be converted into new queries that yield results. Right now, these functions often return a value that winds up stored in the `tcx`. These values would be removed and replaced with maps.\r\n\r\nExample PR: https://github.com/rust-lang/rust/issues/40746\r\n\r\n- [x] `src/librustc_privacy/lib.rs:1187:    let _task = tcx.dep_graph.in_task(DepNode::Privacy);`\r\n    - this wants to become an `AccessLevels` query\r\n    - https://github.com/rust-lang/rust/issues/40746\r\n- [x] `src/librustc/middle/reachable.rs:365:    let _task = tcx.dep_graph.in_task(DepNode::Reachability);`\r\n    - query would be `ReachableSet`, yielding type `NodeSet`\r\n    - it can then request `access_levels` (see previous)\r\n    - (https://github.com/rust-lang/rust/pull/40873)\r\n- [x] `src/librustc_borrowck/borrowck/mod.rs:68:            tcx.dep_graph.with_task(DepNode::BorrowCheck(body_owner_def_id)`\r\n    - writes to `used_mut_nodes`, so probably wants to return this set \r\n    - the lint would be modified to request the borrowck query for the current function\r\n- [x] `src/librustc/middle/region.rs:1260:    let _task = map.dep_graph.in_task(DepNode::RegionResolveCrate);`\r\n    - returns a `RegionMaps`\r\n    - https://github.com/rust-lang/rust/pull/40873\r\n    - https://github.com/rust-lang/rust/issues/41057\r\n\r\nThe following tasks currently execute before a tcx is built, but they could be easily converted into\r\nqueries that are requested **after** tcx is built. The main reason they are the way they are was to\r\navoid a gratuitious refcell (but using the refcell map seems fine):\r\n\r\n- [x] `src/librustc/middle/entry.rs:60:    let _task = hir_map.dep_graph.in_task(DepNode::EntryPoint);`\r\n- [x] `src/librustc/middle/resolve_lifetime.rs:262:    let _task = hir_map.dep_graph.in_task(DepNode::ResolveLifetimes);`\r\n- [x] `src/librustc/middle/lang_items.rs:239:    let _task = map.dep_graph.in_task(DepNode::CollectLanguageItems);`\r\n\r\n# \"Always execute\" passes\r\n\r\n- [x] See https://github.com/rust-lang/rust/issues/41251.\r\n\r\n# Lints\r\n\r\nsee https://github.com/rust-lang/rust/issues/42511\r\n\r\n# Stability\r\n\r\n- The stability index is somewhat complex:\r\n  - [ ] `src/librustc/middle/stability.rs:386:        let _task = tcx.dep_graph.in_task(DepNode::StabilityIndex);`\r\n  - [ ] `src/librustc/middle/stability.rs:400:        let _task = hir_map.dep_graph.in_task(DepNode::StabilityIndex);`\r\n  - [ ] `src/librustc/middle/stability.rs:664:        let _task = tcx.dep_graph.in_task(DepNode::StabilityIndex);`\r\n- From what I can tell, what we do is to construct a `Stability::Index` for the current crate early on,\r\n  store this in the `tcx` in a `RefCell`, and then gradually grow it to cache the results from other crates\r\n- Two possible translations:  \r\n  - each crate has a stability index, and you can query for `stability_index(krate)`\r\n  - have very granular queries like `stability(def_id)`, `deprecation(def_id)`, and `deprecation_entry(def_id)` \r\n      - for the local crate, these would request the stability-index, extract the relevant data\r\n          - good example for uncached queries\r\n      - for the extern crate, we'd go to metadata and cache it in the `DepTrackingMap` or something?\r\n\r\nThis may be worth breaking into a distinct issue.\r\n\r\n# Visitor stuff\r\n\r\nThis visitor pattern should be changed. Currently, we do something like:\r\n\r\n```rust\r\ntcx.visit_all_item_likes_in_krate(DepNode::RvalueCheck, &mut rvcx.as_deep_visitor())\r\n```\r\n\r\nThis will walk all item-like and invoke a task on each one, with the id `DepNode::RvalueCheck(_)`. In many of these cases though we can just convert these into calls to `tcx.hir.krate().visit_all_item_likes(...)`. This will not spawn new tasks, but rather traverse all the items in one big task. This is actually fine most of the time, and in particular whenever the following conditions are met:\r\n\r\n- we don't want to incrementally skip any of this work (yet?)\r\n- we do not produce values that others need (which is generally true)\r\n\r\nIn other words, the compiler currently has a rather more fine-grained task structure that we necessarily want, and so we can often just flatten the structure and then come back later to make it deeper.\r\n\r\n- [x] `src/librustc/dep_graph/visit.rs:41:            let _task = self.tcx.dep_graph.in_task(task_id.clone());`\r\n- [x] `src/librustc/dep_graph/visit.rs:51:            let _task = self.tcx.dep_graph.in_task(task_id.clone());`\r\n- [x] `src/librustc/dep_graph/visit.rs:61:            let _task = self.tcx.dep_graph.in_task(task_id.clone());`\r\n\r\nThe following invocations of `visit_all_item_likes_in_crate()` can probably just be flattened:\r\n\r\n- [x] `src/librustc_passes/rvalues.rs:27:    tcx.visit_all_item_likes_in_krate(DepNode::RvalueCheck, &mut rvcx.as_deep_visitor());`\r\n- [x] `src/librustc_passes/consts.rs:461:    tcx.visit_all_item_likes_in_krate(DepNode::CheckConst,`\r\n- [x] `src/librustc/middle/intrinsicck.rs:28:    tcx.visit_all_item_likes_in_krate(DepNode::IntrinsicCheck, &mut visitor.as_deep_visitor());`\r\n- [x] `src/librustc/middle/stability.rs:427:    tcx.visit_all_item_likes_in_krate(DepNode::StabilityCheck, &mut checker.as_deep_visitor());`\r\n- [x] `src/librustc_typeck/coherence/overlap.rs:27:    tcx.visit_all_item_likes_in_krate(DepNode::CoherenceOverlapCheckSpecial, &mut overlap);`\r\n- [x] `src/librustc_typeck/coherence/orphan.rs:22:    tcx.visit_all_item_likes_in_krate(DepNode::CoherenceOrphanCheck, &mut orphan);`\r\n- [x] `src/librustc_typeck/coherence/inherent.rs:352:    tcx.visit_all_item_likes_in_krate(DepNode::CoherenceCheckImpl,`\r\n- [x] `src/librustc_typeck/coherence/inherent.rs:354:    tcx.visit_all_item_likes_in_krate(DepNode::CoherenceOverlapCheckSpecial,`\r\n- [x] `src/librustc_typeck/impl_wf_check.rs:66:    tcx.visit_all_item_likes_in_krate(DepNode::WfCheck, &mut ImplWfCheck { tcx: tcx });`\r\n- [x] `src/librustc_typeck/collect.rs:92:    tcx.visit_all_item_likes_in_krate(DepNode::CollectItem, &mut visitor.as_deep_visitor());`\r\n- [x] `src/librustc_typeck/check/mod.rs:570:        tcx.visit_all_item_likes_in_krate(DepNode::WfCheck, &mut visit.as_deep_visitor());`\r\n- [x] `src/librustc_typeck/check/mod.rs:576:        tcx.visit_all_item_likes_in_krate(DepNode::TypeckItemType,`\r\n- [x] `src/librustc_const_eval/check_match.rs:61:    tcx.visit_all_item_likes_in_krate(DepNode::MatchCheck,`\r\n\r\nThe following might require a bit more thought:\r\n\r\n- [x] `src/librustc_mir/mir_map.rs:71:        tcx.visit_all_item_likes_in_krate(DepNode::Mir, &mut GatherCtors {`\r\n- [x] `src/librustc_typeck/variance/terms.rs:112:    tcx.visit_all_item_likes_in_krate(|def_id| VarianceDepNode(def_id), &mut terms_cx);`\r\n- [x] `src/librustc_typeck/variance/constraints.rs:68:    tcx.visit_all_item_likes_in_krate(VarianceDepNode, &mut constraint_cx);`\r\n\r\n# Trait selection\r\n\r\nThe general plan here is use the **anonymous nodes** infrastructure. Sketchy details are available in [this outline](https://github.com/nikomatsakis/rustc-on-demand-incremental-design-doc/blob/master/outline.md). This is worth breaking into a distinct issue.\r\n\r\n- [ ] `src/librustc/traits/select.rs:413:        let _task = tcx.dep_graph.in_task(dep_node);`\r\n    - Trait selection. This really wants to use the \"anonymous nodes\"\r\n\r\n# Internal graph manipulation\r\n\r\nThese can be ignored for now, as they are internal to the dep-graph mechanism and so we'll update them once the other work is done.\r\n\r\n- [x] `src/librustc_incremental/persist/load.rs:439:            let _task = tcx.dep_graph.in_task(target_node);`\r\n- [x] `src/librustc_incremental/persist/load.rs:195:            tcx.dep_graph.with_task(n, (), (), create_node);`\r\n- [x] `src/librustc/dep_graph/dep_tracking_map.rs:134:        let _task = graph.in_task(M::to_dep_node(&key));`\r\n- [x] `src/librustc/dep_graph/graph.rs:110:        let _task = self.in_task(key);`\r\n- [x] `src/librustc/ty/maps.rs:271:                let _task = tcx.dep_graph.in_task(Self::to_dep_node(&key));`\r\n\r\n# Docs that will need to be rewritten or deleted\r\n\r\n- [ ] `src/librustc/dep_graph/README.md:67:You set the current task by calling `dep_graph.in_task(node)`. For example:`\r\n- [ ] `src/librustc/dep_graph/README.md:70:let _task = tcx.dep_graph.in_task(DepNode::Privacy);`\r\n- [ ] `src/librustc/dep_graph/README.md:83:let _n1 = tcx.dep_graph.in_task(DepNode::N1);`\r\n- [ ] `src/librustc/dep_graph/README.md:84:let _n2 = tcx.dep_graph.in_task(DepNode::N2);`\r\n- [ ] `src/librustc/dep_graph/README.md:102:let _n1 = tcx.dep_graph.in_task(DepNode::N1);`\r\n- [ ] `src/librustc/dep_graph/README.md:104:let _n2 = tcx.dep_graph.in_task(DepNode::N2);`\r\n- [ ] `src/librustc/dep_graph/README.md:167:    let task = tcx.dep_graph.in_task(DepNode::ItemSignature(def_id));`\r\n\r\n# Uncategorized\r\n\r\nI didn't look at these yet. =)\r\n\r\n- [x] `src/librustc_typeck/check/mod.rs:543:        tcx.dep_graph.with_task(DepNode::TypeckBodiesKrate, tcx, (), check_item_bodies_task);`\r\n- [x] `src/librustc_mir/mir_map.rs:43:    tcx.dep_graph.with_task(DepNode::MirKrate, tcx, (), build_mir_for_crate_task);`\r\n- [ ] `src/librustc_trans/base.rs:1125:        tcx.dep_graph.with_task(dep_node,`\r\n- [ ] `src/librustc_trans/base.rs:1146:        tcx.dep_graph.with_task(dep_node,`\r\n- [x] `src/librustc/ty/mod.rs:1655:        let _task = tcx.dep_graph.in_task(DepNode::SizedConstraint(self.did));`\r\n- [x] `src/librustc_typeck/lib.rs:277:    let _task = tcx.dep_graph.in_task(DepNode::CheckEntryFn);`\r\n- [x] `src/librustc/mir/transform.rs:123:            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));`\r\n- [x] `src/librustc_mir/transform/qualify_consts.rs:969:            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));`\r\n- [x] `src/librustc_mir/transform/inline.rs:65:            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));`\r\n- [x] `src/librustc_mir/transform/inline.rs:89:            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));`\r\n- [x] `src/librustc_mir/transform/inline.rs:187:                let _task = self.tcx.dep_graph.in_task(DepNode::Mir(callsite.caller));`\r\n- [x] `src/librustc_mir/transform/inline.rs:256:            let _task = self.tcx.dep_graph.in_task(DepNode::Mir(def_id));`\r\n- [x] `src/librustc_mir/transform/inline.rs:433:        let _task = self.tcx.dep_graph.in_task(DepNode::Mir(callsite.caller));`\r\n- [x] `src/librustc_driver/derive_registrar.rs:19:    let _task = hir_map.dep_graph.in_task(DepNode::PluginRegistrar);`\r\n- [x] `src/librustc_plugin/build.rs:47:    let _task = hir_map.dep_graph.in_task(DepNode::PluginRegistrar);`\r\n- [x] `src/librustc_trans/trans_item.rs:77:                let _task = ccx.tcx().dep_graph.in_task(DepNode::TransCrateItem(def_id)); // (*)`\r\n- [x] `src/librustc_trans/trans_item.rs:93:                let _task = ccx.tcx().dep_graph.in_task(`\r\n- [x] `src/librustc_trans/base.rs:1034:    let _task = tcx.dep_graph.in_task(DepNode::TransCrate);`\r\n- [x] `src/librustc_trans/back/link.rs:199:    let _task = sess.dep_graph.in_task(DepNode::LinkBinary);`\r\n- [x] `src/librustc_metadata/index_builder.rs:121:        let _task = self.tcx.dep_graph.in_task(DepNode::MetaData(id));`\r\n\r\n", "closed_by": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/40746/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/40746/timeline", "performed_via_github_app": null, "state_reason": "completed"}