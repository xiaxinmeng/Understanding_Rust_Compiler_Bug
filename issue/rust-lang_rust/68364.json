{"url": "https://api.github.com/repos/rust-lang/rust/issues/68364", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/68364/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/68364/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/68364/events", "html_url": "https://github.com/rust-lang/rust/issues/68364", "id": 551926836, "node_id": "MDU6SXNzdWU1NTE5MjY4MzY=", "number": 68364, "title": "Semantics of MIR assignments, around aliasing, ordering, and primitives.", "user": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 256133398, "node_id": "MDU6TGFiZWwyNTYxMzMzOTg=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-mir", "name": "A-mir", "color": "f7e101", "default": false, "description": "Area: Mid-level IR (MIR) - https://blog.rust-lang.org/2016/04/19/MIR.html"}, {"id": 1244499056, "node_id": "MDU6TGFiZWwxMjQ0NDk5MDU2", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-miri", "name": "A-miri", "color": "f7e101", "default": false, "description": "Area: The miri tool"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 29, "created_at": "2020-01-19T14:04:34Z", "updated_at": "2022-04-23T02:28:52Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "In today's MIR, an indirect assignment like `*p = *q;` is similar to, but not exactly the same as:\r\n```rust\r\ntmp = *q;\r\n*p = tmp;\r\n```\r\nThe differences are:\r\n* performance: they only produce the same codegen for primitives\r\n  * this is assuming `tmp` isn't used elsewhere, allowing codegen to treat it like an SSA value, resulting in `store(p, load(q))`, which is also what `*p = *q` codegens to\r\n  * for non-primitives, the amount of data being copied doubles, as `tmp` must be in memory\r\n* correctness: only `*p = *q;` is UB (AFAIK) if `p..p+size` overlaps `q..q+size`\r\n  * this also likely only affects non-primitives, which have to copy data in memory, but we could decide to ignore the type and always make it UB when they overlap\r\n\r\n<hr/>\r\n\r\nFor the purposes of this discussion, a primitive is:\r\n* scalar (`bool`, `char`, integer, float, or pointer/reference)\r\n* vector (SIMD-enabled array of scalars)\r\n\r\nScalar pairs likely also should/need to be included, due to how easy they are to support in any code that already handles scalars, and also due to their use in wide pointers/references.\r\n\r\n<hr/>\r\n\r\nWhat's interesting about primitives, though, is that some kinds of `Rvalue`s (the RHS of the assignment) *always* produce primitive values, because they're primitive operations.\r\n\r\nThe `Rvalue` variants which are always primitive, today, are:\r\n* `Ref` (`&T` / `&mut T` - may become dependent on custom DSTs in the future)\r\n* `AddressOf` (`*const T` / `*mut T` - may become dependent on custom DSTs in the future)\r\n* `Len` (`usize`)\r\n* `Cast`, other than unsizing (scalar)\r\n* `BinaryOp`, `UnaryOp` (scalar, or maybe also vector)\r\n* `CheckedBinaryOp` (pair of integer and `bool` - only if we consider scalar pairs to be primitive)\r\n* `NullaryOp(SizeOf)` (`usize`)\r\n* `NullaryOp(Box)` (`Box<T>`)\r\n* `Discriminant` (integer)\r\n\r\nWhich leaves these variants as potentially relying on memory operations to write the result:\r\n* `Use` (any type, one copy)\r\n* `Repeat` (`[T; N]`, `N` copies)\r\n* `Cast`, specifically unsizing (any type implementing `CoerceUnsized`, per-field copies)\r\n* `Aggregate` (any ADT, per-field copies)\r\n\r\nIf we want to remain conservative, we could ignore types for the latter, and just assume that the destination of the assignment cannot overlap any memory read in the `Operand`s of the `Rvalue`.\r\n\r\nWe could even cement the distinction by moving the always-primitive operations into a new `PrimOp` enum, and/or move the other `Rvalue`s to their own statements (e.g. introduce `Copy(*p, *q)`), but that's more aesthetic than anything for the time being.\r\n\r\nAt the very least, we should probably document these differences, and make sure that `miri` only allows overlaps in the cases we don't consider UB (either abstractly, or due to our choice of codegen).\r\n\r\n<hr/>\r\n\r\nAnother interesting aspect of the always-primitive ops is that they're \"pure functions\" of their operands (other than `NullaryOp(Box)`, I suppose, but that could be replaced with a call to a lang item returning a `Box<MaybeUninit<T>>`, instead).\r\n\r\nThis means that if we wanted to, we could replace some of the intermediary locals with an `PrimOp` DAG, a bit like SSA but without \u03c6 (`phi`) nodes or a strict instruction stream.\r\nAll of the necessary ordering would still happen at the statement level (so this is nowhere near as complex as VSDG), but we might see some benefits in scalar-heavy code.\r\n\r\n<hr/>\r\n\r\nAsides aside, cc @RalfJung @rust-lang/wg-mir-opt\r\n\r\n---\r\n\r\nThe [latest proposal is here](https://github.com/rust-lang/rust/issues/68364#issuecomment-614862820)", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/68364/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/68364/timeline", "performed_via_github_app": null, "state_reason": null}