{"url": "https://api.github.com/repos/rust-lang/rust/issues/67179", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/67179/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/67179/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/67179/events", "html_url": "https://github.com/rust-lang/rust/issues/67179", "id": 535155453, "node_id": "MDU6SXNzdWU1MzUxNTU0NTM=", "number": 67179, "title": "Invalid free memory while dropping", "user": {"login": "sidgilles", "id": 50890155, "node_id": "MDQ6VXNlcjUwODkwMTU1", "avatar_url": "https://avatars.githubusercontent.com/u/50890155?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sidgilles", "html_url": "https://github.com/sidgilles", "followers_url": "https://api.github.com/users/sidgilles/followers", "following_url": "https://api.github.com/users/sidgilles/following{/other_user}", "gists_url": "https://api.github.com/users/sidgilles/gists{/gist_id}", "starred_url": "https://api.github.com/users/sidgilles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sidgilles/subscriptions", "organizations_url": "https://api.github.com/users/sidgilles/orgs", "repos_url": "https://api.github.com/users/sidgilles/repos", "events_url": "https://api.github.com/users/sidgilles/events{/privacy}", "received_events_url": "https://api.github.com/users/sidgilles/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2019-12-09T19:00:18Z", "updated_at": "2019-12-31T15:13:33Z", "closed_at": "2019-12-31T11:38:11Z", "author_association": "NONE", "active_lock_reason": null, "body": "**-------------------**\r\n**Edit**\r\n\r\nI guess this bug will not get fixed by any hook, only by fixing it in the library. Or, at least, i did not find a workaround myself. The problem lies in the way BTreeMap is coded. See the link.\r\nhttps://github.com/rust-lang/rust/blob/a605441e049f0b6d5f7715b94b8ac4662fd7fcf6/src/liballoc/collections/btree/node.rs#L130\r\n\r\nThe static reference is embedded in each binary after compilation and linking process. So, i guess, the \"static EMPTY_ROOT_NODE\" in main exe and in the library refers to different location. See this output below.\r\n\r\n\r\n```\r\n$ nm /home/sidney/Developpement/test_bug/target/debug/libclib.so | grep \"EMPTY_ROOT_NODE\"\r\n000000000002e780 r _ZN5alloc11collections5btree4node15EMPTY_ROOT_NODE17h0caf86d227d3ce02E\r\n$ nm /home/sidney/Developpement/test_bug/target/debug/libclib.so | rustfilt | grep \"2e780\"\r\n000000000002e780 r alloc::collections::btree::node::EMPTY_ROOT_NODE\r\n\r\n$ nm /home/sidney/Developpement/test_bug/target/debug/main | grep \"EMPTY_ROOT_NODE\"\r\n0000000000039ff8 R _ZN5alloc11collections5btree4node15EMPTY_ROOT_NODE17h0caf86d227d3ce02E\r\n$ nm /home/sidney/Developpement/test_bug/target/debug/main | rustfilt | grep \"39ff8\"\r\n0000000000039ff8 R alloc::collections::btree::node::EMPTY_ROOT_NODE\r\n\r\n```\r\n\r\n\r\nPassing a BTreeMap created in main and passing it to Foo led to a bad behavior because the static reference do not point to the same memory location while dropping. I might be wrong but it make sense to me according to the previous output.\r\n\r\n\r\n\r\n**-------------------**\r\n\r\n\r\nHello,\r\n\r\nBasically, my program is dynamically loading a library (cdylib) and retrieve a factory object (Factory design pattern). No problem here.\r\nThen, on demand, a new object with the Foo trait is created. Again, nothing wrong with that. However, moving an object created in the main program to the Foo object instance, lead to an invalid free memory, according to valgrind, when dropping the Foo object.\r\n\r\n**Edit** : This also exist on stable build --> rustc 1.39.0 (2019-11-04)\r\n**Edit** : Trying to change [\"cdylib\"] to [\"dylib\"] lead to a strange behavior : the library is loaded via 'cargo run' but no more via a regular exec by the shell (thus also by valgrind). To let you know that i did not found an understandable workaround.\r\n\r\n\r\n\r\n```\r\n$ rustc --version\r\nrustc 1.41.0-nightly (59947fcae 2019-12-08)\r\n\r\n$ cargo run\r\n    Finished dev [unoptimized + debuginfo] target(s) in 1.29s\r\n     Running `target/debug/main`\r\n--on_plugin_load---\r\n--foo---\r\ndropping Foo object\r\ndropping Drv2\r\nmunmap_chunk(): invalid pointer\r\nAbandon (core dumped)\r\n\r\n\r\n$ valgrind /home/sidney/Developpement/test_bug/target/debug/main\r\n==19143== Memcheck, a memory error detector\r\n==19143== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==19143== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info\r\n==19143== Command: /home/sidney/Developpement/test_bug/target/debug/main\r\n==19143== \r\n--on_plugin_load---\r\n--foo---\r\ndropping Foo object\r\ndropping Drv2\r\n==19143== Invalid free() / delete / delete[] / realloc()\r\n==19143==    at 0x483897B: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==19143==    by 0x4EA64F2: alloc::alloc::dealloc (alloc.rs:106)\r\n==19143==    by 0x4EA63A8: <alloc::alloc::Global as core::alloc::Alloc>::dealloc (alloc.rs:177)\r\n==19143==    by 0x4EA3785: alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Owned,K,V,alloc::collections::btree::node::marker::Leaf>::deallocate_and_ascend (node.rs:504)\r\n==19143==    by 0x4EA1C5B: <alloc::collections::btree::map::IntoIter<K,V> as core::ops::drop::Drop>::drop (map.rs:1431)\r\n==19143==    by 0x4EA611D: core::ptr::real_drop_in_place (mod.rs:181)\r\n==19143==    by 0x4EA2225: core::mem::drop (mod.rs:749)\r\n==19143==    by 0x4EA1BCE: <alloc::collections::btree::map::BTreeMap<K,V> as core::ops::drop::Drop>::drop (map.rs:132)\r\n==19143==    by 0x4EA60BD: core::ptr::real_drop_in_place (mod.rs:181)\r\n==19143==    by 0x4EA615D: core::ptr::real_drop_in_place (mod.rs:181)\r\n==19143==    by 0x111D07: core::ptr::real_drop_in_place (mod.rs:181)\r\n==19143==    by 0x112ED7: core::mem::drop (mod.rs:749)\r\n==19143==  Address 0x13ef38 is 0 bytes inside data symbol \"_ZN5alloc11collections5btree4node15EMPTY_ROOT_NODE17h0caf86d227d3ce02E\"\r\n==19143== \r\ndrop Registry #1\r\n==19143== \r\n==19143== HEAP SUMMARY:\r\n==19143==     in use at exit: 3,116 bytes in 12 blocks\r\n==19143==   total heap usage: 40 allocs, 29 frees, 6,939 bytes allocated\r\n==19143== \r\n==19143== LEAK SUMMARY:\r\n==19143==    definitely lost: 0 bytes in 0 blocks\r\n==19143==    indirectly lost: 0 bytes in 0 blocks\r\n==19143==      possibly lost: 0 bytes in 0 blocks\r\n==19143==    still reachable: 3,116 bytes in 12 blocks\r\n==19143==         suppressed: 0 bytes in 0 blocks\r\n==19143== Rerun with --leak-check=full to see details of leaked memory\r\n==19143== \r\n==19143== For counts of detected and suppressed errors, rerun with: -v\r\n==19143== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\r\n\r\n\r\n\r\n```\r\n\r\nHere the code:\r\n\r\nCommon traits definition - 'common' crate\r\n```rust\r\nuse std::any::Any;\r\nuse std::collections::BTreeMap;\r\n\r\npub trait Plugin: Any + Send + Sync + std::fmt::Debug {\r\n    fn new_subplugin_trait(&self, bmap : BTreeMap<usize, usize>) -> Box<dyn Foo>;\r\n    fn on_plugin_load(&self);\r\n}\r\n\r\npub trait Foo: Any + Send + Sync + std::fmt::Debug {\r\n    fn foo(&self);\r\n}\r\n\r\n```\r\n\r\nCdynlib... Rust book was around...\r\n```rust\r\nuse common::*;\r\n\r\n\r\nuse std::collections::BTreeMap;\r\n//use libloading::{Library, Symbol};\r\n\r\n\r\n#[macro_export]\r\nmacro_rules! declare_plugin {\r\n    ($plugin_type:ty, $constructor:path) => {\r\n        #[no_mangle]\r\n        pub extern \"C\" fn _plugin_create() -> *mut dyn $crate::Plugin {\r\n            // make sure the constructor is the correct type.\r\n            let constructor: fn() -> $plugin_type = $constructor;\r\n\r\n            let object = constructor();\r\n            //println!(\"Plugin : object = {:?}\", object);\r\n            let boxed: Box<dyn $crate::Plugin> = Box::new(object);\r\n            //println!(\"Plugin : boxed = {:?}\", boxed);\r\n            let raw_pointer = Box::into_raw(boxed);\r\n            //println!(\"Plugin : raw_pointer = {:?}\", raw_pointer);\r\n            return raw_pointer;\r\n        }\r\n    };\r\n}\r\n\r\n\r\n//--------\r\n\r\n#[derive(Debug)]\r\npub(crate) struct Drv2 {\r\n    bus_driver : BTreeMap<usize, usize>,\r\n}\r\nimpl Drv2{\r\n    pub fn new(bmap : BTreeMap<usize, usize>,) -> Self {\r\n        Self {\r\n            bus_driver : bmap,\r\n        }\r\n    }\r\n}\r\nimpl Foo for Drv2 {\r\n\r\n    fn foo(&self) {\r\n         println!(\"--foo---\");\r\n    }\r\n}\r\nimpl Drop for Drv2 { // mandatory. if not, segfault occurs\r\n    fn drop(&mut self) {\r\n        println!(\"dropping Drv2\");\r\n    }\r\n}\r\n\r\n\r\n// ------\r\n\r\n#[derive(Debug)]\r\npub(crate) struct Drv {\r\n    bus_driver : BTreeMap<usize, usize>,\r\n}\r\nimpl Drv{\r\n    pub fn new() -> Self {\r\n        Self {\r\n            bus_driver : BTreeMap::<usize, usize>::new(),\r\n        }\r\n    }\r\n}\r\nimpl Plugin for Drv {\r\n\r\n    fn new_subplugin_trait(&self, bmap : BTreeMap<usize, usize>) -> Box<dyn Foo> {\r\n        return Box::new(Drv2::new(bmap));\r\n    }\r\n\r\n    fn on_plugin_load(&self) {\r\n        println!(\"--on_plugin_load---\");\r\n    }\r\n\r\n}\r\n\r\n\r\ndeclare_plugin!(Drv, Drv::new);\r\n\r\n```\r\ncorresponding TOML\r\n\r\n```toml\r\n[dependencies]\r\ncommon = { path = \"../common\" } # from a path in the local filesystem\r\n[lib]\r\ncrate-type = [\"cdylib\"]\r\n```\r\n\r\nAnd finally, main program here\r\n```rust\r\nuse libloading::{Library, Symbol};\r\nuse common::Plugin;\r\nuse std::collections::BTreeMap;\r\n\r\n\r\n\r\n// This Registry class maintain alive and in scope the library import and thus -- important -- the memory space allocated for it.\r\n// Loosing scope will desallocate this memory. Uses of each memory object created via this library will lead to segmentation fault.\r\n\r\n#[derive(Debug)]\r\nstruct Entry {\r\n    name : String,\r\n    lib : libloading::Library,\r\n    factory : Box<dyn Plugin>,\r\n}\r\n\r\n#[derive(Debug)]\r\npub struct Registry {\r\n    factory_list : Vec<Entry>,\r\n}\r\n\r\n\r\nimpl Registry {\r\n\r\n    pub fn new() -> Self {\r\n        Self {\r\n            factory_list : Vec::new(),\r\n        }\r\n\r\n    }\r\n\r\n    pub fn load_from_folder(&mut self, path_str : String) -> () {\r\n\r\n        unsafe {\r\n\r\n            //load and reference the library\r\n            if let libloading::Result::Ok(lib) = libloading::Library::new(&path_str) {\r\n                if let libloading::Result::Ok(constructor) = lib.get::<libloading::Symbol<unsafe fn() -> *mut dyn Plugin>>(b\"_plugin_create\") {\r\n\r\n                    //println!(\"Plugin : constructor = {:?}\", constructor);\r\n                    let boxed_raw = constructor();\r\n                    //println!(\"Plugin : boxed_raw = {:?}\", boxed_raw);\r\n\r\n                    let factory = Box::<dyn Plugin>::from_raw(boxed_raw);\r\n                    //println!(\"Plugin : boxed_any_trait = {:?}\", factory);\r\n\r\n                    factory.on_plugin_load();\r\n                    self.factory_list.push( Entry {\r\n                        name : path_str,\r\n                        lib : lib,\r\n                        factory : factory,\r\n                    });\r\n\r\n                    //self.factory_list.push(boxed_any_trait);\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\nimpl Drop for Registry { // mandatory. if not, segfault occurs\r\n    fn drop(&mut self) {\r\n        println!(\"drop Registry #1\");\r\n        for Entry {\r\n                name,\r\n                lib,\r\n                factory,\r\n            } in self.factory_list.drain(..) {\r\n\r\n            //factory.on_plugin_unload();\r\n            std::mem::drop(factory);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\nfn main() {\r\n\r\n    let mut a  = Registry::new();\r\n    //println!(\"{:#?}\", a);\r\n    a.load_from_folder(\"/home/sidney/Developpement/test_bug/target/debug/libclib.so\".to_string());\r\n    //println!(\"{:#?}\", a);\r\n    let mut b = a.factory_list[0].factory.new_subplugin_trait(BTreeMap::<usize, usize>::new());\r\n    //println!(\"{:#?}\", b);\r\n    b.foo();\r\n    println!(\"dropping Foo object\");\r\n    std::mem::drop(b);\r\n\r\n}\r\n```\r\nand corresponding TOML\r\n```toml\r\n[dependencies]\r\ncommon = { path = \"../common\" } # from a path in the local filesystem\r\nlibloading = \"0.5.2\"\r\n```\r\n\r\n\r\nNote : i had an issue with loadlibrary because of the created Symbol lifetime. Here is another matter.\r\n\r\nFinal note : this bug does not appear on zero-sized type (replacing BTreeMap by ZST_Object {} in signatures ).\r\n\r\n\r\n\r\n\r\n\r\n\r\n", "closed_by": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/67179/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/67179/timeline", "performed_via_github_app": null, "state_reason": "completed"}