{"url": "https://api.github.com/repos/rust-lang/rust/issues/96351", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/96351/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/96351/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/96351/events", "html_url": "https://github.com/rust-lang/rust/issues/96351", "id": 1213467530, "node_id": "I_kwDOAAsO6M5IVAuK", "number": 96351, "title": "The iterator documentation lacks guidance for implementers of iterators with side-effects", "user": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 431251592, "node_id": "MDU6TGFiZWw0MzEyNTE1OTI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-docs", "name": "A-docs", "color": "f7e101", "default": false, "description": "Area: documentation for any part of the project, including the compiler, standard library, and tools"}, {"id": 889209675, "node_id": "MDU6TGFiZWw4ODkyMDk2NzU=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-iterators", "name": "A-iterators", "color": "f7e101", "default": false, "description": "Area: Iterators"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2022-04-23T22:21:55Z", "updated_at": "2022-04-24T17:28:01Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "Today the standard library implementation of the defaulted iterator methods as well as various transformers are developed under an assumption that there are basically two kinds of valid iterators:\r\n\r\n1. Side-effect free iterators (these are very nice and easy to optimize :partying_face: :tada:);\r\n2. Iterators with side effects where all the side effects will be observed no matter how you combine it (e.g. `(0..10).map(|_| println!(\"banana\")).skip(10).next()` will still print out a :banana: 10 times.\r\n\r\nHowever, nothing in the documentation we have appears to inform of this. And so people implementing the `Iterator` trait may be inclined to optimize their side-effect-ful Iterators to omit some side effects when they deem it possible. I was presented \u201cdebug logs\u201d as an example of what definitely doesn't _feel_ like a side-effect even though it definitely is, but even things like database or filesystem access could be suspect here.\r\n\r\nSo, consider the following Up To No Good code as an example:\r\n\r\n```rust\r\nstruct MyIterator {\r\n    current: usize,\r\n}\r\n\r\nimpl Iterator for MyIterator {\r\n    type Item = usize;\r\n    fn next(&mut self) -> Option<usize> {\r\n        self.nth(0)\r\n    }\r\n    \r\n    fn nth(&mut self, count: usize) -> Option<usize> {\r\n        let result = self.current + count;\r\n        self.current = result + 1;\r\n        println!(\"will yield {}\", result);\r\n        Some(result)\r\n    }\r\n}\r\n```\r\n\r\nSeems very justified in isolation. However in the presence of such an implementation we also start leaking implementation details of the standard library left and right:\r\n\r\n```rust\r\nfn main() {\r\n    let mut iterator = MyIterator { current: 0 };\r\n    iterator.nth(10);\r\n    iterator.nth(10);\r\n    let mut skipped_once = MyIterator { current: 0 }.skip(10);\r\n    skipped_once.next();\r\n    let mut skipped_twice = MyIterator { current: 0 }.skip(10).skip(10);\r\n    skipped_twice.next();\r\n}\r\n```\r\n\r\nprints out:\r\n\r\n```\r\nwill yield 10\r\nwill yield 21\r\nwill yield 9\r\nwill yield 10\r\nwill yield 9\r\nwill yield 19\r\nwill yield 20\r\n```\r\n\r\nThe intuition I have as somebody working on Rust is that implementing `skip(10)` by calling `next()` 10 times, or by calling `nth` only once for each `next()` ought to be a valid implementation. However any change to implementation of `skip` suddenly becomes a potentially breaking change in presence of such an iterator implementation.\r\n\r\nAll that is to say that we definitely should document what a correct implementation of the overriden default `Iterator` methods should look like and what are the consequences of not following the guidance.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/96351/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/96351/timeline", "performed_via_github_app": null, "state_reason": null}