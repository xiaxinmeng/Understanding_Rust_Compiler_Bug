{"url": "https://api.github.com/repos/rust-lang/rust/issues/56292", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/56292/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/56292/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/56292/events", "html_url": "https://github.com/rust-lang/rust/issues/56292", "id": 384941871, "node_id": "MDU6SXNzdWUzODQ5NDE4NzE=", "number": 56292, "title": "Stabilize memory-releated `std::arch::wasm32` intrinsics", "user": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 919710011, "node_id": "MDU6TGFiZWw5MTk3MTAwMTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/disposition-merge", "name": "disposition-merge", "color": "008800", "default": false, "description": "This issue / PR is in PFCP or FCP with a disposition to merge it."}, {"id": 923282386, "node_id": "MDU6TGFiZWw5MjMyODIzODY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/finished-final-comment-period", "name": "finished-final-comment-period", "color": "f9e189", "default": false, "description": "The final comment period is finished for this PR / Issue."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 44, "created_at": "2018-11-27T19:04:39Z", "updated_at": "2018-12-15T19:11:50Z", "closed_at": "2018-12-15T19:11:50Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "This is a tracking issue where I'm going to propose that we stabilize two functions in the standard library:\r\n\r\n* [`std::arch::wasm32::memory_size`](https://doc.rust-lang.org/nightly/core/arch/wasm32/memory/fn.size.html)\r\n* [`std::arch::wasm32::memory_grow`](https://doc.rust-lang.org/nightly/core/arch/wasm32/memory/fn.grow.html)\r\n\r\nThese intrinsics are currently existing as `memory::size` and `memory::grow`, but I'm going to propose here that we don't do that and flatten them in the `wasm32` module. As a reference, their signatures are:\r\n\r\n```rust\r\nfn memory_size(memory_index: u32) -> usize;\r\nfn memory_grow(memory_index: u32, delta_pages: usize) -> isize;\r\n```\r\n\r\n## Semantics\r\n\r\nThese two intrinsics represent instructions stabilized in the WebAssembly specification.\r\n\r\nThe [`memory.size`](http://webassembly.github.io/spec/core/exec/instructions.html#exec-memory-size) instruction will return the current size, in WebAssembly pages, of the specified memory index. Currently [only index 0 is allowed](https://github.com/rust-lang-nursery/stdsimd/blob/f97eda0bf8a8ea698b4ec48185c2f550eb37f0bb/coresimd/wasm32/memory.rs#L28-L30), the index is [required to be a constant value](https://github.com/rust-lang-nursery/stdsimd/blob/f97eda0bf8a8ea698b4ec48185c2f550eb37f0bb/coresimd/wasm32/memory.rs#L26), and the return value is an `usize` value. Note that `usize` is used instead of the spec's `i32` for two reasons: this is more forward compatible with a possible wasm64 architecture and the return value is always an unsigned number.\r\n\r\nThe [`memory.grow`](http://webassembly.github.io/spec/core/exec/instructions.html#exec-memory-grow) instruction will grow the memory index specified by the given number of pages. The old size of memory, in pages, is returned. If the grow operation fails, then -1 is returned. LIke `memory_size`, the memory index is currently [required to be 0](https://github.com/rust-lang-nursery/stdsimd/blob/f97eda0bf8a8ea698b4ec48185c2f550eb37f0bb/coresimd/wasm32/memory.rs#L51-L53) and must be a [constant value](https://github.com/rust-lang-nursery/stdsimd/blob/f97eda0bf8a8ea698b4ec48185c2f550eb37f0bb/coresimd/wasm32/memory.rs#L49). The `delta` may be a runtime value, however.\r\n\r\nThe [binary encoding](http://webassembly.github.io/spec/core/binary/instructions.html#memory-instructions) of these two instructions each have a reserved zero byte which is intended to be used to specify a different nonzero memory index in the future. As a recap, each WebAssembly module may have multiple \"memory\" instances, each assigned a unique index starting from zero. In the WebAssembly MVP, however, only at most one memory can be assigned with each wasm module, always located at index 0. (the memory may be omitted as well)\r\n\r\nWhile the `memory` argument is currently required to be zero, it's expected that future versions of WebAssembly will no longer have this requirement and any `u32` value can be specified. It's also worth noting that the zero byte in the encoding of `memory.size` and `memory.grow` may not only be exclusively used for new indices. Current proposals to WebAssembly have repurposed required zero bytes as *flags* fields in addition to specified more than nonzero indices. While I'm not aware of any proposal to do so, it may be possible that a future feature to WebAssembly will have more than just a memory index argument to these instructions.\r\n\r\n## Stabilization in Rust\r\n\r\nStabilization of these intrinsics would be a significant step for Rust on multiple axes:\r\n\r\n* Primarily these would be the first non-x86 intrinsics stabilized. This means it's the first architecture to have a stable `std::arch` module which isn't x86/x86_64. \r\n* Unlike x86 intrinsics, there is no prior art for how these intrinsics should be stabilized. Unlike x86/x86_64 the \"vendor\" (the WebAssembly specification) isn't giving us a document of functions with signatures.\r\n\r\nStabilization here will be paving a path forward for future stabilization of WebAssembly intrinsics, so it's good to consider conventions! It's unclear if the WebAssembly specification will, if ever, provide a document like Intel does for intrinsics with function names and function signatures for other languages to provide.\r\n\r\nWe've had [some discussion](https://github.com/rust-lang-nursery/stdsimd/issues/562) on the naming of wasm intrinsics. We'd like to ensure that we match Clang (like we do for x86/x86_64), but Clang doesn't currently (AFAIK) have a naming convention beyond the `__builtin_*` internal defines it has today.\r\n\r\nWhat I'm proposing here is basically a convention of:\r\n\r\n* We provide intrinsics for instructions not natively expressable in Rust. For example we don't give an `i32.add` intrinsic function as it's just `a + b`.\r\n* Intrinsic signatures match the effective signature of the instruction, to the best it can. Above the `memory.grow` and `memory.size` intrinsics are fairly simple. \r\n* Intrinsic names match the name of the wasm intstructions, with non-rust-identifier characters mapped to an underscore. \r\n\r\nThe thinking behind these set of conventions it that it should be very easy to figure out what each intrinsic does, just like it is for Intel. The Rust documentation would always link to the WebAssembly specification for stabilized intrinsics.\r\n\r\nAdditionally we won't have any sort of automatic verification of WebAssembly intrinsics just yet like we do for x86 intrinsics in the stdsimd repository. There's so few WebAssembly intrinsics it's thought that we can simply manually verify each intrinsic.\r\n\r\n## TODO items before stabilization is finalized\r\n\r\n* [x] FCP (this issue)\r\n* [x] Rename the intrinsics (if that's decided on)\r\n* [x] Fix the \"This is supported on MIPS only\" message in documentation\r\n* [x] Update documentation to link to WebAssembly specification\r\n* [x] [maybe flag functions as safe](https://github.com/rust-lang/rust/issues/56292#issuecomment-442191319)\r\n* [x] Update documentation on behavior with nonzero indexes\r\n* [x] Document the page size on these intrinsics.", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/56292/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/56292/timeline", "performed_via_github_app": null, "state_reason": "completed"}