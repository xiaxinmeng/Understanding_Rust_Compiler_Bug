{"url": "https://api.github.com/repos/rust-lang/rust/issues/42341", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/42341/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/42341/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/42341/events", "html_url": "https://github.com/rust-lang/rust/issues/42341", "id": 232718652, "node_id": "MDU6SXNzdWUyMzI3MTg2NTI=", "number": 42341, "title": "introduce region-clauses into the `ParamEnv`, use to replace the `body_id`", "user": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37234, "node_id": "MDU6TGFiZWwzNzIzNA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-cleanup", "name": "C-cleanup", "color": "f5f1fd", "default": false, "description": "Category: PRs that clean code up or issues documenting cleanup."}, {"id": 13836860, "node_id": "MDU6TGFiZWwxMzgzNjg2MA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-traits", "name": "A-traits", "color": "f7e101", "default": false, "description": "Area: Trait system"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-05-31T22:44:33Z", "updated_at": "2017-07-27T22:36:59Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "When we are in a closure body, we often gain additional implied \"outlives\" relation based on the types of the closure arguments. Consider this:\r\n\r\n```rust\r\nfoo(|x: &T| ...)\r\n```\r\n\r\nHere, the type of `x` will be `&'0 T` for some anonymous region `'0`. Within the function body, then, we can conclude that `T: '0`. We currently handle this through a variety of messy schemes. As part of [chalkificaton](https://github.com/rust-lang/rust-roadmap/issues/8), I would like to consolidate this into a cleaner, more uniform handling of environments and universes. This issue lays out an \"evolving\" plan for doing that.\r\n\r\n### Current handling\r\n\r\nCurrently, for every trait obligation that we have to prove (e.g., `T: Debug`), we have an `ObligationCause`  -- this is *primarily* used for debugging, in that it specifies *why* we have to prove this thing. However, this type also carries a `body_id` identifying the closure it came from. When we wind up having to prove an outlives relationship like `Foo: 'a`, we record this in the fulfillment context (a kind of record of things we have yet to prove), and we track the `body_id` where the obligation was incurred. Then, after type-checking, in the region-checking phase, we walk down the AST and figure out -- for each closure body -- what outlives facts we know at that point in time.  We then pull out the list of outlives obligations from the fulfillment cx for a given body-id and try to prove them, using those facts. This whole process is complex and fragile.\r\n\r\n### Roughly how I want it to work\r\n\r\nWe now have the ability to have every obligation have its own, distinct environment (we used to have just one ambient environment). This means that instead of having this ad-hoc `body_id` field, we can just extend the environment when we enter into a closure body. So, for example, when type-checking the body of the closure in the beginning, our environment would be extended with a `T: 'a` outlives clause. We can do this right away, just as soon as we start type-checking the closure.  This environment is automatically propagated to sub-goals, so when we wind up with some outlives obligations that we have to prove, they will have `T: 'a` in their list of clauses (i.e., the facts that they can draw upon). This means that regionck doesn't have to do anything \"special\" -- rather, the input to regionck will change from being a flat list of obligations, to obligations that can carry more environmental information.\r\n\r\nThere is one complication here:\r\n\r\n- when we first start type-checking closures, we often have not yet inferred the types of the arguments yet. This is partly why the current scheme defers everything until regionck. But this is ok, we can still insert \"outlives\" obligations that contain inference variables. We'll give them their final values before we go and solve things.\r\n\r\n### Actual steps\r\n\r\nOK, I ran out of time for this part. =) ", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/42341/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/42341/timeline", "performed_via_github_app": null, "state_reason": null}