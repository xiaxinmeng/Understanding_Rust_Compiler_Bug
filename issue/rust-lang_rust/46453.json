{"url": "https://api.github.com/repos/rust-lang/rust/issues/46453", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/46453/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/46453/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/46453/events", "html_url": "https://github.com/rust-lang/rust/issues/46453", "id": 278718030, "node_id": "MDU6SXNzdWUyNzg3MTgwMzA=", "number": 46453, "title": "DWARF: linkage_name does not include hash, does not match any symbol", "user": {"login": "m4b", "id": 1920204, "node_id": "MDQ6VXNlcjE5MjAyMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1920204?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m4b", "html_url": "https://github.com/m4b", "followers_url": "https://api.github.com/users/m4b/followers", "following_url": "https://api.github.com/users/m4b/following{/other_user}", "gists_url": "https://api.github.com/users/m4b/gists{/gist_id}", "starred_url": "https://api.github.com/users/m4b/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m4b/subscriptions", "organizations_url": "https://api.github.com/users/m4b/orgs", "repos_url": "https://api.github.com/users/m4b/repos", "events_url": "https://api.github.com/users/m4b/events{/privacy}", "received_events_url": "https://api.github.com/users/m4b/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37547, "node_id": "MDU6TGFiZWwzNzU0Nw==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-linkage", "name": "A-linkage", "color": "f7e101", "default": false, "description": "Area: linking into static, shared libraries and binaries"}, {"id": 203130, "node_id": "MDU6TGFiZWwyMDMxMzA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-debuginfo", "name": "A-debuginfo", "color": "f7e101", "default": false, "description": "Area: Debugging information in compiled programs (DWARF, PDB, etc.)"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 13, "created_at": "2017-12-02T21:10:12Z", "updated_at": "2022-05-16T14:17:01Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "So this is going to be a long issue, but the gist is, to put it semi dramatically, is that I think that all of rust debugging info might be slightly broken, but workable enough for say gdb, that it has gone unnoticed. At the very least, I think:\r\n\r\n1. no_mangle statics are definitely broken https://github.com/rust-lang/rust/issues/33172\r\n2. there are some major discrepancies between rust and c++ dwarf output that should be resolved, w.r.t. the DWARF `linkage_name`\r\n\r\n/cc @philipc @fitzgen @tromey @rkruppe @michaelwoerister\r\n\r\n# Discussion\r\n\r\nI've created some test files in rust and c++, and also grepped the binaries for dwarf dies and also symbol table values, which I explain below.\r\n\r\n## Repro / Test files\r\n\r\n```rust\r\n#[derive(Debug)]\r\npub struct Foo {\r\n    x: u64,\r\n    y: i32,\r\n}\r\n\r\n#[no_mangle]\r\npub static TEST: Foo = Foo { x: 0xdeadbeef, y: -55 };\r\n\r\npub static TEST2: Foo = Foo { x: 0xbeefdead, y: -55 };\r\n\r\nfn deadbeef() {\r\n    println!(\"TEST: {:?} - {:?}\", TEST, TEST2);\r\n}\r\n\r\npub fn main() {\r\n    deadbeef()\r\n}\r\n```\r\n\r\nand an approximating C++ file:\r\n\r\n```c++\r\n#include<cstdio>\r\n#include<cstdint>\r\n\r\nnamespace test {\r\n\r\n  struct Foo {\r\n    uint64_t x;\r\n    int64_t y;\r\n  };\r\n\r\n  Foo TEST = { .x = 0xdeadbeef, .y = -55 };\r\n}\r\n\r\ntest::Foo TEST = { .x = 0xbeefdead, .y = -55 };\r\n\r\nnamespace test {\r\n  void deadbeef() {\r\n    printf(\"test::TEST: {0x%lx, %ld}\\n\", test::TEST.x, test::TEST.y);\r\n    printf(\"TEST: {0x%lx, %ld}\\n\", TEST.x, TEST.y);\r\n  }\r\n}\r\n\r\nint main() {\r\n  test::deadbeef();\r\n  return 0;\r\n}\r\n```\r\n\r\nI've compiled the rust and c++ versions as follows:\r\n\r\n```\r\nrustc -g test.rs -o test\r\ng++ -g -std=c++11 test.cpp -o test_cpp\r\nclang++ -g -std=c++11 test.cpp -o test_cpp_clang\r\n```\r\n\r\nI will use the clang output for the c++ examples below, since it shares the same backend infrastructure, though the g++ does output the same.\r\n\r\n## Analysis\r\n\r\nFirst I will show the dwarf values for `TEST`, `TEST2`, and the function `deadbeef` for the `test` binary, then the `test_cpp_clang` binary.\r\n\r\nI would like to direct the reader's attention to the `DW_AT_linkage_name` field, and the corresponding linkage name it shows for each binary.\r\n\r\n```\r\nDW_TAG_variable [3]  \r\n  DW_AT_name [DW_FORM_strp]\t( .debug_str[0x00000061] = \"TEST\")\r\n  DW_AT_type [DW_FORM_ref4]\t(cu + 0x0049 => {0x00000049})\r\n  DW_AT_external [DW_FORM_flag_present]\t(true)\r\n  DW_AT_decl_file [DW_FORM_data1]\t(\"/home/m4b/tmp/bad_debug/test.rs\")\r\n  DW_AT_decl_line [DW_FORM_data1]\t(8)\r\n  DW_AT_alignment [DW_FORM_udata]\t(1)\r\n  DW_AT_location [DW_FORM_exprloc]\t(<0x9> 03 c0 65 05 00 00 00 00 00 )\r\n  DW_AT_linkage_name [DW_FORM_strp]\t( .debug_str[0x00000066] = \"_ZN4test4TESTE\")\r\n\r\nDW_TAG_variable [6]  \r\n  DW_AT_name [DW_FORM_strp]\t( .debug_str[0x00000075] = \"TEST2\")\r\n  DW_AT_type [DW_FORM_ref4]\t(cu + 0x0049 => {0x00000049})\r\n  DW_AT_decl_file [DW_FORM_data1]\t(\"/home/m4b/tmp/bad_debug/test.rs\")\r\n  DW_AT_decl_line [DW_FORM_data1]\t(10)\r\n  DW_AT_alignment [DW_FORM_udata]\t(1)\r\n  DW_AT_location [DW_FORM_exprloc]\t(<0x9> 03 d0 65 05 00 00 00 00 00 )\r\n  DW_AT_linkage_name [DW_FORM_strp]\t( .debug_str[0x0000007b] = \"_ZN4test5TEST2E\")\r\n\r\nDW_TAG_subprogram [7] *\r\n  DW_AT_low_pc [DW_FORM_addr]\t(0x00000000000073b0)\r\n  DW_AT_high_pc [DW_FORM_data4]\t(0x000000f7)\r\n  DW_AT_frame_base [DW_FORM_exprloc]\t(<0x1> 56 )\r\n  DW_AT_linkage_name [DW_FORM_strp]\t( .debug_str[0x000000d9] = \"_ZN4test8deadbeefE\")\r\n  DW_AT_name [DW_FORM_strp]\t( .debug_str[0x000000ec] = \"deadbeef\")\r\n  DW_AT_decl_file [DW_FORM_data1]\t(\"/home/m4b/tmp/bad_debug/test.rs\")\r\n  DW_AT_decl_line [DW_FORM_data1]\t(12)\r\n```\r\n\r\nAnd now for the cpp version:\r\n\r\n```\r\nDW_TAG_variable [3]  \r\n  DW_AT_name [DW_FORM_strp]     ( .debug_str[0x00000053] = \"TEST\")\r\n  DW_AT_type [DW_FORM_ref4]     (cu + 0x0048 => {0x00000048})\r\n  DW_AT_external [DW_FORM_flag_present] (true)\r\n  DW_AT_decl_file [DW_FORM_data1]       (\"/home/m4b/tmp/bad_debug/test.cpp\")\r\n  DW_AT_decl_line [DW_FORM_data1]       (11)\r\n  DW_AT_location [DW_FORM_exprloc]      (<0x9> 03 30 10 20 00 00 00 00 00 )\r\n  DW_AT_linkage_name [DW_FORM_strp]     ( .debug_str[0x0000008e] = \"_ZN4test4TESTE\")\r\n\r\nDW_TAG_subprogram [6]  \r\n  DW_AT_low_pc [DW_FORM_addr]   (0x0000000000000670)\r\n  DW_AT_high_pc [DW_FORM_data4] (0x0000004c)\r\n  DW_AT_frame_base [DW_FORM_exprloc]    (<0x1> 56 )\r\n  DW_AT_linkage_name [DW_FORM_strp]     ( .debug_str[0x000002be] = \"_ZN4test8deadbeefEv\")\r\n  DW_AT_name [DW_FORM_strp]     ( .debug_str[0x000002d2] = \"deadbeef\")\r\n  DW_AT_decl_file [DW_FORM_data1]       (\"/home/m4b/tmp/bad_debug/test.cpp\")\r\n  DW_AT_decl_line [DW_FORM_data1]       (17)\r\n  DW_AT_external [DW_FORM_flag_present] (true)\r\n\r\nDW_TAG_variable [9]  \r\n  DW_AT_name [DW_FORM_strp]       ( .debug_str[0x00000053] = \"TEST\")\r\n  DW_AT_type [DW_FORM_ref4]       (cu + 0x0048 => {0x00000048})\r\n  DW_AT_external [DW_FORM_flag_present]   (true)\r\n  DW_AT_decl_file [DW_FORM_data1] (\"/home/m4b/tmp/bad_debug/test.cpp\")\r\n  DW_AT_decl_line [DW_FORM_data1] (14)\r\n  DW_AT_location [DW_FORM_exprloc]        (<0x9> 03 40 10 20 00 00 00 00 00 )\r\n```\r\n\r\nThe first thing to note is that for the rust, `no_mangle` static, `TEST`, it is given a linkage name:\r\n\r\n```\r\nDW_AT_linkage_name [DW_FORM_strp]\t( .debug_str[0x00000066] = \"_ZN4test4TESTE\")\r\n```\r\n\r\nIn contrast to the cpp version, which (correctly) has none. I believe the rust DIE that is emitted is outright incorrect, and is the cause of the issue in https://github.com/rust-lang/rust/issues/33172\r\n\r\nNote, although this issue was closed in favor of https://github.com/rust-lang/rust/issues/32574 that issue _does not_ `no_mangle` the static.\r\n\r\nUnfortunately, that issue also noted (but did not seem to pursue further):\r\n\r\n> Now, this variable is not actually emitted. There's no ELF symbol for it.\r\n\r\nwhich I believe may be the crux of the major problem at large here: the `linkage_name` on **all non-mangled Rust DWARF DIEs** references a **non-existent** symbol - I think this is at best highly unusual, and at worst problematic.\r\n\r\n## Missing Symbols\r\n\r\nConsidering only ELF at the moment, we can verify that for `TEST`, `TEST2`, and `deadbeef`, there _is no symbol_ referenced by the `linkage_name` on the DIE:\r\n\r\n```\r\n565d0    LOCAL      OBJECT      _ZN4test5TEST217h8314c5b1b9028ef4E     0x10      .rodata(16)\r\n 73b0    LOCAL      FUNC        _ZN4test8deadbeef17hc8e13bcb4738fc41E  0xf7      .text(14)\r\n565c0    GLOBAL     OBJECT      TEST                                   0x10      .rodata(16)\r\n```\r\n\r\nYou will note that the symbols include the [symbol hash](https://github.com//m4b/rust/blob/b15a8eafcd7e50af116d398c1ac3c5a0504c0270/src/librustc_trans/back/symbol_names.rs#L152).\r\n\r\nIn contrast with the cpp version, the symbol name (including parameter types, see the `v` (for void) in `_ZN4test8deadbeefEv`) is identical to the linkage_name, as I think, expected:\r\n\r\n```\r\n201040    GLOBAL     OBJECT      TEST                                  0x10    .data(22)\r\n   670    GLOBAL     FUNC        _ZN4test8deadbeefEv                   0x4c    .text(12)\r\n201030    GLOBAL     OBJECT      _ZN4test4TESTE                        0x10    .data(22)\r\n```\r\n\r\n# Debuggers\r\n\r\nI would now like to present a debugging session (primarily in `gdb`) for the two binaries to attempt to illustrate some of the oddities that occur, and motivate why I think there is something wrong here, at the very least.\r\n\r\nThere are general ergonomic issues and other oddities that I think are surfacing because of the current debug info situation. I have used `gdb` to illustrate, as `lldb` is essentially non-functioning for me, and when it doesn't segfault, I cannot break on un-mangled names for the rust binaries.\r\n\r\n## GDB\r\n\r\nFirst the rust binary:\r\n\r\n```\r\n(gdb) ptype TEST\r\nNo symbol 'TEST' in current context\r\n(gdb) ptype test::TEST\r\nNo symbol 'test::TEST' in current context\r\n(gdb) ptype test::TEST2\r\nReading in symbols for test.rs...done.\r\ntype = struct test::Foo {\r\n  x: u64,\r\n  y: i32,\r\n}\r\n(gdb) ptype test::deadbeef\r\ntype = fn ()\r\n(gdb) whatis TEST\r\nNo symbol 'TEST' in current context\r\n(gdb) whatis test::TEST\r\nNo symbol 'test::TEST' in current context\r\n(gdb) whatis test::TEST2\r\ntype = test::Foo\r\n(gdb) whatis test::deadbeef\r\ntype = fn ()\r\n(gdb) info addr TEST\r\nSymbol \"TEST\" is at 0x565c0 in a file compiled without debugging.\r\n(gdb) info addr test::TEST\r\nNo symbol \"test::TEST\" in current context.\r\n(gdb) info addr test::TEST2\r\nSymbol \"test::TEST2\" is static storage at address 0x565d0.\r\n(gdb) info addr test::deadbeef\r\nSymbol \"test::deadbeef\" is a function at address 0x73b0.\r\n(gdb) info addr _ZN4test5TEST217h8314c5b1b9028ef4E\r\nSymbol \"test::TEST2\" is at 0x565d0 in a file compiled without debugging.\r\n(gdb) info addr _ZN4test8deadbeef17hc8e13bcb4738fc41E\r\nSymbol \"test::deadbeef\" is at 0x73b0 in a file compiled without debugging.\r\n```\r\n\r\nThe last two are particularly troubling. This certainly looks like a direct consequence of mapping the unmangled, symbol name + hash, in the ELF symbol table to the mangled-without-hash _linkage_ name in the DWARF DIE.\r\n\r\nIf we compare this to the exact same c++ debugging sequence, it is exactly what one would expect:\r\n\r\n```\r\n(gdb) ptype TEST\r\ntype = struct test::Foo {\r\n    uint64_t x;\r\n    int64_t y;\r\n}\r\n(gdb) ptype test::TEST\r\ntype = struct test::Foo {\r\n    uint64_t x;\r\n    int64_t y;\r\n}\r\n(gdb) ptype test::deadbeef\r\ntype = void (void)\r\n(gdb) whatis TEST\r\ntype = test::Foo\r\n(gdb) whatis test::TEST\r\ntype = test::Foo\r\n(gdb) whatis test::deadbeef\r\ntype = void (void)\r\n(gdb) info addr TEST\r\nSymbol \"TEST\" is static storage at address 0x201040.\r\n(gdb) info addr test::TEST\r\nSymbol \"test::TEST\" is static storage at address 0x201030.\r\n(gdb) info addr test::deadbeef\r\nSymbol \"test::deadbeef()\" is a function at address 0x670.\r\n(gdb) info addr _ZN4test4TESTE\r\nSymbol \"test::TEST\" is static storage at address 0x201030.\r\n(gdb) info addr _ZN4test8deadbeefEv\r\nSymbol \"test::deadbeef()\" is a function at address 0x670.\r\n```\r\n\r\n\r\n## LLDB\r\n\r\nAs of lldb with llvm 5.0.0 I cannot even auto-complete or break on non-mangled names, which further increases my suspicion something is wrong, and the fact that it segfaults occasionally when I auto-complete using `test::` as a seed and the stack trace indicates its in the dwarf DIE parsing logic is equally suspicious:\r\n\r\n```\r\nProcess 11803 (lldb) of user 1000 dumped core.\r\nStack trace of thread 11841:\r\n#0  0x00007f4d2e9a4295 _ZN16DWARFCompileUnit6GetDIEEj (liblldb.so.3.8.0)\r\n#1  0x00007f4d2e9a9f60 _ZN14DWARFDebugInfo6GetDIEERK6DIERef (liblldb.so.3.8.0)\r\n#2  0x00007f4d2e9a4265 _ZN16DWARFCompileUnit6GetDIEEj (liblldb.so.3.8.0)\r\n#3  0x00007f4d2e9ac6b0 _ZNK19DWARFDebugInfoEntry13GetAttributesEPK16DWARFCompileUnitN14DWARFFormValue14\r\n#4  0x00007f4d2e9a4f89 _ZN16DWARFCompileUnit12IndexPrivateEPS_N4lldb12LanguageTypeERKN14DWARFFormValue1\r\n#5  0x00007f4d2e9a454c _ZN16DWARFCompileUnit5IndexER9NameToDIES1_S1_S1_S1_S1_S1_S1_ (liblldb.so.3.8.0)\r\n#6  0x00007f4d2e9cab60 _ZNSt17_Function_handlerIFSt10unique_ptrINSt13__future_base12_Result_baseENS2_8_\r\n#7  0x00007f4d2e9caa1a _ZNSt13__future_base13_State_baseV29_M_do_setEPSt8functionIFSt10unique_ptrINS_12\r\n#8  0x00007f4d31feedbf __pthread_once_slow (libpthread.so.0)\r\n#9  0x00007f4d2e9ca5dc _ZNSt13__future_base11_Task_stateISt5_BindIFZN10TaskRunnerIjE7AddTaskIRZN15Symbo\r\n#10 0x00007f4d2ec2fd15 _ZN12_GLOBAL__N_112TaskPoolImpl6WorkerEPS0_ (liblldb.so.3.8.0)\r\n#11 0x00007f4d2c970a6f execute_native_thread_routine (libstdc++.so.6)\r\n#12 0x00007f4d31fe708a start_thread (libpthread.so.0)\r\n#13 0x00007f4d2c3de47f __clone (libc.so.6)\r\n```\r\n\r\n# Solutions\r\n\r\nI believe 1. is the first that should be attempted, but I am not an expert in the compiler internals.\r\n\r\n1. Have the [dwarf name mangler](https://github.com//m4b/rust/blob/b15a8eafcd7e50af116d398c1ac3c5a0504c0270/src/librustc_trans/debuginfo/namespace.rs#L25) include the [symbol hash](https://github.com//m4b/rust/blob/b15a8eafcd7e50af116d398c1ac3c5a0504c0270/src/librustc_trans/back/symbol_names.rs#L152), specifically I think it needs to be appended right about here: https://github.com//m4b/rust/blob/b15a8eafcd7e50af116d398c1ac3c5a0504c0270/src/librustc_trans/debuginfo/namespace.rs#L47\r\n2. Output non-hash versions of symbols into the symbol table that point to the same address, etc., but which reference the non-hash name in the string table.  This is a hack imho, and I've already tried this via binary editing and it did not seem to have any noticeable effect.\r\n\r\nEventually, I think that the final, correct solution imho is to exactly mirror the dwarf output of both the gcc and clang backends, which means:\r\n\r\n1. Making the linkage_name = the symbol table name\r\n2. Adding parameters, etc., into the symbol table name?\r\n\r\n# Final Considerations\r\n\r\nI believe I've also found some weirdness w.r.t. other symbol names, specifically:\r\n\r\n1. locally scoped statics,\r\n2. impls of traits with certain annotations\r\n\r\nexamples of which are:\r\n\r\n```\r\n_ZN3std10sys_common9backtrace11log_enabled7ENABLED17hc187c5b3618ccb2eE.0.0\r\n_ZN61_$LT$alloc..heap..Heap$u20$as$u20$alloc..allocator..Alloc$GT$3oom17h28fb525969c57bd8E\r\n```\r\n\r\nat lines:\r\n\r\n1. https://github.com//m4b/rust/blob/b15a8eafcd7e50af116d398c1ac3c5a0504c0270/src/libstd/sys_common/backtrace.rs#L148 (`0.0` appended to a mangled name is not a valid mangled name afaik)\r\n2. https://github.com//m4b/rust/blob/b15a8eafcd7e50af116d398c1ac3c5a0504c0270/src/liballoc/heap.rs#L94-L100 (the symbol name appears to differ widly from the debug name)\r\n\r\n, respectively.\r\n\r\nBut I think this is another story for another time ;)\r\n", "closed_by": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/46453/reactions", "total_count": 2, "+1": 2, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/46453/timeline", "performed_via_github_app": null, "state_reason": null}