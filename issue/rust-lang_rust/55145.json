{"url": "https://api.github.com/repos/rust-lang/rust/issues/55145", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/55145/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/55145/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/55145/events", "html_url": "https://github.com/rust-lang/rust/issues/55145", "id": 371017054, "node_id": "MDU6SXNzdWUzNzEwMTcwNTQ=", "number": 55145, "title": "dyn closures shouldn't lose range analysis information of the environment", "user": {"login": "RReverser", "id": 557590, "node_id": "MDQ6VXNlcjU1NzU5MA==", "avatar_url": "https://avatars.githubusercontent.com/u/557590?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RReverser", "html_url": "https://github.com/RReverser", "followers_url": "https://api.github.com/users/RReverser/followers", "following_url": "https://api.github.com/users/RReverser/following{/other_user}", "gists_url": "https://api.github.com/users/RReverser/gists{/gist_id}", "starred_url": "https://api.github.com/users/RReverser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RReverser/subscriptions", "organizations_url": "https://api.github.com/users/RReverser/orgs", "repos_url": "https://api.github.com/users/RReverser/repos", "events_url": "https://api.github.com/users/RReverser/events{/privacy}", "received_events_url": "https://api.github.com/users/RReverser/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-10-17T11:02:20Z", "updated_at": "2019-03-01T21:44:33Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Minimal reproducible example:\r\n\r\n```rust\r\npub fn test(b: bool) -> Box<dyn Fn() -> bool> {\r\n    assert!(b);\r\n    Box::new(move || b)\r\n}\r\n```\r\n\r\ncurrently compiles into:\r\n\r\n```asm\r\nexample::test:\r\n        push    rax\r\n        test    edi, edi\r\n        je      .LBB7_3\r\n        mov     edi, 1\r\n        mov     esi, 1\r\n        call    __rust_alloc@PLT\r\n        test    rax, rax\r\n        je      .LBB7_4\r\n        mov     byte ptr [rax], 1\r\n        lea     rdx, [rip + .Lvtable.7]\r\n        pop     rcx\r\n        ret\r\n.LBB7_3:\r\n        call    std::panicking::begin_panic\r\n        ud2\r\n.LBB7_4:\r\n        mov     edi, 1\r\n        mov     esi, 1\r\n        call    alloc::alloc::handle_alloc_error@PLT\r\n        ud2\r\n\r\nexample::test::{{closure}}:\r\n        mov     al, byte ptr [rdi]\r\n        ret\r\n```\r\n\r\nBut given that the `b` is guaranteed to be `true`, I'd expect it to be equivalent to inlining a constant.\r\n\r\nThe only way to propagate such invariants currently seems to be by using the LLVM `assume` intrinsic which is available only on nightly. E.g. for example above:\r\n\r\n```rust\r\n#![feature(core_intrinsics)]\r\n\r\nuse std::intrinsics::assume;\r\n\r\npub fn test(b: bool) -> Box<dyn Fn() -> bool> {\r\n    assert!(b);\r\n    Box::new(move || {\r\n        unsafe { assume(b); }\r\n        b\r\n    })\r\n}\r\n```\r\n\r\ncompiles to\r\n\r\n```asm\r\nexample::test:\r\n        push    rax\r\n        test    edi, edi\r\n        je      .LBB7_3\r\n        mov     edi, 1\r\n        mov     esi, 1\r\n        call    qword ptr [rip + __rust_alloc@GOTPCREL]\r\n        test    rax, rax\r\n        je      .LBB7_4\r\n        mov     byte ptr [rax], 1\r\n        lea     rdx, [rip + .L__unnamed_4]\r\n        pop     rcx\r\n        ret\r\n.LBB7_3:\r\n        call    std::panicking::begin_panic\r\n        ud2\r\n.LBB7_4:\r\n        mov     edi, 1\r\n        mov     esi, 1\r\n        call    qword ptr [rip + _ZN5alloc5alloc18handle_alloc_error17hfd3c7484b550d419E@GOTPCREL]\r\n        ud2\r\n\r\nexample::test::{{closure}}:\r\n        mov     al, 1\r\n        ret\r\n```\r\n\r\nwhich is much closer to the expected result - function is using a constant as it should. However, this still allocates data for a variable even though it's no longer necessary - it has only one value and isn't used in the optimised function body anyway.\r\n\r\nNote that the range analysis issue applies specifically to dynamically dispatched closures (which are still necessary sometimes and are used for generic callbacks), however the second part of the issue (unnecessary allocation) applies to statically dispatched generic closures too. For example:\r\n\r\n```rust\r\npub fn test(b: bool) -> Box<impl Fn() -> bool> {\r\n    assert!(b);\r\n    Box::new(move || {\r\n        b\r\n    })\r\n}\r\n```\r\n\r\ncompiles to:\r\n\r\n```asm\r\nexample::test:\r\n        push    rax\r\n        test    edi, edi\r\n        je      .LBB6_3\r\n        mov     edi, 1\r\n        mov     esi, 1\r\n        call    qword ptr [rip + __rust_alloc@GOTPCREL]\r\n        test    rax, rax\r\n        je      .LBB6_4\r\n        mov     byte ptr [rax], 1\r\n        pop     rcx\r\n        ret\r\n.LBB6_3:\r\n        call    std::panicking::begin_panic\r\n        ud2\r\n.LBB6_4:\r\n        mov     edi, 1\r\n        mov     esi, 1\r\n        call    qword ptr [rip + _ZN5alloc5alloc18handle_alloc_error17hfd3c7484b550d419E@GOTPCREL]\r\n        ud2\r\n```\r\n\r\nI understand these examples might seem superficial and can be easily optimised by hand, but I hope they do showcase a more generic issue, which also applies to e.g. captures of `enum` in `match` branches where captured enum is guaranteed to be within the already matched variants, but this information is not properly propagated and lost to the closure, preventing further optimisations.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/55145/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/55145/timeline", "performed_via_github_app": null, "state_reason": null}