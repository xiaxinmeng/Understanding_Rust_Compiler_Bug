{"url": "https://api.github.com/repos/rust-lang/rust/issues/88126", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/88126/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/88126/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/88126/events", "html_url": "https://github.com/rust-lang/rust/issues/88126", "id": 973136910, "node_id": "MDU6SXNzdWU5NzMxMzY5MTA=", "number": 88126, "title": "stabilize disjoint capture in closures (RFC 2229)", "user": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 919710011, "node_id": "MDU6TGFiZWw5MTk3MTAwMTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/disposition-merge", "name": "disposition-merge", "color": "008800", "default": false, "description": "This issue / PR is in PFCP or FCP with a disposition to merge it."}, {"id": 923282386, "node_id": "MDU6TGFiZWw5MjMyODIzODY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/finished-final-comment-period", "name": "finished-final-comment-period", "color": "f9e189", "default": false, "description": "The final comment period is finished for this PR / Issue."}, {"id": 2947369052, "node_id": "MDU6TGFiZWwyOTQ3MzY5MDUy", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-edition-2021", "name": "A-edition-2021", "color": "f7e101", "default": false, "description": "Area: The 2021 edition"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 16, "created_at": "2021-08-17T23:27:10Z", "updated_at": "2021-10-04T15:34:01Z", "closed_at": "2021-10-04T15:34:00Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "# RFC 2229 Stabilization Report\r\n\r\n## Links\r\n\r\n* [RFC 2229](https://github.com/rust-lang/rfcs/blob/master/text/2229-capture-disjoint-fields.md)\r\n* [Tracking issue](https://github.com/rust-lang/rust/issues/53488) and [project repository](https://github.com/rust-lang/project-rfc-2229/)\r\n* [Reference guide PR](https://github.com/rust-lang/reference/pull/1059)\r\n\r\n## Impl blockers\r\n\r\n* [x] Fixing various ICEs and small bugs that arose from public testing period\r\n* [x] Fixing behavior of `#[nonexhaustive]` captures across crates\r\n\r\n## Summary\r\n\r\nThis feature adjusts the rules for closure captures starting in Rust 2021. In Rust 2018 and before, closures always captured entire local variables. Under these new rules, they capture more precise paths. These paths are always some prefix of the precise paths that are references within the closure body. \r\n\r\nAs a simple example, in Rust 2018, `|| println!(\"{}\", a.y)` captures a reference to `a` and not just `a.y`. Capturing `a` in its entirety prevents mutation or moves from other fields of `a`, so that code like this does not compile:\r\n\r\n```rust,ignore\r\nlet a = SomeStruct::new();\r\ndrop(a.x); // Move out of one field of the struct\r\nprintln!(\"{}\", a.y); // Ok: Still use another field of the struct\r\nlet c = || println!(\"{}\", a.y); // Error: Tries to capture all of `a`\r\nc();\r\n```\r\n\r\nIn Rust 2021, however, this closure would only capture a reference to `a.y`, and hence the code above would compile.\r\n\r\nDisjoint capture was proposed as part of [RFC 2229](https://github.com/rust-lang/rfcs/blob/master/text/2229-capture-disjoint-fields.md) and the RFC contains details about the motivation.\r\n\r\n### Capture algorithm, guide description\r\n\r\n#### Ref closures\r\n\r\nRef closures generally capture the precise paths that you use within the closure, subject to a few limitations:\r\n\r\n* *Unsafe* parts of paths, such as the deref of a raw pointer or an access to the field of a union, always occur in the closure. The closure will therefore capture the prefix of the path that stops right before the unsafe operation (e.g., it would capture the raw pointer, not the data the raw pointer points at).\r\n* When *moving* particular paths, we only capture data that was present on the stack frame of the closure creator. So if a closure moves data from `(*b).f`, where `b: Box<SomeType>`, we would capture all of `b`. This ensures that closures never capture deceptively large amounts of data that were intentionally being passed via a box.\r\n\r\n#### Move closures\r\n\r\nMove closures generally try to take ownership of all their captures. However, in the event that the capture they are taking ownership of is borrowed data, they may borrow the data instead:\r\n\r\n* When the closure only uses a path by reference, and the path passes through a reference, then the path is captured by reference.\r\n    * e.g., a call like `x.0.split(0)` where `x: &([u32], String)` will capture `x.0` by reference, even though this is a move closure (note that in Rust 2018, we would have captured the reference `x` itself, which is ery similar).\r\n* Otherwise, all paths are **moved**, but as above we only capture data that was present on the stack frame of the closure creator. So if a closure moves data from `(*b).f`, where `b: Box<SomeType>`, we would capture all of `b`. This ensures that closures never capture deceptively large amounts of data that were intentionally being passed via a box.\r\n\r\n#### Optimizations\r\n\r\nIn addition to the rules above, the compiler also performs some optimizations to reduce closure size, but these do not affect which programs compile or do not compile, or the order of destructor execution, so they are not relevant to understanding how the program works.\r\n\r\n#### Examples\r\n\r\n```rust\r\nstruct Foo { x: i32 }\r\n\r\nfn box_mut() {\r\n    let bx = Box::new([0; 1024]);\r\n    let c = move || println!(\"{:?}\", *bx);\r\n    // Closure captures `bx`, even though the body uses `*bx`,\r\n    // because of the rule that we always capture data that resides\r\n    // on the creator's stack frame.\r\n}\r\n```\r\n\r\n```rust\r\nstruct Foo { x: i32 }\r\n\r\nfn box_mut() {\r\n    let mut s = Foo { x: 0 } ;\r\n    \r\n    let px = &mut s;\r\n    let bx = Box::new(px);\r\n    \r\n    \r\n    let c = move || bx.x += 10;\r\n    // Closure captures `&mut (*(*bx)).x`, even though this is a move\r\n    // closure, because of the rule that \"moves\" of borrowed data\r\n    // ultimately cature by mutable reference.\r\n}\r\n```\r\n\r\n### Capture algorithm, precise description\r\n\r\nThe precise capture algorithm is [described here](https://github.com/sexxi-goose/reference/blob/closure-doc/src/types/closure.md#overall-capture-analysis-algorithm). The high-level idea is as follows:\r\n\r\n1. Collect the set C of all \"captures\" that appear in the closure body. A capture consists of a place P that is referenced and a mode M:\r\n    * The *place P* is something like `(*a).b.c`\r\n    * The *mode M* is `move`, `ref`, or `ref mut`\r\n    * For example, a closure like `|| x.0.truncate(0)`, where `x: &mut (String, String)`, would capture the place `(*x).0` with the mode `ref mut`.\r\n        * This is because `x.0.truncate(0)` is shorthand for `str::truncate(&mut (*x).0, 0)`\r\n    * Note that the mode M is independent of whether this is a `move` closure or not\r\n2. Truncate the \"captures\" (P, M) in the C by applying various transforms:\r\n    * `unsafe_check(P, M) -> (P, M)` truncates the place P so that any unsafe operations occur in the closure, not the creator\r\n        * e.g., instead of capturing `(*x.f).m`, if `x.f: *mut T`, we would just capture `x.f`\r\n    * `ref_opt(P, M) -> (P, M)` truncates dereferences of `&T` references so that we capture the entire `&T` instead of capturing some subfield. This is an optimization that minimizes the size of closures without affecting the set of things that compile.\r\n        * e.g., given `x: &(String, String)` and `|| foo(&x.0, &x.1)`, we would minimize the places `(*x).0` and `(*x).1` to just `x`, thus capturing a single reference instead of two\r\n    * For a non-move closure:\r\n        * `ref_xform`: If this is a \"by-value\" mode capture, then truncate to the first pointer dereference\r\n            * e.g., given `b: Box<[u8; 1024]>` and a by-value capture of `*b`, truncate at `b` so that we capture the box, not its contents\r\n    * For a move closure:\r\n        * `move_xform`, which performs 3 truncations:\r\n            * If this is a `ref mut` mode capture, and the place contains a deref of an `&mut` reference, then leave it unchanged.\r\n            * If this is a `ref` mode capture, and the place contains a deref of an `&` reference, then leave it unchanged.\r\n            * Else, change to a a `by-value` mode capture, then truncate to the first pointer dereference\r\n3. Minimization: If the set C contains two places (P1, M1) and (P2, M2) where P1 is a prefix of P2, then just capture (P1, max(M1, M2))\r\n    * e.g., given `|| { &x; &mut x.y; }` we capture `x` (the prefix of `x` and `x.y`) but with the mode `ref mut` (the greater of the two modes).\r\n\r\n#### What data does a closure use?\r\n\r\nClosures are considered to reference data under the following conditions:\r\n\r\n* Shared borrows of a place (`&a.b.c`) is a `ref` mode access to the place `a.b.c`; shared borrows are often introduced via calls to methods like `a.b.c.split(0)`\r\n* Mutable borrows of a place (`&mut a.b.c`) is a `ref mut` mode access to the place `a.b.c`; mutable borrows are often introduced via calls to methods like `a.b.c.truncate(0)`\r\n* By-value accesses to a place (`drop(x)`) of `Copy` type are considered mode `ref` of the place `x`\r\n* By-value of a place (`drop(x)`) not of `Copy` type are considered a `move` mode access to the place `x`\r\n* Pattern matching against an enum variant `Enum::Variant` is considered a *read of the enum* if:\r\n    * the enum has multiple variants\r\n    * or the enum is marked as `#[non_exhaustive]` and is defined in another crate (FIXME)\r\n\r\n### Implementation strategy\r\n\r\nThe implementation strategy is to modify the desugaring of closures. Whereas Rust 2018 closures like `|| foo(&mut a.b, &mut c.d, &mut c.e)` desugars to creating an anonymous struct with two fields, one for `a` and one for `c`:\r\n\r\n```rust\r\nClosureStruct { a: &mut a, c: &mut c }\r\n```\r\n\r\nThe Rust 2021 struct would contain a field for each unique capture:\r\n\r\n```rust\r\nClosureStruct { a_b: &mut a.b, c_d: &mut c.d, c_e: &mut c.e }\r\n```\r\n\r\nThis change is focused on MIR construction and does not affect the borrow checker in any significant way (there were changes to the diagnostics code).\r\n\r\n### Size measurements\r\n\r\nWe have measured the size of closures on the compiler and other code bases. A broader crater run is in progress. Preliminary measurements suggest that closures are slightly larger in Rust 2021, but not substantially: the average is that closures grow by less than 1 byte. This table breaks down measurements by the size of the original closure:\r\n\r\n| Rust 2018 min size | Rust 2018 max size | Number of closures | Average size in 2018 | Average growth in 2021 in bytes | Percentage growth |\r\n| --- | --- | --- | --- | --- | --- |\r\n| 0\t| 16 | 17039 | 3.88 | 0.22 | 5.56%\r\n| 16 | 32 | 4105 | 17.90 | 0.76 | 4.26%\r\n| 32 | 64 | 1700 | 40.79 | 0.86 | 2.11%\r\n| 64 | 9999999 | 850 | 99.40 | -0.26 | -0.27% |\r\n| 0 | 9999999 | 23694 | 12.39 | 0.34 | 2.74% |\r\n\r\n## How the RFC's unresolved questions were resolved\r\n\r\nThe RFC posed the following unresolved questions:\r\n\r\n> How to optimize pointers. Can borrows that all reference parts of the same\r\n> object be stored as a single pointer? How should this optimization be\r\n> implemented (e.g. a special `repr`, refinement typing)?\r\n\r\nWe use a naive algorithm apart from a single optimization which captures an `&` reference instead of creating shared references to the individual fields. Our measurements found that this optimization is sufficient to ensure that closures are generally the same size or smaller in Rust 2018 and avoided any complex changes to the borrow checker.\r\n\r\n> How to signal that a function is pure. Is this even needed/wanted? Any other\r\n> places where the language could benefit?\r\n\r\nWe do not signal that functions are pure, which means that overloaded derefs and deref-mut implementations capture the base pointer. The one exception is `Box`, as described in the next question.\r\n\r\n> Should `Box` be special?\r\n\r\nYes, we treat `Box` specially. This is consistent with the borrow checker which genreally treats `Box` as special. This could in the future be generalized with some sort of \"deref pure\" trait but we left that for future work.\r\n\r\n> Drop order can change as a result of this RFC, is this a real stability\r\n> problem? How should this be resolved?\r\n\r\nThis was resolved via edition migrations. Migratons were also used to address some other cases that arose, such as the fact that closures may not implement different auto traits as a result of capturing different things.\r\n\r\n## Test cases and testing\r\n\r\n* Public testing of the 2021 Edition and migration\r\n* Unit tests in the [2229_closure_analysis](https://github.com/rust-lang/rust/tree/30a0a9b694cde95cbab863f7ef4d554f0f46b606/src/test/ui/closures/2229_closure_analysis) directory:\r\n    * The internal `#[rustc_capture_analysis]` annotation causes rustc to dump debugging output about what is captured and why, allowing us to test the model directly.\r\n    * For example, [this test](https://github.com/rust-lang/rust/blob/30a0a9b694cde95cbab863f7ef4d554f0f46b606/src/test/ui/closures/2229_closure_analysis/optimization/edge_case.rs) covers an edge case around the `&T` capture optimization, and the [stderr file](https://github.com/rust-lang/rust/blob/30a0a9b694cde95cbab863f7ef4d554f0f46b606/src/test/ui/closures/2229_closure_analysis/optimization/edge_case.stderr#L28) identifies the precise path that is captured.\r\n\r\n", "closed_by": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/88126/reactions", "total_count": 33, "+1": 0, "-1": 0, "laugh": 0, "hooray": 20, "confused": 0, "heart": 13, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/88126/timeline", "performed_via_github_app": null, "state_reason": "completed"}