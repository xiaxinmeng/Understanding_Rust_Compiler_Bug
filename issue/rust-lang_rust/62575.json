{"url": "https://api.github.com/repos/rust-lang/rust/issues/62575", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/62575/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/62575/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/62575/events", "html_url": "https://github.com/rust-lang/rust/issues/62575", "id": 466583846, "node_id": "MDU6SXNzdWU0NjY1ODM4NDY=", "number": 62575, "title": "Better greedy layout computation for generators", "user": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 679846574, "node_id": "MDU6TGFiZWw2Nzk4NDY1NzQ=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-generators", "name": "A-generators", "color": "f7e101", "default": false, "description": "Area: Generators"}, {"id": 1049491442, "node_id": "MDU6TGFiZWwxMDQ5NDkxNDQy", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-heavy", "name": "I-heavy", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to binary size of generated code."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2019-07-11T00:00:53Z", "updated_at": "2020-12-03T01:25:27Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I've been thinking about a new approach for computing the layout of generators, since I merged #59897. Actually, I've been thinking about it before that, but the approach there felt a bit safer to start with.\r\n\r\nThe idea is that we use the struct layout computation, rather than the enum computation, as a starting point, and add in the fact that fields can overlap. The basic algorithm is simple:\r\n\r\n- We iterate through every field, in descending order of alignment and number of conflicts with other fields*.\r\n- For each field, pick the first offset (with respect to its alignment) that it's still allowed to occupy, given the other fields that we've already placed.\r\n\r\nBecause we're working in descending order of alignment (and alignments are all powers of 2), we should be able to use a \"segment-tree-like\" data structure with a bitset of fields that are still allowed to be placed at a given position. This means that updating the tree is logarithmic in the number of alignment levels, and so is searching for the first position a field is allowed to occupy. \r\n\r\nThis greedy algorithm should be an improvement over the current algorithm, which doesn't attempt to overlap any fields that are live across more than one yield in the generator. It also wouldn't force \"overlap-zone\" fields to always come after \"non-overlap\" fields, which means we can do a better job of eliminating padding. Finally, the logic should be easier to follow in code than the current optimization (once the data structure is written).\r\n\r\nThis problem is NP-complete, so there might be better algorithms than this out there. I'd love to hear suggestions!\r\n\r\n---\r\n\r\n(*) The number of conflicts is the number of other fields in this struct that cannot be overlapped with the current field. The exact heuristic may change. Today, we use number of conflicts to help us decide which fields get to stay in an \"overlap zone\" and which get kicked out. Then, we use order of alignment to lay out the fields in each zone.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/62575/reactions", "total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 1, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/62575/timeline", "performed_via_github_app": null, "state_reason": null}