{"url": "https://api.github.com/repos/rust-lang/rust/issues/29944", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/29944/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/29944/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/29944/events", "html_url": "https://github.com/rust-lang/rust/issues/29944", "id": 117945466, "node_id": "MDU6SXNzdWUxMTc5NDU0NjY=", "number": 29944, "title": "to_degrees/to_radians aren't rounded correctly", "user": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 60329014, "node_id": "MDU6TGFiZWw2MDMyOTAxNA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/P-low", "name": "P-low", "color": "eb6420", "default": false, "description": "Low priority"}, {"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2015-11-20T01:20:59Z", "updated_at": "2018-02-03T14:39:22Z", "closed_at": "2018-02-03T14:39:22Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "``` rust\n#![feature(float_extras)]\n\nfn main() {\n    let exact = 57.2957795130823208767981548141051703324054724665643215491602438612028471483215526324409689958511109441862233816328648932;\n\n    assert_eq!(1_f32.to_degrees(), exact);\n}\n```\n\n```\nthread '<main>' panicked at 'assertion failed: `(left == right)` (left: `57.295776`, right: `57.29578`)', <anon>:6\nplaypen: application terminated with error code 101\n```\n\nThat computed answer is just one bit wrong.\n\nThe above case would be addressed by having the 180/pi value used in the conversion being a correctly rounded constant, rather than computed as `180.0 / consts::PI`, although I'm not sure this will get the right answer in all cases. If we decide to care about this, then we'll need an exact multiplication algorithm such as [Brisebarre and Muller (2008) _Correctly rounded multiplication by arbitrary precision constants_](http://perso.ens-lyon.fr/jean-michel.muller/MultFmacArith.pdf). Let `C` be the exact (i.e. infinite precision) value of 180 / pi, then:\n\n``` rust\n// C as f32\nconst C_H: f32 = 57.295780181884765625;\n// (C - C_H) as f32\nconst C_L: f32 = -6.6880244276035227812826633453369140625e-7;\n\nfn exact_mul(x: f32) -> f32 {\n    let a = C_L * x;\n    let b = C_H.mul_add(x, a);\n    b\n}\n\nfn main() {\n    let exact = 57.2957795130823208767981548141051703324054724665643215491602438612028471483215526324409689958511109441862233816328648932;\n    assert_eq!(exact_mul(1.0), exact);\n}\n```\n\n(There's some conditions on the constant `C` for this to work for all `x`, and I don't know/haven't yet checked if 180/pi satisfies them.)\n\nThis will is noticably slower than the naive method, especially if there's not hardware support for FMA (`mul_add`), however, if we do implement this, people who don't care about accuracy can use the naive method trivially. That said, `to_degrees` is almost always used for output for humans, and is often rounded to many fewer decimal places than full precision, so loss of precision doesn't matter... but also, speed probably doesn't matter so much (the formatting will almost certainly be much slower than the multiplication). On the other hand, `to_radians` won't be used for human output, typically.\n\n``` rust\n#![feature(test, float_extras)]\nextern crate test;\n\n// C as f32\nconst C_H: f32 = 57.295780181884765625;\n// (C - C_H) as f32\nconst C_L: f32 = -6.6880244276035227812826633453369140625e-7;\n\nfn exact_mul(x: f32) -> f32 {\n    let a = C_L * x;\n    let b = C_H.mul_add(x, a);\n    b\n}\n\nconst FLOATS: &'static [f32] = &[-360.0, -359.99, -100.0, -1.001, 0.001, -1e-40,\n                                 0.0,\n                                 1e-40, 0.001, 1.001, 100.0, 359.99, 360.0];\n\n#[bench]\nfn exact(b: &mut test::Bencher) {\n    b.iter(|| {\n        for x in test::black_box(FLOATS) {\n            test::black_box(exact_mul(*x));\n        }\n    })\n}\n\n#[bench]\nfn inexact(b: &mut test::Bencher) {\n    b.iter(|| {\n        for x in test::black_box(FLOATS) {\n            test::black_box(x.to_degrees());\n        }\n    })\n}\n\n#[bench]\nfn format(b: &mut test::Bencher) {\n    b.iter(|| {\n        let mut buf = [0u8; 100];\n        for x in test::black_box(FLOATS) {\n            use std::io::prelude::*;\n            let _ = write!(&mut buf as &mut [_], \"{:.0}\", x);\n            test::black_box(&buf);\n        }\n    })\n}\n```\n\n```\ntest exact   ... bench:         169 ns/iter (+/- 6)\ntest format  ... bench:       1,238 ns/iter (+/- 41)\ntest inexact ... bench:          84 ns/iter (+/- 3)\n```\n\n(It's likely that `to_radians` suffers similarly, since pi / 180 is just as transcendental as 180 / pi, but I haven't found an example with a few tests.)\n\n---\n\nThis issue is somewhat of a policy issue: how much do we care about getting correctly rounded floating point answers? This case is pretty simple, but we almost certainly _don't_ want to guarantee 100% precise answers for functions like `sin`/`exp` etc., since this is non-trivial/slow to do, and IEEE754 (and typical libm's) don't guarantee exact rounding for all inputs.\n", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/29944/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/29944/timeline", "performed_via_github_app": null, "state_reason": "completed"}