{"url": "https://api.github.com/repos/rust-lang/rust/issues/54982", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/54982/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/54982/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/54982/events", "html_url": "https://github.com/rust-lang/rust/issues/54982", "id": 368946430, "node_id": "MDU6SXNzdWUzNjg5NDY0MzA=", "number": 54982, "title": "Index/IndexMut on wrapper type lose alignment based optimization", "user": {"login": "lambda", "id": 37398, "node_id": "MDQ6VXNlcjM3Mzk4", "avatar_url": "https://avatars.githubusercontent.com/u/37398?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lambda", "html_url": "https://github.com/lambda", "followers_url": "https://api.github.com/users/lambda/followers", "following_url": "https://api.github.com/users/lambda/following{/other_user}", "gists_url": "https://api.github.com/users/lambda/gists{/gist_id}", "starred_url": "https://api.github.com/users/lambda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lambda/subscriptions", "organizations_url": "https://api.github.com/users/lambda/orgs", "repos_url": "https://api.github.com/users/lambda/repos", "events_url": "https://api.github.com/users/lambda/events{/privacy}", "received_events_url": "https://api.github.com/users/lambda/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-10-11T04:16:25Z", "updated_at": "2018-12-24T15:19:14Z", "closed_at": "2018-12-24T15:19:14Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "An example on Compiler Explorer uses nightly only and unsafe intrinsics to assert alignment of some  arrays:\r\n\r\n```rust\r\n#![feature(core_intrinsics)]\r\n// Requires the use of the nightly rust\r\n// Compile with -O\r\npub fn max_array(x: &mut[f64; 65536], y: &[f64; 65536]) {\r\n  unsafe {\r\n    std::intrinsics::assume(x.as_ptr() as usize % 64 == 0);\r\n    std::intrinsics::assume(y.as_ptr() as usize % 64 == 0);\r\n  }\r\n  for i in 0..65536 {\r\n    x[i] = if y[i] > x[i] { y[i] } else { x[i] };\r\n  }\r\n}\r\n```\r\n\r\nThe code optimizes to some more efficient vector operations if you can assume that the input arrays have the given alignment.\r\n\r\nWith `std::intrinsics::assume`:\r\n\r\n```asm\r\nexample::max_array:\r\n        xor     eax, eax\r\n.LBB0_1:\r\n        movapd  xmm0, xmmword ptr [rsi + 8*rax]\r\n        movapd  xmm1, xmmword ptr [rsi + 8*rax + 16]\r\n        maxpd   xmm0, xmmword ptr [rdi + 8*rax]\r\n        maxpd   xmm1, xmmword ptr [rdi + 8*rax + 16]\r\n        movapd  xmmword ptr [rdi + 8*rax], xmm0\r\n        movapd  xmmword ptr [rdi + 8*rax + 16], xmm1\r\n        movapd  xmm0, xmmword ptr [rsi + 8*rax + 32]\r\n        movapd  xmm1, xmmword ptr [rsi + 8*rax + 48]\r\n        maxpd   xmm0, xmmword ptr [rdi + 8*rax + 32]\r\n        maxpd   xmm1, xmmword ptr [rdi + 8*rax + 48]\r\n        movapd  xmmword ptr [rdi + 8*rax + 32], xmm0\r\n        movapd  xmmword ptr [rdi + 8*rax + 48], xmm1\r\n        add     rax, 8\r\n        cmp     rax, 65536\r\n        jne     .LBB0_1\r\n        ret\r\n```\r\n\r\nWithout `std::intrinsics::assume`, it uses instructions that don't assume alignment and are presumably slower, as well as requiring more loads to registers:\r\n\r\n```asm\r\nexample::max_array:\r\n        xor     eax, eax\r\n.LBB0_1:\r\n        movupd  xmm0, xmmword ptr [rsi + 8*rax]\r\n        movupd  xmm1, xmmword ptr [rsi + 8*rax + 16]\r\n        movupd  xmm2, xmmword ptr [rdi + 8*rax]\r\n        maxpd   xmm0, xmm2\r\n        movupd  xmm2, xmmword ptr [rdi + 8*rax + 16]\r\n        maxpd   xmm1, xmm2\r\n        movupd  xmm2, xmmword ptr [rdi + 8*rax + 32]\r\n        movupd  xmm3, xmmword ptr [rdi + 8*rax + 48]\r\n        movupd  xmmword ptr [rdi + 8*rax], xmm0\r\n        movupd  xmmword ptr [rdi + 8*rax + 16], xmm1\r\n        movupd  xmm0, xmmword ptr [rsi + 8*rax + 32]\r\n        maxpd   xmm0, xmm2\r\n        movupd  xmm1, xmmword ptr [rsi + 8*rax + 48]\r\n        maxpd   xmm1, xmm3\r\n        movupd  xmmword ptr [rdi + 8*rax + 32], xmm0\r\n        movupd  xmmword ptr [rdi + 8*rax + 48], xmm1\r\n        add     rax, 8\r\n        cmp     rax, 65536\r\n        jne     .LBB0_1\r\n        ret\r\n```\r\n\r\nSince there is support for `#[align(64)]` now, I thought that it would be possible to do this type safely and without using any feature flags by adding that to a wrapper struct, and sure enough, we can get the same optimization with the following (result not shown since it's identical):\r\n\r\n```rust\r\n#[repr(align(64))]\r\npub struct AlignedArray([f64; 65536]);\r\n\r\npub fn max_array(x: &mut AlignedArray, y: &AlignedArray) {\r\n  for i in 0..65536 {\r\n    x.0[i] = if y.0[i] > x.0[i] { y.0[i] } else { x.0[i] };\r\n  }\r\n}\r\n```\r\n\r\nHowever, that has the slight downside of needing to use `.0` instead of just indexing on these wrapper structs. We can fix that by implementing `Index` and `IndexMut`, which I would expect to be a zero-cost abstraction. However, even though the code is still inlined and vectorized with this approach, it lost the benefit of knowing the alignment and compiled as the version with no alignment information (shown earlier):\r\n\r\n```rust\r\nuse std::ops::{Index, IndexMut};\r\n\r\n#[repr(align(64))]\r\npub struct AlignedArray([f64; 65536]);\r\n\r\nimpl Index<usize> for AlignedArray {\r\n    type Output = f64;\r\n    #[inline]\r\n    fn index(&self, i: usize) -> &f64 {\r\n        &self.0[i]\r\n    }\r\n}\r\n\r\nimpl IndexMut<usize> for AlignedArray {\r\n    #[inline]\r\n    fn index_mut(&mut self, i: usize) -> &mut f64 {\r\n        &mut self.0[i]\r\n    }\r\n}\r\n\r\npub fn max_array(x: &mut AlignedArray, y: &AlignedArray) {\r\n  for i in 0..65536 {\r\n    x[i] = if y[i] > x[i] { y[i] } else { x[i] };\r\n  }\r\n}\r\n```\r\n\r\n[Try it yourself on Compiler Explorer](https://godbolt.org/z/s46unL).\r\n\r\nAccording to Compiler Explorer, this is all using rustc 1.31.0-nightly (96cafc53c 2018-10-09). Also worth noting that the ability to produce the alignment optimized version using the wrapper struct with `#[align(64)]` only shows up in the nightly compiler; beta and released compilers give the unaligned version even without the use if `Index`/`IndexMut`.", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/54982/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/54982/timeline", "performed_via_github_app": null, "state_reason": "completed"}