{"url": "https://api.github.com/repos/rust-lang/rust/issues/21786", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/21786/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/21786/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/21786/events", "html_url": "https://github.com/rust-lang/rust/issues/21786", "id": 56070580, "node_id": "MDU6SXNzdWU1NjA3MDU4MA==", "number": 21786, "title": "Revise usage of LLVM lifetime intrinsics", "user": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37234, "node_id": "MDU6TGFiZWwzNzIzNA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-cleanup", "name": "C-cleanup", "color": "f5f1fd", "default": false, "description": "Category: PRs that clean code up or issues documenting cleanup."}, {"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 178802147, "node_id": "MDU6TGFiZWwxNzg4MDIxNDc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-needs-decision", "name": "I-needs-decision", "color": "e11d21", "default": false, "description": "Issues in need of decision."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2015-01-30T18:57:23Z", "updated_at": "2018-12-10T19:08:10Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Currently, rustc emits lifetime intrinsics to declare the shortest possible lifetime for allocas. Unfortunately, this stops some optimizations from happening. For example, @eddyb came up with the following example:\n\n``` rust\n#![crate_type=\"lib\"]\n\nextern crate test;\n#[derive(Copy)]\nstruct Big {\n  large: [u64; 100000],\n}\n\npub fn test_func() {\n  let x = Big {\n    large: [0; 100000],\n  };\n  test::black_box(x);\n}\n```\n\nThis currently results in the following optimized IR:\n\n``` llvm\ndefine void @_ZN9test_func20hef205289cff69060raaE() unnamed_addr #0 {\nentry-block:\n  %x = alloca %struct.Big, align 8\n  %0 = bitcast %struct.Big* %x to i8*\n  %arg = alloca %struct.Big, align 8\n  call void @llvm.lifetime.start(i64 800000, i8* %0)\n  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 800000, i32 8, i1 false)\n  %1 = bitcast %struct.Big* %arg to i8*\n  call void @llvm.lifetime.start(i64 800000, i8* %1)\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %0, i64 800000, i32 8, i1 false)\n  call void asm \"\", \"r,~{dirflag},~{fpsr},~{flags}\"(%struct.Big* %arg) #2, !noalias !0, !srcloc !3\n  call void @llvm.lifetime.end(i64 800000, i8* %1) #2, !alias.scope !4, !noalias !0\n  call void @llvm.lifetime.end(i64 800000, i8* %1)\n  call void @llvm.lifetime.end(i64 800000, i8* %0)\n  ret void\n}\n```\n\nAs you can see, there are still two allocas, one for `x` and one copy of it in `%arg`, which is used for the function call. Since `x` is unused otherwise, we could directly call `memset` on `%arg` and drop `%x` altogether. But the lifetime of `%arg` only start _after_ the `memset` call, so the optimization doesn't happen. Moving the call to `llvm.lifetime.start` up makes the optimization possible.\n\nNow, the lifetime intrinsics only buy us anything if the ranges don't overlap. If the ranges overlap, we may as well make them all start at the same point. One way might be to insert start/end calls at positions that match up with scopes in the language, using an insertion marker like we do for allocas to insert the start calls and a cleanup scope for the end calls. This should also make things more robust than it currently is. We had a few misoptimization problems due to missing calls to `llvm.lifetime.end`. :-/\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/21786/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/21786/timeline", "performed_via_github_app": null, "state_reason": null}