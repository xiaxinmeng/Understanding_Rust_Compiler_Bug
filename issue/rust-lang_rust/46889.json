{"url": "https://api.github.com/repos/rust-lang/rust/issues/46889", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/46889/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/46889/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/46889/events", "html_url": "https://github.com/rust-lang/rust/issues/46889", "id": 283663535, "node_id": "MDU6SXNzdWUyODM2NjM1MzU=", "number": 46889, "title": "Epoch.Next Tracking Issue", "user": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37977651, "node_id": "MDU6TGFiZWwzNzk3NzY1MQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/metabug", "name": "metabug", "color": "5319e7", "default": false, "description": "Issues about issues themselves (\"bugs about bugs\")"}, {"id": 372080667, "node_id": "MDU6TGFiZWwzNzIwODA2Njc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-core", "name": "T-core", "color": "bfd4f2", "default": false, "description": "Relevant to the core team, which will review and decide on the PR/issue."}, {"id": 650846969, "node_id": "MDU6TGFiZWw2NTA4NDY5Njk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-tracking-issue", "name": "C-tracking-issue", "color": "f5f1fd", "default": false, "description": "Category: A tracking issue for an RFC or an unstable feature."}, {"id": 858360099, "node_id": "MDU6TGFiZWw4NTgzNjAwOTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/WG-epoch", "name": "WG-epoch", "color": "c2e0c6", "default": false, "description": "Working group: Epoch (2018) management"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 25, "created_at": "2017-12-20T19:01:10Z", "updated_at": "2018-10-10T15:37:05Z", "closed_at": "2018-10-10T15:37:05Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "## What is this issue?\r\n\r\nHave you noticed that there is a lot going on with Rust these days? Over the last year, there\u2019s been a large push to design a number of tweaks to the Rust language, all with the goal of improving ergonomics and productivity for new and experienced users alike. This issue will help you see what changes are in the works and give you tips for trying them out, giving feedback, or helping to get them implemented.\r\n\r\n## Legend\r\n\u2705 Available in Nightly in \u201ccode complete\u201d form\r\n\ud83d\udc9b Available in Nightly but design not fully realized\r\n\ud83d\udd34 Not yet available in Nightly\r\n\r\n## Ownership\r\n\r\n<details>\r\n<summary>\r\n\u2705  Simplifying how `match` and borrowing interact\r\n</summary>\r\n\r\n| Feature gates  | `#![feature(match_default_bindings)]`          |\r\n| -------------- | ---------------------------------------------- |\r\n| Tracking issue | https://github.com/rust-lang/rust/issues/42640 |\r\n\r\nMatching over borrowed data today in Rust requires a combination of `*` operators, `&` patterns, and `ref` bindings. The `match_default_bindings` feature replaces them with a simpler system; when matching against a value of type `&T`, you can simply ignore the `&` and give a pattern that matches the underlying type `T`. Any bindings in that pattern will be made into references themselves.\r\n\r\n**Example**\r\n\r\n[Simple example matching an `&Option<String>`:](https://play.rust-lang.org/?gist=e3e5a50d64a7cfa266036797017431b4&version=stable):\r\n\r\n```rust\r\n#![feature(match_default_bindings)]\r\n\r\nfn print_opt_string(x: &Option<String>) {\r\n    // Here, `x` has type `&Option<String>`...\r\n    match x {\r\n        // ...but we give a pattern that matches `Option`,\r\n        // ignoring the `&`. As a result, the `y` variable\r\n        // gets the type `&String`.\r\n        Some(y) => println!(\"{}\", y),\r\n        None => println!(\"none\"),\r\n    }\r\n    \r\n    // Equivalent to the following in today's Rust:\r\n    // match x {\r\n    //     &Some(ref y) => ...\r\n    //     &None => ...\r\n    // }\r\n}\r\n\r\nfn main() {\r\n    print_opt_string(&Some(\"foo\".to_string()));\r\n}\r\n```\r\n\r\n**What\u2019s left to be done?**\r\n\r\nNot much. There are a few corner cases that we might want to fine-tune: see [the tracking issue](https://github.com/rust-lang/rust/issues/42640) for the full details.\r\n\r\n</details>\r\n\r\n<details>\r\n<summary>\r\n\u2705   Easier borrowing (a.k.a. NLL)\r\n</summary>\r\n\r\n| Feature gates  | `#![feature(nll)]`   |\r\n| -------------- | -------------------- |\r\n| Primary tracking issue | https://github.com/rust-lang/rust/issues/43234 |\r\n| Other tracking issues| rust-lang/rust#44100 |\r\n\r\nThe compiler is now able to understand control flow much more deeply when deciding what paths are borrowed at any particular point in the program. These changes eliminate a large number of confusing borrowing errors, particularly those errors that are due more to imprecision in the analysis. \r\n\r\n**Examples**\r\n\r\n[Borrow lifetimes are no longer tied to lexical scopes.](https://play.rust-lang.org/?gist=e71d99214aea46ee102fc5402986094a&version=nightly)\r\n\r\n```rust\r\n#![feature(nll)]\r\n\r\nstruct Data {\r\n    value: u32\r\n}\r\n\r\nimpl Data {\r\n    fn is_odd(&self) -> bool {\r\n        (self.value & 1) != 0\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let mut vec = vec![Data { value: 1 }];\r\n  \r\n    // In today's Rust, storing `&vec[0]` into a variable\r\n    // would cause the borrow to last until the end of\r\n    // the enclosing block. But with `nll` enabled,\r\n    // the borrow only lasts until the final use of\r\n    // `first`.\r\n    let first = &vec[0];\r\n    if first.is_odd() {\r\n        // This means that `vec` can be mutated here.\r\n        vec.push(Data { value: 22 });\r\n    }\r\n        \r\n    // Today's Rust, as least if you want to keep\r\n    // the variable `first`:\r\n    //     let is_odd = {\r\n    //         let first = &vec[0];\r\n    //         first.is_odd()\r\n    //     };\r\n    //     if is_odd { .. }\r\n}\r\n```\r\n\r\n[Invoking `&mut self` methods no longer requires \u201cunnesting\u201d:](https://play.rust-lang.org/?gist=f580b199f5ad4231966af9a1fa1c703d&version=nightly)\r\n\r\n```rust\r\n#![feature(nll)]\r\n\r\nstruct Counter {\r\n    data: u32\r\n}\r\n\r\nimpl Counter {\r\n    fn get(&self) -> u32 { self.data }\r\n    fn set(&mut self, value: u32) { self.data = value; }\r\n}\r\n\r\nfn main() {\r\n    let mut c = Counter { data: 0 };\r\n    \r\n    // In today's Rust, this would get a borrow error,\r\n    // because we first borrow `c` (as the receiver to `set()`)\r\n    // and then afterwards attempt to evaluate `c.get()`.\r\n    c.set(c.get() + 1);\r\n    \r\n    // Today's Rust:\r\n    //     let tmp = c.get() + 1;\r\n    //     c.set(tmp);\r\n}\r\n```\r\n\r\n**What\u2019s left to be done?**\r\n\r\nThere is still some engineering effort remaining. For example, some of the error messages are not yet particularly user friendly. In addition, we need to tighten some of the corner cases described in the various RFCs (these are not soundness issues per se, but rather cases where we fear that the analysis may not be forwards compatible with future changes we have in mind).\r\n\r\nWe will be transitioning to the new borrow system, but slowly. We plan to run a \u201ctrial period\u201d where we gather feedback and try to find bugs. We also need to do a \u201cwarning period\u201d before enabling the new borrowing system by default, as the new system fixes a number of bugs where the compiler incorrectly accepted illegal code (the new implementation is believed to be significantly more robust).\r\n\r\n</details>\r\n\r\n<details>\r\n<summary>\r\n\ud83d\udc9b  In-band lifetimes\r\n</summary>\r\n\r\n| Feature gates  | `#![feature(underscore_lifetimes, in_band_lifetimes)]` |\r\n| -------------- | ------------------------------------------------------ |\r\n| Lints | `#![warn(single_use_lifetime, elided_lifetime_in_path)]` |\r\n| Tracking issue | https://github.com/rust-lang/rust/issues/44524         |\r\n\r\nThe current rules that govern explicit lifetime names have some confusing edge cases. These can lead to surprising errors that are hard to diagnose. In addition, the existing annotations can be tedious to supply and get right. The in-band lifetimes RFC aims to adjust the rules to make for a smoother experience overall.\r\n\r\n**Warning:** while the major features of this RFC are in place, some of the lints are not yet fully implemented. This \r\n\r\nThe highlights:\r\n\r\n- In functions, you can now use `'_` to indicate an \u201canonymous lifetime\u201d that you do not care to give a name. This is primarily intended for use with lifetime-parameterized structs; for example, one can now write `Foo<'_>`, whereas before it was common to either write `Foo` (which obscured the fact that a lifetime was present) or to introduce a one-off name like `Foo<'a>` (where `'a` is never used anywhere else).\r\n  - In fact, lifetime parameters will be required (enforced via lint) on structs and enums in all contexts \u2014 in other words, one should not write just `Foo` is `Foo` has a lifetime parameter \u2014 but you can use `Foo<'_>` if the specific value is not important.\r\n- In functions and impls, you can now leave off explicit lifetime declarations like the `<'a>` in `impl<'a>`. Instead, the intention is that simply annotate the lifetimes that must be the same by giving them explicit names, and use `'_` for lifetimes that are not required to match against other lifetimes.\r\n\r\n**Examples**\r\n\r\nTBD\r\n\r\n**What is left to do?**\r\n\r\nSome pieces of this design are not yet implemented:\r\n\r\n- You cannot yet use `'_` or elide lifetimes in impls ([issue #15872](https://github.com/rust-lang/rust/issues/15872))\r\n- Some of the lints that will guide users down the \u201chappy path\u201d are not yet fully implemented:\r\n  - Lint against single-use lifetimes (instructing users to prefer `'_`) ([issue #44752](https://github.com/rust-lang/rust/issues/44752))\r\n  - Lint against \u201csilent elision\u201d in structs (e.g., `Foo` instead of `Foo<'_>`) ([issue #45992](https://github.com/rust-lang/rust/issues/45992))\r\n\r\n</details>\r\n\r\n<details>\r\n<summary>\r\n\ud83d\udd34  Infer `T: 'a` outlives requirements on type definitions\r\n</summary>\r\n\r\n| Feature gates  | N/A \u2014 not yet implemented                      |\r\n| -------------- | ---------------------------------------------- |\r\n| Tracking issue | https://github.com/rust-lang/rust/issues/44493 |\r\n\r\nExplicit `T: 'x` annotations will no longer be needed on type definitions. We will infer their presence based on the fields of the struct or enum. In short, if the struct contains a reference (directly or indirectly) to `T` with lifetime `'x`, then we will infer that `T: 'x` is a requirement:\r\n\r\n```rust\r\nstruct Foo<'x, T> {\r\n  // inferred: `T: 'x`\r\n  field: &'x T\r\n}\r\n```\r\n\r\nExplicit annotations remain as an option used to control trait object lifetime defaults, and simply for backwards compatibility.\r\n\r\n**Examples**\r\n\r\nComing soon =)\r\n\r\n**What\u2019s left to be done**\r\n\r\nEverything\r\n\r\n</details>\r\n\r\n## The Trait System\r\n\r\n<details>\r\n<summary>\r\n\u2705  `impl Trait` and `dyn Trait`\r\n</summary>\r\n\r\n| Feature gates  | `#![feature(universal_impl_trait, conservative_impl_trait, dyn_trait)]` |\r\n| -------------- | ----------------------------------------------------------------------- |\r\n| Tracking issue | #34511 and #44662                           |\r\n\r\n`impl Trait` is a long awaited feature that allows one to describe types by the traits that they implement. For example, a function like `fn foo(args: impl Iterator<Item = u32>)` declares a function `foo` that takes an iterator of `u32` of argument; `impl Trait` can also be used in return position. Currently, `impl Trait` is limited to function signatures and cannot be used in traits or trait impls. In the future, we aim to support the notation in more places. \r\n\r\n`dyn Trait` is a simple syntactic change: whereas a trait object type used to be written as something like `&Write` (where `Write` is a trait), it is now preferred to write `&dyn Write`, which helps to make clear that (a) `Write` is a trait and (b) that method calls on `Write` will employ dynamic dispatch.\r\n\r\nTogether, these two features help to both grow expressiveness, and to address a common point of user confusion about the role of traits and types. In particular, when using these keywords, a *trait* is never used directly as a type; rather one uses the `impl` or `dyn` keyword to select how to use \r\n\r\n**Examples**\r\n\r\n[Using `impl Trait` in argument position:](https://play.rust-lang.org/?gist=22050cdf69421b8e5f91358653feadbd&version=nightly)\r\n\r\n```rust\r\n#![feature(universal_impl_trait, conservative_impl_trait, dyn_trait)]\r\n\r\nfn apply(c: impl Fn(u32) -> u32, arg: u32) -> u32 {\r\n  // equivalent to `fn apply<F>(c: F, arg: u32) where F: Fn(u32) -> u32`\r\n  c(arg)\r\n}\r\n\r\nfn main() {\r\n  println!(\"{}\", apply(|x| x * 2, 22)); // prints 44\r\n}\r\n```\r\n\r\n[Using `impl Trait` in return position:](https://play.rust-lang.org/?gist=b3711b4eb6d66fbd431aa9ca1a22ac6f&version=nightly)\r\n\r\n```rust\r\n#![feature(universal_impl_trait, conservative_impl_trait, dyn_trait)]\r\n\r\nfn even_numbers() -> impl Iterator<Item = u32> {\r\n  (0..).map(|x| x * 2)\r\n}\r\n\r\nfn main() {\r\n  for x in even_numbers().take(5) {\r\n    println!(\"{}\", x);\r\n  }\r\n}\r\n```\r\n\r\n[Using `dyn Trait`:](https://play.rust-lang.org/?gist=910a5133023c606dc870f1620d9f9e7d&version=nightly)\r\n\r\n```rust\r\n#![feature(universal_impl_trait, conservative_impl_trait, dyn_trait)]\r\n\r\nfn apply(c: &dyn Fn(u32) -> u32, arg: u32) -> u32 {\r\n  c(arg)\r\n}\r\n\r\nfn main() {\r\n  println!(\"{}\", apply(&|x| x * 2, 22)); // prints 44\r\n}\r\n```\r\n\r\n**What\u2019s left to be done?**\r\n\r\nThere are still a few outstanding questions about the syntax, notably the precedence of `impl Trait`. You can get the full details at the tracking issues:\r\n\r\n- [impl Trait tracking issue](https://github.com/rust-lang/rust/issues/34511)\r\n- [dyn Trait tracking issue](https://github.com/rust-lang/rust/issues/44662)\r\n\r\n</details>\r\n\r\n<details>\r\n<summary>\r\n\u2705  Closures implementing `Clone` or `Copy`\r\n</summary>\r\n\r\n| Feature gates  | `#![feature(copy_closures, clone_closures)]`   |\r\n| -------------- | ---------------------------------------------- |\r\n| Tracking issue | https://github.com/rust-lang/rust/issues/44490 |\r\n\r\nClosures are now copyable / cloneable if the variables that they capture are copyable / cloneable. Note that non-move closures often borrow captured variables instead of taking ownership of them, and hence a closure may be `Copy` even if some of the variable that it uses are not (because it only requires a shared reference to them).\r\n\r\n**Examples**\r\n\r\n[(Try it on play.)](https://play.rust-lang.org/?gist=2c617557b88c26cfacba14d8e4167658&version=nightly)\r\n\r\n```rust\r\n#![feature(copy_closures, clone_closures)]\r\n\r\nfn main() {\r\n    let v = vec![1, 2, 3]; \r\n    \r\n    // this closure captures `v` by shared reference:\r\n    let v_len1 = || v.len();\r\n    \r\n    // therefore, it is `Copy`:\r\n    let v_len2 = v_len1;\r\n    \r\n    // and naturally also `Clone`:\r\n    let v_len3 = v_len1.clone();\r\n    \r\n    assert_eq!(v_len1(), v.len());\r\n    assert_eq!(v_len2(), v.len());\r\n    assert_eq!(v_len3(), v.len());\r\n}\r\n```\r\n\r\n**What\u2019s left to be done?**\r\n\r\nGain experience.\r\n\r\n</details>\r\n\r\n<details>\r\n<summary>\r\n\ud83d\udd34  Trait aliases\r\n</summary>\r\n\r\n| Feature gates  | `#![feature(trait_alias)]`                     |\r\n| -------------- | ---------------------------------------------- |\r\n| Tracking issue | https://github.com/rust-lang/rust/issues/41517 |\r\n\r\nTrait aliases allow you to make aliases for common used combinations of trait bounds and where-clauses, much like a type alias lets you have an alternate name for a commonly used type.\r\n\r\n**Example**\r\n\r\n(Since this feature is not fully implemented yet, example will not actually work.)\r\n\r\n```rust\r\n#![feature(trait_alias)]\r\n\r\ntrait SendWrite = Write + Send + Sync;\r\n\r\nfn foo<T: SendWrite>(t: &T) {\r\n    // ^^^^^^^^^^^^^ equivalent to `T: Write + Send + Sync`.\r\n}\r\n```\r\n\r\n**What\u2019s left to be done?**\r\n\r\nQuite a bit. Some of the parsing and infrastructure work [landed in nightly](https://github.com/rust-lang/rust/pull/45047), but the semantics are not yet implemented.\r\n\r\n</details>\r\n\r\n<details>\r\n<summary>\r\n\ud83d\udd34  Generic associated types\r\n</summary>\r\n\r\n| Feature gates  | `#![feature(generic_associated_types)]`        |\r\n| -------------- | ---------------------------------------------- |\r\n| Tracking issue | https://github.com/rust-lang/rust/issues/44265 |\r\n\r\nGeneric associated types allow associated types defined in traits to take lifetime or type parameters. This allows for common patterns like an `Iterable` trait which are currently quite difficult to do.\r\n\r\n**Example**\r\n\r\n(Since this feature is not fully implemented yet, example will not actually work.)\r\n\r\n```rust\r\nuse std::vec;\r\n\r\ntrait Iterable {\r\n    type Iterator<'a>;\r\n}\r\n\r\nimpl<T> Iterable for Vec<T> {\r\n    type Iterator<'a> = vec::Iter<'a, T>;\r\n}\r\n```\r\n\r\n**What\u2019s left to be done**\r\n\r\nThe parsing and various bits of the semantics are implemented, but there is still more to come. See the tracking issue.\r\n\r\n</details>\r\n\r\n## Error Handling\r\n\r\n<details>\r\n<summary>\r\n\u2705  `?` applied to `Option` and other types\r\n</summary>\r\n\r\n| Feature gates  | `#![feature(try_trait)]`, but not needed to use `?` with `Option` |\r\n| -------------- | ----------------------------------------------------------------- |\r\n| Tracking issue | https://github.com/rust-lang/rust/issues/42327                    |\r\n\r\nYou can now use the `?` operator in functions that return `Option`, not just `Result`. Furthermore, through [the (as yet unstable) `Try` trait](https://doc.rust-lang.org/std/ops/trait.Try.html), you can extend `?` to operate on types of your own.\r\n\r\n**Example**\r\n\r\n```rust\r\n/// Returns `None` if either `a` or `b` is `None`,\r\n/// but otherwise returns `a + b`.\r\nfn maybe_add(a: Option<u32>, b: Option<u32>) -> Option<u32> {\r\n    Some(a? + b?)\r\n}\r\n```\r\n\r\n**What\u2019s left to be done?**\r\n\r\nGain more experience with the `Try` trait.\r\n\r\n</details>\r\n\r\n<details>\r\n<summary>\r\n\u2705   `?` in `main()`\r\n</summary>\r\n\r\n| Feature gates  | `#![feature(termination_trait)]`               |\r\n| -------------- | ---------------------------------------------- |\r\n| Tracking issue | https://github.com/rust-lang/rust/issues/43301 |\r\n\r\nYou can now give `main()` alternative return types, notably including `Result` types. This enables the use of the `?` operator within `main()`. The goal is to support `?` also in unit tests, but this is not yet implemented. \r\n\r\n**Note:** Implemented in PR https://github.com/rust-lang/rust/pull/46479, which has not yet landed.\r\n\r\n**Example**\r\n\r\n```rust\r\nuse std::io::prelude::*;\r\nuse std::fs::File;\r\n\r\nfn main() -> io::Result<()> {\r\n    let mut file = File::create(\"foo.txt\")?;\r\n    file.write_all(b\"Hello, world!\")?;\r\n}\r\n```\r\n\r\n**What\u2019s left to be done?**\r\n\r\nOnce PR https://github.com/rust-lang/rust/pull/46479 lands, you should be able to use examples involving `main`. But the full design also allows for writing unit tests (`#[test]` fns) with `Result` return types as well.\r\n\r\n</details>\r\n\r\n\r\n## The Module System\r\n\r\n<details>\r\n<summary>\r\n\u2705  Nested groups in imports\r\n</summary>\r\n\r\n| Feature gates  | `#![feature(use_nested_groups)]`              |\r\n| -------------- | --------------------------------------------- |\r\n| Tracking issue | https://github.com/rust-lang/rust/issues/44494 |\r\n\r\nYou can now nest \u201cimport groups\u201d, making it easier to import many names from a single crate without breaking things into multiple `use` statements.\r\n\r\n**Example**\r\n\r\n[(Try it on play)](https://play.rust-lang.org/?gist=ac29045631d264a05b60fdf03af67d0a&version=nightly)\r\n\r\n```rust\r\n#![feature(use_nested_groups)]\r\n\r\nuse std::sync::{\r\n    Arc, \r\n    atomic::{AtomicBool, Ordering},\r\n};\r\n\r\nfn main() {\r\n    let c = Arc::new(AtomicBool::new(true));\r\n    let v = c.load(Ordering::SeqCst);\r\n    println!(\"v={:?}\", v);\r\n}\r\n```\r\n\r\n**What\u2019s left to be done?**\r\n\r\nGain experience, find bugs in the implementation.\r\n</details>\r\n\r\n<details>\r\n<summary>\r\n\ud83d\udc9b  Clarify and streamline paths\r\n</summary>\r\n\r\n| Feature gates  | `#![feature(crate_in_paths, crate_visibility_modifier, non_modrs_mods)]`\r\n| -------------- | ---------------------------------------------------------------------------------------------------- |\r\n| Lints | `#![warn(unreachable_pub)]` |\r\n| Tracking issue | https://github.com/rust-lang/rust/issues/44660 |\r\n\r\nThese changes seek to clarify and streamline Rust's story around paths and visibility for modules and crates. That story will look as follows:\r\n\r\n- Absolute paths should begin with a crate name, where the keyword `crate` refers to the current crate (other forms are linted, see below)\r\n    extern crate is no longer necessary, and is linted (see below); dependencies are available at the root unless shadowed.\r\n- The `crate` keyword also acts as a visibility modifier, equivalent to today's `pub(crate)`. Consequently, uses of bare `pub` on items that are not actually publicly exported are linted, suggesting `crate` visibility instead.\r\n- A `foo.rs` and `foo/` subdirectory may coexist; `mod.rs` is no longer needed when placing submodules in a subdirectory.\r\n\r\n**Example**\r\n\r\n**What\u2019s left to be done?**\r\n\r\n</details>\r\n\r\n\r\n  ", "closed_by": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/46889/reactions", "total_count": 141, "+1": 45, "-1": 0, "laugh": 0, "hooray": 40, "confused": 0, "heart": 56, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/46889/timeline", "performed_via_github_app": null, "state_reason": "completed"}