{"url": "https://api.github.com/repos/rust-lang/rust/issues/90601", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/90601/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/90601/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/90601/events", "html_url": "https://github.com/rust-lang/rust/issues/90601", "id": 1045446897, "node_id": "I_kwDOAAsO6M4-UEDx", "number": 90601, "title": "Compiler errors for auto traits can be very unhelpful, especially when combined with `min_specialization`.", "user": {"login": "BGR360", "id": 13339928, "node_id": "MDQ6VXNlcjEzMzM5OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/13339928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BGR360", "html_url": "https://github.com/BGR360", "followers_url": "https://api.github.com/users/BGR360/followers", "following_url": "https://api.github.com/users/BGR360/following{/other_user}", "gists_url": "https://api.github.com/users/BGR360/gists{/gist_id}", "starred_url": "https://api.github.com/users/BGR360/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BGR360/subscriptions", "organizations_url": "https://api.github.com/users/BGR360/orgs", "repos_url": "https://api.github.com/users/BGR360/repos", "events_url": "https://api.github.com/users/BGR360/events{/privacy}", "received_events_url": "https://api.github.com/users/BGR360/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 235791, "node_id": "MDU6TGFiZWwyMzU3OTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-diagnostics", "name": "A-diagnostics", "color": "f7e101", "default": false, "description": "Area: Messages for errors, warnings, and lints"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 2543602342, "node_id": "MDU6TGFiZWwyNTQzNjAyMzQy", "url": "https://api.github.com/repos/rust-lang/rust/labels/F-auto_traits", "name": "F-auto_traits", "color": "f9c0cc", "default": false, "description": "`#![feature(auto_traits)]`"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2021-11-05T04:37:38Z", "updated_at": "2021-11-07T06:43:34Z", "closed_at": "2021-11-07T06:43:34Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I have here a collection of scenarios where the compiler fails to produce a helpful error message in response to a missing auto trait implementation. All examples are done on `1.58.0-nightly`.\r\n\r\n## Why do I care?\r\n\r\nThis issue cost me the entirety of an afternoon as I attempted to track down the cause of a very vague error. I've provided a minimal repro of that particular scenario in Example 4.  Figuring out that it was due to a missing auto trait implementation was... not fun.\r\n\r\nThe root of the problem is that a type only a receives an auto trait implementation if the entire recursive closure of types that make it up implements the trait. If there is some unknown (to the user) negative impl somewhere deep inside that recursive closure of types, or (as was the case for me) there is some `Box<T: !Sized>`[^1] hidden somewhere in there, then the compiler needs to point out the offending type to the user, or otherwise leave them baffled as to what's going on.\r\n\r\n[^1]: I will say that it's remarkably unintuitive that non-sized types do not receive auto traits by default. I only ended up learning this when I stumbled across [this code](https://github.com/KomodoPlatform/atomicDEX-API/blob/mm2.1/mm2src/common/mm_error/mm_error.rs#L114-L116). There is no mention of this peculiarity in the [Unstable Book](https://doc.rust-lang.org/beta/unstable-book/language-features/auto-traits.html).\r\n\r\n## Example 1: Good\r\n\r\nBelow is an example where the compiler _does_ give a diagnostic that I find satisfactory:\r\n\r\n<details>\r\n<summary>Code</summary>\r\n\r\n```rust\r\n#![feature(auto_traits)]\r\n\r\nauto trait Something {}\r\n\r\nfn destroy<T: Something>(_: T) {\r\n    println!(\"Destroyed something!\");\r\n}\r\n\r\nstruct Stringy(Box<dyn ToString>);\r\n\r\nfn main() {\r\n    destroy(\"hello\");\r\n    destroy(Stringy(Box::new(\"hello\")));\r\n}\r\n```\r\n</details>\r\n\r\nThe compiler correctly identifies the offending type, `dyn ToString`:\r\n\r\n<details>\r\n<summary>Compile error</summary>\r\n\r\n```\r\nerror[E0277]: the trait bound `(dyn ToString + 'static): Something` is not satisfied in `Stringy`\r\n  --> src/main.rs:16:13\r\n   |\r\n16 |     destroy(Stringy(Box::new(\"hello\")));\r\n   |     ------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ within `Stringy`, the trait `Something` is not implemented for `(dyn ToString + 'static)`\r\n   |     |\r\n   |     required by a bound introduced by this call\r\n   |\r\n   = note: required because it appears within the type `*const (dyn ToString + 'static)`\r\n   = note: required because it appears within the type `Unique<(dyn ToString + 'static)>`\r\n   = note: required because it appears within the type `Box<(dyn ToString + 'static)>`\r\nnote: required because it appears within the type `Stringy`\r\n  --> src/main.rs:12:8\r\n   |\r\n12 | struct Stringy(Box<dyn ToString>);\r\n   |        ^^^^^^^\r\nnote: required by a bound in `destroy`\r\n  --> src/main.rs:5:15\r\n   |\r\n5  | fn destroy<T: Something>(_: T) {\r\n   |               ^^^^^^^^^ required by this bound in `destroy`\r\n```\r\n</details>\r\n\r\nhttps://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=3b256c12fe5979c5372ed94c3b4f939a\r\n\r\n## Example 2: What if it was a trait?\r\n\r\nThis example is like Example 1 but I've turned the `destroy` function into a trait, `Destroy`:\r\n\r\n<details>\r\n<summary>Code</summary>\r\n\r\n```rust\r\n#![feature(auto_traits)]\r\n\r\nauto trait Something {}\r\n\r\ntrait Destroy {\r\n    fn destroy(self);\r\n}\r\n\r\nimpl<T: Something> Destroy for T {\r\n    fn destroy(self) {\r\n        println!(\"Destroyed something!\");\r\n    }\r\n}\r\n\r\nstruct Stringy(Box<dyn ToString>);\r\n\r\nfn main() {\r\n    \"hello\".destroy();\r\n    Stringy(Box::new(\"hello\")).destroy();\r\n}\r\n```\r\n</details>\r\n\r\nWith this little change, suddenly the compiler has lost all context regarding `dyn ToString`:\r\n\r\n<details>\r\n<summary>Compile error</summary>\r\n\r\n```\r\nerror[E0599]: the method `destroy` exists for struct `Stringy`, but its trait bounds were not satisfied\r\n  --> src/main.rs:25:32\r\n   |\r\n21 | struct Stringy(Box<dyn ToString>);\r\n   | ----------------------------------\r\n   | |\r\n   | method `destroy` not found for this\r\n   | doesn't satisfy `Stringy: Destroy`\r\n   | doesn't satisfy `Stringy: Something`\r\n...\r\n25 |     Stringy(Box::new(\"hello\")).destroy();\r\n   |                                ^^^^^^^ method cannot be called on `Stringy` due to unsatisfied trait bounds\r\n   |\r\n   = note: the following trait bounds were not satisfied:\r\n           `Stringy: Something`\r\n           which is required by `Stringy: Destroy`\r\n           `&Stringy: Something`\r\n           which is required by `&Stringy: Destroy`\r\n           `&mut Stringy: Something`\r\n           which is required by `&mut Stringy: Destroy`\r\nnote: the following trait must be implemented\r\n  --> src/main.rs:5:1\r\n   |\r\n5  | auto trait Something {}\r\n   | ^^^^^^^^^^^^^^^^^^^^^^^\r\n```\r\n</details>\r\n\r\nhttps://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=72b138ae232c87f5b34e9d96f3aff0bd\r\n\r\n## Example 3: With specialization\r\n\r\nThis expands on Example 2 by adding a specialized implementation of `Destroy` using `feature(min_specialization)`:\r\n\r\n<details>\r\n<summary>Code</summary>\r\n\r\n```rust\r\n#![feature(auto_traits)]\r\n#![feature(min_specialization)]\r\n#![feature(rustc_attrs)]\r\n\r\nauto trait Something {}\r\n\r\ntrait Destroy {\r\n    fn destroy(self);\r\n}\r\n\r\nimpl<T: Something> Destroy for T {\r\n    default fn destroy(self) {\r\n        println!(\"Destroyed something!\");\r\n    }\r\n}\r\n\r\n#[rustc_specialization_trait]\r\ntrait Special {}\r\n\r\nimpl<T: Something + Special> Destroy for T {\r\n    fn destroy(self) {\r\n        println!(\"Destroyed something special!\");\r\n    }\r\n}\r\n\r\nstruct SpecialSomething(Box<dyn ToString>);\r\n\r\nimpl Special for SpecialSomething {}\r\n\r\nfn main() {\r\n    \"hello\".destroy();\r\n    SpecialSomething(Box::new(\"hello\")).destroy();\r\n}\r\n```\r\n</details>\r\n\r\nThe error message is even _less_ helpful!\r\n\r\n<details>\r\n<summary>Compile error</summary>\r\n\r\n```\r\nerror[E0599]: no method named `destroy` found for struct `SpecialSomething` in the current scope\r\n  --> src/main.rs:36:41\r\n   |\r\n31 | struct SpecialSomething(Box<dyn ToString>);\r\n   | ------------------------------------------- method `destroy` not found for this\r\n...\r\n36 |     SpecialSomething(Box::new(\"hello\")).destroy();\r\n   |                                         ^^^^^^^ method not found in `SpecialSomething`\r\n   |\r\n   = help: items from traits can only be used if the trait is implemented and in scope\r\nnote: `Destroy` defines an item `destroy`, perhaps you need to implement it\r\n  --> src/main.rs:7:1\r\n   |\r\n7  | trait Destroy {\r\n   | ^^^^^^^^^^^^^\r\n```\r\n</details>\r\n\r\nhttps://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=bc60361c1dbdcb0a26c128965def0239\r\n\r\n## Example 4: Specialization and Result\r\n\r\nThis is a representative example of what I was working on when I encountered these unhelpful errors:\r\n\r\nhttps://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=06c83fd106d7b7f9ac3b489a18459099\r\n\r\nMy project involves modifying `core::result::Result` to have specialized `FromResidual` behavior for error types that implement a certain trait. I then have a wrapper type in \"user space\" that wraps some arbitrary error type and implements the specialization trait.\r\n\r\nTo enable `?`-conversion from one wrapper to another, I provide a blanket `From` impl.  I utilize auto traits and negative impls to ensure that it does not collide with the blanket `From<T> for T` from the standard library.\r\n\r\nIf the wrapped error type does not receive the `NotSame` auto trait, then the blanket `From` impl fails to apply to it, which in turn makes the `FromResidual` impl fail to apply, and I get the error below:\r\n\r\n<details>\r\n<summary>Compile error</summary>\r\n\r\n```\r\nerror[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)\r\n   --> src/main.rs:112:13\r\n    |\r\n111 | / fn foo() -> Result<(), Special<ErrorA>> {\r\n112 | |     Ok(bar()?)\r\n    | |             ^ cannot use the `?` operator in a function that returns `Result<(), Special<ErrorA>>`\r\n113 | | }\r\n    | |_- this function should return `Result` or `Option` to accept `?`\r\n    |\r\n    = help: the trait `FromResidual<Result<Infallible, Special<ErrorB>>>` is not implemented for `Result<(), Special<ErrorA>>`\r\nnote: required by `from_residual`\r\n```\r\n</details>\r\n\r\nThis error message is even **_less_** helpful than the last, as it doesn't even mention any trait or type that is remotely related to my actual test code!\r\n\r\n---------------------------------------------------\r\n\r\nA few things seem clear here:\r\n1. The act of adding a specialized trait impl greatly degrades the compiler's ability to forward information about unimplemented auto traits.\r\n2. Even without specialization, the error messaging can be subpar.\r\n\r\nI'd be happy to take a stab at improving things here, but I do not know what part of the compiler is responsible for doing this sort of inference (if that's even the correct term to use).\r\n\r\ncc https://github.com/rust-lang/rust/issues/13231 https://github.com/rust-lang/rust/issues/31844 https://github.com/rust-lang/rust/pull/68970 \r\nmaybe also cc https://github.com/rust-lang/rust/issues/84277\r\n", "closed_by": {"login": "BGR360", "id": 13339928, "node_id": "MDQ6VXNlcjEzMzM5OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/13339928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BGR360", "html_url": "https://github.com/BGR360", "followers_url": "https://api.github.com/users/BGR360/followers", "following_url": "https://api.github.com/users/BGR360/following{/other_user}", "gists_url": "https://api.github.com/users/BGR360/gists{/gist_id}", "starred_url": "https://api.github.com/users/BGR360/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BGR360/subscriptions", "organizations_url": "https://api.github.com/users/BGR360/orgs", "repos_url": "https://api.github.com/users/BGR360/repos", "events_url": "https://api.github.com/users/BGR360/events{/privacy}", "received_events_url": "https://api.github.com/users/BGR360/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/90601/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/90601/timeline", "performed_via_github_app": null, "state_reason": "completed"}