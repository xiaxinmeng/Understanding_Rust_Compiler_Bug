{"url": "https://api.github.com/repos/rust-lang/rust/issues/54214", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/54214/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/54214/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/54214/events", "html_url": "https://github.com/rust-lang/rust/issues/54214", "id": 360158734, "node_id": "MDU6SXNzdWUzNjAxNTg3MzQ=", "number": 54214, "title": "Bounds check that should not be eliminated is", "user": {"login": "Ekleog", "id": 411447, "node_id": "MDQ6VXNlcjQxMTQ0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/411447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ekleog", "html_url": "https://github.com/Ekleog", "followers_url": "https://api.github.com/users/Ekleog/followers", "following_url": "https://api.github.com/users/Ekleog/following{/other_user}", "gists_url": "https://api.github.com/users/Ekleog/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ekleog/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ekleog/subscriptions", "organizations_url": "https://api.github.com/users/Ekleog/orgs", "repos_url": "https://api.github.com/users/Ekleog/repos", "events_url": "https://api.github.com/users/Ekleog/events{/privacy}", "received_events_url": "https://api.github.com/users/Ekleog/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2018-09-14T05:10:53Z", "updated_at": "2018-11-09T06:11:17Z", "closed_at": "2018-11-09T06:11:17Z", "author_association": "NONE", "active_lock_reason": null, "body": "Originally tested with `rustc 1.29.0-nightly (e94df4acb 2018-07-31)`. Also reproduced (for amd64, wasm didn't compile) with `rustc 1.30.0-nightly (90d36fb59 2018-09-13)` and `rustc 1.28.0-nightly (b907d9665 2018-06-13)`. The details below will concern the `rustc 1.29.0-nightly (e94df4acb 2018-07-31)`.\r\n\r\nThis issue appears to reproduce only with two crates and optimizations turned on. It may be an upstream LLVM issue, given I'm not sure whether `--emit=llvm-ir` already includes some LLVM-made optimizations or not. Basically, the issue is not there in `--emit=mir`, but is there in `--emit=llvm-ir`.\r\n\r\nWith the following code in crate `stuff`:\r\n```rust\r\n#![no_std]                                                              \r\n#![feature(panic_implementation)]                                       \r\n                                                                        \r\n#[panic_implementation]                                                 \r\nfn on_panic_loop(_unused: &core::panic::PanicInfo) -> ! {               \r\n    loop {}                                                             \r\n}                                                                       \r\n                                                                        \r\nmod ffi {                                                               \r\n    extern {                                                            \r\n        // Contract: fills buf and returns the number of bytes written  \r\n        pub fn read(buf: *mut [u8; 255]) -> u8;                         \r\n    }                                                                   \r\n}                                                                       \r\n                                                                        \r\n#[repr(C)]                                                              \r\npub struct Data {                                                       \r\n    buf: [u8; 255],                                                     \r\n    len: u8,                                                            \r\n}                                                                       \r\n                                                                        \r\nimpl Data {                                                             \r\n    pub fn new() -> Data {                                              \r\n        unsafe {                                                        \r\n            let mut buf = core::mem::uninitialized(); // also happens with [0; 255]\r\n            let len = ffi::read(&mut buf);                              \r\n            Data { buf, len }                                           \r\n        }                                                               \r\n    }                                                                   \r\n                                                                        \r\n    pub fn buf(&self) -> &[u8] {                                        \r\n        &self.buf[..self.len as usize]                                  \r\n    }                                                                   \r\n}                                                                       \r\n```\r\n\r\nAnd the following code into the main crate (that has `stuff` as a dependency):\r\n```rust\r\n#![no_std]\r\n\r\nextern crate stuff;\r\n\r\n#[no_mangle]\r\npub extern \"C\" fn process() -> u32 {\r\n    let data = stuff::Data::new();\r\n    data.buf()[0] as u32\r\n}\r\n```\r\n\r\nWith this in the main Cargo.toml:\r\n```toml\r\n[profile.release]\r\nlto = true\r\nincremental = false\r\nopt-level = \"z\"\r\npanic = \"abort\"\r\n\r\n[lib]\r\ncrate-type = [\"cdylib\"]\r\n```\r\n\r\nThen the following commands:\r\n```\r\n$ cargo build --target wasm32-unknown-unknown --release && wasm2wat target/wasm32-unknown-unknown/release/*.wasm\r\n$ cargo build --release && objdump -d target/release/*.so\r\n```\r\n\r\nBoth show code that has no bounds check:\r\n```\r\n$ cargo build --target wasm32-unknown-unknown --release && wasm2wat target/wasm32-unknown-unknown/release/*.wasm \r\n    Finished release [optimized] target(s) in 0.00s                                                                                                                                           \r\n(module\r\n  (type (;0;) (func (param i32) (result i32)))\r\n  (type (;1;) (func))\r\n  (type (;2;) (func (result i32)))\r\n  (import \"env\" \"read\" (func $read (type 0)))\r\n  (func $__wasm_call_ctors (type 1))\r\n  (func $process (type 2) (result i32)\r\n    (local i32 i32)\r\n    get_global 0\r\n    i32.const 256\r\n    i32.sub\r\n    tee_local 0\r\n    set_global 0\r\n    get_local 0\r\n    i32.const 1\r\n    i32.add\r\n    call $read\r\n    drop\r\n    get_local 0\r\n    i32.load8_u offset=1\r\n    set_local 1\r\n    get_local 0\r\n    i32.const 256\r\n    i32.add\r\n    set_global 0\r\n    get_local 1)\r\n  (table (;0;) 1 1 anyfunc)\r\n  (memory (;0;) 16)\r\n  (global (;0;) (mut i32) (i32.const 1048576))\r\n  (global (;1;) i32 (i32.const 1048576))\r\n  (global (;2;) i32 (i32.const 1048576))\r\n  (export \"memory\" (memory 0))\r\n  (export \"__heap_base\" (global 1))\r\n  (export \"__data_end\" (global 2))\r\n  (export \"process\" (func $process)))\r\n$ cargo build --release && objdump -d target/release/*.so\r\n    Finished release [optimized] target(s) in 0.00s                                                                                                                                           \r\n[snip]\r\nDisassembly of section .init:\r\n[snip]\r\nDisassembly of section .plt.got:\r\n[snip]\r\nDisassembly of section .text:\r\n[snip]\r\n000000000000054a <process>:\r\n 54a:\t53                   \tpush   %rbx\r\n 54b:\t48 81 ec 00 01 00 00 \tsub    $0x100,%rsp\r\n 552:\t48 8d 5c 24 01       \tlea    0x1(%rsp),%rbx\r\n 557:\t48 89 df             \tmov    %rbx,%rdi\r\n 55a:\te8 f1 fe ff ff       \tcallq  450 <read@plt>\r\n 55f:\t0f b6 03             \tmovzbl (%rbx),%eax\r\n 562:\t48 81 c4 00 01 00 00 \tadd    $0x100,%rsp\r\n 569:\t5b                   \tpop    %rbx\r\n 56a:\tc3                   \tretq   \r\n\r\nDisassembly of section .fini:\r\n[snip]\r\n```\r\n\r\nHowever, I would think a bounds check *is* required here, in case `len` is actually returned as 0, as the index to 0 would otherwise read into uninitialized memory (that should be safely hidden behind the `Data` interface)\r\n\r\nDo I miss something obvious?\r\n\r\nThe bounds check appears to disappear between MIR and LLVM IR:\r\n```\r\n// WARNING: This output format is intended for human consumers only\r\n// and is subject to change without notice. Knock yourself out.\r\nfn process() -> u32{\r\n    let mut _0: u32;                     // return place\r\n    scope 1 {\r\n    }\r\n    scope 2 {\r\n        let _1: stuff::Data;             // \"data\" in scope 2 at src/lib.rs:7:9: 7:13\r\n    }\r\n    let mut _2: u8;\r\n    let mut _3: &[u8];\r\n    let mut _4: &stuff::Data;\r\n    let mut _5: usize;\r\n    let mut _6: usize;\r\n    let mut _7: bool;\r\n\r\n    bb0: {                              \r\n        StorageLive(_1);                 // bb0[0]: scope 0 at src/lib.rs:7:9: 7:13\r\n        _1 = const stuff::Data::new() -> bb1; // bb0[1]: scope 0 at src/lib.rs:7:16: 7:34\r\n                                         // ty::Const\r\n                                         // + ty: fn() -> stuff::Data {stuff::Data::new}\r\n                                         // + val: Scalar(Bits { defined: 0, bits: 0 })\r\n                                         // mir::Constant\r\n                                         // + span: src/lib.rs:7:16: 7:32\r\n                                         // + ty: fn() -> stuff::Data {stuff::Data::new}\r\n                                         // + literal: Const { ty: fn() -> stuff::Data {stuff::Data::new}, val: Scalar(Bits { defined: 0, bits: 0 }) }\r\n    }\r\n\r\n    bb1: {                              \r\n        StorageLive(_2);                 // bb1[0]: scope 1 at src/lib.rs:8:5: 8:18\r\n        StorageLive(_3);                 // bb1[1]: scope 1 at src/lib.rs:8:5: 8:15\r\n        StorageLive(_4);                 // bb1[2]: scope 1 at src/lib.rs:8:5: 8:9\r\n        _4 = &_1;                        // bb1[3]: scope 1 at src/lib.rs:8:5: 8:9\r\n        _3 = const stuff::Data::buf(move _4) -> bb2; // bb1[4]: scope 1 at src/lib.rs:8:5: 8:15\r\n                                         // ty::Const\r\n                                         // + ty: for<'r> fn(&'r stuff::Data) -> &'r [u8] {stuff::Data::buf}\r\n                                         // + val: Scalar(Bits { defined: 0, bits: 0 })\r\n                                         // mir::Constant\r\n                                         // + span: src/lib.rs:8:5: 8:15\r\n                                         // + ty: for<'r> fn(&'r stuff::Data) -> &'r [u8] {stuff::Data::buf}\r\n                                         // + literal: Const { ty: for<'r> fn(&'r stuff::Data) -> &'r [u8] {stuff::Data::buf}, val: Scalar(Bits { defined: 0, bits: 0 }) }\r\n    }\r\n\r\n    bb2: {                              \r\n        StorageDead(_4);                 // bb2[0]: scope 1 at src/lib.rs:8:14: 8:15\r\n        StorageLive(_5);                 // bb2[1]: scope 1 at src/lib.rs:8:16: 8:17\r\n        _5 = const 0usize;               // bb2[2]: scope 1 at src/lib.rs:8:16: 8:17\r\n                                         // ty::Const\r\n                                         // + ty: usize\r\n                                         // + val: Scalar(Bits { defined: 64, bits: 0 })\r\n                                         // mir::Constant\r\n                                         // + span: src/lib.rs:8:16: 8:17\r\n                                         // + ty: usize\r\n                                         // + literal: Const { ty: usize, val: Scalar(Bits { defined: 64, bits: 0 }) }\r\n        _6 = Len((*_3));                 // bb2[3]: scope 1 at src/lib.rs:8:5: 8:18\r\n        _7 = Lt(_5, _6);                 // bb2[4]: scope 1 at src/lib.rs:8:5: 8:18\r\n        assert(move _7, \"index out of bounds: the len is move _6 but the index is _5\") -> bb3; // bb2[5]: scope 1 at src/lib.rs:8:5: 8:18\r\n    }\r\n\r\n    bb3: {                              \r\n        _2 = (*_3)[_5];                  // bb3[0]: scope 1 at src/lib.rs:8:5: 8:18\r\n        _0 = move _2 as u32 (Misc);      // bb3[1]: scope 1 at src/lib.rs:8:5: 8:25\r\n        StorageDead(_2);                 // bb3[2]: scope 1 at src/lib.rs:8:24: 8:25\r\n        StorageDead(_1);                 // bb3[3]: scope 0 at src/lib.rs:9:1: 9:2\r\n        StorageDead(_3);                 // bb3[4]: scope 0 at src/lib.rs:9:1: 9:2\r\n        return;                          // bb3[5]: scope 0 at src/lib.rs:9:2: 9:2\r\n    }\r\n}\r\n```\r\nbecomes\r\n```\r\n; Function Attrs: minsize nounwind optsize\r\ndefine i32 @process() unnamed_addr #0 {\r\nstart:\r\n  %0 = alloca [255 x i8], align 1\r\n  %1 = getelementptr inbounds [255 x i8], [255 x i8]* %0, i64 0, i64 0\r\n  call void @llvm.lifetime.start.p0i8(i64 255, i8* nonnull %1) #2, !noalias !574\r\n  call void @llvm.memset.p0i8.i64(i8* nonnull align 1 %1, i8 0, i64 255, i1 false) #2, !noalias !574\r\n  %2 = call zeroext i8 @read([255 x i8]* nonnull %0) #2, !noalias !574\r\n  %data.sroa.0.0.copyload = load i8, i8* %1, align 1\r\n  call void @llvm.lifetime.end.p0i8(i64 255, i8* nonnull %1) #2, !noalias !574\r\n  %3 = zext i8 %data.sroa.0.0.copyload to i32\r\n  ret i32 %3\r\n}\r\n```", "closed_by": {"login": "Ekleog", "id": 411447, "node_id": "MDQ6VXNlcjQxMTQ0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/411447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ekleog", "html_url": "https://github.com/Ekleog", "followers_url": "https://api.github.com/users/Ekleog/followers", "following_url": "https://api.github.com/users/Ekleog/following{/other_user}", "gists_url": "https://api.github.com/users/Ekleog/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ekleog/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ekleog/subscriptions", "organizations_url": "https://api.github.com/users/Ekleog/orgs", "repos_url": "https://api.github.com/users/Ekleog/repos", "events_url": "https://api.github.com/users/Ekleog/events{/privacy}", "received_events_url": "https://api.github.com/users/Ekleog/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/54214/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/54214/timeline", "performed_via_github_app": null, "state_reason": "completed"}