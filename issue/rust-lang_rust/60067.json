{"url": "https://api.github.com/repos/rust-lang/rust/issues/60067", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/60067/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/60067/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/60067/events", "html_url": "https://github.com/rust-lang/rust/issues/60067", "id": 434590698, "node_id": "MDU6SXNzdWU0MzQ1OTA2OTg=", "number": 60067, "title": "This macro generates tests which cause clippy to panic", "user": {"login": "lopopolo", "id": 860434, "node_id": "MDQ6VXNlcjg2MDQzNA==", "avatar_url": "https://avatars.githubusercontent.com/u/860434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lopopolo", "html_url": "https://github.com/lopopolo", "followers_url": "https://api.github.com/users/lopopolo/followers", "following_url": "https://api.github.com/users/lopopolo/following{/other_user}", "gists_url": "https://api.github.com/users/lopopolo/gists{/gist_id}", "starred_url": "https://api.github.com/users/lopopolo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lopopolo/subscriptions", "organizations_url": "https://api.github.com/users/lopopolo/orgs", "repos_url": "https://api.github.com/users/lopopolo/repos", "events_url": "https://api.github.com/users/lopopolo/events{/privacy}", "received_events_url": "https://api.github.com/users/lopopolo/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2019-04-18T04:58:56Z", "updated_at": "2019-04-18T05:14:03Z", "closed_at": "2019-04-18T05:12:37Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I am writing a macro to generate impls for some traits (in the manner of `TryFrom`) and test code. clippy panics when running `cargo clippy --all-targets`.\r\n\r\nI invoke the macro in the same crate that defines it like this:\r\n\r\n```rust\r\nuse crate::convert::fixnum::Int;\r\n\r\nmrb_nilable_impl!(bool as nilable_bool);\r\nmrb_nilable_impl!(Vec<u8> as nilable_byte_string);\r\n// TODO: nilable float\r\nmrb_nilable_impl!(Int as nilable_fixnum);\r\nmrb_nilable_impl!(String as nilable_string);\r\n```\r\n\r\nThis is the macro:\r\n\r\n```rust\r\n#[macro_export]\r\nmacro_rules! mrb_nilable_impl {\r\n    ($type:ty as $wrapper_module:ident) => {\r\n        #[allow(clippy::use_self)]\r\n        impl $crate::TryFromMrb<std::option::Option<$type>> for $crate::Value {\r\n            type From = $crate::Rust;\r\n            type To = $crate::Ruby;\r\n\r\n            unsafe fn try_from_mrb(\r\n                mrb: *mut $crate::sys::mrb_state,\r\n                value: std::option::Option<$type>,\r\n            ) -> std::result::Result<Self, $crate::convert::Error<Self::From, Self::To>> {\r\n                match value {\r\n                    std::option::Option::Some(value) => Self::try_from_mrb(mrb, value),\r\n                    std::option::Option::None => {\r\n                        std::result::Result::Ok(Self::new($crate::sys::mrb_sys_nil_value()))\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        #[allow(clippy::use_self)]\r\n        impl $crate::TryFromMrb<$crate::Value> for std::option::Option<$type> {\r\n            type From = $crate::Ruby;\r\n            type To = $crate::Rust;\r\n\r\n            unsafe fn try_from_mrb(\r\n                mrb: *mut $crate::sys::mrb_state,\r\n                value: $crate::Value,\r\n            ) -> std::result::Result<Self, $crate::convert::Error<Self::From, Self::To>> {\r\n                match value.ruby_type() {\r\n                    $crate::Ruby::Nil => std::result::Result::Ok(None),\r\n                    _ => <$type>::try_from_mrb(mrb, value).map(std::option::Option::Some),\r\n                }\r\n            }\r\n        }\r\n\r\n        #[cfg(test)]\r\n        mod $wrapper_module {\r\n            mod tests {\r\n                use quickcheck_macros::quickcheck;\r\n\r\n                use $crate::convert::*;\r\n                use $crate::value::*;\r\n\r\n                #[test]\r\n                fn fail_convert() {\r\n                    unsafe {\r\n                        let mrb = mrb_open();\r\n                        let context = mrbc_context_new(mrb);\r\n                        // get a mrb_value that can't be converted to a\r\n                        // primitive type.\r\n                        let code = \"Object.new\";\r\n                        let value = mrb_load_nstring_cxt(\r\n                            mrb,\r\n                            code.as_ptr() as *const i8,\r\n                            code.len(),\r\n                            context,\r\n                        );\r\n                        let value = Value::new(value);\r\n                        let result =\r\n                            <std::option::Option<$type>>::try_from_mrb(mrb, value).map(|_| ());\r\n                        mrb_close(mrb);\r\n                        assert_eq!(\r\n                            result.map_err(|e| e.from),\r\n                            std::result::Result::Err(Ruby::Object)\r\n                        );\r\n                    }\r\n                }\r\n\r\n                #[quickcheck]\r\n                fn convert_to_value(v: std::option::Option<$type>) -> bool\r\n                where\r\n                    $type: std::clone::Clone\r\n                        + std::cmp::PartialEq\r\n                        + TryFromMrb<Value, From = Ruby, To = Rust>,\r\n                    Value: TryFromMrb<std::option::Option<$type>, From = Rust, To = Ruby>,\r\n                    std::option::Option<$type>:\r\n                        std::clone::Clone + TryFromMrb<Value, From = Ruby, To = Rust>,\r\n                {\r\n                    unsafe {\r\n                        let mrb = mrb_open();\r\n                        let value = match Value::try_from_mrb(mrb, v.clone()) {\r\n                            std::result::Result::Ok(value) => value,\r\n                            // we don't care about inner conversion failures for `T`\r\n                            std::result::Result::Err(_) => return true,\r\n                        };\r\n                        let good = if let std::option::Option::Some(v) = v {\r\n                            <$type>::try_from_mrb(mrb, value).expect(\"convert\") == v\r\n                        } else {\r\n                            let inner = value.inner();\r\n                            mrb_sys_value_is_nil(inner)\r\n                        };\r\n                        mrb_close(mrb);\r\n                        good\r\n                    }\r\n                }\r\n\r\n                #[quickcheck]\r\n                fn roundtrip(v: std::option::Option<$type>) -> bool\r\n                where\r\n                    $type: std::clone::Clone\r\n                        + std::cmp::PartialEq\r\n                        + TryFromMrb<Value, From = Ruby, To = Rust>,\r\n                    Value: TryFromMrb<std::option::Option<$type>, From = Rust, To = Ruby>,\r\n                    std::option::Option<$type>:\r\n                        std::clone::Clone + TryFromMrb<Value, From = Ruby, To = Rust>,\r\n                {\r\n                    unsafe {\r\n                        let mrb = mrb_open();\r\n                        let value = match Value::try_from_mrb(mrb, v.clone()) {\r\n                            std::result::Result::Ok(value) => value,\r\n                            // we don't care about inner conversion failures for `T`\r\n                            std::result::Result::Err(_) => return true,\r\n                        };\r\n                        let good = <std::option::Option<$type>>::try_from_mrb(mrb, value)\r\n                            .expect(\"convert\")\r\n                            == v;\r\n                        mrb_close(mrb);\r\n                        good\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n}\r\n```\r\n\r\nI have a similar macro which impls the same traits on Vec which does not crash clippy:\r\n\r\n```rust\r\n#[macro_export]\r\nmacro_rules! mrb_array_impl {\r\n    ($type:ty as $wrapper_module:ident) => {\r\n        #[allow(clippy::use_self)]\r\n        impl $crate::TryFromMrb<std::vec::Vec<$type>> for $crate::Value {\r\n            type From = $crate::Rust;\r\n            type To = $crate::Ruby;\r\n\r\n            unsafe fn try_from_mrb(\r\n                mrb: *mut $crate::sys::mrb_state,\r\n                value: std::vec::Vec<$type>,\r\n            ) -> std::result::Result<Self, $crate::convert::Error<Self::From, Self::To>> {\r\n                use std::convert::TryFrom;\r\n                let size = i64::try_from(value.len()).map_err(|_| $crate::convert::Error {\r\n                    from: $crate::Rust::Vec,\r\n                    to: $crate::Ruby::Array,\r\n                })?;\r\n                let array = $crate::sys::mrb_ary_new_capa(mrb, size);\r\n                for (i, item) in value.into_iter().enumerate() {\r\n                    let idx = i64::try_from(i).map_err(|_| $crate::convert::Error {\r\n                        from: $crate::Rust::Vec,\r\n                        to: $crate::Ruby::Array,\r\n                    })?;\r\n                    let ary_item = Self::try_from_mrb(mrb, item)?;\r\n                    let inner = ary_item.inner();\r\n                    $crate::sys::mrb_ary_set(mrb, array, idx, inner);\r\n                }\r\n                std::result::Result::Ok(Self::new(array))\r\n            }\r\n        }\r\n\r\n        #[allow(clippy::use_self)]\r\n        impl $crate::TryFromMrb<$crate::Value> for std::vec::Vec<$type> {\r\n            type From = $crate::Ruby;\r\n            type To = $crate::Rust;\r\n\r\n            unsafe fn try_from_mrb(\r\n                mrb: *mut $crate::sys::mrb_state,\r\n                value: $crate::Value,\r\n            ) -> std::result::Result<Self, $crate::convert::Error<Self::From, Self::To>> {\r\n                use std::convert::TryFrom;\r\n                match value.ruby_type() {\r\n                    $crate::Ruby::Array => {\r\n                        let inner = value.inner();\r\n                        let len = $crate::sys::mrb_sys_ary_len(inner);\r\n                        let cap = usize::try_from(len).map_err(|_| $crate::convert::Error {\r\n                            from: $crate::Ruby::Array,\r\n                            to: $crate::Rust::Vec,\r\n                        })?;\r\n                        let mut vec = Self::with_capacity(cap);\r\n                        for i in 0..cap {\r\n                            let idx = i64::try_from(i).map_err(|_| $crate::convert::Error {\r\n                                from: $crate::Ruby::Array,\r\n                                to: $crate::Rust::Vec,\r\n                            })?;\r\n                            let item =\r\n                                $crate::Value::new($crate::sys::mrb_ary_ref(mrb, inner, idx));\r\n                            vec.push(<$type>::try_from_mrb(mrb, item)?);\r\n                        }\r\n                        std::result::Result::Ok(vec)\r\n                    }\r\n                    type_tag => std::result::Result::Err($crate::convert::Error {\r\n                        from: type_tag,\r\n                        to: $crate::Rust::Vec,\r\n                    }),\r\n                }\r\n            }\r\n        }\r\n\r\n        #[cfg(test)]\r\n        mod $wrapper_module {\r\n            mod tests {\r\n                use quickcheck_macros::quickcheck;\r\n                use std::convert::TryFrom;\r\n\r\n                use $crate::convert::*;\r\n                use $crate::value::*;\r\n\r\n                #[test]\r\n                fn fail_convert() {\r\n                    unsafe {\r\n                        let mrb = mrb_open();\r\n                        let value = Value::new(mrb_sys_true_value());\r\n                        let expected = Error {\r\n                            from: Ruby::Bool,\r\n                            to: Rust::Vec,\r\n                        };\r\n                        let result = <std::vec::Vec<$type>>::try_from_mrb(mrb, value).map(|_| ());\r\n                        mrb_close(mrb);\r\n                        assert_eq!(result, Err(expected));\r\n                    }\r\n                }\r\n\r\n                #[allow(clippy::needless_pass_by_value)]\r\n                #[quickcheck]\r\n                fn convert_to_value(v: std::vec::Vec<$type>) -> bool\r\n                where\r\n                    $type: std::clone::Clone\r\n                        + std::cmp::PartialEq\r\n                        + TryFromMrb<Value, From = Ruby, To = Rust>,\r\n                    Value: TryFromMrb<std::vec::Vec<$type>, From = Rust, To = Ruby>,\r\n                    std::vec::Vec<$type>:\r\n                        std::clone::Clone + TryFromMrb<Value, From = Ruby, To = Rust>,\r\n                {\r\n                    unsafe {\r\n                        let mrb = mrb_open();\r\n                        let value = match Value::try_from_mrb(mrb, v.clone()) {\r\n                            std::result::Result::Ok(value) => value,\r\n                            // we don't care about inner conversion failures for `T`\r\n                            std::result::Result::Err(_) => return true,\r\n                        };\r\n                        let inner = value.inner();\r\n                        let size = i64::try_from(v.len()).expect(\"vec size\");\r\n                        let good = mrb_sys_ary_len(inner) == size;\r\n                        mrb_close(mrb);\r\n                        good\r\n                    }\r\n                }\r\n\r\n                #[allow(clippy::needless_pass_by_value)]\r\n                #[quickcheck]\r\n                fn roundtrip(v: std::vec::Vec<$type>) -> bool\r\n                where\r\n                    $type: std::clone::Clone\r\n                        + std::cmp::PartialEq\r\n                        + TryFromMrb<Value, From = Ruby, To = Rust>,\r\n                    Value: TryFromMrb<std::vec::Vec<$type>, From = Rust, To = Ruby>,\r\n                    std::vec::Vec<$type>:\r\n                        std::clone::Clone + TryFromMrb<Value, From = Ruby, To = Rust>,\r\n                {\r\n                    unsafe {\r\n                        let mrb = mrb_open();\r\n                        let value = match Value::try_from_mrb(mrb, v.clone()) {\r\n                            std::result::Result::Ok(value) => value,\r\n                            // we don't care about inner conversion failures for `T`\r\n                            std::result::Result::Err(_) => return true,\r\n                        };\r\n                        let good =\r\n                            <std::vec::Vec<$type>>::try_from_mrb(mrb, value).expect(\"convert\") == v;\r\n                        mrb_close(mrb);\r\n                        good\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n}\r\n```\r\n\r\n## Meta\r\n\r\nVersion\r\n\r\n```\r\n$ rustc --version --verbose\r\nrustc 1.35.0-nightly (88f755f8a 2019-03-07)\r\nbinary: rustc\r\ncommit-hash: 88f755f8a84df1d9e6b17cf10c96ae8b93481b2e\r\ncommit-date: 2019-03-07\r\nhost: x86_64-apple-darwin\r\nrelease: 1.35.0-nightly\r\nLLVM version: 8.0\r\n```\r\n\r\nBacktrace:\r\n\r\n```\r\n$ RUST_BACKTRACE=1 cargo clippy --all-targets\r\n    Checking mruby v0.1.0 (/Users/lopopolo/dev/repos/rube/mruby)\r\nthread 'rustc' panicked at 'there must be a `else` here', src/libcore/option.rs:1038:5\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\nstack backtrace:\r\n   0: std::sys::unix::backtrace::tracing::imp::unwind_backtrace\r\n   1: std::sys_common::backtrace::_print\r\n   2: std::panicking::default_hook::{{closure}}\r\n   3: std::panicking::default_hook\r\n   4: rustc::util::common::panic_hook\r\n   5: std::panicking::rust_panic_with_hook\r\n   6: std::panicking::continue_panic_fmt\r\n   7: rust_begin_unwind\r\n   8: core::panicking::panic_fmt\r\n   9: core::option::expect_failed\r\n  10: <clippy_lints::formatting::Formatting as rustc::lint::EarlyLintPass>::check_expr\r\n  11: <rustc::lint::context::EarlyLintPassObjects<'_> as rustc::lint::EarlyLintPass>::check_expr\r\n  12: <rustc::lint::context::EarlyContextAndPass<'a, T> as syntax::visit::Visitor<'a>>::visit_expr\r\n  13: <rustc::lint::context::EarlyContextAndPass<'a, T> as syntax::visit::Visitor<'a>>::visit_local\r\n  14: syntax::visit::walk_expr\r\n  15: <rustc::lint::context::EarlyContextAndPass<'a, T> as syntax::visit::Visitor<'a>>::visit_expr\r\n  16: syntax::visit::walk_fn\r\n  17: syntax::visit::walk_item\r\n  18: <rustc::lint::context::EarlyContextAndPass<'a, T> as syntax::visit::Visitor<'a>>::visit_item\r\n  19: syntax::visit::walk_fn\r\n  20: syntax::visit::walk_item\r\n  21: <rustc::lint::context::EarlyContextAndPass<'a, T> as syntax::visit::Visitor<'a>>::visit_item\r\n  22: syntax::visit::walk_item\r\n  23: <rustc::lint::context::EarlyContextAndPass<'a, T> as syntax::visit::Visitor<'a>>::visit_item\r\n  24: syntax::visit::walk_item\r\n  25: <rustc::lint::context::EarlyContextAndPass<'a, T> as syntax::visit::Visitor<'a>>::visit_item\r\n  26: syntax::visit::walk_item\r\n  27: <rustc::lint::context::EarlyContextAndPass<'a, T> as syntax::visit::Visitor<'a>>::visit_item\r\n  28: syntax::visit::walk_item\r\n  29: syntax::visit::walk_crate\r\n  30: rustc::lint::context::early_lint_crate\r\n  31: rustc::lint::context::check_ast_crate\r\n  32: rustc::util::common::time\r\n  33: rustc_driver::driver::compile_input\r\n  34: rustc_driver::run_compiler_with_pool\r\n  35: <scoped_tls::ScopedKey<T>>::set\r\n  36: rustc_driver::run_compiler\r\n  37: <scoped_tls::ScopedKey<T>>::set\r\nquery stack during panic:\r\nend of query stack\r\n\r\nerror: internal compiler error: unexpected panic\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.35.0-nightly (88f755f8a 2019-03-07) running on x86_64-apple-darwin\r\n\r\nnote: compiler flags: -C debuginfo=2 -C incremental\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nerror: Could not compile `mruby`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```", "closed_by": {"login": "lopopolo", "id": 860434, "node_id": "MDQ6VXNlcjg2MDQzNA==", "avatar_url": "https://avatars.githubusercontent.com/u/860434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lopopolo", "html_url": "https://github.com/lopopolo", "followers_url": "https://api.github.com/users/lopopolo/followers", "following_url": "https://api.github.com/users/lopopolo/following{/other_user}", "gists_url": "https://api.github.com/users/lopopolo/gists{/gist_id}", "starred_url": "https://api.github.com/users/lopopolo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lopopolo/subscriptions", "organizations_url": "https://api.github.com/users/lopopolo/orgs", "repos_url": "https://api.github.com/users/lopopolo/repos", "events_url": "https://api.github.com/users/lopopolo/events{/privacy}", "received_events_url": "https://api.github.com/users/lopopolo/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/60067/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/60067/timeline", "performed_via_github_app": null, "state_reason": "completed"}