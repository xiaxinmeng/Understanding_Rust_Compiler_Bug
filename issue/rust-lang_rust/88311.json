{"url": "https://api.github.com/repos/rust-lang/rust/issues/88311", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/88311/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/88311/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/88311/events", "html_url": "https://github.com/rust-lang/rust/issues/88311", "id": 978597538, "node_id": "MDU6SXNzdWU5Nzg1OTc1Mzg=", "number": 88311, "title": "Error for self-referential type parameter bounds appears in presumptuous circumstances and is unclear", "user": {"login": "Wtoll", "id": 68982715, "node_id": "MDQ6VXNlcjY4OTgyNzE1", "avatar_url": "https://avatars.githubusercontent.com/u/68982715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Wtoll", "html_url": "https://github.com/Wtoll", "followers_url": "https://api.github.com/users/Wtoll/followers", "following_url": "https://api.github.com/users/Wtoll/following{/other_user}", "gists_url": "https://api.github.com/users/Wtoll/gists{/gist_id}", "starred_url": "https://api.github.com/users/Wtoll/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Wtoll/subscriptions", "organizations_url": "https://api.github.com/users/Wtoll/orgs", "repos_url": "https://api.github.com/users/Wtoll/repos", "events_url": "https://api.github.com/users/Wtoll/events{/privacy}", "received_events_url": "https://api.github.com/users/Wtoll/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2021-08-25T00:48:56Z", "updated_at": "2023-02-12T08:55:34Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "According to [RFC-0447](https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md) type parameters cannot be bound self-referentially. The justification for this is that \"impls like this, when used, tend to result in overflow in the compiler, but it's more user-friendly to report an error earlier.\"\r\n\r\nThere are two issues with this assumption:\r\n1. The error that is thrown ([E0207](https://doc.rust-lang.org/error-index.html#E0207)) makes no mention of self-referential bounds making it really confusing to debug this error when it shows up\r\n2. With the addition of nightly features such as `const_evaluatable_checked` (and potentially `specialization`) it is now possible to write self-referential trait implementations that would not in fact cause an overflow in the compiler. One can imagine a generic struct that takes a `const U: usize`, has a trait defined for `U = 1`, and then recursively derives implementations for higher `U` values using the implementation for `U = 1` (not entirely sure if specialization would be _required_ for this). Under the current compiler rules code such as this would not compile.\r\n\r\n### What Should Be Done About This\r\n\r\nAt the very least, self-referential type parameter bounds should get their own compiler error. As previously mentioned, the current compiler error makes no mention of self-referential bounds. This makes it really confusing to try and troubleshoot this issue if you're a newcomer to the language, and even in scenarios in which type parameter bounds are more complicated. \r\n\r\nHowever, I believe that having a compiler error for this issue is not the proper path to take. As mentioned above, if my understanding of some nightly features is correct, it's now possible to write self-referential type parameter bounds that **ought** not overflow at compile-time (they might, but that's not necessarily a problem with the code, but potentially a problem with the compiler), however it's currently impossible to check those scenarios because the compiler will throw an error instead of even attempting to resolve them. It's my opinion that the compiler should no longer throw [E0207](https://doc.rust-lang.org/error-index.html#E0207) for self-referential type parameter bounds, and instead there should be a compiler warning that the code may potentially overflow the compiler, but then proceed in attempting to resolve the implementation anyways. The result is that valid self-referential implementations can be written and will hopefully compile properly, and improper self-referential implementations will overflow the compiler along with a warning explaining a potential reason why the compiler overflowed.\r\n\r\n### Related To\r\nIssue #76560\r\nPotentially Issue #31844", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/88311/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/88311/timeline", "performed_via_github_app": null, "state_reason": null}