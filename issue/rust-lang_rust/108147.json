{"url": "https://api.github.com/repos/rust-lang/rust/issues/108147", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/108147/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/108147/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/108147/events", "html_url": "https://github.com/rust-lang/rust/issues/108147", "id": 1588587779, "node_id": "I_kwDOAAsO6M5er-0D", "number": 108147, "title": "Condvar missing wake ups.", "user": {"login": "cconstantine", "id": 14189, "node_id": "MDQ6VXNlcjE0MTg5", "avatar_url": "https://avatars.githubusercontent.com/u/14189?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cconstantine", "html_url": "https://github.com/cconstantine", "followers_url": "https://api.github.com/users/cconstantine/followers", "following_url": "https://api.github.com/users/cconstantine/following{/other_user}", "gists_url": "https://api.github.com/users/cconstantine/gists{/gist_id}", "starred_url": "https://api.github.com/users/cconstantine/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cconstantine/subscriptions", "organizations_url": "https://api.github.com/users/cconstantine/orgs", "repos_url": "https://api.github.com/users/cconstantine/repos", "events_url": "https://api.github.com/users/cconstantine/events{/privacy}", "received_events_url": "https://api.github.com/users/cconstantine/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 9695584, "node_id": "MDU6TGFiZWw5Njk1NTg0", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-concurrency", "name": "A-concurrency", "color": "f7e101", "default": false, "description": "Area: Concurrency related issues."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}, {"id": 2011781731, "node_id": "MDU6TGFiZWwyMDExNzgxNzMx", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs", "name": "T-libs", "color": "bfd4f2", "default": false, "description": "Relevant to the library team, which will review and decide on the PR/issue."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2023-02-17T00:43:02Z", "updated_at": "2023-03-02T23:01:04Z", "closed_at": "2023-03-02T09:34:50Z", "author_association": "NONE", "active_lock_reason": null, "body": "While working with `std::sync::Condvar` to create a threaded syncronization system I think I've encountered a situation where a Condvar can miss wake ups triggered by `.notify_one()` and `.notify_all()` when waiting for a specific condition to be met.\r\n\r\nI suspect this is caused by the `.wait()` and `.wait_timeout()` methods not atomically unlocking/locking the mutex when waiting / waking.  The [docs](https://doc.rust-lang.org/stable/std/sync/struct.Condvar.html#method.wait) for Condvar state: \"This function will atomically unlock the mutex specified (represented by guard) and block the current thread.\"  Of note, it doesn't state something similar for locking the mutex and waking (The C++ [docs](https://en.cppreference.com/w/cpp/thread/condition_variable) do indicate this).  I think it is necessary for the the mutex to be atomically locked with the thread waking, otherwise it will be possible to miss important notifies when spurious wakes happen, or if the desired condition isn't met after the first `notify` is called. I haven't been able to confirm this is the problem, or fix it in the rust implementation of condition variables.\r\n\r\nI tried this code:\r\nhttps://play.rust-lang.org/?version=stable&mode=release&edition=2021&gist=f48827f25042ae134724922b90055385\r\n```rust\r\n#[test]\r\nfn test_condvar() {\r\n    use std::{\r\n        sync::{Arc, Condvar, Mutex},\r\n        thread,\r\n        time::Duration,\r\n    };\r\n\r\n\r\n    // This test will run a loop in a background\r\n    //  thread LOOP_TO times.  Each iteration it\r\n    //  will increment the shared mutex and notify\r\n    //  the condvar of each change.\r\n    // The main thread will wait for the mutex's value\r\n    //  to reach LOOP_TO and keep track of how many\r\n    //  times it was woken up.  It should wake at least\r\n    //  LOOP_TO times.\r\n    const LOOP_TO: u32 = 100;\r\n    let mut wakes = 0;\r\n    \r\n    let pair = Arc::new((Mutex::new(0 as u32), Condvar::new()));\r\n    let pair2 = Arc::clone(&pair);\r\n    \r\n    // Lock the mutex before starting the background thread to\r\n    //  prevent the it from ripping through the loop before\r\n    //  this thread can wait on the Condvar.\r\n    let (outer, outer_cvar) = &*pair2;\r\n    let mut outer_lock = outer.lock().unwrap();\r\n    \r\n    thread::spawn(move || {\r\n        let (lock, cvar) = &*pair;\r\n        for i in 1..=LOOP_TO {\r\n            dbg!(&i);\r\n            {\r\n                let mut started = lock.lock().unwrap();\r\n                *started = i;\r\n            }\r\n            // We notify the condvar that the value has changed.\r\n            cvar.notify_one();\r\n        }\r\n    });\r\n\r\n    while *outer_lock != LOOP_TO {\r\n        dbg!(*outer_lock);\r\n        let timeout;\r\n        // Wait for condvar to be notified.\r\n        (outer_lock, timeout) = outer_cvar.wait_timeout(outer_lock, Duration::from_secs(11)).unwrap();\r\n        assert!(!timeout.timed_out());\r\n        wakes +=1;\r\n    }\r\n    \r\n    dbg!(wakes, LOOP_TO);\r\n    assert!(wakes >= LOOP_TO);\r\n}\r\n```\r\n\r\n### I expected to see this happen:\r\nI expect to see alternating `dbg!` outputs of `*outer_lock`'s value from the test thread, and `&i`'s value from the background thread.  Then, after `LOOP_TO` iterations the `wakes` variable should equal `LOOP_TO`.  This would mean that the test thread woke for every `notify_one()` in the background thread.\r\n\r\n### Instead, this happened:\r\nNot ever time, but frequently, there are missing outputs from `dbg!(*outer_lock)`, and `wakes` is less than `LOOP_TO`.  This indicates to me that the test thread missed triggers to `cvar.notify_one()`.  Adding sleeps can make this test reliably pass and removing the `dbg!` statements will make it more likely to happen, indicating to me that the condition variable and mutexs aren't completely eliminating a race condition of some kind.\r\n\r\n### System information:\r\n```\r\n$ rustc --version --verbose\r\nrustc 1.67.1 (d5a82bbd2 2023-02-07)\r\nbinary: rustc\r\ncommit-hash: d5a82bbd26e1ad8b7401f6a718a9c57c96905483\r\ncommit-date: 2023-02-07\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.67.1\r\nLLVM version: 15.0.6\r\n\r\n$ cat /proc/version\r\nLinux version 5.16.0-3-amd64 (debian-kernel@lists.debian.org) (gcc-11 (Debian 11.2.0-18) 11.2.0, GNU ld (GNU Binutils for Debian) 2.38) #1 SMP PREEMPT Debian 5.16.11-1 (2022-02-25)\r\n```\r\n\r\n### Discussion\r\nBefore making this report I asked about this behavior in the #contribute channel in Discord [here](https://discord.com/channels/442252698964721669/487245758739906560/1075878915962318899).  ", "closed_by": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/108147/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/108147/timeline", "performed_via_github_app": null, "state_reason": "completed"}