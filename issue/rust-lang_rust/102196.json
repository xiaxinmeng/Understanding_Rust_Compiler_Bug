{"url": "https://api.github.com/repos/rust-lang/rust/issues/102196", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/102196/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/102196/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/102196/events", "html_url": "https://github.com/rust-lang/rust/issues/102196", "id": 1383979650, "node_id": "I_kwDOAAsO6M5SfdqC", "number": 102196, "title": "Segmentation fault when formatting u128 on aarch64 GNU/Linux", "user": {"login": "prestontimmons", "id": 207051, "node_id": "MDQ6VXNlcjIwNzA1MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/207051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/prestontimmons", "html_url": "https://github.com/prestontimmons", "followers_url": "https://api.github.com/users/prestontimmons/followers", "following_url": "https://api.github.com/users/prestontimmons/following{/other_user}", "gists_url": "https://api.github.com/users/prestontimmons/gists{/gist_id}", "starred_url": "https://api.github.com/users/prestontimmons/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/prestontimmons/subscriptions", "organizations_url": "https://api.github.com/users/prestontimmons/orgs", "repos_url": "https://api.github.com/users/prestontimmons/repos", "events_url": "https://api.github.com/users/prestontimmons/events{/privacy}", "received_events_url": "https://api.github.com/users/prestontimmons/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 55301954, "node_id": "MDU6TGFiZWw1NTMwMTk1NA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/O-Arm", "name": "O-Arm", "color": "6e6ec0", "default": false, "description": "Target: 32-bit Arm processors (armv6, armv7, thumb...), including 64-bit Arm in AArch32 state"}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2022-09-23T15:33:35Z", "updated_at": "2022-09-25T19:53:19Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "Hello, we've noticed segmentation faults when running Rust binaries compiled on aarch64 GNU/Linux. We've seen this occur in multiple libraries that format or print `SystemTime`.\r\n\r\nArchitecture:\r\n\r\n`uname -a`\r\n```\r\n5.10.135-122.509.amzn2.aarch64 #1 SMP Thu Aug 11 22:41:14 UTC 2022 aarch64 GNU/Linux\r\n```\r\n\r\nReproducible example:\r\n\r\n```rust\r\nfn main() {\r\n    let millis: u128 = 87329875;\r\n    println!(\"{}\", millis);\r\n}\r\n```\r\n\r\nThe segmentation fault occurs when fmt_u128 is called.\r\n\r\nI tested this on 1.62.0 and nightly:\r\n\r\n```\r\n/builds/scratch# cargo run\r\n    Finished dev [unoptimized + debuginfo] target(s) in 0.23s\r\n     Running `target/debug/scratch`\r\nSegmentation fault (core dumped)\r\n\r\n# rustc --version --verbose\r\nrustc 1.62.0 (a8314ef7d 2022-06-27)\r\nbinary: rustc\r\ncommit-hash: a8314ef7d0ec7b75c336af2c9857bfaf43002bfc\r\ncommit-date: 2022-06-27\r\nhost: aarch64-unknown-linux-gnu\r\nrelease: 1.62.0\r\nLLVM version: 14.0.5\r\n```\r\n\r\n```\r\n# cargo +nightly run\r\n    Finished dev [unoptimized + debuginfo] target(s) in 0.24s\r\n     Running `target/debug/scratch`\r\nSegmentation fault (core dumped)\r\n\r\n# rustc +nightly --version --verbose\r\nrustc 1.66.0-nightly (e7119a030 2022-09-22)\r\nbinary: rustc\r\ncommit-hash: e7119a0300b87a3d670408ee8e847c6821b3ae80\r\ncommit-date: 2022-09-22\r\nhost: aarch64-unknown-linux-gnu\r\nrelease: 1.66.0-nightly\r\nLLVM version: 15.0.0\r\n```\r\n\r\nThe segmentation fault does not occur in release mode:\r\n\r\n```\r\n# cargo run --release\r\n    Finished release [optimized] target(s) in 0.23s\r\n     Running `target/release/scratch`\r\n87329875\r\n```\r\n\r\nIt also does not occur if opt-level is set to greater than 0:\r\n\r\n```\r\n[profile.dev]\r\nopt-level = 1\r\n```\r\n\r\nIt also does not occur on Darwin aarch64:\r\n\r\n`uname -a`\r\n```\r\nDarwin TC-4000660 21.6.0 Darwin Kernel Version 21.6.0: Wed Aug 10 14:28:23 PDT 2022; root:xnu-8020.141.5~2/RELEASE_ARM64_T6000 arm64\r\n```\r\n\r\n### Meta\r\n\r\nValgrind traceback:\r\n\r\n<!--\r\nInclude a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\r\nenvironment. E.g. `RUST_BACKTRACE=1 cargo build`.\r\n-->\r\n<details><summary>Backtrace</summary>\r\n<p>\r\n\r\n```\r\n# valgrind target/debug/scratch\r\n==5157== Memcheck, a memory error detector\r\n==5157== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==5157== Using Valgrind-3.16.1 and LibVEX; rerun with -h for copyright info\r\n==5157== Command: target/debug/scratch\r\n==5157== \r\n==5157== Invalid read of size 4\r\n==5157==    at 0x112474: alternate (mod.rs:1893)\r\n==5157==    by 0x112474: core::fmt::Formatter::pad_integral (mod.rs:1366)\r\n==5157==    by 0x111BBB: core::fmt::num::fmt_u128 (num.rs:641)\r\n==5157==    by 0x112347: core::fmt::write (mod.rs:1202)\r\n==5157==    by 0x15D5FB: write_fmt<std::io::stdio::StdoutLock> (mod.rs:1679)\r\n==5157==    by 0x15D5FB: <&std::io::stdio::Stdout as std::io::Write>::write_fmt (stdio.rs:715)\r\n==5157==    by 0x15E133: write_fmt (stdio.rs:689)\r\n==5157==    by 0x15E133: print_to<std::io::stdio::Stdout> (stdio.rs:1017)\r\n==5157==    by 0x15E133: std::io::stdio::_print (stdio.rs:1030)\r\n==5157==    by 0x10CDCB: scratch::main (main.rs:3)\r\n==5157==    by 0x10CEA3: core::ops::function::FnOnce::call_once (function.rs:251)\r\n==5157==    by 0x11B3AB: std::sys_common::backtrace::__rust_begin_short_backtrace (backtrace.rs:122)\r\n==5157==    by 0x17925F: std::rt::lang_start::{{closure}} (rt.rs:166)\r\n==5157==    by 0x15B38B: call_once<(), (dyn core::ops::function::Fn<(), Output=i32> + core::marker::Sync + core::panic::unwind_safe::RefUnwindSafe)> (function.rs:286)\r\n==5157==    by 0x15B38B: do_call<&(dyn core::ops::function::Fn<(), Output=i32> + core::marker::Sync + core::panic::unwind_safe::RefUnwindSafe), i32> (panicking.rs:464)\r\n==5157==    by 0x15B38B: try<i32, &(dyn core::ops::function::Fn<(), Output=i32> + core::marker::Sync + core::panic::unwind_safe::RefUnwindSafe)> (panicking.rs:428)\r\n==5157==    by 0x15B38B: catch_unwind<&(dyn core::ops::function::Fn<(), Output=i32> + core::marker::Sync + core::panic::unwind_safe::RefUnwindSafe), i32> (panic.rs:137)\r\n==5157==    by 0x15B38B: {closure#2} (rt.rs:148)\r\n==5157==    by 0x15B38B: do_call<std::rt::lang_start_internal::{closure_env#2}, isize> (panicking.rs:464)\r\n==5157==    by 0x15B38B: try<isize, std::rt::lang_start_internal::{closure_env#2}> (panicking.rs:428)\r\n==5157==    by 0x15B38B: catch_unwind<std::rt::lang_start_internal::{closure_env#2}, isize> (panic.rs:137)\r\n==5157==    by 0x15B38B: std::rt::lang_start_internal (rt.rs:148)\r\n==5157==    by 0x17922B: std::rt::lang_start (rt.rs:165)\r\n==5157==    by 0x10CE07: main (in /builds/scratch/target/debug/scratch)\r\n==5157==  Address 0x31 is not stack'd, malloc'd or (recently) free'd\r\n==5157== \r\n==5157== \r\n==5157== Process terminating with default action of signal 11 (SIGSEGV): dumping core\r\n==5157==  Access not within mapped region at address 0x57\r\n==5157==    at 0x112474: alternate (mod.rs:1893)\r\n==5157==    by 0x112474: core::fmt::Formatter::pad_integral (mod.rs:1366)\r\n==5157==    by 0x111BBB: core::fmt::num::fmt_u128 (num.rs:641)\r\n==5157==    by 0x112347: core::fmt::write (mod.rs:1202)\r\n==5157==    by 0x15D5FB: write_fmt<std::io::stdio::StdoutLock> (mod.rs:1679)\r\n==5157==    by 0x15D5FB: <&std::io::stdio::Stdout as std::io::Write>::write_fmt (stdio.rs:715)\r\n==5157==    by 0x15E133: write_fmt (stdio.rs:689)\r\n==5157==    by 0x15E133: print_to<std::io::stdio::Stdout> (stdio.rs:1017)\r\n==5157==    by 0x15E133: std::io::stdio::_print (stdio.rs:1030)\r\n==5157==    by 0x10CDCB: scratch::main (main.rs:3)\r\n==5157==    by 0x10CEA3: core::ops::function::FnOnce::call_once (function.rs:251)\r\n==5157==    by 0x11B3AB: std::sys_common::backtrace::__rust_begin_short_backtrace (backtrace.rs:122)\r\n==5157==    by 0x17925F: std::rt::lang_start::{{closure}} (rt.rs:166)\r\n==5157==    by 0x15B38B: call_once<(), (dyn core::ops::function::Fn<(), Output=i32> + core::marker::Sync + core::panic::unwind_safe::RefUnwindSafe)> (function.rs:286)\r\n==5157==    by 0x15B38B: do_call<&(dyn core::ops::function::Fn<(), Output=i32> + core::marker::Sync + core::panic::unwind_safe::RefUnwindSafe), i32> (panicking.rs:464)\r\n==5157==    by 0x15B38B: try<i32, &(dyn core::ops::function::Fn<(), Output=i32> + core::marker::Sync + core::panic::unwind_safe::RefUnwindSafe)> (panicking.rs:428)\r\n==5157==    by 0x15B38B: catch_unwind<&(dyn core::ops::function::Fn<(), Output=i32> + core::marker::Sync + core::panic::unwind_safe::RefUnwindSafe), i32> (panic.rs:137)\r\n==5157==    by 0x15B38B: {closure#2} (rt.rs:148)\r\n==5157==    by 0x15B38B: do_call<std::rt::lang_start_internal::{closure_env#2}, isize> (panicking.rs:464)\r\n==5157==    by 0x15B38B: try<isize, std::rt::lang_start_internal::{closure_env#2}> (panicking.rs:428)\r\n==5157==    by 0x15B38B: catch_unwind<std::rt::lang_start_internal::{closure_env#2}, isize> (panic.rs:137)\r\n==5157==    by 0x15B38B: std::rt::lang_start_internal (rt.rs:148)\r\n==5157==    by 0x17922B: std::rt::lang_start (rt.rs:165)\r\n==5157==    by 0x10CE07: main (in /builds/scratch/target/debug/scratch)\r\n==5157==  If you believe this happened as a result of a stack\r\n==5157==  overflow in your program's main thread (unlikely but\r\n==5157==  possible), you can try to increase the size of the\r\n==5157==  main thread stack using the --main-stacksize= flag.\r\n==5157==  The main thread stack size used in this run was 10485760.\r\n==5157== \r\n==5157== HEAP SUMMARY:\r\n==5157==     in use at exit: 1,109 bytes in 4 blocks\r\n==5157==   total heap usage: 9 allocs, 5 frees, 2,997 bytes allocated\r\n==5157== \r\n==5157== LEAK SUMMARY:\r\n==5157==    definitely lost: 0 bytes in 0 blocks\r\n==5157==    indirectly lost: 0 bytes in 0 blocks\r\n==5157==      possibly lost: 0 bytes in 0 blocks\r\n==5157==    still reachable: 1,109 bytes in 4 blocks\r\n==5157==         suppressed: 0 bytes in 0 blocks\r\n==5157== Rerun with --leak-check=full to see details of leaked memory\r\n==5157== \r\n==5157== For lists of detected and suppressed errors, rerun with: -s\r\n==5157== ERROR SUMMARY: 2 errors from 1 contexts (suppressed: 0 from 0)\r\nSegmentation fault\r\n<backtrace>\r\n```\r\n\r\n</p>\r\n</details>", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/102196/reactions", "total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/102196/timeline", "performed_via_github_app": null, "state_reason": null}