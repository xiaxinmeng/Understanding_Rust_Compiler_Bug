{"url": "https://api.github.com/repos/rust-lang/rust/issues/11730", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/11730/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/11730/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/11730/events", "html_url": "https://github.com/rust-lang/rust/issues/11730", "id": 26115170, "node_id": "MDU6SXNzdWUyNjExNTE3MA==", "number": 11730, "title": "Investigate improving scheduler work-stealing efficiency", "user": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 36953, "node_id": "MDU6TGFiZWwzNjk1Mw==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-runtime", "name": "A-runtime", "color": "f7e101", "default": false, "description": "Area: std's runtime and \"pre-main\" init for handling backtraces, unwinds, stack overflows"}, {"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 60344715, "node_id": "MDU6TGFiZWw2MDM0NDcxNQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/P-medium", "name": "P-medium", "color": "eb6420", "default": false, "description": "Medium priority"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 32, "created_at": "2014-01-22T19:21:15Z", "updated_at": "2014-09-19T03:47:56Z", "closed_at": "2014-09-19T03:47:56Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "Right now the libgreen scheduler implements a work stealing algorithm in tandem with a global sleeper list in order to fan out work among all schedulers when there is work to do.\n\nSadly, this scheme has pathological performance in simple situations like lots of threads contending on a mutex. The reason for this is that every time a thread gets off a mutex a remote scheduler is woken up to run the thread. This remote scheduler is woken up with a _syscall_. The remote scheduler will run the task, but immediately go back to sleep as the task goes back to sleep on the mutex.\n\nThis process of waking up a remote scheduler is very expensive and shows painfully in benchmarks. This problem essentially boils down to a problem where all task enqueues require a syscall. The reason for this is that on some workloads there's almost always a scheduler that is asleep as the system isn't fully loaded. If the system is loaded with work, none of this is a problem because no remote scheduler needs to be woken up.\n\nRight now, there are two ideas for mitigating this cost of a syscall.\n1. Exponential backoff when sleeping. Right now whenever a scheduler goes to sleep, it falls back into `epoll` and gets woken up via `write`. Additionally, it puts a handle on a global sleeper list for other schedulers to grab and then wake up. Instead, a scheduler could have some sort of exponential backoff of sleeping. Only after the backoff was completed would a handle be placed on the sleeper list. The goal for this would be to avoid write syscalls because the handles wouldn't actually be on the list, but other schedulers would still successfully steal work. This exponential backoff would need to be tuneable, and it probably shouldn't happen if there are active I/O handles.\n2. Schedulers should only wake up two other schedulers. Right now there is a global sleeper list where any scheduler can wake up any other scheduler. In addition to being a point of contention, this means that if _any_ scheduler is sleeping that a task enqueue will be a syscall. On systems of lots of cores, I would imagine it's fairly likely that small programs don't fill up all the cores. In order to mitigate this problem, we would arrange the pool of schedulers as a ring of schedulers. Each scheduler would be responsible for waking up its left and right neighbors, but that's it. With this scheme, if one scheduler had lots of serial work, it would occasionally wake up its neighbors, but that's it. Additionally, its neighbors would likely be in the exponential backoff stage before they went to sleep, so there would be no syscalls.\n\nI'm guessing that combining these two strategies will allow us to still distribute work to all cores quickly if there is a truly parallel workload, and also work well on many-task workloads that are mostly sequential (due to a mutex or some such). This is just a guess though, and definitely needs investigation.\n", "closed_by": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/11730/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/11730/timeline", "performed_via_github_app": null, "state_reason": "completed"}