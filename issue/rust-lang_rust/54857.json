{"url": "https://api.github.com/repos/rust-lang/rust/issues/54857", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/54857/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/54857/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/54857/events", "html_url": "https://github.com/rust-lang/rust/issues/54857", "id": 367318627, "node_id": "MDU6SXNzdWUzNjczMTg2Mjc=", "number": 54857, "title": "(Maybe) Undefined behavior in safe code from `getelementptr inbounds` with offset 0", "user": {"login": "jturner314", "id": 1836850, "node_id": "MDQ6VXNlcjE4MzY4NTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1836850?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jturner314", "html_url": "https://github.com/jturner314", "followers_url": "https://api.github.com/users/jturner314/followers", "following_url": "https://api.github.com/users/jturner314/following{/other_user}", "gists_url": "https://api.github.com/users/jturner314/gists{/gist_id}", "starred_url": "https://api.github.com/users/jturner314/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jturner314/subscriptions", "organizations_url": "https://api.github.com/users/jturner314/orgs", "repos_url": "https://api.github.com/users/jturner314/repos", "events_url": "https://api.github.com/users/jturner314/events{/privacy}", "received_events_url": "https://api.github.com/users/jturner314/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 267612997, "node_id": "MDU6TGFiZWwyNjc2MTI5OTc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-unsound", "name": "I-unsound", "color": "e11d21", "default": false, "description": "Issue: A soundness hole (worst kind of bug), see: https://en.wikipedia.org/wiki/Soundness"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 20, "created_at": "2018-10-05T18:22:45Z", "updated_at": "2019-12-15T12:18:57Z", "closed_at": "2019-12-15T12:18:57Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "As far as I can tell, slicing a `Vec<T>` (in safe code) results in undefined behavior when `T` is zero-sized or the `Vec` has zero capacity. I'm probably missing something, but I'm creating this issue in case my investigation is correct.\r\n\r\nIn particular, these two examples appear to cause undefined behavior due the `.offset()` call violating the [first safety constraint](https://doc.rust-lang.org/stable/std/primitive.pointer.html#safety-1) (\"Both the starting and resulting pointer must be either in bounds or one byte past the end of *the same* allocated object.\") when performing the slice:\r\n\r\n```rust\r\n// Example 1: zero-sized T\r\nlet v = Vec::from(&[(); 5][..]);\r\nlet _ = &v[2..3];\r\n\r\n// Example 2: zero-capacity Vec\r\nlet v = Vec::<i32>::with_capacity(0);\r\nlet _ = &v[0..0];\r\n```\r\n\r\n## Example 1\r\n\r\nIn the first example, the `v` has field values\r\n\r\n```rust\r\nVec {\r\n    buf: RawVec {\r\n        ptr: Unique {\r\n            pointer: NonZero(0x1 as *const ()),\r\n            ..\r\n        },\r\n        ..\r\n    },\r\n    len: 5,\r\n}\r\n```\r\n\r\n(Verify this with `v.as_ptr()` and `v.len()`.) Performing the slice `&v[2..3]` expands to approximately the following:\r\n\r\n```rust\r\nlet slice = unsafe {\r\n    let p = v.buf.ptr();\r\n    assume(!p.is_null());\r\n    slice::from_raw_parts(p, v.len)\r\n};\r\n// Note that the pointer of `slice` has value `0x1`.\r\n// (Bounds checks elided here.)\r\nunsafe {\r\n    from_raw_parts((slice as *const [()] as *const ()).offset(2), 3 - 2)\r\n}\r\n```\r\n\r\nSo, it's calling `ptr.offset(2)` where `ptr` has value `0x1`. This pointer is not \"in bounds or one byte past the end of [an] allocated object\", so the `.offset()` is undefined behavior. (This pointer was created from casting an integer (the alignment of `()`) to a pointer in `libcore/ptr.rs, Unique::empty`.)\r\n\r\n## Example 2\r\n\r\nThe second example has a similar issue. In the second example, the `v` has field values\r\n\r\n```rust\r\nVec {\r\n    buf: RawVec {\r\n        ptr: Unique {\r\n            pointer: NonZero(0x4 as *const i32),\r\n            ..\r\n        },\r\n        ..\r\n    },\r\n    len: 0,\r\n}\r\n```\r\n\r\n(Verify this with `v.as_ptr()` and `v.len()`.) Performing the slice `&v[0..0]` expands to approximately the following:\r\n\r\n```rust\r\nlet slice = unsafe {\r\n    let p = v.buf.ptr();\r\n    assume(!p.is_null());\r\n    slice::from_raw_parts(p, v.len)\r\n};\r\n// Note that the pointer of `slice` has value `0x4`.\r\n// (Bounds checks elided here.)\r\nunsafe {\r\n    from_raw_parts((slice as *const [i32] as *const i32).offset(0), 0 - 0)\r\n}\r\n```\r\n\r\nSo, it's calling `ptr.offset(0)` where `ptr` has value `0x4`. This pointer is not \"in bounds or one byte past the end of [an] allocated object\", so the `.offset()` is undefined behavior. (This pointer was created from casting an integer (the alignment of `i32`) to a pointer in `libcore/ptr.rs, Unique::empty`.)\r\n\r\n## Further investigation\r\n\r\nThere are a few ways that these examples might actually not be undefined behavior:\r\n\r\n1. If the documentation is incorrect, and `.offset()` is in fact safe if the offset in bytes is zero (even if the pointer is not part of an allocated object).\r\n\r\n2. If LLVM considers `Unique::empty` to be an allocator so that the returned pointer is considered part of an allocated object. I don't see anything to indicate this is the case, though.\r\n\r\n3. If, somewhere, the runtime allocates the range of bytes with addresses `0x1..=(max possible alignment)`. This would mean that pointers returned by `Unique::empty` would be within an allocated object. I don't see anything to indicate this is the case, though, and I'm not entirely convinced that casting an integer to a pointer would work in this case anyway (since the pointer would be derived from an integer instead of offsetting a pointer of an existing allocation).\r\n\r\nI did some further investigation into possibility 1.\r\n\r\nThe `.offset()` method is converted into an LLVM `getelementptr inbounds` instruction. (`src/libcore/ptr.rs` provides the `.offset()` method, which calls `intrinsics::offset`. `src/libcore/intrinsics.rs` defines the `extern \"rust-intrinsic\"` `offset` but not the implementation. The `codegen_intrinsic_call` function in `src/librustc_codegen_llvm/intrinsic.rs` handles the `\"offset\"` case by calling `.inbounds_gep()` in the `Builder`. The implementation of `.inbounds_gep()` is provided in `src/librustc_codegen_llvm/builder.rs`, which in turn calls the `extern` function `LLVMBuildInBoundsGEP` imported in `src/librustc_llvm/ffi.rs`. The function is defined in `src/llvm/include/llvm-c/Core.h`)\r\n\r\n[The docs for the LLVM `getelementptr inbounds` instruction](https://llvm.org/docs/LangRef.html#id219) say the following:\r\n\r\n> If the `inbounds` keyword is present, the result value of the `getelementptr` is a [poison value](https://www.llvm.org/docs/LangRef.html#poisonvalues) if the base pointer is not an *in bounds* address of an allocated object, or if any of the addresses that would be formed by successive addition of the offsets implied by the indices to the base address with infinitely precise signed arithmetic are not an *in bounds* address of that allocated object. The *in bounds* addresses for an allocated object are all the addresses that point into the object, plus the address one byte past the end. The only *in bounds* address for a null pointer in the default address-space is the null pointer itself. In cases where the base is a vector of pointers the `inbounds` keyword applies to each of the computations element-wise.\r\n\r\nThe LLVM docs say [this about poison values](https://llvm.org/docs/LangRef.html#poisonvalues):\r\n\r\n> Poison values are similar to [undef values][], however they also represent the fact that an instruction or constant expression that cannot evoke side effects has nevertheless detected a condition that results in undefined behavior.\r\n>\r\n> \u2026\r\n>\r\n> Poison values have the same behavior as [undef values][], with the additional effect that any instruction that has a *dependence* on a poison value has undefined behavior.\r\n>\r\n> [undef values]: https://www.llvm.org/docs/LangRef.html#undefvalues\r\n\r\nAs far as I can tell, the reason why the Rust docs for `.offset()` consider getting a \"poison value\" to be undefined behavior is that performing any operation with a dependence on the poison value (e.g. printing it with `println!`) is undefined behavior. In particular, it's possible to perform operations with a dependence on a pointer value in safe code, so a pointer must never be a poison value.\r\n\r\nAnyway, back to the safety constraints on `.offset()`. The constraints listed in the docs for `getelementptr inbounds` match the constraints listed in the docs for `.offset()` with one exception: \"The only *in bounds* address for a null pointer in the default address-space is the null pointer itself.\" This means that even though a null pointer is not part of an allocation, it's still safe to perform an offset of 0 bytes on it. The docs for `getelementptr inbounds` don't indicate that this is true for non-null pointers, though, which is the case described in this issue (slicing a `Vec` with zero-size elements or zero capacity).\r\n\r\n## Meta\r\n\r\nThis appears to be an issue in both stable (1.29.1) and nightly.", "closed_by": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/54857/reactions", "total_count": 7, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 7, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/54857/timeline", "performed_via_github_app": null, "state_reason": "completed"}