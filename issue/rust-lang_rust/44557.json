{"url": "https://api.github.com/repos/rust-lang/rust/issues/44557", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/44557/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/44557/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/44557/events", "html_url": "https://github.com/rust-lang/rust/issues/44557", "id": 257558759, "node_id": "MDU6SXNzdWUyNTc1NTg3NTk=", "number": 44557, "title": "Alloc: Clarify supported Layouts", "user": {"login": "joshlf", "id": 1046063, "node_id": "MDQ6VXNlcjEwNDYwNjM=", "avatar_url": "https://avatars.githubusercontent.com/u/1046063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joshlf", "html_url": "https://github.com/joshlf", "followers_url": "https://api.github.com/users/joshlf/followers", "following_url": "https://api.github.com/users/joshlf/following{/other_user}", "gists_url": "https://api.github.com/users/joshlf/gists{/gist_id}", "starred_url": "https://api.github.com/users/joshlf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joshlf/subscriptions", "organizations_url": "https://api.github.com/users/joshlf/orgs", "repos_url": "https://api.github.com/users/joshlf/repos", "events_url": "https://api.github.com/users/joshlf/events{/privacy}", "received_events_url": "https://api.github.com/users/joshlf/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 129836139, "node_id": "MDU6TGFiZWwxMjk4MzYxMzk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-allocators", "name": "A-allocators", "color": "f7e101", "default": false, "description": "Area: Custom and system allocators"}, {"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 630652267, "node_id": "MDU6TGFiZWw2MzA2NTIyNjc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-feature-request", "name": "C-feature-request", "color": "f5f1fd", "default": false, "description": "Category: A feature request, i.e: not implemented / a PR."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2017-09-14T00:20:32Z", "updated_at": "2018-06-27T13:02:51Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "# TLDR\r\nThe `Alloc` trait doesn't currently document what `Layout`s are guaranteed to be supported, which leaves consumers unsure whether their allocations will fail with `AllocErr::Unsupported`. This issue proposes addressing this by introducing a distinction between \"general\" and \"specialized\" allocators, and documenting a set of required `Layout`s that the former must be able to handle.\r\n\r\n# Problem Statement\r\nOne of the errors that the `Alloc` trait's allocation methods can return is `AllocErr::Unsupported`, which indicates that the allocator doesn't support the requested `Layout`. Currently, the `Alloc` trait places no restrictions - either using the type system or in documentation - on what `Layout`s must be supported. Thus, consumers of a generic `Alloc` (as opposed to a particular type that implements `Alloc`) must assume that any given allocation request might be unsupported.\r\n\r\nThis creates a problem: in order for a consumer of an `Alloc` to be able to guarantee to their users that they will not crash at runtime (after all, having gotten `AllocErr::Unsupported`, there's really no other recourse other than to abort or bubble up the error), they need to document the set of `Layout`s that they might request from an allocator provided by the user. This, in turn, requires that all implementations of `Alloc` document precisely which `Layout`s they can handle so that users can ensure that they're upholding the requirements of the consumers. Even if all of this documentation was written and maintained, it'd impose a very large burden on the users. Imagine every time you wanted to use `Vec<T, A: Alloc>` for a particular, custom `A`, you had to carefully read the `Vec` documentation and the documentation for the desired allocator to ensure they were compatible.\r\n\r\nWorse still, the current mechanism for configuring the global allocator involves providing an instance of `Alloc`. In this case, there's no way for code to communicate to the person configuring the global allocator what their requirements are, since that code might be buried behind an arbitrary number of dependencies (e.g., I use crate `foo` which depends on crate `bar` which depends on crate `baz` which is incompatible with the global allocator I've configured).\r\n\r\nThis came up in practice for me while working on my [slab-alloc](https://crates.io/crates/slab-alloc) crate (which is basically just an object cache). I allow users to provide a custom `Alloc` to back a `SlabAlloc` instance, but I currently have no way other than in documentation to ensure that the provided `Alloc`s will be compatible with the allocations I perform. If, for example, a user were to provide an allocator incapable of providing page-aligned allocations, or if somebody upstream of my crate configured a global allocator with this limitation, my code would crash at runtime.\r\n\r\n# Proposal\r\nIn order to address this issue, I propose introducing (in the `Alloc` trait's documentation) the notion of a \"general allocator,\" which is an implementation of the `Alloc` trait which guarantees the ability to handle a certain class of standard allocation requests.\r\n\r\nAll implementations of `Alloc` are assumed to be general allocators unless documented to the contrary. All consumers of an `Alloc` type parameter are assumed to be compatible with a general allocator (that is, they do not perform any allocations which are outside of the set of guaranteed-to-be-supported allocations) unless documented to the contrary.\r\n\r\nAn allocation is guaranteed to be supported so long as it meets the following criteria:\r\n- The size is non-zero\r\n- The alignment is a non-zero power of two (this is already enforced by `Layout`)\r\n- The size is a multiple of the alignment (this is already enforced by `Layout`)\r\n- The alignment is not larger than the system's page size\r\n- The size is not larger than 2^31 bytes on 32-bit platforms or 2^47 on 64-bit platforms\r\n\r\nThis system does not hamstring special-case uses. `Alloc` implementations which do not provide all of these guarantees merely need to document this. `Alloc` consumers which require more than what a general allocator guarantees merely need to document this, placing the onus on their users to provide an appropriate `Alloc`.\r\n\r\n## Open questions\r\n- A 2^31 byte limit on 32-bit platforms might be limiting, so it might be worth making it 2^32 - 1 bytes (and 2^48 - 1 on 64-bit) instead. My concern is how this will play with signed integers, but that might be the sort of thing that it's reasonable to expect an allocator implementor to just be careful about.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/44557/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/44557/timeline", "performed_via_github_app": null, "state_reason": null}