{"url": "https://api.github.com/repos/rust-lang/rust/issues/106431", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/106431/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/106431/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/106431/events", "html_url": "https://github.com/rust-lang/rust/issues/106431", "id": 1518099632, "node_id": "I_kwDOAAsO6M5afFyw", "number": 106431, "title": "Implied bounds / well-formedness of references treats contravariant lifetimes the same as covariant", "user": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37544, "node_id": "MDU6TGFiZWwzNzU0NA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-typesystem", "name": "A-typesystem", "color": "f7e101", "default": false, "description": "Area: The type system"}, {"id": 60344715, "node_id": "MDU6TGFiZWw2MDM0NDcxNQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/P-medium", "name": "P-medium", "color": "eb6420", "default": false, "description": "Medium priority"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}, {"id": 4172483496, "node_id": "LA_kwDOAAsO6M74swuo", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-types", "name": "T-types", "color": "bfd4f2", "default": false, "description": "Relevant to the types team, which will review and decide on the PR/issue."}, {"id": 4971343621, "node_id": "LA_kwDOAAsO6M8AAAABKFCvBQ", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-only-steffahn-can-write-unsafe-code-correctly", "name": "I-only-steffahn-can-write-unsafe-code-correctly", "color": "e11d21", "default": false, "description": "Issue: Something which causes only @steffahn to be able to write unsafe code correctly"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2023-01-04T00:29:22Z", "updated_at": "2023-04-05T17:35:17Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "Potentially related to https://github.com/rust-lang/rust/issues/25860 . The issues _seem_ related but the examples are pretty different so I figured I'd file this as separate.\r\n\r\nI'm not yet sure if I can craft an actual self-contained soundness bug out of this, but it does cause a soundness bug in `Yoke` which relies on `for<'a>` working correctly: https://github.com/unicode-org/icu4x/issues/2926. I have multiple potential fixes for the yoke issue, but it's worth at least noting.\r\n\r\n\r\nTLDR: Rust currently correctly implies a `'inner: 'outer` bound when you have `&'outer &'inner _`. It is also _incorrectly_ implying this for  `&'outer fn(&'inner _)`\r\n\r\n\r\n\r\nThe reduced example is as follows:\r\n\r\n```rust\r\n\r\n// A function that forces the closure to work for ALL lifetimes\r\n// ... or does it?  };-)\r\nfn attach<C, F>(cart: Box<C>, transform: F) where F: for<'all> FnOnce(&'all C) -> &'all str {\r\n    // could call f(&cart);, etc\r\n}\r\n\r\ntype Contra<'a> = fn(&'a ());\r\n\r\nfn contra_shorter<'contra, 's: 'contra>(param_contra: Contra<'contra>, param_s: &'s str) {\r\n    let contravariant_cart = Box::new(param_contra);\r\n    attach(contravariant_cart, |_| param_s);\r\n    \r\n}\r\n```\r\n\r\n([playpen](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=964e5c3e41e0f2c81a5a785c069248e5))\r\n\r\nThis should not compile. `F` requires the returned string to be valid for ALL lifetimes `'all`, whereas we're returning a string of lifetime `'s`\r\n\r\nThis code is behaving the same as this code:\r\n\r\n```rust\r\nfn co_shorter<'co, 's: 'co>(param_co: &'co u8, param_s: &'s str) {\r\n    let covariant_cart = Box::new(param_co);\r\n    attach(covariant_cart, |_| param_s);\r\n}\r\n```\r\n\r\n\r\nwhere the concrete type of `F` is `for<'all> FnOnce(&'all &'co u8) -> &'all str`, and well-formedness implies that `'all` must be shorter than `'co`, so you end up getting a `'co: 'all` bound, and `'s: 'co` ends up giving us `'s: 'all`, so even though there is a `for<'all>`, the `'all` is actually artificially restricted to being \"for all shorter than `'co`\" and returning data of lifetime `'s` is valid there.\r\n\r\n(the `'s: 'co` is actually not necessary for `co_shorter()` to compile, but it's easier to explain that way)\r\n\r\n\r\n\r\n-----\r\n\r\nBasically, for `&'outer Foo<'inner>`, the implied bound probably _should_ be:\r\n\r\n - For covariant `Foo`: `'inner: 'outer`\r\n - For contravariant `Foo`: Nothing\r\n - For invariant `Foo`: `'inner: 'outer`, or nothing\r\n\r\nBasically the implied bound is safe when things are _guaranteed to not be contravariant_. It's actually fine to have the implied bound for e.g. the invariant case of `&'outer Cell<'inner _>`, because a cell is logically a tuple of a covariant getter and contravariant setter, and the setter implies no bounds but the getter can imply bounds.\r\n\r\nThis does give me some pause since typically we tend to believe that code that works on invariant types will also work on contravariant types, and here's a situation where it won't; so perhaps it's safer to also opt invariant lifetimes out of this. Idk.\r\n\r\n<s>Contravariant types _could_ imply the bound `'outer: 'inner` because function parameters can't live for less than the function does, but I'm not sure this implied bound is ever _useful_. Does lead to a nice symmetry though.</s>\r\n\r\nThe Yoke bug (https://github.com/unicode-org/icu4x/issues/2926) only shows up for contravariance due to how Yoke is structured. It's not clear to me that there's a way to write an unsafe abstraction that relies on `for<'a>` being truly universal where an implied bound coming from an _invariant_ type may cause unsoundness. But I could be wrong.\r\n\r\n------\r\n\r\nA further exploration can be found in this code ([playpen](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=07fc364b2f39512059fe64334499ca54)):\r\n\r\n<details><summary>Show code</summary>\r\n\r\n```rust\r\n// A function that forces the closure to work for ALL lifetimes\r\n// ... or does it?  };-)\r\nfn attach<C, F>(cart: Box<C>, transform: F) where F: for<'all> FnOnce(&'all C) -> &'all str {\r\n    // could call f(&cart);, etc\r\n}\r\n\r\ntype Contra<'a> = fn(&'a ());\r\n\r\n\r\nfn main() {\r\n    // create a Box<&'a _> with a longer lifetime than s ('a_longer; where `'a_longer: 's`)\r\n    let local_longer = vec![1,2,3,4];\r\n    let covariant_cart_longer: Box<&'_ [u32]> = Box::new(&*local_longer);\r\n    \r\n    // let's say this has lifetime 's\r\n    let s = String::from(\"hello\");\r\n    \r\n    \r\n    // Create a Box<Contra<'contra>>, contravariant over 'contra\r\n    let contravariant_cart: Box<Contra<'_>> = Box::new((|_| ()) as Contra);\r\n    \r\n    \r\n    // Create a Box<_> that is fully owned\r\n    let owned = vec![1,2,3,4];\r\n    let owned_cart = Box::new(owned);\r\n    \r\n    // create a Box<&'a _> with a shorter lifetime than s ('a_shorter, where `'s: 'a_shorter`)\r\n    let local_shorter = vec![1,2,3,4];\r\n    let covariant_cart_shorter: Box<&'_ [u32]> = Box::new(&*local_shorter);  \r\n    \r\n\r\n\r\n    // does not compile, &s cannot produce &'all str for ALL 'all\r\n    //\r\n    // attach(owned_cart, |_| &s); \r\n\r\n\r\n\r\n    // This does compile, because in the bounds for F, `&'all C` is `&'all &'a_longer [u32]`, which forces\r\n    // 'all to be shorter than 'a_shorter due to well-formedness / implied bounds (`'a_shorter: 'all`), reducing the for<'all> in scope\r\n    // which works just fine for &s since 's is longer than 'a_shorter (`'s: 'a_shorter`) implying that `'s: 'all`\r\n    attach(covariant_cart_shorter, |_| &s);\r\n    \r\n    \r\n    \r\n    // Seems like it shouldn't work, because the reason from before doesn't seem apply: even if 'all is forced to be shorter than 'a_longer,\r\n    // there is still a period of time where 'a_longer is valid but 's is not, so the closure shouldn't compile.\r\n    //\r\n    // However, rustc is smart! It knows that it can make it work by squeezing 'a_longer *until* it is shorter than 's (`'s: 'a_longer`), and then WF rules force\r\n    // us back into 'all being short (`'a_longer: 'all`), which brings us back to the previous situation; `'s: 'all`\r\n    attach(covariant_cart_longer, |_| &s);\r\n    \r\n\r\n    // works, but shouldn't. 'contra is being selected to be *something*, and that somehow impacts WFness enough to\r\n    // restrict the range of the for<'all>\r\n    //\r\n    // Without knowing WF rules for functions for sure, the clear answer is that *if* there are WF rules for functions, they would apply outside-in, not inside-out,\r\n    // i.e. &'all fn(&'contra) would restrict 'contra to live at least as long as 'all, not vice versa.\r\n    // This is unhelpful for us since we still have compiling code where &'s str is somehow a valid `for<'all> &'all str`; we MUST restrict 'all somehow\r\n    //\r\n    // To poke at this further without the problem of rustc picking some lifetime for 'contra, let's give it a named lifetime in two methods below:\r\n    attach(contravariant_cart, |_| &s);\r\n    \r\n}\r\n\r\n// First let's just give it a named lifetime\r\nfn contra_longer<'a>(param_contra: Contra<'a>) {\r\n    let contravariant_cart = Box::new(param_contra);\r\n    let s = String::from(\"hello\");\r\n    // doesn't work, &s cannot produce &'all str for ALL 'all\r\n    // huzzah!\r\n    // attach(contravariant_cart, |_| &s);\r\n    \r\n}\r\n\r\n// Now let's give it *and* s named lifetimes, and say that 's lives at least as long as 'contra\r\nfn contra_shorter<'contra, 's: 'contra>(param_contra: Contra<'contra>, param_s: &'s str) {\r\n    let contravariant_cart = Box::new(param_contra);\r\n    // ... does work, but shouldn't\r\n    // this is the same behavior as that for covariant lifetimes, clearly\r\n    // the WF rules are assuming covariance somehow;\r\n    //\r\n    // the previous function fails to compile because 's lives \r\n    // less than 'contra, so we have a case similar to that of `covariant_cart_shorter` but this time the\r\n    // covariance cannot come to the rescue\r\n    attach(contravariant_cart, |_| param_s);\r\n    \r\n}\r\n```\r\n</details>\r\n\r\nThe line `attach(contravariant_cart, |_| &s);` should not compile, nor should the function `contra_shorter()`. `contra_longer()` happens to correctly fail to compile because the same variance trick that saves `covariant_cart_shorter` does not apply here.\r\n\r\ncc @pnkfelix @lcnr \r\n\r\nThanks to @workingjubilee for rubberducking this with me.\r\n\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/106431/reactions", "total_count": 2, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 2, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/106431/timeline", "performed_via_github_app": null, "state_reason": null}