{"url": "https://api.github.com/repos/rust-lang/rust/issues/41023", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/41023/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/41023/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/41023/events", "html_url": "https://github.com/rust-lang/rust/issues/41023", "id": 218793114, "node_id": "MDU6SXNzdWUyMTg3OTMxMTQ=", "number": 41023, "title": "Mutex not releasing lock properly when being used through an accessor struct on ARM", "user": {"login": "timvisee", "id": 856222, "node_id": "MDQ6VXNlcjg1NjIyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/856222?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timvisee", "html_url": "https://github.com/timvisee", "followers_url": "https://api.github.com/users/timvisee/followers", "following_url": "https://api.github.com/users/timvisee/following{/other_user}", "gists_url": "https://api.github.com/users/timvisee/gists{/gist_id}", "starred_url": "https://api.github.com/users/timvisee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timvisee/subscriptions", "organizations_url": "https://api.github.com/users/timvisee/orgs", "repos_url": "https://api.github.com/users/timvisee/repos", "events_url": "https://api.github.com/users/timvisee/events{/privacy}", "received_events_url": "https://api.github.com/users/timvisee/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-04-02T20:58:09Z", "updated_at": "2017-04-02T21:22:35Z", "closed_at": "2017-04-02T21:17:56Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I'm having some weird problems with the `Mutex` struct provided by the standard library of Rust. The release of mutex guards seems to be inconsistent across platforms. Because of that, a mutex lock isn't released properly on specific platforms.\r\n\r\nI'm not 100% sure if this caused by a bug, or because of defined platform-specific behavior. Based on the [issue contributing](https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md) document I figured I'd post this issue anyway as I couldn't find any relevant issue.\r\n\r\n### Problem description\r\nIn my case, I'm using an _accessor_ struct, that wraps a mutex guard (lock). This accessor provides various methods that help you easily access data through the mutex guard. The mutex guard should be dropped when the accessor struct is dropped, this should release the lock on the mutex that is held by the guard.y case, I'm using an _accessor_ struct, that wraps a mutex guard (lock). This accessor provides various methods that help you easily access data through the \r\n\r\nWhen running the troublesome code on an `x86_46` machine, everything works fine. Locks are created by the accessor and released when the code is done using the accessor. However, when running the code on an `arm` machine, the lock does never seem to be released. Therefore, the code blocks when trying to create the second accessor struct, as the mutex lock is blocking.\r\n\r\n### Code\r\nI've tried to simplify the code to a bare minimum, to make the bug reproducible. It creates a manager struct, that holds a data struct (`MyStruct`) wrapped in a `Mutex` in an `Arc`. The manager then creates a looping thread, that accesses the data field from the manager for each iteration. This is done by instantiating the accessor struct which is holding the mutex lock. A status message before and after aquiring the lock is printed to the console.\r\n\r\n```rust\r\nuse std::sync::{Arc, Mutex, MutexGuard};\r\nuse std::thread;\r\nuse std::time::Duration;\r\n\r\nfn main() {\r\n    // Create our manager\r\n    let manager = MyManager::new();\r\n\r\n    // Start a thread that uses the manager's data\r\n    manager.start_thread();\r\n}\r\n\r\n// A structure containing data, that we want to wrap in a mutex to 'make' it Sync\r\npub struct MyStruct {\r\n    value: i32,\r\n}\r\n\r\nimpl MyStruct {\r\n    pub fn new(value: i32) -> Self {\r\n        MyStruct {\r\n            value: value,\r\n        }\r\n    }\r\n\r\n    pub fn get(&self) -> &i32 {\r\n        &self.value\r\n    }\r\n}\r\n\r\n// A managing struct, that holds an arc with the mutex\r\npub struct MyManager {\r\n    field: Arc<Mutex<MyStruct>>,\r\n}\r\n\r\nimpl MyManager {\r\n    pub fn new() -> Self {\r\n        MyManager {\r\n            field: Arc::new(Mutex::new(MyStruct::new(3))),\r\n        }\r\n    }\r\n\r\n    pub fn start_thread(&self) {\r\n        // Clone the arc wrapping the mutex\r\n        let field_arc = self.field.clone();\r\n\r\n        thread::spawn(move || {\r\n            loop {\r\n                println!(\"Acquiring lock...\");\r\n\r\n                // Try to create an accessor from the arc, to acquire a lock on the mutex\r\n                let _ = Accessor::from(&field_arc);\r\n\r\n                println!(\"Lock acquired.\");\r\n\r\n                thread::sleep(Duration::new(1, 0));\r\n            }\r\n        }).join().unwrap();\r\n    }\r\n}\r\n\r\n// An accessor, that wraps a mutex guard and makes the data accessible through\r\n// helping methods on the accessor. It drops the guard (and it's mutex lock)\r\n// when the accessor is dropped.\r\npub struct Accessor<'a> {\r\n    guard: MutexGuard<'a, MyStruct>,\r\n}\r\n\r\nimpl<'a> Accessor<'a> {\r\n    pub fn new(guard: MutexGuard<'a, MyStruct>) -> Self {\r\n        Accessor {\r\n            guard: guard,\r\n        }\r\n    }\r\n\r\n    pub fn from(data: &'a Mutex<MyStruct>) -> Accessor<'a> {\r\n        Self::new(data.lock().unwrap())\r\n    }\r\n\r\n    // A helper method, to access the data\r\n    pub fn value(&self) -> &i32 {\r\n        self.guard.get()\r\n    }\r\n}\r\n```\r\n\r\nI'm sure this can be simplified much more, to really focus on the actual problem, although I'm currently not sure how. In that case, I'll edit the code sample above.\r\n\r\n### Output\r\nThe expected output of the code are repeated, alternating console messages showing:\r\n* `Acquiring lock...`\r\n* `Lock acquired!`\r\n\r\nHere follows the actual sample code output on the system's I've tested it on.\r\n\r\n`x86_64` machine:\r\n```\r\nAquiring lock...\r\nLock aquired.\r\nAquiring lock...\r\nLock aquired.\r\nAquiring lock...\r\nLock aquired.\r\n[...]\r\n```\r\n\r\n`arm` machine:\r\n```\r\nAquiring lock...\r\nLock aquired.\r\nAquiring lock...\r\n[program is stuck...]\r\n```\r\nOn the `x86_64` machine, the program gives the expected results. This is not the case on the `arm` machine however.\r\n\r\nThe program isn't able to lock a second time, probably, because the previous lock isn't released. That is **not** what should happen based on my understanding.  \r\n**This is a problem!**\r\n\r\n## Meta\r\n`rustc --version --verbose` on `x86_64`:\r\n```\r\nrustc 1.18.0-nightly (5e122f59b 2017-04-01)\r\nbinary: rustc\r\ncommit-hash: 5e122f59ba23494d460466cca53c71646d99c767\r\ncommit-date: 2017-04-01\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.18.0-nightly\r\nLLVM version: 3.9\r\n```\r\n\r\n`rustc --version --verbose` on `arm`:\r\n```\r\nrustc 1.17.0-nightly (6f10e2f63 2017-03-14)\r\nbinary: rustc\r\ncommit-hash: 6f10e2f63de720468e2b4bfcb275e4b90b1f9870\r\ncommit-date: 2017-03-14\r\nhost: armv7-unknown-linux-gnueabihf\r\nrelease: 1.17.0-nightly\r\nLLVM version: 3.9\r\n```\r\n\r\nThe `arm` machine I'm using is a Raspberry Pi 3B to be exact.", "closed_by": {"login": "timvisee", "id": 856222, "node_id": "MDQ6VXNlcjg1NjIyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/856222?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timvisee", "html_url": "https://github.com/timvisee", "followers_url": "https://api.github.com/users/timvisee/followers", "following_url": "https://api.github.com/users/timvisee/following{/other_user}", "gists_url": "https://api.github.com/users/timvisee/gists{/gist_id}", "starred_url": "https://api.github.com/users/timvisee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timvisee/subscriptions", "organizations_url": "https://api.github.com/users/timvisee/orgs", "repos_url": "https://api.github.com/users/timvisee/repos", "events_url": "https://api.github.com/users/timvisee/events{/privacy}", "received_events_url": "https://api.github.com/users/timvisee/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/41023/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/41023/timeline", "performed_via_github_app": null, "state_reason": "completed"}