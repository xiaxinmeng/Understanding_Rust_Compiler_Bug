{"url": "https://api.github.com/repos/rust-lang/rust/issues/98593", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/98593/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/98593/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/98593/events", "html_url": "https://github.com/rust-lang/rust/issues/98593", "id": 1286484669, "node_id": "I_kwDOAAsO6M5MrjK9", "number": 98593, "title": "[strict provenance] Provide a way to \"create allocations at a fixed address\"", "user": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 880020421, "node_id": "MDU6TGFiZWw4ODAwMjA0MjE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/WG-embedded", "name": "WG-embedded", "color": "c2e0c6", "default": false, "description": "Of interest to the embedded Working Group"}, {"id": 3983786342, "node_id": "LA_kwDOAAsO6M7tc8Fm", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-strict-provenance", "name": "A-strict-provenance", "color": "f7e101", "default": false, "description": "Area: Strict provenance for raw pointers"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 71, "created_at": "2022-06-27T22:08:22Z", "updated_at": "2022-11-21T16:01:26Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "This issue is part of the Strict Provenance Experiment - https://github.com/rust-lang/rust/issues/95228\r\n\r\nOn some platforms it makes sense to just take a hard-coded address, cast it to a pointer, and starting working with that pointer -- because there are external environment assumptions that say that certain things are provided at certain addresses.\r\n\r\nThis is perfectly fine for Rust as long as that memory is entirely *disjoint* from all the memory that Rust understands (`static` globals, stack allocations, heap allocations). Basically we can think of there being a single hard-coded provenance for \"all the memory that is disjoint from the Abstract Machine\", and that is the provenance we would like to use for these pointers created from hard-coded addresses. These restrictions make this operation a lot easier to specify than [`from_exposed_addr`](https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html). (Remember: `from_exposed_addr` is *outside* of Strict Provenance. The goal of this issue is to provide a way to write such code while following Strict Provenance.)\r\n\r\nIn the spirit of the Strict Provenance APIs, that means we probably want a function that does this, and that we can attach suitable documentation to. There are some open questions for the syntax and semantics of that function:\r\n- What should it be called? `make_alloc`, `assume_alloc`, `hard_coded_alloc`? I am leaning towards something with \"alloc\" because this function is basically like an allocator, except that you tell it at which address to allocate and you have to promise that that is Okay To Do.\r\n- It should definitely take a `usize` for the address and return `*mut T`. Should it also take a size, saying how large this assumed allocation is?\r\n- Should each invocation return a fresh provenance, or should they all return the same provenance? Probably the latter; using a fresh provenance comes with a bunch of restrictions that I doubt such low-level code will be happy about.\r\n- (other things I have not thought of)\r\n\r\nCc @Lokathor who keeps mentioning this usecase every time I want to ban int2ptr casts. ;)\r\nTagging WG-embedded since that's where this kind of stuff mostly happens (AFAIK)", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/98593/reactions", "total_count": 16, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 16, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/98593/timeline", "performed_via_github_app": null, "state_reason": null}