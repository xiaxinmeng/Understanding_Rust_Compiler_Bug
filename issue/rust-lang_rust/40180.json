{"url": "https://api.github.com/repos/rust-lang/rust/issues/40180", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/40180/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/40180/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/40180/events", "html_url": "https://github.com/rust-lang/rust/issues/40180", "id": 211161812, "node_id": "MDU6SXNzdWUyMTExNjE4MTI=", "number": 40180, "title": "Tracking issue for the `x86-interrupt` calling convention", "user": {"login": "phil-opp", "id": 1131315, "node_id": "MDQ6VXNlcjExMzEzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1131315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phil-opp", "html_url": "https://github.com/phil-opp", "followers_url": "https://api.github.com/users/phil-opp/followers", "following_url": "https://api.github.com/users/phil-opp/following{/other_user}", "gists_url": "https://api.github.com/users/phil-opp/gists{/gist_id}", "starred_url": "https://api.github.com/users/phil-opp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phil-opp/subscriptions", "organizations_url": "https://api.github.com/users/phil-opp/orgs", "repos_url": "https://api.github.com/users/phil-opp/repos", "events_url": "https://api.github.com/users/phil-opp/events{/privacy}", "received_events_url": "https://api.github.com/users/phil-opp/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 246778137, "node_id": "MDU6TGFiZWwyNDY3NzgxMzc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/B-unstable", "name": "B-unstable", "color": "d304cb", "default": false, "description": "Implemented in the nightly compiler and unstable."}, {"id": 650846969, "node_id": "MDU6TGFiZWw2NTA4NDY5Njk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-tracking-issue", "name": "C-tracking-issue", "color": "f5f1fd", "default": false, "description": "Category: A tracking issue for an RFC or an unstable feature."}, {"id": 3537250192, "node_id": "LA_kwDOAAsO6M7S1ieQ", "url": "https://api.github.com/repos/rust-lang/rust/labels/S-tracking-needs-summary", "name": "S-tracking-needs-summary", "color": "4682b4", "default": false, "description": "It's hard to tell what's been done and what hasn't! Someone should do some investigation."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 36, "created_at": "2017-03-01T18:04:22Z", "updated_at": "2022-04-09T04:22:48Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "## Overview\r\n\r\nTracking issue for the `x86-interrupt` calling convention, which was added in PR #39832. The feature gate name is `abi_x86_interrupt`. This feature will not be considered for stabilization without an RFC.\r\n\r\nThe `x86-interrupt` calling convention can be used for defining interrupt handlers on 32-bit and 64-bit x86 targets. The compiler then uses `iret` instead of `ret` for returning and ensures that all registers are restored to their original values.\r\n\r\n### Usage\r\n\r\n```rust\r\nextern \"x86-interrupt\" fn handler(stack_frame: ExceptionStackFrame) {\u2026}\r\n```\r\n\r\nfor interrupts and exceptions without error code and\r\n\r\n```rust\r\nextern \"x86-interrupt\" fn handler_with_err_code(stack_frame: ExceptionStackFrame,\r\n                                                error_code: u64) {\u2026}\r\n```\r\n\r\nfor exceptions that push an error code (e.g., page faults or general protection faults). The programmer must ensure that the correct version is used for each interrupt.\r\n\r\nFor more details see the [LLVM PR][1], and the corresponding [proposal][2].\r\n\r\n[1]: https://reviews.llvm.org/D15567\r\n[2]: http://lists.llvm.org/pipermail/cfe-dev/2015-September/045171.html\r\n\r\n## Known issues\r\n\r\n- [ ] An earlier version of this description stated that the `ExceptionStackFrame` is passed by reference (instead of by value). This used to work on older LLVM version, but no longer works on LLVM 12. See https://github.com/rust-lang/rust/issues/40180#issuecomment-814270159 for more details.\r\n- [ ] LLVM **doesn't preserve MMX and x87 floating point registers** across interrupts. This issue was reported in https://github.com/llvm/llvm-project/issues/26785.\r\n- [x] _(fixed)_ x86-interrupt calling convention leads to **wrong error code** in debug mode (#57270)\r\n\r\n### 64-bit\r\n\r\n- [x] The x86_64 automatically aligns the stack on a 16-byte boundary when an interrupts occurs in 64-bit mode. However, the CPU pushes an 8-byte error code for some exceptions, which destroys the 16-byte alignment. At the moment, LLVM doesn't handle this case correctly and always assumes a 16-byte alignment. This leads to **alignment issues on targets with SSE support**, since LLVM uses misaligned [`movaps`](http://x86.renejeschke.de/html/file_module_x86_id_180.html) instructions for saving the `xmm` registers. This issue is tracked as [bug 26413](https://bugs.llvm.org//show_bug.cgi?id=26413).\r\n\r\n  _A fix for this problem was submitted in [D30049](https://reviews.llvm.org/D30049) and merged in [rL299383](https://reviews.llvm.org/rL299383)._\r\n\r\n- [x] LLVM always tries to backup the `xmm` registers on 64-bit platforms even if the target doesn't support SSE. This leads to invalid opcode exceptions whenever an interrupt handler is invoked.\r\n\r\n  _The fix was merged to LLVM trunk in [rL295347](https://reviews.llvm.org/rL295347). Backported in rust-lang/llvm#63._\r\n\r\n- [ ] https://github.com/llvm/llvm-project/issues/41189\r\n### 32-bit\r\n\r\n- [ ] In 32-bit mode, the CPU performs no stack alignment on interrupts. Thus, the interrupt handler should perform a dynamic stack alignment (i.e. `and esp, 16`). However, LLVM doesn't do that at the moment, which might lead to **alignment errors**, especially for targets with SSE support. This issue is tracked in https://github.com/llvm/llvm-project/issues/26851.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/40180/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/40180/timeline", "performed_via_github_app": null, "state_reason": null}