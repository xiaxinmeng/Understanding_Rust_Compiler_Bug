{"url": "https://api.github.com/repos/rust-lang/rust/issues/74446", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/74446/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/74446/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/74446/events", "html_url": "https://github.com/rust-lang/rust/issues/74446", "id": 659413406, "node_id": "MDU6SXNzdWU2NTk0MTM0MDY=", "number": 74446, "title": "Clarify \"structural equality\" rules", "user": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 900795185, "node_id": "MDU6TGFiZWw5MDA3OTUxODU=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-const-eval", "name": "A-const-eval", "color": "f7e101", "default": false, "description": "Area: constant evaluation (mir interpretation)"}, {"id": 2823748714, "node_id": "MDU6TGFiZWwyODIzNzQ4NzE0", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-valtree", "name": "A-valtree", "color": "f7e101", "default": false, "description": "Things about value trees or fixed by value trees"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 22, "created_at": "2020-07-17T16:41:26Z", "updated_at": "2022-05-28T14:04:36Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "[RFC 1445](https://github.com/rust-lang/rfcs/blob/master/text/1445-restrict-constants-in-patterns.md) introduced the notion of a type supporting \"structural match\", which enables constants of that type to be used in patterns. The goal was to only let primitive types and types with `derive(PartialEq, Eq)` participate in patterns. Since then the `#[structural_match]` attribute was [replaced by two traits](https://github.com/rust-lang/rust/issues/63438): [`StructuralPartialEq`](https://doc.rust-lang.org/nightly/core/marker/trait.StructuralPartialEq.html) and [`StructuralEq`](https://doc.rust-lang.org/nightly/core/marker/trait.StructuralEq.html). More recently, [a value-based analysis](https://github.com/rust-lang/rust/pull/67343) was introduced as an alternative to the type-based traits.\r\n\r\nIn the past, if my understanding is correct, this was only used as a kind of \"lint\" to avoid strange behavior on `match`. (Though there are [some question marks](https://github.com/rust-lang/const-eval/issues/42) here and some matches on constants can affect exhaustiveness checking, which is crucial for soundness.) But my understanding is that recently, it also started playing a role around const generics -- and thus the entire story could become critical for soundness, and I start to become interested. ;) So far, the traits mentioned above are safe, so in principle nothing can depend on them for soundness. They are also unstable though, so any such soundness issue would affect just nightly Rust.\r\n\r\nThere is a lot of good documentation on when and how these traits are implemented, but what I am missing is good documentation on what the trait *means*. I have the feeling that there is a very concrete guarantee associated with these traits, a guarantee that const generics and match both would like to rely on. I'd like to \"tease out\" that guarantee from the existing trait and analysis with the benefit of hindsight, and then hopefully that enables us to simplify this story, or at least document it better.\r\n\r\nSo, here is what I *think* the guarantee is, based on what I saw so far:\r\n* A *value* `v` has *structural equality* if (a) it can be converted to a [value tree](https://github.com/rust-lang/compiler-team/issues/323), and (b) `PartialEq::eq(v, v2)` returns `true` if and only if the value tree representation of `v2` equals that of `v` (in particular, if `v2` cannot be represented in a value tree, the return value must be `false`).\r\n* A *type* has structural equality if all of its values do.\r\n\r\nNow I wonder, does this make sense? Of course this is slightly hypothetical as value trees are not implemented yet, but in most cases I think it is intuitively clear what the tree for a value looks like -- and when it is not clear, it likely has no tree. (In particular, unions, raw pointers [except when cast from an integer] and function pointers cannot be represented in a value tree.) I think this is exactly the guarantee that const generics need, but I only have a birds-eye view of const generics so I am not certain of this. And this also seems closely related to the idea of \"which const values are reasonable to use as a pattern\". I'd be interested in any counterexamples that you might know of.\r\n\r\nIf this definition works, then I think we could replace both of the `Structural*` traits by a single marker trait that just represents this guarantee. But to evaluate if that definition makes sense, we first have to figure out what we *want* from \"structural equality\".\r\n\r\nEDIT: Also see the \"Patterns\" section [in this document](https://hackmd.io/Qvrj_eOFTkCHZrhJ7f1ItA#Patterns), which arrives at a similar (but different) definition coming from what we want for patterns to not behave strangely (in a certain hypothetical valtree-based future).\r\n\r\n### Open problems\r\n\r\nThere is one problem that I know of so far: the `StructuralEq` trait docs have this example\r\n```rust\r\n#[derive(PartialEq, Eq)]\r\nstruct Wrap<X>(X);\r\nfn higher_order(_: &()) { }\r\nconst CFN: Wrap<fn(&())> = Wrap(higher_order);\r\nfn main() {\r\n    match CFN {\r\n        CFN => {}\r\n        _ => {}\r\n    }\r\n}\r\n```\r\nHowever, function pointers do not have a well-behaved notion of equality (Rust functions are \"unnamed\" in LLVM terms), and as such they are not suited for a value tree representation. Indeed function pointers should not be used for const generics; I assume there is some safeguard in place that rejects even some \"structural equality\" values/types for const generics. Moreover higher-order function pointers do not implement `PartialEq`.\r\n\r\nCuriously, floats are allowed in patterns but show a future-compat warning. If floats are problematic even though they have deterministic equality, then for sure we could deprecate matching on function pointers whose equality is non-deterministic and can change when codegen units are partitioned differently!\r\n\r\nBut leaving that aside, I could imagine handling this by changing (b) to say that *if* `T` implements `PartialEq`, then this property has to hold (so values of types not implementing `PartialEq` are fine as long as we can put them into a valtree). For (a) I could imagine an \"extended valtree\" that permits function pointers (represented as a `ty::Instance<'tcx>`) in its leaves; we would only permit such leaves for \"structural equality checking for matches\" but strictly disallow them for constant generics.\r\n\r\nCc @oli-obk @lcnr @pnkfelix @varkor @ecstatic-morse ", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/74446/reactions", "total_count": 10, "+1": 3, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 7, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/74446/timeline", "performed_via_github_app": null, "state_reason": null}