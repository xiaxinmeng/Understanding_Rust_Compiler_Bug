{"url": "https://api.github.com/repos/rust-lang/rust/issues/11455", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/11455/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/11455/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/11455/events", "html_url": "https://github.com/rust-lang/rust/issues/11455", "id": 25405556, "node_id": "MDU6SXNzdWUyNTQwNTU1Ng==", "number": 11455, "title": "RFC: Limited return type inference constrained to a trait", "user": {"login": "glaebhoerl", "id": 1216629, "node_id": "MDQ6VXNlcjEyMTY2Mjk=", "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glaebhoerl", "html_url": "https://github.com/glaebhoerl", "followers_url": "https://api.github.com/users/glaebhoerl/followers", "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}", "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}", "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions", "organizations_url": "https://api.github.com/users/glaebhoerl/orgs", "repos_url": "https://api.github.com/users/glaebhoerl/repos", "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}", "received_events_url": "https://api.github.com/users/glaebhoerl/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 32, "created_at": "2014-01-10T16:29:08Z", "updated_at": "2014-09-19T03:39:09Z", "closed_at": "2014-09-19T03:38:45Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "### Problem\n\nRight now if you want to write a function that transforms an iterator you have to specify the type explicitly:\n\n(1.)\n\n```\nstruct MyTransformer<Iter> { ... }\nimpl<T, Iter: Iterator<T>> Iterator<T> for MyTransformer<Iter> { ... }\nfn my_transform<T, Iter: Iterator<T>>(iter: Iter) -> MyTransformer<Iter> { ... }\n```\n\nIf you want to hide the type of the iterator, you can use a trait object:\n\n(2.)\n\n```\nfn my_transform<T, Iter: Iterator<T>>(iter: Iter) -> ~Iterator<T> { ... }\n```\n\nbut this has a performance cost: heap allocation and indirection.\n\nOne solution is return type inference:\n\n(3.)\n\n```\nfn my_transform<T, Iter: Iterator<T>>(iter: Iter) -> _ { ... }\n```\n\nThis is what C++14 adopts. It has several drawbacks:\n- It breaks encapsulation. The signature of the function (the interface) now depends on the body of the function (the implementation).\n- If you're a client of this function and want to know what you can do with the return type, you either have to rely on external documentation (comments) or look at the implementation.\n- In Rust's case, it significantly complicates the type checking algorithm.\n\nRust's policy of no type inference at the API level is a sound one, in my opinion.\n\nThe same problem will recur when we add unboxed closures.\n### Proposed solution\n\nAllow writing:\n\n(4.)\n\n```\nfn my_transform<T, Iter: Iterator<T>>(iter: Iter) -> Iterator<T> { ... }\n```\n\nThis syntax, a trait as the return type of a function, indicates a limited form of return type inference. Clients of the function may only use the return type according to the trait. The return type of the function must infer to a type that implements the trait.\n\nThis is _sort of_ like an existential, but not quite, which is why I think thinking of it as return type inference is more accurate. If it were a true existential, the function could have several branches and return a different type, each implementing `Iterator`, from each branch. This is OK with trait objects, but clearly not representable in an unboxed form. Similarly, from a caller's perspective, if it were a true existential, two calls to the function could not be assumed to return the same type. But here it's quite reasonable to assume that they do.\n\nIn the interest of least surprise, the return type of such a function with an inferred return type should be assumed to be equal only to itself:\n\n```\ntrait IsThing { }\nstruct Thing;\nimpl IsThing for Thing { }\n\nfn some_thing() -> IsThing { Thing }\nfn some_other_thing() -> IsThing { Thing }\n\nlet mut my_thing = some_thing();\n\n// we expect this to work\nmy_thing = some_thing();\n\n// we expect this *not* to work\nmy_thing = some_other_thing();\n// because it would be surprising if the compiler \"knew\" that\n// `some_thing` and `some_other_thing` return the same type\n// when this isn't present in their signatures\n```\n\nIn other words, when typechecking the rest of the program, for each function with such an inferred return type, the compiler would conjure a new anonymous type which it would pretend is the return type of the function, knowing only that it implements the trait. The true identity of this type (and the impl on it) would be determined when typechecking the function itself. In this way it should be possible to typecheck the body of the function and the rest of the program separately. (Edit: I think we would have to ban using this feature on trait methods though.)\n\nThis solution seems superior to the other three (explicit return type, trait object, or unlimited return type inference), especially if you also consider wanting to return a lambda when we have unboxed closures.\n", "closed_by": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/11455/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/11455/timeline", "performed_via_github_app": null, "state_reason": "completed"}