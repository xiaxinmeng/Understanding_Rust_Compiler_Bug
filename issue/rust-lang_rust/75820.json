{"url": "https://api.github.com/repos/rust-lang/rust/issues/75820", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/75820/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/75820/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/75820/events", "html_url": "https://github.com/rust-lang/rust/issues/75820", "id": 684068045, "node_id": "MDU6SXNzdWU2ODQwNjgwNDU=", "number": 75820, "title": "Replace the pretty-print/retokenize hack with a direct comparsion of AST nodes", "user": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37234, "node_id": "MDU6TGFiZWwzNzIzNA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-cleanup", "name": "C-cleanup", "color": "f5f1fd", "default": false, "description": "Category: PRs that clean code up or issues documenting cleanup."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 2079070889, "node_id": "MDU6TGFiZWwyMDc5MDcwODg5", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-proc-macros", "name": "A-proc-macros", "color": "f7e101", "default": false, "description": "Area: Procedural macros"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2020-08-22T21:10:37Z", "updated_at": "2021-01-12T14:17:34Z", "closed_at": "2021-01-12T14:17:33Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "Currently, proc-macro expansion pretty-prints the `Nonterminal` being passed to the proc macro:\r\n\r\nhttps://github.com/rust-lang/rust/blob/5528caf91442729b47b8f818be0a0ddfd0c17ffb/src/librustc_parse/lib.rs#L283-L293\r\n\r\nThis ensures that the `TokenStream` we pass to a proc-macro always agrees with the AST struct it is attached to. This is necessary because the compiler may directly modify the AST structure after it is parsed but before it is passed to a proc-macro. Currently, it looks like `#[cfg]` attributes are the only way for a proc-macro to observe this: a `derive` macro will have cfg-stripping applied to the fields/variants of the target struct/enum before it is invoked.\r\n\r\nUnfortunately, while this check has no false negatives (keeping an invalid `TokenStream`), it has had a large number of false positives (throwing away the `TokenStream` when it could have been kept):\r\n\r\n* https://github.com/rust-lang/rust/issues/68489\r\n* https://github.com/rust-lang/rust/issues/70987\r\n* https://github.com/rust-lang/rust/pull/73157\r\n* https://github.com/rust-lang/rust/issues/75734\r\n\r\nWhen a false positive occurs, it results in an instance of https://github.com/rust-lang/rust/issues/43081. Originally, I thought that these false positives could only result in unspanned/mis-spanned compiler errors - while obnoxious to deal with, they can be fixed as they come up.\r\n\r\nUnfortunately, using the re-created `TokenStream` means that in addition to losing location information, we also lose hygiene information (since both are accessed via a `Span`). This is much more serious - it results in code compiling that should not. In two cases, users actually wrote macros that explicitly relied on hygiene information being lost, likely because they did not realize that this was a bug. Fixing pretty-print/retokenize false positives can therefore incur unavoidable breakage in certain crates. If one of these buggy macros was exposed in a public API, the problem would be much worse. See https://github.com/rust-lang/rust/pull/73084 for more details.\r\n\r\nI propose that we replace the pretty-print/reparse hack with the following strategy:\r\n\r\n* During token collection, we clone the AST struct (e.g. `Item`) just before the `TokenStream` is attached. We then attach a `struct AstTokens(P(T), TokenStream)` to the struct. The struct now stores a copy of itself (behind a `P`) as it was just after parsing.\r\n* We `#[derive(PartialEq)]` for the entire AST - while a few structs/enum do this, most don't.\r\n* When we need to tokenize a `Nonterminal`, we compare the current AST struct to the original one that it stores. If they are equal, we use the stored `TokenStream` - otherwise, we pretty-print and retokenize.\r\n\r\nThere are some details that would need to be worked out:\r\n* We would need to temporarily remove/ignore certain attributes from the original AST struct prior to the comparison, since the outer AST struct (wrapped in a `Nonterminal`) has an attribute macro removed before it is expanded.\r\n* We might want to create an internal `AstEq` trait, which we derive instead of `PartialEq`. It's conceivable that we might want to implement `PartialEq` for a 'looser' form of equality on some AST structs in the future, which would be incompatible with the 'strict' equality (e.g. checking that `NodeId`s match exactly) required by this check. However, doing so might be overkill.\r\n* The overhead of cloning an AST structure and walking it via `PartialEQ` could conceivable be higher than pretty-printing and re-tokenizing - we would need to benchmark it.\r\n\r\nHowever, adopting this scheme would allow us to bypass all issues resulting from inconsistencies in the pretty-printer. While we would still require the pretty-printer to produce *correct* code (when we detect a mismatch), the proc-macro infrastructure would no longer require it to exactly preserve certain information (empty `where` clauses, extra parentheses, etc.)\r\n\r\nAlternatives:\r\n1. Keep the pretty-print/re-tokenize hack. It seems very unlikely that https://github.com/rust-lang/rust/issues/75734 is the last issue we will encounter, so we will probably need to continue to make modifications to the pretty-printer to support its use with proc-macros.\r\n2. Attempt to track modification to the AST structure - e.g. instead of handing out mutable references in `MutVisitor`, create some kind of smart pointer that invalidates the `TokenStream` when mutable access is required. I attempted several variants of this approach, but all proved to be extremely invasive, requiring changes across the entire compiler.\r\n3. Do nothing for now, but remove the pretty-print hack without replacing it with anything once https://github.com/rust-lang/rust/issues/43081 is fully resolved (e.g. we handle `#[cfg]`s and inner attributes correctly). While this approach might work, it seems dangerous - any modifications to the AST done by the compiler risk getting lost whenever proc-macros are involved. While I'm pretty sure that `#[cfg]`s are the only place where we intentionally modify the AST before a proc-macro sees it, we might inadvertently introduce additional modifications in the future.", "closed_by": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/75820/reactions", "total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/75820/timeline", "performed_via_github_app": null, "state_reason": "completed"}