{"url": "https://api.github.com/repos/rust-lang/rust/issues/19032", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/19032/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/19032/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/19032/events", "html_url": "https://github.com/rust-lang/rust/issues/19032", "id": 49096307, "node_id": "MDU6SXNzdWU0OTA5NjMwNw==", "number": 19032, "title": "Coherence and blanket impls interact in a suboptimal fashion with generic impls", "user": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37544, "node_id": "MDU6TGFiZWwzNzU0NA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-typesystem", "name": "A-typesystem", "color": "f7e101", "default": false, "description": "Area: The type system"}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 26, "created_at": "2014-11-17T14:34:08Z", "updated_at": "2020-12-22T14:40:35Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "There is a tricky scenario with coherence rules and blanket impls of traits. This manifested as #18835, which is an inability to implement `FnOnce` manually for generic types. It turns out to be a legitimate coherence violation, at least according to the current rules (in other words, the problem is not specific to `FnOnce`, but rather an undesired interaction between blanket impls (like those used in the fn trait inheritance hierarchy) and coherence. I am not sure of the best fix, though negative where clauses would provide one possible solution. Changing the `Fn` type parameters to associated types, which arguably they ought to be, would also solve the problem.\n\nLet me explain what happens. There is a blanket impl of `FnOnce` for all things that implement `FnMut`:\n\n```\nimpl<A,R,F:FnMut<A,R>> FnOnce<A,R> for F { ... }\n```\n\nNow imagine someone tries to implement `FnOnce` in a generic way:\n\n```\nstruct Thunk<R> { value: R }\nimpl<R> FnOnce<(),R> for Thunk<R> {\n    fn call_once(self) -> R { self.value }\n}\n```\n\nIf you try this, you wind up with a coherence violation. The coherence checker is concerned because it is possible that someone from another crate comes along implements `FnMut` for `Thunk` as well:\n\n```\nstruct SomeSpecificType;\nimpl FnMut<(),SomeSpecificType> for Thunk<SomeSpecificType> { ... }\n```\n\nThis impl passes the orphan check because `SomeSpecificType` is local to the current crate. Now there is a coherence problem with respect to `FnOnce` for `Thunk<SomeSpecificType>` -- do use the impl that delegates to `FnMut`, or the direct impl?\n\nIf the `A` and `R` arguments to the `Fn` traits were associated types, there would be no issue, because the second impl would be illegal -- the `Fn` traits could only be implemented within the same crate as the main type itself.\n\nIf we had negative where clauses, one could write the manual `FnOnce` impl using a negative where clause:\n\n```\nstruct Thunk<R> { value: R }\nimpl<R> FnOnce<(),R> for Thunk<R>\n    where Thunk<R> : !FnMut<(),R> // imaginary syntax\n{\n    fn call_once(self) -> R { self.value }\n}\n```\n\nThis is _basically_ specialization: we implement `FnOnce`, so long as nobody has implemented `FnMut`, in which case that version wins. This is not necessarily what the author wanted to write, it's just something that would be possible.\n\nThere is also the (somewhat weird) possibility that one could write a negative where clause on the original blanket impl, kind of trying to say \"you can implement FnOnce in terms of FnMut, but only if FnOnce is not implemented already\". But if you think about it for a bit this is (a) basically a weird ad-hoc kind of specialization and (b) sort of a logical contradiction. I think the current logic, if naively extended with negative where clauses, would essentially reject that sort of impl, because the negative where clause doesn't hold (FnOnce _is_ implemented, by that same impl).\n\nNote that we don't have to solve this for 1.0 because direct impls of the `Fn` traits are going to be behind a feature gate (per #18875).\n\ncc @aturon \n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/19032/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/19032/timeline", "performed_via_github_app": null, "state_reason": null}