{"url": "https://api.github.com/repos/rust-lang/rust/issues/3599", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/3599/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/3599/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/3599/events", "html_url": "https://github.com/rust-lang/rust/issues/3599", "id": 7159050, "node_id": "MDU6SXNzdWU3MTU5MDUw", "number": 3599, "title": "net_tcp read timeout", "user": {"login": "jesse99", "id": 425055, "node_id": "MDQ6VXNlcjQyNTA1NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/425055?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jesse99", "html_url": "https://github.com/jesse99", "followers_url": "https://api.github.com/users/jesse99/followers", "following_url": "https://api.github.com/users/jesse99/following{/other_user}", "gists_url": "https://api.github.com/users/jesse99/gists{/gist_id}", "starred_url": "https://api.github.com/users/jesse99/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jesse99/subscriptions", "organizations_url": "https://api.github.com/users/jesse99/orgs", "repos_url": "https://api.github.com/users/jesse99/repos", "events_url": "https://api.github.com/users/jesse99/events{/privacy}", "received_events_url": "https://api.github.com/users/jesse99/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2012-09-26T19:00:57Z", "updated_at": "2013-08-19T17:33:58Z", "closed_at": "2013-08-19T17:33:58Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Not completely sure if this is a bug because I'm finding it difficult to figure out how to use net_tcp using the unit tests. But the below code times out when both the client and the server try to read.\n\n```\n// rustc --test tcp.rs && export RUST_LOG=tcp=3,std::net_tcp=3 && ./tcp\nextern mod std;\n\nuse ip = std::net_ip;\nuse std::net_ip::{IpAddr};\nuse tcp = std::net_tcp;\nuse uv = std::uv;\nuse comm::{Chan, Port};\nuse Option = option::Option;\n\n#[forbid(implicit_copies)]\n#[allow(non_implicitly_copyable_typarams)]    // uv uses non-implicitly copyable Result types\n\n// Note that net_tcp currently does not use SO_REUSEADDR so you may need\n// to change this port if you get an AddressInUse error.\nconst server_port: uint = 8089;\n\n// Spins up a task used to wait for new incoming connections from clients. \npriv fn run_server(addr: IpAddr, port: uint, exit_chan: Chan<()>)\n{\n    let hl_loop = uv::global_loop::get();\n\n    // When we connect to a client the tasks that execute to service requests\n    // from it will be distributed across two threads (unless some subtask\n    // creates a new scheduler).\n    do task::spawn_sched(task::ManualThreads(1))        // TODO: try using 2\n    |move addr|\n    {\n        let backlog = 2;    // TODO: add a type alias or something for the horrible below\n        let on_establish: fn~ (&&kill_ch: comm::Chan<Option<tcp::TcpErrData>>) = |_kill_ch, copy addr| {error!(\"listening for connections on %s\", ip::format_addr(&addr))};\n\n        // listen will block until it gets an error (from the system or from kill_ch). \n        error!(\"server is listening\");\n        let result = tcp::listen(copy addr, port, backlog, hl_loop, on_establish, on_connect);\n        if result.is_err()\n        {\n            fail fmt!(\"failed listen on %s: %?\", ip::format_addr(&addr), result.get_err());\n        }\n\n        // Let our caller know when we're done listening.\n        error!(\"server is exiting\");\n        exit_chan.send(());\n    }\n}\n\npriv fn on_connect(&&connection: tcp::TcpNewConnection, &&kill_chan: Chan<Option<tcp::TcpErrData>>)\n{\n    do task::spawn\n    {\n        error!(\"server is accepting a connection\");\n        let result = tcp::accept(connection);\n        if result.is_ok()\n        {\n            error!(\"server accepted the connection\");\n            let sock = result::get_ref(&result);\n            handle_connection(sock, kill_chan);\n        }\n        else\n        {\n            fail fmt!(\"accept to failed: %?\", result.get_err());\n        }\n    }\n}\n\npriv fn handle_connection(sock: &tcp::TcpSocket, kill_chan: Chan<Option<tcp::TcpErrData>>)\n{\n    loop\n    {\n        let request = read_str(\"server request\", sock);\n        error!(\"server got request: %?\", request);\n        if request.starts_with(\"dupe: \")\n        {\n            let reply = request.slice(0, \"dupe: \".len());\n            write_str(sock, reply + reply);\n        }\n        else if request.starts_with(\"shutdown:\")\n        {\n            // We need to stop the server tasks here. Sockets are closed when the last referrence\n            // to them goes away. This will happen when we break out of this loop, but we\n            // still need to terminate the listen loop which is why we send to kill_chan.\n            let err = {err_name: ~\"shutdown\", err_msg: ~\"client requested server  shutdown\"};\n            kill_chan.send(option::Some(err)); \n            break;\n        }\n        else\n        {\n            fail fmt!(\"bad request: '%s'\", request);\n        }\n    }\n}\n\npriv fn run_client(addr: IpAddr, port: uint)\n{\n    let hl_loop = uv::global_loop::get();\n\n    error!(\"client is connecting\");\n    let result = tcp::connect(addr, port, hl_loop);\n    if result.is_ok()\n    {\n        error!(\"client connected\");\n        let sock = result::unwrap(move result);\n\n        write_str(&sock, ~\"dupe: hey\");\n        let reply = read_str(\"server reply\", &sock);\n        error!(\"client received: %?\", reply);\n        if reply != ~\"heyhey\"\n        {\n            fail fmt!(\"client expected 'heyhey', but found '%s'\", reply);\n        }\n\n        write_str(&sock, ~\"shutdown:\");\n    }\n    else\n    {\n        fail fmt!(\"connect failed: %?\", result.get_err());\n    }\n}\n\npriv fn write_str(sock: &tcp::TcpSocket, message: ~str)\n{\n    do str::as_bytes(message)\n    |buffer|\n    {\nerror!(\"   writing %?\", buffer);\n        let result = sock.write(buffer);\n        if result.is_err()\n        {\n            fail fmt!(\"write('%s') failed: %?\", message, result.get_err());\n        }\n    }\n}\n\n// TCP is a stream oriented protocol so there are no messages as such:\n// there are just streams of bytes. However framing does occur when\n// the network stack packages up the bytes into a packet. Here we assume\n// that our packets correspond to individual messages. In general this is\n// a terrible idea: messages may at some point become too large for a\n// single packet or the network stack may decide to gang up multiple\n// messages in one packet.\npriv fn read_str(expected: &str, sock: &tcp::TcpSocket) -> ~str\n{\n    // The right way to do this is to read each chunk, buffer the results,\n    // and return the message part (e.g. using a delimeter like a null\n    // character). Bonus points for not allowing rogue clients to grow\n    // the buffer arbitrarily large.\n    let timeout = 2000;                    // msecs\n    match sock.read(timeout)\n    {\n        result::Ok(buffer) =>\n        {\nerror!(\"   read %?\", buffer);\n            str::from_bytes(buffer)\n        }\n        result::Err(err) =>\n        {\n            fail fmt!(\"read %s failed: %?\", expected, err);\n        }\n    }\n}\n\nfn resolve_addr(addr: &str) -> IpAddr\n{\n    let hl_loop = uv::global_loop::get();\n    match ip::get_addr(addr, hl_loop)\n    {\n        result::Ok(addrs) if addrs.is_not_empty() =>\n        {\n            addrs[0]\n        }\n        result::Ok(*) =>\n        {\n            fail fmt!(\"ip::get_addr('%s') failed: empty result\", addr);\n        }\n        result::Err(err) =>\n        {\n            fail fmt!(\"ip::get_addr('%s') failed: %?\", addr, err);\n        }\n    }\n}\n\n#[test]\nfn simple_client_server()\n{\n    let exit_port = Port();\n    let exit_chan = Chan(exit_port);\n\n    let addr = resolve_addr(\"127.0.0.1\");\n    run_server(addr, server_port, exit_chan);\n\n    do task::spawn_sched(task::SingleThreaded)    // TODO: don't think we need to spawn a task here\n    {\n        run_client(addr, server_port);\n        exit_chan.send(());\n    }\n\n    // Wait for the server to finish.\n    exit_port.recv();\n    exit_port.recv();\n}\n```\n\nLogging shows this:\n\n```\nrustc --test tcp.rs && export RUST_LOG=tcp=3,std::net_tcp=3 && ./tcp\nwarning: no debug symbols in executable (-arch x86_64)\n\nrunning 1 test\nrust: ~\"server is listening\"\nrust: ~\"addr: { mut sin_family: 528, mut sin_port: 0, mut sin_addr: 16777343, mut sin_zero: (0, 0, 0, 0, 0, 0, 0, 0) }\"\nrust: ~\"listening for connections on 127.0.0.1\"\nrust: ~\"client is connecting\"\nrust: ~\"tcp_connect result_ch Chan_(18)\"\nrust: ~\"stream_handle_ptr outside interact 140379594689168\"\nrust: ~\"in interact cb for tcp client connect..\"\nrust: ~\"stream_handle_ptr in interact 140379594689168\"\nrust: ~\"tcp_init successful\"\nrust: ~\"dealing w/ ipv4 connection..\"\nrust: ~\"addr: { mut sin_family: 528, mut sin_port: 0, mut sin_addr: 16777343, mut sin_zero: (0, 0, 0, 0, 0, 0, 0, 0) }\"\nrust: ~\"tcp_connect successful\"\nrust: ~\"leaving tcp_connect interact cb...\"\nrust: ~\"tcp_connect result_ch Chan_(18)\"\nrust: ~\"successful tcp connection!\"\nrust: ~\"leaving tcp_connect_on_connect_cb\"\nrust: ~\"tcp::connect - received success on result_po\"\nrust: ~\"client connected\"\nrust: ~\"   writing ~[ 100, 117, 112, 101, 58, 32, 104, 101, 121, 0 ]\"\nrust: ~\"server is accepting a connection\"\nrust: ~\"in interact cb for tcp::accept\"\nrust: ~\"uv_tcp_init successful for client stream\"\nrust: ~\"successfully accepted client connection\"\nrust: ~\"in interact cb for tcp::write 140379593647056\"\nrust: ~\"uv_write() invoked successfully\"\nrust: ~\"successful write complete\"\nrust: ~\"server accepted the connection\"\nrust: ~\"starting tcp::read\"\nrust: ~\"in tcp::read_start before interact loop\"\nrust: ~\"starting tcp::read\"\nrust: ~\"in tcp::read_start before interact loop\"\nrust: ~\"in tcp::read_start interact cb 140379593647056\"\nrust: ~\"success doing uv_read_start\"\nrust: ~\"tcp::read before recv_timeout\"\nrust: ~\"in tcp::read_start interact cb 140379593647056\"\nrust: ~\"success doing uv_read_start\"\nrust: ~\"tcp read on_alloc_cb!\"\nrust: ~\"tcp::read before recv_timeout\"\nrust: ~\"tcp read on_alloc_cb h: 140379593655232 char_ptr: 140379605528064 sugsize: 65536\"\nrust: ~\"entering on_tcp_read_cb stream: 140379593655232 nread: 10\"\nrust: ~\"tcp on_read_cb nread: 10\"\nrust: ~\"exiting on_tcp_read_cb\"\nrust: ~\"tcp::read after recv_timeout\"\nrust: ~\"tcp::read: timed out..\"\nrust: ~\"tcp::read after recv_timeout\"\nrust: ~\"tcp::read: timed out..\"\nrust: ~\"in interact cb for tcp::read_stop\"\nrust: ~\"successfully called uv_read_stop\"\nrust: ~\"in interact cb for tcp::read_stop\"\nrust: ~\"successfully called uv_read_stop\"\nrust: task failed at 'read server request failed: { err_name: ~\"TIMEOUT\", err_msg: ~\"req timed out\" }', tcp.rs:156\nrust: task failed at 'read server reply failed: { err_name: ~\"TIMEOUT\", err_msg: ~\"req timed out\" }', tcp.rs:156\nrust: ~\"interact dtor for tcp_socket stream 140379593655232 loop 140379593647056\"\nrust: ~\"interact dtor for tcp_socket stream 140379594689168 loop 140379593647056\"\nrust: ~\"tcp_socket_dtor_close_cb exiting..\"\nrust: ~\"tcp_socket_dtor_close_cb exiting..\"\n/bin/sh: line 1: 56867 Segmentation fault: 11  ./tcp\nmake: *** [tcp] Error 139\nexited with code 2\n```\n\nSo it appears the the message _is_ being read but the read function isn't returning for some reason (the first message is \"dupe: hey\\0\" which is 10 bytes). This is on  Mac with rust from Sep 22, 2012.\n\nThe seg faults are a bit disturbing too...\n", "closed_by": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/3599/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/3599/timeline", "performed_via_github_app": null, "state_reason": "completed"}