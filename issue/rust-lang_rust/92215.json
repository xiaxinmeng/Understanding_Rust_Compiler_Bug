{"url": "https://api.github.com/repos/rust-lang/rust/issues/92215", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/92215/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/92215/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/92215/events", "html_url": "https://github.com/rust-lang/rust/issues/92215", "id": 1087238097, "node_id": "I_kwDOAAsO6M5Aze_R", "number": 92215, "title": "Bad optimisation of slice equality across platforms and architectures.", "user": {"login": "OMGtechy", "id": 5058104, "node_id": "MDQ6VXNlcjUwNTgxMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5058104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/OMGtechy", "html_url": "https://github.com/OMGtechy", "followers_url": "https://api.github.com/users/OMGtechy/followers", "following_url": "https://api.github.com/users/OMGtechy/following{/other_user}", "gists_url": "https://api.github.com/users/OMGtechy/gists{/gist_id}", "starred_url": "https://api.github.com/users/OMGtechy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/OMGtechy/subscriptions", "organizations_url": "https://api.github.com/users/OMGtechy/orgs", "repos_url": "https://api.github.com/users/OMGtechy/repos", "events_url": "https://api.github.com/users/OMGtechy/events{/privacy}", "received_events_url": "https://api.github.com/users/OMGtechy/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 10, "created_at": "2021-12-22T22:44:40Z", "updated_at": "2021-12-26T21:40:23Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "All of the information found here can be found and reproduced [here](https://github.com/OMGtechy/memcmp-issue).\r\n\r\nThe context for finding this problem is this: I was experimenting with string searching algorithms as a way of learning Rust, but when refactoring some code, hit a big performance regression.\r\n\r\nThe code having performance issues is a naive string search. It can be reproduced with different implementations, but I feel this one expresses things most concisely:\r\n```rust\r\npub fn naive_search_manual(haystack: &[u8], needle: &[u8]) -> Option<usize> {\r\n    if needle.is_empty() {\r\n        return Some(0usize);\r\n    }\r\n\r\n    haystack.windows(needle.len()).position(|candidate| {\r\n        for i in 0..candidate.len() {\r\n            if needle[i] != candidate[i] {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    })\r\n}\r\n```\r\nLet's call the above the \"manual search.\" The compiler correctly recognises that `i` will never be out of bounds, since the window size is `needle`'s length and therefore `candidate` is always the same size as the needle. All is well so far. However, this is just doing simple equality testing ... why not just check for equality?\r\n```rust\r\npub fn naive_search_equality(haystack: &[u8], needle: &[u8]) -> Option<usize> {\r\n    if needle.is_empty() {\r\n        return Some(0usize);\r\n    }\r\n\r\n    haystack.windows(needle.len()).position(|candidate| candidate == needle)\r\n}\r\n```\r\nMuch cleaner. However ...\r\n```\r\ntest bench_equality ... bench:         341 ns/iter (+/- 140)\r\ntest bench_manual   ... bench:         175 ns/iter (+/- 11)\r\n```\r\nThe performance is attrocious compared with the prior implementation. What's going on?\r\n\r\nAfter running a profiler on it, I saw some calls out to VC++ libraries in the slow version that were not present in the fast version. Thinking there might be some performance hazard in the Rust FFI hopping back and forth to so frequently, I tried statically linking things. The VC++ libraries disappeared from the profile, but the performance issue did not. All I saw was a huge amount of time spent in `memcmp`.\r\n\r\nAfter talking to some people on the Rust Language Community Discord server (https://discord.com/invite/rust-lang-community) - I thought it might be a Windows issue and did some investigation. I came across https://github.com/rust-lang/rust/issues/90360, which looked similar to what I was seeing. However, just to be sure, I checked on other platforms.\r\n\r\nIt reproduced on Linux (inside a docker instance). Assuming this was some quirk of docker on Windows, I tried it on my M1 Mac. It reproduced again. This does not appear to restricted to Windows at all.\r\n\r\nThe rustc version used is the same on each platform (except the host, of course)\r\n```\r\nrustc 1.57.0 (f1edd0429 2021-11-29)\r\nbinary: rustc\r\ncommit-hash: f1edd0429582dd29cccacaf50fd134b05593bd9c\r\ncommit-date: 2021-11-29\r\nhost: [ ... snip ... ]\r\nrelease: 1.57.0\r\nLLVM version: 13.0.0\r\n```\r\nThe hosts are:\r\n```\r\nhost: x86_64-pc-windows-msvc\r\nhost: x86_64-unknown-linux-gnu\r\nhost: aarch64-apple-darwin\r\n```\r\nThe disassembly for each can be found in the repo linked at the start of this issue. The docker variant doesn't use `memcmp`, but does use `bcmp`.\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/92215/reactions", "total_count": 2, "+1": 2, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/92215/timeline", "performed_via_github_app": null, "state_reason": null}