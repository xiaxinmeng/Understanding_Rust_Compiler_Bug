{"url": "https://api.github.com/repos/rust-lang/rust/issues/6996", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/6996/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/6996/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/6996/events", "html_url": "https://github.com/rust-lang/rust/issues/6996", "id": 15283047, "node_id": "MDU6SXNzdWUxNTI4MzA0Nw==", "number": 6996, "title": "Use of GC inside destructors aborts when destructor called from GC", "user": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 36953, "node_id": "MDU6TGFiZWwzNjk1Mw==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-runtime", "name": "A-runtime", "color": "f7e101", "default": false, "description": "Area: std's runtime and \"pre-main\" init for handling backtraces, unwinds, stack overflows"}, {"id": 37544, "node_id": "MDU6TGFiZWwzNzU0NA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-typesystem", "name": "A-typesystem", "color": "f7e101", "default": false, "description": "Area: The type system"}, {"id": 100522, "node_id": "MDU6TGFiZWwxMDA1MjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-crash", "name": "I-crash", "color": "e10c02", "default": false, "description": "Issue: The compiler crashes (SIGSEGV, SIGABRT, etc). Use I-ICE instead when the compiler panics."}, {"id": 43009118, "node_id": "MDU6TGFiZWw0MzAwOTExOA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-destructors", "name": "A-destructors", "color": "f7e101", "default": false, "description": "Area: destructors (Drop, ..)"}, {"id": 60344715, "node_id": "MDU6TGFiZWw2MDM0NDcxNQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/P-medium", "name": "P-medium", "color": "eb6420", "default": false, "description": "Medium priority"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 13, "created_at": "2013-06-07T17:32:30Z", "updated_at": "2014-10-11T19:15:42Z", "closed_at": "2014-10-11T19:14:55Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "# Updated example\n\n``` rust\nuse std::task;\nuse std::gc::{GC, Gc};\nuse std::cell::RefCell;\n\nstruct Foo;\nimpl Drop for Foo {\n    fn drop(&mut self) {\n        allocate();\n    }\n}\n\nfn allocate() {\n    struct A {\n        inner: RefCell<Option<Gc<A>>>,\n        other: Foo,\n    }\n    let a = box(GC) A {\n        inner: RefCell::new(None),\n        other: Foo,\n    };\n    *a.inner.borrow_mut() = Some(a.clone());\n}\n\nfn main() {\n    allocate();\n}\n```\n\n```\nfailed at 'assertion failed: self.live_allocs.is_null()', /home/rustbuild/src/rust-buildbot/slave/nightly-linux/build/src/librustrt/local_heap.rs:173\nrun with `RUST_BACKTRACE=1` to see a backtrace\n\nYou've met with a terrible fate, haven't you?\n\nfatal runtime error: Could not unwind stack, error = 5\nzsh: illegal hardware instruction (core dumped)  ./foo\n```\n# Original description\n\nThis program crashes:\n\n```\nstruct Foo { x: int } // surprisingly, doesn't crash with an empty struct\n\nimpl Drop for Foo {\n    fn finalize(&self) {\n        let _x = @Foo { x: self.x + 1 };\n    }\n}\n\nfn main() { let _x = @Foo { x: 0 }; }\n```\n\nWith the current implementation, the crash message is:\n\n```\nrust: task f46140 ran out of stack\nrust: domain main @0xf44a40 root task failed\nrust: task f46140 ran out of stack during unwinding\nterminate called after throwing an instance of 'rust_task*'\nAborted\n```\n\nBut when we switch to tracing GC for @-pointers, I predict a new problem: the destructor won't run until an attempt to allocate another @-pointer fails, at which point @-pointers could no longer be allocatable... and the allocation would fail (even though the amount of live memory in use might be reasonably small). This raises some questions:\n- Should we ban creating new @-pointers in destructors, or does \"disable recursive GC\" during GC\" suffice?\n- Depending on the allocator design, would that also make it unsafe to allocate ~-pointers in destructors?\n\nRelated #910.\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/6996/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/6996/timeline", "performed_via_github_app": null, "state_reason": "completed"}