{"url": "https://api.github.com/repos/rust-lang/rust/issues/71025", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/71025/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/71025/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/71025/events", "html_url": "https://github.com/rust-lang/rust/issues/71025", "id": 598270379, "node_id": "MDU6SXNzdWU1OTgyNzAzNzk=", "number": 71025, "title": "Sub-optimal codegen: Unnecessarily dumping AVX registers to stack", "user": {"login": "ejmahler", "id": 1156730, "node_id": "MDQ6VXNlcjExNTY3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1156730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ejmahler", "html_url": "https://github.com/ejmahler", "followers_url": "https://api.github.com/users/ejmahler/followers", "following_url": "https://api.github.com/users/ejmahler/following{/other_user}", "gists_url": "https://api.github.com/users/ejmahler/gists{/gist_id}", "starred_url": "https://api.github.com/users/ejmahler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ejmahler/subscriptions", "organizations_url": "https://api.github.com/users/ejmahler/orgs", "repos_url": "https://api.github.com/users/ejmahler/repos", "events_url": "https://api.github.com/users/ejmahler/events{/privacy}", "received_events_url": "https://api.github.com/users/ejmahler/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 234956, "node_id": "MDU6TGFiZWwyMzQ5NTY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-codegen", "name": "A-codegen", "color": "f7e101", "default": false, "description": "Area: Code generation"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 631737389, "node_id": "MDU6TGFiZWw2MzE3MzczODk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-simd", "name": "A-simd", "color": "f7e101", "default": false, "description": "Area: SIMD (Single Instruction Multiple Data)"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-04-11T13:51:49Z", "updated_at": "2022-03-25T01:46:40Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\n\r\nI tried this code ([example 1](https://rust.godbolt.org/z/86FfSi)), in which we have a public function `mutate_array` that internally calls `mutate_chunk`:\r\n\r\n```rust\r\nuse std::arch::x86_64::*;\r\n\r\n#[inline(always)]\r\npub unsafe fn mutate_chunk(rows: [__m256d; 4]) -> [__m256d; 4] {\r\n    [\r\n        _mm256_permute2f128_pd(rows[0], rows[1], 0x20),\r\n        _mm256_permute2f128_pd(rows[2], rows[3], 0x20),\r\n        _mm256_permute2f128_pd(rows[0], rows[1], 0x31),\r\n        _mm256_permute2f128_pd(rows[2], rows[3], 0x31),\r\n    ]\r\n}\r\n\r\n\r\n#[target_feature(enable = \"avx\")]\r\npub unsafe fn mutate_array(input: *const f64, output: *mut f64) {\r\n    let mut input_data = [_mm256_setzero_pd(); 4];\r\n\r\n    for i in 0..4 {\r\n        input_data[i] = _mm256_loadu_pd(input.add(4*i));\r\n    }\r\n\r\n    let output_data = mutate_chunk(input_data);\r\n\r\n    for i in 0..4 {\r\n        _mm256_storeu_pd(output.add(4*i), output_data[i]);\r\n    }\r\n}\r\n```\r\n\r\nThis is a very stripped-down example of code that appears all over my project. We load data into AVX registers, do some sort of operation on the loaded data, then store it back to memory. The (more or less) optimal assembly for this example code is:\r\n```\r\nexample::mutate_array:\r\n        vmovups ymm0, ymmword ptr [rdi]\r\n        vmovups ymm1, ymmword ptr [rdi + 32]\r\n        vmovups ymm2, ymmword ptr [rdi + 64]\r\n        vmovups ymm3, ymmword ptr [rdi + 96]\r\n        vperm2f128      ymm4, ymm0, ymm1, 32\r\n        vperm2f128      ymm5, ymm2, ymm3, 49\r\n        vperm2f128      ymm0, ymm0, ymm1, 49\r\n        vperm2f128      ymm1, ymm2, ymm3, 32\r\n        vmovups ymmword ptr [rsi], ymm4\r\n        vmovups ymmword ptr [rsi + 32], ymm1\r\n        vmovups ymmword ptr [rsi + 64], ymm0\r\n        vmovups ymmword ptr [rsi + 96], ymm5\r\n        vzeroupper\r\n        ret\r\n```\r\n4 loads, 4 permutes, 4 stores.\r\n\r\nAs you can see from the godbolt link, the actual generated assembly is quite a bit longer:\r\n\r\n```\r\nexample::mutate_array:\r\n        push    rbp\r\n        mov     rbp, rsp\r\n        and     rsp, -32\r\n        sub     rsp, 288\r\n        vmovups ymm0, ymmword ptr [rdi]\r\n        vmovups ymm1, ymmword ptr [rdi + 32]\r\n        vmovups ymm2, ymmword ptr [rdi + 64]\r\n        vmovups ymm3, ymmword ptr [rdi + 96]\r\n        vmovaps ymmword ptr [rsp + 96], ymm3\r\n        vmovaps ymmword ptr [rsp + 64], ymm2\r\n        vmovaps ymmword ptr [rsp + 32], ymm1\r\n        vmovaps ymmword ptr [rsp], ymm0\r\n        vmovaps ymm0, ymmword ptr [rsp]\r\n        vmovaps ymm1, ymmword ptr [rsp + 32]\r\n        vmovaps ymm2, ymmword ptr [rsp + 64]\r\n        vmovaps ymm3, ymmword ptr [rsp + 96]\r\n        vperm2f128      ymm4, ymm0, ymm1, 32\r\n        vmovaps ymmword ptr [rsp + 128], ymm4\r\n        vperm2f128      ymm4, ymm2, ymm3, 32\r\n        vperm2f128      ymm0, ymm0, ymm1, 49\r\n        vperm2f128      ymm1, ymm2, ymm3, 49\r\n        vmovaps ymmword ptr [rsp + 160], ymm4\r\n        vmovaps ymmword ptr [rsp + 192], ymm0\r\n        vmovaps ymmword ptr [rsp + 224], ymm1\r\n        vmovaps ymm0, ymmword ptr [rsp + 224]\r\n        vmovups ymmword ptr [rsi + 96], ymm0\r\n        vmovaps ymm0, ymmword ptr [rsp + 192]\r\n        vmovups ymmword ptr [rsi + 64], ymm0\r\n        vmovaps ymm0, ymmword ptr [rsp + 160]\r\n        vmovups ymmword ptr [rsi + 32], ymm0\r\n        vmovaps ymm0, ymmword ptr [rsp + 128]\r\n        vmovups ymmword ptr [rsi], ymm0\r\n        mov     rsp, rbp\r\n        pop     rbp\r\n        vzeroupper\r\n        ret\r\n```\r\n\r\nThe second assembly block is the same as the first, except for the addition of reads/writes to the `rsp` (ie the stack). It loads the 4 values from memory fine -- but before running the permutes, it stores the values to `rsp`, then immediately reads them back. Same thing after the permutes: Before writing the data to the output, it stores it to `rsp`, then immediately reads it back.\r\n\r\nIt's possible to nudge the compiler into generating the correct output by partially unrolling the input and output loops.\r\n\r\nBy changing the input loop\r\n```rust\r\nfor i in 0..4 {\r\n    input_data[i] = _mm256_loadu_pd(input.add(4*i));\r\n}\r\n```\r\nto\r\n```rust\r\nfor i in 0..2 {\r\n    input_data[i*2] =   _mm256_loadu_pd(input.add(8*i));\r\n    input_data[i*2+1] = _mm256_loadu_pd(input.add(8*i + 4));\r\n}\r\n```\r\nwe can see that the loop is functionally identical, but the compiler no longer writes the inputs to the stack ([example 2](https://rust.godbolt.org/z/8Ct7Uu)).\r\n\r\nWe can apply the same treatment to the output loop, completely eliminating the stack reads and writes: [example 3](https://rust.godbolt.org/z/PHhARc).\r\n\r\nWithout knowing anything about the internals of the compiler, I can imagine two possibilities here:\r\n 1. Example 1 demonstrates trivial missed optimization: the compiler is unrolling the loop, but fails to determine that it can eliminate the array. As a result, it more than doubles the instruction count of the function, tanking performance.\r\n 2. Alternatively, something in the Rust standard requires all arrays to have an in-memory representation, and they aren't allowed to be completely optimized away to register storage, even entirely within a function. If this is the case, then examples 2 and 3 demonstrate a code generation bug, because we can clearly see that the storage to the array was completely optimized away.\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.44.0-nightly (42abbd887 2020-04-07)\r\nbinary: rustc\r\ncommit-hash: 42abbd8878d3b67238f3611b0587c704ba94f39c\r\ncommit-date: 2020-04-07\r\nhost: x86_64-pc-windows-msvc\r\nrelease: 1.44.0-nightly\r\nLLVM version: 9.0\r\n```", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/71025/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/71025/timeline", "performed_via_github_app": null, "state_reason": null}