{"url": "https://api.github.com/repos/rust-lang/rust/issues/36481", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/36481/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/36481/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/36481/events", "html_url": "https://github.com/rust-lang/rust/issues/36481", "id": 177041425, "node_id": "MDU6SXNzdWUxNzcwNDE0MjU=", "number": 36481, "title": "Exposure of HashMap iteration order allows for O(n\u00b2) blowup.", "user": {"login": "Veedrac", "id": 2867413, "node_id": "MDQ6VXNlcjI4Njc0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/2867413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veedrac", "html_url": "https://github.com/Veedrac", "followers_url": "https://api.github.com/users/Veedrac/followers", "following_url": "https://api.github.com/users/Veedrac/following{/other_user}", "gists_url": "https://api.github.com/users/Veedrac/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veedrac/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veedrac/subscriptions", "organizations_url": "https://api.github.com/users/Veedrac/orgs", "repos_url": "https://api.github.com/users/Veedrac/repos", "events_url": "https://api.github.com/users/Veedrac/events{/privacy}", "received_events_url": "https://api.github.com/users/Veedrac/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 60344715, "node_id": "MDU6TGFiZWw2MDM0NDcxNQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/P-medium", "name": "P-medium", "color": "eb6420", "default": false, "description": "Medium priority"}, {"id": 166999014, "node_id": "MDU6TGFiZWwxNjY5OTkwMTQ=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-collections", "name": "A-collections", "color": "f7e101", "default": false, "description": "Area: std::collections."}, {"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 101, "created_at": "2016-09-14T22:41:40Z", "updated_at": "2023-02-05T05:57:06Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Exposing `HashMap`'s iteration order can cause `O(n\u00b2)` blowup even in innocent-looking code _without_ the presence of an attacker. In the presence of an attacker, access to the order of a dictionary allows HashDoS-like attacks with only two requests in common scenarios.\n## Without an attacker\n\nConsider a user with two possibly-disjoint hash maps\n\n```\nlet first_map: HashMap<u64, _> = (0..900000).map(|i| (i, ())).collect();\nlet second_map: HashMap<u64, _> = (900000..1800000).map(|i| (i, ())).collect();\n```\n\nThe user wants to merge the hash maps, and does so na\u00efvely,\n\n```\nlet mut merged = first_map;\nmerged.extend(second_map);\n```\n\nTime for merge when `second_map` is shuffled: **0.4s**\n\nTime for merge when `second_map` is not shuffled: **40.s** (x100 amplification)\n\nThis effect is noticeably more pronounced when merging with a round robin strategy.\n## With an attacker\n\nThe threat model here is simple. The attacker is able to send JSON to the server. The server parses the JSON into a `HashMap` and through whatever means - an error message including the formatted map or explicit listing of the contents of the map - may reveal the order of the map.\n\nThe attack on this model requires two requests. The first sends some large JSON to the server\n\n```\nlet first_request: HashMap<u64, _> = (0..900000).map(|i| (i, ())).collect();\n```\n\nand recieves an ordering\n\n```\nlet returned_data: Vec<_> = first_request.into_iter().collect();\n```\n\nThe attacker then sends the first and third quarter of this list in a new JSON object.\n\n```\nlet second_request: HashMap<u64, _> =\n returned_data[..225000].iter()\n     .chain(&returned_data[450000..675000])\n     .cloned().collect();\n```\n\nTotal time _without_ second request: **0.1s**\n\nTotal time _with_ second request: **200s** (x2000 amplification)\n\n---\n## Solutions, near-solutions and non-solutions\n\nThese solutions should not be considered to be ordered, necessarily disjoint, nor an exhaustive list of options.\n### Fall back to `BTreeMap`\n\nIt should be clear that we cannot treat hash maps as a solved problem just because we use `SipHash`. In fact, `SipHash` is entirely insufficient to solve the problem. My first suggestion is thus to stop trying to make the hasher secure, and instead fall back to `BTreeMap` when nonlinear behaviour is detected.\n\nThis guarantees a minimum level of performance regardless of the capabilities of the attacker, and allows usage of a faster hashing algorithm by default. Hash maps should get faster by default as a result. This does not prevent having to consider the issue, since the fallback is costly and must be rare, but this is an easier problem than entirely securing the hash map.\n### Use a hash map without problematic blowup, or less affected by it\n\nJava solves this problem by using a hash map with chaining and converting large buckets to tree maps. This mitigates the impact of degradation, but does not seem to allow using contiguous hash maps by default.\n\nAs far as I am aware, the blowup cannot be resolved by moving to another common form of open addressing, although quadratic probing would be significantly less affected by some of these attacks. Chaining alone also defeats the attacks given here, but still requires a secure hash and fails with attackers with more capabilities.\n### Use different seeds for each hash map\n\nPull requests #31356 (closed) and #33318 (merged) first proposed incrementing the thread local seed for each hash map. This was later removed when no threat model was seen, but would prevent both attacks listed here.\n\nThis still allows attacks when hash maps are reused.\n### Randomize iteration order\n\nI am not sure how one would randomize iteration order efficiently. However, it should solve the problem unless hashes are exposed through other means.\n### Ignore the problem\n\nGiven that Rust went so far as to use `SipHash`, quadratic blowup on code as simple as `fst.extend(snd)` seems too extreme to ignore.\n", "closed_by": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/36481/reactions", "total_count": 33, "+1": 25, "-1": 0, "laugh": 0, "hooray": 5, "confused": 0, "heart": 3, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/36481/timeline", "performed_via_github_app": null, "state_reason": null}