{"url": "https://api.github.com/repos/rust-lang/rust/issues/38230", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/38230/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/38230/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/38230/events", "html_url": "https://github.com/rust-lang/rust/issues/38230", "id": 194206379, "node_id": "MDU6SXNzdWUxOTQyMDYzNzk=", "number": 38230, "title": "Sorting `&[usize]` is slower than sorting equivalent `&[isize]`", "user": {"login": "ghost", "id": 10137, "node_id": "MDQ6VXNlcjEwMTM3", "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ghost", "html_url": "https://github.com/ghost", "followers_url": "https://api.github.com/users/ghost/followers", "following_url": "https://api.github.com/users/ghost/following{/other_user}", "gists_url": "https://api.github.com/users/ghost/gists{/gist_id}", "starred_url": "https://api.github.com/users/ghost/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ghost/subscriptions", "organizations_url": "https://api.github.com/users/ghost/orgs", "repos_url": "https://api.github.com/users/ghost/repos", "events_url": "https://api.github.com/users/ghost/events{/privacy}", "received_events_url": "https://api.github.com/users/ghost/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2016-12-07T23:40:40Z", "updated_at": "2016-12-09T11:54:03Z", "closed_at": "2016-12-09T11:54:03Z", "author_association": "NONE", "active_lock_reason": null, "body": "```\r\n$ echo \"fn main() { (0usize..10_000_000).map(|x| x * x * x * 18913515181 % 1_000_000).map(|x| x as usize).collect::<Vec<_>>().sort(); }\" | rustc -O - && time ./rust_out\r\n0.918\r\n$ echo \"fn main() { (0usize..10_000_000).map(|x| x * x * x * 18913515181 % 1_000_000).map(|x| x as isize).collect::<Vec<_>>().sort(); }\" | rustc -O - && time ./rust_out\r\n0.826\r\n```\r\n\r\nNote that this is a fair comparison.\r\nBoth cases sort the same sequence of numbers small enough to fit in both usize and isize.\r\n\r\nC++ doesn't suffer from the same problem:\r\n\r\n```\r\n$ echo -e \"#include <algorithm>\\n long long a[int(1e7)]; int main() { for (unsigned long long i = 0; i < 1e7; ++i) a[i] = i * i * i * 18913515181 % 1000000000; std::sort(a, a + int(1e7)); return 0; }\" | clang++ -O2 -x c++ - && time ./a.out\r\n0.839\r\n$ echo -e \"#include <algorithm>\\n unsigned long long a[int(1e7)]; int main() { for (unsigned long long i = 0; i < 1e7; ++i) a[i] = i * i * i * 18913515181 % 1000000000; std::sort(a, a + int(1e7)); return 0; }\" | clang++ -O2 -x c++ - && time ./a.out\r\n0.839\r\n```\r\n\r\nNote that I'm being careful not to invoke undefined behavior here (i.e. overflowing is ok in case of unsigned integers).\r\n\r\nI don't think our sort algorithm is at fault here. Let's see the difference in produced assembly:\r\n\r\n```\r\n$ echo \"fn main() { (0usize..10_000_000).map(|x| x * x * x * 18913515181 % 1_000_000).map(|x| x as usize).collect::<Vec<_>>().sort(); }\" | rustc -O --emit asm -o usize.s -                                 \r\n$ echo \"fn main() { (0usize..10_000_000).map(|x| x * x * x * 18913515181 % 1_000_000).map(|x| x as isize).collect::<Vec<_>>().sort(); }\" | rustc -O --emit asm -o isize.s -                                 \r\n$ diff -u usize.s isize.s\r\n--- usize.s     2016-12-08 00:28:41.866753541 +0100\r\n+++ isize.s     2016-12-08 00:28:48.347759690 +0100\r\n@@ -120,7 +120,7 @@\r\n        movq    (%rdi,%r8,8), %rbp\r\n        leaq    8(%rdx), %rax\r\n        cmpq    -8(%rbx), %rbp\r\n-       jb      .LBB0_12\r\n+       jl      .LBB0_12\r\n        jmp     .LBB0_15\r\n        .p2align        4, 0x90\r\n .LBB0_13:\r\n@@ -173,7 +173,7 @@\r\n        je      .LBB0_21\r\n        movq    -8(%r13), %rax\r\n        cmpq    (%r13), %rax\r\n-       ja      .LBB0_21\r\n+       jg      .LBB0_21\r\n        movq    %r13, %rbp\r\n        subq    %rsi, %rbp\r\n        andq    $-8, %rbp\r\n@@ -201,9 +201,9 @@\r\n        leaq    8(%rax), %r8\r\n        leaq    8(%rsi), %r9\r\n        cmpq    %rbp, %rcx\r\n-       cmovbeq %r9, %rsi\r\n-       cmovaq  %r8, %rax\r\n-       cmovaq  %rbp, %rcx\r\n+       cmovleq %r9, %rsi\r\n+       cmovgq  %r8, %rax\r\n+       cmovgq  %rbp, %rcx\r\n        movq    %rcx, (%rbx)\r\n        addq    $8, %rbx\r\n        cmpq    %r14, %rbx\r\n```\r\n\r\nThe generated files are differing in just a few signed vs unsigned instructions.\r\n\r\nFinally, let me also show the difference in assembly produced by C++: [link](https://gist.github.com/stjepang/7ece505e89a0a6348603e531976b8f39)\r\nAgain, a few differing signed vs unsigned instructions, but in this case no difference in performance.\r\n\r\nSo, what is going on here? I really can't explain why the performance of sort regresses as soon as we switch from `isize` to `usize`. Any ideas?", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/38230/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/38230/timeline", "performed_via_github_app": null, "state_reason": "completed"}