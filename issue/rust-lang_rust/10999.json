{"url": "https://api.github.com/repos/rust-lang/rust/issues/10999", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/10999/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/10999/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/10999/events", "html_url": "https://github.com/rust-lang/rust/issues/10999", "id": 24352642, "node_id": "MDU6SXNzdWUyNDM1MjY0Mg==", "number": 10999, "title": "Borrow checker is sensitive to the order of borrows in surprising ways", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2013-12-16T14:33:51Z", "updated_at": "2013-12-16T14:40:52Z", "closed_at": "2013-12-16T14:40:52Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Here is a piece of code that borrow-checks:\n\n``` rust\nuse std::util;\n\nenum List<T> {\n    Cons(T, ~List<T>),\n    Nil\n}\n\nfn pop<T>(prev: &mut ~List<T>) -> Option<~List<T>> {\n    let xs = util::replace(match prev {\n        &~Cons(_, ref mut rs) => rs,\n        &~Nil => return None\n    }, ~Nil);\n    Some(util::replace(prev, xs))\n}\n```\n\nHere is a rewritten variant of `pop`, where the let has been substituted in, which does not borrow-check:\n\n``` rust\nfn pop<T>(prev: &mut ~List<T>) -> Option<~List<T>> {\n    Some(util::replace(prev, util::replace(match prev {\n        &~Cons(_, ref mut rs) => rs,\n        &~Nil => return None\n    }, ~Nil)))\n}\n```\n\nfailing with:\n\n```\ndel.rs|22 col 18 error| cannot borrow `(**prev)#1` as mutable more than once at a time\ndel.rs|21 col 23 n| second borrow of `(**prev)#1` as mutable occurs here\n```\n\nWhat is going on? The problem has to do with the _order of arguments_ to the outer replace. Consider this alternate version, which has a flipped replace function:\n\n``` rust\npub fn freplace<T>(mut src: T, dest: &mut T) -> T {\n    util::swap(dest, &mut src);\n    src\n}\n\nfn pop<T>(prev: &mut ~List<T>) -> Option<~List<T>> {\n    Some(freplace(util::replace(match prev {\n        &~Cons(_, ref mut rs) => rs,\n        &~Nil => return None\n    }, ~Nil), prev))\n}\n```\n\nThis borrow-checks fine. The key is that the borrow-checker is interpreting the original (failing) code as something like this:\n\n``` rust\nfn pop2<T>(prev: &mut ~List<T>) -> Option<~List<T>> {\n    let ref mut prev2 : &mut ~List<T> = prev;\n    let xs = util::replace(match prev {\n        &~Cons(_, ref mut rs) => rs,\n        &~Nil => return None\n    }, ~Nil);\n    Some(util::replace(*prev2, xs))\n}\n```\n\nwhereas the succeeding code is more like:\n\n``` rust\nfn pop2<T>(prev: &mut ~List<T>) -> Option<~List<T>> {\n    let xs = util::replace(match prev {\n        &~Cons(_, ref mut rs) => rs,\n        &~Nil => return None\n    }, ~Nil);\n    let ref mut prev2 : &mut ~List<T> = prev;\n    Some(util::replace(*prev2, xs))\n}\n```\n\nOperationally, all of these code fragments do the same thing, since only one of the two arguments has side-effects; but of course, to the borrow-checker, a borrow counts as a side-effect.\n\nSince borrows commute, one way to fix this is \"sink\" big borrows as late as possible (in analogy to how you sink memory dereferences to reduce register pressure). I don't actually know if this works or is a good idea.\n\nIf you squint, fixing Issue #6268 might resolve this issue as well. My interpretation goes something like this: the big borrow starts off as the secondary aliasing loan, permitting the inner replace, before it becomes a proper primary loan.\n\nCC @nikomatsakis \n", "closed_by": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/10999/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/10999/timeline", "performed_via_github_app": null, "state_reason": "completed"}