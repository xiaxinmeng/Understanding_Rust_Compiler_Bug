{"url": "https://api.github.com/repos/rust-lang/rust/issues/45889", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/45889/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/45889/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/45889/events", "html_url": "https://github.com/rust-lang/rust/issues/45889", "id": 272619487, "node_id": "MDU6SXNzdWUyNzI2MTk0ODc=", "number": 45889, "title": "[NLL] extend MIR type checker to check aggregate rvalues", "user": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 67766349, "node_id": "MDU6TGFiZWw2Nzc2NjM0OQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/E-mentor", "name": "E-mentor", "color": "02E10C", "default": false, "description": "Call for participation: This issue has a mentor. Use RustcContributor::new on Zulip for discussion."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-11-09T16:07:53Z", "updated_at": "2017-11-13T09:12:54Z", "closed_at": "2017-11-13T09:12:54Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Once #45825 lands,  we will be using the MIR type checker to drive the NLL region checker. This means we'll have to fix a few omissions. One of them is that MIR type checker does not check MIR rvalues (expressions that construct a value) for internal validity.\r\n\r\nHere is an example NLL program affected by this:\r\n\r\n```\r\n#![allow(unused_assignments)]\r\n\r\nstruct Wrap<'a> { w: &'a mut u32 }\r\n\r\nfn foo() {\r\n    let mut x = 22;\r\n    let wrapper = Wrap { w: &mut x };\r\n    x += 1;\r\n    *wrapper.w += 1;\r\n}\r\n\r\nfn main() { }\r\n```\r\n\r\nIf you run this with `-Znll -Zborrowck-mir`, you'll see that it emits just one error, tagged with `(Ast)`:\r\n\r\n```\r\nerror[E0506]: cannot assign to `x` because it is borrowed (Ast)\r\n --> /home/nmatsakis/tmp/mir-rvalue.rs:8:5\r\n  |\r\n7 |     let wrapper = Wrap { w: &mut x };\r\n  |                                  - borrow of `x` occurs here\r\n8 |     x += 1;\r\n  |     ^^^^^^ assignment to borrowed `x` occurs here\r\n```\r\n\r\nThis error indicates that the old borrow checker is reporting an error, but we would expect *both* the old and new borrow check to report an error. \r\n\r\nWhat's going wrong here is as follows:\r\n\r\n- The `Wrap { w: &mut x }` expression introduces a region variable `'?0` representing the region parameter of `Wrap`. You can think of it like `Wrap::<'?0> { w: &mut x }`.\r\n- For the struct expression to be well-typed, then, we ought to check that the expected type `E` of each field (as taken from the struct declaration) is a supertype of the type `V` of the value assigned to it (in other words, that `V <: E`). \r\n    - Here, the expected type would be `&'?0 mut u32`, and the type `V` would be the type `&'?1 mut u32`, where `'?1` that is the lifetime of the borrow. Hence you would  have `&'?1 u32 <: &'?0 u32`, which in turn means `'?1: '?0`.\r\n    - However, the current MIR type-checker does not generate such a constraint, so we wind up with no relation between `'?0` and `'?1`.\r\n\r\nThe reason why is not hard to see. The MIR type checker's \"main loop\" is right here:\r\n\r\nhttps://github.com/rust-lang/rust/blob/fd9ecfdfd01c0954172a002cc806174a077b9e3d/src/librustc_mir/transform/type_check.rs#L747-L757\r\n\r\nIt basically invokes `check_stmt` on every MIR statement. In this case, the statement in question will be an assignment statement. You can see that yourself if you run with `-Zverbose -Zmir-dump='foo&nll'` (in addition to the other options) and open the resulting NLL file (it will generate a lot of files; the you want is `rustc.node12.-------.nll.0.mir`). The interesting statement is this one, the 7th statement in `bb0` (written `bb0[7]`):\r\n\r\n```\r\n        _2 = Wrap<'_#2r> { w: _3 };\r\n```\r\n\r\nHere we have an assignment statement, with the lvalue (left-hand side) being the variable `_2`  and the rvalue (right-hand side) being `Wrap<'_#2r> { w: _3 }`. This is a [struct aggregate rvalue](https://github.com/rust-lang/rust/blob/fd9ecfdfd01c0954172a002cc806174a077b9e3d/src/librustc/mir/mod.rs#L1316). If we look then at the types of the variables `_2` and `_3`, we see:\r\n\r\n```\r\nlet _2: Wrap<'_#5r>;\r\nlet mut _3: &'_#6r mut u32;\r\n```\r\n\r\nRight now, what `check_stmt` does for an assignment statement is to compute the type of the rvalue and check that it is a subtype of the lvalue:\r\n\r\nhttps://github.com/rust-lang/rust/blob/fd9ecfdfd01c0954172a002cc806174a077b9e3d/src/librustc_mir/transform/type_check.rs#L398-L405\r\n\r\nThe type of the rvalue here will be `Wrap<'_#2r>`, so we will get a relationship `'_#2r: '_#5r` (this `'_#` is the compiler's way of printing a region variable; equivalent to the `'?` I was using). But we get **no** relation to the type of `_3`.\r\n\r\nSo we need to add some kind of function `check_rvalue`, and call it here. It would visit the inside of an rvalue and make sure its types are internally consistent. I think that for the purposes of this bug, it would only handle aggregate rvalues, we can add other cases later.\r\n\r\nThe first step we need to do for this case is to compute the expected types of all the fields, based on the field declaration. There is actually code to do this already. The [`sanitize_projection` method](https://github.com/rust-lang/rust/blob/fd9ecfdfd01c0954172a002cc806174a077b9e3d/src/librustc_mir/transform/type_check.rs#L164-L169) has the job of checking that a path like `a.b` has a valid type. To do that, it must lookup the type of `b` and check it. This is done by [invoking the `field_ty` method](https://github.com/rust-lang/rust/blob/fd9ecfdfd01c0954172a002cc806174a077b9e3d/src/librustc_mir/transform/type_check.rs#L281-L286), defined on `TypeVerifier`. (The type verifier is kind of like a little pre-pass; it checks that some basic assumptions are met before the type-checker proper runs.)\r\n\r\nThere is no reason for this method to be confined to `TypeVerified`; it should be easy enough to promote to the `TypeChecker` (the verifier can then invoke it via `self.cx.field_ty` instead).\r\n\r\nOnce that method has been moved, our `check_rvalue` method can invoke it to find the types of each field in the aggregate, and then can invoke `sub_types` on the actual type of the operand. \r\n\r\nSo, the complete set of steps:\r\n\r\n- Promote `field_ty` onto the `TypeChecker`\r\n- Introduce `check_rvalue` method, leaving cases largely unhandled\r\n- For aggregate, use `field_ty` to check the relationship between the operand provided and the field's expected type\r\n- Done.\r\n\r\nOnce we've finished this, there is more to do. For example, we need to check that the various where clauses declared on the type are met, and handle other kinds of rvalues. But I'm going to defer those to other issues. (Predicates, for example, are https://github.com/rust-lang/rust/issues/45827)\r\n\r\n", "closed_by": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/45889/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/45889/timeline", "performed_via_github_app": null, "state_reason": "completed"}