{"url": "https://api.github.com/repos/rust-lang/rust/issues/61695", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/61695/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/61695/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/61695/events", "html_url": "https://github.com/rust-lang/rust/issues/61695", "id": 453906105, "node_id": "MDU6SXNzdWU0NTM5MDYxMDU=", "number": 61695, "title": "Tracking issue for `Result::into_ok`", "user": {"login": "phaylon", "id": 41822, "node_id": "MDQ6VXNlcjQxODIy", "avatar_url": "https://avatars.githubusercontent.com/u/41822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phaylon", "html_url": "https://github.com/phaylon", "followers_url": "https://api.github.com/users/phaylon/followers", "following_url": "https://api.github.com/users/phaylon/following{/other_user}", "gists_url": "https://api.github.com/users/phaylon/gists{/gist_id}", "starred_url": "https://api.github.com/users/phaylon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phaylon/subscriptions", "organizations_url": "https://api.github.com/users/phaylon/orgs", "repos_url": "https://api.github.com/users/phaylon/repos", "events_url": "https://api.github.com/users/phaylon/events{/privacy}", "received_events_url": "https://api.github.com/users/phaylon/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 246778137, "node_id": "MDU6TGFiZWwyNDY3NzgxMzc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/B-unstable", "name": "B-unstable", "color": "d304cb", "default": false, "description": "Implemented in the nightly compiler and unstable."}, {"id": 650846969, "node_id": "MDU6TGFiZWw2NTA4NDY5Njk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-tracking-issue", "name": "C-tracking-issue", "color": "f5f1fd", "default": false, "description": "Category: A tracking issue for an RFC or an unstable feature."}, {"id": 2238600090, "node_id": "MDU6TGFiZWwyMjM4NjAwMDkw", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-result-option", "name": "A-result-option", "color": "f7e101", "default": false, "description": "Area: Result and Option combinators"}, {"id": 2240305001, "node_id": "MDU6TGFiZWwyMjQwMzA1MDAx", "url": "https://api.github.com/repos/rust-lang/rust/labels/Libs-Tracked", "name": "Libs-Tracked", "color": "d4c5f9", "default": false, "description": "Libs issues that are tracked on the team's project board."}, {"id": 2240342704, "node_id": "MDU6TGFiZWwyMjQwMzQyNzA0", "url": "https://api.github.com/repos/rust-lang/rust/labels/Libs-Small", "name": "Libs-Small", "color": "d4c5f9", "default": false, "description": "Libs issues that are considered \"small\" or self-contained"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 17, "created_at": "2019-06-09T14:58:40Z", "updated_at": "2022-02-10T16:44:00Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I would like to propose adding a `unwrap_infallible` associated function to `core::result::Result`. The purpose is to convert `Result<T, core::convert::Infallible>` to a `T`, as the error case is impossible.\r\n\r\nThe implementation would basically be:\r\n\r\n```rust\r\nimpl<T> Result<T, Infallible> {\r\n    #[inline]\r\n    pub fn unwrap_infallible(self) -> T {\r\n        match self {\r\n            Ok(value) => value,\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nAn example use-case I have is a wrapper type with generic value verification, like `Handle<T:Verify>`. Some verifications can fail, but some can not. When verification is infallible, a `Result<Handle<T>, Infallible>` will be returned.\r\n\r\nSince some can fail, the `Handle` type implements `TryFrom` and not `From`. Because of the blanket implementation of `TryFrom` for all types implementing `From`, I can't additionally add a `From` conversion for the infallible cases. This blanket implementation makes sense, as it allows an API to take a `T: TryFrom` and handle all possible conversions, even infallible ones.\r\n\r\nBut for the API consumer it would be beneficial to be able to go from an infallible `Result<T, Infallible>` to a plain `T` without having to manually match or use `expect`. The latter is shorter and chainable, but has the disadvantage that it will still compile when the types are changed and the conversion is no longer infallible.\r\n\r\nIt might be that there is a different solution to infallible conversions via `TryFrom` in the future, for example via specialization. I believe that having an `unwrap_infallible` would still be beneficial in many other cases where generically fallible actions can be infallible in certain situations. One example is when working with a library that is based on fallible operations with a user supplied error type, but where the specific implementation from the user is infallible.\r\n\r\nI'd be happy to work on a PR for this if it's acceptable to add, though I might require some guidance with regards to stability attributes, feature flags and so on. It's a bit hard to find information on that, and experimentation is costly as it takes me a while to complete a `./x.py test src/libcore` :)", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/61695/reactions", "total_count": 20, "+1": 20, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/61695/timeline", "performed_via_github_app": null, "state_reason": null}