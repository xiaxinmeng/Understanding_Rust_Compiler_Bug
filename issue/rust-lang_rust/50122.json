{"url": "https://api.github.com/repos/rust-lang/rust/issues/50122", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/50122/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/50122/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/50122/events", "html_url": "https://github.com/rust-lang/rust/issues/50122", "id": 316328929, "node_id": "MDU6SXNzdWUzMTYzMjg5Mjk=", "number": 50122, "title": "How to determine hygienic context for \"non-atomic\" code fragments", "user": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 632573348, "node_id": "MDU6TGFiZWw2MzI1NzMzNDg=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-macros-2.0", "name": "A-macros-2.0", "color": "f7e101", "default": false, "description": "Area: declarative macros 2.0, https://github.com/rust-lang/rust/issues/39412"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2018-04-20T16:15:30Z", "updated_at": "2018-09-25T13:57:00Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Reminder: Syntactic/hygienic context is formally a \"chain of expansions\" and informally \"the place where something is actually written\". For example, in this example\r\n```rust\r\nmacro m($b: expr) {\r\n    a + $b\r\n}\r\n\r\nlet x = m!(b);\r\n```\r\n`a`'s context is inside the macro `m` and `b`'s - outside of the macro.\r\nWith Macro 2.0 hygiene names are resolved in locations where they are \"actually written\".\r\n\r\nFor \"atomic\" tokens like identifiers or punctuation signs the context is unambiguous, but complex entities like expressions or types can be combined from tokens introduced in different contexts, look for example at this code ultimately expanding into `println!(\"Hello world!\")`\r\n```rust\r\nmacro context_parens($name: tt, $bang: tt, $args: tt) {\r\n    $name $bang ( $args )\r\n}\r\n\r\nmacro context_hello($name: tt, $bang: tt) {\r\n    context_parens!($name, $bang, \"Hello world!\")\r\n}\r\n\r\nmacro context_bang($name: tt) {\r\n    context_hello!($name, !)\r\n}\r\n\r\nmacro context_println() {\r\n    context_bang!(println)\r\n}\r\n\r\nfn main() {\r\n    context_println!();\r\n}\r\n```\r\n\r\nSo, what is the \"call site\" context of the `println` macro in this case?\r\nWhere should we resolve identifiers with call-site hygiene for macros invoked like this?\r\n\r\nContexts of \"non-atomic\" entities are important for several other reason than determining call-site hygiene, for example in `Struct { field1, field2, ..rest }` fields `fieldN` where `N > 2` are checked for privacy in the context of `..rest` fragment, but that fragment may also be a Frankenstein's monster combined from pieces with different contexts.\r\n\r\n---\r\nProposed solution:\r\n\r\nFor each complex entity figure out and document an atomic entity that is \"essential\" for that complex entity and that serves as a source of hygienic context for the complex entity.\r\n\r\nFor example, for binary operator expressions the context may be determined by the context of the operator: `context($a + $b) = context(+)`, for the \"remaining fields\" fragment `..$rest` mentioned above the context may be determined by the context of `..`, etc.\r\n\r\nI'm... not sure what that essential atomic token would be for macro invocations, probably `!` for bang macros and `[]` for attribute macros.\r\n(Note that paired delimiters like `()`, `[]` and `{}` always have the same context in a pair).", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/50122/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/50122/timeline", "performed_via_github_app": null, "state_reason": null}