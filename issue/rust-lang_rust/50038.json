{"url": "https://api.github.com/repos/rust-lang/rust/issues/50038", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/50038/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/50038/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/50038/events", "html_url": "https://github.com/rust-lang/rust/issues/50038", "id": 315284702, "node_id": "MDU6SXNzdWUzMTUyODQ3MDI=", "number": 50038, "title": "What exactly token streams are passed to procedural macros 1.2", "user": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 632573348, "node_id": "MDU6TGFiZWw2MzI1NzMzNDg=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-macros-2.0", "name": "A-macros-2.0", "color": "f7e101", "default": false, "description": "Area: declarative macros 2.0, https://github.com/rust-lang/rust/issues/39412"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 17, "created_at": "2018-04-18T00:13:15Z", "updated_at": "2018-04-21T16:18:44Z", "closed_at": "2018-04-21T16:18:44Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "This is an issue that needs to be resolved before stabilization of \"Macros 1.2\".\r\n\r\nProcedural macros that we are going to stabilize currently have two flavors - `proc_macro` and `proc_macro_attribute`.\r\n\r\n---\r\n`proc_macro` macros have signature `fn(TokenStream) -> TokenStream` and can be invoked with \"bang\" forms like this:\r\n```rust\r\nmy::proc::macro!( TOKEN_STREAM )\r\nmy::proc::macro![ TOKEN_STREAM ]\r\nmy::proc::macro! { TOKEN_STREAM }\r\n```\r\n\r\nOnly the `TOKEN_STREAM` part is passed to the macro as `TokenStream`, the delimiters (brackets) are NOT passed.\r\n\r\nWhy this is bad:\r\n- The macro doesn't know what delimiters it was invoked with.\r\nIt was a part of Macro 2.0 promise to give macros control over delimiters in their invocations, so e.g. `vec`-like macros could require square brackets like `vec![1, 2, 3]` and reject other brackets.\r\nWe should not prevent this kind of control being implemented in the future.\r\n\r\nWhy this is good:\r\n- Brackets are mostly not a part of the \"useful payload\" for the macro, they are there so macro invocations could be parsed unambiguously in many context in which they can appear - expressions, types, blocks, modules, etc, etc, etc.\r\n\r\n---\r\n`proc_macro_attribute` macros have signature `fn(TokenStream, TokenStream) -> TokenStream` and can be invoked with \"attribute\" forms like this:\r\n```rust\r\n#[my::proc::macro TOKEN_STREAM] TARGET\r\n#![my::proc::macro TOKEN_STREAM] TERGET\r\n```\r\n\r\n`TARGET` is a trait/impl/foreign item, or a statement and it's passed to the macro as the second `TokenStream` argument, but we are not interested in it right now.\r\n\r\nThe `TOKEN_STREAM` part is passed to the macro as the first `TokenStream` argument, nothing is ignored.\r\n\r\nWhy this is bad:\r\n- It's not clear where the path ends and where the token stream starts.\r\nSomething like `#[a::b :: + -]` seems to match the grammar, but is rejected right now because paths always parsed greedily so `::` is interpreted as a path separator rather than a path of the token stream.\r\nAnnoying questions arise with generic arguments in paths like `#[a<>::b::c<u8>]`. Technically this is a syntactically valid path and `c` having type arguments is rather a semantic error and the empty  `<>` after the module `a` is not an error at all, but rigth now this attribute is interpreted as `#[a /* <- PATH | TOKEN_STREAM -> */ <>::b::c<u8>]`.\r\nIdeally we'd like to avoid these questions completely and have an unambiguous delimiter.\r\n- It's not clear where the token stream *ends*.\r\nWith plain `#[attr TOKEN_STREAM]` it's pretty clear - the stream ends before the `]` (in this sense the situation is simpler than with bang macros), but things start breaking when other macros appear.\r\n    ```rust\r\n    macro m($meta1: meta, $meta2: meta) { ... }\r\n    \r\n    // No way to determine where the first attribute starts and the second attribute ends\r\n    m!( a::b::c x , y , z , d::e::f u , v , w )\r\n    ```\r\n    So with this attribute syntax we can't support `meta` anymore!\r\n- It's not consistent with `proc_macro` macros. `m!(a, b, c)` does not include parentheses into the token stream, but `#[m(a, b, c)]` does.\r\n- I'm not actually sure people *intend* to stabilize this attribute syntax suddenly expanded from traditional forms (`#[attr]`, `#[attr(list)]`, `#[attr = literal]`) to being nearly unlimited (i.e. something like `#[a::b::c e f + c ,,, ;_:]` being legal) right now.\r\n\r\n---\r\n\r\nProposed solution:\r\n- Stabilize `proc_macro` as is for \"Macros 1.2\".\r\n- In the future extend the set of `proc_macro` plugin interfaces with one more signature `fn(TokenStream, Delimiter) -> TokenStream` that allows controlling delimiters used in macro invocations.\r\n- In the future possibly support bang macro invocations without delimiters for symmetry with attributes and because they may be legitimately useful (`let x = MACRO_CONST!;`, see https://internals.rust-lang.org/t/idea-elide-parens-brackets-on-unparametrized-macros/6527) (the `Delimiter` argument is `Delimiter::None` in this case).\r\n\r\n- Restrict attribute syntax accepted by `proc_macro_attribute` for \"Macros 1.2\" to\r\n    ```rust\r\n    // Symmetric with bang macro invocations\r\n    #[my::proc::macro(TOKEN_STREAM)]\r\n    #[my::proc::macro[TOKEN_STREAM]]\r\n    #[my::proc::macro { TOKEN_STREAM }]\r\n    // Additionally\r\n    #[my::proc::macro]\r\n    #[my::proc::macro = TOKEN_TREE]\r\n    ```\r\n    Or, more radically, do not stabilize the `=` syntax for procedural macros 1.2.\r\nThis is not a fundamental restriction - arbitrary token streams still can be placed inside the brackets (`#[a::b::c(e f + c ,,, ;_:)]`).\r\n- The token stream passed to the macro DOES NOT include the delimiters.\r\n- In the future extend the set of `proc_macro_attribute` plugin interfaces with one more signature `fn(TokenStream, TokenStream, Delimiter) -> TokenStream` that allows controlling delimiters used in macro invocations (the delimiter is `Delimiter::None` for both `#[attr]` and `#[attr = tt]` forms but they are still discernable by the token stream being empty or not).", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/50038/reactions", "total_count": 2, "+1": 2, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/50038/timeline", "performed_via_github_app": null, "state_reason": "completed"}