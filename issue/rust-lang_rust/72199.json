{"url": "https://api.github.com/repos/rust-lang/rust/issues/72199", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/72199/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/72199/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/72199/events", "html_url": "https://github.com/rust-lang/rust/issues/72199", "id": 618331301, "node_id": "MDU6SXNzdWU2MTgzMzEzMDE=", "number": 72199, "title": "Primitive vs struct antipattern?", "user": {"login": "sjep", "id": 61925014, "node_id": "MDQ6VXNlcjYxOTI1MDE0", "avatar_url": "https://avatars.githubusercontent.com/u/61925014?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sjep", "html_url": "https://github.com/sjep", "followers_url": "https://api.github.com/users/sjep/followers", "following_url": "https://api.github.com/users/sjep/following{/other_user}", "gists_url": "https://api.github.com/users/sjep/gists{/gist_id}", "starred_url": "https://api.github.com/users/sjep/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sjep/subscriptions", "organizations_url": "https://api.github.com/users/sjep/orgs", "repos_url": "https://api.github.com/users/sjep/repos", "events_url": "https://api.github.com/users/sjep/events{/privacy}", "received_events_url": "https://api.github.com/users/sjep/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 171502053, "node_id": "MDU6TGFiZWwxNzE1MDIwNTM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-borrow-checker", "name": "A-borrow-checker", "color": "f7e101", "default": false, "description": "Area: The borrow checker"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-05-14T15:38:04Z", "updated_at": "2023-01-23T08:19:26Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "This is coming from a stack overflow [question](https://stackoverflow.com/questions/61732690/why-is-it-allowed-to-have-both-immutable-and-mutable-borrows-of-a-vector-of-nume/61734260#61734260).\r\n\r\nMy answer didn't sit well with me. While it's true that the `add_assign` isn't called in the primitive case, the fact that it's called shouldn't cause a compilation failure because the Vec isn't being passed in.\r\n\r\nThe below fails to compile:\r\n\r\n```rust\r\n\ufeff\ufeffuse std::ops::AddAssign;\r\n\r\n#[derive(Clone, Copy, PartialEq, Debug, Default)]\r\nstruct MyNum(i32);\r\n\r\nimpl AddAssign for MyNum {\r\n    fn add_assign(&mut self, rhs: MyNum) {\r\n        *self = MyNum(self.0 + rhs.0)\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let mut b = vec![MyNum(0), MyNum(1)];\r\n    b[0] += b[1];\r\n}\r\n```\r\nWith this message:\r\n```none\r\nerror[E0502]: cannot borrow `b` as immutable because it is also borrowed as mutable\r\n  --> src/main.rs:14:13\r\n   |\r\n14 |     b[0] += b[1];\r\n   |     --------^---\r\n   |     |       |\r\n   |     |       immutable borrow occurs here\r\n   |     mutable borrow occurs here\r\n   |     mutable borrow later used here\r\n```\r\n\r\nHowever this works:\r\n```rust\r\nfn main() {\r\n    let mut b = vec![1, 2];\r\n    b[0] += b[1];\r\n}\r\n```\r\n\r\nLooking at the MIR, the only difference I can see is in the primitive case Index is called _before_ IndexMut whereas in the struct case that is reversed. I don't see why the struct needs to behave differently.\r\n\r\nI expected to see this happen: the primitive case and the struct case should either both fail or both succeed. In my mind, they should both succeed as the dereference for `b[1]` can complete before `b[0]`.\r\n\r\nIf the mutable struct needs to exist first for some reason then the slice version should also fail, but this works:\r\n```rust\r\nuse std::ops::AddAssign;\r\n\r\n#[derive(Clone, Copy, PartialEq, Debug, Default)]\r\nstruct MyNum(i32);\r\n\r\nimpl AddAssign for MyNum {\r\n    fn add_assign(&mut self, rhs: MyNum) {\r\n        *self = MyNum(self.0 + rhs.0)\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let mut b = vec![MyNum(0), MyNum(1)];\r\n    let slice = b.as_mut_slice();\r\n    slice[0] += slice[1];\r\n}\r\n```\r\n\r\n### Meta\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.45.0-nightly (75e1463c5 2020-05-13)\r\nbinary: rustc\r\ncommit-hash: 75e1463c52aaea25bd32ed53c73797357e561cce\r\ncommit-date: 2020-05-13\r\nhost: x86_64-apple-darwin\r\nrelease: 1.45.0-nightly\r\nLLVM version: 9.0\r\n```\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/72199/reactions", "total_count": 2, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 2}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/72199/timeline", "performed_via_github_app": null, "state_reason": null}