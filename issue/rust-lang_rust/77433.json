{"url": "https://api.github.com/repos/rust-lang/rust/issues/77433", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/77433/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/77433/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/77433/events", "html_url": "https://github.com/rust-lang/rust/issues/77433", "id": 713224662, "node_id": "MDU6SXNzdWU3MTMyMjQ2NjI=", "number": 77433, "title": "Suboptimal performance of BinaryHeap::append", "user": {"login": "hanmertens", "id": 21318961, "node_id": "MDQ6VXNlcjIxMzE4OTYx", "avatar_url": "https://avatars.githubusercontent.com/u/21318961?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hanmertens", "html_url": "https://github.com/hanmertens", "followers_url": "https://api.github.com/users/hanmertens/followers", "following_url": "https://api.github.com/users/hanmertens/following{/other_user}", "gists_url": "https://api.github.com/users/hanmertens/gists{/gist_id}", "starred_url": "https://api.github.com/users/hanmertens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hanmertens/subscriptions", "organizations_url": "https://api.github.com/users/hanmertens/orgs", "repos_url": "https://api.github.com/users/hanmertens/repos", "events_url": "https://api.github.com/users/hanmertens/events{/privacy}", "received_events_url": "https://api.github.com/users/hanmertens/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 166999014, "node_id": "MDU6TGFiZWwxNjY5OTkwMTQ=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-collections", "name": "A-collections", "color": "f7e101", "default": false, "description": "Area: std::collections."}, {"id": 2011781731, "node_id": "MDU6TGFiZWwyMDExNzgxNzMx", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs", "name": "T-libs", "color": "bfd4f2", "default": false, "description": "Relevant to the library team, which will review and decide on the PR/issue."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2020-10-01T22:27:37Z", "updated_at": "2021-01-16T14:04:43Z", "closed_at": "2021-01-16T14:04:43Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "The [current implementation of `BinaryHeap::append`](https://github.com/rust-lang/rust/blob/8fe73e80d762bc575040239fc05fb1c612873554/library/alloc/src/collections/binary_heap.rs#L609) uses a heuristic based on the worst-case number of comparisons to determine between two strategies:\r\n\r\n1. Calling `self.extend(other.drain())`, equivalent to pushing all elements of the other heap.\r\n2. Appending the vector of the other heap and rebuilding the heap from scratch.\r\n\r\nI've done some benchmarking, and it turns out that method 1 (based on `extend`) is always faster for two heaps based on randomly shuffled data &ndash; on the computers I've tested it on, anyway. I've included images of [the benchmarks](https://github.com/hanmertens/dary_heap/blob/3fe25525773f42d53174599d54490f001e4929af/benches/dary_heap.rs) below: first the current `append` strategy, then the `extend` strategy (method 1). In the benchmarks, two heaps are merged, one containing the number of elements on the *x*-axis, the other containing 100,000 minus that number (for the rightmost data points both heaps are equal in size). The red line (sometimes hiding behind the green one) is in both images that corresponding to `std::collections::BinaryHeap`, the other lines are not relevant to this issue (they aren't standard library types).\r\n\r\n![append](https://user-images.githubusercontent.com/21318961/94867430-8c68dd00-0441-11eb-8858-55f0a23f75f5.png)\r\n![extend](https://user-images.githubusercontent.com/21318961/94867441-8ffc6400-0441-11eb-8b6f-7d42c46f9d2d.png)\r\n\r\nFrom the jump in performance in the first graph, you can clearly see when the switch between the two approaches happens. Graphs are similar for smaller heaps, I didn't test larger ones. It's possible method 2 is faster under other circumstances (maybe if one of the heaps contains mostly very small/large elements?), especially if both heaps are (almost) equal in size. However, I think the benchmark is more close to the \"average\" real-world use case than such a case would be (I'd be happy to be proven wrong about this, though).\r\n\r\n<details><summary>Simplification of the benchmark that only runs the parts relevant for this issue</summary>\r\n\r\n##### `Cargo.toml`\r\n```toml\r\n[package]\r\nname = \"binary_heap_bench\"\r\nversion = \"0.1.0\"\r\nedition = \"2018\"\r\n\r\n[dependencies]\r\ncriterion = \"0.3\"\r\nrand = \"0.7\"\r\n\r\n[[bench]]\r\nname = \"benchmark\"\r\nharness = false\r\n```\r\n\r\n##### `benches/benchmark.rs`\r\n```rust\r\nuse criterion::*;\r\nuse rand::{seq::SliceRandom, thread_rng};\r\nuse std::collections::BinaryHeap;\r\nuse std::iter::FromIterator;\r\nuse std::mem;\r\n\r\n/// Data type we want to use\r\ntype T = u32;\r\n\r\n/// Produce shuffled vector containing values 0..n\r\nfn random_data(n: T) -> Vec<T> {\r\n    let mut data = Vec::from_iter(0..n);\r\n    data.shuffle(&mut thread_rng());\r\n    data\r\n}\r\n\r\nfn two_heaps<H: From<Vec<T>>>(mut vec1: Vec<T>, i: usize) -> (H, H) {\r\n    let vec2 = vec1.split_off(i);\r\n    (vec1.into(), vec2.into())\r\n}\r\n\r\nfn std_heap_append((mut heap1, mut heap2): (BinaryHeap<T>, BinaryHeap<T>)) -> BinaryHeap<T> {\r\n    heap1.append(&mut heap2);\r\n    heap1\r\n}\r\n\r\nfn std_heap_extend((mut heap1, mut heap2): (BinaryHeap<T>, BinaryHeap<T>)) -> BinaryHeap<T> {\r\n    if heap1.len() < heap2.len() {\r\n        mem::swap(&mut heap1, &mut heap2);\r\n    }\r\n    heap1.extend(heap2.drain());\r\n    heap1\r\n}\r\n\r\nfn benchmark(c: &mut Criterion) {\r\n    let mut group = c.benchmark_group(\"append/extend\");\r\n    let base = 100000;\r\n    let step = 2500;\r\n    for i in (step..=base as usize / 2).step_by(step) {\r\n        let size = BatchSize::SmallInput;\r\n        group.bench_function(BenchmarkId::new(\"append\", i), |b| {\r\n            b.iter_batched(|| two_heaps(random_data(base), i), std_heap_append, size)\r\n        });\r\n        group.bench_function(BenchmarkId::new(\"extend\", i), |b| {\r\n            b.iter_batched(|| two_heaps(random_data(base), i), std_heap_extend, size)\r\n        });\r\n    }\r\n}\r\n\r\ncriterion_group!(benches, benchmark);\r\ncriterion_main!(benches);\r\n```\r\n</details>", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/77433/reactions", "total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 1, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/77433/timeline", "performed_via_github_app": null, "state_reason": "completed"}