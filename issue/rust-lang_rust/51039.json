{"url": "https://api.github.com/repos/rust-lang/rust/issues/51039", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/51039/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/51039/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/51039/events", "html_url": "https://github.com/rust-lang/rust/issues/51039", "id": 326208401, "node_id": "MDU6SXNzdWUzMjYyMDg0MDE=", "number": 51039, "title": "[idea] attr for function prototype assertion", "user": {"login": "jnqnfe", "id": 33935229, "node_id": "MDQ6VXNlcjMzOTM1MjI5", "avatar_url": "https://avatars.githubusercontent.com/u/33935229?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jnqnfe", "html_url": "https://github.com/jnqnfe", "followers_url": "https://api.github.com/users/jnqnfe/followers", "following_url": "https://api.github.com/users/jnqnfe/following{/other_user}", "gists_url": "https://api.github.com/users/jnqnfe/gists{/gist_id}", "starred_url": "https://api.github.com/users/jnqnfe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jnqnfe/subscriptions", "organizations_url": "https://api.github.com/users/jnqnfe/orgs", "repos_url": "https://api.github.com/users/jnqnfe/repos", "events_url": "https://api.github.com/users/jnqnfe/events{/privacy}", "received_events_url": "https://api.github.com/users/jnqnfe/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-05-24T16:56:40Z", "updated_at": "2018-10-02T17:56:34Z", "closed_at": "2018-10-02T17:56:34Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I have a program with support for plugins. Plugins are dynamically loaded on demand. In C a macro was used for defining the start of the function that is the entry point into the plugin, which guaranteed that this function in all plugins (official and 3rd-party) always had the correct prototype/signature. Trying to hack a similar macro based solution into the new Rust codebase is not exactly ideal, and thus in my new Rust codebase such functions are now written without any such hackish thing. It would be great if there were some neat and simple solution for checking at compile time that these functions match a certain signature. Without such a solution, if the signature changes in the program's core lib, and a plugin is forgotten to be updated, compiling works successfully and you only (possibly) notice the problem later at runtime.\r\n\r\nI envision a simple solution like follows, You:\r\n1) define a public type describing the signature\r\n2) against the relevant function, declare a \"prototype_match\" attribute, pointing it at the signature type.\r\n\r\nAlternatively, the signature type could be `use`d and the name only specified in the attr.\r\n\r\nSometimes it may also be important that the function name is something specific, thus an additional attribute for that.\r\n\r\nAn example:\r\n\r\nIn the core lib, `::plugins` mod\r\n```rust\r\npub type DescriptorFnSig = fn(&Foo) -> Result<Bar, ()>;\r\npub const DescriptorFnName: &str = \"foo_plugin_descriptor\";\r\n```\r\nIn an example plugin, suggested usage # 1\r\n```rust\r\nextern crate foo;\r\nuse foo::{Foo, Bar};\r\n\r\n#[no_mangle]\r\n#[attr(prototype_match=\"foo::plugins::DescriptorFnSig\")]\r\n#[attr(symbol_name=\"foo::plugins::DescriptorFnName\")]\r\npub fn foo_plugin_descriptor(foo: &Foo) -> Result<Bar, ()> {\r\n    //whatever\r\n}\r\n```\r\nIn an example plugin, suggested usage # 2\r\n```rust\r\nextern crate foo;\r\nuse foo::{Foo, Bar};\r\nuse foo::plugins::{DescriptorFnSig, DescriptorFnName}\r\n\r\n#[no_mangle]\r\n#[attr(prototype_match=DescriptorFnSig)]\r\n#[attr(symbol_name=DescriptorFnName)]\r\npub fn foo_plugin_descriptor(foo: &Foo) -> Result<Bar, ()> {\r\n    //whatever\r\n}\r\n```\r\nIf the function to which these attr are attached is found to not match what is specified, a error should occur at compile time. Also if what is pointed to by the attr is not found, an error (or warning?) occurs.\r\n\r\nIt may not be enough though for these attributes to only exist against functions, there may be other uses for them. For instance, in the C code for this program, the function names actually have an ABI version embedded in them. In the Rust codebase it would be a major pain to be renaming all such functions in every plugin to do similar (and using macros is as already suggested not ideal - I don't much like the idea of forcing the entire function body through a macro invocation). Alternatively they could have a public no_mangle symbol which declares the ABI version that the plugin was compiled against. These concepts could be applied to such a `const`, thus highlighting at compile time the problem if the expected name or type of this const ever changes.\r\n\r\nExample\r\nin the core lib, `::plugins` mod\r\n```rust\r\npub const ABIVersion = 1; // Current plugin ABI version\r\npub const ABISymbolName: &str = \"FOO_ABI_VERSION\";\r\npub type AbiVersionType = u16;\r\n```\r\nin a plugin:\r\n```rust\r\nextern crate foo;\r\nuse foo::plugins::{AbiVersionType, ABIVersion, ABISymbolName};\r\n#[no_mangle]\r\n#[attr(type_match=AbiVersionType)]\r\n#[attr(symbol_name=ABISymbolName)]\r\npub const FOO_ABI_VERSION: AbiVersionType = ABIVersion;\r\n```\r\n\r\nI am aware that the solution for converting C's static_asserts to Rust are to create a small unit test, and I could imagine that to some degree the same could be done here, however that's a rather messy solution in my opinion, and in a large and complex application as I'm working on I'm not convinced by it.\r\n\r\nThe solution proposed is much cleaner, surely of wide interest to programs with plugin systems, and surely very simple to implement in rustc.", "closed_by": {"login": "XAMPPRocky", "id": 4464295, "node_id": "MDQ6VXNlcjQ0NjQyOTU=", "avatar_url": "https://avatars.githubusercontent.com/u/4464295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/XAMPPRocky", "html_url": "https://github.com/XAMPPRocky", "followers_url": "https://api.github.com/users/XAMPPRocky/followers", "following_url": "https://api.github.com/users/XAMPPRocky/following{/other_user}", "gists_url": "https://api.github.com/users/XAMPPRocky/gists{/gist_id}", "starred_url": "https://api.github.com/users/XAMPPRocky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/XAMPPRocky/subscriptions", "organizations_url": "https://api.github.com/users/XAMPPRocky/orgs", "repos_url": "https://api.github.com/users/XAMPPRocky/repos", "events_url": "https://api.github.com/users/XAMPPRocky/events{/privacy}", "received_events_url": "https://api.github.com/users/XAMPPRocky/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/51039/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/51039/timeline", "performed_via_github_app": null, "state_reason": "completed"}