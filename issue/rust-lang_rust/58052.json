{"url": "https://api.github.com/repos/rust-lang/rust/issues/58052", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/58052/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/58052/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/58052/events", "html_url": "https://github.com/rust-lang/rust/issues/58052", "id": 405711646, "node_id": "MDU6SXNzdWU0MDU3MTE2NDY=", "number": 58052, "title": "Annotating higher-ranked lifetimes on closures is arduous", "user": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 1775993, "node_id": "MDU6TGFiZWwxNzc1OTkz", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-lifetimes", "name": "A-lifetimes", "color": "f7e101", "default": false, "description": "Area: lifetime related"}, {"id": 122406831, "node_id": "MDU6TGFiZWwxMjI0MDY4MzE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-closures", "name": "A-closures", "color": "f7e101", "default": false, "description": "Area: closures (`|args| { .. }`)"}, {"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2019-02-01T13:55:25Z", "updated_at": "2023-04-13T05:55:41Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "Executive summary: If you want to make a closure returning a higher-ranked lifetime, you need to use a helper like `fn annotate<T,F>(f: F) -> F where F: Fn(&T) -> &T { f }`. We could probably do better.\r\n\r\n----\r\n\r\nSpawned off of https://github.com/rust-lang/rust/issues/22557#issuecomment-77467069 (and possibly a duplicate of #22340 )\r\n\r\nConsider this code ([play](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=550d63c90360f959d74c512aad75bd95)):\r\n\r\n```rust\r\nfn main() {\r\n    let f = |x: &i32| x;\r\n    let i = &3;\r\n    let j = f(i);\r\n}\r\n```\r\n\r\nIt doesn't compile. And its diagnostic is pretty hard to understand.\r\n\r\nYou can see an explanation from @nikomatsakis about why it doesn't compile here: https://github.com/rust-lang/rust/issues/22557#issuecomment-77467069\r\n\r\nWith `#![feature(nll)]`, it still doesn't compile; the diagnostic is slightly better:\r\n\r\n```\r\nerror: lifetime may not live long enough\r\n --> src/main.rs:4:23\r\n  |\r\n4 |     let f = |x: &i32| x;\r\n  |                 -   - ^ returning this value requires that `'1` must outlive `'2`\r\n  |                 |   |\r\n  |                 |   return type of closure is &'2 i32\r\n  |                 let's call the lifetime of this reference `'1`\r\n```\r\n\r\n----\r\n\r\nThe aforementioned [explanation](https://github.com/rust-lang/rust/issues/22557#issuecomment-77467069) claims that adding a return type will get it to compile. But when I tried that, *it did not work*, both with and without `#![feature(nll)]` ([play](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=4c1949c24979c12ed83bdd58dd032a05), which includes NLL since I like its diagnostic here better):\r\n\r\n```rust\r\nfn main() {\r\n    let f = |x: &i32| -> &i32 { x };\r\n    let i = &3;\r\n    let j = f(i);\r\n}\r\n```\r\n\r\nyields (and we'll leave #58053 in its own bug):\r\n\r\n```\r\nerror: lifetime may not live long enough\r\n --> src/main.rs:4:33\r\n  |\r\n4 |     let f = |x: &i32| -> &i32 { x };\r\n  |                 -           -   ^ returning this value requires that `'1` must outlive `'2`\r\n  |                 |           |\r\n  |                 |           return type of closure is &'2 i32\r\n  |                 let's call the lifetime of this reference `'1`\r\n```\r\n\r\nSo what gives? Well, I think when @nikomatsakis claimed that an explicit return type would work, they were assuming that an explicit return type would cause lifetime elision rules to apply such that the same lifetime would be provided for the input and output reference-types on `f`. But as we saw in #56537, lifetime elision rules do not apply to closure return type annotations.\r\n\r\n----\r\n\r\nSo what we want is to say that we have a lifetime parametric closure, with a type something like `for<'a> Fn(&'a i32) -> &'a i32`. But no, that's not a type, its a trait bound, so this does not work either ([play](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=84058cafa8766434fbb5a92456a6cd3b)):\r\n\r\n```rust\r\nfn main() {\r\n    let f: for<'a> Fn(&'a i32) -> &'a i32 = |x| x;\r\n    let i = &3;\r\n    let j = f(i);\r\n}\r\n```\r\n\r\nyields:\r\n\r\n```\r\nerror[E0308]: mismatched types\r\n --> src/main.rs:4:45\r\n  |\r\n4 |     let f: for<'a> Fn(&'a i32) -> &'a i32 = |x| x;\r\n  |                                             ^^^^^ expected trait std::ops::Fn, found closure\r\n  |\r\n  = note: expected type `dyn for<'a> std::ops::Fn(&'a i32) -> &'a i32`\r\n             found type `[closure@src/main.rs:4:45: 4:50]`\r\n\r\nerror[E0277]: the size for values of type `dyn for<'a> std::ops::Fn(&'a i32) -> &'a i32` cannot be known at compilation time\r\n --> src/main.rs:4:9\r\n  |\r\n4 |     let f: for<'a> Fn(&'a i32) -> &'a i32 = |x| x;\r\n  |         ^ doesn't have a size known at compile-time\r\n  |\r\n  = help: the trait `std::marker::Sized` is not implemented for `dyn for<'a> std::ops::Fn(&'a i32) -> &'a i32`\r\n  = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\r\n  = note: all local variables must have a statically known size\r\n  = help: unsized locals are gated as an unstable feature\r\n```\r\n\r\n----\r\n\r\nAn approach that *does* work is to feed in the trait bound explicitly via a helper function, like this ([play](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2015&gist=bd1f8c14fab2930979e892b6e5b6e1c8)):\r\n\r\n```rust\r\nfn annotate<T,F>(f: F) -> F where F: Fn(&T) -> &T { f }\r\n\r\nfn main() {\r\n    let f = annotate(|x| x);\r\n    let i = &3;\r\n    let j = f(i);\r\n    assert_eq!(*j, 3);\r\n}\r\n```\r\n\r\nBut that seems like a pretty arduous way to encode a relatively simple pattern. If you look at https://github.com/rust-lang/rust/issues/22340#issuecomment-219794032, you can see others have suggested syntaxes like `for <'a> |x: &'a i32| -> &'a i32 { x }`, (where the `for <'a> CLOSURE_EXPR` is the new interesting expression form), which would be more convenient for addressing cases like ths.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/58052/reactions", "total_count": 22, "+1": 17, "-1": 0, "laugh": 0, "hooray": 0, "confused": 5, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/58052/timeline", "performed_via_github_app": null, "state_reason": null}