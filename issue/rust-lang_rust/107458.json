{"url": "https://api.github.com/repos/rust-lang/rust/issues/107458", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/107458/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/107458/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/107458/events", "html_url": "https://github.com/rust-lang/rust/issues/107458", "id": 1561537949, "node_id": "I_kwDOAAsO6M5dEy2d", "number": 107458, "title": "Combined enum optimization", "user": {"login": "DzenanJupic", "id": 56133904, "node_id": "MDQ6VXNlcjU2MTMzOTA0", "avatar_url": "https://avatars.githubusercontent.com/u/56133904?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DzenanJupic", "html_url": "https://github.com/DzenanJupic", "followers_url": "https://api.github.com/users/DzenanJupic/followers", "following_url": "https://api.github.com/users/DzenanJupic/following{/other_user}", "gists_url": "https://api.github.com/users/DzenanJupic/gists{/gist_id}", "starred_url": "https://api.github.com/users/DzenanJupic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DzenanJupic/subscriptions", "organizations_url": "https://api.github.com/users/DzenanJupic/orgs", "repos_url": "https://api.github.com/users/DzenanJupic/repos", "events_url": "https://api.github.com/users/DzenanJupic/events{/privacy}", "received_events_url": "https://api.github.com/users/DzenanJupic/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 630652267, "node_id": "MDU6TGFiZWw2MzA2NTIyNjc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-feature-request", "name": "C-feature-request", "color": "f5f1fd", "default": false, "description": "Category: A feature request, i.e: not implemented / a PR."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2023-01-30T00:38:15Z", "updated_at": "2023-01-30T16:47:59Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "Not totally sure how to title this issue. Not even sure if this can be solved in `rustc`, or if such optimizations happen in `llvm`. The issue is about an exhaustiveness optimization that the compiler performs for certain enums, but not for others, depending on the discriminant value.\r\n\r\nLet's say we have two enums:\r\n```rust\r\n#[repr(u8)]\r\npub enum InnerA {\r\n    A = 0b00,\r\n    B = 0b01,\r\n}\r\n\r\n#[repr(u8)]\r\npub enum InnerB {\r\n    A = 0b00,\r\n    B = 0b10,\r\n}\r\n```\r\n\r\nand want to create a combined type that also only takes up 8 bits. Using a `struct` with two fields does not work here, since the compiler doesn't 'merge' the enums into one byte, so we'd end up with 2 bytes instead.\r\nWe either have to use a bitmap, or we have to create a third enum. A third enum is more verbose but usually leads to cleaner (and better optimized) code down the line.\r\n\r\n```rust\r\n#[repr(u8)]\r\npub enum Combined {\r\n    AA = 0b00,\r\n    BA = 0b01,\r\n    AB = 0b10,\r\n    BB = 0b11,\r\n}\r\n```\r\n\r\nIf we now add all the required methods for converting between `u8` and the enum and checkout the generated code, we can see that the compiler does an amazing job at optimizing all the `unreachable`s away. [[godbolt](https://rust.godbolt.org/z/5EdfG7vq6)]\r\n\r\n<details>\r\n<summary>Code</summary>\r\n\r\n```rust\r\n#[repr(u8)]\r\n#[derive(Copy, Clone)]\r\npub enum Combined {\r\n    AA = 0b00,\r\n    BA = 0b01,\r\n    AB = 0b10,\r\n    BB = 0b11,\r\n}\r\n\r\nimpl Combined {\r\n    pub const fn new(a: InnerA, b: InnerB) -> Self {\r\n        match Self::from_u8(a as u8 | b as u8) {\r\n            Some(combined) => combined,\r\n            None => unreachable!(),\r\n        }\r\n    }\r\n    \r\n    pub const fn from_u8(val: u8) -> Option<Self> {\r\n        match val {\r\n            0b00 => Some(Self::AA),\r\n            0b01 => Some(Self::BA),\r\n            0b10 => Some(Self::AB),\r\n            0b11 => Some(Self::BB),\r\n            _ => None,\r\n        }\r\n    }\r\n    \r\n    pub const fn a(self) -> InnerA {\r\n        let a = self as u8 & InnerA::B as u8;\r\n        match InnerA::from_u8(a) {\r\n            Some(a) => a,\r\n            None => unreachable!(),\r\n        }\r\n    }\r\n    \r\n    pub const fn b(self) -> InnerB {\r\n        let b = self as u8 & InnerB::B as u8;\r\n        match InnerB::from_u8(b) {\r\n            Some(b) => b,\r\n            None => unreachable!(),\r\n        }\r\n    }\r\n}\r\n\r\n#[repr(u8)]\r\npub enum InnerA {\r\n    A = 0b00,\r\n    B = 0b01,\r\n}\r\n\r\nimpl InnerA {\r\n    pub const fn from_u8(val: u8) -> Option<Self> {\r\n        match val {\r\n            0b00 => Some(Self::A),\r\n            0b01 => Some(Self::B),\r\n            _ => None,\r\n        }\r\n    }\r\n}\r\n\r\n#[repr(u8)]\r\npub enum InnerB {\r\n    A = 0b00,\r\n    B = 0b10,\r\n}\r\n\r\n\r\nimpl InnerB {\r\n    pub const fn from_u8(val: u8) -> Option<Self> {\r\n        match val {\r\n            0b00 => Some(Self::A),\r\n            0b10 => Some(Self::B),\r\n            _ => None,\r\n        }\r\n    }\r\n}\r\n```\r\n</details>\r\n<details>\r\n<summary>Assembly</summary>\r\n\r\n```asm\r\nexample::Combined::new:\r\n        mov     eax, edi\r\n        or      eax, esi\r\n        ret\r\n\r\nexample::Combined::from_u8:\r\n        cmp     dil, 4\r\n        mov     eax, 4\r\n        cmovb   eax, edi\r\n        ret\r\n\r\nexample::Combined::a:\r\n        mov     eax, edi\r\n        and     al, 1\r\n        ret\r\n\r\nexample::Combined::b:\r\n        cmp     dil, 2\r\n        setae   al\r\n        add     al, al\r\n        ret\r\n\r\nexample::InnerA::from_u8:\r\n        cmp     dil, 1\r\n        sete    al\r\n        mov     cl, 2\r\n        sub     cl, al\r\n        xor     edx, edx\r\n        test    dil, dil\r\n        movzx   eax, cl\r\n        cmove   eax, edx\r\n        ret\r\n\r\nexample::InnerB::from_u8:\r\n        cmp     dil, 2\r\n        sete    al\r\n        xor     al, 3\r\n        xor     ecx, ecx\r\n        test    dil, dil\r\n        movzx   eax, al\r\n        cmove   eax, ecx\r\n        ret\r\n```\r\n</details>\r\n\r\nIf we now change the enum discriminates, however, so that not every possible bit pattern is covered, there's now suddenly a branch in `Combined::new` [[godbolt](https://rust.godbolt.org/z/s8jfTofvM)].\r\n\r\n<details>\r\n<summary>Code</summary>\r\n\r\n```rust\r\n#[repr(u8)]\r\n#[derive(Copy, Clone)]\r\npub enum Combined {\r\n    AA = 0b000,\r\n    BA = 0b001,\r\n    AB = 0b100,\r\n    BB = 0b101,\r\n}\r\n\r\nimpl Combined {\r\n    pub const fn new(a: InnerA, b: InnerB) -> Self {\r\n        match Self::from_u8(a as u8 | b as u8) {\r\n            Some(combined) => combined,\r\n            None => unreachable!(),\r\n        }\r\n    }\r\n    \r\n    pub const fn from_u8(val: u8) -> Option<Self> {\r\n        match val {\r\n            0b000 => Some(Self::AA),\r\n            0b001 => Some(Self::BA),\r\n            0b100 => Some(Self::AB),\r\n            0b101 => Some(Self::BB),\r\n            _ => None,\r\n        }\r\n    }\r\n    \r\n    pub const fn a(self) -> InnerA {\r\n        let a = self as u8 & InnerA::B as u8;\r\n        match InnerA::from_u8(a) {\r\n            Some(a) => a,\r\n            None => unreachable!(),\r\n        }\r\n    }\r\n    \r\n    pub const fn b(self) -> InnerB {\r\n        let b = self as u8 & InnerB::B as u8;\r\n        match InnerB::from_u8(b) {\r\n            Some(b) => b,\r\n            None => unreachable!(),\r\n        }\r\n    }\r\n}\r\n\r\n#[repr(u8)]\r\npub enum InnerA {\r\n    A = 0b000,\r\n    B = 0b001,\r\n}\r\n\r\nimpl InnerA {\r\n    pub const fn from_u8(val: u8) -> Option<Self> {\r\n        match val {\r\n            0b000 => Some(Self::A),\r\n            0b001 => Some(Self::B),\r\n            _ => None,\r\n        }\r\n    }\r\n}\r\n\r\n#[repr(u8)]\r\npub enum InnerB {\r\n    A = 0b000,\r\n    B = 0b100,\r\n}\r\n\r\n\r\nimpl InnerB {\r\n    pub const fn from_u8(val: u8) -> Option<Self> {\r\n        match val {\r\n            0b000 => Some(Self::A),\r\n            0b100 => Some(Self::B),\r\n            _ => None,\r\n        }\r\n    }\r\n}\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>Assembly</summary>\r\n\r\n```asm\r\nexample::Combined::new:\r\n        or      edi, esi\r\n        cmp     dil, 5\r\n        ja      .LBB0_2\r\n        movzx   eax, dil\r\n        mov     ecx, 51\r\n        bt      ecx, eax\r\n        jae     .LBB0_2\r\n        mov     eax, edi\r\n        ret\r\n.LBB0_2:\r\n        push    rax\r\n        lea     rdi, [rip + .L__unnamed_1]\r\n        lea     rdx, [rip + .L__unnamed_2]\r\n        mov     esi, 40\r\n        call    qword ptr [rip + core::panicking::panic@GOTPCREL]\r\n        ud2\r\n\r\nexample::Combined::from_u8:\r\n        lea     ecx, [8*rdi]\r\n        movabs  rdx, 5514839064832\r\n        shr     rdx, cl\r\n        cmp     dil, 6\r\n        mov     eax, 6\r\n        cmovb   eax, edx\r\n        ret\r\n\r\nexample::Combined::a:\r\n        mov     eax, edi\r\n        and     al, 1\r\n        ret\r\n\r\nexample::Combined::b:\r\n        cmp     dil, 4\r\n        setae   al\r\n        shl     al, 2\r\n        ret\r\n\r\nexample::InnerA::from_u8:\r\n        cmp     dil, 1\r\n        sete    al\r\n        mov     cl, 2\r\n        sub     cl, al\r\n        xor     edx, edx\r\n        test    dil, dil\r\n        movzx   eax, cl\r\n        cmove   eax, edx\r\n        ret\r\n\r\nexample::InnerB::from_u8:\r\n        cmp     dil, 4\r\n        sete    al\r\n        xor     al, 5\r\n        xor     ecx, ecx\r\n        test    dil, dil\r\n        movzx   eax, al\r\n        cmove   eax, ecx\r\n        ret\r\n\r\n.L__unnamed_1:\r\n        .ascii  \"internal error: entered unreachable code\"\r\n\r\n.L__unnamed_3:\r\n        .ascii  \"/app/example.rs\"\r\n\r\n.L__unnamed_2:\r\n        .quad   .L__unnamed_3\r\n        .asciz  \"\\017\\000\\000\\000\\000\\000\\000\\000\\016\\000\\000\\000\\025\\000\\000\"\r\n```\r\n</details>\r\n\r\nIn my [original code](https://rust.godbolt.org/z/Er5fEo9sG) there are even more branches.\r\n\r\nIs there a way to fix the relevant optimizations to apply to all enums, no matter the discriminant values? I'd be happy to do the required work myself. I've however never worked on the compiler, so I'd need some hints about which pieces of code to look at.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/107458/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/107458/timeline", "performed_via_github_app": null, "state_reason": null}