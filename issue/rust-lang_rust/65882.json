{"url": "https://api.github.com/repos/rust-lang/rust/issues/65882", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/65882/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/65882/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/65882/events", "html_url": "https://github.com/rust-lang/rust/issues/65882", "id": 513040079, "node_id": "MDU6SXNzdWU1MTMwNDAwNzk=", "number": 65882, "title": "Return value packing for Option<T> and Result<T,E> on WebAssembly", "user": {"login": "brion", "id": 103075, "node_id": "MDQ6VXNlcjEwMzA3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/103075?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brion", "html_url": "https://github.com/brion", "followers_url": "https://api.github.com/users/brion/followers", "following_url": "https://api.github.com/users/brion/following{/other_user}", "gists_url": "https://api.github.com/users/brion/gists{/gist_id}", "starred_url": "https://api.github.com/users/brion/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brion/subscriptions", "organizations_url": "https://api.github.com/users/brion/orgs", "repos_url": "https://api.github.com/users/brion/repos", "events_url": "https://api.github.com/users/brion/events{/privacy}", "received_events_url": "https://api.github.com/users/brion/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 234956, "node_id": "MDU6TGFiZWwyMzQ5NTY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-codegen", "name": "A-codegen", "color": "f7e101", "default": false, "description": "Area: Code generation"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 474645165, "node_id": "MDU6TGFiZWw0NzQ2NDUxNjU=", "url": "https://api.github.com/repos/rust-lang/rust/labels/O-wasm", "name": "O-wasm", "color": "6e6ec0", "default": false, "description": "Target: WASM (WebAssembly), http://webassembly.org/"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2019-10-27T23:44:48Z", "updated_at": "2019-10-27T23:58:21Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "I'm looking at how `Result<T,E>` and `Option<T>` return values get handled on the WebAssembly target, using integral types as the `T` and small fieldless enums as the `E` type. It seems hard to predict when Rust will use stack allocation for the return value, and some optimizations that happen on native platforms like x86-64 Linux aren't happening where I expect them.\r\n\r\n(I'm aware that internal Rust ABIs are unstable, but it'd nice to be able to reason about performance on critical paths, so I'm checking this out in detail before building a pipeline that depends on Results or Options in a tight interpreter loop.)\r\n\r\nTested some example code like:\r\n\r\n```rust\r\n// A small enum to annotate error conditions\r\n#[derive(Copy, Clone, Debug)]\r\npub enum MyErr {\r\n    PageFault,\r\n    IllegalInstruction,\r\n    Halt\r\n}\r\n\r\n#[inline(never)]\r\npub fn result_u16(i: u64) -> Result<u16, MyErr> {\r\n    if i < 50 {\r\n        Ok(i as u16)\r\n    } else {\r\n        Err(MyErr::IllegalInstruction)\r\n    }\r\n}\r\n\r\n#[inline(never)]\r\npub fn option_u16(i: u64) -> Option<u16> {\r\n    if i < 50 {\r\n        Some(i as u16)\r\n    } else {\r\n        None\r\n    }\r\n}\r\n```\r\n\r\nwith similar variants for u8, u16, u32, and u64 returns. The `MyErr` enum is small enough to fit in less than a byte itself for `Result` returns.\r\n\r\nOn a Linux or macOS x86-64 build (with the benefit of having native support for two return values in registers) I get:\r\n\r\n\r\n* option_u8 returns two words in AL (discriminant) and EDX (payload)\r\n* option_u16 returns two words in AL (discriminant) and EDX (payload)\r\n* option_u32 returns two words in AL (discriminant) and EDX (payload)\r\n* option_u64 returns two words in AL (discriminant) and RDX (payload)\r\n* result_u8 returns two words in AL(discriminant) and EDX (payload)\r\n* result_u16 returns a packed 32-bit word in EAX, with Ok payload in the top 16 bits\r\n* result_u32 returns a packed 64-bit word in RAX, with Ok payload in the top 32 bits\r\n* result_u64 returns on stack\r\n\r\nOn a WebAssembly build, I get:\r\n\r\n* option_u8 returns on stack\r\n* option_u16 returns on stack\r\n* option_u32 returns on stack\r\n* option_u64 returns on stack\r\n* result_u8 returns on stack\r\n* result_u16 returns a packed 32-bit word, with Ok payload in the top 16 bits\r\n* result_u32 returns on stack\r\n* result_u64 returns on stack\r\n\r\nCouple big things surprised me here. First, while on native x86-64 `Option<T>` is well optimized using two registers, `Result<T,E>` doesn't consistently get the same treatment. Perhaps because conceptually the enum payload is a separate data byte and it complicates things?\r\n\r\nSecond, none of the Option types get optimized into integral values on WebAssembly, where there's no multiple return value handling yet but return types up to 64 bits are available.\r\n\r\nThird, while `Result<u16,MyErr>` gets packed into a 32-bit word on WebAssembly, the `u8` version is not though it would fit handily in a 32-bit word too, nor is the `u32` version packed into a 64-bit word like on native. (There might be something weird with my u8 version, like it's optimizing out the MyErr or something.)\r\n\r\nAs for `Result<u64,MyErr>`, that's using stack as expected.\r\n\r\nIn summary, on WebAssembly:\r\n* It's hard to predict when enum structures will get packed into a register versus transferred through stack memory, making it harder to reason about performance.\r\n* `Option<T>` is not getting \"register\"-packed at any size, causing transfer of data through memory.\r\n* `Result<u8, MyErr>` and `Result<u32, MyErr>` should be packable into 32-bit and 64-bit return values, but are not. It's unclear why.\r\n* `Result<u64, MyErr>` as stack transfer remains optimal until some future day when WebAssembly gains multiple return values.\r\n\r\nThanks for any advice or explanations!", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/65882/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/65882/timeline", "performed_via_github_app": null, "state_reason": null}