{"url": "https://api.github.com/repos/rust-lang/rust/issues/18009", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/18009/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/18009/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/18009/events", "html_url": "https://github.com/rust-lang/rust/issues/18009", "id": 45663393, "node_id": "MDU6SXNzdWU0NTY2MzM5Mw==", "number": 18009, "title": "Metabug: Libcollections TODO", "user": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37977651, "node_id": "MDU6TGFiZWwzNzk3NzY1MQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/metabug", "name": "metabug", "color": "5319e7", "default": false, "description": "Issues about issues themselves (\"bugs about bugs\")"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 28, "created_at": "2014-10-13T16:55:54Z", "updated_at": "2017-11-10T08:42:57Z", "closed_at": "2015-10-27T15:49:49Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "As part of the stabilization process, we'd like our standard collection implementations to be _good_. Maybe even _great_. Wouldn't that be nice? The overall quality of each implementation is pretty varied, partially just because the language has dramatically shifted out from underneath them. Vec and HashMap are in a good place because they're The Big Dogs of data structuring, and have gotten substantial attention as a result. Other less-used collections are in worse shape, and need some serious attention.\n\nIf you're interested in working on a Rust project, or collections in particular, here's a big list of things to do experiment with on libcollections.\n- [x] DList's internal \"safe\" API is totally busted. It's not safe at all. Possibly simply because RawLink is Copyable. This allows a reference to a RawLink to be converted into a value, allowing mutation of an immutable DList.\n- [x] Investigate implementing a proper bidirectional cursor on DList that can insert/remove values. It's borderline useless without this.\n- [x] Full code review of BitV and BitVSet. They've had a lot of bugs because the code base has seen a lot of churn. Some legacy references to the bad-old-day of BitV being an enum still exist (such as a benchmark that just tests how fast bitshifting a uint is).\n- [x] #16736 BitV's internal representation is a Vec of uints. It should almost certainly be a Vec of u32's, or some other non-machine-sized type.\n- [x] RingBuf _should not be_ a Vec of Options.\n- [x] Investigate whether accepting total unsafety in TreeMap and using RawPtrs everywhere is worth it. May be necessary in a future full of scoped allocators.\n- [x] Replace the bulky triple of Vecs used in BTreeMap's Node struct with a single manually allocated\n  buffer, in the same vein as HashMap's RawTable.\n- [x] Investigate a richer default B-selection algorithm for BTreeMap's default constructor than \"6\"\n- [ ] Investigate alternative node-search schemes over trivial linear search for BTreeMap. Binary search? skip-k-at-a-time linear search? Dynamic (or static!) selection of these algorithms based on B/K/V?\n- [x] Seriously optimize BTreeMap _at all_. _At all_.\n- [x] Investigate the possibility of replacing the heap-allocated `Vec<*mut Node<T>>`-based search-stacks of BTreeMap, TreeMap, and TrieMap with a stack-allocated `[*mut Node<T>, ..uint::BITS]` (TreeMap might need more, it's an AA-tree, dunno how tall they can get). Note that a preliminary experiment on BTree gave very poor results, though it has the least to gain from such a design from it's current design (tracks depth, can use `with_capacity`.\n- [x] Investigate the possibility of reusing the SearchStack concept used in BTreeMap to more safely wrap the rawptr-based search stacks of TreeMap and TrieMap.\n- [x] Investigate the possibility of making the iterators for TreeMap and TrieMap DoubleEnded, rather than having separate forward/backward iterators.\n- [x] At very least, get rid of the old-style internal backwards iterator on TrieMap.\n- [x] Investigate the possibility of cutting out a lot of the macro-madness from TreeMap and TrieMap (BTreeMap has no macros and little-to-no code duplication, just hardcore generics). Possibly using the Deref/DerefMut trick in HashMap.\n- [x] Investigate completely replacing the unsafe rawptr search-stacks in the iterators of TreeMap and TrieMap with safe stacks of iterators over the nodes themselves, like BTreeMap does.\n- [x] Investigate arbitrary sub-range iterators for sorted sets/maps.\n- [x] Investigate functionality augmentations to a lot of collections iterators. For instance DList's iterator provides `peek_next` and `remove_next` methods for soundly removing elements from the list during iteration. At _least_ Vec, RingBuf, and HashMap could all support this soundly, I believe. Vec, RingBuf, and DList could also support `insert_next`. Special iterator-like objects dedicated to these tasks might be better ideas, though (cursors, zippers, etc).\n- [x] #17320 Implement the new Entry API on TreeMap and TrieMap.\n- [ ] Investigate different hashing architectures and mechanisms for hash algorithm selection than the current one. For instance, our current stream-based architecture is poorly designed for small keys (e.g. u64's) which can and should be hashed in a single step.\n- [ ] #15947 Investigate making ordering-based collections _comparator_ based rather than directly _Ord_-based using unboxed closures. Ord types should be supported through some kind of \"natural comparator\" that is reversible (for supporting reverse orderings). PriorityQueue in particular would like this to simplify min-vs-max-heap.\n- [ ] Investigate optimizing PriorityQueue.extend with a modified heapify operation.\n- [ ] Consider more slice utility methods. slice.rotate_left/right? slice.shift_and_replace_left/right? \n- [x] Consider providing `split(&mut self, at: Index) -> Self` on some collections.\n- [ ] Investigate tricks used in other languages to optimize for common/special access patterns.\n- [ ] Tests! Code coverage!\n- [ ] Docs! Examples!\n- [ ] Detailed discussions of what individual collections are good/bad for.\n- [ ] Performance comparison tables (probably just assymptoticss\n- [x] There was only one other checked box and it looked lonely so I made it a friend. :D\n", "closed_by": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/18009/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/18009/timeline", "performed_via_github_app": null, "state_reason": "completed"}