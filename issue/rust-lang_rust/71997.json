{"url": "https://api.github.com/repos/rust-lang/rust/issues/71997", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/71997/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/71997/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/71997/events", "html_url": "https://github.com/rust-lang/rust/issues/71997", "id": 614411446, "node_id": "MDU6SXNzdWU2MTQ0MTE0NDY=", "number": 71997, "title": "Optimize away bounds check in loop indexing into slice, given an assertion", "user": {"login": "joshtriplett", "id": 162737, "node_id": "MDQ6VXNlcjE2MjczNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162737?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joshtriplett", "html_url": "https://github.com/joshtriplett", "followers_url": "https://api.github.com/users/joshtriplett/followers", "following_url": "https://api.github.com/users/joshtriplett/following{/other_user}", "gists_url": "https://api.github.com/users/joshtriplett/gists{/gist_id}", "starred_url": "https://api.github.com/users/joshtriplett/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joshtriplett/subscriptions", "organizations_url": "https://api.github.com/users/joshtriplett/orgs", "repos_url": "https://api.github.com/users/joshtriplett/repos", "events_url": "https://api.github.com/users/joshtriplett/events{/privacy}", "received_events_url": "https://api.github.com/users/joshtriplett/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 22, "created_at": "2020-05-07T23:47:06Z", "updated_at": "2021-04-08T01:24:42Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "I wrote a simple loop indexing into a slice, to test rustc's ability to optimize away bounds checks if it knows an index is in bounds. Even with this very simple test case, I can't seem to get rust to omit the bounds checks no matter what `assert!` I add. (I know that I could trivially write this code using iterators instead, but I'm trying to figure out rust's ability to optimize here.)\r\n\r\nTest case (edited since original posting to augment the `assert!` further):\r\n\r\n```rust\r\n#[no_mangle]\r\nfn f(slice: &[u64], start: usize, end: usize) -> u64 {\r\n    let mut total = 0;\r\n    assert!(start < end && start < slice.len() && end <= slice.len());\r\n    for i in start..end {\r\n        total += slice[i];\r\n    }\r\n    total\r\n}\r\n```\r\n\r\nI put that into the compiler explorer, with `-O`, and the resulting assembly looks like this:\r\n\r\n```\r\nf:\r\n        push    rax\r\n        cmp     rdx, rcx\r\n        jae     .LBB5_8\r\n        cmp     rsi, rdx\r\n        jbe     .LBB5_8\r\n        cmp     rsi, rcx\r\n        jb      .LBB5_8\r\n        xor     eax, eax\r\n.LBB5_4:\r\n        cmp     rdx, rsi\r\n        jae     .LBB5_7\r\n        add     rax, qword ptr [rdi + 8*rdx]\r\n        add     rdx, 1\r\n        cmp     rcx, rdx\r\n        jne     .LBB5_4\r\n        pop     rcx\r\n        ret\r\n.LBB5_7:\r\n        lea     rax, [rip + .L__unnamed_5]\r\n        mov     rdi, rdx\r\n        mov     rdx, rax\r\n        call    qword ptr [rip + core::panicking::panic_bounds_check@GOTPCREL]\r\n        ud2\r\n.LBB5_8:\r\n        call    std::panicking::begin_panic\r\n        ud2\r\n```\r\n\r\nBased on the x86 calling convention, `rdi` contains the slice base address, `rsi` contains the slice length, `rdx` contains `start`, and `rcx` contains `end`.\r\n\r\nSo, the first three comparisons verify the assertion and jump to `.LBB5_8` if it fails, to panic.\r\n\r\nThen inside the loop, there's still another comparison of `rdx` to `rsi`, and a jump to `.LBB5_7` to panic if out of bounds.\r\n\r\nAs far as I can tell, that's exactly the same comparison. Shouldn't rustc be able to optimize away that bounds check?\r\n\r\nThings I've tested:\r\n- I tried replacing the `assert!` with an `if` and `unreachable!`, or an `if` and `unsafe { std::hint::unreachable_unchecked() }`, but in both cases the loop still checked if the index was in bounds on each iteration.\r\n- I tried using `-Zmutable-noalias=yes`, which didn't help.\r\n- I tried various forms of the assertion condition.\r\n\r\nIdeally, rustc should be able to optimize away the bounds check in the loop, based on the assertion. Even better would be if rustc could hoist the bounds check out of the loop even without the assertion, but that seems like a harder problem.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/71997/reactions", "total_count": 3, "+1": 3, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/71997/timeline", "performed_via_github_app": null, "state_reason": null}