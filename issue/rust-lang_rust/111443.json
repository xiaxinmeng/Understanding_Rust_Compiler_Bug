{"url": "https://api.github.com/repos/rust-lang/rust/issues/111443", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/111443/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/111443/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/111443/events", "html_url": "https://github.com/rust-lang/rust/issues/111443", "id": 1704529669, "node_id": "I_kwDOAAsO6M5lmQ8F", "number": 111443, "title": "Trait fn impl takes precedence over concrete type's fn impl depending on visibility", "user": {"login": "rljacobson", "id": 1412598, "node_id": "MDQ6VXNlcjE0MTI1OTg=", "avatar_url": "https://avatars.githubusercontent.com/u/1412598?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rljacobson", "html_url": "https://github.com/rljacobson", "followers_url": "https://api.github.com/users/rljacobson/followers", "following_url": "https://api.github.com/users/rljacobson/following{/other_user}", "gists_url": "https://api.github.com/users/rljacobson/gists{/gist_id}", "starred_url": "https://api.github.com/users/rljacobson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rljacobson/subscriptions", "organizations_url": "https://api.github.com/users/rljacobson/orgs", "repos_url": "https://api.github.com/users/rljacobson/repos", "events_url": "https://api.github.com/users/rljacobson/events{/privacy}", "received_events_url": "https://api.github.com/users/rljacobson/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2023-05-10T19:43:26Z", "updated_at": "2023-05-10T19:46:08Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "How function names are resolved to concrete implementations on concrete struct and trait objects appears to be incorrect for a specific (but reasonable) corner case.\r\n\r\nSuppose we have\r\n\r\n * a concrete struct type `MyStruct`\r\n * a method `foo_function(\u2026)` implemented on `MyStruct` (i.e. within `impl MyStruct{}`)\r\n * a trait `MyTrait` having a trait method `foo_function(\u2026)`\r\n * a submodule `my_submodule`\u00a0within whatever module contains `MyStruct`.\r\n * an implementation of `MyTrait` for `MyStruct`, which necessarily has an implementation for the `MyTrait`  `foo_function(\u2026)` function. (It doesn't matter if it's the default impl of `foo_function(\u2026)` for `MyTrait`.)\r\n\r\nWhich function the expression `MyStruct::foo_function(\u2026)`\u00a0resolves to depends on whether the implementation of  `foo_function(\u2026)` for `MyType`\u00a0is inside of `sub_module`. See the code below.\r\n\r\nI tried this code:\r\n\r\n```rust\r\nstruct MyStruct{}\r\n\r\nimpl MyStruct {\r\n    pub fn bar_function(&self) {\r\n        // Which function is called in the following depends on the visibility of the concrete type's `foo_function`.\r\n        // This behavior is NOT exhibited if we move the concrete type's `foo_function` impl to the same module.\r\n\r\n        // Call the function on the concrete `MyStruct` instance. Which function is _actually_ called?\r\n        self.foo_function();\r\n\r\n        // Same as above but with explicit notation to emphasize we are naming the MyStruct version in the call.\r\n        MyStruct::foo_function(self);\r\n    }\r\n\r\n    // The following is an error if its counterpart in `my_submodule` exists.\r\n    // fn foo_function(&self){\r\n    //     println!(\"a third possibility.\");\r\n    // }\r\n}\r\n\r\n// Some of the `MyStruct` impl in a submodule, for example, another file to keep the codebase navigable.\r\nmod my_submodule {\r\n    // pub(crate) // Has no effect on behavior in question.\r\n    use crate::{MyStruct};\r\n\r\n    impl MyStruct {\r\n        pub // Different behavior depending on whether `fn` is `pub` or not.\r\n        fn foo_function(&self) {\r\n            println!(\"The MyStruct fn\");\r\n        }\r\n\r\n        pub fn baz_function(&self) {\r\n            // Resolves to the method immediately above this one in every case.\r\n            MyStruct::foo_function(self);\r\n        }\r\n    }\r\n}\r\n\r\ntrait MyTrait {\r\n    fn foo_function(&self);\r\n}\r\n\r\nimpl MyTrait for MyStruct {\r\n    fn foo_function(&self) {\r\n        println!(\"The trait impl fn.\");\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let my_concrete_struct: &MyStruct = &MyStruct{};\r\n\r\n    my_concrete_struct.foo_function();\r\n    my_concrete_struct.bar_function();\r\n    my_concrete_struct.baz_function();\r\n}\r\n```\r\n\r\n**I expected to see this happen:**\r\n\r\nIn any context in which private methods of `MyStruct` are normally visible, I expect `MyStruct::foo_function` to resolve to the implementation of `foo_function(\u2026)` on `MyStruct` regardless of the visibility of that implementation. In other words, I expect the statement  `MyStruct::foo_function(my_concrete_struct);` and `my_concrete_struct.foo_function();`  to print `The MyStruct fn` whenever they are in the implementation of a method on `MyStruct`. Moreover, I expect a `pub`\u00a0annotation on an implementation on `MyStruct` to modify the visibility of the function outside of the implementation of `MyStruct`\u00a0while having no effect on its visiblity within a module.\r\n\r\n**Instead, this happened:** \r\n\r\nWhen the implementation of  `foo_function` on `MyStruct` is `pub` (i.e. `pub fn foo_function(\u2026)\u2026`), the expression `MyStruct::foo_function` does preferentially resolve to the implementation on `MyStruct` regardless of where it is called from. However\u2026\r\n\r\nWhen  the implementation of  `foo_function` on `MyStruct` is not `pub`, that function is inaccessible even to other methods of `MyStruct`\u00a0the implementations of which are outside of `my_submodule`,\u00a0but remain accessible to methods on `MyStruct`\u00a0defined within `my_submodule`. There appears to be no \"fully qualified name\" which allows methods outside of `my_submodule`\u00a0to access the method inside `my_submodule`\u00a0nor a \"fully qualified name\" which allows methods inside `my_submodule`\u00a0to access methods outside of `my_submodule`\u00a0except by importing the trait and using `MyTrait::foo_function(&self)`.\r\n\r\nApparently, declaring the `foo_function` within `my_submodule` as `pub` makes it public not just within the struct but within the submodule as well. Likewise, declaring the `foo_function` within `my_submodule` *without* the `pub` annotation makes it not only private to code outside of the implementation of `MyStruct` but also private within `my_submodule`. For other methods on `MyStruct` defined within `my_submodule`, the `foo_function` within `my_submodule` shadows any definition outside of `my_submodule`.\r\n\r\nCuriously, if there is an implementation of  `foo_function`  on `MyStruct` (as opposed to a trait implementation) outside of `my_submodule`, that implementation *cannot* be shadowed by another implementation of  `foo_function`  on `MyStruct` defined within `my_submodule` . One might expect otherwise considering the notation `MyStruct::foo_function` is allowed to vary depending on scope.\r\n\r\nA consequence of this behavior is that a trait fn impl can take precedence over a concrete type's fn impl when the concrete type's impl is not pub and in a submodule.\r\n\r\n### Meta\r\n\r\nDoesn't appear to depend on compiler version.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/111443/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/111443/timeline", "performed_via_github_app": null, "state_reason": null}