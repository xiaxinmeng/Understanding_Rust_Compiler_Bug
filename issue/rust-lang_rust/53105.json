{"url": "https://api.github.com/repos/rust-lang/rust/issues/53105", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/53105/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/53105/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/53105/events", "html_url": "https://github.com/rust-lang/rust/issues/53105", "id": 347825275, "node_id": "MDU6SXNzdWUzNDc4MjUyNzU=", "number": 53105, "title": "noalias is not enough", "user": {"login": "gnzlbg", "id": 904614, "node_id": "MDQ6VXNlcjkwNDYxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/904614?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gnzlbg", "html_url": "https://github.com/gnzlbg", "followers_url": "https://api.github.com/users/gnzlbg/followers", "following_url": "https://api.github.com/users/gnzlbg/following{/other_user}", "gists_url": "https://api.github.com/users/gnzlbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/gnzlbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gnzlbg/subscriptions", "organizations_url": "https://api.github.com/users/gnzlbg/orgs", "repos_url": "https://api.github.com/users/gnzlbg/repos", "events_url": "https://api.github.com/users/gnzlbg/events{/privacy}", "received_events_url": "https://api.github.com/users/gnzlbg/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 234956, "node_id": "MDU6TGFiZWwyMzQ5NTY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-codegen", "name": "A-codegen", "color": "f7e101", "default": false, "description": "Area: Code generation"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2018-08-06T08:24:02Z", "updated_at": "2022-11-25T02:00:22Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Somebody on the internet (https://blog.dend.ro/rust-and-the-case-of-the-redundant-comparison/) complained that something like this:\r\n\r\n```rust\r\nfn vec_clear(x: &mut i32) {\r\n    if *x != 0 {\r\n        *x = 0;\r\n    }\r\n}\r\n```\r\n\r\ngenerates a conditional store: \r\n\r\n```asm\r\n    cmpl    $0, (%rdi)\r\n    je      .LBB0_2\r\n    movl    $0, (%rdi)\r\n.LBB0_2:  \r\n    retq\r\n```\r\n\r\non `x86_64` instead of just an unconditional store `movl $0, (%rdi); retq`.\r\n\r\nTaking a look at the optimized LLVM-IR:\r\n\r\n```llvm\r\ndefine void @vec_clear(i32* noalias nocapture dereferenceable(4) %x) {\r\nstart:\r\n  %0 = load i32, i32* %x, align 4\r\n  %1 = icmp eq i32 %0, 0\r\n  br i1 %1, label %bb2, label %bb1\r\n\r\nbb1:\r\n  store i32 0, i32* %x, align 4\r\n  br label %bb2\r\n\r\nbb2:\r\n  ret void\r\n}\r\n```\r\n\r\nshows the issue.\r\n\r\nThe LLVM-IR generated by rustc is loosing critical information. It marks `i32*` as `noalias`, which means, that no other pointers _in `vec_clear`'s scope_ will alias it. However, outside `vec_clear` scope, other pointers are allowed to alias that memory. That is, if `*x` is zero, other threads could be concurrently reading the memory and if LLVM would generate an unconditional store here, that would introduce a data-race, which means that this optimization is not safe on the LLVM-IR generated by rustc. OTOH, &mut i32` means that the pointer has unique access to the memory, that is, no other pointer can access the memory behind it as long as that pointer is alive. Therefore, transforming the code to an unconditional store does not introduce a data-race. \r\n\r\nTherefore, _I think_ that `noalias` is not enough to perform this optimization and that we would need something stronger for LLVM to be able to perform it. \r\n\r\n---\r\n\r\nThis also shows that `&mut T` is stronger than C's `restrict` keyword.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/53105/reactions", "total_count": 4, "+1": 2, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 2, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/53105/timeline", "performed_via_github_app": null, "state_reason": null}