{"url": "https://api.github.com/repos/rust-lang/rust/issues/10491", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/10491/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/10491/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/10491/events", "html_url": "https://github.com/rust-lang/rust/issues/10491", "id": 22683179, "node_id": "MDU6SXNzdWUyMjY4MzE3OQ==", "number": 10491, "title": "Proposal: Struct fields in concert with anonymous fields", "user": {"login": "orenbenkiki", "id": 68190, "node_id": "MDQ6VXNlcjY4MTkw", "avatar_url": "https://avatars.githubusercontent.com/u/68190?v=4", "gravatar_id": "", "url": "https://api.github.com/users/orenbenkiki", "html_url": "https://github.com/orenbenkiki", "followers_url": "https://api.github.com/users/orenbenkiki/followers", "following_url": "https://api.github.com/users/orenbenkiki/following{/other_user}", "gists_url": "https://api.github.com/users/orenbenkiki/gists{/gist_id}", "starred_url": "https://api.github.com/users/orenbenkiki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/orenbenkiki/subscriptions", "organizations_url": "https://api.github.com/users/orenbenkiki/orgs", "repos_url": "https://api.github.com/users/orenbenkiki/repos", "events_url": "https://api.github.com/users/orenbenkiki/events{/privacy}", "received_events_url": "https://api.github.com/users/orenbenkiki/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2013-11-14T18:48:39Z", "updated_at": "2015-01-23T00:36:09Z", "closed_at": "2015-01-23T00:36:09Z", "author_association": "NONE", "active_lock_reason": null, "body": "Following http://smallcultfollowing.com/babysteps/blog/2013/10/24/single-inheritance/ and the thread at https://mail.mozilla.org/pipermail/rust-dev/2013-November/006465.html and referring to #9728\n\nThis proposal is in line with the single inheritance proposal, but puts it in context of anonymous fields. The key idea is separation of concerns: anonymous fields are used for inheriting implementation of \"virtual functions\", while \"struct traits\" are used for inheriting data members.\n\nNeither the anonymous fields not the single inheritance proposals, when taken on their own, allow solving the full problem, since it is actually two (related) problems. This proposal puts them both together in a way that allows the programmer to express whatever best fits his problem - shared data members, shared methods, or both. \n\nThe proposal is as follows. Assume some form of anonymous fields support, that is, allowing:\n\n``` rust\npub struct FooS { foo: int }\nimpl  FooT for FooS { ... }\npub struct BarS { FooS; bar: int; BazS; ... }\nimpl FooT for BarS {} // Inherits trait implementation, possibly w/ overrided\n```\n\nWith the expected semantics (allowing access to FooT trait methods via either ~FooS or ~BarS, at the cost of a virtual function call, e.g. along the lines of #9728).\n\nWe then add a new concept, \"struct traits\". Every struct is also automatically a trait. Any type implementing the trait has the matching struct as an anonymous member at offset 0 - that is, for any type implementing the trait, we can access all the struct data members at the same (known at compile time) offsets they exist at the original struct.\n\nWe provide the single-inheritance syntax for implementing struct traits. That is, the above code could be written as:\n\n``` rust\npub struct FooS { foo: int }\nimpl  FooT for FooS { ... }\npub struct BarS : FooS { bar: int; BazS; ... } // Single inheritance\nimpl FooT for BarS {} // Inherits trait implementation, possibly w/ overrided\n```\n\nThe semantics of `struct BarS : FooS` are (1) behave as if the struct starts with a `FooS` anonymous member; (2) make the `BarS` type implement the `FooS` struct trait. That is, it would be possible to write:\n\n``` rust\nfn useFoo<T: FooS + FooT>(t: ~T) {\n    t.foo; // Simple data access at compile-time-known offset.\n    t.method(); // Virtual function call using the FooT trait.\n}\n...\nuseFoo(~FooS { foo: 0 });\nuseFoo(~BarS { FooS { foo: 1 }, bar: 2 });\n... \n```\n\nNote that we maintain the seperation of concerns. Single inheritance does not imply implementing any trait other than the base struct trait. Normal (virtual?) traits are treated exactly as they are treated for normal anonymous members; they require an `impl`; etc.\n\nFast access to common data members is done via struct traits and single inheritance; restriction to single inheritance is understandable since it is an inherent requirement for zero-cost data member access (since a struct has only one prefix).\n\nInvocation of \"virtual methods\" is done via traits as today. Anonymous fields allow us to inherit implementation if this is desired (or defining completely new implementation if we want). Invoking trait methods always incurs the extra cost of a virtual function call; this includes the cost of carrying a run-time-known offset for accessing the data members required by the inherited implementation. In this case, as usual for traits, it is possible for a struct to inherit and implement any number of traits, by using several anonymous members.\n\nI propose this extension to the single inheritance proposal (or, if you look at it from the other direction, to the anonymous fields proposal) provides the best of both worlds, without having to restrict ourselves to single implementation inheritance (that is, give up mixins), and without having to give up the fast access to base data members (that is, give up on performance for a very common case).\n", "closed_by": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/10491/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/10491/timeline", "performed_via_github_app": null, "state_reason": "completed"}