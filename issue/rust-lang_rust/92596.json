{"url": "https://api.github.com/repos/rust-lang/rust/issues/92596", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/92596/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/92596/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/92596/events", "html_url": "https://github.com/rust-lang/rust/issues/92596", "id": 1094808384, "node_id": "I_kwDOAAsO6M5BQXNA", "number": 92596, "title": "Benchmark entirely unfair locks for parallel rustc", "user": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 891133401, "node_id": "MDU6TGFiZWw4OTExMzM0MDE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-parallel-queries", "name": "A-parallel-queries", "color": "f7e101", "default": false, "description": "Area: Parallel query execution"}, {"id": 1576178387, "node_id": "MDU6TGFiZWwxNTc2MTc4Mzg3", "url": "https://api.github.com/repos/rust-lang/rust/labels/WG-compiler-parallel", "name": "WG-compiler-parallel", "color": "c2e0c6", "default": false, "description": "Working group working on parallelizing the compiler"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2022-01-05T22:52:49Z", "updated_at": "2022-01-05T22:52:49Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "My theory is that the accounting necessary for implementing eventually fair locks in parking lot causes an instruction count increase for parallel rusrc by a couple of percents without improving the wall time. Without this accounting taking a lock should be a matter of a cmpxchg and possibly a futex wait if it was already locked. I don't think it matters as much if a thread is starved for extended periods of time rather than splitting this starving between threads as eventually the thread responsible for the starving will finish it's task and no longer cause any other threads to starve, thus guaranteeing progress. Whether I am right or not will need to be shown using benchmarking. It would also be interesting to see how long a spinlock should happen before falling back to a futex wait, if it should happen at all given that some query locks are probably held for extended periods of time.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/92596/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/92596/timeline", "performed_via_github_app": null, "state_reason": null}