{"url": "https://api.github.com/repos/rust-lang/rust/issues/72297", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/72297/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/72297/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/72297/events", "html_url": "https://github.com/rust-lang/rust/issues/72297", "id": 619722540, "node_id": "MDU6SXNzdWU2MTk3MjI1NDA=", "number": 72297, "title": "Splitting borrows through smart pointers has confusing diagnostics", "user": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 235791, "node_id": "MDU6TGFiZWwyMzU3OTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-diagnostics", "name": "A-diagnostics", "color": "f7e101", "default": false, "description": "Area: Messages for errors, warnings, and lints"}, {"id": 171502053, "node_id": "MDU6TGFiZWwxNzE1MDIwNTM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-borrow-checker", "name": "A-borrow-checker", "color": "f7e101", "default": false, "description": "Area: The borrow checker"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 1596121013, "node_id": "MDU6TGFiZWwxNTk2MTIxMDEz", "url": "https://api.github.com/repos/rust-lang/rust/labels/D-confusing", "name": "D-confusing", "color": "c9f7a3", "default": false, "description": "Confusing diagnostic error that should be reworked"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2020-05-17T14:49:20Z", "updated_at": "2020-06-11T17:32:10Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "```rust\r\nuse std::cell::RefCell;\r\n\r\n#[derive(Default)]\r\nstruct NotCopy;\r\n\r\n#[derive(Default)]\r\nstruct Split {\r\n    one: Option<NotCopy>,\r\n    two: NotCopy,\r\n}\r\n\r\nfn read(_: &NotCopy) {}\r\n\r\nfn main() {\r\n    let mut split = Split::default();\r\n    \r\n    // comment this:\r\n    let split = &mut split;\r\n    \r\n    // uncomment this:\r\n    // let split = RefCell::new(split);\r\n    // let mut split = split.borrow_mut();\r\n\r\n    if let Some(ref mut one) = split.one {\r\n        read(&split.two);\r\n        *one = NotCopy;\r\n    }\r\n}\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=f42ceb391fdaa9aad25aa7a387a67c88))\r\n\r\n\r\nThis compiles fine, but if you switch the commented out parts, you get:\r\n\r\n```\r\nerror[E0502]: cannot borrow `split` as immutable because it is also borrowed as mutable\r\n  --> src/main.rs:21:15\r\n   |\r\n20 |     if let Some(ref mut one) = split.one {\r\n   |                                ----- mutable borrow occurs here\r\n21 |         read(&split.two);\r\n   |               ^^^^^ immutable borrow occurs here\r\n22 |         *one = NotCopy;\r\n   |         -------------- mutable borrow later used here\r\n```\r\n\r\nThe reason this does not error in the original case is that Rust is aware of the semantics of `&mut T`'s `DerefMut` and can reason about splitting borrows, however it is _not_ aware of the semantics of `RefMut<T>`'s `DerefMut` and `&split.two` is able to read from `split.one` in a safely-written `DerefMut` impl.\r\n\r\nThe fix is to convert the `RefMut<T>` into an `&mut T`, via `&mut *split` before doing any of reads or writes.\r\n\r\nOne typically expects splitting mutable borrows to work in Rust, so it's weird when it doesn't. It would be nice if the compiler could detect when a situation is one of splitting borrows through a DerefMut impl and make the appropriate suggestion. ", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/72297/reactions", "total_count": 2, "+1": 2, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/72297/timeline", "performed_via_github_app": null, "state_reason": null}