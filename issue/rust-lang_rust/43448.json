{"url": "https://api.github.com/repos/rust-lang/rust/issues/43448", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/43448/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/43448/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/43448/events", "html_url": "https://github.com/rust-lang/rust/issues/43448", "id": 244970025, "node_id": "MDU6SXNzdWUyNDQ5NzAwMjU=", "number": 43448, "title": "std::sync::Once can block forever in forked process", "user": {"login": "joshlf", "id": 1046063, "node_id": "MDQ6VXNlcjEwNDYwNjM=", "avatar_url": "https://avatars.githubusercontent.com/u/1046063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joshlf", "html_url": "https://github.com/joshlf", "followers_url": "https://api.github.com/users/joshlf/followers", "following_url": "https://api.github.com/users/joshlf/following{/other_user}", "gists_url": "https://api.github.com/users/joshlf/gists{/gist_id}", "starred_url": "https://api.github.com/users/joshlf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joshlf/subscriptions", "organizations_url": "https://api.github.com/users/joshlf/orgs", "repos_url": "https://api.github.com/users/joshlf/repos", "events_url": "https://api.github.com/users/joshlf/events{/privacy}", "received_events_url": "https://api.github.com/users/joshlf/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 9695584, "node_id": "MDU6TGFiZWw5Njk1NTg0", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-concurrency", "name": "A-concurrency", "color": "f7e101", "default": false, "description": "Area: Concurrency related issues."}, {"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 17, "created_at": "2017-07-24T04:36:09Z", "updated_at": "2020-04-30T13:10:26Z", "closed_at": "2020-04-30T13:10:26Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "There's a bug in [`std::sync::Once`](https://doc.rust-lang.org/std/sync/struct.Once.html) that makes it so that, under certain conditions, a call to [`call_once`](https://doc.rust-lang.org/std/sync/struct.Once.html#method.call_once) in a process which was forked from another Rust process can block forever.\r\n\r\n## How `Once` works\r\n\r\nSimplifying a bit (ignoring poisoning), the algorithm employed by `Once` works as follows: The `Once` can be in one of three states: `INCOMPLETE`, `COMPLETE`, and `RUNNING`.\r\n* The `Once` starts off in the `INCOMPLETE` state.\r\n* When a call to `call_once` begins, the `Once` might be in any of the three states:\r\n  * If the `Once` is in the `INCOMPLETE` state, then it is transitioned to the `RUNNING` state, and the function begins executing.\r\n  * If the `Once` is in the `RUNNING` state, then some other call to `call_once` is executing the function, so this call puts itself on a list of waiters and goes to sleep. It will be woken back up once the function is done executing in whatever thread is executing it.\r\n  * If the `Once` is in the `COMPLETE` state, then the function has already been executed, so `call_once` returns immediately without doing anything.\r\n\r\nFinally, when the function's execution completes, the thread doing the execution transitions the `Once` into the `COMPLETE` state, and wakes up any waiters that accumulated while it was executing the function.\r\n\r\n## The issue\r\n\r\nThis algorithm is broken when forking. In particular, if a `Once` is in the `RUNNING` state at the point that the process forks, when the child's memory space (which, by default, is a copy-on-write copy of the parent's) is created, the `Once` will still be in the `RUNNING` state. However, in the child process, calls to `call_once` will fail for two reasons:\r\n* If the call happens while the function is still being executed, the waiter object that is enqueued will not actually be visible to the executor because it will only affect the child's memory space, not the parent's, and so the executor (a member of the parent thread) finishes, it will wake up all of the waiters in the parent process, blissfully ignorant that a thread from the child process is also waiting.\r\n* If the function execution finishes first, the change of the `Once`'s state from `RUNNING` to `COMPLETE` will not be reflected in the child's memory space. Thus, a future call to `call_once` will spuriously find the `Once` still in the `RUNNING` state even though it isn't really in that state anymore.\r\n\r\nThese two problems can be seen in action in two proofs of concept that I wrote: [This one](https://play.rust-lang.org/?gist=c368c63c4ec27e02c894f1795fea22ed&version=stable) demonstrates the first issue, while [this one](https://play.rust-lang.org/?gist=5baeb000cb8e8feae574fdeff9fdb98c&version=stable) demonstrates the second.\r\n\r\n## A proposed fix\r\n\r\nJoint credit for this proposal goes to @ezrosent.\r\n\r\nThe idea behind this fix is to record the process' PID when transitioning a `Once` from `INCOMPLETE` to `RUNNING`, and having future accesses that find the `Once` in the `RUNNING` state verify that it wasn't transitioned by a parent process. Unfortunately, this doesn't quite work because PIDs can be re-used, so if process A spawns process B, then process A quits, then process B spawns process C, it's possible for A and C to have the same PID.\r\n\r\nInstead, we introduce the idea of an \"MPID\" - a monotonically-increasing PID-like counter that is maintained by the process (e.g. . We increment it every time a process forks, and use it in the `Once` objects to record which process transitioned an object from `INCOMPLETE` to `RUNNING`.\r\n\r\nMore concretely, here are the components of the proposed solution:\r\n* There is a process-global MPID variable (could be either `usize` or `u64`) that is initialized to 0 and is incremented immediately after `fork`. Note that this does _not_ guarantee that no two processes anywhere in the tree of processes forked from a particular process have the same MPID. In fact, all processes forked by a given process will all have the same MPID. However, it does guarantee that a process will not share an MPID with any of its ancestors, and that is all we need.\r\n* The `Once` object is modified to have another `mpid` field that is initialized to 0.\r\n* Each waiter object is modified to have another `mpid` field that is initialized to the MPID of the current process when the object is created.\r\n* A modified algorithm for `call_once` looks roughly like this:\r\n  * Loop:\r\n    * Load the current state. If it is `COMPLETE`, return.\r\n    * If the state is `INCOMPLETE`, do then load `mpid` and:\r\n      * If `mpid` is equal to the current MPID, then try to CAS the state from `INCOMPLETE` to `RUNNING`. If it fails, retry the entire loop. If it succeeds, you're responsible for running the function, so do the original algorithm.\r\n      * If `mpid` is not equal to the current MPID, then try to CAS it from its current value to the current MPID. If this succeeds, go to the previous step (where `mpid` is equal to the current MPID), and if it fails, retry the entire loop.\r\n    * If the state is `RUNNING`, then load `mpid` and:\r\n      * If `mpid` is equal to the current MPID, then the thread that transitioned the `Once` into the `RUNNING` state is in the current process, so do the normal algorithm: wait for it to be done (recording the current MPID in the waiter object).\r\n      * If `mpid` is not equal to the current MPID, then the thread that transitioned the `Once` into the `RUNNING` state is in an ancestor process. Thus, attempt to CAS `mpid` to the current MPID. If it fails, repeat the entire loop. If it succeeds, then it is your responsibility to run the function, so continue as if you had transitioned the `Once` into the `RUNNING` state, with one exception: when waking up waiters, you need to check that they are not waiters in an ancestor process; do this by checking the waiter object's `mpid` field, and only waking waiters with an `mpid` field equal to the current MPID.\r\n\r\nOne thing to note: It is safe to try to CAS `mpid` and then separately to transition into `RUNNING` even though the value of `mpid` needs to reflect the MPID of the thread that transitioned into `RUNNING` - a thread that successfully transitions a `Once` into the `RUNNING` state will have previously verified that `mpid` is correct, and thus it will not change forever in the future (at least, not in this process) since the MPID of a process never changes.\r\n\r\n### Open question\r\nOne open question is how to ensure that code is run just after `fork` (to increment the global MPID variable) and, critically, before any other code runs (especially code that uses `Once`). `pthread` provides the [`pthread_atfork`](http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_atfork.html) function to register callbacks that run before and after `fork` calls, but obviously this doesn't address Windows, and I also don't know if there's a good way to ensure that the necessary call to `pthread_atfork` is made at process initialization time.\r\n\r\n## Prior art\r\n\r\nThere's some prior art here. In particular, jemalloc [has acknowledged a similar issue](https://github.com/jemalloc/jemalloc/blob/a9f7732d45c22ca7d22bed6ff2eaeb702356884e/src/jemalloc.c#L3204), and has a partial fix for it.", "closed_by": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/43448/reactions", "total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/43448/timeline", "performed_via_github_app": null, "state_reason": "completed"}