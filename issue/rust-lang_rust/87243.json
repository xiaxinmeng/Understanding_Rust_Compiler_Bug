{"url": "https://api.github.com/repos/rust-lang/rust/issues/87243", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/87243/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/87243/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/87243/events", "html_url": "https://github.com/rust-lang/rust/issues/87243", "id": 946958432, "node_id": "MDU6SXNzdWU5NDY5NTg0MzI=", "number": 87243, "title": "Change rustc's AST to support formatting code around unrecognized literals", "user": {"login": "programmerjake", "id": 4584340, "node_id": "MDQ6VXNlcjQ1ODQzNDA=", "avatar_url": "https://avatars.githubusercontent.com/u/4584340?v=4", "gravatar_id": "", "url": "https://api.github.com/users/programmerjake", "html_url": "https://github.com/programmerjake", "followers_url": "https://api.github.com/users/programmerjake/followers", "following_url": "https://api.github.com/users/programmerjake/following{/other_user}", "gists_url": "https://api.github.com/users/programmerjake/gists{/gist_id}", "starred_url": "https://api.github.com/users/programmerjake/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/programmerjake/subscriptions", "organizations_url": "https://api.github.com/users/programmerjake/orgs", "repos_url": "https://api.github.com/users/programmerjake/repos", "events_url": "https://api.github.com/users/programmerjake/events{/privacy}", "received_events_url": "https://api.github.com/users/programmerjake/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 27424086, "node_id": "MDU6TGFiZWwyNzQyNDA4Ng==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-parser", "name": "A-parser", "color": "f7e101", "default": false, "description": "Area: The parsing of Rust source code to an AST."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 630652267, "node_id": "MDU6TGFiZWw2MzA2NTIyNjc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-feature-request", "name": "C-feature-request", "color": "f5f1fd", "default": false, "description": "Category: A feature request, i.e: not implemented / a PR."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2021-07-18T05:50:50Z", "updated_at": "2023-03-30T20:37:05Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "From https://github.com/rust-lang/rustfmt/issues/4901:\r\n\r\n> I'm writing a Hardware Description Language (HDL) embedded in Rust and I'm using a proc-macro `val!` to convert Rust expressions (`syn::Expr`) to the code needed for generating my compiler IR. rustfmt guesses that the macro arguments are expressions and nicely formats them:\r\n> \r\n> ```rust\r\n> counter.assign_data_in(val!(if overflowed { 0 } else { counter_output + 1 }));\r\n> ```\r\n> \r\n> However, I support integer types with less usual bit counts, such as `u20`. rustfmt refuses to format as soon as it sees an odd integer literal, so I have to manually format that section of my code:\r\n> https://salsa.debian.org/Kazan-team/rust-hdl/-/blob/f232063e797ddb097d88df4e6580c7ee861efdef/examples/blinky.rs#L17\r\n> \r\n> ```rust\r\n> let overflowed = val!(counter_output >= 1_000_000_u20);\r\n> ```\r\n> \r\n> however `syn` has no problems whatsoever parsing that expression.\r\n> \r\n> Please adjust rustfmt to still format expressions even if it can't parse the type of a literal.\r\n> \r\n> Short demo (builds fine):\r\n> https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=3da9013aa7b1b43706ad584e652897c5\r\n> \r\n> ```rust\r\n> macro_rules! val {\r\n>     ($($tokens:tt)*) => {\r\n>         0 // good enough for demo\r\n>     };\r\n> }\r\n> \r\n> fn f() -> i32 {\r\n>     // not formatted by rustfmt\r\n>     val!(a >\r\n>     123u20)\r\n> }\r\n> \r\n> fn g() -> i32 {\r\n>     // formatted by rustfmt\r\n>     val!(a >\r\n>     123u32)\r\n> }\r\n> ```\r\n> \r\n> formats to:\r\n> \r\n> ```rust\r\n> macro_rules! val {\r\n>     ($($tokens:tt)*) => {\r\n>         0 // good enough for demo\r\n>     };\r\n> }\r\n> \r\n> fn f() -> i32 {\r\n>     // not formatted by rustfmt\r\n>     val!(a >\r\n>     123u20)\r\n> }\r\n> \r\n> fn g() -> i32 {\r\n>     // formatted by rustfmt\r\n>     val!(a > 123u32)\r\n> }\r\n> ```\r\n\r\nI think this can be achieved by changing rustc's AST to produce a formattible expression AST even when a literal isn't recognized.\r\n\r\nThis also has benefits around future-proofing, allowing an old rustfmt to work on a later version of Rust code that added additional literal types (like `123u20` or (`format_args!` literal) `f\"abc{var}\"`).", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/87243/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/87243/timeline", "performed_via_github_app": null, "state_reason": null}