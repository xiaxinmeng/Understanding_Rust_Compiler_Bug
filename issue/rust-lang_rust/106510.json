{"url": "https://api.github.com/repos/rust-lang/rust/issues/106510", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/106510/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/106510/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/106510/events", "html_url": "https://github.com/rust-lang/rust/issues/106510", "id": 1521512041, "node_id": "I_kwDOAAsO6M5asG5p", "number": 106510, "title": "Compiler stops autodereferencing type to resolve trait once type type implements trait with unrelated generic parameters", "user": {"login": "KevinThierauf", "id": 47986413, "node_id": "MDQ6VXNlcjQ3OTg2NDEz", "avatar_url": "https://avatars.githubusercontent.com/u/47986413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KevinThierauf", "html_url": "https://github.com/KevinThierauf", "followers_url": "https://api.github.com/users/KevinThierauf/followers", "following_url": "https://api.github.com/users/KevinThierauf/following{/other_user}", "gists_url": "https://api.github.com/users/KevinThierauf/gists{/gist_id}", "starred_url": "https://api.github.com/users/KevinThierauf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KevinThierauf/subscriptions", "organizations_url": "https://api.github.com/users/KevinThierauf/orgs", "repos_url": "https://api.github.com/users/KevinThierauf/repos", "events_url": "https://api.github.com/users/KevinThierauf/events{/privacy}", "received_events_url": "https://api.github.com/users/KevinThierauf/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2023-01-05T22:05:30Z", "updated_at": "2023-01-06T21:19:43Z", "closed_at": "2023-01-06T21:19:43Z", "author_association": "NONE", "active_lock_reason": null, "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\n\r\nThe following is a minimal code sample that showcases the present issue:\r\n\r\n```rust\r\n// some trait\r\ntrait SomeTrait<T> {\r\n    fn do_stuff(&self, value: T);\r\n}\r\n\r\nstruct Structure;\r\n\r\nimpl<T> SomeTrait<T> for Structure {\r\n    fn do_stuff(&self, _: T) {\r\n        println!(\"generic\");\r\n    }\r\n}\r\n\r\n// some example types\r\nstruct A;\r\nstruct B;\r\nstruct C;\r\n\r\n// implement SomeTrait<A> on &Structure, not Structure (autoderef specialization)\r\nimpl SomeTrait<A> for &Structure {\r\n    fn do_stuff(&self, _: A) {\r\n        println!(\"specialized TraitA\");\r\n    }\r\n}\r\n\r\n// same as before, but for SomeTrait<C> instead of SomeTrait<A>\r\nimpl SomeTrait<C> for &Structure {\r\n    fn do_stuff(&self, _: C) {\r\n        println!(\"specialized TraitC\");\r\n    }\r\n}\r\n\r\nlet structure = Structure;\r\nlet tmp = &structure; // tmp is &Structure\r\nlet tmp = &tmp; // tmp is &&Structure\r\ntmp.do_stuff(A); // will call specialized TraitA version\r\ntmp.do_stuff(C); // will call specialized TraitC version\r\n\r\ntmp.do_stuff(B); // should call generic version, compiler error if SomeTrait<A> or SomeTrait<C> is implemented, compiles if neither definitions are provided\r\n```\r\n\r\nThe compiler incorrectly (I believe) fails with this example. Notably, the call to ```tmp.do_stuff(B);``` is the only line that fails. If the impl of ```SomeTrait<A>``` and ```SomeTrait<C>``` are removed for &Structure, the ```tmp.do_stuff(B);``` DOES work -- the call to ```tmp.do_stuff(B);``` is not ambiguous; the impl of ```SomeTrait<A>``` and ```SomeTrait<B>``` do not apply, as the compiler notes. Instead, it appears that, once the compiler sees that a version of ```SomeTrait``` is defined (even one that does not apply) it stops the autodereferencing that would otherwise occur. The following error message explains this pretty clearly:\r\n\r\n```\r\nerror[E0277]: the trait bound `&example::Structure: SomeTrait<B>` is not satisfied\r\n  --> src/example.rs:79:18\r\n   |\r\n79 |     tmp.do_stuff(B); // should call generic version, fails if SomeTrait<A> or SomeTrait<C> is implemented\r\n   |         -------- ^ the trait `SomeTrait<B>` is not implemented for `&example::Structure`\r\n   |         |\r\n   |         required by a bound introduced by this call\r\n   |\r\n   = help: the following other types implement trait `SomeTrait<T>`:\r\n             <&example::Structure as SomeTrait<A>>\r\n             <&example::Structure as SomeTrait<C>>\r\n             <example::Structure as SomeTrait<T>>\r\n```\r\n\r\nThe expectation is that the autoderef rules should apply here. The compiler notes that ```&Structure``` does not implement ```SomeTrait<B>```, which is true. Normally, this would mean that ```&Structure``` is dereferenced, and the compiler checks if ```SomeTrait<B>``` is implemented for ```Structure``` instead. In this case, however, this does not seem to happen. Since the compiler notes that there are definitions of ```SomeTrait``` with other generic parameters (```A``` and ```C```, but not ```B```) on ```&Structure```, it fails instead of checking the dereferenced types. As I understand it, a trait with two sets of generic parameters are two completely different traits. That is, ```SomeTrait<A>```, ```SomeTrait<B>```, and ```SomeTrait<C>``` are all different traits, and as such, the definition of ```SomeTrait<A>``` or ```SomeTrait<C>``` should not prevent autodereferencing.\r\n\r\nIn essence, I believe that this example should compile, with the final call using the ```impl<T> SomeTrait<T> for Structure``` implementation by dereferencing &Structure, instead of failing once the ```SomeTrait<A>``` and ```SomeTrait<C>``` definitions are found on ```Structure``` as they are unrelated.\r\n\r\n### Meta\r\nI've checked this behavior on both stable and nightly, with the same results on both versions.\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustup 1.25.1 (bb60b1e89 2022-07-12)\r\ninfo: This is the version for the rustup toolchain manager, not the rustc compiler.\r\ninfo: The currently active `rustc` version is `rustc 1.68.0-nightly (659e169d3 2023-01-04)\r\n```\r\n\r\n\r\n", "closed_by": {"login": "KevinThierauf", "id": 47986413, "node_id": "MDQ6VXNlcjQ3OTg2NDEz", "avatar_url": "https://avatars.githubusercontent.com/u/47986413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KevinThierauf", "html_url": "https://github.com/KevinThierauf", "followers_url": "https://api.github.com/users/KevinThierauf/followers", "following_url": "https://api.github.com/users/KevinThierauf/following{/other_user}", "gists_url": "https://api.github.com/users/KevinThierauf/gists{/gist_id}", "starred_url": "https://api.github.com/users/KevinThierauf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KevinThierauf/subscriptions", "organizations_url": "https://api.github.com/users/KevinThierauf/orgs", "repos_url": "https://api.github.com/users/KevinThierauf/repos", "events_url": "https://api.github.com/users/KevinThierauf/events{/privacy}", "received_events_url": "https://api.github.com/users/KevinThierauf/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/106510/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/106510/timeline", "performed_via_github_app": null, "state_reason": "completed"}