{"url": "https://api.github.com/repos/rust-lang/rust/issues/73295", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/73295/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/73295/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/73295/events", "html_url": "https://github.com/rust-lang/rust/issues/73295", "id": 638034779, "node_id": "MDU6SXNzdWU2MzgwMzQ3Nzk=", "number": 73295, "title": "Allow export of Rust symbols from a C shared object via a staticlib", "user": {"login": "adetaylor", "id": 145740, "node_id": "MDQ6VXNlcjE0NTc0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/145740?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adetaylor", "html_url": "https://github.com/adetaylor", "followers_url": "https://api.github.com/users/adetaylor/followers", "following_url": "https://api.github.com/users/adetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/adetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/adetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adetaylor/subscriptions", "organizations_url": "https://api.github.com/users/adetaylor/orgs", "repos_url": "https://api.github.com/users/adetaylor/repos", "events_url": "https://api.github.com/users/adetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/adetaylor/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37547, "node_id": "MDU6TGFiZWwzNzU0Nw==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-linkage", "name": "A-linkage", "color": "f7e101", "default": false, "description": "Area: linking into static, shared libraries and binaries"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 16, "created_at": "2020-06-12T22:35:43Z", "updated_at": "2023-05-24T19:49:42Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "clang offers the ability to mark a symbol as exported or non-exported from a dynamic shared object (DSO) using `__attribute__((visibility (\"default\")))` and `__attribute__ ((visibility (\"hidden\")))`. This issue requests the same in Rust, though it may be a bit more complex in the Rust case.\r\n\r\nAnother way of looking at it is to cleave the dual purpose of `#[no_mangle]` where it both sets visibility and alters the exported name.\r\n\r\nThe rest of this issue explains why this would be useful.\r\n\r\nI am working in a pre-existing complex C++ codebase. It produces multiple DSOs, let\u2019s say:\r\n\r\n* `libbase.so`\r\n* `libservices.so`\r\n\r\nWe want to build Rust code into each of those DSOs. Internally, the C++ and Rust code is intermixed freely (for example, the C++ JSON APIs within `libbase.so` call into a serde-based parser, which calls back into C++ to instantiate objects, etc.) There is no possibility of splitting these DSOs into separate DSOs for Rust and C++ code.\r\n\r\nWe build Rust code into these DSOs in the approved way, which is to aggregate a bunch of Rust libraries (rlibs) into a separate Rust `staticlib` for each of the DSOs. (For example, `libbase_rust_deps.a` and `libservices_rust_deps.a`). The final C++ linker links exactly one of these staticlibs together with the C++ .a and .o in the final construction of the DSO. That should be fine, since the whole point of a `staticlib` Rust target is to contain the Rust code and all its dependencies.\r\n\r\n`libservices.so` depends on `libbase.so`. In C++, `libservices.so` uses symbols exposed from `libbase.so`. For example, there may be a `CPP::Log` function used by C++ code within both `libbase.so` and `libservices.so`. That\u2019ll be exported from `libbase.so` using an `__attribute__((visibility (\"default\")))` annotation in the source code for `CPP::Log`.\r\n\r\nSo far so good.\r\n\r\nBut now we want to put a Rust wrapper around that `CPP::Log` function, to make, say, `rs_log`. Ideally, there would be just a single implementation of `rs_log` in `libbase.so`. We want to be able to call that Rust wrapper from within the Rust parts of `libbase.so` or `libservices.so`.\r\n\r\nThis seems to be impossible.\r\n\r\nOur options are:\r\n* Build a `dylib` using rustc, which exposes all public Rust APIs from the DSO. We can\u2019t do that for the reasons cited above; we need to build a `staticlib` as the Rust code is just a small component of existing DSOs. Rustc can\u2019t be in control of the final linking.\r\n* Mark `rs_log` as `#[no_mangle]` which successfully exports it from `libbase.so`, but using a C ABI which prevents Rust discovering and using this symbol even if downstream crates are built using `--extern rust_base=./libbase.so`\r\n\r\n(this latter case gives\r\n```\r\nerror[E0463]: can't find crate for `rust_base`\r\n  --> ./rust_static_libs/libservices_rust_deps/mod.rs:20:1\r\n   |\r\n20 | extern crate rust_base;\r\n   | ^^^^^^^^^^^^^^^^^^^^^^^ can't find crate\r\n```\r\n)\r\n\r\n### Solution?\r\n\r\nIt\u2019s a problem that `#[no_mangle]` has twin effects: specify a particular name for C linkage purposes, _and_ mark the symbol for DSO export. We want to do the latter but not the former. https://github.com/rust-lang/rust/issues/54135#issuecomment-607935953 wants to do the former but not the latter. Can we separate those?\r\n\r\nFor our needs, ideally we\u2019d mark `rs_log` with something like an `#[dso_export]` annotation. This would:\r\n* Mark that symbol with the equivalent of `__attribute__((visibility (\"default\")))`, such that as it moves through the rlib, then staticlib, then the DSO, it is successfully exported from the DSO.\r\n* But unlike `#[no_mangle]` it wouldn\u2019t change the symbol name and it would remain callable by Rust.\r\n* (The likely trickier bit) When building the final `staticlib`, determine if there are any such exported Rust APIs. If so, include whatever information is required by Rust to consider `libbase.so` to be a valid crate equivalent to a `dylib`. (I don\u2019t know how Rust metadata is structured; whether this is just an extra few exported symbols or if there are entire linker sections within a `dylib` that would somehow need to be replicated. I strongly suspect the latter so I don\u2019t even know if this is possible without changing the final C++ linker command).\r\n\r\n### Related work\r\n\r\nhttps://github.com/rust-lang/rust/issues/54135 requests something similar, but using `#[used]` on static variables - so I think it\u2019s not quite the same thing.\r\nhttps://github.com/dtolnay/cxx/issues/219 proposes the workaround which we might need to do meanwhile (but isn\u2019t ideal because, in the above example, `RS::Log` would be duplicated between two DSOs)\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/73295/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/73295/timeline", "performed_via_github_app": null, "state_reason": null}