{"url": "https://api.github.com/repos/rust-lang/rust/issues/78544", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/78544/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/78544/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/78544/events", "html_url": "https://github.com/rust-lang/rust/issues/78544", "id": 732702744, "node_id": "MDU6SXNzdWU3MzI3MDI3NDQ=", "number": 78544, "title": "MIR InstrumentCoverage: Improve coverage of `#[should_panic]` tests and `catch_unwind()` handlers", "user": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 256133398, "node_id": "MDU6TGFiZWwyNTYxMzMzOTg=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-mir", "name": "A-mir", "color": "f7e101", "default": false, "description": "Area: Mid-level IR (MIR) - https://blog.rust-lang.org/2016/04/19/MIR.html"}, {"id": 2483744621, "node_id": "MDU6TGFiZWwyNDgzNzQ0NjIx", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-code-coverage", "name": "A-code-coverage", "color": "f7e101", "default": false, "description": "Area: Source-based code coverage (-Cinstrument-coverage)"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2020-10-29T22:21:01Z", "updated_at": "2023-04-05T17:41:30Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "At present, the MIR `InstrumentCoverage` pass omits unwind paths when computing coverage spans and injecting counters because (1) statements executed during an unwind are generally compiler-generated, so they don't have source code to \"cover\"; and (2) in normal runtime execution, unwind paths are generally called when an unexpected and/or unhandled error is encountered.\r\n\r\nUnexpected errors can (and probably should) be corrected before addressing coverage errors.\r\n\r\nSome exceptions to this are: (1) tests that include testing for known `panic` situations, for instance, unit tests annotated with the `#[should_panic]` attribute; and (2) code that leverages a `catch_unwind()` handler.\r\n\r\nSince coverage analysis is commonly used to validate that test cases execute all source code, and `#[should_panic]` tests might be included among the test cases, `InstrumentCoverage` could be improved to provide a more accurate representation of coverage when a `Call` unwinds.\r\n\r\nSpecifically, non-branching `Statement`s and `Terminator`s that follow a `TerminatorKind::Call` (if not other `TerminatorKind`s) are counted as having been \"executed\" by the same counter that counts the execution of the `Call`, as well as the non-branching statements that preceded the `Call`.\r\n\r\nBut if the `Call` panics, non-branching statements leading up to the `Call` will have been executed, and statements following the `Call` will *not* be executed. With only one counter, both sets of statements (before and after, and the `Call` itself will have the same execution count (either 1 or 0, depending on the type of counter, and where the counter is incremented).\r\n\r\nTo accurately count these sequences with the potential for panics, an actual code counter needs to be incremented after each successful call.\r\n\r\nAdding these counters will increase the physical size of the binaries and slow down execution, so this is a feature that should only be enabled as an option.\r\n\r\nOne question is, how can this option be enabled granularly? \r\n\r\nFor `#[should_panic]` tests, it makes sense to enable the option for the test function, but this would not correct the counters for panicking calls in functions called by the test function. It may be possible to trace the calls to enable the option on the functions called by `#[should_panic]` test functions, and the functions executed by those functions, but this won't work for functions from external crates.\r\n\r\nSimilar logic could be used for functions called via `catch_unwind()`, with similar limitations. \r\n\r\nSo a worst-case approach would be to enable this feature when compiling the tested crate and all of its dependencies, using a `rustc` compiler flag.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/78544/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/78544/timeline", "performed_via_github_app": null, "state_reason": null}