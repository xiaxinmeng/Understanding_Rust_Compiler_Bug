{"url": "https://api.github.com/repos/rust-lang/rust/issues/87520", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/87520/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/87520/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/87520/events", "html_url": "https://github.com/rust-lang/rust/issues/87520", "id": 954140187, "node_id": "MDU6SXNzdWU5NTQxNDAxODc=", "number": 87520, "title": "Which patterns on union fields should be considered safe?", "user": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 7, "created_at": "2021-07-27T18:13:11Z", "updated_at": "2021-10-19T17:35:37Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "*Moved from #85263 as the PR has been merged.*\r\n\r\n# Summary of safety of pattern matching against Rust `union`s\r\n\r\n*Written by @Smittyvb, copied from https://github.com/rust-lang/rust/pull/85263#issuecomment-842549594*\r\n\r\nThe unsafety checker is being to rewritten operate on the THIR instead of the MIR. As a part of that, I was implementing the unsafety rules for `union`s, and encountered some weird edge cases with the way the MIR unsafety checker handles `union`s. In general, writing to a union is safe but reading is `unsafe`. There are some cases where _writing_ to a union is unsafe (such as when that might cause a `Drop` call) that are not being implemented in this PR.\r\n\r\n## Behavior specified by [RFC 1444](https://rust-lang.github.io/rfcs/1444-union.html)\r\n\r\n> Unsafe code may pattern match on union fields, using the same syntax as a\r\n> struct, without the requirement to mention every field of the union in a match\r\n> or use `..`:\r\n> \r\n> ```rust\r\n> fn f(u: MyUnion) {\r\n>     unsafe {\r\n>         match u {\r\n>             MyUnion { f1: 10 } => { println!(\"ten\"); }\r\n>             MyUnion { f2 } => { println!(\"{}\", f2); }\r\n>         }\r\n>     }\r\n> }\r\n> ```\r\n> \r\n> Matching a specific value from a union field makes a refutable pattern; naming\r\n> a union field without matching a specific value makes an irrefutable pattern.\r\n> Both require unsafe code.\r\n> \r\n> Pattern matching may match a union as a field of a larger structure.  In\r\n> particular, when using a Rust union to implement a C tagged union via FFI, this\r\n> allows matching on the tag and the corresponding field simultaneously:\r\n> \r\n> ```rust\r\n> #[repr(u32)]\r\n> enum Tag { I, F }\r\n> \r\n> #[repr(C)]\r\n> union U {\r\n>     i: i32,\r\n>     f: f32,\r\n> }\r\n> \r\n> #[repr(C)]\r\n> struct Value {\r\n>     tag: Tag,\r\n>     u: U,\r\n> }\r\n> \r\n> fn is_zero(v: Value) -> bool {\r\n>     unsafe {\r\n>         match v {\r\n>             Value { tag: I, u: U { i: 0 } } => true,\r\n>             Value { tag: F, u: U { f: 0.0 } } => true,\r\n>             _ => false,\r\n>         }\r\n>     }\r\n> }\r\n> ```\r\n> \r\n> Note that a pattern match on a union field that has a smaller size than the\r\n> entire union must not make any assumptions about the value of the union's\r\n> memory outside that field.  For example, if a union contains a `u8` and a\r\n> `u32`, matching on the `u8` may not perform a `u32`-sized comparison over the\r\n> entire union.\r\n\r\n## Actual behavior\r\nThe MIR unsafety checker doesn't implement that behavior exactly. Due to the way that the MIR is constructed and optimized, some destructuring patterns against unions that that the RFC specifies to be unsafe are allowed.\r\n\r\nThe behavior of the MIR is mostly \"irrefutable pattern matching against unions without any bindings after desugaring or-patterns is safe\", with some extra weird behavior when niches are involved.\r\n\r\nHere are some examples of what the MIR considers safe and unsafe. Here is the prelude for all of these examples:\r\n```rust\r\nunion Foo { bar: i8, zst: (), pizza: Pizza, oneval: OneVal, twoval: TwoVal, khar: char }\r\n\r\n#[derive(Copy, Clone)]\r\nstruct Pizza { topping: Option<PizzaTopping> }\r\n\r\n#[derive(Copy, Clone)]\r\nenum PizzaTopping { Cheese, Pineapple }\r\n\r\n#[derive(Copy, Clone)]\r\n#[repr(u8)]\r\nenum OneVal { One = 1 }\r\n\r\n#[derive(Copy, Clone)]\r\n#[repr(u8)]\r\npub enum TwoVal {\r\n    One = 1,\r\n    Two = 2,\r\n}\r\n\r\nlet mut foo = Foo { bar: 5 };\r\n```\r\n\r\n### Patterns considered safe\r\n```rust\r\nmatch (Foo { bar: 42 }) {\r\n    Foo { oneval: OneVal::One } => {\r\n        // always run\r\n    },\r\n}\r\n```\r\n```rust\r\nmatch foo {\r\n    Foo { bar: _ | _ } => {},\r\n}\r\n```\r\n```rust\r\nmatch u {\r\n    Foo { pizza: Pizza { .. } } => {},\r\n};\r\n```\r\n```rust\r\nmatch u {\r\n    Foo { pizza: Pizza { topping: _ } } => {},\r\n};\r\n```\r\n```rust\r\nmatch foo {\r\n    Foo { zst: () } => {},\r\n}\r\n```\r\n```rust\r\nlet Foo { bar: _ } = foo;\r\n```\r\n```rust\r\nmatch Some(foo) {\r\n    Some(Foo { bar: _ }) => 3,\r\n    None => 4,\r\n};\r\n```\r\n\r\n### Patterns considered `unsafe`\r\nAll of these require an `unsafe` block to compile.\r\n\r\n```rust\r\nmatch (Foo { bar: 42 }) {\r\n    Foo { twoval: TwoVal::One | TwoVal::Two } => {\r\n        // always run\r\n    },\r\n}\r\n```\r\n```rust\r\nmatch foo {\r\n    Foo {\r\n        pizza: Pizza {\r\n            topping: Some(PizzaTopping::Cheese) | Some(PizzaTopping::Pineapple) | None\r\n        }\r\n    } => {},\r\n}\r\n```\r\n```rust\r\nmatch foo {\r\n    Foo { bar: _a } => {},\r\n}\r\n```\r\n```rust\r\nlet Foo { bar: inner } = foo;\r\n```\r\n```rust\r\nlet (Foo { bar } | Foo { bar }) = foo;\r\n```\r\n```rust\r\nmatch foo.khar {\r\n    '\\0'..='\\u{D7FF}' | '\\u{E000}'..='\\u{10FFFF}' => ()\r\n};\r\n```\r\n```rust\r\nmatch x.b {\r\n    '\\0'..='\\u{10FFFF}' => 1,\r\n};\r\n```\r\n\r\n---\r\n\r\ncc @Smittyvb @RalfJung @nikomatsakis", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/87520/reactions", "total_count": 2, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 2, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/87520/timeline", "performed_via_github_app": null, "state_reason": null}