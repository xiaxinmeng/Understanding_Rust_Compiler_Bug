{"url": "https://api.github.com/repos/rust-lang/rust/issues/73174", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/73174/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/73174/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/73174/events", "html_url": "https://github.com/rust-lang/rust/issues/73174", "id": 635661656, "node_id": "MDU6SXNzdWU2MzU2NjE2NTY=", "number": 73174, "title": "Matching function signature is nearly impossible in declarative macros (mbe)", "user": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 132910982, "node_id": "MDU6TGFiZWwxMzI5MTA5ODI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-macros", "name": "A-macros", "color": "f7e101", "default": false, "description": "Area: All kinds of macros (custom derive, macro_rules!, proc macros, ..)"}, {"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 630652267, "node_id": "MDU6TGFiZWw2MzA2NTIyNjc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-feature-request", "name": "C-feature-request", "color": "f5f1fd", "default": false, "description": "Category: A feature request, i.e: not implemented / a PR."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2020-06-09T18:22:48Z", "updated_at": "2020-06-11T02:17:35Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "I'm trying a write a macro that needs a function signature. I want smt like this to work:\r\n```rust\r\nmacros! {\r\n    pub fn foo(&self, arg: Arg) -> Ret;\r\n    // inside the macro I have access to visibility, function qualifiers, arguments, \r\n}\r\n```\r\n\r\nHowever, there are 2 things that are nearly impossible to parse...\r\n\r\n## Qualifiers\r\n\r\nAccording to [rust reference][ref] rust function can have\r\n- either `const` or `async` \r\n- `unsafe`\r\n- `extern` / `extern \"Abi\"`\r\n\r\nIt's possible to use `$( unsafe )?` (and same for other qualifiers), however, you then can't expand it back (because in this repetition there are no `$var`s).\r\n\r\nIt's also not possible to match them with `tt`s because `:vis` [doesn't allow][tt_follow_vis] `tt` after it.\r\n\r\n_My workaround_ is to use `[ $( $qual:tt )* ]`, but it's just a workaround and it requires changes to macro input. (you need to write `pub [unsafe] fn ...`)\r\n\r\n[ref]: https://doc.rust-lang.org/reference/items/functions.html\r\n[tt_follow_vis]: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=460c3c4a0c1a76f9cc5cf0c5143009e2\r\n\r\n## Trait bounds and `where` clause\r\n\r\nthere are several problems with bounds...\r\n\r\n#### 1. there is no way to match a trait (`path::Trait<'life, Type>`)\r\n\r\nThis one is more tricky. There are no such fragments as trait or bound, so we'll need to work around this somehow. (`:ty` doesn't work because it assumes that a trait is a trait object and it [can't be used][trait_ty] in a bound)\r\n\r\nI'd like this to work: `$trait:path $( < $( $lifes:lifetime ),* $(,)? $( $generics:ty ),* $(,)? > )?`, however, there are 2 problems with it:\r\n1. `:path` [doesn't allow][path_lt] `<` after it. (workaround: use `$tr_head:ident $( :: $tr_tail:ident )*` instead of `:path`)\r\n2. `rustc` can't choose between [parsing `'life` as a lifetime or as a type][local_ihateyou] (???) (it somehow [thinks that `'life` can be a part of trait object][life_tr_obj])\r\n\r\nI thought that `2.` can be worked around by using smt like `$life_or_ty_head:tt $( :: $ty_tail:ident )* $( < $( $lifes:lifetime ),* $(,)? $( $generics:ty ),* $(,)? > )?` (`:tt` will match both `'life` and `head` part of `head::Ty...`), **but** here is a catch: to express a type you need generics with lifetimes over again :)\r\n\r\n[trait_ty]: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=b7a33f376fa0b21659523236900df797\r\n[path_lt]: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=2774ff6da7cc9d6abfe8e2e5d7775674\r\n[local_ihateyou]: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=6cab28918be2277664dca43eb1737b70\r\n[life_tr_obj]: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=69e8b2d08b8af74590f6952c4604c2e1\r\n\r\n#### 2. it's not possible to use `+`, `*` and `?` as a separator in repetition \r\n\r\nYou need this to match a bound: `: Trait + 'a + Trait2 + 'b ...`\r\n\r\nRelated issue (opened in 2014! >_<): #18700 \r\n\r\n#### 3. you can't express 'either PatternA or PatternB' with mbe\r\n\r\nThis is needed because in where clause you can alternate lifetimes and types:\r\n```rust\r\nfn test<'t, 'a, 'b, 'c, A, B>() \r\nwhere\r\n    A: Trait,\r\n    't: 'a + 'b,\r\n    B: Trait,\r\n    't: 'c,\r\n{}\r\n```\r\n([playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=8b5fd784112b8c7a84f2f46a694fdf3d))\r\n\r\n## Possible solutions\r\n\r\nOne a may think of is to add missing fragments & separator escaping, e.g.:\r\n\r\n- `:trait` (matches the same things as `:ty` but assumes that it's trait)\r\n- `:bound` (matches bound, e.g.: `Trait + 'life + Trait<'life, i32, T>`)\r\n- `:qual` (matches one of `const`, `async`, `unsafe`, `extern \"Abi\"` and `extern`)\r\n- `$( ... )$+*` (matches 0 or more `...` separated by `+`, see https://github.com/rust-lang/rfcs/pull/944)\r\n\r\nThis would solve most of the mentioned problems (except `'life`/`Gen` ordering), but I have no idea what problems all of that can bring, is it hard to implement, is this breaking change, etc. I would like to hear from somebody who is more competent in this theme...\r\n\r\nThe lifetime/generics ordering problem can be solved with 'or patterns' (ADT/enums in macros? :thinking:) but this needs a syntax decision and there are a lot of open questions (I think). \r\n\r\nI can imagine smt like `${ A( $a:ident ... ) | B( ... $b:ident ) }` & `${ A => { a($a) }; B => { b($b) }; }` (first is a pattern and second is a expansion thing) that will expand `t ...` to `a(t)` and `... t` to `b(t)`......\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/73174/reactions", "total_count": 7, "+1": 7, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/73174/timeline", "performed_via_github_app": null, "state_reason": null}