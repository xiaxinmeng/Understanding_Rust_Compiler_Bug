{"url": "https://api.github.com/repos/rust-lang/rust/issues/81005", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/81005/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/81005/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/81005/events", "html_url": "https://github.com/rust-lang/rust/issues/81005", "id": 785884013, "node_id": "MDU6SXNzdWU3ODU4ODQwMTM=", "number": 81005, "title": "Safety of ptr::swap is unclear", "user": {"login": "pandaman64", "id": 1788628, "node_id": "MDQ6VXNlcjE3ODg2Mjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1788628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pandaman64", "html_url": "https://github.com/pandaman64", "followers_url": "https://api.github.com/users/pandaman64/followers", "following_url": "https://api.github.com/users/pandaman64/following{/other_user}", "gists_url": "https://api.github.com/users/pandaman64/gists{/gist_id}", "starred_url": "https://api.github.com/users/pandaman64/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pandaman64/subscriptions", "organizations_url": "https://api.github.com/users/pandaman64/orgs", "repos_url": "https://api.github.com/users/pandaman64/repos", "events_url": "https://api.github.com/users/pandaman64/events{/privacy}", "received_events_url": "https://api.github.com/users/pandaman64/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 2011781731, "node_id": "MDU6TGFiZWwyMDExNzgxNzMx", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs", "name": "T-libs", "color": "bfd4f2", "default": false, "description": "Relevant to the library team, which will review and decide on the PR/issue."}, {"id": 2242906716, "node_id": "MDU6TGFiZWwyMjQyOTA2NzE2", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-raw-pointers", "name": "A-raw-pointers", "color": "f7e101", "default": false, "description": "Area: raw pointers, MaybeUninit, NonNull"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2021-01-14T10:47:41Z", "updated_at": "2022-02-08T20:19:10Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "The [`ptr::swap`](https://doc.rust-lang.org/std/ptr/fn.swap.html) function allows passed pointers to overlap, and its safety section is as follows:\r\n> Behavior is undefined if any of the following conditions are violated:\r\n>\r\n>    - Both x and y must be valid for both reads and writes.\r\n>    - Both x and y must be properly aligned.\r\n>\r\n> Note that even if T has size 0, the pointers must be non-NULL and properly aligned.\r\n\r\nIt says that both pointers must be \"valid,\" but IIUC, the definition of validity becomes unclear under Stacked Borrows.\r\n\r\nConsider the following program (all code in this comment is checked using Miri with `MIRIFLAGS=\"-Zmiri-track-raw-pointers\"`):\r\n```rust\r\nunsafe {\r\n    let mut x: [i32; 3] = [100, 200, 300];\r\n    let p: *mut i32 = x.as_mut_ptr();\r\n    let p1: *mut [i32; 2] = p as *mut [i32; 2]; // pointer to the first two elements\r\n    let p2: *mut [i32; 2] = &mut *(p.add(1) as *mut [i32; 2]); // pointer to the last two elements\r\n\r\n    // \u2606: each pointer is valid according to Stacked Borrows.\r\n    *p2 = [100, 200];\r\n    *p1 = [200, 300];\r\n}\r\n```\r\n\r\n`p1` and `p2` are both \"valid\" at \u2606 in the sense that this program is safe.\r\n`p2` is invalidated when we perform a write using `p1`, but it's ok because we don't use `p2` anymore.\r\n\r\nHowever, the following program exhibits UB in spite of the validity of `p1` and `p2`, because `ptr::swap` first reads from `p1` and the read invalidates `p2`.\r\n```rust\r\n// Example 1 (UB)\r\nunsafe {\r\n    let mut x: [i32; 3] = [100, 200, 300];\r\n    let p: *mut i32 = x.as_mut_ptr();\r\n    let p1: *mut [i32; 2] = p as *mut [i32; 2];\r\n    let p2: *mut [i32; 2] = &mut *(p.add(1) as *mut [i32; 2]); // intermediate reference\r\n\r\n    std::ptr::swap(p1, p2); // this is UB\r\n}\r\n```\r\n\r\nNote that the intermediate unique reference (`&mut *`) is crucial for \"separating\" the two pointers.\r\nIf we remove the intermediate reference, those pointers have the same capabilities.\r\nIn other words, the following program does **not** exhibit UB:\r\n```rust\r\n// Example 2 (no UB)\r\nunsafe {\r\n    let mut x: [i32; 3] = [100, 200, 300];\r\n    let p: *mut i32 = x.as_mut_ptr();\r\n    let p1: *mut [i32; 2] = p as *mut [i32; 2];\r\n    let p2: *mut [i32; 2] = p.add(1) as *mut [i32; 2]; // no intermediate reference\r\n\r\n    std::ptr::swap(p1, p2); // this is not UB\r\n}\r\n```\r\n\r\nThe difference between the two examples is so subtle that I'm not sure how to spell out the exact safety conditions for `ptr::swap`.\r\n\r\nThis issue is found while formalizing the safety of `ptr::swap` in the Rustv project.\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/81005/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/81005/timeline", "performed_via_github_app": null, "state_reason": null}