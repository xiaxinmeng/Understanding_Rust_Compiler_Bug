{"url": "https://api.github.com/repos/rust-lang/rust/issues/73849", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/73849/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/73849/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/73849/events", "html_url": "https://github.com/rust-lang/rust/issues/73849", "id": 646999978, "node_id": "MDU6SXNzdWU2NDY5OTk5Nzg=", "number": 73849, "title": "Rust does not optimize register save/restore for early exit (slower than nim)", "user": {"login": "nokola", "id": 6869225, "node_id": "MDQ6VXNlcjY4NjkyMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6869225?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nokola", "html_url": "https://github.com/nokola", "followers_url": "https://api.github.com/users/nokola/followers", "following_url": "https://api.github.com/users/nokola/following{/other_user}", "gists_url": "https://api.github.com/users/nokola/gists{/gist_id}", "starred_url": "https://api.github.com/users/nokola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nokola/subscriptions", "organizations_url": "https://api.github.com/users/nokola/orgs", "repos_url": "https://api.github.com/users/nokola/repos", "events_url": "https://api.github.com/users/nokola/events{/privacy}", "received_events_url": "https://api.github.com/users/nokola/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2020-06-28T20:32:22Z", "updated_at": "2020-07-05T08:48:24Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\n\r\nNote: This is a synthetic benchmark, however I believe it has the potential to improve runtime performance across the board for function calls because the push/pop register optimization in case of \"early exit\" seems like a low-hanging fruit. See assembly analysis below.\r\n\r\nI used the following code \r\n\r\n**Rust 1.44.1:**\r\ncompiler options: -C opt-level=3 -C lto=fat\r\n```rust\r\npub fn fib(n: u64) -> u64 {\r\n  if n <= 1 { return 1 }\r\n  fib(n - 1) + fib(n - 2)\r\n}\r\n\r\nfn main() {\r\n  println!(\"{}\", fib(48));\r\n}\r\n```\r\nTotalSeconds      : 12.3482073\r\nTotalMilliseconds : 12348.2073 **5% slower**\r\n\r\n**Nim 1.2.0:**\r\ncompiler options: cpp -d:release --passC:-fno-inline-small-functions\r\n```nim\r\nproc fib(n: uint64): uint64 =\r\n    if n <= 1: return 1\r\n    return fib(n - 1) + fib(n - 2)\r\n\r\necho fib(48)\r\n```\r\nTotalSeconds      : 11.7725467\r\nTotalMilliseconds : 11772.5467\r\n\r\n**I expected to see this happen:** Rust-generated assembly (see below) to only save and restore register if needed\r\n\r\nInstead, this happened: Rust-generated assembly saves registers even in the \"early exit\" case, when `n <= 1`. Compared to nim's assembly, we see that the registers are not saved/restored for the early exit case. \r\n\r\nNote: Given with the exponential count of the \"early exit\" case, this makes the benchmark perform significantly slower. However, I suspect even in real life we will benefit from having an early exit optimization.\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.44.1 (c7087fe00 2020-06-17)\r\nbinary: rustc\r\ncommit-hash: c7087fe00d2ba919df1d813c040a5d47e43b0fe7\r\ncommit-date: 2020-06-17\r\nhost: x86_64-pc-windows-msvc\r\nrelease: 1.44.1\r\nLLVM version: 9.0\r\n```\r\n\r\n### Analysis: generated assembly and likely reason for slowdown\r\nFor the assembly analysis I use https://rust.godbolt.org/ with the above sample code and options.\r\nHere's the relevant assembly and source:\r\n**Rust:**\r\n\r\n![image](https://user-images.githubusercontent.com/6869225/85957512-c8703b80-b942-11ea-85a4-464e208c65bf.png)\r\n\r\n\r\n```asm\r\nexample::fib:\r\n        push    r15\r\n        push    r14\r\n        push    rbx\r\n        mov     r14d, 1    # function init\r\n\r\n        cmp     rdi, 2      # if n <= 1\r\n        jb      .LBB0_3     # return 1\r\n        mov     rbx, rdi\r\n        mov     r14d, 1\r\n        mov     r15, qword ptr [rip + example::fib@GOTPCREL]\r\n.LBB0_2:\r\n        lea     rdi, [rbx - 1]\r\n        call    r15\r\n        add     rbx, -2\r\n        add     r14, rax\r\n        cmp     rbx, 1\r\n        ja      .LBB0_2\r\n.LBB0_3:\r\n        mov     rax, r14\r\n        pop     rbx\r\n        pop     r14\r\n        pop     r15\r\n        ret\r\n```\r\n\r\n**Nim:**\r\n\r\n![image](https://user-images.githubusercontent.com/6869225/85957543-171dd580-b943-11ea-9381-7f26cb0e4ee3.png)\r\n\r\n```nim\r\nproc fib(n: uint64): uint64 =\r\n    if n <= 1: return 1\r\n    return fib(n - 1) + fib(n - 2)\r\n\r\necho fib(48)\r\n```\r\n\r\n```asm\r\nfib__Q9chlIZts06QqO9cyt9cUDmlg(unsigned long):\r\n cmp    rdi,0x1\r\n ja     20 <fib__Q9chlIZts06QqO9cyt9cUDmlg(unsigned long)+0x10>\r\n mov    eax,0x1\r\n ret    \r\n nop    DWORD PTR [rax+0x0]\r\n push   r12\r\n lea    r12,[rdi-0x3]\r\n push   rbp\r\n lea    rbp,[rdi-0x1]\r\n sub    rdi,0x2\r\n push   rbx\r\n and    rdi,0xfffffffffffffffe\r\n xor    ebx,ebx\r\n sub    r12,rdi\r\n mov    rdi,rbp\r\n sub    rbp,0x2\r\n call   45 <fib__Q9chlIZts06QqO9cyt9cUDmlg(unsigned long)+0x35>\r\n add    rbx,rax\r\n cmp    rbp,r12\r\n jne    39 <fib__Q9chlIZts06QqO9cyt9cUDmlg(unsigned long)+0x29>\r\n lea    rax,[rbx+0x1]\r\n pop    rbx\r\n pop    rbp\r\n pop    r12\r\n ret    \r\n nop    WORD PTR cs:[rax+rax*1+0x0]\r\n```\r\n\r\n### Analysis:\r\n1. Rust will always save registers (push on function entry, pop on exit) even for cases that doesn't need it. In contrast, nim's generated code will not.\r\n2. This may or may not end up being beneficial in real-life scenarios, I suspect the optimization may be important.\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/73849/reactions", "total_count": 7, "+1": 7, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/73849/timeline", "performed_via_github_app": null, "state_reason": null}