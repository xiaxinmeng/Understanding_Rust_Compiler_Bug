{"url": "https://api.github.com/repos/rust-lang/rust/issues/9728", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/9728/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/9728/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/9728/events", "html_url": "https://github.com/rust-lang/rust/issues/9728", "id": 20567028, "node_id": "MDU6SXNzdWUyMDU2NzAyOA==", "number": 9728, "title": "Proposal: Anonymous fields", "user": {"login": "orenbenkiki", "id": 68190, "node_id": "MDQ6VXNlcjY4MTkw", "avatar_url": "https://avatars.githubusercontent.com/u/68190?v=4", "gravatar_id": "", "url": "https://api.github.com/users/orenbenkiki", "html_url": "https://github.com/orenbenkiki", "followers_url": "https://api.github.com/users/orenbenkiki/followers", "following_url": "https://api.github.com/users/orenbenkiki/following{/other_user}", "gists_url": "https://api.github.com/users/orenbenkiki/gists{/gist_id}", "starred_url": "https://api.github.com/users/orenbenkiki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/orenbenkiki/subscriptions", "organizations_url": "https://api.github.com/users/orenbenkiki/orgs", "repos_url": "https://api.github.com/users/orenbenkiki/repos", "events_url": "https://api.github.com/users/orenbenkiki/events{/privacy}", "received_events_url": "https://api.github.com/users/orenbenkiki/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2013-10-05T16:31:52Z", "updated_at": "2014-03-23T08:43:44Z", "closed_at": "2014-03-23T08:43:44Z", "author_association": "NONE", "active_lock_reason": null, "body": "This is an attempt at defining possible implementation of anonymous fields (inspired by Go). There are some \"obvious\" design choices and some not-so-obvious ones involved. The following is what I hope to be a \"reasonable\" combination. Here goes...\n\nThe idea is to allow fields without a name, e.g.:\n\n```\nstruct Foo {\n    Bar, // Anonymous field\n    Baz, // Another anonymous field\n    named: int // Named field\n}\n```\n\nIt is illegal to have two anonymous fields with the same type (as that would be ambiguous).\n## Members\n\nWriting `foo.Bar.member` would access members of the `Bar` structure. This is always legal (since there's only one `Bar` member).\n\nWriting `foo.member` will access a member explicitly declared in `Foo`, if there is one. Otherwise, of there's only one anonymous member providing the member, it is accessed. Otherwise (if there's no such anonymous field, or if there's more than one), it is an error.\n## Methods\n\nWriting `foo.Bar.method(...)` would invoke the method on the `Bar` field. This is always legal (since there's only one `Bar` member).\n\nWriting `foo.method(...)` works similarly to accessing a member - if there's a method explicitly declared for `Foo`, it is called; if there's only one anonymous field providing it, it is called; otherwise, it is an error.\n\nDesign choice A: When a method of an anonymous field is invoked, all `self.*` or `function(self)` accesses are interpreted using the type of the anonymous field. For example, if `Foo` provides a `foo` method, and `Bar` also provides a `foo` method, and `Bar.bar` invokes `self.foo`, then `Foo.bar` will invoke `Bar.foo`, not `Foo.foo`.\n## Traits\n\nDesign choice B: There are no implicit traits for `Foo`.\n\nWhen implementing a trait for `Foo`, it is allowed to omit the implementation of a function if it is unambiguously available by any anonymous field. So, if `Bar` implements a trait, one should typically simply say `impl Trait for Foo {}` and be done.\n\nHowever, if an explicit function is defined inside the `impl Trait for Foo { ... }` block, it would be used instead of any anonymous field function. This is consistent with the function calling semantics above. For example, it may be required to specify a function if it is provided by more than one anonymous field.\n## Access\n\nDesign choice C: Public/private control of members and methods accessed via the anonymous field is inherited from the type of the anonymous field. That is, `Foo` gets no special access rights to the internals of `Bar`.\n## Diamonds\n\nDesign choice D: If both `Bar` and `Baz` have an anonymous field called `Qux`, then there are two separate instances of `Qux` - `foo.Bar.Qux...` and `foo.Baz.Qux...`. This is consistent with reusing the compiled version of anonymous field functions, and avoids the nastiness involved with the diamond multiple-inheritance pattern. So, no equivalent to C++'s \"virtual inheritance\".\n## Alternatives\n\nAn alternative to anonymous fields is to provide a `delegate` syntax, allowing delegating certain methods to (named) fields. Delegation would also need to work for members. The syntax for delegation would be tricky as we don't want to repeat the whole list of methods/members on the one hand, but would need to provide some control on the other hand. Possibly `delegate * to field_name` would be enough, but that is essentially the same having anonymous fields.\n## Other issues?\n\nThe above design choices are made with an eye for a useful simple semantics combined with a simple vtable-based implementation. This doesn't make them \"right\" and I probably missed some issues...\n", "closed_by": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/9728/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/9728/timeline", "performed_via_github_app": null, "state_reason": "completed"}