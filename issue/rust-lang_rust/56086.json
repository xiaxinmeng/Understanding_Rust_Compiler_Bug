{"url": "https://api.github.com/repos/rust-lang/rust/issues/56086", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/56086/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/56086/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/56086/events", "html_url": "https://github.com/rust-lang/rust/issues/56086", "id": 382428867, "node_id": "MDU6SXNzdWUzODI0Mjg4Njc=", "number": 56086, "title": "using wasm-pack build on ndarray concatenate", "user": {"login": "DevinBayly", "id": 11687631, "node_id": "MDQ6VXNlcjExNjg3NjMx", "avatar_url": "https://avatars.githubusercontent.com/u/11687631?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinBayly", "html_url": "https://github.com/DevinBayly", "followers_url": "https://api.github.com/users/DevinBayly/followers", "following_url": "https://api.github.com/users/DevinBayly/following{/other_user}", "gists_url": "https://api.github.com/users/DevinBayly/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinBayly/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinBayly/subscriptions", "organizations_url": "https://api.github.com/users/DevinBayly/orgs", "repos_url": "https://api.github.com/users/DevinBayly/repos", "events_url": "https://api.github.com/users/DevinBayly/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinBayly/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 9618520, "node_id": "MDU6TGFiZWw5NjE4NTIw", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-ICE", "name": "I-ICE", "color": "e10c02", "default": false, "description": "Issue: The compiler panicked, giving an Internal Compilation Error (ICE) \u2744\ufe0f"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}, {"id": 1359848690, "node_id": "MDU6TGFiZWwxMzU5ODQ4Njkw", "url": "https://api.github.com/repos/rust-lang/rust/labels/E-needs-mcve", "name": "E-needs-mcve", "color": "02e10c", "default": false, "description": "Call for participation: This issue needs a Minimal Complete and Verifiable Example"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-11-19T23:02:07Z", "updated_at": "2020-03-10T11:33:59Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "Hi there,\r\n\r\nHere's the lib.rs code that caused a compilation panic when using wasm-pack build \r\n```\r\n// next step is to try to figure out how to get the wasm module into an iodide session\r\nextern crate cfg_if; // this is the line which lest us enable things like wee aloc and console err panic hook\r\nextern crate wasm_bindgen;\r\nuse wasm_bindgen::prelude::*;\r\n\r\nextern crate js_sys;\r\n#[macro_use(array)]\r\nextern crate ndarray;\r\nextern crate nalgebra;\r\nextern crate rand;\r\nextern crate ndarray_rand;\r\n// better error handling\r\nextern crate console_error_panic_hook;\r\nuse std::panic;\r\n\r\n\r\n#[macro_use]\r\nextern crate failure_derive;\r\nextern crate failure;\r\n\r\n\r\nuse failure::Error;\r\nuse ndarray::prelude::*;\r\nuse ndarray::SliceOrIndex;\r\nuse ndarray::Array;\r\nuse ndarray::{stack,Axis,ArrayD, Dim, Ix, Ix2, IxDyn};\r\nuse rand::{thread_rng,Rng};\r\nuse rand::distributions::{Uniform,Distribution};\r\nuse ndarray_rand::RandomExt;\r\n\r\nuse nalgebra::{DMatrix};\r\n\r\nmod utils;\r\n\r\n\r\n#[wasm_bindgen]\r\nextern {\r\n    fn alert(s: &str);\r\n}\r\n\r\n#[wasm_bindgen]\r\npub fn greet() {\r\n    alert(\"Hello, wasm-pack-tutorial!\");\r\n}\r\n// need to be able to say the return type of  some of these functions is a certain dimension type\r\n// ?? should I use an enum for thedim type?\r\n#[wasm_bindgen]\r\n#[derive(Clone)]\r\npub struct Nd {\r\n    array: ArrayD<f32>,\r\n}\r\n\r\n//setting the consolelog for faster debugging\r\n#[wasm_bindgen]\r\nextern \"C\" {\r\n    #[wasm_bindgen(js_namespace = console)]\r\n    fn log(s:&str);\r\n}\r\nfn ret_f32(v:JsValue) -> f32{\r\n    js_sys::Number::new(&v).value_of() as f32\r\n}\r\n\r\n//todo change the ndarr to nd style\r\n#[wasm_bindgen]\r\nimpl Nd {\r\n    // this is for the panic hook\r\n    pub fn init() {\r\n        panic::set_hook(Box::new(console_error_panic_hook::hook));\r\n    }\r\n    // this gets called each time so that we can handle creation errors\r\n\r\n    pub fn svd(&self) -> Nd {\r\n        let count = self.array.shape();\r\n        // convert to nalgebra type\r\n        //let shape = self.array.shape();\r\n        //println!(\"{:?} {:?}\",shape[0],shape[1]);\r\n        let inside = self.array.view().to_owned().into_raw_vec();\r\n        let nalg_arr = DMatrix::from_iterator(count[0],count[1],inside);\r\n        //let res = SVD::new(nalg_arr,true,true);\r\n        //let lu = nalg_arr.svd(true,true);\r\n        let nalgebra::SVD {u,v_t:vt,singular_values} = nalg_arr.svd(true,true);\r\n        let svd_vt_data = vt.unwrap().data;\r\n        Nd{\r\n            array:Array::from_shape_vec([1,svd_vt_data.len()],svd_vt_data.to_vec()).unwrap().into_dyn()\r\n        }\r\n    }\r\n\r\n    // creation methods \r\n    pub fn from_array_buffer(arr: &[f32], dims: &js_sys::Array) -> Nd {\r\n        let dim_vec = make_arr_usize(dims);\r\n        let ixdyn = IxDyn(&dim_vec);\r\n        Nd {\r\n            array: Array::from_shape_vec(ixdyn, arr.to_vec()).unwrap().into_dyn(),\r\n        }\r\n    }\r\n\r\n    // eye will return a zero matrix with ones on diagonal.\r\n    pub fn eye(dim:JsValue)-> Nd {\r\n        let int_val= js_sys::Number::new(&dim).value_of() as usize;\r\n        Nd {\r\n            array: Array::eye(int_val).into_dyn()\r\n        }\r\n    }\r\n\r\n    // A value which fills the array of dimensions given\r\n    pub fn fill(dims: &js_sys::Array,val:JsValue) -> Nd {\r\n        let dim_vec = make_arr_usize(dims);\r\n        let float_val = js_sys::Number::new(&val).value_of() as f32;\r\n        let ixdyn = IxDyn(&dim_vec);\r\n        Nd {\r\n            array: Array::from_elem(ixdyn,float_val)\r\n        }\r\n    }\r\n\r\n\r\n    pub fn range(start:JsValue,end:JsValue,step:JsValue)-> Nd{\r\n        let start = ret_f32(start);\r\n        let end = ret_f32(end);\r\n        let step = ret_f32(step);\r\n        Nd {\r\n            array:Array::range(start,end,step).into_dyn()\r\n        }\r\n    }\r\n\r\n    //assumption is that the elements are floats\r\n    pub fn linspace(start:JsValue,end:JsValue,len:JsValue)-> Nd{\r\n        //shadow the js\r\n        let start = ret_f32(start);\r\n        let end = ret_f32(end);\r\n        let len = ret_f32(len) as usize;\r\n        Nd {\r\n            array:Array::linspace(start,end,len).into_dyn()\r\n        }\r\n    }\r\n\r\n    pub fn zeros(dims: &js_sys::Array)-> Nd {\r\n        let dim_vec = make_arr_usize(dims);\r\n        let ixdyn = IxDyn(&dim_vec);\r\n        Nd {\r\n            array: Array::zeros(ixdyn)\r\n        }\r\n    }\r\n    #[wasm_bindgen(constructor)]\r\n    pub fn make(arr_arg: &js_sys::Array) -> Nd {\r\n        // simple test\r\n        let str_arr = String::from(arr_arg.to_string()); //both coversions required due to the JsString used first\r\n        let mut vec_str: Vec<_> = str_arr.split(\",\").collect();\r\n        let filler = vec_str.remove(0).parse::<f32>().unwrap();\r\n        let vec_dim: Vec<usize> = vec_str\r\n            .into_iter()\r\n            .map(|x| x.parse::<usize>().unwrap())\r\n            .collect();\r\n        let mut temp_arr = ArrayD::<f32>::zeros(IxDyn(&vec_dim));\r\n        // todo explore whether the from_elem alt is faster than zero/fill method\r\n        temp_arr.fill(filler);\r\n        Nd { array: temp_arr }\r\n    }\r\n\r\n    // would like to integrate random, but that is also a new crate to bring in\r\n    //pub fn random(dims: &js_sys::Array,range:&js_sys::Array) -> Nd {\r\n    //    let dim_vec = make_arr_usize(dims);\r\n    //    // !! investigatewhy the second for each is nec\r\n    //    log(&format!(\"{:?}\",dim_vec));\r\n    //    let ixdyn = IxDyn(&dim_vec);\r\n    //    log(&format!(\"{:?}\",ixdyn));\r\n    //    let range_vec = make_arr_f32(range);\r\n    //    log(&format!(\"{:?}\",range_vec));\r\n    //    //let range_ob = Uniform::new(range_vec[0] as i32,range_vec[1]as i32);\r\n    //    let range_ob = Uniform::from(0..100);\r\n    //    log(&format!(\"{:?}\",range_ob));\r\n    //    let a =  Array::random(ixdyn,range_ob) ;\r\n    //    log(&format!(\"{:?}\",a));\r\n    //        Nd {\r\n    //            array:a.into_dyn()\r\n    //        }\r\n    //    }\r\n\r\n    // operator section\r\n    //  -note these functions are functional and don't modify their arguments\r\n    pub fn add(&self, other: &Nd) -> Nd {\r\n        let _temp_self = self.array.clone();\r\n        let _temp_other = other.array.clone();\r\n        Nd {\r\n            array: _temp_self + _temp_other,\r\n        }\r\n    }\r\n    pub fn subtract(&self,other:&Nd) -> Nd {\r\n        Nd{\r\n            array: self.array.clone() - other.array.clone(),\r\n        }\r\n    }\r\n    pub fn dot(&self, other: &Nd) -> Nd {\r\n        // !! double check that this dot works with non 2d matrices\r\n        let _temp_self = self.array.clone();\r\n        let _temp_other = other.array.clone();\r\n        let _temp_self_dottable = _temp_self.into_dimensionality::<Ix2>().unwrap();\r\n        let _temp_other_dottable = _temp_other.into_dimensionality::<Ix2>().unwrap();\r\n        Nd {\r\n            array: _temp_self_dottable.dot(&_temp_other_dottable).into_dyn(),\r\n        }\r\n    }\r\n    //not finished implementing\r\n    //pub fn exp(& self,n :JsValue) -> Nd {\r\n    //    let n = js_sys::Number::new(&n).value_of() as usize;\r\n    //    let mut lhs = self.array.clone();\r\n    //    for _ in 0..n {\r\n    //        lhs = lhs.dot(self.array);\r\n    //    }\r\n    //    Nd{\r\n    //        array:lhs\r\n    //    }\r\n\r\n    //}\r\n    // this is the element wise power, not matrix exponentiation\r\n    pub fn e_pow(&self,n: JsValue) -> Nd {\r\n        // use the map in place on ndarray\r\n        let n = js_sys::Number::new(&n).value_of() as i32;\r\n        // !!  look into the inplace version, this seems like it might be too slow\r\n        let powered = self.array.mapv(|a| a.powi(n));\r\n        Nd{\r\n            array: powered\r\n        }\r\n    }\r\n    pub fn sqrt(&mut self) -> Nd {\r\n        Nd {\r\n            array:self.array.mapv(f32::sqrt)\r\n        }\r\n    }\r\n    \r\n    //manipulation code\r\n    // numpy and other sci comp packages inplace transpose mutation\r\n    pub fn transpose(&mut self){\r\n        let trans = self.array.t().to_owned(); // !! beware of the jturner to_owned issue, only remove this comment when layout specs of to_owned are understood\r\n        self.array = trans;\r\n    }\r\n\r\n    pub fn concatenate(&self,&other:Nd,axis:JsValue) -> Nd {\r\n        let axis_uint = js_sys::Number::new(&n).value_of() as usize;\r\n        Nd {\r\n            array:stack(Axis(axis_uint),[&self.array.view(),&other.array.view()]).unwrap()\r\n        }\r\n    }\r\n\r\n    pub fn get_slice_rust(&self, ind: JsValue) -> Self {\r\n        //ind is a string which will contain the unpackable indexing structure\r\n        //create a vector kind of thing from it, and rework following for iterating over the comma\r\n        //separated entries\r\n        let ind_string = ind.as_string().unwrap();\r\n        let ind_vector = ind_string.split(',').collect::<Vec<&str>>();\r\n        log(&format!(\"{:?}\", ind_vector)[..]);\r\n        let mut val_vec: Vec<SliceOrIndex> = vec![];\r\n        for ind_str in ind_vector.iter() {\r\n            // single integer index specified\r\n            if let Ok(num) = ind_str.parse::<u32>() {\r\n                val_vec.push(SliceOrIndex::Index(num as isize));\r\n            } else {\r\n                // maybe extend this to the 2:5:1 syntax for indexing\r\n                let pair = ind_str\r\n                    .split(':')\r\n                    .map(|e| e.parse::<u32>())\r\n                    .collect::<Vec<Result<u32, std::num::ParseIntError>>>();\r\n                //make into slice for destructuring matching\r\n                match pair.as_slice() {\r\n                    //num: syntax\r\n                    [Ok(num), _] => {\r\n                        val_vec.push(SliceOrIndex::Slice {\r\n                            start: *num as isize,\r\n                            end: None,\r\n                            step: 1_isize,\r\n                        });\r\n                    }//num:num syntax\r\n                    [Ok(num1), Ok(num2)] => {\r\n                        val_vec.push(SliceOrIndex::Slice {\r\n                            start: *num1 as isize,\r\n                            end: Some(*num2 as isize),\r\n                            step: 1_isize,\r\n                        });\r\n                    }// :num syntax\r\n                    [_, Ok(num)] => {\r\n                        val_vec.push(SliceOrIndex::Slice {\r\n                            start: 0_isize,\r\n                            end: Some(*num as isize),\r\n                            step: 1_isize,\r\n                        });\r\n                    }\r\n                    _ => panic!(),\r\n                }\r\n            }\r\n        }\r\n        log(&format!(\"{:?}\", val_vec)[..]);\r\n        // should have val_vec created by this point\r\n        // !! slicing creates an array view, which might not be accepted for ND creation\r\n        //      if so, look up how to create new ndarray from view\r\n        let nd_slice_ob = ndarray::SliceInfo::<_, IxDyn>::new(val_vec).unwrap();\r\n        Nd {\r\n            array: self.array.slice(nd_slice_ob.as_ref()).to_owned(),\r\n        }\r\n    }\r\n    pub fn get(&self, ind: &js_sys::Array) -> f32 {\r\n        let rust_ind = make_arr_usize(ind);\r\n        self.array[&rust_ind[..]]\r\n    }\r\n    pub fn set(&mut self, ind: &js_sys::Array, val: f32) {\r\n        let rust_ind = make_arr_usize(ind);\r\n        self.array[&rust_ind[..]] = val;\r\n    }\r\n    pub fn show(&self) -> String {\r\n        format!(\"{:?}\", self.array)\r\n    }\r\n}\r\n\r\nfn make_arr_f32(arr:&js_sys::Array)-> Vec<f32> {\r\n    let mut v = vec![];\r\n    arr.for_each(&mut |x,_,_| v.push(js_sys::Number::new(&x).value_of() as f32));\r\n    v\r\n}\r\n\r\nfn make_arr_f64(arr:&js_sys::Array)-> Vec<f64> {\r\n    let mut v = vec![];\r\n    arr.for_each(&mut |x,_,_| v.push(js_sys::Number::new(&x).value_of()));\r\n    v\r\n}\r\n\r\nfn make_arr_usize(arr: &js_sys::Array) -> Vec<usize> {\r\n    let mut dim_vec = vec![];\r\n    arr.for_each(&mut |x, _, _| dim_vec.push(x.as_f64().unwrap() as usize));\r\n    dim_vec\r\n}\r\n```\r\nCargo.toml\r\n```\r\n[package]\r\nname = \"wasm-ndarray\"\r\nversion = \"0.1.4\"\r\nauthors = [\"Your Name \"]\r\n\r\n[lib]\r\ncrate-type = [\"cdylib\", \"rlib\"]\r\n\r\n[features]\r\ndefault = [\"console_error_panic_hook\"]\r\n\r\n[dependencies]\r\nfailure = \"0.1.3\"\r\nfailure_derive = \"0.1.3\"\r\ncfg-if = \"0.1.2\"\r\nndarray = \"0.12.0\"\r\nnalgebra = \"0.16\"\r\nrand = {git = \"https://github.com/rust-random/rand\",features=[\"wasm-bindgen\"]}\r\nndarray-rand = \"0.8.0\"\r\njs-sys = \"0.3.2\"\r\nwasm-bindgen = \"0.2\"\r\n\r\n# The `console_error_panic_hook` crate provides better debugging of panics by\r\n# logging them with `console.error`. This is great for development, but requires\r\n# all the `std::fmt` and `std::panicking` infrastructure, so isn't great for\r\n# code size when deploying.\r\nconsole_error_panic_hook = { version = \"0.1.1\", optional = true }\r\n\r\n# `wee_alloc` is a tiny allocator for wasm that is only ~1K in code size\r\n# compared to the default allocator's ~10K. It is slower than the default\r\n# allocator, however.\r\n#\r\n# Unfortunately, `wee_alloc` requires nightly Rust when targeting wasm for now.\r\nwee_alloc = { version = \"0.4.2\", optional = true }\r\n\r\n[dev-dependencies]\r\nwasm-bindgen-test = \"0.2\"\r\n\r\n[profile.release]\r\n# Tell `rustc` to optimize for small code size.\r\nopt-level = \"s\"\r\n```\r\ntriggers error report\r\n```\r\n\r\n  \r\n  [1/9] Checking `rustc` version...\r\n  [2/9] Checking crate configuration...\r\n  [3/9] Adding WASM target...\r\n  info: component 'rust-std' for target 'wasm32-unknown-unknown' is up to date\r\n  [4/9] Compiling to WASM...\r\n     Compiling wasm-ndarray v0.1.4 (~/Documents/mozilla_projects/parallel_gsoc/wasm_pack/wasm-ndarray)\r\n  error[E0425]: cannot find value `n` in this scope\r\n  \r\n  warning: unused `#[macro_use]` import\r\n   --> src/lib.rs:7:13\r\n    |\r\n  7 | #[macro_use(array)]\r\n    |             ^^^^^\r\n    |\r\n    = note: #[warn(unused_imports)] on by default\r\n  \r\n  warning: unused `#[macro_use]` import\r\n    --> src/lib.rs:17:1\r\n     |\r\n  17 | #[macro_use]\r\n     | ^^^^^^^^^^^^\r\n  \r\n  warning: unused import: `failure::Error`\r\n    --> src/lib.rs:22:5\r\n     |\r\n  22 | use failure::Error;\r\n     |     ^^^^^^^^^^^^^^\r\n  \r\n  warning: unused imports: `Dim`, `Ix`\r\n    --> src/lib.rs:26:34\r\n     |\r\n  26 | use ndarray::{stack,Axis,ArrayD, Dim, Ix, Ix2, IxDyn};\r\n     |                                  ^^^  ^^\r\n  \r\n  warning: unused import: `thread_rng`\r\n    --> src/lib.rs:27:12\r\n     |\r\n  27 | use rand::{thread_rng,Rng};\r\n     |            ^^^^^^^^^^\r\n  \r\n  warning: unused imports: `Distribution`, `Uniform`\r\n    --> src/lib.rs:28:27\r\n     |\r\n  28 | use rand::distributions::{Uniform,Distribution};\r\n     |                           ^^^^^^^ ^^^^^^^^^^^^\r\n  \r\n  warning: unused import: `ndarray_rand::RandomExt`\r\n    --> src/lib.rs:29:5\r\n     |\r\n  29 | use ndarray_rand::RandomExt;\r\n     |     ^^^^^^^^^^^^^^^^^^^^^^^\r\n  \r\n  thread 'main' panicked at 'byte index 1 is out of bounds of ``', libcore/str/mod.rs:2094:9\r\n  note: Run with `RUST_BACKTRACE=1` for a backtrace.\r\n  error: aborting due to previous error\r\n  \r\n  For more information about this error, try `rustc --explain E0425`.\r\n  \r\n  error: internal compiler error: unexpected panic\r\n  \r\n  note: the compiler unexpectedly panicked. this is a bug.\r\n  \r\n  note: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n  \r\n  note: rustc 1.32.0-nightly (6b9b97bd9 2018-11-15) running on x86_64-unknown-linux-gnu\r\n  \r\n  note: compiler flags: -C opt-level=s --crate-type cdylib --crate-type rlib\r\n  \r\n  note: some of the compiler flags provided by cargo are hidden\r\n  \r\n  error: Could not compile `wasm-ndarray`.\r\n  \r\n| To learn more, run the command again with --verbose.\r\nCompiling your crate to WebAssembly\r\nCaused by: Process exited with exit code: 101: `cargo build` did not exit successfully.\r\n\r\nstdout:\r\n\r\nstderr:\r\n\r\n   Compiling wasm-ndarray v0.1.4 (~/Documents/mozilla_projects/parallel_gsoc/wasm_pack/wasm-ndarray)\r\nerror[E0425]: cannot find value `n` in this scope\r\n\r\nwarning: unused `#[macro_use]` import\r\n --> src/lib.rs:7:13\r\n  |\r\n7 | #[macro_use(array)]\r\n  |             ^^^^^\r\n  |\r\n  = note: #[warn(unused_imports)] on by default\r\n\r\nwarning: unused `#[macro_use]` import\r\n  --> src/lib.rs:17:1\r\n   |\r\n17 | #[macro_use]\r\n   | ^^^^^^^^^^^^\r\n\r\nwarning: unused import: `failure::Error`\r\n  --> src/lib.rs:22:5\r\n   |\r\n22 | use failure::Error;\r\n   |     ^^^^^^^^^^^^^^\r\n\r\nwarning: unused imports: `Dim`, `Ix`\r\n  --> src/lib.rs:26:34\r\n   |\r\n26 | use ndarray::{stack,Axis,ArrayD, Dim, Ix, Ix2, IxDyn};\r\n   |                                  ^^^  ^^\r\n\r\nwarning: unused import: `thread_rng`\r\n  --> src/lib.rs:27:12\r\n   |\r\n27 | use rand::{thread_rng,Rng};\r\n   |            ^^^^^^^^^^\r\n\r\nwarning: unused imports: `Distribution`, `Uniform`\r\n  --> src/lib.rs:28:27\r\n   |\r\n28 | use rand::distributions::{Uniform,Distribution};\r\n   |                           ^^^^^^^ ^^^^^^^^^^^^\r\n\r\nwarning: unused import: `ndarray_rand::RandomExt`\r\n  --> src/lib.rs:29:5\r\n   |\r\n29 | use ndarray_rand::RandomExt;\r\n   |     ^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nthread 'main' panicked at 'byte index 1 is out of bounds of ``', libcore/str/mod.rs:2094:9\r\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\r\nerror: aborting due to previous error\r\n\r\nFor more information about this error, try `rustc --explain E0425`.\r\n\r\nerror: internal compiler error: unexpected panic\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.32.0-nightly (6b9b97bd9 2018-11-15) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C opt-level=s --crate-type cdylib --crate-type rlib\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nerror: Could not compile `wasm-ndarray`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```\r\nBest of luck!", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/56086/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/56086/timeline", "performed_via_github_app": null, "state_reason": null}