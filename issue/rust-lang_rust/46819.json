{"url": "https://api.github.com/repos/rust-lang/rust/issues/46819", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/46819/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/46819/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/46819/events", "html_url": "https://github.com/rust-lang/rust/issues/46819", "id": 282965128, "node_id": "MDU6SXNzdWUyODI5NjUxMjg=", "number": 46819, "title": "Implement shipping a per-target LLVM backend", "user": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 67766349, "node_id": "MDU6TGFiZWw2Nzc2NjM0OQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/E-mentor", "name": "E-mentor", "color": "02E10C", "default": false, "description": "Call for participation: This issue has a mentor. Use RustcContributor::new on Zulip for discussion."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2017-12-18T17:47:05Z", "updated_at": "2018-01-29T07:50:39Z", "closed_at": "2018-01-29T07:50:39Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "LLVM is quite a flexible compiler with a huge number of targets, but sometimes targets require custom versions or forks of LLVM. Up to now we've got two primary example of this:\r\n\r\n* Emscripten uses a [fork of LLVM](https://github.com/kripken/emscripten-fastcomp) which has a custom backend that emits asm.js through its tooling.\r\n* iOS may [have restrictions](https://github.com/rust-lang/rust/issues/35968) which require it to ship bitcode, and as a result will probably require a particular version of LLVM.\r\n\r\nWhile each of these targets may have a lot more going on with it in terms of future plans and whatnot, it suffices to say that for the near future (6mo -1y) it seems like Emscripten in particular won't be moving away from its LLVM fork and we'd like to keep its functionality. This desire to keep Emscripten results in a tension with [upgrading LLVM on our end](https://github.com/rust-lang/rust/issues/43370) as we can't do so until Emscripten does so.\r\n\r\nAs a result, let's ship multiple copies of LLVM!\r\n\r\n## General idea\r\n\r\nThe overall idea for this issue is to allow each target to optionally have a custom LLVM backend. We would then be compiling LLVM multiple times, once per necessary, and shipping multiple copies of LLVM to users. At compile time the compiler would select which version of LLVM is appropriate, dynamically load it, and then use it to compile and generate code.\r\n\r\nThis means that our build system will need to prepare itself for building multiple copies of LLVM. By default developers probably won't be building multiple copies of LLVM, but the bots on Travis/AppVeyor would all be compiling multiple copies when making dist builds.\r\n\r\nThe current thinking is that `rustc_driver`-the-crate will no longer depend on `rustc_trans`. Instead `rustc_trans` will be compiled as usual except it will *also* expose a C interface. The driver will then dynamically select the right trans backend, open it up, and use the C API to register hooks and whatnot.\r\n\r\n## Compiler changes\r\n\r\nI believe the first thing that'll need to be changed is how we build the compiler, specifically with how `librustc_trans` is loaded. I've been told that the `rustc_trans` crate is very close to only exposing basically a C API, and this would require us to complete that work. So the first task for this issue would be to work with the compiler team to ensure that the `rustc_trans` crate has a C API and the `rustc_driver` crate only uses this C API.\r\n\r\nOnce that's been done the dependency between `librust_driver` and `librustc_trans` can be broken. Instead we'll be doing something like:\r\n\r\n* Remove `rustc_trans` from `librustc_driver/Cargo.toml`\r\n* Change `librustc_llvm` to compile only as an rlib, not as both an rlib and a dylib.\r\n* Add a new step to rustbuild in [compile.rs](https://github.com/rust-lang/rust/blob/master/src/bootstrap/compile.rs) called `RustcTrans`\r\n* Implement `RustcTrans` similar to the step called `Rustc`, but this step will compile just the `librustc_trans` target\r\n* Implement `RustcTransLink` similar to `RustcLink`, except it'll link just the one `rustc_trans` dylib into the sysroot in a specific location (detailed below)\r\n* Augment the `Assemble` step to require `RustcTransLink` in addition to `RustcLink`\r\n\r\nThe sysroot (on unix) currently looks like:\r\n\r\n```\r\nbin/\r\n  rustc\r\n  rustdoc\r\nlib/\r\n  librustc_driver-xxx.so\r\n  librustc_trans-xxx.so\r\n  librustc_...so\r\n  rustlib/\r\n    $target/\r\n      lib/\r\n        libstd.rlib\r\n        libcore.rlib\r\n```\r\n\r\nI think what we'll want to move to is something that looks like:\r\n\r\n```\r\nbin/\r\n  rustc\r\n  rustdoc\r\nlib/\r\n  librustc_driver-xxx.so\r\n  librustc_...so\r\n  rustlib/\r\n    backends/\r\n      librustc_trans-standard.so\r\n      librustc_trans-emscripten.so\r\n      librustc_trans-ios.so\r\n    $target/\r\n      lib/\r\n        libstd.rlib\r\n        libcore.rlib\r\n```\r\n\r\nSpecifically the `librustc_trans.so` dynamic library no longer lives in `lib`. Instead multiple copies of it will live in `lib/rustlib/backends`. The `RustcTransLink` step is what will assemble the `backends` folder. Initially we'll just have the `standard` dynamic library sitting inside there.\r\n\r\nOnce this is done the driver needs to be modified when loading `rustc_trans` the crate. At *runtime* the driver will determine the target and look at an optional field in the custom target spec. This'll default to `None` which say sto load the \"standard\" backend, and if it's `Some` rustc will instead look for a different backend. For now we'll add this later though.\r\n\r\nOk so at this point, hopefully, rustc_driver is now loading librustc_trans through a dynamic library at runtime and we're ready for the next step!\r\n\r\n## Changes to rustbuild\r\n\r\nNext up we need to get a second version of LLVM compiling. For now we'll stick to the motivational use case for this, Emscripten. First thing to do is to add a config option to `config.toml.example`, let's say something like:\r\n\r\n```\r\n[llvm]\r\n# Configures multiple separately compiled backends to get created. This is \r\n# used in Rust for the Emscripten target primarily right now which uses a\r\n# fork of LLVM. This key is empty by default (only one LLVM backend is compiled)\r\n# but it can be an array of strings, where currently the only accepted string is\r\n# \"emscripten\"\r\n#separately-compiled-backends = []\r\n```\r\n\r\nWe'll then modify the `Assemble` step to check this config option. For each configured backend we'll execute `RustcTransLink` appropriately (adding a new option for the LLVM backend we'd like to create) and plumb that option all the way down to the `Llvm` target which will get modified appropriately.\r\n\r\nOnce this is done you should be able to configure via `config.toml` that you'd like to have an emscripten backend and when `./x.py build` is executed it'll compile LLVM/librustc_trans twice into two separate directories.\r\n\r\nIn order to ensure that `librustc_trans` builds are cached appropriately this *may* want to also add features to the `rustc_trans` crate which get toggled depending on the LLVM backend, but this can be played around with when implementing.\r\n\r\nNow at this point we've got multiple LLVM compilations, so let's put some polishing touches on things!\r\n\r\n## Distribution changes\r\n\r\nWe'll want to change the `rustc` component package to include the `backends` folder that we're creating. This will involve changing the `Rustc` step in `dist.rs`, and when you run `./x.py dist` the `rustc` packages created should all have the `librustc_trans` dylib inside them at the `backends` location. \r\n\r\nEventually we'll also want to enable the multiple llvm backends by default when the configured release channel is *not* `dev` and the `DEPLOY` env var is set to 1. This can be done most likely in `src/ci/run.sh` by passing a new option.\r\n\r\nFinally what we'll want to do is add a second submodule. We'll want, for example, a `src/llvm-emscripten` submodule. This won't actually get checked out on most builds, but for the dist builds on the bots we'll make sure to update the submodule and run with it.\r\n\r\n---\r\n\r\nAnd... I think that may be it? I'm sure I'll need to fill in a lot of cracks along the way but I'm more than willing to help mentor this issue! If you're interested in implementing this please just let me know!\r\n\r\n\r\n\r\n  ", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/46819/reactions", "total_count": 11, "+1": 11, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/46819/timeline", "performed_via_github_app": null, "state_reason": "completed"}