{"url": "https://api.github.com/repos/rust-lang/rust/issues/44799", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/44799/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/44799/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/44799/events", "html_url": "https://github.com/rust-lang/rust/issues/44799", "id": 260048312, "node_id": "MDU6SXNzdWUyNjAwNDgzMTI=", "number": 44799, "title": "It's not possible to have a recursive interaction with C glue without dynamic dispatch", "user": {"login": "uzytkownik", "id": 5706, "node_id": "MDQ6VXNlcjU3MDY=", "avatar_url": "https://avatars.githubusercontent.com/u/5706?v=4", "gravatar_id": "", "url": "https://api.github.com/users/uzytkownik", "html_url": "https://github.com/uzytkownik", "followers_url": "https://api.github.com/users/uzytkownik/followers", "following_url": "https://api.github.com/users/uzytkownik/following{/other_user}", "gists_url": "https://api.github.com/users/uzytkownik/gists{/gist_id}", "starred_url": "https://api.github.com/users/uzytkownik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/uzytkownik/subscriptions", "organizations_url": "https://api.github.com/users/uzytkownik/orgs", "repos_url": "https://api.github.com/users/uzytkownik/repos", "events_url": "https://api.github.com/users/uzytkownik/events{/privacy}", "received_events_url": "https://api.github.com/users/uzytkownik/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-09-24T00:42:31Z", "updated_at": "2017-09-24T15:01:14Z", "closed_at": "2017-09-24T15:01:14Z", "author_association": "NONE", "active_lock_reason": null, "body": "I tried to avoid double dynamic dispatch when writing binding to C++ library. I tried to write following code:\r\n\r\n    cpp!{{\r\n        #include <library.h>\r\n        extern void __rust_foo_foo(void *hnd, char *str);\r\n        class Foo : Base {\r\n            void *hnd;\r\n            Foo(void *hnd) : hdn(hnd) {}\r\n            void foo(StringArray &strarr) { // Overload of a method\r\n                String string;\r\n                for (int i = 0; StringArray.Has(i, &string); i++) {\r\n                    __rust_foo_foo(hnd, string.Text());\r\n                }\r\n            }\r\n        }\r\n    }}\r\n    \r\n    #[no_mangle]\r\n    pub extern fn __rust_foo_foo(vec: &mut std::vec::Vec<*mut u8>, chr: *mut u8) {\r\n        vec.push_back(chr);\r\n    }\r\n\r\n    pub fn run_foo() -> std::vec::Vec<*mut u8> {\r\n        let mut vec = std::vec::Vec::new();\r\n        {\r\n            let vec_ref = &mut vec;\r\n            cpp!([vec_ref as \"void *\"] -> {\r\n                Foo foo(vec_ref);\r\n                foo.do_something(); // calls foo internally\r\n            });\r\n        }\r\n        vec\r\n    }\r\n\r\nUnfortunately it results in undefined references to `__rust_foo_foo` (despite it being an exported object as shown by nm) if I try to link binding to executable. This has a number of drowbacks with regard to siplicity/performance.\r\n\r\n    cpp!{{\r\n        #include <library.h>\r\n        typedef void (*__rust_foo_foo)(void *hnd, char *str);\r\n        class Foo : Base {\r\n            void *hnd;\r\n            __rust_foo_foo func;\r\n            Foo(void *hnd, __rust_foo_foo func) : hdn(hnd) {}\r\n            void foo(char *str) { // Overload of a method\r\n                String string;\r\n                for (int i = 0; StringArray.Has(i, &string); i++) {\r\n                    __rust_foo_foo(hnd, string.Text());\r\n                }\r\n            }\r\n        }\r\n    }}\r\n    \r\n    #[no_mangle]\r\n    extern fn __rust_foo_foo(vec: &mut std::vec::Vec<*mut u8>, chr: *mut u8) {\r\n        vec.push_back(chr);\r\n    }\r\n    \r\n    pub fn run_foo() -> std::vec::Vec<*mut u8> {\r\n        let mut vec = std::vec::Vec::new();\r\n        {\r\n            let vec_ref = &mut vec;\r\n            let func = __rust_foo_foo;\r\n            cpp!([vec_ref as \"void *\", func as \"__rust_foo_foo\"] -> {\r\n                Foo foo(vec_ref, func);\r\n                foo.do_something(); // calls foo internally\r\n            });\r\n        }\r\n        vec\r\n    }", "closed_by": {"login": "uzytkownik", "id": 5706, "node_id": "MDQ6VXNlcjU3MDY=", "avatar_url": "https://avatars.githubusercontent.com/u/5706?v=4", "gravatar_id": "", "url": "https://api.github.com/users/uzytkownik", "html_url": "https://github.com/uzytkownik", "followers_url": "https://api.github.com/users/uzytkownik/followers", "following_url": "https://api.github.com/users/uzytkownik/following{/other_user}", "gists_url": "https://api.github.com/users/uzytkownik/gists{/gist_id}", "starred_url": "https://api.github.com/users/uzytkownik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/uzytkownik/subscriptions", "organizations_url": "https://api.github.com/users/uzytkownik/orgs", "repos_url": "https://api.github.com/users/uzytkownik/repos", "events_url": "https://api.github.com/users/uzytkownik/events{/privacy}", "received_events_url": "https://api.github.com/users/uzytkownik/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/44799/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/44799/timeline", "performed_via_github_app": null, "state_reason": "completed"}