{"url": "https://api.github.com/repos/rust-lang/rust/issues/30003", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/30003/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/30003/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/30003/events", "html_url": "https://github.com/rust-lang/rust/issues/30003", "id": 118407946, "node_id": "MDU6SXNzdWUxMTg0MDc5NDY=", "number": 30003, "title": "thread_local macro stability precludes safe async signal handling", "user": {"login": "mahkoh", "id": 1882250, "node_id": "MDQ6VXNlcjE4ODIyNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1882250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mahkoh", "html_url": "https://github.com/mahkoh", "followers_url": "https://api.github.com/users/mahkoh/followers", "following_url": "https://api.github.com/users/mahkoh/following{/other_user}", "gists_url": "https://api.github.com/users/mahkoh/gists{/gist_id}", "starred_url": "https://api.github.com/users/mahkoh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mahkoh/subscriptions", "organizations_url": "https://api.github.com/users/mahkoh/orgs", "repos_url": "https://api.github.com/users/mahkoh/repos", "events_url": "https://api.github.com/users/mahkoh/events{/privacy}", "received_events_url": "https://api.github.com/users/mahkoh/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 60329014, "node_id": "MDU6TGFiZWw2MDMyOTAxNA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/P-low", "name": "P-low", "color": "eb6420", "default": false, "description": "Low priority"}, {"id": 178802147, "node_id": "MDU6TGFiZWwxNzg4MDIxNDc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-needs-decision", "name": "I-needs-decision", "color": "e11d21", "default": false, "description": "Issues in need of decision."}, {"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2015-11-23T15:41:52Z", "updated_at": "2019-03-12T17:19:35Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "The `thread_local!` macro accepts arbitrary (non-Sync) objects to be put into thread local storage. It is not hard to construct a case where this causes signal handlers to observe inconsistent state:\n\n``` rust\nextern {\n    fn signal(num: i32, handler: extern fn(i32)) -> extern fn(i32);\n}\n\nuse std::cell::{RefCell};\n\n/// First and second value always the same.\nthread_local!(static X: RefCell<(usize,usize)> = RefCell::new((0,0)));\n\nextern fn handler(_: i32) {\n    X.with(|x| {\n        let x = x.borrow();\n        println!(\"{:?}\", *x);\n    });\n}\n\nfn main() {\n    unsafe { signal(2, handler); }\n    X.with(|x| {\n        let mut x = x.borrow_mut();\n        x.0 += 1;\n        // raise(2)\n        x.1 += 1;\n    });\n}\n```\n\n`RefCell` is not signal safe. A mutable borrow will not mark the `RefCell` as being borrowed in this case. This can be simulated as follows:\n- Compile with `-O -C lto`\n- In gdb, step to the instruction that stores the second value.\n- `signal 2`\n\nExpected result: panic/abort/segfault or similar. Actual result: `(1, 0)` is printed.\n\nFixing RefCell by adding a memory barrier does not fix the problem since there might be many other non-Sync types that were not written with signal handling in mind and that use unsafe constructs. For correctness, TLS would have to be restricted to types that are async safe via a new marker trait. With such a trait, signal handling would be safe by default in all rust code and all signals handlers could call arbitrary rust functions (as long as said functions don't call non-rust code which might not be async safe.)\n\n---\n\nThis concerns me because adding a signal handler is a safe operation in lrs and all `#[thread_local]` objects that require mutation are wrapped in a single threaded mutex implementation with interior mutability. And if it is decided that async signal handling is never safe in rust, then `#[thread_local]` might be stabilized and might also start to accept arbitrary objects which would practically force me to create a full compiler fork for the sake of safety. The current implementation in lrs is already unsafe because the single threaded mutex implementation has to be marked `Sync` to be placed in a `#[thread_local]`. For correctness, there would have to be the above mentioned marker trait that restricts what can be put in a `#[thread_local]`.\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/30003/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/30003/timeline", "performed_via_github_app": null, "state_reason": null}