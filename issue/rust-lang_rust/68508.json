{"url": "https://api.github.com/repos/rust-lang/rust/issues/68508", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/68508/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/68508/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/68508/events", "html_url": "https://github.com/rust-lang/rust/issues/68508", "id": 554644769, "node_id": "MDU6SXNzdWU1NTQ2NDQ3Njk=", "number": 68508, "title": "Exponential Type Blowup when wrapping function", "user": {"login": "gakonst", "id": 17802178, "node_id": "MDQ6VXNlcjE3ODAyMTc4", "avatar_url": "https://avatars.githubusercontent.com/u/17802178?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gakonst", "html_url": "https://github.com/gakonst", "followers_url": "https://api.github.com/users/gakonst/followers", "following_url": "https://api.github.com/users/gakonst/following{/other_user}", "gists_url": "https://api.github.com/users/gakonst/gists{/gist_id}", "starred_url": "https://api.github.com/users/gakonst/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gakonst/subscriptions", "organizations_url": "https://api.github.com/users/gakonst/orgs", "repos_url": "https://api.github.com/users/gakonst/repos", "events_url": "https://api.github.com/users/gakonst/events{/privacy}", "received_events_url": "https://api.github.com/users/gakonst/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 64037154, "node_id": "MDU6TGFiZWw2NDAzNzE1NA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-compiletime", "name": "I-compiletime", "color": "e11d21", "default": false, "description": "Problems and improvements with respect to compile times."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-01-24T10:05:41Z", "updated_at": "2021-01-22T23:54:29Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "I am implementing a service architecture, where each service can be thought of as middleware. It makes sense to define complex services which need to manage their own complex state as their own structs and implement my `Service` trait for each one. However, for simple operations, e.g. logging or manipulating some argument in place, it makes more sense to have a wrapper service which receives the previous service's \"request\", does whatever it needs to do, and passes it on. The wrapper service also implements the `Service` trait. \r\n\r\nThe problem here is that there is an exponential type length complexity blowup when passing in the function. \r\n\r\nProbably related: https://github.com/rust-lang/rust/issues/54540, note how there's no closure in my example\r\n\r\nMVCE below: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=17d88bb1e552b2cc285ced44777e726b\r\n\r\n(complex services: BaseService / MyService, stateless services: logger, doubler)\r\n\r\n```rust\r\n// The objective is to be able to wrap existing services with simple functions, without\r\n// having to define a new service each time we want to perform a very minimal action\r\n// on the data flow. We could define a LoggerService and a DoublingService, but that\r\n// is _a lot_ of boilerplate.\r\nfn main() {\r\n    let s = BaseService;\r\n    // We can create as many new services as we want,\r\n    // the type length increases linearly, as expected\r\n    let s = MyService::new(s);\r\n    let s = MyService::new(s);\r\n    // The type length of `s` doubles\r\n    let s = WrappedService::new(s, stateless_log);\r\n    // if you try to wrap a few times, your code hits the type length limit\r\n    let s = WrappedService::new(s, stateless_double);\r\n    let s = WrappedService::new(s, stateless_double);\r\n    let s = WrappedService::new(s, stateless_double);\r\n    let s = WrappedService::new(s, stateless_double);\r\n    let s = WrappedService::new(s, stateless_double);\r\n    let s = WrappedService::new(s, stateless_double);\r\n    let s = WrappedService::new(s, stateless_double);\r\n    let s = WrappedService::new(s, stateless_double);\r\n    let s = WrappedService::new(s, stateless_double)\r\n}\r\n\r\ntype Request = u64;\r\ntype MyResult = Result<(), ()>;\r\n\r\npub trait Service {\r\n    fn handle(&mut self, request: Request) -> MyResult;\r\n}\r\n\r\n// A simple service which we we use as our base\r\n#[derive(Clone)]\r\npub struct BaseService;\r\nimpl Service for BaseService {\r\n    fn handle(&mut self, _request: Request) -> MyResult {\r\n        Ok(())\r\n    }\r\n}\r\n\r\n// A service that takes another service (and could have more state)\r\n#[derive(Clone)]\r\npub struct MyService<O> {\r\n    next: O,\r\n}\r\nimpl<O> MyService<O>\r\nwhere\r\n    O: Service + Clone + Send,\r\n{\r\n    pub fn new(next: O) -> Self {\r\n        MyService { next }\r\n    }\r\n}\r\nimpl<O> Service for MyService<O>\r\nwhere\r\n    O: Service + Clone + Send,\r\n{\r\n    fn handle(&mut self, request: Request) -> MyResult {\r\n        self.next.handle(request)\r\n    }\r\n}\r\n\r\n/// =========== Stateless Services =========\r\n\r\nuse std::sync::Arc;\r\n\r\n// We have to store the service onion so far, and the function we want to inject\r\n#[derive(Clone)]\r\npub struct WrappedService<F, I> {\r\n    f: F,\r\n    inner: Arc<I>,\r\n}\r\nimpl<F, S> WrappedService<F, S>\r\nwhere\r\n    F: Fn(S, Request) -> MyResult,\r\n    S: Service + Clone,\r\n{\r\n    pub fn new(inner: S, f: F) -> Self {\r\n        WrappedService {\r\n            f,\r\n            inner: Arc::new(inner),\r\n        }\r\n    }\r\n}\r\nimpl<F, S> Service for WrappedService<F, S>\r\nwhere\r\n    F: Fn(S, Request) -> MyResult,\r\n    S: Service + Clone,\r\n{\r\n    fn handle(&mut self, request: Request) -> MyResult {\r\n        (self.f)((*self.inner).clone(), request)\r\n    }\r\n}\r\n\r\n// Is there a way to convert these to a service, without having to go through a lot of boilerplate?\r\npub fn stateless_log<O: Service + Clone>(mut next: O, request: Request) -> MyResult {\r\n    println!(\"sending request\");\r\n    let result = next.handle(request);\r\n    println!(\"got result\");\r\n    result\r\n}\r\n\r\npub fn stateless_double<O: Service + Clone>(mut next: O, request: Request) -> MyResult {\r\n    let request = 2 * request;\r\n    let result = next.handle(request);\r\n    result\r\n}\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=17d88bb1e552b2cc285ced44777e726b))", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/68508/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/68508/timeline", "performed_via_github_app": null, "state_reason": null}