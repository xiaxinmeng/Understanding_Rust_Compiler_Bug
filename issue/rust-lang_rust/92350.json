{"url": "https://api.github.com/repos/rust-lang/rust/issues/92350", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/92350/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/92350/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/92350/events", "html_url": "https://github.com/rust-lang/rust/issues/92350", "id": 1089869356, "node_id": "I_kwDOAAsO6M5A9hYs", "number": 92350, "title": "Vec of 2D or 3D arrays generates very slow code", "user": {"login": "leonardo-m", "id": 22328461, "node_id": "MDQ6VXNlcjIyMzI4NDYx", "avatar_url": "https://avatars.githubusercontent.com/u/22328461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/leonardo-m", "html_url": "https://github.com/leonardo-m", "followers_url": "https://api.github.com/users/leonardo-m/followers", "following_url": "https://api.github.com/users/leonardo-m/following{/other_user}", "gists_url": "https://api.github.com/users/leonardo-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/leonardo-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/leonardo-m/subscriptions", "organizations_url": "https://api.github.com/users/leonardo-m/orgs", "repos_url": "https://api.github.com/users/leonardo-m/repos", "events_url": "https://api.github.com/users/leonardo-m/events{/privacy}", "received_events_url": "https://api.github.com/users/leonardo-m/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}, {"id": 3425147156, "node_id": "LA_kwDOAAsO6M7MJ5kU", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-array", "name": "A-array", "color": "f7e101", "default": false, "description": "Area: [T; N]"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2021-12-28T12:42:12Z", "updated_at": "2023-03-07T05:29:41Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "Using fixed sized arrays is very useful because the back-end knows their length, and this allows some significant optimizations.\r\n\r\nBut allocating large ones is a problem, here I'm using a solution that's generally good enough (it's more efficient than using the \"box\" keyword), based on vec! + into_boxed_slice + try_into. This solution breaks when you have 2D+ arrays:\r\n\r\n```rust\r\nconst L1: usize = 100_000;\r\nconst L2: usize = 200;\r\n\r\npub struct Foo {\r\n    m1: Box<[[u32; 50]; L1]>,\r\n    t1: Box<[[[f64; L2]; L1]; 2]>,\r\n}\r\n\r\nimpl Foo {\r\n    pub fn new() -> Self {\r\n        Self {\r\n            m1: vec![[0; 50]; L1].into_boxed_slice().try_into().unwrap(),\r\n            t1: vec![[[0.0; L2]; L1]; 2].into_boxed_slice().try_into().unwrap(),\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nGives the unreasonable and very slow asm with copies:\r\n\r\n```asm\r\nexample::Foo::new:\r\n        push    r15\r\n        push    r14\r\n        push    r12\r\n        push    rbx\r\n        mov     eax, 160000008\r\n        call    __rust_probestack\r\n        sub     rsp, rax\r\n        mov     edi, 20000000\r\n        mov     esi, 4\r\n        call    qword ptr [rip + __rust_alloc@GOTPCREL]\r\n        test    rax, rax\r\n        je      .LBB0_7\r\n        mov     r14, rax\r\n        xor     eax, eax\r\n        vxorps  xmm0, xmm0, xmm0\r\n.LBB0_2:\r\n        vmovups ymmword ptr [r14 + rax + 160], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 128], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 96], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 64], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 32], ymm0\r\n        vmovups ymmword ptr [r14 + rax], ymm0\r\n        mov     qword ptr [r14 + rax + 192], 0\r\n        vmovups ymmword ptr [r14 + rax + 200], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 232], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 264], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 296], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 328], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 360], ymm0\r\n        mov     qword ptr [r14 + rax + 392], 0\r\n        vmovups ymmword ptr [r14 + rax + 400], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 432], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 464], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 496], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 528], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 560], ymm0\r\n        mov     qword ptr [r14 + rax + 592], 0\r\n        vmovups ymmword ptr [r14 + rax + 760], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 728], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 696], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 664], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 632], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 600], ymm0\r\n        mov     qword ptr [r14 + rax + 792], 0\r\n        vmovups ymmword ptr [r14 + rax + 800], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 832], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 864], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 896], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 928], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 960], ymm0\r\n        mov     qword ptr [r14 + rax + 992], 0\r\n        vmovups ymmword ptr [r14 + rax + 1000], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 1032], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 1064], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 1096], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 1128], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 1160], ymm0\r\n        mov     qword ptr [r14 + rax + 1192], 0\r\n        vmovups ymmword ptr [r14 + rax + 1360], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 1328], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 1296], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 1264], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 1232], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 1200], ymm0\r\n        mov     qword ptr [r14 + rax + 1392], 0\r\n        vmovups ymmword ptr [r14 + rax + 1560], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 1528], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 1496], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 1464], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 1432], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 1400], ymm0\r\n        mov     qword ptr [r14 + rax + 1592], 0\r\n        vmovups ymmword ptr [r14 + rax + 1760], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 1728], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 1696], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 1664], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 1632], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 1600], ymm0\r\n        mov     qword ptr [r14 + rax + 1792], 0\r\n        add     rax, 1800\r\n        cmp     rax, 19999800\r\n        jne     .LBB0_2\r\n        vxorps  xmm0, xmm0, xmm0\r\n        vmovups ymmword ptr [r14 + rax + 160], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 128], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 96], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 64], ymm0\r\n        vmovups ymmword ptr [r14 + rax + 32], ymm0\r\n        vmovups ymmword ptr [r14 + rax], ymm0\r\n        mov     qword ptr [r14 + rax + 192], 0\r\n        lea     rbx, [rsp + 8]\r\n        lea     r15, [rsp + 160000008]\r\n        mov     r12, qword ptr [rip + memset@GOTPCREL]\r\n.LBB0_4:\r\n        mov     edx, 1600\r\n        mov     rdi, rbx\r\n        xor     esi, esi\r\n        vzeroupper\r\n        call    r12\r\n        lea     rdi, [rbx + 1600]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 3200]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 4800]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 6400]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 8000]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 9600]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 11200]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 12800]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 14400]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 16000]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 17600]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 19200]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 20800]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 22400]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 24000]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 25600]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 27200]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 28800]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 30400]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 32000]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 33600]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 35200]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 36800]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 38400]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 40000]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 41600]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 43200]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 44800]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 46400]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 48000]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 49600]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 51200]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 52800]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 54400]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 56000]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 57600]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 59200]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 60800]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        lea     rdi, [rbx + 62400]\r\n        mov     edx, 1600\r\n        xor     esi, esi\r\n        call    r12\r\n        add     rbx, 64000\r\n        cmp     rbx, r15\r\n        jne     .LBB0_4\r\n        mov     edi, 320000000\r\n        mov     esi, 8\r\n        call    qword ptr [rip + __rust_alloc@GOTPCREL]\r\n        test    rax, rax\r\n        je      .LBB0_8\r\n        mov     rbx, rax\r\n        lea     r15, [rsp + 8]\r\n        mov     r12, qword ptr [rip + memcpy@GOTPCREL]\r\n        mov     edx, 160000000\r\n        mov     rdi, rax\r\n        mov     rsi, r15\r\n        call    r12\r\n        mov     rdi, rbx\r\n        add     rdi, 160000000\r\n        mov     edx, 160000000\r\n        mov     rsi, r15\r\n        call    r12\r\n        mov     rax, r14\r\n        mov     rdx, rbx\r\n        add     rsp, 160000008\r\n        pop     rbx\r\n        pop     r12\r\n        pop     r14\r\n        pop     r15\r\n        ret\r\n.LBB0_7:\r\n        mov     edi, 20000000\r\n        mov     esi, 4\r\n        call    qword ptr [rip + alloc::alloc::handle_alloc_error@GOTPCREL]\r\n        ud2\r\n.LBB0_8:\r\n        mov     edi, 320000000\r\n        mov     esi, 8\r\n        call    qword ptr [rip + alloc::alloc::handle_alloc_error@GOTPCREL]\r\n        ud2\r\n```\r\n\r\nI can regain some efficiency creating 1D boxed arrays and then transmuting them to 2D/3D, but it's error prone (even if I use a macro for this):\r\n\r\n\r\n```rust\r\nconst L1: usize = 100_000;\r\nconst L2: usize = 200;\r\n\r\npub struct Foo {\r\n    m1: Box<[[u32; 50]; L1]>,\r\n    t1: Box<[[[f64; L2]; L1]; 2]>,\r\n}\r\n\r\nimpl Foo {\r\n    pub fn new() -> Self {\r\n        use std::mem::transmute;\r\n\r\n        let m1_data: Box<[u32; 50 * L1]> = vec![0; 50 * L1].into_boxed_slice().try_into().unwrap();\r\n        let t1_data: Box<[f64; L2 * L1 * 2]> = vec![0.0; L2 * L1 * 2].into_boxed_slice().try_into().unwrap();\r\n\r\n        Self {\r\n            m1: unsafe { transmute(m1_data) },\r\n            t1: unsafe { transmute(t1_data) },\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nIt gives the reasonable asm:\r\n\r\n```asm\r\nexample::Foo::new:\r\n        push    rbx\r\n        mov     edi, 20000000\r\n        mov     esi, 4\r\n        call    qword ptr [rip + __rust_alloc_zeroed@GOTPCREL]\r\n        test    rax, rax\r\n        je      .LBB0_3\r\n        mov     rbx, rax\r\n        mov     edi, 320000000\r\n        mov     esi, 8\r\n        call    qword ptr [rip + __rust_alloc_zeroed@GOTPCREL]\r\n        test    rax, rax\r\n        je      .LBB0_4\r\n        mov     rdx, rax\r\n        mov     rax, rbx\r\n        pop     rbx\r\n        ret\r\n.LBB0_3:\r\n        mov     edi, 20000000\r\n        mov     esi, 4\r\n        call    qword ptr [rip + alloc::alloc::handle_alloc_error@GOTPCREL]\r\n        ud2\r\n.LBB0_4:\r\n        mov     edi, 320000000\r\n        mov     esi, 8\r\n        call    qword ptr [rip + alloc::alloc::handle_alloc_error@GOTPCREL]\r\n        ud2\r\n```", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/92350/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/92350/timeline", "performed_via_github_app": null, "state_reason": null}