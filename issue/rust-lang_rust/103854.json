{"url": "https://api.github.com/repos/rust-lang/rust/issues/103854", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/103854/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/103854/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/103854/events", "html_url": "https://github.com/rust-lang/rust/issues/103854", "id": 1432221254, "node_id": "I_kwDOAAsO6M5VXfZG", "number": 103854, "title": "Do we need Send bounds to stabilize async_fn_in_trait?", "user": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 1049510487, "node_id": "MDU6TGFiZWwxMDQ5NTEwNDg3", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-async-await", "name": "A-async-await", "color": "f7e101", "default": false, "description": "Area: Async & Await"}, {"id": 1259721467, "node_id": "MDU6TGFiZWwxMjU5NzIxNDY3", "url": "https://api.github.com/repos/rust-lang/rust/labels/AsyncAwait-Triaged", "name": "AsyncAwait-Triaged", "color": "d4c5f9", "default": false, "description": "Async-await issues that have been triaged during a working group meeting."}, {"id": 2352122097, "node_id": "MDU6TGFiZWwyMzUyMTIyMDk3", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-discussion", "name": "C-discussion", "color": "f5f1fd", "default": false, "description": "Category: Discussion or questions that doesn't represent real issues."}, {"id": 3618128266, "node_id": "LA_kwDOAAsO6M7XqEGK", "url": "https://api.github.com/repos/rust-lang/rust/labels/F-async_fn_in_trait", "name": "F-async_fn_in_trait", "color": "f9c0cc", "default": false, "description": "Static async fn in traits"}, {"id": 3793096324, "node_id": "LA_kwDOAAsO6M7iFg6E", "url": "https://api.github.com/repos/rust-lang/rust/labels/WG-async", "name": "WG-async", "color": "c2e0c6", "default": false, "description": ""}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 53, "created_at": "2022-11-01T23:06:07Z", "updated_at": "2023-05-15T23:53:45Z", "closed_at": "2023-05-15T23:53:45Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "## Problem: Spawning from generics\r\n\r\nGiven an ordinary trait with `async fn`:\r\n\r\n```rust\r\n#![feature(async_fn_in_trait)]\r\n\r\ntrait AsyncIterator {\r\n    type Item;\r\n    async fn next(&mut self) -> Option<Self::Item>;\r\n}\r\n```\r\n\r\nIt is not currently possible to write a function like this:\r\n\r\n```rust\r\nfn spawn_print_all<I: AsyncIterator + Send + 'static>(mut count: I)\r\nwhere\r\n    I::Item: Display,\r\n{\r\n    tokio::spawn(async move {\r\n        //       ^^^^^^^^^^^^\r\n        // ERROR: future cannot be sent between threads safely\r\n        while let Some(x) = count.next().await {\r\n            //              ^^^^^^^^^^^^\r\n            // note: future is not `Send` as it awaits another future which is not `Send`\r\n            println!(\"{x}\");\r\n        }\r\n    });\r\n}\r\n```\r\n[playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=04726fa1708bc790001d0b4b03d23ea1)\r\n\r\nSpeaking more generally, it is impossible to write a function that\r\n\r\n* Is generic over this trait\r\n* Spawns a task on a work-stealing executor\r\n* Calls an `async fn` of the trait from the spawned task\r\n\r\nThe problem is that the compiler does not know the concrete type of the future returned by `next`, or whether that future is `Send`.\r\n\r\n## Near-term mitigations\r\n\r\n### Spawning from concrete contexts\r\n\r\nHowever, it is perfectly fine to spawn in a non-generic function that _calls_ our generic function, e.g.\r\n\r\n```rust\r\nasync fn print_all<I: AsyncIterator>(mut count: I)\r\nwhere\r\n    I::Item: Display,\r\n{\r\n    while let Some(x) = count.next().await {\r\n        println!(\"{x}\");\r\n    }\r\n}\r\n\r\nasync fn do_something() {\r\n    let iter = Countdown::new(10);\r\n    executor::spawn(print_all(iter)); // <-- This works!\r\n}\r\n```\r\n[playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=fc6b1ef2060ac8a79079ad8d59822727)\r\n\r\nThis works because spawn occurs in a context where\r\n* We know the concrete type of our iterator, `Countdown`\r\n* We know the future returned by `Countdown::next` is `Send`\r\n* We therefore know that the future returned by our call to `print_all::<Countdown>` and passed to `spawn` is `Send`\r\n\r\nMaking this work smoothly depends on auto trait leakage.\r\n\r\n### Adding bounds in the trait\r\n\r\nAnother workaround is to write a special version of our trait that is designed to be used in generic contexts:\r\n\r\n```rust\r\n#![feature(return_position_impl_trait_in_trait)]\r\n\r\ntrait SpawnAsyncIterator: Send + 'static {\r\n    type Item;\r\n    fn next(&mut self) -> impl Future<Output = Option<Self::Item>> + Send + '_;\r\n}\r\n```\r\n[playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=525075cf5cda73650aa43eee0a0b7213)\r\n\r\nHere we've added the `Send` bound by using return_position_impl_trait_in_trait syntax. We've also added `Self: Send + 'static` for convenience.\r\n\r\nFor a trait only used in a specific application, you could add these bounds directly to that trait instead of creating two versions of the same trait.\r\n\r\nFor cases where you do need two versions of the trait, your options are\r\n\r\n* If you control both versions of the trait, write a blanket impl that forwards from `SpawnAsyncIterator` to `AsyncIterator` ([playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=ce84e8b20440c95d5a261889466e7ce8))\r\n* Write a macro that expands to a delegating impl for a given type\r\n* Write impls by hand for each type, depending on what you need\r\n\r\n### Only work-stealing executors\r\n\r\nEven though work-stealing executors are the most commonly used in Rust, there are a sizable number of users that use single-threaded or thread-per-core executors. They won't run into this problem, at least with `Send`.\r\n\r\n## Aside: Possible solutions\r\n\r\nSolutions are **outside the scope of this issue**, but they would probably involve the ability to write something like \r\n\r\n```rust\r\nfn spawn_print_all<I: AsyncIterator<next(): Send> + Send + 'static>(mut count: I)\r\n//                                 ^^^^^^^^^^^^^^ new (syntax TBD)\r\nwhere\r\n    I::Item: Display,\r\n{\r\n    ...\r\n}\r\n```\r\n\r\nFurther discussion about the syntax or shape of this solution should happen on the [async-fundamentals-initiative](https://github.com/rust-lang/async-fundamentals-initiative/issues) repo, or a future RFC.\r\n\r\n## Questions\r\n\r\n* How often do people see this problem in practice?\r\n* Is this problem, despite the mitigations, bad enough that we should hold back stabilization of `async_fn_in_trait` until we have a solution?\r\n\r\nIf you've had a chance to give `async_fn_in_trait` a spin, or can relay other relevant first-hand knowledge, please comment below with your experience.", "closed_by": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/103854/reactions", "total_count": 16, "+1": 12, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 4}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/103854/timeline", "performed_via_github_app": null, "state_reason": "completed"}