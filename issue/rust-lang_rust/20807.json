{"url": "https://api.github.com/repos/rust-lang/rust/issues/20807", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/20807/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/20807/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/20807/events", "html_url": "https://github.com/rust-lang/rust/issues/20807", "id": 53883591, "node_id": "MDU6SXNzdWU1Mzg4MzU5MQ==", "number": 20807, "title": "JoinGuard::join returning an Err is **really** unsafe", "user": {"login": "tomaka", "id": 1412254, "node_id": "MDQ6VXNlcjE0MTIyNTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1412254?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomaka", "html_url": "https://github.com/tomaka", "followers_url": "https://api.github.com/users/tomaka/followers", "following_url": "https://api.github.com/users/tomaka/following{/other_user}", "gists_url": "https://api.github.com/users/tomaka/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomaka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomaka/subscriptions", "organizations_url": "https://api.github.com/users/tomaka/orgs", "repos_url": "https://api.github.com/users/tomaka/repos", "events_url": "https://api.github.com/users/tomaka/events{/privacy}", "received_events_url": "https://api.github.com/users/tomaka/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 14, "created_at": "2015-01-09T16:08:53Z", "updated_at": "2015-02-18T12:51:52Z", "closed_at": "2015-02-18T12:51:52Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Exception safety is a very well-known problem in C++.\n\nConsider this:\n\n``` cpp\nstruct Foo {\n    int* ptr;\n};\n\nvoid modify(Foo& value) {\n    delete foo.ptr;\n    foo.ptr = new int;\n}\n\nvoid error_proof_modify(Foo& value) {\n    try {\n        modify(value);\n    } catch(...) {\n        cerr << \"Error, but let's continue!\";\n    }\n}\n```\n\nIf the call to `new` throws an exception, the error gets caught and the execution continue. However the `Foo` object is now in an invalid state with its pointer pointing to memory that has been free'd.\n\nBefore #20615 and before the change in `Send` this is not possible in Rust, because when a thread panics all objects that are local to this thread are no longer accessible. It's also the reason why mutexes are poisoned in case of a panic.\n\nBut now that it's possible to send local variables to other threads, and ignore when this other thread panics, situations like this can totally happen.\n\nLet's take this code for example:\n\n``` rust\npub struct Foo {\n    val1: int,\n    val2: int,\n    val3: int,\n    calculation_result: int,    // must always be equal to val1+val2+val3\n}\n\nimpl Foo {\n    pub fn set_val1(&mut self, value: int) {\n        self.val1 = value;\n        self.update_calculation();\n    }\n    pub fn set_val2(&mut self, value: int) {\n        self.val2 = value;\n        self.update_calculation();\n    }\n    pub fn set_val3(&mut self, value: int) {\n        self.val3 = value;\n        self.update_calculation();\n    }\n\n    fn update_calculation(&mut self) {\n        if self.val1 == 127 { panic!(\"for the sake of this example, we panic\") };\n        self.calculation_result = self.val1 + self.val2 + self.val3;\n    }\n}\n```\n\nLooks safe, right?\n\nBut what if you use that \"ignore panics\" trick?\n\n``` rust\nlet mut foo: Foo = ...;  // whatever\n\nThread::scoped(|| {\n    foo.set_val1(127);\n}).join();   // ignoring the panic\n\nuse_foo(&foo);   // continue using `foo`\n```\n\nAt the end of this code, you have a `Foo` object in an invalid state because `calculation_result` is not equal to `val1+val2+val3` as it should be. Continuing to use the Foo object in this invalid state could lead to weird and hard to debug results (depending on the rest of the code).\n\nWith the latest reforms in thread, library writer really have to take exception safety (or \"panic safety\") into account by avoiding the kind of code written above. You may argue that it's just the fault of the person who wrote the `Foo` struct. The problem is that exception safety is **hard**. Too hard to get right.\n\nIn my opinion, `JoinGuard::join` should just panic if the underlying thread panicked, without leaving the choice to the user. The only situation in which a `try_join` function (or another name) is safe is for `JoinGuard<'static>`.\n\ncc @aturon\n", "closed_by": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/20807/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/20807/timeline", "performed_via_github_app": null, "state_reason": "completed"}