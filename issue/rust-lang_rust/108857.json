{"url": "https://api.github.com/repos/rust-lang/rust/issues/108857", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/108857/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/108857/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/108857/events", "html_url": "https://github.com/rust-lang/rust/issues/108857", "id": 1613230018, "node_id": "I_kwDOAAsO6M5gJ-_C", "number": 108857, "title": "rustc will emit code for const-eval false branches", "user": {"login": "Voultapher", "id": 6864584, "node_id": "MDQ6VXNlcjY4NjQ1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6864584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Voultapher", "html_url": "https://github.com/Voultapher", "followers_url": "https://api.github.com/users/Voultapher/followers", "following_url": "https://api.github.com/users/Voultapher/following{/other_user}", "gists_url": "https://api.github.com/users/Voultapher/gists{/gist_id}", "starred_url": "https://api.github.com/users/Voultapher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Voultapher/subscriptions", "organizations_url": "https://api.github.com/users/Voultapher/orgs", "repos_url": "https://api.github.com/users/Voultapher/repos", "events_url": "https://api.github.com/users/Voultapher/events{/privacy}", "received_events_url": "https://api.github.com/users/Voultapher/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2023-03-07T11:13:03Z", "updated_at": "2023-03-07T11:13:03Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I tried this code:\r\n\r\n```rust\r\n#![feature(inline_const)]\r\n\r\nuse std::mem;\r\n\r\nconst fn is_elegible<T>() -> bool {\r\n    mem::size_of::<T>() <= mem::size_of::<[u64; 4]>()\r\n}\r\n\r\nfn logic_a<T>(_v: &mut [T]) {\r\n    println!(\"{}\", std::any::type_name::<T>());\r\n}\r\n\r\nfn logic_b<T>(v: &mut [T]) {\r\n    use std::sync::atomic::{AtomicBool, Ordering};\r\n\r\n    static VAL: AtomicBool = AtomicBool::new(false);\r\n\r\n    if v.len() > 2 {\r\n        VAL.store(true, Ordering::Release);\r\n    }\r\n}\r\n\r\nfn do_some_logic<T>(v: &mut [T]) {\r\n    if const { is_elegible::<T>() } {\r\n        logic_a(v);\r\n    } else {\r\n        logic_b(v);\r\n    }\r\n}\r\n\r\npub fn main() {\r\n    do_some_logic(&mut [3, 5, 6]);\r\n\r\n    // struct BigThing([u64; 20]);\r\n    // do_some_logic(&mut [BigThing([0; 20])]);\r\n}\r\n```\r\n\r\nI expected to see this happen:\r\n\r\nLooking at the LLVM-IR and generated code, it generates code for `logic_b` despite `const { is_elegible::<T>() }` evaluating to `true`, which means only `logic_a` should be passed to the code-gen backend.\r\n\r\nInstead, this happened:\r\n\r\nBefore LLVM-IR or any other backend IR is generated if an expression is forced to be evaluated inline via an inline cost block, it must be evaluated and pruned.\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.69.0-nightly (5243ea5c2 2023-02-20)\r\nbinary: rustc\r\ncommit-hash: 5243ea5c29b136137c36bd773e5baa663790e097\r\ncommit-date: 2023-02-20\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.69.0-nightly\r\nLLVM version: 15.0.7\r\n```\r\n\r\nThis has been discussed before, and I was told the expected behavior is the current behavior https://internals.rust-lang.org/t/why-does-a-const-eval-not-taken-branch-still-generate-llvm-ir/18378/15 and it is for some cases but not reliably.\r\n\r\n### Motivation\r\n\r\nWhen building large complex abstractions such as sort implementations it can be valuable to limit certain code to specific types. There are other places in the standard library that also do such heuristics eg. https://github.com/rust-lang/rust/blob/e58621a4a30db1ae7fcc041e108042c1ce14d3bd/library/core/src/slice/rotate.rs#L74\r\nThe conversation seemed to show no consensus whether `if const_fn()` should be const evaluated, but it using `if const { const_fn() }` seems to imply that we can rely on the condition being const evaluated. Without such a construct certain optimizations can't be done without sacrificing compile times, which is problematic eg. https://github.com/rust-lang/rust/pull/108662\r\n\r\nWhat I'd like to se would be consistent behavior or a new abstraction that provides that behavior if inline const expressions are deemed to be the wrong tool.\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/108857/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/108857/timeline", "performed_via_github_app": null, "state_reason": null}