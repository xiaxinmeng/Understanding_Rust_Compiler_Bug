{"url": "https://api.github.com/repos/rust-lang/rust/issues/59412", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/59412/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/59412/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/59412/events", "html_url": "https://github.com/rust-lang/rust/issues/59412", "id": 424920401, "node_id": "MDU6SXNzdWU0MjQ5MjA0MDE=", "number": 59412, "title": "[eRFC] Include call graph information in LLVM IR", "user": {"login": "japaric", "id": 5018213, "node_id": "MDQ6VXNlcjUwMTgyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5018213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/japaric", "html_url": "https://github.com/japaric", "followers_url": "https://api.github.com/users/japaric/followers", "following_url": "https://api.github.com/users/japaric/following{/other_user}", "gists_url": "https://api.github.com/users/japaric/gists{/gist_id}", "starred_url": "https://api.github.com/users/japaric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/japaric/subscriptions", "organizations_url": "https://api.github.com/users/japaric/orgs", "repos_url": "https://api.github.com/users/japaric/repos", "events_url": "https://api.github.com/users/japaric/events{/privacy}", "received_events_url": "https://api.github.com/users/japaric/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 880020421, "node_id": "MDU6TGFiZWw4ODAwMjA0MjE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/WG-embedded", "name": "WG-embedded", "color": "c2e0c6", "default": false, "description": "Of interest to the embedded Working Group"}, {"id": 1206122880, "node_id": "MDU6TGFiZWwxMjA2MTIyODgw", "url": "https://api.github.com/repos/rust-lang/rust/labels/needs-fcp", "name": "needs-fcp", "color": "fceb9f", "default": false, "description": "This change is insta-stable, so needs a completed FCP to proceed."}, {"id": 5226909857, "node_id": "LA_kwDOAAsO6M8AAAABN4xQoQ", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-cli", "name": "A-cli", "color": "f7e101", "default": false, "description": "Area: Command line interface to the compiler."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 17, "created_at": "2019-03-25T14:05:32Z", "updated_at": "2023-03-05T01:37:30Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "## Summary\r\n\r\nAdd an experimental compiler feature / flag to add call graph information, in\r\nthe  form of LLVM metadata, to the LLVM IR (`.ll`) files produced by the\r\ncompiler.\r\n\r\n## Motivation\r\n\r\n(This section ended up being a bit long winded. The TL;DR is improving existing\r\nstack analysis usage tools.)\r\n\r\nStack usage analysis is a hard requirement for [certifying] safety critical\r\n(embedded) applications. This analysis is usually implemented as a static\r\nanalysis tool that computes the worst case stack usage of an application. The\r\ninformation provided by this tool is used in the certification process to\r\ndemonstrate that the application won't run into a stack overflow at runtime.\r\n\r\n[certifying]: https://www.absint.com/qualification/safety.htm\r\n\r\n[Several][a] [such][b] [tools][c] exist for C/C++ programs, mainly in commercial\r\nand closed source forms. A few months ago the Rust compiler gained a feature\r\nthat's a pre-requisite for implementing such tools in the Rust world: [`-Z\r\nemit-stack-sizes`]. This flag makes stack usage information about every Rust\r\nfunction available in the binary artifacts (object files) produced by the\r\ncompiler.\r\n\r\n[a]: https://www.absint.com/stackanalyzer/index.htm\r\n[b]: https://www.iar.com/support/tech-notes/general/stack-usage-and-stack-usage-control-files/\r\n[c]: https://www.adacore.com/gnatpro/toolsuite/gnatstack\r\n[`-Z emit-stack-sizes`]: https://doc.rust-lang.org/unstable-book/compiler-flags/emit-stack-sizes.html\r\n\r\nAnd just recently a tool that uses this flag and call graph analysis to perform\r\nwhole program stack usage analysis has been developed: [`cargo-call-stack`][]\r\n(*full disclaimer: I'm the author of said tool*). The tool does OK when dealing\r\nwith programs that only uses direct function calls but it's lacking (either\r\nover-pessimistic or flat out incorrect) when analyzing programs that contain\r\nindirect function calls, that is function pointer calls and/or dynamic\r\ndispatch.\r\n\r\n[`cargo-call-stack`]: https://github.com/japaric/cargo-call-stack\r\n\r\nCall graph analysis in the presence of indirect function calls is notoriously\r\nhard, but Rust strong typing makes the problem tractable -- in fact, dynamic\r\ndispatch is easier to reason about than function pointer calls. However, this\r\nlast part only holds true when Rust type information is available to the tool,\r\nwhich is not the case today.\r\n\r\nTo elaborate: it's' important that the call graph is extracted from\r\npost-LLVM-optimization output as that greatly reduces the chance of inserting\r\ninvalid edges. For example, what appears to be a function call at the (Rust)\r\nsource level (e.g. `let x = foo();`) may not actually exist in the final binary\r\ndue to inlining or dead code elimination. For this reason, Rust stack usage\r\nanalysis tools are limited to two sources of call graph information: the machine\r\ncode in the final executable and post-optimization LLVM IR (`rustc`'s\r\n`--emit=llvm-ir`). The former contains no type information and the latter\r\ncontains *LLVM* type information, not Rust type information.\r\n\r\n`cargo-call-stack` currently uses the type information available in the\r\nLLVM IR of a crate to reason about indirect function calls. However, LLVM type\r\ninformation is not as complete as Rust type information because the conversion\r\nis lossy. Consider the following Rust source code and corresponding LLVM IR.\r\n\r\n``` rust\r\n#[no_mangle] // shorter name\r\nstatic F: AtomicPtr<fn() -> u32> = AtomicPtr::new(foo as *mut _);\r\n\r\nfn main() {\r\n    if let Some(f) = unsafe { F.load(Ordering::Relaxed).as_ref() } {\r\n        f(); // function pointer call\r\n    }\r\n\r\n    // volatile load to preserve the return value of `bar`\r\n    unsafe {\r\n        core::ptr::read_volatile(&baz());\r\n    }\r\n}\r\n\r\n#[no_mangle]\r\nfn foo() -> u32 {\r\n    F.store(bar as *mut _, Ordering::Relaxed);\r\n\r\n    0\r\n}\r\n\r\n#[no_mangle]\r\nfn bar() -> u32 {\r\n    1\r\n}\r\n\r\n#[inline(never)]\r\n#[no_mangle]\r\nfn baz() -> i32 {\r\n    F.load(Ordering::Relaxed) as usize as i32\r\n}\r\n```\r\n\r\n``` llvm\r\ndefine void @main() unnamed_addr #3 !dbg !1240 {\r\nstart:\r\n  %_14 = alloca i32, align 4\r\n  %0 = load atomic i32, i32* bitcast (<{ i8*, [0 x i8] }>* @F to i32*) monotonic, align 4\r\n  %1 = icmp eq i32 %0, 0, !dbg !1251\r\n  br i1 %1, label %bb5, label %bb3, !dbg !1251\r\n\r\nbb3:                                              ; preds = %start\r\n  %2 = inttoptr i32 %0 to i32 ()**, !dbg !1252\r\n  %3 = load i32 ()*, i32 ()** %2, align 4, !dbg !1254, !nonnull !46\r\n  %4 = tail call i32 %3() #9, !dbg !1254\r\n  br label %bb5, !dbg !1255\r\n\r\n; ..\r\n}\r\n\r\n; Function Attrs: norecurse nounwind\r\ndefine internal i32 @foo() unnamed_addr #0 !dbg !1189 {\r\n; ..\r\n}\r\n\r\n; Function Attrs: norecurse nounwind readnone\r\ndefine internal i32 @bar() unnamed_addr #1 !dbg !1215 {\r\n; ..\r\n}\r\n\r\n; Function Attrs: noinline norecurse nounwind\r\ndefine internal fastcc i32 @baz() unnamed_addr #2 !dbg !1217 {\r\n; ..\r\n}\r\n```\r\n\r\nNote how in the LLVM IR output `foo`, `bar` and `baz` all have the same function\r\nsignature: `i32 ()`, which is the LLVM version of `fn() -> i32`. There are no\r\nunsigned integer types in LLVM IR so both Rust types, `i32` and `u32`, get\r\nconverted to `i32` in the LLVM IR.\r\n\r\nLine `%4 = ..` in the LLVM IR is the function pointer call. This too,\r\nincorrectly, indicates that a function pointer with signature `i32 ()` (`fn() ->\r\ni32`) is being invoked.\r\n\r\nThis lossy conversion leads `cargo-call-stack` to incorrectly add an edge\r\nbetween the node that represents the function pointer call and `baz`. See below:\r\n\r\n![fn-wrong](https://user-images.githubusercontent.com/5018213/54923442-8a4bc700-4f0a-11e9-848a-e920c9a9083c.png)\r\n\r\nIf the tool had access to call graph information from the compiler it would have\r\nproduced the following accurate call graph.\r\n\r\n![fn-right](https://user-images.githubusercontent.com/5018213/54923492-a5b6d200-4f0a-11e9-8a10-3ce5db19ddf4.png)\r\n\r\nThis eRFC proposes adding a feature to aid call graph and stack usage analysis.\r\n\r\n(For a more in depth explanation of how `cargo-call-stack` works please refer to\r\nthis blog post: https://blog.japaric.io/stack-analysis/)\r\n\r\n## Design\r\n\r\nWe propose that call graph information is added to the LLVM IR that `rustc`\r\nproduces in the form of [LLVM metadata] when the unstable `-Z call-metadata`\r\n`rustc` flag is used.\r\n\r\n[LLVM metadata]: https://llvm.org/docs/LangRef.html#metadata\r\n\r\n### Function pointer calls\r\n\r\nFunctions that are converted into function pointers in Rust source (e.g. `let x:\r\nfn() -> i32 = foo`) will get extra LLVM metadata in their definitions (IR:\r\n`define`). The metadata will have the form `!{!\"fn\", !\"fn() -> i32\"}`, where the\r\nsecond node represents the signature of the function. Likewise, function pointer\r\ncalls will get similar LLVM metadata at call site (IR: `call`/ `invoke`).\r\nRevisiting the previous example, the IR would change as shown below:\r\n\r\n``` llvm\r\ndefine void @main() unnamed_addr #3 !dbg !1240 {\r\n; ..\r\n  %4 = tail call i32 %3() #9, !dbg !1254, !rust !0\r\n; ..                                      ^^^^^^^^ (ADDED)\r\n}\r\n\r\n; Function Attrs: norecurse nounwind\r\ndefine internal i32 @foo() unnamed_addr #0 !dbg !1189 !rust !0 {\r\n; ..                                                  ^^^^^^^^ (ADDED)\r\n}\r\n\r\n; Function Attrs: norecurse nounwind readnone\r\ndefine internal i32 @bar() unnamed_addr #1 !dbg !1215 !rust !0 {\r\n; ..                                                  ^^^^^^^^ (ADDED)\r\n}\r\n\r\n; Function Attrs: noinline norecurse nounwind\r\ndefine internal fastcc i32 @baz() unnamed_addr #2 !dbg !1217 {\r\n; ..\r\n}\r\n\r\n; ..\r\n\r\n; (ADDED) at the bottom of the file\r\n!0 = !{!\"fn\", \"fn() -> i32\"}\r\n; ..\r\n```\r\n\r\nNote how `main` and `baz` didn't get the extra `!rust` metadata because they are\r\nnever converted into function pointers. Whereas both `foo` and `bar` got the\r\nsame metadata because they have the same signature and are converted into\r\nfunction pointers in the source code (lines `static F` and `F.store`).\r\n\r\nWhen tools parse this LLVM IR they will know that line `%4 = ..` can invoke\r\n`foo` or `bar` (`!rust !0`), but not `baz` or `main` because the latter two\r\ndon't have the same \"fn\" metadata.\r\n\r\nThis `-Z` flag only promises two things with respect to \"fn\" metadata:\r\n\r\n- Only functions that are converted (coerced) into function pointers in the\r\n  source code will get \"fn\" metadata -- note that this does *not* necessarily mean that\r\n  function will be called via a function pointer call\r\n\r\n- That the string node that comes after the `!\"fn\"` node will be *unique* for\r\n  each function type -- the flag does *not* make any promise about the contents\r\n  or syntax of this string node. (Having a stringified version of the function\r\n  signature in the LLVM IR would be nice to have but it's not required to\r\n  produce an accurate call graph.)\r\n\r\nAdding this kind of metadata doesn't affect LLVM optimization passes and more\r\nimportantly our previous experiments show that this custom metadata is not\r\nremoved by LLVM passes.\r\n\r\n### Trait objects\r\n\r\nThere's one more of bit of information we can encode in the metadata to make the\r\nanalysis less pessimistic: information about trait objects.\r\n\r\nConsider the following Rust source code and corresponding LLVM IR.\r\n\r\n``` rust\r\nstatic TO: Mutex<&'static (dyn Foo + Sync)> = Mutex::new(&Bar);\r\nstatic X: AtomicI32 = AtomicI32::new(0);\r\n\r\nfn main() {\r\n    (*TO.lock()).foo();\r\n\r\n    if X.load(Ordering::Relaxed).quux() {\r\n        // side effect to keep `quux`'s return value\r\n        unsafe { asm!(\"\" : : : \"memory\" : \"volatile\") }\r\n    }\r\n}\r\n\r\ntrait Foo {\r\n    fn foo(&self) -> bool {\r\n        false\r\n    }\r\n}\r\n\r\nstruct Bar;\r\n\r\nimpl Foo for Bar {}\r\n\r\nstruct Baz;\r\n\r\nimpl Foo for Baz {\r\n    fn foo(&self) -> bool {\r\n        true\r\n    }\r\n}\r\n\r\ntrait Quux {\r\n    fn quux(&self) -> bool;\r\n}\r\n\r\nimpl Quux for i32 {\r\n    #[inline(never)]\r\n    fn quux(&self) -> bool {\r\n        *TO.lock() = &Baz;\r\n\r\n        unsafe { core::ptr::read_volatile(self) > 0 }\r\n    }\r\n}\r\n```\r\n\r\n``` llvm\r\n; Function Attrs: noinline noreturn nounwind\r\ndefine void @main() unnamed_addr #2 !dbg !1418 {\r\n; ..\r\n  %8 = tail call zeroext i1 %7({}* nonnull align 1 %4) #8, !dbg !1437, !rust !0\r\n; ..                                                                   ^^^^^^^^\r\n}\r\n\r\n; app::Foo::foo\r\n; Function Attrs: norecurse nounwind readnone\r\ndefine internal zeroext i1 @_ZN3app3Foo3foo17h5a849e28d8bf9a2eE(\r\n  %Bar* noalias nocapture nonnull readonly align 1\r\n) unnamed_addr #0 !dbg !1224 !rust !1 {\r\n; ..                         ^^^^^^^^\r\n}\r\n\r\n; <app::Baz as app::Foo>::foo\r\n; Function Attrs: norecurse nounwind readnone\r\ndefine internal zeroext i1\r\n  @\"_ZN37_$LT$app..Baz$u20$as$u20$app..Foo$GT$3foo17h9e4a36340940b841E\"(\r\n    %Baz* noalias nocapture nonnull readonly align 1\r\n  ) unnamed_addr #0 !dbg !1236 !rust !2 {\r\n; ..                           ^^^^^^^^\r\n}\r\n\r\n; <i32 as app::Quux>::quux\r\n; Function Attrs: noinline norecurse nounwind\r\ndefine internal fastcc zeroext i1\r\n  @\"_ZN33_$LT$i32$u20$as$u20$app..Quux$GT$4quux17haf5232e76b46052fE\"(\r\n    i32* noalias readonly align 4 dereferenceable(4)\r\n  ) unnamed_addr #1 !dbg !1245 !rust !3 {\r\n; ..                           ^^^^^^^^\r\n}\r\n\r\n; ..\r\n\r\n!0 = \"fn(*mut ()) -> bool\"\r\n!1 = \"fn(&Bar) -> bool\"\r\n!2 = \"fn(&Baz) -> bool\"\r\n!3 = \"fn(&i32) -> bool\"\r\n; ..\r\n```\r\n\r\nIn this case we have dynamic dispatch, which shows up in the LLVM IR at line\r\n`%8` as a function pointer call where the signature of the function pointer is\r\n`i1 ({}*)`, which is more or less equivalent to Rust's `fn(*mut ()) -> bool` --\r\nthe `{}*` denotes an \"erased\" type.\r\n\r\nWith just the function signature metadata tools could at best assume that the\r\ndynamic dispatch could invoke `Bar.foo()`, `Baz.foo()` or `i32.quux()` resulting\r\nin the following, incorrect call graph.\r\n\r\n![trait-wrong](https://user-images.githubusercontent.com/5018213/54923627-ef072180-4f0a-11e9-9b63-4c07d30af267.png)\r\n\r\nThus, we also propose that the `-Z call-metadata` flag adds trait-method\r\ninformation to trait method implementations (IR: `define`) *of traits that are\r\nconverted into trait objects*, and to dynamic dispatch sites (IR: `call _ %_({}*\r\n_, ..)`) using the following metadata syntax: `!{!\"dyn\", !\"Foo\", !\"foo\"}`, where\r\nthe second node represents the trait and the third node represents the method\r\nbeing dispatched / defined.\r\n\r\nBuilding upon the previous example, here's how the \"dyn\" metadata would be\r\nemitted by the compiler:\r\n\r\n``` llvm\r\n; Function Attrs: noinline noreturn nounwind\r\ndefine void @main() unnamed_addr #2 !dbg !1418 {\r\n; ..\r\n  %8 = tail call zeroext i1 %7({}* nonnull align 1 %4) #8, !dbg !1437, !rust !0\r\n; ..\r\n}\r\n\r\n; app::Foo::foo\r\n; Function Attrs: norecurse nounwind readnone\r\ndefine internal zeroext i1 @_ZN3app3Foo3foo17h5a849e28d8bf9a2eE(\r\n  %Bar* noalias nocapture nonnull readonly align 1\r\n) unnamed_addr #0 !dbg !1224 !rust !0 {\r\n; ..                         ^^^^^^^^ (CHANGED)\r\n}\r\n\r\n; <app::Baz as app::Foo>::foo\r\n; Function Attrs: norecurse nounwind readnone\r\ndefine internal zeroext i1\r\n  @\"_ZN37_$LT$app..Baz$u20$as$u20$app..Foo$GT$3foo17h9e4a36340940b841E\"(\r\n    %Baz* noalias nocapture nonnull readonly align 1\r\n  ) unnamed_addr #0 !dbg !1236 !rust !0 {\r\n; ..                           ^^^^^^^^ (CHANGED)\r\n}\r\n\r\n; <i32 as app::Quux>::quux\r\n; Function Attrs: noinline norecurse nounwind\r\ndefine internal fastcc zeroext i1\r\n  @\"_ZN33_$LT$i32$u20$as$u20$app..Quux$GT$4quux17haf5232e76b46052fE\"(\r\n    i32* noalias readonly align 4 dereferenceable(4)\r\n  ) unnamed_addr #1 !dbg !1245          {\r\n; ..                           ^^^^^^^^ (REMOVED)\r\n}\r\n\r\n; ..\r\n\r\n!0 = !{!\"dyn\", !\"Foo\", !\"foo\"}\" ; CHANGED\r\n; ..\r\n```\r\n\r\nNote that `<i32 as Quux>::quux` loses its `!rust` metadata because there's no\r\n`dyn Quux` in the source code.\r\n\r\nWith trait-method information tools would be able to limit the candidates of\r\ndynamic dispatch to the actual implementations of the trait being dispatched.\r\nThus the call graph produced by the tools would become:\r\n\r\n![trait-right](https://user-images.githubusercontent.com/5018213/54923643-f5959900-4f0a-11e9-822a-9c99bdae87a6.png)\r\n\r\nLike \"fn\" metadata, \"dyn\" metadata only promises two things:\r\n\r\n- Only trait method implementations (including default implementations) of\r\n  traits *that appear as trait objects* (e.g. `&dyn Foo`, `Box<dyn Bar>`) in the\r\n  source code will get this kind of metadata\r\n\r\n- That the string nodes that come after the `!\"dyn\"` node will be *unique* for\r\n  each trait and method -- the flag does *not* make any promise about the\r\n  contents or syntax of these string nodes.\r\n\r\n#### Destructors\r\n\r\nCalling the destructor of a trait object (e.g. `Box<dyn Foo>`) can result in the\r\ndestructor of any `Foo` implementer being invoked. This information will also be\r\nencoded in the LLVM IR using \"drop\" metadata of the form: `!{!\"drop\", !\"Foo\"}`\r\nwhere the second node represents the trait.\r\n\r\nHere's an example of this kind of metadata:\r\n\r\n``` rust\r\ntrait Foo {\r\n    fn foo(&self) {}\r\n}\r\n\r\nstruct Bar;\r\n\r\nimpl Foo for Bar {}\r\n\r\nstruct Baz;\r\n\r\nimpl Foo for Baz {}\r\n\r\nstatic MAYBE: AtomicBool = AtomicBool::new(false);\r\n\r\nfn main() {\r\n    let mut x: Box<dyn Foo> = Box::new(Bar);\r\n\r\n    if MAYBE.load(Ordering::Relaxed) {\r\n        x = Box::new(Baz);\r\n    }\r\n\r\n    drop(x);\r\n}\r\n```\r\n\r\nUnoptimized LLVM IR:\r\n\r\n``` llvm\r\n; core::ptr::real_drop_in_place\r\ndefine internal void @_(%Baz* nonnull align 1) unnamed_addr #4 !rust !199 {\r\n  ; ..\r\n}\r\n\r\n; core::ptr::real_drop_in_place\r\ndefine internal void @_(%Bar* nonnull align 1) unnamed_addr #4 !rust !199 {\r\n  ; ..\r\n}\r\n\r\n; hello::main\r\ndefine internal void @() {\r\n  ; ..\r\n\r\n  ; `drop(x)`\r\n  invoke void @_ZN4core3ptr18real_drop_in_place17h258eb03c50ca2fcaE(..)\r\n\r\n  ; ..\r\n}\r\n\r\n; core::ptr::real_drop_in_place\r\ndefine internal void @_ZN4core3ptr18real_drop_in_place17h258eb03c50ca2fcaE(..) {\r\n  ; ..\r\n\r\n  ; calls destructor on the concrete type behind the trait object\r\n  invoke void %8({}* align 1 %3)\r\n          to label %bb3 unwind label %cleanup, !dbg !209, !rust !199\r\n\r\n  ; ..\r\n}\r\n\r\n!199 = !{!\"drop\", !\"Foo\"}\r\n```\r\n\r\nHere dropping `x` can result in `Bar`'s or `Baz`'s destructor being invoked (see `!199`).\r\n\r\n### Multiple metadata\r\n\r\nSome function definitions may get more than one different metadata kind or\r\ndifferent instances of the same kind. In that case we'll use a metadata tuple\r\n(e.g. `!{!1, !2}`) to group the different instances. An example:\r\n\r\n``` rust\r\ntrait Foo {\r\n    fn foo(&self) -> bool;\r\n}\r\n\r\ntrait Bar {\r\n    fn bar(&self) -> i32 {\r\n        0\r\n    }\r\n}\r\n\r\nstruct Baz;\r\n\r\nimpl Foo for Baz {\r\n    fn foo(&self) -> bool {\r\n        false\r\n    }\r\n}\r\n\r\nimpl Bar for Baz {}\r\n\r\nfn main() {\r\n    let x: &Foo = &Baz;\r\n    let y: &Bar = &Baz;\r\n\r\n    let z: fn(&Baz) -> bool = Baz::foo;\r\n}\r\n```\r\n\r\nUnoptimized LLVM IR:\r\n\r\n``` llvm\r\n; core::ptr::real_drop_in_place\r\ndefine internal void @_(%Baz* nonnull align 1) unnamed_addr #2 !rust !107 {\r\n  ; ..\r\n}\r\n\r\n; <hello::Baz as hello::Foo>::foo\r\ndefine internal zeroext i1 @_(%Baz* noalias nonnull readonly align 1) unnamed_addr #2 !rust !157 {\r\n  ; ..\r\n}\r\n\r\n!105 = !{!\"drop\", !\"Foo\"}\r\n!106 = !{!\"drop\", !\"Bar\"}\r\n!107 = !{!105, !106}\r\n; ..\r\n!155 = !{!\"dyn\", !\"Foo\", !\"foo\"}\r\n!156 = !{!\"fn\", !\"fn(&Baz) -> bool\"}\r\n!157 = !{!155, !156}\r\n```\r\n\r\n### Summary\r\n\r\nIn summary, these are the proposed changes:\r\n\r\n- Add an unstable `-Z call-metadata` flag\r\n\r\n- Using this flag adds extra LLVM metadata to the LLVM IR produced by `rustc`\r\n  (`--emit=llvm-ir`). Three kinds of metadata will be added:\r\n\r\n  - `!{!\"fn\", !\"fn() -> i32\"}` metadata will be added to the definitions of\r\n    functions (IR: `define`) *that are coerced into function pointers in the\r\n    source code* and to function pointer calls (IR: `call _ %_(..)`). The second\r\n    node is a string that uniquely identifies the signature (type) of the\r\n    function.\r\n\r\n  - `!{!\"dyn\", !\"Trait\", !\"method\"}` metadata will be added to the trait method\r\n    implementations (IR: `define`) of traits *that appear as trait objects in\r\n    the source code* and to dynamic dispatch sites (IR: `call _ %_({}* _, ..)`).\r\n    The second node is a string that uniquely identifies the trait and the third\r\n    node is a string that uniquely identifies the trait method.\r\n\r\n  - `!{!\"drop\", \"Trait\"}` metadata will be added to destructors (IR: `define`)\r\n    of types that implement traits *that appear as trait objects in the source\r\n    code* and to the invocations of trait object destructors. The second node is\r\n    a string that uniquely identifies the implemented trait / trait object.\r\n\r\n## Alternatives\r\n\r\nAn alternative would be to make type information available in the final binary\r\nartifact, that is in the executable, rather than in the LLVM IR. This would make\r\nthe feature harder to implement and *less* portable. Making the type information\r\navailable in, say, the ELF format would require designing a (binary) format\r\nto encode the information in a linker section plus non-trivial implementation\r\nwork. Making this feature available in other formats (Mach-O, WASM, etc.) would\r\nonly multiply the amount of required work, likely leading to this feature being\r\nimplemented for some formats but not others.\r\n\r\n## Drawbacks\r\n\r\nLLVM IR is tied to the LLVM backend; this makes the proposed feature hard, or\r\nmaybe even impossible, to port to other backends like cranelift. I don't think\r\nthis is much of an issue as this is an experimental feature; backend portability\r\ncan, and should, be revisited when we consider stabilizing this feature (if\r\never).\r\n\r\n---\r\n\r\nSince this is a (hopefully small) experimental compiler feature (along the lines\r\nof [`-Z emit-stack-sizes`][pr51946]) and not a language (semantics or syntax)\r\nchange I'm posting this in rust-lang/rust for FCP consideration. If this\r\nwarrants a formal RFC I'd be happy to repost this in rust-lang/rfcs.\r\n\r\n[pr51946]: https://github.com/rust-lang/rust/pull/51946\r\n\r\ncc @rust-lang/compiler @oli-obk ", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/59412/reactions", "total_count": 4, "+1": 4, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/59412/timeline", "performed_via_github_app": null, "state_reason": null}