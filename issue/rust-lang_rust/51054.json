{"url": "https://api.github.com/repos/rust-lang/rust/issues/51054", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/51054/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/51054/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/51054/events", "html_url": "https://github.com/rust-lang/rust/issues/51054", "id": 326344570, "node_id": "MDU6SXNzdWUzMjYzNDQ1NzA=", "number": 51054, "title": "SipHasher takes up lots of time in incremental builds", "user": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 64037154, "node_id": "MDU6TGFiZWw2NDAzNzE1NA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-compiletime", "name": "I-compiletime", "color": "e11d21", "default": false, "description": "Problems and improvements with respect to compile times."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 307747675, "node_id": "MDU6TGFiZWwzMDc3NDc2NzU=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-incr-comp", "name": "A-incr-comp", "color": "f7e101", "default": false, "description": "Area: Incremental compilation"}, {"id": 849077850, "node_id": "MDU6TGFiZWw4NDkwNzc4NTA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/WG-compiler-performance", "name": "WG-compiler-performance", "color": "c2e0c6", "default": false, "description": "Working group: Compiler Performance"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2018-05-25T00:47:19Z", "updated_at": "2021-12-06T21:17:12Z", "closed_at": "2021-12-06T21:17:11Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Here's Cachegrind data for `clap-rs` from rustc-benchmarks on a \"base incremental\" \"check\" build (i.e. the first incremental build):\r\n```\r\n--------------------------------------------------------------------------------\r\n            Ir\r\n--------------------------------------------------------------------------------\r\n39,792,587,805  PROGRAM TOTALS\r\n\r\n6,008,282,218  librustc_data_structures/sip128.rs:rustc_data_structures::sip128::SipHasher128::short_write\r\n1,655,965,059  libcore/num/mod.rs:rustc_data_structures::sip128::SipHasher128::short_write\r\n  319,188,771  libcore/cmp.rs:rustc_data_structures::sip128::SipHasher128::short_write\r\n```\r\nThat's over 20% of the instructions under `short_write`.\r\n\r\nHere are the annotations for the hot pieces of code in librustc_data_structures/sip128.rs.\r\n```\r\n          .  macro_rules! compress {\r\n          .      ($state:expr) => ({\r\n967,427,173          compress!($state.v0, $state.v1, $state.v2, $state.v3)\r\n          .      });\r\n          .      ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\r\n          .      ({\r\n          .          $v0 = $v0.wrapping_add($v1); $v1 = $v1.rotate_left(13); $v1 ^= $v0;\r\n          .          $v0 = $v0.rotate_left(32);\r\n          .          $v2 = $v2.wrapping_add($v3); $v3 = $v3.rotate_left(16); $v3 ^= $v2;\r\n          .          $v0 = $v0.wrapping_add($v3); $v3 = $v3.rotate_left(21); $v3 ^= $v0;\r\n          .          $v2 = $v2.wrapping_add($v1); $v1 = $v1.rotate_left(17); $v1 ^= $v2;\r\n 79,051,764          $v2 = $v2.rotate_left(32);\r\n          .      });\r\n          .  }\r\n          .\r\n          .  /// Load an integer of the desired type from a byte stream, in LE order. Uses\r\n          .  /// `copy_nonoverlapping` to let the compiler generate the most efficient way\r\n          .  /// to load it from a possibly unaligned address.\r\n          .  ///\r\n          .  /// Unsafe because: unchecked indexing at i..i+size_of(int_ty)\r\n          .  macro_rules! load_int_le {\r\n          .      ($buf:expr, $i:expr, $int_ty:ident) =>\r\n          .      ({\r\n          .         debug_assert!($i + mem::size_of::<$int_ty>() <= $buf.len());\r\n          .         let mut data = 0 as $int_ty;\r\n 13,166,995         ptr::copy_nonoverlapping($buf.get_unchecked($i),\r\n          .                                  &mut data as *mut _ as *mut u8,\r\n          .                                  mem::size_of::<$int_ty>());\r\n          .         data.to_le()\r\n          .      });\r\n          .  }\r\n          .\r\n          .  /// Load an u64 using up to 7 bytes of a byte slice.\r\n          .  ///\r\n          .  /// Unsafe because: unchecked indexing at start..start+len\r\n          .  #[inline]\r\n          .  unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\r\n          .      debug_assert!(len < 8);\r\n          .      let mut i = 0; // current byte index (from LSB) in the output u64\r\n          .      let mut out = 0;\r\n345,951,546      if i + 3 < len {\r\n 80,328,075          out = load_int_le!(buf, start + i, u32) as u64;\r\n          .          i += 4;\r\n          .      }\r\n747,722,073      if i + 1 < len {\r\n480,400,389          out |= (load_int_le!(buf, start + i, u16) as u64) << (i * 8);\r\n 87,344,805          i += 2\r\n          .      }\r\n345,951,546      if i < len {\r\n211,374,738          out |= (*buf.get_unchecked(start + i) as u64) << (i * 8);\r\n          .          i += 1;\r\n          .      }\r\n          .      debug_assert_eq!(i, len);\r\n          .      out\r\n          .  }\r\n```\r\nand\r\n```\r\n          .      #[inline]\r\n          .      fn short_write(&mut self, msg: &[u8]) {\r\n          .          debug_assert!(msg.len() <= 8);\r\n          .          let length = msg.len();\r\n212,792,515          self.length += length;\r\n          .\r\n319,188,774          let needed = 8 - self.ntail;\r\n          .          let fill = cmp::min(length, needed);\r\n212,792,515          if fill == 8 {\r\n 38,954,670              self.tail = unsafe { load_int_le!(msg, 0, u64) };\r\n          .          } else {\r\n560,468,202              self.tail |= unsafe { u8to64_le(msg, 0, fill) } << (8 * self.ntail);\r\n186,822,734              if length < needed {\r\n 55,081,556                  self.ntail += length;\r\n          .                  return;\r\n          .              }\r\n          .          }\r\n 78,855,480          self.state.v3 ^= self.tail;\r\n          .          Sip24Rounds::c_rounds(&mut self.state);\r\n157,710,960          self.state.v0 ^= self.tail;\r\n          .\r\n          .          // Buffered tail is now flushed, process new input.\r\n157,710,958          self.ntail = length - needed;\r\n 78,855,480          self.tail = unsafe { u8to64_le(msg, needed, self.ntail) };\r\n212,792,514      }\r\n```\r\nAnd from libcore/num/mod.rs:\r\n```\r\n            .          #[inline]\r\n            .          pub fn rotate_left(self, n: u32) -> Self {\r\n            .              // Protect against undefined behaviour for over-long bit shifts\r\n            .              let n = n % $BITS;\r\n1,187,178,937              (self << n) | (self >> (($BITS - n) % $BITS))\r\n            .          }\r\n```\r\nI stared at this for a while but wasn't able to come up with any notable improvements.\r\n\r\nHashing is the hottest part of most incremental check builds. If we can't speed up this code, perhaps we could use a different hasher, or find a way to hash less data.\r\n\r\nCC @michaelwoerister ", "closed_by": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/51054/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/51054/timeline", "performed_via_github_app": null, "state_reason": "completed"}