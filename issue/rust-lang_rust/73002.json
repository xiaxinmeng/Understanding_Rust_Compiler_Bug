{"url": "https://api.github.com/repos/rust-lang/rust/issues/73002", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/73002/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/73002/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/73002/events", "html_url": "https://github.com/rust-lang/rust/issues/73002", "id": 631148678, "node_id": "MDU6SXNzdWU2MzExNDg2Nzg=", "number": 73002, "title": "Clarify the behavior of std::task::Waker and Future::Poll", "user": {"login": "frostyplanet", "id": 318150, "node_id": "MDQ6VXNlcjMxODE1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/318150?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frostyplanet", "html_url": "https://github.com/frostyplanet", "followers_url": "https://api.github.com/users/frostyplanet/followers", "following_url": "https://api.github.com/users/frostyplanet/following{/other_user}", "gists_url": "https://api.github.com/users/frostyplanet/gists{/gist_id}", "starred_url": "https://api.github.com/users/frostyplanet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frostyplanet/subscriptions", "organizations_url": "https://api.github.com/users/frostyplanet/orgs", "repos_url": "https://api.github.com/users/frostyplanet/repos", "events_url": "https://api.github.com/users/frostyplanet/events{/privacy}", "received_events_url": "https://api.github.com/users/frostyplanet/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 1049510487, "node_id": "MDU6TGFiZWwxMDQ5NTEwNDg3", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-async-await", "name": "A-async-await", "color": "f7e101", "default": false, "description": "Area: Async & Await"}, {"id": 1259721467, "node_id": "MDU6TGFiZWwxMjU5NzIxNDY3", "url": "https://api.github.com/repos/rust-lang/rust/labels/AsyncAwait-Triaged", "name": "AsyncAwait-Triaged", "color": "d4c5f9", "default": false, "description": "Async-await issues that have been triaged during a working group meeting."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-06-04T21:08:03Z", "updated_at": "2020-11-11T20:35:09Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "I have been implemented a few sync mechanism including WaitGroup and MPMC/MPSC in async, althought currently my code seems to work fine. I have some confusion about the documented and feels that there's undefined behavior, especially when future is implemented as lockless and waited/wake_up between multiple thread concurrently.\r\n\r\nIn https://doc.rust-lang.org/std/future/trait.Future.html there's a saying.\r\n`\r\nNote that on multiple calls to poll, only the Waker from the Context passed to the most recent call should be scheduled to receive a wakeup.`\r\n\r\nBefore I have any introspect to the low level implemented, I'm assuming the following action should by done when implemented std::future::Future:\r\n\r\n-  when poll(), the first thing is should have a test of the condition of readiness\r\n-  register the waker,  either store the waker inside some object, or pass it to event driver reside in other thread.\r\n-  check the condition of readiness again  \r\n-  If poll() return Ready before  the waker atually fired, should do some cleanup of the waker registration resource. \r\n-  on Drop to the Future object (when use tokio::time::timeout with the future),  should do some cleanup of the waker registration resource\r\n\r\nLater I found that when trying to be lockless,  during future::select!  will make the future poll() multiple times,  and register the waker to even driver every time harm the performance. And because I'm not sure  whether waker is the same when produced by the same future during multiple poll().  And when a future expect to seldom waked up (eg close channel receiver poll in combination with other busy channel receiver )  all the waker produced by the same future will take up considerble memory resource if my CustomWaker is not cleanup (cancel) ASAP. \r\n\r\nAnd then I discovered in all my usage cases the following assumption seems to be valid, which may help greatly to simply and speed up my code in parallel enviromment,  under controllable memory usage:\r\n\r\n- A waker is valid from the time ctx.waker().clone() until it's woken up by outsider\r\n-  During multiple poll(),  if the waker of previous call is not woken up, I can expect the future to wake up  on future calls poll() when waker.wake() on previous waker.\r\n- If a call to poll() thinks it's condition is not meet, concurrent wake() will guarantee the future to wake in the future. \r\n\r\nI have a little investigation to tokio-0.2 runtime code:\r\nhttps://github.com/tokio-rs/tokio/blob/master/tokio/src/runtime/task/raw.rs \r\nhttps://github.com/tokio-rs/tokio/blob/master/tokio/src/runtime/task/stack.rs\r\nhttps://github.com/tokio-rs/tokio/blob/master/tokio/src/runtime/task/waker.rs\r\n\r\nstd::task::Waker just wraps std::task::RawWaker.  RawWaker.data points to \"header\" entry allocated on the heap.  when ctx.waker().clone(),  a ref_count of  \"header\". which means all waker return by ctx.waker().clone() points to the same waker. until all the waker is dropped or waked, the \"header\" exists.\r\nThe logic seems to support my assumption. modfication to my code base on these assumption runs better than before.\r\n\r\nI think the document or RFC need to be more clarify, for better users' understanding and for more expectable behavior of different runtime implementations.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/73002/reactions", "total_count": 4, "+1": 4, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/73002/timeline", "performed_via_github_app": null, "state_reason": null}