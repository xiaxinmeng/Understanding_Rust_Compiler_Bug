{"url": "https://api.github.com/repos/rust-lang/rust/issues/52122", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/52122/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/52122/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/52122/events", "html_url": "https://github.com/rust-lang/rust/issues/52122", "id": 339111428, "node_id": "MDU6SXNzdWUzMzkxMTE0Mjg=", "number": 52122, "title": "Use hash of compilation unit expression tree to prevent needless recompiles after formatting changes", "user": {"login": "mqudsi", "id": 606923, "node_id": "MDQ6VXNlcjYwNjkyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/606923?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mqudsi", "html_url": "https://github.com/mqudsi", "followers_url": "https://api.github.com/users/mqudsi/followers", "following_url": "https://api.github.com/users/mqudsi/following{/other_user}", "gists_url": "https://api.github.com/users/mqudsi/gists{/gist_id}", "starred_url": "https://api.github.com/users/mqudsi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mqudsi/subscriptions", "organizations_url": "https://api.github.com/users/mqudsi/orgs", "repos_url": "https://api.github.com/users/mqudsi/repos", "events_url": "https://api.github.com/users/mqudsi/events{/privacy}", "received_events_url": "https://api.github.com/users/mqudsi/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 64037154, "node_id": "MDU6TGFiZWw2NDAzNzE1NA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-compiletime", "name": "I-compiletime", "color": "e11d21", "default": false, "description": "Problems and improvements with respect to compile times."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 307747675, "node_id": "MDU6TGFiZWwzMDc3NDc2NzU=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-incr-comp", "name": "A-incr-comp", "color": "f7e101", "default": false, "description": "Area: Incremental compilation"}, {"id": 630652267, "node_id": "MDU6TGFiZWw2MzA2NTIyNjc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-feature-request", "name": "C-feature-request", "color": "f5f1fd", "default": false, "description": "Category: A feature request, i.e: not implemented / a PR."}, {"id": 693665681, "node_id": "MDU6TGFiZWw2OTM2NjU2ODE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/WG-incr-comp", "name": "WG-incr-comp", "color": "c2e0c6", "default": false, "description": "Working group: incremental compilation"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-07-07T02:50:15Z", "updated_at": "2022-07-17T20:12:46Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "If it is possible to obtain some sort of digest or fingerprint for the complete expression tree of a single compilation unit after tokenization and parsing has been completed but before actual compilation takes place, it should be possible to optimize away recompilations of code that has only changed aesthetically but reduces to an identical call tree.\r\n\r\nEssentially, the idea is to explore whether it is possible to obtain a unique signature for a unit of code that has been parsed but before the heaviest lifting is done or any real compilation takes place, such that after compiling a file containing - for example - the following:\r\n\r\n```rust\r\nfn main() {\r\n    return match 1 == 1 {\r\n        true => { () }\r\n        false => { () }\r\n    }\r\n}\r\n```\r\n\r\nthat file is refactored to contain the following:\r\n\r\n```rust\r\nfn main() {\r\n    return match 1 == 1 {\r\n        true => (),\r\n        false => (),\r\n    }\r\n}\r\n```\r\n\r\nthe compiler is able to determine after a quick first pass that although the file has changed, the logic of the file remains unchanged and apart from updating symbol locations, etc. the actual compilation need not be repeated.\r\n\r\nWhile this was an extremely naive example, there are a host of other changes that could be taken into account. Ultimately, it would be wonderful if (as a benchmark) any valid code once compiled would not trigger a complete recompile if `cargo fmt` is run regardless of how many superficial changes that cleanup/reformatting triggered.\r\n\r\nThings that come to mind:\r\n\r\n* Changing `use` statements\r\n* Referring to types by their abbreviated vs unabbreviated names\r\n* Adding or dropping commas or braces in places where the meaning is not affected\r\n* Adding or removing comments anywhere\r\n* Adding or removing whitespace anywhere\r\n* Literally reordering independent (non-nested) blocks within a file such that `struct foo;` which was once before `struct bar;` now comes after it, etc.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/52122/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/52122/timeline", "performed_via_github_app": null, "state_reason": null}