{"url": "https://api.github.com/repos/rust-lang/rust/issues/80630", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/80630/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/80630/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/80630/events", "html_url": "https://github.com/rust-lang/rust/issues/80630", "id": 777521792, "node_id": "MDU6SXNzdWU3Nzc1MjE3OTI=", "number": 80630, "title": "Rust insufficiently optimizes loop { match { } } state machines", "user": {"login": "tuxmark5", "id": 506439, "node_id": "MDQ6VXNlcjUwNjQzOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/506439?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tuxmark5", "html_url": "https://github.com/tuxmark5", "followers_url": "https://api.github.com/users/tuxmark5/followers", "following_url": "https://api.github.com/users/tuxmark5/following{/other_user}", "gists_url": "https://api.github.com/users/tuxmark5/gists{/gist_id}", "starred_url": "https://api.github.com/users/tuxmark5/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tuxmark5/subscriptions", "organizations_url": "https://api.github.com/users/tuxmark5/orgs", "repos_url": "https://api.github.com/users/tuxmark5/repos", "events_url": "https://api.github.com/users/tuxmark5/events{/privacy}", "received_events_url": "https://api.github.com/users/tuxmark5/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}, {"id": 1927601458, "node_id": "MDU6TGFiZWwxOTI3NjAxNDU4", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-mir-opt", "name": "A-mir-opt", "color": "f7e101", "default": false, "description": "Area: MIR optimizations"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 20, "created_at": "2021-01-02T20:39:51Z", "updated_at": "2023-05-05T15:32:42Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "This is how a typical state machine might look in Rust:\r\n\r\n```rust\r\n#[inline(never)]\r\nfn print(s: &str) {\r\n    println!(\"{}\", s);\r\n}\r\n\r\n#[inline(never)]\r\nfn exec(mut s: i32) {\r\n    loop {\r\n        match s {\r\n            0 => { print(\"0\"); s = 2; },\r\n            1 => { print(\"1\"); s = 3; },\r\n            2 => { print(\"2\"); s = 1; },\r\n            _ => return\r\n        }\r\n    }\r\n}\r\n\r\nfn main() {\r\n    exec(0);\r\n}\r\n```\r\nOne would expect that the first jump from function start into one of the states (0, 1, 2 or _) would be compiled as a jumptable or a series of cmp/conditional jump instructions and once the execution is in one of the states the remaining jumps would be deterministic (non-conditional) jumps.\r\n\r\nAnd this is how equivalent code in [gcc](https://godbolt.org/z/3KGoM7) is optimized.\r\n\r\nHowever Rust/LLVM at the end of each state performs needless comparisons to determine to which label to jump to next, even though the jump target can be computed statically. You can inspect the generated assembly in [Rust Playground](https://play.rust-lang.org/?version=stable&mode=release&edition=2018).\r\n\r\nThis is probably more of a LLVM issue rather than Rust directly, but it's important to get this fixed/optimized, because now it's impossible to efficiently write such state machines in Rust (because there is no `goto`)\r\n\r\n### Meta\r\n\r\nTested with all versions available in Rust playground:\r\n\r\n* 1.49.0\r\n* 1.50.0-beta.2 (2020-12-31 25b3db3aa752d9d4633c)\r\n* 1.51.0-nightly (2020-12-30 e2267046859c9ceb932a)", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/80630/reactions", "total_count": 3, "+1": 3, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/80630/timeline", "performed_via_github_app": null, "state_reason": null}