{"url": "https://api.github.com/repos/rust-lang/rust/issues/62391", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/62391/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/62391/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/62391/events", "html_url": "https://github.com/rust-lang/rust/issues/62391", "id": 464403549, "node_id": "MDU6SXNzdWU0NjQ0MDM1NDk=", "number": 62391, "title": "Pin docs should mention pitfalls of generic code", "user": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 60344715, "node_id": "MDU6TGFiZWw2MDM0NDcxNQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/P-medium", "name": "P-medium", "color": "eb6420", "default": false, "description": "Medium priority"}, {"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 431251592, "node_id": "MDU6TGFiZWw0MzEyNTE1OTI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-docs", "name": "A-docs", "color": "f7e101", "default": false, "description": "Area: documentation for any part of the project, including the compiler, standard library, and tools"}, {"id": 1049510487, "node_id": "MDU6TGFiZWwxMDQ5NTEwNDg3", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-async-await", "name": "A-async-await", "color": "f7e101", "default": false, "description": "Area: Async & Await"}, {"id": 1259721467, "node_id": "MDU6TGFiZWwxMjU5NzIxNDY3", "url": "https://api.github.com/repos/rust-lang/rust/labels/AsyncAwait-Triaged", "name": "AsyncAwait-Triaged", "color": "d4c5f9", "default": false, "description": "Async-await issues that have been triaged during a working group meeting."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2019-07-04T22:06:55Z", "updated_at": "2020-03-17T18:32:47Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "The [pin module docs](https://doc.rust-lang.org/beta/std/pin/index.html) currently have a note about implementing `Future` combinators:\r\n\r\n> When implementing a Future combinator, you will usually need structural pinning for the nested futures, as you need to get pinned references to them to call poll.\r\n\r\nHowever, this can be tricky in the presence of generics. Consider this code.\r\n\r\n```rust\r\nuse std::future::Future;\r\nuse std::task::Context;\r\nuse std::pin::Pin;\r\nuse std::task::Poll;\r\nuse std::marker::{Unpin, PhantomPinned};\r\n\r\nmod other_mod {\r\n    use super::*;\r\n\r\n    pub enum DubiousDrop {\r\n        First(PhantomPinned),\r\n        Second(PhantomPinned)\r\n    }\r\n\r\n    impl Drop for DubiousDrop {\r\n        fn drop(&mut self) {\r\n            std::mem::forget(std::mem::replace(self, match self {\r\n                &mut DubiousDrop::First(_) => DubiousDrop::Second(PhantomPinned),\r\n                &mut DubiousDrop::Second(_) => DubiousDrop::First(PhantomPinned)\r\n            }))\r\n        }\r\n    }\r\n\r\n    impl Future for DubiousDrop {\r\n        type Output = ();\r\n        fn poll(self: Pin<&mut Self>, _cx: &mut Context) -> Poll<()> {\r\n            Poll::Ready(())\r\n        }\r\n    }\r\n}\r\n\r\n\r\nstruct MyWrapper<F: Future<Output = ()>> {\r\n    pub fut: F\r\n}\r\n\r\nimpl<F: Future<Output = ()>> Future for MyWrapper<F> {\r\n    type Output = ();\r\n    \r\n    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<()> {\r\n        // Unsound - we don't know that 'fut' upholds the\r\n        // guarantees of 'Pin'\r\n        unsafe { self.map_unchecked_mut(|s| &mut s.fut) }.poll(cx)\r\n    }\r\n}\r\n\r\nfn assert_unpin<T: Unpin>() {}\r\n\r\nfn boom(cx: &mut Context) {\r\n    // Uncomment to trigger a compilation error\r\n    //assert_unpin::<MyWrapper<other_mod::DubiousDrop>>();\r\n    let mut wrapper = Box::pin(MyWrapper { fut: other_mod::DubiousDrop::First(PhantomPinned) });\r\n    Pin::new(&mut wrapper).poll(cx);\r\n}\r\n\r\nfn main() {}\r\n```\r\n\r\nHere, we have an enum `DubiousDrop`, whose destructor changes the enum variant. This type is slightly contrived but is perfectly safe (in fact, the entire containing module is safe).\r\n\r\nWe then implement a simple pass-through future combinator called `MyWrapper`, which simply delegates to a wrapped future using a pin projection. Unfortunately, `MyWrapper` is unsound - it constructs a `Pin<&mut F>` without knowing if `F` upholds the `Pin` guarantees. Our `DubiousDrop` enum explicitly does *not* uphold these guarantees - its destructor invalidates its memory by changing the enum variant, and it is not `Unpin`. Therefore, calling `boom` triggers UB in safe code.\r\n\r\nAFAICT, there are two ways to prevent this kind of issue:\r\n\r\n1. Require that the wrapped `Future` be `Unpin` (in this case, adding an `F: Unpin` bound to `MyWrapper`. This is the approach taken by types like [futures::future::Select](https://rust-lang-nursery.github.io/futures-api-docs/0.3.0-alpha.17/futures/future/struct.Select.html).\r\n2. Make it unsafe to construct the wrapper/combinator type, and document that the caller must uphold the `Pin` requirements on their type.\r\n\r\nHowever, none of this appears to explicitly documented, and it's fairly subtle. I think it's important for the `std::pin` and `std::pin::Pin` docs to make these requirements very clear, as it seems to be somewhat of a footgun.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/62391/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/62391/timeline", "performed_via_github_app": null, "state_reason": null}