{"url": "https://api.github.com/repos/rust-lang/rust/issues/64453", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/64453/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/64453/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/64453/events", "html_url": "https://github.com/rust-lang/rust/issues/64453", "id": 493624880, "node_id": "MDU6SXNzdWU0OTM2MjQ4ODA=", "number": 64453, "title": "ICE: borrowck/check_loans: assertion failed: `self.bccx.region_scope_tree.scopes_intersect(...)`", "user": {"login": "acnologia000", "id": 36767190, "node_id": "MDQ6VXNlcjM2NzY3MTkw", "avatar_url": "https://avatars.githubusercontent.com/u/36767190?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acnologia000", "html_url": "https://github.com/acnologia000", "followers_url": "https://api.github.com/users/acnologia000/followers", "following_url": "https://api.github.com/users/acnologia000/following{/other_user}", "gists_url": "https://api.github.com/users/acnologia000/gists{/gist_id}", "starred_url": "https://api.github.com/users/acnologia000/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acnologia000/subscriptions", "organizations_url": "https://api.github.com/users/acnologia000/orgs", "repos_url": "https://api.github.com/users/acnologia000/repos", "events_url": "https://api.github.com/users/acnologia000/events{/privacy}", "received_events_url": "https://api.github.com/users/acnologia000/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 9618520, "node_id": "MDU6TGFiZWw5NjE4NTIw", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-ICE", "name": "I-ICE", "color": "e10c02", "default": false, "description": "Issue: The compiler panicked, giving an Internal Compilation Error (ICE) \u2744\ufe0f"}, {"id": 46741598, "node_id": "MDU6TGFiZWw0Njc0MTU5OA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/E-needs-test", "name": "E-needs-test", "color": "02e10c", "default": false, "description": "Call for participation: writing correctness tests"}, {"id": 60344715, "node_id": "MDU6TGFiZWw2MDM0NDcxNQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/P-medium", "name": "P-medium", "color": "eb6420", "default": false, "description": "Medium priority"}, {"id": 171502053, "node_id": "MDU6TGFiZWwxNzE1MDIwNTM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-borrow-checker", "name": "A-borrow-checker", "color": "f7e101", "default": false, "description": "Area: The borrow checker"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 262252840, "node_id": "MDU6TGFiZWwyNjIyNTI4NDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/regression-from-stable-to-stable", "name": "regression-from-stable-to-stable", "color": "e4008a", "default": false, "description": "Performance or correctness regression from one stable version to another."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "closed", "locked": false, "assignee": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 11, "created_at": "2019-09-14T13:49:45Z", "updated_at": "2019-10-02T22:35:19Z", "closed_at": "2019-10-02T22:35:19Z", "author_association": "NONE", "active_lock_reason": null, "body": "err :  \r\n```\r\nD:\\work\\rust\\web_api_rust>cargo build\r\n   Compiling web_api_rust v0.1.0 (D:\\work\\rust\\web_api_rust)\r\nwarning: unused variable: `x`\r\n  --> src\\response_builder.rs:13:20\r\n   |\r\n13 | pub fn file_server(x:&str) {\r\n   |                    ^ help: consider prefixing with an underscore: `_x`\r\n   |\r\n   = note: #[warn(unused_variables)] on by default\r\n\r\nthread 'rustc' panicked at 'assertion failed: self.bccx.region_scope_tree.scopes_intersect(old_loan.kill_scope,      \r\n                                             new_loan.kill_scope)', src\\librustc_borrowck\\borrowck\\check_loans.rs:493:9\r\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\r\n\r\nerror: internal compiler error: unexpected panic\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports    \r\n\r\nnote: rustc 1.37.0 (eae3437df 2019-08-13) running on x86_64-pc-windows-msvc\r\n\r\nnote: compiler flags: -C debuginfo=2 -C incremental --crate-type bin\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nerror: Could not compile `web_api_rust`.\r\n```\r\n\r\ncode i was compiling : \r\n\r\nmain.rs\r\n```rust\r\nuse std::env;\r\nuse std::io::{Read, Write};\r\nuse std::net::{TcpListener, TcpStream};\r\nuse std::fs::File;\r\n\r\nmod request_proc;\r\nmod thread_pool;\r\nmod response_builder;\r\nmod misc;\r\nfn main() {\r\n    //Getting thread pool size from environment variable (to be set by user)\r\n    //using 2 threads per route as default in case variable is not set\r\n    //this can be hardcoded or read from a file , hence optional\r\n    let pool_size: usize = match env::var(\"THREAD_POOL_SIZE_FOR_EACH_ROUTE\") {\r\n        // value of 'THREAD_POOL_SIZE_FOR_EACH_ROUTE' is returned as string that needs to\r\n        // be parsed into usize ,in case of errors we are using default values\r\n        Ok(var) => match var.parse() {\r\n            Ok(val) => val,\r\n            Err(_err) => {\r\n                println!(\"> Parse Error :{}'THREAD_POOL_SIZE_FOR_EACH_ROUTE' can only have unsigned integer Value\",_err);\r\n                println!(\"> using default value for THREAD_POOL_SIZE_FOR_EACH_ROUTE\");\r\n                2\r\n            }\r\n        },\r\n        Err(_s) => 2,\r\n    };\r\n\r\n    //Getting listening port  from environment variable (to be set by user)\r\n    //using 0.0.0.0:7878 as defaut port in case variable is not set\r\n    //this can be hardcoded or read from a file , hence optional\r\n    let port = match env::var(\"RUST_SERVER_PORT\") {\r\n        Ok(var) => var,\r\n        Err(_s) => {\r\n            println!(\r\n                \"> failed at reading :{} 'RUST_SERVER_PORT' using default\",\r\n                _s\r\n            );\r\n            \"0.0.0.0:7878\".to_string()\r\n        }\r\n    };\r\n\r\n    //spitting basic chatter to notify user that application is running and reporting settings being used\r\n    // again totally optional but helpful\r\n    println!(\"> edit 'RUST_SERVER_PORT' environment variable to change server listening port\");\r\n    println!(\r\n        \"> edit 'THREAD_POOL_SIZE_FOR_EACH_ROUTE' environment variable to change thread pool size\"\r\n    );\r\n    println!(\r\n        \"> Using {} as thread pool size for each route \\n> using {} as port\",\r\n        pool_size, port\r\n    );\r\n\r\n    // binding a listner on our designated port for listening for Tcp requests\r\n    // binding to a port might fail in case if we are bining to port that needs\r\n    // elivated privelleges to access or port is busy(being used by another application)\r\n    // or port/Ip are unavailable or wrong , its a good idea to report details to user\r\n    let listner = match TcpListener::bind(&port) {\r\n        Ok(val) => val,\r\n        Err(err) => panic!(\"> Binding failure : {}\", err),\r\n    };\r\n\r\n    //declaring string pattern for all routes\r\n    let home_route = \"/\".to_string();\r\n    let route_2 = \"/r2\".to_string();\r\n    let route_3 = \"/r3\".to_string();\r\n    //making thread pool for each route\r\n    let home_pool = thread_pool::ThreadPool::new(pool_size);\r\n    let route2pool = thread_pool::ThreadPool::new(pool_size);\r\n    let route3pool = thread_pool::ThreadPool::new(pool_size);\r\n    //buffer to store request\r\n    let mut req_buffer = [0; 512];\r\n    let test_file = fopen(\"x.html\".to_string());\r\n    // listening to incoming requests in an infinite loop\r\n    // listner.incoming() waits until a request comes in\r\n    // and returns a 'std::result::Result<std::net::TcpStream, std::io::Error>' whenever a request drops\r\n    // which should be unwrapped/matched to get 'std::net::TcpStream' which contains our Tcp request\r\n    // and acts a portal to send back the response for incoming Tcp request\r\n    // assume 'std::net::TcpStream' as a special envelope that is used to recieve Tcp request\r\n    // and send Tcp respose\r\n    for stream in listner.incoming() {\r\n        // getting actual Tcp::stream from Result type given by listener\r\n        let mut stream = match stream {\r\n            Ok(val) => val,\r\n            Err(_err) => {\r\n                println!(\"> Failed at Unwrapping Stream :{}\", _err);\r\n                continue;\r\n            }\r\n        };\r\n\r\n        // stream does not returns Tcp request directly , instead it writes it into\r\n        // empty byte array we provid\r\n        match stream.read(&mut req_buffer) {\r\n            Ok(_val) => {}\r\n            Err(err) => println!(\"> Failed at reading Request into buffer :{}\", err),\r\n        };\r\n\r\n        // parsing request (which is stored in req_buffer) from [u8] to more readable and usable data structure\r\n        let request =\r\n            request_proc::parse_request(&mut String::from_utf8_lossy(&req_buffer).to_string())\r\n                .unwrap();\r\n        // using match as case-switch to send requests to be executed in different thread-pools\r\n        match request {\r\n            // compairing refrance to path inside request to routes and\r\n            // accordingly execute appropriate functions in designated thread pools\r\n            ref path if path.path == home_route => home_pool.execute(|| home(stream, request,&test_file)),\r\n            ref path if path.path == route_2 => route2pool.execute(|| route1(stream)),\r\n            ref path if path.path == route_3 => route3pool.execute(|| route2(stream)),\r\n\r\n            // _ handles all the cases that cannot be handled in our defined paths\r\n            // since we dont have what user is asking for so according to internet standard\r\n            // we will return Error 404\r\n            // we will send response by stream.write(b\"some response\") method in stream\r\n            // response is always written as &[u8] (refrance to byte array)\r\n            // stream.write returns an Result<usize> that should be checked as there is a real\r\n            // possibility of respose writing failure\r\n            // if everything goes well it returns number bytes sent as response (which is useless in most cases)\r\n            _ => err(stream),\r\n        }\r\n    }\r\n}\r\n\r\nfn home(mut stream: TcpStream, request: request_proc::Request,fdata:&String) {\r\n    println!(\"{}\", request.to_string());\r\n    match stream.write(format!(\"HTTP/1.1 200 OK \\nContent-Type: text/html \\r\\n\\r\\n  {} \",fdata).as_bytes()){\r\n        Err(err) => println!(\"> write error : {}\", err),\r\n        Ok(_val) => {}\r\n    }\r\n}\r\n\r\nfn route1(mut stream: TcpStream) {\r\n    match stream\r\n        .write(\"HTTP/1.1 200 OK \\nContent-Type: text/html \\r\\n\\r\\n hello from route 1\".as_bytes())\r\n    {\r\n        Err(err) => println!(\"> write error : {}\", err),\r\n        Ok(_val) => {}\r\n    }\r\n}\r\n\r\nfn route2(mut stream: TcpStream) {\r\n    match stream\r\n        .write(\"HTTP/1.1 200 OK \\nContent-Type: text/html \\r\\n\\r\\n hello from route 2\".as_bytes())\r\n    {\r\n        Err(err) => println!(\"> write error : {}\", err),\r\n        Ok(_val) => {}\r\n    }\r\n}\r\n\r\nfn err(mut stream: TcpStream) {\r\n    let res = \"Error 404 , not found\".as_bytes().to_vec();\r\n    let reponse = response_builder::response_builder_text(response_builder::Text::Html,&res);\r\n    match stream.write(reponse.as_bytes()) {\r\n        Err(err) => println!(\"> write error : {}\", err),\r\n        Ok(_val) => {}\r\n    }\r\n}\r\n// set env var for speed optimization during release build <RUSTFLAGS=\"-C target-cpu=native\">\r\n\r\n#[inline(always)] \r\nfn fopen(fname :String) -> String{\r\n    //let mut buffer :Vec<u8>= Vec::with_capacity(5000);\r\n    let mut buffer : String = String::new();\r\n    let nname = &fname[1..];\r\n    let k = File::open(nname);\r\n    \r\n    match k {\r\n    Err(_e) => { buffer = format!(\"{}\",_e).to_string()}//\"ERROR 404 NOT FOUND\".to_string().into_bytes(); },\r\n    Ok(mut fread) => {                   \r\n        match fread.read_to_string(&mut buffer) {\r\n            Err(_err) =>{ buffer = \"UNABLE TO READ FILE\".to_string() } \r\n            Ok(_n) => {\r\n                println!(\"read {} bytes of data \", _n)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n    buffer\r\n}\r\n\r\n\r\n```\r\n\r\nrest code lives at https://github.com/acnologia000/rust_web_api_example\r\n", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/64453/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/64453/timeline", "performed_via_github_app": null, "state_reason": "completed"}