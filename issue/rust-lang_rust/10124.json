{"url": "https://api.github.com/repos/rust-lang/rust/issues/10124", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/10124/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/10124/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/10124/events", "html_url": "https://github.com/rust-lang/rust/issues/10124", "id": 21706791, "node_id": "MDU6SXNzdWUyMTcwNjc5MQ==", "number": 10124, "title": "RFC: variadic generics", "user": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 24, "created_at": "2013-10-28T17:39:38Z", "updated_at": "2014-10-08T23:34:43Z", "closed_at": "2014-09-16T03:53:02Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "## The Problem\n- [fn types need a reform](http://smallcultfollowing.com/babysteps/blog/2013/10/10/fn-types-in-rust/), and being able to define a trait with a variable number of type parameters would help\n- working with functions which have a variable number of arguments is impossible right now (e.g. a generic `bind` method, `f.bind(a, b)(c) == f(a, b, c)`) and defining such functions may only be done (in a limited fashion) with macros\n- tuples also have similar restrictions right now, there is no way to define a function which takes any tuple and returns the first element, for example\n## The Solution: Part One\n\nC++11 sets a decent precedent, with its variadic templates, which can be used to define type-safe variadic functions, among other things.\nI propose a similar syntax, a trailing `..T` in generic formal type parameters:\n\n``` rust\ntype Tuple<..T> = (..T); // the parens here are the same as the ones around a tuple.\n// use => expansion\nTuple<> => ()\nTuple<int> => (int,)\nTuple<A, B, C> => (A, B, C)\n```\n\nThe simple example above only uses `..T`, but not `T` itself.\nThe question which arises is this: what is `T`? C++11 has a special case for variadic parameter packs, but we can do better.\nWe have tuples. We can use them to store the actual variadic generic type parameters:\n\n``` rust\n// Completely equivalent definition:\ntype Tuple<..T> = T;\n// Detailed expansion of (..T) from above:\nTuple<> => (..()) => ()\nTuple<int> => (..(int,)) => (int,)\nTuple<A, B, C> => (..(A, B, C)) => (A, B, C)\n```\n## The Solution: Part Two\n\nNow that we know the answer is \"tuples\", everything else is about extending them.\nThe prefix `..` operator would expand a tuple type:\n\n``` rust\n// in another tuple type:\ntype AppendTuple<T, U> = (..T, U);\ntype PrependTuple<T, U> = (U, ..T);\nAppendTuple<PrependTuple<Tuple<B>, A>, C> => (A, B, C)\n// in a fn type's parameter list:\ntype VoidFn<..Args> = fn(..Args);\nVoidFn<A, B, C> => fn(A, B, C);\n// in a variadic generic parameter list:\nTuple<..(A, B, C), ..(D, E, F)> => (A, B, C, D, E, F)\n```\n\nThen we can do the same thing with values:\n\n``` rust\n// in another tuple:\n(..(true, false), ..(1, \"foo\"), \"bar\") => (true, false, 1, \"foo\", \"bar\")\n// in a function call:\nf(..(a, b), ..(c, d, e), f) => f(a, b, c, d, e, f)\n```\n\nThere's only one piece missing: we're still not able to define a function which takes a variable number of arguments.\nFor this, I propose `..x: T` (where T is a tuple type) in a pattern, which can be used to \"capture\" multiple arguments  when used in fn formal arguments:\n\n``` rust\n// Destructure a tuple.\nlet (head, ..tail) = foo;\n// This function has the type fn(int, A, B, C), and can be called as such:\nfn bar(_: int, ..x: (A, B, C)) -> R {...}\n```\n\nA type bound for `..T` (i.e. `impl<..T: Trait>`) could mean that the tuple `T` has to satisfy the bound (or each type in `T`, but that's generally less useful).\n## Examples:\n\n``` rust\n// The highly anticipated Fn trait.\ntrait Fn<Ret, ..Args> {\n    fn call(self, .._: Args) -> Ret;\n}\nimpl Fn<Ret, ..Args> for fn(..Args) -> Ret {\n    fn call(self, ..args: Args) -> Ret {\n        self(..args)\n    }\n}\nimpl Fn<Ret, ..Args> for |..Args| -> Ret {\n    fn call(self, ..args: Args) -> Ret {\n        self(..args)\n    }\n}\n\n// Cloning tuples (all cons-list-like algorithms can be implemented this way).\nimpl<Head, ..Tail: Clone> Clone for (Head, ..Tail) {\n    fn clone(&self @ &(ref head, ..ref tail)) -> (Head, ..Tail) {\n        (head.clone(), ..tail.clone())\n    }\n}\nimpl Clone for () {\n    fn clone(&self) -> () {\n        ()\n    }\n}\n\n// Restricting all types in a variadic tuple to one type.\ntrait ArrayLikeTuple<T> {\n    fn len() -> uint;\n}\nimpl<T> ArrayLikeTuple<T> for () {\n    fn len() -> uint {0}\n}\nimpl<T, ..Tail: ArrayLikeTuple<T>> ArrayLikeTuple<T> for (T, ..Tail) {\n    fn len() -> uint {\n        1 + Tail::len()\n    }\n}\n\n// And using that trait to write variadic container constructors.\nimpl<T> Vec<T> {\n    fn new<..Args: ArrayLikeTuple<T>>(..args: Args) -> Vec<T> {\n        let v: Vec<T> = Vec::with_capacity(Args::len());\n        // Use an unsafe move_iter-like pattern to move all the args\n        // directly into the newly allocated vector. \n        // Alternatively, implement &move [T] and move_iter on that.\n    }\n}\n\n// Zipping tuples, using a `Tuple` kind and associated items.\ntrait TupleZip<Other>: Tuple {\n    type Result: Tuple;\n    fn zip(self, other: Other) -> Result;\n}\nimpl TupleZip<()> for () {\n    type Result = ();\n    fn zip(self, _: ()) -> () {}\n}\nimpl<A, ATail: TupleZip<BTail>, B, BTail: Tuple> TupleZip<(B, ..BTail)> for (A, ..ATail) {\n    type Result = ((A, B), ..ATail::Result);\n    fn zip(self @ (a, ..a_tail), (b, ..b_tail): (B, ..BTail)) -> Result {\n        ((a, b), ..a_tail.zip(b_tail))\n    }\n}\n```\n## Todo\n- better formal descriptions\n- figure out the details of pattern matching\n- more examples\n", "closed_by": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/10124/reactions", "total_count": 22, "+1": 22, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/10124/timeline", "performed_via_github_app": null, "state_reason": "completed"}