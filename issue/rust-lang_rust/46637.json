{"url": "https://api.github.com/repos/rust-lang/rust/issues/46637", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/46637/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/46637/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/46637/events", "html_url": "https://github.com/rust-lang/rust/issues/46637", "id": 280838317, "node_id": "MDU6SXNzdWUyODA4MzgzMTc=", "number": 46637, "title": "HRTB: Generic matrix struct and type inference issues", "user": {"login": "Xaldew", "id": 1394310, "node_id": "MDQ6VXNlcjEzOTQzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1394310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xaldew", "html_url": "https://github.com/Xaldew", "followers_url": "https://api.github.com/users/Xaldew/followers", "following_url": "https://api.github.com/users/Xaldew/following{/other_user}", "gists_url": "https://api.github.com/users/Xaldew/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xaldew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xaldew/subscriptions", "organizations_url": "https://api.github.com/users/Xaldew/orgs", "repos_url": "https://api.github.com/users/Xaldew/repos", "events_url": "https://api.github.com/users/Xaldew/events{/privacy}", "received_events_url": "https://api.github.com/users/Xaldew/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 604454086, "node_id": "MDU6TGFiZWw2MDQ0NTQwODY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-inference", "name": "A-inference", "color": "f7e101", "default": false, "description": "Area: Type inference"}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-12-10T19:44:35Z", "updated_at": "2018-01-23T16:14:56Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "Hello,\r\n\r\nI ran across something that *might* be an issue with the Rust type inferencer, but I'm more inclined to think that it is an error on my part and that the error message should be adjusted to something that describes the problem a bit more clearly.\r\n\r\nIn short, I attempted to create a *generic* small-matrix struct with the typical linear algebra operations, multiplications, etc. I also didn't want it to contain just primitive types, so I followed [these](https://stackoverflow.com/questions/34630695/how-to-write-a-trait-bound-for-adding-two-references-of-a-generic-type) instructions and used higher ranked trait bounds to make it work with references to both primitive types and any other type implementing `Add` (such as potential `BigInts`). To this end, I created the following structs and functions:\r\n\r\n```rust\r\n#[derive(Debug,Clone,PartialEq,Eq)]\r\npub struct Mat2x2<T>\r\n{\r\n    m: [T; 4],\r\n}\r\n\r\nimpl<'a, 'b, T> ops::Mul<&'b Mat2x2<T>> for &'a Mat2x2<T>\r\n    where T: Clone + ops::Add<Output = T>,\r\nfor<'c> &'c T: Clone + ops::Mul<Output = T>\r\n{\r\n    type Output = Mat2x2<T>;\r\n\r\n    fn mul(self, rhs: &'b Mat2x2<T>) -> Self::Output\r\n    {\r\n        let m = &self.m;\r\n        let n = &rhs.m;\r\n        Mat2x2 { m: [\r\n            &m[0]*&n[0] + &m[1]*&n[2], &m[0]*&n[1] + &m[1]*&n[3],\r\n            &m[2]*&n[0] + &m[3]*&n[2], &m[2]*&n[1] + &m[3]*&n[3]\r\n        ]}\r\n    }\r\n}\r\n\r\nfn main()\r\n{\r\n    let a = Mat2x2 { m: [1, 0, 0, 1] };\r\n    let b = Mat2x2 { m: [1, 0, 0, 1] };\r\n    let c = &a * &b;\r\n    assert_eq!(a, c);\r\n}\r\n```\r\n\r\nAnd this works fine on its own, but when I introduce some other function that also uses higher ranked trait bounds *and* type-inference, things get a bit weird:\r\n\r\n```rust\r\n#![recursion_limit=\"10\"]\r\nuse std::ops;\r\n\r\n#[derive(Debug,Clone,PartialEq,Eq)]\r\npub struct Mat2x2<T>\r\n{\r\n    m: [T; 4],\r\n}\r\n\r\nfn testing<T>() -> T\r\n    where T: Clone + From<u64>,\r\nfor<'a> &'a T: ops::Mul<Output = T>\r\n{\r\n    let a: T = From::from(0);\r\n    let b: T = From::from(1);\r\n    let d: T = &a * &b;\r\n    d\r\n}\r\n\r\nimpl<'a, 'b, T> ops::Mul<&'b Mat2x2<T>> for &'a Mat2x2<T>\r\n    where T: Clone + ops::Add<Output = T>,\r\nfor<'c> &'c T: Clone + ops::Mul<Output = T>\r\n{\r\n    type Output = Mat2x2<T>;\r\n\r\n    fn mul(self, rhs: &'b Mat2x2<T>) -> Self::Output\r\n    {\r\n        let m = &self.m;\r\n        let n = &rhs.m;\r\n        Mat2x2 { m: [\r\n            &m[0]*&n[0] + &m[1]*&n[2], &m[0]*&n[1] + &m[1]*&n[3],\r\n            &m[2]*&n[0] + &m[3]*&n[2], &m[2]*&n[1] + &m[3]*&n[3]\r\n        ]}\r\n    }\r\n}\r\n\r\nfn main()\r\n{\r\n    let a = Mat2x2 { m: [1, 0, 0, 1] };\r\n    let b = Mat2x2 { m: [1, 0, 0, 1] };\r\n    let c = &a * &b;\r\n    assert_eq!(a, c);\r\n\r\n    let res: u64 = testing::<_>();\r\n    let ans: u64 = 55;\r\n    assert_eq!(res, ans);\r\n}\r\n```\r\n\r\nThis will refuse to compile with the error:\r\n\r\n```\r\nerror[E0275]: overflow evaluating the requirement `<_ as std::ops::Add>::Output`\r\n  --> src/lib.rs:44:20\r\n   |\r\n44 |     let res: u64 = testing::<_>();\r\n   |                    ^^^^^^^^^^^^\r\n   |\r\n   = help: consider adding a `#![recursion_limit=\"10\"]` attribute to your crate\r\n   = note: required because of the requirements on the impl of `std::ops::Mul` for `&'c Mat2x2<_>`\r\n   = note: required because of the requirements on the impl of `std::ops::Mul` for `&'c Mat2x2<Mat2x2<_>>`\r\n   = note: required because of the requirements on the impl of `std::ops::Mul` for `&'c Mat2x2<Mat2x2<Mat2x2<_>>>`\r\n   = note: required because of the requirements on the impl of `std::ops::Mul` for `&'c Mat2x2<Mat2x2<Mat2x2<Mat2x2<_>>>>`\r\n   = note: required because of the requirements on the impl of `for<'a> std::ops::Mul` for `&'a Mat2x2<Mat2x2<Mat2x2<Mat2x2<Mat2x2<_>>>>>`\r\n   = note: required by `testing`\r\n```\r\n\r\n(I explicitly set the recursion depth rather low to reduce the amount of output).\r\n\r\nIf I understand this correctly, Rust is unable to deduce the type `T` for `testing`, and is for some reason trying all possible nestings of `Mat2x2` to figure it out and the process of doing that runs afoul of the generic recursion depth limit.\r\n\r\nAs far as I can tell, this happens because `Mat2x2` implements `Mul` and requires `T` to also implement it, enabling this kind of recursion. So what I'm wondering is this: Is this working as intended? And if so, is there any way to work around it?\r\n\r\nIt is possible to explicitly set the type for `testing`, but that essentially means that type inference gets disabled when using this kind of structures, which is a bit of a shame.\r\n\r\nInitially, I posted this on the [rust-lang](https://users.rust-lang.org/t/hrtb-generic-matrix-struct-and-type-inference-issues/14290) forums, but I was suggested to actually post it here, since it *might* be a bug.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/46637/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/46637/timeline", "performed_via_github_app": null, "state_reason": null}