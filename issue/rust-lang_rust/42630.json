{"url": "https://api.github.com/repos/rust-lang/rust/issues/42630", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/42630/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/42630/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/42630/events", "html_url": "https://github.com/rust-lang/rust/issues/42630", "id": 235559023, "node_id": "MDU6SXNzdWUyMzU1NTkwMjM=", "number": 42630, "title": "float tests fails on wasm32-unknown-emscripten", "user": {"login": "malbarbo", "id": 1678126, "node_id": "MDQ6VXNlcjE2NzgxMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1678126?v=4", "gravatar_id": "", "url": "https://api.github.com/users/malbarbo", "html_url": "https://github.com/malbarbo", "followers_url": "https://api.github.com/users/malbarbo/followers", "following_url": "https://api.github.com/users/malbarbo/following{/other_user}", "gists_url": "https://api.github.com/users/malbarbo/gists{/gist_id}", "starred_url": "https://api.github.com/users/malbarbo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/malbarbo/subscriptions", "organizations_url": "https://api.github.com/users/malbarbo/orgs", "repos_url": "https://api.github.com/users/malbarbo/repos", "events_url": "https://api.github.com/users/malbarbo/events{/privacy}", "received_events_url": "https://api.github.com/users/malbarbo/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 120005, "node_id": "MDU6TGFiZWwxMjAwMDU=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-testsuite", "name": "A-testsuite", "color": "f7e101", "default": false, "description": "Area: The testsuite used to check the correctness of rustc"}, {"id": 474645165, "node_id": "MDU6TGFiZWw0NzQ2NDUxNjU=", "url": "https://api.github.com/repos/rust-lang/rust/labels/O-wasm", "name": "O-wasm", "color": "6e6ec0", "default": false, "description": "Target: WASM (WebAssembly), http://webassembly.org/"}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2017-06-13T13:44:08Z", "updated_at": "2017-08-27T05:08:03Z", "closed_at": "2017-08-27T05:08:03Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "This tests (taken from rust tests):\r\n\r\n```rust\r\n#![feature(dec2flt)]\r\n\r\n#![allow(unused_macros, unused_imports, dead_code)]\r\n\r\nextern crate core;\r\n\r\nuse std::num::FpCategory::*;\r\nuse std::num::FpCategory as Fp;\r\nuse core::num::dec2flt::rawfp::{RawFloat, Unpacked};\r\n\r\nconst SOME_FLOATS: [f64; 9] =\r\n    [0.1f64, 33.568, 42.1e-5, 777.0e9, 1.1111, 0.347997,\r\n     9843579834.35892, 12456.0e-150, 54389573.0e-150];\r\n\r\n// src/libcore/tests/num/dec2flt/mod.rs\r\n\r\n// Take a float literal, turn it into a string in various ways (that are all trusted\r\n// to be correct) and see if those strings are parsed back to the value of the literal.\r\n// Requires a *polymorphic literal*, i.e. one that can serve as f64 as well as f32.\r\nmacro_rules! test_literal {\r\n    ($x: expr) => ({\r\n        let x32: f32 = $x;\r\n        let x64: f64 = $x;\r\n        let inputs = &[stringify!($x).into(), format!(\"{:?}\", x64), format!(\"{:e}\", x64)];\r\n        for input in inputs {\r\n            assert_eq!(input.parse(), Ok(x64));\r\n            assert_eq!(input.parse(), Ok(x32));\r\n            let neg_input = &format!(\"-{}\", input);\r\n            assert_eq!(neg_input.parse(), Ok(-x64));\r\n            assert_eq!(neg_input.parse(), Ok(-x32));\r\n        }\r\n    })\r\n}\r\n\r\n#[test]\r\nfn ordinary() {\r\n    test_literal!(1.0);\r\n    test_literal!(3e-5);\r\n    test_literal!(0.1);\r\n    test_literal!(12345.);\r\n    test_literal!(0.9999999);\r\n    test_literal!(2.2250738585072014e-308);\r\n}\r\n\r\n#[test]\r\nfn special_code_paths() {\r\n    test_literal!(36893488147419103229.0); // 2^65 - 3, triggers half-to-even with even significand\r\n    test_literal!(101e-33); // Triggers the tricky underflow case in AlgorithmM (for f32)\r\n    test_literal!(1e23); // Triggers AlgorithmR\r\n    test_literal!(2075e23); // Triggers another path through AlgorithmR\r\n    test_literal!(8713e-23); // ... and yet another.\r\n}\r\n\r\n\r\n// src/libcore/tests/num/dec2flt/rawfp.rs\r\n\r\n#[test]\r\nfn prev_float_monotonic() {\r\n    let mut x = 1.0;\r\n    for _ in 0..100 {\r\n        let x1 = prev_float(x);\r\n        assert!(x1 < x);\r\n        assert!(x - x1 < 1e-15);\r\n        x = x1;\r\n    }\r\n}\r\n\r\n#[test]\r\nfn next_prev_identity() {\r\n    for &x in &SOME_FLOATS {\r\n        assert_eq!(prev_float(next_float(x)), x);\r\n        assert_eq!(prev_float(prev_float(next_float(next_float(x)))), x);\r\n        assert_eq!(next_float(prev_float(x)), x);\r\n        assert_eq!(next_float(next_float(prev_float(prev_float(x)))), x);\r\n    }\r\n}\r\n\r\n\r\n/// Inverse of `RawFloat::unpack()` for normalized numbers.\r\n/// Panics if the significand or exponent are not valid for normalized numbers.\r\npub fn encode_normal<T: RawFloat>(x: Unpacked) -> T {\r\n    debug_assert!(T::MIN_SIG <= x.sig && x.sig <= T::MAX_SIG,\r\n        \"encode_normal: significand not normalized\");\r\n    // Remove the hidden bit\r\n    let sig_enc = x.sig & !(1 << T::EXPLICIT_SIG_BITS);\r\n    // Adjust the exponent for exponent bias and mantissa shift\r\n    let k_enc = x.k + T::MAX_EXP + T::EXPLICIT_SIG_BITS as i16;\r\n    debug_assert!(k_enc != 0 && k_enc < T::MAX_ENCODED_EXP,\r\n        \"encode_normal: exponent out of range\");\r\n    // Leave sign bit at 0 (\"+\"), our numbers are all positive\r\n    let bits = (k_enc as u64) << T::EXPLICIT_SIG_BITS | sig_enc;\r\n    T::from_bits(bits)\r\n}\r\n\r\n/// Find the largest floating point number strictly smaller than the argument.\r\n/// Does not handle subnormals, zero, or exponent underflow.\r\npub fn prev_float<T: RawFloat>(x: T) -> T {\r\n    match x.classify() {\r\n        Infinite => panic!(\"prev_float: argument is infinite\"),\r\n        Nan => panic!(\"prev_float: argument is NaN\"),\r\n        Subnormal => panic!(\"prev_float: argument is subnormal\"),\r\n        Zero => panic!(\"prev_float: argument is zero\"),\r\n        Normal => {\r\n            let Unpacked { sig, k } = x.unpack();\r\n            if sig == T::MIN_SIG {\r\n                encode_normal(Unpacked::new(T::MAX_SIG, k - 1))\r\n            } else {\r\n                encode_normal(Unpacked::new(sig - 1, k))\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Find the smallest floating point number strictly larger than the argument.\r\n// This operation is saturating, i.e. next_float(inf) == inf.\r\n// Unlike most code in this module, this function does handle zero, subnormals, and infinities.\r\n// However, like all other code here, it does not deal with NaN and negative numbers.\r\npub fn next_float<T: RawFloat>(x: T) -> T {\r\n    match x.classify() {\r\n        Nan => panic!(\"next_float: argument is NaN\"),\r\n        Infinite => T::INFINITY,\r\n        // This seems too good to be true, but it works.\r\n        // 0.0 is encoded as the all-zero word. Subnormals are 0x000m...m where m is the mantissa.\r\n        // In particular, the smallest subnormal is 0x0...01 and the largest is 0x000F...F.\r\n        // The smallest normal number is 0x0010...0, so this corner case works as well.\r\n        // If the increment overflows the mantissa, the carry bit increments the exponent as we\r\n        // want, and the mantissa bits become zero. Because of the hidden bit convention, this\r\n        // too is exactly what we want!\r\n        // Finally, f64::MAX + 1 = 7eff...f + 1 = 7ff0...0 = f64::INFINITY.\r\n        Zero | Subnormal | Normal => {\r\n            let bits: u64 = x.transmute();\r\n            T::from_bits(bits + 1)\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// src/libcore/tests/num/mod.rs\r\n#[test]\r\nfn test_f32f64() {\r\n    use core::f32;\r\n\r\n    let max: f64 = f32::MAX.into();\r\n    assert_eq!(max as f32, f32::MAX);\r\n    assert!(max.is_normal());\r\n\r\n    let min: f64 = f32::MIN.into();\r\n    assert_eq!(min as f32, f32::MIN);\r\n    assert!(min.is_normal());\r\n\r\n    let min_positive: f64 = f32::MIN_POSITIVE.into();\r\n    assert_eq!(min_positive as f32, f32::MIN_POSITIVE);\r\n    assert!(min_positive.is_normal());\r\n\r\n    let epsilon: f64 = f32::EPSILON.into();\r\n    assert_eq!(epsilon as f32, f32::EPSILON);\r\n    assert!(epsilon.is_normal());\r\n\r\n    let zero: f64 = (0.0f32).into();\r\n    assert_eq!(zero as f32, 0.0f32);\r\n    assert!(zero.is_sign_positive());\r\n\r\n    let neg_zero: f64 = (-0.0f32).into();\r\n    assert_eq!(neg_zero as f32, -0.0f32);\r\n    assert!(neg_zero.is_sign_negative());\r\n\r\n    let infinity: f64 = f32::INFINITY.into();\r\n    assert_eq!(infinity as f32, f32::INFINITY);\r\n    assert!(infinity.is_infinite());\r\n    assert!(infinity.is_sign_positive());\r\n\r\n    let neg_infinity: f64 = f32::NEG_INFINITY.into();\r\n    assert_eq!(neg_infinity as f32, f32::NEG_INFINITY);\r\n    assert!(neg_infinity.is_infinite());\r\n    assert!(neg_infinity.is_sign_negative());\r\n\r\n    let nan: f64 = f32::NAN.into();\r\n    assert!(nan.is_nan());\r\n}\r\n\r\n\r\n// src/libstd/f64.rs\r\n#[test]\r\nfn test_one() {\r\n    let one: f64 = 1.0f64;\r\n    assert_eq!(1.0, one);\r\n    assert!(!one.is_infinite());\r\n    assert!(one.is_finite());\r\n    assert!(one.is_sign_positive());\r\n    assert!(!one.is_sign_negative());\r\n    assert!(!one.is_nan());\r\n    assert!(one.is_normal());\r\n    assert_eq!(Fp::Normal, one.classify());\r\n}\r\n\r\n#[test]\r\nfn test_is_normal() {\r\n    use std::f64::*;\r\n    let nan: f64 = NAN;\r\n    let inf: f64 = INFINITY;\r\n    let neg_inf: f64 = NEG_INFINITY;\r\n    let zero: f64 = 0.0f64;\r\n    let neg_zero: f64 = -0.0;\r\n    assert!(!nan.is_normal());\r\n    assert!(!inf.is_normal());\r\n    assert!(!neg_inf.is_normal());\r\n    assert!(!zero.is_normal());\r\n    assert!(!neg_zero.is_normal());\r\n    assert!(1f64.is_normal());\r\n    assert!(1e-307f64.is_normal());\r\n    assert!(!1e-308f64.is_normal());\r\n}\r\n\r\n#[test]\r\nfn test_classify() {\r\n    use std::f64::*;\r\n    let nan: f64 = NAN;\r\n    let inf: f64 = INFINITY;\r\n    let neg_inf: f64 = NEG_INFINITY;\r\n    let zero: f64 = 0.0f64;\r\n    let neg_zero: f64 = -0.0;\r\n    assert_eq!(nan.classify(), Fp::Nan);\r\n    assert_eq!(inf.classify(), Fp::Infinite);\r\n    assert_eq!(neg_inf.classify(), Fp::Infinite);\r\n    assert_eq!(zero.classify(), Fp::Zero);\r\n    assert_eq!(neg_zero.classify(), Fp::Zero);\r\n    assert_eq!(1e-307f64.classify(), Fp::Normal);\r\n    assert_eq!(1e-308f64.classify(), Fp::Subnormal);\r\n}\r\n```\r\n\r\nfails on `wasm32-unknown-emscripten`. I think that this as bug in asm2wasm because the same tests works on  `asmjs-unknown-emscripten`. I used [cross](https://github.com/japaric/cross) to run the tests (it is necessary to create a project and put the code in lib.rs):\r\n\r\n```\r\ncross test --target asmjs-unknown-emscripten # works\r\ncross test --target wasm32-unknown-emscripten # fails\r\n```\r\n\r\nTests results:\r\n\r\n```\r\nrunning 8 tests\r\ntest next_prev_identity ... FAILED\r\ntest ordinary ... FAILED\r\ntest prev_float_monotonic ... FAILED\r\ntest special_code_paths ... FAILED\r\ntest test_classify ... FAILED\r\ntest test_f32f64 ... FAILED\r\ntest test_is_normal ... FAILED\r\ntest test_one ... FAILED\r\n\r\nfailures:\r\n\r\n---- next_prev_identity stdout ----\r\n\tthread 'main' panicked at 'prev_float: argument is subnormal', src/lib.rs:101\r\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\r\n\r\n---- ordinary stdout ----\r\n\tthread 'main' panicked at 'assertion failed: `(left == right)` (left: `Ok(0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002225073858507201)`, right: `Ok(0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002225073858507201)`)', src/lib.rs:42\r\n\r\n---- prev_float_monotonic stdout ----\r\n\tthread 'main' panicked at 'prev_float: argument is subnormal', src/lib.rs:101\r\n\r\n---- special_code_paths stdout ----\r\n\tthread 'main' panicked at 'assertion failed: `(left == right)` (left: `Ok(36893488147419100000)`, right: `Ok(36893488147419100000)`)', src/lib.rs:47\r\n\r\n---- test_classify stdout ----\r\n\tthread 'main' panicked at 'assertion failed: `(left == right)` (left: `Subnormal`, right: `Normal`)', src/lib.rs:227\r\n\r\n---- test_f32f64 stdout ----\r\n\tthread 'main' panicked at 'assertion failed: max.is_normal()', src/lib.rs:145\r\n\r\n---- test_is_normal stdout ----\r\n\tthread 'main' panicked at 'assertion failed: 1f64.is_normal()', src/lib.rs:209\r\n\r\n---- test_one stdout ----\r\n\tthread 'main' panicked at 'assertion failed: one.is_normal()', src/lib.rs:192\r\n\r\n\r\nfailures:\r\n    next_prev_identity\r\n    ordinary\r\n    prev_float_monotonic\r\n    special_code_paths\r\n    test_classify\r\n    test_f32f64\r\n    test_is_normal\r\n    test_one\r\n\r\ntest result: FAILED. 0 passed; 8 failed; 0 ignored; 0 measured; 0 filtered out\r\n```", "closed_by": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/42630/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/42630/timeline", "performed_via_github_app": null, "state_reason": "completed"}