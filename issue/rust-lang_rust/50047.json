{"url": "https://api.github.com/repos/rust-lang/rust/issues/50047", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/50047/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/50047/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/50047/events", "html_url": "https://github.com/rust-lang/rust/issues/50047", "id": 315379115, "node_id": "MDU6SXNzdWUzMTUzNzkxMTU=", "number": 50047, "title": "Box::new(expr) first puts expr on the stack, then copies.", "user": {"login": "glandium", "id": 1038527, "node_id": "MDQ6VXNlcjEwMzg1Mjc=", "avatar_url": "https://avatars.githubusercontent.com/u/1038527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glandium", "html_url": "https://github.com/glandium", "followers_url": "https://api.github.com/users/glandium/followers", "following_url": "https://api.github.com/users/glandium/following{/other_user}", "gists_url": "https://api.github.com/users/glandium/gists{/gist_id}", "starred_url": "https://api.github.com/users/glandium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glandium/subscriptions", "organizations_url": "https://api.github.com/users/glandium/orgs", "repos_url": "https://api.github.com/users/glandium/repos", "events_url": "https://api.github.com/users/glandium/events{/privacy}", "received_events_url": "https://api.github.com/users/glandium/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 256133398, "node_id": "MDU6TGFiZWwyNTYxMzMzOTg=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-mir", "name": "A-mir", "color": "f7e101", "default": false, "description": "Area: Mid-level IR (MIR) - https://blog.rust-lang.org/2016/04/19/MIR.html"}, {"id": 884691893, "node_id": "MDU6TGFiZWw4ODQ2OTE4OTM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/WG-codegen", "name": "WG-codegen", "color": "c2e0c6", "default": false, "description": "Working Group: Codegen (Runtime perf and code size)"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2018-04-18T08:25:21Z", "updated_at": "2018-05-29T14:34:03Z", "closed_at": "2018-05-29T14:34:02Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Consider the following code:\r\n```rust\r\npub fn foo() -> Box<[u8; 4096]> {\r\n    Box::new([0; 4096])\r\n}\r\n```\r\n(made it big because it's kind of simpler to see the memset and memcpy calls in the resulting asm)\r\n\r\nIt generates the following assembly:\r\n```asm\r\nexample::foo:\r\n  push rbx\r\n  mov eax, 4096\r\n  call __rust_probestack\r\n  sub rsp, rax\r\n  mov rdi, rsp\r\n  xor esi, esi\r\n  mov edx, 4096\r\n  call memset@PLT\r\n  mov edi, 4096\r\n  mov esi, 1\r\n  call __rust_alloc@PLT\r\n  mov rbx, rax\r\n  test rbx, rbx\r\n  je .LBB1_1\r\n  mov rsi, rsp\r\n  mov edx, 4096\r\n  mov rdi, rbx\r\n  call memcpy@PLT\r\n  mov rax, rbx\r\n  add rsp, 4096\r\n  pop rbx\r\n  ret\r\n.LBB1_1:\r\n  call <alloc::alloc::Global as core::alloc::GlobalAlloc>::oom\r\n  ud2\r\n```\r\n\r\nwhich does a memset, alloc, memcpy dance.\r\n\r\nI was accepting this as a fact of life, but today, I was looking at a random old version of rustc on godbolt, and it turns out before 1.12, the memset, alloc, memcpy dance wasn't happening:\r\n```asm\r\nexample::foo:\r\n  push rbx\r\n  mov edi, 4096\r\n  mov esi, 1\r\n  call __rust_allocate@PLT\r\n  mov rbx, rax\r\n  test rbx, rbx\r\n  je .LBB0_2\r\n  xor esi, esi\r\n  mov edx, 4096\r\n  mov rdi, rbx\r\n  call memset@PLT\r\n  mov rax, rbx\r\n  pop rbx\r\n  ret\r\n.LBB0_2:\r\n  call alloc::oom::oom@PLT\r\n```\r\nhttps://godbolt.org/g/J3cy5E\r\n\r\nThe llvm ir back then looks like the following:\r\n```\r\ntarget datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\r\ntarget triple = \"x86_64-unknown-linux-gnu\"\r\n\r\ndefine noalias dereferenceable(4096) [4096 x i8]* @example::foo() unnamed_addr #0 {\r\nentry-block:\r\n  %0 = tail call i8* @__rust_allocate(i64 4096, i64 1) #1, !noalias !0\r\n  %1 = icmp eq i8* %0, null\r\n  br i1 %1, label %then-block-57-.i.i, label %\"_ZN5alloc5boxed30_$LT$impl$u20$Box$LT$T$GT$$GT$3new17ha7ffa7dfb1e725d2E.exit\"\r\n\r\nthen-block-57-.i.i: ; preds = %entry-block\r\n  tail call void @alloc::oom::oom(), !noalias !0\r\n  unreachable\r\n\r\n\"_ZN5alloc5boxed30_$LT$impl$u20$Box$LT$T$GT$$GT$3new17ha7ffa7dfb1e725d2E.exit\": ; preds = %entry-block\r\n  %2 = bitcast i8* %0 to [4096 x i8]*\r\n  call void @llvm.memset.p0i8.i64(i8* nonnull %0, i8 0, i64 4096, i32 1, i1 false)\r\n  ret [4096 x i8]* %2\r\n}\r\n\r\ndeclare noalias i8* @__rust_allocate(i64, i64) unnamed_addr #1\r\n\r\ndeclare void @alloc::oom::oom() unnamed_addr #2\r\n\r\ndeclare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #3\r\n\r\nattributes #0 = { uwtable }\r\nattributes #1 = { nounwind }\r\nattributes #2 = { cold noinline noreturn }\r\nattributes #3 = { argmemonly nounwind }\r\n\r\n!0 = !{!1}\r\n!1 = distinct !{!1, !2, !\"alloc::boxed::<impl Box<T>>::new: %x\"}\r\n!2 = distinct !{!2, !\"alloc::boxed::<impl Box<T>>::new\"}\r\n```\r\n\r\nwhile on nightly, it looks like:\r\n```\r\ntarget datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\r\ntarget triple = \"x86_64-unknown-linux-gnu\"\r\n\r\ndefine internal fastcc void @\"<alloc::alloc::Global as core::alloc::GlobalAlloc>::oom\"() unnamed_addr #0 {\r\n  tail call void @__rust_oom()\r\n  unreachable\r\n}\r\n\r\ndefine noalias align 1 dereferenceable(4096) [4096 x i8]* @example::foo() unnamed_addr #1 {\r\n  %_1 = alloca [4096 x i8], align 1\r\n  %_1.0.sroa_idx2 = getelementptr inbounds [4096 x i8], [4096 x i8]* %_1, i64 0, i64 0\r\n  call void @llvm.lifetime.start.p0i8(i64 4096, i8* nonnull %_1.0.sroa_idx2)\r\n  call void @llvm.memset.p0i8.i64(i8* nonnull %_1.0.sroa_idx2, i8 0, i64 4096, i32 1, i1 false)\r\n  %0 = tail call i8* @__rust_alloc(i64 4096, i64 1) #5, !noalias !0\r\n  %1 = icmp eq i8* %0, null\r\n  br i1 %1, label %bb7.i.i, label %\"_ZN35_$LT$alloc..boxed..Box$LT$T$GT$$GT$3new17hbb8214c4d412a6d3E.exit\"\r\n\r\nbb7.i.i: ; preds = %start\r\n  tail call fastcc void @\"<alloc::alloc::Global as core::alloc::GlobalAlloc>::oom\"() #5, !noalias !0\r\n  unreachable\r\n\r\n\"_ZN35_$LT$alloc..boxed..Box$LT$T$GT$$GT$3new17hbb8214c4d412a6d3E.exit\": ; preds = %start\r\n  %2 = bitcast i8* %0 to [4096 x i8]*\r\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %0, i8* nonnull %_1.0.sroa_idx2, i64 4096, i32 1, i1 false) #5\r\n  call void @llvm.lifetime.end.p0i8(i64 4096, i8* nonnull %_1.0.sroa_idx2)\r\n  ret [4096 x i8]* %2\r\n}\r\n\r\ndeclare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #2\r\n\r\ndeclare void @__rust_oom() unnamed_addr #3\r\n\r\ndeclare noalias i8* @__rust_alloc(i64, i64) unnamed_addr #4\r\n\r\ndeclare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #2\r\n\r\ndeclare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #2\r\n\r\ndeclare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #2\r\n\r\nattributes #0 = { inlinehint noreturn nounwind uwtable \"probe-stack\"=\"__rust_probestack\" }\r\nattributes #1 = { nounwind uwtable \"probe-stack\"=\"__rust_probestack\" }\r\nattributes #2 = { argmemonly nounwind }\r\nattributes #3 = { cold noreturn nounwind \"probe-stack\"=\"__rust_probestack\" }\r\nattributes #4 = { nounwind \"probe-stack\"=\"__rust_probestack\" }\r\nattributes #5 = { nounwind }\r\n\r\n!0 = !{!1}\r\n!1 = distinct !{!1, !2, !\"<alloc::boxed::Box<T>>::new: %x\"}\r\n!2 = distinct !{!2, !\"<alloc::boxed::Box<T>>::new\"}\r\n```", "closed_by": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/50047/reactions", "total_count": 2, "+1": 2, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/50047/timeline", "performed_via_github_app": null, "state_reason": "completed"}