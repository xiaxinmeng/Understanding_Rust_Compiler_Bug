{"url": "https://api.github.com/repos/rust-lang/rust/issues/11361", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/11361/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/11361/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/11361/events", "html_url": "https://github.com/rust-lang/rust/issues/11361", "id": 25145593, "node_id": "MDU6SXNzdWUyNTE0NTU5Mw==", "number": 11361, "title": "Weird borrowck issues with &mut &mut [u8]", "user": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 171502053, "node_id": "MDU6TGFiZWwxNzE1MDIwNTM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-borrow-checker", "name": "A-borrow-checker", "color": "f7e101", "default": false, "description": "Area: The borrow checker"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2014-01-07T03:06:17Z", "updated_at": "2023-05-23T09:20:11Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I ran into some bizarre borrowck issues when trying to write a function that would modify a `&mut &mut [u8]`. The goal here was to make it simple to shove data into a `[u8, ..512]` by virtue of copying data into the corresponding `&mut [u8]` and then modifying the slice. I tried three different approaches, and they all had issues. The various errors are commented into the source.\n\n(All 3 approaches require `use std::vdc::MutableCloneableVector`)\n\nThe first approach tried to define a function `append(buf: &mut &mut [u8], v: &[u8])` that would copy the data into `buf` and then modify `*buf` to contain the new slice. This ran into an odd lifetime error where it thinks that I can't say `*buf = buf.mut_slice_from(len)`. It claims the lifetime of `buf` is too short, but I don't see why that matters. I'm actually re-slicing `*buf`, and putting the result back into the same location that held the original slice, so I would expect it to have the same lifetime and, therefore, be valid.\n\n``` Rust\nfn one() {\n    let mut line = [0u8, ..512];\n    let mut buf = line.as_mut_slice();\n\n    fn append(buf: &mut &mut [u8], v: &[u8]) {\n        let len = buf.clone_from_slice(v);\n        *buf = buf.slice_from_mut(len);\n// error: lifetime of `buf` is too short to guarantee its contents can be safely reborrowed\n//             ^~~\n// note: `buf` would have to be valid for the anonymous lifetime #2 defined on the block at 7:45...\n// note: ...but `buf` is only valid for the anonymous lifetime #1 defined on the block at 7:45\n    }\n\n    append(&mut buf, b\"test\");\n    append(&mut buf, b\"foo\");\n}\n```\n\nThe second approach was to give both levels of indirection the same lifetime, e.g. `append<'a>(&'a mut &'a mut [u8], v: &[u8])` to try and squelch the error. This didn't work because I wasn't allowed to reassign back to `*buf`, as it considered `buf.mut_slice_from(len)` to borrow it. I assume the borrow check is tied to the lifetime, which is shared at both levels, so borrowck thinks `buf` is borrowed when it's really `*buf` that's borrowed.\n\nCuriously, it also decided I couldn't use `&mut buf` twice in the calling code, as it seemed to think it was already borrowed.\n\n``` Rust\nfn two() {\n    let mut line = [0u8, ..512];\n    let mut buf = line.as_mut_slice();\n\n    fn append<'a>(buf: &'a mut &'a mut [u8], v: &[u8]) {\n        let len = buf.copy_from(v);\n        *buf = buf.mut_slice_from(len);\n// error: cannot assign to `*buf` because it is borrowed\n//      ^~~~\n// note: borrow of `*buf` occurs here\n//             ^~~\n    }\n\n    append(&mut buf, bytes!(\"test\"));\n    append(&mut buf, bytes!(\"foo\"))\n// error: cannot borrow `buf` as mutable more than once at a time\n//         ^~~~~~~~\n// note: previous borrow of `buf` as mutable occurs here\n//         ^~~~~~~~\n}\n```\n\nThe third approach was to ditch `&mut &mut [u8]` entirely and try capturing `buf` in a closure instead. This gave some odd errors. First off, it kept referencing `(*buf)[]`, and I don't know what it meant by that. Also, the first error here indicates that a borrow on a _later_ line was blocking a borrow on an _earlier_ line, which is quite bizarre. How can `buf` have been borrowed already when the later line is, well, later? It also considered the same reference to `buf` to consist of multiple mutable borrows.\n\n``` Rust\nfn three() {\n    let mut line = [0u8, ..512];\n    let mut buf = line.as_mut_slice();\n\n    let append = |v: &[u8]| {\n        let len = buf.copy_from(v);\n// error: cannot borrow `(*buf)[]` as mutable more than once at a time\n//                ^~~\n        buf = buf.mut_slice_from(len);\n// note: previous borrow of `(*buf)[]` as mutable occurs here\n//            ^~~\n// error: cannot borrow `(*buf)[]` as mutable more than once at a time\n//            ^~~\n// note: previous borrow of `(*buf)[]` as mutable occurs here\n//            ^~~\n// error: cannot assign to `buf` because it is borrowed\n//      ^~~\n// note: borrow of `buf` occurs here\n//            ^~~\n    };\n\n    append(bytes!(\"test\"));\n    append(bytes!(\"foo\"));\n}\n```\n\nIn the end, I couldn't figure out any way to accomplish what I wanted. It seems to me the first approach should have worked.\n\n/cc @nikomatsakis \n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/11361/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/11361/timeline", "performed_via_github_app": null, "state_reason": null}