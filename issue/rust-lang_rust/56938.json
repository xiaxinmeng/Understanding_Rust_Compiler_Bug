{"url": "https://api.github.com/repos/rust-lang/rust/issues/56938", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/56938/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/56938/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/56938/events", "html_url": "https://github.com/rust-lang/rust/issues/56938", "id": 391967195, "node_id": "MDU6SXNzdWUzOTE5NjcxOTU=", "number": 56938, "title": "Uses of GlobalAlloc::realloc yield useless code in lto+opt-level=2 builds", "user": {"login": "glandium", "id": 1038527, "node_id": "MDQ6VXNlcjEwMzg1Mjc=", "avatar_url": "https://avatars.githubusercontent.com/u/1038527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glandium", "html_url": "https://github.com/glandium", "followers_url": "https://api.github.com/users/glandium/followers", "following_url": "https://api.github.com/users/glandium/following{/other_user}", "gists_url": "https://api.github.com/users/glandium/gists{/gist_id}", "starred_url": "https://api.github.com/users/glandium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glandium/subscriptions", "organizations_url": "https://api.github.com/users/glandium/orgs", "repos_url": "https://api.github.com/users/glandium/repos", "events_url": "https://api.github.com/users/glandium/events{/privacy}", "received_events_url": "https://api.github.com/users/glandium/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 129836139, "node_id": "MDU6TGFiZWwxMjk4MzYxMzk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-allocators", "name": "A-allocators", "color": "f7e101", "default": false, "description": "Area: Custom and system allocators"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 1049491442, "node_id": "MDU6TGFiZWwxMDQ5NDkxNDQy", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-heavy", "name": "I-heavy", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to binary size of generated code."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 12, "created_at": "2018-12-18T02:11:59Z", "updated_at": "2019-04-14T18:34:11Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I noticed this in Firefox (where we do build with `-C lto -C opt-level=2`). Essentially any use of an API that ends up calling __rust_realloc generates useless code. A small testcase is:\r\n```rust\r\n#[no_mangle]\r\npub extern \"C\" fn qux(v: &mut Vec<usize>) {\r\n    v.push(42);\r\n}\r\n```\r\nwhich, with the following `Cargo.toml` config:\r\n```\r\n[profile.release]\r\nlto = true\r\nopt-level = 2\r\npanic = \"abort\"\r\ncodegen-units = 1\r\nrpath = false\r\n\r\n[lib]\r\ncrate-type = [\"cdylib\"]\r\n```\r\n\r\ngenerates the following assembly:\r\n```asm\r\n0000000000003200 <qux>:\r\n    3200:       55                      push   %rbp\r\n    3201:       41 57                   push   %r15\r\n    3203:       41 56                   push   %r14\r\n    3205:       41 55                   push   %r13\r\n    3207:       41 54                   push   %r12\r\n    3209:       53                      push   %rbx\r\n    320a:       50                      push   %rax\r\n    320b:       49 89 fd                mov    %rdi,%r13\r\n    320e:       48 8b 4f 10             mov    0x10(%rdi),%rcx\r\n    3212:       48 3b 4f 08             cmp    0x8(%rdi),%rcx\r\n    3216:       75 55                   jne    326d <qux+0x6d>\r\n    3218:       49 89 ce                mov    %rcx,%r14\r\n    321b:       49 83 c6 01             add    $0x1,%r14\r\n    321f:       0f 82 e2 00 00 00       jb     3307 <qux+0x107>\r\n    3225:       48 8d 04 09             lea    (%rcx,%rcx,1),%rax\r\n    3229:       49 39 c6                cmp    %rax,%r14\r\n    322c:       4c 0f 42 f0             cmovb  %rax,%r14\r\n    3230:       ba 08 00 00 00          mov    $0x8,%edx\r\n    3235:       45 31 ff                xor    %r15d,%r15d\r\n    3238:       4c 89 f0                mov    %r14,%rax\r\n    323b:       48 f7 e2                mul    %rdx\r\n    323e:       49 89 c4                mov    %rax,%r12\r\n    3241:       0f 91 c0                setno  %al\r\n    3244:       0f 80 bd 00 00 00       jo     3307 <qux+0x107>\r\n    324a:       41 88 c7                mov    %al,%r15b\r\n    324d:       49 c1 e7 03             shl    $0x3,%r15\r\n    3251:       48 85 c9                test   %rcx,%rcx\r\n    3254:       74 1d                   je     3273 <qux+0x73>\r\n    3256:       49 8b 6d 00             mov    0x0(%r13),%rbp\r\n    325a:       4d 85 e4                test   %r12,%r12\r\n    325d:       74 3f                   je     329e <qux+0x9e>\r\n    325f:       48 89 ef                mov    %rbp,%rdi\r\n    3262:       4c 89 e6                mov    %r12,%rsi\r\n    3265:       ff 15 35 2d 02 00       callq  *0x22d35(%rip)        # 25fa0 <realloc@GLIBC_2.2.5>\r\n    326b:       eb 6a                   jmp    32d7 <qux+0xd7>\r\n    326d:       49 8b 5d 00             mov    0x0(%r13),%rbx\r\n    3271:       eb 78                   jmp    32eb <qux+0xeb>\r\n    3273:       4d 39 e7                cmp    %r12,%r15\r\n    3276:       76 56                   jbe    32ce <qux+0xce>\r\n    3278:       48 c7 04 24 00 00 00    movq   $0x0,(%rsp)\r\n    327f:       00 \r\n    3280:       48 89 e7                mov    %rsp,%rdi\r\n    3283:       4c 89 fe                mov    %r15,%rsi\r\n    3286:       4c 89 e2                mov    %r12,%rdx\r\n    3289:       ff 15 39 2d 02 00       callq  *0x22d39(%rip)        # 25fc8 <posix_memalign@GLIBC_2.2.5>\r\n    328f:       85 c0                   test   %eax,%eax\r\n    3291:       75 7b                   jne    330e <qux+0x10e>\r\n    3293:       48 8b 1c 24             mov    (%rsp),%rbx\r\n    3297:       48 85 db                test   %rbx,%rbx\r\n    329a:       75 43                   jne    32df <qux+0xdf>\r\n    329c:       eb 70                   jmp    330e <qux+0x10e>\r\n    329e:       48 c7 04 24 00 00 00    movq   $0x0,(%rsp)\r\n    32a5:       00 \r\n    32a6:       48 89 e7                mov    %rsp,%rdi\r\n    32a9:       be 08 00 00 00          mov    $0x8,%esi\r\n    32ae:       31 d2                   xor    %edx,%edx\r\n    32b0:       ff 15 12 2d 02 00       callq  *0x22d12(%rip)        # 25fc8 <posix_memalign@GLIBC_2.2.5>\r\n    32b6:       85 c0                   test   %eax,%eax\r\n    32b8:       75 54                   jne    330e <qux+0x10e>\r\n    32ba:       48 8b 1c 24             mov    (%rsp),%rbx\r\n    32be:       48 85 db                test   %rbx,%rbx\r\n    32c1:       74 4b                   je     330e <qux+0x10e>\r\n    32c3:       48 89 ef                mov    %rbp,%rdi\r\n    32c6:       ff 15 d4 2b 02 00       callq  *0x22bd4(%rip)        # 25ea0 <free@GLIBC_2.2.5>\r\n    32cc:       eb 11                   jmp    32df <qux+0xdf>\r\n    32ce:       4c 89 e7                mov    %r12,%rdi\r\n    32d1:       ff 15 a9 2c 02 00       callq  *0x22ca9(%rip)        # 25f80 <malloc@GLIBC_2.2.5>\r\n    32d7:       48 89 c3                mov    %rax,%rbx\r\n    32da:       48 85 db                test   %rbx,%rbx\r\n    32dd:       74 2f                   je     330e <qux+0x10e>\r\n    32df:       49 89 5d 00             mov    %rbx,0x0(%r13)\r\n    32e3:       4d 89 75 08             mov    %r14,0x8(%r13)\r\n    32e7:       49 8b 4d 10             mov    0x10(%r13),%rcx\r\n    32eb:       48 c7 04 cb 2a 00 00    movq   $0x2a,(%rbx,%rcx,8)\r\n    32f2:       00 \r\n    32f3:       49 83 45 10 01          addq   $0x1,0x10(%r13)\r\n    32f8:       48 83 c4 08             add    $0x8,%rsp\r\n    32fc:       5b                      pop    %rbx\r\n    32fd:       41 5c                   pop    %r12\r\n    32ff:       41 5d                   pop    %r13\r\n    3301:       41 5e                   pop    %r14\r\n    3303:       41 5f                   pop    %r15\r\n    3305:       5d                      pop    %rbp\r\n    3306:       c3                      retq   \r\n    3307:       e8 84 9f 00 00          callq  d290 <_ZN5alloc7raw_vec17capacity_overflow17h0432b49d9a8429deE>\r\n    330c:       0f 0b                   ud2    \r\n    330e:       4c 89 e7                mov    %r12,%rdi\r\n    3311:       4c 89 fe                mov    %r15,%rsi\r\n    3314:       e8 87 9f 00 00          callq  d2a0 <_ZN5alloc5alloc18handle_alloc_error17h612a63a56f8c2099E>\r\n    3319:       0f 0b                   ud2    \r\n    331b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)\r\n```\r\n\r\nThat's a lot of code, and the most notable in here is that there's a call to `realloc`, two calls to `posix_memalign`, one to `free` and one to `malloc`.\r\n\r\nNow, to understand what's going on, let's write our own copy of the `GlobalAlloc` implementation:\r\n```rust\r\nuse std::alloc::{GlobalAlloc, Layout};\r\nuse std::cmp;\r\nuse std::ptr;\r\nuse libc;\r\n\r\n#[no_mangle]\r\npub extern \"C\" fn qux(v: &mut Vec<usize>) {\r\n    v.push(42);\r\n}\r\n\r\nstruct System;\r\n\r\nconst MIN_ALIGN: usize = 16; \r\n\r\nunsafe impl GlobalAlloc for System {\r\n    #[inline]\r\n    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\r\n        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\r\n            libc::malloc(layout.size()) as *mut u8\r\n        } else {\r\n            #[cfg(target_os = \"macos\")]\r\n            {\r\n                if layout.align() > (1 << 31) {\r\n                    return ptr::null_mut()\r\n                }\r\n            }\r\n            aligned_malloc(&layout)\r\n        }\r\n    }   \r\n\r\n    #[inline]\r\n    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\r\n        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\r\n            libc::calloc(layout.size(), 1) as *mut u8\r\n        } else {\r\n            let ptr = self.alloc(layout.clone());\r\n            if !ptr.is_null() {\r\n                ptr::write_bytes(ptr, 0, layout.size());\r\n            }\r\n            ptr\r\n        }\r\n    }   \r\n\r\n    #[inline]\r\n    unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\r\n        libc::free(ptr as *mut libc::c_void)\r\n    }   \r\n\r\n    #[inline]\r\n    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\r\n        if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\r\n            libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8\r\n        } else {\r\n            realloc_fallback(self, ptr, layout, new_size)\r\n        }\r\n    }   \r\n}\r\n\r\nunsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\r\n    let mut out = ptr::null_mut();\r\n    let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\r\n    if ret != 0 { \r\n        ptr::null_mut()\r\n    } else {\r\n        out as *mut u8\r\n    }   \r\n}\r\n\r\nunsafe fn realloc_fallback(\r\n    alloc: &System,\r\n    ptr: *mut u8, \r\n    old_layout: Layout,\r\n    new_size: usize,\r\n) -> *mut u8 {\r\n    // Docs for GlobalAlloc::realloc require this to be valid:\r\n    let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\r\n\r\n    let new_ptr = GlobalAlloc::alloc(alloc, new_layout);\r\n    if !new_ptr.is_null() {\r\n        let size = cmp::min(old_layout.size(), new_size);\r\n        ptr::copy_nonoverlapping(ptr, new_ptr, size);\r\n        GlobalAlloc::dealloc(alloc, ptr, old_layout);\r\n    }   \r\n    new_ptr\r\n}\r\n\r\n#[global_allocator]\r\nstatic HEAP: System = System;\r\n```\r\n(this compiles to the same assembly)\r\n\r\nWhat's going on here is that `layout.align()` is, in our inlined case, a constant for the alignment of `usize`, which is 8 on x86_64, so `layout.align() <= MIN_ALIGN` is always true. However, because the `new_size` given to `realloc` is not `NonZero` (despite the GlobalAlloc documentation specifying the value can never be 0), LLVM doesn't know that the condition `layout.align() <= new_size` is also always true, so it ends up creating code for both `libc::realloc` and `realloc_fallback` branches.\r\n\r\nChanging the condition in `realloc` to force `new_size == 0` to go through `libc::realloc` gets rid of the call to `free` and one call to `posix_memalign`. Sadly, doing the same with `layout.size() == 0` in `alloc` to call `libc::malloc` doesn't get right of the other `posix_memalign` call. I guess the compiler still thinks that the new size computed in `RawVec::reserve_internal` can be somewhere between `layout.align()` and `layout.size()`, which is actually not possible.\r\n\r\nAssuming we can somehow get the compiler to get rid of that useless `posix_memalign`, that still leaves us with, essentially, code doing `new_ptr = if ptr { libc::realloc(ptr, new_size) } else { libc::malloc(new_size) }`, which, considering the API guarantees of `libc::realloc`, is a branch and a function call too much, since `new_ptr = libc::realloc(ptr, new_size)` would work just as well, `libc::realloc(ptr::null_mut(), new_size)` being the same as `libc::malloc(new_size)`. Sadly, there's nothing in the Alloc API that would allow to fold this.\r\n\r\nCc: @SimonSapin ", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/56938/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/56938/timeline", "performed_via_github_app": null, "state_reason": null}