{"url": "https://api.github.com/repos/rust-lang/rust/issues/40196", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/40196/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/40196/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/40196/events", "html_url": "https://github.com/rust-lang/rust/issues/40196", "id": 211241378, "node_id": "MDU6SXNzdWUyMTEyNDEzNzg=", "number": 40196, "title": "Bizarre heisenbug on ioctl with unsafe rust", "user": {"login": "rlupton20", "id": 13752145, "node_id": "MDQ6VXNlcjEzNzUyMTQ1", "avatar_url": "https://avatars.githubusercontent.com/u/13752145?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rlupton20", "html_url": "https://github.com/rlupton20", "followers_url": "https://api.github.com/users/rlupton20/followers", "following_url": "https://api.github.com/users/rlupton20/following{/other_user}", "gists_url": "https://api.github.com/users/rlupton20/gists{/gist_id}", "starred_url": "https://api.github.com/users/rlupton20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rlupton20/subscriptions", "organizations_url": "https://api.github.com/users/rlupton20/orgs", "repos_url": "https://api.github.com/users/rlupton20/repos", "events_url": "https://api.github.com/users/rlupton20/events{/privacy}", "received_events_url": "https://api.github.com/users/rlupton20/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2017-03-01T23:24:59Z", "updated_at": "2017-03-02T21:04:30Z", "closed_at": "2017-03-02T21:04:30Z", "author_association": "NONE", "active_lock_reason": null, "body": "```\r\n$ rustc --version\r\nrustc 1.11.0\r\n\r\n$ cargo --version\r\ncargo 0.12.0 (built 2016-12-03)\r\n```\r\n(installed using nix on nixos 16.09 stable channel).\r\n\r\nI've been playing with `libc` to construct a basic rust tun/tap driver so I can play around with network protocols, and noticed at some point after refactoring my little toy, my call to `ioctl` stopped working (returning a `-1` error rather than expected `0`).\r\n\r\nI dropped back through my commits to find an early working version, and compared the values being passed to `ioctl` and verified that they were the same. Interestingly however, I noticed that adding a simple `println!` call before the `ioctl` on the previously succeeding version caused it to fail.\r\n\r\nFor instance:\r\n```\r\nfn main() {\r\n    let mut ifreq : IfReq = IfReq::from_name(\"toytap\").unwrap();\r\n    ifreq.ifr_flags(IFFTAP | IFF_NO_PI);\r\n\r\n    match OpenOptions::new().write(true).open(\"/dev/net/tun\") {\r\n        Ok(t) => {\r\n            unsafe {\r\n                let fd : c_int = t.into_raw_fd();\r\n                let rc : i32 = ioctl(fd, TUNSETIFF, ifreq);\r\n                println!(\"{}\", rc);\r\n            }\r\n        }\r\n        Err(e) => println!(\"Failed to open tun device: {}\", e)\r\n    }\r\n\r\n}\r\n```\r\nprints `rc` out as `0`\r\n\r\nwhile\r\n\r\n```\r\nfn main() {\r\n    let mut ifreq : IfReq = IfReq::from_name(\"toytap\").unwrap();\r\n    ifreq.ifr_flags(IFFTAP | IFF_NO_PI);\r\n\r\n    match OpenOptions::new().write(true).open(\"/dev/net/tun\") {\r\n        Ok(t) => {\r\n            unsafe {\r\n                let fd : c_int = t.into_raw_fd();\r\n                println!(\"One day I'll catch you!\");\r\n                let rc : i32 = ioctl(fd, TUNSETIFF, ifreq);\r\n                println!(\"{}\", rc);\r\n            }\r\n        }\r\n        Err(e) => println!(\"Failed to open tun device: {}\", e)\r\n    }\r\n\r\n}\r\n```\r\nprints out `rc` as `-1`. A real life heisenbug!\r\n\r\nI can see there is a possibility this is an issue with `libc`, yet I somehow doubt it. Also, I understand there may well be quirks with unsafe rust which I've blindly stumbled into here, but I would only expect that if I were to start mangling bits of memory explicitly, and the above just doesn't look suspicious enough to me.\r\n\r\nUnfortunately this means my nice (to my eye anyway) rust code isn't working, so I'll give my little evening-hack version below if anyone is interested in reproducing it. It assumes a TAP device named `toytap` to be available for use by the user - adjust as necessary.\r\n\r\n```\r\nextern crate libc;\r\n\r\nuse std::fs::OpenOptions;\r\nuse std::os::unix::io::IntoRawFd;\r\nuse libc::{c_int, c_char, c_short, ioctl, IF_NAMESIZE};\r\n\r\nstatic IFFTAP : c_short = 2;\r\nstatic IFF_NO_PI : c_short = 4096;\r\nstatic TUNSETIFF : u64 = 1074025674; // Need to check this\r\n\r\n#[repr(C)]\r\nstruct IfReq {\r\n    ifr_name : [c_char; IF_NAMESIZE],\r\n    union : [u8; 24]\r\n}\r\n\r\nimpl IfReq {\r\n    fn ifr_flags(&mut self, flags : c_short) {\r\n        // Zero the flags and copy the two bytes of flags\r\n        self.union = [0; 24];\r\n        self.union[0] = flags as u8;\r\n        self.union[1] = (flags << 8) as u8;\r\n    }\r\n\r\n    fn new() -> Self {\r\n        let name : [c_char ; IF_NAMESIZE] = [0 as c_char ; IF_NAMESIZE];\r\n        IfReq {\r\n            ifr_name : name,\r\n            union : [0 ; 24]\r\n        }\r\n    }\r\n\r\n    fn from_name(name : &str) -> Option<IfReq> {\r\n        if name.len() >= IF_NAMESIZE {\r\n            None\r\n        }\r\n        else {\r\n            let mut ifreq : IfReq = IfReq::new();\r\n            for (i,c) in name.as_bytes().iter().enumerate() {\r\n                ifreq.ifr_name[i] = *c as c_char;\r\n            }\r\n            Some(ifreq)\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\nfn main() {\r\n    let mut ifreq : IfReq = IfReq::from_name(\"toytap\").unwrap();\r\n    ifreq.ifr_flags(IFFTAP | IFF_NO_PI);\r\n\r\n    match OpenOptions::new().write(true).open(\"/dev/net/tun\") {\r\n        Ok(t) => {\r\n            unsafe {\r\n                let fd : c_int = t.into_raw_fd();\r\n                // INSERT PRINT STATEMENT HERE\r\n                let rc : i32 = ioctl(fd, TUNSETIFF, ifreq);\r\n                println!(\"{}\", rc);\r\n            }\r\n        }\r\n        Err(e) => println!(\"Failed to open tun device: {}\", e)\r\n    }\r\n\r\n}\r\n\r\n```", "closed_by": {"login": "rlupton20", "id": 13752145, "node_id": "MDQ6VXNlcjEzNzUyMTQ1", "avatar_url": "https://avatars.githubusercontent.com/u/13752145?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rlupton20", "html_url": "https://github.com/rlupton20", "followers_url": "https://api.github.com/users/rlupton20/followers", "following_url": "https://api.github.com/users/rlupton20/following{/other_user}", "gists_url": "https://api.github.com/users/rlupton20/gists{/gist_id}", "starred_url": "https://api.github.com/users/rlupton20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rlupton20/subscriptions", "organizations_url": "https://api.github.com/users/rlupton20/orgs", "repos_url": "https://api.github.com/users/rlupton20/repos", "events_url": "https://api.github.com/users/rlupton20/events{/privacy}", "received_events_url": "https://api.github.com/users/rlupton20/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/40196/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/40196/timeline", "performed_via_github_app": null, "state_reason": "completed"}