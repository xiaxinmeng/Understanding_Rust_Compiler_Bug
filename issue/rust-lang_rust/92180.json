{"url": "https://api.github.com/repos/rust-lang/rust/issues/92180", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/92180/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/92180/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/92180/events", "html_url": "https://github.com/rust-lang/rust/issues/92180", "id": 1086248517, "node_id": "I_kwDOAAsO6M5AvtZF", "number": 92180, "title": "`-Zmacro-backtrace` gets confused when macros define other macros", "user": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 235791, "node_id": "MDU6TGFiZWwyMzU3OTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-diagnostics", "name": "A-diagnostics", "color": "f7e101", "default": false, "description": "Area: Messages for errors, warnings, and lints"}, {"id": 132910982, "node_id": "MDU6TGFiZWwxMzI5MTA5ODI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-macros", "name": "A-macros", "color": "f7e101", "default": false, "description": "Area: All kinds of macros (custom derive, macro_rules!, proc macros, ..)"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 1359848690, "node_id": "MDU6TGFiZWwxMzU5ODQ4Njkw", "url": "https://api.github.com/repos/rust-lang/rust/labels/E-needs-mcve", "name": "E-needs-mcve", "color": "02e10c", "default": false, "description": "Call for participation: This issue needs a Minimal Complete and Verifiable Example"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2021-12-21T21:35:29Z", "updated_at": "2021-12-21T21:44:35Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "Given the following code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=49b4f59c6307c22b5f5705f3bbf48205\r\n\r\n<details>\r\n\r\n```rust\r\n#![crate_type = \"lib\"]\r\n\r\nmacro_rules! define_state_group {\r\n    ( $name:ident = { $($states:tt)+ } ) => {\r\n        macro_rules! $name {\r\n            () => {\r\n                state!($($states)+);\r\n            };\r\n        }\r\n    };\r\n}\r\n\r\nmacro_rules! state {\r\n    (\r\n        $name:ident $(<-- ( $($enter_actions:tt)* ))* {\r\n            $($arms:tt)*\r\n        }\r\n\r\n        $($rest:tt)*\r\n    ) => {\r\n        fn $name(&mut self, input: &[u8]) -> StateResult {\r\n            loop {\r\n                let ch = self.consume_ch(input);\r\n\r\n                state_body!(|[self, input, ch]|> [$($arms)*], [$($($enter_actions)*)*]);\r\n            }\r\n        }\r\n\r\n        state!($($rest)*);\r\n    };\r\n\r\n    // NOTE: end of the state list\r\n    () => ();\r\n}\r\n\r\nmacro_rules! state_body {\r\n    ( | [ $self:tt, $input:ident, $ch:ident ] |> [$($arms:tt)+], [$($enter_actions:tt)*] ) => {\r\n        action_list!(@state_enter |$self, $input|> $($enter_actions)*);\r\n        state_body!(@map_arms | [$self, $input, $ch] |> [$($arms)+], [])\r\n    };\r\n\r\n\r\n    // Recursively expand each arm's pattern\r\n    //--------------------------------------------------------------------\r\n    ( @map_arms\r\n        | $scope_vars:tt |>\r\n        [ $pat:tt => ( $($actions:tt)* ) $($rest:tt)* ], [ $($expanded:tt)* ]\r\n    ) => {\r\n        arm_pattern!(|[ $scope_vars, [$($rest)*], [$($expanded)*] ]|> $pat => ( $($actions)* ))\r\n    };\r\n\r\n    ( @map_arms\r\n        | $scope_vars:tt |>\r\n        [], [$($expanded:tt)*]\r\n    ) => {\r\n        state_body!(@match_block |$scope_vars|> $($expanded)*);\r\n    };\r\n\r\n\r\n    // Callback for the expand_arm_pattern\r\n    //--------------------------------------------------------------------\r\n    ( @callback\r\n        | [ $scope_vars:tt, [$($pending:tt)*], [$($expanded:tt)*] ] |>\r\n        $($expanded_arm:tt)*\r\n    ) => {\r\n        state_body!(@map_arms | $scope_vars |> [$($pending)*], [$($expanded)* $($expanded_arm)*])\r\n    };\r\n\r\n\r\n    // Character match block\r\n    //--------------------------------------------------------------------\r\n    ( @match_block\r\n        | [ $self:tt, $input:ident, $ch:ident ] |>\r\n        $( $pat:pat $(|$pat_cont:pat)* $(if $pat_expr:expr)* => ( $($actions:tt)* ) )*\r\n    ) => {\r\n        // NOTE: guard against unreachable patterns\r\n        // (e.g. such may occur if `eof => ...` arm comes before `eoc => ...` arm.)\r\n        #[deny(unreachable_patterns)]\r\n        match $ch {\r\n            $(\r\n                $pat $(| $pat_cont)* $(if $pat_expr)* => {\r\n                    action_list!(|$self, $input|> $($actions)*);\r\n                }\r\n            )*\r\n        }\r\n    };\r\n}\r\n\r\nmacro_rules! action_list {\r\n    ( | $self:tt, $input:ident |>\r\n        if $cond:ident\r\n            ( $($if_actions:tt)* )\r\n        else\r\n            ( $($else_actions:tt)* )\r\n    ) => {\r\n        if $self.$cond() {\r\n            action_list!(| $self, $input |> $($if_actions)*);\r\n        } else {\r\n            action_list!(| $self, $input |> $($else_actions)*);\r\n        }\r\n    };\r\n\r\n    ( | $self:tt, $input:ident |> { $($code_block:tt)* } ) => ( $($code_block)* );\r\n\r\n    ( | $self:tt, $input:ident |> $action:ident $($args:expr),*; $($rest:tt)* ) => {\r\n        trace!(@actions $action $($args:expr)*);\r\n        action!(| $self, $input |> $action $($args),*);\r\n        action_list!(| $self, $input |> $($rest)*);\r\n    };\r\n\r\n     ( | $self:tt, $input:ident |> $action:ident ? $($args:expr),*; $($rest:tt)* ) => {\r\n        trace!(@actions $action $($args:expr)*);\r\n        action!(| $self, $input |> $action ? $($args),*);\r\n        action_list!(| $self, $input |> $($rest)*);\r\n    };\r\n\r\n    // NOTE: state transition should always be in the end of the action list\r\n    ( | $self:tt, $input:ident|> $($transition:tt)+ ) => {\r\n        trace!(@actions $($transition)+);\r\n        action!(@state_transition | $self, $input |> $($transition)+);\r\n    };\r\n\r\n    // NOTE: end of the action list\r\n    ( | $self:tt, $input:ident |> ) => ();\r\n\r\n\r\n    // State enter action list\r\n    //--------------------------------------------------------------------\r\n    ( @state_enter | $self:tt, $input:ident |> $($actions:tt)+ ) => {\r\n        if $self.is_state_enter() {\r\n            action_list!(|$self, $input|> $($actions)*);\r\n            $self.set_is_state_enter(false);\r\n        }\r\n    };\r\n\r\n    // NOTE: don't generate any code for the empty action list\r\n    ( @state_enter | $self:tt, $input:ident |> ) => ();\r\n}\r\n\r\ndefine_state_group!(rawtext_states_group = {\r\n\r\n    rawtext_state {\r\n        b'<' => ( emit_text?; mark_tag_start; --> rawtext_less_than_sign_state )\r\n        eoc  => ( emit_text?; )\r\n        eof  => ( emit_text?; emit_eof?; )\r\n        _    => ()\r\n    }\r\n\r\n    rawtext_less_than_sign_state {\r\n        b'/' => ( --> rawtext_end_tag_open_state )\r\n        eof  => ( emit_text?; emit_eof?; )\r\n        _    => ( unmark_tag_start; emit_text?; reconsume in rawtext_state )\r\n    }\r\n\r\n    rawtext_end_tag_open_state {\r\n        alpha => ( create_end_tag; start_token_part; update_tag_name_hash; --> rawtext_end_tag_name_state )\r\n        eof   => ( emit_text?; emit_eof?; )\r\n        _     => ( unmark_tag_start; emit_text?; reconsume in rawtext_state )\r\n    }\r\n\r\n    rawtext_end_tag_name_state {\r\n        whitespace => (\r\n            if is_appropriate_end_tag\r\n                ( finish_tag_name?; --> before_attribute_name_state )\r\n            else\r\n                ( unmark_tag_start; emit_text?; reconsume in rawtext_state )\r\n        )\r\n\r\n        b'/' => (\r\n            if is_appropriate_end_tag\r\n                ( --> self_closing_start_tag_state )\r\n            else\r\n                ( unmark_tag_start; emit_text?; reconsume in rawtext_state )\r\n        )\r\n\r\n        b'>' => (\r\n            if is_appropriate_end_tag\r\n                ( emit_tag?; --> dyn next_text_parsing_state )\r\n            else\r\n                ( unmark_tag_start; emit_text?; reconsume in rawtext_state )\r\n        )\r\n\r\n        alpha => ( update_tag_name_hash; )\r\n        eof   => ( emit_text?; emit_eof?; )\r\n        _     => ( unmark_tag_start; emit_text?; reconsume in rawtext_state )\r\n    }\r\n\r\n});\r\n\r\n// #[macro_use]\r\n// mod ch_sequence;\r\n\r\nmacro_rules! arm_pattern {\r\n    ( | $cb_args:tt |>\r\n         alpha => $actions:tt\r\n    ) => {\r\n        state_body!(@callback | $cb_args |> Some(b'a'..=b'z') | Some(b'A'..=b'Z') => $actions);\r\n    };\r\n\r\n    ( | $cb_args:tt |>\r\n        whitespace => $actions:tt\r\n    ) => {\r\n        state_body!(@callback | $cb_args |>\r\n            Some(b' ') | Some(b'\\n') | Some(b'\\r') | Some(b'\\t') | Some(b'\\x0C') => $actions\r\n        );\r\n    };\r\n\r\n    ( | [ [$self:tt, $input_chunk:ident, $ch:ident ], $($rest_cb_args:tt)+ ] |>\r\n        closing_quote => $actions:tt\r\n    ) => {\r\n        state_body!(@callback | [ [$self, $input_chunk, $ch], $($rest_cb_args)+ ] |>\r\n            Some(ch) if ch == $self.closing_quote() => $actions\r\n        );\r\n    };\r\n\r\n\r\n    ( | [ [$self:tt, $input:ident, $ch:ident ], $($rest_cb_args:tt)+ ] |>\r\n        eoc => ( $($actions:tt)* )\r\n    ) => {\r\n        state_body!(@callback | [ [$self, $input, $ch], $($rest_cb_args)+ ] |>\r\n            None if !$self.is_last_input() => ({\r\n                action_list!(|$self, $input|> $($actions)* );\r\n\r\n                return $self.break_on_end_of_input($input);\r\n            })\r\n        );\r\n    };\r\n\r\n    // NOTE: this arm is always enforced by the compiler to make match exhaustive,\r\n    // so it's safe to break parsing loop here, since we don't have any input left\r\n    // to parse. We execute EOF actions only if it's a last input, otherwise we just\r\n    // break the parsing loop if it hasn't been done by the explicit EOC arm.\r\n    ( | [ [$self:tt, $input:ident, $ch:ident ], $($rest_cb_args:tt)+ ] |>\r\n        eof => ( $($actions:tt)* )\r\n    ) => {\r\n        state_body!(@callback | [ [$self, $input, $ch], $($rest_cb_args)+ ] |>\r\n            None => ({\r\n                if $self.is_last_input() {\r\n                    action_list!(|$self, $input|> $($actions)* );\r\n                }\r\n\r\n                return $self.break_on_end_of_input($input);\r\n            })\r\n        );\r\n    };\r\n\r\n    ( | [ $scope_vars:tt, $($rest_cb_args:tt)+ ] |>\r\n        [ $seq_pat:tt $(; $case_mod:ident)* ] => $actions:tt\r\n    ) => {\r\n        // NOTE: character sequence arm should be expanded in\r\n        // place before we hit the character match block.\r\n        ch_sequence_arm_pattern!(|$scope_vars|> $seq_pat, $actions, $($case_mod)* );\r\n        state_body!(@callback | [ $scope_vars, $($rest_cb_args)+ ] |>);\r\n    };\r\n\r\n    ( | $cb_args:tt |> $pat:pat => $actions:tt ) => {\r\n        state_body!(@callback | $cb_args |> Some($pat) => $actions);\r\n    };\r\n}\r\n\r\nmacro_rules! action {\r\n    (| $self:tt, $input:ident | > $action_fn:ident ? $($args:expr),* ) => {\r\n        $self.$action_fn($input $(,$args),*).map_err(ParsingTermination::ActionError)?;\r\n    };\r\n\r\n    (| $self:tt, $input:ident | > $action_fn:ident $($args:expr),* ) => {\r\n        $self.$action_fn($input $(,$args),*);\r\n    };\r\n\r\n    ( @state_transition | $self:tt, $input:ident | > reconsume in $state:ident) => {\r\n        $self.unconsume_ch();\r\n        action!(@state_transition | $self, $input | > --> $state);\r\n    };\r\n\r\n    ( @state_transition | $self:tt, $input:ident | > - -> $state:ident) => {\r\n        $self.switch_state(Self::$state);\r\n        return Ok(());\r\n    };\r\n\r\n    ( @state_transition | $self:tt, $input:ident | > - -> dyn $state_getter:ident) => {\r\n        {\r\n            let state = $self.$state_getter();\r\n            $self.switch_state(state);\r\n        }\r\n\r\n        return Ok(());\r\n    };\r\n}\r\n\r\nmacro_rules! trace {\r\n    ( $($args:tt)+ ) => {\r\n    }\r\n}\r\n\r\nuse std::error::Error;\r\n\r\ntype StateResult = Result<(), ParsingTermination>;\r\ntype ActionResult = Result<(), Box<dyn Error>>;\r\n// type ActionResult = Result<(), Box<dyn Error>>;\r\nstruct Parser;\r\ntype State = fn(&mut Parser, &[u8]) -> StateResult;\r\nenum ParsingTermination {\r\n    ActionError(Box<dyn Error>)\r\n}\r\n\r\nimpl Parser {\r\n    rawtext_states_group!();\r\n\r\n    fn consume_ch(&mut self, input: &[u8]) -> Option<u8> {\r\n        loop {}\r\n    }\r\n    fn unconsume_ch(&mut self) {}\r\n    fn break_on_end_of_input(&mut self, input: &[u8]) -> StateResult {\r\n        loop {}\r\n    }\r\n    fn is_last_input(&mut self) -> bool {\r\n        loop {}\r\n    }\r\n    fn is_appropriate_end_tag(&mut self) -> bool {\r\n        loop {}\r\n    }\r\n    fn switch_state(&mut self, state: State) {}\r\n    fn emit_text(&mut self, input: &[u8]) -> ActionResult {\r\n        loop {}\r\n    }\r\n    fn unmark_tag_start(&mut self, _input: &[u8]) {}\r\n    fn emit_eof(&mut self, input: &[u8]) -> ActionResult {\r\n        loop {}\r\n    }\r\n    fn update_tag_name_hash(&mut self, input: &[u8]) {}\r\n    fn emit_tag(&mut self, _input: &[u8]) -> ActionResult {\r\n        loop {}\r\n    }\r\n    fn next_text_parsing_state(&self) -> fn(&mut Self, &[u8]) -> StateResult {\r\n        loop {}\r\n    }\r\n    fn finish_tag_name<S>(&mut self, input: &[u8], tag_hint_sink: S) -> ActionResult {\r\n        loop {}\r\n    }\r\n    fn self_closing_start_tag_state(&mut self, input: &[u8]) -> StateResult {\r\n        loop {}\r\n    }\r\n    fn before_attribute_name_state(&mut self, input: &[u8]) -> StateResult {\r\n        loop {}\r\n    }\r\n    fn start_token_part(&mut self, input: &[u8]) -> StateResult {\r\n        loop {}\r\n    }\r\n    fn create_end_tag(&mut self, _input: &[u8]) {\r\n        loop {}\r\n    }\r\n    fn mark_tag_start(&mut self, input: &[u8]) {\r\n        loop {}\r\n    }\r\n}\r\n```\r\n\r\n</details>\r\n\r\nThe current output with `-Zmacro-backtrace=yes`:\r\n\r\n```\r\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\r\n   --> src/parser/state_machine/syntax_dsl/backtrace.rs:164:19\r\n    |\r\n5   | /         macro_rules! $name {\r\n6   | |             () => {\r\n7   | |                 state!($($states)+);\r\n8   | |             };\r\n9   | |         }\r\n    | |_________- in this expansion of `rawtext_states_group!`\r\n...\r\n164 |                   ( finish_tag_name?; --> before_attribute_name_state )\r\n    |                     ^^^^^^^^^^^^^^^ expected 2 arguments\r\n...\r\n263 |           $self.$action_fn($input $(,$args),*).map_err(ParsingTermination::ActionErr...\r\n    |                            ------ supplied 1 argument\r\n...\r\n307 |       rawtext_states_group!();\r\n    |       ----------------------- in this macro invocation\r\n    |\r\nnote: associated function defined here\r\n   --> src/parser/state_machine/syntax_dsl/backtrace.rs:337:8\r\n    |\r\n337 |     fn finish_tag_name<S>(&mut self, input: &[u8], tag_hint_sink: S) -> ActionResult {\r\n    |        ^^^^^^^^^^^^^^^    ---------  ------------  ----------------=\r\n```\r\n\r\n<!-- The following is not always necessary. -->\r\nIdeally the output should include at least the expansion of `state!` and `state_body!`; right now it only shows `define_state_group!`, `rawtext_states_group!`, and `action!`.\r\n\r\n(I'll try to reduce this, but I only have so much time to work on this.)\r\n\r\ncc @estebank\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/92180/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/92180/timeline", "performed_via_github_app": null, "state_reason": null}