{"url": "https://api.github.com/repos/rust-lang/rust/issues/50279", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/50279/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/50279/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/50279/events", "html_url": "https://github.com/rust-lang/rust/issues/50279", "id": 318374624, "node_id": "MDU6SXNzdWUzMTgzNzQ2MjQ=", "number": 50279, "title": "Error message regarding BinaryHeap::peek() is misleading...", "user": {"login": "ghost", "id": 10137, "node_id": "MDQ6VXNlcjEwMTM3", "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ghost", "html_url": "https://github.com/ghost", "followers_url": "https://api.github.com/users/ghost/followers", "following_url": "https://api.github.com/users/ghost/following{/other_user}", "gists_url": "https://api.github.com/users/ghost/gists{/gist_id}", "starred_url": "https://api.github.com/users/ghost/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ghost/subscriptions", "organizations_url": "https://api.github.com/users/ghost/orgs", "repos_url": "https://api.github.com/users/ghost/repos", "events_url": "https://api.github.com/users/ghost/events{/privacy}", "received_events_url": "https://api.github.com/users/ghost/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-04-27T11:29:54Z", "updated_at": "2018-04-27T14:21:27Z", "closed_at": "2018-04-27T14:21:27Z", "author_association": "NONE", "active_lock_reason": null, "body": "The following code works as expected. See the comment in the code below:\r\n```\r\nuse std::collections::BinaryHeap;\r\n\r\nfn perform_operations(xs : &mut Vec<i64>) -> u64 {\r\n    let mut heap = BinaryHeap::new();\r\n    for i in 0 .. xs.len() {\r\n        heap.push((- xs[i], - (i as i64)));\r\n    }\r\n    loop {\r\n        let heap_size = heap.len();\r\n        if heap_size >= 2 {\r\n            let h_1 = heap.pop().unwrap();\r\n            // ----------------------------------------------------------------\r\n            // NOTE: This code works. Note the &h_2 on the LHS of the let\r\n            // statement.\r\n            // ----------------------------------------------------------------\r\n            let &h_2 = heap.peek().unwrap();\r\n            if h_1.0 == h_2.0 {\r\n                heap.pop();\r\n                let l_idx = (- h_1.1) as usize;\r\n                let r_idx = (- h_2.1) as usize;\r\n                xs[l_idx] = 0;\r\n                xs[r_idx] = 2 * xs[r_idx];\r\n                heap.push((- xs[r_idx], - (r_idx as i64)));\r\n            } \r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    let mut n = 0;\r\n    for &mut x in xs {\r\n        if x > 0 {\r\n            n = n + 1;\r\n        }\r\n    }\r\n    n\r\n}\r\n\r\nfn main() {\r\n    let mut xs = vec![3, 4, 1, 2, 2, 1, 1];\r\n    let r = perform_operations(&mut xs);\r\n    println!(\"{}\", r);\r\n    let mut first = true;\r\n    for x in xs {\r\n        if x > 0 {\r\n            if first {\r\n                first = false;\r\n                print!(\"{}\", x);\r\n            } else {\r\n                print!(\" {}\", x);\r\n            }\r\n        }\r\n    }\r\n    println!();\r\n}\r\n```\r\nNow, let us make a small change, let change &h_2 in the let statement to h_2.\r\n\r\n```\r\nuse std::collections::BinaryHeap;\r\n\r\nfn perform_operations(xs : &mut Vec<i64>) -> u64 {\r\n    let mut heap = BinaryHeap::new();\r\n    for i in 0 .. xs.len() {\r\n        heap.push((- xs[i], - (i as i64)));\r\n    }\r\n    loop {\r\n        let heap_size = heap.len();\r\n        if heap_size >= 2 {\r\n            let h_1 = heap.pop().unwrap();\r\n            // ----------------------------------------------------------------\r\n            // NOTE: This code does not compile. Note the h_2 on the LHS of the\r\n            // let statement. The compiler errors are unhelpful and confusing,\r\n            // we would expect the compiler to just provide help saying,\r\n            // convert h_2 to &h_2.\r\n            // ----------------------------------------------------------------\r\n            let h_2 = heap.peek().unwrap();\r\n            if h_1.0 == h_2.0 {\r\n                heap.pop();\r\n                let l_idx = (- h_1.1) as usize;\r\n                let r_idx = (- h_2.1) as usize;\r\n                xs[l_idx] = 0;\r\n                xs[r_idx] = 2 * xs[r_idx];\r\n                heap.push((- xs[r_idx], - (r_idx as i64)));\r\n            } \r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    let mut n = 0;\r\n    for &mut x in xs {\r\n        if x > 0 {\r\n            n = n + 1;\r\n        }\r\n    }\r\n    n\r\n}\r\n\r\nfn main() {\r\n    let mut xs = vec![3, 4, 1, 2, 2, 1, 1];\r\n    let r = perform_operations(&mut xs);\r\n    println!(\"{}\", r);\r\n    let mut first = true;\r\n    for x in xs {\r\n        if x > 0 {\r\n            if first {\r\n                first = false;\r\n                print!(\"{}\", x);\r\n            } else {\r\n                print!(\" {}\", x);\r\n            }\r\n        }\r\n    }\r\n    println!();\r\n}\r\n```\r\n\r\nHere is the compiler error:\r\n\r\n```\r\nerror[E0502]: cannot borrow `heap` as mutable because it is also borrowed as immutable\r\n  --> src/main.rs:18:17\r\n   |\r\n16 |             let h_2 = heap.peek().unwrap();\r\n   |                       ---- immutable borrow occurs here\r\n17 |             if h_1.0 == h_2.0 {\r\n18 |                 heap.pop();\r\n   |                 ^^^^ mutable borrow occurs here\r\n...\r\n25 |         } else {\r\n   |         - immutable borrow ends here\r\n\r\nerror[E0502]: cannot borrow `heap` as mutable because it is also borrowed as immutable\r\n  --> src/main.rs:23:17\r\n   |\r\n16 |             let h_2 = heap.peek().unwrap();\r\n   |                       ---- immutable borrow occurs here\r\n...\r\n23 |                 heap.push((- xs[r_idx], - (r_idx as i64)));\r\n   |                 ^^^^ mutable borrow occurs here\r\n24 |             } \r\n25 |         } else {\r\n   |         - immutable borrow ends here\r\n\r\n```\r\n\r\nCan someone explain how adding an & on the LHS affect the borrow status of the heap object?", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/50279/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/50279/timeline", "performed_via_github_app": null, "state_reason": "completed"}