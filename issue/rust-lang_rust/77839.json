{"url": "https://api.github.com/repos/rust-lang/rust/issues/77839", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/77839/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/77839/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/77839/events", "html_url": "https://github.com/rust-lang/rust/issues/77839", "id": 718966960, "node_id": "MDU6SXNzdWU3MTg5NjY5NjA=", "number": 77839, "title": "Tracking issue for WebAssembly atomics", "user": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 474645165, "node_id": "MDU6TGFiZWw0NzQ2NDUxNjU=", "url": "https://api.github.com/repos/rust-lang/rust/labels/O-wasm", "name": "O-wasm", "color": "6e6ec0", "default": false, "description": "Target: WASM (WebAssembly), http://webassembly.org/"}, {"id": 650846969, "node_id": "MDU6TGFiZWw2NTA4NDY5Njk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-tracking-issue", "name": "C-tracking-issue", "color": "f5f1fd", "default": false, "description": "Category: A tracking issue for an RFC or an unstable feature."}, {"id": 2352122097, "node_id": "MDU6TGFiZWwyMzUyMTIyMDk3", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-discussion", "name": "C-discussion", "color": "f5f1fd", "default": false, "description": "Category: Discussion or questions that doesn't represent real issues."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2020-10-12T00:50:04Z", "updated_at": "2023-05-04T11:22:30Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "This is an issue intended to track the state of WebAssembly atomics support in Rust. For the WebAssembly target there is the [threads proposal in WebAssembly](https://github.com/webassembly/threads) which adds a number of instructions and a new kind of memory to the WebAssembly specification. The new instructions largely deal with atomic memory operations (e.g. `i32.atomic.add`), but also deal with synchronization between threads (`memory.atomic.notify`). The threads proposal does *not* add an ability to spawn threads nor does it really define what threads are, but it's largely set up to have a wasm-instance-per-thread (not that this is super relevant for the standard library).\r\n\r\nAs of the time of this writing the WebAssembly threads proposal is at [stage 2 of the phases process](https://github.com/webassembly/proposals). It is [shipping in Chrome and in Firefox](https://webassembly.org/roadmap/), however.\r\n\r\nRust's support for this proposal boils down to a few things:\r\n\r\n* Primarily Rust/LLVM support the `-Ctarget-feature=+atomics` CLI flag to rustc. This causes codegen for atomic types like `std::sync::atomic` [to use the atomic instructions](https://godbolt.org/z/GGz3fq).\r\n* Rust has support for the three synchronization intrinsics:\r\n  * [`memory.atomic.notify`](https://doc.rust-lang.org/stable/core/arch/wasm32/fn.memory_atomic_notify.html)\r\n  * [`memory.atomic.wait32`](https://doc.rust-lang.org/stable/core/arch/wasm32/fn.memory_atomic_wait32.html)\r\n  * [`memory.atomic.wait64`](https://doc.rust-lang.org/stable/core/arch/wasm32/fn.memory_atomic_wait64.html)\r\n* The Rust standard library [implements mutexes differently](https://github.com/rust-lang/rust/blob/c71248b70870960af9993de4f31d3cba9bbce7e8/library/std/src/sys/wasm/mod.rs#L50-L66) based on whether the `atomics` feature is enabled for the library at compile time. Namely it has custom implementations of:\r\n  * [`Condvar`](https://github.com/rust-lang/rust/blob/master/library/std/src/sys/wasm/condvar_atomics.rs)\r\n  * [`Mutex`](https://github.com/rust-lang/rust/blob/master/library/std/src/sys/wasm/mutex_atomics.rs)\r\n  * [`RwLock`](https://github.com/rust-lang/rust/blob/master/library/std/src/sys/wasm/rwlock_atomics.rs)\r\n\r\nIn terms of toolchain, we're, as usual, inheriting a lot of the experience from LLVM as well. As usual the WebAssembly target uses LLD as the linker, but [a number of options are passed by default](https://github.com/rust-lang/rust/blob/c71248b70870960af9993de4f31d3cba9bbce7e8/compiler/rustc_codegen_ssa/src/back/linker.rs#L1041-L1072) when we're generating an executable compiled with threads (currently detected with `-Ctarget-feature=+atomics`). We instruct LLD to create a \"shared\" memory (which allows the memory to be shared across multiple wasm instances, how threading works on the web and in other engines), specifies a default maximum size for memory (this is required for shared memory, and normal wasm memories don't need to list a maximum), flags memory as being imported (since otherwise each instance would export a new memory and not share it!), and ensures that a few TLS/initialization-related symbols are exported.\r\n\r\nThe symbols are perhaps the most interesting part here, so to go into them in some more detail:\r\n\r\n* `__wasm_init_memory` - this is called once which initializes all data segments of memory (e.g. copies from `data` into `memory`). This is intended to only happen once for the lifetime of a module at the beginning.\r\n* `__wasm_init_tls` - this is a function which is intended to be called once-per-instance and initializes thread-local information from a static area. The pointer to thread-local data is passed as the first argument. The pointer must be initialized according to `__tls_size` and `__tls_align`.\r\n\r\nAlso as of today there is no dedicated target for wasm with atomics. The usage of `-Ctarget-feature=+atomics` was intended to help ship this feature ASAP on nightly Rust, but wasn't necessarily intended to be the final form of the feature. This means that if you want to use wasm and atomics you need to use Cargo's `-Zbuild-std` feature to recompiled the standard library.\r\n\r\n---\r\n\r\nOverall threads, wasm, and Rust I feel are not in a great spot. I'm unfortunately not certain about how best to move things forward. One thing we could do is to simply stabilize everything as-is and call it a day. As can be seen with memory initialization, imports, and TLS, lots of pieces are missing and are quite manual. Additionally `std::thread` has no hope of ever working with this model!\r\n\r\nIn addition to the drawbacks previously mentioned, there's no way for TLS destructors to get implemented with any of this runtime support. The standard library ignores destructors registered on wasm and simply never runs them. Even if a runtime has a method of running TLS destructors, they don't have a way of hooking into the standard library to run the destructors.\r\n\r\nI personally fear that the most likely scenario here is to simply stabilize what we have, bad user experience and all. Other possible alternatives (but not great ones?) might be:\r\n\r\n* Add new wasm target for threads, but add a target per \"runtime\". We might add one for wasm-bindgen, one for Wasmtime, etc. This can try to work around TLS destructor issues and make things much more seamless, but it would be an explosion of targets.\r\n* Coordinate with C and other toolchains to try to create a standard way to deal with wasm threads. For example we could standardize with C how modules are instantiated, TLS is handled, threads are intended to be spawned/exited, etc. This AFAIK isn't happening since I believe \"Emscripten does its thing\" and I don't think anyone else is trying to get something done in this space. Wasm-bindgen \"works\" but doesn't implement TLS destructors and it's still very manual and left up to users.\r\n\r\nI originally started writing this issue [to stabilize the `core::arch` intrinsics](https://github.com/rust-lang/stdarch/pull/926#issuecomment-704675105), but upon reflection there are so many other unanswered questions in this space I'm no longer certain this is the best course of action. In any case I wanted to write down my thoughts on the current state of things, and hopefully have a canonical place this can be discussed for Rust-related things.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/77839/reactions", "total_count": 59, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 36, "rocket": 0, "eyes": 23}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/77839/timeline", "performed_via_github_app": null, "state_reason": null}