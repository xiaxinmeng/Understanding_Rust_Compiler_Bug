{"url": "https://api.github.com/repos/rust-lang/rust/issues/108030", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/108030/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/108030/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/108030/events", "html_url": "https://github.com/rust-lang/rust/issues/108030", "id": 1583790565, "node_id": "I_kwDOAAsO6M5eZrnl", "number": 108030, "title": "LTO prunes symbols which are used resulting in a linking error", "user": {"login": "koute", "id": 246574, "node_id": "MDQ6VXNlcjI0NjU3NA==", "avatar_url": "https://avatars.githubusercontent.com/u/246574?v=4", "gravatar_id": "", "url": "https://api.github.com/users/koute", "html_url": "https://github.com/koute", "followers_url": "https://api.github.com/users/koute/followers", "following_url": "https://api.github.com/users/koute/following{/other_user}", "gists_url": "https://api.github.com/users/koute/gists{/gist_id}", "starred_url": "https://api.github.com/users/koute/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/koute/subscriptions", "organizations_url": "https://api.github.com/users/koute/orgs", "repos_url": "https://api.github.com/users/koute/repos", "events_url": "https://api.github.com/users/koute/events{/privacy}", "received_events_url": "https://api.github.com/users/koute/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2023-02-14T09:18:30Z", "updated_at": "2023-04-05T17:32:59Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "### Steps to Reproduce\r\n\r\n```\r\ngit clone https://github.com/paritytech/substrate.git\r\ncd substrate\r\ngit fetch origin 10bf4bd0d9ed75c62bf9e094759fa9315e1c2017\r\ngit checkout 10bf4bd0d9ed75c62bf9e094759fa9315e1c2017\r\ncd bin/node/cli\r\ncargo build --profile=production\r\n```\r\n\r\nThis will take quite a while; sorry, I don't have a more minimal reproduction on hand since the issue doesn't reproduce on a toy example and reducing the actual reproduction into a minimal example is tricky when it takes forever to reproduce.\r\n\r\n### Expected Results\r\n\r\nThe compilation succeeds.\r\n\r\n### Actual Results\r\n\r\nLinking fails.\r\n\r\n```\r\nerror: linking with `cc` failed: exit status: 1\r\n  |\r\n  = note: \"cc\" \"-m64\" \"/tmp/rustcVp2xZW/symbols.o\" \"/home/benchbot/cargo_target_dir/production/deps/substrate-5e6858252d8e1fde.substrate.8fb52a54-cgu.0.rcgu.o\" \"-Wl,--as-needed\" \"-L\" \"/home/benchbot/cargo_target_dir/production/deps\" \"-L\" \"/home/benchbot/cargo_target_dir/production/build/secp256k1-sys-325112220bd38f82/out\" \"-L\" \"/home/benchbot/cargo_target_dir/production/build/psm-9a0468c1d0238995/out\" \"-L\" \"/home/benchbot/cargo_target_dir/production/build/zstd-sys-89ca5ccaf9b199da/out\" \"-L\" \"/home/benchbot/cargo_target_dir/production/build/wasmtime-runtime-abbae99d5a8a5288/out\" \"-L\" \"/home/benchbot/cargo_target_dir/production/build/blake3-3c4da28db5e4fd3e/out\" \"-L\" \"/home/benchbot/cargo_target_dir/production/build/blake3-3c4da28db5e4fd3e/out\" \"-L\" \"/home/benchbot/cargo_target_dir/production/build/ring-2ca6aaf61769762f/out\" \"-L\" \"/home/benchbot/cargo_target_dir/production/build/librocksdb-sys-9f56c52ab5fb72b3/out\" \"-L\" \"/home/benchbot/cargo_target_dir/production/build/librocksdb-sys-9f56c52ab5fb72b3/out\" \"-L\" \"/home/benchbot/cargo_target_dir/production/build/tikv-jemalloc-sys-1c1b04141739d384/out/build/lib\" \"-L\" \"/home/benchbot/cargo_target_dir/production/build/lz4-sys-8668a2a3112e8575/out\" \"-L\" \"/usr/local/rustup/toolchains/1.66.1-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"-Wl,-Bstatic\" \"/tmp/rustcVp2xZW/liblz4_sys-d7fc638637648eea.rlib\" \"/tmp/rustcVp2xZW/liblibrocksdb_sys-8e2bd3fbce00bae8.rlib\" \"/tmp/rustcVp2xZW/libring-eaff6bf0aa221db4.rlib\" \"/tmp/rustcVp2xZW/libblake3-71adb6285cf48b0f.rlib\" \"/tmp/rustcVp2xZW/libsecp256k1_sys-3053efd9f5b6aa76.rlib\" \"/tmp/rustcVp2xZW/libpsm-9a050d5bd674c210.rlib\" \"/tmp/rustcVp2xZW/libzstd_sys-21f01571affc3d59.rlib\" \"/tmp/rustcVp2xZW/libwasmtime_runtime-0c33dd4e6df14e3b.rlib\" \"/usr/local/rustup/toolchains/1.66.1-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib/libcompiler_builtins-91d9d5141f4e57a1.rlib\" \"-Wl,-Bdynamic\" \"-lstdc++\" \"-lz\" \"-lgcc_s\" \"-lutil\" \"-lrt\" \"-lpthread\" \"-lm\" \"-ldl\" \"-lc\" \"-Wl,--eh-frame-hdr\" \"-Wl,-znoexecstack\" \"-L\" \"/usr/local/rustup/toolchains/1.66.1-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"-o\" \"/home/benchbot/cargo_target_dir/production/deps/substrate-5e6858252d8e1fde\" \"-Wl,--gc-sections\" \"-pie\" \"-Wl,-zrelro,-znow\" \"-Wl,-O1\" \"-nodefaultlibs\"\r\n  = note: /usr/bin/ld: /home/benchbot/cargo_target_dir/production/deps/substrate-5e6858252d8e1fde.substrate.8fb52a54-cgu.0.rcgu.o: in function `table_grow_funcref':\r\n          substrate.8fb52a54-cgu.0:(.text+0x151): undefined reference to `wasmtime_runtime::libcalls::trampolines::impl_table_grow_funcref'\r\n          /usr/bin/ld: /home/benchbot/cargo_target_dir/production/deps/substrate-5e6858252d8e1fde.substrate.8fb52a54-cgu.0.rcgu.o: in function `table_fill_funcref':\r\n          substrate.8fb52a54-cgu.0:(.text+0x1b1): undefined reference to `wasmtime_runtime::libcalls::trampolines::impl_table_fill_funcref'\r\n          collect2: error: ld returned 1 exit status\r\n```\r\n\r\n### Versions and Environment\r\n\r\n* rustc 1.69.0-nightly (c8e6a9e8b 2023-01-23)\r\n* rustc 1.69.0-nightly (065852def 2023-02-13)\r\n* Linux+amd64\r\n\r\nThe issue also reproduces on macOS+aarch64.\r\n\r\n### Extra Info\r\n\r\nI'm not sure whether this is a generic LTO bug, or a bug with `global_asm!`.\r\n\r\nThe [`wasmtime`](https://github.com/bytecodealliance/wasmtime) crate sets up a bunch of `global_asm!` trampolines like this:\r\n\r\n<details>\r\n  <summary>Relevant code</summary>\r\n\r\n```rust\r\ncfg_if::cfg_if! {\r\n        #[macro_export]\r\n        macro_rules! asm_func {\r\n            ($name:expr, $body:expr $(, $($args:tt)*)?) => {\r\n                std::arch::global_asm!(\r\n                    concat!(\r\n                        \".p2align 4\\n\",\r\n                        \".hidden \", $name, \"\\n\",\r\n                        \".global \", $name, \"\\n\",\r\n                        $crate::elf_func_type_header!($name),\r\n                        $name, \":\\n\",\r\n                        $body,\r\n                        \".size \", $name, \",.-\", $name,\r\n                    )\r\n                    $(, $($args)*)?\r\n                );\r\n            };\r\n        }\r\n    }\r\n}\r\n\r\n// ...\r\n\r\n#[rustfmt::skip]\r\nmacro_rules! wasm_to_libcall_trampoline {\r\n    ($libcall:ident ; $libcall_impl:ident) => {\r\n        wasmtime_asm_macros::asm_func!(\r\n            stringify!($libcall),\r\n            concat!(\r\n                \"\r\n                   .cfi_startproc simple\r\n                   .cfi_def_cfa_offset 0\r\n\r\n                    // Load the pointer to `VMRuntimeLimits` in `\", scratch0!(), \"`.\r\n                    mov \", scratch0!(), \", 8[\", arg0!(), \"]\r\n\r\n                    // Store the last Wasm FP into the `last_wasm_exit_fp` in the limits.\r\n                    mov 24[\", scratch0!(), \"], rbp\r\n\r\n                    // Store the last Wasm PC into the `last_wasm_exit_pc` in the limits.\r\n                    mov \", scratch1!(), \", [rsp]\r\n                    mov 32[\", scratch0!(), \"], \", scratch1!(), \"\r\n\r\n                    // Tail call to the actual implementation of this libcall.\r\n                    jmp {}\r\n\r\n                    .cfi_endproc\r\n                \",\r\n            ),\r\n            sym $libcall_impl\r\n        );\r\n    };\r\n}\r\n\r\n// ...\r\n\r\n    macro_rules! libcall {\r\n        (\r\n            $(\r\n                $( #[$attr:meta] )*\r\n                $name:ident( vmctx: vmctx $(, $pname:ident: $param:ident )* ) $( -> $result:ident )?;\r\n            )*\r\n        ) => {paste::paste! {\r\n            $(\r\n                // The actual libcall itself, which has the `pub` name here, is\r\n                // defined via the `wasm_to_libcall_trampoline!` macro on\r\n                // supported platforms or otherwise in inline assembly for\r\n                // platforms like s390x which don't have stable `global_asm!`\r\n                // yet.\r\n                extern \"C\" {\r\n                    #[allow(missing_docs)]\r\n                    #[allow(improper_ctypes)]\r\n                    pub fn $name(\r\n                        vmctx: *mut VMContext,\r\n                        $( $pname: libcall!(@ty $param), )*\r\n                    ) $(-> libcall!(@ty $result))?;\r\n                }\r\n\r\n                wasm_to_libcall_trampoline!($name ; [<impl_ $name>]);\r\n\r\n                // This is the direct entrypoint from the inline assembly which\r\n                // still has the same raw signature as the trampoline itself.\r\n                // This will delegate to the outer module to the actual\r\n                // implementation and automatically perform `catch_unwind` along\r\n                // with conversion of the return value in the face of traps.\r\n                //\r\n                // Note that rust targets which support `global_asm!` can use\r\n                // the `sym` operator to get the symbol here, but other targets\r\n                // like s390x need to use outlined assembly files which requires\r\n                // `no_mangle`.\r\n                #[cfg_attr(target_arch = \"s390x\", no_mangle)]\r\n                unsafe extern \"C\" fn [<impl_ $name>](\r\n                    vmctx : *mut VMContext,\r\n                    $( $pname : libcall!(@ty $param), )*\r\n                ) $( -> libcall!(@ty $result))? {\r\n                    let result = std::panic::catch_unwind(|| {\r\n                        super::$name(vmctx, $($pname),*)\r\n                    });\r\n                    match result {\r\n                        Ok(ret) => LibcallResult::convert(ret),\r\n                        Err(panic) => crate::traphandlers::resume_panic(panic),\r\n                    }\r\n                }\r\n            )*\r\n        }};\r\n\r\n        (@ty i32) => (u32);\r\n        (@ty i64) => (u64);\r\n        (@ty reference) => (*mut u8);\r\n        (@ty pointer) => (*mut u8);\r\n        (@ty vmctx) => (*mut VMContext);\r\n    }\r\n\r\n// ...\r\n\r\nlibcall! {\r\n    // ...\r\n    /// Returns an index for Wasm's `table.fill` instruction for `externref`s.\r\n    table_fill_externref(vmctx: vmctx, table: i32, dst: i32, val: reference, len: i32);\r\n    /// Returns an index for Wasm's `table.fill` instruction for `funcref`s.\r\n    table_fill_funcref(vmctx: vmctx, table: i32, dst: i32, val: pointer, len: i32);\r\n    // ...\r\n}\r\n\r\n// ...\r\n\r\n// Implementation of `table.fill`.\r\nunsafe fn table_fill(\r\n    vmctx: *mut VMContext,\r\n    table_index: u32,\r\n    dst: u32,\r\n    // NB: we don't know whether this is a `VMExternRef` or a pointer to a\r\n    // `VMCallerCheckedAnyfunc` until we look at the table's element type.\r\n    val: *mut u8,\r\n    len: u32,\r\n) -> Result<(), Trap> {\r\n    // ...\r\n}\r\n\r\nuse table_fill as table_fill_funcref;\r\nuse table_fill as table_fill_externref;\r\n```\r\n\r\n</details>\r\n\r\nSo as you can see the symbol that's being unnecessarily stripped out is being passed into the `global_asm!` block (`sym $libcall_impl`) and that is being called from assembly (`jmp {}`). That symbol is just a normal mangled extern \"C\" function (`unsafe extern \"C\" fn [<impl_ $name>]`). What's also interesting is also that this seems to affect only these two symbols (there are more that are defined, and it seems like those are not being stripped out for some reason), and that it doesn't reproduce on toy examples.\r\n\r\nThere are also two potential workarounds; first workaround is to just mark the function as `#[no_mangle]`:\r\n\r\n```diff\r\ndiff --git a/crates/runtime/src/libcalls.rs b/crates/runtime/src/libcalls.rs\r\nindex 5bed4d8ef..626fb861f 100644\r\n--- a/crates/runtime/src/libcalls.rs\r\n+++ b/crates/runtime/src/libcalls.rs\r\n@@ -109,7 +109,7 @@ pub mod trampolines {\r\n                 // the `sym` operator to get the symbol here, but other targets\r\n                 // like s390x need to use outlined assembly files which requires\r\n                 // `no_mangle`.\r\n-                #[cfg_attr(target_arch = \"s390x\", no_mangle)]\r\n+                #[no_mangle]\r\n                 unsafe extern \"C\" fn [<impl_ $name>](\r\n                     vmctx : *mut VMContext,\r\n                     $( $pname : libcall!(@ty $param), )*\r\n```\r\n\r\nThe other is to create a dummy `static` variable with a `#[used]` on it:\r\n\r\n```diff\r\ndiff --git a/crates/runtime/src/libcalls.rs b/crates/runtime/src/libcalls.rs\r\nindex 626cae408..2ce3bfc7d 100644\r\n--- a/crates/runtime/src/libcalls.rs\r\n+++ b/crates/runtime/src/libcalls.rs\r\n@@ -122,6 +122,17 @@ pub mod trampolines {\r\n                         Err(panic) => crate::traphandlers::resume_panic(panic),\r\n                     }\r\n                 }\r\n+\r\n+                #[allow(non_upper_case_globals)]\r\n+                #[used]\r\n+                static [<impl_ $name _ref>]: unsafe extern \"C\" fn(\r\n+                    *mut VMContext,\r\n+                    $( $pname : libcall!(@ty $param), )*\r\n+                ) $( -> libcall!(@ty $result))? = [<impl_ $name>];\r\n             )*\r\n         }};\r\n```\r\n\r\nAfter applying either of those the linking succeeds even when LTO is enabled.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/108030/reactions", "total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 1}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/108030/timeline", "performed_via_github_app": null, "state_reason": null}