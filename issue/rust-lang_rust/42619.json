{"url": "https://api.github.com/repos/rust-lang/rust/issues/42619", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/42619/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/42619/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/42619/events", "html_url": "https://github.com/rust-lang/rust/issues/42619", "id": 235397377, "node_id": "MDU6SXNzdWUyMzUzOTczNzc=", "number": 42619, "title": "Do we need to clarify the fsync() close() Unix-ism?", "user": {"login": "federicomenaquintero", "id": 7617, "node_id": "MDQ6VXNlcjc2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/7617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/federicomenaquintero", "html_url": "https://github.com/federicomenaquintero", "followers_url": "https://api.github.com/users/federicomenaquintero/followers", "following_url": "https://api.github.com/users/federicomenaquintero/following{/other_user}", "gists_url": "https://api.github.com/users/federicomenaquintero/gists{/gist_id}", "starred_url": "https://api.github.com/users/federicomenaquintero/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/federicomenaquintero/subscriptions", "organizations_url": "https://api.github.com/users/federicomenaquintero/orgs", "repos_url": "https://api.github.com/users/federicomenaquintero/repos", "events_url": "https://api.github.com/users/federicomenaquintero/events{/privacy}", "received_events_url": "https://api.github.com/users/federicomenaquintero/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2017-06-12T23:50:15Z", "updated_at": "2017-06-14T02:28:05Z", "closed_at": "2017-06-14T02:28:05Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I was doing a little investigation of how/when we close(2) files.  This is done in impl Drop for FileDesc, libstd/sys/unix/fd.rs.\r\n\r\nThis is of course fine.  In addition, I was wondering if Rust needs to expose the close() call in the public API, so people could actually check for errors when closing files, and per Unix lore, be safe when closing files on NFS yields an error.\r\n\r\nPretty much every API which wraps close(2) has run into the same issue.  The links provided in [the comments in the implementation for Glib's g_close()][gclose] are enlightening, particularly [this one][chris].  Summary:\r\n\r\n* You can't recover from EINTR on close(), so you should just ignore it and give up.\r\n* All other errors are of concern; pending writes and quotas (or just low disk space) mean that close() could give you ENOSPC or EIO or whatever.\r\n\r\nI *think* there are two cases to consider:\r\n\r\n* The program is writing a random, \"non-important\" file.  Maybe a temporary file or whatever.  Maybe it can just close() the file and don't do anything about errors.\r\n* The program is writing a file with the user's data (i.e. File/Save on a word processor).  In that case you really want to check errors on close(), to tell the user that something didn't work.  Is it low disk space?  Maybe the user can delete some files and try to save again.  I/O error?  Try saving to another disk.  I.e. do anything and *save* before the program has a chance to crash elsewhere :)\r\n\r\nPeople recommend doing fsync() before close() if you really care about the bits being on the disk.  This makes sense; fsync() means that both file data and its metadata are written out.  The question is whether a successful fsync() means that we can pretty much ignore the result of close().\r\n\r\nMy next question was about what the kernel is actually doing.  On Linux, close() is implemented [here][linux-close]:\r\n\r\n```C\r\nSYSCALL_DEFINE1(close, unsigned int, fd)\r\n{\r\n\tint retval = __close_fd(current->files, fd);\r\n\r\n\t/* can't restart close syscall because file table entry was cleared */\r\n\tif (unlikely(retval == -ERESTARTSYS ||\r\n\t\t     retval == -ERESTARTNOINTR ||\r\n\t\t     retval == -ERESTARTNOHAND ||\r\n\t\t     retval == -ERESTART_RESTARTBLOCK))\r\n\t\tretval = -EINTR;\r\n\r\n\treturn retval;\r\n}\r\n```\r\n\r\nThat `__close_fd()` is [here][linux-closefd]:\r\n```C\r\nint __close_fd(struct files_struct *files, unsigned fd)\r\n{\r\n\tstruct file *file;\r\n\r\n        ...\r\n\treturn filp_close(file, files);\r\n\r\nout_unlock:\r\n\t...\r\n\treturn -EBADF;\r\n}\r\n```\r\n\r\nAnd [`filp_close()`][filp-close] is the one that actually calls file system implementations:\r\n```C\r\nint filp_close(struct file *filp, fl_owner_t id)\r\n{\r\n\tint retval = 0;\r\n\r\n        ...\r\n\tif (filp->f_op->flush)\r\n\t\tretval = filp->f_op->flush(filp, id);\r\n\r\n        ...\r\n\treturn retval;\r\n}\r\n```\r\nOn Linux, the *only* thing (outside of EBADF) that can cause close() to return an error is a file system's flush() returning an error... or EINTR from a signal.\r\n\r\nI then looked for which file systems implement `f_op->flush()`.  It's only afs, cifs, ecryptfs, exofs, fuse, nfs.  And on nfs's implementation, it just calls vfs_flush(), which calls underlying_filesystem->fsync().  Fuse's is hairier, as it actually depends on the implementing process.  I didn't look at the others.\r\n\r\nAlso, I have no idea of what other operating systems do!\r\n\r\nI think we could have a recommendation to call File.sync_all() for really important, user's data.  I am not yet sure if we should export close() in the File API, as I cannot answer \"is successful fsync() then close() enough for the safety of the user's data\" yet :(\r\n\r\nComments are appreciated.\r\n\r\n[gclose]: https://git.gnome.org/browse/glib/tree/glib/gstdio.c?h=2.53.2#n866\r\n[chris]: https://utcc.utoronto.ca/~cks/space/blog/unix/CloseEINTR\r\n[linux-close]: https://github.com/torvalds/linux/blob/master/fs/open.c#L1149\r\n[linux-closefd]: https://github.com/torvalds/linux/blob/master/fs/file.c#L635\r\n[filp-close]: https://github.com/torvalds/linux/blob/master/fs/open.c#L1122", "closed_by": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/42619/reactions", "total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/42619/timeline", "performed_via_github_app": null, "state_reason": "completed"}