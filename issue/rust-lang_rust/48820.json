{"url": "https://api.github.com/repos/rust-lang/rust/issues/48820", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/48820/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/48820/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/48820/events", "html_url": "https://github.com/rust-lang/rust/issues/48820", "id": 303146976, "node_id": "MDU6SXNzdWUzMDMxNDY5NzY=", "number": 48820, "title": "std::thread::JoinHandle should be marked with #[must_use]", "user": {"login": "ghost", "id": 10137, "node_id": "MDQ6VXNlcjEwMTM3", "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ghost", "html_url": "https://github.com/ghost", "followers_url": "https://api.github.com/users/ghost/followers", "following_url": "https://api.github.com/users/ghost/following{/other_user}", "gists_url": "https://api.github.com/users/ghost/gists{/gist_id}", "starred_url": "https://api.github.com/users/ghost/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ghost/subscriptions", "organizations_url": "https://api.github.com/users/ghost/orgs", "repos_url": "https://api.github.com/users/ghost/repos", "events_url": "https://api.github.com/users/ghost/events{/privacy}", "received_events_url": "https://api.github.com/users/ghost/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2018-03-07T15:38:14Z", "updated_at": "2019-05-30T20:34:15Z", "closed_at": "2018-11-03T20:54:14Z", "author_association": "NONE", "active_lock_reason": null, "body": "Here's a problem that caught my attention after reading @matklad's blog post titled [Stopping a Rust worker](https://matklad.github.io/2018/03/02/stopping-a-rust-worker.html). While the presented thread stopping mechanism is indeed very nice and convenient, I think a serious flaw is being overlooked: the spawned thread is never joined.\r\n\r\nI've also noticed that spawning threads without ever joining has become a common pattern in Rust code. As a good example, take a peek at [IndraDB](https://github.com/indradb/indradb/blob/7d73168dc4637560192c7e2e0e92b276ce59aa0b/bin/src/server/script/mapreduce/mod.rs#L34)'s codebase.\r\n\r\nSeeing something like the following should give everyone a pause and make them think twice:\r\n\r\n```rust\r\nthread::spawn(|| {\r\n    // ...\r\n});\r\n```\r\n\r\nNot only this thread is not joined, but the `JoinHandle` returned by `thread::spawn` is completely ignored. This is a pattern that should be discouraged.\r\n\r\nSo what's all the fuss about - why is not joining dangerous? Consider this:\r\n\r\n```rust\r\nuse std::sync::mpsc;\r\nuse std::thread;\r\n\r\nstruct Foo;\r\n\r\nimpl Drop for Foo {\r\n    fn drop(&mut self) {\r\n        println!(\"Important cleanup work...\");\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let (s, r) = mpsc::channel::<()>();\r\n    \r\n    thread::spawn(move || {\r\n        // Initialize some kind of resource.\r\n        let _foo = Foo;\r\n        \r\n        // This loop ends when the channel becomes closed.\r\n        for msg in r {\r\n            // Process the message.\r\n        }\r\n    });\r\n    \r\n    // Close the channel.\r\n    drop(s);\r\n}\r\n```\r\n\r\nAt the end of the main function, the channel is closed and the worker thread is signalled that no more messages will be sent. This automatically breaks the loop, which is nice.\r\n\r\nHowever, the thread will not have enough time to actually take notice and drop all its variables. Instead, the thread is abruptly killed. That means it doesn't have a chance to do any kind of final cleanup work, like flushing buffers to disk, closing files, deallocating memory, or anything like that.\r\n\r\nEven worse - the exit code is 0, Rust doesn't give any warnings, and everything looks good, while it really isn't! \r\n\r\nI believe we should mark `JoinHandle` with `#[must_use]`. And if the user really doesn't want to join the thread (which should be very rare), they should acknowledge the possibility of the thread silently getting killed and write `let _handle = thread::spawn(...)` instead.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/48820/reactions", "total_count": 15, "+1": 11, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 4, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/48820/timeline", "performed_via_github_app": null, "state_reason": "completed"}