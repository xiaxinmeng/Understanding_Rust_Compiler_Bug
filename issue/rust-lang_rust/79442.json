{"url": "https://api.github.com/repos/rust-lang/rust/issues/79442", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/79442/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/79442/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/79442/events", "html_url": "https://github.com/rust-lang/rust/issues/79442", "id": 751569521, "node_id": "MDU6SXNzdWU3NTE1Njk1MjE=", "number": 79442, "title": "Exploring PGO for the Rust compiler", "user": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 64037154, "node_id": "MDU6TGFiZWw2NDAzNzE1NA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-compiletime", "name": "I-compiletime", "color": "e11d21", "default": false, "description": "Problems and improvements with respect to compile times."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 325438536, "node_id": "MDU6TGFiZWwzMjU0Mzg1MzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-bootstrap", "name": "T-bootstrap", "color": "bfd4f2", "default": false, "description": "Relevant to the bootstrap subteam: Rust's build system (x.py and src/bootstrap)"}, {"id": 593503757, "node_id": "MDU6TGFiZWw1OTM1MDM3NTc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-infra", "name": "T-infra", "color": "bfd4f2", "default": false, "description": "Relevant to the infrastructure team, which will review and decide on the PR/issue."}, {"id": 808123953, "node_id": "MDU6TGFiZWw4MDgxMjM5NTM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-release", "name": "T-release", "color": "bfd4f2", "default": false, "description": "Relevant to the release subteam, which will review and decide on the PR/issue."}, {"id": 849077850, "node_id": "MDU6TGFiZWw4NDkwNzc4NTA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/WG-compiler-performance", "name": "WG-compiler-performance", "color": "c2e0c6", "default": false, "description": "Working group: Compiler Performance"}, {"id": 1508600909, "node_id": "MDU6TGFiZWwxNTA4NjAwOTA5", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-reproducibility", "name": "A-reproducibility", "color": "f7e101", "default": false, "description": "Area: Reproducible / Deterministic builds"}, {"id": 2352122097, "node_id": "MDU6TGFiZWwyMzUyMTIyMDk3", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-discussion", "name": "C-discussion", "color": "f5f1fd", "default": false, "description": "Category: Discussion or questions that doesn't represent real issues."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 24, "created_at": "2020-11-26T12:54:41Z", "updated_at": "2023-02-03T07:45:36Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "This issue is a landing place for discussion of whether and how to apply profile-guided optimization to `rustc`. There is some preliminary investigation of the topic in the [Exploring PGO for the Rust compiler](https://blog.rust-lang.org/inside-rust/2020/11/11/exploring-pgo-for-the-rust-compiler.html) post on the Inside Rust blog. The gist of it is that the performance gains offered by PGO look very promising but we need to\r\n\r\n - confirm the results on different machines and platforms,\r\n - make sure that there are no reasons to *not* do PGO on the compiler, and\r\n - find a feasible way to implement this on CI (or find a less ambitious alternative).\r\n\r\nLet's start with the first point.\r\n\r\n\r\n### Confirming the results\r\n\r\nThe blog post contains a step by step description of how to obtain a PGOed compiler -- but it is rather time consuming to actually do that. In order to make things easier I could provide a branch of the compiler that has all the changes already applied and, more importantly, a pre-recorded, checked-in `.profdata` file for both LLVM and rustc. Alternatively, I could just put up the final toolchain for download somewhere. Even better would be to make it available via rustup somehow. Please comment below on how to best approach this.\r\n\r\n### Reasons not to do PGO?\r\n\r\nConcerns raised so far are:\r\n\r\n- This makes `rustc` builds non-reproducible -- something which I don't think is true. With a fixed `.profdata` file, both rustc and Clang should always generate the same output. That is `-Cprofile-use` and `-fprofile-use` do not introduce any source of randomness, as far as I can tell. So if the `.profdata` file being used is tracked by version control, we should be fine. It would be good to get some kind of further confirmation of that though.\r\n\r\n- If we apply PGO just to stable and beta releases, we don't get enough testing for PGO-specific toolchain bugs.\r\n\r\n- It is too much effort to continuously monitor the effect of PGO (e.g. via perf.rlo) because we would need PGOed nightlies in addition to non-PGOed nightlies (the latter of which serve as a baseline).\r\n\r\n- Doing PGO might be risky in that it adds another opportunity for LLVM bugs to introduce miscompilations.\r\n\r\n- It makes CI more complicated.\r\n\r\n- It increases cycle times for the compiler.\r\n\r\nThe last two points *can* definitely be true. Finding out whether they have to be is the point of the next section:\r\n\r\n\r\n### Find a feasible way of using PGO for rustc\r\n\r\nThere are several ways we can bring PGO to rustc:\r\n\r\n1. Provide rustbuild support for easily building your own fully PGOed compiler.\r\n2. Provide PGOed builds only for stable and beta releases, where the additional cycle time is offset by the lower build frequency.\r\n3. Provide a kind of \"best-effort\" PGO which uses out-dated (but regularly updated) profiling data, in the hope that it is accurate enough to still give most of the gains. \r\n\r\nLet's go through the points in more detail:\r\n\r\n1. **Easy DIY PGO via rustbuild** - I think we should definitely do this. There is quite a bit of design space on how to structure the concrete build options (@luser has posted some [relevant thoughts](https://github.com/rust-lang/cargo/issues/7618#issuecomment-731269657) in a related topic). But overall it should not be too much work, and since it is completely opt-in, there's also little risk involved. In addition, it is also a necessary intermediate step for the other two options.\r\n\r\n2. **PGO for beta and stable releases only** - The feasibility of option (2) depends on a few things:\r\n\r\n  - Is it acceptable from a testing point of view to build stable and beta artifacts with different settings than regular CI builds? Arguably beta releases get quite a bit of testing because they are used for building the compiler itself. On the other hand, building the compiler is a quite sensitive task.\r\n\r\n  - Is it technically actually possible to do the long, three-phase compilation process on CI, or would we run into time limits set by the infrastructure? We might be more flexible in this respect now than we have been in the past.\r\n\r\n  - How do we handle cross-compiled toolchains where profile data collection and compilation cannot run on the same system? A simple answer there is: don't do PGO for these targets. A possible better answer is to use profiling data collected on another system. This is even more relevant for the \"best-effort\" approach as described below.\r\n\r\n  Personally I'm on the fence whether I find this approach acceptable or not -- especially given that there is a third option that is potentially quite a bit better.\r\n\r\n3. **Do PGO on a best-effort** - After @pnkfelix asked a few questions in this direction, I've been looking into the LLVM profile data format a bit and it looks like it's actually quite robust:\r\n\r\n  - Every function entry contains a hash value of the function's control flow graph. This gives LLVM the ability to check if a given entry is safe to use for a given function and, if not, it can just ignore the data and compile the function normally. That would be great news because it would mean that we can use profile data collected from a different version of the compiler and still get PGO for most functions. As a consequence, we could have a `.profdata` file in version control and *always* use it. An asynchronous automated task could then regularly do data collection and check it into the repository. \r\n\r\n  - PGO works at the LLVM IR level, so everything is still rather platform independent. My guess is that the majority of functions has the same CFG on different platforms, meaning that the profile data can be collected on one platform and then be used on all other platforms. That might massively decrease the amount of complexity for bringing PGO to CI. It would also be great news for targets like macOS where the build hardware is too weak to do the whole 3-phase build.\r\n\r\n  - Function entries are keyed by symbol name, so if the symbol name is the same across platforms (which it should be the case with the new symbol mangling scheme), LLVM should have no trouble finding the entry for a given function in a `.profdata` file collected on a different platform. \r\n\r\n  Overall I came to like this approach quite a bit. Once we have a `.profdata` file being just another file in the git repository things become quite simple. If it is enough for that file to be \"eventually consistent\" we can just always use PGO without thinking about it twice. Profile data collection becomes nicely decoupled from the rest of the build process.\r\n\r\n\r\nI think the next step is to check whether the various assumptions made above actually hold, leading to the following concrete tasks:\r\n\r\n- [x] Confirm that PGO is actually worth the trouble, i.e. independently replicate the results from the [Exploring PGO for the Rust compiler](https://blog.rust-lang.org/inside-rust/2020/11/11/exploring-pgo-for-the-rust-compiler.html) blog post on different systems. (Done. See https://github.com/rust-lang/rust/issues/79442#issuecomment-763543926)\r\n- [ ] Verify that the LLVM profdata format is as robust as described above:\r\n  - [x] Try to find documentation or ask LLVM folks if support for partially out-of-date profdata is well supported and an actual design goal (see https://github.com/rust-lang/rust/issues/79442#issuecomment-734845976)\r\n  - [ ] Try to find documentation or ask LLVM folks if platform independence is well supported and an actual design goal.\r\n  - [ ] Ask people who have experience using this in production.\r\n  - [ ] Try it out: Compile various test programs with out-of-date data and data collected on another platform. See if that leads to any hard errors.\r\n- [ ] Investigate how out-of-date profdata for rutsc typically is if it were collected only once a day (for example).\r\n- [ ] Investigate how big the mismatch between different platforms is. Concretely: \r\n  - [ ] How many hash mismatches do we get on x86-64 Windows and macOS when compiling with profdata collected on x86-64 Linux? \r\n  - [ ] How many hash mismatches do we get on Aarch64 macOS when compiling with profdata collected on x86-64 Linux?\r\n  - [ ] What about x86 vs x86-64?\r\n- [ ] Investigate how much slower it is to build an instrumented compiler.\r\n- [ ] Investigate if *using* profdata leads to a significant compile time increase, that is, make sure that it is feasible to always compile with `-Cprofile-use`. \r\n- [ ] Double-check that PGO does not introduce a significant additional risk of running into LLVM miscompilation bugs. Ask production users for their experience.\r\n- [ ] Check if Rust symbol names with the current (legacy) symbol mangling scheme are platform-dependent, or if we would need to switch the compiler to the new scheme if want to use profdata across platforms.\r\n- [ ] Confirm that `-fprofile-use` and `-Cprofile-use` do not affect binary reproducibility (if used with a fixed `.profdata` file).\r\n\r\nOnce we know about all of the above we should be in a good position to decide whether to make an MCP to officially implement this.\r\n\r\nPlease post any feedback that you might have below!", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/79442/reactions", "total_count": 24, "+1": 8, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 12, "rocket": 4, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/79442/timeline", "performed_via_github_app": null, "state_reason": null}