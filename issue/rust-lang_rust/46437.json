{"url": "https://api.github.com/repos/rust-lang/rust/issues/46437", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/46437/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/46437/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/46437/events", "html_url": "https://github.com/rust-lang/rust/issues/46437", "id": 278623621, "node_id": "MDU6SXNzdWUyNzg2MjM2MjE=", "number": 46437, "title": "Move more of src/rustllvm to upstream LLVM", "user": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 289259951, "node_id": "MDU6TGFiZWwyODkyNTk5NTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/E-help-wanted", "name": "E-help-wanted", "color": "02E10C", "default": false, "description": "Call for participation: Help is requested to fix this issue."}, {"id": 650846969, "node_id": "MDU6TGFiZWw2NTA4NDY5Njk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-tracking-issue", "name": "C-tracking-issue", "color": "f5f1fd", "default": false, "description": "Category: A tracking issue for an RFC or an unstable feature."}, {"id": 3537211959, "node_id": "LA_kwDOAAsO6M7S1ZI3", "url": "https://api.github.com/repos/rust-lang/rust/labels/S-tracking-impl-incomplete", "name": "S-tracking-impl-incomplete", "color": "4682b4", "default": false, "description": ""}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 9, "created_at": "2017-12-01T23:09:20Z", "updated_at": "2022-05-06T15:02:06Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "In general we try to use the LLVM C API whenever we can as it's generally nice and stable. It also has the great benefit of being maintained by LLVM so it tends to never be a pain point when upgrading LLVM! Unfortunately though LLVM's C API isn't 100% comprehensive and we often need functionality above and beyond what you can do with just C.\r\n\r\nFor this custom functionality we typically use the C++ API of LLVM and compile our own shims which then in turn have a C API. At the time of this writing all of the C++ to C shims are located in the [`src/rustllvm` directory](https://github.com/rust-lang/rust/tree/bb42071f63830a984c4983f6fbdf982916857f72/src/rustllvm) across three main files: [`ArchiveWrapper.cpp`](https://github.com/rust-lang/rust/blob/bb42071f63830a984c4983f6fbdf982916857f72/src/rustllvm/ArchiveWrapper.cpp), [`PassWrapper.cpp`](https://github.com/rust-lang/rust/blob/bb42071f63830a984c4983f6fbdf982916857f72/src/rustllvm/PassWrapper.cpp), and [`RustWrapper.cpp`](https://github.com/rust-lang/rust/blob/bb42071f63830a984c4983f6fbdf982916857f72/src/rustllvm/RustWrapper.cpp). These files are all compiled via `build.rs` [around here](https://github.com/rust-lang/rust/blob/bb42071f63830a984c4983f6fbdf982916857f72/src/librustc_llvm/build.rs#L167-L172) where basically use `llvm-config` to guide us in how to compile those files.\r\n\r\nThe downside of these shims that we have, however, is that they're difficult for us to maintain over time. They impose problems whenever we upgrade LLVM (we have to get them compiling again as the C++ APIs change quite regularly). Additionally it also makes consumers of Rust have a more difficult time using custom LLVM versions. For example right now our shims compile on LLVM 5 but probably not LLVM trunk. Additionally for users that like to follow LLVM trunk then keeping up with the breakage of our shims can be quite difficult!\r\n\r\nTo help solve this problem it seems the ideal solution is to try to upstream at least a big chunk of the C++ APIs that we're using. This way we can much more closely stick to LLVM's C API which is far more stable. It makes it that much easier for us to eventually upgrade LLVM and it makes users using a custom LLVM not need to worry about using an LLVM beyond the one that we're using (aka LLVM trunk).\r\n\r\nI'll try to have a checklist here we can maintain over time which also is a good listing of what each of the APIs does!\r\n\r\n\r\n## `ArchiveWrapper.cpp`\r\n\r\nIn general this is functionality for reading archive `*.a` files in the Rust compiler. This makes reading rlibs (which are archive files) extra speedy. The functions here are:\r\n\r\n* [ ] `LLVMRustOpenArchive`\r\n* [ ] `LLVMRustDestroyArchive`\r\n* [ ] `LLVMRustArchiveIteratorNew`\r\n* [ ] `LLVMRustArchiveIteratorFree`\r\n* [ ] `LLVMRustArchiveIteratorNext`\r\n* [ ] `LLVMRustArchiveChildName`\r\n* [ ] `LLVMRustArchiveChildData`\r\n* [ ] `LLVMRustArchiveChildFree`\r\n* [ ] `LLVMRustArchiveMemberNew`\r\n* [ ] `LLVMRustArchiveMemberFree`\r\n* [ ] `LLVMRustWriteArchive`\r\n\r\nThese functions are basically just reading and writing archives, using iterators for reading and providing a list of structs for writing.\r\n\r\n## `PassWrapper.cpp`\r\n\r\nThis file is when we get into a bit more of a smorgasboard of random functions rather than a consistent theme, so I'll comment more of them inline below. \r\n\r\nA general theme here I've found as I wrote these down is that it's not critical that all of these are implemented. I could imagine that it would be possible to have a mode where we as rustc still compile shims sometimes (like the ones below)  but many of the shims are stubbed out to not actually use LLVM at all if we're in \"non-Rust-LLVM mode\" (aka custom LLVM mode). In other words, we don't necessarily need to upstream 100% of these functions.\r\n\r\n* [ ] `LLVMInitializePasses` - not entirely sure why we can't use the upstream versions. Someone more knowledgeable with LLVM may know how to replace this!\r\n* [ ] `LLVMRustFindAndCreatePass` - this is how we add custom passes to a pass manager by their string name\r\n* [ ] `LLVMRustPassKind` - categorizes whether a pass is a function or module pass\r\n* [ ] `LLVMRustAddPass` - add a custom pass to a pass manager\r\n* [ ] `LLVMRustPassManagerBuilderPopulateThinLTOPassManager` - thin wrapper around the C++ API to populate a ThinLTO pass manager\r\n* [ ] `LLVMRustHasFeature` - this is actually a pretty tricky one. It has to do with https://github.com/rust-lang/rust/issues/46181 and is I think the only function which actually only works with our fork. I can provide more information for this if necessary.\r\n* [ ] `LLVMRustPrintTargetCPUs` - mostly just a debugging helper we could stub out in the custom LLVM case.\r\n* [ ] `LLVMRustPrintTargetFeatures` - same as above\r\n* [ ] `LLVMRustCreateTargetMachine` - this is one we have to create a `TargetMachineRef` ourselves but also giving us full access to all the fields, would probably just involve exposing more field accessors and setters and such.\r\n* [ ] `LLVMRustDisposeTargetMachine` - complement to the above\r\n* [ ] `LLVMRustAddAnalysisPasses` - I think this is just adding \"standard\" passes to the pass manager IIRC, we're just trying to mirror what clang is doing here.\r\n* [ ] `LLVMRustConfigurePassManagerBuilder` - just configuring some fields, again also aimed at mirroring clang.\r\n* [ ] `LLVMRustAddBuilderLibraryInfo` - again, attempting to mirror clang by configuring all the fields\r\n* [ ] `LLVMRustAddLibraryInfo` - mirroring clang\r\n* [ ] `LLVMRustRunFunctionPassManager` - seems ripe to add upstream!\r\n* [ ] `LLVMRustSetLLVMOptions` - I think this is for one-time configuration of LLVM at startup\r\n* [ ] `LLVMRustWriteOutputFile` - there's a whole bunch of ways to write outupt files with LLVM, if we had something that just wrote it out to memory or a file that'd be good enough for us\r\n* [ ] `LLVMRustPrintModule` - I'm pretty sure this is mainly just generating IR, but I'm not personally too familiar with the need for a custom class here\r\n* [ ] `LLVMRustPrintPasses` - AFAIK a debugging helper, could be stubbed out with a custom LLVM\r\n* [ ] `LLVMRustAddAlwaysInlinePass` - may just be missing upstream?\r\n* [ ] `LLVMRustRunRestrictionPass` - I think this is part of our LTO bindings, internalizing lots of stuff\r\n* [ ] `LLVMRustMarkAllFunctionsNounwind` - definitely part of our LTO bindings, for when you're compiling with `-C lto` and `-C panic=abort`\r\n* [ ] `LLVMRustSetDataLayoutFromTargetMachine` - not entirely sure what this is...\r\n* [ ] `LLVMRustGetModuleDataLayout` - also not entirely sure what this is...\r\n* [ ] `LLVMRustSetModulePIELevel` - I think just configuring more properties\r\n* [ ] `LLVMRustThinLTOAvailable` - for us just testing the LLVM version right now\r\n* [ ] `LLVMRustWriteThinBitcodeToFile` - mostly just what it says on the tin\r\n* [ ] `LLVMRustThinLTOBufferCreate` - same as abvoe but in memory\r\n* [ ] `LLVMRustThinLTOBufferFree` - freeing the above\r\n* [ ] `LLVMRustThinLTOBufferPtr` - reading the above\r\n* [ ] `LLVMRustThinLTOBufferLen` - reading the above\r\n* [ ] `LLVMRustParseBitcodeForThinLTO` - mostly what it says on the tin\r\n\r\nThese APIs are all related to ThinLTO are are still somewhat in flux, there may not be a great C API just yet.\r\n\r\n* [ ] `LLVMRustCreateThinLTOData`\r\n* [ ] `LLVMRustFreeThinLTOData`\r\n* [ ] `LLVMRustPrepareThinLTORename`\r\n* [ ] `LLVMRustPrepareThinLTOResolveWeak`\r\n* [ ] `LLVMRustPrepareThinLTOInternalize`\r\n* [ ] `LLVMRustPrepareThinLTOImport`\r\n\r\n## `RustWrapper.cpp`\r\n\r\nSort of even a bigger smorgasboard than `PassWrapper.cpp`! Note that many of these functions are very old and may have actually made their way into the C API of LLVM by now, in which case that'd be awesome!\r\n\r\n* [ ] `LLVMRustCreateMemoryBufferWithContentsOfFile` - this is something we can and probably should write ourselves rather than relying on LLVM\r\n* [ ] `LLVMRustGetLastError` - this is a Rust-specific API for getting out an error message, I'd imagine that whenever it's set we'd have something analagous in LLVM.\r\n* [ ] `LLVMRustSetLastError` - used by the C++ code to set the error that rustc will retrieve later\r\n* [ ] `LLVMRustSetNormalizedTarget` - I think this is just exposing something that wasn't already there.\r\n* [ ] `LLVMRustPrintPassTimings` - debugging on our end.\r\n* [ ] `LLVMRustGetNamedValue` - I think this is just fun dealing with metadata\r\n* [ ] `LLVMRustGetOrInsertFunction` - needed that C++ function most likely.\r\n* [ ] `LLVMRustGetOrInsertGlobal` - again, probably just needed the function\r\n* [ ] `LLVMRustMetadataTypeInContext` - more constructors for more types\r\n* [ ] `LLVMRustAddCallSiteAttribute` - just a \"fluff\" thing we needed to do that wasn't possible in C IIRC\r\n* [ ] `LLVMRustAddAlignmentCallSiteAttr` - same as above\r\n* [ ] `LLVMRustAddDereferenceableCallSiteAttr` - same as above\r\n* [ ] `LLVMRustAddDereferenceableOrNullCallSiteAttr` - same as above\r\n* [ ] `LLVMRustAddFunctionAttribute` - same as above\r\n* [ ] `LLVMRustAddAlignmentAttr` - same as above\r\n* [ ] `LLVMRustAddDereferenceableAttr` - same as above\r\n* [ ] `LLVMRustAddDereferenceableOrNullAttr` - same as above\r\n* [ ] `LLVMRustAddFunctionAttrStringValue` - same as above\r\n* [ ] `LLVMRustRemoveFunctionAttributes` - same as above\r\n* [ ] `LLVMRustSetHasUnsafeAlgebra` - not entirely sure what this is doing...\r\n* [ ] `LLVMRustBuildAtomicLoad` - I think at the time the C API didn't exist?\r\n* [ ] `LLVMRustBuildAtomicStore` - same as above\r\n* [ ] `LLVMRustBuildAtomicCmpXchg` - same as above\r\n* [ ] `LLVMRustBuildAtomicFence` - same as above\r\n* [x] `LLVMRustSetDebug` - I think one-time configuration of LLVM\r\n* [ ] `LLVMRustInlineAsm` - I think the C API didn't exist (or wasn't full-featured enough)\r\n* [ ] `LLVMRustAppendModuleInlineAsm` - that function probably wasn't exposed in C\r\n* [ ] `LLVMRustVersionMinor` - just exposing a constant\r\n* [ ] `LLVMRustVersionMajor` - same as above\r\n* [ ] `LLVMRustDebugMetadataVersion` - this and most debug functions below I think just aren't in the C API\r\n* [ ] `LLVMRustAddModuleFlag` - same as above\r\n* [ ] `LLVMRustMetadataAsValue` - same as above\r\n* [ ] `LLVMRustDI*` - same as above (there's a whole bunch of these)\r\n* [ ] `LLVMRustWriteValueToString` - IIRC this is mostly debugging\r\n* [ ] `LLVMRustLinkInExternalBitcode` - used during normal LTO\r\n* [x] `LLVMRustLinkInParsedExternalBitcode` - used during normal LTO\r\n* [ ] `LLVMRustGetSectionName` - not sure where this came from...\r\n* [ ] `LLVMRustArrayType` - missing C API?\r\n* [ ] `LLVMRustWriteTwineToString` - I think more debugging/diagnostics\r\n* [ ] `LLVMRustUnpackOptimizationDiagnostic` - diagnostics\r\n* [ ] `LLVMRustUnpackInlineAsmDiagnostic` - diagnostics\r\n* [ ] `LLVMRustWriteDiagnosticInfoToString` - diagnostics\r\n* [ ] `LLVMRustGetDiagInfoKind` - custom for us I think?\r\n* [ ] `LLVMRustGetTypeKind` - missing C API?\r\n* [x] `LLVMRustWriteDebugLocToString` - debugging API I think\r\n* [ ] `LLVMRustSetInlineAsmDiagnosticHandler` - dealing with inline asm diagnostics\r\n* [ ] `LLVMRustWriteSMDiagnosticToString` - diagnostics\r\n* [x] `LLVMRustBuildLandingPad` - missing C API?\r\n* [ ] `LLVMRustBuildCleanupPad` - same as above\r\n* [ ] `LLVMRustBuildCleanupRet` - same as above\r\n* [ ] `LLVMRustBuildCatchPad` - same as above\r\n* [ ] `LLVMRustBuildCatchRet` - same as above\r\n* [ ] `LLVMRustBuildCatchSwitch` - same as above\r\n* [ ] `LLVMRustAddHandler` - same as above\r\n* [ ] `LLVMRustBuildOperandBundleDef` - same as above\r\n* [ ] `LLVMRustBuildCall` - same as above\r\n* [ ] `LLVMRustBuildInvoke` - same as above\r\n* [ ] `LLVMRustPositionBuilderAtStart` - same as above I think?\r\n* [ ] `LLVMRustSetComdat` - same as above\r\n* [ ] `LLVMRustUnsetComdat` - same as above\r\n* [ ] `LLVMRustGetLinkage` - same as above\r\n* [ ] `LLVMRustSetLinkage` - same as above\r\n* [ ] `LLVMRustConstInt128Get` - same as above\r\n* [x] `LLVMRustGetValueContext` - same as above\r\n* [ ] `LLVMRustGetVisibility` - same as above\r\n* [ ] `LLVMRustSetVisibility` - same as above\r\n* [ ] `LLVMRustModuleBufferCreate` - serializing a module to memory\r\n* [ ] `LLVMRustModuleBufferFree` - freeing above\r\n* [ ] `LLVMRustModuleBufferPtr` - reading above\r\n* [ ] `LLVMRustModuleBufferLen` - reading above\r\n* [ ] `LLVMRustModuleCost` - mostly a debugging helper\r\n  \r\n  ", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/46437/reactions", "total_count": 2, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 2, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/46437/timeline", "performed_via_github_app": null, "state_reason": null}