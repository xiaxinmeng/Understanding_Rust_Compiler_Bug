{"url": "https://api.github.com/repos/rust-lang/rust/issues/3294", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/3294/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/3294/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/3294/events", "html_url": "https://github.com/rust-lang/rust/issues/3294", "id": 6502191, "node_id": "MDU6SXNzdWU2NTAyMTkx", "number": 3294, "title": "string operations are quite inefficient", "user": {"login": "Vincent-Belliard", "id": 2185554, "node_id": "MDQ6VXNlcjIxODU1NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2185554?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vincent-Belliard", "html_url": "https://github.com/Vincent-Belliard", "followers_url": "https://api.github.com/users/Vincent-Belliard/followers", "following_url": "https://api.github.com/users/Vincent-Belliard/following{/other_user}", "gists_url": "https://api.github.com/users/Vincent-Belliard/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vincent-Belliard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vincent-Belliard/subscriptions", "organizations_url": "https://api.github.com/users/Vincent-Belliard/orgs", "repos_url": "https://api.github.com/users/Vincent-Belliard/repos", "events_url": "https://api.github.com/users/Vincent-Belliard/events{/privacy}", "received_events_url": "https://api.github.com/users/Vincent-Belliard/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2012-08-28T15:38:42Z", "updated_at": "2012-08-28T17:55:08Z", "closed_at": "2012-08-28T17:52:06Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "A week ago, I discovered Rust. The project is really interesting and is close to my vision of computer languages. I really love the enum/match mechanism and the memory model with shared and unique boxes. Everything looks consistent but the strings. The mechanism with three kinds of strings is not obvious to use but most of all, the generated llvm is quite inefficient. \n\nFor example, if you make the following example:\n\n<pre><code>struct Example {\n    let mut a: ~str;\n    new() {\n        self.a = ~\"\";\n    }\n    fn set_a(new_a: ~str) {\n        self.a = copy new_a;\n    }\n    fn cmp_a(ref_a: ~str) -> bool {\n        self.a == ref_a\n    }\n}</code></pre>\n\n\nThe constructor will make three calls (upcall_str_new_uniq, glue_grop and llvm.memmove).\nThe set_a function will make three calls (exchange_malloc, llvm.memmove and glue_drop).\nThe cmp_a function just do one mandatory call (upcall_cmp_type) but if you compare with a constant, you add a call to upcall_str_new_uniq and a call to glue_free.\n\nStrings operations are very common and a good compiler should optimize theses operations so Rust must do that.\n\nFor several years now, I make a language which share a lot of things with Rust. I had the same strings problems that Rust have and I think I found something quite efficient.\n\nI use reference counted objects to hold strings (the objects have a links_count, a string size (in bytes), a string size (in characters) and the characters (in utf8). A static string has a links count of -1 which is never increment nor decrement. The strings are shared between thread (but, like Rust, I don't share objects between threads). I use the cmpxchg llvm function to increment or decrement links to be thread safe.\n\nWith the same example:\n\n<pre><code>class Example\n    {\n    public field a: String: default_value = \"\" ;\n    public constructor(self):\n        {\n        }\n    public method set_a(self, new_a: String):\n        {\n        a = new_a ;\n        }\n    public method cmp_a(self, ref_a: String) returns Boolean:\n        {\n        if (a == ref_a) return with true;\n        return with false;\n        }\n    }</code></pre>\n\n\nI have the following LLVM code:\n\n<pre><code>define void @constructor__Example(%class.Example* %_self)\n    {\n    %1 = getelementptr inbounds %class.Example* %_self, i32 0, i32 0\n    store %string_content* bitcast ({ i64, i64, i64, [1 x i8] }* @str_8 to %string_content*), %string_content** %1\n    ret void\n    }\ndefine void @__Example.set__a.String(%class.Example* %_self, %string_content* %_new__a)\n    {\n    %1 = getelementptr inbounds %class.Example* %_self, i32 0, i32 0\n    %2 = load %string_content** %1\n    %3 = getelementptr inbounds %string_content* %_new__a, i32 0, i32 0\n    %4 = load i64* %3\n    %5 = icmp eq i64 %4, -1\n ; if static don't increment\n    br i1 %5, label %11, label %6\n; do the increment until it has not be smashed by another thread\n; 6:\n    %7 = phi i64 [ %4, %0 ], [ %9, %6 ]\n    %8 = add i64 %7, 1\n    %9 = cmpxchg i64* %3, i64 %7, i64 %8 monotonic\n    %10 = icmp eq i64 %7, %9\n    br i1 %10, label %11, label %6\n; 11:\n    %12 = load i64* %3\n    %13 = getelementptr inbounds %string_content* %2, i32 0, i32 0\n    %14 = load i64* %13\n    %15 = icmp eq i64 %14, -1\n; if static don't decrement\n    br i1 %15, label %24, label %16\n ; do the decrement until is has not be smashed by another thread\n; 16:\n    %17 = phi i64 [ %14, %11 ], [ %19, %16 ]\n    %18 = sub i64 %17, 1\n    %19 = cmpxchg i64* %13, i64 %17, i64 %18 monotonic\n    %20 = icmp eq i64 %17, %19\n    br i1 %20, label %21, label %16\n; 21:\n    %22 = icmp eq i64 %18, 0\n; if we assigned zero to links count, we free the string\n    br i1 %22, label %23, label %24\n; 23:\n    call void @free_string_content(%string_content* %2)\n    br label %24\n; 24:\n    store %string_content* %_new__a, %string_content** %1\n    br label %25\n; 25:\n    ret void\n    }\ndefine i1 @__Example.cmp__a.String(%class.Example* %_self, %string_content* %_ref__a)\n    {\n    %1 = getelementptr inbounds %class.Example* %_self, i32 0, i32 0\n    %2 = load %string_content** %1\n    %3 = call i1 @equals_string_contents(%string_content* %2, %string_content* %_ref__a)\n    br i1 %3, label %4, label %5\n; 4:\n    ret i1 1\n; 5:\n    br label %6\n; 6:\n    ret i1 0\n    }</code></pre>\n\n\nIn the constructor, the field is initialized with a static string. The compiler makes an optimization and doesn't generate the increment (which does nothing for a static string).\n\nI think that the way I manage strings with Entity could be very useful for Rust. If it would be decided that it must be done for Rust, I would do the development (or provide some help) with pleasure.\n\nYou can have a look at the Entity language (http://code.google.com/p/entity-language/). The final compiler with llvm generation is very young and only a few things are managed by this compiler.\n", "closed_by": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/3294/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/3294/timeline", "performed_via_github_app": null, "state_reason": "completed"}