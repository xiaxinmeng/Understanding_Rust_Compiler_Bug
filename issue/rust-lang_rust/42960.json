{"url": "https://api.github.com/repos/rust-lang/rust/issues/42960", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/42960/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/42960/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/42960/events", "html_url": "https://github.com/rust-lang/rust/issues/42960", "id": 239330653, "node_id": "MDU6SXNzdWUyMzkzMzA2NTM=", "number": 42960, "title": "#[repr(align(x))] is limited to 32768", "user": {"login": "Ekleog", "id": 411447, "node_id": "MDQ6VXNlcjQxMTQ0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/411447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ekleog", "html_url": "https://github.com/Ekleog", "followers_url": "https://api.github.com/users/Ekleog/followers", "following_url": "https://api.github.com/users/Ekleog/following{/other_user}", "gists_url": "https://api.github.com/users/Ekleog/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ekleog/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ekleog/subscriptions", "organizations_url": "https://api.github.com/users/Ekleog/orgs", "repos_url": "https://api.github.com/users/Ekleog/repos", "events_url": "https://api.github.com/users/Ekleog/events{/privacy}", "received_events_url": "https://api.github.com/users/Ekleog/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2017-06-28T23:59:04Z", "updated_at": "2017-07-09T09:53:36Z", "closed_at": "2017-07-09T00:21:23Z", "author_association": "NONE", "active_lock_reason": null, "body": "In some cases, the hardware imposes natural alignment for some data (ie. data aligned to its length). For example, the ARM Memory Protection Unit.\r\n\r\nThis can happen even when handling large structs (eg. `0x10000`-sized buffers). These buffers would thus require an alignment of `0x10000`. Which appears not to be possible with `#[repr(align(x))]`, that appears limited to 32768.\r\n\r\nI'm currently using the following (ugly, esp. because of the absence of type-level integers) workaround to get the aligned data I need:\r\n```rust\r\npub struct Aligned {                                                        \r\n   unaligned: [u8; 0x100000]                                                    \r\n}                                                                                \r\npub static mut DATA: Aligned = Aligned { unaligned: [0; 0x100000] };\r\nimpl Aligned {                                                              \r\n   pub fn get(&self) -> &[u8] {                                                  \r\n       let begin_addr = &self.unaligned[0] as *const _ as usize;                \r\n       let aligned_begin_addr = (begin_addr & !0x7FFFF) + 0x80000;              \r\n       let offset = aligned_begin_addr - begin_addr;                            \r\n       &self.unaligned[offset..(offset+0x80000)]                                \r\n   }                                                                            \r\n   pub fn get_mut(&mut self) -> &mut [u8] {                                      \r\n       let begin_addr = &self.unaligned[0] as *const _ as usize;                \r\n       let aligned_begin_addr = (begin_addr & !0x7FFFF) + 0x80000;              \r\n       let offset = aligned_begin_addr - begin_addr;                            \r\n       &mut self.unaligned[offset..(offset+0x80000)]                            \r\n   }                                                                            \r\n}  \r\n```\r\n\r\nIf I can manually do it, I don't really get why rustc wouldn't be able to do it (esp. with http://www.cs.brandeis.edu/~cs146a/rust/doc-02-21-2015/rustc/lib/llvm/fn.LLVMSetAlignment.html taking an u32 as input)?\r\n\r\nIs there a technical issue or is this just a current implementation limitation?\r\n\r\nAs this behaviour is not specified in RFC1358, cc'ing https://github.com/rust-lang/rust/issues/33626\r\n\r\nDisclaimer: I'm not actually running this code on an ARM MPU-enabled chip, but explaining the actual use case would be too long and complex and the issue is exactly the same, so I just picked this example.", "closed_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/42960/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/42960/timeline", "performed_via_github_app": null, "state_reason": "completed"}