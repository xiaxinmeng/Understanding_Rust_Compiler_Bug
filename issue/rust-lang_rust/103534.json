{"url": "https://api.github.com/repos/rust-lang/rust/issues/103534", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/103534/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/103534/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/103534/events", "html_url": "https://github.com/rust-lang/rust/issues/103534", "id": 1422778617, "node_id": "I_kwDOAAsO6M5UzeD5", "number": 103534, "title": "Parse error recovery is obversable by macros in several cases", "user": {"login": "fmease", "id": 14913065, "node_id": "MDQ6VXNlcjE0OTEzMDY1", "avatar_url": "https://avatars.githubusercontent.com/u/14913065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmease", "html_url": "https://github.com/fmease", "followers_url": "https://api.github.com/users/fmease/followers", "following_url": "https://api.github.com/users/fmease/following{/other_user}", "gists_url": "https://api.github.com/users/fmease/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmease/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmease/subscriptions", "organizations_url": "https://api.github.com/users/fmease/orgs", "repos_url": "https://api.github.com/users/fmease/repos", "events_url": "https://api.github.com/users/fmease/events{/privacy}", "received_events_url": "https://api.github.com/users/fmease/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 235791, "node_id": "MDU6TGFiZWwyMzU3OTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-diagnostics", "name": "A-diagnostics", "color": "f7e101", "default": false, "description": "Area: Messages for errors, warnings, and lints"}, {"id": 27424086, "node_id": "MDU6TGFiZWwyNzQyNDA4Ng==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-parser", "name": "A-parser", "color": "f7e101", "default": false, "description": "Area: The parsing of Rust source code to an AST."}, {"id": 132910982, "node_id": "MDU6TGFiZWwxMzI5MTA5ODI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-macros", "name": "A-macros", "color": "f7e101", "default": false, "description": "Area: All kinds of macros (custom derive, macro_rules!, proc macros, ..)"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 13, "created_at": "2022-10-25T16:50:42Z", "updated_at": "2023-01-26T03:23:56Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "## Introduction\r\n\r\nIn multiple cases, macro fragment specifiers like `expr` and `stmt` match more token streams than they should as a consequence of the parser trying to recover from obviously invalid Rust code to provide better immediate and subsequent error messages to the user.\r\n\r\n## Why Is This a Concern?\r\n\r\nThe user should be allowed to assume that a fragment specifier only matches valid Rust code, anything else would make the fragment specifier not live up to its name and as a result render it useless (to exaggerate).\r\n\r\nOne use of macros is the ability to define embedded / internal domain-specific languages (DSLs). Part of that is defining new syntax which might not necessarily be valid Rust syntax. Declarative macros allow users to create several macro rules / matchers enabling relatively fine-grained matching on tokens. Obviously, when writing those rules, macro authors need to know what a given fragment specifier accepts in order to confidently determine which specific rule applies for a given input. If the grammar used by a fragment specifier is actually larger than promised and basically *unknown* (implementation-defined to be precise), this becomes an impossible task.\r\n\r\nNot only that. If we don't do anything, the grammars matched by fragment specifiers *will keep changing* over time as more and more recovery code gets added. This breaks Rust's backward compatibility guarantees! Macro calls that used to compile at some fixed point in time might potentially no longer compile in a future version of the compiler. In fact, backward compatibility has already been broken multiple times in the past without notice by (some) PRs introducing more error recovery.\r\n\r\n## Examples\r\n\r\nThere might be **many more cases** than listed below but it takes a lot of time experimenting and looking through the parser. I'll try to extend the list over time.\r\n\r\n### Expressions\r\n\r\n```rust\r\nmacro_rules! check {\r\n    ($e:expr) => {};\r\n\r\n    // or `===`, `!==`, `<>`, `<=>`, `or` instead of `and`\r\n    ($a:literal and $b:literal) => {};\r\n    ($a:literal AND $b:literal) => {};\r\n\r\n    (not $a:literal) => {};\r\n    (NOT $a:literal) => {};\r\n}\r\n\r\ncheck! { 0 AND 1 } // passes (all good)\r\ncheck! { 0 and 1 } // \u26a0\ufe0f FAILS but should pass! \"`and` is not a logical operator\"\r\n\r\ncheck! { NOT 1 } // passes (all good)\r\ncheck! { not 1 } // \u26a0\ufe0f FAILS but should pass! \"unexpected `1` after identifier\"\r\n```\r\n\r\n<details>\r\n<summary><b>stderr</b></summary>\r\n\r\n```\r\nerror: `and` is not a logical operator\r\n  --> src/lib.rs:13:12\r\n   |\r\n13 | check! { 0 and 1 } // \u26a0\ufe0f FAILS but should pass! \"invalid comparison operator\"\r\n   |            ^^^ help: use `&&` to perform logical conjunction\r\n   |\r\n   = note: unlike in e.g., Python and PHP, `&&` and `||` are used for logical operators\r\n\r\nerror: unexpected `1` after identifier\r\n  --> src/lib.rs:16:14\r\n   |\r\n16 | check! { not 1 } // \u26a0\ufe0f FAILS but should pass! \"unexpected `1` after identifier\"\r\n   |          ----^\r\n   |          |\r\n   |          help: use `!` to perform bitwise not\r\n\r\n```\r\n\r\n</details>\r\n\r\n### Statements\r\n\r\n```rust\r\nmacro_rules! check {\r\n    ($s:stmt) => {};\r\n\r\n    // or `auto` instead of `var`\r\n    (var $i:ident) => {};\r\n    (VAR $i:ident) => {};\r\n}\r\n\r\ncheck! { VAR x } // passes (all good)\r\ncheck! { var x } // \u26a0\ufe0f FAILS but should pass! \"invalid variable declaration\" (+ ICE, #103529)\r\n```\r\n\r\n<details>\r\n<summary><b>stderr</b></summary>\r\n\r\n```\r\nerror: invalid variable declaration\r\n  --> src/lib.rs:10:10\r\n   |\r\n10 | check! { var x } // \u26a0\ufe0f FAILS but should pass! \"invalid variable declaration\" (+ ICE, #103529)\r\n   |          ^^^\r\n   |\r\nhelp: write `let` instead of `var` to introduce a new variable\r\n   |\r\n10 | check! { let x } // \u26a0\ufe0f FAILS but should pass! \"invalid variable declaration\" (+ ICE, #103529)\r\n   |          ~~~\r\n```\r\n\r\n</details>\r\n\r\n### Other Fragments (e.g. Items, Types)\r\n\r\n\\[no known cases at the time of this writing (active search ongoing)\\]\r\n\r\n## Editorial Notes\r\n\r\n<details>\r\n<summary>editorial notes</summary>\r\n\r\nI used to list some more cases above (which some of you might have noticed) but I've since removed them as they've turned out to be incorrect. Here they are:\r\n\r\n```rust\r\nmacro_rules! check {\r\n    ($e:expr) => {};\r\n\r\n    ($a:literal++) => {};\r\n    ($a:literal@@) => {};\r\n\r\n    ($n:ident : $e:expr) => {};\r\n}\r\n\r\ncheck! { 1@@ } // passes (all good)\r\ncheck! { 1++ } // FAILS but would fail ANYWAY! \"Rust has no postfix increment operator\"\r\n// ^ without the recovery code, we would try to parse a binary expression (operator `+`) and fail at the 2nd `+`\r\n\r\ncheck! { struct : loop {} } // passes (all good)\r\ncheck! { main : loop {} } // FAILS but would fail ANYWAY! \"malformed loop label\"\r\n// ^ without the recovery code, we would try to parse type ascription and fail at `loop {}` which isn't a type\r\n```\r\n\r\n</details>\r\n\r\n---\r\n\r\nRelated issue: #90256 (concerning procedural macros).\r\n\r\n@rustbot label A-macros A-diagnostics A-parser T-compiler\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/103534/reactions", "total_count": 12, "+1": 5, "-1": 0, "laugh": 0, "hooray": 0, "confused": 3, "heart": 4, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/103534/timeline", "performed_via_github_app": null, "state_reason": null}