{"url": "https://api.github.com/repos/rust-lang/rust/issues/39849", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/39849/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/39849/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/39849/events", "html_url": "https://github.com/rust-lang/rust/issues/39849", "id": 207852799, "node_id": "MDU6SXNzdWUyMDc4NTI3OTk=", "number": 39849, "title": "implement `catch` expressions", "user": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 67766349, "node_id": "MDU6TGFiZWw2Nzc2NjM0OQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/E-mentor", "name": "E-mentor", "color": "02E10C", "default": false, "description": "Call for participation: This issue has a mentor. Use RustcContributor::new on Zulip for discussion."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 419557634, "node_id": "MDU6TGFiZWw0MTk1NTc2MzQ=", "url": "https://api.github.com/repos/rust-lang/rust/labels/E-medium", "name": "E-medium", "color": "02e10c", "default": false, "description": "Call for participation: Experience needed to fix: Medium / intermediate"}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2017-02-15T16:22:47Z", "updated_at": "2017-04-11T17:58:26Z", "closed_at": "2017-04-11T17:58:26Z", "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "This is a sub-issue of #31436 corresponding to the addition of `catch` expressions. What follows is a rough implementation plan. It consists of four PRs. I'll happily expand and add details upon request.\r\n\r\nThe high-level summary is that it would be nice to implement catch by having the HIR support the ability of a `break` to target arbitrary enclosing blocks. This would not be something exposed in the main language, which still permits only breaking out of loops (but we might choose to do so in the future, that'd require an RFC).\r\n\r\nHere are some high-level notes on how to go about this. It's a \"medium-sized\" job, I think. It may be best to begin with some refactorings, as you will see. \r\n\r\n### Refactoring 1: **Normalize how labeled and unlabeled breaks work.**\r\n\r\n  - Currently, the `ExprBreak` and `ExprAgain` variants of `hir::Expr_` reference a `Option<Label>` indicating where we should break to\r\n  - During HIR lowering, if the user gave an explicit label (e.g., `'a: loop { ... break 'a }`), it will get translated into a specific node-id (the `loop_id` field of the `Label` struct)\r\n  - This is done by consulting the name resolution tables in the `lower_label()` method of HIR lowering\r\n    - Since we don't plan to change the surface language, we don't really have to change anything in name resolution, thankfully.\r\n  - Annoyingly, if you have an **anonymous** break (e.g., `loop { break; }`), then we don't store any label or indication\r\n    of where you break to. Instead, each pass must carry a stack of loops along with it. This is annoying and it would be nice to change it, so that every HIR `break` (and `continue`) already knows precisely where it is going.\r\n  - In other words, we want to change the type of the `break` variant to `ExprBreak(Label, Option<P<Expr>>)` -- the \"label\", in particular, is no longer optional.\r\n    - Probably we want to change the `Label` struct so that the \"name\" field is optional, for pretty-printing if nothing else\r\n  - On the other hand, this refactoring may not be *that* important since most passes will still have to maintain a stack, but it seems good.\r\n  - To do the refactoring:\r\n    - lowering needs to grow a stack of \"in-scope\" loops, so that it can check which is on the top\r\n    - the `librustc_passes/loops.rs` code currently does some sanity check and reports errors for malformed `break` (e.g., `break` outside of a loop)\r\n    - that logic basically moves into lowering\r\n    - we will then want to update the passes that consume `ExprBreak` and `ExprAgain`:\r\n        - MIR construction, liveness, CFG construction\r\n        - the changes are small, since you basically just want to take the `Some`\r\n          path that exists (i.e., the code is there to handle the `None` that we are removing\r\n        - in the case of `liveness`, the `loop_scope` stack can just be removed entirely, we won't be using it anymore\r\n          \r\n**Why do this?** This refactoring is an improvement because it consolidates the knowledge of where a `break` goes into one pass: HIR lowering. Right now, that knowledge is repeated in several passes, each of which must maintain a stack of loops. It will still be necessary to keep that stack of loops, but we'll be using it differently. In today's code, we sometimes search the stack for a loop with a given id (labeled break) and sometimes just take the top of the stack (unlabeled break). After this refactoring, we are always searching for the entry with a given id. This is important, because in the next section we are going to add blocks into these stacks, and so if we wanted to keep unlabeled breaks as they are, we'd have to ensure that when we check the top of the stack, we don't find some random block, but only the top-most loop.\r\n\r\n### Next step: add `catch` into AST\r\n\r\nThe goal here is just to do the plumbing of parsing `catch` and getting it into the AST.\r\n\r\n- Extend the parser to support `catch`\r\n- Add a feature-gate \r\n- Produce corresponding AST nodes\r\n- In HIR lowering, you can keep a stack of in-scope `catch` nodes \r\n    - for the first PR, if `?` is used inside of a `catch` node, I would just abort with `bug!(\"unimplemented: ? in catch\")`\r\n    - but we'll use the stack for more stuff later :P\r\n    \r\n### Next step: allow HIR `break` to target blocks\r\n\r\nThe goal here is to make it possible for breaks to target blocks in HIR. We won't need to change the data structures very much for this to work. Probably it's a good idea to rename the field `loop_id` in `hir::Label` to something like `node_id` or `target_id`, since it won't always be naming a loop anymore.\r\n\r\nIn principle, this change can be landed as an initial PR. Annoyingly, though, since we are not changing the surface syntax, there isn't a good way to **test** this code without also adding support for `catch`, so we may want to do the two changes together in one PR. Though I'd also be ok to land them separately, or perhaps add some sort of internal testing attributes that enable anonymous `break` to break out of the innermost block (`#[rustc_break_from_block]`).\r\n\r\nAnyway, we basically don't need to change HIR lowering at all. All the existing breaks are still valid breaks. The only change is that (in the next PR...) HIR lowering will produce new breaks that target blocks and not just loops. So we need to prepare the passes that consume breaks to be prepared for that. These are the same set of passes we saw in the first refactoring: MIR construction, liveness, and CFG construction. As we saw in that first refactoring, each of these passes maintains an internal stack of loops which they already use to search and find the appropriate place that a break should branch to. So the gist of the change is to extend these stacks to include breaks too. Here are some details on each pass:\r\n\r\n- **liveness:**\r\n    - the `with_loop_nodes` helper is the one that sets up the targets for breaks and so forth. At present it pushes onto a stack (`self.loop_scope`), but that should have been removed in the first refactoring. It also stores into a map (`self.break_ln`) with the \"place that a break with a given target should go to\" (`ln` stands for \"liveness node\"). \r\n    - in the `propagate_through_block(blk, succ_ln)` method, we want to therefore record `self.break_ln.insert(node_id, succ_ln)`, as `succ_ln` is the liveness node for the successor of the block\r\n- **CFG construction:**\r\n    - CFG construction keeps a vec of `LoopScope` entries rather than a map like liveness. We'll need to push onto this for blocks. The relevant function is `fn block(&mut self, blk: &hir::Block, pred: CFGIndex) -> CFGIndex`; annoyingly, the way that the CFG construction works is that you are given the predecessor node (`pred`) and you return the successor. This means that whenever we process a block, we'll have to create a dummy node (`self.add_dummy_node(&[])`) that we can add into the `LoopScope` vector to use as the target of blocks. Once we're finished processing the contents of the block, it can branch to this dummy node and then we will return the dummy node.\r\n    - (See the efficiency note below.)\r\n- **MIR building:**\r\n    - MIR building works similarly; the helper that pushes on the stack is `in_loop_scope()`\r\n    - one difference here is that we have to have the `ExprBreak` that targets a block generate an appopriate value; this should work the same way that it does for `let x = loop { break 22 };`.\r\n \r\n**Efficiency note.** We may not want to create a bunch of dummy basic blocks for **every block**. Unfortunately, because MIR and CFG construction works forward, this is sort of hard to avoid. To fix this, I think we will want to extend the HIR for a block to include a boolean indicating whether it is targeted by any breaks, so we can only add the dummy node for those cases where it is needed. This will also mean you have to edit the HAIR, which is a kind of simple, HIR-like representation that exists briefly as we lower to MIR (`src/librustc_mir/hair/`). This change should be fairly straightforward -- in particular, until the next step, NO blocks can be targeted by breaks, so we can just set this value to always be false.\r\n\r\n### The final change: adding `catch` to the HIR\r\n\r\nWith those pieces in place, we can finally put all the various bits together. Basically when building the HIR for `catch { ... }`, we would do the following:\r\n\r\n- create a block that is eligible to be the target of a break (the boolean is true)\r\n- push the id for this block onto the internal stack of catch nodes\r\n- when we see `?`, we would construct an `ExprBreak` targeting this block (with a value), instead of a `ExprReturn`\r\n\r\nThat's \"it\"! Then we can write some tests!", "closed_by": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/39849/reactions", "total_count": 4, "+1": 0, "-1": 0, "laugh": 0, "hooray": 4, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/39849/timeline", "performed_via_github_app": null, "state_reason": "completed"}