{"url": "https://api.github.com/repos/rust-lang/rust/issues/66265", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/66265/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/66265/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/66265/events", "html_url": "https://github.com/rust-lang/rust/issues/66265", "id": 520578850, "node_id": "MDU6SXNzdWU1MjA1Nzg4NTA=", "number": 66265, "title": "As of 1.37.0, `dylib` shared libraries no longer support interpositioning of functions defined in C", "user": {"login": "solb", "id": 1214534, "node_id": "MDQ6VXNlcjEyMTQ1MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1214534?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solb", "html_url": "https://github.com/solb", "followers_url": "https://api.github.com/users/solb/followers", "following_url": "https://api.github.com/users/solb/following{/other_user}", "gists_url": "https://api.github.com/users/solb/gists{/gist_id}", "starred_url": "https://api.github.com/users/solb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solb/subscriptions", "organizations_url": "https://api.github.com/users/solb/orgs", "repos_url": "https://api.github.com/users/solb/repos", "events_url": "https://api.github.com/users/solb/events{/privacy}", "received_events_url": "https://api.github.com/users/solb/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 37547, "node_id": "MDU6TGFiZWwzNzU0Nw==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-linkage", "name": "A-linkage", "color": "f7e101", "default": false, "description": "Area: linking into static, shared libraries and binaries"}, {"id": 60344715, "node_id": "MDU6TGFiZWw2MDM0NDcxNQ==", "url": "https://api.github.com/repos/rust-lang/rust/labels/P-medium", "name": "P-medium", "color": "eb6420", "default": false, "description": "Medium priority"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 262252840, "node_id": "MDU6TGFiZWwyNjIyNTI4NDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/regression-from-stable-to-stable", "name": "regression-from-stable-to-stable", "color": "e4008a", "default": false, "description": "Performance or correctness regression from one stable version to another."}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2019-11-10T09:54:25Z", "updated_at": "2020-06-03T19:14:45Z", "closed_at": null, "author_association": "NONE", "active_lock_reason": null, "body": "I encountered a stable-to-stable linking regression while working with a project that compiles to an x86-64 ELF shared library for Linux.  The library exports a Rust interface, but also includes some wrappers of libc functions, written in C, that need to shadow the system implementations via interpositioning.  I perform the final linking step using rustc, which works correctly under rustc 1.36.0 but subtly fails under 1.37.0: the libc wrapper functions are not exported as dynamic symbols, causing the program to behave differently at runtime.  The offending patchset appears to be https://github.com/rust-lang/rust/pull/59752, and I've managed to construct a minimal example to illustrate the problem...\r\n\r\n# Minimal example\r\nThe library consists of two files:\r\n* `interpose.rs` defines a single-function Rust API:\r\n```\r\n#![crate_type = \"dylib\"]\r\n\r\npub fn relax() {\r\n\tprintln!(\"Relax said the night guard\");\r\n}\r\n```\r\n* `exit.c` defines an implementation of `exit()` that should shadow the one in libc:\r\n```\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nvoid exit(int ign) {\r\n\t(void) ign;\r\n\tputs(\"We are programmed to receive\");\r\n}\r\n```\r\nThe following short program, `hotel_california.rs`, will be used to test its behavior:\r\n```\r\nextern crate interpose;\r\n\r\nuse interpose::relax;\r\nuse std::os::raw::c_int;\r\n\r\nextern {\r\n\t// NB: Deliberately returns () instead of ! for the purpose of this example.\r\n\tfn exit(_: c_int);\r\n}\r\n\r\nfn main() {\r\n\trelax();\r\n\tunsafe { exit(1); }\r\n\tprintln!(\"You can check out any time you like but you can never leave\");\r\n}\r\n```\r\n\r\n# Expected behavior (past stable releases)\r\nThis is how the program used to behave when built with a stable compiler:\r\n```\r\n$ rustc --version\r\nrustc 1.36.0 (a53f9df32 2019-07-03)\r\n$ rustc -Cprefer-dynamic -Clink-arg=exit.o interpose.rs\r\n$ rustc -L. -Crpath hotel_california.rs\r\n$ ./hotel_california\r\nRelax said the night guard\r\nWe are programmed to receive\r\nYou can check out any time you like but you can never leave\r\n$ echo $?\r\n0\r\n```\r\nNotice that the call to `exit()` gets intercepted and does not, in fact, exit the program.\r\n\r\n# Broken behavior (as of 1.37.0 stable)\r\nNewer versions of the compiler result in different program output:\r\n```\r\n$ rustc --version\r\nrustc 1.37.0\r\n$ rustc -Cprefer-dynamic -Clink-arg=exit.o interpose.rs\r\n$ rustc -L. -Crpath hotel_california.rs\r\n$ ./hotel_california\r\nRelax said the night guard\r\n$ echo $?\r\n1\r\n```\r\n\r\n# Discussion: symbol table entries\r\nThe problem is evident upon examining the static and dynamic symbol tables of the `libinterpose.so` file.  When built with rustc 1.36.0, we see that `exit` is exported in the dynamic symbol table (indicated by the `D`):\r\n```\r\n$ objdump -tT libinterpose.so | grep exit$\r\n000000000000118c g     F .text  000000000000001a exit\r\n000000000000118c g    DF .text  000000000000001a exit\r\n```\r\nIn contrast, the output from rustc 1.37.0 doesn't list `exit` in the dynamic symbol table because the static symbol table lists it as a local symbol (`l`) rather than a global one (`g`):\r\n```\r\n$ objdump -tT libinterpose.so | grep exit$\r\n000000000000118c l     F .text  000000000000001a exit\r\n```\r\n\r\n# Discussion: linker invocation\r\nI was curious to see how rustc was invoking cc to link the program, so I traced the command-line arguments by substituting the fake linker `false`.  Here's with rustc 1.36.0:\r\n```\r\n$ rustc -Clinker=false -Cprefer-dynamic -Clink-arg=exit.o interpose.rs\r\nerror: linking with `false` failed: exit code: 1\r\n  |\r\n  = note: \"false\" \"-Wl,--as-needed\" \"-Wl,-z,noexecstack\" \"-m64\" \"-L\" \"/home/solb/Desktop/rust-1.36/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"interpose.interpose.3a1fbbbh-cgu.0.rcgu.o\" \"interpose.interpose.3a1fbbbh-cgu.1.rcgu.o\" \"-o\" \"libinterpose.so\" \"in\r\nterpose.54bybojgvbim5uqh.rcgu.o\" \"-Wl,-zrelro\" \"-Wl,-znow\" \"-nodefaultlibs\" \"-L\" \"/home/solb/Desktop/rust-1.36/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"-Wl,--start-group\" \"-L\" \"/home/solb/Desktop/rust-1.36/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"-lst\r\nd-9895e8982b0a79e7\" \"-Wl,--end-group\" \"-Wl,-Bstatic\" \"/tmp/user/1000/rustchJWjrY/libcompiler_builtins-38e90baf978bc428.rlib\" \"-Wl,-Bdynamic\" \"-ldl\" \"-lrt\" \"-lpthread\" \"-lgcc_s\" \"-lc\" \"-lm\" \"-lrt\" \"-lpthread\" \"-lutil\" \"-lutil\" \"-shared\" \"exit.o\"\r\n  = note: \r\n\r\nerror: aborting due to previous error\r\n```\r\nAnd with rustc 1.37.0:\r\n```\r\n$ rustc -Clinker=false -Cprefer-dynamic -Clink-arg=exit.o interpose.rs\r\nerror: linking with `false` failed: exit code: 1\r\n  |\r\n  = note: \"false\" \"-Wl,--as-needed\" \"-Wl,-z,noexecstack\" \"-m64\" \"-L\" \"/usr/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"interpose.interpose.3a1fbbbh-cgu.0.rcgu.o\" \"interpose.interpose.3a1fbbbh-cgu.1.rcgu.o\" \"-o\" \"libinterpose.so\" \"-Wl,--version-script=/tmp/\r\nuser/1000/rustc7Re7af/list\" \"interpose.54bybojgvbim5uqh.rcgu.o\" \"-Wl,-zrelro\" \"-Wl,-znow\" \"-nodefaultlibs\" \"-L\" \"/usr/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"-Wl,--start-group\" \"-L\" \"/usr/lib/x86_64-linux-gnu\" \"-lstd-6c8733432f42c6a2\" \"-Wl,--end-group\"\r\n \"-Wl,-Bstatic\" \"/tmp/user/1000/rustc7Re7af/libcompiler_builtins-67541964815c9eb5.rlib\" \"-Wl,-Bdynamic\" \"-ldl\" \"-lrt\" \"-lpthread\" \"-lgcc_s\" \"-lc\" \"-lm\" \"-lrt\" \"-lpthread\" \"-lutil\" \"-lutil\" \"-shared\" \"-Wl,-soname=libinterpose.so\" \"exit.o\"\r\n  = note: \r\n\r\nerror: aborting due to previous error\r\n```\r\nNotice the newly-added `-Wl,--version-script` flag, which has no knowledge of the symbols from the `exit.o` object file.\r\n\r\n# Discussion: static library instead of bare object file\r\nOne might be tempted to work around the problem by telling rustc about the object file so it can keep the symbols it defines global.  I tried this on rustc 1.36.0:\r\n```\r\n$ ar rs libexit.a exit.o\r\nar: creating libexit.a\r\n$ rustc -Cprefer-dynamic -L. interpose.rs -lexit\r\n$ rustc -L. -Crpath hotel_california.rs\r\n```\r\nThis has a very surprising result: the exit symbol is not present at all in `libinterpose.so`, but it does exist somewhere (the LLVM bitcode for monomorphization, maybe?) that allows the compiler to statically link it into the **executable**:\r\n```\r\n$ objdump -tT libinterpose.so | grep exit$\r\n$ objdump -tT hotel_california | grep exit$\r\n0000000000001337 g     F .text  000000000000001a              exit\r\n0000000000001337 g    DF .text  000000000000001a  Base        exit\r\n```\r\nThis is no good either because it leads to subtly different interposition behavior.  For example:\r\n* Before, `exit()` could be further shadowed by libraries loaded via the `LD_PRELOAD` environment variable.  Building it directly into the executable breaks this.\r\n* The `cc` and `ld` apply very different optimizations to `exit()` because it is now part of a PIE instead of a PIC object; depending on how wrapping is implemented, this can break it and even result in infinite recursion.\r\n* If a C program links against `libinterpose.so`, it will no longer get the interposed version of `exit()`.  This is a very real situation for my project, because it also exports a C API via Rust's FFI.\r\n\r\n# Possible mitigation: expose a `-Climit_rdylib_exports` command-line switch\r\nThe simplest way to allow users to work around this would be to allow invokers of rustc to opt out of the change introduced by https://github.com/rust-lang/rust/pull/59752.  However, the change is likely to have broken other use cases as well, so perhaps it needs to be revisited in more detail.\r\n\r\n# See also\r\nThe same changeset seems to be causing problems with inline functions, as observed at https://github.com/rust-lang/rust/issues/65610.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/66265/reactions", "total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/66265/timeline", "performed_via_github_app": null, "state_reason": null}