{"url": "https://api.github.com/repos/rust-lang/rust/issues/48837", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/48837/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/48837/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/48837/events", "html_url": "https://github.com/rust-lang/rust/issues/48837", "id": 303360361, "node_id": "MDU6SXNzdWUzMDMzNjAzNjE=", "number": 48837, "title": "Reference to a #[thread_local] is dereferenced too early", "user": {"login": "joshlf", "id": 1046063, "node_id": "MDQ6VXNlcjEwNDYwNjM=", "avatar_url": "https://avatars.githubusercontent.com/u/1046063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joshlf", "html_url": "https://github.com/joshlf", "followers_url": "https://api.github.com/users/joshlf/followers", "following_url": "https://api.github.com/users/joshlf/following{/other_user}", "gists_url": "https://api.github.com/users/joshlf/gists{/gist_id}", "starred_url": "https://api.github.com/users/joshlf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joshlf/subscriptions", "organizations_url": "https://api.github.com/users/joshlf/orgs", "repos_url": "https://api.github.com/users/joshlf/repos", "events_url": "https://api.github.com/users/joshlf/events{/privacy}", "received_events_url": "https://api.github.com/users/joshlf/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 123111, "node_id": "MDU6TGFiZWwxMjMxMTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/O-macos", "name": "O-macos", "color": "6e6ec0", "default": false, "description": "Operating system: macOS"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 632886930, "node_id": "MDU6TGFiZWw2MzI4ODY5MzA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-thread-locals", "name": "A-thread-locals", "color": "f7e101", "default": false, "description": "Area: Thread local storage (TLS)"}, {"id": 650731663, "node_id": "MDU6TGFiZWw2NTA3MzE2NjM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-bug", "name": "C-bug", "color": "f5f1fd", "default": false, "description": "Category: This is a bug."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2018-03-08T05:22:48Z", "updated_at": "2020-04-20T20:23:42Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I'm working on the [dynamic library for elfmalloc](https://github.com/ezrosent/allocators-rs/tree/master/elfc) for Mac, and one of the caveats that we have to work with is that, during dynamic library loading, TLS is unavailable (if you try to access a `#[thread_local]`, the program simply aborts).\r\n\r\nIn order to work around this, we have a mechanism which checks to make sure that dynamic loading is finished before we access any thread-local storage (see the [`with` method](https://github.com/ezrosent/allocators-rs/blob/6f85313c51f42f0b4f8ea7d6d938caa5eab54412/alloc-tls/src/lib.rs#L209)).\r\n\r\nRecently, we encountered a strange bug: We were spuriously accessing thread-local values while dynamic loading was still happening. The code in question looks like this:\r\n\r\n```rust\r\npub unsafe fn alloc(size: usize) -> *mut u8 {\r\n    LOCAL_ELF_HEAP.with(|h| (*h.get()).alloc.alloc(size))\r\n        .unwrap_or_else(|| super::large_alloc::alloc(size))\r\n}\r\n```\r\n\r\n`LOCAL_ELF_HEAP` is a `#[thread_local]` variable, and in the `with` method, we make sure that dynamic loading is done before we dereference `&self`. To make a long story short, it appears as though the generated code has reordered the instructions to dereference `LOCAL_ELF_HEAP` *before* we check to make sure that dynamic loading is done. You can see that in the disassembly of the `alloc` method (output from lldb):\r\n\r\n```text\r\n    0x10f1b7670 <+0>:  pushq  %rbp\r\n    0x10f1b7671 <+1>:  movq   %rsp, %rbp\r\n    0x10f1b7674 <+4>:  subq   $0x40, %rsp\r\n    0x10f1b7678 <+8>:  leaq   -0x20(%rbp), %rax\r\n    0x10f1b767c <+12>: leaq   -0x28(%rbp), %rcx\r\n    0x10f1b7680 <+16>: movq   %rdi, -0x28(%rbp)\r\n    0x10f1b7684 <+20>: movq   %rcx, -0x10(%rbp)\r\n    0x10f1b7688 <+24>: movq   -0x10(%rbp), %rdx\r\n    0x10f1b768c <+28>: leaq   0xaf5f5(%rip), %rdi       ; elfmalloc::general::global::LOCAL_ELF_HEAP::h7d8e035078da16c9\r\n    0x10f1b7693 <+35>: movq   %rax, -0x30(%rbp)\r\n    0x10f1b7697 <+39>: movq   %rdx, -0x38(%rbp)\r\n    0x10f1b769b <+43>: callq  *(%rdi)\r\n->  0x10f1b769d <+45>: leaq   -0x20(%rbp), %rdi\r\n    0x10f1b76a1 <+49>: movq   %rax, %rsi\r\n    0x10f1b76a4 <+52>: movq   -0x38(%rbp), %rdx\r\n    0x10f1b76a8 <+56>: callq  0x10f1e2ac0               ; _$LT$alloc_tls..TLSSlot$LT$T$GT$$GT$::with::h2a59e6dd7499a672 at lib.rs:209\r\n    0x10f1b76ad <+61>: leaq   -0x20(%rbp), %rdi\r\n    0x10f1b76b1 <+65>: leaq   -0x28(%rbp), %rax\r\n    0x10f1b76b5 <+69>: movq   %rax, -0x8(%rbp)\r\n    0x10f1b76b9 <+73>: movq   -0x8(%rbp), %rsi\r\n    0x10f1b76bd <+77>: callq  0x10f1eb9a0               ; _$LT$core..option..Option$LT$T$GT$$GT$::unwrap_or_else::h09d8edc34df58ca5 at option.rs:373\r\n    0x10f1b76c2 <+82>: movq   %rax, -0x40(%rbp)\r\n    0x10f1b76c6 <+86>: movq   -0x40(%rbp), %rax\r\n    0x10f1b76ca <+90>: addq   $0x40, %rsp\r\n    0x10f1b76ce <+94>: popq   %rbp\r\n    0x10f1b76cf <+95>: retq\r\n```\r\n\r\nThe `->` points to where the next instruction to be executed at the time that the program aborted. The `callq` is to `libdyld.dylib`'s `_tlv_bootstrap`, which is simply [implemented as](https://opensource.apple.com/source/dyld/dyld-239.3/src/threadLocalVariables.c) `abort();`.\r\n\r\nThe key thing to note is that the call to `_tlv_boostrap` (which attempts - and fails - to access the `#[thread_local]`) is *before* the call to `with` a couple of instructions later. I'm not positive, but my hypothesis is that the compiler reordered the accesses because immutable references are supposed to guarantee that the referent exists, and so it thought that the reordering was valid.", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/48837/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/48837/timeline", "performed_via_github_app": null, "state_reason": null}