{"url": "https://api.github.com/repos/rust-lang/rust/issues/94047", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/94047/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/94047/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/94047/events", "html_url": "https://github.com/rust-lang/rust/issues/94047", "id": 1139663543, "node_id": "I_kwDOAAsO6M5D7eK3", "number": 94047, "title": "Tracking Issue for `Iterator::try_collect`", "user": {"login": "a-lafrance", "id": 38890624, "node_id": "MDQ6VXNlcjM4ODkwNjI0", "avatar_url": "https://avatars.githubusercontent.com/u/38890624?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a-lafrance", "html_url": "https://github.com/a-lafrance", "followers_url": "https://api.github.com/users/a-lafrance/followers", "following_url": "https://api.github.com/users/a-lafrance/following{/other_user}", "gists_url": "https://api.github.com/users/a-lafrance/gists{/gist_id}", "starred_url": "https://api.github.com/users/a-lafrance/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a-lafrance/subscriptions", "organizations_url": "https://api.github.com/users/a-lafrance/orgs", "repos_url": "https://api.github.com/users/a-lafrance/repos", "events_url": "https://api.github.com/users/a-lafrance/events{/privacy}", "received_events_url": "https://api.github.com/users/a-lafrance/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668062, "node_id": "MDU6TGFiZWwyMTE2NjgwNjI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs-api", "name": "T-libs-api", "color": "bfd4f2", "default": false, "description": "Relevant to the library API team, which will review and decide on the PR/issue."}, {"id": 650846969, "node_id": "MDU6TGFiZWw2NTA4NDY5Njk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-tracking-issue", "name": "C-tracking-issue", "color": "f5f1fd", "default": false, "description": "Category: A tracking issue for an RFC or an unstable feature."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 21, "created_at": "2022-02-16T08:02:29Z", "updated_at": "2023-05-05T12:19:51Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "<!--\r\nThank you for creating a tracking issue!\r\n\r\nTracking issues are for tracking a feature from implementation to stabilization.\r\n\r\nMake sure to include the relevant RFC for the feature if it has one.\r\n\r\nIf the new feature is small, it may be fine to skip the RFC process. In that\r\ncase, you can use use `issue = \"none\"` in your initial implementation PR. The\r\nreviewer will ask you to open a tracking issue if they agree your feature can be\r\nadded without an RFC.\r\n-->\r\n\r\nFeature gate: `#![feature(iterator_try_collect)]`\r\n\r\nThis is a tracking issue for adding the `try_collect()` method to the `Iterator` trait, as originally discussed [here](https://internals.rust-lang.org/t/idea-fallible-iterator-mapping-with-try-map/15715?u=scottmcm). `Iterator::try_collect()` is a fallible variation of `Iterator::collect()` analogous to similar methods for `reduce` and `fold`, among others, that provides a simpler, generic way to collect iterators of `Try` elements into `Try`-wrapped types.\r\n\r\n### Difference from `Iterator::collect`\r\n\r\nIn terms of functionality, the main difference between `try_collect()` and `collect()` is that `try_collect()` allows you to fallibly collect iterators yielding types that implement `Try` but not `FromIterator`, which `collect()` can't do. Concretely this means you can `try_collect()` iterators yielding `ControlFlow<_, i32>` into `ControlFlow<_, Vec<i32>>`, which you can't do with `collect()`.\r\n\r\nIt's also a `&mut self` method instead of `collect`'s `self`, so that you can resume iteration after it early exits on an error.  (Like how `try_fold` is `&mut self` while `fold` is just `self`.)\r\n\r\nAnother benefit of `try_collect()` is discoverability. Because the discoverability of the \"collect-into-`Result`\" appears to be lower than desired, \"promoting\" the technique into its own method seems like a good way to increase its discoverability and reach more users who would find it useful.  (One of many examples of people just not being able to find the `Option: FromIterator` themselves: <https://users.rust-lang.org/t/try-collect-as-iter-consuming-operation/20479?u=scottmcm>.)\r\n\r\nFinally, `try_collect()` presents a small ergonomics benefit in terms of type hints when collecting, namely that you only have to hint at the output type you're collecting into, not the whole `Try` type. For example, that means you can collect an iterator yielding `Result<i32, SomeComplicatedError>` with `try_collect::<Vec<_>>()`, as opposed to having to specify the whole `Result` with `collect::<Result<Vec<_>, _>>()`.\r\n\r\n### Public API\r\n\r\n<!--\r\nFor most library features, it'd be useful to include a summarized version of the public API.\r\n(E.g. just the public function signatures without their doc comments or implementation.)\r\n-->\r\n\r\n```rust\r\ntrait Iterator {\r\n    type Item;\r\n\r\n    fn try_collect<B>(&mut self) -> ChangeOutputType<Self::Item, B>\r\n    where\r\n        Self: Sized,\r\n        <Self as Iterator>::Item: Try,\r\n        <<Self as Iterator>::Item as Try>::Residual: Residual<B>,\r\n        B: FromIterator<<Self::Item as Try>::Output>;\r\n}\r\n```\r\n\r\n### Steps / History\r\n\r\n- [x] Implementation: #94041\r\n- [ ] Final comment period (FCP)\r\n- [ ] Stabilization PR\r\n\r\n<!--\r\nOnce the feature has gone through a few release cycles and there are no\r\nunresolved questions left, the feature might be ready for stabilization.\r\n\r\nIf this feature didn't go through the RFC process, a final comment period\r\n(FCP) is always needed before stabilization. This works as follows:\r\n\r\nA library API team member can kick off the stabilization process, at which point\r\nthe rfcbot will ask all the team members to verify they agree with\r\nstabilization. Once enough members agree and there are no concerns, the final\r\ncomment period begins: this issue will be marked as such and will be listed\r\nin the next This Week in Rust newsletter. If no blocking concerns are raised in\r\nthat period of 10 days, a stabilzation PR can be opened by anyone.\r\n-->\r\n\r\n### Unresolved Questions\r\n\r\n<!--\r\nInclude any open questions that need to be answered before the feature can be\r\nstabilised. If multiple (unrelated) big questions come up, it can be a good idea\r\nto open a separate issue for each, to make it easier to keep track of the\r\ndiscussions.\r\n\r\nIt's useful to link any relevant discussions and conclusions (whether on GitHub,\r\nZulip, or the internals forum) here.\r\n-->\r\n\r\n- [ ] Should it have a more complicated signature to be able to return the partial results too? (@CAD97  https://internals.rust-lang.org/t/idea-fallible-iterator-mapping-with-try-map/15715/6?u=scottmcm )\r\n- [ ] Should it take `self` rather than `&mut self`, to prevent users from accidentally continuing to use the iterator after a `try_collect()` failure? Note that you can still continue to use the iterator if you use `by_ref()` first, so it's not necessarily a functionality change.\r\n- [ ] Does the name `try_collect()` conflict too much with the idea of collecting that's fallible in allocation? (i.e. collecting with `Vec::try_reserve` or similar)\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/94047/reactions", "total_count": 18, "+1": 7, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 2, "rocket": 8, "eyes": 1}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/94047/timeline", "performed_via_github_app": null, "state_reason": null}