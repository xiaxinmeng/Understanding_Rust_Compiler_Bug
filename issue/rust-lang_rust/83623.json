{"url": "https://api.github.com/repos/rust-lang/rust/issues/83623", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/83623/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/83623/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/83623/events", "html_url": "https://github.com/rust-lang/rust/issues/83623", "id": 842843493, "node_id": "MDU6SXNzdWU4NDI4NDM0OTM=", "number": 83623, "title": "&& operator chains (and ||, possibly) generates unoptimizable LLVM IR", "user": {"login": "AngelicosPhosphoros", "id": 13154246, "node_id": "MDQ6VXNlcjEzMTU0MjQ2", "avatar_url": "https://avatars.githubusercontent.com/u/13154246?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AngelicosPhosphoros", "html_url": "https://github.com/AngelicosPhosphoros", "followers_url": "https://api.github.com/users/AngelicosPhosphoros/followers", "following_url": "https://api.github.com/users/AngelicosPhosphoros/following{/other_user}", "gists_url": "https://api.github.com/users/AngelicosPhosphoros/gists{/gist_id}", "starred_url": "https://api.github.com/users/AngelicosPhosphoros/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AngelicosPhosphoros/subscriptions", "organizations_url": "https://api.github.com/users/AngelicosPhosphoros/orgs", "repos_url": "https://api.github.com/users/AngelicosPhosphoros/repos", "events_url": "https://api.github.com/users/AngelicosPhosphoros/events{/privacy}", "received_events_url": "https://api.github.com/users/AngelicosPhosphoros/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 108333, "node_id": "MDU6TGFiZWwxMDgzMzM=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-LLVM", "name": "A-LLVM", "color": "f7e101", "default": false, "description": "Area: Code generation parts specific to LLVM. Both correctness bugs and optimization-related issues."}, {"id": 113376, "node_id": "MDU6TGFiZWwxMTMzNzY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-slow", "name": "I-slow", "color": "e10c02", "default": false, "description": "Problems and improvements with respect to performance of generated code."}, {"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 16, "created_at": "2021-03-28T22:10:25Z", "updated_at": "2023-04-07T17:47:43Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\n\r\n**tl;dr:** Current IR generated by && chain too hard to optimize for LLVM and always compiles to chain of jumps.\r\n\r\nI started of investigation of this from [this Reddit thread](https://www.reddit.com/r/rust/comments/medh15/why_are_derived_partialeqimplementations_not_more/) about lack of using SIMD instructions in PartialEq implementations.\r\n\r\n## Current Rust PartialEq\r\n\r\nI assumed that PartialEq implementation generates code like:\r\n<details><summary>handwritten eq</summary>\r\n<p>\r\n\r\n```rust\r\npub struct Blueprint {\r\n    pub fuel_tank_size: u32,\r\n    pub payload: u32,\r\n    pub wheel_diameter: u32,\r\n    pub wheel_width: u32,\r\n    pub storage: u32,\r\n}\r\n\r\nimpl PartialEq for Blueprint{\r\n    fn eq(&self, other: &Self)->bool{\r\n       (self.fuel_tank_size == other.fuel_tank_size)\r\n            && (self.payload == other.payload)\r\n            && (self.wheel_diameter == other.wheel_diameter)\r\n            && (self.wheel_width == other.wheel_width)\r\n            && (self.storage == other.storage)\r\n    }\r\n}\r\n```\r\n\r\n</p>\r\n</details>\r\nand it produce such asm:\r\n<details>\r\n<p>\r\n\r\n```asm\r\n<example::Blueprint as core::cmp::PartialEq>::eq:\r\n        mov     eax, dword ptr [rdi]\r\n        cmp     eax, dword ptr [rsi]\r\n        jne     .LBB0_1\r\n        mov     eax, dword ptr [rdi + 4]\r\n        cmp     eax, dword ptr [rsi + 4]\r\n        jne     .LBB0_1\r\n        mov     eax, dword ptr [rdi + 8]\r\n        cmp     eax, dword ptr [rsi + 8]\r\n        jne     .LBB0_1\r\n        mov     eax, dword ptr [rdi + 12]\r\n        cmp     eax, dword ptr [rsi + 12]\r\n        jne     .LBB0_1\r\n        mov     ecx, dword ptr [rdi + 16]\r\n        mov     al, 1\r\n        cmp     ecx, dword ptr [rsi + 16]\r\n        jne     .LBB0_1\r\n        ret\r\n.LBB0_1:\r\n        xor     eax, eax\r\n        ret\r\n```\r\n\r\n</p>\r\n</details>\r\n\r\n[godbolt link for handwritten Eq](https://rust.godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(fontScale:14,j:1,lang:rust,selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'pub+struct+Blueprint+%7B%0A++++pub+fuel_tank_size:+u32,%0A++++pub+payload:+u32,%0A++++pub+wheel_diameter:+u32,%0A++++pub+wheel_width:+u32,%0A++++pub+storage:+u32,%0A%7D%0A%0Aimpl+PartialEq+for+Blueprint%7B%0A++++fn+eq(%26self,+other:+%26Self)-%3Ebool%7B%0A+++++++(self.fuel_tank_size+%3D%3D+other.fuel_tank_size)%0A++++++++++++%26%26+(self.payload+%3D%3D+other.payload)%0A++++++++++++%26%26+(self.wheel_diameter+%3D%3D+other.wheel_diameter)%0A++++++++++++%26%26+(self.wheel_width+%3D%3D+other.wheel_width)%0A++++++++++++%26%26+(self.storage+%3D%3D+other.storage)%0A++++%7D%0A%7D'),l:'5',n:'0',o:'Rust+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:r1510,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',libraryCode:'1',trim:'1'),fontScale:14,j:1,lang:rust,libs:!(),options:'-C+opt-level%3D3+-C+target-cpu%3Dhaswell',selection:(endColumn:12,endLineNumber:21,positionColumn:1,positionLineNumber:1,selectionStartColumn:12,selectionStartLineNumber:21,startColumn:1,startLineNumber:1),source:1),l:'5',n:'0',o:'rustc+1.51.0+(Editor+%231,+Compiler+%231)+Rust',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4)\r\n\r\nIt is quite ineffective because have 5 branches which probably can be replaced by few SIMD instructions.\r\n\r\n\r\n## State on Clang land\r\n\r\nSo I decided to look how Clang compiles similar code (to know, if there some LLVM issue). So I written such code:\r\n<details><summary>clang code and asm</summary>\r\n<p>\r\n\r\n```cpp\r\n#include <cstdint>\r\n\r\nstruct Blueprint{\r\n    uint32_t fuel_tank_size;\r\n    uint32_t payload;\r\n    uint32_t wheel_diameter;\r\n    uint32_t wheel_width;\r\n    uint32_t storage;\r\n};\r\n\r\nbool operator==(const Blueprint& th, const Blueprint& arg)noexcept{\r\n    return th.fuel_tank_size == arg.fuel_tank_size\r\n            && th.payload == arg.payload\r\n            && th.wheel_diameter  == arg.wheel_diameter\r\n            && th.wheel_width == arg.wheel_width\r\n            && th.storage == arg.storage;\r\n}\r\n```\r\n\r\nAnd asm\r\n```asm\r\noperator==(Blueprint const&, Blueprint const&):                    # @operator==(Blueprint const&, Blueprint const&)\r\n        movdqu  xmm0, xmmword ptr [rdi]\r\n        movdqu  xmm1, xmmword ptr [rsi]\r\n        pcmpeqb xmm1, xmm0\r\n        movd    xmm0, dword ptr [rdi + 16]      # xmm0 = mem[0],zero,zero,zero\r\n        movd    xmm2, dword ptr [rsi + 16]      # xmm2 = mem[0],zero,zero,zero\r\n        pcmpeqb xmm2, xmm0\r\n        pand    xmm2, xmm1\r\n        pmovmskb        eax, xmm2\r\n        cmp     eax, 65535\r\n        sete    al\r\n        ret\r\n```\r\n\r\n</p>\r\n</details>\r\n\r\nAlso, [godbolt with Clang code](https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(fontScale:14,j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:10,positionColumn:1,positionLineNumber:10,selectionStartColumn:1,selectionStartLineNumber:10,startColumn:1,startLineNumber:10),source:'%23include+%3Ccstdint%3E%0A%0Astruct+Blueprint%7B%0A++++uint32_t+fuel_tank_size%3B%0A++++uint32_t+payload%3B%0A++++uint32_t+wheel_diameter%3B%0A++++uint32_t+wheel_width%3B%0A++++uint32_t+storage%3B%0A%7D%3B%0A%0Abool+operator%3D%3D(const+Blueprint%26+th,+const+Blueprint%26+arg)noexcept%7B%0A++++return+th.fuel_tank_size+%3D%3D+arg.fuel_tank_size%0A++++++++++++%26%26+th.payload+%3D%3D+arg.payload%0A++++++++++++%26%26+th.wheel_diameter++%3D%3D+arg.wheel_diameter%0A++++++++++++%26%26+th.wheel_width+%3D%3D+arg.wheel_width%0A++++++++++++%26%26+th.storage+%3D%3D+arg.storage%3B%0A%7D'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:clang1101,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',libraryCode:'1',trim:'1'),fontScale:14,j:1,lang:c%2B%2B,libs:!(),options:'-O3',selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:1),l:'5',n:'0',o:'x86-64+clang+11.0.1+(Editor+%231,+Compiler+%231)+C%2B%2B',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4).\r\n\r\nAs you see, Clang successfully optimizes the code to use SIMD instructions and doesn't ever generates branches.\r\n\r\n\r\n## Rust variants of good asm generation\r\n\r\nI checked other code variants in Rust.\r\n<details><summary>Rust variants and ASM</summary>\r\n<p>\r\n\r\n```rust\r\npub struct Blueprint {\r\n    pub fuel_tank_size: u32,\r\n    pub payload: u32,\r\n    pub wheel_diameter: u32,\r\n    pub wheel_width: u32,\r\n    pub storage: u32,\r\n}\r\n\r\n// Equivalent of #[derive(PartialEq)]\r\npub fn eq0(a: &Blueprint, b: &Blueprint)->bool{\r\n    (a.fuel_tank_size == b.fuel_tank_size)\r\n        && (a.payload == b.payload)\r\n        && (a.wheel_diameter == b.wheel_diameter)\r\n        && (a.wheel_width == b.wheel_width)\r\n        && (a.storage == b.storage)\r\n}\r\n\r\n// Optimizes good but changes semantics\r\npub fn eq1(a: &Blueprint, b: &Blueprint)->bool{\r\n    (a.fuel_tank_size == b.fuel_tank_size)\r\n        & (a.payload == b.payload)\r\n        & (a.wheel_diameter == b.wheel_diameter)\r\n        & (a.wheel_width == b.wheel_width)\r\n        & (a.storage == b.storage)\r\n}\r\n\r\n// Optimizes good and have same semantics as PartialEq\r\npub fn eq2(a: &Blueprint, b: &Blueprint)->bool{\r\n    if a.fuel_tank_size != b.fuel_tank_size{\r\n        return false;\r\n    }\r\n    if a.payload != b.payload{\r\n        return false;\r\n    }\r\n    if a.wheel_diameter != b.wheel_diameter{\r\n        return false;\r\n    }\r\n    if a.wheel_width != b.wheel_width{\r\n        return false;\r\n    }\r\n    if a.storage != b.storage{\r\n        return false;\r\n    }\r\n    true\r\n}\r\n```\r\n\r\n```asm\r\nexample::eq0:\r\n        mov     eax, dword ptr [rdi]\r\n        cmp     eax, dword ptr [rsi]\r\n        jne     .LBB0_1\r\n        mov     eax, dword ptr [rdi + 4]\r\n        cmp     eax, dword ptr [rsi + 4]\r\n        jne     .LBB0_1\r\n        mov     eax, dword ptr [rdi + 8]\r\n        cmp     eax, dword ptr [rsi + 8]\r\n        jne     .LBB0_1\r\n        mov     eax, dword ptr [rdi + 12]\r\n        cmp     eax, dword ptr [rsi + 12]\r\n        jne     .LBB0_1\r\n        mov     ecx, dword ptr [rdi + 16]\r\n        mov     al, 1\r\n        cmp     ecx, dword ptr [rsi + 16]\r\n        jne     .LBB0_1\r\n        ret\r\n.LBB0_1:\r\n        xor     eax, eax\r\n        ret\r\n\r\nexample::eq1:\r\n        mov     eax, dword ptr [rdi + 16]\r\n        cmp     eax, dword ptr [rsi + 16]\r\n        vmovdqu xmm0, xmmword ptr [rdi]\r\n        sete    cl\r\n        vpcmpeqd        xmm0, xmm0, xmmword ptr [rsi]\r\n        vmovmskps       eax, xmm0\r\n        cmp     al, 15\r\n        sete    al\r\n        and     al, cl\r\n        ret\r\n\r\nexample::eq2:\r\n        vmovdqu xmm0, xmmword ptr [rdi]\r\n        vmovd   xmm1, dword ptr [rdi + 16]\r\n        vmovd   xmm2, dword ptr [rsi + 16]\r\n        vpxor   xmm1, xmm1, xmm2\r\n        vpxor   xmm0, xmm0, xmmword ptr [rsi]\r\n        vpor    xmm0, xmm0, xmm1\r\n        vptest  xmm0, xmm0\r\n        sete    al\r\n        ret\r\n```\r\n\r\n</p>\r\n</details>\r\n\r\nAnd [godbolt link with variants](https://rust.godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlICsupVs1qhiAVwDOBUpMztkBPHUqZa6AMKpW4gLa0QAVkOk16ADJ5amAHJ6ARpmIgATAHZSAB1STCy2lo6%2BkYm3r5KdJbWdrqOzu6y8piK/gwEzMQEgXoGxokKEbRpGQRRtg5Orh7SJdnBeTWZZTFxVQCUsqjixMgcAOSe4vYA1NISisMAQjqYnsRWBMMApG6TSwAMAILDO8ODI1Ti8gD66bQA1se%2BAF4cw%2BIAzC6kG9u7%2B3vMAJ6sqMzoIHuTxeW12eyGwwA7ghMCd8MxdJgCJUgc9XmCPtDYaxjpC8OgCEhUSC3jsPtISMxgHdHmitisACKvV4AehZw2wAEdxHgAG5sNSLVBUZYuB5LQyTLDzXmYCAABRKeDYXLaEqZWw%2BVFow0wnPWEGYgKWLgAbNMjnMFqRhvZjWaLbN5vQ2gBaJYPbD2VDaFZrUG7Q0AOkOJzOlxumGWDyZMdtIaOOPDVzwtzVAbBOxNpuzw2Dnm%2Bv3%2B0djDPjBZ%2Bf3Q6dJmezueDWLhysRyOIJY9ZfsQabOPhracNczu3rZrzzB7MJOeIJCA7ce7vdx%2BMJQ%2BHopzY%2BDFOIVKjnc78Z3e5rjOZWzZwwA8p4lLpU5hJMNgD70LbxItkAgRNSn3JdCISjIJIrxajqeqcIa9rmjMVr0Dadobo6cEEG6Hpej6rB%2BuigYTqGSYiBGD7zl2CZhoRKZpjhw4NhOFZFm%2BB4LkG9FVmuNFbhOS79kiTgkfG3EtrxxDsXWnGTtiy6zvxi5TjiM6rtRYmmuOQbHtSMlqUQu7UqebgapsrLsjed4Pk%2BL4YMMIhvt%2BsqjAiUb/oBeDAVZT6KpkyqsFyoEQtquqci4UFIbBzoyLa0HIWFaGet6vqrEpeAinhianBRkbDGAYCHt2%2BFpRclGYNhGaZsQSLdDqVBsHIHr%2BrWZ4lUlVksYWVaZdlzGsf8xW1mCZUEBVwxVawNUPHVYINbWTVcXJxw8W27U5RJzYOW2PXrsM/WDcNo3jSO%2BmJcly3ySuc5ZUtS4KQg63rltxCVdVRVjUpk1gtNWmUhp53MepRUJSVfXlfdQ2PbVL0HSVBASEV9IQ5sfQdKwIB9IYfSkAYfTrGjqDIwASlIiySF0PT7mKnBowQyNY20HTnEY6xCMj3BoxjWOkDjfRo5IIAM5TmMI6QcCwEgaC6J4eDsGQFAQKL4uSyAxCcIYnAM1QEtttzEB2vzpD2FYGRfMj5OkKLiL0FetCsIbOtYABojsFTaP4GVKSytzOuYAAHskH79MbCzyI7Qh4PYu7EF8WhYEbFPzLo0cdDQ9BMAKXC8AInBCD%2BCsE8H9jc5AHSoLe/ju66GjDEXBCuuwspYTGDzDGXwzpMQ1JV8ggydt%2BkiQvIrBc0kKQqBAZh1AYnDPGYzQVM43C8GEfh0GPggL4U0%2BxJUGdyAUqQt1k2g5Fwzzb8khTFE0VjlBvs%2B8I0%2B9BOPsh7%2BvrScB0RPdL0XCI8jqPo0HHMJDSGQMMTgQZlZBnWHmXAhASCigeBnYYWgxYSz4iaBBbRhj42kBTR2NNSB00MAzJGfRmb/x1hzLmPNSB82pj/PoLgWYAORrg/m%2BDZTEF8CobgQA%3D%3D)\r\n\r\nFunction `eq0` uses `&&`, `eq1` uses `&` so has different semantics, `eq2` has similar semantics but _optimized better_.\r\n`eq1` is very simple case (we have one block generated by rustc which easily optimized) and has different semantics so we skip it.\r\nWe would use `eq0` and `eq2` further.\r\n\r\n## Investigation of LLVM IR\r\n\r\n`clang` and `eq2` cases successfully proved that LLVM capable to optimization of && so I started to investigate generated LLVM IR and optimized LLVM IR. I decided to check differences of IR for clang, eq0 and eq2.\r\n\r\nI would put first generated LLVM IR, its diagram, and optimized LLVM IR for cases. Also, I used different code in files than godbolt so function names aren't match for case names.\r\n\r\n### Clang IR\r\nI compiled code to LLVM IR using `clang++ is_sorted.cpp -O0 -S -emit-llvm`, removed `optnone` attribut manually, then looked optimizations using `opt -O3 -print-before-all -print-after-all 2>passes.ll`\r\n\r\n<details><summary>Code and diagrams</summary>\r\n<p>\r\n<details><summary>real code</summary>\r\n<p>\r\n\r\n```cpp\r\n#include <cstdint>\r\n\r\nstruct Blueprint{\r\n    uint32_t fuel_tank_size;\r\n    uint32_t payload;\r\n    uint32_t wheel_diameter;\r\n    uint32_t wheel_width;\r\n    uint32_t storage;\r\n};\r\n\r\nbool operator==(const Blueprint& th, const Blueprint& arg)noexcept{\r\n    return th.fuel_tank_size == arg.fuel_tank_size\r\n            && th.payload == arg.payload\r\n            && th.wheel_diameter  == arg.wheel_diameter\r\n            && th.wheel_width == arg.wheel_width\r\n            && th.storage == arg.storage;\r\n}\r\n```\r\n\r\n</p>\r\n</details>\r\n\r\nSo first generated LLVM IR\r\n```llvm\r\n%struct.Blueprint = type { i32, i32, i32, i32, i32 }\r\n\r\n; Function Attrs: noinline nounwind optnone uwtable\r\ndefine dso_local zeroext i1 @_ZeqRK9BlueprintS1_(%struct.Blueprint* nonnull align 4 dereferenceable(20) %0, %struct.Blueprint* nonnull align 4 dereferenceable(20) %1) #0 {\r\n  %3 = alloca %struct.Blueprint*, align 8\r\n  %4 = alloca %struct.Blueprint*, align 8\r\n  store %struct.Blueprint* %0, %struct.Blueprint** %3, align 8\r\n  store %struct.Blueprint* %1, %struct.Blueprint** %4, align 8\r\n  %5 = load %struct.Blueprint*, %struct.Blueprint** %3, align 8\r\n  %6 = getelementptr inbounds %struct.Blueprint, %struct.Blueprint* %5, i32 0, i32 0\r\n  %7 = load i32, i32* %6, align 4\r\n  %8 = load %struct.Blueprint*, %struct.Blueprint** %4, align 8\r\n  %9 = getelementptr inbounds %struct.Blueprint, %struct.Blueprint* %8, i32 0, i32 0\r\n  %10 = load i32, i32* %9, align 4\r\n  %11 = icmp eq i32 %7, %10\r\n  br i1 %11, label %12, label %44\r\n\r\n12:                                               ; preds = %2\r\n  %13 = load %struct.Blueprint*, %struct.Blueprint** %3, align 8\r\n  %14 = getelementptr inbounds %struct.Blueprint, %struct.Blueprint* %13, i32 0, i32 1\r\n  %15 = load i32, i32* %14, align 4\r\n  %16 = load %struct.Blueprint*, %struct.Blueprint** %4, align 8\r\n  %17 = getelementptr inbounds %struct.Blueprint, %struct.Blueprint* %16, i32 0, i32 1\r\n  %18 = load i32, i32* %17, align 4\r\n  %19 = icmp eq i32 %15, %18\r\n  br i1 %19, label %20, label %44\r\n\r\n20:                                               ; preds = %12\r\n  %21 = load %struct.Blueprint*, %struct.Blueprint** %3, align 8\r\n  %22 = getelementptr inbounds %struct.Blueprint, %struct.Blueprint* %21, i32 0, i32 2\r\n  %23 = load i32, i32* %22, align 4\r\n  %24 = load %struct.Blueprint*, %struct.Blueprint** %4, align 8\r\n  %25 = getelementptr inbounds %struct.Blueprint, %struct.Blueprint* %24, i32 0, i32 2\r\n  %26 = load i32, i32* %25, align 4\r\n  %27 = icmp eq i32 %23, %26\r\n  br i1 %27, label %28, label %44\r\n\r\n28:                                               ; preds = %20\r\n  %29 = load %struct.Blueprint*, %struct.Blueprint** %3, align 8\r\n  %30 = getelementptr inbounds %struct.Blueprint, %struct.Blueprint* %29, i32 0, i32 3\r\n  %31 = load i32, i32* %30, align 4\r\n  %32 = load %struct.Blueprint*, %struct.Blueprint** %4, align 8\r\n  %33 = getelementptr inbounds %struct.Blueprint, %struct.Blueprint* %32, i32 0, i32 3\r\n  %34 = load i32, i32* %33, align 4\r\n  %35 = icmp eq i32 %31, %34\r\n  br i1 %35, label %36, label %44\r\n\r\n36:                                               ; preds = %28\r\n  %37 = load %struct.Blueprint*, %struct.Blueprint** %3, align 8\r\n  %38 = getelementptr inbounds %struct.Blueprint, %struct.Blueprint* %37, i32 0, i32 4\r\n  %39 = load i32, i32* %38, align 4\r\n  %40 = load %struct.Blueprint*, %struct.Blueprint** %4, align 8\r\n  %41 = getelementptr inbounds %struct.Blueprint, %struct.Blueprint* %40, i32 0, i32 4\r\n  %42 = load i32, i32* %41, align 4\r\n  %43 = icmp eq i32 %39, %42\r\n  br label %44\r\n\r\n44:                                               ; preds = %36, %28, %20, %12, %2\r\n  %45 = phi i1 [ false, %28 ], [ false, %20 ], [ false, %12 ], [ false, %2 ], [ %43, %36 ]\r\n  ret i1 %45\r\n}\r\n```\r\n\r\nPicture of control flow\r\n![Clang control flow diagram](https://user-images.githubusercontent.com/13154246/112767711-f5ac6000-9020-11eb-8a81-fbe43eade0bf.png)\r\n\r\nOptimized LLVM\r\n```llvm\r\n; Function Attrs: noinline norecurse nounwind readonly uwtable\r\ndefine dso_local zeroext i1 @_ZeqRK9BlueprintS1_(%struct.Blueprint* nocapture nonnull readonly align 4 dereferenceable(20) %0, %struct.Blueprint* nocapture nonnull readonly align 4 dereferenceable(20) %1) local_unnamed_addr #0 {\r\n  %3 = getelementptr inbounds %struct.Blueprint, %struct.Blueprint* %0, i64 0, i32 0\r\n  %4 = load i32, i32* %3, align 4\r\n  %5 = getelementptr inbounds %struct.Blueprint, %struct.Blueprint* %1, i64 0, i32 0\r\n  %6 = load i32, i32* %5, align 4\r\n  %7 = icmp eq i32 %4, %6\r\n  br i1 %7, label %8, label %32\r\n\r\n8:                                                ; preds = %2\r\n  %9 = getelementptr inbounds %struct.Blueprint, %struct.Blueprint* %0, i64 0, i32 1\r\n  %10 = load i32, i32* %9, align 4\r\n  %11 = getelementptr inbounds %struct.Blueprint, %struct.Blueprint* %1, i64 0, i32 1\r\n  %12 = load i32, i32* %11, align 4\r\n  %13 = icmp eq i32 %10, %12\r\n  br i1 %13, label %14, label %32\r\n\r\n14:                                               ; preds = %8\r\n  %15 = getelementptr inbounds %struct.Blueprint, %struct.Blueprint* %0, i64 0, i32 2\r\n  %16 = load i32, i32* %15, align 4\r\n  %17 = getelementptr inbounds %struct.Blueprint, %struct.Blueprint* %1, i64 0, i32 2\r\n  %18 = load i32, i32* %17, align 4\r\n  %19 = icmp eq i32 %16, %18\r\n  br i1 %19, label %20, label %32\r\n\r\n20:                                               ; preds = %14\r\n  %21 = getelementptr inbounds %struct.Blueprint, %struct.Blueprint* %0, i64 0, i32 3\r\n  %22 = load i32, i32* %21, align 4\r\n  %23 = getelementptr inbounds %struct.Blueprint, %struct.Blueprint* %1, i64 0, i32 3\r\n  %24 = load i32, i32* %23, align 4\r\n  %25 = icmp eq i32 %22, %24\r\n  br i1 %25, label %26, label %32\r\n\r\n26:                                               ; preds = %20\r\n  %27 = getelementptr inbounds %struct.Blueprint, %struct.Blueprint* %0, i64 0, i32 4\r\n  %28 = load i32, i32* %27, align 4\r\n  %29 = getelementptr inbounds %struct.Blueprint, %struct.Blueprint* %1, i64 0, i32 4\r\n  %30 = load i32, i32* %29, align 4\r\n  %31 = icmp eq i32 %28, %30\r\n  br label %32\r\n\r\n32:                                               ; preds = %26, %20, %14, %8, %2\r\n  %33 = phi i1 [ false, %20 ], [ false, %14 ], [ false, %8 ], [ false, %2 ], [ %31, %26 ]\r\n  ret i1 %33\r\n}\r\n```\r\n</details>\r\n\r\nAs you see, Clang original code doesn't changed much, it removed only copying from source structs to temporary locals.\r\nOriginal control flow is very clear and last block utilizes single phi node with a lot of inputs to fill result value.\r\n\r\n### Rust eq2 case\r\n\r\nI generated LLVM code using such command: `rustc +nightly cmp.rs --emit=llvm-ir -C opt-level=3 -C codegen-units=1 --crate-type=rlib -C 'llvm-args=-print-after-all -print-before-all' 2>passes.ll`\r\n\r\n<details><summary>Rust eq2 case IR and graphs</summary>\r\n<details><summary>real code</summary>\r\n\r\n```rust\r\npub struct Blueprint {\r\n    pub fuel_tank_size: u32,\r\n    pub payload: u32,\r\n    pub wheel_diameter: u32,\r\n    pub wheel_width: u32,\r\n    pub storage: u32,\r\n}\r\n\r\nimpl PartialEq for Blueprint{\r\n    fn eq(&self, other: &Self)->bool{\r\n        if self.fuel_tank_size != other.fuel_tank_size{\r\n            return false;\r\n        }\r\n        if self.payload != other.payload{\r\n            return false;\r\n        }\r\n        if self.wheel_diameter != other.wheel_diameter{\r\n            return false;\r\n        }\r\n        if self.wheel_width != other.wheel_width{\r\n            return false;\r\n        }\r\n        if self.storage != other.storage{\r\n            return false;\r\n        }\r\n       true\r\n    }\r\n}\r\n```\r\n\r\n</details>\r\n\r\nIt generates such IR:\r\n```llvm\r\n; Function Attrs: nonlazybind uwtable\r\ndefine zeroext i1 @\"_ZN55_$LT$cmp..Blueprint$u20$as$u20$core..cmp..PartialEq$GT$2eq17h7ce388cf7c1072a4E\"(%Blueprint* noalias readonly align 4 dereferenceable(20) %self, %Blueprint* noalias readonly align 4 dereferenceable(20) %other) unnamed_addr #0 {\r\nstart:\r\n  %0 = alloca i8, align 1\r\n  %1 = bitcast %Blueprint* %self to i32*\r\n  %_4 = load i32, i32* %1, align 4\r\n  %2 = bitcast %Blueprint* %other to i32*\r\n  %_5 = load i32, i32* %2, align 4\r\n  %_3 = icmp ne i32 %_4, %_5\r\n  br i1 %_3, label %bb1, label %bb2\r\n\r\nbb1:                                              ; preds = %start\r\n  store i8 0, i8* %0, align 1\r\n  br label %bb11\r\n\r\nbb2:                                              ; preds = %start\r\n  %3 = getelementptr inbounds %Blueprint, %Blueprint* %self, i32 0, i32 3\r\n  %_7 = load i32, i32* %3, align 4\r\n  %4 = getelementptr inbounds %Blueprint, %Blueprint* %other, i32 0, i32 3\r\n  %_8 = load i32, i32* %4, align 4\r\n  %_6 = icmp ne i32 %_7, %_8\r\n  br i1 %_6, label %bb3, label %bb4\r\n\r\nbb3:                                              ; preds = %bb2\r\n  store i8 0, i8* %0, align 1\r\n  br label %bb11\r\n\r\nbb4:                                              ; preds = %bb2\r\n  %5 = getelementptr inbounds %Blueprint, %Blueprint* %self, i32 0, i32 5\r\n  %_10 = load i32, i32* %5, align 4\r\n  %6 = getelementptr inbounds %Blueprint, %Blueprint* %other, i32 0, i32 5\r\n  %_11 = load i32, i32* %6, align 4\r\n  %_9 = icmp ne i32 %_10, %_11\r\n  br i1 %_9, label %bb5, label %bb6\r\n\r\nbb5:                                              ; preds = %bb4\r\n  store i8 0, i8* %0, align 1\r\n  br label %bb11\r\n\r\nbb6:                                              ; preds = %bb4\r\n  %7 = getelementptr inbounds %Blueprint, %Blueprint* %self, i32 0, i32 7\r\n  %_13 = load i32, i32* %7, align 4\r\n  %8 = getelementptr inbounds %Blueprint, %Blueprint* %other, i32 0, i32 7\r\n  %_14 = load i32, i32* %8, align 4\r\n  %_12 = icmp ne i32 %_13, %_14\r\n  br i1 %_12, label %bb7, label %bb8\r\n\r\nbb7:                                              ; preds = %bb6\r\n  store i8 0, i8* %0, align 1\r\n  br label %bb11\r\n\r\nbb8:                                              ; preds = %bb6\r\n  %9 = getelementptr inbounds %Blueprint, %Blueprint* %self, i32 0, i32 9\r\n  %_16 = load i32, i32* %9, align 4\r\n  %10 = getelementptr inbounds %Blueprint, %Blueprint* %other, i32 0, i32 9\r\n  %_17 = load i32, i32* %10, align 4\r\n  %_15 = icmp ne i32 %_16, %_17\r\n  br i1 %_15, label %bb9, label %bb10\r\n\r\nbb9:                                              ; preds = %bb8\r\n  store i8 0, i8* %0, align 1\r\n  br label %bb11\r\n\r\nbb10:                                             ; preds = %bb8\r\n  store i8 1, i8* %0, align 1\r\n  br label %bb11\r\n\r\nbb11:                                             ; preds = %bb10, %bb9, %bb7, %bb5, %bb3, %bb1\r\n  %11 = load i8, i8* %0, align 1, !range !2\r\n  %12 = trunc i8 %11 to i1\r\n  ret i1 %12\r\n}\r\n```\r\nWhich can be described with such picture\r\n![Rust eq2 control flow](https://user-images.githubusercontent.com/13154246/112768100-f3e39c00-9022-11eb-81e9-b97195c50e19.png)\r\n\r\nAnd after optimizations it would end with:\r\n```llvm\r\n; Function Attrs: norecurse nounwind nonlazybind readonly uwtable willreturn\r\ndefine zeroext i1 @\"_ZN55_$LT$cmp..Blueprint$u20$as$u20$core..cmp..PartialEq$GT$2eq17h7ce388cf7c1072a4E\"(%Blueprint* noalias nocapture readonly align 4 dereferenceable(20) %self, %Blueprint* noalias nocapture readonly align 4 dereferenceable(20) %other) unnamed_addr #0 {\r\nstart:\r\n  %0 = getelementptr inbounds %Blueprint, %Blueprint* %self, i64 0, i32 0, i64 0\r\n  %_4 = load i32, i32* %0, align 4\r\n  %1 = getelementptr inbounds %Blueprint, %Blueprint* %other, i64 0, i32 0, i64 0\r\n  %_5 = load i32, i32* %1, align 4\r\n  %_3.not = icmp eq i32 %_4, %_5\r\n  br i1 %_3.not, label %bb2, label %bb11\r\n\r\nbb2:                                              ; preds = %start\r\n  %2 = getelementptr inbounds %Blueprint, %Blueprint* %self, i64 0, i32 3\r\n  %_7 = load i32, i32* %2, align 4\r\n  %3 = getelementptr inbounds %Blueprint, %Blueprint* %other, i64 0, i32 3\r\n  %_8 = load i32, i32* %3, align 4\r\n  %_6.not = icmp eq i32 %_7, %_8\r\n  br i1 %_6.not, label %bb4, label %bb11\r\n\r\nbb4:                                              ; preds = %bb2\r\n  %4 = getelementptr inbounds %Blueprint, %Blueprint* %self, i64 0, i32 5\r\n  %_10 = load i32, i32* %4, align 4\r\n  %5 = getelementptr inbounds %Blueprint, %Blueprint* %other, i64 0, i32 5\r\n  %_11 = load i32, i32* %5, align 4\r\n  %_9.not = icmp eq i32 %_10, %_11\r\n  br i1 %_9.not, label %bb6, label %bb11\r\n\r\nbb6:                                              ; preds = %bb4\r\n  %6 = getelementptr inbounds %Blueprint, %Blueprint* %self, i64 0, i32 7\r\n  %_13 = load i32, i32* %6, align 4\r\n  %7 = getelementptr inbounds %Blueprint, %Blueprint* %other, i64 0, i32 7\r\n  %_14 = load i32, i32* %7, align 4\r\n  %_12.not = icmp eq i32 %_13, %_14\r\n  br i1 %_12.not, label %bb8, label %bb11\r\n\r\nbb8:                                              ; preds = %bb6\r\n  %8 = getelementptr inbounds %Blueprint, %Blueprint* %self, i64 0, i32 9\r\n  %_16 = load i32, i32* %8, align 4\r\n  %9 = getelementptr inbounds %Blueprint, %Blueprint* %other, i64 0, i32 9\r\n  %_17 = load i32, i32* %9, align 4\r\n  %_15.not = icmp eq i32 %_16, %_17\r\n  ret i1 %_15.not\r\n\r\nbb11:                                             ; preds = %bb6, %bb4, %bb2, %start\r\n  ret i1 false\r\n}\r\n```\r\n\r\n</details>\r\n\r\nIn general, algorithm can be described as \r\n1. Allocate single byte in stack and store its reference\r\n2. In bad cases stores `false` into the byte and jump to end.\r\n3. In last check store last comparison into byte and jump to end\r\n4. return data from byte.\r\n\r\nThis indirect usage of byte is optimized in mem2reg phase to pretty SSA form and control flow remains forward only.\r\n\r\n### Rust eq0 case (which used in reality very often and optimizes bad)\r\n\r\n<details><summary>IR code and control flow diagrams</summary>\r\n<details><summary>Real code</summary>\r\n\r\n```rust\r\npub struct Blueprint {\r\n    pub fuel_tank_size: u32,\r\n    pub payload: u32,\r\n    pub wheel_diameter: u32,\r\n    pub wheel_width: u32,\r\n    pub storage: u32,\r\n}\r\nimpl PartialEq for Blueprint{\r\n   fn eq(&self, other: &Self)->bool{\r\n      (self.fuel_tank_size == other.fuel_tank_size)\r\n           && (self.payload == other.payload)\r\n           && (self.wheel_diameter == other.wheel_diameter)\r\n           && (self.wheel_width == other.wheel_width)\r\n           && (self.storage == other.storage)\r\n   }\r\n}\r\n```\r\n\r\n</details>\r\n\r\nSo, rustc generates such code:\r\n```llvm\r\n; Function Attrs: nonlazybind uwtable\r\ndefine zeroext i1 @\"_ZN55_$LT$cmp..Blueprint$u20$as$u20$core..cmp..PartialEq$GT$2eq17h7ce388cf7c1072a4E\"(%Blueprint* noalias readonly align 4 dereferenceable(20) %self, %Blueprint* noalias readonly align 4 dereferenceable(20) %other) unnamed_addr #0 {\r\nstart:\r\n  %_5 = alloca i8, align 1\r\n  %_4 = alloca i8, align 1\r\n  %_3 = alloca i8, align 1\r\n  %0 = alloca i8, align 1\r\n  call void @llvm.lifetime.start.p0i8(i64 1, i8* %_3)\r\n  call void @llvm.lifetime.start.p0i8(i64 1, i8* %_4)\r\n  call void @llvm.lifetime.start.p0i8(i64 1, i8* %_5)\r\n  %1 = bitcast %Blueprint* %self to i32*\r\n  %_7 = load i32, i32* %1, align 4\r\n  %2 = bitcast %Blueprint* %other to i32*\r\n  %_8 = load i32, i32* %2, align 4\r\n  %_6 = icmp eq i32 %_7, %_8\r\n  br i1 %_6, label %bb15, label %bb14\r\n\r\nbb1:                                              ; preds = %bb3\r\n  store i8 1, i8* %0, align 1\r\n  br label %bb4\r\n\r\nbb2:                                              ; preds = %bb3, %bb8\r\n  store i8 0, i8* %0, align 1\r\n  br label %bb4\r\n\r\nbb3:                                              ; preds = %bb8\r\n  %3 = getelementptr inbounds %Blueprint, %Blueprint* %self, i32 0, i32 9\r\n  %_19 = load i32, i32* %3, align 4\r\n  %4 = getelementptr inbounds %Blueprint, %Blueprint* %other, i32 0, i32 9\r\n  %_20 = load i32, i32* %4, align 4\r\n  %_18 = icmp eq i32 %_19, %_20\r\n  br i1 %_18, label %bb1, label %bb2\r\n\r\nbb4:                                              ; preds = %bb2, %bb1\r\n  call void @llvm.lifetime.end.p0i8(i64 1, i8* %_3)\r\n  %5 = load i8, i8* %0, align 1, !range !2\r\n  %6 = trunc i8 %5 to i1\r\n  ret i1 %6\r\n\r\nbb5:                                              ; preds = %bb7\r\n  store i8 1, i8* %_3, align 1\r\n  br label %bb8\r\n\r\nbb6:                                              ; preds = %bb7, %bb12\r\n  store i8 0, i8* %_3, align 1\r\n  br label %bb8\r\n\r\nbb7:                                              ; preds = %bb12\r\n  %7 = getelementptr inbounds %Blueprint, %Blueprint* %self, i32 0, i32 7\r\n  %_16 = load i32, i32* %7, align 4\r\n  %8 = getelementptr inbounds %Blueprint, %Blueprint* %other, i32 0, i32 7\r\n  %_17 = load i32, i32* %8, align 4\r\n  %_15 = icmp eq i32 %_16, %_17\r\n  br i1 %_15, label %bb5, label %bb6\r\n\r\nbb8:                                              ; preds = %bb6, %bb5\r\n  call void @llvm.lifetime.end.p0i8(i64 1, i8* %_4)\r\n  %9 = load i8, i8* %_3, align 1, !range !2\r\n  %10 = trunc i8 %9 to i1\r\n  br i1 %10, label %bb3, label %bb2\r\n\r\nbb9:                                              ; preds = %bb11\r\n  store i8 1, i8* %_4, align 1\r\n  br label %bb12\r\n\r\nbb10:                                             ; preds = %bb11, %bb16\r\n  store i8 0, i8* %_4, align 1\r\n  br label %bb12\r\n\r\nbb11:                                             ; preds = %bb16\r\n  %11 = getelementptr inbounds %Blueprint, %Blueprint* %self, i32 0, i32 5\r\n  %_13 = load i32, i32* %11, align 4\r\n  %12 = getelementptr inbounds %Blueprint, %Blueprint* %other, i32 0, i32 5\r\n  %_14 = load i32, i32* %12, align 4\r\n  %_12 = icmp eq i32 %_13, %_14\r\n  br i1 %_12, label %bb9, label %bb10\r\n\r\nbb12:                                             ; preds = %bb10, %bb9\r\n  call void @llvm.lifetime.end.p0i8(i64 1, i8* %_5)\r\n  %13 = load i8, i8* %_4, align 1, !range !2\r\n  %14 = trunc i8 %13 to i1\r\n  br i1 %14, label %bb7, label %bb6\r\n\r\nbb13:                                             ; preds = %bb15\r\n  store i8 1, i8* %_5, align 1\r\n  br label %bb16\r\n\r\nbb14:                                             ; preds = %bb15, %start\r\n  store i8 0, i8* %_5, align 1\r\n  br label %bb16\r\n\r\nbb15:                                             ; preds = %start\r\n  %15 = getelementptr inbounds %Blueprint, %Blueprint* %self, i32 0, i32 3\r\n  %_10 = load i32, i32* %15, align 4\r\n  %16 = getelementptr inbounds %Blueprint, %Blueprint* %other, i32 0, i32 3\r\n  %_11 = load i32, i32* %16, align 4\r\n  %_9 = icmp eq i32 %_10, %_11\r\n  br i1 %_9, label %bb13, label %bb14\r\n\r\nbb16:                                             ; preds = %bb14, %bb13\r\n  %17 = load i8, i8* %_5, align 1, !range !2\r\n  %18 = trunc i8 %17 to i1\r\n  br i1 %18, label %bb11, label %bb10\r\n}\r\n```\r\n\r\nWhich has such control flow\r\n![Control flow of eq0 case](https://user-images.githubusercontent.com/13154246/112769453-b9c9c880-9029-11eb-999a-c237870186f3.png)\r\n\r\nAnd get optimized to this:\r\n```llvm\r\n; Function Attrs: norecurse nounwind nonlazybind readonly uwtable willreturn\r\ndefine zeroext i1 @\"_ZN55_$LT$cmp..Blueprint$u20$as$u20$core..cmp..PartialEq$GT$2eq17h7ce388cf7c1072a4E\"(%Blueprint* noalias nocapture readonly align 4 dereferenceable(20) %self, %Blueprint* noalias nocapture readonly align 4 dereferenceable(20) %other) unnamed_addr #0 {\r\nstart:\r\n  %0 = getelementptr inbounds %Blueprint, %Blueprint* %self, i64 0, i32 0, i64 0\r\n  %_7 = load i32, i32* %0, align 4\r\n  %1 = getelementptr inbounds %Blueprint, %Blueprint* %other, i64 0, i32 0, i64 0\r\n  %_8 = load i32, i32* %1, align 4\r\n  %_6 = icmp eq i32 %_7, %_8\r\n  br i1 %_6, label %bb15, label %bb2\r\n\r\nbb2:                                              ; preds = %start, %bb15, %bb11, %bb7, %bb3\r\n  br label %bb4\r\n\r\nbb3:                                              ; preds = %bb7\r\n  %2 = getelementptr inbounds %Blueprint, %Blueprint* %self, i64 0, i32 9\r\n  %_19 = load i32, i32* %2, align 4\r\n  %3 = getelementptr inbounds %Blueprint, %Blueprint* %other, i64 0, i32 9\r\n  %_20 = load i32, i32* %3, align 4\r\n  %_18 = icmp eq i32 %_19, %_20\r\n  br i1 %_18, label %bb4, label %bb2\r\n\r\nbb4:                                              ; preds = %bb3, %bb2\r\n  %.0 = phi i1 [ false, %bb2 ], [ true, %bb3 ]\r\n  ret i1 %.0\r\n\r\nbb7:                                              ; preds = %bb11\r\n  %4 = getelementptr inbounds %Blueprint, %Blueprint* %self, i64 0, i32 7\r\n  %_16 = load i32, i32* %4, align 4\r\n  %5 = getelementptr inbounds %Blueprint, %Blueprint* %other, i64 0, i32 7\r\n  %_17 = load i32, i32* %5, align 4\r\n  %_15 = icmp eq i32 %_16, %_17\r\n  br i1 %_15, label %bb3, label %bb2\r\n\r\nbb11:                                             ; preds = %bb15\r\n  %6 = getelementptr inbounds %Blueprint, %Blueprint* %self, i64 0, i32 5\r\n  %_13 = load i32, i32* %6, align 4\r\n  %7 = getelementptr inbounds %Blueprint, %Blueprint* %other, i64 0, i32 5\r\n  %_14 = load i32, i32* %7, align 4\r\n  %_12 = icmp eq i32 %_13, %_14\r\n  br i1 %_12, label %bb7, label %bb2\r\n\r\nbb15:                                             ; preds = %start\r\n  %8 = getelementptr inbounds %Blueprint, %Blueprint* %self, i64 0, i32 3\r\n  %_10 = load i32, i32* %8, align 4\r\n  %9 = getelementptr inbounds %Blueprint, %Blueprint* %other, i64 0, i32 3\r\n  %_11 = load i32, i32* %9, align 4\r\n  %_9 = icmp eq i32 %_10, %_11\r\n  br i1 %_9, label %bb11, label %bb2\r\n}\r\n```\r\n\r\n</details>\r\n\r\nWell, it is really hard to tell whats going on in the generated code. Control flow operators placed basically in reversed order (first checked condition put in last position, then it jumps in both cases back than jumps against after condition), and such behaviour doesn't change during optimization passes and in final generated ASM we end with a lot of jumps and miss SIMD usage.\r\nIt looks like that LLVM fails to reorganize this blocks in more natural order and probably fails to understand many temporary allocas.\r\n\r\n## Conclusions of LLVM IR research\r\n\r\nLet's look the control flow diagrams last time.\r\n\r\nClang:\r\n![Clang control flow diagram](https://user-images.githubusercontent.com/13154246/112767711-f5ac6000-9020-11eb-8a81-fbe43eade0bf.png)\r\n\r\nRust eq2 (with manual early returns)\r\n![Rust eq2 control flow](https://user-images.githubusercontent.com/13154246/112768100-f3e39c00-9022-11eb-81e9-b97195c50e19.png)\r\n\r\nRust eq0 with usage of `&&` operator.\r\n![Control flow of eq0 case](https://user-images.githubusercontent.com/13154246/112769453-b9c9c880-9029-11eb-999a-c237870186f3.png)\r\n\r\nFinally, I have 2 ideas of new algorithms which can be generated by proper codegen for `&&` chains:\r\n\r\n##### First approach\r\nWe need exploit \u03c6 nodes with lots of inputs from Clang approach:\r\nPseudocode:\r\n```\r\nb0:\r\n  if first_equation jump to b1 else to b_last\r\nb1:\r\n  if second_equation jump to b2 else b_last\r\nb2: ...\r\n...\r\nbn: if nth_equation: jump to b_true else b_last:\r\nb_true: jump to b_last\r\nb_last:\r\n  %result = phi i1 [false, b0], [false, b1], ..., [false, bn], [true, b_true]\r\n```\r\nProbably, it is the best solution because LLVM tends to handle Clang approach better and this code is already in SSA form which is loved by optimizations.\r\n\r\n##### Second approach\r\nPseudocode\r\n```\r\nstart: \r\n    %byte = allocate byte here\r\n    store %byte true\r\nb0:\r\n   if first_equation jump to b2 else to b_false\r\nb1:\r\n   if second_equation jump to b3 else to b_false\r\nb2:\r\n...\r\nbn:\r\n   if nth_equation jump to b_last else to b_false\r\nb_false:\r\n   store %byte false\r\nb_last:\r\n   load %byte\r\n```\r\nThis version is less friendly to the optimizer because we use pointer here but it would be converted to SSA form in mem2reg phase of optimization.\r\n\r\nImplementing of such algorithms would probably require handling of chains of && operators as one prefix operator with many arguments e.g. `&&(arg0, arg1, ..., argN)`.\r\n\r\nI don't know which part of pipeline is needed to be changed to fix this and which my suggested generated code is easier to produce.\r\n\r\nAlso, very I expect same problem with `||` operator implementation too.\r\n\r\n## Importance and final thoughts\r\n\r\nThis bug effectively prevents SIMD optimizations in most `#[derive(PartialEq)]` and some other places too so fixing it could lead to big performance gains.  Hope my investigation of this bug would help to fix it.\r\n\r\nAlso, sorry for possible weird wording and grammar mistakes because English isn't native language for me.\r\n\r\nAnd finally, which rustc and clang I used:\r\n```\r\n$ clang++-11 --version\r\nUbuntu clang version 11.0.0-2~ubuntu20.04.1\r\nTarget: x86_64-pc-linux-gnu\r\nThread model: posix\r\nInstalledDir: /usr/bin\r\n\r\n$ rustc +nightly --version\r\nrustc 1.53.0-nightly (07e0e2ec2 2021-03-24)\r\n```", "closed_by": {"login": "AngelicosPhosphoros", "id": 13154246, "node_id": "MDQ6VXNlcjEzMTU0MjQ2", "avatar_url": "https://avatars.githubusercontent.com/u/13154246?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AngelicosPhosphoros", "html_url": "https://github.com/AngelicosPhosphoros", "followers_url": "https://api.github.com/users/AngelicosPhosphoros/followers", "following_url": "https://api.github.com/users/AngelicosPhosphoros/following{/other_user}", "gists_url": "https://api.github.com/users/AngelicosPhosphoros/gists{/gist_id}", "starred_url": "https://api.github.com/users/AngelicosPhosphoros/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AngelicosPhosphoros/subscriptions", "organizations_url": "https://api.github.com/users/AngelicosPhosphoros/orgs", "repos_url": "https://api.github.com/users/AngelicosPhosphoros/repos", "events_url": "https://api.github.com/users/AngelicosPhosphoros/events{/privacy}", "received_events_url": "https://api.github.com/users/AngelicosPhosphoros/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/83623/reactions", "total_count": 843, "+1": 388, "-1": 0, "laugh": 0, "hooray": 59, "confused": 0, "heart": 290, "rocket": 76, "eyes": 30}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/83623/timeline", "performed_via_github_app": null, "state_reason": null}