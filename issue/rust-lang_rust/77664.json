{"url": "https://api.github.com/repos/rust-lang/rust/issues/77664", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/77664/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/77664/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/77664/events", "html_url": "https://github.com/rust-lang/rust/issues/77664", "id": 716768509, "node_id": "MDU6SXNzdWU3MTY3Njg1MDk=", "number": 77664, "title": "(Lack of) Polymorphization can lead to an unnecessarily recursive type & make compilation fail", "user": {"login": "danielhenrymantilla", "id": 9920355, "node_id": "MDQ6VXNlcjk5MjAzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/9920355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielhenrymantilla", "html_url": "https://github.com/danielhenrymantilla", "followers_url": "https://api.github.com/users/danielhenrymantilla/followers", "following_url": "https://api.github.com/users/danielhenrymantilla/following{/other_user}", "gists_url": "https://api.github.com/users/danielhenrymantilla/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielhenrymantilla/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielhenrymantilla/subscriptions", "organizations_url": "https://api.github.com/users/danielhenrymantilla/orgs", "repos_url": "https://api.github.com/users/danielhenrymantilla/repos", "events_url": "https://api.github.com/users/danielhenrymantilla/events{/privacy}", "received_events_url": "https://api.github.com/users/danielhenrymantilla/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 234902, "node_id": "MDU6TGFiZWwyMzQ5MDI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/C-enhancement", "name": "C-enhancement", "color": "f5f1fd", "default": false, "description": "Category: An issue proposing an enhancement or a PR with one."}, {"id": 13836860, "node_id": "MDU6TGFiZWwxMzgzNjg2MA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-traits", "name": "A-traits", "color": "f7e101", "default": false, "description": "Area: Trait system"}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 1183099971, "node_id": "MDU6TGFiZWwxMTgzMDk5OTcx", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-suggestion-diagnostics", "name": "A-suggestion-diagnostics", "color": "f7e101", "default": false, "description": "Area: suggestions generated by the compiler applied by cargo fix"}, {"id": 1839565265, "node_id": "MDU6TGFiZWwxODM5NTY1MjY1", "url": "https://api.github.com/repos/rust-lang/rust/labels/D-terse", "name": "D-terse", "color": "c9f7a3", "default": false, "description": "A diagnostic that doesn't give enough information about the problem at hand"}, {"id": 2263949245, "node_id": "MDU6TGFiZWwyMjYzOTQ5MjQ1", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-polymorphization", "name": "A-polymorphization", "color": "f7e101", "default": false, "description": "Area: Polymorphization"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2020-10-07T18:46:24Z", "updated_at": "2022-10-04T09:21:45Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Main issue related to the \"[polymorphization](https://rust-lang.github.io/compiler-team/working-groups/polymorphization/)\" (or lack thereof) problem: #46477\r\n\r\n___\r\n\r\nMinimal repro:\r\n\r\n```rust\r\nfn foo<F : FnOnce()> (recurse: bool, f: F)\r\n{\r\n    if recurse {\r\n        foo(false, || ())\r\n    }\r\n    f();\r\n}\r\n\r\nfn initial ()\r\n{}\r\n\r\nfn main ()\r\n{\r\n    foo(true, initial);\r\n}\r\n```\r\n\r\n[fails with](https://rust.godbolt.org/z/hYbzGW):\r\n\r\n```text\r\nerror: reached the recursion limit while instantiating `foo::<[closure@src/main.rs:4:20: 4:25]>`\r\n --> src/main.rs:4:9\r\n  |\r\n4 |         foo(false, || ())\r\n  |         ^^^^^^^^^^^^^^^^^\r\n  |\r\n```\r\n\r\n___\r\n\r\nThe issue seems to stem from the fact that the closure created inside `foo`, `|| ()`, despite not using `f` and thus not having anything of type `F` inside, has nevertheless a type that is infected with all the generic parameters in scope. So this leads to that closure being generic over the type parameter `F`.\r\n\r\nSo, the initial call `foo::<F = fn {initial}>` causes Rust to go and monomorphize `foo` for that given `F`, which requires monomorphizing the next call to `foo()`, and because of the above, whereby the closure is infected with the `F` type parameter, it will end up monomorphizing something like `foo::<F = Closure<fn {initial}>>`. And that call, in and on itself, leads to monomorphizing the next call, `foo::<F = Closure<Closure<fn {initial}>>>`, and so on, \u2026, _ad infinitum_, causing the type recursion limit to be reached.\r\n\r\nGranted, we could say that this is an issue with \"badly done\" recursion, and so we may ask:\r\n\r\n### Why report this\r\n\r\nI think it is worth doing it for several reasons:\r\n\r\n  - Mainly, because it causes a compilation error! And the error message is not very helpful \ud83d\ude2c\r\n\r\n      - For instance, the first time I've encountered this issue, it is definitely an obscure one, and it's taken me a while to figure out what the root cause for the compilation error was.\r\n\r\n        Thus, having this be available may serve for future reference for other people, rather than the linked canonical issue #46477, or specific problems that some people had with iterator adaptors.\r\n\r\n  - This is not \"intended behavior\" in that replacing a capture-less closure with an isomorphic **function item avoids the compilation error**!\r\n\r\n    ```rust\r\n    fn foo<F : FnOnce()> (recurse: bool, f: F)\r\n    {\r\n        if recurse {\r\n            foo(false, { fn no_op(){}; no_op })\r\n        }\r\n        f();\r\n    }\r\n\r\n    fn main ()\r\n    {\r\n        foo(true, || ());\r\n    }\r\n    ```\r\n\r\n  - Another odd thing is that the compilation error happens **at usage site** rather than at definition site, which I think has also been part of the confusion (I was getting `cargo check` to pass fine, and the compilation errors only happened with `cargo test` calling that function). Worse, even a call site, if it can be proven unreachable by the compiler, can trigger dead code elimination and the whole recursive-monomorphization to be skipped altogether. That is, the following code compiles fine:\r\n\r\n    ```rust\r\n    fn foo<F : FnOnce()> (recurse: bool, f: F)\r\n    {\r\n        if recurse {\r\n            foo(false, || ())\r\n        }\r\n        f();\r\n    }\r\n\r\n    fn main ()\r\n    {\r\n        if false { foo(true, || ()); }\r\n    }\r\n    ```\r\n\r\n  - This issue is also here to raise awareness about the semver implications of Rust supporting polymorphization: it is not only a matter of binary size and code bloat (as mentioned in #46477), it is actually a matter of compilation erroring or not. That means that if some version of the compiler were to support polymorphization and effectively make this code compile, then regressing with that polymorphization functionality would be breaking change \u26a0\ufe0f.\r\n\r\n  - Finally, this is also to suggest a workaround for those stumbling upon it.\r\n\r\n### The workaround\r\n\r\n  - I have had to [use these workarounds to be able to support recursion within my crate](https://github.com/danielhenrymantilla/with_locals.rs/pull/6) that offers sugar for CPS, [`::with_locals`](https://docs.rs/with_locals)\r\n\r\nSome of you may have figured it by now, given how the `fn()...` item was not infected by the type `F`.\r\n\r\nSimilarly, in the case of a stateful closure, especially one actually capturing `f`, not even polymorphization would solve the issue. The real way to solve it would be introduce type erasure, similar to `fn()`, but for closures. That is, `dyn Fn...`:\r\n\r\n```rust\r\nfn foo<F : FnMut()> (recurse: bool, mut f: F)\r\n{\r\n    if recurse {\r\n        // monomorphization for the `&mut dyn FnMut()` is terminal / ends the recursion.\r\n        foo::<&mut dyn FnMut()>(false, &mut || {\r\n             println!(\"Recursed!\");\r\n             f();\r\n        });\r\n    } else {\r\n        f();\r\n    }\r\n}\r\n\r\nfn main ()\r\n{\r\n    foo(true, || ());\r\n}\r\n```\r\n\r\n<details><summary>Less easy cases</summary>\r\n\r\n  - For the `FnOnce()` people, this will either require `Box`ing, or to use an internal helper function with a runtime-checked `FnOnce`-ness:\r\n\r\n    ```rust\r\n    fn foo<F : FnOnce()> (recurse: bool, f: F)\r\n    {\r\n        fn helper (recurse: bool, f: &mut dyn FnMut())\r\n        {\r\n            if recurse { helper(false, &mut || { ... }); } else { f(); }\r\n        }\r\n        let mut f = Some(f);\r\n        helper(\r\n            recurse,\r\n            &mut move || {\r\n                f   .take()\r\n                    .expect(\"Attempted to call a `FnOnce()` multiple times\")\r\n                    ()\r\n            },\r\n        );\r\n    }\r\n    ```\r\n\r\n    Note that the \"fallibility\" of the `FnMut()` would be solved with unsized locals, and/or, equivalently, with a `RefMove<'_, T>`, `StackBox<'_, T>`, `Own<'_, T>`, `&'_ own T` owning reference type (instanced with `T = dyn FnOnce()`).\r\n\r\n  - Finally, If the closure happens to return a value, then care should be take not to wrap the return type.\r\n\r\n    That is,\r\n\r\n    ```rust\r\n    fn foo<R> (recurse: bool, f: &mut dyn FnMut() -> R) -> R\r\n    {\r\n        if recurse {\r\n            foo(false, &mut || (f(), 42)).0\r\n        } else {\r\n            f()\r\n        }\r\n    }\r\n    ```\r\n\r\n    will also fail since we hit the same issue as before but this time with `R -> (R, i32) -> ((R, i32), i32) -> \u2026`\r\n\r\n    The workaround, is to (ab)use the mutability of the closure to return the value elsewhere:\r\n\r\n    ```rust\r\n    fn foo<R, F : FnOnce() -> R> (recurse: bool, f: F) -> R\r\n    {\r\n        fn helper<R> (recurse: bool, f: &mut dyn FnMut() -> R) -> R\r\n        {\r\n            if recurse {\r\n                let mut out_slot = None;\r\n                // fixed `R = ()` terminates the recursion.\r\n                helper(false, &mut || -> () {\r\n                    out_slot = Some((f(), 42));\r\n                });\r\n                out_slot.unwrap().0\r\n            } else {\r\n                f()\r\n            }\r\n        }\r\n        let mut f = Some(f);\r\n        helper(recurse, &mut || f.take().unwrap()())\r\n    }\r\n\r\n___\r\n\r\n</details>", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/77664/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/77664/timeline", "performed_via_github_app": null, "state_reason": null}