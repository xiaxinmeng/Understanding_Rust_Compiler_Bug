{"url": "https://api.github.com/repos/rust-lang/rust/issues/78546", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/78546/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/78546/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/78546/events", "html_url": "https://github.com/rust-lang/rust/issues/78546", "id": 732719072, "node_id": "MDU6SXNzdWU3MzI3MTkwNzI=", "number": 78546, "title": "MIR InstrumentCoverage - Can the source_info.span for `FakeRead` statements be more consistent?", "user": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 256133398, "node_id": "MDU6TGFiZWwyNTYxMzMzOTg=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-mir", "name": "A-mir", "color": "f7e101", "default": false, "description": "Area: Mid-level IR (MIR) - https://blog.rust-lang.org/2016/04/19/MIR.html"}, {"id": 2483744621, "node_id": "MDU6TGFiZWwyNDgzNzQ0NjIx", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-code-coverage", "name": "A-code-coverage", "color": "f7e101", "default": false, "description": "Area: Source-based code coverage (-Cinstrument-coverage)"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2020-10-29T22:59:15Z", "updated_at": "2023-04-05T17:41:31Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "Rust's LLVM InstrProf-based source code coverage implementation instruments Rust code via the MIR pass InstrumentCoverage. Most criteria for identifying coverage regions and counter locations are very general, based on Control Flow Graph (CFG) analysis of the MIR, and a fairly straightforward mapping of MIR Statements and Terminators to their source code regions (Spans).\r\n\r\nStatementKind::FakeRead are an exception, requiring special handling for at lease one case: When its `cause` is `ForGuardBinding`, the `Statement`s `source_info.span` seems to be wrong.\r\n\r\nExample:\r\n\r\n```rust\r\n    match somenum {\r\n        x if x < 1 => { ... }\r\n    }...\r\n```\r\n\r\nThe BasicBlock within the match arm code included one of these statements, but the span\r\nfor it covered the literal number `1` in this source. The actual `FakeRead` statement, and its components, have nothing to do with that source span:\r\n\r\n```mir\r\n    FakeRead(ForGuardBinding, _4);\r\n```\r\n\r\nwhere `_4` is:\r\n\r\n```mir\r\n    _4 = &_1; (at the span for the first `x`)\r\n```\r\n\r\nand `_1` is the `Place` for `somenum`.\r\n\r\nThe current workaround is to ignore these `Statement`s, and rely on other `Statement`s for coverage (which appears to provide reasonable results):\r\n\r\n```rust\r\nfn filtered_statement_span(statement: &'a Statement<'tcx>, body_span: Span) -> Option<Span> {\r\n    match statement.kind {\r\n...\r\n        StatementKind::FakeRead(cause, _) if cause == FakeReadCause::ForGuardBinding => None,\r\n```\r\n\r\nBut workarounds like this one may be incomplete or error-prone, and could be hard to maintain in the future. Plus, if the given span is actually wrong, this bug would have been introduced in an earlier phase (perhaps lowering AST to HIR, or a later pass), the invalid span may trigger other compiler issues.\r\n\r\nThe arm code BasicBlock already has its own assignment for `x` itself, `_3 = 1`, and I've\r\ndecided it's reasonable for that span (even though outside the arm code) to be part of\r\nthe counted coverage of the arm code execution, but I can't justify including the literal\r\n`1` in the arm code. I'm pretty sure that, if the `FakeRead(ForGuardBinding)` has a\r\npurpose in codegen, it's probably in the right BasicBlock, but if so, the `Statement`s\r\n`source_info.span` can't be right.\r\n\r\nIf the span can be corrected, the match pattern for this special case can be removed.\r\n", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/78546/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/78546/timeline", "performed_via_github_app": null, "state_reason": null}