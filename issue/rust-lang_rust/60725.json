{"url": "https://api.github.com/repos/rust-lang/rust/issues/60725", "repository_url": "https://api.github.com/repos/rust-lang/rust", "labels_url": "https://api.github.com/repos/rust-lang/rust/issues/60725/labels{/name}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/60725/comments", "events_url": "https://api.github.com/repos/rust-lang/rust/issues/60725/events", "html_url": "https://github.com/rust-lang/rust/issues/60725", "id": 442961929, "node_id": "MDU6SXNzdWU0NDI5NjE5Mjk=", "number": 60725, "title": "Compiling is signification slower with long return position impl types", "user": {"login": "upsuper", "id": 333750, "node_id": "MDQ6VXNlcjMzMzc1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/333750?v=4", "gravatar_id": "", "url": "https://api.github.com/users/upsuper", "html_url": "https://github.com/upsuper", "followers_url": "https://api.github.com/users/upsuper/followers", "following_url": "https://api.github.com/users/upsuper/following{/other_user}", "gists_url": "https://api.github.com/users/upsuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/upsuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/upsuper/subscriptions", "organizations_url": "https://api.github.com/users/upsuper/orgs", "repos_url": "https://api.github.com/users/upsuper/repos", "events_url": "https://api.github.com/users/upsuper/events{/privacy}", "received_events_url": "https://api.github.com/users/upsuper/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 64037154, "node_id": "MDU6TGFiZWw2NDAzNzE1NA==", "url": "https://api.github.com/repos/rust-lang/rust/labels/I-compiletime", "name": "I-compiletime", "color": "e11d21", "default": false, "description": "Problems and improvements with respect to compile times."}, {"id": 211668100, "node_id": "MDU6TGFiZWwyMTE2NjgxMDA=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-compiler", "name": "T-compiler", "color": "bfd4f2", "default": false, "description": "Relevant to the compiler team, which will review and decide on the PR/issue."}, {"id": 631673608, "node_id": "MDU6TGFiZWw2MzE2NzM2MDg=", "url": "https://api.github.com/repos/rust-lang/rust/labels/A-impl-trait", "name": "A-impl-trait", "color": "f7e101", "default": false, "description": "Area: impl Trait. Universally / existentially quantified anonymous types with static dispatch."}, {"id": 1359848690, "node_id": "MDU6TGFiZWwxMzU5ODQ4Njkw", "url": "https://api.github.com/repos/rust-lang/rust/labels/E-needs-mcve", "name": "E-needs-mcve", "color": "02e10c", "default": false, "description": "Call for participation: This issue needs a Minimal Complete and Verifiable Example"}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2019-05-11T06:58:24Z", "updated_at": "2019-06-06T21:50:43Z", "closed_at": null, "author_association": "CONTRIBUTOR", "active_lock_reason": null, "body": "I have the following (relatively complicated) parser code (with dependency `combine 3.8.1` and `either_n 0.2.0`), which takes ~45s on my computer to compile for `cargo test`:\r\n<details>\r\n\r\n```rust\r\n#[macro_use]\r\nextern crate combine;\r\n\r\nuse combine::error::StringStreamError;\r\nuse combine::parser::{\r\n    char::{alpha_num, char, letter, spaces, string},\r\n    choice::{choice, optional},\r\n    combinator::attempt,\r\n    range::recognize,\r\n    repeat::{many, skip_many1},\r\n    Parser,\r\n};\r\nuse either_n::{Either2, Either3, Either6};\r\nuse std::iter::{self, FromIterator};\r\n\r\npub fn parse_item(input: &str) -> Result<(&str, TokenStream<'_>), ()> {\r\n    (identifier_str(), item_after_name())\r\n        .parse(input)\r\n        .map_err(|_| ())\r\n        .and_then(|((name, rest), remaining)| match remaining {\r\n            \"\" => Ok((name, TokenStream(rest.collect()))),\r\n            _ => Err(()),\r\n        })\r\n}\r\n\r\n#[derive(Clone, Debug, Default, Eq, PartialEq)]\r\npub struct TokenStream<'a>(pub Vec<Token<'a>>);\r\n\r\nimpl<'a> FromIterator<Token<'a>> for TokenStream<'a> {\r\n    fn from_iter<I: IntoIterator<Item = Token<'a>>>(iter: I) -> Self {\r\n        TokenStream(Vec::from_iter(iter))\r\n    }\r\n}\r\n\r\nimpl<'a> IntoIterator for TokenStream<'a> {\r\n    type Item = Token<'a>;\r\n    type IntoIter = <Vec<Token<'a>> as IntoIterator>::IntoIter;\r\n\r\n    fn into_iter(self) -> Self::IntoIter {\r\n        self.0.into_iter()\r\n    }\r\n}\r\n\r\nimpl<'a> Extend<Token<'a>> for TokenStream<'a> {\r\n    fn extend<I: IntoIterator<Item = Token<'a>>>(&mut self, iter: I) {\r\n        self.0.extend(iter);\r\n    }\r\n}\r\n\r\nimpl<'a, Iter> Extend<Iter> for TokenStream<'a>\r\nwhere\r\n    Iter: IntoIterator<Item = Token<'a>>,\r\n{\r\n    fn extend<I: IntoIterator<Item = Iter>>(&mut self, iter: I) {\r\n        self.0.extend(iter.into_iter().flatten())\r\n    }\r\n}\r\n\r\n#[derive(Clone, Debug, Eq, PartialEq)]\r\npub enum Token<'a> {\r\n    Text(&'a str),\r\n    Nested(TokenStream<'a>),\r\n    Type(TokenStream<'a>),\r\n    Primitive(Primitive<'a>),\r\n    Identifier(&'a str),\r\n    AssocType(&'a str),\r\n    Range(Range),\r\n    Where,\r\n}\r\n\r\nimpl<'a> From<Primitive<'a>> for Token<'a> {\r\n    fn from(primitive: Primitive<'a>) -> Self {\r\n        Token::Primitive(primitive)\r\n    }\r\n}\r\n\r\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\r\npub enum Primitive<'a> {\r\n    Ref(&'a str),\r\n    SliceStart,\r\n    SliceEnd,\r\n    TupleStart,\r\n    TupleEnd,\r\n    Unit,\r\n    Named(&'a str),\r\n}\r\n\r\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\r\npub enum Range {\r\n    Range,\r\n    RangeFrom,\r\n    RangeFull,\r\n    RangeInclusive,\r\n    RangeTo,\r\n    RangeToInclusive,\r\n}\r\n\r\n// TODO: Replace this macro with named existential type when it's available.\r\n// See https://github.com/rust-lang/rust/issues/34511\r\nmacro_rules! parser_str_to_iter_token {\r\n    ($a:lifetime) => {\r\n        parser_str_to!($a, impl Iterator<Item = Token<$a>>)\r\n    };\r\n}\r\n\r\nmacro_rules! parser_str_to {\r\n    ($a:lifetime, $ty:ty) => {\r\n        impl Parser<Input = &$a str, Output = $ty>\r\n    }\r\n}\r\n\r\nfn item_after_name<'a>() -> parser_str_to_iter_token!('a) {\r\n    (\r\n        lex(\"(\"),\r\n        nested_type_like_list(),\r\n        lex(\")\"),\r\n        optional_tokens(chain2(lex(\"->\"), single_type_like())),\r\n        optional_tokens(chain4(\r\n            wrap(\"where\", Token::Where),\r\n            single_type_like(),\r\n            lex(\":\"),\r\n            sep1_by_lex(single_type_like, \"+\"),\r\n        )),\r\n    )\r\n        .map(|(left, params, right, ret, where_clause)| {\r\n            iter::empty()\r\n                .chain(left)\r\n                .chain(params)\r\n                .chain(right)\r\n                .chain(ret)\r\n                .chain(where_clause)\r\n        })\r\n}\r\n\r\ntype BoxedTokenIter<'a> = Box<dyn Iterator<Item = Token<'a>> + 'a>;\r\n\r\n// // Add an extra wrapper for this parser so that it can be invoked recursively.\r\n// parser! {\r\n//     fn type_like['a]()(&'a str) -> BoxedTokenIter<'a> {\r\n//         type_like_inner()\r\n//     }\r\n// }\r\n// \r\n// fn type_like_inner<'a>() -> parser_str_to!('a, BoxedTokenIter<'a>) {\r\n//     sep1_by_lex(single_type_like, \"|\").map(to_boxed_iter)\r\n// }\r\n\r\nfn type_like<'a>() -> parser_str_to_iter_token!('a) {\r\n    sep1_by_lex(single_type_like, \"|\")\r\n}\r\n\r\n// Add an extra wrapper for this parser so that we don't have too deep type name.\r\nparser! {\r\n    fn single_type_like['a]()(&'a str) -> BoxedTokenIter<'a> {\r\n        single_type_like_inner()\r\n    }\r\n}\r\n\r\nfn single_type_like_inner<'a>() -> parser_str_to!('a, BoxedTokenIter<'a>) {\r\n    single_type_like_token().map(iter::once).map(to_boxed_iter)\r\n}\r\n\r\nfn to_boxed_iter<'a, T>(iter: impl Iterator<Item = T> + 'a) -> Box<dyn Iterator<Item = T> + 'a> {\r\n    Box::new(iter)\r\n}\r\n\r\nfn single_type_like_token<'a>() -> parser_str_to!('a, Token<'a>) {\r\n    to_type_token(choice((\r\n        attempt(ref_type()).map(Either6::One),\r\n        attempt(slice_type()).map(Either6::Two),\r\n        attempt(fn_type()).map(Either6::Three),\r\n        attempt(tuple_type()).map(Either6::Four),\r\n        attempt(range_type()).map(Either6::Five),\r\n        named_type().map(Either6::Six),\r\n    )))\r\n}\r\n\r\nfn ref_type<'a>() -> parser_str_to_iter_token!('a) {\r\n    chain3(\r\n        recognize((\r\n            char('&'),\r\n            optional(string(\"mut\")),\r\n            optional(attempt((spaces(), lifetime()))),\r\n        ))\r\n        .map(|s| iter::once(Token::Primitive(Primitive::Ref(s)))),\r\n        maybe_spaces(),\r\n        single_type_like(),\r\n    )\r\n}\r\n\r\nfn slice_type<'a>() -> parser_str_to_iter_token!('a) {\r\n    chain3(\r\n        wrap_start(\"[\", Primitive::SliceStart),\r\n        type_like(),\r\n        wrap_end(\"]\", Primitive::SliceEnd),\r\n    )\r\n}\r\n\r\nfn fn_type<'a>() -> parser_str_to_iter_token!('a) {\r\n    chain4(\r\n        text((char('('), spaces())),\r\n        nested_type_like_list(),\r\n        text((spaces(), char(')'), spaces(), string(\"->\"), spaces())),\r\n        type_like(),\r\n    )\r\n}\r\n\r\nfn tuple_type<'a>() -> parser_str_to_iter_token!('a) {\r\n    choice((\r\n        attempt(wrap(\"()\", Primitive::Unit)).map(Either2::One),\r\n        chain3(\r\n            wrap_start(\"(\", Primitive::TupleStart),\r\n            nested_type_like_list(),\r\n            wrap_end(\")\", Primitive::TupleEnd),\r\n        )\r\n        .map(Either2::Two),\r\n    ))\r\n}\r\n\r\nfn nested_type_like_list<'a>() -> parser_str_to_iter_token!('a) {\r\n    optional(\r\n        sep1_by_lex(type_like, \",\")\r\n            .map(Iterator::collect)\r\n            .map(Token::Nested),\r\n    )\r\n    .map(IntoIterator::into_iter)\r\n}\r\n\r\nfn range_type<'a>() -> parser_str_to_iter_token!('a) {\r\n    (\r\n        optional(named_type()),\r\n        choice((attempt(lex_str(\"..=\")), attempt(lex_str(\"..\")))),\r\n        optional(named_type()),\r\n    )\r\n        .and_then(|(start, op, end)| {\r\n            let range = match (&start, op.trim(), &end) {\r\n                (None, \"..\", None) => Range::RangeFull,\r\n                (None, \"..\", Some(_)) => Range::RangeTo,\r\n                (None, \"..=\", Some(_)) => Range::RangeToInclusive,\r\n                (Some(_), \"..\", None) => Range::RangeFrom,\r\n                (Some(_), \"..\", Some(_)) => Range::Range,\r\n                (Some(_), \"..=\", Some(_)) => Range::RangeInclusive,\r\n                _ => return Err(StringStreamError::UnexpectedParse),\r\n            };\r\n            let start = start.into_iter().flatten();\r\n            let end = end.into_iter().flatten();\r\n            Ok(iter::empty()\r\n                .chain(start)\r\n                .chain(range_token(op, range))\r\n                .chain(end))\r\n        })\r\n}\r\n\r\nfn range_token(s: &str, range: Range) -> impl Iterator<Item = Token<'_>> {\r\n    let start = match &s[..s.len() - s.trim_start().len()] {\r\n        \"\" => None,\r\n        spaces => Some(Token::Text(spaces)),\r\n    };\r\n    let end = match &s[s.trim_end().len()..] {\r\n        \"\" => None,\r\n        spaces => Some(Token::Text(spaces)),\r\n    };\r\n    iter::empty()\r\n        .chain(start)\r\n        .chain(iter::once(Token::Range(range)))\r\n        .chain(end)\r\n}\r\n\r\nfn named_type<'a>() -> parser_str_to_iter_token!('a) {\r\n    chain2(\r\n        named_type_base().map(|ty| iter::once(Token::Type(ty.collect()))),\r\n        // Associated items\r\n        many::<TokenStream<'_>, _>(attempt(chain2(\r\n            lex(\"::\"),\r\n            identifier_str().map(Token::AssocType).map(iter::once),\r\n        ))),\r\n    )\r\n}\r\n\r\nfn named_type_base<'a>() -> parser_str_to_iter_token!('a) {\r\n    chain2(\r\n        // Name\r\n        identifier_str().map(|ident| {\r\n            iter::once(if is_primitive(ident) {\r\n                Token::Primitive(Primitive::Named(ident))\r\n            } else {\r\n                Token::Identifier(ident)\r\n            })\r\n        }),\r\n        // Optional parameters\r\n        optional_tokens(chain3(\r\n            lex(\"<\"),\r\n            sep1_by_lex(type_param, \",\"),\r\n            text((spaces(), char('>'))),\r\n        )),\r\n    )\r\n}\r\n\r\nfn to_type_token<'a>(inner: parser_str_to_iter_token!('a)) -> parser_str_to!('a, Token<'a>) {\r\n    inner.map(|ty| {\r\n        let mut inner: Vec<_> = ty.collect();\r\n        match inner.as_ref() as &[_] {\r\n            [Token::Type(_)] => inner.remove(0),\r\n            _ => Token::Type(TokenStream(inner)),\r\n        }\r\n    })\r\n}\r\n\r\n#[rustfmt::skip]\r\nfn is_primitive(ident: &str) -> bool {\r\n    match ident {\r\n        \"bool\" | \"char\" | \"str\" |\r\n        \"i8\" | \"i16\" | \"i32\" | \"i64\" | \"i128\" | \"isize\" |\r\n        \"u8\" | \"u16\" | \"u32\" | \"u64\" | \"u128\" | \"usize\" => true,\r\n        _ => false,\r\n    }\r\n}\r\n\r\nfn type_param<'a>() -> parser_str_to_iter_token!('a) {\r\n    choice((\r\n        attempt(lifetime_param()).map(Either3::One),\r\n        attempt(assoc_type_param()).map(Either3::Two),\r\n        type_like().map(Either3::Three),\r\n    ))\r\n}\r\n\r\nfn lifetime_param<'a>() -> parser_str_to_iter_token!('a) {\r\n    text(lifetime())\r\n}\r\n\r\nfn assoc_type_param<'a>() -> parser_str_to_iter_token!('a) {\r\n    chain3(\r\n        identifier_str().map(Token::AssocType).map(iter::once),\r\n        lex(\"=\"),\r\n        type_like(),\r\n    )\r\n}\r\n\r\nfn optional_tokens<'a>(inner: parser_str_to_iter_token!('a)) -> parser_str_to_iter_token!('a) {\r\n    optional(attempt(inner))\r\n        .map(IntoIterator::into_iter)\r\n        .map(Iterator::flatten)\r\n}\r\n\r\nfn sep1_by_lex<'a, P, I>(\r\n    parser_fn: impl Fn() -> P,\r\n    sep: &'static str,\r\n) -> parser_str_to_iter_token!('a)\r\nwhere\r\n    P: Parser<Input = &'a str, Output = I>,\r\n    I: Iterator<Item = Token<'a>>,\r\n{\r\n    chain2(\r\n        parser_fn(),\r\n        many::<TokenStream<'a>, _>(attempt(chain2(lex(sep), parser_fn()))),\r\n    )\r\n}\r\n\r\nfn lex<'a>(s: &'static str) -> parser_str_to_iter_token!('a) {\r\n    text(lex_str(s))\r\n}\r\n\r\nfn lex_str<'a>(s: &'static str) -> parser_str_to!('a, &'a str) {\r\n    recognize((spaces(), string(s), spaces()))\r\n}\r\n\r\nfn wrap_start<'a>(\r\n    inner: &'static str,\r\n    token: impl Into<Token<'a>>,\r\n) -> parser_str_to_iter_token!('a) {\r\n    let token = token.into();\r\n    chain2(\r\n        string(inner).map(move |_| iter::once(token.clone())),\r\n        maybe_spaces(),\r\n    )\r\n}\r\n\r\nfn wrap_end<'a>(inner: &'static str, token: impl Into<Token<'a>>) -> parser_str_to_iter_token!('a) {\r\n    let token = token.into();\r\n    chain2(\r\n        maybe_spaces(),\r\n        string(inner).map(move |_| iter::once(token.clone())),\r\n    )\r\n}\r\n\r\nfn wrap<'a>(inner: &'static str, token: impl Into<Token<'a>>) -> parser_str_to_iter_token!('a) {\r\n    let token = token.into();\r\n    chain3(\r\n        maybe_spaces(),\r\n        string(inner).map(move |_| iter::once(token.clone())),\r\n        maybe_spaces(),\r\n    )\r\n}\r\n\r\nfn maybe_spaces<'a>() -> parser_str_to_iter_token!('a) {\r\n    recognize(spaces()).map(|s| match s {\r\n        \"\" => None.into_iter(),\r\n        s => Some(Token::Text(s)).into_iter(),\r\n    })\r\n}\r\n\r\nfn text<'a>(inner: impl Parser<Input = &'a str>) -> parser_str_to_iter_token!('a) {\r\n    text_token(inner).map(iter::once)\r\n}\r\n\r\nfn text_token<'a>(\r\n    inner: impl Parser<Input = &'a str>,\r\n) -> impl Parser<Input = &'a str, Output = Token<'a>> {\r\n    recognize(inner).map(Token::Text)\r\n}\r\n\r\nfn lifetime<'a>() -> parser_str_to!('a, &'a str) {\r\n    recognize((char('\\''), skip_many1(letter())))\r\n}\r\n\r\nfn identifier_str<'a>() -> parser_str_to!('a, &'a str) {\r\n    recognize(skip_many1(choice((alpha_num(), char('_')))))\r\n}\r\n\r\nmacro_rules! impl_chain {\r\n    ($name:ident: $($v:ident)+) => {\r\n        fn $name<'a>($(\r\n            $v: parser_str_to!('a, impl IntoIterator<Item = Token<'a>>),\r\n        )+) -> parser_str_to_iter_token!('a) {\r\n            ($($v),+).map(|($($v),+)| {\r\n                iter::empty() $(.chain($v.into_iter()))+\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\nimpl_chain!(chain2: a b);\r\nimpl_chain!(chain3: a b c);\r\nimpl_chain!(chain4: a b c d);\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use combine::Parser;\r\n\r\n    macro_rules! tokens {\r\n        ($($t:tt)*) => {{\r\n            let mut result = vec![];\r\n            tokens_impl!(result $($t)*);\r\n            result\r\n        }};\r\n    }\r\n    macro_rules! tokens_impl {\r\n        ($result:ident) => {};\r\n        ($result:ident where $($t:tt)*) => {\r\n            $result.push(Token::Where);\r\n            tokens_impl!($result $($t)*);\r\n        };\r\n        ($result:ident +$ident:ident $($t:tt)*) => {\r\n            $result.push(Token::AssocType(stringify!($ident)));\r\n            tokens_impl!($result $($t)*);\r\n        };\r\n        ($result:ident $ident:ident $($t:tt)*) => {\r\n            $result.push(Token::Identifier(stringify!($ident)));\r\n            tokens_impl!($result $($t)*);\r\n        };\r\n        ($result:ident $str:literal $($t:tt)*) => {\r\n            $result.push(Token::Text($str));\r\n            tokens_impl!($result $($t)*);\r\n        };\r\n        ($result:ident &$r:literal $($t:tt)*) => {\r\n            $result.push(Token::Primitive(Primitive::Ref(concat!(\"&\", $r))));\r\n            tokens_impl!($result $($t)*);\r\n        };\r\n        ($result:ident @() $($t:tt)*) => {\r\n            $result.push(Token::Type(TokenStream(vec![\r\n                Token::Primitive(Primitive::Unit),\r\n            ])));\r\n            tokens_impl!($result $($t)*);\r\n        };\r\n        ($result:ident @( $($inner:tt)* ) $($t:tt)*) => {\r\n            $result.push(Token::Type(TokenStream(vec![\r\n                Token::Primitive(Primitive::TupleStart),\r\n                Token::Nested(TokenStream(tokens!($($inner)*))),\r\n                Token::Primitive(Primitive::TupleEnd),\r\n            ])));\r\n            tokens_impl!($result $($t)*);\r\n        };\r\n        ($result:ident @[ $($inner:tt)* ] $($t:tt)*) => {\r\n            let mut inner = vec![];\r\n            inner.push(Token::Primitive(Primitive::SliceStart));\r\n            tokens_impl!(inner $($inner)*);\r\n            inner.push(Token::Primitive(Primitive::SliceEnd));\r\n            $result.push(Token::Type(TokenStream(inner)));\r\n            tokens_impl!($result $($t)*);\r\n        };\r\n        ($result:ident ~$range:ident $($t:tt)*) => {\r\n            $result.push(Token::Range(Range::$range));\r\n            tokens_impl!($result $($t)*);\r\n        };\r\n        ($result:ident @$ident:ident $($t:tt)*) => {\r\n            $result.push(Token::Type(TokenStream(vec![\r\n                Token::Primitive(Primitive::Named(stringify!($ident))),\r\n            ])));\r\n            tokens_impl!($result $($t)*);\r\n        };\r\n        ($result:ident ^$ident:ident $($t:tt)*) => {\r\n            $result.push(Token::Type(TokenStream(vec![\r\n                Token::Identifier(stringify!($ident)),\r\n            ])));\r\n            tokens_impl!($result $($t)*);\r\n        };\r\n        ($result:ident ^[ $($inner:tt)* ] $($t:tt)*) => {\r\n            $result.push(Token::Type(TokenStream(tokens!($($inner)*))));\r\n            tokens_impl!($result $($t)*);\r\n        };\r\n        ($result:ident { $($inner:tt)* } $($t:tt)*) => {\r\n            $result.push(Token::Nested(TokenStream(tokens!($($inner)*))));\r\n            tokens_impl!($result $($t)*);\r\n        };\r\n    }\r\n\r\n    macro_rules! test {\r\n        ($parser:ident: [$($input:literal => [$($expected:tt)*],)*]) => {\r\n            #[test]\r\n            fn $parser() {\r\n                $(\r\n                    let (tokens, remaining) = super::$parser().parse($input)\r\n                        .expect(\"failed to parse\");\r\n                    assert_eq!(remaining, \"\", \"unparsed content\");\r\n                    assert_eq!(tokens.collect::<Vec<_>>(), tokens!($($expected)*));\r\n                )*\r\n            }\r\n        };\r\n    }\r\n\r\n    test!(item_after_name: [\r\n        \" ((T) -> ())\" => [\" (\" { ^[\"(\" { ^T } \") -> \" @()] } \")\"],\r\n        \" ((&T) -> bool) -> (B, B) where B: Default + Extend<T>\" => [\r\n            \" (\" { ^[\"(\" { ^[&\"\" ^T] } \") -> \" @bool] } \") \" \"-> \" @( ^B \", \" ^B )\r\n            \" \" where \" \" ^B \": \" ^Default \" + \" ^[ Extend \"<\" ^T \">\" ]\r\n        ],\r\n    ]);\r\n\r\n    test!(type_like: [\r\n        // Named\r\n        \"Foo\" => [^Foo],\r\n        \"Option<Foo>\" => [^[Option \"<\" ^Foo \">\"]],\r\n        \"Foo::Err\" => [^[^Foo \"::\" +Err]],\r\n        // References\r\n        \"&Foo\" => [^[&\"\" ^Foo]],\r\n        \"&'a Foo\" => [^[&\"'a\" \" \" ^Foo]],\r\n        \"&mut Foo\" => [^[&\"mut\" \" \" ^Foo]],\r\n        \"&mut 'a Foo\" => [^[&\"mut 'a\" \" \" ^Foo]],\r\n        \"&[Foo]\" => [^[&\"\" @[^Foo]]],\r\n        // Tuple-like\r\n        \"()\" => [@()],\r\n        \"(Foo, &Bar)\" => [@(^Foo \", \" ^[&\"\" ^Bar])],\r\n        // Range\r\n        \"usize.. usize\" => [^[@usize ~Range \" \" @usize]],\r\n        \"usize..=usize\" => [^[@usize ~RangeInclusive @usize]],\r\n        \"     .. usize\" => [^[\"     \" ~RangeTo \" \" @usize]],\r\n        \"     ..=usize\" => [^[\"     \" ~RangeToInclusive @usize]],\r\n        \"usize..      \" => [^[@usize ~RangeFrom \"      \"]],\r\n        \"     ..      \" => [^[\"     \" ~RangeFull \"      \"]],\r\n        // Function\r\n        \"() -> Foo\" => [^[\"(\" \") -> \" ^Foo]],\r\n        \"(Iterator<Item = T>) -> Result<(), T>\" => [\r\n            ^[\"(\" { ^[Iterator \"<\" +Item \" = \" ^T \">\"] } \") -> \" ^[Result \"<\" @() \", \" ^T \">\"]]\r\n        ],\r\n        \"(Foo, &(Bar, &mut 'a [Baz])) -> T\" => [\r\n            ^[\"(\" { ^Foo \", \" ^[&\"\" @(^Bar \", \" ^[&\"mut 'a\" \" \" @[^Baz]])] } \") -> \" ^T]\r\n        ],\r\n        // Union (pseudo-type)\r\n        \"Foo | &Bar<T> | (Baz) -> bool\" => [\r\n            ^Foo \" | \" ^[&\"\" ^[Bar \"<\" ^T \">\"]] \" | \" ^[\"(\" { ^Baz } \") -> \" @bool]\r\n        ],\r\n    ]);\r\n}\r\n```\r\n\r\n</details>\r\n\r\nHowever, if you replace the function `type_like` with the commented code above it (the `parser!` macro and `type_like_inner` function), it compiles significant faster, and only takes ~18s.\r\n\r\nThere might be something improvable here?", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/rust-lang/rust/issues/60725/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/rust-lang/rust/issues/60725/timeline", "performed_via_github_app": null, "state_reason": null}