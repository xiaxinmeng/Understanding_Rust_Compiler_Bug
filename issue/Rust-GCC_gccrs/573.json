{"url": "https://api.github.com/repos/Rust-GCC/gccrs/issues/573", "repository_url": "https://api.github.com/repos/Rust-GCC/gccrs", "labels_url": "https://api.github.com/repos/Rust-GCC/gccrs/issues/573/labels{/name}", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/issues/573/comments", "events_url": "https://api.github.com/repos/Rust-GCC/gccrs/issues/573/events", "html_url": "https://github.com/Rust-GCC/gccrs/issues/573", "id": 946825199, "node_id": "MDU6SXNzdWU5NDY4MjUxOTk=", "number": 573, "title": "Declarative macro expansion", "user": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 2029873897, "node_id": "MDU6TGFiZWwyMDI5ODczODk3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/labels/plan", "name": "plan", "color": "42ed5c", "default": false, "description": ""}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": {"url": "https://api.github.com/repos/Rust-GCC/gccrs/milestones/7", "html_url": "https://github.com/Rust-GCC/gccrs/milestone/7", "labels_url": "https://api.github.com/repos/Rust-GCC/gccrs/milestones/7/labels", "id": 6862692, "node_id": "MDk6TWlsZXN0b25lNjg2MjY5Mg==", "number": 7, "title": "Macro Expansion", "description": "The compiler needs to support macros which is likely 2-3 month effort", "creator": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "open_issues": 0, "closed_issues": 163, "state": "closed", "created_at": "2021-06-17T09:43:24Z", "updated_at": "2022-08-23T08:04:13Z", "due_on": "2022-03-28T07:00:00Z", "closed_at": "2022-03-31T10:49:54Z"}, "comments": 4, "created_at": "2021-07-17T13:32:24Z", "updated_at": "2022-03-14T09:46:23Z", "closed_at": "2022-03-14T09:46:23Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "This issue is designed to document the planned macro expansion system for declarative macros and to allow discussion regarding potential improvements to it.\r\n\r\nAll macro invocations are parsed in the Parser into either `MacroInvocation` or `MacroInvocationSemi` objects, depending on context. `MacroInvocationSemi`s can be `Item`s, associate items, or statements - basically anywhere where a semicolon would be required (though curly bracket macros do not require one). `MacroInvocation`s can be types, patterns or expressions - basically anywhere where a semicolon should never be used. This was done largely due to the Reference's separation into these two forms, and has its advantages and disadvantages.\r\n\r\nHowever, in order to simplify expansion, both `MacroInvocation` and `MacroInvocationSemi` classes have a `MacroInvocData` member variable, which stores the actual \"data\" of the macro (including name of macro and all tokens used inside). This was intended to allow the MacroExpander to operate by expanding instances of the data class rather than having to write two virtually identical methods for each expand method.\r\n\r\nThe basic idea for macro expansion is for the `MacroExpander` to basically scan through the entire AST, storing any macro definitions found (`MacroRulesDefinition` for declarative macros) and then attempting to expand any macro invocations found. The result of the expanded macro invocation (if it is possible to expand it currently) will then replace the macro invocation in the AST.\r\n\r\nTo actually expand declarative macros, it is planned for the `expand_decl_macro` method in `MacroExpander` be used. This takes the invocation data and the rules definition, and should return an `ASTFragment`. This sounds simple enough, but the actual implementation required is quite complicated and has multiple potential approaches, as detailed in #17. In short, Rust macro definitions can (and frequently do) have several potential \"match patterns\", and if one does not match, then the next should be tried. The basic consensus at the time was to follow this \"backtracking\" approach, rather than attempt a predictive one or use a generated parser.\r\n\r\nWith the backtracking approach, the macro parser would call specific methods of a new `Parser` instance on the token stream stored in the macro - e.g. `parse_expr` when an expression non-terminal was found as the next token in the match pattern. If there was a parse error, the macro parser would abort parsing that match pattern and attempt the next. If the macro parser successfully matched the entire \"match pattern\" with no parse errors, then the \"replacement pattern\" specified by that match-replacement pair would be used to generate the AST fragment.\r\n\r\nSince the regular `Parser` class is being reused by the `MacroParser`, it requires some sort of (wrapped) stream of tokens to operate on. However, due to how [Rust uses the concept of a \"token tree\" (either a non-delimiter token or a token tree within delimiters) in macros](https://doc.rust-lang.org/reference/macros-by-example.html#metavariables) (and also since the Reference models it as such), I thought it was easier to store macro tokens in a token tree form. As such, there needs to be a conversion of this token tree form into a token stream before the `Parser` uses it. However, intuition tells me that there are likely issues with doing this that I haven't thought of yet.\r\n\r\nAnother issue is that the `Parser` may, in rare cases, mutate the token stream. For example, it will split a `>>` (right-shift) token into two `>` (right angle bracket) tokens if it expects right angle brackets at the end of a generic type, for instance. However, this will theoretically apply for some different \"matched patterns\" but not others - i.e. it could be a generic close in one, but a right-shift in a different one. The best way I could think of to solve that issue (i.e. to avoid expensive copies of the entire token stream each time) was to record each time the parser modified the token stream inside the stream's wrapper, and have a \"reset\" function on the wrapper that reversed all changes. For example, a stack holding pairs of \"token pointer\" and \"stream index\" inside the wrapper could be used to implement this.\r\n\r\nThe last paragraph was where I got up to when thinking about the implementation. I'm sure there's other issues or implementation details that I haven't thought of yet.\r\n\r\nNotes:\r\n\r\n- By \"declarative macro\", I refer to what the Rust Reference calls [\"macros by example\" or \"MBE\"](https://doc.rust-lang.org/reference/macros-by-example.html) - macros that are based entirely on declarative \"if it matches this, replace it with this\" logic. This is in contrast to [\"procedural macros\"](https://doc.rust-lang.org/reference/procedural-macros.html) that can actually run code at compile time. Declarative macros, or at least user-defined ones, are defined using `macro_rules`, while procedural macros are defined differently.\r\n- By \"macro invocation\", I mean a place where a macro is called, or executed if you like. It is the place where the macro will be replaced by a result at compile time.\r\n- By \"macro definition\", I mean the place where a specific declarative macro is defined, i.e. the rules regarding what to match and what to replace said matches with.\r\n- The Reference mathematically defines how declarative macros should behave in naively ambiguous situations [here](https://doc.rust-lang.org/reference/macro-ambiguity.html). \r\n- [According to the Reference](https://doc.rust-lang.org/reference/macros-by-example.html#scoping-exporting-and-importing), Rust uses a somewhat complicated double-scoping system for macros that probably complicates the simple model that I have assumed above. There is \"textual scope\" (comparable to the scope of a declared variable - to end of enclosing scope) and \"path scope\", and different macro invocations can force one or the other.\r\n    - Similar to variable declarations, macro definitions can shadow others. As a result, macro definitions would have to be stored in some sort of \"list of maps\" data structure.\r\n- Macro expansion is significantly complicated by the fact that it and name resolution are interlaced, in the sense that neither can be fully completed without the other. This is because some macro lookups require name resolution to occur, and some name resolution requires macro expansion to have finished to generate something, etc. rustc has a [complex way of doing this](https://github.com/rust-lang/rust/blob/a08f25a7ef2800af5525762e981c24d96c14febe/compiler/rustc_expand/src/expand.rs#L426-L617).\r\n- Declarative macros are [hygienic](https://doc.rust-lang.org/reference/macros-by-example.html#hygiene), which means that the variables within are in their own scope. Special handling that I have not thought about yet is likely to be required for this.\r\n- An AST fragment is conceptually just a \"fragment\" of the AST that can syntactically replace the macro invocation at its specific context. Because of the many different contexts a macro invocation can be in (statement, pattern, expression, etc.), an AST fragment has to be very freeform. \r\n    - My current best idea for its representation is as an ordered list of so-called `SingleASTNode`s, where a `SingleASTNode` is a single AST node of any type - expression, statement, item, etc. `SingleASTNode` should be a tagged union, but due to implementation difficulties it is currently a struct and so wastes memory. There are advantages and disadvantages to this representation as well.\r\n - The reason why `AST::Token` stores a pointer to `Lexer::Token` is to prevent the requirement for potentially expensive re-conversion of tokens between the two types, while still allowing `AST::Token` to be represented heterogeneously as a kind of `TokenTree`. The re-conversions would be required if, for example, there was a macro invocation within the expression being matched.\r\n - The reason why the `Parser` splits tokens like `>>` into two `>`s in certain contexts is because it seemed to me like the best solution to the problem at the time. The problem is that the lexer, which has no syntactic information available (only regular information), cannot disambiguate between a right-shift and two right angle brackets without a space between them. I thought that this would be the best option as it best reflects the \"true\" token stream as interpreted by the parser, and options seemed to require more special handling.\r\n - The reason why the `Parser` is a template class is to allow the use of different \"wrappers\" for token streams, other than the `Lexer` class that it was originally built for. Similarly, the reason why the parser calls `add_error` instead of `rust_error_at` is to allow parse errors to be discarded by the macro parser when it tries a new match pattern - `rust_error_at` cannot be recovered from.\r\n- Some previous discussion mainly on declarative macros can be found in #17. ", "closed_by": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/Rust-GCC/gccrs/issues/573/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/Rust-GCC/gccrs/issues/573/timeline", "performed_via_github_app": null, "state_reason": "completed"}