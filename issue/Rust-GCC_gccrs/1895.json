{"url": "https://api.github.com/repos/Rust-GCC/gccrs/issues/1895", "repository_url": "https://api.github.com/repos/Rust-GCC/gccrs", "labels_url": "https://api.github.com/repos/Rust-GCC/gccrs/issues/1895/labels{/name}", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/issues/1895/comments", "events_url": "https://api.github.com/repos/Rust-GCC/gccrs/issues/1895/events", "html_url": "https://github.com/Rust-GCC/gccrs/issues/1895", "id": 1593286773, "node_id": "I_kwDOANBUbM5e96B1", "number": 1895, "title": "Support Iterators", "user": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 61372777, "node_id": "MDU6TGFiZWw2MTM3Mjc3Nw==", "url": "https://api.github.com/repos/Rust-GCC/gccrs/labels/enhancement", "name": "enhancement", "color": "84b6eb", "default": true, "description": null}], "state": "open", "locked": false, "assignee": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}], "milestone": {"url": "https://api.github.com/repos/Rust-GCC/gccrs/milestones/22", "html_url": "https://github.com/Rust-GCC/gccrs/milestone/22", "labels_url": "https://api.github.com/repos/Rust-GCC/gccrs/milestones/22/labels", "id": 9278274, "node_id": "MI_kwDOANBUbM4AjZNC", "number": 22, "title": "HIR Pipeline for libcore 1.49 Complete", "description": "Support all of the patterns and features used in libcore 1.49 at the HIR level: this includes, and isn't limited to, complex match patterns, inline assembly, some of the more complex type system features such as specialization, etc.", "creator": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "open_issues": 34, "closed_issues": 54, "state": "open", "created_at": "2023-04-13T08:17:13Z", "updated_at": "2023-06-20T19:14:22Z", "due_on": null, "closed_at": null}, "comments": 1, "created_at": "2023-02-21T11:11:21Z", "updated_at": "2023-06-13T18:25:12Z", "closed_at": null, "author_association": "MEMBER", "active_lock_reason": null, "body": "This is a parent issue to track progress on getting for-loops working, which actually uses iterators under the hood.\r\n\r\n### Task List\r\n\r\n- [x] #1894\r\n- [ ] #1893\r\n- [ ] #869 \r\n- [x] #850 \r\n- [x] #855 \r\n- [x] #1902\r\n- [x] https://github.com/Rust-GCC/gccrs/issues/1981\r\n- [x] https://github.com/Rust-GCC/gccrs/issues/2000\r\n- [x] #1984\r\n- [x] #1899\r\n- [x] #1904\r\n- [x] #1898\r\n- [x] #1897 \r\n- [x] #1896 \r\n- [x] #1901\r\n- [x] #1903\r\n- [x] #1524 \r\n- [ ] https://github.com/Rust-GCC/gccrs/issues/2015\r\n- [ ] https://github.com/Rust-GCC/gccrs/issues/2019\r\n- [x] https://github.com/Rust-GCC/gccrs/pull/1905\r\n- [x] https://github.com/Rust-GCC/gccrs/pull/1931\r\n- [x] https://github.com/Rust-GCC/gccrs/pull/1945\r\n- [x] https://github.com/Rust-GCC/gccrs/pull/1948\r\n- [x] https://github.com/Rust-GCC/gccrs/pull/1977\r\n- [x] https://github.com/Rust-GCC/gccrs/pull/1999\r\n- [x] https://github.com/Rust-GCC/gccrs/pull/2011\r\n- [x] https://github.com/Rust-GCC/gccrs/pull/2018\r\n\r\n### Goal-test case:\r\n\r\n```rust\r\n#![feature(intrinsics)]\r\n\r\npub use option::Option::{self, None, Some};\r\npub use result::Result::{self, Err, Ok};\r\n\r\nmod option {\r\n    pub enum Option<T> {\r\n        None,\r\n        Some(T),\r\n    }\r\n}\r\n\r\nmod result {\r\n    pub enum Result<T, E> {\r\n        Ok(T),\r\n        Err(E),\r\n    }\r\n}\r\n\r\n#[lang = \"sized\"]\r\npub trait Sized {}\r\n\r\n#[lang = \"clone\"]\r\npub trait Clone: Sized {\r\n    fn clone(&self) -> Self;\r\n\r\n    fn clone_from(&mut self, source: &Self) {\r\n        *self = source.clone()\r\n    }\r\n}\r\n\r\nmod impls {\r\n    use super::Clone;\r\n\r\n    macro_rules! impl_clone {\r\n        ($($t:ty)*) => {\r\n            $(\r\n                impl Clone for $t {\r\n                    fn clone(&self) -> Self {\r\n                        *self\r\n                    }\r\n                }\r\n            )*\r\n        }\r\n    }\r\n\r\n    impl_clone! {\r\n        usize u8 u16 u32 u64 // u128\r\n        isize i8 i16 i32 i64 // i128\r\n        f32 f64\r\n        bool char\r\n    }\r\n}\r\n\r\n#[lang = \"copy\"]\r\npub trait Copy: Clone {\r\n    // Empty.\r\n}\r\n\r\nmod copy_impls {\r\n    use super::Copy;\r\n\r\n    macro_rules! impl_copy {\r\n        ($($t:ty)*) => {\r\n            $(\r\n                impl Copy for $t {}\r\n            )*\r\n        }\r\n    }\r\n\r\n    impl_copy! {\r\n        usize u8 u16 u32 u64 // u128\r\n        isize i8 i16 i32 i64 // i128\r\n        f32 f64\r\n        bool char\r\n    }\r\n}\r\n\r\nmod intrinsics {\r\n    extern \"rust-intrinsic\" {\r\n        pub fn add_with_overflow<T>(x: T, y: T) -> (T, bool);\r\n        pub fn wrapping_add<T>(a: T, b: T) -> T;\r\n        pub fn wrapping_sub<T>(a: T, b: T) -> T;\r\n        pub fn rotate_left<T>(a: T, b: T) -> T;\r\n        pub fn rotate_right<T>(a: T, b: T) -> T;\r\n        pub fn offset<T>(ptr: *const T, count: isize) -> *const T;\r\n        pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\r\n        pub fn move_val_init<T>(dst: *mut T, src: T);\r\n        pub fn uninit<T>() -> T;\r\n    }\r\n}\r\n\r\nmod ptr {\r\n    #[lang = \"const_ptr\"]\r\n    impl<T> *const T {\r\n        pub unsafe fn offset(self, count: isize) -> *const T {\r\n            intrinsics::offset(self, count)\r\n        }\r\n    }\r\n\r\n    #[lang = \"mut_ptr\"]\r\n    impl<T> *mut T {\r\n        pub unsafe fn offset(self, count: isize) -> *mut T {\r\n            intrinsics::offset(self, count) as *mut T\r\n        }\r\n    }\r\n\r\n    pub unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\r\n        let x = x as *mut T;\r\n        let y = y as *mut T;\r\n        let len = mem::size_of::<T>() * count;\r\n        swap_nonoverlapping_bytes(x, y, len)\r\n    }\r\n\r\n    pub(crate) unsafe fn swap_nonoverlapping_one<T>(x: *mut T, y: *mut T) {\r\n        // For types smaller than the block optimization below,\r\n        // just swap directly to avoid pessimizing codegen.\r\n        if mem::size_of::<T>() < 32 {\r\n            let z = read(x);\r\n            intrinsics::copy_nonoverlapping(y, x, 1);\r\n            write(y, z);\r\n        } else {\r\n            swap_nonoverlapping(x, y, 1);\r\n        }\r\n    }\r\n\r\n    pub unsafe fn write<T>(dst: *mut T, src: T) {\r\n        intrinsics::move_val_init(&mut *dst, src)\r\n    }\r\n\r\n    pub unsafe fn read<T>(src: *const T) -> T {\r\n        let mut tmp: T = mem::uninitialized();\r\n        intrinsics::copy_nonoverlapping(src, &mut tmp, 1);\r\n        tmp\r\n    }\r\n\r\n    unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\r\n        struct Block(u64, u64, u64, u64);\r\n        struct UnalignedBlock(u64, u64, u64, u64);\r\n\r\n        let block_size = mem::size_of::<Block>();\r\n\r\n        // Loop through x & y, copying them `Block` at a time\r\n        // The optimizer should unroll the loop fully for most types\r\n        // N.B. We can't use a for loop as the `range` impl calls `mem::swap` recursively\r\n        let mut i = 0;\r\n        while i + block_size <= len {\r\n            // Create some uninitialized memory as scratch space\r\n            // Declaring `t` here avoids aligning the stack when this loop is unused\r\n            let mut t: Block = mem::uninitialized();\r\n            let t = &mut t as *mut _ as *mut u8;\r\n            let x = x.offset(i as isize);\r\n            let y = y.offset(i as isize);\r\n\r\n            // Swap a block of bytes of x & y, using t as a temporary buffer\r\n            // This should be optimized into efficient SIMD operations where available\r\n            intrinsics::copy_nonoverlapping(x, t, block_size);\r\n            intrinsics::copy_nonoverlapping(y, x, block_size);\r\n            intrinsics::copy_nonoverlapping(t, y, block_size);\r\n            i += block_size;\r\n        }\r\n\r\n        if i < len {\r\n            // Swap any remaining bytes\r\n            let mut t: UnalignedBlock = mem::uninitialized();\r\n            let rem = len - i;\r\n\r\n            let t = &mut t as *mut _ as *mut u8;\r\n            let x = x.offset(i as isize);\r\n            let y = y.offset(i as isize);\r\n\r\n            intrinsics::copy_nonoverlapping(x, t, rem);\r\n            intrinsics::copy_nonoverlapping(y, x, rem);\r\n            intrinsics::copy_nonoverlapping(t, y, rem);\r\n        }\r\n    }\r\n}\r\n\r\nmod mem {\r\n    extern \"rust-intrinsic\" {\r\n        pub fn transmute<T, U>(_: T) -> U;\r\n        pub fn size_of<T>() -> usize;\r\n    }\r\n\r\n    pub fn swap<T>(x: &mut T, y: &mut T) {\r\n        unsafe {\r\n            ptr::swap_nonoverlapping_one(x, y);\r\n        }\r\n    }\r\n\r\n    pub fn replace<T>(dest: &mut T, mut src: T) -> T {\r\n        swap(dest, &mut src);\r\n        src\r\n    }\r\n\r\n    pub unsafe fn uninitialized<T>() -> T {\r\n        intrinsics::uninit()\r\n    }\r\n}\r\n\r\nmacro_rules! impl_uint {\r\n    ($($ty:ident = $lang:literal),*) => {\r\n        $(\r\n            impl $ty {\r\n                pub fn wrapping_add(self, rhs: Self) -> Self {\r\n                    unsafe {\r\n                        intrinsics::wrapping_add(self, rhs)\r\n                    }\r\n                }\r\n\r\n                pub fn wrapping_sub(self, rhs: Self) -> Self {\r\n                    unsafe {\r\n                        intrinsics::wrapping_sub(self, rhs)\r\n                    }\r\n                }\r\n\r\n                pub fn rotate_left(self, n: u32) -> Self {\r\n                    unsafe {\r\n                        intrinsics::rotate_left(self, n as Self)\r\n                    }\r\n                }\r\n\r\n                pub fn rotate_right(self, n: u32) -> Self {\r\n                    unsafe {\r\n                        intrinsics::rotate_right(self, n as Self)\r\n                    }\r\n                }\r\n\r\n                pub fn to_le(self) -> Self {\r\n                    #[cfg(target_endian = \"little\")]\r\n                    {\r\n                        self\r\n                    }\r\n                }\r\n\r\n                pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\r\n                    Self::from_le(Self::from_ne_bytes(bytes))\r\n                }\r\n\r\n                pub const fn from_le(x: Self) -> Self {\r\n                    #[cfg(target_endian = \"little\")]\r\n                    {\r\n                        x\r\n                    }\r\n                }\r\n\r\n                pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\r\n                    unsafe { mem::transmute(bytes) }\r\n                }\r\n\r\n                pub fn checked_add(self, rhs: Self) -> Option<Self> {\r\n                    let (a, b) = self.overflowing_add(rhs);\r\n                    if b {\r\n                        Option::None\r\n                    } else {\r\n                        Option::Some(a)\r\n                    }\r\n                }\r\n\r\n                pub fn overflowing_add(self, rhs: Self) -> (Self, bool) {\r\n                    let (a, b) = unsafe { intrinsics::add_with_overflow(self as i32, rhs as i32) };\r\n                    (a as Self, b)\r\n                }\r\n            }\r\n        )*\r\n    }\r\n}\r\n\r\nimpl_uint!(\r\n    u8 = \"u8\",\r\n    u16 = \"u16\",\r\n    u32 = \"u32\",\r\n    u64 = \"u64\",\r\n    usize = \"usize\"\r\n);\r\n\r\n#[lang = \"add\"]\r\npub trait Add<RHS = Self> {\r\n    type Output;\r\n\r\n    fn add(self, rhs: RHS) -> Self::Output;\r\n}\r\nmacro_rules! add_impl {\r\n    ($($t:ty)*) => ($(\r\n        impl Add for $t {\r\n            type Output = $t;\r\n\r\n            fn add(self, other: $t) -> $t { self + other }\r\n        }\r\n    )*)\r\n}\r\n\r\nadd_impl! { usize u8 u16 u32 u64  /*isize i8 i16 i32 i64*/  f32 f64 }\r\n\r\n#[lang = \"sub\"]\r\npub trait Sub<RHS = Self> {\r\n    type Output;\r\n\r\n    fn sub(self, rhs: RHS) -> Self::Output;\r\n}\r\nmacro_rules! sub_impl {\r\n    ($($t:ty)*) => ($(\r\n        impl Sub for $t {\r\n            type Output = $t;\r\n\r\n            fn sub(self, other: $t) -> $t { self - other }\r\n        }\r\n    )*)\r\n}\r\n\r\nsub_impl! { usize u8 u16 u32 u64  /*isize i8 i16 i32 i64*/  f32 f64 }\r\n\r\n#[lang = \"Range\"]\r\npub struct Range<Idx> {\r\n    pub start: Idx,\r\n    pub end: Idx,\r\n}\r\n\r\npub trait TryFrom<T>: Sized {\r\n    /// The type returned in the event of a conversion error.\r\n    type Error;\r\n\r\n    /// Performs the conversion.\r\n    fn try_from(value: T) -> Result<Self, Self::Error>;\r\n}\r\n\r\npub trait From<T>: Sized {\r\n    fn from(_: T) -> Self;\r\n}\r\n\r\nimpl<T> From<T> for T {\r\n    fn from(t: T) -> T {\r\n        t\r\n    }\r\n}\r\n\r\nimpl<T, U> TryFrom<U> for T\r\nwhere\r\n    T: From<U>,\r\n{\r\n    type Error = !;\r\n\r\n    fn try_from(value: U) -> Result<Self, Self::Error> {\r\n        Ok(T::from(value))\r\n    }\r\n}\r\n\r\ntrait Step {\r\n    /// Returns the number of steps between two step objects. The count is\r\n    /// inclusive of `start` and exclusive of `end`.\r\n    ///\r\n    /// Returns `None` if it is not possible to calculate `steps_between`\r\n    /// without overflow.\r\n    fn steps_between(start: &Self, end: &Self) -> Option<usize>;\r\n\r\n    /// Replaces this step with `1`, returning itself\r\n    fn replace_one(&mut self) -> Self;\r\n\r\n    /// Replaces this step with `0`, returning itself\r\n    fn replace_zero(&mut self) -> Self;\r\n\r\n    /// Adds one to this step, returning the result\r\n    fn add_one(&self) -> Self;\r\n\r\n    /// Subtracts one to this step, returning the result\r\n    fn sub_one(&self) -> Self;\r\n\r\n    /// Add an usize, returning None on overflow\r\n    fn add_usize(&self, n: usize) -> Option<Self>;\r\n}\r\n\r\n// These are still macro-generated because the integer literals resolve to different types.\r\nmacro_rules! step_identical_methods {\r\n    () => {\r\n        #[inline]\r\n        fn replace_one(&mut self) -> Self {\r\n            mem::replace(self, 1)\r\n        }\r\n\r\n        #[inline]\r\n        fn replace_zero(&mut self) -> Self {\r\n            mem::replace(self, 0)\r\n        }\r\n\r\n        #[inline]\r\n        fn add_one(&self) -> Self {\r\n            //Add::add(*self, 1)\r\n            *self\r\n        }\r\n\r\n        #[inline]\r\n        fn sub_one(&self) -> Self {\r\n            // Sub::sub(*self, 1)\r\n            *self\r\n        }\r\n    };\r\n}\r\n\r\nmacro_rules! step_impl_unsigned {\r\n    ($($t:ty)*) => ($(\r\n        impl Step for $t {\r\n            fn steps_between(start: &$t, end: &$t) -> Option<usize> {\r\n                if *start < *end {\r\n                    // Note: We assume $t <= usize here\r\n                    Option::Some((*end - *start) as usize)\r\n                } else {\r\n                    Option::Some(0)\r\n                }\r\n            }\r\n\r\n            fn add_usize(&self, n: usize) -> Option<Self> {\r\n                match <$t>::try_from(n) {\r\n                    Result::Ok(n_as_t) => self.checked_add(n_as_t),\r\n                    Result::Err(_) => Option::None,\r\n                }\r\n            }\r\n\r\n            step_identical_methods!();\r\n        }\r\n    )*)\r\n}\r\nmacro_rules! step_impl_signed {\r\n    ($( [$t:ty : $unsigned:ty] )*) => ($(\r\n        impl Step for $t {\r\n            #[inline]\r\n            #[allow(trivial_numeric_casts)]\r\n            fn steps_between(start: &$t, end: &$t) -> Option<usize> {\r\n                if *start < *end {\r\n                    // Note: We assume $t <= isize here\r\n                    // Use .wrapping_sub and cast to usize to compute the\r\n                    // difference that may not fit inside the range of isize.\r\n                    Option::Some((*end as isize).wrapping_sub(*start as isize) as usize)\r\n                } else {\r\n                    Option::Some(0)\r\n                }\r\n            }\r\n\r\n            #[inline]\r\n            #[allow(unreachable_patterns)]\r\n            fn add_usize(&self, n: usize) -> Option<Self> {\r\n                match <$unsigned>::try_from(n) {\r\n                    Result::Ok(n_as_unsigned) => {\r\n                        // Wrapping in unsigned space handles cases like\r\n                        // `-120_i8.add_usize(200) == Option::Some(80_i8)`,\r\n                        // even though 200_usize is out of range for i8.\r\n                        let wrapped = (*self as $unsigned).wrapping_add(n_as_unsigned) as $t;\r\n                        if wrapped >= *self {\r\n                            Option::Some(wrapped)\r\n                        } else {\r\n                            Option::None  // Addition overflowed\r\n                        }\r\n                    }\r\n                    Result::Err(_) => Option::None,\r\n                }\r\n            }\r\n\r\n            step_identical_methods!();\r\n        }\r\n    )*)\r\n}\r\n\r\nmacro_rules! step_impl_no_between {\r\n    ($($t:ty)*) => ($(\r\n        impl Step for $t {\r\n            #[inline]\r\n            fn steps_between(_start: &Self, _end: &Self) -> Option<usize> {\r\n                Option::None\r\n            }\r\n\r\n            #[inline]\r\n            fn add_usize(&self, n: usize) -> Option<Self> {\r\n                self.checked_add(n as $t)\r\n            }\r\n\r\n            step_identical_methods!();\r\n        }\r\n    )*)\r\n}\r\n\r\nstep_impl_unsigned!(usize u8 u16 u32);\r\n// step_impl_signed!([isize: usize][i8: u8][i16: u16][i32: u32]);\r\n#[cfg(target_pointer_width = \"64\")]\r\nstep_impl_unsigned!(u64);\r\n#[cfg(target_pointer_width = \"64\")]\r\n// step_impl_signed!([i64: u64]);\r\n// If the target pointer width is not 64-bits, we\r\n// assume here that it is less than 64-bits.\r\n#[cfg(not(target_pointer_width = \"64\"))]\r\nstep_impl_no_between!(u64 i64);\r\n// step_impl_no_between!(u128 i128);\r\n\r\npub trait Iterator {\r\n    type Item;\r\n\r\n    fn next(&mut self) -> Option<Self::Item>;\r\n}\r\n\r\nimpl<A: Step> Iterator for Range<A> {\r\n    type Item = A;\r\n\r\n    fn next(&mut self) -> Option<A> {\r\n        if self.start < self.end {\r\n            // We check for overflow here, even though it can't actually\r\n            // happen. Adding this check does however help llvm vectorize loops\r\n            // for some ranges that don't get vectorized otherwise,\r\n            // and this won't actually result in an extra check in an optimized build.\r\n            match self.start.add_usize(1) {\r\n                Option::Some(mut n) => {\r\n                    mem::swap(&mut n, &mut self.start);\r\n                    Option::Some(n)\r\n                }\r\n                Option::None => Option::None,\r\n            }\r\n        } else {\r\n            Option::None\r\n        }\r\n    }\r\n}\r\n\r\npub trait IntoIterator {\r\n    type Item;\r\n\r\n    type IntoIter: Iterator<Item = Self::Item>;\r\n\r\n    fn into_iter(self) -> Self::IntoIter;\r\n}\r\n\r\nimpl<I: Iterator> IntoIterator for I {\r\n    type Item = I::Item;\r\n    type IntoIter = I;\r\n\r\n    fn into_iter(self) -> I {\r\n        self\r\n    }\r\n}\r\n\r\nfn main() {}\r\n\r\n\r\n```", "closed_by": null, "reactions": {"url": "https://api.github.com/repos/Rust-GCC/gccrs/issues/1895/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/Rust-GCC/gccrs/issues/1895/timeline", "performed_via_github_app": null, "state_reason": null}