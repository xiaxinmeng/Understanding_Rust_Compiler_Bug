{"url": "https://api.github.com/repos/Rust-GCC/gccrs/issues/1274", "repository_url": "https://api.github.com/repos/Rust-GCC/gccrs", "labels_url": "https://api.github.com/repos/Rust-GCC/gccrs/issues/1274/labels{/name}", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/issues/1274/comments", "events_url": "https://api.github.com/repos/Rust-GCC/gccrs/issues/1274/events", "html_url": "https://github.com/Rust-GCC/gccrs/issues/1274", "id": 1246463559, "node_id": "I_kwDOANBUbM5KS4ZH", "number": 1274, "title": "Bad assertion on Impl Blocks containing associated types", "user": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 61372775, "node_id": "MDU6TGFiZWw2MTM3Mjc3NQ==", "url": "https://api.github.com/repos/Rust-GCC/gccrs/labels/bug", "name": "bug", "color": "fc2929", "default": true, "description": null}], "state": "closed", "locked": false, "assignee": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}], "milestone": {"url": "https://api.github.com/repos/Rust-GCC/gccrs/milestones/6", "html_url": "https://github.com/Rust-GCC/gccrs/milestone/6", "labels_url": "https://api.github.com/repos/Rust-GCC/gccrs/milestones/6/labels", "id": 6262846, "node_id": "MDk6TWlsZXN0b25lNjI2Mjg0Ng==", "number": 6, "title": "Imports and visibility", "description": "Multi file compilation and with use, extern and mod.", "creator": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "open_issues": 0, "closed_issues": 161, "state": "closed", "created_at": "2021-01-03T14:20:54Z", "updated_at": "2022-08-23T08:04:15Z", "due_on": "2022-05-30T07:00:00Z", "closed_at": "2022-08-03T10:02:38Z"}, "comments": 0, "created_at": "2022-05-24T12:19:40Z", "updated_at": "2022-05-25T12:49:01Z", "closed_at": "2022-05-25T12:49:00Z", "author_association": "MEMBER", "active_lock_reason": null, "body": "<!--\r\nThank you for finding an Internal Compiler Error! \ud83e\uddca  If possible, try to provide\r\na minimal verifiable example. You can read \"Rust Bug Minimization Patterns\" for\r\nhow to create smaller examples.\r\n\r\nhttp://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\r\n\r\n-->\r\n\r\n### Code\r\n\r\n```rust\r\nmod intrinsics {\r\n    extern \"rust-intrinsic\" {\r\n        pub fn wrapping_add<T>(a: T, b: T) -> T;\r\n        pub fn rotate_left<T>(a: T, b: T) -> T;\r\n        pub fn rotate_right<T>(a: T, b: T) -> T;\r\n        pub fn offset<T>(ptr: *const T, count: isize) -> *const T;\r\n    }\r\n}\r\n\r\nmod mem {\r\n    extern \"rust-intrinsic\" {\r\n        fn transmute<T, U>(_: T) -> U;\r\n        fn size_of<T>() -> usize;\r\n    }\r\n}\r\n\r\nmacro_rules! impl_uint {\r\n    ($($ty:ident = $lang:literal),*) => {\r\n        $(\r\n            impl $ty {\r\n                pub fn wrapping_add(self, rhs: Self) -> Self {\r\n                    intrinsics::wrapping_add(self, rhs)\r\n                }\r\n\r\n                pub fn rotate_left(self, n: u32) -> Self {\r\n                    intrinsics::rotate_left(self, n as Self)\r\n                }\r\n\r\n                pub fn rotate_right(self, n: u32) -> Self {\r\n                    intrinsics::rotate_right(self, n as Self)\r\n                }\r\n\r\n                pub fn to_le(self) -> Self {\r\n                    #[cfg(target_endian = \"little\")]\r\n                    {\r\n                        self\r\n                    }\r\n                }\r\n\r\n                pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\r\n                    Self::from_le(Self::from_ne_bytes(bytes))\r\n                }\r\n\r\n                pub const fn from_le(x: Self) -> Self {\r\n                    #[cfg(target_endian = \"little\")]\r\n                    {\r\n                        x\r\n                    }\r\n                }\r\n\r\n                pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\r\n                    unsafe { mem::transmute(bytes) }\r\n                }\r\n            }\r\n        )*\r\n    }\r\n}\r\n\r\nimpl_uint!(\r\n    u8 = \"u8\",\r\n    u16 = \"u16\",\r\n    u32 = \"u32\",\r\n    u64 = \"u64\",\r\n    u128 = \"u128\",\r\n    usize = \"usize\"\r\n);\r\n\r\nmod cmp {\r\n    pub fn min(a: usize, b: usize) -> usize {\r\n        if a < b {\r\n            a\r\n        } else {\r\n            b\r\n        }\r\n    }\r\n}\r\n\r\nextern \"C\" {\r\n    fn printf(s: *const i8, ...);\r\n}\r\n\r\nstruct FatPtr<T> {\r\n    data: *const T,\r\n    len: usize,\r\n}\r\n\r\npub union Repr<T> {\r\n    rust: *const [T],\r\n    rust_mut: *mut [T],\r\n    raw: FatPtr<T>,\r\n}\r\n\r\npub enum Option<T> {\r\n    None,\r\n    Some(T),\r\n}\r\n\r\n#[lang = \"RangeFull\"]\r\npub struct RangeFull;\r\n\r\n#[lang = \"Range\"]\r\npub struct Range<Idx> {\r\n    pub start: Idx,\r\n    pub end: Idx,\r\n}\r\n\r\n#[lang = \"RangeFrom\"]\r\npub struct RangeFrom<Idx> {\r\n    pub start: Idx,\r\n}\r\n\r\n#[lang = \"RangeTo\"]\r\npub struct RangeTo<Idx> {\r\n    pub end: Idx,\r\n}\r\n\r\n#[lang = \"RangeInclusive\"]\r\npub struct RangeInclusive<Idx> {\r\n    pub start: Idx,\r\n    pub end: Idx,\r\n}\r\n\r\n#[lang = \"const_slice_ptr\"]\r\nimpl<T> *const [T] {\r\n    pub const fn len(self) -> usize {\r\n        let a = unsafe { Repr { rust: self }.raw };\r\n        a.len\r\n    }\r\n\r\n    pub const fn as_ptr(self) -> *const T {\r\n        self as *const T\r\n    }\r\n}\r\n\r\n#[lang = \"const_ptr\"]\r\nimpl<T> *const T {\r\n    pub const unsafe fn offset(self, count: isize) -> *const T {\r\n        unsafe { intrinsics::offset(self, count) }\r\n    }\r\n\r\n    pub const unsafe fn add(self, count: usize) -> Self {\r\n        unsafe { self.offset(count as isize) }\r\n    }\r\n\r\n    pub const fn as_ptr(self) -> *const T {\r\n        self as *const T\r\n    }\r\n}\r\n\r\nconst fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\r\n    unsafe {\r\n        Repr {\r\n            raw: FatPtr { data, len },\r\n        }\r\n        .rust\r\n    }\r\n}\r\n\r\n#[lang = \"index\"]\r\ntrait Index<Idx> {\r\n    type Output;\r\n\r\n    fn index(&self, index: Idx) -> &Self::Output;\r\n}\r\n\r\nimpl<T> [T] {\r\n    pub const fn is_empty(&self) -> bool {\r\n        self.len() == 0\r\n    }\r\n\r\n    pub const fn len(&self) -> usize {\r\n        unsafe { Repr { rust: self }.raw.len }\r\n    }\r\n}\r\n\r\npub unsafe trait SliceIndex<T> {\r\n    type Output;\r\n\r\n    fn get(self, slice: &T) -> Option<&Self::Output>;\r\n\r\n    unsafe fn get_unchecked(self, slice: *const T) -> *const Self::Output;\r\n\r\n    fn index(self, slice: &T) -> &Self::Output;\r\n}\r\n\r\nunsafe impl<T> SliceIndex<[T]> for usize {\r\n    type Output = T;\r\n\r\n    fn get(self, slice: &[T]) -> Option<&T> {\r\n        unsafe { Option::Some(&*self.get_unchecked(slice)) }\r\n    }\r\n\r\n    unsafe fn get_unchecked(self, slice: *const [T]) -> *const T {\r\n        // SAFETY: the caller guarantees that `slice` is not dangling, so it\r\n        // cannot be longer than `isize::MAX`. They also guarantee that\r\n        // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\r\n        // so the call to `add` is safe.\r\n        unsafe { slice.as_ptr().add(self) }\r\n    }\r\n\r\n    fn index(self, slice: &[T]) -> &T {\r\n        unsafe { &*self.get_unchecked(slice) }\r\n    }\r\n}\r\n\r\nunsafe impl<T> SliceIndex<[T]> for Range<usize> {\r\n    type Output = [T];\r\n\r\n    fn get(self, slice: &[T]) -> Option<&[T]> {\r\n        if self.start > self.end || self.end > slice.len() {\r\n            Option::None\r\n        } else {\r\n            unsafe { Option::Some(&*self.get_unchecked(slice)) }\r\n        }\r\n    }\r\n\r\n    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\r\n        unsafe {\r\n            let a: *const T = slice.as_ptr();\r\n            let b: *const T = a.add(self.start);\r\n            slice_from_raw_parts(b, self.end - self.start)\r\n        }\r\n    }\r\n\r\n    fn index(self, slice: &[T]) -> &[T] {\r\n        unsafe { &*self.get_unchecked(slice) }\r\n    }\r\n}\r\n\r\n// issue-1270\r\n// unsafe impl<T> SliceIndex<[T]> for RangeTo<usize> {\r\n//     type Output = [T];\r\n\r\n//     fn get(self, slice: &[T]) -> Option<&[T]> {\r\n//         (0..self.end).get(slice)\r\n//     }\r\n\r\n//     unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\r\n//         // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\r\n//         unsafe { (0..self.end).get_unchecked(slice) }\r\n//     }\r\n\r\n//     fn index(self, slice: &[T]) -> &[T] {\r\n//         (0..self.end).index(slice)\r\n//     }\r\n// }\r\n\r\n// #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\r\n// unsafe impl<T> SliceIndex<[T]> for RangeFrom<usize> {\r\n//     type Output = [T];\r\n\r\n//     fn get(self, slice: &[T]) -> Option<&[T]> {\r\n//         (self.start..slice.len()).get(slice)\r\n//     }\r\n\r\n//     unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\r\n//         // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\r\n//         unsafe { (self.start..slice.len()).get_unchecked(slice) }\r\n//     }\r\n\r\n//     fn index(self, slice: &[T]) -> &[T] {\r\n//         unsafe { &*self.get_unchecked(slice) }\r\n//     }\r\n// }\r\n\r\nunsafe impl<T> SliceIndex<[T]> for RangeFull {\r\n    type Output = [T];\r\n\r\n    fn get(self, slice: &[T]) -> Option<&[T]> {\r\n        Option::Some(slice)\r\n    }\r\n\r\n    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\r\n        slice\r\n    }\r\n\r\n    fn index(self, slice: &[T]) -> &[T] {\r\n        slice\r\n    }\r\n}\r\n\r\n// unsafe impl<T> SliceIndex<[T]> for RangeToInclusive<usize> {\r\n//     type Output = [T];\r\n\r\n//     fn get(self, slice: &[T]) -> Option<&[T]> {\r\n//         (0..=self.end).get(slice)\r\n//     }\r\n\r\n//     unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\r\n//         // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\r\n//         unsafe { (0..=self.end).get_unchecked(slice) }\r\n//     }\r\n\r\n//     fn index(self, slice: &[T]) -> &[T] {\r\n//         (0..=self.end).index(slice)\r\n//     }\r\n// }\r\n\r\nimpl<T, I> Index<I> for [T]\r\nwhere\r\n    I: SliceIndex<[T]>,\r\n{\r\n    type Output = I::Output;\r\n\r\n    fn index(&self, index: I) -> &I::Output {\r\n        index.index(self)\r\n    }\r\n}\r\n\r\n// end prelude from libcore\r\n\r\nconst OUT_LEN: usize = 32;\r\nconst KEY_LEN: usize = 32;\r\nconst BLOCK_LEN: usize = 64;\r\nconst CHUNK_LEN: usize = 1024;\r\n\r\nconst CHUNK_START: u32 = 1 << 0;\r\nconst CHUNK_END: u32 = 1 << 1;\r\nconst PARENT: u32 = 1 << 2;\r\nconst ROOT: u32 = 1 << 3;\r\nconst KEYED_HASH: u32 = 1 << 4;\r\nconst DERIVE_KEY_CONTEXT: u32 = 1 << 5;\r\nconst DERIVE_KEY_MATERIAL: u32 = 1 << 6;\r\n\r\nconst IV: [u32; 8] = [\r\n    0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19,\r\n];\r\n\r\nconst MSG_PERMUTATION: [usize; 16] = [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8];\r\n\r\n// The mixing function, G, which mixes either a column or a diagonal.\r\nfn g(state: &mut [u32; 16], a: usize, b: usize, c: usize, d: usize, mx: u32, my: u32) {\r\n    state[a] = state[a].wrapping_add(state[b]).wrapping_add(mx);\r\n    state[d] = (state[d] ^ state[a]).rotate_right(16);\r\n    state[c] = state[c].wrapping_add(state[d]);\r\n    state[b] = (state[b] ^ state[c]).rotate_right(12);\r\n    state[a] = state[a].wrapping_add(state[b]).wrapping_add(my);\r\n    state[d] = (state[d] ^ state[a]).rotate_right(8);\r\n    state[c] = state[c].wrapping_add(state[d]);\r\n    state[b] = (state[b] ^ state[c]).rotate_right(7);\r\n}\r\n\r\nfn round(state: &mut [u32; 16], m: &[u32; 16]) {\r\n    // Mix the columns.\r\n    g(state, 0, 4, 8, 12, m[0], m[1]);\r\n    g(state, 1, 5, 9, 13, m[2], m[3]);\r\n    g(state, 2, 6, 10, 14, m[4], m[5]);\r\n    g(state, 3, 7, 11, 15, m[6], m[7]);\r\n    // Mix the diagonals.\r\n    g(state, 0, 5, 10, 15, m[8], m[9]);\r\n    g(state, 1, 6, 11, 12, m[10], m[11]);\r\n    g(state, 2, 7, 8, 13, m[12], m[13]);\r\n    g(state, 3, 4, 9, 14, m[14], m[15]);\r\n}\r\n\r\nfn permute(m: &mut [u32; 16]) {\r\n    let mut permuted = [0; 16];\r\n    // for i in 0..16 {\r\n    //     permuted[i] = m[MSG_PERMUTATION[i]];\r\n    // }\r\n    *m = permuted;\r\n}\r\n\r\nfn compress(\r\n    chaining_value: &[u32; 8],\r\n    block_words: &[u32; 16],\r\n    counter: u64,\r\n    block_len: u32,\r\n    flags: u32,\r\n) -> [u32; 16] {\r\n    let mut state = [\r\n        chaining_value[0],\r\n        chaining_value[1],\r\n        chaining_value[2],\r\n        chaining_value[3],\r\n        chaining_value[4],\r\n        chaining_value[5],\r\n        chaining_value[6],\r\n        chaining_value[7],\r\n        IV[0],\r\n        IV[1],\r\n        IV[2],\r\n        IV[3],\r\n        counter as u32,\r\n        (counter >> 32) as u32,\r\n        block_len,\r\n        flags,\r\n    ];\r\n    let mut block = *block_words;\r\n\r\n    round(&mut state, &block); // round 1\r\n    permute(&mut block);\r\n    round(&mut state, &block); // round 2\r\n    permute(&mut block);\r\n    round(&mut state, &block); // round 3\r\n    permute(&mut block);\r\n    round(&mut state, &block); // round 4\r\n    permute(&mut block);\r\n    round(&mut state, &block); // round 5\r\n    permute(&mut block);\r\n    round(&mut state, &block); // round 6\r\n    permute(&mut block);\r\n    round(&mut state, &block); // round 7\r\n\r\n    // for i in 0..8 {\r\n    //     state[i] ^= state[i + 8];\r\n    //     state[i + 8] ^= chaining_value[i];\r\n    // }\r\n    state\r\n}\r\n\r\nfn first_8_words(compression_output: [u32; 16]) -> [u32; 8] {\r\n    compression_output[0..8].try_into().unwrap()\r\n}\r\n\r\nfn words_from_little_endian_bytes(bytes: &[u8], words: &mut [u32]) {\r\n    // debug_assert_eq!(bytes.len(), 4 * words.len());\r\n    // for (four_bytes, word) in bytes.chunks_exact(4).zip(words) {\r\n    //     *word = u32::from_le_bytes(four_bytes.try_into().unwrap());\r\n    // }\r\n}\r\n\r\n// Each chunk or parent node can produce either an 8-word chaining value or, by\r\n// setting the ROOT flag, any number of final output bytes. The Output struct\r\n// captures the state just prior to choosing between those two possibilities.\r\nstruct Output {\r\n    input_chaining_value: [u32; 8],\r\n    block_words: [u32; 16],\r\n    counter: u64,\r\n    block_len: u32,\r\n    flags: u32,\r\n}\r\n\r\nimpl Output {\r\n    fn chaining_value(&self) -> [u32; 8] {\r\n        first_8_words(compress(\r\n            &self.input_chaining_value,\r\n            &self.block_words,\r\n            self.counter,\r\n            self.block_len,\r\n            self.flags,\r\n        ))\r\n    }\r\n\r\n    fn root_output_bytes(&self, out_slice: &mut [u8]) {\r\n        let mut output_block_counter = 0;\r\n        // for out_block in out_slice.chunks_mut(2 * OUT_LEN) {\r\n        //     let words = compress(\r\n        //         &self.input_chaining_value,\r\n        //         &self.block_words,\r\n        //         output_block_counter,\r\n        //         self.block_len,\r\n        //         self.flags | ROOT,\r\n        //     );\r\n        //     // The output length might not be a multiple of 4.\r\n        //     for (word, out_word) in words.iter().zip(out_block.chunks_mut(4)) {\r\n        //         out_word.copy_from_slice(&word.to_le_bytes()[..out_word.len()]);\r\n        //     }\r\n        //     output_block_counter += 1;\r\n        // }\r\n    }\r\n}\r\n\r\nstruct ChunkState {\r\n    chaining_value: [u32; 8],\r\n    chunk_counter: u64,\r\n    block: [u8; BLOCK_LEN],\r\n    block_len: u8,\r\n    blocks_compressed: u8,\r\n    flags: u32,\r\n}\r\n\r\nimpl ChunkState {\r\n    fn new(key_words: [u32; 8], chunk_counter: u64, flags: u32) -> Self {\r\n        Self {\r\n            chaining_value: key_words,\r\n            chunk_counter,\r\n            block: [0; BLOCK_LEN],\r\n            block_len: 0,\r\n            blocks_compressed: 0,\r\n            flags,\r\n        }\r\n    }\r\n\r\n    fn len(&self) -> usize {\r\n        BLOCK_LEN * self.blocks_compressed as usize + self.block_len as usize\r\n    }\r\n\r\n    fn start_flag(&self) -> u32 {\r\n        if self.blocks_compressed == 0 {\r\n            CHUNK_START\r\n        } else {\r\n            0\r\n        }\r\n    }\r\n\r\n    fn update(&mut self, mut input: &[u8]) {\r\n        while !input.is_empty() {\r\n            // If the block buffer is full, compress it and clear it. More\r\n            // input is coming, so this compression is not CHUNK_END.\r\n            if self.block_len as usize == BLOCK_LEN {\r\n                let mut block_words = [0; 16];\r\n                words_from_little_endian_bytes(&self.block, &mut block_words);\r\n                self.chaining_value = first_8_words(compress(\r\n                    &self.chaining_value,\r\n                    &block_words,\r\n                    self.chunk_counter,\r\n                    BLOCK_LEN as u32,\r\n                    self.flags | self.start_flag(),\r\n                ));\r\n                self.blocks_compressed += 1;\r\n                self.block = [0; BLOCK_LEN];\r\n                self.block_len = 0;\r\n            }\r\n\r\n            // Copy input bytes into the block buffer.\r\n            let want = BLOCK_LEN - self.block_len as usize;\r\n            let take = cmp::min(want, input.len());\r\n\r\n            // FIXME issue-1270 range-from range-to\r\n            //\r\n            // self.block[self.block_len as usize..][..take].copy_from_slice(&input[..take]);\r\n            self.block_len += take as u8;\r\n            // input = &input[take..];\r\n        }\r\n    }\r\n\r\n    fn output(&self) -> Output {\r\n        let mut block_words = [0; 16];\r\n        words_from_little_endian_bytes(&self.block, &mut block_words);\r\n        Output {\r\n            input_chaining_value: self.chaining_value,\r\n            block_words,\r\n            counter: self.chunk_counter,\r\n            block_len: self.block_len as u32,\r\n            flags: self.flags | self.start_flag() | CHUNK_END,\r\n        }\r\n    }\r\n}\r\n\r\nfn parent_output(\r\n    left_child_cv: [u32; 8],\r\n    right_child_cv: [u32; 8],\r\n    key_words: [u32; 8],\r\n    flags: u32,\r\n) -> Output {\r\n    let mut block_words = [0; 16];\r\n\r\n    // FIXME issue-1270 range-from range-to\r\n    // block_words[..8].copy_from_slice(&left_child_cv);\r\n    // block_words[8..].copy_from_slice(&right_child_cv);\r\n    Output {\r\n        input_chaining_value: key_words,\r\n        block_words,\r\n        counter: 0,                  // Always 0 for parent nodes.\r\n        block_len: BLOCK_LEN as u32, // Always BLOCK_LEN (64) for parent nodes.\r\n        flags: PARENT | flags,\r\n    }\r\n}\r\n\r\nfn parent_cv(\r\n    left_child_cv: [u32; 8],\r\n    right_child_cv: [u32; 8],\r\n    key_words: [u32; 8],\r\n    flags: u32,\r\n) -> [u32; 8] {\r\n    parent_output(left_child_cv, right_child_cv, key_words, flags).chaining_value()\r\n}\r\n\r\n/// An incremental hasher that can accept any number of writes.\r\npub struct Hasher {\r\n    chunk_state: ChunkState,\r\n    key_words: [u32; 8],\r\n    cv_stack: [[u32; 8]; 54], // Space for 54 subtree chaining values:\r\n    cv_stack_len: u8,         // 2^54 * CHUNK_LEN = 2^64\r\n    flags: u32,\r\n}\r\n\r\nimpl Hasher {\r\n    fn new_internal(key_words: [u32; 8], flags: u32) -> Self {\r\n        Self {\r\n            chunk_state: ChunkState::new(key_words, 0, flags),\r\n            key_words,\r\n            cv_stack: [[0; 8]; 54],\r\n            cv_stack_len: 0,\r\n            flags,\r\n        }\r\n    }\r\n\r\n    /// Construct a new `Hasher` for the regular hash function.\r\n    pub fn new() -> Self {\r\n        Self::new_internal(IV, 0)\r\n    }\r\n\r\n    /// Construct a new `Hasher` for the keyed hash function.\r\n    pub fn new_keyed(key: &[u8; KEY_LEN]) -> Self {\r\n        let mut key_words = [0; 8];\r\n        words_from_little_endian_bytes(key, &mut key_words);\r\n        Self::new_internal(key_words, KEYED_HASH)\r\n    }\r\n\r\n    /// Construct a new `Hasher` for the key derivation function. The context\r\n    /// string should be hardcoded, globally unique, and application-specific.\r\n    pub fn new_derive_key(context: &str) -> Self {\r\n        let mut context_hasher = Self::new_internal(IV, DERIVE_KEY_CONTEXT);\r\n        // FIXME https://github.com/Rust-GCC/gccrs/issues/1271\r\n        // context_hasher.update(context.as_bytes());\r\n        let mut context_key = [0; KEY_LEN];\r\n        context_hasher.finalize(&mut context_key);\r\n        let mut context_key_words = [0; 8];\r\n        words_from_little_endian_bytes(&context_key, &mut context_key_words);\r\n        Self::new_internal(context_key_words, DERIVE_KEY_MATERIAL)\r\n    }\r\n\r\n    fn push_stack(&mut self, cv: [u32; 8]) {\r\n        self.cv_stack[self.cv_stack_len as usize] = cv;\r\n        self.cv_stack_len += 1;\r\n    }\r\n\r\n    fn pop_stack(&mut self) -> [u32; 8] {\r\n        self.cv_stack_len -= 1;\r\n        self.cv_stack[self.cv_stack_len as usize]\r\n    }\r\n\r\n    // Section 5.1.2 of the BLAKE3 spec explains this algorithm in more detail.\r\n    fn add_chunk_chaining_value(&mut self, mut new_cv: [u32; 8], mut total_chunks: u64) {\r\n        // This chunk might complete some subtrees. For each completed subtree,\r\n        // its left child will be the current top entry in the CV stack, and\r\n        // its right child will be the current value of `new_cv`. Pop each left\r\n        // child off the stack, merge it with `new_cv`, and overwrite `new_cv`\r\n        // with the result. After all these merges, push the final value of\r\n        // `new_cv` onto the stack. The number of completed subtrees is given\r\n        // by the number of trailing 0-bits in the new total number of chunks.\r\n        while total_chunks & 1 == 0 {\r\n            new_cv = parent_cv(self.pop_stack(), new_cv, self.key_words, self.flags);\r\n            total_chunks >>= 1;\r\n        }\r\n        self.push_stack(new_cv);\r\n    }\r\n\r\n    /// Add input to the hash state. This can be called any number of times.\r\n    pub fn update(&mut self, mut input: &[u8]) {\r\n        while !input.is_empty() {\r\n            // If the current chunk is complete, finalize it and reset the\r\n            // chunk state. More input is coming, so this chunk is not ROOT.\r\n            if self.chunk_state.len() == CHUNK_LEN {\r\n                let chunk_cv = self.chunk_state.output().chaining_value();\r\n                let total_chunks = self.chunk_state.chunk_counter + 1;\r\n                self.add_chunk_chaining_value(chunk_cv, total_chunks);\r\n                self.chunk_state = ChunkState::new(self.key_words, total_chunks, self.flags);\r\n            }\r\n\r\n            // Compress input bytes into the current chunk state.\r\n            let want = CHUNK_LEN - self.chunk_state.len();\r\n            let take = cmp::min(want, input.len());\r\n            // FIXME https://github.com/Rust-GCC/gccrs/issues/1271\r\n            // self.chunk_state.update(&input[..take]);\r\n            // input = &input[take..];\r\n        }\r\n    }\r\n\r\n    /// Finalize the hash and write any number of output bytes.\r\n    pub fn finalize(&self, out_slice: &mut [u8]) {\r\n        // Starting with the Output from the current chunk, compute all the\r\n        // parent chaining values along the right edge of the tree, until we\r\n        // have the root Output.\r\n        let mut output = self.chunk_state.output();\r\n        let mut parent_nodes_remaining = self.cv_stack_len as usize;\r\n        while parent_nodes_remaining > 0 {\r\n            parent_nodes_remaining -= 1;\r\n            output = parent_output(\r\n                self.cv_stack[parent_nodes_remaining],\r\n                output.chaining_value(),\r\n                self.key_words,\r\n                self.flags,\r\n            );\r\n        }\r\n        output.root_output_bytes(out_slice);\r\n    }\r\n}\r\n\r\n```\r\n\r\n### Meta\r\n\r\n- What version of Rust GCC were you using, git sha if possible.\r\n\r\n### Error output\r\n\r\n```\r\nrust1: internal compiler error: in operator(), at rust/typecheck/rust-hir-dot-operator.cc:254\r\n```\r\n\r\n<!--\r\nInclude a backtrace if available.\r\n-->\r\n<details><summary>Backtrace</summary>\r\n  <p>\r\n  \r\n  ```\r\nrust1: internal compiler error: in operator(), at rust/typecheck/rust-hir-dot-operator.cc:254\r\n0x136f94a operator()\r\n        ../../gccrs/gcc/rust/typecheck/rust-hir-dot-operator.cc:254\r\n0x137107b _M_invoke\r\n        /usr/include/c++/9/bits/std_function.h:285\r\n0x122b21c Rust::Analysis::Mappings::iterate_impl_blocks(std::function<bool (unsigned int, Rust::HIR::ImplBlock*)>)\r\n        ../../gccrs/gcc/rust/util/rust-hir-map.cc:786\r\n0x136fcc3 Rust::Resolver::MethodResolver::select()\r\n        ../../gccrs/gcc/rust/typecheck/rust-hir-dot-operator.cc:225\r\n0x136eebe Rust::Resolver::MethodResolver::Try(Rust::TyTy::BaseType const*, Rust::HIR::PathIdentSegment const&, std::vector<Rust::Resolver::Adjustment, std::allocator<Rust::Resolver::Adjustment> >&)\r\n        ../../gccrs/gcc/rust/typecheck/rust-hir-dot-operator.cc:134\r\n0x136e8ce Rust::Resolver::MethodResolver::Probe(Rust::TyTy::BaseType const*, Rust::HIR::PathIdentSegment const&, bool)\r\n        ../../gccrs/gcc/rust/typecheck/rust-hir-dot-operator.cc:35\r\n0x136c30a Rust::Resolver::TypeCheckExpr::resolve_operator_overload(Rust::Analysis::RustLangItem::ItemType, Rust::HIR::OperatorExprMeta, Rust::TyTy::BaseType*, Rust::TyTy::BaseType*)\r\n        ../../gccrs/gcc/rust/typecheck/rust-hir-type-check-expr.cc:321\r\n0x136bf3f Rust::Resolver::TypeCheckExpr::visit(Rust::HIR::ArrayIndexExpr&)\r\n        ../../gccrs/gcc/rust/typecheck/rust-hir-type-check-expr.cc:260\r\n0x11f20f1 Rust::HIR::ArrayIndexExpr::accept_vis(Rust::HIR::HIRFullVisitor&)\r\n        ../../gccrs/gcc/rust/hir/tree/rust-hir-full-test.cc:3995\r\n0x12ea133 Rust::Resolver::TypeCheckExpr::Resolve(Rust::HIR::Expr*, bool)\r\n        ../../gccrs/gcc/rust/typecheck/rust-hir-type-check-expr.h:49\r\n0x11f1ef9 Rust::HIR::AssignmentExpr::accept_vis(Rust::HIR::HIRFullVisitor&)\r\n        ../../gccrs/gcc/rust/hir/tree/rust-hir-full-test.cc:3941\r\n0x12ea133 Rust::Resolver::TypeCheckExpr::Resolve(Rust::HIR::Expr*, bool)\r\n        ../../gccrs/gcc/rust/typecheck/rust-hir-type-check-expr.h:49\r\n0x11f34ef Rust::HIR::ExprStmtWithoutBlock::accept_vis(Rust::HIR::HIRFullVisitor&)\r\n        ../../gccrs/gcc/rust/hir/tree/rust-hir-full-test.cc:4541\r\n0x12e28ee Rust::Resolver::TypeCheckExpr::visit(Rust::HIR::BlockExpr&)\r\n        ../../gccrs/gcc/rust/typecheck/rust-hir-type-check.cc:101\r\n0x11f2359 Rust::HIR::BlockExpr::accept_vis(Rust::HIR::HIRFullVisitor&)\r\n        ../../gccrs/gcc/rust/hir/tree/rust-hir-full-test.cc:4061\r\n0x12ea133 Rust::Resolver::TypeCheckExpr::Resolve(Rust::HIR::Expr*, bool)\r\n        ../../gccrs/gcc/rust/typecheck/rust-hir-type-check-expr.h:49\r\n0x11f2ba1 Rust::HIR::Function::accept_vis(Rust::HIR::HIRFullVisitor&)\r\n        ../../gccrs/gcc/rust/hir/tree/rust-hir-full-test.cc:4289\r\n0x12e269b Rust::Resolver::TypeResolution::Resolve(Rust::HIR::Crate&)\r\n        ../../gccrs/gcc/rust/typecheck/rust-hir-type-check.cc:47\r\n0x113dd91 Rust::Session::parse_file(char const*)\r\n        ../../gccrs/gcc/rust/rust-session-manager.cc:741\r\n0x113d416 Rust::Session::parse_files(int, char const**)\r\n        ../../gccrs/gcc/rust/rust-session-manager.cc:572\r\n  ```\r\n  \r\n  </p>\r\n</details>\r\n", "closed_by": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "reactions": {"url": "https://api.github.com/repos/Rust-GCC/gccrs/issues/1274/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/Rust-GCC/gccrs/issues/1274/timeline", "performed_via_github_app": null, "state_reason": "completed"}