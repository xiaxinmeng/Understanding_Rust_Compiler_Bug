{"sha": "3e67bded92b389dfdb56f7a9a40e85b8be4d4d4c", "node_id": "C_kwDOAAsO6NoAKDNlNjdiZGVkOTJiMzg5ZGZkYjU2ZjdhOWE0MGU4NWI4YmU0ZDRkNGM", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-07-04T07:40:30Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-17T17:20:28Z"}, "message": "Make names more explicit.", "tree": {"sha": "4d20c86b71ea6c12620432303ed5821339cb4354", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d20c86b71ea6c12620432303ed5821339cb4354"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e67bded92b389dfdb56f7a9a40e85b8be4d4d4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e67bded92b389dfdb56f7a9a40e85b8be4d4d4c", "html_url": "https://github.com/rust-lang/rust/commit/3e67bded92b389dfdb56f7a9a40e85b8be4d4d4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e67bded92b389dfdb56f7a9a40e85b8be4d4d4c/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2a17e9bd10b6a777485d9e37fa0289bf5ecf62f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2a17e9bd10b6a777485d9e37fa0289bf5ecf62f", "html_url": "https://github.com/rust-lang/rust/commit/b2a17e9bd10b6a777485d9e37fa0289bf5ecf62f"}], "stats": {"total": 36, "additions": 21, "deletions": 15}, "files": [{"sha": "b3de6741594097b8595bfa39277dbc5382e38405", "filename": "compiler/rustc_span/src/span_encoding.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3e67bded92b389dfdb56f7a9a40e85b8be4d4d4c/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e67bded92b389dfdb56f7a9a40e85b8be4d4d4c/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs?ref=3e67bded92b389dfdb56f7a9a40e85b8be4d4d4c", "patch": "@@ -28,12 +28,17 @@ use rustc_data_structures::fx::FxIndexSet;\n /// Inline (compressed) format:\n /// - `span.base_or_index == span_data.lo`\n /// - `span.len_or_tag == len == span_data.hi - span_data.lo` (must be `<= MAX_LEN`)\n-/// - `span.ctxt == span_data.ctxt` (must be `< MAX_CTXT`)\n+/// - `span.ctxt_or_tag == span_data.ctxt` (must be `<= MAX_CTXT`)\n+///\n+/// Interned format with inline `SyntaxContext`:\n+/// - `span.base_or_index == index` (indexes into the interner table)\n+/// - `span.len_or_tag == LEN_TAG` (high bit set, all other bits are zero)\n+/// - `span.ctxt_or_tag == span_data.ctxt` (must be `<= MAX_CTXT`)\n ///\n /// Interned format:\n /// - `span.base_or_index == index` (indexes into the interner table)\n /// - `span.len_or_tag == LEN_TAG` (high bit set, all other bits are zero)\n-/// - `span.ctxt == span_data.ctxt` (must be < `MAX_CTXT`) or `MAX_CTXT` otherwise\n+/// - `span.ctxt_or_tag == CTXT_TAG`\n ///\n /// The inline form uses 0 for the tag value (rather than 1) so that we don't\n /// need to mask out the tag bit when getting the length, and so that the\n@@ -50,10 +55,10 @@ use rustc_data_structures::fx::FxIndexSet;\n ///   at 3 or 4, and then it drops off quickly from 8 onwards. 15 bits is enough\n ///   for 99.99%+ of cases, but larger values (sometimes 20+ bits) might occur\n ///   dozens of times in a typical crate.\n-/// - `ctxt` is 16 bits in `Span` and 32 bits in `SpanData`, which means that\n+/// - `ctxt_or_tag` is 16 bits in `Span` and 32 bits in `SpanData`, which means that\n ///   large `ctxt` values will cause interning. The number of bits needed for\n ///   `ctxt` values depend partly on the crate size and partly on the form of\n-///   the code. No crates in `rustc-perf` need more than 15 bits for `ctxt`,\n+///   the code. No crates in `rustc-perf` need more than 15 bits for `ctxt_or_tag`,\n ///   but larger crates might need more than 16 bits.\n ///\n /// In order to reliably use parented spans in incremental compilation,\n@@ -65,15 +70,16 @@ use rustc_data_structures::fx::FxIndexSet;\n pub struct Span {\n     base_or_index: u32,\n     len_or_tag: u16,\n-    ctxt_or_max: u16,\n+    ctxt_or_tag: u16,\n }\n \n const LEN_TAG: u16 = 0b1000_0000_0000_0000;\n const MAX_LEN: u32 = 0b0111_1111_1111_1111;\n-const MAX_CTXT: u32 = 0b1111_1111_1111_1111;\n+const CTXT_TAG: u32 = 0b1111_1111_1111_1111;\n+const MAX_CTXT: u32 = CTXT_TAG - 1;\n \n /// Dummy span, both position and length are zero, syntax context is zero as well.\n-pub const DUMMY_SP: Span = Span { base_or_index: 0, len_or_tag: 0, ctxt_or_max: 0 };\n+pub const DUMMY_SP: Span = Span { base_or_index: 0, len_or_tag: 0, ctxt_or_tag: 0 };\n \n impl Span {\n     #[inline]\n@@ -89,15 +95,15 @@ impl Span {\n \n         let (base, len, ctxt2) = (lo.0, hi.0 - lo.0, ctxt.as_u32());\n \n-        if len <= MAX_LEN && ctxt2 < MAX_CTXT && parent.is_none() {\n+        if len <= MAX_LEN && ctxt2 <= MAX_CTXT && parent.is_none() {\n             // Inline format.\n-            Span { base_or_index: base, len_or_tag: len as u16, ctxt_or_max: ctxt2 as u16 }\n+            Span { base_or_index: base, len_or_tag: len as u16, ctxt_or_tag: ctxt2 as u16 }\n         } else {\n             // Interned format.\n             let index =\n                 with_span_interner(|interner| interner.intern(&SpanData { lo, hi, ctxt, parent }));\n-            let ctxt_or_max = if ctxt2 < MAX_CTXT { ctxt2 } else { MAX_CTXT } as u16;\n-            Span { base_or_index: index, len_or_tag: LEN_TAG, ctxt_or_max }\n+            let ctxt_or_tag = if ctxt2 <= MAX_CTXT { ctxt2 } else { CTXT_TAG } as u16;\n+            Span { base_or_index: index, len_or_tag: LEN_TAG, ctxt_or_tag }\n         }\n     }\n \n@@ -120,7 +126,7 @@ impl Span {\n             SpanData {\n                 lo: BytePos(self.base_or_index),\n                 hi: BytePos(self.base_or_index + self.len_or_tag as u32),\n-                ctxt: SyntaxContext::from_u32(self.ctxt_or_max as u32),\n+                ctxt: SyntaxContext::from_u32(self.ctxt_or_tag as u32),\n                 parent: None,\n             }\n         } else {\n@@ -133,10 +139,10 @@ impl Span {\n     /// This function is used as a fast path when decoding the full `SpanData` is not necessary.\n     #[inline]\n     pub fn ctxt(self) -> SyntaxContext {\n-        let ctxt_or_max = self.ctxt_or_max as u32;\n-        if ctxt_or_max < MAX_CTXT {\n+        let ctxt_or_tag = self.ctxt_or_tag as u32;\n+        if ctxt_or_tag <= MAX_CTXT {\n             // Inline format or interned format with inline ctxt.\n-            SyntaxContext::from_u32(ctxt_or_max)\n+            SyntaxContext::from_u32(ctxt_or_tag)\n         } else {\n             // Interned format.\n             let index = self.base_or_index;"}]}