{"sha": "ed37335c012a66f5d028a160221b1ca152a61325", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkMzczMzVjMDEyYTY2ZjVkMDI4YTE2MDIyMWIxY2ExNTJhNjEzMjU=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-09-02T13:21:10Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-09-03T16:36:07Z"}, "message": "Begin refactor of import insertion", "tree": {"sha": "cef02c8c4cc8ad519ecd8f8040a7100d30329da7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cef02c8c4cc8ad519ecd8f8040a7100d30329da7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed37335c012a66f5d028a160221b1ca152a61325", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed37335c012a66f5d028a160221b1ca152a61325", "html_url": "https://github.com/rust-lang/rust/commit/ed37335c012a66f5d028a160221b1ca152a61325", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed37335c012a66f5d028a160221b1ca152a61325/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74e7422b69d35c55ff6fde77258047f0292d36e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/74e7422b69d35c55ff6fde77258047f0292d36e0", "html_url": "https://github.com/rust-lang/rust/commit/74e7422b69d35c55ff6fde77258047f0292d36e0"}], "stats": {"total": 908, "additions": 440, "deletions": 468}, "files": [{"sha": "8ee5e0c9c55684df35bb7d828fed0b08e26c3349", "filename": "crates/assists/src/utils/insert_use.rs", "status": "modified", "additions": 440, "deletions": 468, "changes": 908, "blob_url": "https://github.com/rust-lang/rust/blob/ed37335c012a66f5d028a160221b1ca152a61325/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed37335c012a66f5d028a160221b1ca152a61325/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs?ref=ed37335c012a66f5d028a160221b1ca152a61325", "patch": "@@ -1,17 +1,13 @@\n-//! Handle syntactic aspects of inserting a new `use`.\n-// FIXME: rewrite according to the plan, outlined in\n-// https://github.com/rust-analyzer/rust-analyzer/issues/3301#issuecomment-592931553\n-\n-use std::iter::successors;\n+use std::iter::{self, successors};\n \n+use algo::skip_trivia_token;\n+use ast::{edit::AstNodeEdit, PathSegmentKind, VisibilityOwner};\n use either::Either;\n use syntax::{\n-    ast::{self, NameOwner, VisibilityOwner},\n-    AstNode, AstToken, Direction, SmolStr,\n-    SyntaxKind::{PATH, PATH_SEGMENT},\n-    SyntaxNode, SyntaxToken, T,\n+    algo,\n+    ast::{self, make, AstNode},\n+    Direction, InsertPosition, SyntaxElement, SyntaxNode, T,\n };\n-use text_edit::TextEditBuilder;\n \n use crate::assist_context::AssistContext;\n \n@@ -22,525 +18,501 @@ pub(crate) fn find_insert_use_container(\n ) -> Option<Either<ast::ItemList, ast::SourceFile>> {\n     ctx.sema.ancestors_with_macros(position.clone()).find_map(|n| {\n         if let Some(module) = ast::Module::cast(n.clone()) {\n-            return module.item_list().map(|it| Either::Left(it));\n+            return module.item_list().map(Either::Left);\n         }\n         Some(Either::Right(ast::SourceFile::cast(n)?))\n     })\n }\n \n-/// Creates and inserts a use statement for the given path to import.\n-/// The use statement is inserted in the scope most appropriate to the\n-/// the cursor position given, additionally merged with the existing use imports.\n pub(crate) fn insert_use_statement(\n     // Ideally the position of the cursor, used to\n     position: &SyntaxNode,\n     path_to_import: &str,\n-    ctx: &AssistContext,\n-    builder: &mut TextEditBuilder,\n+    ctx: &crate::assist_context::AssistContext,\n+    builder: &mut text_edit::TextEditBuilder,\n ) {\n-    let target = path_to_import.split(\"::\").map(SmolStr::new).collect::<Vec<_>>();\n-    let container = find_insert_use_container(position, ctx);\n+    insert_use(position.clone(), make::path_from_text(path_to_import), Some(MergeBehaviour::Full));\n+}\n+\n+pub fn insert_use(\n+    where_: SyntaxNode,\n+    path: ast::Path,\n+    merge_behaviour: Option<MergeBehaviour>,\n+) -> SyntaxNode {\n+    let use_item = make::use_(make::use_tree(path.clone(), None, None, false));\n+    // merge into existing imports if possible\n+    if let Some(mb) = merge_behaviour {\n+        for existing_use in where_.children().filter_map(ast::Use::cast) {\n+            if let Some(merged) = try_merge_imports(&existing_use, &use_item, mb) {\n+                let to_delete: SyntaxElement = existing_use.syntax().clone().into();\n+                let to_delete = to_delete.clone()..=to_delete;\n+                let to_insert = iter::once(merged.syntax().clone().into());\n+                return algo::replace_children(&where_, to_delete, to_insert);\n+            }\n+        }\n+    }\n+\n+    // either we weren't allowed to merge or there is no import that fits the merge conditions\n+    // so look for the place we have to insert to\n+    let (insert_position, add_blank) = find_insert_position(&where_, path);\n+\n+    let to_insert: Vec<SyntaxElement> = {\n+        let mut buf = Vec::new();\n+\n+        if add_blank == AddBlankLine::Before {\n+            buf.push(make::tokens::single_newline().into());\n+        }\n+\n+        buf.push(use_item.syntax().clone().into());\n+\n+        if add_blank == AddBlankLine::After {\n+            buf.push(make::tokens::single_newline().into());\n+        } else if add_blank == AddBlankLine::AfterTwice {\n+            buf.push(make::tokens::single_newline().into());\n+            buf.push(make::tokens::single_newline().into());\n+        }\n \n-    if let Some(container) = container {\n-        let syntax = container.either(|l| l.syntax().clone(), |r| r.syntax().clone());\n-        let action = best_action_for_target(syntax, position.clone(), &target);\n-        make_assist(&action, &target, builder);\n+        buf\n+    };\n+\n+    algo::insert_children(&where_, insert_position, to_insert)\n+}\n+\n+fn try_merge_imports(\n+    old: &ast::Use,\n+    new: &ast::Use,\n+    merge_behaviour: MergeBehaviour,\n+) -> Option<ast::Use> {\n+    // dont merge into re-exports\n+    if old.visibility().map(|vis| vis.pub_token()).is_some() {\n+        return None;\n+    }\n+    let old_tree = old.use_tree()?;\n+    let new_tree = new.use_tree()?;\n+    let merged = try_merge_trees(&old_tree, &new_tree, merge_behaviour)?;\n+    Some(old.with_use_tree(merged))\n+}\n+\n+/// Simple function that checks if a UseTreeList is deeper than one level\n+fn use_tree_list_is_nested(tl: &ast::UseTreeList) -> bool {\n+    tl.use_trees().any(|use_tree| {\n+        use_tree.use_tree_list().is_some() || use_tree.path().and_then(|p| p.qualifier()).is_some()\n+    })\n+}\n+\n+pub fn try_merge_trees(\n+    old: &ast::UseTree,\n+    new: &ast::UseTree,\n+    merge_behaviour: MergeBehaviour,\n+) -> Option<ast::UseTree> {\n+    let lhs_path = old.path()?;\n+    let rhs_path = new.path()?;\n+\n+    let (lhs_prefix, rhs_prefix) = common_prefix(&lhs_path, &rhs_path)?;\n+    let lhs = old.split_prefix(&lhs_prefix);\n+    let rhs = new.split_prefix(&rhs_prefix);\n+    let lhs_tl = lhs.use_tree_list()?;\n+    let rhs_tl = rhs.use_tree_list()?;\n+\n+    // if we are only allowed to merge the last level check if the paths are only one level deep\n+    // FIXME: This shouldn't work yet i think\n+    if merge_behaviour == MergeBehaviour::Last && use_tree_list_is_nested(&lhs_tl)\n+        || use_tree_list_is_nested(&rhs_tl)\n+    {\n+        return None;\n     }\n+\n+    let should_insert_comma = lhs_tl\n+        .r_curly_token()\n+        .and_then(|it| skip_trivia_token(it.prev_token()?, Direction::Prev))\n+        .map(|it| it.kind() != T![,])\n+        .unwrap_or(true);\n+    let mut to_insert: Vec<SyntaxElement> = Vec::new();\n+    if should_insert_comma {\n+        to_insert.push(make::token(T![,]).into());\n+        to_insert.push(make::tokens::single_space().into());\n+    }\n+    to_insert.extend(\n+        rhs_tl\n+            .syntax()\n+            .children_with_tokens()\n+            .filter(|it| it.kind() != T!['{'] && it.kind() != T!['}']),\n+    );\n+    let pos = InsertPosition::Before(lhs_tl.r_curly_token()?.into());\n+    let use_tree_list = lhs_tl.insert_children(pos, to_insert);\n+    Some(lhs.with_use_tree_list(use_tree_list))\n }\n \n-fn collect_path_segments_raw(\n-    segments: &mut Vec<ast::PathSegment>,\n-    mut path: ast::Path,\n-) -> Option<usize> {\n-    let oldlen = segments.len();\n+/// Traverses both paths until they differ, returning the common prefix of both.\n+fn common_prefix(lhs: &ast::Path, rhs: &ast::Path) -> Option<(ast::Path, ast::Path)> {\n+    let mut res = None;\n+    let mut lhs_curr = first_path(&lhs);\n+    let mut rhs_curr = first_path(&rhs);\n     loop {\n-        let mut children = path.syntax().children_with_tokens();\n-        let (first, second, third) = (\n-            children.next().map(|n| (n.clone(), n.kind())),\n-            children.next().map(|n| (n.clone(), n.kind())),\n-            children.next().map(|n| (n.clone(), n.kind())),\n-        );\n-        match (first, second, third) {\n-            (Some((subpath, PATH)), Some((_, T![::])), Some((segment, PATH_SEGMENT))) => {\n-                path = ast::Path::cast(subpath.as_node()?.clone())?;\n-                segments.push(ast::PathSegment::cast(segment.as_node()?.clone())?);\n-            }\n-            (Some((segment, PATH_SEGMENT)), _, _) => {\n-                segments.push(ast::PathSegment::cast(segment.as_node()?.clone())?);\n-                break;\n+        match (lhs_curr.segment(), rhs_curr.segment()) {\n+            (Some(lhs), Some(rhs)) if lhs.syntax().text() == rhs.syntax().text() => (),\n+            _ => break,\n+        }\n+        res = Some((lhs_curr.clone(), rhs_curr.clone()));\n+\n+        match lhs_curr.parent_path().zip(rhs_curr.parent_path()) {\n+            Some((lhs, rhs)) => {\n+                lhs_curr = lhs;\n+                rhs_curr = rhs;\n             }\n-            (_, _, _) => return None,\n+            _ => break,\n         }\n     }\n-    // We need to reverse only the new added segments\n-    let only_new_segments = segments.split_at_mut(oldlen).1;\n-    only_new_segments.reverse();\n-    Some(segments.len() - oldlen)\n+\n+    res\n }\n \n-fn fmt_segments_raw(segments: &[SmolStr], buf: &mut String) {\n-    let mut iter = segments.iter();\n-    if let Some(s) = iter.next() {\n-        buf.push_str(s);\n-    }\n-    for s in iter {\n-        buf.push_str(\"::\");\n-        buf.push_str(s);\n-    }\n+/// What type of merges are allowed.\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub enum MergeBehaviour {\n+    /// Merge everything together creating deeply nested imports.\n+    Full,\n+    /// Only merge the last import level, doesn't allow import nesting.\n+    Last,\n }\n \n-/// Returns the number of common segments.\n-fn compare_path_segments(left: &[SmolStr], right: &[ast::PathSegment]) -> usize {\n-    left.iter().zip(right).take_while(|(l, r)| compare_path_segment(l, r)).count()\n+#[derive(Eq, PartialEq, PartialOrd, Ord)]\n+enum ImportGroup {\n+    // the order here defines the order of new group inserts\n+    Std,\n+    ExternCrate,\n+    ThisCrate,\n+    ThisModule,\n+    SuperModule,\n }\n \n-fn compare_path_segment(a: &SmolStr, b: &ast::PathSegment) -> bool {\n-    if let Some(kb) = b.kind() {\n-        match kb {\n-            ast::PathSegmentKind::Name(nameref_b) => a == nameref_b.text(),\n-            ast::PathSegmentKind::SelfKw => a == \"self\",\n-            ast::PathSegmentKind::SuperKw => a == \"super\",\n-            ast::PathSegmentKind::CrateKw => a == \"crate\",\n-            ast::PathSegmentKind::Type { .. } => false, // not allowed in imports\n+impl ImportGroup {\n+    fn new(path: &ast::Path) -> ImportGroup {\n+        let default = ImportGroup::ExternCrate;\n+\n+        let first_segment = match first_segment(path) {\n+            Some(it) => it,\n+            None => return default,\n+        };\n+\n+        let kind = first_segment.kind().unwrap_or(PathSegmentKind::SelfKw);\n+        match kind {\n+            PathSegmentKind::SelfKw => ImportGroup::ThisModule,\n+            PathSegmentKind::SuperKw => ImportGroup::SuperModule,\n+            PathSegmentKind::CrateKw => ImportGroup::ThisCrate,\n+            PathSegmentKind::Name(name) => match name.text().as_str() {\n+                \"std\" => ImportGroup::Std,\n+                \"core\" => ImportGroup::Std,\n+                // FIXME: can be ThisModule as well\n+                _ => ImportGroup::ExternCrate,\n+            },\n+            PathSegmentKind::Type { .. } => unreachable!(),\n         }\n-    } else {\n-        false\n     }\n }\n \n-fn compare_path_segment_with_name(a: &SmolStr, b: &ast::Name) -> bool {\n-    a == b.text()\n+fn first_segment(path: &ast::Path) -> Option<ast::PathSegment> {\n+    first_path(path).segment()\n }\n \n-#[derive(Clone, Debug)]\n-enum ImportAction {\n-    Nothing,\n-    // Add a brand new use statement.\n-    AddNewUse {\n-        anchor: Option<SyntaxNode>, // anchor node\n-        add_after_anchor: bool,\n-    },\n-\n-    // To split an existing use statement creating a nested import.\n-    AddNestedImport {\n-        // how may segments matched with the target path\n-        common_segments: usize,\n-        path_to_split: ast::Path,\n-        // the first segment of path_to_split we want to add into the new nested list\n-        first_segment_to_split: Option<ast::PathSegment>,\n-        // Wether to add 'self' in addition to the target path\n-        add_self: bool,\n-    },\n-    // To add the target path to an existing nested import tree list.\n-    AddInTreeList {\n-        common_segments: usize,\n-        // The UseTreeList where to add the target path\n-        tree_list: ast::UseTreeList,\n-        add_self: bool,\n-    },\n+fn first_path(path: &ast::Path) -> ast::Path {\n+    successors(Some(path.clone()), ast::Path::qualifier).last().unwrap()\n }\n \n-impl ImportAction {\n-    fn add_new_use(anchor: Option<SyntaxNode>, add_after_anchor: bool) -> Self {\n-        ImportAction::AddNewUse { anchor, add_after_anchor }\n+fn segment_iter(path: &ast::Path) -> impl Iterator<Item = ast::PathSegment> + Clone {\n+    path.syntax().children().flat_map(ast::PathSegment::cast)\n+}\n+\n+#[derive(PartialEq, Eq)]\n+enum AddBlankLine {\n+    Before,\n+    After,\n+    AfterTwice,\n+}\n+\n+fn find_insert_position(\n+    scope: &SyntaxNode,\n+    insert_path: ast::Path,\n+) -> (InsertPosition<SyntaxElement>, AddBlankLine) {\n+    let group = ImportGroup::new(&insert_path);\n+    let path_node_iter = scope\n+        .children()\n+        .filter_map(|node| ast::Use::cast(node.clone()).zip(Some(node)))\n+        .flat_map(|(use_, node)| use_.use_tree().and_then(|tree| tree.path()).zip(Some(node)));\n+    // Iterator that discards anything thats not in the required grouping\n+    // This implementation allows the user to rearrange their import groups as this only takes the first group that fits\n+    let group_iter = path_node_iter\n+        .clone()\n+        .skip_while(|(path, _)| ImportGroup::new(path) != group)\n+        .take_while(|(path, _)| ImportGroup::new(path) == group);\n+\n+    let segments = segment_iter(&insert_path);\n+    // track the last element we iterated over, if this is still None after the iteration then that means we never iterated in the first place\n+    let mut last = None;\n+    // find the element that would come directly after our new import\n+    let post_insert =\n+        group_iter.inspect(|(_, node)| last = Some(node.clone())).find(|(path, _)| {\n+            let check_segments = segment_iter(&path);\n+            segments\n+                .clone()\n+                .zip(check_segments)\n+                .flat_map(|(seg, seg2)| seg.name_ref().zip(seg2.name_ref()))\n+                .all(|(l, r)| l.text() <= r.text())\n+        });\n+    match post_insert {\n+        // insert our import before that element\n+        Some((_, node)) => (InsertPosition::Before(node.into()), AddBlankLine::After),\n+        // there is no element after our new import, so append it to the end of the group\n+        None => match last {\n+            Some(node) => (InsertPosition::After(node.into()), AddBlankLine::Before),\n+            // the group we were looking for actually doesnt exist, so insert\n+            None => {\n+                // similar concept here to the `last` from above\n+                let mut last = None;\n+                // find the group that comes after where we want to insert\n+                let post_group = path_node_iter\n+                    .inspect(|(_, node)| last = Some(node.clone()))\n+                    .find(|(p, _)| ImportGroup::new(p) > group);\n+                match post_group {\n+                    Some((_, node)) => {\n+                        (InsertPosition::Before(node.into()), AddBlankLine::AfterTwice)\n+                    }\n+                    // there is no such group, so append after the last one\n+                    None => match last {\n+                        Some(node) => (InsertPosition::After(node.into()), AddBlankLine::Before),\n+                        // there are no imports in this file at all\n+                        None => (InsertPosition::First, AddBlankLine::AfterTwice),\n+                    },\n+                }\n+            }\n+        },\n     }\n+}\n \n-    fn add_nested_import(\n-        common_segments: usize,\n-        path_to_split: ast::Path,\n-        first_segment_to_split: Option<ast::PathSegment>,\n-        add_self: bool,\n-    ) -> Self {\n-        ImportAction::AddNestedImport {\n-            common_segments,\n-            path_to_split,\n-            first_segment_to_split,\n-            add_self,\n-        }\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use test_utils::assert_eq_text;\n+\n+    #[test]\n+    fn insert_start() {\n+        check_none(\n+            \"std::bar::A\",\n+            r\"use std::bar::B;\n+use std::bar::D;\n+use std::bar::F;\n+use std::bar::G;\",\n+            r\"use std::bar::A;\n+use std::bar::B;\n+use std::bar::D;\n+use std::bar::F;\n+use std::bar::G;\",\n+        )\n     }\n \n-    fn add_in_tree_list(\n-        common_segments: usize,\n-        tree_list: ast::UseTreeList,\n-        add_self: bool,\n-    ) -> Self {\n-        ImportAction::AddInTreeList { common_segments, tree_list, add_self }\n+    #[test]\n+    fn insert_middle() {\n+        check_none(\n+            \"std::bar::E\",\n+            r\"use std::bar::A;\n+use std::bar::D;\n+use std::bar::F;\n+use std::bar::G;\",\n+            r\"use std::bar::A;\n+use std::bar::D;\n+use std::bar::E;\n+use std::bar::F;\n+use std::bar::G;\",\n+        )\n     }\n \n-    fn better(left: ImportAction, right: ImportAction) -> ImportAction {\n-        if left.is_better(&right) {\n-            left\n-        } else {\n-            right\n-        }\n+    #[test]\n+    fn insert_end() {\n+        check_none(\n+            \"std::bar::Z\",\n+            r\"use std::bar::A;\n+use std::bar::D;\n+use std::bar::F;\n+use std::bar::G;\",\n+            r\"use std::bar::A;\n+use std::bar::D;\n+use std::bar::F;\n+use std::bar::G;\n+use std::bar::Z;\",\n+        )\n     }\n \n-    fn is_better(&self, other: &ImportAction) -> bool {\n-        match (self, other) {\n-            (ImportAction::Nothing, _) => true,\n-            (ImportAction::AddInTreeList { .. }, ImportAction::Nothing) => false,\n-            (\n-                ImportAction::AddNestedImport { common_segments: n, .. },\n-                ImportAction::AddInTreeList { common_segments: m, .. },\n-            )\n-            | (\n-                ImportAction::AddInTreeList { common_segments: n, .. },\n-                ImportAction::AddNestedImport { common_segments: m, .. },\n-            )\n-            | (\n-                ImportAction::AddInTreeList { common_segments: n, .. },\n-                ImportAction::AddInTreeList { common_segments: m, .. },\n-            )\n-            | (\n-                ImportAction::AddNestedImport { common_segments: n, .. },\n-                ImportAction::AddNestedImport { common_segments: m, .. },\n-            ) => n > m,\n-            (ImportAction::AddInTreeList { .. }, _) => true,\n-            (ImportAction::AddNestedImport { .. }, ImportAction::Nothing) => false,\n-            (ImportAction::AddNestedImport { .. }, _) => true,\n-            (ImportAction::AddNewUse { .. }, _) => false,\n-        }\n+    #[test]\n+    fn insert_middle_pnested() {\n+        check_none(\n+            \"std::bar::E\",\n+            r\"use std::bar::A;\n+use std::bar::{D, Z}; // example of weird imports due to user\n+use std::bar::F;\n+use std::bar::G;\",\n+            r\"use std::bar::A;\n+use std::bar::E;\n+use std::bar::{D, Z}; // example of weird imports due to user\n+use std::bar::F;\n+use std::bar::G;\",\n+        )\n     }\n-}\n \n-// Find out the best ImportAction to import target path against current_use_tree.\n-// If current_use_tree has a nested import the function gets called recursively on every UseTree inside a UseTreeList.\n-fn walk_use_tree_for_best_action(\n-    current_path_segments: &mut Vec<ast::PathSegment>, // buffer containing path segments\n-    current_parent_use_tree_list: Option<ast::UseTreeList>, // will be Some value if we are in a nested import\n-    current_use_tree: ast::UseTree, // the use tree we are currently examinating\n-    target: &[SmolStr],             // the path we want to import\n-) -> ImportAction {\n-    // We save the number of segments in the buffer so we can restore the correct segments\n-    // before returning. Recursive call will add segments so we need to delete them.\n-    let prev_len = current_path_segments.len();\n-\n-    let tree_list = current_use_tree.use_tree_list();\n-    let alias = current_use_tree.rename();\n-\n-    let path = match current_use_tree.path() {\n-        Some(path) => path,\n-        None => {\n-            // If the use item don't have a path, it means it's broken (syntax error)\n-            return ImportAction::add_new_use(\n-                current_use_tree\n-                    .syntax()\n-                    .ancestors()\n-                    .find_map(ast::Use::cast)\n-                    .map(|it| it.syntax().clone()),\n-                true,\n-            );\n-        }\n-    };\n+    #[test]\n+    fn insert_middle_groups() {\n+        check_none(\n+            \"foo::bar::G\",\n+            r\"use std::bar::A;\n+use std::bar::D;\n+\n+use foo::bar::F;\n+use foo::bar::H;\",\n+            r\"use std::bar::A;\n+use std::bar::D;\n+\n+use foo::bar::F;\n+use foo::bar::G;\n+use foo::bar::H;\",\n+        )\n+    }\n \n-    // This can happen only if current_use_tree is a direct child of a UseItem\n-    if let Some(name) = alias.and_then(|it| it.name()) {\n-        if compare_path_segment_with_name(&target[0], &name) {\n-            return ImportAction::Nothing;\n-        }\n+    #[test]\n+    fn insert_first_matching_group() {\n+        check_none(\n+            \"foo::bar::G\",\n+            r\"use foo::bar::A;\n+use foo::bar::D;\n+\n+use std;\n+\n+use foo::bar::F;\n+use foo::bar::H;\",\n+            r\"use foo::bar::A;\n+use foo::bar::D;\n+use foo::bar::G;\n+\n+use std;\n+\n+use foo::bar::F;\n+use foo::bar::H;\",\n+        )\n     }\n \n-    collect_path_segments_raw(current_path_segments, path.clone());\n-\n-    // We compare only the new segments added in the line just above.\n-    // The first prev_len segments were already compared in 'parent' recursive calls.\n-    let left = target.split_at(prev_len).1;\n-    let right = current_path_segments.split_at(prev_len).1;\n-    let common = compare_path_segments(left, &right);\n-    let mut action = match common {\n-        0 => ImportAction::add_new_use(\n-            // e.g: target is std::fmt and we can have\n-            // use foo::bar\n-            // We add a brand new use statement\n-            current_use_tree\n-                .syntax()\n-                .ancestors()\n-                .find_map(ast::Use::cast)\n-                .map(|it| it.syntax().clone()),\n-            true,\n-        ),\n-        common if common == left.len() && left.len() == right.len() => {\n-            // e.g: target is std::fmt and we can have\n-            // 1- use std::fmt;\n-            // 2- use std::fmt::{ ... }\n-            if let Some(list) = tree_list {\n-                // In case 2 we need to add self to the nested list\n-                // unless it's already there\n-                let has_self = list.use_trees().map(|it| it.path()).any(|p| {\n-                    p.and_then(|it| it.segment())\n-                        .and_then(|it| it.kind())\n-                        .filter(|k| *k == ast::PathSegmentKind::SelfKw)\n-                        .is_some()\n-                });\n-\n-                if has_self {\n-                    ImportAction::Nothing\n-                } else {\n-                    ImportAction::add_in_tree_list(current_path_segments.len(), list, true)\n-                }\n-            } else {\n-                // Case 1\n-                ImportAction::Nothing\n-            }\n-        }\n-        common if common != left.len() && left.len() == right.len() => {\n-            // e.g: target is std::fmt and we have\n-            // use std::io;\n-            // We need to split.\n-            let segments_to_split = current_path_segments.split_at(prev_len + common).1;\n-            ImportAction::add_nested_import(\n-                prev_len + common,\n-                path,\n-                Some(segments_to_split[0].clone()),\n-                false,\n-            )\n-        }\n-        common if common == right.len() && left.len() > right.len() => {\n-            // e.g: target is std::fmt and we can have\n-            // 1- use std;\n-            // 2- use std::{ ... };\n-\n-            // fallback action\n-            let mut better_action = ImportAction::add_new_use(\n-                current_use_tree\n-                    .syntax()\n-                    .ancestors()\n-                    .find_map(ast::Use::cast)\n-                    .map(|it| it.syntax().clone()),\n-                true,\n-            );\n-            if let Some(list) = tree_list {\n-                // Case 2, check recursively if the path is already imported in the nested list\n-                for u in list.use_trees() {\n-                    let child_action = walk_use_tree_for_best_action(\n-                        current_path_segments,\n-                        Some(list.clone()),\n-                        u,\n-                        target,\n-                    );\n-                    if child_action.is_better(&better_action) {\n-                        better_action = child_action;\n-                        if let ImportAction::Nothing = better_action {\n-                            return better_action;\n-                        }\n-                    }\n-                }\n-            } else {\n-                // Case 1, split adding self\n-                better_action = ImportAction::add_nested_import(prev_len + common, path, None, true)\n-            }\n-            better_action\n-        }\n-        common if common == left.len() && left.len() < right.len() => {\n-            // e.g: target is std::fmt and we can have\n-            // use std::fmt::Debug;\n-            let segments_to_split = current_path_segments.split_at(prev_len + common).1;\n-            ImportAction::add_nested_import(\n-                prev_len + common,\n-                path,\n-                Some(segments_to_split[0].clone()),\n-                true,\n-            )\n-        }\n-        common if common < left.len() && common < right.len() => {\n-            // e.g: target is std::fmt::nested::Debug\n-            // use std::fmt::Display\n-            let segments_to_split = current_path_segments.split_at(prev_len + common).1;\n-            ImportAction::add_nested_import(\n-                prev_len + common,\n-                path,\n-                Some(segments_to_split[0].clone()),\n-                false,\n-            )\n-        }\n-        _ => unreachable!(),\n-    };\n+    #[test]\n+    fn insert_missing_group() {\n+        check_none(\n+            \"std::fmt\",\n+            r\"use foo::bar::A;\n+use foo::bar::D;\",\n+            r\"use std::fmt;\n+\n+use foo::bar::A;\n+use foo::bar::D;\",\n+        )\n+    }\n \n-    // If we are inside a UseTreeList adding a use statement become adding to the existing\n-    // tree list.\n-    action = match (current_parent_use_tree_list, action.clone()) {\n-        (Some(use_tree_list), ImportAction::AddNewUse { .. }) => {\n-            ImportAction::add_in_tree_list(prev_len, use_tree_list, false)\n-        }\n-        (_, _) => action,\n-    };\n+    #[test]\n+    fn insert_no_imports() {\n+        check_full(\n+            \"foo::bar\",\n+            \"fn main() {}\",\n+            r\"use foo::bar;\n \n-    // We remove the segments added\n-    current_path_segments.truncate(prev_len);\n-    action\n-}\n+fn main() {}\",\n+        )\n+    }\n \n-fn best_action_for_target(\n-    container: SyntaxNode,\n-    anchor: SyntaxNode,\n-    target: &[SmolStr],\n-) -> ImportAction {\n-    let mut storage = Vec::with_capacity(16); // this should be the only allocation\n-    let best_action = container\n-        .children()\n-        .filter_map(ast::Use::cast)\n-        .filter(|u| u.visibility().is_none())\n-        .filter_map(|it| it.use_tree())\n-        .map(|u| walk_use_tree_for_best_action(&mut storage, None, u, target))\n-        .fold(None, |best, a| match best {\n-            Some(best) => Some(ImportAction::better(best, a)),\n-            None => Some(a),\n-        });\n+    #[test]\n+    fn insert_empty_file() {\n+        // empty files will get two trailing newlines\n+        // this is due to the test case insert_no_imports above\n+        check_full(\n+            \"foo::bar\",\n+            \"\",\n+            r\"use foo::bar;\n+\n+\",\n+        )\n+    }\n \n-    match best_action {\n-        Some(action) => action,\n-        None => {\n-            // We have no action and no UseItem was found in container so we find\n-            // another item and we use it as anchor.\n-            // If there are no items above, we choose the target path itself as anchor.\n-            // todo: we should include even whitespace blocks as anchor candidates\n-            let anchor = container.children().next().or_else(|| Some(anchor));\n+    #[test]\n+    fn adds_std_group() {\n+        check_full(\n+            \"std::fmt::Debug\",\n+            r\"use stdx;\",\n+            r\"use std::fmt::Debug;\n \n-            let add_after_anchor = anchor\n-                .clone()\n-                .and_then(ast::Attr::cast)\n-                .map(|attr| attr.kind() == ast::AttrKind::Inner)\n-                .unwrap_or(false);\n-            ImportAction::add_new_use(anchor, add_after_anchor)\n-        }\n+use stdx;\",\n+        )\n     }\n-}\n \n-fn make_assist(action: &ImportAction, target: &[SmolStr], edit: &mut TextEditBuilder) {\n-    match action {\n-        ImportAction::AddNewUse { anchor, add_after_anchor } => {\n-            make_assist_add_new_use(anchor, *add_after_anchor, target, edit)\n-        }\n-        ImportAction::AddInTreeList { common_segments, tree_list, add_self } => {\n-            // We know that the fist n segments already exists in the use statement we want\n-            // to modify, so we want to add only the last target.len() - n segments.\n-            let segments_to_add = target.split_at(*common_segments).1;\n-            make_assist_add_in_tree_list(tree_list, segments_to_add, *add_self, edit)\n-        }\n-        ImportAction::AddNestedImport {\n-            common_segments,\n-            path_to_split,\n-            first_segment_to_split,\n-            add_self,\n-        } => {\n-            let segments_to_add = target.split_at(*common_segments).1;\n-            make_assist_add_nested_import(\n-                path_to_split,\n-                first_segment_to_split,\n-                segments_to_add,\n-                *add_self,\n-                edit,\n-            )\n-        }\n-        _ => {}\n+    #[test]\n+    fn merges_groups() {\n+        check_last(\"std::io\", r\"use std::fmt;\", r\"use std::{fmt, io};\")\n     }\n-}\n \n-fn make_assist_add_new_use(\n-    anchor: &Option<SyntaxNode>,\n-    after: bool,\n-    target: &[SmolStr],\n-    edit: &mut TextEditBuilder,\n-) {\n-    if let Some(anchor) = anchor {\n-        let indent = leading_indent(anchor);\n-        let mut buf = String::new();\n-        if after {\n-            buf.push_str(\"\\n\");\n-            if let Some(spaces) = &indent {\n-                buf.push_str(spaces);\n-            }\n-        }\n-        buf.push_str(\"use \");\n-        fmt_segments_raw(target, &mut buf);\n-        buf.push_str(\";\");\n-        if !after {\n-            buf.push_str(\"\\n\\n\");\n-            if let Some(spaces) = &indent {\n-                buf.push_str(&spaces);\n-            }\n-        }\n-        let position = if after { anchor.text_range().end() } else { anchor.text_range().start() };\n-        edit.insert(position, buf);\n+    #[test]\n+    fn merges_groups_last() {\n+        check_last(\n+            \"std::io\",\n+            r\"use std::fmt::{Result, Display};\",\n+            r\"use std::fmt::{Result, Display};\n+use std::io;\",\n+        )\n     }\n-}\n \n-fn make_assist_add_in_tree_list(\n-    tree_list: &ast::UseTreeList,\n-    target: &[SmolStr],\n-    add_self: bool,\n-    edit: &mut TextEditBuilder,\n-) {\n-    let last = tree_list.use_trees().last();\n-    if let Some(last) = last {\n-        let mut buf = String::new();\n-        let comma = last.syntax().siblings(Direction::Next).find(|n| n.kind() == T![,]);\n-        let offset = if let Some(comma) = comma {\n-            comma.text_range().end()\n-        } else {\n-            buf.push_str(\",\");\n-            last.syntax().text_range().end()\n-        };\n-        if add_self {\n-            buf.push_str(\" self\")\n-        } else {\n-            buf.push_str(\" \");\n-        }\n-        fmt_segments_raw(target, &mut buf);\n-        edit.insert(offset, buf);\n-    } else {\n+    #[test]\n+    fn merges_groups2() {\n+        check_full(\n+            \"std::io\",\n+            r\"use std::fmt::{Result, Display};\",\n+            r\"use std::{fmt::{Result, Display}, io};\",\n+        )\n     }\n-}\n \n-fn make_assist_add_nested_import(\n-    path: &ast::Path,\n-    first_segment_to_split: &Option<ast::PathSegment>,\n-    target: &[SmolStr],\n-    add_self: bool,\n-    edit: &mut TextEditBuilder,\n-) {\n-    let use_tree = path.syntax().ancestors().find_map(ast::UseTree::cast);\n-    if let Some(use_tree) = use_tree {\n-        let (start, add_colon_colon) = if let Some(first_segment_to_split) = first_segment_to_split\n-        {\n-            (first_segment_to_split.syntax().text_range().start(), false)\n-        } else {\n-            (use_tree.syntax().text_range().end(), true)\n-        };\n-        let end = use_tree.syntax().text_range().end();\n+    #[test]\n+    fn skip_merges_groups_pub() {\n+        check_full(\n+            \"std::io\",\n+            r\"pub use std::fmt::{Result, Display};\",\n+            r\"pub use std::fmt::{Result, Display};\n+use std::io;\",\n+        )\n+    }\n \n-        let mut buf = String::new();\n-        if add_colon_colon {\n-            buf.push_str(\"::\");\n-        }\n-        buf.push_str(\"{\");\n-        if add_self {\n-            buf.push_str(\"self, \");\n-        }\n-        fmt_segments_raw(target, &mut buf);\n-        if !target.is_empty() {\n-            buf.push_str(\", \");\n-        }\n-        edit.insert(start, buf);\n-        edit.insert(end, \"}\".to_string());\n+    #[test]\n+    fn merges_groups_self() {\n+        check_full(\"std::fmt::Debug\", r\"use std::fmt;\", r\"use std::fmt::{self, Debug};\")\n     }\n-}\n \n-/// If the node is on the beginning of the line, calculate indent.\n-fn leading_indent(node: &SyntaxNode) -> Option<SmolStr> {\n-    for token in prev_tokens(node.first_token()?) {\n-        if let Some(ws) = ast::Whitespace::cast(token.clone()) {\n-            let ws_text = ws.text();\n-            if let Some(pos) = ws_text.rfind('\\n') {\n-                return Some(ws_text[pos + 1..].into());\n-            }\n-        }\n-        if token.text().contains('\\n') {\n-            break;\n-        }\n+    fn check(\n+        path: &str,\n+        ra_fixture_before: &str,\n+        ra_fixture_after: &str,\n+        mb: Option<MergeBehaviour>,\n+    ) {\n+        let file = ast::SourceFile::parse(ra_fixture_before).tree().syntax().clone();\n+        let path = ast::SourceFile::parse(&format!(\"use {};\", path))\n+            .tree()\n+            .syntax()\n+            .descendants()\n+            .find_map(ast::Path::cast)\n+            .unwrap();\n+\n+        let result = insert_use(file, path, mb).to_string();\n+        assert_eq_text!(&result, ra_fixture_after);\n+    }\n+\n+    fn check_full(path: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n+        check(path, ra_fixture_before, ra_fixture_after, Some(MergeBehaviour::Full))\n     }\n-    return None;\n-    fn prev_tokens(token: SyntaxToken) -> impl Iterator<Item = SyntaxToken> {\n-        successors(token.prev_token(), |token| token.prev_token())\n+\n+    fn check_last(path: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n+        check(path, ra_fixture_before, ra_fixture_after, Some(MergeBehaviour::Last))\n+    }\n+\n+    fn check_none(path: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n+        check(path, ra_fixture_before, ra_fixture_after, None)\n     }\n }"}]}