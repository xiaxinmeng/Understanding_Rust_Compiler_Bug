{"sha": "177f740311639165fb1464688752c01a039fa577", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3N2Y3NDAzMTE2MzkxNjVmYjE0NjQ2ODg3NTJjMDFhMDM5ZmE1Nzc=", "commit": {"author": {"name": "Niels langager Ellegaard", "email": "niels.ellegaard@gmail.com", "date": "2014-01-05T09:17:51Z"}, "committer": {"name": "Niels langager Ellegaard", "email": "niels.ellegaard@gmail.com", "date": "2014-01-05T10:25:12Z"}, "message": "Command is now an enum", "tree": {"sha": "bb4c6c796bd3570605ac18ef5dd3f7961cde0efb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb4c6c796bd3570605ac18ef5dd3f7961cde0efb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/177f740311639165fb1464688752c01a039fa577", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/177f740311639165fb1464688752c01a039fa577", "html_url": "https://github.com/rust-lang/rust/commit/177f740311639165fb1464688752c01a039fa577", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/177f740311639165fb1464688752c01a039fa577/comments", "author": {"login": "nielsle", "id": 292118, "node_id": "MDQ6VXNlcjI5MjExOA==", "avatar_url": "https://avatars.githubusercontent.com/u/292118?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nielsle", "html_url": "https://github.com/nielsle", "followers_url": "https://api.github.com/users/nielsle/followers", "following_url": "https://api.github.com/users/nielsle/following{/other_user}", "gists_url": "https://api.github.com/users/nielsle/gists{/gist_id}", "starred_url": "https://api.github.com/users/nielsle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nielsle/subscriptions", "organizations_url": "https://api.github.com/users/nielsle/orgs", "repos_url": "https://api.github.com/users/nielsle/repos", "events_url": "https://api.github.com/users/nielsle/events{/privacy}", "received_events_url": "https://api.github.com/users/nielsle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nielsle", "id": 292118, "node_id": "MDQ6VXNlcjI5MjExOA==", "avatar_url": "https://avatars.githubusercontent.com/u/292118?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nielsle", "html_url": "https://github.com/nielsle", "followers_url": "https://api.github.com/users/nielsle/followers", "following_url": "https://api.github.com/users/nielsle/following{/other_user}", "gists_url": "https://api.github.com/users/nielsle/gists{/gist_id}", "starred_url": "https://api.github.com/users/nielsle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nielsle/subscriptions", "organizations_url": "https://api.github.com/users/nielsle/orgs", "repos_url": "https://api.github.com/users/nielsle/repos", "events_url": "https://api.github.com/users/nielsle/events{/privacy}", "received_events_url": "https://api.github.com/users/nielsle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4eceb0050c107c4ed18221bde9e5046613a710b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4eceb0050c107c4ed18221bde9e5046613a710b6", "html_url": "https://github.com/rust-lang/rust/commit/4eceb0050c107c4ed18221bde9e5046613a710b6"}], "stats": {"total": 186, "additions": 98, "deletions": 88}, "files": [{"sha": "3fb6f9caeb82c560a9c4b19fcffebaae48c017ee", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 53, "deletions": 16, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/177f740311639165fb1464688752c01a039fa577/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177f740311639165fb1464688752c01a039fa577/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=177f740311639165fb1464688752c01a039fa577", "patch": "@@ -234,85 +234,122 @@ impl RustcFlags {\n     }\n }\n \n+\n+#[deriving(Eq)]\n+pub enum Command {\n+    BuildCmd,\n+    CleanCmd,\n+    DoCmd,\n+    InfoCmd,\n+    InstallCmd,\n+    ListCmd,\n+    PreferCmd,\n+    TestCmd,\n+    InitCmd,\n+    UninstallCmd,\n+    UnpreferCmd,\n+}\n+\n+impl FromStr for Command {\n+\n+    fn from_str(s: &str) -> Option<Command>  {\n+       match s {\n+            &\"build\" => Some(BuildCmd),\n+            &\"clean\" => Some(CleanCmd),\n+            &\"do\" => Some(DoCmd),\n+            &\"info\" => Some(InfoCmd),\n+            &\"install\" => Some(InstallCmd),\n+            &\"list\"    => Some(ListCmd),\n+            &\"prefer\" => Some(PreferCmd),\n+            &\"test\" => Some(TestCmd),\n+            &\"init\" => Some(InitCmd),\n+            &\"uninstall\" => Some(UninstallCmd),\n+            &\"unprefer\" => Some(UnpreferCmd),\n+            _ => None\n+        }\n+    }\n+}\n+\n /// Returns true if any of the flags given are incompatible with the cmd\n pub fn flags_forbidden_for_cmd(flags: &RustcFlags,\n                         cfgs: &[~str],\n-                        cmd: &str, user_supplied_opt_level: bool) -> bool {\n+                        cmd: Command, user_supplied_opt_level: bool) -> bool {\n     let complain = |s| {\n         println!(\"The {} option can only be used with the `build` command:\n                   rustpkg [options..] build {} [package-ID]\", s, s);\n     };\n \n-    if flags.linker.is_some() && cmd != \"build\" && cmd != \"install\" {\n+    if flags.linker.is_some() && cmd != BuildCmd && cmd != InstallCmd {\n         println(\"The --linker option can only be used with the build or install commands.\");\n         return true;\n     }\n-    if flags.link_args.is_some() && cmd != \"build\" && cmd != \"install\" {\n+    if flags.link_args.is_some() && cmd != BuildCmd && cmd != InstallCmd {\n         println(\"The --link-args option can only be used with the build or install commands.\");\n         return true;\n     }\n \n-    if !cfgs.is_empty() && cmd != \"build\" && cmd != \"install\" && cmd != \"test\" {\n+    if !cfgs.is_empty() && cmd != BuildCmd && cmd != InstallCmd && cmd != TestCmd {\n         println(\"The --cfg option can only be used with the build, test, or install commands.\");\n         return true;\n     }\n \n-    if user_supplied_opt_level && cmd != \"build\" && cmd != \"install\" {\n+    if user_supplied_opt_level && cmd != BuildCmd && cmd != InstallCmd {\n         println(\"The -O and --opt-level options can only be used with the build \\\n                     or install commands.\");\n         return true;\n     }\n \n-    if flags.save_temps  && cmd != \"build\" && cmd != \"install\" {\n+    if flags.save_temps  && cmd != BuildCmd && cmd != InstallCmd {\n         println(\"The --save-temps option can only be used with the build \\\n                     or install commands.\");\n         return true;\n     }\n \n-    if flags.target.is_some()  && cmd != \"build\" && cmd != \"install\" {\n+    if flags.target.is_some()  && cmd != BuildCmd && cmd != InstallCmd {\n         println(\"The --target option can only be used with the build \\\n                     or install commands.\");\n         return true;\n     }\n-    if flags.target_cpu.is_some()  && cmd != \"build\" && cmd != \"install\" {\n+    if flags.target_cpu.is_some()  && cmd != BuildCmd && cmd != InstallCmd {\n         println(\"The --target-cpu option can only be used with the build \\\n                     or install commands.\");\n         return true;\n     }\n-    if flags.experimental_features.is_some() && cmd != \"build\" && cmd != \"install\" {\n+    if flags.experimental_features.is_some() && cmd != BuildCmd && cmd != InstallCmd {\n         println(\"The -Z option can only be used with the build or install commands.\");\n         return true;\n     }\n \n     match flags.compile_upto {\n-        Link if cmd != \"build\" => {\n+        Link if cmd != BuildCmd => {\n             complain(\"--no-link\");\n             true\n         }\n-        Trans if cmd != \"build\" => {\n+        Trans if cmd != BuildCmd => {\n             complain(\"--no-trans\");\n             true\n         }\n-        Assemble if cmd != \"build\" => {\n+        Assemble if cmd != BuildCmd => {\n             complain(\"-S\");\n             true\n         }\n-        Pretty if cmd != \"build\" => {\n+        Pretty if cmd != BuildCmd => {\n             complain(\"--pretty\");\n             true\n         }\n-        Analysis if cmd != \"build\" => {\n+        Analysis if cmd != BuildCmd => {\n             complain(\"--parse-only\");\n             true\n         }\n-        LLVMCompileBitcode if cmd != \"build\" => {\n+        LLVMCompileBitcode if cmd != BuildCmd => {\n             complain(\"--emit-llvm\");\n             true\n         }\n-        LLVMAssemble if cmd != \"build\" => {\n+        LLVMAssemble if cmd != BuildCmd => {\n             complain(\"--emit-llvm\");\n             true\n         }\n         _ => false\n     }\n }\n+"}, {"sha": "43f190f37a23ee836bdfe735e9d370becb08fff2", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 24, "deletions": 42, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/177f740311639165fb1464688752c01a039fa577/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177f740311639165fb1464688752c01a039fa577/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=177f740311639165fb1464688752c01a039fa577", "patch": "@@ -45,6 +45,8 @@ use workspace::determine_destination;\n use context::{Context, BuildContext,\n                        RustcFlags, Trans, Link, Nothing, Pretty, Analysis, Assemble,\n                        LLVMAssemble, LLVMCompileBitcode};\n+use context::{Command, BuildCmd, CleanCmd, DoCmd, InfoCmd, InstallCmd, ListCmd,\n+    PreferCmd, TestCmd, InitCmd, UninstallCmd, UnpreferCmd};\n use crate_id::CrateId;\n use package_source::PkgSrc;\n use target::{WhatToBuild, Everything, is_lib, is_main, is_test, is_bench};\n@@ -205,7 +207,7 @@ impl<'a> PkgScript<'a> {\n }\n \n pub trait CtxMethods {\n-    fn run(&self, cmd: &str, args: ~[~str]);\n+    fn run(&self, cmd: Command, args: ~[~str]);\n     fn do_cmd(&self, _cmd: &str, _pkgname: &str);\n     /// Returns a pair of the selected package ID, and the destination workspace\n     fn build_args(&self, args: ~[~str], what: &WhatToBuild) -> Option<(CrateId, Path)>;\n@@ -281,13 +283,13 @@ impl CtxMethods for BuildContext {\n             Some((crateid, dest_ws))\n         }\n     }\n-    fn run(&self, cmd: &str, args: ~[~str]) {\n+    fn run(&self, cmd: Command, args: ~[~str]) {\n         let cwd = os::getcwd();\n         match cmd {\n-            \"build\" => {\n+            BuildCmd => {\n                 self.build_args(args, &WhatToBuild::new(MaybeCustom, Everything));\n             }\n-            \"clean\" => {\n+            CleanCmd => {\n                 if args.len() < 1 {\n                     match cwd_to_workspace() {\n                         None => { usage::clean(); return }\n@@ -304,17 +306,17 @@ impl CtxMethods for BuildContext {\n                     self.clean(&cwd, &crateid); // tjc: should use workspace, not cwd\n                 }\n             }\n-            \"do\" => {\n+            DoCmd => {\n                 if args.len() < 2 {\n                     return usage::do_cmd();\n                 }\n \n                 self.do_cmd(args[0].clone(), args[1].clone());\n             }\n-            \"info\" => {\n+            InfoCmd => {\n                 self.info();\n             }\n-            \"install\" => {\n+            InstallCmd => {\n                if args.len() < 1 {\n                     match cwd_to_workspace() {\n                         None if dir_has_crate_file(&cwd) => {\n@@ -360,21 +362,21 @@ impl CtxMethods for BuildContext {\n                     }\n                 }\n             }\n-            \"list\" => {\n+            ListCmd => {\n                 println(\"Installed packages:\");\n                 installed_packages::list_installed_packages(|pkg_id| {\n                     pkg_id.path.display().with_str(|s| println(s));\n                     true\n                 });\n             }\n-            \"prefer\" => {\n+            PreferCmd => {\n                 if args.len() < 1 {\n                     return usage::uninstall();\n                 }\n \n                 self.prefer(args[0], None);\n             }\n-            \"test\" => {\n+            TestCmd => {\n                 // Build the test executable\n                 let maybe_id_and_workspace = self.build_args(args,\n                                                              &WhatToBuild::new(MaybeCustom, Tests));\n@@ -388,14 +390,14 @@ impl CtxMethods for BuildContext {\n                     }\n                 }\n             }\n-            \"init\" => {\n+            InitCmd => {\n                 if args.len() != 0 {\n                     return usage::init();\n                 } else {\n                     self.init();\n                 }\n             }\n-            \"uninstall\" => {\n+            UninstallCmd => {\n                 if args.len() < 1 {\n                     return usage::uninstall();\n                 }\n@@ -417,14 +419,13 @@ impl CtxMethods for BuildContext {\n                     });\n                 }\n             }\n-            \"unprefer\" => {\n+            UnpreferCmd => {\n                 if args.len() < 1 {\n                     return usage::unprefer();\n                 }\n \n                 self.unprefer(args[0], None);\n             }\n-            _ => fail!(\"I don't know the command `{}`\", cmd)\n         }\n     }\n \n@@ -864,38 +865,19 @@ pub fn main_args(args: &[~str]) -> int {\n         experimental_features: experimental_features\n     };\n \n-    let mut cmd_opt = None;\n-    for a in args.iter() {\n-        if util::is_cmd(*a) {\n-            cmd_opt = Some(a);\n-            break;\n-        }\n-    }\n-    let cmd = match cmd_opt {\n+    let cmd_opt = args.iter().filter_map( |s| from_str(s.clone())).next();\n+    let command = match(cmd_opt) {\n         None => {\n             usage::general();\n             return 0;\n         }\n         Some(cmd) => {\n             let bad_option = context::flags_forbidden_for_cmd(&rustc_flags,\n                                                               cfgs,\n-                                                              *cmd,\n+                                                              cmd,\n                                                               user_supplied_opt_level);\n             if help || bad_option {\n-                match *cmd {\n-                    ~\"build\" => usage::build(),\n-                    ~\"clean\" => usage::clean(),\n-                    ~\"do\" => usage::do_cmd(),\n-                    ~\"info\" => usage::info(),\n-                    ~\"install\" => usage::install(),\n-                    ~\"list\"    => usage::list(),\n-                    ~\"prefer\" => usage::prefer(),\n-                    ~\"test\" => usage::test(),\n-                    ~\"init\" => usage::init(),\n-                    ~\"uninstall\" => usage::uninstall(),\n-                    ~\"unprefer\" => usage::unprefer(),\n-                    _ => usage::general()\n-                };\n+                usage::usage_for_command(cmd);\n                 if bad_option {\n                     return BAD_FLAG_CODE;\n                 }\n@@ -909,9 +891,10 @@ pub fn main_args(args: &[~str]) -> int {\n     };\n \n     // Pop off all flags, plus the command\n-    let remaining_args = args.iter().skip_while(|s| !util::is_cmd(**s));\n-    // I had to add this type annotation to get the code to typecheck\n-    let mut remaining_args: ~[~str] = remaining_args.map(|s| (*s).clone()).collect();\n+    let mut remaining_args: ~[~str] = args.iter().skip_while(|&s| {\n+        let maybe_command: Option<Command> = from_str(*s);\n+        maybe_command.is_none()\n+    }).map(|s| s.clone()).collect();\n     remaining_args.shift();\n     let sroot = match supplied_sysroot {\n         Some(s) => Path::new(s),\n@@ -923,7 +906,6 @@ pub fn main_args(args: &[~str]) -> int {\n     debug!(\"Will store workcache in {}\", ws.display());\n \n     let rm_args = remaining_args.clone();\n-    let sub_cmd = cmd.clone();\n     // Wrap the rest in task::try in case of a condition failure in a task\n     let result = do task::try {\n         BuildContext {\n@@ -935,7 +917,7 @@ pub fn main_args(args: &[~str]) -> int {\n             },\n             workcache_context: api::default_context(sroot.clone(),\n                                                     default_workspace()).workcache_context\n-        }.run(sub_cmd, rm_args.clone())\n+        }.run(command, rm_args.clone())\n     };\n     // FIXME #9262: This is using the same error code for all errors,\n     // and at least one test case succeeds if rustpkg returns COPY_FAILED_CODE,"}, {"sha": "a41e99f6d663d461099883a7202e3ca4ef62fb25", "filename": "src/librustpkg/usage.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/177f740311639165fb1464688752c01a039fa577/src%2Flibrustpkg%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177f740311639165fb1464688752c01a039fa577/src%2Flibrustpkg%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fusage.rs?ref=177f740311639165fb1464688752c01a039fa577", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use context::Command;\n+\n pub fn general() {\n     println(\"Usage: rustpkg [options] <cmd> [args..]\n \n@@ -154,3 +156,22 @@ This will turn the current working directory into a workspace. The first\n command you run when starting off a new project.\n \");\n }\n+\n+pub fn usage_for_command(command: Command){\n+    match command {\n+        BuildCmd => build(),\n+        CleanCmd => clean(),\n+        DoCmd => do_cmd(),\n+        InfoCmd => info(),\n+        InstallCmd => install(),\n+        ListCmd => list(),\n+        PreferCmd => prefer(),\n+        TestCmd => test(),\n+        InitCmd => init(),\n+        UninstallCmd => uninstall(),\n+        UnpreferCmd => unprefer(),\n+    };\n+}\n+\n+\n+"}, {"sha": "5f5c34dc04b82222a46b7e0f91ebcb622874e538", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/177f740311639165fb1464688752c01a039fa577/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177f740311639165fb1464688752c01a039fa577/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=177f740311639165fb1464688752c01a039fa577", "patch": "@@ -41,13 +41,6 @@ pub use target::{lib_name_of, lib_crate_filename, WhatToBuild, MaybeCustom, Infe\n use workcache_support::{digest_file_with_date, digest_only_date};\n use messages::error;\n \n-// It would be nice to have the list of commands in just one place -- for example,\n-// you could update the match in rustpkg.rc but forget to update this list. I think\n-// that should be fixed.\n-static COMMANDS: &'static [&'static str] =\n-    &[\"build\", \"clean\", \"do\", \"info\", \"init\", \"install\", \"list\", \"prefer\", \"test\", \"uninstall\",\n-      \"unprefer\"];\n-\n \n pub type ExitCode = int; // For now\n \n@@ -63,10 +56,6 @@ impl ToStr for Pkg {\n     }\n }\n \n-pub fn is_cmd(cmd: &str) -> bool {\n-    COMMANDS.iter().any(|&c| c == cmd)\n-}\n-\n struct ListenerFn {\n     cmds: ~[~str],\n     span: codemap::Span,\n@@ -634,25 +623,6 @@ pub fn mk_string_lit(s: @str) -> ast::lit {\n     }\n }\n \n-#[cfg(test)]\n-mod test {\n-    use super::is_cmd;\n-\n-    #[test]\n-    fn test_is_cmd() {\n-        assert!(is_cmd(\"build\"));\n-        assert!(is_cmd(\"clean\"));\n-        assert!(is_cmd(\"do\"));\n-        assert!(is_cmd(\"info\"));\n-        assert!(is_cmd(\"install\"));\n-        assert!(is_cmd(\"prefer\"));\n-        assert!(is_cmd(\"test\"));\n-        assert!(is_cmd(\"uninstall\"));\n-        assert!(is_cmd(\"unprefer\"));\n-    }\n-\n-}\n-\n pub fn option_to_vec<T>(x: Option<T>) -> ~[T] {\n     match x {\n        Some(y) => ~[y],"}]}