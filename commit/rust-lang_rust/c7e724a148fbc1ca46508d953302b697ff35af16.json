{"sha": "c7e724a148fbc1ca46508d953302b697ff35af16", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3ZTcyNGExNDhmYmMxY2E0NjUwOGQ5NTMzMDJiNjk3ZmYzNWFmMTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-25T10:34:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-25T10:34:07Z"}, "message": "Auto merge of #40434 - mattico:splice-update, r=alexcrichton\n\nImplement Vec::splice and String::splice (RFC 1432)\n\nRFC: rust-lang/rfcs#1432, tracking issue: #32310\nA rebase of https://github.com/rust-lang/rust/pull/32355 with a few more tests.\n\nLet me know if you have any ideas for more tests.\n\ncc @SimonSapin", "tree": {"sha": "b13c7dd690a21bcb41a21738e52944e82fce2739", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b13c7dd690a21bcb41a21738e52944e82fce2739"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7e724a148fbc1ca46508d953302b697ff35af16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7e724a148fbc1ca46508d953302b697ff35af16", "html_url": "https://github.com/rust-lang/rust/commit/c7e724a148fbc1ca46508d953302b697ff35af16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7e724a148fbc1ca46508d953302b697ff35af16/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0777c757a6832dc5f8f218377f99960f5477311f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0777c757a6832dc5f8f218377f99960f5477311f", "html_url": "https://github.com/rust-lang/rust/commit/0777c757a6832dc5f8f218377f99960f5477311f"}, {"sha": "feae5a08a2d5d8db14a4b99a050dbc14a6bffb2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/feae5a08a2d5d8db14a4b99a050dbc14a6bffb2a", "html_url": "https://github.com/rust-lang/rust/commit/feae5a08a2d5d8db14a4b99a050dbc14a6bffb2a"}], "stats": {"total": 457, "additions": 449, "deletions": 8}, "files": [{"sha": "1adc59b84eac0ad32d7aeb35168e17f0a8193334", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7e724a148fbc1ca46508d953302b697ff35af16/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/c7e724a148fbc1ca46508d953302b697ff35af16/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=c7e724a148fbc1ca46508d953302b697ff35af16", "patch": "@@ -195,6 +195,7 @@\n     - [slice_rsplit](library-features/slice-rsplit.md)\n     - [sort_internals](library-features/sort-internals.md)\n     - [sort_unstable](library-features/sort-unstable.md)\n+    - [splice](library-features/splice.md)\n     - [step_by](library-features/step-by.md)\n     - [step_trait](library-features/step-trait.md)\n     - [str_checked_slicing](library-features/str-checked-slicing.md)"}, {"sha": "ca7f78a8f79e523c3048aeefec9aaebfa82421fe", "filename": "src/doc/unstable-book/src/library-features/splice.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c7e724a148fbc1ca46508d953302b697ff35af16/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md", "raw_url": "https://github.com/rust-lang/rust/raw/c7e724a148fbc1ca46508d953302b697ff35af16/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md?ref=c7e724a148fbc1ca46508d953302b697ff35af16", "patch": "@@ -0,0 +1,24 @@\n+# `splice`\n+\n+The tracking issue for this feature is: [#32310]\n+\n+[#32310]: https://github.com/rust-lang/rust/issues/32310\n+\n+------------------------\n+\n+The `splice()` method on `Vec` and `String` allows you to replace a range\n+of values in a vector or string with another range of values, and returns\n+the replaced values.\n+\n+A simple example:\n+\n+```rust\n+#![feature(splice)]\n+let mut s = String::from(\"\u03b1 is alpha, \u03b2 is beta\");\n+let beta_offset = s.find('\u03b2').unwrap_or(s.len());\n+\n+// Replace the range up until the \u03b2 from the string\n+let t: String = s.splice(..beta_offset, \"\u0391 is capital alpha; \").collect();\n+assert_eq!(t, \"\u03b1 is alpha, \");\n+assert_eq!(s, \"\u0391 is capital alpha; \u03b2 is beta\");\n+```\n\\ No newline at end of file"}, {"sha": "2eef132374e58b8a9f92c8edb37e5c101713da37", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7e724a148fbc1ca46508d953302b697ff35af16/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e724a148fbc1ca46508d953302b697ff35af16/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=c7e724a148fbc1ca46508d953302b697ff35af16", "patch": "@@ -1519,13 +1519,9 @@ impl<T: Clone> ToOwned for [T] {\n         self.to_vec()\n     }\n \n-    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec`, which is required for this method\n-    // definition, is not available. Since we don't require this method for testing purposes, I'll\n-    // just stub it\n-    // NB see the slice::hack module in slice.rs for more information\n     #[cfg(test)]\n     fn to_owned(&self) -> Vec<T> {\n-        panic!(\"not available with cfg(test)\")\n+        hack::to_vec(self)\n     }\n \n     fn clone_into(&self, target: &mut Vec<T>) {"}, {"sha": "0a82fda09cb84dc935d38cb02715b7793aee7c74", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 124, "deletions": 1, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/c7e724a148fbc1ca46508d953302b697ff35af16/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e724a148fbc1ca46508d953302b697ff35af16/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=c7e724a148fbc1ca46508d953302b697ff35af16", "patch": "@@ -1316,7 +1316,7 @@ impl String {\n         self.vec.clear()\n     }\n \n-    /// Create a draining iterator that removes the specified range in the string\n+    /// Creates a draining iterator that removes the specified range in the string\n     /// and yields the removed chars.\n     ///\n     /// Note: The element range is removed even if the iterator is not\n@@ -1382,6 +1382,71 @@ impl String {\n         }\n     }\n \n+    /// Creates a splicing iterator that removes the specified range in the string,\n+    /// replaces with the given string, and yields the removed chars.\n+    /// The given string doesn\u2019t need to be the same length as the range.\n+    ///\n+    /// Note: The element range is removed when the `Splice` is dropped,\n+    /// even if the iterator is not consumed until the end.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the starting point or end point do not lie on a [`char`]\n+    /// boundary, or if they're out of bounds.\n+    ///\n+    /// [`char`]: ../../std/primitive.char.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(splice)]\n+    /// let mut s = String::from(\"\u03b1 is alpha, \u03b2 is beta\");\n+    /// let beta_offset = s.find('\u03b2').unwrap_or(s.len());\n+    ///\n+    /// // Replace the range up until the \u03b2 from the string\n+    /// let t: String = s.splice(..beta_offset, \"\u0391 is capital alpha; \").collect();\n+    /// assert_eq!(t, \"\u03b1 is alpha, \");\n+    /// assert_eq!(s, \"\u0391 is capital alpha; \u03b2 is beta\");\n+    /// ```\n+    #[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+    pub fn splice<'a, 'b, R>(&'a mut self, range: R, replace_with: &'b str) -> Splice<'a, 'b>\n+        where R: RangeArgument<usize>\n+    {\n+        // Memory safety\n+        //\n+        // The String version of Splice does not have the memory safety issues\n+        // of the vector version. The data is just plain bytes.\n+        // Because the range removal happens in Drop, if the Splice iterator is leaked,\n+        // the removal will not happen.\n+        let len = self.len();\n+        let start = match range.start() {\n+             Included(&n) => n,\n+             Excluded(&n) => n + 1,\n+             Unbounded => 0,\n+        };\n+        let end = match range.end() {\n+             Included(&n) => n + 1,\n+             Excluded(&n) => n,\n+             Unbounded => len,\n+        };\n+\n+        // Take out two simultaneous borrows. The &mut String won't be accessed\n+        // until iteration is over, in Drop.\n+        let self_ptr = self as *mut _;\n+        // slicing does the appropriate bounds checks\n+        let chars_iter = self[start..end].chars();\n+\n+        Splice {\n+            start: start,\n+            end: end,\n+            iter: chars_iter,\n+            string: self_ptr,\n+            replace_with: replace_with\n+        }\n+    }\n+\n     /// Converts this `String` into a `Box<str>`.\n     ///\n     /// This will drop any excess capacity.\n@@ -2145,3 +2210,61 @@ impl<'a> DoubleEndedIterator for Drain<'a> {\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a> FusedIterator for Drain<'a> {}\n+\n+/// A splicing iterator for `String`.\n+///\n+/// This struct is created by the [`splice()`] method on [`String`]. See its\n+/// documentation for more.\n+///\n+/// [`splice()`]: struct.String.html#method.splice\n+/// [`String`]: struct.String.html\n+#[derive(Debug)]\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+pub struct Splice<'a, 'b> {\n+    /// Will be used as &'a mut String in the destructor\n+    string: *mut String,\n+    /// Start of part to remove\n+    start: usize,\n+    /// End of part to remove\n+    end: usize,\n+    /// Current remaining range to remove\n+    iter: Chars<'a>,\n+    replace_with: &'b str,\n+}\n+\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+unsafe impl<'a, 'b> Sync for Splice<'a, 'b> {}\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+unsafe impl<'a, 'b> Send for Splice<'a, 'b> {}\n+\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+impl<'a, 'b> Drop for Splice<'a, 'b> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            let vec = (*self.string).as_mut_vec();\n+            vec.splice(self.start..self.end, self.replace_with.bytes());\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+impl<'a, 'b> Iterator for Splice<'a, 'b> {\n+    type Item = char;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<char> {\n+        self.iter.next()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+impl<'a, 'b> DoubleEndedIterator for Splice<'a, 'b> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<char> {\n+        self.iter.next_back()\n+    }\n+}"}, {"sha": "eae3bf3915f60d1f40f30ab3203aafcc1363d4cf", "filename": "src/libcollections/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7e724a148fbc1ca46508d953302b697ff35af16/src%2Flibcollections%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e724a148fbc1ca46508d953302b697ff35af16/src%2Flibcollections%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Flib.rs?ref=c7e724a148fbc1ca46508d953302b697ff35af16", "patch": "@@ -20,6 +20,7 @@\n #![feature(pattern)]\n #![feature(placement_in_syntax)]\n #![feature(rand)]\n+#![feature(splice)]\n #![feature(step_by)]\n #![feature(str_escape)]\n #![feature(test)]"}, {"sha": "b1731b2a5dcaa486b8e189e97b88dbdf23b9e85f", "filename": "src/libcollections/tests/string.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c7e724a148fbc1ca46508d953302b697ff35af16/src%2Flibcollections%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e724a148fbc1ca46508d953302b697ff35af16/src%2Flibcollections%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fstring.rs?ref=c7e724a148fbc1ca46508d953302b697ff35af16", "patch": "@@ -419,6 +419,69 @@ fn test_drain() {\n     assert_eq!(t, \"\");\n }\n \n+#[test]\n+fn test_splice() {\n+    let mut s = \"Hello, world!\".to_owned();\n+    let t: String = s.splice(7..12, \"\u4e16\u754c\").collect();\n+    assert_eq!(s, \"Hello, \u4e16\u754c!\");\n+    assert_eq!(t, \"world\");\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_splice_char_boundary() {\n+    let mut s = \"Hello, \u4e16\u754c!\".to_owned();\n+    s.splice(..8, \"\");\n+}\n+\n+#[test]\n+fn test_splice_inclusive_range() {\n+    let mut v = String::from(\"12345\");\n+    let t: String = v.splice(2...3, \"789\").collect();\n+    assert_eq!(v, \"127895\");\n+    assert_eq!(t, \"34\");\n+    let t2: String = v.splice(1...2, \"A\").collect();\n+    assert_eq!(v, \"1A895\");\n+    assert_eq!(t2, \"27\");\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_splice_out_of_bounds() {\n+    let mut s = String::from(\"12345\");\n+    s.splice(5..6, \"789\");\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_splice_inclusive_out_of_bounds() {\n+    let mut s = String::from(\"12345\");\n+    s.splice(5...5, \"789\");\n+}\n+\n+#[test]\n+fn test_splice_empty() {\n+    let mut s = String::from(\"12345\");\n+    let t: String = s.splice(1..2, \"\").collect();\n+    assert_eq!(s, \"1345\");\n+    assert_eq!(t, \"2\");\n+}\n+\n+#[test]\n+fn test_splice_unbounded() {\n+    let mut s = String::from(\"12345\");\n+    let t: String = s.splice(.., \"\").collect();\n+    assert_eq!(s, \"\");\n+    assert_eq!(t, \"12345\");\n+}\n+\n+#[test]\n+fn test_splice_forget() {\n+    let mut s = String::from(\"12345\");\n+    ::std::mem::forget(s.splice(2..4, \"789\"));\n+    assert_eq!(s, \"12345\");\n+}\n+\n #[test]\n fn test_extend_ref() {\n     let mut a = \"foo\".to_string();"}, {"sha": "29f18274962fe04e6c3a517370c401d610f711ca", "filename": "src/libcollections/tests/vec.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c7e724a148fbc1ca46508d953302b697ff35af16/src%2Flibcollections%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e724a148fbc1ca46508d953302b697ff35af16/src%2Flibcollections%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fvec.rs?ref=c7e724a148fbc1ca46508d953302b697ff35af16", "patch": "@@ -579,6 +579,69 @@ fn test_drain_inclusive_out_of_bounds() {\n     v.drain(5...5);\n }\n \n+#[test]\n+fn test_splice() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let a = [10, 11, 12];\n+    v.splice(2..4, a.iter().cloned());\n+    assert_eq!(v, &[1, 2, 10, 11, 12, 5]);\n+    v.splice(1..3, Some(20));\n+    assert_eq!(v, &[1, 20, 11, 12, 5]);\n+}\n+\n+#[test]\n+fn test_splice_inclusive_range() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let a = [10, 11, 12];\n+    let t1: Vec<_> = v.splice(2...3, a.iter().cloned()).collect();\n+    assert_eq!(v, &[1, 2, 10, 11, 12, 5]);\n+    assert_eq!(t1, &[3, 4]);\n+    let t2: Vec<_> = v.splice(1...2, Some(20)).collect();\n+    assert_eq!(v, &[1, 20, 11, 12, 5]);\n+    assert_eq!(t2, &[2, 10]);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_splice_out_of_bounds() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let a = [10, 11, 12];\n+    v.splice(5..6, a.iter().cloned());\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_splice_inclusive_out_of_bounds() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let a = [10, 11, 12];\n+    v.splice(5...5, a.iter().cloned());\n+}\n+\n+#[test]\n+fn test_splice_items_zero_sized() {\n+    let mut vec = vec![(), (), ()];\n+    let vec2 = vec![];\n+    let t: Vec<_> = vec.splice(1..2, vec2.iter().cloned()).collect();\n+    assert_eq!(vec, &[(), ()]);\n+    assert_eq!(t, &[()]);\n+}\n+\n+#[test]\n+fn test_splice_unbounded() {\n+    let mut vec = vec![1, 2, 3, 4, 5];\n+    let t: Vec<_> = vec.splice(.., None).collect();\n+    assert_eq!(vec, &[]);\n+    assert_eq!(t, &[1, 2, 3, 4, 5]);\n+}\n+\n+#[test]\n+fn test_splice_forget() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let a = [10, 11, 12];\n+    ::std::mem::forget(v.splice(2..4, a.iter().cloned()));\n+    assert_eq!(v, &[1, 2]);\n+}\n+\n #[test]\n fn test_into_boxed_slice() {\n     let xs = vec![1, 2, 3];"}, {"sha": "e5964385b1253d68cb51b6e5ba19ac13988576a6", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 172, "deletions": 2, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/c7e724a148fbc1ca46508d953302b697ff35af16/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e724a148fbc1ca46508d953302b697ff35af16/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=c7e724a148fbc1ca46508d953302b697ff35af16", "patch": "@@ -1057,13 +1057,13 @@ impl<T> Vec<T> {\n         self.len += count;\n     }\n \n-    /// Create a draining iterator that removes the specified range in the vector\n+    /// Creates a draining iterator that removes the specified range in the vector\n     /// and yields the removed items.\n     ///\n     /// Note 1: The element range is removed even if the iterator is only\n     /// partially consumed or not consumed at all.\n     ///\n-    /// Note 2: It is unspecified how many elements are removed from the vector,\n+    /// Note 2: It is unspecified how many elements are removed from the vector\n     /// if the `Drain` value is leaked.\n     ///\n     /// # Panics\n@@ -1845,6 +1845,54 @@ impl<T> Vec<T> {\n             }\n         }\n     }\n+\n+    /// Creates a splicing iterator that replaces the specified range in the vector\n+    /// with the given `replace_with` iterator and yields the removed items.\n+    /// `replace_with` does not need to be the same length as `range`.\n+    ///\n+    /// Note 1: The element range is removed even if the iterator is not\n+    /// consumed until the end.\n+    ///\n+    /// Note 2: It is unspecified how many elements are removed from the vector,\n+    /// if the `Splice` value is leaked.\n+    ///\n+    /// Note 3: The input iterator `replace_with` is only consumed\n+    /// when the `Splice` value is dropped.\n+    ///\n+    /// Note 4: This is optimal if:\n+    ///\n+    /// * The tail (elements in the vector after `range`) is empty,\n+    /// * or `replace_with` yields fewer elements than `range`\u2019s length\n+    /// * or the lower bound of its `size_hint()` is exact.\n+    ///\n+    /// Otherwise, a temporary vector is allocated and the tail is moved twice.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the starting point is greater than the end point or if\n+    /// the end point is greater than the length of the vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(splice)]\n+    /// let mut v = vec![1, 2, 3];\n+    /// let new = [7, 8];\n+    /// let u: Vec<_> = v.splice(..2, new.iter().cloned()).collect();\n+    /// assert_eq!(v, &[7, 8, 3]);\n+    /// assert_eq!(u, &[1, 2]);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+    pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<I::IntoIter>\n+        where R: RangeArgument<usize>, I: IntoIterator<Item=T>\n+    {\n+        Splice {\n+            drain: self.drain(range),\n+            replace_with: replace_with.into_iter(),\n+        }\n+    }\n+\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n@@ -2344,3 +2392,125 @@ impl<'a, T> InPlace<T> for PlaceBack<'a, T> {\n         &mut *ptr\n     }\n }\n+\n+\n+/// A splicing iterator for `Vec`.\n+///\n+/// This struct is created by the [`splice()`] method on [`Vec`]. See its\n+/// documentation for more.\n+///\n+/// [`splice()`]: struct.Vec.html#method.splice\n+/// [`Vec`]: struct.Vec.html\n+#[derive(Debug)]\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+pub struct Splice<'a, I: Iterator + 'a> {\n+    drain: Drain<'a, I::Item>,\n+    replace_with: I,\n+}\n+\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+impl<'a, I: Iterator> Iterator for Splice<'a, I> {\n+    type Item = I::Item;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.drain.next()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.drain.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+impl<'a, I: Iterator> DoubleEndedIterator for Splice<'a, I> {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.drain.next_back()\n+    }\n+}\n+\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+impl<'a, I: Iterator> ExactSizeIterator for Splice<'a, I> {}\n+\n+\n+#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+impl<'a, I: Iterator> Drop for Splice<'a, I> {\n+    fn drop(&mut self) {\n+        // exhaust drain first\n+        while let Some(_) = self.drain.next() {}\n+\n+\n+        unsafe {\n+            if self.drain.tail_len == 0 {\n+                let vec = &mut *self.drain.vec.as_mut_ptr();\n+                vec.extend(self.replace_with.by_ref());\n+                return\n+            }\n+\n+            // First fill the range left by drain().\n+            if !self.drain.fill(&mut self.replace_with) {\n+                return\n+            }\n+\n+            // There may be more elements. Use the lower bound as an estimate.\n+            // FIXME: Is the upper bound a better guess? Or something else?\n+            let (lower_bound, _upper_bound) = self.replace_with.size_hint();\n+            if lower_bound > 0  {\n+                self.drain.move_tail(lower_bound);\n+                if !self.drain.fill(&mut self.replace_with) {\n+                    return\n+                }\n+            }\n+\n+            // Collect any remaining elements.\n+            // This is a zero-length vector which does not allocate if `lower_bound` was exact.\n+            let mut collected = self.replace_with.by_ref().collect::<Vec<I::Item>>().into_iter();\n+            // Now we have an exact count.\n+            if collected.len() > 0 {\n+                self.drain.move_tail(collected.len());\n+                let filled = self.drain.fill(&mut collected);\n+                debug_assert!(filled);\n+                debug_assert_eq!(collected.len(), 0);\n+            }\n+        }\n+        // Let `Drain::drop` move the tail back if necessary and restore `vec.len`.\n+    }\n+}\n+\n+/// Private helper methods for `Splice::drop`\n+impl<'a, T> Drain<'a, T> {\n+    /// The range from `self.vec.len` to `self.tail_start` contains elements\n+    /// that have been moved out.\n+    /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n+    /// Return whether we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n+    unsafe fn fill<I: Iterator<Item=T>>(&mut self, replace_with: &mut I) -> bool {\n+        let vec = &mut *self.vec.as_mut_ptr();\n+        let range_start = vec.len;\n+        let range_end = self.tail_start;\n+        let range_slice = slice::from_raw_parts_mut(\n+            vec.as_mut_ptr().offset(range_start as isize),\n+            range_end - range_start);\n+\n+        for place in range_slice {\n+            if let Some(new_item) = replace_with.next() {\n+                ptr::write(place, new_item);\n+                vec.len += 1;\n+            } else {\n+                return false\n+            }\n+        }\n+        true\n+    }\n+\n+    /// Make room for inserting more elements before the tail.\n+    unsafe fn move_tail(&mut self, extra_capacity: usize) {\n+        let vec = &mut *self.vec.as_mut_ptr();\n+        let used_capacity = self.tail_start + self.tail_len;\n+        vec.buf.reserve(used_capacity, extra_capacity);\n+\n+        let new_tail_start = self.tail_start + extra_capacity;\n+        let src = vec.as_ptr().offset(self.tail_start as isize);\n+        let dst = vec.as_mut_ptr().offset(new_tail_start as isize);\n+        ptr::copy(src, dst, self.tail_len);\n+        self.tail_start = new_tail_start;\n+    }\n+}"}]}