{"sha": "37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3MzA2YzFkMjVhNmJiOGQxZTk2YWRhZmY2YTM2MGQ2MTYzYjhmMjk=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-04-09T07:15:31Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-04-20T00:41:53Z"}, "message": "Refactor ty_vec represent &[T] as &([T])\n\nRefactores all uses of ty_vec and associated things to remove the vstore abstraction (still used for strings, for now). Pointers to vectors are stored as ty_rptr or ty_uniq wrapped around a ty_vec. There are no user-facing changes. Existing behaviour is preserved by special-casing many instances of pointers containing vectors. Hopefully with DST most of these hacks will go away. For now it is useful to leave them hanging around rather than abstracting them into a method or something.\n\nCloses #13554.", "tree": {"sha": "91051bd00ea667f183b47547547d3b753774fc56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91051bd00ea667f183b47547547d3b753774fc56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "html_url": "https://github.com/rust-lang/rust/commit/37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3757f01c9bed7b2fe0d726ac45c754312e2917ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/3757f01c9bed7b2fe0d726ac45c754312e2917ea", "html_url": "https://github.com/rust-lang/rust/commit/3757f01c9bed7b2fe0d726ac45c754312e2917ea"}], "stats": {"total": 1261, "additions": 755, "deletions": 506}, "files": [{"sha": "cfa2d647ec9014f924a87b162d4abed43a5ce4bd", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -137,8 +137,7 @@ pub fn parse_substs_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx:\n     parse_substs(&mut st, conv)\n }\n \n-fn parse_vstore<M>(st: &mut PState, conv: conv_did,\n-                   parse_mut: |&mut PState| -> M) -> ty::Vstore<M> {\n+fn parse_vstore(st: &mut PState, conv: conv_did) -> ty::Vstore {\n     assert_eq!(next(st), '/');\n \n     let c = peek(st);\n@@ -150,11 +149,24 @@ fn parse_vstore<M>(st: &mut PState, conv: conv_did,\n \n     match next(st) {\n         '~' => ty::VstoreUniq,\n-        '&' => ty::VstoreSlice(parse_region(st, conv), parse_mut(st)),\n+        '&' => ty::VstoreSlice(parse_region(st, conv)),\n         c => st.tcx.sess.bug(format!(\"parse_vstore(): bad input '{}'\", c))\n     }\n }\n \n+fn parse_size(st: &mut PState) -> Option<uint> {\n+    assert_eq!(next(st), '/');\n+\n+    if peek(st) == '|' {\n+        assert_eq!(next(st), '|');\n+        None\n+    } else {\n+        let n = parse_uint(st);\n+        assert_eq!(next(st), '|');\n+        Some(n)\n+    }\n+}\n+\n fn parse_trait_store(st: &mut PState, conv: conv_did) -> ty::TraitStore {\n     match next(st) {\n         '~' => ty::UniqTraitStore,\n@@ -342,12 +354,12 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         return ty::mk_rptr(st.tcx, r, mt);\n       }\n       'V' => {\n-        let ty = parse_ty(st, |x,y| conv(x,y));\n-        let v = parse_vstore(st, |x,y| conv(x,y), parse_mutability);\n-        return ty::mk_vec(st.tcx, ty, v);\n+        let mt = parse_mt(st, |x,y| conv(x,y));\n+        let sz = parse_size(st);\n+        return ty::mk_vec(st.tcx, mt, sz);\n       }\n       'v' => {\n-        let v = parse_vstore(st, |x,y| conv(x,y), |_| ());\n+        let v = parse_vstore(st, |x,y| conv(x,y));\n         return ty::mk_str(st.tcx, v);\n       }\n       'T' => {\n@@ -396,7 +408,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n           assert_eq!(next(st), ']');\n           return ty::mk_struct(st.tcx, did, substs);\n       }\n-      c => { error!(\"unexpected char in type string: {}\", c); fail!();}\n+      c => { fail!(\"unexpected char in type string: {}\", c);}\n     }\n }\n "}, {"sha": "1d7d43f895ede84139ce3ffcca1ae59380f31970", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -204,17 +204,17 @@ fn enc_bound_region(w: &mut MemWriter, cx: &ctxt, br: ty::BoundRegion) {\n     }\n }\n \n-pub fn enc_vstore<M>(w: &mut MemWriter, cx: &ctxt,\n-                     v: ty::Vstore<M>,\n-                     enc_mut: |&mut MemWriter, M|) {\n+pub fn enc_vstore(w: &mut MemWriter, cx: &ctxt,\n+                  v: ty::Vstore,\n+                  enc_mut: |&mut MemWriter|) {\n     mywrite!(w, \"/\");\n     match v {\n         ty::VstoreFixed(u) => mywrite!(w, \"{}|\", u),\n         ty::VstoreUniq => mywrite!(w, \"~\"),\n-        ty::VstoreSlice(r, m) => {\n+        ty::VstoreSlice(r) => {\n             mywrite!(w, \"&\");\n             enc_region(w, cx, r);\n-            enc_mut(w, m);\n+            enc_mut(w);\n         }\n     }\n }\n@@ -292,14 +292,18 @@ fn enc_sty(w: &mut MemWriter, cx: &ctxt, st: &ty::sty) {\n             enc_region(w, cx, r);\n             enc_mt(w, cx, mt);\n         }\n-        ty::ty_vec(ty, v) => {\n+        ty::ty_vec(mt, sz) => {\n             mywrite!(w, \"V\");\n-            enc_ty(w, cx, ty);\n-            enc_vstore(w, cx, v, enc_mutability);\n+            enc_mt(w, cx, mt);\n+            mywrite!(w, \"/\");\n+            match sz {\n+                Some(n) => mywrite!(w, \"{}|\", n),\n+                None => mywrite!(w, \"|\"),\n+            }\n         }\n         ty::ty_str(v) => {\n             mywrite!(w, \"v\");\n-            enc_vstore(w, cx, v, |_, ()| {});\n+            enc_vstore(w, cx, v, |_| {});\n         }\n         ty::ty_closure(ref f) => {\n             mywrite!(w, \"f\");"}, {"sha": "db1badb7d59866587ed9b660c397c7f10f4c1ad7", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 92, "deletions": 69, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -191,7 +191,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: Vec<@Pat> ) {\n                         }\n                     }\n                 }\n-                ty::ty_vec(..) => {\n+                ty::ty_vec(..) | ty::ty_rptr(..) => {\n                     match *ctor {\n                         vec(n) => Some(format!(\"vectors of length {}\", n)),\n                         _ => None\n@@ -258,50 +258,57 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n           None => {\n             match ty::get(left_ty).sty {\n               ty::ty_bool => {\n-                match is_useful_specialized(cx, m, v,\n-                                            val(const_bool(true)),\n-                                            0u, left_ty){\n-                  not_useful => {\n-                    is_useful_specialized(cx, m, v,\n-                                          val(const_bool(false)),\n-                                          0u, left_ty)\n+                  match is_useful_specialized(cx, m, v,\n+                                              val(const_bool(true)),\n+                                              0u, left_ty){\n+                      not_useful => {\n+                          is_useful_specialized(cx, m, v,\n+                                                val(const_bool(false)),\n+                                                0u, left_ty)\n+                      }\n+                      ref u => (*u).clone(),\n                   }\n-                  ref u => (*u).clone(),\n-                }\n               }\n               ty::ty_enum(eid, _) => {\n-                for va in (*ty::enum_variants(cx.tcx, eid)).iter() {\n-                    match is_useful_specialized(cx, m, v, variant(va.id),\n-                                                va.args.len(), left_ty) {\n-                      not_useful => (),\n-                      ref u => return (*u).clone(),\n-                    }\n-                }\n-                not_useful\n+                  for va in (*ty::enum_variants(cx.tcx, eid)).iter() {\n+                      match is_useful_specialized(cx, m, v, variant(va.id),\n+                                                  va.args.len(), left_ty) {\n+                        not_useful => (),\n+                        ref u => return (*u).clone(),\n+                      }\n+                  }\n+                  not_useful\n               }\n-              ty::ty_vec(_, ty::VstoreFixed(n)) => {\n-                is_useful_specialized(cx, m, v, vec(n), n, left_ty)\n+              ty::ty_vec(_, Some(n)) => {\n+                  is_useful_specialized(cx, m, v, vec(n), n, left_ty)\n               }\n-              ty::ty_vec(..) => {\n-                let max_len = m.iter().rev().fold(0, |max_len, r| {\n-                  match r.get(0).node {\n-                    PatVec(ref before, _, ref after) => {\n-                      cmp::max(before.len() + after.len(), max_len)\n-                    }\n-                    _ => max_len\n+              ty::ty_vec(..) => fail!(\"impossible case\"),\n+              ty::ty_rptr(_, ty::mt{ty: ty, ..}) | ty::ty_uniq(ty) => match ty::get(ty).sty {\n+                  ty::ty_vec(_, None) => {\n+                      let max_len = m.iter().rev().fold(0, |max_len, r| {\n+                          match r.get(0).node {\n+                              PatVec(ref before, _, ref after) => {\n+                                  cmp::max(before.len() + after.len(), max_len)\n+                              }\n+                              _ => max_len\n+                          }\n+                      });\n+                      for n in iter::range(0u, max_len + 1) {\n+                          match is_useful_specialized(cx, m, v, vec(n), n, left_ty) {\n+                              not_useful => (),\n+                              ref u => return (*u).clone(),\n+                          }\n+                      }\n+                      not_useful\n                   }\n-                });\n-                for n in iter::range(0u, max_len + 1) {\n-                  match is_useful_specialized(cx, m, v, vec(n), n, left_ty) {\n-                    not_useful => (),\n-                    ref u => return (*u).clone(),\n+                  _ => {\n+                      let arity = ctor_arity(cx, &single, left_ty);\n+                      is_useful_specialized(cx, m, v, single, arity, left_ty)\n                   }\n-                }\n-                not_useful\n-              }\n+              },\n               _ => {\n-                let arity = ctor_arity(cx, &single, left_ty);\n-                is_useful_specialized(cx, m, v, single, arity, left_ty)\n+                  let arity = ctor_arity(cx, &single, left_ty);\n+                  is_useful_specialized(cx, m, v, single, arity, left_ty)\n               }\n             }\n           }\n@@ -394,17 +401,16 @@ fn is_wild(cx: &MatchCheckCtxt, p: @Pat) -> bool {\n }\n \n fn missing_ctor(cx: &MatchCheckCtxt,\n-                    m: &matrix,\n-                    left_ty: ty::t)\n-                 -> Option<ctor> {\n-    match ty::get(left_ty).sty {\n-      ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(..) | ty::ty_tup(_) |\n-      ty::ty_struct(..) => {\n-        for r in m.iter() {\n-            if !is_wild(cx, *r.get(0)) { return None; }\n-        }\n-        return Some(single);\n-      }\n+                m: &matrix,\n+                left_ty: ty::t)\n+                -> Option<ctor> {\n+    return match ty::get(left_ty).sty {\n+      ty::ty_box(_) | ty::ty_tup(_) |\n+      ty::ty_struct(..) => check_matrix_for_wild(cx, m),\n+      ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty: ty, ..}) => match ty::get(ty).sty {\n+          ty::ty_vec(_, None) => ctor_for_slice(m),\n+          _ => check_matrix_for_wild(cx, m),\n+      },\n       ty::ty_enum(eid, _) => {\n         let mut found = Vec::new();\n         for r in m.iter() {\n@@ -441,7 +447,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n         else if true_found { Some(val(const_bool(false))) }\n         else { Some(val(const_bool(true))) }\n       }\n-      ty::ty_vec(_, ty::VstoreFixed(n)) => {\n+      ty::ty_vec(_, Some(n)) => {\n         let mut missing = true;\n         let mut wrong = false;\n         for r in m.iter() {\n@@ -464,8 +470,19 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n           _         => None\n         }\n       }\n-      ty::ty_vec(..) => {\n+      ty::ty_vec(..) => fail!(\"impossible case\"),\n+      _ => Some(single)\n+    };\n+\n+    fn check_matrix_for_wild(cx: &MatchCheckCtxt, m: &matrix) -> Option<ctor> {\n+        for r in m.iter() {\n+            if !is_wild(cx, *r.get(0)) { return None; }\n+        }\n+        return Some(single);\n+    }\n \n+    // For slice and ~[T].\n+    fn ctor_for_slice(m: &matrix) -> Option<ctor> {\n         // Find the lengths and slices of all vector patterns.\n         let mut vec_pat_lens = m.iter().filter_map(|r| {\n             match r.get(0).node {\n@@ -511,31 +528,37 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n           Some(k) => Some(vec(k)),\n           None => None\n         }\n-      }\n-      _ => Some(single)\n     }\n }\n \n fn ctor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n-    match ty::get(ty).sty {\n-      ty::ty_tup(ref fs) => fs.len(),\n-      ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(..) => 1u,\n-      ty::ty_enum(eid, _) => {\n-          let id = match *ctor { variant(id) => id,\n-          _ => fail!(\"impossible case\") };\n-        match ty::enum_variants(cx.tcx, eid).iter().find(|v| v.id == id ) {\n-            Some(v) => v.args.len(),\n-            None => fail!(\"impossible case\")\n-        }\n-      }\n-      ty::ty_struct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n-      ty::ty_vec(..) => {\n+    fn vec_ctor_arity(ctor: &ctor) -> uint {\n         match *ctor {\n-          vec(n) => n,\n-          _ => 0u\n+            vec(n) => n,\n+            _ => 0u\n         }\n-      }\n-      _ => 0u\n+    }\n+\n+    match ty::get(ty).sty {\n+        ty::ty_tup(ref fs) => fs.len(),\n+        ty::ty_box(_) => 1u,\n+        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty: ty, ..}) => match ty::get(ty).sty {\n+            ty::ty_vec(_, None) => vec_ctor_arity(ctor),\n+            _ => 1u,\n+        },\n+        ty::ty_enum(eid, _) => {\n+            let id = match *ctor {\n+                variant(id) => id,\n+                _ => fail!(\"impossible case\")\n+            };\n+            match ty::enum_variants(cx.tcx, eid).iter().find(|v| v.id == id ) {\n+                Some(v) => v.args.len(),\n+                None => fail!(\"impossible case\")\n+            }\n+        }\n+        ty::ty_struct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n+        ty::ty_vec(_, Some(_)) => vec_ctor_arity(ctor),\n+        _ => 0u\n     }\n }\n "}, {"sha": "6ce815d9bc46c731681f3b2e7926fe9105bb8065", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -918,7 +918,6 @@ fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n                     n_box += 1;\n                 }\n                 ty::ty_uniq(_) | ty::ty_str(ty::VstoreUniq) |\n-                ty::ty_vec(_, ty::VstoreUniq) |\n                 ty::ty_trait(~ty::TyTrait { store: ty::UniqTraitStore, .. }) |\n                 ty::ty_closure(~ty::ClosureTy { store: ty::UniqTraitStore, .. }) => {\n                     n_uniq += 1;\n@@ -1156,10 +1155,13 @@ fn check_unused_result(cx: &Context, s: &ast::Stmt) {\n fn check_deprecated_owned_vector(cx: &Context, e: &ast::Expr) {\n     let t = ty::expr_ty(cx.tcx, e);\n     match ty::get(t).sty {\n-        ty::ty_vec(_, ty::VstoreUniq) => {\n-            cx.span_lint(DeprecatedOwnedVector, e.span,\n-                         \"use of deprecated `~[]` vector; replaced by `std::vec::Vec`\")\n-        }\n+        ty::ty_uniq(t) => match ty::get(t).sty {\n+            ty::ty_vec(_, None) => {\n+                cx.span_lint(DeprecatedOwnedVector, e.span,\n+                             \"use of deprecated `~[]` vector; replaced by `std::vec::Vec`\")\n+            }\n+            _ => {}\n+        },\n         _ => {}\n     }\n }"}, {"sha": "84e9151c11ccee1cd2f881f68db389a09ea9d151", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -170,7 +170,6 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n     match ty::get(t).sty {\n         ty::ty_uniq(_) |\n         ty::ty_trait(~ty::TyTrait { store: ty::UniqTraitStore, .. }) |\n-        ty::ty_vec(_, ty::VstoreUniq) |\n         ty::ty_str(ty::VstoreUniq) |\n         ty::ty_closure(~ty::ClosureTy {store: ty::UniqTraitStore, ..}) => {\n             Some(deref_ptr(OwnedPtr))\n@@ -180,13 +179,12 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n             let kind = ty::BorrowKind::from_mutbl(mt.mutbl);\n             Some(deref_ptr(BorrowedPtr(kind, r)))\n         }\n-        ty::ty_vec(_, ty::VstoreSlice(r, mutbl)) |\n         ty::ty_trait(~ty::TyTrait { store: ty::RegionTraitStore(r, mutbl), .. }) => {\n             let kind = ty::BorrowKind::from_mutbl(mutbl);\n             Some(deref_ptr(BorrowedPtr(kind, r)))\n         }\n \n-        ty::ty_str(ty::VstoreSlice(r, ())) |\n+        ty::ty_str(ty::VstoreSlice(r)) |\n         ty::ty_closure(~ty::ClosureTy {store: ty::RegionTraitStore(r, _), ..}) => {\n             Some(deref_ptr(BorrowedPtr(ty::ImmBorrow, r)))\n         }\n@@ -204,7 +202,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n             Some(deref_interior(InteriorField(PositionalField(0))))\n         }\n \n-        ty::ty_vec(_, ty::VstoreFixed(_)) |\n+        ty::ty_vec(_, Some(_)) |\n         ty::ty_str(ty::VstoreFixed(_)) => {\n             Some(deref_interior(InteriorElement(element_kind(t))))\n         }\n@@ -483,8 +481,8 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                    expr_ty: ty::t,\n                    def: ast::Def)\n                    -> McResult<cmt> {\n-        debug!(\"cat_def: id={} expr={}\",\n-               id, expr_ty.repr(self.tcx()));\n+        debug!(\"cat_def: id={} expr={} def={:?}\",\n+               id, expr_ty.repr(self.tcx()), def);\n \n         match def {\n           ast::DefStruct(..) | ast::DefVariant(..) => {\n@@ -785,7 +783,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         //!   the implicit index deref, if any (see above)\n \n         let element_ty = match ty::index(base_cmt.ty) {\n-          Some(ty) => ty,\n+          Some(ref mt) => mt.ty,\n           None => {\n             self.tcx().sess.span_bug(\n                 elt.span(),\n@@ -868,13 +866,10 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n              */\n \n             match ty::get(slice_ty).sty {\n-                ty::ty_vec(_, ty::VstoreSlice(slice_r, mutbl)) => {\n-                    (mutbl, slice_r)\n-                }\n-\n-                ty::ty_rptr(_, ref mt) => {\n-                    vec_slice_info(tcx, pat, mt.ty)\n-                }\n+                ty::ty_rptr(r, ref mt) => match ty::get(mt.ty).sty {\n+                    ty::ty_vec(slice_mt, None) => (slice_mt.mutbl, r),\n+                    _ => vec_slice_info(tcx, pat, mt.ty),\n+                },\n \n                 _ => {\n                     tcx.sess.span_bug(\n@@ -1307,6 +1302,11 @@ impl Repr for InteriorKind {\n \n fn element_kind(t: ty::t) -> ElementKind {\n     match ty::get(t).sty {\n+        ty::ty_rptr(_, ty::mt{ty:ty, ..}) |\n+        ty::ty_uniq(ty) => match ty::get(ty).sty {\n+            ty::ty_vec(_, None) => VecElement,\n+            _ => OtherElement\n+        },\n         ty::ty_vec(..) => VecElement,\n         ty::ty_str(..) => StrElement,\n         _ => OtherElement"}, {"sha": "72818576cbb7147c00ba359a41ae6aca11d48759", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -438,7 +438,8 @@ impl<'a,'b> Clone for ArmData<'a, 'b> {\n struct Match<'a,'b> {\n     pats: Vec<@ast::Pat> ,\n     data: ArmData<'a,'b>,\n-    bound_ptrs: Vec<(Ident, ValueRef)> }\n+    bound_ptrs: Vec<(Ident, ValueRef)>\n+}\n \n impl<'a,'b> Repr for Match<'a,'b> {\n     fn repr(&self, tcx: &ty::ctxt) -> ~str {\n@@ -1109,8 +1110,9 @@ fn extract_vec_elems<'a>(\n         let slice_begin = tvec::pointer_add_byte(bcx, base, slice_byte_offset);\n         let slice_len_offset = C_uint(bcx.ccx(), elem_count - 1u);\n         let slice_len = Sub(bcx, len, slice_len_offset);\n-        let slice_ty = ty::mk_vec(bcx.tcx(), vt.unit_ty,\n-                                  ty::VstoreSlice(ty::ReStatic, ast::MutImmutable));\n+        let slice_ty = ty::mk_slice(bcx.tcx(),\n+                                    ty::ReStatic,\n+                                    ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable});\n         let scratch = rvalue_scratch_datum(bcx, slice_ty, \"\");\n         Store(bcx, slice_begin,\n               GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));"}, {"sha": "92a6bb73c8e3a3075eae64f7a71f67f256bb2e0b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -188,7 +188,7 @@ fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv,\n         // FIXME #6750 ~Trait cannot be directly marked as\n         // noalias because the actual object pointer is nested.\n         ty::ty_uniq(..) | // ty::ty_trait(_, _, ty::UniqTraitStore, _, _) |\n-        ty::ty_vec(_, ty::VstoreUniq) | ty::ty_str(ty::VstoreUniq) => {\n+        ty::ty_str(ty::VstoreUniq) => {\n             unsafe {\n                 llvm::LLVMAddReturnAttribute(llfn, lib::llvm::NoAliasAttribute as c_uint);\n             }\n@@ -260,7 +260,7 @@ pub fn decl_rust_fn(ccx: &CrateContext, has_env: bool,\n             // FIXME #6750 ~Trait cannot be directly marked as\n             // noalias because the actual object pointer is nested.\n             ty::ty_uniq(..) | // ty::ty_trait(_, _, ty::UniqTraitStore, _, _) |\n-            ty::ty_vec(_, ty::VstoreUniq) | ty::ty_str(ty::VstoreUniq) |\n+            ty::ty_str(ty::VstoreUniq) |\n             ty::ty_closure(~ty::ClosureTy {store: ty::UniqTraitStore, ..}) => {\n                 unsafe {\n                     llvm::LLVMAddAttribute(llarg, lib::llvm::NoAliasAttribute as c_uint);\n@@ -664,8 +664,12 @@ pub fn iter_structural_ty<'r,\n               }\n           })\n       }\n-      ty::ty_str(ty::VstoreFixed(n)) |\n-      ty::ty_vec(_, ty::VstoreFixed(n)) => {\n+      ty::ty_str(ty::VstoreFixed(n)) => {\n+        let unit_ty = ty::sequence_element_type(cx.tcx(), t);\n+        let (base, len) = tvec::get_fixed_base_and_byte_len(cx, av, unit_ty, n);\n+        cx = tvec::iter_vec_raw(cx, base, unit_ty, len, f);\n+      }\n+      ty::ty_vec(_, Some(n)) => {\n         let unit_ty = ty::sequence_element_type(cx.tcx(), t);\n         let (base, len) = tvec::get_fixed_base_and_byte_len(cx, av, unit_ty, n);\n         cx = tvec::iter_vec_raw(cx, base, unit_ty, len, f);"}, {"sha": "8bc217343f7fe97b037d4ba7ef80667ee6c30dd9", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -653,7 +653,7 @@ pub fn trans_call_inner<'a>(\n         match ty::get(ret_ty).sty {\n             // `~` pointer return values never alias because ownership\n             // is transferred\n-            ty::ty_uniq(..) | ty::ty_vec(_, ty::VstoreUniq) => {\n+            ty::ty_uniq(..) => {\n                 attrs.push((0, NoAliasAttribute));\n             }\n             _ => {}"}, {"sha": "72e716d0c3cae7ac4b5e670741732787c34143b3", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -711,8 +711,12 @@ pub enum MonoDataClass {\n pub fn mono_data_classify(t: ty::t) -> MonoDataClass {\n     match ty::get(t).sty {\n         ty::ty_float(_) => MonoFloat,\n-        ty::ty_rptr(..) | ty::ty_uniq(..) | ty::ty_box(..) |\n-        ty::ty_str(ty::VstoreUniq) | ty::ty_vec(_, ty::VstoreUniq) |\n+        ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n+            ty::ty_vec(_, None) => MonoBits,\n+            _ => MonoNonNull,\n+        },\n+        ty::ty_uniq(..) | ty::ty_box(..) |\n+        ty::ty_str(ty::VstoreUniq) |\n         ty::ty_bare_fn(..) => MonoNonNull,\n         // Is that everything?  Would closures or slices qualify?\n         _ => MonoBits"}, {"sha": "8848feb888904668c0351c26f923fe6900f80997", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -139,8 +139,11 @@ fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n         Some(ref mt) => {\n             assert!(mt.mutbl != ast::MutMutable);\n             let dv = match ty::get(t).sty {\n-                ty::ty_ptr(..) | ty::ty_rptr(..) => {\n-                     const_deref_ptr(cx, v)\n+                ty::ty_ptr(mt) | ty::ty_rptr(_, mt) => {\n+                    match ty::get(mt.ty).sty {\n+                        ty::ty_vec(_, None) => cx.sess().bug(\"unexpected slice\"),\n+                        _ => const_deref_ptr(cx, v),\n+                    }\n                 }\n                 ty::ty_enum(..) | ty::ty_struct(..) => {\n                     const_deref_newtype(cx, v, t)\n@@ -244,7 +247,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                                     assert_eq!(abi::slice_elt_base, 0);\n                                     assert_eq!(abi::slice_elt_len, 1);\n                                     match ty::get(ty).sty {\n-                                        ty::ty_vec(_, ty::VstoreFixed(len)) => {\n+                                        ty::ty_vec(_, Some(len)) => {\n                                             llconst = C_struct(cx, [\n                                                 llptr,\n                                                 C_uint(cx, len)\n@@ -432,14 +435,21 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                                           \"index is not an integer-constant expression\")\n               };\n               let (arr, len) = match ty::get(bt).sty {\n-                  ty::ty_vec(_, ty::VstoreFixed(u)) => (bv, C_uint(cx, u)),\n-                  ty::ty_vec(_, ty::VstoreSlice(..)) |\n                   ty::ty_str(ty::VstoreSlice(..)) => {\n                     let e1 = const_get_elt(cx, bv, [0]);\n                     (const_deref_ptr(cx, e1), const_get_elt(cx, bv, [1]))\n                   },\n+                  ty::ty_vec(_, Some(u)) => (bv, C_uint(cx, u)),\n+                  ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n+                      ty::ty_vec(_, None) => {\n+                          let e1 = const_get_elt(cx, bv, [0]);\n+                          (const_deref_ptr(cx, e1), const_get_elt(cx, bv, [1]))\n+                      },\n+                      _ => cx.sess().span_bug(base.span,\n+                                              \"index-expr base must be a vector or string type\")\n+                  },\n                   _ => cx.sess().span_bug(base.span,\n-                        \"index-expr base must be a fixed-size vector or a slice\")\n+                                          \"index-expr base must be a vector or string type\")\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;"}, {"sha": "1a57acf84d22198a82c4e11b1e591737d838cd27", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -2202,27 +2202,27 @@ fn type_metadata(cx: &CrateContext,\n         ty::ty_box(typ) => {\n             create_pointer_to_box_metadata(cx, t, typ)\n         },\n-        ty::ty_vec(ty, ref vstore) => {\n-            match *vstore {\n-                ty::VstoreFixed(len) => {\n-                    fixed_vec_metadata(cx, ty, len, usage_site_span)\n-                }\n-                ty::VstoreUniq => {\n-                    let vec_metadata = vec_metadata(cx, ty, usage_site_span);\n+        ty::ty_vec(ref mt, Some(len)) => fixed_vec_metadata(cx, mt.ty, len, usage_site_span),\n+        ty::ty_uniq(typ) => {\n+            match ty::get(typ).sty {\n+                ty::ty_vec(ref mt, None) => {\n+                    let vec_metadata = vec_metadata(cx, mt.ty, usage_site_span);\n                     pointer_type_metadata(cx, t, vec_metadata)\n                 }\n-                ty::VstoreSlice(..) => {\n-                    vec_slice_metadata(cx, t, ty, usage_site_span)\n+                _ => {\n+                    let pointee = type_metadata(cx, typ, usage_site_span);\n+                    pointer_type_metadata(cx, t, pointee)\n                 }\n             }\n-        },\n-        ty::ty_uniq(typ) => {\n-            let pointee = type_metadata(cx, typ, usage_site_span);\n-            pointer_type_metadata(cx, t, pointee)\n         }\n         ty::ty_ptr(ref mt) | ty::ty_rptr(_, ref mt) => {\n-            let pointee = type_metadata(cx, mt.ty, usage_site_span);\n-            pointer_type_metadata(cx, t, pointee)\n+            match ty::get(mt.ty).sty {\n+                ty::ty_vec(ref mt, None) => vec_slice_metadata(cx, t, mt.ty, usage_site_span),\n+                _ => {\n+                    let pointee = type_metadata(cx, mt.ty, usage_site_span);\n+                    pointer_type_metadata(cx, t, pointee)\n+                }\n+            }\n         },\n         ty::ty_bare_fn(ref barefnty) => {\n             subroutine_type_metadata(cx, &barefnty.sig, usage_site_span)"}, {"sha": "4e850b8990a1a1cdb440715da9d1270691cecd6a", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -240,8 +240,8 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n \n         // this type may have a different region/mutability than the\n         // real one, but it will have the same runtime representation\n-        let slice_ty = ty::mk_vec(tcx, unit_ty,\n-                                  ty::VstoreSlice(ty::ReStatic, ast::MutImmutable));\n+        let slice_ty = ty::mk_slice(tcx, ty::ReStatic,\n+                                    ty::mt { ty: unit_ty, mutbl: ast::MutImmutable });\n \n         let scratch = rvalue_scratch_datum(bcx, slice_ty, \"__adjust\");\n         Store(bcx, base, GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n@@ -1505,16 +1505,19 @@ pub enum cast_kind {\n \n pub fn cast_type_kind(t: ty::t) -> cast_kind {\n     match ty::get(t).sty {\n-        ty::ty_char       => cast_integral,\n+        ty::ty_char        => cast_integral,\n         ty::ty_float(..)   => cast_float,\n         ty::ty_ptr(..)     => cast_pointer,\n-        ty::ty_rptr(..)    => cast_pointer,\n+        ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty{\n+            ty::ty_vec(_, None) => cast_other,\n+            _ => cast_pointer,\n+        },\n         ty::ty_bare_fn(..) => cast_pointer,\n         ty::ty_int(..)     => cast_integral,\n         ty::ty_uint(..)    => cast_integral,\n-        ty::ty_bool       => cast_integral,\n+        ty::ty_bool        => cast_integral,\n         ty::ty_enum(..)    => cast_enum,\n-        _                 => cast_other\n+        _                  => cast_other\n     }\n }\n \n@@ -1717,7 +1720,10 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n \n     let r = match ty::get(datum.ty).sty {\n         ty::ty_uniq(content_ty) => {\n-            deref_owned_pointer(bcx, expr, datum, content_ty)\n+            match ty::get(content_ty).sty {\n+                ty::ty_vec(_, None) => bcx.tcx().sess.span_bug(expr.span, \"unexpected ~[T]\"),\n+                _ => deref_owned_pointer(bcx, expr, datum, content_ty),\n+            }\n         }\n \n         ty::ty_box(content_ty) => {\n@@ -1731,16 +1737,21 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n \n         ty::ty_ptr(ty::mt { ty: content_ty, .. }) |\n         ty::ty_rptr(_, ty::mt { ty: content_ty, .. }) => {\n-            assert!(!ty::type_needs_drop(bcx.tcx(), datum.ty));\n+            match ty::get(content_ty).sty {\n+                ty::ty_vec(_, None) => bcx.tcx().sess.span_bug(expr.span, \"unexpected &[T]\"),\n+                _ => {\n+                    assert!(!ty::type_needs_drop(bcx.tcx(), datum.ty));\n \n-            let ptr = datum.to_llscalarish(bcx);\n+                    let ptr = datum.to_llscalarish(bcx);\n \n-            // Always generate an lvalue datum, even if datum.mode is\n-            // an rvalue.  This is because datum.mode is only an\n-            // rvalue for non-owning pointers like &T or *T, in which\n-            // case cleanup *is* scheduled elsewhere, by the true\n-            // owner (or, in the case of *T, by the user).\n-            DatumBlock(bcx, Datum(ptr, content_ty, LvalueExpr))\n+                    // Always generate an lvalue datum, even if datum.mode is\n+                    // an rvalue.  This is because datum.mode is only an\n+                    // rvalue for non-owning pointers like &T or *T, in which\n+                    // case cleanup *is* scheduled elsewhere, by the true\n+                    // owner (or, in the case of *T, by the user).\n+                    DatumBlock(bcx, Datum(ptr, content_ty, LvalueExpr))\n+                }\n+            }\n         }\n \n         _ => {"}, {"sha": "98e09b2fd31fdfb9aaae81ace0508dc1f9af5bfa", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -83,19 +83,21 @@ fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n             ty::mk_box(tcx, ty::mk_i8()),\n \n         ty::ty_uniq(typ) if !ty::type_needs_drop(tcx, typ) => {\n-            let llty = sizing_type_of(ccx, typ);\n-            // Unique boxes do not allocate for zero-size types. The standard library may assume\n-            // that `free` is never called on the pointer returned for `~ZeroSizeType`.\n-            if llsize_of_alloc(ccx, llty) == 0 {\n-                ty::mk_i8()\n-            } else {\n-                ty::mk_uniq(tcx, ty::mk_i8())\n-            }\n-        }\n-\n-        ty::ty_vec(ty, ty::VstoreUniq) if !ty::type_needs_drop(tcx, ty) =>\n-            ty::mk_uniq(tcx, ty::mk_i8()),\n-\n+            match ty::get(typ).sty {\n+                ty::ty_vec(_, None) => t,\n+                _ => {\n+                    let llty = sizing_type_of(ccx, typ);\n+                    // Unique boxes do not allocate for zero-size types. The standard\n+                    // library may assume that `free` is never called on the pointer\n+                    // returned for `~ZeroSizeType`.\n+                    if llsize_of_alloc(ccx, llty) == 0 {\n+                        ty::mk_i8()\n+                    } else {\n+                        ty::mk_uniq(tcx, ty::mk_i8())\n+                    }\n+                        }\n+                    }\n+                }\n         _ => t\n     }\n }\n@@ -284,12 +286,22 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n         ty::ty_uniq(content_ty) => {\n             let llbox = Load(bcx, v0);\n             let not_null = IsNotNull(bcx, llbox);\n-            with_cond(bcx, not_null, |bcx| {\n-                let bcx = drop_ty(bcx, llbox, content_ty);\n-                trans_exchange_free(bcx, llbox)\n-            })\n+            match ty::get(content_ty).sty {\n+                ty::ty_vec(mt, None) => {\n+                    with_cond(bcx, not_null, |bcx| {\n+                        let bcx = tvec::make_drop_glue_unboxed(bcx, llbox, mt.ty);\n+                        trans_exchange_free(bcx, llbox)\n+                    })\n+                }\n+                _ => {\n+                    with_cond(bcx, not_null, |bcx| {\n+                        let bcx = drop_ty(bcx, llbox, content_ty);\n+                        trans_exchange_free(bcx, llbox)\n+                    })\n+                }\n+            }\n         }\n-        ty::ty_vec(_, ty::VstoreUniq) | ty::ty_str(ty::VstoreUniq) => {\n+        ty::ty_str(ty::VstoreUniq) => {\n             let llbox = Load(bcx, v0);\n             let not_null = IsNotNull(bcx, llbox);\n             with_cond(bcx, not_null, |bcx| {"}, {"sha": "7dc4641e97fa71d40c5e7d1b866d747557416da5", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -54,7 +54,7 @@ impl<'a> Reflector<'a> {\n         // We're careful to not use first class aggregates here because that\n         // will kick us off fast isel. (Issue #4352.)\n         let bcx = self.bcx;\n-        let str_vstore = ty::VstoreSlice(ty::ReStatic, ());\n+        let str_vstore = ty::VstoreSlice(ty::ReStatic);\n         let str_ty = ty::mk_str(bcx.tcx(), str_vstore);\n         let scratch = rvalue_scratch_datum(bcx, str_ty, \"\");\n         let len = C_uint(bcx.ccx(), s.get().len());\n@@ -121,10 +121,10 @@ impl<'a> Reflector<'a> {\n         self.visit(\"leave_\" + bracket_name, extra);\n     }\n \n-    pub fn vstore_name_and_extra<M>(&mut self,\n-                                    t: ty::t,\n-                                    vstore: ty::Vstore<M>)\n-                                    -> (~str, Vec<ValueRef> ) {\n+    pub fn vstore_name_and_extra(&mut self,\n+                                 t: ty::t,\n+                                 vstore: ty::Vstore)\n+                                 -> (~str, Vec<ValueRef> ) {\n         match vstore {\n             ty::VstoreFixed(n) => {\n                 let extra = (vec!(self.c_uint(n))).append(self.c_size_and_align(t).as_slice());\n@@ -168,17 +168,12 @@ impl<'a> Reflector<'a> {\n               let (name, extra) = self.vstore_name_and_extra(t, vst);\n               self.visit(\"estr_\".to_owned() + name, extra.as_slice())\n           }\n-          ty::ty_vec(ty, vst) => {\n-              let (name, extra) = self.vstore_name_and_extra(t, vst);\n-              let extra = extra.append(self.c_mt(&ty::mt {\n-                  ty: ty,\n-                  mutbl: match vst {\n-                      ty::VstoreSlice(_, m) => m,\n-                      _ => ast::MutImmutable\n-                  }\n-              }).as_slice());\n-              self.visit(\"evec_\".to_owned() + name, extra.as_slice())\n+          ty::ty_vec(ref mt, Some(sz)) => {\n+              let extra = (vec!(self.c_uint(sz))).append(self.c_size_and_align(t).as_slice());\n+              let extra = extra.append(self.c_mt(mt).as_slice());\n+              self.visit(\"evec_fixed\".to_owned(), extra.as_slice())\n           }\n+          ty::ty_vec(..) => fail!(\"unexpected unsized vec\"),\n           // Should remove mt from box and uniq.\n           ty::ty_box(typ) => {\n               let extra = self.c_mt(&ty::mt {\n@@ -188,19 +183,37 @@ impl<'a> Reflector<'a> {\n               self.visit(\"box\", extra.as_slice())\n           }\n           ty::ty_uniq(typ) => {\n-              let extra = self.c_mt(&ty::mt {\n-                  ty: typ,\n-                  mutbl: ast::MutImmutable,\n-              });\n-              self.visit(\"uniq\", extra.as_slice())\n+              match ty::get(typ).sty {\n+                  ty::ty_vec(ref mt, None) => {\n+                      let (name, extra) = (~\"uniq\", Vec::new());\n+                      let extra = extra.append(self.c_mt(mt).as_slice());\n+                      self.visit(~\"evec_\" + name, extra.as_slice())\n+                  }\n+                  _ => {\n+                      let extra = self.c_mt(&ty::mt {\n+                          ty: typ,\n+                          mutbl: ast::MutImmutable,\n+                      });\n+                      self.visit(\"uniq\", extra.as_slice())\n+                  }\n+              }\n           }\n           ty::ty_ptr(ref mt) => {\n               let extra = self.c_mt(mt);\n               self.visit(\"ptr\", extra.as_slice())\n           }\n           ty::ty_rptr(_, ref mt) => {\n-              let extra = self.c_mt(mt);\n-              self.visit(\"rptr\", extra.as_slice())\n+              match ty::get(mt.ty).sty {\n+                  ty::ty_vec(ref mt, None) => {\n+                      let (name, extra) = (~\"slice\", Vec::new());\n+                      let extra = extra.append(self.c_mt(mt).as_slice());\n+                      self.visit(~\"evec_\" + name, extra.as_slice())\n+                  }\n+                  _ => {\n+                      let extra = self.c_mt(mt);\n+                      self.visit(\"rptr\", extra.as_slice())\n+                  }\n+              }\n           }\n \n           ty::ty_tup(ref tys) => {"}, {"sha": "4bcb609df616c9a76252c6b195cd5503520bc69a", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -162,8 +162,10 @@ pub fn trans_slice_vstore<'a>(\n         llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);\n \n         // Arrange for the backing array to be cleaned up.\n-        let fixed_ty = ty::mk_vec(bcx.tcx(), vt.unit_ty,\n-                                  ty::VstoreFixed(count));\n+        let fixed_ty = ty::mk_vec(bcx.tcx(),\n+                                  ty::mt {ty: vt.unit_ty,\n+                                          mutbl: ast::MutMutable},\n+                                  Some(count));\n         let llfixed_ty = type_of::type_of(bcx.ccx(), fixed_ty).ptr_to();\n         let llfixed_casted = BitCast(bcx, llfixed, llfixed_ty);\n         let cleanup_scope = cleanup::temporary_scope(bcx.tcx(), content_expr.id);\n@@ -461,6 +463,35 @@ pub fn get_fixed_base_and_byte_len(bcx: &Block,\n     (base, len)\n }\n \n+pub fn get_base_and_byte_len_for_vec(bcx: &Block,\n+                                     llval: ValueRef,\n+                                     vec_ty: ty::t)\n+                                     -> (ValueRef, ValueRef) {\n+    /*!\n+     * Converts a vector into the slice pair.  The vector should be\n+     * stored in `llval` which should be by ref. If you have a datum,\n+     * you would probably prefer to call\n+     * `Datum::get_base_and_byte_len()`.\n+     */\n+\n+    let ccx = bcx.ccx();\n+    let vt = vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty));\n+\n+    let size = match ty::get(vec_ty).sty {\n+        ty::ty_vec(_, size) => size,\n+        _ => ccx.sess().bug(\"non-vector in get_base_and_byte_len_for_vec\"),\n+    };\n+\n+    match size {\n+        Some(n) => {\n+            let base = GEPi(bcx, llval, [0u, 0u]);\n+            let len = Mul(bcx, C_uint(ccx, n), vt.llunit_size);\n+            (base, len)\n+        }\n+        None => ccx.sess().bug(\"unsized vector in get_base_and_byte_len_for_vec\")\n+    }\n+}\n+\n pub fn get_base_and_len(bcx: &Block,\n                         llval: ValueRef,\n                         vec_ty: ty::t)\n@@ -477,16 +508,17 @@ pub fn get_base_and_len(bcx: &Block,\n     let vt = vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty));\n \n     let vstore = match ty::get(vec_ty).sty {\n-        ty::ty_vec(_, vst) => vst,\n-        ty::ty_str(vst) => {\n-            // Convert from immutable-only-Vstore to Vstore.\n-            match vst {\n-                ty::VstoreFixed(n) => ty::VstoreFixed(n),\n-                ty::VstoreSlice(r, ()) => ty::VstoreSlice(r, ast::MutImmutable),\n-                ty::VstoreUniq => ty::VstoreUniq\n-            }\n-        }\n-        _ => ty::VstoreUniq\n+        ty::ty_str(vst) => vst,\n+        ty::ty_vec(_, Some(n)) => ty::VstoreFixed(n),\n+        ty::ty_rptr(r, mt) => match ty::get(mt.ty).sty {\n+            ty::ty_vec(_, None) => ty::VstoreSlice(r),\n+            _ => ccx.sess().bug(\"unexpected type (ty_rptr) in get_base_and_len\"),\n+        },\n+        ty::ty_uniq(t) => match ty::get(t).sty {\n+            ty::ty_vec(_, None) => ty::VstoreUniq,\n+            _ => ccx.sess().bug(\"unexpected type (ty_uniq) in get_base_and_len\"),\n+        },\n+        _ => ccx.sess().bug(\"unexpected type in get_base_and_len\"),\n     };\n \n     match vstore {"}, {"sha": "48c25fb985d83c8201328575c9de06798e309765", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -117,14 +117,17 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         ty::ty_float(t) => Type::float_from_ty(cx, t),\n \n         ty::ty_str(ty::VstoreUniq) |\n-        ty::ty_vec(_, ty::VstoreUniq) |\n         ty::ty_box(..) |\n         ty::ty_uniq(..) |\n-        ty::ty_ptr(..) |\n-        ty::ty_rptr(..) => Type::i8p(cx),\n+        ty::ty_ptr(..) => Type::i8p(cx),\n+        ty::ty_rptr(_, mt) => {\n+            match ty::get(mt.ty).sty {\n+                ty::ty_vec(_, None) => Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false),\n+                _ => Type::i8p(cx),\n+            }\n+        }\n \n-        ty::ty_str(ty::VstoreSlice(..)) |\n-        ty::ty_vec(_, ty::VstoreSlice(..)) => {\n+        ty::ty_str(ty::VstoreSlice(..)) => {\n             Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false)\n         }\n \n@@ -133,8 +136,8 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         ty::ty_trait(..) => Type::opaque_trait(cx),\n \n         ty::ty_str(ty::VstoreFixed(size)) => Type::array(&Type::i8(cx), size as u64),\n-        ty::ty_vec(ty, ty::VstoreFixed(size)) => {\n-            Type::array(&sizing_type_of(cx, ty), size as u64)\n+        ty::ty_vec(mt, Some(size)) => {\n+            Type::array(&sizing_type_of(cx, mt.ty), size as u64)\n         }\n \n         ty::ty_tup(..) | ty::ty_enum(..) => {\n@@ -153,7 +156,8 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n             }\n         }\n \n-        ty::ty_self(_) | ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n+        ty::ty_self(_) | ty::ty_infer(..) | ty::ty_param(..) |\n+        ty::ty_err(..) | ty::ty_vec(_, None) => {\n             cx.sess().bug(format!(\"fictitious type {:?} in sizing_type_of()\",\n                                   ty::get(t).sty))\n         }\n@@ -215,18 +219,21 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           Type::at_box(cx, type_of(cx, typ)).ptr_to()\n       }\n       ty::ty_uniq(typ) => {\n-          type_of(cx, typ).ptr_to()\n-      }\n-      ty::ty_vec(ty, ty::VstoreUniq) => {\n-          Type::vec(cx, &type_of(cx, ty)).ptr_to()\n+          match ty::get(typ).sty {\n+              ty::ty_vec(mt, None) => Type::vec(cx, &type_of(cx, mt.ty)).ptr_to(),\n+              _ => type_of(cx, typ).ptr_to(),\n+          }\n       }\n       ty::ty_ptr(ref mt) => type_of(cx, mt.ty).ptr_to(),\n-      ty::ty_rptr(_, ref mt) => type_of(cx, mt.ty).ptr_to(),\n-\n-      ty::ty_vec(ty, ty::VstoreSlice(..)) => {\n-          let p_ty = type_of(cx, ty).ptr_to();\n-          let u_ty = Type::uint_from_ty(cx, ast::TyU);\n-          Type::struct_(cx, [p_ty, u_ty], false)\n+      ty::ty_rptr(_, ref mt) => {\n+          match ty::get(mt.ty).sty {\n+              ty::ty_vec(mt, None) => {\n+                  let p_ty = type_of(cx, mt.ty).ptr_to();\n+                  let u_ty = Type::uint_from_ty(cx, ast::TyU);\n+                  Type::struct_(cx, [p_ty, u_ty], false)\n+              }\n+              _ => type_of(cx, mt.ty).ptr_to(),\n+          }\n       }\n \n       ty::ty_str(ty::VstoreSlice(..)) => {\n@@ -238,8 +245,8 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           Type::array(&Type::i8(cx), (n + 1u) as u64)\n       }\n \n-      ty::ty_vec(ty, ty::VstoreFixed(n)) => {\n-          Type::array(&type_of(cx, ty), n as u64)\n+      ty::ty_vec(ref mt, Some(n)) => {\n+          Type::array(&type_of(cx, mt.ty), n as u64)\n       }\n \n       ty::ty_bare_fn(_) => {\n@@ -271,7 +278,9 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n               adt::incomplete_type_of(cx, repr, name)\n           }\n       }\n-      ty::ty_self(..) => cx.sess().unimpl(\"type_of: ty_self\"),\n+\n+      ty::ty_vec(_, None) => cx.sess().bug(\"type_of with unszied ty_vec\"),\n+      ty::ty_self(..) => cx.sess().unimpl(\"type_of with ty_self\"),\n       ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),\n       ty::ty_param(..) => cx.sess().bug(\"type_of with ty_param\"),\n       ty::ty_err(..) => cx.sess().bug(\"type_of with ty_err\")"}, {"sha": "04d73e12f3704c3c7a3b089da769f6c23079ed69", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 103, "deletions": 62, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -130,16 +130,14 @@ pub struct mt {\n }\n \n #[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash, Show)]\n-/// Describes the \"storage mode\" of a `[]`, whether it's fixed length or a slice.\n-///\n-/// Set M to () to disable mutable slices.\n-pub enum Vstore<M = ast::Mutability> {\n+/// Describes the \"storage mode\" of a str, whether it's fixed length or a slice.\n+pub enum Vstore {\n     /// [T, ..N]\n     VstoreFixed(uint),\n     /// ~[T]\n     VstoreUniq,\n     /// &[T] and &mut [T]\n-    VstoreSlice(Region, M)\n+    VstoreSlice(Region)\n }\n \n #[deriving(Clone, Eq, TotalEq, Hash, Encodable, Decodable, Show)]\n@@ -735,8 +733,8 @@ pub enum sty {\n     ty_enum(DefId, substs),\n     ty_box(t),\n     ty_uniq(t),\n-    ty_str(Vstore<()>),\n-    ty_vec(t, Vstore),\n+    ty_str(Vstore),\n+    ty_vec(mt, Option<uint>),\n     ty_ptr(mt),\n     ty_rptr(Region, mt),\n     ty_bare_fn(BareFnTy),\n@@ -813,7 +811,7 @@ pub enum type_err {\n     terr_regions_no_overlap(Region, Region),\n     terr_regions_insufficiently_polymorphic(BoundRegion, Region),\n     terr_regions_overly_polymorphic(BoundRegion, Region),\n-    terr_vstores_differ(terr_vstore_kind, expected_found<Vstore<()>>),\n+    terr_vstores_differ(terr_vstore_kind, expected_found<Vstore>),\n     terr_trait_stores_differ(terr_vstore_kind, expected_found<TraitStore>),\n     terr_in_field(@type_err, ast::Ident),\n     terr_sorts(expected_found<t>),\n@@ -1179,12 +1177,8 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n         return f;\n     }\n     match &st {\n-      &ty_str(VstoreSlice(r, ())) => {\n-        flags |= rflags(r);\n-      }\n-      &ty_vec(ty, VstoreSlice(r, _)) => {\n+      &ty_str(VstoreSlice(r)) => {\n         flags |= rflags(r);\n-        flags |= get(ty).flags;\n       }\n       &ty_nil | &ty_bool | &ty_char | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n       &ty_str(_) => {}\n@@ -1212,10 +1206,10 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n               _ => {}\n           }\n       }\n-      &ty_box(tt) | &ty_uniq(tt) | &ty_vec(tt, _) => {\n+      &ty_box(tt) | &ty_uniq(tt) => {\n         flags |= get(tt).flags\n       }\n-      &ty_ptr(ref m) => {\n+      &ty_ptr(ref m) | &ty_vec(ref m, _) => {\n         flags |= get(m.ty).flags;\n       }\n       &ty_rptr(r, ref m) => {\n@@ -1349,7 +1343,7 @@ pub fn mk_mach_float(tm: ast::FloatTy) -> t {\n #[inline]\n pub fn mk_char() -> t { mk_prim_t(&primitives::TY_CHAR) }\n \n-pub fn mk_str(cx: &ctxt, v: Vstore<()>) -> t {\n+pub fn mk_str(cx: &ctxt, v: Vstore) -> t {\n     mk_t(cx, ty_str(v))\n }\n \n@@ -1385,8 +1379,16 @@ pub fn mk_nil_ptr(cx: &ctxt) -> t {\n     mk_ptr(cx, mt {ty: mk_nil(), mutbl: ast::MutImmutable})\n }\n \n-pub fn mk_vec(cx: &ctxt, ty: t, v: Vstore) -> t {\n-    mk_t(cx, ty_vec(ty, v))\n+pub fn mk_vec(cx: &ctxt, tm: mt, sz: Option<uint>) -> t {\n+    mk_t(cx, ty_vec(tm, sz))\n+}\n+\n+pub fn mk_slice(cx: &ctxt, r: Region, tm: mt) -> t {\n+    mk_rptr(cx, r,\n+            mt {\n+                ty: mk_vec(cx, tm, None),\n+                mutbl: tm.mutbl\n+            })\n }\n \n pub fn mk_tup(cx: &ctxt, ts: Vec<t>) -> t { mk_t(cx, ty_tup(ts)) }\n@@ -1465,8 +1467,8 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n         ty_str(_) | ty_self(_) |\n         ty_infer(_) | ty_param(_) | ty_err => {}\n-        ty_box(ty) | ty_uniq(ty) | ty_vec(ty, _) => maybe_walk_ty(ty, f),\n-        ty_ptr(ref tm) | ty_rptr(_, ref tm) => {\n+        ty_box(ty) | ty_uniq(ty) => maybe_walk_ty(ty, f),\n+        ty_ptr(ref tm) | ty_rptr(_, ref tm) | ty_vec(ref tm, _) => {\n             maybe_walk_ty(tm.ty, f);\n         }\n         ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n@@ -1601,13 +1603,23 @@ pub fn type_is_self(ty: t) -> bool {\n     }\n }\n \n+fn type_is_slice(ty:t) -> bool {\n+    match get(ty).sty {\n+        ty_rptr(_, mt) => match get(mt.ty).sty {\n+            ty_vec(_, None) => true,\n+            _ => false,\n+        },\n+        _ => false\n+    }\n+}\n+\n pub fn type_is_structural(ty: t) -> bool {\n     match get(ty).sty {\n       ty_struct(..) | ty_tup(_) | ty_enum(..) | ty_closure(_) | ty_trait(..) |\n-      ty_vec(_, VstoreFixed(_)) | ty_str(VstoreFixed(_)) |\n-      ty_vec(_, VstoreSlice(..)) | ty_str(VstoreSlice(..))\n+      ty_vec(_, Some(_)) |\n+      ty_str(VstoreFixed(_)) | ty_str(VstoreSlice(_))\n       => true,\n-      _ => false\n+      _ => type_is_slice(ty)\n     }\n }\n \n@@ -1621,7 +1633,12 @@ pub fn type_is_simd(cx: &ctxt, ty: t) -> bool {\n pub fn sequence_element_type(cx: &ctxt, ty: t) -> t {\n     match get(ty).sty {\n         ty_str(_) => mk_mach_uint(ast::TyU8),\n-        ty_vec(ty, _) => ty,\n+        ty_vec(mt, _) => mt.ty,\n+        ty_ptr(mt{ty: t, ..}) | ty_rptr(_, mt{ty: t, ..}) |\n+        ty_box(t) | ty_uniq(t) => match get(t).sty {\n+            ty_vec(mt, None) => mt.ty,\n+            _ => cx.sess.bug(\"sequence_element_type called on non-sequence value\"),\n+        },\n         _ => cx.sess.bug(\"sequence_element_type called on non-sequence value\"),\n     }\n }\n@@ -1655,8 +1672,13 @@ pub fn type_is_boxed(ty: t) -> bool {\n \n pub fn type_is_region_ptr(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_rptr(_, _) => true,\n-      _ => false\n+        ty_rptr(_, mt) => match get(mt.ty).sty {\n+            // FIXME(nrc, DST) slices weren't regarded as rptrs, so we preserve this\n+            // odd behaviour for now. (But ~[] were unique. I have no idea why).\n+            ty_vec(_, None) => false,\n+            _ => true\n+        },\n+        _ => false\n     }\n }\n \n@@ -1669,7 +1691,7 @@ pub fn type_is_unsafe_ptr(ty: t) -> bool {\n \n pub fn type_is_unique(ty: t) -> bool {\n     match get(ty).sty {\n-        ty_uniq(_) | ty_vec(_, VstoreUniq) | ty_str(VstoreUniq) => true,\n+        ty_uniq(_) | ty_str(VstoreUniq) => true,\n         _ => false\n     }\n }\n@@ -1743,8 +1765,7 @@ fn type_needs_unwind_cleanup_(cx: &ctxt, ty: t,\n             !needs_unwind_cleanup\n           }\n           ty_uniq(_) |\n-          ty_str(VstoreUniq) |\n-          ty_vec(_, VstoreUniq) => {\n+          ty_str(VstoreUniq) => {\n             // Once we're inside a box, the annihilator will find\n             // it and destroy it.\n             if !encountered_box {\n@@ -2086,19 +2107,11 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                     borrowed_contents(r, mt.mutbl))\n             }\n \n-            ty_vec(ty, VstoreUniq) => {\n-                tc_ty(cx, ty, cache).owned_pointer()\n-            }\n-\n-            ty_vec(ty, VstoreSlice(r, mutbl)) => {\n-                tc_ty(cx, ty, cache).reference(borrowed_contents(r, mutbl))\n-            }\n-\n-            ty_vec(ty, VstoreFixed(_)) => {\n-                tc_ty(cx, ty, cache)\n+            ty_vec(mt, _) => {\n+                tc_mt(cx, mt, cache)\n             }\n \n-            ty_str(VstoreSlice(r, ())) => {\n+            ty_str(VstoreSlice(r)) => {\n                 borrowed_contents(r, ast::MutImmutable)\n             }\n \n@@ -2321,8 +2334,8 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n             // fixed length vectors need special treatment compared to\n             // normal vectors, since they don't necessarily have the\n             // possibilty to have length zero.\n-            ty_vec(_, VstoreFixed(0)) => false, // don't need no contents\n-            ty_vec(ty, VstoreFixed(_)) => type_requires(cx, seen, r_ty, ty),\n+            ty_vec(_, Some(0)) => false, // don't need no contents\n+            ty_vec(mt, Some(_)) => type_requires(cx, seen, r_ty, mt.ty),\n \n             ty_nil |\n             ty_bot |\n@@ -2338,7 +2351,7 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n             ty_err |\n             ty_param(_) |\n             ty_self(_) |\n-            ty_vec(_, _) => {\n+            ty_vec(_, None) => {\n                 false\n             }\n             ty_box(typ) | ty_uniq(typ) => {\n@@ -2459,8 +2472,8 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n             }\n             // Fixed-length vectors.\n             // FIXME(#11924) Behavior undecided for zero-length vectors.\n-            ty_vec(ty, VstoreFixed(_)) => {\n-                type_structurally_recursive(cx, sp, seen, ty)\n+            ty_vec(mt, Some(_)) => {\n+                type_structurally_recursive(cx, sp, seen, mt.ty)\n             }\n \n             // Push struct and enum def-ids onto `seen` before recursing.\n@@ -2604,21 +2617,34 @@ pub fn type_is_c_like_enum(cx: &ctxt, ty: t) -> bool {\n // Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n pub fn deref(t: t, explicit: bool) -> Option<mt> {\n     match get(t).sty {\n-        ty_box(typ) | ty_uniq(typ) => Some(mt {\n-            ty: typ,\n-            mutbl: ast::MutImmutable,\n-        }),\n-        ty_rptr(_, mt) => Some(mt),\n+        ty_box(typ) | ty_uniq(typ) => match get(typ).sty {\n+            // Don't deref ~[] etc., might need to generalise this to all DST.\n+            ty_vec(_, None) => None,\n+            _ => Some(mt {\n+                ty: typ,\n+                mutbl: ast::MutImmutable,\n+            }),\n+        },\n+        ty_rptr(_, mt) => match get(mt.ty).sty {\n+            // Don't deref &[], might need to generalise this to all DST.\n+            ty_vec(_, None) => None,\n+            _ => Some(mt),\n+        },\n         ty_ptr(mt) if explicit => Some(mt),\n         _ => None\n     }\n }\n \n // Returns the type of t[i]\n-pub fn index(t: t) -> Option<t> {\n+pub fn index(t: t) -> Option<mt> {\n     match get(t).sty {\n-        ty_vec(ty, _) => Some(ty),\n-        ty_str(_) => Some(mk_u8()),\n+        ty_vec(mt, _) => Some(mt),\n+        ty_ptr(mt{ty: t, ..}) | ty_rptr(_, mt{ty: t, ..}) |\n+        ty_box(t) | ty_uniq(t) => match get(t).sty {\n+            ty_vec(mt, None) => Some(mt),\n+            _ => None,\n+        },\n+        ty_str(_) => Some(mt {ty: mk_u8(), mutbl: ast::MutImmutable}),\n         _ => None\n     }\n }\n@@ -2723,8 +2749,7 @@ pub fn ty_region(tcx: &ctxt,\n                  ty: t) -> Region {\n     match get(ty).sty {\n         ty_rptr(r, _) => r,\n-        ty_vec(_, VstoreSlice(r, _)) => r,\n-        ty_str(VstoreSlice(r, ())) => r,\n+        ty_str(VstoreSlice(r)) => r,\n         ref s => {\n             tcx.sess.span_bug(\n                 span,\n@@ -2929,12 +2954,22 @@ pub fn adjust_ty(cx: &ctxt,\n                   r: Region, m: ast::Mutability,\n                   ty: ty::t) -> ty::t {\n         match get(ty).sty {\n-            ty_vec(ty, _) => {\n-                ty::mk_vec(cx, ty, VstoreSlice(r, m))\n+            ty_uniq(t) | ty_ptr(mt{ty: t, ..}) |\n+            ty_rptr(_, mt{ty: t, ..}) => match get(t).sty {\n+                ty::ty_vec(mt, None) => ty::mk_slice(cx, r, ty::mt {ty: mt.ty, mutbl: m}),\n+                ref s => {\n+                    cx.sess.span_bug(\n+                        span,\n+                        format!(\"borrow-vec associated with bad sty: {:?}\",\n+                             s));\n+                }\n+            },\n+            ty_vec(mt, Some(_)) => {\n+                ty::mk_slice(cx, r, ty::mt {ty: mt.ty, mutbl: m})\n             }\n \n             ty_str(_) => {\n-                ty::mk_str(cx, VstoreSlice(r, ()))\n+                ty::mk_str(cx, VstoreSlice(r))\n             }\n \n             ref s => {\n@@ -4152,10 +4187,10 @@ pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n             return t_norm;\n         }\n \n-        fn fold_vstore<M>(&mut self, vstore: Vstore<M>) -> Vstore<M> {\n+        fn fold_vstore(&mut self, vstore: Vstore) -> Vstore {\n             match vstore {\n                 VstoreFixed(..) | VstoreUniq => vstore,\n-                VstoreSlice(_, m) => VstoreSlice(ReStatic, m)\n+                VstoreSlice(_) => VstoreSlice(ReStatic)\n             }\n         }\n \n@@ -4575,9 +4610,15 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n             ty_uniq(_) => {\n                 byte!(10);\n             }\n-            ty_vec(_, v) => {\n+            ty_vec(m, Some(_)) => {\n                 byte!(11);\n-                hash!(v);\n+                mt(&mut state, m);\n+                1u8.hash(&mut state);\n+            }\n+            ty_vec(m, None) => {\n+                byte!(11);\n+                mt(&mut state, m);\n+                0u8.hash(&mut state);\n             }\n             ty_ptr(m) => {\n                 byte!(12);"}, {"sha": "70e14d844e99948807551d9551de34e9bd80adb5", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -68,7 +68,7 @@ pub trait TypeFolder {\n         r\n     }\n \n-    fn fold_vstore<M>(&mut self, vstore: ty::Vstore<M>) -> ty::Vstore<M> {\n+    fn fold_vstore(&mut self, vstore: ty::Vstore) -> ty::Vstore {\n         super_fold_vstore(self, vstore)\n     }\n \n@@ -147,8 +147,8 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n         ty::ty_ptr(ref tm) => {\n             ty::ty_ptr(this.fold_mt(tm))\n         }\n-        ty::ty_vec(ty, vst) => {\n-            ty::ty_vec(this.fold_ty(ty), this.fold_vstore(vst))\n+        ty::ty_vec(ref tm, sz) => {\n+            ty::ty_vec(this.fold_mt(tm), sz)\n         }\n         ty::ty_enum(tid, ref substs) => {\n             ty::ty_enum(tid, this.fold_substs(substs))\n@@ -191,13 +191,13 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n     }\n }\n \n-pub fn super_fold_vstore<T:TypeFolder, M>(this: &mut T,\n-                                          vstore: ty::Vstore<M>)\n-                                          -> ty::Vstore<M> {\n+pub fn super_fold_vstore<T:TypeFolder>(this: &mut T,\n+                                       vstore: ty::Vstore)\n+                                       -> ty::Vstore {\n     match vstore {\n         ty::VstoreFixed(i) => ty::VstoreFixed(i),\n         ty::VstoreUniq => ty::VstoreUniq,\n-        ty::VstoreSlice(r, m) => ty::VstoreSlice(this.fold_region(r), m),\n+        ty::VstoreSlice(r) => ty::VstoreSlice(this.fold_region(r)),\n     }\n }\n "}, {"sha": "40f69c8c0904e71924a47ee2ebb29480b101eebf", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -389,25 +389,33 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n         }\n     }\n \n+    fn ast_ty_to_mt<AC:AstConv, RS:RegionScope>(this: &AC,\n+                                                rscope: &RS,\n+                                                ty: &ast::Ty) -> ty::mt {\n+        ty::mt {ty: ast_ty_to_ty(this, rscope, ty), mutbl: ast::MutImmutable}\n+    }\n+\n     // Handle ~, and & being able to mean strs and vecs.\n     // If a_seq_ty is a str or a vec, make it a str/vec.\n     // Also handle first-class trait types.\n     fn mk_pointer<AC:AstConv,\n                   RS:RegionScope>(\n                   this: &AC,\n                   rscope: &RS,\n-                  a_seq_ty: &ast::Ty,\n+                  a_seq_ty: &ast::MutTy,\n                   ptr_ty: PointerTy,\n                   constr: |ty::t| -> ty::t)\n                   -> ty::t {\n         let tcx = this.tcx();\n         debug!(\"mk_pointer(ptr_ty={:?})\", ptr_ty);\n \n-        match a_seq_ty.node {\n+        match a_seq_ty.ty.node {\n             ast::TyVec(ty) => {\n-                let vst = ptr_ty.expect_vstore(tcx, a_seq_ty.span, \"vectors\");\n-                debug!(\"&[]: vst={:?}\", vst);\n-                return ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, ty), vst);\n+                let mut mt = ast_ty_to_mt(this, rscope, ty);\n+                if a_seq_ty.mutbl == ast::MutMutable {\n+                    mt.mutbl = ast::MutMutable;\n+                }\n+                return constr(ty::mk_vec(tcx, mt, None));\n             }\n             ast::TyPath(ref path, ref bounds, id) => {\n                 // Note that the \"bounds must be empty if path is not a trait\"\n@@ -421,8 +429,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                             ty::VstoreUniq => {\n                                 return ty::mk_str(tcx, ty::VstoreUniq);\n                             }\n-                            ty::VstoreSlice(r, ast::MutImmutable) => {\n-                                return ty::mk_str(tcx, ty::VstoreSlice(r, ()));\n+                            ty::VstoreSlice(r) => {\n+                                return ty::mk_str(tcx, ty::VstoreSlice(r));\n                             }\n                             _ => {}\n                         }\n@@ -432,8 +440,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                             this, rscope, trait_def_id, None, path);\n                         let trait_store = match ptr_ty {\n                             VStore(ty::VstoreUniq) => ty::UniqTraitStore,\n-                            VStore(ty::VstoreSlice(r, m)) => {\n-                                ty::RegionTraitStore(r, m)\n+                            VStore(ty::VstoreSlice(r)) => {\n+                                ty::RegionTraitStore(r, a_seq_ty.mutbl)\n                             }\n                             _ => {\n                                 tcx.sess.span_err(\n@@ -456,7 +464,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n             _ => {}\n         }\n \n-        constr(ast_ty_to_ty(this, rscope, a_seq_ty))\n+        constr(ast_ty_to_ty(this, rscope, a_seq_ty.ty))\n     }\n \n     let tcx = this.tcx();\n@@ -479,16 +487,19 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n             ast::TyNil => ty::mk_nil(),\n             ast::TyBot => ty::mk_bot(),\n             ast::TyBox(ty) => {\n-                mk_pointer(this, rscope, ty, Box, |ty| ty::mk_box(tcx, ty))\n+                let mt = ast::MutTy { ty: ty, mutbl: ast::MutImmutable };\n+                mk_pointer(this, rscope, &mt, Box, |ty| ty::mk_box(tcx, ty))\n             }\n             ast::TyUniq(ty) => {\n-                mk_pointer(this, rscope, ty, VStore(ty::VstoreUniq),\n+                let mt = ast::MutTy { ty: ty, mutbl: ast::MutImmutable };\n+                mk_pointer(this, rscope, &mt, VStore(ty::VstoreUniq),\n                            |ty| ty::mk_uniq(tcx, ty))\n             }\n             ast::TyVec(ty) => {\n                 tcx.sess.span_err(ast_ty.span, \"bare `[]` is not a type\");\n                 // return /something/ so they can at least get more errors\n-                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, ty), ty::VstoreUniq)\n+                let vec_ty = ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty), None);\n+                ty::mk_uniq(tcx, vec_ty)\n             }\n             ast::TyPtr(ref mt) => {\n                 ty::mk_ptr(tcx, ty::mt {\n@@ -499,7 +510,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n             ast::TyRptr(ref region, ref mt) => {\n                 let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n                 debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n-                mk_pointer(this, rscope, &*mt.ty, VStore(ty::VstoreSlice(r, mt.mutbl)),\n+                mk_pointer(this, rscope, mt, VStore(ty::VstoreSlice(r)),\n                            |ty| ty::mk_rptr(tcx, r, ty::mt {ty: ty, mutbl: mt.mutbl}))\n             }\n             ast::TyTup(ref fields) => {\n@@ -612,11 +623,11 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                     Ok(ref r) => {\n                         match *r {\n                             const_eval::const_int(i) =>\n-                                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, ty),\n-                                           ty::VstoreFixed(i as uint)),\n+                                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty),\n+                                           Some(i as uint)),\n                             const_eval::const_uint(i) =>\n-                                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, ty),\n-                                           ty::VstoreFixed(i as uint)),\n+                                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty),\n+                                           Some(i as uint)),\n                             _ => {\n                                 tcx.sess.span_fatal(\n                                     ast_ty.span, \"expected constant expr for vector length\");"}, {"sha": "286c8d1775107ef67df3cdd8cecec940a6a91f76", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 49, "deletions": 40, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -616,48 +616,58 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n             fcx.infcx().next_region_var(\n                 infer::PatternRegion(pat.span));\n \n+        let check_err = || {\n+            for &elt in before.iter() {\n+                check_pat(pcx, elt, ty::mk_err());\n+            }\n+            for &elt in slice.iter() {\n+                check_pat(pcx, elt, ty::mk_err());\n+            }\n+            for &elt in after.iter() {\n+                check_pat(pcx, elt, ty::mk_err());\n+            }\n+            // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n+            fcx.infcx().type_error_message_str_with_expected(\n+                pat.span,\n+                |expected, actual| {\n+                    expected.map_or(\"\".to_owned(), |e| {\n+                        format!(\"mismatched types: expected `{}` but found {}\",\n+                             e, actual)})},\n+                Some(expected),\n+                \"a vector pattern\".to_owned(),\n+                None);\n+            fcx.write_error(pat.id);\n+        };\n+\n         let (elt_type, region_var, mutbl) = match *structure_of(fcx,\n                                                                 pat.span,\n                                                                 expected) {\n-          ty::ty_vec(ty, vstore) => {\n-            match vstore {\n-                ty::VstoreSlice(r, m) => (ty, r, m),\n-                ty::VstoreUniq => {\n-                    fcx.type_error_message(pat.span,\n-                                           |_| {\n-                                            ~\"unique vector patterns are no \\\n-                                              longer supported\"\n-                                           },\n-                                           expected,\n-                                           None);\n-                    (ty, default_region_var, ast::MutImmutable)\n-                }\n-                ty::VstoreFixed(_) => {\n-                    (ty, default_region_var, ast::MutImmutable)\n-                }\n-            }\n-          }\n-          _ => {\n-              for &elt in before.iter() {\n-                  check_pat(pcx, elt, ty::mk_err());\n+          ty::ty_vec(mt, Some(_)) => (mt.ty, default_region_var, ast::MutImmutable),\n+          ty::ty_uniq(t) => match ty::get(t).sty {\n+              ty::ty_vec(mt, None) => {\n+                  fcx.type_error_message(pat.span,\n+                                         |_| {\n+                                          ~\"unique vector patterns are no \\\n+                                            longer supported\"\n+                                         },\n+                                         expected,\n+                                         None);\n+                  (mt.ty, default_region_var, ast::MutImmutable)\n               }\n-              for &elt in slice.iter() {\n-                  check_pat(pcx, elt, ty::mk_err());\n+              _ => {\n+                  check_err();\n+                  return;\n               }\n-              for &elt in after.iter() {\n-                  check_pat(pcx, elt, ty::mk_err());\n+          },\n+          ty::ty_rptr(r, mt) => match ty::get(mt.ty).sty {\n+              ty::ty_vec(mt, None) => (mt.ty, r, mt.mutbl),\n+              _ => {\n+                  check_err();\n+                  return;\n               }\n-              // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n-              fcx.infcx().type_error_message_str_with_expected(\n-                  pat.span,\n-                  |expected, actual| {\n-                      expected.map_or(\"\".to_owned(), |e| {\n-                          format!(\"mismatched types: expected `{}` but found {}\",\n-                               e, actual)})},\n-                  Some(expected),\n-                  \"a vector pattern\".to_owned(),\n-                  None);\n-              fcx.write_error(pat.id);\n+          },\n+          _ => {\n+              check_err();\n               return;\n           }\n         };\n@@ -666,10 +676,9 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         }\n         match slice {\n             Some(slice_pat) => {\n-                let slice_ty = ty::mk_vec(tcx,\n-                    elt_type,\n-                    ty::VstoreSlice(region_var, mutbl)\n-                );\n+                let slice_ty = ty::mk_slice(tcx,\n+                                            region_var,\n+                                            ty::mt {ty: elt_type, mutbl: mutbl});\n                 check_pat(pcx, slice_pat, slice_ty);\n             }\n             None => ()"}, {"sha": "178d3c8b54438e7f267a69d696178bd6a393dc26", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 62, "deletions": 40, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -93,6 +93,7 @@ use middle::typeck::{MethodStatic, MethodObject};\n use middle::typeck::{param_numbered, param_self, param_index};\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use util::common::indenter;\n+use util::ppaux;\n use util::ppaux::Repr;\n \n use collections::HashSet;\n@@ -332,6 +333,7 @@ impl<'a> LookupContext<'a> {\n     fn search(&self, self_ty: ty::t) -> Option<MethodCallee> {\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         let self_expr_id = self.self_expr.map(|e| e.id);\n+\n         let (self_ty, autoderefs, result) =\n             check::autoderef(\n                 self.fcx, span, self_ty, self_expr_id, PreferMutLvalue,\n@@ -721,7 +723,7 @@ impl<'a> LookupContext<'a> {\n             None => None,\n             Some(method) => {\n                 debug!(\"(searching for autoderef'd method) writing \\\n-                       adjustment {:?}\", adjustment);\n+                       adjustment {:?} for {}\", adjustment, self.ty_to_str( self_ty));\n                 match adjustment {\n                     Some((self_expr_id, adj)) => {\n                         self.fcx.write_adjustment(self_expr_id, adj);\n@@ -765,19 +767,16 @@ impl<'a> LookupContext<'a> {\n             ty::ty_rptr(_, self_mt) => {\n                 let region =\n                     self.infcx().next_region_var(infer::Autoref(self.span));\n+                let (extra_derefs, auto) = match ty::get(self_mt.ty).sty {\n+                    ty::ty_vec(_, None) => (0, ty::AutoBorrowVec(region, self_mt.mutbl)),\n+                    _ => (1, ty::AutoPtr(region, self_mt.mutbl)),\n+                };\n                 (ty::mk_rptr(tcx, region, self_mt),\n                  ty::AutoDerefRef {\n-                     autoderefs: autoderefs+1,\n-                     autoref: Some(ty::AutoPtr(region, self_mt.mutbl))})\n-            }\n-            ty::ty_vec(self_ty, VstoreSlice(_, mutbl)) => {\n-                let region =\n-                    self.infcx().next_region_var(infer::Autoref(self.span));\n-                (ty::mk_vec(tcx, self_ty, VstoreSlice(region, mutbl)),\n-                 ty::AutoDerefRef {\n-                     autoderefs: autoderefs,\n-                     autoref: Some(ty::AutoBorrowVec(region, mutbl))})\n+                     autoderefs: autoderefs + extra_derefs,\n+                     autoref: Some(auto)})\n             }\n+\n             ty::ty_trait(~ty::TyTrait {\n                 def_id, ref substs, store: ty::RegionTraitStore(_, mutbl), bounds\n             }) => {\n@@ -808,6 +807,35 @@ impl<'a> LookupContext<'a> {\n         }\n     }\n \n+    fn auto_slice_vec(&self, mt: ty::mt, autoderefs: uint) -> Option<MethodCallee> {\n+        let tcx = self.tcx();\n+        debug!(\"auto_slice_vec {}\", ppaux::ty_to_str(tcx, mt.ty));\n+\n+        // First try to borrow to a slice\n+        let entry = self.search_for_some_kind_of_autorefd_method(\n+            AutoBorrowVec, autoderefs, [MutImmutable, MutMutable],\n+            |m,r| ty::mk_slice(tcx, r,\n+                               ty::mt {ty:mt.ty, mutbl:m}));\n+\n+        if entry.is_some() {\n+            return entry;\n+        }\n+\n+        // Then try to borrow to a slice *and* borrow a pointer.\n+        self.search_for_some_kind_of_autorefd_method(\n+            AutoBorrowVecRef, autoderefs, [MutImmutable, MutMutable],\n+            |m,r| {\n+                let slice_ty = ty::mk_slice(tcx, r,\n+                                            ty::mt {ty:mt.ty, mutbl:m});\n+                // NB: we do not try to autoref to a mutable\n+                // pointer. That would be creating a pointer\n+                // to a temporary pointer (the borrowed\n+                // slice), so any update the callee makes to\n+                // it can't be observed.\n+                ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:MutImmutable})\n+            })\n+    }\n+\n     fn search_for_autosliced_method(&self,\n                                     self_ty: ty::t,\n                                     autoderefs: uint)\n@@ -818,44 +846,32 @@ impl<'a> LookupContext<'a> {\n          */\n \n         let tcx = self.tcx();\n+        debug!(\"search_for_autosliced_method {}\", ppaux::ty_to_str(tcx, self_ty));\n+\n         let sty = ty::get(self_ty).sty.clone();\n         match sty {\n-            ty_vec(ty, VstoreUniq) |\n-            ty_vec(ty, VstoreSlice(..)) |\n-            ty_vec(ty, VstoreFixed(_)) => {\n-                // First try to borrow to a slice\n-                let entry = self.search_for_some_kind_of_autorefd_method(\n-                    AutoBorrowVec, autoderefs, [MutImmutable, MutMutable],\n-                    |m,r| ty::mk_vec(tcx, ty, VstoreSlice(r, m)));\n-\n-                if entry.is_some() { return entry; }\n-\n-                // Then try to borrow to a slice *and* borrow a pointer.\n-                self.search_for_some_kind_of_autorefd_method(\n-                    AutoBorrowVecRef, autoderefs, [MutImmutable, MutMutable],\n-                    |m,r| {\n-                        let slice_ty = ty::mk_vec(tcx, ty, VstoreSlice(r, m));\n-                        // NB: we do not try to autoref to a mutable\n-                        // pointer. That would be creating a pointer\n-                        // to a temporary pointer (the borrowed\n-                        // slice), so any update the callee makes to\n-                        // it can't be observed.\n-                        ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:MutImmutable})\n-                    })\n-            }\n+            ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n+                ty_vec(mt, None) => self.auto_slice_vec(mt, autoderefs),\n+                _ => None\n+            },\n+            ty_uniq(t) => match ty::get(t).sty {\n+                ty_vec(mt, None) => self.auto_slice_vec(mt, autoderefs),\n+                _ => None\n+            },\n+            ty_vec(mt, Some(_)) => self.auto_slice_vec(mt, autoderefs),\n \n             ty_str(VstoreUniq) |\n             ty_str(VstoreFixed(_)) => {\n                 let entry = self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowVec, autoderefs, [MutImmutable],\n-                    |_m,r| ty::mk_str(tcx, VstoreSlice(r, ())));\n+                    |_m,r| ty::mk_str(tcx, VstoreSlice(r)));\n \n                 if entry.is_some() { return entry; }\n \n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowVecRef, autoderefs, [MutImmutable],\n                     |m,r| {\n-                        let slice_ty = ty::mk_str(tcx, VstoreSlice(r, ()));\n+                        let slice_ty = ty::mk_str(tcx, VstoreSlice(r));\n                         ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:m})\n                     })\n             }\n@@ -1163,7 +1179,7 @@ impl<'a> LookupContext<'a> {\n         });\n         debug!(\"after replacing bound regions, fty={}\", self.ty_to_str(fty));\n \n-        // before we only checked whether self_ty could be a subtype\n+        // Before, we only checked whether self_ty could be a subtype\n         // of rcvr_ty; now we actually make it so (this may cause\n         // variables to unify etc).  Since we checked beforehand, and\n         // nothing has changed in the meantime, this unification\n@@ -1293,8 +1309,11 @@ impl<'a> LookupContext<'a> {\n                 debug!(\"(is relevant?) explicit self is a region\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_rptr(_, mt) => {\n-                        mutability_matches(mt.mutbl, m) &&\n-                        rcvr_matches_ty(self.fcx, mt.ty, candidate)\n+                        match ty::get(mt.ty).sty {\n+                            ty::ty_vec(_, None) => false,\n+                            _ => mutability_matches(mt.mutbl, m) &&\n+                                 rcvr_matches_ty(self.fcx, mt.ty, candidate),\n+                        }\n                     }\n \n                     ty::ty_trait(~ty::TyTrait {\n@@ -1312,7 +1331,10 @@ impl<'a> LookupContext<'a> {\n                 debug!(\"(is relevant?) explicit self is a unique pointer\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(typ) => {\n-                        rcvr_matches_ty(self.fcx, typ, candidate)\n+                        match ty::get(typ).sty {\n+                            ty::ty_vec(_, None) => false,\n+                            _ => rcvr_matches_ty(self.fcx, typ, candidate),\n+                        }\n                     }\n \n                     ty::ty_trait(~ty::TyTrait {"}, {"sha": "65c335a24211446af7d9aef41d76415efff961b8", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 52, "deletions": 21, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -1286,10 +1286,9 @@ pub fn check_lit(fcx: &FnCtxt, lit: &ast::Lit) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n-        ast::LitStr(..) => ty::mk_str(tcx, ty::VstoreSlice(ty::ReStatic, ())),\n+        ast::LitStr(..) => ty::mk_str(tcx, ty::VstoreSlice(ty::ReStatic)),\n         ast::LitBinary(..) => {\n-            ty::mk_vec(tcx, ty::mk_u8(),\n-                       ty::VstoreSlice(ty::ReStatic, ast::MutImmutable))\n+            ty::mk_slice(tcx, ty::ReStatic, ty::mt{ ty: ty::mk_u8(), mutbl: ast::MutImmutable })\n         }\n         ast::LitChar(_) => ty::mk_char(),\n         ast::LitInt(_, t) => ty::mk_mach_int(t),\n@@ -2458,15 +2457,15 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprVstore(ev, vst) => {\n         let typ = match ev.node {\n           ast::ExprLit(lit) if ast_util::lit_is_str(lit) => {\n-            let v = ast_expr_vstore_to_vstore(fcx, ev, vst, ());\n+            let v = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             ty::mk_str(tcx, v)\n           }\n           ast::ExprVec(ref args) => {\n             let mutability = match vst {\n                 ast::ExprVstoreMutSlice => ast::MutMutable,\n                 _ => ast::MutImmutable,\n             };\n-            let v = ast_expr_vstore_to_vstore(fcx, ev, vst, mutability);\n+            let v = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             let mut any_error = false;\n             let mut any_bot = false;\n             let t: ty::t = fcx.infcx().next_ty_var();\n@@ -2485,7 +2484,23 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             } else if any_bot {\n                 ty::mk_bot()\n             } else {\n-                ty::mk_vec(tcx, t, v)\n+                match v {\n+                    ty::VstoreFixed(sz) => ty::mk_vec(tcx,\n+                                                      ty::mt {ty: t, mutbl: mutability},\n+                                                      Some(sz)),\n+                    ty::VstoreUniq => ty::mk_uniq(tcx,\n+                                                  ty::mk_vec(tcx,\n+                                                             ty::mt {ty: t, mutbl: mutability},\n+                                                             None)), // Sadly, we know the length\n+                                                                     // - Some(args.len()) - but\n+                                                                     // must thow it away or cause\n+                                                                     // confusion further down the\n+                                                                     // pipeline. Hopefully we can\n+                                                                     // remedy this later.\n+                                                                     // See below (x3) too.\n+                    ty::VstoreSlice(r) => ty::mk_slice(tcx, r,\n+                                                       ty::mt {ty: t, mutbl: mutability}),\n+                }\n             }\n           }\n           ast::ExprRepeat(element, count_expr) => {\n@@ -2495,7 +2510,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 ast::ExprVstoreMutSlice => ast::MutMutable,\n                 _ => ast::MutImmutable,\n             };\n-            let v = ast_expr_vstore_to_vstore(fcx, ev, vst, mutability);\n+            let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             let t = fcx.infcx().next_ty_var();\n             check_expr_has_type(fcx, element, t);\n             let arg_t = fcx.expr_ty(element);\n@@ -2504,7 +2519,17 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             } else if ty::type_is_bot(arg_t) {\n                 ty::mk_bot()\n             } else {\n-                ty::mk_vec(tcx, t, v)\n+                match tt {\n+                    ty::VstoreFixed(sz) => ty::mk_vec(tcx,\n+                                                      ty::mt {ty: t, mutbl: mutability},\n+                                                      Some(sz)),\n+                    ty::VstoreUniq => ty::mk_uniq(tcx,\n+                                                  ty::mk_vec(tcx,\n+                                                             ty::mt {ty: t, mutbl: mutability},\n+                                                             None)),\n+                    ty::VstoreSlice(r) => ty::mk_slice(tcx, r,\n+                                                       ty::mt {ty: t, mutbl: mutability}),\n+                }\n             }\n           }\n           _ =>\n@@ -2949,6 +2974,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         fn is_vec(t: ty::t) -> bool {\n                             match ty::get(t).sty {\n                                 ty::ty_vec(..) => true,\n+                                ty::ty_ptr(ty::mt{ty: t, ..}) | ty::ty_rptr(_, ty::mt{ty: t, ..}) |\n+                                ty::ty_box(t) | ty::ty_uniq(t) => match ty::get(t).sty {\n+                                    ty::ty_vec(_, None) => true,\n+                                    _ => false,\n+                                },\n                                 _ => false\n                             }\n                         }\n@@ -3005,7 +3035,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         for e in args.iter() {\n             check_expr_has_type(fcx, *e, t);\n         }\n-        let typ = ty::mk_vec(tcx, t, ty::VstoreFixed(args.len()));\n+        let typ = ty::mk_vec(tcx, ty::mt {ty: t, mutbl: ast::MutImmutable},\n+                             Some(args.len()));\n         fcx.write_ty(id, typ);\n       }\n       ast::ExprRepeat(element, count_expr) => {\n@@ -3021,7 +3052,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             fcx.write_bot(id);\n         }\n         else {\n-            let t = ty::mk_vec(tcx, t, ty::VstoreFixed(count));\n+            let t = ty::mk_vec(tcx, ty::mt {ty: t, mutbl: ast::MutImmutable},\n+                               Some(count));\n             fcx.write_ty(id, t);\n         }\n       }\n@@ -3089,9 +3121,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 autoderef(fcx, expr.span, raw_base_t, Some(base.id),\n                           lvalue_pref, |base_t, _| ty::index(base_t));\n               match field_ty {\n-                  Some(ty) => {\n+                  Some(mt) => {\n                       check_expr_has_type(fcx, idx, ty::mk_uint());\n-                      fcx.write_ty(id, ty);\n+                      fcx.write_ty(id, mt.ty);\n                       fcx.write_autoderef_adjustment(base.id, autoderefs);\n                   }\n                   None => {\n@@ -3833,33 +3865,32 @@ pub fn type_is_c_like_enum(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     return ty::type_is_c_like_enum(fcx.ccx.tcx, typ_s);\n }\n \n-pub fn ast_expr_vstore_to_vstore<M>(fcx: &FnCtxt,\n-                                    e: &ast::Expr,\n-                                    v: ast::ExprVstore,\n-                                    m: M)\n-                                    -> ty::Vstore<M> {\n+pub fn ast_expr_vstore_to_vstore(fcx: &FnCtxt,\n+                                 e: &ast::Expr,\n+                                 v: ast::ExprVstore)\n+                                 -> ty::Vstore {\n     match v {\n         ast::ExprVstoreUniq => ty::VstoreUniq,\n         ast::ExprVstoreSlice | ast::ExprVstoreMutSlice => {\n             match e.node {\n                 ast::ExprLit(..) => {\n                     // string literals and *empty slices* live in static memory\n-                    ty::VstoreSlice(ty::ReStatic, m)\n+                    ty::VstoreSlice(ty::ReStatic)\n                 }\n                 ast::ExprVec(ref elements) if elements.len() == 0 => {\n                     // string literals and *empty slices* live in static memory\n-                    ty::VstoreSlice(ty::ReStatic, m)\n+                    ty::VstoreSlice(ty::ReStatic)\n                 }\n                 ast::ExprRepeat(..) |\n                 ast::ExprVec(..) => {\n                     // vector literals are temporaries on the stack\n                     match fcx.tcx().region_maps.temporary_scope(e.id) {\n                         Some(scope) => {\n-                            ty::VstoreSlice(ty::ReScope(scope), m)\n+                            ty::VstoreSlice(ty::ReScope(scope))\n                         }\n                         None => {\n                             // this slice occurs in a static somewhere\n-                            ty::VstoreSlice(ty::ReStatic, m)\n+                            ty::VstoreSlice(ty::ReStatic)\n                         }\n                     }\n                 }"}, {"sha": "f6a4d972a070f91bdcbc115e054d1b0d0353a86c", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -928,11 +928,17 @@ fn constrain_index(rcx: &mut Rcx,\n \n     let r_index_expr = ty::ReScope(index_expr.id);\n     match ty::get(indexed_ty).sty {\n-        ty::ty_str(ty::VstoreSlice(r_ptr, ())) |\n-        ty::ty_vec(_, ty::VstoreSlice(r_ptr, _)) => {\n+        ty::ty_str(ty::VstoreSlice(r_ptr)) => {\n             rcx.fcx.mk_subr(true, infer::IndexSlice(index_expr.span),\n                             r_index_expr, r_ptr);\n         }\n+        ty::ty_rptr(r_ptr, mt) => match ty::get(mt.ty).sty {\n+            ty::ty_vec(_, None) => {\n+                rcx.fcx.mk_subr(true, infer::IndexSlice(index_expr.span),\n+                                r_index_expr, r_ptr);\n+            }\n+            _ => {}\n+        },\n \n         _ => {}\n     }"}, {"sha": "d9ec448c2c5cf46af1c68659315364d1e3e881eb", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -100,8 +100,7 @@ pub fn relate_nested_regions(tcx: &ty::ctxt,\n \n         fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n             match ty::get(ty).sty {\n-                ty::ty_rptr(r, ty::mt {ty, ..}) |\n-                ty::ty_vec(ty, ty::VstoreSlice(r, _)) => {\n+                ty::ty_rptr(r, ty::mt {ty, ..}) => {\n                     self.relate(r);\n                     self.stack.push(r);\n                     ty_fold::super_fold_ty(self, ty);"}, {"sha": "ad0590318ea924c2b244648fe75978ecf3ee7cde", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -102,9 +102,19 @@ impl<'f> Coerce<'f> {\n         // See above for details.\n         match ty::get(b).sty {\n             ty::ty_rptr(_, mt_b) => {\n-                return self.unpack_actual_value(a, |sty_a| {\n-                    self.coerce_borrowed_pointer(a, sty_a, b, mt_b)\n-                });\n+                match ty::get(mt_b.ty).sty {\n+                    ty::ty_vec(mt_b, None) => {\n+                        return self.unpack_actual_value(a, |sty_a| {\n+                            self.coerce_borrowed_vector(a, sty_a, b, mt_b.mutbl)\n+                        });\n+                    }\n+                    ty::ty_vec(_, _) => {},\n+                    _ => {\n+                        return self.unpack_actual_value(a, |sty_a| {\n+                            self.coerce_borrowed_pointer(a, sty_a, b, mt_b)\n+                        });\n+                    }\n+                };\n             }\n \n             ty::ty_str(VstoreSlice(..)) => {\n@@ -113,12 +123,6 @@ impl<'f> Coerce<'f> {\n                 });\n             }\n \n-            ty::ty_vec(_, VstoreSlice(_, mutbl_b)) => {\n-                return self.unpack_actual_value(a, |sty_a| {\n-                    self.coerce_borrowed_vector(a, sty_a, b, mutbl_b)\n-                });\n-            }\n-\n             ty::ty_closure(~ty::ClosureTy {store: ty::RegionTraitStore(..), ..}) => {\n                 return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_fn(a, sty_a, b)\n@@ -266,7 +270,7 @@ impl<'f> Coerce<'f> {\n         };\n \n         let r_a = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n-        let a_borrowed = ty::mk_str(self.get_ref().infcx.tcx, VstoreSlice(r_a, ()));\n+        let a_borrowed = ty::mk_str(self.get_ref().infcx.tcx, VstoreSlice(r_a));\n         if_ok!(self.subtype(a_borrowed, b));\n         Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,\n@@ -287,14 +291,21 @@ impl<'f> Coerce<'f> {\n         let sub = Sub(*self.get_ref());\n         let r_borrow = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n         let ty_inner = match *sty_a {\n-            ty::ty_vec(ty, _) => ty,\n+            ty::ty_uniq(t) | ty::ty_ptr(ty::mt{ty: t, ..}) |\n+            ty::ty_rptr(_, ty::mt{ty: t, ..}) => match ty::get(t).sty {\n+                ty::ty_vec(mt, None) => mt.ty,\n+                _ => {\n+                    return self.subtype(a, b);\n+                }\n+            },\n+            ty::ty_vec(mt, _) => mt.ty,\n             _ => {\n                 return self.subtype(a, b);\n             }\n         };\n \n-        let a_borrowed = ty::mk_vec(self.get_ref().infcx.tcx, ty_inner,\n-                                    VstoreSlice(r_borrow, mutbl_b));\n+        let a_borrowed = ty::mk_slice(self.get_ref().infcx.tcx, r_borrow,\n+                                      mt {ty: ty_inner, mutbl: mutbl_b});\n         if_ok!(sub.tys(a_borrowed, b));\n         Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,"}, {"sha": "bd3bb18fa3364897c23fb1e7dffb8bc720612ea5", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -270,15 +270,15 @@ pub trait Combine {\n \n     fn vstores(&self,\n                 vk: ty::terr_vstore_kind,\n-                a: ty::Vstore<()>,\n-                b: ty::Vstore<()>)\n-                -> cres<ty::Vstore<()>> {\n+                a: ty::Vstore,\n+                b: ty::Vstore)\n+                -> cres<ty::Vstore> {\n         debug!(\"{}.vstores(a={:?}, b={:?})\", self.tag(), a, b);\n \n         match (a, b) {\n-            (ty::VstoreSlice(a_r, _), ty::VstoreSlice(b_r, _)) => {\n+            (ty::VstoreSlice(a_r), ty::VstoreSlice(b_r)) => {\n                 self.contraregions(a_r, b_r).and_then(|r| {\n-                    Ok(ty::VstoreSlice(r, ()))\n+                    Ok(ty::VstoreSlice(r))\n                 })\n             }\n \n@@ -510,48 +510,49 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       }\n \n       (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {\n-        this.tys(a_inner, b_inner).and_then(|typ| Ok(ty::mk_uniq(tcx, typ)))\n+            let typ = if_ok!(this.tys(a_inner, b_inner));\n+\n+            match (&ty::get(a_inner).sty, &ty::get(b_inner).sty) {\n+                (&ty::ty_vec(_, None), &ty::ty_vec(_, None)) => Ok(ty::mk_uniq(tcx, typ)),\n+                (&ty::ty_vec(_, None), _) |\n+                (_, &ty::ty_vec(_, None)) => Err(ty::terr_sorts(expected_found(this, a, b))),\n+                _ => Ok(ty::mk_uniq(tcx, typ)),\n+            }\n       }\n \n       (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) => {\n-        this.mts(a_mt, b_mt).and_then(|mt| Ok(ty::mk_ptr(tcx, mt)))\n+            let mt = if_ok!(this.mts(a_mt, b_mt));\n+            match (&ty::get(a_mt.ty).sty, &ty::get(b_mt.ty).sty) {\n+                (&ty::ty_vec(_, None), &ty::ty_vec(_, None)) => Ok(ty::mk_ptr(tcx, mt)),\n+                (&ty::ty_vec(_, None), _) |\n+                (_, &ty::ty_vec(_, None)) => Err(ty::terr_sorts(expected_found(this, a, b))),\n+                _ => Ok(ty::mk_ptr(tcx, mt)),\n+            }\n       }\n \n       (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n-          let r = if_ok!(this.contraregions(a_r, b_r));\n-          let mt = if_ok!(this.mts(a_mt, b_mt));\n-          Ok(ty::mk_rptr(tcx, r, mt))\n+            let r = if_ok!(this.contraregions(a_r, b_r));\n+            let mt = if_ok!(this.mts(a_mt, b_mt));\n+\n+            // This is a horible hack - historically, [T] was not treated as a type,\n+            // so, for example, &T and &[U] should not unify. In fact the only thing\n+            // &[U] should unify with is &[T]. We preserve that behaviour with this\n+            // check. See also ty_uniq, ty_ptr.\n+            match (&ty::get(a_mt.ty).sty, &ty::get(b_mt.ty).sty) {\n+                (&ty::ty_vec(_, None), &ty::ty_vec(_, None)) => Ok(ty::mk_rptr(tcx, r, mt)),\n+                (&ty::ty_vec(_, None), _) |\n+                (_, &ty::ty_vec(_, None)) => Err(ty::terr_sorts(expected_found(this, a, b))),\n+                _ => Ok(ty::mk_rptr(tcx, r, mt)),\n+            }\n       }\n \n-      (&ty::ty_vec(a_inner, vs_a), &ty::ty_vec(b_inner, vs_b)) => {\n-        // This could be nicer if we didn't have to go through .mts(a, b).\n-        let (vs_a, mutbl_a) = match vs_a {\n-            ty::VstoreFixed(n) => (ty::VstoreFixed(n), ast::MutImmutable),\n-            ty::VstoreSlice(r, m) => (ty::VstoreSlice(r, ()), m),\n-            ty::VstoreUniq => (ty::VstoreUniq, ast::MutImmutable)\n-        };\n-        let (vs_b, mutbl_b) = match vs_b {\n-            ty::VstoreFixed(n) => (ty::VstoreFixed(n), ast::MutImmutable),\n-            ty::VstoreSlice(r, m) => (ty::VstoreSlice(r, ()), m),\n-            ty::VstoreUniq => (ty::VstoreUniq, ast::MutImmutable)\n-        };\n-        let a_mt = ty::mt {\n-            ty: a_inner,\n-            mutbl: mutbl_a\n-        };\n-        let b_mt = ty::mt {\n-            ty: b_inner,\n-            mutbl: mutbl_b\n-        };\n-        this.mts(&a_mt, &b_mt).and_then(|mt| {\n-            this.vstores(ty::terr_vec, vs_a, vs_b).and_then(|vs| {\n-                let store = match vs {\n-                    ty::VstoreFixed(n) => ty::VstoreFixed(n),\n-                    ty::VstoreSlice(r, _) => ty::VstoreSlice(r, mt.mutbl),\n-                    ty::VstoreUniq => ty::VstoreUniq\n-                };\n-                Ok(ty::mk_vec(tcx, mt.ty, store))\n-            })\n+      (&ty::ty_vec(ref a_mt, sz_a), &ty::ty_vec(ref b_mt, sz_b)) => {\n+        this.mts(a_mt, b_mt).and_then(|mt| {\n+            if sz_a == sz_b {\n+                Ok(ty::mk_vec(tcx, mt, sz_a))\n+            } else {\n+                Err(ty::terr_sorts(expected_found(this, a, b)))\n+            }\n         })\n       }\n "}, {"sha": "907153d6cbee4816fa7190e3d121bdd79b447f8a", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -717,16 +717,8 @@ impl<'a> ConstraintContext<'a> {\n                 self.add_constraints_from_vstore(vstore, variance);\n             }\n \n-            ty::ty_vec(ty, vstore) => {\n-                self.add_constraints_from_vstore(vstore, variance);\n-                let mt = ty::mt {\n-                    ty: ty,\n-                    mutbl: match vstore {\n-                        ty::VstoreSlice(_, m) => m,\n-                        _ => ast::MutImmutable\n-                    }\n-                };\n-                self.add_constraints_from_mt(&mt, variance);\n+            ty::ty_vec(ref mt, _) => {\n+                self.add_constraints_from_mt(mt, variance);\n             }\n \n             ty::ty_uniq(typ) | ty::ty_box(typ) => {\n@@ -799,11 +791,11 @@ impl<'a> ConstraintContext<'a> {\n \n     /// Adds constraints appropriate for a vector with Vstore `vstore`\n     /// appearing in a context with ambient variance `variance`\n-    fn add_constraints_from_vstore<M>(&mut self,\n-                                      vstore: ty::Vstore<M>,\n-                                      variance: VarianceTermPtr<'a>) {\n+    fn add_constraints_from_vstore(&mut self,\n+                                   vstore: ty::Vstore,\n+                                   variance: VarianceTermPtr<'a>) {\n         match vstore {\n-            ty::VstoreSlice(r, _) => {\n+            ty::VstoreSlice(r) => {\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(r, contra);\n             }"}, {"sha": "1d98cc143de78e7d7fe3feb71a0b0077a1105310", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37306c1d25a6bb8d1e96adaff6a360d6163b8f29/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=37306c1d25a6bb8d1e96adaff6a360d6163b8f29", "patch": "@@ -395,23 +395,23 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n         let bound_str = bounds.repr(cx);\n         format!(\"{}{}{}{}\", trait_store_to_str(cx, store), ty, bound_sep, bound_str)\n       }\n-      ty_vec(ty, vs) => {\n-        match vs {\n-            ty::VstoreFixed(n) => {\n-                format!(\"[{}, .. {}]\", ty_to_str(cx, ty), n)\n-            }\n-            _ => {\n-                format!(\"{}[{}]\", vs.repr(cx), ty_to_str(cx, ty))\n-            }\n-        }\n-      }\n       ty_str(vs) => {\n         match vs {\n             ty::VstoreFixed(n) => format!(\"str/{}\", n),\n             ty::VstoreUniq => \"~str\".to_owned(),\n-            ty::VstoreSlice(r, ()) => format!(\"{}str\", region_ptr_to_str(cx, r))\n+            ty::VstoreSlice(r) => format!(\"{}str\", region_ptr_to_str(cx, r))\n         }\n       }\n+      ty_vec(ref mt, sz) => {\n+          match sz {\n+              Some(n) => {\n+                  format!(\"[{}, .. {}]\", mt_to_str(cx, mt), n)\n+              }\n+              None => {\n+                  format!(\"[{}]\", ty_to_str(cx, mt.ty))\n+              }\n+          }\n+      }\n     }\n }\n \n@@ -853,19 +853,7 @@ impl Repr for ty::Vstore {\n         match *self {\n             ty::VstoreFixed(n) => format!(\"{}\", n),\n             ty::VstoreUniq => \"~\".to_owned(),\n-            ty::VstoreSlice(r, m) => {\n-                format!(\"{}{}\", region_ptr_to_str(tcx, r), mutability_to_str(m))\n-            }\n-        }\n-    }\n-}\n-\n-impl Repr for ty::Vstore<()> {\n-    fn repr(&self, tcx: &ctxt) -> ~str {\n-        match *self {\n-            ty::VstoreFixed(n) => format!(\"{}\", n),\n-            ty::VstoreUniq => \"~\".to_owned(),\n-            ty::VstoreSlice(r, ()) => region_ptr_to_str(tcx, r)\n+            ty::VstoreSlice(r) => region_ptr_to_str(tcx, r)\n         }\n     }\n }"}]}