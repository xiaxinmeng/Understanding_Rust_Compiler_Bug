{"sha": "c70cdc0ed487e5b24195ceedd65b458381c2b5c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MGNkYzBlZDQ4N2U1YjI0MTk1Y2VlZGQ2NWI0NTgzODFjMmI1Yzc=", "commit": {"author": {"name": "Josh Stone", "email": "cuviper@gmail.com", "date": "2019-03-28T01:15:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-28T01:15:25Z"}, "message": "Rollup merge of #59283 - SimonSapin:branchless-ascii-case, r=joshtriplett\n\nMake ASCII case conversions more than 4\u00d7 faster\n\nReformatted output of `./x.py bench src/libcore --test-args ascii` below. The `libcore` benchmark calls `[u8]::make_ascii_lowercase`. `lookup` has code (effectively) identical to that before this PR, and ~~`branchless`~~ `mask_shifted_bool_match_range` after this PR.\n\n~~See [code comments](https://github.com/rust-lang/rust/pull/59283/commits/ce933f77c865a15670855ac5941fe200752b739f#diff-01076f91a26400b2db49663d787c2576R3796) in `u8::to_ascii_uppercase` in `src/libcore/num/mod.rs` for an explanation of the branchless algorithm.~~\n\n**Update:** the algorithm was simplified while keeping the performance. See `branchless` v.s. `mask_shifted_bool_match_range` benchmarks.\n\nCredits to @raphlinus for the idea in https://twitter.com/raphlinus/status/1107654782544736261, which extends this algorithm to \u201cfake SIMD\u201d on `u32` to convert four bytes at a time. The `fake_simd_u32` benchmarks implements this with [`let (before, aligned, after) = bytes.align_to_mut::<u32>()`](https://doc.rust-lang.org/std/primitive.slice.html#method.align_to_mut). Note however that this is buggy when addition carries/overflows into the next byte (which does not happen if the input is known to be ASCII).\n\nThis could be fixed (to optimize `[u8]::make_ascii_lowercase` and `[u8]::make_ascii_uppercase` in `src/libcore/slice/mod.rs`) either with some more bitwise trickery that I didn\u2019t quite figure out, or by using \u201creal\u201d SIMD intrinsics for byte-wise addition. I did not pursue this however because the current (incorrect) fake SIMD algorithm is only marginally faster than the one-byte-at-a-time branchless algorithm. This is because LLVM auto-vectorizes the latter, as can be seen on https://rust.godbolt.org/z/anKtbR.\n\nBenchmark results on Linux x64 with Intel i7-7700K: (updated from https://github.com/rust-lang/rust/pull/59283#issuecomment-474146863)\n\n```rust\n6830 bytes string:\n\nalloc_only                          ... bench:    112 ns/iter (+/- 0) = 62410 MB/s\nblack_box_read_each_byte            ... bench:  1,733 ns/iter (+/- 8) = 4033 MB/s\nlookup_table                        ... bench:  1,766 ns/iter (+/- 11) = 3958 MB/s\nbranch_and_subtract                 ... bench:    417 ns/iter (+/- 1) = 16762 MB/s\nbranch_and_mask                     ... bench:    401 ns/iter (+/- 1) = 17431 MB/s\nbranchless                          ... bench:    365 ns/iter (+/- 0) = 19150 MB/s\nlibcore                             ... bench:    367 ns/iter (+/- 1) = 19046 MB/s\nfake_simd_u32                       ... bench:    361 ns/iter (+/- 2) = 19362 MB/s\nfake_simd_u64                       ... bench:    361 ns/iter (+/- 1) = 19362 MB/s\nmask_mult_bool_branchy_lookup_table ... bench:  6,309 ns/iter (+/- 19) = 1107 MB/s\nmask_mult_bool_lookup_table         ... bench:  4,183 ns/iter (+/- 29) = 1671 MB/s\nmask_mult_bool_match_range          ... bench:    339 ns/iter (+/- 0) = 20619 MB/s\nmask_shifted_bool_match_range       ... bench:    339 ns/iter (+/- 1) = 20619 MB/s\n\n32 bytes string:\n\nalloc_only                          ... bench:     15 ns/iter (+/- 0) = 2133 MB/s\nblack_box_read_each_byte            ... bench:     29 ns/iter (+/- 0) = 1103 MB/s\nlookup_table                        ... bench:     24 ns/iter (+/- 4) = 1333 MB/s\nbranch_and_subtract                 ... bench:     16 ns/iter (+/- 0) = 2000 MB/s\nbranch_and_mask                     ... bench:     16 ns/iter (+/- 0) = 2000 MB/s\nbranchless                          ... bench:     16 ns/iter (+/- 0) = 2000 MB/s\nlibcore                             ... bench:     15 ns/iter (+/- 0) = 2133 MB/s\nfake_simd_u32                       ... bench:     17 ns/iter (+/- 0) = 1882 MB/s\nfake_simd_u64                       ... bench:     16 ns/iter (+/- 0) = 2000 MB/s\nmask_mult_bool_branchy_lookup_table ... bench:     42 ns/iter (+/- 0) = 761 MB/s\nmask_mult_bool_lookup_table         ... bench:     35 ns/iter (+/- 0) = 914 MB/s\nmask_mult_bool_match_range          ... bench:     16 ns/iter (+/- 0) = 2000 MB/s\nmask_shifted_bool_match_range       ... bench:     16 ns/iter (+/- 0) = 2000 MB/s\n\n7 bytes string:\n\nalloc_only                          ... bench:     14 ns/iter (+/- 0) = 500 MB/s\nblack_box_read_each_byte            ... bench:     22 ns/iter (+/- 0) = 318 MB/s\nlookup_table                        ... bench:     16 ns/iter (+/- 0) = 437 MB/s\nbranch_and_subtract                 ... bench:     16 ns/iter (+/- 0) = 437 MB/s\nbranch_and_mask                     ... bench:     16 ns/iter (+/- 0) = 437 MB/s\nbranchless                          ... bench:     19 ns/iter (+/- 0) = 368 MB/s\nlibcore                             ... bench:     20 ns/iter (+/- 0) = 350 MB/s\nfake_simd_u32                       ... bench:     18 ns/iter (+/- 0) = 388 MB/s\nfake_simd_u64                       ... bench:     21 ns/iter (+/- 0) = 333 MB/s\nmask_mult_bool_branchy_lookup_table ... bench:     20 ns/iter (+/- 0) = 350 MB/s\nmask_mult_bool_lookup_table         ... bench:     19 ns/iter (+/- 0) = 368 MB/s\nmask_mult_bool_match_range          ... bench:     19 ns/iter (+/- 0) = 368 MB/s\nmask_shifted_bool_match_range       ... bench:     19 ns/iter (+/- 0) = 368 MB/s\n```", "tree": {"sha": "6ce7df7719a365b5ce3411c36f02e0658f0a4483", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ce7df7719a365b5ce3411c36f02e0658f0a4483"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c70cdc0ed487e5b24195ceedd65b458381c2b5c7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcnCAuCRBK7hj4Ov3rIwAAdHIIAJz7uqd5zpaTZQiavArCDDj8\nrRcoENVvuIYtA2M4uRSL6kfHMOS1ehqZWmMtzyzYf6dJvoHROJJBopYglOMFnnIk\nh73gw8s0nM4LQkazurW3gAmcwam4LpCdGxHF6gAFFuzkrXDlQB6TtWc9LjzEdGOI\n0OAdno2Gx98C3Oy7CFXvf+A0TmIKg7vmhQv2XVpt/N9tAZ8WKPa6Pb2qdm2xerkO\nU2CYam/xAUFQJsLs9ilfXlhJ0ZduLZybUvxpdGxhG8wFrvLlCBRcKQWYeCho6emw\nZ3fC5m0zFjPIIV5szUZ038ostTgQmr7bjwiHO96N1A5Lv1GX0SW7BAkKB0ERuJo=\n=6xmb\n-----END PGP SIGNATURE-----\n", "payload": "tree 6ce7df7719a365b5ce3411c36f02e0658f0a4483\nparent e5fa59735bdc6624a4489b82801c4dc44998f81b\nparent 7fad370fe9dc000f6f6f497a1939de6196e2c4fc\nauthor Josh Stone <cuviper@gmail.com> 1553735725 -0700\ncommitter GitHub <noreply@github.com> 1553735725 -0700\n\nRollup merge of #59283 - SimonSapin:branchless-ascii-case, r=joshtriplett\n\nMake ASCII case conversions more than 4\u00d7 faster\n\nReformatted output of `./x.py bench src/libcore --test-args ascii` below. The `libcore` benchmark calls `[u8]::make_ascii_lowercase`. `lookup` has code (effectively) identical to that before this PR, and ~~`branchless`~~ `mask_shifted_bool_match_range` after this PR.\n\n~~See [code comments](https://github.com/rust-lang/rust/pull/59283/commits/ce933f77c865a15670855ac5941fe200752b739f#diff-01076f91a26400b2db49663d787c2576R3796) in `u8::to_ascii_uppercase` in `src/libcore/num/mod.rs` for an explanation of the branchless algorithm.~~\n\n**Update:** the algorithm was simplified while keeping the performance. See `branchless` v.s. `mask_shifted_bool_match_range` benchmarks.\n\nCredits to @raphlinus for the idea in https://twitter.com/raphlinus/status/1107654782544736261, which extends this algorithm to \u201cfake SIMD\u201d on `u32` to convert four bytes at a time. The `fake_simd_u32` benchmarks implements this with [`let (before, aligned, after) = bytes.align_to_mut::<u32>()`](https://doc.rust-lang.org/std/primitive.slice.html#method.align_to_mut). Note however that this is buggy when addition carries/overflows into the next byte (which does not happen if the input is known to be ASCII).\n\nThis could be fixed (to optimize `[u8]::make_ascii_lowercase` and `[u8]::make_ascii_uppercase` in `src/libcore/slice/mod.rs`) either with some more bitwise trickery that I didn\u2019t quite figure out, or by using \u201creal\u201d SIMD intrinsics for byte-wise addition. I did not pursue this however because the current (incorrect) fake SIMD algorithm is only marginally faster than the one-byte-at-a-time branchless algorithm. This is because LLVM auto-vectorizes the latter, as can be seen on https://rust.godbolt.org/z/anKtbR.\n\nBenchmark results on Linux x64 with Intel i7-7700K: (updated from https://github.com/rust-lang/rust/pull/59283#issuecomment-474146863)\n\n```rust\n6830 bytes string:\n\nalloc_only                          ... bench:    112 ns/iter (+/- 0) = 62410 MB/s\nblack_box_read_each_byte            ... bench:  1,733 ns/iter (+/- 8) = 4033 MB/s\nlookup_table                        ... bench:  1,766 ns/iter (+/- 11) = 3958 MB/s\nbranch_and_subtract                 ... bench:    417 ns/iter (+/- 1) = 16762 MB/s\nbranch_and_mask                     ... bench:    401 ns/iter (+/- 1) = 17431 MB/s\nbranchless                          ... bench:    365 ns/iter (+/- 0) = 19150 MB/s\nlibcore                             ... bench:    367 ns/iter (+/- 1) = 19046 MB/s\nfake_simd_u32                       ... bench:    361 ns/iter (+/- 2) = 19362 MB/s\nfake_simd_u64                       ... bench:    361 ns/iter (+/- 1) = 19362 MB/s\nmask_mult_bool_branchy_lookup_table ... bench:  6,309 ns/iter (+/- 19) = 1107 MB/s\nmask_mult_bool_lookup_table         ... bench:  4,183 ns/iter (+/- 29) = 1671 MB/s\nmask_mult_bool_match_range          ... bench:    339 ns/iter (+/- 0) = 20619 MB/s\nmask_shifted_bool_match_range       ... bench:    339 ns/iter (+/- 1) = 20619 MB/s\n\n32 bytes string:\n\nalloc_only                          ... bench:     15 ns/iter (+/- 0) = 2133 MB/s\nblack_box_read_each_byte            ... bench:     29 ns/iter (+/- 0) = 1103 MB/s\nlookup_table                        ... bench:     24 ns/iter (+/- 4) = 1333 MB/s\nbranch_and_subtract                 ... bench:     16 ns/iter (+/- 0) = 2000 MB/s\nbranch_and_mask                     ... bench:     16 ns/iter (+/- 0) = 2000 MB/s\nbranchless                          ... bench:     16 ns/iter (+/- 0) = 2000 MB/s\nlibcore                             ... bench:     15 ns/iter (+/- 0) = 2133 MB/s\nfake_simd_u32                       ... bench:     17 ns/iter (+/- 0) = 1882 MB/s\nfake_simd_u64                       ... bench:     16 ns/iter (+/- 0) = 2000 MB/s\nmask_mult_bool_branchy_lookup_table ... bench:     42 ns/iter (+/- 0) = 761 MB/s\nmask_mult_bool_lookup_table         ... bench:     35 ns/iter (+/- 0) = 914 MB/s\nmask_mult_bool_match_range          ... bench:     16 ns/iter (+/- 0) = 2000 MB/s\nmask_shifted_bool_match_range       ... bench:     16 ns/iter (+/- 0) = 2000 MB/s\n\n7 bytes string:\n\nalloc_only                          ... bench:     14 ns/iter (+/- 0) = 500 MB/s\nblack_box_read_each_byte            ... bench:     22 ns/iter (+/- 0) = 318 MB/s\nlookup_table                        ... bench:     16 ns/iter (+/- 0) = 437 MB/s\nbranch_and_subtract                 ... bench:     16 ns/iter (+/- 0) = 437 MB/s\nbranch_and_mask                     ... bench:     16 ns/iter (+/- 0) = 437 MB/s\nbranchless                          ... bench:     19 ns/iter (+/- 0) = 368 MB/s\nlibcore                             ... bench:     20 ns/iter (+/- 0) = 350 MB/s\nfake_simd_u32                       ... bench:     18 ns/iter (+/- 0) = 388 MB/s\nfake_simd_u64                       ... bench:     21 ns/iter (+/- 0) = 333 MB/s\nmask_mult_bool_branchy_lookup_table ... bench:     20 ns/iter (+/- 0) = 350 MB/s\nmask_mult_bool_lookup_table         ... bench:     19 ns/iter (+/- 0) = 368 MB/s\nmask_mult_bool_match_range          ... bench:     19 ns/iter (+/- 0) = 368 MB/s\nmask_shifted_bool_match_range       ... bench:     19 ns/iter (+/- 0) = 368 MB/s\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c70cdc0ed487e5b24195ceedd65b458381c2b5c7", "html_url": "https://github.com/rust-lang/rust/commit/c70cdc0ed487e5b24195ceedd65b458381c2b5c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c70cdc0ed487e5b24195ceedd65b458381c2b5c7/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5fa59735bdc6624a4489b82801c4dc44998f81b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5fa59735bdc6624a4489b82801c4dc44998f81b", "html_url": "https://github.com/rust-lang/rust/commit/e5fa59735bdc6624a4489b82801c4dc44998f81b"}, {"sha": "7fad370fe9dc000f6f6f497a1939de6196e2c4fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fad370fe9dc000f6f6f497a1939de6196e2c4fc", "html_url": "https://github.com/rust-lang/rust/commit/7fad370fe9dc000f6f6f497a1939de6196e2c4fc"}], "stats": {"total": 509, "additions": 374, "deletions": 135}, "files": [{"sha": "635537e3121581ca31d6b86980f127c05ec338d5", "filename": "src/libcore/benches/ascii.rs", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/c70cdc0ed487e5b24195ceedd65b458381c2b5c7/src%2Flibcore%2Fbenches%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c70cdc0ed487e5b24195ceedd65b458381c2b5c7/src%2Flibcore%2Fbenches%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fascii.rs?ref=c70cdc0ed487e5b24195ceedd65b458381c2b5c7", "patch": "@@ -0,0 +1,349 @@\n+// Lower-case ASCII 'a' is the first byte that has its highest bit set\n+// after wrap-adding 0x1F:\n+//\n+//     b'a' + 0x1F == 0x80 == 0b1000_0000\n+//     b'z' + 0x1F == 0x98 == 0b10011000\n+//\n+// Lower-case ASCII 'z' is the last byte that has its highest bit unset\n+// after wrap-adding 0x05:\n+//\n+//     b'a' + 0x05 == 0x66 == 0b0110_0110\n+//     b'z' + 0x05 == 0x7F == 0b0111_1111\n+//\n+// \u2026 except for 0xFB to 0xFF, but those are in the range of bytes\n+// that have the highest bit unset again after adding 0x1F.\n+//\n+// So `(byte + 0x1f) & !(byte + 5)` has its highest bit set\n+// iff `byte` is a lower-case ASCII letter.\n+//\n+// Lower-case ASCII letters all have the 0x20 bit set.\n+// (Two positions right of 0x80, the highest bit.)\n+// Unsetting that bit produces the same letter, in upper-case.\n+//\n+// Therefore:\n+fn branchless_to_ascii_upper_case(byte: u8) -> u8 {\n+    byte &\n+    !(\n+        (\n+            byte.wrapping_add(0x1f) &\n+            !byte.wrapping_add(0x05) &\n+            0x80\n+        ) >> 2\n+    )\n+}\n+\n+\n+macro_rules! benches {\n+    ($( fn $name: ident($arg: ident: &mut [u8]) $body: block )+ @iter $( $is_: ident, )+) => {\n+        benches! {@\n+            $( fn $name($arg: &mut [u8]) $body )+\n+            $( fn $is_(bytes: &mut [u8]) { bytes.iter().all(u8::$is_) } )+\n+        }\n+    };\n+\n+    (@$( fn $name: ident($arg: ident: &mut [u8]) $body: block )+) => {\n+        benches!(mod short SHORT $($name $arg $body)+);\n+        benches!(mod medium MEDIUM $($name $arg $body)+);\n+        benches!(mod long LONG $($name $arg $body)+);\n+    };\n+\n+    (mod $mod_name: ident $input: ident $($name: ident $arg: ident $body: block)+) => {\n+        mod $mod_name {\n+            use super::*;\n+\n+            $(\n+                #[bench]\n+                fn $name(bencher: &mut Bencher) {\n+                    bencher.bytes = $input.len() as u64;\n+                    bencher.iter(|| {\n+                        let mut vec = $input.as_bytes().to_vec();\n+                        {\n+                            let $arg = &mut vec[..];\n+                            black_box($body);\n+                        }\n+                        vec\n+                    })\n+                }\n+            )+\n+        }\n+    }\n+}\n+\n+use test::black_box;\n+use test::Bencher;\n+\n+benches! {\n+    fn case00_alloc_only(_bytes: &mut [u8]) {}\n+\n+    fn case01_black_box_read_each_byte(bytes: &mut [u8]) {\n+        for byte in bytes {\n+            black_box(*byte);\n+        }\n+    }\n+\n+    fn case02_lookup_table(bytes: &mut [u8]) {\n+        for byte in bytes {\n+            *byte = ASCII_UPPERCASE_MAP[*byte as usize]\n+        }\n+    }\n+\n+    fn case03_branch_and_subtract(bytes: &mut [u8]) {\n+        for byte in bytes {\n+            *byte = if b'a' <= *byte && *byte <= b'z' {\n+                *byte - b'a' + b'A'\n+            } else {\n+                *byte\n+            }\n+        }\n+    }\n+\n+    fn case04_branch_and_mask(bytes: &mut [u8]) {\n+        for byte in bytes {\n+            *byte = if b'a' <= *byte && *byte <= b'z' {\n+                *byte & !0x20\n+            } else {\n+                *byte\n+            }\n+        }\n+    }\n+\n+    fn case05_branchless(bytes: &mut [u8]) {\n+        for byte in bytes {\n+            *byte = branchless_to_ascii_upper_case(*byte)\n+        }\n+    }\n+\n+    fn case06_libcore(bytes: &mut [u8]) {\n+        bytes.make_ascii_uppercase()\n+    }\n+\n+    fn case07_fake_simd_u32(bytes: &mut [u8]) {\n+        let (before, aligned, after) = unsafe {\n+            bytes.align_to_mut::<u32>()\n+        };\n+        for byte in before {\n+            *byte = branchless_to_ascii_upper_case(*byte)\n+        }\n+        for word in aligned {\n+            // FIXME: this is incorrect for some byte values:\n+            // addition within a byte can carry/overflow into the next byte.\n+            // Test case: b\"\\xFFz  \"\n+            *word &= !(\n+                (\n+                    word.wrapping_add(0x1f1f1f1f) &\n+                    !word.wrapping_add(0x05050505) &\n+                    0x80808080\n+                ) >> 2\n+            )\n+        }\n+        for byte in after {\n+            *byte = branchless_to_ascii_upper_case(*byte)\n+        }\n+    }\n+\n+    fn case08_fake_simd_u64(bytes: &mut [u8]) {\n+        let (before, aligned, after) = unsafe {\n+            bytes.align_to_mut::<u64>()\n+        };\n+        for byte in before {\n+            *byte = branchless_to_ascii_upper_case(*byte)\n+        }\n+        for word in aligned {\n+            // FIXME: like above, this is incorrect for some byte values.\n+            *word &= !(\n+                (\n+                    word.wrapping_add(0x1f1f1f1f_1f1f1f1f) &\n+                    !word.wrapping_add(0x05050505_05050505) &\n+                    0x80808080_80808080\n+                ) >> 2\n+            )\n+        }\n+        for byte in after {\n+            *byte = branchless_to_ascii_upper_case(*byte)\n+        }\n+    }\n+\n+    fn case09_mask_mult_bool_branchy_lookup_table(bytes: &mut [u8]) {\n+        fn is_ascii_lowercase(b: u8) -> bool {\n+            if b >= 0x80 { return false }\n+            match ASCII_CHARACTER_CLASS[b as usize] {\n+                L | Lx => true,\n+                _ => false,\n+            }\n+        }\n+        for byte in bytes {\n+            *byte &= !(0x20 * (is_ascii_lowercase(*byte) as u8))\n+        }\n+    }\n+\n+    fn case10_mask_mult_bool_lookup_table(bytes: &mut [u8]) {\n+        fn is_ascii_lowercase(b: u8) -> bool {\n+            match ASCII_CHARACTER_CLASS[b as usize] {\n+                L | Lx => true,\n+                _ => false\n+            }\n+        }\n+        for byte in bytes {\n+            *byte &= !(0x20 * (is_ascii_lowercase(*byte) as u8))\n+        }\n+    }\n+\n+    fn case11_mask_mult_bool_match_range(bytes: &mut [u8]) {\n+        fn is_ascii_lowercase(b: u8) -> bool {\n+            match b {\n+                b'a'...b'z' => true,\n+                _ => false\n+            }\n+        }\n+        for byte in bytes {\n+            *byte &= !(0x20 * (is_ascii_lowercase(*byte) as u8))\n+        }\n+    }\n+\n+    fn case12_mask_shifted_bool_match_range(bytes: &mut [u8]) {\n+        fn is_ascii_lowercase(b: u8) -> bool {\n+            match b {\n+                b'a'...b'z' => true,\n+                _ => false\n+            }\n+        }\n+        for byte in bytes {\n+            *byte &= !((is_ascii_lowercase(*byte) as u8) << 5)\n+        }\n+    }\n+\n+    fn case13_subtract_shifted_bool_match_range(bytes: &mut [u8]) {\n+        fn is_ascii_lowercase(b: u8) -> bool {\n+            match b {\n+                b'a'...b'z' => true,\n+                _ => false\n+            }\n+        }\n+        for byte in bytes {\n+            *byte -= (is_ascii_lowercase(*byte) as u8) << 5\n+        }\n+    }\n+\n+    fn case14_subtract_multiplied_bool_match_range(bytes: &mut [u8]) {\n+        fn is_ascii_lowercase(b: u8) -> bool {\n+            match b {\n+                b'a'...b'z' => true,\n+                _ => false\n+            }\n+        }\n+        for byte in bytes {\n+            *byte -= (b'a' - b'A') * is_ascii_lowercase(*byte) as u8\n+        }\n+    }\n+\n+    @iter\n+\n+    is_ascii,\n+    is_ascii_alphabetic,\n+    is_ascii_uppercase,\n+    is_ascii_lowercase,\n+    is_ascii_alphanumeric,\n+    is_ascii_digit,\n+    is_ascii_hexdigit,\n+    is_ascii_punctuation,\n+    is_ascii_graphic,\n+    is_ascii_whitespace,\n+    is_ascii_control,\n+}\n+\n+macro_rules! repeat {\n+    ($s: expr) => { concat!($s, $s, $s, $s, $s, $s, $s, $s, $s, $s) }\n+}\n+\n+const SHORT: &'static str = \"Alice's\";\n+const MEDIUM: &'static str = \"Alice's Adventures in Wonderland\";\n+const LONG: &'static str = repeat!(r#\"\n+    La Guida di Bragia, a Ballad Opera for the Marionette Theatre (around 1850)\n+    Alice's Adventures in Wonderland (1865)\n+    Phantasmagoria and Other Poems (1869)\n+    Through the Looking-Glass, and What Alice Found There\n+        (includes \"Jabberwocky\" and \"The Walrus and the Carpenter\") (1871)\n+    The Hunting of the Snark (1876)\n+    Rhyme? And Reason? (1883) \u2013 shares some contents with the 1869 collection,\n+        including the long poem \"Phantasmagoria\"\n+    A Tangled Tale (1885)\n+    Sylvie and Bruno (1889)\n+    Sylvie and Bruno Concluded (1893)\n+    Pillow Problems (1893)\n+    What the Tortoise Said to Achilles (1895)\n+    Three Sunsets and Other Poems (1898)\n+    The Manlet (1903)[106]\n+\"#);\n+\n+const ASCII_UPPERCASE_MAP: [u8; 256] = [\n+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+    b' ', b'!', b'\"', b'#', b'$', b'%', b'&', b'\\'',\n+    b'(', b')', b'*', b'+', b',', b'-', b'.', b'/',\n+    b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7',\n+    b'8', b'9', b':', b';', b'<', b'=', b'>', b'?',\n+    b'@', b'A', b'B', b'C', b'D', b'E', b'F', b'G',\n+    b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O',\n+    b'P', b'Q', b'R', b'S', b'T', b'U', b'V', b'W',\n+    b'X', b'Y', b'Z', b'[', b'\\\\', b']', b'^', b'_',\n+    b'`',\n+\n+          b'A', b'B', b'C', b'D', b'E', b'F', b'G',\n+    b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O',\n+    b'P', b'Q', b'R', b'S', b'T', b'U', b'V', b'W',\n+    b'X', b'Y', b'Z',\n+\n+                      b'{', b'|', b'}', b'~', 0x7f,\n+    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n+    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n+    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n+    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n+    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n+    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n+    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n+    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n+    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n+    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n+    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n+    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n+    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n+    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n+    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n+];\n+\n+enum AsciiCharacterClass {\n+    C,  // control\n+    Cw, // control whitespace\n+    W,  // whitespace\n+    D,  // digit\n+    L,  // lowercase\n+    Lx, // lowercase hex digit\n+    U,  // uppercase\n+    Ux, // uppercase hex digit\n+    P,  // punctuation\n+    N,  // Non-ASCII\n+}\n+use self::AsciiCharacterClass::*;\n+\n+static ASCII_CHARACTER_CLASS: [AsciiCharacterClass; 256] = [\n+//  _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _a _b _c _d _e _f\n+    C, C, C, C, C, C, C, C, C, Cw,Cw,C, Cw,Cw,C, C, // 0_\n+    C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, // 1_\n+    W, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, // 2_\n+    D, D, D, D, D, D, D, D, D, D, P, P, P, P, P, P, // 3_\n+    P, Ux,Ux,Ux,Ux,Ux,Ux,U, U, U, U, U, U, U, U, U, // 4_\n+    U, U, U, U, U, U, U, U, U, U, U, P, P, P, P, P, // 5_\n+    P, Lx,Lx,Lx,Lx,Lx,Lx,L, L, L, L, L, L, L, L, L, // 6_\n+    L, L, L, L, L, L, L, L, L, L, L, P, P, P, P, C, // 7_\n+    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n+    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n+    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n+    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n+    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n+    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n+    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n+    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n+];"}, {"sha": "707cdd5f450ea970bb727235b2b87a600897fcfb", "filename": "src/libcore/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c70cdc0ed487e5b24195ceedd65b458381c2b5c7/src%2Flibcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c70cdc0ed487e5b24195ceedd65b458381c2b5c7/src%2Flibcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Flib.rs?ref=c70cdc0ed487e5b24195ceedd65b458381c2b5c7", "patch": "@@ -5,6 +5,7 @@ extern crate core;\n extern crate test;\n \n mod any;\n+mod ascii;\n mod char;\n mod hash;\n mod iter;"}, {"sha": "3fcae6b94b06d855c2d9fa291e879f79b8fe3863", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 24, "deletions": 135, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/c70cdc0ed487e5b24195ceedd65b458381c2b5c7/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c70cdc0ed487e5b24195ceedd65b458381c2b5c7/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=c70cdc0ed487e5b24195ceedd65b458381c2b5c7", "patch": "@@ -3794,7 +3794,8 @@ impl u8 {\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_uppercase(&self) -> u8 {\n-        ASCII_UPPERCASE_MAP[*self as usize]\n+        // Unset the fith bit if this is a lowercase letter\n+        *self & !((self.is_ascii_lowercase() as u8) << 5)\n     }\n \n     /// Makes a copy of the value in its ASCII lower case equivalent.\n@@ -3816,7 +3817,8 @@ impl u8 {\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_lowercase(&self) -> u8 {\n-        ASCII_LOWERCASE_MAP[*self as usize]\n+        // Set the fith bit if this is an uppercase letter\n+        *self | ((self.is_ascii_uppercase() as u8) << 5)\n     }\n \n     /// Checks that two values are an ASCII case-insensitive match.\n@@ -3918,9 +3920,8 @@ impl u8 {\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_alphabetic(&self) -> bool {\n-        if *self >= 0x80 { return false; }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            L | Lx | U | Ux => true,\n+        match *self {\n+            b'A'...b'Z' | b'a'...b'z' => true,\n             _ => false\n         }\n     }\n@@ -3954,9 +3955,8 @@ impl u8 {\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_uppercase(&self) -> bool {\n-        if *self >= 0x80 { return false }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            U | Ux => true,\n+        match *self {\n+            b'A'...b'Z' => true,\n             _ => false\n         }\n     }\n@@ -3990,9 +3990,8 @@ impl u8 {\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_lowercase(&self) -> bool {\n-        if *self >= 0x80 { return false }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            L | Lx => true,\n+        match *self {\n+            b'a'...b'z' => true,\n             _ => false\n         }\n     }\n@@ -4029,9 +4028,8 @@ impl u8 {\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_alphanumeric(&self) -> bool {\n-        if *self >= 0x80 { return false }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            D | L | Lx | U | Ux => true,\n+        match *self {\n+            b'0'...b'9' | b'A'...b'Z' | b'a'...b'z' => true,\n             _ => false\n         }\n     }\n@@ -4065,9 +4063,8 @@ impl u8 {\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_digit(&self) -> bool {\n-        if *self >= 0x80 { return false }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            D => true,\n+        match *self {\n+            b'0'...b'9' => true,\n             _ => false\n         }\n     }\n@@ -4104,9 +4101,8 @@ impl u8 {\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_hexdigit(&self) -> bool {\n-        if *self >= 0x80 { return false }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            D | Lx | Ux => true,\n+        match *self {\n+            b'0'...b'9' | b'A'...b'F' | b'a'...b'f' => true,\n             _ => false\n         }\n     }\n@@ -4144,9 +4140,8 @@ impl u8 {\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_punctuation(&self) -> bool {\n-        if *self >= 0x80 { return false }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            P => true,\n+        match *self {\n+            b'!'...b'/' | b':'...b'@' | b'['...b'`' | b'{'...b'~' => true,\n             _ => false\n         }\n     }\n@@ -4180,9 +4175,8 @@ impl u8 {\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_graphic(&self) -> bool {\n-        if *self >= 0x80 { return false; }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            Ux | U | Lx | L | D | P => true,\n+        match *self {\n+            b'!'...b'~' => true,\n             _ => false\n         }\n     }\n@@ -4233,9 +4227,8 @@ impl u8 {\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_whitespace(&self) -> bool {\n-        if *self >= 0x80 { return false; }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            Cw | W => true,\n+        match *self {\n+            b'\\t' | b'\\n' | b'\\x0C' | b'\\r' | b' ' => true,\n             _ => false\n         }\n     }\n@@ -4271,9 +4264,8 @@ impl u8 {\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_control(&self) -> bool {\n-        if *self >= 0x80 { return false; }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            C | Cw => true,\n+        match *self {\n+            b'\\0'...b'\\x1F' | b'\\x7F' => true,\n             _ => false\n         }\n     }\n@@ -4939,106 +4931,3 @@ impl_from! { u32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\"\n \n // Float -> Float\n impl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-\n-static ASCII_LOWERCASE_MAP: [u8; 256] = [\n-    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n-    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n-    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n-    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n-    b' ', b'!', b'\"', b'#', b'$', b'%', b'&', b'\\'',\n-    b'(', b')', b'*', b'+', b',', b'-', b'.', b'/',\n-    b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7',\n-    b'8', b'9', b':', b';', b'<', b'=', b'>', b'?',\n-    b'@',\n-\n-          b'a', b'b', b'c', b'd', b'e', b'f', b'g',\n-    b'h', b'i', b'j', b'k', b'l', b'm', b'n', b'o',\n-    b'p', b'q', b'r', b's', b't', b'u', b'v', b'w',\n-    b'x', b'y', b'z',\n-\n-                      b'[', b'\\\\', b']', b'^', b'_',\n-    b'`', b'a', b'b', b'c', b'd', b'e', b'f', b'g',\n-    b'h', b'i', b'j', b'k', b'l', b'm', b'n', b'o',\n-    b'p', b'q', b'r', b's', b't', b'u', b'v', b'w',\n-    b'x', b'y', b'z', b'{', b'|', b'}', b'~', 0x7f,\n-    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n-    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n-    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n-    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n-    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n-    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n-    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n-    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n-    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n-    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n-    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n-    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n-    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n-    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n-    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n-    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n-];\n-\n-static ASCII_UPPERCASE_MAP: [u8; 256] = [\n-    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n-    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n-    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n-    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n-    b' ', b'!', b'\"', b'#', b'$', b'%', b'&', b'\\'',\n-    b'(', b')', b'*', b'+', b',', b'-', b'.', b'/',\n-    b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7',\n-    b'8', b'9', b':', b';', b'<', b'=', b'>', b'?',\n-    b'@', b'A', b'B', b'C', b'D', b'E', b'F', b'G',\n-    b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O',\n-    b'P', b'Q', b'R', b'S', b'T', b'U', b'V', b'W',\n-    b'X', b'Y', b'Z', b'[', b'\\\\', b']', b'^', b'_',\n-    b'`',\n-\n-          b'A', b'B', b'C', b'D', b'E', b'F', b'G',\n-    b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O',\n-    b'P', b'Q', b'R', b'S', b'T', b'U', b'V', b'W',\n-    b'X', b'Y', b'Z',\n-\n-                      b'{', b'|', b'}', b'~', 0x7f,\n-    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n-    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n-    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n-    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n-    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n-    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n-    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n-    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n-    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n-    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n-    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n-    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n-    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n-    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n-    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n-    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n-];\n-\n-enum AsciiCharacterClass {\n-    C,  // control\n-    Cw, // control whitespace\n-    W,  // whitespace\n-    D,  // digit\n-    L,  // lowercase\n-    Lx, // lowercase hex digit\n-    U,  // uppercase\n-    Ux, // uppercase hex digit\n-    P,  // punctuation\n-}\n-use self::AsciiCharacterClass::*;\n-\n-static ASCII_CHARACTER_CLASS: [AsciiCharacterClass; 128] = [\n-//  _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _a _b _c _d _e _f\n-    C, C, C, C, C, C, C, C, C, Cw,Cw,C, Cw,Cw,C, C, // 0_\n-    C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, // 1_\n-    W, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, // 2_\n-    D, D, D, D, D, D, D, D, D, D, P, P, P, P, P, P, // 3_\n-    P, Ux,Ux,Ux,Ux,Ux,Ux,U, U, U, U, U, U, U, U, U, // 4_\n-    U, U, U, U, U, U, U, U, U, U, U, P, P, P, P, P, // 5_\n-    P, Lx,Lx,Lx,Lx,Lx,Lx,L, L, L, L, L, L, L, L, L, // 6_\n-    L, L, L, L, L, L, L, L, L, L, L, P, P, P, P, C, // 7_\n-];"}]}