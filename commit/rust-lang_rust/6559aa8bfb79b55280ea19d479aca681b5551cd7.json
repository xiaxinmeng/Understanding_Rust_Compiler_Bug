{"sha": "6559aa8bfb79b55280ea19d479aca681b5551cd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1NTlhYThiZmI3OWI1NTI4MGVhMTlkNDc5YWNhNjgxYjU1NTFjZDc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-05T09:57:19Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-05T10:04:41Z"}, "message": "Write the iface type of an impl in the crate data\n\nAlso, move checking of ifaces into the collect phase of typeck\nto give further passes some guarantees.\n\nIssue #1227", "tree": {"sha": "30022403d81ca14e38063cf99e1c91461d119d84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30022403d81ca14e38063cf99e1c91461d119d84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6559aa8bfb79b55280ea19d479aca681b5551cd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6559aa8bfb79b55280ea19d479aca681b5551cd7", "html_url": "https://github.com/rust-lang/rust/commit/6559aa8bfb79b55280ea19d479aca681b5551cd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6559aa8bfb79b55280ea19d479aca681b5551cd7/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3eb35900c7f0b1c95455fb2088977b9ac468c96c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3eb35900c7f0b1c95455fb2088977b9ac468c96c", "html_url": "https://github.com/rust-lang/rust/commit/3eb35900c7f0b1c95455fb2088977b9ac468c96c"}], "stats": {"total": 234, "additions": 129, "deletions": 105}, "files": [{"sha": "2e732aea249a9cfdb8ee217d9603dcd87dd73f0b", "filename": "src/comp/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6559aa8bfb79b55280ea19d479aca681b5551cd7/src%2Fcomp%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559aa8bfb79b55280ea19d479aca681b5551cd7/src%2Fcomp%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcommon.rs?ref=6559aa8bfb79b55280ea19d479aca681b5551cd7", "patch": "@@ -67,6 +67,7 @@ const tag_crate_hash: uint = 0x28u;\n const tag_mod_impl: uint = 0x30u;\n \n const tag_impl_method: uint = 0x31u;\n+const tag_impl_iface: uint = 0x32u;\n \n // djb's cdb hashes.\n fn hash_node_id(&&node_id: int) -> uint { ret 177573u ^ (node_id as uint); }"}, {"sha": "2e57e4e97e9cf478f5b87a8a11b31687c31c1bf7", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6559aa8bfb79b55280ea19d479aca681b5551cd7/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559aa8bfb79b55280ea19d479aca681b5551cd7/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=6559aa8bfb79b55280ea19d479aca681b5551cd7", "patch": "@@ -13,6 +13,7 @@ export get_impls_for_mod;\n export get_impl_methods;\n export get_type;\n export get_item_name;\n+export get_impl_iface;\n \n fn get_symbol(cstore: cstore::cstore, def: ast::def_id) -> str {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n@@ -100,6 +101,14 @@ fn get_item_name(cstore: cstore::cstore, cnum: int, id: int) -> ast::ident {\n     ret decoder::lookup_item_name(cdata, id);\n }\n \n+fn get_impl_iface(tcx: ty::ctxt, def: ast::def_id)\n+    -> option::t<ty::t> {\n+    let cstore = tcx.sess.get_cstore();\n+    let cdata = cstore::get_crate_data(cstore, def.crate).data;\n+    let resolver = bind translate_def_id(cstore, def.crate, _);\n+    decoder::get_impl_iface(cdata, def, tcx, resolver)\n+}\n+\n // Translates a def_id from an external crate to a def_id for the current\n // compilation environment. We use this when trying to load types from\n // external crates - if those types further refer to types in other crates"}, {"sha": "269b6500ac927ebcc57583e7f952d4d8296af193", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6559aa8bfb79b55280ea19d479aca681b5551cd7/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559aa8bfb79b55280ea19d479aca681b5551cd7/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=6559aa8bfb79b55280ea19d479aca681b5551cd7", "patch": "@@ -14,8 +14,10 @@ export get_symbol;\n export get_tag_variants;\n export get_type;\n export get_type_param_count;\n+export get_impl_iface;\n export lookup_def;\n export lookup_item_name;\n+export get_impl_iface;\n export resolve_path;\n export get_crate_attributes;\n export list_crate_metadata;\n@@ -115,6 +117,18 @@ fn item_type(item: ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n     t\n }\n \n+fn item_impl_iface(item: ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n+                   extres: external_resolver) -> option::t<ty::t> {\n+    let result = none;\n+    ebml::tagged_docs(item, tag_impl_iface) {|ity|\n+        let def_parser = bind parse_external_def_id(this_cnum, extres, _);\n+        let t = parse_ty_data(ity.data, this_cnum, ity.start,\n+                              ity.end - ity.start, def_parser, tcx);\n+        result = some(t);\n+    }\n+    result\n+}\n+\n fn item_ty_param_bounds(item: ebml::doc, this_cnum: ast::crate_num,\n                         tcx: ty::ctxt, extres: external_resolver)\n     -> @[ty::param_bounds] {\n@@ -217,6 +231,11 @@ fn get_type_param_count(data: @[u8], id: ast::node_id) -> uint {\n     item_ty_param_count(lookup_item(id, data))\n }\n \n+fn get_impl_iface(data: @[u8], def: ast::def_id, tcx: ty::ctxt,\n+                  extres: external_resolver) -> option::t<ty::t> {\n+    item_impl_iface(lookup_item(def.node, data), def.crate, tcx, extres)\n+}\n+\n fn get_symbol(data: @[u8], id: ast::node_id) -> str {\n     ret item_symbol(lookup_item(id, data));\n }\n@@ -269,7 +288,6 @@ fn lookup_impl_methods(data: @[u8], node: ast::node_id, cnum: ast::crate_num)\n     rslt\n }\n \n-\n fn family_has_type_params(fam_ch: u8) -> bool {\n     ret alt fam_ch as char {\n           'c' { false }"}, {"sha": "2ea9d418a7f1660d6ab2f580228c80ebf2928808", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6559aa8bfb79b55280ea19d479aca681b5551cd7/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559aa8bfb79b55280ea19d479aca681b5551cd7/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=6559aa8bfb79b55280ea19d479aca681b5551cd7", "patch": "@@ -202,13 +202,17 @@ fn encode_variant_id(ebml_w: ebml::writer, vid: def_id) {\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_type);\n+fn write_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n     let ty_str_ctxt =\n         @{ds: def_to_str,\n           tcx: ecx.ccx.tcx,\n           abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     tyencode::enc_ty(io::new_writer(ebml_w.writer), ty_str_ctxt, typ);\n+}\n+\n+fn encode_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_type);\n+    write_type(ecx, ebml_w, typ);\n     ebml::end_tag(ebml_w);\n }\n \n@@ -369,7 +373,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_symbol(ecx, ebml_w, ctor_id);\n         ebml::end_tag(ebml_w);\n       }\n-      item_impl(tps, _, _, methods) {\n+      item_impl(tps, ifce, _, methods) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'i' as u8);\n@@ -381,6 +385,15 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             ebml_w.writer.write(str::bytes(def_to_str(local_def(m.id))));\n             ebml::end_tag(ebml_w);\n         }\n+        alt ifce {\n+          some(_) {\n+            ebml::start_tag(ebml_w, tag_impl_iface);\n+            write_type(ecx, ebml_w, ty::lookup_item_type(\n+                ecx.ccx.tcx, local_def(item.id)).ty);\n+            ebml::end_tag(ebml_w);\n+          }\n+          _ {}\n+        }\n         ebml::end_tag(ebml_w);\n \n         for m in methods {"}, {"sha": "95e84483be6144c37ab4dd7b6713c7d9497baeea", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6559aa8bfb79b55280ea19d479aca681b5551cd7/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559aa8bfb79b55280ea19d479aca681b5551cd7/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=6559aa8bfb79b55280ea19d479aca681b5551cd7", "patch": "@@ -102,7 +102,7 @@ export substitute_type_params;\n export t;\n export new_ty_hash;\n export tag_variants;\n-export iface_methods, store_iface_methods;\n+export iface_methods, store_iface_methods, impl_iface;\n export tag_variant_with_id;\n export ty_param_substs_opt_and_ty;\n export ty_param_bounds_and_ty;\n@@ -2670,6 +2670,14 @@ fn iface_methods(cx: ctxt, id: ast::def_id) -> @[method] {\n     result\n }\n \n+fn impl_iface(cx: ctxt, id: ast::def_id) -> option::t<t> {\n+    if id.crate == ast::local_crate {\n+        option::map(cx.tcache.find(id), {|it| it.ty})\n+    } else {\n+        csearch::get_impl_iface(cx, id)\n+    }\n+}\n+\n // Tag information\n type variant_info = @{args: [ty::t], ctor_ty: ty::t, id: ast::def_id};\n "}, {"sha": "02e1ed9d4f2e515d9d87d8a829fd3362ebed6d6e", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 75, "deletions": 100, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/6559aa8bfb79b55280ea19d479aca681b5551cd7/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6559aa8bfb79b55280ea19d479aca681b5551cd7/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=6559aa8bfb79b55280ea19d479aca681b5551cd7", "patch": "@@ -506,8 +506,17 @@ fn ty_param_bounds(tcx: ty::ctxt, mode: mode, params: [ast::ty_param])\n                 bounds += [alt b {\n                   ast::bound_send. { ty::bound_send }\n                   ast::bound_copy. { ty::bound_copy }\n-                  ast::bound_iface(ifc) {\n-                    ty::bound_iface(ast_ty_to_ty(tcx, mode, ifc))\n+                  ast::bound_iface(t) {\n+                    let ity = ast_ty_to_ty(tcx, mode, t);\n+                    alt ty::struct(tcx, ity) {\n+                      ty::ty_iface(_, _) {}\n+                      _ {\n+                        tcx.sess.span_fatal(\n+                            t.span, \"type parameter bounds must be \\\n+                                     interface types\");\n+                      }\n+                    }\n+                    ty::bound_iface(ity)\n                   }\n                 }];\n             }\n@@ -627,6 +636,30 @@ fn mk_ty_params(tcx: ty::ctxt, atps: [ast::ty_param])\n      })}\n }\n \n+fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n+                       impl_tps: uint, if_m: ty::method, substs: [ty::t]) {\n+    if impl_m.tps != if_m.tps {\n+        tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n+                          \"` has an incompatible set of type parameters\");\n+    } else {\n+        let impl_fty = ty::mk_fn(tcx, impl_m.fty);\n+        // Add dummy substs for the parameters of the impl method\n+        let substs = substs + vec::init_fn({|i|\n+            ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n+        }, vec::len(*if_m.tps));\n+        let if_fty = ty::substitute_type_params(tcx, substs,\n+                                                ty::mk_fn(tcx, if_m.fty));\n+        alt ty::unify::unify(impl_fty, if_fty, ty::unify::precise, tcx) {\n+          ty::unify::ures_err(err) {\n+            tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n+                              \"` has an incompatible type: \" +\n+                              ty::type_err_to_str(err));\n+          }\n+          _ {}\n+        }\n+    }\n+}\n+\n // Item collection - a pair of bootstrap passes:\n //\n // (1) Collect the IDs of all type items (typedefs) and store them in a table.\n@@ -684,20 +717,50 @@ mod collect {\n             write::ty_only(cx.tcx, it.id, tpt.ty);\n             get_tag_variant_types(cx, tpt.ty, variants, ty_params);\n           }\n-          ast::item_impl(tps, _, selfty, ms) {\n+          ast::item_impl(tps, ifce, selfty, ms) {\n             let i_bounds = ty_param_bounds(cx.tcx, m_collect, tps);\n+            let my_methods = [];\n             for m in ms {\n                 let bounds = ty_param_bounds(cx.tcx, m_collect, m.tps);\n-                let ty = ty::mk_fn(cx.tcx,\n-                                   ty_of_fn_decl(cx.tcx, m_collect,\n-                                                 ast::proto_bare, m.decl));\n+                let mty = ty_of_method(cx.tcx, m_collect, m);\n+                my_methods += [mty];\n+                let fty = ty::mk_fn(cx.tcx, mty.fty);\n                 cx.tcx.tcache.insert(local_def(m.id),\n                                      {bounds: @(*i_bounds + *bounds),\n-                                      ty: ty});\n-                write::ty_only(cx.tcx, m.id, ty);\n+                                      ty: fty});\n+                write::ty_only(cx.tcx, m.id, fty);\n             }\n             write::ty_only(cx.tcx, it.id, ast_ty_to_ty(cx.tcx, m_collect,\n                                                        selfty));\n+            alt ifce {\n+              some(t) {\n+                let iface_ty = ast_ty_to_ty(cx.tcx, m_collect, t);\n+                cx.tcx.tcache.insert(local_def(it.id),\n+                                     {bounds: i_bounds, ty: iface_ty});\n+                alt ty::struct(cx.tcx, iface_ty) {\n+                  ty::ty_iface(did, tys) {\n+                    for if_m in *ty::iface_methods(cx.tcx, did) {\n+                        alt vec::find(my_methods,\n+                                      {|m| if_m.ident == m.ident}) {\n+                          some(m) {\n+                            compare_impl_method(cx.tcx, t.span, m,\n+                                                vec::len(tps), if_m, tys);\n+                          }\n+                          none. {\n+                            cx.tcx.sess.span_err(t.span, \"missing method `\" +\n+                                                 if_m.ident + \"`\");\n+                          }\n+                        }\n+                    }\n+                  }\n+                  _ {\n+                    cx.tcx.sess.span_fatal(t.span, \"can only implement \\\n+                                                    interface types\");\n+                  }\n+                }\n+              }\n+              _ {}\n+            }\n           }\n           ast::item_obj(object, ty_params, ctor_id) {\n             // Now we need to call ty_of_obj_ctor(); this is the type that\n@@ -1491,7 +1554,6 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n               ty::bound_iface(t) {\n                 let (iid, tps) = alt ty::struct(tcx, t) {\n                     ty::ty_iface(i, tps) { (i, tps) }\n-                    _ { cont; }\n                 };\n                 let ifce_methods = ty::iface_methods(tcx, iid);\n                 alt vec::position_pred(*ifce_methods, {|m| m.ident == name}) {\n@@ -2720,30 +2782,6 @@ fn check_method(ccx: @crate_ctxt, method: @ast::method) {\n     check_fn(ccx, ast::proto_bare, method.decl, method.body, method.id, none);\n }\n \n-fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n-                       impl_tps: uint, if_m: ty::method, substs: [ty::t]) {\n-    if impl_m.tps != if_m.tps {\n-        tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n-                          \"` has an incompatible set of type parameters\");\n-    } else {\n-        let impl_fty = ty::mk_fn(tcx, impl_m.fty);\n-        // Add dummy substs for the parameters of the impl method\n-        let substs = substs + vec::init_fn({|i|\n-            ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n-        }, vec::len(*if_m.tps));\n-        let if_fty = ty::substitute_type_params(tcx, substs,\n-                                                ty::mk_fn(tcx, if_m.fty));\n-        alt ty::unify::unify(impl_fty, if_fty, ty::unify::precise, tcx) {\n-          ty::unify::ures_err(err) {\n-            tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n-                              \"` has an incompatible type: \" +\n-                              ty::type_err_to_str(err));\n-          }\n-          _ {}\n-        }\n-    }\n-}\n-\n fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n     alt it.node {\n       ast::item_const(_, e) { check_const(ccx, it.span, e, it.id); }\n@@ -2762,70 +2800,15 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         // Now remove the info from the stack.\n         vec::pop(ccx.self_infos);\n       }\n-      ast::item_impl(tps, ifce, ty, ms) {\n+      ast::item_impl(tps, _, ty, ms) {\n         ccx.self_infos += [self_impl(ast_ty_to_ty(ccx.tcx, m_check, ty))];\n-        let my_methods = vec::map(ms, {|m|\n-            check_method(ccx, m);\n-            ty_of_method(ccx.tcx, m_check, m)\n-        });\n+        for m in ms { check_method(ccx, m); }\n         vec::pop(ccx.self_infos);\n-        alt ifce {\n-          some(ty) {\n-            let iface_ty = ast_ty_to_ty(ccx.tcx, m_check, ty);\n-            alt ty::struct(ccx.tcx, iface_ty) {\n-              ty::ty_iface(did, tys) {\n-                for if_m in *ty::iface_methods(ccx.tcx, did) {\n-                    alt vec::find(my_methods, {|m| if_m.ident == m.ident}) {\n-                      some(m) {\n-                        compare_impl_method(ccx.tcx, ty.span, m,\n-                                            vec::len(tps), if_m, tys);\n-                      }\n-                      none. {\n-                        ccx.tcx.sess.span_err(ty.span, \"missing method `\" +\n-                                              if_m.ident + \"`\");\n-                      }\n-                    }\n-                }\n-                let tpt = {bounds: ty_param_bounds(ccx.tcx, m_check, tps),\n-                           ty: iface_ty};\n-                ccx.tcx.tcache.insert(local_def(it.id), tpt);\n-              }\n-              _ {\n-                ccx.tcx.sess.span_err(ty.span, \"can only implement interface \\\n-                                                types\");\n-              }\n-            }\n-          }\n-          _ {}\n-        }\n       }\n       _ {/* nothing to do */ }\n     }\n }\n \n-fn check_ty_params(ccx: @crate_ctxt, tps: [ast::ty_param]) {\n-    for tp in tps {\n-        let i = 0u;\n-        for bound in *tp.bounds {\n-            alt bound {\n-              ast::bound_iface(at) {\n-                let tbound = ccx.tcx.ty_param_bounds.get(tp.id)[i];\n-                let bound_ty = alt tbound { ty::bound_iface(t) { t } };\n-                alt ty::struct(ccx.tcx, bound_ty) {\n-                  ty::ty_iface(_, _) {}\n-                  _ {\n-                    ccx.tcx.sess.span_err(at.span, \"type parameter bounds \\\n-                                                    must be interface types\");\n-                  }\n-                }\n-              }\n-              _ {}\n-            }\n-            i += 1u;\n-        }\n-    }\n-}\n-\n fn arg_is_argv_ty(tcx: ty::ctxt, a: ty::arg) -> bool {\n     alt ty::struct(tcx, a.ty) {\n       ty::ty_vec(mt) {\n@@ -2907,7 +2890,6 @@ mod dict {\n         let tcx = fcx.ccx.tcx;\n         let (iface_id, iface_tps) = alt ty::struct(tcx, iface_ty) {\n             ty::ty_iface(did, tps) { (did, tps) }\n-            _ { tcx.sess.abort_if_errors(); fail; }\n         };\n         let ty = fixup_ty(fcx, sp, ty);\n         alt ty::struct(tcx, ty) {\n@@ -2989,13 +2971,7 @@ mod dict {\n     fn connect_iface_tps(fcx: @fn_ctxt, sp: span, impl_tys: [ty::t],\n                          iface_tys: [ty::t], impl_did: ast::def_id) {\n         let tcx = fcx.ccx.tcx;\n-        // FIXME[impl]\n-        assert impl_did.crate == ast::local_crate;\n-        let ity = alt tcx.items.get(impl_did.node) {\n-          ast_map::node_item(@{node: ast::item_impl(_, some(ity), _, _), _}) {\n-              ast_ty_to_ty(tcx, m_check, ity)\n-          }\n-        };\n+        let ity = option::get(ty::impl_iface(tcx, impl_did));\n         let iface_ty = ty::substitute_type_params(tcx, impl_tys, ity);\n         alt ty::struct(tcx, iface_ty) {\n           ty::ty_iface(_, tps) {\n@@ -3068,8 +3044,7 @@ fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n                 dict_map: std::map::new_int_hash(),\n                 tcx: tcx};\n     let visit = visit::mk_simple_visitor(@{\n-        visit_item: bind check_item(ccx, _),\n-        visit_ty_params: bind check_ty_params(ccx, _)\n+        visit_item: bind check_item(ccx, _)\n         with *visit::default_simple_visitor()\n     });\n     visit::visit_crate(*crate, (), visit);"}]}