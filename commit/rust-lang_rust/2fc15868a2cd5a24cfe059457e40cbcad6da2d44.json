{"sha": "2fc15868a2cd5a24cfe059457e40cbcad6da2d44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmYzE1ODY4YTJjZDVhMjRjZmUwNTk0NTdlNDBjYmNhZDZkYTJkNDQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-02-04T02:13:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-02-04T02:13:59Z"}, "message": "go back to the older model of coherence collect", "tree": {"sha": "284273281907fb7648b858cc40a58ce8b0766e06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/284273281907fb7648b858cc40a58ce8b0766e06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fc15868a2cd5a24cfe059457e40cbcad6da2d44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fc15868a2cd5a24cfe059457e40cbcad6da2d44", "html_url": "https://github.com/rust-lang/rust/commit/2fc15868a2cd5a24cfe059457e40cbcad6da2d44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fc15868a2cd5a24cfe059457e40cbcad6da2d44/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b5613cb1d7db44a7ef5cdd937c45e7d82743021", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b5613cb1d7db44a7ef5cdd937c45e7d82743021", "html_url": "https://github.com/rust-lang/rust/commit/4b5613cb1d7db44a7ef5cdd937c45e7d82743021"}], "stats": {"total": 62, "additions": 43, "deletions": 19}, "files": [{"sha": "2ffc3951cc94db96466248f17345fd0fba378366", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2fc15868a2cd5a24cfe059457e40cbcad6da2d44/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc15868a2cd5a24cfe059457e40cbcad6da2d44/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=2fc15868a2cd5a24cfe059457e40cbcad6da2d44", "patch": "@@ -75,6 +75,21 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n     pub fn keys(&self) -> Vec<M::Key> {\n         self.map.keys().cloned().collect()\n     }\n+\n+    /// Append `elem` to the vector stored for `k`, creating a new vector if needed.\n+    /// This is considered a write to `k`.\n+    ///\n+    /// NOTE: Caution is required when using this method. You should\n+    /// be sure that nobody is **reading from the vector** while you\n+    /// are writing to it. Eventually, it'd be nice to remove this.\n+    pub fn push<E: Clone>(&mut self, k: M::Key, elem: E)\n+        where M: DepTrackingMapConfig<Value=Vec<E>>\n+    {\n+        self.write(&k);\n+        self.map.entry(k)\n+                .or_insert(Vec::new())\n+                .push(elem);\n+    }\n }\n \n impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {"}, {"sha": "b6a863fd2ed0d533626972afbf1c6a219659a63d", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2fc15868a2cd5a24cfe059457e40cbcad6da2d44/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc15868a2cd5a24cfe059457e40cbcad6da2d44/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=2fc15868a2cd5a24cfe059457e40cbcad6da2d44", "patch": "@@ -15,8 +15,9 @@\n // done by the orphan and overlap modules. Then we build up various\n // mappings. That mapping code resides here.\n \n+use dep_graph::DepTrackingMap;\n use hir::def_id::DefId;\n-use rustc::ty::{self, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, maps, TyCtxt, TypeFoldable};\n use rustc::ty::{Ty, TyBool, TyChar, TyError};\n use rustc::ty::{TyParam, TyRawPtr};\n use rustc::ty::{TyRef, TyAdt, TyDynamic, TyNever, TyTuple};\n@@ -29,7 +30,7 @@ use rustc::dep_graph::DepNode;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{Item, ItemImpl};\n use rustc::hir;\n-use rustc::util::nodemap::DefIdMap;\n+use std::cell::RefMut;\n \n mod builtin;\n mod orphan;\n@@ -38,7 +39,7 @@ mod unsafety;\n \n struct CoherenceCollect<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    inherent_impls: DefIdMap<Vec<DefId>>,\n+    inherent_impls: RefMut<'a, DepTrackingMap<maps::InherentImpls<'tcx>>>,\n }\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceCollect<'a, 'tcx> {\n@@ -56,6 +57,16 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceCollect<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> CoherenceCollect<'a, 'tcx> {\n+    fn check(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+        let inherent_impls = tcx.inherent_impls.borrow_mut();\n+        let mut this = &mut CoherenceCollect { tcx, inherent_impls };\n+\n+        // Check implementations and traits. This populates the tables\n+        // containing the inherent methods and extension methods. It also\n+        // builds up the trait inheritance table.\n+        tcx.visit_all_item_likes_in_krate(DepNode::CoherenceCheckImpl, this);\n+    }\n+\n     // Returns the def ID of the base type, if there is one.\n     fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {\n         match ty.sty {\n@@ -77,18 +88,6 @@ impl<'a, 'tcx> CoherenceCollect<'a, 'tcx> {\n         }\n     }\n \n-    fn check(&mut self) {\n-        // Check implementations and traits. This populates the tables\n-        // containing the inherent methods and extension methods. It also\n-        // builds up the trait inheritance table.\n-        self.tcx.visit_all_item_likes_in_krate(DepNode::CoherenceCheckImpl, self);\n-\n-        // Transfer the inherent impl lists, not that they are known, into the tcx\n-        for (ty_def_id, impl_def_ids) in self.inherent_impls.drain() {\n-            self.tcx.inherent_impls.borrow_mut().insert(ty_def_id, impl_def_ids);\n-        }\n-    }\n-\n     fn check_implementation(&mut self, item: &Item) {\n         let tcx = self.tcx;\n         let impl_did = tcx.hir.local_def_id(item.id);\n@@ -127,9 +126,18 @@ impl<'a, 'tcx> CoherenceCollect<'a, 'tcx> {\n     }\n \n     fn add_inherent_impl(&mut self, base_def_id: DefId, impl_def_id: DefId) {\n-        self.inherent_impls.entry(base_def_id)\n-                           .or_insert(vec![])\n-                           .push(impl_def_id);\n+        // Subtle: it'd be better to collect these into a local map\n+        // and then write the vector only once all items are known,\n+        // but that leads to degenerate dep-graphs. The problem is\n+        // that the write of that big vector winds up having reads\n+        // from *all* impls in the krate, since we've lost the\n+        // precision basically.  This would be ok in the firewall\n+        // model so once we've made progess towards that we can modify\n+        // the strategy here. In the meantime, using `push` is ok\n+        // because we are doing this as a pre-pass before anyone\n+        // actually reads from `inherent_impls` -- and we know this is\n+        // true beacuse we hold the refcell lock.\n+        self.inherent_impls.push(base_def_id, impl_def_id);\n     }\n \n     fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'tcx>, impl_def_id: DefId) {\n@@ -169,8 +177,9 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: Def\n }\n \n pub fn check_coherence(ccx: &CrateCtxt) {\n+    CoherenceCollect::check(ccx.tcx);\n+\n     let _task = ccx.tcx.dep_graph.in_task(DepNode::Coherence);\n-    CoherenceCollect { tcx: ccx.tcx, inherent_impls: DefIdMap() }.check();\n     unsafety::check(ccx.tcx);\n     orphan::check(ccx.tcx);\n     overlap::check(ccx.tcx);"}]}