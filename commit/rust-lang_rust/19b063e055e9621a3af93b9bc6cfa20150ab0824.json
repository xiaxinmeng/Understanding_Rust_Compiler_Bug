{"sha": "19b063e055e9621a3af93b9bc6cfa20150ab0824", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5YjA2M2UwNTVlOTYyMWEzYWY5M2I5YmM2Y2ZhMjAxNTBhYjA4MjQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-24T22:17:11Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-24T23:02:04Z"}, "message": "Merge LoopState into GlobalState", "tree": {"sha": "674e7247d502247981c17d71b7ca94cfcaab5cae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/674e7247d502247981c17d71b7ca94cfcaab5cae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19b063e055e9621a3af93b9bc6cfa20150ab0824", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19b063e055e9621a3af93b9bc6cfa20150ab0824", "html_url": "https://github.com/rust-lang/rust/commit/19b063e055e9621a3af93b9bc6cfa20150ab0824", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19b063e055e9621a3af93b9bc6cfa20150ab0824/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bff7307b8c4cc8577ea2a58b8438afc70aab2bea", "url": "https://api.github.com/repos/rust-lang/rust/commits/bff7307b8c4cc8577ea2a58b8438afc70aab2bea", "html_url": "https://github.com/rust-lang/rust/commit/bff7307b8c4cc8577ea2a58b8438afc70aab2bea"}], "stats": {"total": 143, "additions": 64, "deletions": 79}, "files": [{"sha": "ad5f94e872acd80b4257288e5958440223b2c0d2", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/19b063e055e9621a3af93b9bc6cfa20150ab0824/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b063e055e9621a3af93b9bc6cfa20150ab0824/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=19b063e055e9621a3af93b9bc6cfa20150ab0824", "patch": "@@ -20,11 +20,12 @@ use crate::{\n     diagnostics::{CheckFixes, DiagnosticCollection},\n     from_proto,\n     line_endings::LineEndings,\n+    main_loop::ReqQueue,\n     request_metrics::{LatestRequests, RequestMetrics},\n     to_proto::url_from_abs_path,\n     Result,\n };\n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n \n fn create_flycheck(workspaces: &[ProjectWorkspace], config: &FlycheckConfig) -> Option<Flycheck> {\n     // FIXME: Figure out the multi-workspace situation\n@@ -40,12 +41,23 @@ fn create_flycheck(workspaces: &[ProjectWorkspace], config: &FlycheckConfig) ->\n     })\n }\n \n+#[derive(Eq, PartialEq)]\n+pub(crate) enum Status {\n+    Loading,\n+    Ready,\n+}\n+\n+impl Default for Status {\n+    fn default() -> Self {\n+        Status::Loading\n+    }\n+}\n+\n /// `GlobalState` is the primary mutable state of the language server\n ///\n /// The most interesting components are `vfs`, which stores a consistent\n /// snapshot of the file systems, and `analysis_host`, which stores our\n /// incremental salsa database.\n-#[derive(Debug)]\n pub(crate) struct GlobalState {\n     pub(crate) config: Config,\n     pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n@@ -54,10 +66,13 @@ pub(crate) struct GlobalState {\n     pub(crate) task_receiver: Receiver<vfs::loader::Message>,\n     pub(crate) flycheck: Option<Flycheck>,\n     pub(crate) diagnostics: DiagnosticCollection,\n-    pub(crate) proc_macro_client: ProcMacroClient,\n+    pub(crate) mem_docs: FxHashSet<VfsPath>,\n     pub(crate) vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,\n+    pub(crate) status: Status,\n+    pub(crate) req_queue: ReqQueue,\n     pub(crate) latest_requests: Arc<RwLock<LatestRequests>>,\n     source_root_config: SourceRootConfig,\n+    _proc_macro_client: ProcMacroClient,\n }\n \n /// An immutable snapshot of the world's state at a point in time.\n@@ -75,6 +90,7 @@ impl GlobalState {\n         workspaces: Vec<ProjectWorkspace>,\n         lru_capacity: Option<usize>,\n         config: Config,\n+        req_queue: ReqQueue,\n     ) -> GlobalState {\n         let mut change = AnalysisChange::new();\n \n@@ -136,13 +152,16 @@ impl GlobalState {\n             workspaces: Arc::new(workspaces),\n             analysis_host,\n             loader,\n-            vfs: Arc::new(RwLock::new((vfs, FxHashMap::default()))),\n             task_receiver,\n-            latest_requests: Default::default(),\n             flycheck,\n             diagnostics: Default::default(),\n-            proc_macro_client,\n+            mem_docs: FxHashSet::default(),\n+            vfs: Arc::new(RwLock::new((vfs, FxHashMap::default()))),\n+            status: Status::default(),\n+            req_queue,\n+            latest_requests: Default::default(),\n             source_root_config: project_folders.source_root_config,\n+            _proc_macro_client: proc_macro_client,\n         };\n         res.process_changes();\n         res"}, {"sha": "02e188b0285686cc898d8fcab8947b8dbd34f39f", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 39, "deletions": 73, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/19b063e055e9621a3af93b9bc6cfa20150ab0824/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b063e055e9621a3af93b9bc6cfa20150ab0824/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=19b063e055e9621a3af93b9bc6cfa20150ab0824", "patch": "@@ -11,24 +11,21 @@ use std::{\n };\n \n use crossbeam_channel::{never, select, unbounded, RecvError, Sender};\n-use lsp_server::{\n-    Connection, ErrorCode, Message, Notification, ReqQueue, Request, RequestId, Response,\n-};\n+use lsp_server::{Connection, ErrorCode, Message, Notification, Request, RequestId, Response};\n use lsp_types::{request::Request as _, NumberOrString, TextDocumentContentChangeEvent};\n use ra_db::VfsPath;\n use ra_flycheck::CheckTask;\n use ra_ide::{Canceled, FileId, LineIndex};\n use ra_prof::profile;\n use ra_project_model::{PackageRoot, ProjectWorkspace};\n-use rustc_hash::FxHashSet;\n use serde::{de::DeserializeOwned, Serialize};\n use threadpool::ThreadPool;\n \n use crate::{\n     config::{Config, FilesWatcher, LinkedProject},\n     diagnostics::DiagnosticTask,\n     from_proto,\n-    global_state::{file_id_to_url, GlobalState, GlobalStateSnapshot},\n+    global_state::{file_id_to_url, GlobalState, GlobalStateSnapshot, Status},\n     handlers, lsp_ext,\n     request_metrics::RequestMetrics,\n     Result,\n@@ -78,7 +75,6 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n         SetThreadPriority(thread, thread_priority_above_normal);\n     }\n \n-    let mut loop_state = LoopState::default();\n     let mut global_state = {\n         let workspaces = {\n             if config.linked_projects.is_empty() && config.notifications.cargo_toml_not_found {\n@@ -116,6 +112,8 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n                 .collect::<Vec<_>>()\n         };\n \n+        let mut req_queue = ReqQueue::default();\n+\n         if let FilesWatcher::Client = config.files.watcher {\n             let registration_options = lsp_types::DidChangeWatchedFilesRegistrationOptions {\n                 watchers: workspaces\n@@ -132,15 +130,15 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n                 register_options: Some(serde_json::to_value(registration_options).unwrap()),\n             };\n             let params = lsp_types::RegistrationParams { registrations: vec![registration] };\n-            let request = loop_state.req_queue.outgoing.register(\n+            let request = req_queue.outgoing.register(\n                 lsp_types::request::RegisterCapability::METHOD.to_string(),\n                 params,\n                 DO_NOTHING,\n             );\n             connection.sender.send(request.into()).unwrap();\n         }\n \n-        GlobalState::new(workspaces, config.lru_capacity, config)\n+        GlobalState::new(workspaces, config.lru_capacity, config, req_queue)\n     };\n \n     let pool = ThreadPool::default();\n@@ -172,15 +170,13 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n                 };\n             }\n             assert!(!global_state.vfs.read().0.has_changes());\n-            loop_turn(&pool, &task_sender, &connection, &mut global_state, &mut loop_state, event)?;\n+            loop_turn(&pool, &task_sender, &connection, &mut global_state, event)?;\n             assert!(!global_state.vfs.read().0.has_changes());\n         }\n     }\n     global_state.analysis_host.request_cancellation();\n     log::info!(\"waiting for tasks to finish...\");\n-    task_receiver.into_iter().for_each(|task| {\n-        on_task(task, &connection.sender, &mut loop_state.req_queue.incoming, &mut global_state)\n-    });\n+    task_receiver.into_iter().for_each(|task| on_task(task, &connection.sender, &mut global_state));\n     log::info!(\"...tasks have finished\");\n     log::info!(\"joining threadpool...\");\n     pool.join();\n@@ -244,35 +240,15 @@ impl fmt::Debug for Event {\n     }\n }\n \n-type ReqHandler = fn(&mut GlobalState, Response);\n+pub(crate) type ReqHandler = fn(&mut GlobalState, Response);\n+pub(crate) type ReqQueue = lsp_server::ReqQueue<(&'static str, Instant), ReqHandler>;\n const DO_NOTHING: ReqHandler = |_, _| ();\n-type Incoming = lsp_server::Incoming<(&'static str, Instant)>;\n-\n-#[derive(Default)]\n-struct LoopState {\n-    req_queue: ReqQueue<(&'static str, Instant), ReqHandler>,\n-    mem_docs: FxHashSet<VfsPath>,\n-    status: Status,\n-}\n-\n-#[derive(Eq, PartialEq)]\n-enum Status {\n-    Loading,\n-    Ready,\n-}\n-\n-impl Default for Status {\n-    fn default() -> Self {\n-        Status::Loading\n-    }\n-}\n \n fn loop_turn(\n     pool: &ThreadPool,\n     task_sender: &Sender<Task>,\n     connection: &Connection,\n     global_state: &mut GlobalState,\n-    loop_state: &mut LoopState,\n     event: Event,\n ) -> Result<()> {\n     let loop_start = Instant::now();\n@@ -288,43 +264,37 @@ fn loop_turn(\n     let mut became_ready = false;\n     match event {\n         Event::Task(task) => {\n-            on_task(task, &connection.sender, &mut loop_state.req_queue.incoming, global_state);\n+            on_task(task, &connection.sender, global_state);\n             global_state.maybe_collect_garbage();\n         }\n         Event::Vfs(task) => match task {\n             vfs::loader::Message::Loaded { files } => {\n                 let vfs = &mut global_state.vfs.write().0;\n                 for (path, contents) in files {\n                     let path = VfsPath::from(path);\n-                    if !loop_state.mem_docs.contains(&path) {\n+                    if !global_state.mem_docs.contains(&path) {\n                         vfs.set_file_contents(path, contents)\n                     }\n                 }\n             }\n             vfs::loader::Message::Progress { n_total, n_done } => {\n                 if n_done == n_total {\n-                    loop_state.status = Status::Ready;\n+                    global_state.status = Status::Ready;\n                     became_ready = true;\n                 }\n-                report_progress(loop_state, &connection.sender, n_done, n_total, \"roots scanned\")\n+                report_progress(global_state, &connection.sender, n_done, n_total, \"roots scanned\")\n             }\n         },\n         Event::CheckWatcher(task) => on_check_task(task, global_state, task_sender)?,\n         Event::Msg(msg) => match msg {\n-            Message::Request(req) => on_request(\n-                global_state,\n-                &mut loop_state.req_queue.incoming,\n-                pool,\n-                task_sender,\n-                &connection.sender,\n-                loop_start,\n-                req,\n-            )?,\n+            Message::Request(req) => {\n+                on_request(global_state, pool, task_sender, &connection.sender, loop_start, req)?\n+            }\n             Message::Notification(not) => {\n-                on_notification(&connection.sender, global_state, loop_state, not)?;\n+                on_notification(&connection.sender, global_state, not)?;\n             }\n             Message::Response(resp) => {\n-                let handler = loop_state.req_queue.outgoing.complete(resp.id.clone());\n+                let handler = global_state.req_queue.outgoing.complete(resp.id.clone());\n                 handler(global_state, resp)\n             }\n         },\n@@ -338,8 +308,8 @@ fn loop_turn(\n         }\n     }\n \n-    if loop_state.status == Status::Ready && (state_changed || became_ready) {\n-        let subscriptions = loop_state\n+    if global_state.status == Status::Ready && (state_changed || became_ready) {\n+        let subscriptions = global_state\n             .mem_docs\n             .iter()\n             .map(|path| global_state.vfs.read().0.file_id(&path).unwrap())\n@@ -373,18 +343,15 @@ fn loop_turn(\n     Ok(())\n }\n \n-fn on_task(\n-    task: Task,\n-    msg_sender: &Sender<Message>,\n-    incoming_requests: &mut Incoming,\n-    state: &mut GlobalState,\n-) {\n+fn on_task(task: Task, msg_sender: &Sender<Message>, global_state: &mut GlobalState) {\n     match task {\n         Task::Respond(response) => {\n-            if let Some((method, start)) = incoming_requests.complete(response.id.clone()) {\n+            if let Some((method, start)) =\n+                global_state.req_queue.incoming.complete(response.id.clone())\n+            {\n                 let duration = start.elapsed();\n                 log::info!(\"handled req#{} in {:?}\", response.id, duration);\n-                state.complete_request(RequestMetrics {\n+                global_state.complete_request(RequestMetrics {\n                     id: response.id.clone(),\n                     method: method.to_string(),\n                     duration,\n@@ -395,13 +362,12 @@ fn on_task(\n         Task::Notify(n) => {\n             msg_sender.send(n.into()).unwrap();\n         }\n-        Task::Diagnostic(task) => on_diagnostic_task(task, msg_sender, state),\n+        Task::Diagnostic(task) => on_diagnostic_task(task, msg_sender, global_state),\n     }\n }\n \n fn on_request(\n     global_state: &mut GlobalState,\n-    incoming_requests: &mut Incoming,\n     pool: &ThreadPool,\n     task_sender: &Sender<Task>,\n     msg_sender: &Sender<Message>,\n@@ -414,7 +380,6 @@ fn on_request(\n         global_state,\n         task_sender,\n         msg_sender,\n-        incoming_requests,\n         request_received,\n     };\n     pool_dispatcher\n@@ -469,7 +434,6 @@ fn on_request(\n fn on_notification(\n     msg_sender: &Sender<Message>,\n     global_state: &mut GlobalState,\n-    loop_state: &mut LoopState,\n     not: Notification,\n ) -> Result<()> {\n     let not = match notification_cast::<lsp_types::notification::Cancel>(not) {\n@@ -478,7 +442,7 @@ fn on_notification(\n                 NumberOrString::Number(id) => id.into(),\n                 NumberOrString::String(id) => id.into(),\n             };\n-            if let Some(response) = loop_state.req_queue.incoming.cancel(id) {\n+            if let Some(response) = global_state.req_queue.incoming.cancel(id) {\n                 msg_sender.send(response.into()).unwrap()\n             }\n             return Ok(());\n@@ -488,7 +452,7 @@ fn on_notification(\n     let not = match notification_cast::<lsp_types::notification::DidOpenTextDocument>(not) {\n         Ok(params) => {\n             if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                if !loop_state.mem_docs.insert(path.clone()) {\n+                if !global_state.mem_docs.insert(path.clone()) {\n                     log::error!(\"duplicate DidOpenTextDocument: {}\", path)\n                 }\n                 global_state\n@@ -504,7 +468,7 @@ fn on_notification(\n     let not = match notification_cast::<lsp_types::notification::DidChangeTextDocument>(not) {\n         Ok(params) => {\n             if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                assert!(loop_state.mem_docs.contains(&path));\n+                assert!(global_state.mem_docs.contains(&path));\n                 let vfs = &mut global_state.vfs.write().0;\n                 let file_id = vfs.file_id(&path).unwrap();\n                 let mut text = String::from_utf8(vfs.file_contents(file_id).to_vec()).unwrap();\n@@ -518,7 +482,7 @@ fn on_notification(\n     let not = match notification_cast::<lsp_types::notification::DidCloseTextDocument>(not) {\n         Ok(params) => {\n             if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                if !loop_state.mem_docs.remove(&path) {\n+                if !global_state.mem_docs.remove(&path) {\n                     log::error!(\"orphan DidCloseTextDocument: {}\", path)\n                 }\n                 if let Some(path) = path.as_path() {\n@@ -549,7 +513,7 @@ fn on_notification(\n         Ok(_) => {\n             // As stated in https://github.com/microsoft/language-server-protocol/issues/676,\n             // this notification's parameters should be ignored and the actual config queried separately.\n-            let request = loop_state.req_queue.outgoing.register(\n+            let request = global_state.req_queue.outgoing.register(\n                 lsp_types::request::WorkspaceConfiguration::METHOD.to_string(),\n                 lsp_types::ConfigurationParams {\n                     items: vec![lsp_types::ConfigurationItem {\n@@ -732,7 +696,7 @@ fn on_diagnostic_task(task: DiagnosticTask, msg_sender: &Sender<Message>, state:\n }\n \n fn report_progress(\n-    loop_state: &mut LoopState,\n+    global_state: &mut GlobalState,\n     sender: &Sender<Message>,\n     done: usize,\n     total: usize,\n@@ -742,7 +706,7 @@ fn report_progress(\n     let message = Some(format!(\"{}/{} {}\", done, total, message));\n     let percentage = Some(100.0 * done as f64 / total.max(1) as f64);\n     let work_done_progress = if done == 0 {\n-        let work_done_progress_create = loop_state.req_queue.outgoing.register(\n+        let work_done_progress_create = global_state.req_queue.outgoing.register(\n             lsp_types::request::WorkDoneProgressCreate::METHOD.to_string(),\n             lsp_types::WorkDoneProgressCreateParams { token: token.clone() },\n             DO_NOTHING,\n@@ -777,7 +741,6 @@ struct PoolDispatcher<'a> {\n     req: Option<Request>,\n     pool: &'a ThreadPool,\n     global_state: &'a mut GlobalState,\n-    incoming_requests: &'a mut Incoming,\n     msg_sender: &'a Sender<Message>,\n     task_sender: &'a Sender<Task>,\n     request_received: Instant,\n@@ -806,7 +769,7 @@ impl<'a> PoolDispatcher<'a> {\n             result_to_task::<R>(id, result)\n         })\n         .map_err(|_| format!(\"sync task {:?} panicked\", R::METHOD))?;\n-        on_task(task, self.msg_sender, self.incoming_requests, self.global_state);\n+        on_task(task, self.msg_sender, self.global_state);\n         Ok(self)\n     }\n \n@@ -853,7 +816,10 @@ impl<'a> PoolDispatcher<'a> {\n                 return None;\n             }\n         };\n-        self.incoming_requests.register(id.clone(), (R::METHOD, self.request_received));\n+        self.global_state\n+            .req_queue\n+            .incoming\n+            .register(id.clone(), (R::METHOD, self.request_received));\n         Some((id, params))\n     }\n "}]}