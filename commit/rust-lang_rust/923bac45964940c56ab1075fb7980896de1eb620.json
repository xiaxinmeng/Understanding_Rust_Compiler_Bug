{"sha": "923bac45964940c56ab1075fb7980896de1eb620", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyM2JhYzQ1OTY0OTQwYzU2YWIxMDc1ZmI3OTgwODk2ZGUxZWI2MjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-06T20:22:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-06T20:22:35Z"}, "message": "Auto merge of #36025 - michaelwoerister:incr-comp-hash-spans, r=nikomatsakis\n\nincr. comp.: Take spans into account for ICH\n\nThis PR makes the ICH (incr. comp. hash) take spans into account when debuginfo is enabled.\n\nA side-effect of this is that the SVH (which is based on the ICHs of all items in the crate) becomes sensitive to the tiniest change in a code base if debuginfo is enabled. Since we are not trying to model ABI compatibility via the SVH anymore (this is done via the crate disambiguator now), this should be not be a problem.\n\nFixes #33888.\nFixes #32753.", "tree": {"sha": "c917d9e5681f15bdb3f7e72e707ce5934875d3f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c917d9e5681f15bdb3f7e72e707ce5934875d3f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/923bac45964940c56ab1075fb7980896de1eb620", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/923bac45964940c56ab1075fb7980896de1eb620", "html_url": "https://github.com/rust-lang/rust/commit/923bac45964940c56ab1075fb7980896de1eb620", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/923bac45964940c56ab1075fb7980896de1eb620/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13c4e32e7aca87cbf867be68bf0fc45528bb3fcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/13c4e32e7aca87cbf867be68bf0fc45528bb3fcf", "html_url": "https://github.com/rust-lang/rust/commit/13c4e32e7aca87cbf867be68bf0fc45528bb3fcf"}, {"sha": "3057b7b9749f16ad982b54b4bdeee7e2c8a845bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3057b7b9749f16ad982b54b4bdeee7e2c8a845bb", "html_url": "https://github.com/rust-lang/rust/commit/3057b7b9749f16ad982b54b4bdeee7e2c8a845bb"}], "stats": {"total": 988, "additions": 843, "deletions": 145}, "files": [{"sha": "2009e18f6ee2016c8a404d776d393693fb729ecf", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=923bac45964940c56ab1075fb7980896de1eb620", "patch": "@@ -913,6 +913,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"dump MIR state at various points in translation\"),\n     dump_mir_dir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"the directory the MIR is dumped into\"),\n+    perf_stats: bool = (false, parse_bool, [UNTRACKED],\n+          \"print some performance-related statistics\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "3477ec6f99af1afc8e34878b9ea83059bc3e5e5a", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=923bac45964940c56ab1075fb7980896de1eb620", "patch": "@@ -18,6 +18,7 @@ use session::search_paths::PathKind;\n use session::config::{DebugInfoLevel, PanicStrategy};\n use ty::tls;\n use util::nodemap::{NodeMap, FnvHashMap};\n+use util::common::duration_to_secs_str;\n use mir::transform as mir_pass;\n \n use syntax::ast::{NodeId, Name};\n@@ -43,6 +44,7 @@ use std::env;\n use std::ffi::CString;\n use std::rc::Rc;\n use std::fmt;\n+use std::time::Duration;\n use libc::c_int;\n \n pub mod config;\n@@ -105,9 +107,23 @@ pub struct Session {\n \n     incr_comp_session: RefCell<IncrCompSession>,\n \n+    /// Some measurements that are being gathered during compilation.\n+    pub perf_stats: PerfStats,\n+\n     next_node_id: Cell<ast::NodeId>,\n }\n \n+pub struct PerfStats {\n+    // The accumulated time needed for computing the SVH of the crate\n+    pub svh_time: Cell<Duration>,\n+    // The accumulated time spent on computing incr. comp. hashes\n+    pub incr_comp_hashes_time: Cell<Duration>,\n+    // The number of incr. comp. hash computations performed\n+    pub incr_comp_hashes_count: Cell<u64>,\n+    // The accumulated time spent on computing symbol hashes\n+    pub symbol_hash_time: Cell<Duration>,\n+}\n+\n impl Session {\n     pub fn local_crate_disambiguator(&self) -> token::InternedString {\n         self.crate_disambiguator.borrow().clone()\n@@ -411,6 +427,17 @@ impl Session {\n             None\n         }\n     }\n+\n+    pub fn print_perf_stats(&self) {\n+        println!(\"Total time spent computing SVHs:               {}\",\n+                 duration_to_secs_str(self.perf_stats.svh_time.get()));\n+        println!(\"Total time spent computing incr. comp. hashes: {}\",\n+                 duration_to_secs_str(self.perf_stats.incr_comp_hashes_time.get()));\n+        println!(\"Total number of incr. comp. hashes computed:   {}\",\n+                 self.perf_stats.incr_comp_hashes_count.get());\n+        println!(\"Total time spent computing symbol hashes:      {}\",\n+                 duration_to_secs_str(self.perf_stats.symbol_hash_time.get()));\n+    }\n }\n \n pub fn build_session(sopts: config::Options,\n@@ -528,6 +555,12 @@ pub fn build_session_(sopts: config::Options,\n         available_macros: RefCell::new(HashSet::new()),\n         imported_macro_spans: RefCell::new(HashMap::new()),\n         incr_comp_session: RefCell::new(IncrCompSession::NotInitialized),\n+        perf_stats: PerfStats {\n+            svh_time: Cell::new(Duration::from_secs(0)),\n+            incr_comp_hashes_time: Cell::new(Duration::from_secs(0)),\n+            incr_comp_hashes_count: Cell::new(0),\n+            symbol_hash_time: Cell::new(Duration::from_secs(0)),\n+        }\n     };\n \n     init_llvm(&sess);"}, {"sha": "78f20b77f3185b478690a390e59d95b9c4e95ec3", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=923bac45964940c56ab1075fb7980896de1eb620", "patch": "@@ -17,7 +17,7 @@ use std::fmt::Debug;\n use std::hash::{Hash, BuildHasher};\n use std::iter::repeat;\n use std::path::Path;\n-use std::time::Instant;\n+use std::time::{Duration, Instant};\n \n use hir;\n use hir::intravisit;\n@@ -47,27 +47,44 @@ pub fn time<T, F>(do_it: bool, what: &str, f: F) -> T where\n     let rv = f();\n     let dur = start.elapsed();\n \n-    // Hack up our own formatting for the duration to make it easier for scripts\n-    // to parse (always use the same number of decimal places and the same unit).\n-    const NANOS_PER_SEC: f64 = 1_000_000_000.0;\n-    let secs = dur.as_secs() as f64;\n-    let secs = secs + dur.subsec_nanos() as f64 / NANOS_PER_SEC;\n-\n     let mem_string = match get_resident() {\n         Some(n) => {\n             let mb = n as f64 / 1_000_000.0;\n             format!(\"; rss: {}MB\", mb.round() as usize)\n         }\n         None => \"\".to_owned(),\n     };\n-    println!(\"{}time: {:.3}{}\\t{}\", repeat(\"  \").take(old).collect::<String>(),\n-             secs, mem_string, what);\n+    println!(\"{}time: {}{}\\t{}\",\n+             repeat(\"  \").take(old).collect::<String>(),\n+             duration_to_secs_str(dur),\n+             mem_string,\n+             what);\n \n     DEPTH.with(|slot| slot.set(old));\n \n     rv\n }\n \n+// Hack up our own formatting for the duration to make it easier for scripts\n+// to parse (always use the same number of decimal places and the same unit).\n+pub fn duration_to_secs_str(dur: Duration) -> String {\n+    const NANOS_PER_SEC: f64 = 1_000_000_000.0;\n+    let secs = dur.as_secs() as f64 +\n+               dur.subsec_nanos() as f64 / NANOS_PER_SEC;\n+\n+    format!(\"{:.3}\", secs)\n+}\n+\n+pub fn record_time<T, F>(accu: &Cell<Duration>, f: F) -> T where\n+    F: FnOnce() -> T,\n+{\n+    let start = Instant::now();\n+    let rv = f();\n+    let duration = start.elapsed();\n+    accu.set(duration + accu.get());\n+    rv\n+}\n+\n // Like std::macros::try!, but for Option<>.\n macro_rules! option_try(\n     ($e:expr) => (match $e { Some(e) => e, None => return None })"}, {"sha": "47f623266f3b74cff40d833e4f6e8d216a59445f", "filename": "src/librustc_data_structures/fnv.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibrustc_data_structures%2Ffnv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibrustc_data_structures%2Ffnv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffnv.rs?ref=923bac45964940c56ab1075fb7980896de1eb620", "patch": "@@ -57,3 +57,9 @@ impl Hasher for FnvHasher {\n         self.0\n     }\n }\n+\n+pub fn hash<T: Hash>(v: &T) -> u64 {\n+    let mut state = FnvHasher::default();\n+    v.hash(&mut state);\n+    state.finish()\n+}"}, {"sha": "2d4bd6af6d4af91c98eaf12f71ea5784cb7d0872", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=923bac45964940c56ab1075fb7980896de1eb620", "patch": "@@ -235,6 +235,10 @@ pub fn compile_input(sess: &Session,\n     // any more, we can finalize it (which involves renaming it)\n     rustc_incremental::finalize_session_directory(sess, trans.link.crate_hash);\n \n+    if sess.opts.debugging_opts.perf_stats {\n+        sess.print_perf_stats();\n+    }\n+\n     controller_entry_point!(compilation_done,\n                             sess,\n                             CompileState::state_when_compilation_done(input, sess, outdir, output),"}, {"sha": "ad9c48420e217d04b5a82ba23808b7a1064464c3", "filename": "src/librustc_incremental/calculate_svh/caching_codemap_view.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibrustc_incremental%2Fcalculate_svh%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibrustc_incremental%2Fcalculate_svh%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fcaching_codemap_view.rs?ref=923bac45964940c56ab1075fb7980896de1eb620", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty::TyCtxt;\n+use std::rc::Rc;\n+use syntax::codemap::CodeMap;\n+use syntax_pos::{BytePos, FileMap};\n+\n+#[derive(Clone)]\n+struct CacheEntry {\n+    time_stamp: usize,\n+    line_number: usize,\n+    line_start: BytePos,\n+    line_end: BytePos,\n+    file: Rc<FileMap>,\n+}\n+\n+pub struct CachingCodemapView<'tcx> {\n+    codemap: &'tcx CodeMap,\n+    line_cache: [CacheEntry; 3],\n+    time_stamp: usize,\n+}\n+\n+impl<'tcx> CachingCodemapView<'tcx> {\n+    pub fn new<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CachingCodemapView<'tcx> {\n+        let codemap = tcx.sess.codemap();\n+        let first_file = codemap.files.borrow()[0].clone();\n+        let entry = CacheEntry {\n+            time_stamp: 0,\n+            line_number: 0,\n+            line_start: BytePos(0),\n+            line_end: BytePos(0),\n+            file: first_file,\n+        };\n+\n+        CachingCodemapView {\n+            codemap: codemap,\n+            line_cache: [entry.clone(), entry.clone(), entry.clone()],\n+            time_stamp: 0,\n+        }\n+    }\n+\n+    pub fn codemap(&self) -> &'tcx CodeMap {\n+        self.codemap\n+    }\n+\n+    pub fn byte_pos_to_line_and_col(&mut self,\n+                                    pos: BytePos)\n+                                    -> Option<(Rc<FileMap>, usize, BytePos)> {\n+        self.time_stamp += 1;\n+\n+        // Check if the position is in one of the cached lines\n+        for cache_entry in self.line_cache.iter_mut() {\n+            if pos >= cache_entry.line_start && pos < cache_entry.line_end {\n+                cache_entry.time_stamp = self.time_stamp;\n+                return Some((cache_entry.file.clone(),\n+                             cache_entry.line_number,\n+                             pos - cache_entry.line_start));\n+            }\n+        }\n+\n+        // No cache hit ...\n+        let mut oldest = 0;\n+        for index in 1 .. self.line_cache.len() {\n+            if self.line_cache[index].time_stamp < self.line_cache[oldest].time_stamp {\n+                oldest = index;\n+            }\n+        }\n+\n+        let cache_entry = &mut self.line_cache[oldest];\n+\n+        // If the entry doesn't point to the correct file, fix it up\n+        if pos < cache_entry.file.start_pos || pos >= cache_entry.file.end_pos {\n+            let file_valid;\n+            let files = self.codemap.files.borrow();\n+\n+            if files.len() > 0 {\n+                let file_index = self.codemap.lookup_filemap_idx(pos);\n+                let file = files[file_index].clone();\n+\n+                if pos >= file.start_pos && pos < file.end_pos {\n+                    cache_entry.file = file;\n+                    file_valid = true;\n+                } else {\n+                    file_valid = false;\n+                }\n+            } else {\n+                file_valid = false;\n+            }\n+\n+            if !file_valid {\n+                return None;\n+            }\n+        }\n+\n+        let line_index = cache_entry.file.lookup_line(pos).unwrap();\n+        let line_bounds = cache_entry.file.line_bounds(line_index);\n+\n+        cache_entry.line_number = line_index + 1;\n+        cache_entry.line_start = line_bounds.0;\n+        cache_entry.line_end = line_bounds.1;\n+        cache_entry.time_stamp = self.time_stamp;\n+\n+        return Some((cache_entry.file.clone(),\n+                     cache_entry.line_number,\n+                     pos - cache_entry.line_start));\n+    }\n+}"}, {"sha": "c54fe2114517e17d234ba9044a6c5acc886f5605", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=923bac45964940c56ab1075fb7980896de1eb620", "patch": "@@ -35,32 +35,46 @@ use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::intravisit as visit;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashMap;\n+use rustc::util::common::record_time;\n+use rustc::session::config::DebugInfoLevel::NoDebugInfo;\n \n use self::def_path_hash::DefPathHashes;\n use self::svh_visitor::StrictVersionHashVisitor;\n+use self::caching_codemap_view::CachingCodemapView;\n \n mod def_path_hash;\n mod svh_visitor;\n+mod caching_codemap_view;\n \n pub type IncrementalHashesMap = FnvHashMap<DepNode<DefId>, u64>;\n \n pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                                     -> IncrementalHashesMap {\n     let _ignore = tcx.dep_graph.in_ignore();\n     let krate = tcx.map.krate();\n-    let mut visitor = HashItemsVisitor { tcx: tcx,\n-                                         hashes: FnvHashMap(),\n-                                         def_path_hashes: DefPathHashes::new(tcx) };\n-    visitor.calculate_def_id(DefId::local(CRATE_DEF_INDEX), |v| visit::walk_crate(v, krate));\n-    krate.visit_all_items(&mut visitor);\n-    visitor.compute_crate_hash();\n+    let hash_spans = tcx.sess.opts.debuginfo != NoDebugInfo;\n+    let mut visitor = HashItemsVisitor {\n+        tcx: tcx,\n+        hashes: FnvHashMap(),\n+        def_path_hashes: DefPathHashes::new(tcx),\n+        codemap: CachingCodemapView::new(tcx),\n+        hash_spans: hash_spans,\n+    };\n+    record_time(&tcx.sess.perf_stats.incr_comp_hashes_time, || {\n+        visitor.calculate_def_id(DefId::local(CRATE_DEF_INDEX),\n+                                 |v| visit::walk_crate(v, krate));\n+        krate.visit_all_items(&mut visitor);\n+    });\n+    record_time(&tcx.sess.perf_stats.svh_time, || visitor.compute_crate_hash());\n     visitor.hashes\n }\n \n struct HashItemsVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_path_hashes: DefPathHashes<'a, 'tcx>,\n+    codemap: CachingCodemapView<'tcx>,\n     hashes: IncrementalHashesMap,\n+    hash_spans: bool,\n }\n \n impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n@@ -81,7 +95,9 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n         let mut state = SipHasher::new();\n         walk_op(&mut StrictVersionHashVisitor::new(&mut state,\n                                                    self.tcx,\n-                                                   &mut self.def_path_hashes));\n+                                                   &mut self.def_path_hashes,\n+                                                   &mut self.codemap,\n+                                                   self.hash_spans));\n         let item_hash = state.finish();\n         self.hashes.insert(DepNode::Hir(def_id), item_hash);\n         debug!(\"calculate_item_hash: def_id={:?} hash={:?}\", def_id, item_hash);\n@@ -117,9 +133,13 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n             item_hashes.hash(&mut crate_state);\n         }\n \n-        for attr in &krate.attrs {\n-            debug!(\"krate attr {:?}\", attr);\n-            attr.meta().hash(&mut crate_state);\n+        {\n+            let mut visitor = StrictVersionHashVisitor::new(&mut crate_state,\n+                                                            self.tcx,\n+                                                            &mut self.def_path_hashes,\n+                                                            &mut self.codemap,\n+                                                            self.hash_spans);\n+            visitor.hash_attributes(&krate.attrs);\n         }\n \n         let crate_hash = crate_state.finish();"}, {"sha": "af8ec6c62578f9b705b303d60a8c7b452b11340e", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 336, "deletions": 81, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=923bac45964940c56ab1075fb7980896de1eb620", "patch": "@@ -13,43 +13,106 @@\n // hash computation, but for many kinds of items the order of\n // declaration should be irrelevant to the ABI.\n \n-pub use self::SawExprComponent::*;\n-pub use self::SawStmtComponent::*;\n+use self::SawExprComponent::*;\n use self::SawAbiComponent::*;\n use syntax::ast::{self, Name, NodeId};\n use syntax::parse::token;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::def::{Def, PathResolution};\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit as visit;\n-use rustc::hir::intravisit::{Visitor, FnKind};\n use rustc::ty::TyCtxt;\n-\n+use rustc_data_structures::fnv;\n use std::hash::{Hash, SipHasher};\n \n use super::def_path_hash::DefPathHashes;\n+use super::caching_codemap_view::CachingCodemapView;\n+\n+const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\"cfg\",\n+                                                      \"rustc_clean\",\n+                                                      \"rustc_dirty\"];\n \n pub struct StrictVersionHashVisitor<'a, 'hash: 'a, 'tcx: 'hash> {\n     pub tcx: TyCtxt<'hash, 'tcx, 'tcx>,\n     pub st: &'a mut SipHasher,\n-\n     // collect a deterministic hash of def-ids that we have seen\n     def_path_hashes: &'a mut DefPathHashes<'hash, 'tcx>,\n+    hash_spans: bool,\n+    codemap: &'a mut CachingCodemapView<'tcx>,\n }\n \n impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n     pub fn new(st: &'a mut SipHasher,\n                tcx: TyCtxt<'hash, 'tcx, 'tcx>,\n-               def_path_hashes: &'a mut DefPathHashes<'hash, 'tcx>)\n+               def_path_hashes: &'a mut DefPathHashes<'hash, 'tcx>,\n+               codemap: &'a mut CachingCodemapView<'tcx>,\n+               hash_spans: bool)\n                -> Self {\n-        StrictVersionHashVisitor { st: st, tcx: tcx, def_path_hashes: def_path_hashes }\n+        StrictVersionHashVisitor {\n+            st: st,\n+            tcx: tcx,\n+            def_path_hashes: def_path_hashes,\n+            hash_spans: hash_spans,\n+            codemap: codemap,\n+        }\n     }\n \n     fn compute_def_id_hash(&mut self, def_id: DefId) -> u64 {\n         self.def_path_hashes.hash(def_id)\n     }\n+\n+    // Hash a span in a stable way. We can't directly hash the span's BytePos\n+    // fields (that would be similar to hashing pointers, since those are just\n+    // offsets into the CodeMap). Instead, we hash the (file name, line, column)\n+    // triple, which stays the same even if the containing FileMap has moved\n+    // within the CodeMap.\n+    // Also note that we are hashing byte offsets for the column, not unicode\n+    // codepoint offsets. For the purpose of the hash that's sufficient.\n+    fn hash_span(&mut self, span: Span) {\n+        debug_assert!(self.hash_spans);\n+        debug!(\"hash_span: st={:?}\", self.st);\n+\n+        // If this is not an empty or invalid span, we want to hash the last\n+        // position that belongs to it, as opposed to hashing the first\n+        // position past it.\n+        let span_hi = if span.hi > span.lo {\n+            // We might end up in the middle of a multibyte character here,\n+            // but that's OK, since we are not trying to decode anything at\n+            // this position.\n+            span.hi - BytePos(1)\n+        } else {\n+            span.hi\n+        };\n+\n+        let loc1 = self.codemap.byte_pos_to_line_and_col(span.lo);\n+        let loc2 = self.codemap.byte_pos_to_line_and_col(span_hi);\n+\n+        let expansion_kind = match span.expn_id {\n+            NO_EXPANSION => SawSpanExpnKind::NoExpansion,\n+            COMMAND_LINE_EXPN => SawSpanExpnKind::CommandLine,\n+            _ => SawSpanExpnKind::SomeExpansion,\n+        };\n+\n+        SawSpan(loc1.as_ref().map(|&(ref fm, line, col)| (&fm.name[..], line, col)),\n+                loc2.as_ref().map(|&(ref fm, line, col)| (&fm.name[..], line, col)),\n+                expansion_kind)\n+            .hash(self.st);\n+\n+        if expansion_kind == SawSpanExpnKind::SomeExpansion {\n+            let call_site = self.codemap.codemap().source_callsite(span);\n+            self.hash_span(call_site);\n+        }\n+    }\n+\n+    fn hash_discriminant<T>(&mut self, v: &T) {\n+        unsafe {\n+            let disr = ::std::intrinsics::discriminant_value(v);\n+            debug!(\"hash_discriminant: disr={}, st={:?}\", disr, self.st);\n+            disr.hash(self.st);\n+        }\n+    }\n }\n \n // To off-load the bulk of the hash-computation on #[derive(Hash)],\n@@ -80,26 +143,38 @@ enum SawAbiComponent<'a> {\n     SawIdent(token::InternedString),\n     SawStructDef(token::InternedString),\n \n-    SawLifetime(token::InternedString),\n-    SawLifetimeDef(token::InternedString),\n+    SawLifetime,\n+    SawLifetimeDef(usize),\n \n     SawMod,\n     SawForeignItem,\n     SawItem,\n     SawTy,\n     SawGenerics,\n-    SawFn,\n     SawTraitItem,\n     SawImplItem,\n     SawStructField,\n     SawVariant,\n-    SawPath,\n+    SawPath(bool),\n+    SawPathSegment,\n+    SawPathParameters,\n+    SawPathListItem,\n     SawBlock,\n     SawPat,\n     SawLocal,\n     SawArm,\n     SawExpr(SawExprComponent<'a>),\n-    SawStmt(SawStmtComponent),\n+    SawStmt,\n+    SawVis,\n+    SawWherePredicate,\n+    SawTyParamBound,\n+    SawPolyTraitRef,\n+    SawAssocTypeBinding,\n+    SawAttribute(ast::AttrStyle),\n+    SawMacroDef,\n+    SawSpan(Option<(&'a str, usize, BytePos)>,\n+            Option<(&'a str, usize, BytePos)>,\n+            SawSpanExpnKind),\n }\n \n /// SawExprComponent carries all of the information that we want\n@@ -117,7 +192,7 @@ enum SawAbiComponent<'a> {\n /// guarantee of collision-freedom, hash collisions are just\n /// (hopefully) unlikely.)\n #[derive(Hash)]\n-pub enum SawExprComponent<'a> {\n+enum SawExprComponent<'a> {\n \n     SawExprLoop(Option<token::InternedString>),\n     SawExprField(token::InternedString),\n@@ -138,7 +213,7 @@ pub enum SawExprComponent<'a> {\n     SawExprIf,\n     SawExprWhile,\n     SawExprMatch,\n-    SawExprClosure,\n+    SawExprClosure(CaptureClause),\n     SawExprBlock,\n     SawExprAssign,\n     SawExprAssignOp(hir::BinOp_),\n@@ -167,7 +242,7 @@ fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n         ExprWhile(..)            => SawExprWhile,\n         ExprLoop(_, id)          => SawExprLoop(id.map(|id| id.node.as_str())),\n         ExprMatch(..)            => SawExprMatch,\n-        ExprClosure(..)          => SawExprClosure,\n+        ExprClosure(cc, _, _, _) => SawExprClosure(cc),\n         ExprBlock(..)            => SawExprBlock,\n         ExprAssign(..)           => SawExprAssign,\n         ExprAssignOp(op, ..)     => SawExprAssignOp(op.node),\n@@ -185,71 +260,83 @@ fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n     }\n }\n \n-/// SawStmtComponent is analogous to SawExprComponent, but for statements.\n-#[derive(Hash)]\n-pub enum SawStmtComponent {\n-    SawStmtExpr,\n-    SawStmtSemi,\n+#[derive(Clone, Copy, Hash, Eq, PartialEq)]\n+enum SawSpanExpnKind {\n+    NoExpansion,\n+    CommandLine,\n+    SomeExpansion,\n+}\n+\n+macro_rules! hash_attrs {\n+    ($visitor:expr, $attrs:expr) => ({\n+        let attrs = $attrs;\n+        if attrs.len() > 0 {\n+            $visitor.hash_attributes(attrs);\n+        }\n+    })\n }\n \n-impl<'a, 'hash, 'tcx> Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n+macro_rules! hash_span {\n+    ($visitor:expr, $span:expr) => ({\n+        if $visitor.hash_spans {\n+            $visitor.hash_span($span);\n+        }\n+    })\n+}\n+\n+impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n     fn visit_nested_item(&mut self, _: ItemId) {\n         // Each item is hashed independently; ignore nested items.\n     }\n \n-    fn visit_variant_data(&mut self, s: &'tcx VariantData, name: Name,\n-                          g: &'tcx Generics, _: NodeId, _: Span) {\n+    fn visit_variant_data(&mut self,\n+                          s: &'tcx VariantData,\n+                          name: Name,\n+                          _: &'tcx Generics,\n+                          _: NodeId,\n+                          span: Span) {\n         debug!(\"visit_variant_data: st={:?}\", self.st);\n         SawStructDef(name.as_str()).hash(self.st);\n-        visit::walk_generics(self, g);\n-        visit::walk_struct_def(self, s)\n+        hash_span!(self, span);\n+        visit::walk_struct_def(self, s);\n     }\n \n-    fn visit_variant(&mut self, v: &'tcx Variant, g: &'tcx Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self,\n+                     v: &'tcx Variant,\n+                     g: &'tcx Generics,\n+                     item_id: NodeId) {\n         debug!(\"visit_variant: st={:?}\", self.st);\n         SawVariant.hash(self.st);\n-        // walk_variant does not call walk_generics, so do it here.\n-        visit::walk_generics(self, g);\n+        hash_attrs!(self, &v.node.attrs);\n         visit::walk_variant(self, v, g, item_id)\n     }\n \n-    // All of the remaining methods just record (in the hash\n-    // SipHasher) that the visitor saw that particular variant\n-    // (with its payload), and continue walking as the default\n-    // visitor would.\n-    //\n-    // Some of the implementations have some notes as to how one\n-    // might try to make their SVH computation less discerning\n-    // (e.g. by incorporating reachability analysis).  But\n-    // currently all of their implementations are uniform and\n-    // uninteresting.\n-    //\n-    // (If you edit a method such that it deviates from the\n-    // pattern, please move that method up above this comment.)\n-\n-    fn visit_name(&mut self, _: Span, name: Name) {\n+    fn visit_name(&mut self, span: Span, name: Name) {\n         debug!(\"visit_name: st={:?}\", self.st);\n         SawIdent(name.as_str()).hash(self.st);\n+        hash_span!(self, span);\n     }\n \n     fn visit_lifetime(&mut self, l: &'tcx Lifetime) {\n         debug!(\"visit_lifetime: st={:?}\", self.st);\n-        SawLifetime(l.name.as_str()).hash(self.st);\n+        SawLifetime.hash(self.st);\n+        visit::walk_lifetime(self, l);\n     }\n \n     fn visit_lifetime_def(&mut self, l: &'tcx LifetimeDef) {\n         debug!(\"visit_lifetime_def: st={:?}\", self.st);\n-        SawLifetimeDef(l.lifetime.name.as_str()).hash(self.st);\n+        SawLifetimeDef(l.bounds.len()).hash(self.st);\n+        visit::walk_lifetime_def(self, l);\n     }\n \n-    // We do recursively walk the bodies of functions/methods\n-    // (rather than omitting their bodies from the hash) since\n-    // monomorphization and cross-crate inlining generally implies\n-    // that a change to a crate body will require downstream\n-    // crates to be recompiled.\n     fn visit_expr(&mut self, ex: &'tcx Expr) {\n         debug!(\"visit_expr: st={:?}\", self.st);\n-        SawExpr(saw_expr(&ex.node)).hash(self.st); visit::walk_expr(self, ex)\n+        SawExpr(saw_expr(&ex.node)).hash(self.st);\n+        // No need to explicitly hash the discriminant here, since we are\n+        // implicitly hashing the discriminant of SawExprComponent.\n+        hash_span!(self, ex.span);\n+        hash_attrs!(self, &ex.attrs);\n+        visit::walk_expr(self, ex)\n     }\n \n     fn visit_stmt(&mut self, s: &'tcx Stmt) {\n@@ -263,8 +350,16 @@ impl<'a, 'hash, 'tcx> Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx\n         // rules).\n         match s.node {\n             StmtDecl(..) => (),\n-            StmtExpr(..) => SawStmt(SawStmtExpr).hash(self.st),\n-            StmtSemi(..) => SawStmt(SawStmtSemi).hash(self.st),\n+            StmtExpr(..) => {\n+                SawStmt.hash(self.st);\n+                self.hash_discriminant(&s.node);\n+                hash_span!(self, s.span);\n+            }\n+            StmtSemi(..) => {\n+                SawStmt.hash(self.st);\n+                self.hash_discriminant(&s.node);\n+                hash_span!(self, s.span);\n+            }\n         }\n \n         visit::walk_stmt(self, s)\n@@ -273,21 +368,21 @@ impl<'a, 'hash, 'tcx> Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx\n     fn visit_foreign_item(&mut self, i: &'tcx ForeignItem) {\n         debug!(\"visit_foreign_item: st={:?}\", self.st);\n \n-        // FIXME (#14132) ideally we would incorporate privacy (or\n-        // perhaps reachability) somewhere here, so foreign items\n-        // that do not leak into downstream crates would not be\n-        // part of the ABI.\n-        SawForeignItem.hash(self.st); visit::walk_foreign_item(self, i)\n+        SawForeignItem.hash(self.st);\n+        hash_span!(self, i.span);\n+        hash_attrs!(self, &i.attrs);\n+        visit::walk_foreign_item(self, i)\n     }\n \n     fn visit_item(&mut self, i: &'tcx Item) {\n         debug!(\"visit_item: {:?} st={:?}\", i, self.st);\n \n-        // FIXME (#14132) ideally would incorporate reachability\n-        // analysis somewhere here, so items that never leak into\n-        // downstream crates (e.g. via monomorphisation or\n-        // inlining) would not be part of the ABI.\n-        SawItem.hash(self.st); visit::walk_item(self, i)\n+        SawItem.hash(self.st);\n+        // Hash the value of the discriminant of the Item variant.\n+        self.hash_discriminant(&i.node);\n+        hash_span!(self, i.span);\n+        hash_attrs!(self, &i.attrs);\n+        visit::walk_item(self, i)\n     }\n \n     fn visit_mod(&mut self, m: &'tcx Mod, _s: Span, n: NodeId) {\n@@ -297,63 +392,159 @@ impl<'a, 'hash, 'tcx> Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx\n \n     fn visit_ty(&mut self, t: &'tcx Ty) {\n         debug!(\"visit_ty: st={:?}\", self.st);\n-        SawTy.hash(self.st); visit::walk_ty(self, t)\n+        SawTy.hash(self.st);\n+        hash_span!(self, t.span);\n+        visit::walk_ty(self, t)\n     }\n \n     fn visit_generics(&mut self, g: &'tcx Generics) {\n         debug!(\"visit_generics: st={:?}\", self.st);\n-        SawGenerics.hash(self.st); visit::walk_generics(self, g)\n-    }\n-\n-    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx FnDecl,\n-                b: &'tcx Block, s: Span, n: NodeId) {\n-        debug!(\"visit_fn: st={:?}\", self.st);\n-        SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s, n)\n+        SawGenerics.hash(self.st);\n+        visit::walk_generics(self, g)\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx TraitItem) {\n         debug!(\"visit_trait_item: st={:?}\", self.st);\n-        SawTraitItem.hash(self.st); visit::walk_trait_item(self, ti)\n+        SawTraitItem.hash(self.st);\n+        self.hash_discriminant(&ti.node);\n+        hash_span!(self, ti.span);\n+        hash_attrs!(self, &ti.attrs);\n+        visit::walk_trait_item(self, ti)\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx ImplItem) {\n         debug!(\"visit_impl_item: st={:?}\", self.st);\n-        SawImplItem.hash(self.st); visit::walk_impl_item(self, ii)\n+        SawImplItem.hash(self.st);\n+        self.hash_discriminant(&ii.node);\n+        hash_span!(self, ii.span);\n+        hash_attrs!(self, &ii.attrs);\n+        visit::walk_impl_item(self, ii)\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx StructField) {\n         debug!(\"visit_struct_field: st={:?}\", self.st);\n-        SawStructField.hash(self.st); visit::walk_struct_field(self, s)\n+        SawStructField.hash(self.st);\n+        hash_span!(self, s.span);\n+        hash_attrs!(self, &s.attrs);\n+        visit::walk_struct_field(self, s)\n     }\n \n     fn visit_path(&mut self, path: &'tcx Path, _: ast::NodeId) {\n         debug!(\"visit_path: st={:?}\", self.st);\n-        SawPath.hash(self.st); visit::walk_path(self, path)\n+        SawPath(path.global).hash(self.st);\n+        hash_span!(self, path.span);\n+        visit::walk_path(self, path)\n     }\n \n     fn visit_block(&mut self, b: &'tcx Block) {\n         debug!(\"visit_block: st={:?}\", self.st);\n-        SawBlock.hash(self.st); visit::walk_block(self, b)\n+        SawBlock.hash(self.st);\n+        hash_span!(self, b.span);\n+        visit::walk_block(self, b)\n     }\n \n     fn visit_pat(&mut self, p: &'tcx Pat) {\n         debug!(\"visit_pat: st={:?}\", self.st);\n-        SawPat.hash(self.st); visit::walk_pat(self, p)\n+        SawPat.hash(self.st);\n+        self.hash_discriminant(&p.node);\n+        hash_span!(self, p.span);\n+        visit::walk_pat(self, p)\n     }\n \n     fn visit_local(&mut self, l: &'tcx Local) {\n         debug!(\"visit_local: st={:?}\", self.st);\n-        SawLocal.hash(self.st); visit::walk_local(self, l)\n+        SawLocal.hash(self.st);\n+        hash_attrs!(self, &l.attrs);\n+        visit::walk_local(self, l)\n+        // No need to hash span, we are hashing all component spans\n     }\n \n     fn visit_arm(&mut self, a: &'tcx Arm) {\n         debug!(\"visit_arm: st={:?}\", self.st);\n-        SawArm.hash(self.st); visit::walk_arm(self, a)\n+        SawArm.hash(self.st);\n+        hash_attrs!(self, &a.attrs);\n+        visit::walk_arm(self, a)\n     }\n \n     fn visit_id(&mut self, id: NodeId) {\n         debug!(\"visit_id: id={} st={:?}\", id, self.st);\n-        self.hash_resolve(id);\n+        self.hash_resolve(id)\n+    }\n+\n+    fn visit_vis(&mut self, v: &'tcx Visibility) {\n+        debug!(\"visit_vis: st={:?}\", self.st);\n+        SawVis.hash(self.st);\n+        self.hash_discriminant(v);\n+        visit::walk_vis(self, v)\n+    }\n+\n+    fn visit_where_predicate(&mut self, predicate: &'tcx WherePredicate) {\n+        debug!(\"visit_where_predicate: st={:?}\", self.st);\n+        SawWherePredicate.hash(self.st);\n+        self.hash_discriminant(predicate);\n+        // Ignoring span. Any important nested components should be visited.\n+        visit::walk_where_predicate(self, predicate)\n+    }\n+\n+    fn visit_ty_param_bound(&mut self, bounds: &'tcx TyParamBound) {\n+        debug!(\"visit_ty_param_bound: st={:?}\", self.st);\n+        SawTyParamBound.hash(self.st);\n+        self.hash_discriminant(bounds);\n+        // The TraitBoundModifier in TraitTyParamBound will be hash in\n+        // visit_poly_trait_ref()\n+        visit::walk_ty_param_bound(self, bounds)\n+    }\n+\n+    fn visit_poly_trait_ref(&mut self, t: &'tcx PolyTraitRef, m: &'tcx TraitBoundModifier) {\n+        debug!(\"visit_poly_trait_ref: st={:?}\", self.st);\n+        SawPolyTraitRef.hash(self.st);\n+        m.hash(self.st);\n+        visit::walk_poly_trait_ref(self, t, m)\n+    }\n+\n+    fn visit_path_list_item(&mut self, prefix: &'tcx Path, item: &'tcx PathListItem) {\n+        debug!(\"visit_path_list_item: st={:?}\", self.st);\n+        SawPathListItem.hash(self.st);\n+        self.hash_discriminant(&item.node);\n+        hash_span!(self, item.span);\n+        visit::walk_path_list_item(self, prefix, item)\n+    }\n+\n+    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'tcx PathSegment) {\n+        debug!(\"visit_path_segment: st={:?}\", self.st);\n+        SawPathSegment.hash(self.st);\n+        visit::walk_path_segment(self, path_span, path_segment)\n+    }\n+\n+    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &'tcx PathParameters) {\n+        debug!(\"visit_path_parameters: st={:?}\", self.st);\n+        SawPathParameters.hash(self.st);\n+        self.hash_discriminant(path_parameters);\n+        visit::walk_path_parameters(self, path_span, path_parameters)\n+    }\n+\n+    fn visit_assoc_type_binding(&mut self, type_binding: &'tcx TypeBinding) {\n+        debug!(\"visit_assoc_type_binding: st={:?}\", self.st);\n+        SawAssocTypeBinding.hash(self.st);\n+        hash_span!(self, type_binding.span);\n+        visit::walk_assoc_type_binding(self, type_binding)\n+    }\n+\n+    fn visit_attribute(&mut self, _: &ast::Attribute) {\n+        // We explicitly do not use this method, since doing that would\n+        // implicitly impose an order on the attributes being hashed, while we\n+        // explicitly don't want their order to matter\n+    }\n+\n+    fn visit_macro_def(&mut self, macro_def: &'tcx MacroDef) {\n+        debug!(\"visit_macro_def: st={:?}\", self.st);\n+        if macro_def.export {\n+            SawMacroDef.hash(self.st);\n+            hash_attrs!(self, &macro_def.attrs);\n+            visit::walk_macro_def(self, macro_def)\n+            // FIXME(mw): We should hash the body of the macro too but we don't\n+            //            have a stable way of doing so yet.\n+        }\n     }\n }\n \n@@ -451,4 +642,68 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             }\n         }\n     }\n+\n+    fn hash_meta_item(&mut self, meta_item: &ast::MetaItem) {\n+        debug!(\"hash_meta_item: st={:?}\", self.st);\n+\n+        // ignoring span information, it doesn't matter here\n+        self.hash_discriminant(&meta_item.node);\n+        match meta_item.node {\n+            ast::MetaItemKind::Word(ref s) => {\n+                s.len().hash(self.st);\n+                s.hash(self.st);\n+            }\n+            ast::MetaItemKind::NameValue(ref s, ref lit) => {\n+                s.len().hash(self.st);\n+                s.hash(self.st);\n+                lit.node.hash(self.st);\n+            }\n+            ast::MetaItemKind::List(ref s, ref items) => {\n+                s.len().hash(self.st);\n+                s.hash(self.st);\n+                // Sort subitems so the hash does not depend on their order\n+                let indices = self.indices_sorted_by(&items, |p| {\n+                    (p.name(), fnv::hash(&p.literal().map(|i| &i.node)))\n+                });\n+                items.len().hash(self.st);\n+                for (index, &item_index) in indices.iter().enumerate() {\n+                    index.hash(self.st);\n+                    let nested_meta_item: &ast::NestedMetaItemKind = &items[item_index].node;\n+                    self.hash_discriminant(nested_meta_item);\n+                    match *nested_meta_item {\n+                        ast::NestedMetaItemKind::MetaItem(ref meta_item) => {\n+                            self.hash_meta_item(meta_item);\n+                        }\n+                        ast::NestedMetaItemKind::Literal(ref lit) => {\n+                            lit.node.hash(self.st);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn hash_attributes(&mut self, attributes: &[ast::Attribute]) {\n+        debug!(\"hash_attributes: st={:?}\", self.st);\n+        let indices = self.indices_sorted_by(attributes, |attr| attr.name());\n+\n+        for i in indices {\n+            let attr = &attributes[i].node;\n+            if !attr.is_sugared_doc &&\n+               !IGNORED_ATTRIBUTES.contains(&&*attr.value.name()) {\n+                SawAttribute(attr.style).hash(self.st);\n+                self.hash_meta_item(&*attr.value);\n+            }\n+        }\n+    }\n+\n+    fn indices_sorted_by<T, K, F>(&mut self, items: &[T], get_key: F) -> Vec<usize>\n+        where K: Ord,\n+              F: Fn(&T) -> K\n+    {\n+        let mut indices = Vec::with_capacity(items.len());\n+        indices.extend(0 .. items.len());\n+        indices.sort_by_key(|index| get_key(&items[*index]));\n+        indices\n+    }\n }"}, {"sha": "1f823eedda0dda5445fdf355acd5bc0a6aac273a", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=923bac45964940c56ab1075fb7980896de1eb620", "patch": "@@ -24,6 +24,7 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(rand)]\n+#![feature(core_intrinsics)]\n \n extern crate graphviz;\n extern crate rbml;"}, {"sha": "76d83eee4bb41bc2392da7c6a6eed7aaaa589601", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=923bac45964940c56ab1075fb7980896de1eb620", "patch": "@@ -108,6 +108,7 @@ use rustc::ty::{Ty, TyCtxt, TypeFoldable};\n use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n use rustc::ty::subst::Substs;\n use rustc::hir::map::definitions::{DefPath, DefPathData};\n+use rustc::util::common::record_time;\n \n use syntax::attr;\n use syntax::parse::token::{self, InternedString};\n@@ -138,33 +139,35 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n     let tcx = scx.tcx();\n \n-    let mut hash_state = scx.symbol_hasher().borrow_mut();\n-\n-    hash_state.reset();\n-\n-    // the main symbol name is not necessarily unique; hash in the\n-    // compiler's internal def-path, guaranteeing each symbol has a\n-    // truly unique path\n-    hash_state.input_str(&def_path.to_string(tcx));\n-\n-    // Include the main item-type. Note that, in this case, the\n-    // assertions about `needs_subst` may not hold, but this item-type\n-    // ought to be the same for every reference anyway.\n-    assert!(!item_type.has_erasable_regions());\n-    let encoded_item_type = tcx.sess.cstore.encode_type(tcx, item_type, def_id_to_string);\n-    hash_state.input(&encoded_item_type[..]);\n-\n-    // also include any type parameters (for generic items)\n-    if let Some(substs) = substs {\n-        for t in substs.types() {\n-            assert!(!t.has_erasable_regions());\n-            assert!(!t.needs_subst());\n-            let encoded_type = tcx.sess.cstore.encode_type(tcx, t, def_id_to_string);\n-            hash_state.input(&encoded_type[..]);\n+    return record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n+        let mut hash_state = scx.symbol_hasher().borrow_mut();\n+\n+        hash_state.reset();\n+\n+        // the main symbol name is not necessarily unique; hash in the\n+        // compiler's internal def-path, guaranteeing each symbol has a\n+        // truly unique path\n+        hash_state.input_str(&def_path.to_string(tcx));\n+\n+        // Include the main item-type. Note that, in this case, the\n+        // assertions about `needs_subst` may not hold, but this item-type\n+        // ought to be the same for every reference anyway.\n+        assert!(!item_type.has_erasable_regions());\n+        let encoded_item_type = tcx.sess.cstore.encode_type(tcx, item_type, def_id_to_string);\n+        hash_state.input(&encoded_item_type[..]);\n+\n+        // also include any type parameters (for generic items)\n+        if let Some(substs) = substs {\n+            for t in substs.types() {\n+                assert!(!t.has_erasable_regions());\n+                assert!(!t.needs_subst());\n+                let encoded_type = tcx.sess.cstore.encode_type(tcx, t, def_id_to_string);\n+                hash_state.input(&encoded_type[..]);\n+            }\n         }\n-    }\n \n-    return format!(\"h{}\", truncated_hash_result(&mut *hash_state));\n+        format!(\"h{}\", truncated_hash_result(&mut *hash_state))\n+    });\n \n     fn truncated_hash_result(symbol_hasher: &mut Sha256) -> String {\n         let output = symbol_hasher.result_bytes();"}, {"sha": "cd6f2874954b8656224fed5f55ad6f0ff423ed9f", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=923bac45964940c56ab1075fb7980896de1eb620", "patch": "@@ -348,26 +348,10 @@ impl CodeMap {\n         let files = self.files.borrow();\n         let f = (*files)[idx].clone();\n \n-        let len = f.lines.borrow().len();\n-        if len == 0 {\n-            return Err(f);\n+        match f.lookup_line(pos) {\n+            Some(line) => Ok(FileMapAndLine { fm: f, line: line }),\n+            None => Err(f)\n         }\n-\n-        let mut a = 0;\n-        {\n-            let lines = f.lines.borrow();\n-            let mut b = lines.len();\n-            while b - a > 1 {\n-                let m = (a + b) / 2;\n-                if (*lines)[m] > pos {\n-                    b = m;\n-                } else {\n-                    a = m;\n-                }\n-            }\n-            assert!(a <= lines.len());\n-        }\n-        Ok(FileMapAndLine { fm: f, line: a })\n     }\n \n     pub fn lookup_char_pos_adj(&self, pos: BytePos) -> LocWithOpt {\n@@ -691,7 +675,7 @@ impl CodeMap {\n     }\n \n     // Return the index of the filemap (in self.files) which contains pos.\n-    fn lookup_filemap_idx(&self, pos: BytePos) -> usize {\n+    pub fn lookup_filemap_idx(&self, pos: BytePos) -> usize {\n         let files = self.files.borrow();\n         let files = &*files;\n         let count = files.len();"}, {"sha": "d835f8058fa0e70e8a511242d6b09f3d6c6653c9", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923bac45964940c56ab1075fb7980896de1eb620/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=923bac45964940c56ab1075fb7980896de1eb620", "patch": "@@ -507,6 +507,39 @@ impl FileMap {\n     pub fn count_lines(&self) -> usize {\n         self.lines.borrow().len()\n     }\n+\n+    /// Find the line containing the given position. The return value is the\n+    /// index into the `lines` array of this FileMap, not the 1-based line\n+    /// number. If the filemap is empty or the position is located before the\n+    /// first line, None is returned.\n+    pub fn lookup_line(&self, pos: BytePos) -> Option<usize> {\n+        let lines = self.lines.borrow();\n+        if lines.len() == 0 {\n+            return None;\n+        }\n+\n+        let line_index = lookup_line(&lines[..], pos);\n+        assert!(line_index < lines.len() as isize);\n+        if line_index >= 0 {\n+            Some(line_index as usize)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn line_bounds(&self, line_index: usize) -> (BytePos, BytePos) {\n+        if self.start_pos == self.end_pos {\n+            return (self.start_pos, self.end_pos);\n+        }\n+\n+        let lines = self.lines.borrow();\n+        assert!(line_index < lines.len());\n+        if line_index == (lines.len() - 1) {\n+            (lines[line_index], self.end_pos)\n+        } else {\n+            (lines[line_index], lines[line_index + 1])\n+        }\n+    }\n }\n \n // _____________________________________________________________________________\n@@ -688,3 +721,34 @@ pub struct MalformedCodemapPositions {\n     pub end_pos: BytePos\n }\n \n+// Given a slice of line start positions and a position, returns the index of\n+// the line the position is on. Returns -1 if the position is located before\n+// the first line.\n+fn lookup_line(lines: &[BytePos], pos: BytePos) -> isize {\n+    match lines.binary_search(&pos) {\n+        Ok(line) => line as isize,\n+        Err(line) => line as isize - 1\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{lookup_line, BytePos};\n+\n+    #[test]\n+    fn test_lookup_line() {\n+\n+        let lines = &[BytePos(3), BytePos(17), BytePos(28)];\n+\n+        assert_eq!(lookup_line(lines, BytePos(0)), -1);\n+        assert_eq!(lookup_line(lines, BytePos(3)),  0);\n+        assert_eq!(lookup_line(lines, BytePos(4)),  0);\n+\n+        assert_eq!(lookup_line(lines, BytePos(16)), 0);\n+        assert_eq!(lookup_line(lines, BytePos(17)), 1);\n+        assert_eq!(lookup_line(lines, BytePos(18)), 1);\n+\n+        assert_eq!(lookup_line(lines, BytePos(28)), 2);\n+        assert_eq!(lookup_line(lines, BytePos(29)), 2);\n+    }\n+}"}, {"sha": "f922ac0da41b193ca292c58d251a7c60a16a3358", "filename": "src/test/incremental/source_loc_macros.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/923bac45964940c56ab1075fb7980896de1eb620/src%2Ftest%2Fincremental%2Fsource_loc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923bac45964940c56ab1075fb7980896de1eb620/src%2Ftest%2Fincremental%2Fsource_loc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fsource_loc_macros.rs?ref=923bac45964940c56ab1075fb7980896de1eb620", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test makes sure that different expansions of the file!(), line!(),\n+// column!() macros get picked up by the incr. comp. hash.\n+\n+// revisions:rpass1 rpass2\n+\n+// compile-flags: -Z query-dep-graph\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+fn line_same() {\n+    let _ = line!();\n+}\n+\n+#[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+fn col_same() {\n+    let _ = column!();\n+}\n+\n+#[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+fn file_same() {\n+    let _ = file!();\n+}\n+\n+#[cfg(rpass1)]\n+fn line_different() {\n+    let _ = line!();\n+}\n+\n+#[cfg(rpass2)]\n+#[rustc_dirty(label=\"Hir\", cfg=\"rpass2\")]\n+fn line_different() {\n+    let _ = line!();\n+}\n+\n+#[cfg(rpass1)]\n+fn col_different() {\n+    let _ = column!();\n+}\n+\n+#[cfg(rpass2)]\n+#[rustc_dirty(label=\"Hir\", cfg=\"rpass2\")]\n+fn col_different() {\n+    let _ =        column!();\n+}\n+\n+fn main() {\n+    line_same();\n+    line_different();\n+    col_same();\n+    col_different();\n+    file_same();\n+}"}, {"sha": "dfd2a6610f259780e62d232cd8b4fb98e3627f01", "filename": "src/test/incremental/span_hash_stable/auxiliary/mod.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/923bac45964940c56ab1075fb7980896de1eb620/src%2Ftest%2Fincremental%2Fspan_hash_stable%2Fauxiliary%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923bac45964940c56ab1075fb7980896de1eb620/src%2Ftest%2Fincremental%2Fspan_hash_stable%2Fauxiliary%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspan_hash_stable%2Fauxiliary%2Fmod.rs?ref=923bac45964940c56ab1075fb7980896de1eb620", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[cfg(rpass1)]\n+pub mod sub2;\n+\n+pub mod sub1;\n+\n+#[cfg(rpass2)]\n+pub mod sub2;"}, {"sha": "2d042c316833e1393654c49e9dd3d0bd6bfc7177", "filename": "src/test/incremental/span_hash_stable/auxiliary/sub1.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/923bac45964940c56ab1075fb7980896de1eb620/src%2Ftest%2Fincremental%2Fspan_hash_stable%2Fauxiliary%2Fsub1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923bac45964940c56ab1075fb7980896de1eb620/src%2Ftest%2Fincremental%2Fspan_hash_stable%2Fauxiliary%2Fsub1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspan_hash_stable%2Fauxiliary%2Fsub1.rs?ref=923bac45964940c56ab1075fb7980896de1eb620", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+pub struct SomeType {\n+    pub x: u32,\n+    pub y: i64,\n+}"}, {"sha": "df7d2f0267d02dd254fd1a7bfb65802b420dcb00", "filename": "src/test/incremental/span_hash_stable/auxiliary/sub2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/923bac45964940c56ab1075fb7980896de1eb620/src%2Ftest%2Fincremental%2Fspan_hash_stable%2Fauxiliary%2Fsub2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923bac45964940c56ab1075fb7980896de1eb620/src%2Ftest%2Fincremental%2Fspan_hash_stable%2Fauxiliary%2Fsub2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspan_hash_stable%2Fauxiliary%2Fsub2.rs?ref=923bac45964940c56ab1075fb7980896de1eb620", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+pub struct SomeOtherType {\n+    pub a: i32,\n+    pub b: u64,\n+}"}, {"sha": "1512c5dc53788decc7b2610c367276f86ac27f4f", "filename": "src/test/incremental/span_hash_stable/main.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/923bac45964940c56ab1075fb7980896de1eb620/src%2Ftest%2Fincremental%2Fspan_hash_stable%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923bac45964940c56ab1075fb7980896de1eb620/src%2Ftest%2Fincremental%2Fspan_hash_stable%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspan_hash_stable%2Fmain.rs?ref=923bac45964940c56ab1075fb7980896de1eb620", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test makes sure that it doesn't make a difference in which order we are\n+// adding source files to the codemap. The order affects the BytePos values of\n+// the spans and this test makes sure that we handle them correctly by hashing\n+// file:line:column instead of raw byte offset.\n+\n+// revisions:rpass1 rpass2\n+// compile-flags: -g -Z query-dep-graph\n+\n+#![feature(rustc_attrs)]\n+\n+mod auxiliary;\n+\n+fn main() {\n+    let _ = auxiliary::sub1::SomeType {\n+        x: 0,\n+        y: 1,\n+    };\n+\n+    let _ = auxiliary::sub2::SomeOtherType {\n+        a: 2,\n+        b: 3,\n+    };\n+}\n+"}, {"sha": "9c8b8552498c492608470197262e63456cdd283a", "filename": "src/test/incremental/spans_insignificant_w_o_debuginfo.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/923bac45964940c56ab1075fb7980896de1eb620/src%2Ftest%2Fincremental%2Fspans_insignificant_w_o_debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923bac45964940c56ab1075fb7980896de1eb620/src%2Ftest%2Fincremental%2Fspans_insignificant_w_o_debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspans_insignificant_w_o_debuginfo.rs?ref=923bac45964940c56ab1075fb7980896de1eb620", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test makes sure that just changing a definition's location in the\n+// source file does *not* change its incr. comp. hash, if debuginfo is disabled.\n+\n+// revisions:rpass1 rpass2\n+\n+// compile-flags: -Z query-dep-graph\n+\n+#![feature(rustc_attrs)]\n+\n+#[cfg(rpass1)]\n+pub fn main() {}\n+\n+#[cfg(rpass2)]\n+#[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n+pub fn main() {}"}, {"sha": "b0920aa1fa510dbda5706477214de25356b8d0e2", "filename": "src/test/incremental/spans_significant_w_debuginfo.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/923bac45964940c56ab1075fb7980896de1eb620/src%2Ftest%2Fincremental%2Fspans_significant_w_debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923bac45964940c56ab1075fb7980896de1eb620/src%2Ftest%2Fincremental%2Fspans_significant_w_debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspans_significant_w_debuginfo.rs?ref=923bac45964940c56ab1075fb7980896de1eb620", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test makes sure that just changing a definition's location in the\n+// source file also changes its incr. comp. hash, if debuginfo is enabled.\n+\n+// revisions:rpass1 rpass2\n+\n+// compile-flags: -g -Z query-dep-graph\n+\n+#![feature(rustc_attrs)]\n+\n+#[cfg(rpass1)]\n+pub fn main() {}\n+\n+#[cfg(rpass2)]\n+#[rustc_dirty(label=\"Hir\", cfg=\"rpass2\")]\n+pub fn main() {}"}]}