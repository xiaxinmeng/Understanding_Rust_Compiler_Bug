{"sha": "a094ff9590b83c8f94d898f92c2964a5803ded06", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwOTRmZjk1OTBiODNjOGY5NGQ4OThmOTJjMjk2NGE1ODAzZGVkMDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-02T15:17:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-02T15:17:32Z"}, "message": "Auto merge of #79547 - erikdesjardins:byval, r=nagisa\n\nPass arguments up to 2*usize by value\n\nIn https://github.com/rust-lang/rust/pull/77434#discussion_r498719533, `@eddyb` said:\n\n> I wonder if it makes sense to limit this to returns [...]\n\nLet's do a perf run and find out.\n\nIt seems the `extern \"C\"` ABI will pass arguments up to 2*usize in registers: https://godbolt.org/z/n8E6zc. (modified from https://github.com/rust-lang/rust/issues/26494#issuecomment-619506345)\n\nr? `@nagisa`", "tree": {"sha": "9012a5007c09a4a7c1412ad69c5e008db08f3758", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9012a5007c09a4a7c1412ad69c5e008db08f3758"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a094ff9590b83c8f94d898f92c2964a5803ded06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a094ff9590b83c8f94d898f92c2964a5803ded06", "html_url": "https://github.com/rust-lang/rust/commit/a094ff9590b83c8f94d898f92c2964a5803ded06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a094ff9590b83c8f94d898f92c2964a5803ded06/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d37afad0cc87bf709ad10c85319296ac53030f03", "url": "https://api.github.com/repos/rust-lang/rust/commits/d37afad0cc87bf709ad10c85319296ac53030f03", "html_url": "https://github.com/rust-lang/rust/commit/d37afad0cc87bf709ad10c85319296ac53030f03"}, {"sha": "53943d6debc78efafa037744774d3216d22a10ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/53943d6debc78efafa037744774d3216d22a10ad", "html_url": "https://github.com/rust-lang/rust/commit/53943d6debc78efafa037744774d3216d22a10ad"}], "stats": {"total": 27, "additions": 16, "deletions": 11}, "files": [{"sha": "d6b3afb3be3df1739870366e93b88e58bf361335", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a094ff9590b83c8f94d898f92c2964a5803ded06/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a094ff9590b83c8f94d898f92c2964a5803ded06/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=a094ff9590b83c8f94d898f92c2964a5803ded06", "patch": "@@ -2848,7 +2848,7 @@ where\n             || abi == SpecAbi::RustIntrinsic\n             || abi == SpecAbi::PlatformIntrinsic\n         {\n-            let fixup = |arg: &mut ArgAbi<'tcx, Ty<'tcx>>, is_ret: bool| {\n+            let fixup = |arg: &mut ArgAbi<'tcx, Ty<'tcx>>| {\n                 if arg.is_ignore() {\n                     return;\n                 }\n@@ -2886,9 +2886,9 @@ where\n                     _ => return,\n                 }\n \n-                // Return structures up to 2 pointers in size by value, matching `ScalarPair`. LLVM\n-                // will usually return these in 2 registers, which is more efficient than by-ref.\n-                let max_by_val_size = if is_ret { Pointer.size(cx) * 2 } else { Pointer.size(cx) };\n+                // Pass and return structures up to 2 pointers in size by value, matching `ScalarPair`.\n+                // LLVM will usually pass these in 2 registers, which is more efficient than by-ref.\n+                let max_by_val_size = Pointer.size(cx) * 2;\n                 let size = arg.layout.size;\n \n                 if arg.layout.is_unsized() || size > max_by_val_size {\n@@ -2900,9 +2900,9 @@ where\n                     arg.cast_to(Reg { kind: RegKind::Integer, size });\n                 }\n             };\n-            fixup(&mut self.ret, true);\n+            fixup(&mut self.ret);\n             for arg in &mut self.args {\n-                fixup(arg, false);\n+                fixup(arg);\n             }\n             return;\n         }"}, {"sha": "a69291d47821ae06742cdcaf714348db6ce10a73", "filename": "src/test/codegen/arg-return-value-in-reg.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a094ff9590b83c8f94d898f92c2964a5803ded06/src%2Ftest%2Fcodegen%2Farg-return-value-in-reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a094ff9590b83c8f94d898f92c2964a5803ded06/src%2Ftest%2Fcodegen%2Farg-return-value-in-reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Farg-return-value-in-reg.rs?ref=a094ff9590b83c8f94d898f92c2964a5803ded06", "patch": "@@ -1,4 +1,4 @@\n-//! This test checks that types of up to 128 bits are returned by-value instead of via out-pointer.\n+//! Check that types of up to 128 bits are passed and returned by-value instead of via pointer.\n \n // compile-flags: -C no-prepopulate-passes -O\n // only-x86_64\n@@ -11,7 +11,7 @@ pub struct S {\n     c: u32,\n }\n \n-// CHECK: define i128 @modify(%S* noalias nocapture dereferenceable(16) %s)\n+// CHECK: define i128 @modify(i128{{( %0)?}})\n #[no_mangle]\n pub fn modify(s: S) -> S {\n     S { a: s.a + s.a, b: s.b + s.b, c: s.c + s.c }", "previous_filename": "src/test/codegen/return-value-in-reg.rs"}, {"sha": "f282fd237054c48e881048e25b3db786c352b696", "filename": "src/test/codegen/union-abi.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a094ff9590b83c8f94d898f92c2964a5803ded06/src%2Ftest%2Fcodegen%2Funion-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a094ff9590b83c8f94d898f92c2964a5803ded06/src%2Ftest%2Fcodegen%2Funion-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funion-abi.rs?ref=a094ff9590b83c8f94d898f92c2964a5803ded06", "patch": "@@ -63,11 +63,16 @@ pub union UnionU128{a:u128}\n #[no_mangle]\n pub fn test_UnionU128(_: UnionU128) -> UnionU128 { loop {} }\n \n+pub union UnionU128x2{a:(u128, u128)}\n+// CHECK: define void @test_UnionU128x2(i128 %_1.0, i128 %_1.1)\n+#[no_mangle]\n+pub fn test_UnionU128x2(_: UnionU128x2) { loop {} }\n+\n #[repr(C)]\n-pub union CUnionU128{a:u128}\n-// CHECK: define void @test_CUnionU128(%CUnionU128* {{.*}} %_1)\n+pub union CUnionU128x2{a:(u128, u128)}\n+// CHECK: define void @test_CUnionU128x2(%CUnionU128x2* {{.*}} %_1)\n #[no_mangle]\n-pub fn test_CUnionU128(_: CUnionU128) { loop {} }\n+pub fn test_CUnionU128x2(_: CUnionU128x2) { loop {} }\n \n pub union UnionBool { b:bool }\n // CHECK: define zeroext i1 @test_UnionBool(i8 %b)"}]}