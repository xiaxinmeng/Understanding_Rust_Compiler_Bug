{"sha": "df80193bda8ae3a5e720612fe24fa313af098812", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmODAxOTNiZGE4YWUzYTVlNzIwNjEyZmUyNGZhMzEzYWYwOTg4MTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-08T05:09:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-08T05:09:53Z"}, "message": "Auto merge of #4628 - flip1995:rustup, r=phansch\n\nRustup to rust-lang/rust#64874\n\nTODO:\n- [x] replace `rvalue_promotable_map` in [1]\n- [ ] ~~fix [2] according to this comment https://github.com/rust-lang/rust/pull/64874#issuecomment-536203626 this should be merged with `consume`, but I didn't figure out how to merge them, yet.~~\n- [ ] ~~fix [3]; What to do with `LoanCause`?~~\n\n[2]+[3] probably have to be resolved by a rewrite of the lint. https://github.com/rust-lang/rust-clippy/pull/4628#issuecomment-538574944\n\n[1]\nhttps://github.com/rust-lang/rust-clippy/blob/54bf4ffd626970e831bb80c037f804a3b3450835/clippy_lints/src/methods/mod.rs#L1292-L1299\n\n[2]\nhttps://github.com/rust-lang/rust-clippy/blob/54bf4ffd626970e831bb80c037f804a3b3450835/clippy_lints/src/escape.rs#L126\n\n[3]\nhttps://github.com/rust-lang/rust-clippy/blob/54bf4ffd626970e831bb80c037f804a3b3450835/clippy_lints/src/escape.rs#L166-L176\n\nI could need some help with [1]. The purpose of this is to \"don't lint for constant values\". cc @matthewjasper\n\nFor now I see what I can do with [2].\n\nchangelog: Temporary break `boxed_local` lint.", "tree": {"sha": "a412995c7588caf85c5e2bff6231d7fb3088c3f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a412995c7588caf85c5e2bff6231d7fb3088c3f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df80193bda8ae3a5e720612fe24fa313af098812", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df80193bda8ae3a5e720612fe24fa313af098812", "html_url": "https://github.com/rust-lang/rust/commit/df80193bda8ae3a5e720612fe24fa313af098812", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df80193bda8ae3a5e720612fe24fa313af098812/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54bf4ffd626970e831bb80c037f804a3b3450835", "url": "https://api.github.com/repos/rust-lang/rust/commits/54bf4ffd626970e831bb80c037f804a3b3450835", "html_url": "https://github.com/rust-lang/rust/commit/54bf4ffd626970e831bb80c037f804a3b3450835"}, {"sha": "3d39379f9c1541e6642c89a839d1bfd0538d8a00", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d39379f9c1541e6642c89a839d1bfd0538d8a00", "html_url": "https://github.com/rust-lang/rust/commit/3d39379f9c1541e6642c89a839d1bfd0538d8a00"}], "stats": {"total": 331, "additions": 71, "deletions": 260}, "files": [{"sha": "bb6e0e5c51c2812b68fcf13cecc32be8a2f4068f", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 25, "deletions": 73, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/df80193bda8ae3a5e720612fe24fa313af098812/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df80193bda8ae3a5e720612fe24fa313af098812/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=df80193bda8ae3a5e720612fe24fa313af098812", "patch": "@@ -78,16 +78,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxedLocal {\n \n         let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n         let region_scope_tree = &cx.tcx.region_scope_tree(fn_def_id);\n-        ExprUseVisitor::new(\n-            &mut v,\n-            cx.tcx,\n-            fn_def_id,\n-            cx.param_env,\n-            region_scope_tree,\n-            cx.tables,\n-            None,\n-        )\n-        .consume_body(body);\n+        ExprUseVisitor::new(&mut v, cx.tcx, fn_def_id, cx.param_env, region_scope_tree, cx.tables).consume_body(body);\n \n         for node in v.set {\n             span_lint(\n@@ -114,86 +105,47 @@ fn is_argument(map: &hir::map::Map<'_>, id: HirId) -> bool {\n }\n \n impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n-    fn consume(&mut self, _: HirId, _: Span, cmt: &cmt_<'tcx>, mode: ConsumeMode) {\n+    fn consume(&mut self, cmt: &cmt_<'tcx>, mode: ConsumeMode) {\n         if let Categorization::Local(lid) = cmt.cat {\n-            if let Move(DirectRefMove) | Move(CaptureMove) = mode {\n+            if let ConsumeMode::Move = mode {\n                 // moved out or in. clearly can't be localized\n                 self.set.remove(&lid);\n             }\n         }\n-    }\n-    fn matched_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: MatchMode) {}\n-    fn consume_pat(&mut self, consume_pat: &Pat, cmt: &cmt_<'tcx>, _: ConsumeMode) {\n         let map = &self.cx.tcx.hir();\n-        if is_argument(map, consume_pat.hir_id) {\n-            // Skip closure arguments\n-            let parent_id = map.get_parent_node(consume_pat.hir_id);\n-            if let Some(Node::Expr(..)) = map.find(map.get_parent_node(parent_id)) {\n-                return;\n-            }\n-\n-            if is_non_trait_box(cmt.ty) && !self.is_large_box(cmt.ty) {\n-                self.set.insert(consume_pat.hir_id);\n-            }\n-            return;\n-        }\n-        if let Categorization::Rvalue(..) = cmt.cat {\n-            if let Some(Node::Stmt(st)) = map.find(map.get_parent_node(cmt.hir_id)) {\n-                if let StmtKind::Local(ref loc) = st.kind {\n-                    if let Some(ref ex) = loc.init {\n-                        if let ExprKind::Box(..) = ex.kind {\n-                            if is_non_trait_box(cmt.ty) && !self.is_large_box(cmt.ty) {\n-                                // let x = box (...)\n-                                self.set.insert(consume_pat.hir_id);\n-                            }\n-                            // TODO Box::new\n-                            // TODO vec![]\n-                            // TODO \"foo\".to_owned() and friends\n-                        }\n-                    }\n+        if let Categorization::Local(lid) = cmt.cat {\n+            if let Some(Node::Binding(_)) = map.find(cmt.hir_id) {\n+                if self.set.contains(&lid) {\n+                    // let y = x where x is known\n+                    // remove x, insert y\n+                    self.set.insert(cmt.hir_id);\n+                    self.set.remove(&lid);\n                 }\n             }\n         }\n+    }\n+\n+    fn borrow(&mut self, cmt: &cmt_<'tcx>, _: ty::BorrowKind) {\n         if let Categorization::Local(lid) = cmt.cat {\n-            if self.set.contains(&lid) {\n-                // let y = x where x is known\n-                // remove x, insert y\n-                self.set.insert(consume_pat.hir_id);\n-                self.set.remove(&lid);\n-            }\n+            self.set.remove(&lid);\n         }\n     }\n-    fn borrow(\n-        &mut self,\n-        _: HirId,\n-        _: Span,\n-        cmt: &cmt_<'tcx>,\n-        _: ty::Region<'_>,\n-        _: ty::BorrowKind,\n-        loan_cause: LoanCause,\n-    ) {\n-        if let Categorization::Local(lid) = cmt.cat {\n-            match loan_cause {\n-                // `x.foo()`\n-                // Used without autoderef-ing (i.e., `x.clone()`).\n-                LoanCause::AutoRef |\n-\n-                // `&x`\n-                // `foo(&x)` where no extra autoref-ing is happening.\n-                LoanCause::AddrOf |\n \n-                // `match x` can move.\n-                LoanCause::MatchDiscriminant => {\n-                    self.set.remove(&lid);\n-                }\n+    fn mutate(&mut self, cmt: &cmt_<'tcx>) {\n+        let map = &self.cx.tcx.hir();\n+        if is_argument(map, cmt.hir_id) {\n+            // Skip closure arguments\n+            let parent_id = map.get_parent_node(cmt.hir_id);\n+            if let Some(Node::Expr(..)) = map.find(map.get_parent_node(parent_id)) {\n+                return;\n+            }\n \n-                // Do nothing for matches, etc. These can't escape.\n-                _ => {}\n+            if is_non_trait_box(cmt.ty) && !self.is_large_box(cmt.ty) {\n+                self.set.insert(cmt.hir_id);\n             }\n+            return;\n         }\n     }\n-    fn decl_without_init(&mut self, _: HirId, _: Span) {}\n-    fn mutate(&mut self, _: HirId, _: Span, _: &cmt_<'tcx>, _: MutateMode) {}\n }\n \n impl<'a, 'tcx> EscapeDelegate<'a, 'tcx> {"}, {"sha": "ea496a0294ab2b762f6ea6804360519af18762a0", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/df80193bda8ae3a5e720612fe24fa313af098812/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df80193bda8ae3a5e720612fe24fa313af098812/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=df80193bda8ae3a5e720612fe24fa313af098812", "patch": "@@ -1547,37 +1547,31 @@ struct MutatePairDelegate {\n }\n \n impl<'tcx> Delegate<'tcx> for MutatePairDelegate {\n-    fn consume(&mut self, _: HirId, _: Span, _: &cmt_<'tcx>, _: ConsumeMode) {}\n+    fn consume(&mut self, _: &cmt_<'tcx>, _: ConsumeMode) {}\n \n-    fn matched_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: MatchMode) {}\n-\n-    fn consume_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: ConsumeMode) {}\n-\n-    fn borrow(&mut self, _: HirId, sp: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, bk: ty::BorrowKind, _: LoanCause) {\n+    fn borrow(&mut self, cmt: &cmt_<'tcx>, bk: ty::BorrowKind) {\n         if let ty::BorrowKind::MutBorrow = bk {\n             if let Categorization::Local(id) = cmt.cat {\n                 if Some(id) == self.hir_id_low {\n-                    self.span_low = Some(sp)\n+                    self.span_low = Some(cmt.span)\n                 }\n                 if Some(id) == self.hir_id_high {\n-                    self.span_high = Some(sp)\n+                    self.span_high = Some(cmt.span)\n                 }\n             }\n         }\n     }\n \n-    fn mutate(&mut self, _: HirId, sp: Span, cmt: &cmt_<'tcx>, _: MutateMode) {\n+    fn mutate(&mut self, cmt: &cmt_<'tcx>) {\n         if let Categorization::Local(id) = cmt.cat {\n             if Some(id) == self.hir_id_low {\n-                self.span_low = Some(sp)\n+                self.span_low = Some(cmt.span)\n             }\n             if Some(id) == self.hir_id_high {\n-                self.span_high = Some(sp)\n+                self.span_high = Some(cmt.span)\n             }\n         }\n     }\n-\n-    fn decl_without_init(&mut self, _: HirId, _: Span) {}\n }\n \n impl<'tcx> MutatePairDelegate {\n@@ -1655,7 +1649,6 @@ fn check_for_mutation(\n         cx.param_env,\n         region_scope_tree,\n         cx.tables,\n-        None,\n     )\n     .walk_expr(body);\n     delegate.mutation_span()"}, {"sha": "d10d635e0e8b2e0457d379c39bc2f9cd7696f04c", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/df80193bda8ae3a5e720612fe24fa313af098812/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df80193bda8ae3a5e720612fe24fa313af098812/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=df80193bda8ae3a5e720612fe24fa313af098812", "patch": "@@ -21,11 +21,11 @@ use syntax::symbol::{sym, LocalInternedString, Symbol};\n use crate::utils::usage::mutated_variables;\n use crate::utils::{\n     get_arg_name, get_parent_expr, get_trait_def_id, has_iter_method, implements_trait, in_macro, is_copy,\n-    is_ctor_function, is_expn_of, is_type_diagnostic_item, iter_input_pats, last_path_segment, match_def_path,\n-    match_qpath, match_trait_method, match_type, match_var, method_calls, method_chain_args, paths, remove_blocks,\n-    return_ty, same_tys, single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite,\n-    span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, sugg, walk_ptrs_ty,\n-    walk_ptrs_ty_depth, SpanlessEq,\n+    is_ctor_or_promotable_const_function, is_expn_of, is_type_diagnostic_item, iter_input_pats, last_path_segment,\n+    match_def_path, match_qpath, match_trait_method, match_type, match_var, method_calls, method_chain_args, paths,\n+    remove_blocks, return_ty, same_tys, single_segment_path, snippet, snippet_with_applicability,\n+    snippet_with_macro_callsite, span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then,\n+    span_note_and_lint, sugg, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -1281,22 +1281,13 @@ fn lint_or_fun_call<'a, 'tcx>(\n         fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n             let call_found = match &expr.kind {\n                 // ignore enum and struct constructors\n-                hir::ExprKind::Call(..) => !is_ctor_function(self.cx, expr),\n+                hir::ExprKind::Call(..) => !is_ctor_or_promotable_const_function(self.cx, expr),\n                 hir::ExprKind::MethodCall(..) => true,\n                 _ => false,\n             };\n \n             if call_found {\n-                // don't lint for constant values\n-                let owner_def = self.cx.tcx.hir().get_parent_did(expr.hir_id);\n-                let promotable = self\n-                    .cx\n-                    .tcx\n-                    .rvalue_promotable_map(owner_def)\n-                    .contains(&expr.hir_id.local_id);\n-                if !promotable {\n-                    self.found |= true;\n-                }\n+                self.found |= true;\n             }\n \n             if !self.found {"}, {"sha": "80f178289e4d3d3f87ebc4704c68ee3f0d2c88a6", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 13, "deletions": 102, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/df80193bda8ae3a5e720612fe24fa313af098812/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df80193bda8ae3a5e720612fe24fa313af098812/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=df80193bda8ae3a5e720612fe24fa313af098812", "patch": "@@ -134,18 +134,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n             spans_need_deref,\n             ..\n         } = {\n-            let mut ctx = MovedVariablesCtxt::new(cx);\n+            let mut ctx = MovedVariablesCtxt::default();\n             let region_scope_tree = &cx.tcx.region_scope_tree(fn_def_id);\n-            euv::ExprUseVisitor::new(\n-                &mut ctx,\n-                cx.tcx,\n-                fn_def_id,\n-                cx.param_env,\n-                region_scope_tree,\n-                cx.tables,\n-                None,\n-            )\n-            .consume_body(body);\n+            euv::ExprUseVisitor::new(&mut ctx, cx.tcx, fn_def_id, cx.param_env, region_scope_tree, cx.tables)\n+                .consume_body(body);\n             ctx\n         };\n \n@@ -325,115 +317,34 @@ fn requires_exact_signature(attrs: &[Attribute]) -> bool {\n     })\n }\n \n-struct MovedVariablesCtxt<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+#[derive(Default)]\n+struct MovedVariablesCtxt {\n     moved_vars: FxHashSet<HirId>,\n     /// Spans which need to be prefixed with `*` for dereferencing the\n     /// suggested additional reference.\n     spans_need_deref: FxHashMap<HirId, FxHashSet<Span>>,\n }\n \n-impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n-        Self {\n-            cx,\n-            moved_vars: FxHashSet::default(),\n-            spans_need_deref: FxHashMap::default(),\n-        }\n-    }\n-\n-    fn move_common(&mut self, _consume_id: HirId, _span: Span, cmt: &mc::cmt_<'tcx>) {\n+impl MovedVariablesCtxt {\n+    fn move_common(&mut self, cmt: &mc::cmt_<'_>) {\n         let cmt = unwrap_downcast_or_interior(cmt);\n \n         if let mc::Categorization::Local(vid) = cmt.cat {\n             self.moved_vars.insert(vid);\n         }\n     }\n-\n-    fn non_moving_pat(&mut self, matched_pat: &Pat, cmt: &mc::cmt_<'tcx>) {\n-        let cmt = unwrap_downcast_or_interior(cmt);\n-\n-        if let mc::Categorization::Local(vid) = cmt.cat {\n-            let mut id = matched_pat.hir_id;\n-            loop {\n-                let parent = self.cx.tcx.hir().get_parent_node(id);\n-                if id == parent {\n-                    // no parent\n-                    return;\n-                }\n-                id = parent;\n-\n-                if let Some(node) = self.cx.tcx.hir().find(id) {\n-                    match node {\n-                        Node::Expr(e) => {\n-                            // `match` and `if let`\n-                            if let ExprKind::Match(ref c, ..) = e.kind {\n-                                self.spans_need_deref\n-                                    .entry(vid)\n-                                    .or_insert_with(FxHashSet::default)\n-                                    .insert(c.span);\n-                            }\n-                        },\n-\n-                        Node::Stmt(s) => {\n-                            // `let <pat> = x;`\n-                            if_chain! {\n-                                if let StmtKind::Local(ref local) = s.kind;\n-                                then {\n-                                    self.spans_need_deref\n-                                        .entry(vid)\n-                                        .or_insert_with(FxHashSet::default)\n-                                        .insert(local.init\n-                                            .as_ref()\n-                                            .map(|e| e.span)\n-                                            .expect(\"`let` stmt without init aren't caught by match_pat\"));\n-                                }\n-                            }\n-                        },\n-\n-                        _ => {},\n-                    }\n-                }\n-            }\n-        }\n-    }\n }\n \n-impl<'a, 'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n-    fn consume(&mut self, consume_id: HirId, consume_span: Span, cmt: &mc::cmt_<'tcx>, mode: euv::ConsumeMode) {\n-        if let euv::ConsumeMode::Move(_) = mode {\n-            self.move_common(consume_id, consume_span, cmt);\n-        }\n-    }\n-\n-    fn matched_pat(&mut self, matched_pat: &Pat, cmt: &mc::cmt_<'tcx>, mode: euv::MatchMode) {\n-        if let euv::MatchMode::MovingMatch = mode {\n-            self.move_common(matched_pat.hir_id, matched_pat.span, cmt);\n-        } else {\n-            self.non_moving_pat(matched_pat, cmt);\n-        }\n-    }\n-\n-    fn consume_pat(&mut self, consume_pat: &Pat, cmt: &mc::cmt_<'tcx>, mode: euv::ConsumeMode) {\n-        if let euv::ConsumeMode::Move(_) = mode {\n-            self.move_common(consume_pat.hir_id, consume_pat.span, cmt);\n+impl<'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt {\n+    fn consume(&mut self, cmt: &mc::cmt_<'tcx>, mode: euv::ConsumeMode) {\n+        if let euv::ConsumeMode::Move = mode {\n+            self.move_common(cmt);\n         }\n     }\n \n-    fn borrow(\n-        &mut self,\n-        _: HirId,\n-        _: Span,\n-        _: &mc::cmt_<'tcx>,\n-        _: ty::Region<'_>,\n-        _: ty::BorrowKind,\n-        _: euv::LoanCause,\n-    ) {\n-    }\n-\n-    fn mutate(&mut self, _: HirId, _: Span, _: &mc::cmt_<'tcx>, _: euv::MutateMode) {}\n+    fn borrow(&mut self, _: &mc::cmt_<'tcx>, _: ty::BorrowKind) {}\n \n-    fn decl_without_init(&mut self, _: HirId, _: Span) {}\n+    fn mutate(&mut self, _: &mc::cmt_<'tcx>) {}\n }\n \n fn unwrap_downcast_or_interior<'a, 'tcx>(mut cmt: &'a mc::cmt_<'tcx>) -> mc::cmt_<'tcx> {"}, {"sha": "ae288f460eadf4545428e17a8b29e64eca8bde70", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df80193bda8ae3a5e720612fe24fa313af098812/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df80193bda8ae3a5e720612fe24fa313af098812/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=df80193bda8ae3a5e720612fe24fa313af098812", "patch": "@@ -803,13 +803,15 @@ pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n }\n \n /// Checks if an expression is constructing a tuple-like enum variant or struct\n-pub fn is_ctor_function(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n+pub fn is_ctor_or_promotable_const_function(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     if let ExprKind::Call(ref fun, _) = expr.kind {\n         if let ExprKind::Path(ref qp) = fun.kind {\n-            return matches!(\n-                cx.tables.qpath_res(qp, fun.hir_id),\n-                def::Res::Def(DefKind::Variant, ..) | Res::Def(DefKind::Ctor(..), _)\n-            );\n+            let res = cx.tables.qpath_res(qp, fun.hir_id);\n+            return match res {\n+                def::Res::Def(DefKind::Variant, ..) | Res::Def(DefKind::Ctor(..), _) => true,\n+                def::Res::Def(_, def_id) => cx.tcx.is_promotable_const_fn(def_id),\n+                _ => false,\n+            };\n         }\n     }\n     false"}, {"sha": "41662099fd3d785ec64bb97d170e1ad71d3d580b", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/df80193bda8ae3a5e720612fe24fa313af098812/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df80193bda8ae3a5e720612fe24fa313af098812/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=df80193bda8ae3a5e720612fe24fa313af098812", "patch": "@@ -6,7 +6,6 @@ use rustc::middle::mem_categorization::cmt_;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n-use syntax::source_map::Span;\n \n /// Returns a set of mutated local variable IDs, or `None` if mutations could not be determined.\n pub fn mutated_variables<'a, 'tcx>(expr: &'tcx Expr, cx: &'a LateContext<'a, 'tcx>) -> Option<FxHashSet<HirId>> {\n@@ -23,7 +22,6 @@ pub fn mutated_variables<'a, 'tcx>(expr: &'tcx Expr, cx: &'a LateContext<'a, 'tc\n         cx.param_env,\n         region_scope_tree,\n         cx.tables,\n-        None,\n     )\n     .walk_expr(expr);\n \n@@ -66,21 +64,15 @@ impl<'tcx> MutVarsDelegate {\n }\n \n impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n-    fn consume(&mut self, _: HirId, _: Span, _: &cmt_<'tcx>, _: ConsumeMode) {}\n+    fn consume(&mut self, _: &cmt_<'tcx>, _: ConsumeMode) {}\n \n-    fn matched_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: MatchMode) {}\n-\n-    fn consume_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: ConsumeMode) {}\n-\n-    fn borrow(&mut self, _: HirId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, bk: ty::BorrowKind, _: LoanCause) {\n+    fn borrow(&mut self, cmt: &cmt_<'tcx>, bk: ty::BorrowKind) {\n         if let ty::BorrowKind::MutBorrow = bk {\n             self.update(&cmt.cat)\n         }\n     }\n \n-    fn mutate(&mut self, _: HirId, _: Span, cmt: &cmt_<'tcx>, _: MutateMode) {\n+    fn mutate(&mut self, cmt: &cmt_<'tcx>) {\n         self.update(&cmt.cat)\n     }\n-\n-    fn decl_without_init(&mut self, _: HirId, _: Span) {}\n }"}, {"sha": "19342fe1be742b5f041b76492cfb1a6cc85429a3", "filename": "tests/ui/escape_analysis.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df80193bda8ae3a5e720612fe24fa313af098812/tests%2Fui%2Fescape_analysis.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df80193bda8ae3a5e720612fe24fa313af098812/tests%2Fui%2Fescape_analysis.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fescape_analysis.stderr?ref=df80193bda8ae3a5e720612fe24fa313af098812", "patch": "@@ -12,11 +12,5 @@ error: local variable doesn't need to be boxed here\n LL | pub fn new(_needs_name: Box<PeekableSeekable<&()>>) -> () {}\n    |            ^^^^^^^^^^^\n \n-error: local variable doesn't need to be boxed here\n-  --> $DIR/escape_analysis.rs:170:23\n-   |\n-LL |     fn closure_borrow(x: Box<A>) {\n-   |                       ^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "0eeb76e0ec5fd713656843aa48b6000fdd98803f", "filename": "tests/ui/mut_range_bound.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df80193bda8ae3a5e720612fe24fa313af098812/tests%2Fui%2Fmut_range_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df80193bda8ae3a5e720612fe24fa313af098812/tests%2Fui%2Fmut_range_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_range_bound.stderr?ref=df80193bda8ae3a5e720612fe24fa313af098812", "patch": "@@ -2,27 +2,27 @@ error: attempt to mutate range bound within loop; note that the range of the loo\n   --> $DIR/mut_range_bound.rs:16:9\n    |\n LL |         m = 5;\n-   |         ^^^^^\n+   |         ^\n    |\n    = note: `-D clippy::mut-range-bound` implied by `-D warnings`\n \n error: attempt to mutate range bound within loop; note that the range of the loop is unchanged\n   --> $DIR/mut_range_bound.rs:23:9\n    |\n LL |         m *= 2;\n-   |         ^^^^^^\n+   |         ^\n \n error: attempt to mutate range bound within loop; note that the range of the loop is unchanged\n   --> $DIR/mut_range_bound.rs:31:9\n    |\n LL |         m = 5;\n-   |         ^^^^^\n+   |         ^\n \n error: attempt to mutate range bound within loop; note that the range of the loop is unchanged\n   --> $DIR/mut_range_bound.rs:32:9\n    |\n LL |         n = 7;\n-   |         ^^^^^\n+   |         ^\n \n error: attempt to mutate range bound within loop; note that the range of the loop is unchanged\n   --> $DIR/mut_range_bound.rs:46:22"}, {"sha": "3cb64a227f1af81e52766329177bedc605d39fea", "filename": "tests/ui/needless_pass_by_value.stderr", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/df80193bda8ae3a5e720612fe24fa313af098812/tests%2Fui%2Fneedless_pass_by_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df80193bda8ae3a5e720612fe24fa313af098812/tests%2Fui%2Fneedless_pass_by_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_pass_by_value.stderr?ref=df80193bda8ae3a5e720612fe24fa313af098812", "patch": "@@ -28,12 +28,7 @@ error: this argument is passed by value, but not consumed in the function body\n   --> $DIR/needless_pass_by_value.rs:49:18\n    |\n LL | fn test_match(x: Option<Option<String>>, y: Option<Option<String>>) {\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^\n-help: consider taking a reference instead\n-   |\n-LL | fn test_match(x: &Option<Option<String>>, y: Option<Option<String>>) {\n-LL |     match *x {\n-   |\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^ help: consider taking a reference instead: `&Option<Option<String>>`\n \n error: this argument is passed by value, but not consumed in the function body\n   --> $DIR/needless_pass_by_value.rs:62:24\n@@ -45,14 +40,7 @@ error: this argument is passed by value, but not consumed in the function body\n   --> $DIR/needless_pass_by_value.rs:62:36\n    |\n LL | fn test_destructure(x: Wrapper, y: Wrapper, z: Wrapper) {\n-   |                                    ^^^^^^^\n-help: consider taking a reference instead\n-   |\n-LL | fn test_destructure(x: Wrapper, y: &Wrapper, z: Wrapper) {\n-LL |     let Wrapper(s) = z; // moved\n-LL |     let Wrapper(ref t) = *y; // not moved\n-LL |     let Wrapper(_) = *y; // still not moved\n-   |\n+   |                                    ^^^^^^^ help: consider taking a reference instead: `&Wrapper`\n \n error: this argument is passed by value, but not consumed in the function body\n   --> $DIR/needless_pass_by_value.rs:78:49\n@@ -152,37 +140,25 @@ error: this argument is passed by value, but not consumed in the function body\n   --> $DIR/needless_pass_by_value.rs:131:45\n    |\n LL | fn test_destructure_copy(x: CopyWrapper, y: CopyWrapper, z: CopyWrapper) {\n-   |                                             ^^^^^^^^^^^\n+   |                                             ^^^^^^^^^^^ help: consider taking a reference instead: `&CopyWrapper`\n    |\n help: consider marking this type as Copy\n   --> $DIR/needless_pass_by_value.rs:123:1\n    |\n LL | struct CopyWrapper(u32);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n-help: consider taking a reference instead\n-   |\n-LL | fn test_destructure_copy(x: CopyWrapper, y: &CopyWrapper, z: CopyWrapper) {\n-LL |     let CopyWrapper(s) = z; // moved\n-LL |     let CopyWrapper(ref t) = *y; // not moved\n-LL |     let CopyWrapper(_) = *y; // still not moved\n-   |\n \n error: this argument is passed by value, but not consumed in the function body\n   --> $DIR/needless_pass_by_value.rs:131:61\n    |\n LL | fn test_destructure_copy(x: CopyWrapper, y: CopyWrapper, z: CopyWrapper) {\n-   |                                                             ^^^^^^^^^^^\n+   |                                                             ^^^^^^^^^^^ help: consider taking a reference instead: `&CopyWrapper`\n    |\n help: consider marking this type as Copy\n   --> $DIR/needless_pass_by_value.rs:123:1\n    |\n LL | struct CopyWrapper(u32);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n-help: consider taking a reference instead\n-   |\n-LL | fn test_destructure_copy(x: CopyWrapper, y: CopyWrapper, z: &CopyWrapper) {\n-LL |     let CopyWrapper(s) = *z; // moved\n-   |\n \n error: this argument is passed by value, but not consumed in the function body\n   --> $DIR/needless_pass_by_value.rs:143:40"}]}