{"sha": "fae4e2a155c860f81201e404eb2e28bde50bcc4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhZTRlMmExNTVjODYwZjgxMjAxZTQwNGViMmUyOGJkZTUwYmNjNGU=", "commit": {"author": {"name": "Shotaro Yamada", "email": "sinkuu@sinkuu.xyz", "date": "2020-04-17T04:24:24Z"}, "committer": {"name": "Shotaro Yamada", "email": "sinkuu@sinkuu.xyz", "date": "2020-04-20T08:59:27Z"}, "message": "Remove unused ToHex/FromHex trait", "tree": {"sha": "51d28f3d45b3873181dc698589e6b4ee64f17112", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51d28f3d45b3873181dc698589e6b4ee64f17112"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fae4e2a155c860f81201e404eb2e28bde50bcc4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fae4e2a155c860f81201e404eb2e28bde50bcc4e", "html_url": "https://github.com/rust-lang/rust/commit/fae4e2a155c860f81201e404eb2e28bde50bcc4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fae4e2a155c860f81201e404eb2e28bde50bcc4e/comments", "author": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33905adc5fc51a69329a15ed51c5ee7a71af6088", "url": "https://api.github.com/repos/rust-lang/rust/commits/33905adc5fc51a69329a15ed51c5ee7a71af6088", "html_url": "https://github.com/rust-lang/rust/commit/33905adc5fc51a69329a15ed51c5ee7a71af6088"}], "stats": {"total": 207, "additions": 0, "deletions": 207}, "files": [{"sha": "bc2da535fd3728b8cd412cd42746c96575e17447", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae4e2a155c860f81201e404eb2e28bde50bcc4e/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae4e2a155c860f81201e404eb2e28bde50bcc4e/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=fae4e2a155c860f81201e404eb2e28bde50bcc4e", "patch": "@@ -29,8 +29,6 @@ extern crate log;\n #[macro_use]\n extern crate cfg_if;\n \n-pub use rustc_serialize::hex::ToHex;\n-\n #[inline(never)]\n #[cold]\n pub fn cold_path<F: FnOnce() -> R, R>(f: F) -> R {"}, {"sha": "cfb165a3d4397d4848774f6e1b0aece763a49c24", "filename": "src/libserialize/hex.rs", "status": "removed", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/33905adc5fc51a69329a15ed51c5ee7a71af6088/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33905adc5fc51a69329a15ed51c5ee7a71af6088/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=33905adc5fc51a69329a15ed51c5ee7a71af6088", "patch": "@@ -1,137 +0,0 @@\n-//! Hex binary-to-text encoding\n-\n-pub use self::FromHexError::*;\n-\n-use std::error;\n-use std::fmt;\n-\n-/// A trait for converting a value to hexadecimal encoding\n-pub trait ToHex {\n-    /// Converts the value of `self` to a hex value, returning the owned\n-    /// string.\n-    fn to_hex(&self) -> String;\n-}\n-\n-const CHARS: &[u8] = b\"0123456789abcdef\";\n-\n-impl ToHex for [u8] {\n-    /// Turn a vector of `u8` bytes into a hexadecimal string.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(rustc_private)]\n-    ///\n-    /// extern crate serialize;\n-    /// use serialize::hex::ToHex;\n-    ///\n-    /// fn main () {\n-    ///     let str = [52,32].to_hex();\n-    ///     println!(\"{}\", str);\n-    /// }\n-    /// ```\n-    fn to_hex(&self) -> String {\n-        let mut v = Vec::with_capacity(self.len() * 2);\n-        for &byte in self {\n-            v.push(CHARS[(byte >> 4) as usize]);\n-            v.push(CHARS[(byte & 0xf) as usize]);\n-        }\n-\n-        unsafe { String::from_utf8_unchecked(v) }\n-    }\n-}\n-\n-/// A trait for converting hexadecimal encoded values\n-pub trait FromHex {\n-    /// Converts the value of `self`, interpreted as hexadecimal encoded data,\n-    /// into an owned vector of bytes, returning the vector.\n-    fn from_hex(&self) -> Result<Vec<u8>, FromHexError>;\n-}\n-\n-/// Errors that can occur when decoding a hex encoded string\n-#[derive(Copy, Clone, Debug)]\n-pub enum FromHexError {\n-    /// The input contained a character not part of the hex format\n-    InvalidHexCharacter(char, usize),\n-    /// The input had an invalid length\n-    InvalidHexLength,\n-}\n-\n-impl fmt::Display for FromHexError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            InvalidHexCharacter(ch, idx) => {\n-                write!(f, \"Invalid character '{}' at position {}\", ch, idx)\n-            }\n-            InvalidHexLength => write!(f, \"Invalid input length\"),\n-        }\n-    }\n-}\n-\n-impl error::Error for FromHexError {}\n-\n-impl FromHex for str {\n-    /// Converts any hexadecimal encoded string (literal, `@`, `&`, or `~`)\n-    /// to the byte values it encodes.\n-    ///\n-    /// You can use the `String::from_utf8` function to turn a\n-    /// `Vec<u8>` into a string with characters corresponding to those values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// This converts a string literal to hexadecimal and back.\n-    ///\n-    /// ```\n-    /// #![feature(rustc_private)]\n-    ///\n-    /// extern crate serialize;\n-    /// use serialize::hex::{FromHex, ToHex};\n-    ///\n-    /// fn main () {\n-    ///     let hello_str = \"Hello, World\".as_bytes().to_hex();\n-    ///     println!(\"{}\", hello_str);\n-    ///     let bytes = hello_str.from_hex().unwrap();\n-    ///     println!(\"{:?}\", bytes);\n-    ///     let result_str = String::from_utf8(bytes).unwrap();\n-    ///     println!(\"{}\", result_str);\n-    /// }\n-    /// ```\n-    fn from_hex(&self) -> Result<Vec<u8>, FromHexError> {\n-        // This may be an overestimate if there is any whitespace\n-        let mut b = Vec::with_capacity(self.len() / 2);\n-        let mut modulus = 0;\n-        let mut buf = 0;\n-\n-        for (idx, byte) in self.bytes().enumerate() {\n-            buf <<= 4;\n-\n-            match byte {\n-                b'A'..=b'F' => buf |= byte - b'A' + 10,\n-                b'a'..=b'f' => buf |= byte - b'a' + 10,\n-                b'0'..=b'9' => buf |= byte - b'0',\n-                b' ' | b'\\r' | b'\\n' | b'\\t' => {\n-                    buf >>= 4;\n-                    continue;\n-                }\n-                _ => {\n-                    let ch = self[idx..].chars().next().unwrap();\n-                    return Err(InvalidHexCharacter(ch, idx));\n-                }\n-            }\n-\n-            modulus += 1;\n-            if modulus == 2 {\n-                modulus = 0;\n-                b.push(buf);\n-            }\n-        }\n-\n-        match modulus {\n-            0 => Ok(b),\n-            _ => Err(InvalidHexLength),\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests;"}, {"sha": "ce62c0ff2329db6d2f72ba872907ebde2aed7893", "filename": "src/libserialize/hex/tests.rs", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/33905adc5fc51a69329a15ed51c5ee7a71af6088/src%2Flibserialize%2Fhex%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33905adc5fc51a69329a15ed51c5ee7a71af6088/src%2Flibserialize%2Fhex%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex%2Ftests.rs?ref=33905adc5fc51a69329a15ed51c5ee7a71af6088", "patch": "@@ -1,67 +0,0 @@\n-extern crate test;\n-use crate::hex::{FromHex, ToHex};\n-use test::Bencher;\n-\n-#[test]\n-pub fn test_to_hex() {\n-    assert_eq!(\"foobar\".as_bytes().to_hex(), \"666f6f626172\");\n-}\n-\n-#[test]\n-pub fn test_from_hex_okay() {\n-    assert_eq!(\"666f6f626172\".from_hex().unwrap(), b\"foobar\");\n-    assert_eq!(\"666F6F626172\".from_hex().unwrap(), b\"foobar\");\n-}\n-\n-#[test]\n-pub fn test_from_hex_odd_len() {\n-    assert!(\"666\".from_hex().is_err());\n-    assert!(\"66 6\".from_hex().is_err());\n-}\n-\n-#[test]\n-pub fn test_from_hex_invalid_char() {\n-    assert!(\"66y6\".from_hex().is_err());\n-}\n-\n-#[test]\n-pub fn test_from_hex_ignores_whitespace() {\n-    assert_eq!(\"666f 6f6\\r\\n26172 \".from_hex().unwrap(), b\"foobar\");\n-}\n-\n-#[test]\n-pub fn test_to_hex_all_bytes() {\n-    for i in 0..256 {\n-        assert_eq!([i as u8].to_hex(), format!(\"{:02x}\", i as usize));\n-    }\n-}\n-\n-#[test]\n-pub fn test_from_hex_all_bytes() {\n-    for i in 0..256 {\n-        let ii: &[u8] = &[i as u8];\n-        assert_eq!(format!(\"{:02x}\", i as usize).from_hex().unwrap(), ii);\n-        assert_eq!(format!(\"{:02X}\", i as usize).from_hex().unwrap(), ii);\n-    }\n-}\n-\n-#[bench]\n-pub fn bench_to_hex(b: &mut Bencher) {\n-    let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n-             \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n-    b.iter(|| {\n-        s.as_bytes().to_hex();\n-    });\n-    b.bytes = s.len() as u64;\n-}\n-\n-#[bench]\n-pub fn bench_from_hex(b: &mut Bencher) {\n-    let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n-             \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n-    let sb = s.as_bytes().to_hex();\n-    b.iter(|| {\n-        sb.from_hex().unwrap();\n-    });\n-    b.bytes = sb.len() as u64;\n-}"}, {"sha": "c0011fddf4ff3552641d23eb8a85a51922334013", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae4e2a155c860f81201e404eb2e28bde50bcc4e/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae4e2a155c860f81201e404eb2e28bde50bcc4e/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=fae4e2a155c860f81201e404eb2e28bde50bcc4e", "patch": "@@ -25,7 +25,6 @@ pub use self::serialize::{UseSpecializedDecodable, UseSpecializedEncodable};\n mod collection_impls;\n mod serialize;\n \n-pub mod hex;\n pub mod json;\n \n pub mod leb128;"}]}