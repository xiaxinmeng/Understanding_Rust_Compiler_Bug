{"sha": "22db8b1d53f866af3d949d6682f0cc3e2b00893f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZGI4YjFkNTNmODY2YWYzZDk0OWQ2NjgyZjBjYzNlMmIwMDg5M2Y=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-17T21:01:23Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-17T21:02:39Z"}, "message": "rustc: Use memmove instructions more aggressively in DPS mode. LLVM converts these to optimized block transfer instructions, significantly reducing code size.", "tree": {"sha": "e4d2fb5bbb131048de07077c139af43f654e0e38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4d2fb5bbb131048de07077c139af43f654e0e38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22db8b1d53f866af3d949d6682f0cc3e2b00893f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22db8b1d53f866af3d949d6682f0cc3e2b00893f", "html_url": "https://github.com/rust-lang/rust/commit/22db8b1d53f866af3d949d6682f0cc3e2b00893f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22db8b1d53f866af3d949d6682f0cc3e2b00893f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b7884e1faff210b88037ae047c81b06da4d05a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b7884e1faff210b88037ae047c81b06da4d05a3", "html_url": "https://github.com/rust-lang/rust/commit/4b7884e1faff210b88037ae047c81b06da4d05a3"}], "stats": {"total": 87, "additions": 74, "deletions": 13}, "files": [{"sha": "176c175a74b55898e0845fd92c7b6a28cdc60f32", "filename": "src/comp/middle/trans_dps.rs", "status": "modified", "additions": 74, "deletions": 13, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/22db8b1d53f866af3d949d6682f0cc3e2b00893f/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22db8b1d53f866af3d949d6682f0cc3e2b00893f/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs?ref=22db8b1d53f866af3d949d6682f0cc3e2b00893f", "patch": "@@ -20,6 +20,7 @@ import std::ivec;\n import std::option::none;\n import std::option::some;\n import std::str;\n+import std::uint;\n \n import LLFalse = lib::llvm::False;\n import LLTrue = lib::llvm::True;\n@@ -36,6 +37,30 @@ fn llelement_type(TypeRef llty) -> TypeRef {\n     lib::llvm::llvm::LLVMGetElementType(llty)\n }\n \n+fn llalign_of(&@crate_ctxt ccx, TypeRef llty) -> uint {\n+    ret llvm::LLVMPreferredAlignmentOfType(ccx.td.lltd, llty);\n+}\n+\n+fn llsize_of(&@crate_ctxt ccx, TypeRef llty) -> uint {\n+    ret llvm::LLVMStoreSizeOfType(ccx.td.lltd, llty);\n+}\n+\n+fn mk_const(&@crate_ctxt ccx, &str name, bool exported, ValueRef llval)\n+        -> ValueRef {\n+    auto llglobal = llvm::LLVMAddGlobal(ccx.llmod, trans::val_ty(llval),\n+                                        str::buf(name));\n+\n+    llvm::LLVMSetInitializer(llglobal, llval);\n+    llvm::LLVMSetGlobalConstant(llglobal, LLTrue);\n+\n+    if !exported {\n+        llvm::LLVMSetLinkage(llglobal,\n+                             lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n+    }\n+\n+    ret llglobal;\n+}\n+\n \n // Destination utilities\n \n@@ -138,10 +163,38 @@ fn store(&@block_ctxt bcx, &dest dest, ValueRef llsrc, bool cast)\n     ret bcx;\n }\n \n-tag heap { hp_task; hp_shared; }\n+fn memmove(&@block_ctxt bcx, &dest dest, ValueRef llsrcptr) -> @block_ctxt {\n+    alt (dest.slot) {\n+      // TODO: We might want to support these; I can't think of any case in\n+      // which we would want them off the top of my head, but feel free to add\n+      // them if they aid orthogonality.\n+      dst_nil { fail \"dst_nil in memmove\"; }\n+      dst_imm(_) { fail \"dst_imm in memmove\"; }\n+      dst_ptr(?lldestptr) {\n+        auto lldestty = llelement_type(trans::val_ty(llsrcptr));\n+        auto llsrcty = llelement_type(trans::val_ty(llsrcptr));\n+        auto dest_align = llalign_of(bcx_ccx(bcx), lldestty);\n+        auto src_align = llalign_of(bcx_ccx(bcx), llsrcty);\n+        auto align = uint::min(dest_align, src_align);\n+        auto llfn = bcx_ccx(bcx).intrinsics.get(\"llvm.memmove.p0i8.p0i8.i32\");\n+        auto lldestptr_i8 = bcx.build.PointerCast(lldestptr,\n+                                                  tc::T_ptr(tc::T_i8()));\n+        auto llsrcptr_i8 = bcx.build.PointerCast(llsrcptr,\n+                                                 tc::T_ptr(tc::T_i8()));\n+        bcx.build.Call(llfn,\n+                       ~[lldestptr_i8,\n+                         llsrcptr_i8,\n+                         tc::C_uint(llsize_of(bcx_ccx(bcx), llsrcty)),\n+                         tc::C_uint(align),\n+                         tc::C_bool(false)]);\n+        ret bcx;\n+      }\n+    }\n+}\n \n // Allocates a value of the given LLVM size on either the task heap or the\n // shared heap.\n+tag heap { hp_task; hp_shared; }\n fn malloc(&@block_ctxt bcx, ValueRef lldest, heap heap,\n           option[ValueRef] llcustom_size_opt) -> @block_ctxt {\n     auto llptrty = llelement_type(lltype_of(lldest));\n@@ -177,7 +230,7 @@ fn trans_lit(&@block_ctxt cx, &dest dest, &ast::lit lit) -> @block_ctxt {\n       ast::lit_str(?s, ast::sk_unique) {\n         auto r = trans_lit_str_common(bcx_ccx(bcx), s);\n         auto llstackpart = r._0; auto llheappartopt = r._1;\n-        bcx = store(bcx, dest, llstackpart, true);\n+        bcx = memmove(bcx, dest, llstackpart);\n         alt (llheappartopt) {\n           none { /* no-op */ }\n           some(?llheappart) {\n@@ -191,7 +244,8 @@ fn trans_lit(&@block_ctxt cx, &dest dest, &ast::lit lit) -> @block_ctxt {\n                                       tc::T_ptr(tc::T_ptr(llheappartty)));\n             malloc(bcx, lldestptrptr, hp_shared, none);\n             auto lldestptr = bcx.build.Load(lldestptrptr);\n-            bcx.build.Store(llheappart, lldestptr);\n+            memmove(bcx, rec(slot=dst_ptr(lldestptr), mode=dm_copy),\n+                    llheappart);\n           }\n         }\n       }\n@@ -341,6 +395,8 @@ fn trans_block(&@block_ctxt cx, &dest dest, &ast::block block)\n // since that doesn't work for crate constants.\n fn trans_lit_str_common(&@crate_ctxt ccx, &str s)\n         -> tup(ValueRef, option[ValueRef]) {\n+    auto llstackpart; auto llheappartopt;\n+\n     auto len = str::byte_len(s);\n \n     auto array = ~[];\n@@ -352,18 +408,23 @@ fn trans_lit_str_common(&@crate_ctxt ccx, &str s)\n             array += ~[tc::C_u8(0u)];\n         }\n \n-        ret tup(tc::C_struct(~[tc::C_uint(len + 1u),\n-                               tc::C_uint(abi::ivec_default_length),\n-                               tc::C_array(tc::T_i8(), array)]),\n-                none);\n-    }\n-\n-    auto llheappart = tc::C_struct(~[tc::C_uint(len),\n+        llstackpart = tc::C_struct(~[tc::C_uint(len + 1u),\n+                                     tc::C_uint(abi::ivec_default_length),\n                                      tc::C_array(tc::T_i8(), array)]);\n-    ret tup(tc::C_struct(~[tc::C_uint(0u),\n+        llheappartopt = none;\n+    } else {\n+        auto llheappart = tc::C_struct(~[tc::C_uint(len),\n+                                         tc::C_array(tc::T_i8(), array)]);\n+        llstackpart =\n+            tc::C_struct(~[tc::C_uint(0u),\n                            tc::C_uint(abi::ivec_default_length),\n-                           tc::C_null(tc::T_ptr(lltype_of(llheappart)))]),\n-            some(llheappart));\n+                           tc::C_null(tc::T_ptr(lltype_of(llheappart)))]);\n+        llheappartopt = some(mk_const(ccx, \"const_istr_heap\", false,\n+                                      llheappart));\n+    }\n+\n+    ret tup(mk_const(ccx, \"const_istr_stack\", false, llstackpart),\n+            llheappartopt);\n }\n \n // As above, we don't use destination-passing style here."}]}