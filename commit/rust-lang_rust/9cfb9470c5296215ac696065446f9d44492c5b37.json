{"sha": "9cfb9470c5296215ac696065446f9d44492c5b37", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljZmI5NDcwYzUyOTYyMTVhYzY5NjA2NTQ0NmY5ZDQ0NDkyYzViMzc=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-01-25T15:23:54Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-01-25T15:23:54Z"}, "message": "Allow unsized types as function parameters", "tree": {"sha": "1e804ec90f19c409480b38f8c4085713e1b36bd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e804ec90f19c409480b38f8c4085713e1b36bd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cfb9470c5296215ac696065446f9d44492c5b37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cfb9470c5296215ac696065446f9d44492c5b37", "html_url": "https://github.com/rust-lang/rust/commit/9cfb9470c5296215ac696065446f9d44492c5b37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cfb9470c5296215ac696065446f9d44492c5b37/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcb469e147dcaf2f9eb53e6f3c33a128522b51ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcb469e147dcaf2f9eb53e6f3c33a128522b51ba", "html_url": "https://github.com/rust-lang/rust/commit/bcb469e147dcaf2f9eb53e6f3c33a128522b51ba"}], "stats": {"total": 107, "additions": 70, "deletions": 37}, "files": [{"sha": "71df9dba61b65b0052ca522612fb76b5d4892c19", "filename": "src/abi/comments.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb9470c5296215ac696065446f9d44492c5b37/src%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb9470c5296215ac696065446f9d44492c5b37/src%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fcomments.rs?ref=9cfb9470c5296215ac696065446f9d44492c5b37", "patch": "@@ -77,15 +77,21 @@ pub fn add_local_place_comments<'tcx>(\n             (\"ssa\", std::borrow::Cow::Borrowed(\"\"))\n         }\n         CPlaceInner::NoPlace => (\"zst\", \"\".into()),\n-        CPlaceInner::Addr(ptr, None) => match ptr.base_and_offset() {\n-            (crate::pointer::PointerBase::Addr(addr), offset) => {\n-                (\"reuse\", format!(\"storage={}{}\", addr, offset).into())\n+        CPlaceInner::Addr(ptr, meta) => {\n+            let meta = if let Some(meta) = meta {\n+                Cow::Owned(format!(\",meta={}\", meta))\n+            } else {\n+                Cow::Borrowed(\"\")\n+            };\n+            match ptr.base_and_offset() {\n+                (crate::pointer::PointerBase::Addr(addr), offset) => {\n+                    (\"reuse\", format!(\"storage={}{}{}\", addr, offset, meta).into())\n+                }\n+                (crate::pointer::PointerBase::Stack(stack_slot), offset) => {\n+                    (\"stack\", format!(\"storage={}{}{}\", stack_slot, offset, meta).into())\n+                }\n             }\n-            (crate::pointer::PointerBase::Stack(stack_slot), offset) => {\n-                (\"stack\", format!(\"storage={}{}\", stack_slot, offset).into())\n-            }\n-        },\n-        CPlaceInner::Addr(_, Some(_)) => unreachable!(),\n+        }\n     };\n \n     fx.add_global_comment(format!("}, {"sha": "813a436ddf2c1aae62ba97f58dbfa249e408d748", "filename": "src/abi/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb9470c5296215ac696065446f9d44492c5b37/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb9470c5296215ac696065446f9d44492c5b37/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=9cfb9470c5296215ac696065446f9d44492c5b37", "patch": "@@ -139,7 +139,7 @@ fn clif_sig_from_fn_sig<'tcx>(\n             inputs.map(AbiParam::new).collect(),\n             vec![AbiParam::new(ret_ty_a), AbiParam::new(ret_ty_b)],\n         ),\n-        PassMode::ByRef => {\n+        PassMode::ByRef { sized: true } => {\n             (\n                 Some(pointer_ty(tcx)) // First param is place to put return val\n                     .into_iter()\n@@ -149,6 +149,7 @@ fn clif_sig_from_fn_sig<'tcx>(\n                 vec![],\n             )\n         }\n+        PassMode::ByRef { sized: false } => todo!(),\n     };\n \n     if requires_caller_location {\n@@ -350,9 +351,11 @@ pub fn codegen_fn_prelude(fx: &mut FunctionCx<'_, '_, impl Backend>, start_ebb:\n \n         let is_ssa = ssa_analyzed[local] == crate::analyze::SsaKind::Ssa;\n \n+        // While this is normally an optimization to prevent an unnecessary copy when an argument is\n+        // not mutated by the current function, this is necessary to support unsized arguments.\n         match arg_kind {\n             ArgKind::Normal(Some(val)) => {\n-                if let Some(addr) = val.try_to_addr() {\n+                if let Some((addr, meta)) = val.try_to_addr() {\n                     let local_decl = &fx.mir.local_decls[local];\n                     //                       v this ! is important\n                     let internally_mutable = !val.layout().ty.is_freeze(\n@@ -364,7 +367,11 @@ pub fn codegen_fn_prelude(fx: &mut FunctionCx<'_, '_, impl Backend>, start_ebb:\n                         // We wont mutate this argument, so it is fine to borrow the backing storage\n                         // of this argument, to prevent a copy.\n \n-                        let place = CPlace::for_ptr(Pointer::new(addr), val.layout());\n+                        let place = if let Some(meta) = meta {\n+                            CPlace::for_ptr_with_extra(Pointer::new(addr), meta, val.layout())\n+                        } else {\n+                            CPlace::for_ptr(Pointer::new(addr), val.layout())\n+                        };\n \n                         #[cfg(debug_assertions)]\n                         self::comments::add_local_place_comments(fx, place, local);"}, {"sha": "bbb231ed8b747be8ba6097e0ce9700e06f068ba0", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb9470c5296215ac696065446f9d44492c5b37/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb9470c5296215ac696065446f9d44492c5b37/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=9cfb9470c5296215ac696065446f9d44492c5b37", "patch": "@@ -7,7 +7,7 @@ pub enum PassMode {\n     NoPass,\n     ByVal(Type),\n     ByValPair(Type, Type),\n-    ByRef,\n+    ByRef { sized: bool },\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -70,14 +70,13 @@ impl PassMode {\n             PassMode::NoPass => Empty,\n             PassMode::ByVal(clif_type) => Single(clif_type),\n             PassMode::ByValPair(a, b) => Pair(a, b),\n-            PassMode::ByRef => Single(pointer_ty(tcx)),\n+            PassMode::ByRef { sized: true } => Single(pointer_ty(tcx)),\n+            PassMode::ByRef { sized: false } => Pair(pointer_ty(tcx), pointer_ty(tcx)),\n         }\n     }\n }\n \n pub fn get_pass_mode<'tcx>(tcx: TyCtxt<'tcx>, layout: TyLayout<'tcx>) -> PassMode {\n-    assert!(!layout.is_unsized());\n-\n     if layout.is_zst() {\n         // WARNING zst arguments must never be passed, as that will break CastKind::ClosureFnPointer\n         PassMode::NoPass\n@@ -94,16 +93,16 @@ pub fn get_pass_mode<'tcx>(tcx: TyCtxt<'tcx>, layout: TyLayout<'tcx>) -> PassMod\n                     // Returning (i128, i128) by-val-pair would take 4 regs, while only 3 are\n                     // available on x86_64. Cranelift gets confused when too many return params\n                     // are used.\n-                    PassMode::ByRef\n+                    PassMode::ByRef { sized: true }\n                 } else {\n                     PassMode::ByValPair(a, b)\n                 }\n             }\n \n             // FIXME implement Vector Abi in a cg_llvm compatible way\n-            layout::Abi::Vector { .. } => PassMode::ByRef,\n+            layout::Abi::Vector { .. } => PassMode::ByRef { sized: true },\n \n-            layout::Abi::Aggregate { .. } => PassMode::ByRef,\n+            &layout::Abi::Aggregate { sized } => PassMode::ByRef { sized },\n         }\n     }\n }\n@@ -119,7 +118,12 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n             let (a, b) = arg.load_scalar_pair(fx);\n             Pair(a, b)\n         }\n-        PassMode::ByRef => Single(arg.force_stack(fx).get_addr(fx)),\n+        PassMode::ByRef { sized: _ } => {\n+            match arg.force_stack(fx) {\n+                (ptr, None) => Single(ptr.get_addr(fx)),\n+                (ptr, Some(meta)) => Pair(ptr.get_addr(fx), meta),\n+            }\n+        }\n     }\n }\n \n@@ -158,6 +162,10 @@ pub(super) fn cvalue_for_param<'tcx>(\n             let (a, b) = ebb_params.assert_pair();\n             Some(CValue::by_val_pair(a, b, layout))\n         }\n-        PassMode::ByRef => Some(CValue::by_ref(Pointer::new(ebb_params.assert_single()), layout)),\n+        PassMode::ByRef { sized: true } => Some(CValue::by_ref(Pointer::new(ebb_params.assert_single()), layout)),\n+        PassMode::ByRef { sized: false } => {\n+            let (ptr, meta) = ebb_params.assert_pair();\n+            Some(CValue::by_ref_unsized(Pointer::new(ptr), meta, layout))\n+        }\n     }\n }"}, {"sha": "d76711173f1110ffcf76b5cb423818a049d11439", "filename": "src/abi/returning.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb9470c5296215ac696065446f9d44492c5b37/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb9470c5296215ac696065446f9d44492c5b37/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=9cfb9470c5296215ac696065446f9d44492c5b37", "patch": "@@ -9,7 +9,7 @@ pub fn can_return_to_ssa_var<'tcx>(tcx: TyCtxt<'tcx>, dest_layout: TyLayout<'tcx\n     match get_pass_mode(tcx, dest_layout) {\n         PassMode::NoPass | PassMode::ByVal(_) => true,\n         // FIXME Make it possible to return ByValPair and ByRef to an ssa var.\n-        PassMode::ByValPair(_, _) | PassMode::ByRef => false\n+        PassMode::ByValPair(_, _) | PassMode::ByRef { sized: _ } => false\n     }\n }\n \n@@ -33,13 +33,14 @@ pub(super) fn codegen_return_param(\n \n             Empty\n         }\n-        PassMode::ByRef => {\n+        PassMode::ByRef { sized: true } => {\n             let ret_param = fx.bcx.append_ebb_param(start_ebb, fx.pointer_type);\n             fx.local_map\n                 .insert(RETURN_PLACE, CPlace::for_ptr(Pointer::new(ret_param), ret_layout));\n \n             Single(ret_param)\n         }\n+        PassMode::ByRef { sized: false } => todo!(),\n     };\n \n     #[cfg(debug_assertions)]\n@@ -65,10 +66,11 @@ pub(super) fn codegen_with_call_return_arg<'tcx, B: Backend, T>(\n     let output_pass_mode = get_pass_mode(fx.tcx, ret_layout);\n     let return_ptr = match output_pass_mode {\n         PassMode::NoPass => None,\n-        PassMode::ByRef => match ret_place {\n+        PassMode::ByRef { sized: true } => match ret_place {\n             Some(ret_place) => Some(ret_place.to_ptr(fx).get_addr(fx)),\n             None => Some(fx.bcx.ins().iconst(fx.pointer_type, 43)),\n         },\n+        PassMode::ByRef { sized: false } => todo!(),\n         PassMode::ByVal(_) | PassMode::ByValPair(_, _) => None,\n     };\n \n@@ -89,17 +91,19 @@ pub(super) fn codegen_with_call_return_arg<'tcx, B: Backend, T>(\n                 ret_place.write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_layout));\n             }\n         }\n-        PassMode::ByRef => {}\n+        PassMode::ByRef { sized: true } => {}\n+        PassMode::ByRef { sized: false } => todo!(),\n     }\n \n     (call_inst, meta)\n }\n \n pub fn codegen_return(fx: &mut FunctionCx<impl Backend>) {\n     match get_pass_mode(fx.tcx, return_layout(fx)) {\n-        PassMode::NoPass | PassMode::ByRef => {\n+        PassMode::NoPass | PassMode::ByRef { sized: true } => {\n             fx.bcx.ins().return_(&[]);\n         }\n+        PassMode::ByRef { sized: false } => todo!(),\n         PassMode::ByVal(_) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let ret_val = place.to_cvalue(fx).load_scalar(fx);"}, {"sha": "882eb82f5aaa8e971b6f17b9f84f6aa292dcdc16", "filename": "src/value_and_place.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb9470c5296215ac696065446f9d44492c5b37/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb9470c5296215ac696065446f9d44492c5b37/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=9cfb9470c5296215ac696065446f9d44492c5b37", "patch": "@@ -66,14 +66,18 @@ pub struct CValue<'tcx>(CValueInner, TyLayout<'tcx>);\n \n #[derive(Debug, Copy, Clone)]\n enum CValueInner {\n-    ByRef(Pointer),\n+    ByRef(Pointer, Option<Value>),\n     ByVal(Value),\n     ByValPair(Value, Value),\n }\n \n impl<'tcx> CValue<'tcx> {\n     pub fn by_ref(ptr: Pointer, layout: TyLayout<'tcx>) -> CValue<'tcx> {\n-        CValue(CValueInner::ByRef(ptr), layout)\n+        CValue(CValueInner::ByRef(ptr, None), layout)\n+    }\n+\n+    pub fn by_ref_unsized(ptr: Pointer, meta: Value, layout: TyLayout<'tcx>) -> CValue<'tcx> {\n+        CValue(CValueInner::ByRef(ptr, Some(meta)), layout)\n     }\n \n     pub fn by_val(value: Value, layout: TyLayout<'tcx>) -> CValue<'tcx> {\n@@ -89,24 +93,24 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     // FIXME remove\n-    pub fn force_stack<'a>(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>) -> Pointer {\n+    pub fn force_stack<'a>(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>) -> (Pointer, Option<Value>) {\n         let layout = self.1;\n         match self.0 {\n-            CValueInner::ByRef(ptr) => ptr,\n+            CValueInner::ByRef(ptr, meta) => (ptr, meta),\n             CValueInner::ByVal(_) | CValueInner::ByValPair(_, _) => {\n                 let cplace = CPlace::new_stack_slot(fx, layout);\n                 cplace.write_cvalue(fx, self);\n-                cplace.to_ptr(fx)\n+                (cplace.to_ptr(fx), None)\n             }\n         }\n     }\n \n-    pub fn try_to_addr(self) -> Option<Value> {\n+    pub fn try_to_addr(self) -> Option<(Value, Option<Value>)> {\n         match self.0 {\n-            CValueInner::ByRef(ptr) => {\n+            CValueInner::ByRef(ptr, meta) => {\n                 if let Some((base_addr, offset)) = ptr.try_get_addr_and_offset() {\n                     if offset == Offset32::new(0) {\n-                        Some(base_addr)\n+                        Some((base_addr, meta))\n                     } else {\n                         None\n                     }\n@@ -122,7 +126,7 @@ impl<'tcx> CValue<'tcx> {\n     pub fn load_scalar<'a>(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>) -> Value {\n         let layout = self.1;\n         match self.0 {\n-            CValueInner::ByRef(ptr) => {\n+            CValueInner::ByRef(ptr, None) => {\n                 let clif_ty = match layout.abi {\n                     layout::Abi::Scalar(ref scalar) => scalar_to_clif_type(fx.tcx, scalar.clone()),\n                     layout::Abi::Vector { ref element, count } => {\n@@ -134,6 +138,7 @@ impl<'tcx> CValue<'tcx> {\n                 ptr.load(fx, clif_ty, MemFlags::new())\n             }\n             CValueInner::ByVal(value) => value,\n+            CValueInner::ByRef(_, Some(_)) => bug!(\"load_scalar for unsized value not allowed\"),\n             CValueInner::ByValPair(_, _) => bug!(\"Please use load_scalar_pair for ByValPair\"),\n         }\n     }\n@@ -145,7 +150,7 @@ impl<'tcx> CValue<'tcx> {\n     ) -> (Value, Value) {\n         let layout = self.1;\n         match self.0 {\n-            CValueInner::ByRef(ptr) => {\n+            CValueInner::ByRef(ptr, None) => {\n                 let (a_scalar, b_scalar) = match &layout.abi {\n                     layout::Abi::ScalarPair(a, b) => (a, b),\n                     _ => unreachable!(\"load_scalar_pair({:?})\", self),\n@@ -157,6 +162,7 @@ impl<'tcx> CValue<'tcx> {\n                 let val2 = ptr.offset(fx, b_offset).load(fx, clif_ty2, MemFlags::new());\n                 (val1, val2)\n             }\n+            CValueInner::ByRef(_, Some(_)) => bug!(\"load_scalar_pair for unsized value not allowed\"),\n             CValueInner::ByVal(_) => bug!(\"Please use load_scalar for ByVal\"),\n             CValueInner::ByValPair(val1, val2) => (val1, val2),\n         }\n@@ -182,10 +188,11 @@ impl<'tcx> CValue<'tcx> {\n                     _ => unreachable!(\"value_field for ByVal with abi {:?}\", layout.abi),\n                 }\n             }\n-            CValueInner::ByRef(ptr) => {\n+            CValueInner::ByRef(ptr, None) => {\n                 let (field_ptr, field_layout) = codegen_field(fx, ptr, None, layout, field);\n                 CValue::by_ref(field_ptr, field_layout)\n             }\n+            CValueInner::ByRef(_, Some(_)) => todo!(),\n             _ => bug!(\"place_field for {:?}\", self),\n         }\n     }\n@@ -495,7 +502,7 @@ impl<'tcx> CPlace<'tcx> {\n                     dst_layout.abi\n                 );\n             }\n-            CValueInner::ByRef(from_ptr) => {\n+            CValueInner::ByRef(from_ptr, None) => {\n                 let from_addr = from_ptr.get_addr(fx);\n                 let to_addr = to_ptr.get_addr(fx);\n                 let src_layout = from.1;\n@@ -511,6 +518,7 @@ impl<'tcx> CPlace<'tcx> {\n                     src_align,\n                 );\n             }\n+            CValueInner::ByRef(_, Some(_)) => todo!(),\n         }\n     }\n "}]}