{"sha": "ba583091e60553633dd3cc9ab37a1d9f64827a1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhNTgzMDkxZTYwNTUzNjMzZGQzY2M5YWIzN2ExZDlmNjQ4MjdhMWU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-16T12:43:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-16T12:43:21Z"}, "message": "Merge #1817\n\n1817: Support path starting with a type r=matklad a=uHOOCCOOHu\n\nThe path syntax `<Ty>::foo`\n\nCo-authored-by: uHOOCCOOHu <hooccooh1896@gmail.com>", "tree": {"sha": "41a9b72f46b1119ff32964f77365459fdb46a37d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41a9b72f46b1119ff32964f77365459fdb46a37d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba583091e60553633dd3cc9ab37a1d9f64827a1e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdf4NpCRBK7hj4Ov3rIwAAdHIIABKytSkFV+LvngRhHh3I795n\nZXWbkhnXHTsrINHcypq2HofpTzQAeQE+18huzkzTtCmKRaP1b79mJ1Hpi9OTyGLw\npRxt9mTnZSvI9pHij+kiOhc90UpzDxFzx5exsNqGlIJ3wwAsIyi71HuGA3ktmSL9\nNv+r2ZfkBg4JamYoR9yH0WRDTDakm6iEoh2iq63oNH3BM4wBVTQ0RkoAP6nhBpwB\nzyP1q9P/B6rbQIUFpJvEHMQMVP2E5QRYP088hBN5AK53RC3aT/Q2+VHobyKgiKlK\nFRIH50H72H37UgG4jz9LSiphGKCPXfRvNBESDq1wsUSVZLrmadI/dPQk35hotgE=\n=QAKT\n-----END PGP SIGNATURE-----\n", "payload": "tree 41a9b72f46b1119ff32964f77365459fdb46a37d\nparent 6b33b90091b0cecd4c092d34451aba9f2492063c\nparent 7ed3be32916facf3b709d5277381408cd3ec134a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1568637801 +0000\ncommitter GitHub <noreply@github.com> 1568637801 +0000\n\nMerge #1817\n\n1817: Support path starting with a type r=matklad a=uHOOCCOOHu\n\nThe path syntax `<Ty>::foo`\n\nCo-authored-by: uHOOCCOOHu <hooccooh1896@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba583091e60553633dd3cc9ab37a1d9f64827a1e", "html_url": "https://github.com/rust-lang/rust/commit/ba583091e60553633dd3cc9ab37a1d9f64827a1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba583091e60553633dd3cc9ab37a1d9f64827a1e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b33b90091b0cecd4c092d34451aba9f2492063c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b33b90091b0cecd4c092d34451aba9f2492063c", "html_url": "https://github.com/rust-lang/rust/commit/6b33b90091b0cecd4c092d34451aba9f2492063c"}, {"sha": "7ed3be32916facf3b709d5277381408cd3ec134a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ed3be32916facf3b709d5277381408cd3ec134a", "html_url": "https://github.com/rust-lang/rust/commit/7ed3be32916facf3b709d5277381408cd3ec134a"}], "stats": {"total": 383, "additions": 235, "deletions": 148}, "files": [{"sha": "5aae9854614ad7587d7bb1eb258b0b7f331285b4", "filename": "crates/ra_assists/src/auto_import.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fauto_import.rs?ref=ba583091e60553633dd3cc9ab37a1d9f64827a1e", "patch": "@@ -504,19 +504,20 @@ fn apply_auto_import(\n     }\n }\n \n-pub fn collect_hir_path_segments(path: &hir::Path) -> Vec<SmolStr> {\n+pub fn collect_hir_path_segments(path: &hir::Path) -> Option<Vec<SmolStr>> {\n     let mut ps = Vec::<SmolStr>::with_capacity(10);\n     match path.kind {\n         hir::PathKind::Abs => ps.push(\"\".into()),\n         hir::PathKind::Crate => ps.push(\"crate\".into()),\n         hir::PathKind::Plain => {}\n         hir::PathKind::Self_ => ps.push(\"self\".into()),\n         hir::PathKind::Super => ps.push(\"super\".into()),\n+        hir::PathKind::Type(_) => return None,\n     }\n     for s in path.segments.iter() {\n         ps.push(s.name.to_string().into());\n     }\n-    ps\n+    Some(ps)\n }\n \n // This function produces sequence of text edits into edit\n@@ -552,7 +553,7 @@ pub(crate) fn auto_import(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist\n     }\n \n     let hir_path = hir::Path::from_ast(path.clone())?;\n-    let segments = collect_hir_path_segments(&hir_path);\n+    let segments = collect_hir_path_segments(&hir_path)?;\n     if segments.len() < 2 {\n         return None;\n     }"}, {"sha": "f06e5ec07ea72385ba93ec84276e261d7f1be1f0", "filename": "crates/ra_hir/src/expr/validation.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs?ref=ba583091e60553633dd3cc9ab37a1d9f64827a1e", "patch": "@@ -7,8 +7,7 @@ use crate::{\n     db::HirDatabase,\n     diagnostics::{DiagnosticSink, MissingFields, MissingOkInTailExpr},\n     expr::AstPtr,\n-    name,\n-    path::{PathKind, PathSegment},\n+    path::known,\n     ty::{ApplicationTy, InferenceResult, Ty, TypeCtor},\n     Adt, Function, Name, Path,\n };\n@@ -108,14 +107,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             None => return,\n         };\n \n-        let std_result_path = Path {\n-            kind: PathKind::Abs,\n-            segments: vec![\n-                PathSegment { name: name::STD, args_and_bindings: None },\n-                PathSegment { name: name::RESULT_MOD, args_and_bindings: None },\n-                PathSegment { name: name::RESULT_TYPE, args_and_bindings: None },\n-            ],\n-        };\n+        let std_result_path = known::std_result_result();\n \n         let resolver = self.func.resolver(db);\n         let std_result_enum = match resolver.resolve_known_enum(db, &std_result_path) {"}, {"sha": "1bf993ffb0fd04e64aaf74899e4430e74be55ad6", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=ba583091e60553633dd3cc9ab37a1d9f64827a1e", "patch": "@@ -85,6 +85,7 @@ impl AsName for ra_db::Dependency {\n     }\n }\n \n+// Primitives\n pub(crate) const ISIZE: Name = Name::new(SmolStr::new_inline_from_ascii(5, b\"isize\"));\n pub(crate) const I8: Name = Name::new(SmolStr::new_inline_from_ascii(2, b\"i8\"));\n pub(crate) const I16: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"i16\"));\n@@ -102,24 +103,30 @@ pub(crate) const F64: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"f64\")\n pub(crate) const BOOL: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"bool\"));\n pub(crate) const CHAR: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"char\"));\n pub(crate) const STR: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"str\"));\n+\n+// Special names\n pub(crate) const SELF_PARAM: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"self\"));\n pub(crate) const SELF_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"Self\"));\n pub(crate) const MACRO_RULES: Name = Name::new(SmolStr::new_inline_from_ascii(11, b\"macro_rules\"));\n+\n+// Components of known path (value or mod name)\n pub(crate) const STD: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"std\"));\n pub(crate) const ITER: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"iter\"));\n-pub(crate) const INTO_ITERATOR: Name =\n-    Name::new(SmolStr::new_inline_from_ascii(12, b\"IntoIterator\"));\n-pub(crate) const ITEM: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"Item\"));\n pub(crate) const OPS: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"ops\"));\n-pub(crate) const TRY: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"Try\"));\n-pub(crate) const OK: Name = Name::new(SmolStr::new_inline_from_ascii(2, b\"Ok\"));\n-pub(crate) const FUTURE_MOD: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"future\"));\n+pub(crate) const FUTURE: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"future\"));\n+pub(crate) const RESULT: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"result\"));\n+pub(crate) const BOXED: Name = Name::new(SmolStr::new_inline_from_ascii(5, b\"boxed\"));\n+\n+// Components of known path (type name)\n+pub(crate) const INTO_ITERATOR_TYPE: Name =\n+    Name::new(SmolStr::new_inline_from_ascii(12, b\"IntoIterator\"));\n+pub(crate) const ITEM_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"Item\"));\n+pub(crate) const TRY_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"Try\"));\n+pub(crate) const OK_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(2, b\"Ok\"));\n pub(crate) const FUTURE_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"Future\"));\n-pub(crate) const RESULT_MOD: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"result\"));\n pub(crate) const RESULT_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"Result\"));\n-pub(crate) const OUTPUT: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"Output\"));\n-pub(crate) const TARGET: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"Target\"));\n-pub(crate) const BOXED_MOD: Name = Name::new(SmolStr::new_inline_from_ascii(5, b\"boxed\"));\n+pub(crate) const OUTPUT_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"Output\"));\n+pub(crate) const TARGET_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"Target\"));\n pub(crate) const BOX_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"Box\"));\n \n fn resolve_name(text: &SmolStr) -> SmolStr {"}, {"sha": "b808a0c36c22037fdc0ad611062e4c99bcaecedb", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=ba583091e60553633dd3cc9ab37a1d9f64827a1e", "patch": "@@ -382,6 +382,11 @@ impl CrateDefMap {\n                     return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n                 }\n             }\n+            PathKind::Type(_) => {\n+                // This is handled in `infer::infer_path_expr`\n+                // The result returned here does not matter\n+                return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n+            }\n         };\n \n         for (i, segment) in segments {"}, {"sha": "a61161b63ac697c10584b756dd0e4b1b0fe25699", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 73, "deletions": 27, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=ba583091e60553633dd3cc9ab37a1d9f64827a1e", "patch": "@@ -1,4 +1,4 @@\n-use std::sync::Arc;\n+use std::{iter, sync::Arc};\n \n use ra_syntax::{\n     ast::{self, NameOwner, TypeAscriptionOwner},\n@@ -42,14 +42,16 @@ pub enum GenericArg {\n     // or lifetime...\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum PathKind {\n     Plain,\n     Self_,\n     Super,\n     Crate,\n     // Absolute path\n     Abs,\n+    // Type based path like `<T>::foo`\n+    Type(Box<TypeRef>),\n }\n \n impl Path {\n@@ -63,6 +65,16 @@ impl Path {\n         }\n     }\n \n+    pub fn from_simple_segments(kind: PathKind, segments: impl IntoIterator<Item = Name>) -> Path {\n+        Path {\n+            kind,\n+            segments: segments\n+                .into_iter()\n+                .map(|name| PathSegment { name, args_and_bindings: None })\n+                .collect(),\n+        }\n+    }\n+\n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n     pub fn from_ast(mut path: ast::Path) -> Option<Path> {\n         let mut kind = PathKind::Plain;\n@@ -92,24 +104,32 @@ impl Path {\n                 ast::PathSegmentKind::Type { type_ref, trait_ref } => {\n                     assert!(path.qualifier().is_none()); // this can only occur at the first segment\n \n-                    // FIXME: handle <T> syntax (type segments without trait)\n-\n-                    // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n-                    let path = Path::from_ast(trait_ref?.path()?)?;\n-                    kind = path.kind;\n-                    let mut prefix_segments = path.segments;\n-                    prefix_segments.reverse();\n-                    segments.extend(prefix_segments);\n-                    // Insert the type reference (T in the above example) as Self parameter for the trait\n                     let self_type = TypeRef::from_ast(type_ref?);\n-                    let mut last_segment = segments.last_mut()?;\n-                    if last_segment.args_and_bindings.is_none() {\n-                        last_segment.args_and_bindings = Some(Arc::new(GenericArgs::empty()));\n-                    };\n-                    let args = last_segment.args_and_bindings.as_mut().unwrap();\n-                    let mut args_inner = Arc::make_mut(args);\n-                    args_inner.has_self_type = true;\n-                    args_inner.args.insert(0, GenericArg::Type(self_type));\n+\n+                    match trait_ref {\n+                        // <T>::foo\n+                        None => {\n+                            kind = PathKind::Type(Box::new(self_type));\n+                        }\n+                        // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n+                        Some(trait_ref) => {\n+                            let path = Path::from_ast(trait_ref.path()?)?;\n+                            kind = path.kind;\n+                            let mut prefix_segments = path.segments;\n+                            prefix_segments.reverse();\n+                            segments.extend(prefix_segments);\n+                            // Insert the type reference (T in the above example) as Self parameter for the trait\n+                            let mut last_segment = segments.last_mut()?;\n+                            if last_segment.args_and_bindings.is_none() {\n+                                last_segment.args_and_bindings =\n+                                    Some(Arc::new(GenericArgs::empty()));\n+                            };\n+                            let args = last_segment.args_and_bindings.as_mut().unwrap();\n+                            let mut args_inner = Arc::make_mut(args);\n+                            args_inner.has_self_type = true;\n+                            args_inner.args.insert(0, GenericArg::Type(self_type));\n+                        }\n+                    }\n                 }\n                 ast::PathSegmentKind::CrateKw => {\n                     kind = PathKind::Crate;\n@@ -214,7 +234,7 @@ impl GenericArgs {\n         }\n         if let Some(ret_type) = ret_type {\n             let type_ref = TypeRef::from_ast_opt(ret_type.type_ref());\n-            bindings.push((name::OUTPUT, type_ref))\n+            bindings.push((name::OUTPUT_TYPE, type_ref))\n         }\n         if args.is_empty() && bindings.is_empty() {\n             None\n@@ -230,10 +250,7 @@ impl GenericArgs {\n \n impl From<Name> for Path {\n     fn from(name: Name) -> Path {\n-        Path {\n-            kind: PathKind::Plain,\n-            segments: vec![PathSegment { name, args_and_bindings: None }],\n-        }\n+        Path::from_simple_segments(PathKind::Plain, iter::once(name))\n     }\n }\n \n@@ -287,6 +304,7 @@ fn convert_path(prefix: Option<Path>, path: ast::Path) -> Option<Path> {\n     let segment = path.segment()?;\n     let res = match segment.kind()? {\n         ast::PathSegmentKind::Name(name) => {\n+            // no type args in use\n             let mut res = prefix\n                 .unwrap_or_else(|| Path { kind: PathKind::Plain, segments: Vec::with_capacity(1) });\n             res.segments.push(PathSegment {\n@@ -299,19 +317,19 @@ fn convert_path(prefix: Option<Path>, path: ast::Path) -> Option<Path> {\n             if prefix.is_some() {\n                 return None;\n             }\n-            Path { kind: PathKind::Crate, segments: Vec::new() }\n+            Path::from_simple_segments(PathKind::Crate, iter::empty())\n         }\n         ast::PathSegmentKind::SelfKw => {\n             if prefix.is_some() {\n                 return None;\n             }\n-            Path { kind: PathKind::Self_, segments: Vec::new() }\n+            Path::from_simple_segments(PathKind::Self_, iter::empty())\n         }\n         ast::PathSegmentKind::SuperKw => {\n             if prefix.is_some() {\n                 return None;\n             }\n-            Path { kind: PathKind::Super, segments: Vec::new() }\n+            Path::from_simple_segments(PathKind::Super, iter::empty())\n         }\n         ast::PathSegmentKind::Type { .. } => {\n             // not allowed in imports\n@@ -320,3 +338,31 @@ fn convert_path(prefix: Option<Path>, path: ast::Path) -> Option<Path> {\n     };\n     Some(res)\n }\n+\n+pub mod known {\n+    use super::{Path, PathKind};\n+    use crate::name;\n+\n+    pub fn std_iter_into_iterator() -> Path {\n+        Path::from_simple_segments(\n+            PathKind::Abs,\n+            vec![name::STD, name::ITER, name::INTO_ITERATOR_TYPE],\n+        )\n+    }\n+\n+    pub fn std_ops_try() -> Path {\n+        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::TRY_TYPE])\n+    }\n+\n+    pub fn std_result_result() -> Path {\n+        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::RESULT, name::RESULT_TYPE])\n+    }\n+\n+    pub fn std_future_future() -> Path {\n+        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::FUTURE, name::FUTURE_TYPE])\n+    }\n+\n+    pub fn std_boxed_box() -> Path {\n+        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::BOXED, name::BOX_TYPE])\n+    }\n+}"}, {"sha": "bb69159010d8f7e3aa052e2d29eeee8ba2544b61", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=ba583091e60553633dd3cc9ab37a1d9f64827a1e", "patch": "@@ -15,6 +15,7 @@ use crate::{\n     name::{Name, SELF_PARAM, SELF_TYPE},\n     nameres::{CrateDefMap, CrateModuleId, PerNs},\n     path::{Path, PathKind},\n+    type_ref::TypeRef,\n     Adt, BuiltinType, Const, Enum, EnumVariant, Function, MacroDef, ModuleDef, Static, Struct,\n     Trait, TypeAlias,\n };\n@@ -64,9 +65,10 @@ pub enum TypeNs {\n }\n \n #[derive(Debug)]\n-pub enum ValueOrPartial {\n+pub enum ResolveValueResult<'a> {\n     ValueNs(ValueNs),\n     Partial(TypeNs, usize),\n+    TypeRef(&'a TypeRef),\n }\n \n #[derive(Debug)]\n@@ -183,11 +185,15 @@ impl Resolver {\n         Some(res)\n     }\n \n-    pub(crate) fn resolve_path_in_value_ns(\n+    pub(crate) fn resolve_path_in_value_ns<'p>(\n         &self,\n         db: &impl HirDatabase,\n-        path: &Path,\n-    ) -> Option<ValueOrPartial> {\n+        path: &'p Path,\n+    ) -> Option<ResolveValueResult<'p>> {\n+        if let PathKind::Type(type_ref) = &path.kind {\n+            return Some(ResolveValueResult::TypeRef(type_ref));\n+        }\n+\n         let n_segments = path.segments.len();\n         let tmp = SELF_PARAM;\n         let first_name = if path.is_self() { &tmp } else { &path.segments.first()?.name };\n@@ -208,23 +214,23 @@ impl Resolver {\n                         .find(|entry| entry.name() == first_name);\n \n                     if let Some(e) = entry {\n-                        return Some(ValueOrPartial::ValueNs(ValueNs::LocalBinding(e.pat())));\n+                        return Some(ResolveValueResult::ValueNs(ValueNs::LocalBinding(e.pat())));\n                     }\n                 }\n                 Scope::ExprScope(_) => continue,\n \n                 Scope::GenericParams(params) if n_segments > 1 => {\n                     if let Some(param) = params.find_by_name(first_name) {\n                         let ty = TypeNs::GenericParam(param.idx);\n-                        return Some(ValueOrPartial::Partial(ty, 1));\n+                        return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n                 Scope::GenericParams(_) => continue,\n \n                 Scope::ImplBlockScope(impl_) if n_segments > 1 => {\n                     if first_name == &SELF_TYPE {\n                         let ty = TypeNs::SelfType(*impl_);\n-                        return Some(ValueOrPartial::Partial(ty, 1));\n+                        return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n                 Scope::ImplBlockScope(_) => continue,\n@@ -247,7 +253,7 @@ impl Resolver {\n                                 | ModuleDef::BuiltinType(_)\n                                 | ModuleDef::Module(_) => return None,\n                             };\n-                            Some(ValueOrPartial::ValueNs(value))\n+                            Some(ResolveValueResult::ValueNs(value))\n                         }\n                         Some(idx) => {\n                             let ty = match module_def.take_types()? {\n@@ -262,7 +268,7 @@ impl Resolver {\n                                 | ModuleDef::Const(_)\n                                 | ModuleDef::Static(_) => return None,\n                             };\n-                            Some(ValueOrPartial::Partial(ty, idx))\n+                            Some(ResolveValueResult::Partial(ty, idx))\n                         }\n                     };\n                 }\n@@ -277,8 +283,8 @@ impl Resolver {\n         path: &Path,\n     ) -> Option<ValueNs> {\n         match self.resolve_path_in_value_ns(db, path)? {\n-            ValueOrPartial::ValueNs(it) => Some(it),\n-            ValueOrPartial::Partial(..) => None,\n+            ResolveValueResult::ValueNs(it) => Some(it),\n+            ResolveValueResult::Partial(..) | ResolveValueResult::TypeRef(_) => None,\n         }\n     }\n "}, {"sha": "2a907c9f1caf22780e6632c87b586df15f1c7a9e", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=ba583091e60553633dd3cc9ab37a1d9f64827a1e", "patch": "@@ -25,8 +25,7 @@ use crate::{\n         BodySourceMap,\n     },\n     ids::LocationCtx,\n-    name,\n-    path::{PathKind, PathSegment},\n+    path::known,\n     resolve::{ScopeDef, TypeNs, ValueNs},\n     ty::method_resolution::implements_trait,\n     AsName, AstId, Const, Crate, DefWithBody, Either, Enum, Function, HasBody, HirFileId, MacroDef,\n@@ -433,14 +432,7 @@ impl SourceAnalyzer {\n     /// Checks that particular type `ty` implements `std::future::Future`.\n     /// This function is used in `.await` syntax completion.\n     pub fn impls_future(&self, db: &impl HirDatabase, ty: Ty) -> bool {\n-        let std_future_path = Path {\n-            kind: PathKind::Abs,\n-            segments: vec![\n-                PathSegment { name: name::STD, args_and_bindings: None },\n-                PathSegment { name: name::FUTURE_MOD, args_and_bindings: None },\n-                PathSegment { name: name::FUTURE_TYPE, args_and_bindings: None },\n-            ],\n-        };\n+        let std_future_path = known::std_future_future();\n \n         let std_future_trait = match self.resolver.resolve_known_trait(db, &std_future_path) {\n             Some(it) => it,"}, {"sha": "94f8ecdc9f1660576a57ec219829ecf67daa8393", "filename": "crates/ra_hir/src/ty/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs?ref=ba583091e60553633dd3cc9ab37a1d9f64827a1e", "patch": "@@ -42,7 +42,7 @@ fn deref_by_trait(\n         crate::lang_item::LangItemTarget::Trait(t) => t,\n         _ => return None,\n     };\n-    let target = deref_trait.associated_type_by_name(db, &name::TARGET)?;\n+    let target = deref_trait.associated_type_by_name(db, &name::TARGET_TYPE)?;\n \n     if target.generic_params(db).count_params_including_parent() != 1 {\n         // the Target type + Deref trait should only have one generic parameter,"}, {"sha": "bf9609d8c7749292330d3c412e72d2b33a2ba672", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 52, "deletions": 75, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=ba583091e60553633dd3cc9ab37a1d9f64827a1e", "patch": "@@ -44,11 +44,12 @@ use crate::{\n     generics::{GenericParams, HasGenericParams},\n     name,\n     nameres::Namespace,\n-    path::{GenericArg, GenericArgs, PathKind, PathSegment},\n-    resolve::{Resolver, TypeNs, ValueNs, ValueOrPartial},\n+    path::{known, GenericArg, GenericArgs},\n+    resolve::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n     ty::infer::diagnostics::InferenceDiagnostic,\n     type_ref::{Mutability, TypeRef},\n-    Adt, ConstData, DefWithBody, FnData, Function, HasBody, ImplItem, Name, Path, StructField,\n+    Adt, ConstData, DefWithBody, Either, FnData, Function, HasBody, ImplItem, Name, Path,\n+    StructField,\n };\n \n mod unify;\n@@ -470,9 +471,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let value_or_partial = resolver.resolve_path_in_value_ns(self.db, &path)?;\n \n         let (value, self_subst) = match value_or_partial {\n-            ValueOrPartial::ValueNs(it) => (it, None),\n-            ValueOrPartial::Partial(def, remaining_index) => {\n-                self.resolve_assoc_item(def, path, remaining_index, id)?\n+            ResolveValueResult::ValueNs(it) => (it, None),\n+            ResolveValueResult::Partial(def, remaining_index) => {\n+                self.resolve_assoc_item(Either::A(def), path, remaining_index, id)?\n+            }\n+            ResolveValueResult::TypeRef(type_ref) => {\n+                let ty = self.make_ty(type_ref);\n+                self.resolve_assoc_item(Either::B(ty), path, 0, id)?\n             }\n         };\n \n@@ -503,7 +508,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn resolve_assoc_item(\n         &mut self,\n-        mut def: TypeNs,\n+        mut def_or_ty: Either<TypeNs, Ty>,\n         path: &Path,\n         remaining_index: usize,\n         id: ExprOrPatId,\n@@ -516,30 +521,33 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         // resolve intermediate segments\n         for (i, segment) in path.segments[remaining_index..].iter().enumerate() {\n             let is_last_segment = i == path.segments[remaining_index..].len() - 1;\n-            ty = {\n-                let typable: TypableDef = match def {\n-                    TypeNs::Adt(it) => it.into(),\n-                    TypeNs::TypeAlias(it) => it.into(),\n-                    TypeNs::BuiltinType(it) => it.into(),\n-                    // FIXME associated item of traits, generics, and Self\n-                    TypeNs::Trait(_) | TypeNs::GenericParam(_) | TypeNs::SelfType(_) => {\n-                        return None;\n-                    }\n-                    // FIXME: report error here\n-                    TypeNs::EnumVariant(_) => return None,\n-                };\n-\n-                let ty = self.db.type_for_def(typable, Namespace::Types);\n+            ty = match def_or_ty {\n+                Either::A(def) => {\n+                    let typable: TypableDef = match def {\n+                        TypeNs::Adt(it) => it.into(),\n+                        TypeNs::TypeAlias(it) => it.into(),\n+                        TypeNs::BuiltinType(it) => it.into(),\n+                        // FIXME associated item of traits, generics, and Self\n+                        TypeNs::Trait(_) | TypeNs::GenericParam(_) | TypeNs::SelfType(_) => {\n+                            return None;\n+                        }\n+                        // FIXME: report error here\n+                        TypeNs::EnumVariant(_) => return None,\n+                    };\n \n-                // For example, this substs will take `Gen::*<u32>*::make`\n-                assert!(remaining_index > 0);\n-                let substs = Ty::substs_from_path_segment(\n-                    self.db,\n-                    &self.resolver,\n-                    &path.segments[remaining_index + i - 1],\n-                    typable,\n-                );\n-                ty.subst(&substs)\n+                    let ty = self.db.type_for_def(typable, Namespace::Types);\n+\n+                    // For example, this substs will take `Gen::*<u32>*::make`\n+                    assert!(remaining_index > 0);\n+                    let substs = Ty::substs_from_path_segment(\n+                        self.db,\n+                        &self.resolver,\n+                        &path.segments[remaining_index + i - 1],\n+                        typable,\n+                    );\n+                    ty.subst(&substs)\n+                }\n+                Either::B(ty) => ty,\n             };\n             if is_last_segment {\n                 break;\n@@ -550,15 +558,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             log::debug!(\"looking for path segment: {:?}\", segment);\n \n             let ty = mem::replace(&mut ty, Ty::Unknown);\n-            def = ty.iterate_impl_items(self.db, krate, |item| {\n+            def_or_ty = ty.iterate_impl_items(self.db, krate, |item| {\n                 match item {\n                     crate::ImplItem::Method(_) => None,\n                     crate::ImplItem::Const(_) => None,\n \n                     // FIXME: Resolve associated types\n                     crate::ImplItem::TypeAlias(_) => {\n-                        // Some(TypeNs::TypeAlias(..))\n-                        None::<TypeNs>\n+                        // Some(Either::A(TypeNs::TypeAlias(..)))\n+                        None\n                     }\n                 }\n             })?;\n@@ -1434,57 +1442,26 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn resolve_into_iter_item(&self) -> Option<TypeAlias> {\n-        let into_iter_path = Path {\n-            kind: PathKind::Abs,\n-            segments: vec![\n-                PathSegment { name: name::STD, args_and_bindings: None },\n-                PathSegment { name: name::ITER, args_and_bindings: None },\n-                PathSegment { name: name::INTO_ITERATOR, args_and_bindings: None },\n-            ],\n-        };\n-\n-        let trait_ = self.resolver.resolve_known_trait(self.db, &into_iter_path)?;\n-        trait_.associated_type_by_name(self.db, &name::ITEM)\n+        let path = known::std_iter_into_iterator();\n+        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        trait_.associated_type_by_name(self.db, &name::ITEM_TYPE)\n     }\n \n     fn resolve_ops_try_ok(&self) -> Option<TypeAlias> {\n-        let ops_try_path = Path {\n-            kind: PathKind::Abs,\n-            segments: vec![\n-                PathSegment { name: name::STD, args_and_bindings: None },\n-                PathSegment { name: name::OPS, args_and_bindings: None },\n-                PathSegment { name: name::TRY, args_and_bindings: None },\n-            ],\n-        };\n-\n-        let trait_ = self.resolver.resolve_known_trait(self.db, &ops_try_path)?;\n-        trait_.associated_type_by_name(self.db, &name::OK)\n+        let path = known::std_ops_try();\n+        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        trait_.associated_type_by_name(self.db, &name::OK_TYPE)\n     }\n \n     fn resolve_future_future_output(&self) -> Option<TypeAlias> {\n-        let future_future_path = Path {\n-            kind: PathKind::Abs,\n-            segments: vec![\n-                PathSegment { name: name::STD, args_and_bindings: None },\n-                PathSegment { name: name::FUTURE_MOD, args_and_bindings: None },\n-                PathSegment { name: name::FUTURE_TYPE, args_and_bindings: None },\n-            ],\n-        };\n-\n-        let trait_ = self.resolver.resolve_known_trait(self.db, &future_future_path)?;\n-        trait_.associated_type_by_name(self.db, &name::OUTPUT)\n+        let path = known::std_future_future();\n+        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        trait_.associated_type_by_name(self.db, &name::OUTPUT_TYPE)\n     }\n \n     fn resolve_boxed_box(&self) -> Option<Adt> {\n-        let boxed_box_path = Path {\n-            kind: PathKind::Abs,\n-            segments: vec![\n-                PathSegment { name: name::STD, args_and_bindings: None },\n-                PathSegment { name: name::BOXED_MOD, args_and_bindings: None },\n-                PathSegment { name: name::BOX_TYPE, args_and_bindings: None },\n-            ],\n-        };\n-        let struct_ = self.resolver.resolve_known_struct(self.db, &boxed_box_path)?;\n+        let path = known::std_boxed_box();\n+        let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n         Some(Adt::Struct(struct_))\n     }\n }"}, {"sha": "1bd677cab755373512195f705bde498b8437384f", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=ba583091e60553633dd3cc9ab37a1d9f64827a1e", "patch": "@@ -281,6 +281,64 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn infer_path_type() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct S;\n+\n+impl S {\n+    fn foo() -> i32 { 1 }\n+}\n+\n+fn test() {\n+    S::foo();\n+    <S>::foo();\n+}\n+\"#),\n+        @r###\"\n+    [41; 46) '{ 1 }': i32\n+    [43; 44) '1': i32\n+    [60; 93) '{     ...o(); }': ()\n+    [66; 72) 'S::foo': fn foo() -> i32\n+    [66; 74) 'S::foo()': i32\n+    [80; 88) '<S>::foo': fn foo() -> i32\n+    [80; 90) '<S>::foo()': i32\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn infer_slice_method() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang = \"slice\"]\n+impl<T> [T] {\n+    fn foo(&self) -> T {\n+        loop {}\n+    }\n+}\n+\n+#[lang = \"slice_alloc\"]\n+impl<T> [T] {}\n+\n+fn test() {\n+    <[_]>::foo(b\"foo\");\n+}\n+\"#),\n+        @r###\"\n+    [45; 49) 'self': &[T]\n+    [56; 79) '{     ...     }': !\n+    [66; 73) 'loop {}': !\n+    [71; 73) '{}': ()\n+    [133; 160) '{     ...o\"); }': ()\n+    [139; 149) '<[_]>::foo': fn foo<u8>(&[T]) -> T\n+    [139; 157) '<[_]>:...\"foo\")': u8\n+    [150; 156) 'b\"foo\"': &[u8]\n+\"###\n+    );\n+}\n+\n #[test]\n fn infer_struct() {\n     assert_snapshot!("}, {"sha": "dc1f8c82cb7554419477d417df413bdc0615ed50", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=ba583091e60553633dd3cc9ab37a1d9f64827a1e", "patch": "@@ -2385,6 +2385,9 @@ impl PathSegment {\n     pub fn ret_type(&self) -> Option<RetType> {\n         AstChildren::new(&self.syntax).next()\n     }\n+    pub fn path_type(&self) -> Option<PathType> {\n+        AstChildren::new(&self.syntax).next()\n+    }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathType {"}, {"sha": "da9de2214be2fa8810cab713d37255a49ec702ce", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/ba583091e60553633dd3cc9ab37a1d9f64827a1e/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=ba583091e60553633dd3cc9ab37a1d9f64827a1e", "patch": "@@ -689,7 +689,7 @@ Grammar(\n             ]\n         ),\n         \"PathSegment\": (\n-            options: [ \"NameRef\", \"TypeArgList\", \"ParamList\", \"RetType\" ]\n+            options: [ \"NameRef\", \"TypeArgList\", \"ParamList\", \"RetType\", \"PathType\" ]\n         ),\n         \"TypeArgList\": (collections: [\n             (\"type_args\", \"TypeArg\"),"}]}