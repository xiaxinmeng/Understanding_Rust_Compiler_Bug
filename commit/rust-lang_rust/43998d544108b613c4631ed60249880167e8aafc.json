{"sha": "43998d544108b613c4631ed60249880167e8aafc", "node_id": "C_kwDOAAsO6NoAKDQzOTk4ZDU0NDEwOGI2MTNjNDYzMWVkNjAyNDk4ODAxNjdlOGFhZmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-11T11:12:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-11T11:12:26Z"}, "message": "Auto merge of #95931 - matthiaskrgr:rollup-1c5zhit, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #95743 (Update binary_search example to instead redirect to partition_point)\n - #95771 (Update linker-plugin-lto.md to 1.60)\n - #95861 (Note that CI tests Windows 10)\n - #95875 (bootstrap: show available paths help text for aliased subcommands)\n - #95876 (Add a note for unsatisfied `~const Drop` bounds)\n - #95907 (address fixme for diagnostic variable name)\n - #95917 (thin_box test: import from std, not alloc)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "fd24d91aaf2601993b9cf28c45d5cf06fc7f678d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd24d91aaf2601993b9cf28c45d5cf06fc7f678d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43998d544108b613c4631ed60249880167e8aafc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43998d544108b613c4631ed60249880167e8aafc", "html_url": "https://github.com/rust-lang/rust/commit/43998d544108b613c4631ed60249880167e8aafc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43998d544108b613c4631ed60249880167e8aafc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d00e77078c0bd003323af67b4deb27627226d2e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d00e77078c0bd003323af67b4deb27627226d2e6", "html_url": "https://github.com/rust-lang/rust/commit/d00e77078c0bd003323af67b4deb27627226d2e6"}, {"sha": "5b8e2ea520b31edaebdce12c680819e516679229", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b8e2ea520b31edaebdce12c680819e516679229", "html_url": "https://github.com/rust-lang/rust/commit/5b8e2ea520b31edaebdce12c680819e516679229"}], "stats": {"total": 255, "additions": 157, "deletions": 98}, "files": [{"sha": "07878defa8ccdef1562f5ff78fa7ad7398c11c25", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 63, "deletions": 61, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/43998d544108b613c4631ed60249880167e8aafc/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43998d544108b613c4631ed60249880167e8aafc/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=43998d544108b613c4631ed60249880167e8aafc", "patch": "@@ -347,8 +347,7 @@ impl<'tcx> Ty<'tcx> {\n impl<'tcx> TyCtxt<'tcx> {\n     pub fn note_and_explain_type_err(\n         self,\n-        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n-        db: &mut Diagnostic,\n+        diag: &mut Diagnostic,\n         err: &TypeError<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         sp: Span,\n@@ -360,12 +359,12 @@ impl<'tcx> TyCtxt<'tcx> {\n             ArgumentSorts(values, _) | Sorts(values) => {\n                 match (values.expected.kind(), values.found.kind()) {\n                     (ty::Closure(..), ty::Closure(..)) => {\n-                        db.note(\"no two closures, even if identical, have the same type\");\n-                        db.help(\"consider boxing your closure and/or using it as a trait object\");\n+                        diag.note(\"no two closures, even if identical, have the same type\");\n+                        diag.help(\"consider boxing your closure and/or using it as a trait object\");\n                     }\n                     (ty::Opaque(..), ty::Opaque(..)) => {\n                         // Issue #63167\n-                        db.note(\"distinct uses of `impl Trait` result in different opaque types\");\n+                        diag.note(\"distinct uses of `impl Trait` result in different opaque types\");\n                     }\n                     (ty::Float(_), ty::Infer(ty::IntVar(_)))\n                         if let Ok(\n@@ -374,7 +373,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                         ) = self.sess.source_map().span_to_snippet(sp) =>\n                     {\n                         if snippet.chars().all(|c| c.is_digit(10) || c == '-' || c == '_') {\n-                            db.span_suggestion(\n+                            diag.span_suggestion(\n                                 sp,\n                                 \"use a float literal\",\n                                 format!(\"{}.0\", snippet),\n@@ -386,30 +385,30 @@ impl<'tcx> TyCtxt<'tcx> {\n                         let generics = self.generics_of(body_owner_def_id);\n                         let e_span = self.def_span(generics.type_param(expected, self).def_id);\n                         if !sp.contains(e_span) {\n-                            db.span_label(e_span, \"expected type parameter\");\n+                            diag.span_label(e_span, \"expected type parameter\");\n                         }\n                         let f_span = self.def_span(generics.type_param(found, self).def_id);\n                         if !sp.contains(f_span) {\n-                            db.span_label(f_span, \"found type parameter\");\n+                            diag.span_label(f_span, \"found type parameter\");\n                         }\n-                        db.note(\n+                        diag.note(\n                             \"a type parameter was expected, but a different one was found; \\\n                              you might be missing a type parameter or trait bound\",\n                         );\n-                        db.note(\n+                        diag.note(\n                             \"for more information, visit \\\n                              https://doc.rust-lang.org/book/ch10-02-traits.html\\\n                              #traits-as-parameters\",\n                         );\n                     }\n                     (ty::Projection(_), ty::Projection(_)) => {\n-                        db.note(\"an associated type was expected, but a different one was found\");\n+                        diag.note(\"an associated type was expected, but a different one was found\");\n                     }\n                     (ty::Param(p), ty::Projection(proj)) | (ty::Projection(proj), ty::Param(p)) => {\n                         let generics = self.generics_of(body_owner_def_id);\n                         let p_span = self.def_span(generics.type_param(p, self).def_id);\n                         if !sp.contains(p_span) {\n-                            db.span_label(p_span, \"this type parameter\");\n+                            diag.span_label(p_span, \"this type parameter\");\n                         }\n                         let hir = self.hir();\n                         let mut note = true;\n@@ -444,26 +443,26 @@ impl<'tcx> TyCtxt<'tcx> {\n                             note = !suggest_constraining_type_param(\n                                 self,\n                                 generics,\n-                                db,\n+                                diag,\n                                 &format!(\"{}\", proj.self_ty()),\n                                 &path,\n                                 None,\n                             );\n                         }\n                         if note {\n-                            db.note(\"you might be missing a type parameter or trait bound\");\n+                            diag.note(\"you might be missing a type parameter or trait bound\");\n                         }\n                     }\n                     (ty::Param(p), ty::Dynamic(..) | ty::Opaque(..))\n                     | (ty::Dynamic(..) | ty::Opaque(..), ty::Param(p)) => {\n                         let generics = self.generics_of(body_owner_def_id);\n                         let p_span = self.def_span(generics.type_param(p, self).def_id);\n                         if !sp.contains(p_span) {\n-                            db.span_label(p_span, \"this type parameter\");\n+                            diag.span_label(p_span, \"this type parameter\");\n                         }\n-                        db.help(\"type parameters must be constrained to match other types\");\n-                        if self.sess.teach(&db.get_code().unwrap()) {\n-                            db.help(\n+                        diag.help(\"type parameters must be constrained to match other types\");\n+                        if self.sess.teach(&diag.get_code().unwrap()) {\n+                            diag.help(\n                                 \"given a type parameter `T` and a method `foo`:\n ```\n trait Trait<T> { fn foo(&self) -> T; }\n@@ -489,7 +488,7 @@ impl<T> Trait<T> for X {\n ```\",\n                             );\n                         }\n-                        db.note(\n+                        diag.note(\n                             \"for more information, visit \\\n                              https://doc.rust-lang.org/book/ch10-02-traits.html\\\n                              #traits-as-parameters\",\n@@ -499,9 +498,9 @@ impl<T> Trait<T> for X {\n                         let generics = self.generics_of(body_owner_def_id);\n                         let p_span = self.def_span(generics.type_param(p, self).def_id);\n                         if !sp.contains(p_span) {\n-                            db.span_label(p_span, \"this type parameter\");\n+                            diag.span_label(p_span, \"this type parameter\");\n                         }\n-                        db.help(&format!(\n+                        diag.help(&format!(\n                             \"every closure has a distinct type and so could not always match the \\\n                              caller-chosen type of parameter `{}`\",\n                             p\n@@ -511,12 +510,12 @@ impl<T> Trait<T> for X {\n                         let generics = self.generics_of(body_owner_def_id);\n                         let p_span = self.def_span(generics.type_param(p, self).def_id);\n                         if !sp.contains(p_span) {\n-                            db.span_label(p_span, \"this type parameter\");\n+                            diag.span_label(p_span, \"this type parameter\");\n                         }\n                     }\n                     (ty::Projection(proj_ty), _) => {\n                         self.expected_projection(\n-                            db,\n+                            diag,\n                             proj_ty,\n                             values,\n                             body_owner_def_id,\n@@ -529,19 +528,19 @@ impl<T> Trait<T> for X {\n                             values.found, values.expected,\n                         );\n                         if !(self.suggest_constraining_opaque_associated_type(\n-                            db,\n+                            diag,\n                             &msg,\n                             proj_ty,\n                             values.expected,\n                         ) || self.suggest_constraint(\n-                            db,\n+                            diag,\n                             &msg,\n                             body_owner_def_id,\n                             proj_ty,\n                             values.expected,\n                         )) {\n-                            db.help(&msg);\n-                            db.note(\n+                            diag.help(&msg);\n+                            diag.note(\n                                 \"for more information, visit \\\n                                 https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\",\n                             );\n@@ -560,7 +559,7 @@ impl<T> Trait<T> for X {\n             CyclicTy(ty) => {\n                 // Watch out for various cases of cyclic types and try to explain.\n                 if ty.is_closure() || ty.is_generator() {\n-                    db.note(\n+                    diag.note(\n                         \"closures cannot capture themselves or take themselves as argument;\\n\\\n                          this error may be the result of a recent compiler bug-fix,\\n\\\n                          see issue #46062 <https://github.com/rust-lang/rust/issues/46062>\\n\\\n@@ -574,19 +573,18 @@ impl<T> Trait<T> for X {\n                     .iter()\n                     .filter(|attr| attr.has_name(sym::target_feature))\n                     .map(|attr| attr.span);\n-                db.note(\n+                diag.note(\n                     \"functions with `#[target_feature]` can only be coerced to `unsafe` function pointers\"\n                 );\n-                db.span_labels(target_spans, \"`#[target_feature]` added here\");\n+                diag.span_labels(target_spans, \"`#[target_feature]` added here\");\n             }\n             _ => {}\n         }\n     }\n \n     fn suggest_constraint(\n         self,\n-        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n-        db: &mut Diagnostic,\n+        diag: &mut Diagnostic,\n         msg: &str,\n         body_owner_def_id: DefId,\n         proj_ty: &ty::ProjectionTy<'tcx>,\n@@ -623,7 +621,7 @@ impl<T> Trait<T> for X {\n                         }\n \n                         if self.constrain_generic_bound_associated_type_structured_suggestion(\n-                            db,\n+                            diag,\n                             &trait_ref,\n                             pred.bounds,\n                             &assoc,\n@@ -642,7 +640,7 @@ impl<T> Trait<T> for X {\n                     {\n                         // This is type param `A` in `<A as T>::Foo`.\n                         return self.constrain_generic_bound_associated_type_structured_suggestion(\n-                            db,\n+                            diag,\n                             &trait_ref,\n                             param.bounds,\n                             &assoc,\n@@ -673,8 +671,7 @@ impl<T> Trait<T> for X {\n     ///    fn that returns the type.\n     fn expected_projection(\n         self,\n-        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n-        db: &mut Diagnostic,\n+        diag: &mut Diagnostic,\n         proj_ty: &ty::ProjectionTy<'tcx>,\n         values: &ExpectedFound<Ty<'tcx>>,\n         body_owner_def_id: DefId,\n@@ -712,41 +709,44 @@ impl<T> Trait<T> for X {\n             // want the more general suggestion later in this method about \"consider constraining\n             // the associated type or calling a method that returns the associated type\".\n             let point_at_assoc_fn = self.point_at_methods_that_satisfy_associated_type(\n-                db,\n+                diag,\n                 assoc.container.id(),\n                 current_method_ident,\n                 proj_ty.item_def_id,\n                 values.expected,\n             );\n             // Possibly suggest constraining the associated type to conform to the\n             // found type.\n-            if self.suggest_constraint(db, &msg, body_owner_def_id, proj_ty, values.found)\n+            if self.suggest_constraint(diag, &msg, body_owner_def_id, proj_ty, values.found)\n                 || point_at_assoc_fn\n             {\n                 return;\n             }\n         }\n \n-        self.suggest_constraining_opaque_associated_type(db, &msg, proj_ty, values.found);\n+        self.suggest_constraining_opaque_associated_type(diag, &msg, proj_ty, values.found);\n \n-        if self.point_at_associated_type(db, body_owner_def_id, values.found) {\n+        if self.point_at_associated_type(diag, body_owner_def_id, values.found) {\n             return;\n         }\n \n         if !impl_comparison {\n             // Generic suggestion when we can't be more specific.\n             if callable_scope {\n-                db.help(&format!(\"{} or calling a method that returns `{}`\", msg, values.expected));\n+                diag.help(&format!(\n+                    \"{} or calling a method that returns `{}`\",\n+                    msg, values.expected\n+                ));\n             } else {\n-                db.help(&msg);\n+                diag.help(&msg);\n             }\n-            db.note(\n+            diag.note(\n                 \"for more information, visit \\\n                  https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\",\n             );\n         }\n-        if self.sess.teach(&db.get_code().unwrap()) {\n-            db.help(\n+        if self.sess.teach(&diag.get_code().unwrap()) {\n+            diag.help(\n                 \"given an associated type `T` and a method `foo`:\n ```\n trait Trait {\n@@ -769,8 +769,7 @@ fn foo(&self) -> Self::T { String::new() }\n     /// a return type. This can occur when dealing with `TryStream` (#71035).\n     fn suggest_constraining_opaque_associated_type(\n         self,\n-        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n-        db: &mut Diagnostic,\n+        diag: &mut Diagnostic,\n         msg: &str,\n         proj_ty: &ty::ProjectionTy<'tcx>,\n         ty: Ty<'tcx>,\n@@ -790,7 +789,7 @@ fn foo(&self) -> Self::T { String::new() }\n             let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(self);\n \n             self.constrain_generic_bound_associated_type_structured_suggestion(\n-                db,\n+                diag,\n                 &trait_ref,\n                 opaque_hir_ty.bounds,\n                 assoc,\n@@ -806,8 +805,7 @@ fn foo(&self) -> Self::T { String::new() }\n \n     fn point_at_methods_that_satisfy_associated_type(\n         self,\n-        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n-        db: &mut Diagnostic,\n+        diag: &mut Diagnostic,\n         assoc_container_id: DefId,\n         current_method_ident: Option<Symbol>,\n         proj_ty_item_def_id: DefId,\n@@ -854,16 +852,15 @@ fn foo(&self) -> Self::T { String::new() }\n             for (sp, label) in methods.into_iter() {\n                 span.push_span_label(sp, label);\n             }\n-            db.span_help(span, &msg);\n+            diag.span_help(span, &msg);\n             return true;\n         }\n         false\n     }\n \n     fn point_at_associated_type(\n         self,\n-        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n-        db: &mut Diagnostic,\n+        diag: &mut Diagnostic,\n         body_owner_def_id: DefId,\n         found: Ty<'tcx>,\n     ) -> bool {\n@@ -887,7 +884,7 @@ fn foo(&self) -> Self::T { String::new() }\n                             if let hir::Defaultness::Default { has_value: true } = item.defaultness\n                             {\n                                 if self.type_of(item.id.def_id) == found {\n-                                    db.span_label(\n+                                    diag.span_label(\n                                         item.span,\n                                         \"associated type defaults can't be assumed inside the \\\n                                             trait defining them\",\n@@ -907,7 +904,7 @@ fn foo(&self) -> Self::T { String::new() }\n                 for item in &items[..] {\n                     if let hir::AssocItemKind::Type = item.kind {\n                         if self.type_of(item.id.def_id) == found {\n-                            db.span_label(item.span, \"expected this associated type\");\n+                            diag.span_label(item.span, \"expected this associated type\");\n                             return true;\n                         }\n                     }\n@@ -927,8 +924,7 @@ fn foo(&self) -> Self::T { String::new() }\n     /// type is defined on a supertrait of the one present in the bounds.\n     fn constrain_generic_bound_associated_type_structured_suggestion(\n         self,\n-        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n-        db: &mut Diagnostic,\n+        diag: &mut Diagnostic,\n         trait_ref: &ty::TraitRef<'tcx>,\n         bounds: hir::GenericBounds<'_>,\n         assoc: &ty::AssocItem,\n@@ -958,15 +954,21 @@ fn foo(&self) -> Self::T { String::new() }\n             _ => return false,\n         };\n \n-        self.constrain_associated_type_structured_suggestion(db, span, assoc, assoc_substs, ty, msg)\n+        self.constrain_associated_type_structured_suggestion(\n+            diag,\n+            span,\n+            assoc,\n+            assoc_substs,\n+            ty,\n+            msg,\n+        )\n     }\n \n     /// Given a span corresponding to a bound, provide a structured suggestion to set an\n     /// associated type to a given type `ty`.\n     fn constrain_associated_type_structured_suggestion(\n         self,\n-        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n-        db: &mut Diagnostic,\n+        diag: &mut Diagnostic,\n         span: Span,\n         assoc: &ty::AssocItem,\n         assoc_substs: &[ty::GenericArg<'tcx>],\n@@ -984,7 +986,7 @@ fn foo(&self) -> Self::T { String::new() }\n                 let item_args = self.format_generic_args(assoc_substs);\n                 (span.shrink_to_hi(), format!(\"<{}{} = {}>\", assoc.ident(self), item_args, ty))\n             };\n-            db.span_suggestion_verbose(span, msg, sugg, MaybeIncorrect);\n+            diag.span_suggestion_verbose(span, msg, sugg, MaybeIncorrect);\n             return true;\n         }\n         false"}, {"sha": "3ec63d102fab6bc29031921160ee5c50bc4cc3bc", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/43998d544108b613c4631ed60249880167e8aafc/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43998d544108b613c4631ed60249880167e8aafc/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=43998d544108b613c4631ed60249880167e8aafc", "patch": "@@ -1875,8 +1875,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n     /// Returns whether to add `'static` lifetime to the suggested lifetime list.\n     crate fn report_elision_failure(\n         &mut self,\n-        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n-        db: &mut Diagnostic,\n+        diag: &mut Diagnostic,\n         params: &[ElisionFailureInfo],\n     ) -> bool {\n         let mut m = String::new();\n@@ -1891,7 +1890,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n             let ElisionFailureInfo { parent, index, lifetime_count: n, have_bound_regions, span } =\n                 info;\n \n-            db.span_label(span, \"\");\n+            diag.span_label(span, \"\");\n             let help_name = if let Some(ident) =\n                 parent.and_then(|body| self.tcx.hir().body(body).params[index].pat.simple_ident())\n             {\n@@ -1923,27 +1922,27 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         }\n \n         if len == 0 {\n-            db.help(\n+            diag.help(\n                 \"this function's return type contains a borrowed value, \\\n                  but there is no value for it to be borrowed from\",\n             );\n             true\n         } else if elided_len == 0 {\n-            db.help(\n+            diag.help(\n                 \"this function's return type contains a borrowed value with \\\n                  an elided lifetime, but the lifetime cannot be derived from \\\n                  the arguments\",\n             );\n             true\n         } else if elided_len == 1 {\n-            db.help(&format!(\n+            diag.help(&format!(\n                 \"this function's return type contains a borrowed value, \\\n                  but the signature does not say which {} it is borrowed from\",\n                 m\n             ));\n             false\n         } else {\n-            db.help(&format!(\n+            diag.help(&format!(\n                 \"this function's return type contains a borrowed value, \\\n                  but the signature does not say whether it is borrowed from {}\",\n                 m"}, {"sha": "0cb70de241596080f181260637f8fac47d3e6246", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43998d544108b613c4631ed60249880167e8aafc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43998d544108b613c4631ed60249880167e8aafc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=43998d544108b613c4631ed60249880167e8aafc", "patch": "@@ -440,6 +440,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             }\n                         }\n \n+                        if Some(trait_ref.def_id()) == tcx.lang_items().drop_trait()\n+                            && predicate_is_const\n+                        {\n+                            err.note(\"`~const Drop` was renamed to `~const Destruct`\");\n+                            err.note(\"See <https://github.com/rust-lang/rust/pull/94901> for more details\");\n+                        }\n+\n                         let explanation = if let ObligationCauseCode::MainFunctionType =\n                             obligation.cause.code()\n                         {"}, {"sha": "488671d8d8d19b7fbf1ab6129ec934969e37dc41", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/43998d544108b613c4631ed60249880167e8aafc/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43998d544108b613c4631ed60249880167e8aafc/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=43998d544108b613c4631ed60249880167e8aafc", "patch": "@@ -2593,14 +2593,15 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     ///\n     /// If you want to insert an item to a sorted deque, while maintaining\n-    /// sort order:\n+    /// sort order, consider using [`partition_point`]:\n     ///\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut deque: VecDeque<_> = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n     /// let num = 42;\n-    /// let idx = deque.binary_search(&num).unwrap_or_else(|x| x);\n+    /// let idx = deque.partition_point(|&x| x < num);\n+    /// // The above is equivalent to `let idx = deque.binary_search(&num).unwrap_or_else(|x| x);`\n     /// deque.insert(idx, num);\n     /// assert_eq!(deque, &[0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);\n     /// ```\n@@ -2744,6 +2745,19 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// assert!(deque.iter().take(i).all(|&x| x < 5));\n     /// assert!(deque.iter().skip(i).all(|&x| !(x < 5)));\n     /// ```\n+    ///\n+    /// If you want to insert an item to a sorted deque, while maintaining\n+    /// sort order:\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut deque: VecDeque<_> = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n+    /// let num = 42;\n+    /// let idx = deque.partition_point(|&x| x < num);\n+    /// deque.insert(idx, num);\n+    /// assert_eq!(deque, &[0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);\n+    /// ```\n     #[stable(feature = \"vecdeque_binary_search\", since = \"1.54.0\")]\n     pub fn partition_point<P>(&self, mut pred: P) -> usize\n     where"}, {"sha": "51d2e9324bf2e9e2772582d13737be8b59a76062", "filename": "library/alloc/tests/thin_box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43998d544108b613c4631ed60249880167e8aafc/library%2Falloc%2Ftests%2Fthin_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43998d544108b613c4631ed60249880167e8aafc/library%2Falloc%2Ftests%2Fthin_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fthin_box.rs?ref=43998d544108b613c4631ed60249880167e8aafc", "patch": "@@ -1,5 +1,5 @@\n-use alloc::boxed::ThinBox;\n use core::mem::size_of;\n+use std::boxed::ThinBox;\n \n #[test]\n fn want_niche_optimization() {"}, {"sha": "2a4030de00b4e0f70a4db3e878ab3f1708aa6ccc", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/43998d544108b613c4631ed60249880167e8aafc/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43998d544108b613c4631ed60249880167e8aafc/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=43998d544108b613c4631ed60249880167e8aafc", "patch": "@@ -2331,12 +2331,13 @@ impl<T> [T] {\n     /// ```\n     ///\n     /// If you want to insert an item to a sorted vector, while maintaining\n-    /// sort order:\n+    /// sort order, consider using [`partition_point`]:\n     ///\n     /// ```\n     /// let mut s = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n     /// let num = 42;\n-    /// let idx = s.binary_search(&num).unwrap_or_else(|x| x);\n+    /// let idx = s.partition_point(|&x| x < num);\n+    /// // The above is equivalent to `let idx = s.binary_search(&num).unwrap_or_else(|x| x);`\n     /// s.insert(idx, num);\n     /// assert_eq!(s, [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);\n     /// ```\n@@ -3743,6 +3744,17 @@ impl<T> [T] {\n     /// assert!(v[..i].iter().all(|&x| x < 5));\n     /// assert!(v[i..].iter().all(|&x| !(x < 5)));\n     /// ```\n+    ///\n+    /// If you want to insert an item to a sorted vector, while maintaining\n+    /// sort order:\n+    ///\n+    /// ```\n+    /// let mut s = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let num = 42;\n+    /// let idx = s.partition_point(|&x| x < num);\n+    /// s.insert(idx, num);\n+    /// assert_eq!(s, [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);\n+    /// ```\n     #[stable(feature = \"partition_point\", since = \"1.52.0\")]\n     #[must_use]\n     pub fn partition_point<P>(&self, mut pred: P) -> usize"}, {"sha": "0276d15a5b472bb857bdb8add33e031e54e3f047", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43998d544108b613c4631ed60249880167e8aafc/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43998d544108b613c4631ed60249880167e8aafc/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=43998d544108b613c4631ed60249880167e8aafc", "patch": "@@ -621,9 +621,9 @@ impl<'a> Builder<'a> {\n \n     pub fn get_help(build: &Build, subcommand: &str) -> Option<String> {\n         let kind = match subcommand {\n-            \"build\" => Kind::Build,\n-            \"doc\" => Kind::Doc,\n-            \"test\" => Kind::Test,\n+            \"build\" | \"b\" => Kind::Build,\n+            \"doc\" | \"d\" => Kind::Doc,\n+            \"test\" | \"t\" => Kind::Test,\n             \"bench\" => Kind::Bench,\n             \"dist\" => Kind::Dist,\n             \"install\" => Kind::Install,"}, {"sha": "e7bf8d9a36f252e3b67d587d4867ec3215e396f0", "filename": "src/doc/rustc/src/linker-plugin-lto.md", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/43998d544108b613c4631ed60249880167e8aafc/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "raw_url": "https://github.com/rust-lang/rust/raw/43998d544108b613c4631ed60249880167e8aafc/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md?ref=43998d544108b613c4631ed60249880167e8aafc", "patch": "@@ -136,7 +136,7 @@ able to get around this problem by setting `-Clinker=lld-link` in RUSTFLAGS\n ```sh\n rustup toolchain install --profile minimal nightly\n MINOR_VERSION=$(rustc +nightly --version | cut -d . -f 2)\n-LOWER_BOUND=44\n+LOWER_BOUND=61\n \n llvm_version() {\n     toolchain=\"$1\"\n@@ -179,5 +179,19 @@ The following table shows known good combinations of toolchain versions.\n | Rust 1.44    |    Clang 9    |\n | Rust 1.45    |    Clang 10   |\n | Rust 1.46    |    Clang 10   |\n+| Rust 1.47    |    Clang 11   |\n+| Rust 1.48    |    Clang 11   |\n+| Rust 1.49    |    Clang 11   |\n+| Rust 1.50    |    Clang 11   |\n+| Rust 1.51    |    Clang 11   |\n+| Rust 1.52    |    Clang 12   |\n+| Rust 1.53    |    Clang 12   |\n+| Rust 1.54    |    Clang 12   |\n+| Rust 1.55    |    Clang 12   |\n+| Rust 1.56    |    Clang 13   |\n+| Rust 1.57    |    Clang 13   |\n+| Rust 1.58    |    Clang 13   |\n+| Rust 1.59    |    Clang 13   |\n+| Rust 1.60    |    Clang 14   |\n \n Note that the compatibility policy for this feature might change in the future."}, {"sha": "b3c4a52c414b2b746bcf74c847c0aa40cc53e135", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43998d544108b613c4631ed60249880167e8aafc/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/43998d544108b613c4631ed60249880167e8aafc/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=43998d544108b613c4631ed60249880167e8aafc", "patch": "@@ -31,18 +31,20 @@ All tier 1 targets with host tools support the full standard library.\n target | notes\n -------|-------\n `aarch64-unknown-linux-gnu` | ARM64 Linux (kernel 4.2, glibc 2.17+) [^missing-stack-probes]\n-`i686-pc-windows-gnu` | 32-bit MinGW (Windows 7+)\n-`i686-pc-windows-msvc` | 32-bit MSVC (Windows 7+)\n+`i686-pc-windows-gnu` | 32-bit MinGW (Windows 7+) [^windows-support]\n+`i686-pc-windows-msvc` | 32-bit MSVC (Windows 7+) [^windows-support]\n `i686-unknown-linux-gnu` | 32-bit Linux (kernel 2.6.32+, glibc 2.11+)\n `x86_64-apple-darwin` | 64-bit macOS (10.7+, Lion+)\n-`x86_64-pc-windows-gnu` | 64-bit MinGW (Windows 7+)\n-`x86_64-pc-windows-msvc` | 64-bit MSVC (Windows 7+)\n+`x86_64-pc-windows-gnu` | 64-bit MinGW (Windows 7+) [^windows-support]\n+`x86_64-pc-windows-msvc` | 64-bit MSVC (Windows 7+) [^windows-support]\n `x86_64-unknown-linux-gnu` | 64-bit Linux (kernel 2.6.32+, glibc 2.11+)\n \n [^missing-stack-probes]: Stack probes support is missing on\n   `aarch64-unknown-linux-gnu`, but it's planned to be implemented in the near\n   future. The implementation is tracked on [issue #77071][77071].\n \n+[^windows-support]: Only Windows 10 currently undergoes automated testing. Earlier versions of Windows rely on testing and support from the community.\n+\n [77071]: https://github.com/rust-lang/rust/issues/77071\n \n ## Tier 1"}, {"sha": "85a3e05e8b2136005da7d24c17d0534baae0b77a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43998d544108b613c4631ed60249880167e8aafc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43998d544108b613c4631ed60249880167e8aafc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=43998d544108b613c4631ed60249880167e8aafc", "patch": "@@ -302,23 +302,13 @@ impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n \n impl<'a> Clean<Option<WherePredicate>> for ty::PolyTraitPredicate<'a> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n-        // `T: ~const Drop` is not equivalent to `T: Drop`, and we don't currently document `~const` bounds\n-        // because of its experimental status, so just don't show these.\n         // `T: ~const Destruct` is hidden because `T: Destruct` is a no-op.\n         if self.skip_binder().constness == ty::BoundConstness::ConstIfConst\n-            && [cx.tcx.lang_items().drop_trait(), cx.tcx.lang_items().destruct_trait()]\n-                .iter()\n-                .any(|tr| *tr == Some(self.skip_binder().def_id()))\n+            && Some(self.skip_binder().def_id()) == cx.tcx.lang_items().destruct_trait()\n         {\n             return None;\n         }\n \n-        #[cfg(bootstrap)]\n-        {\n-            // FIXME: remove `lang_items().drop_trait()` from above logic,\n-            // as well as the comment about `~const Drop` because it was renamed to `Destruct`.\n-        }\n-\n         let poly_trait_ref = self.map_bound(|pred| pred.trait_ref);\n         Some(WherePredicate::BoundPredicate {\n             ty: poly_trait_ref.skip_binder().self_ty().clean(cx),"}, {"sha": "f9173feeeec81dd0e0ee13938765a3ba6bdb98a8", "filename": "src/test/rustdoc/rfc-2632-const-trait-impl.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/43998d544108b613c4631ed60249880167e8aafc/src%2Ftest%2Frustdoc%2Frfc-2632-const-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43998d544108b613c4631ed60249880167e8aafc/src%2Ftest%2Frustdoc%2Frfc-2632-const-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Frfc-2632-const-trait-impl.rs?ref=43998d544108b613c4631ed60249880167e8aafc", "patch": "@@ -1,5 +1,5 @@\n // Test that we do not currently display `~const` in rustdoc\n-// as that syntax is currently provisional; `~const Drop` has\n+// as that syntax is currently provisional; `~const Destruct` has\n // no effect on stable code so it should be hidden as well.\n //\n // To future blessers: make sure that `const_trait_impl` is\n@@ -8,6 +8,8 @@\n #![feature(const_trait_impl)]\n #![crate_name = \"foo\"]\n \n+use std::marker::Destruct;\n+\n pub struct S<T>(T);\n \n // @!has foo/trait.Tr.html '//pre[@class=\"rust trait\"]/code/a[@class=\"trait\"]' '~const'\n@@ -20,22 +22,36 @@ pub trait Tr<T> {\n     // @!has - '//div[@id=\"method.a\"]/h4[@class=\"code-header\"]/span[@class=\"where\"]' '~const'\n     // @has - '//div[@id=\"method.a\"]/h4[@class=\"code-header\"]/span[@class=\"where fmt-newline\"]' ': Clone'\n     #[default_method_body_is_const]\n-    fn a<A: ~const Clone>() where Option<A>: ~const Clone {}\n+    fn a<A: ~const Clone + ~const Destruct>()\n+    where\n+        Option<A>: ~const Clone + ~const Destruct,\n+    {\n+    }\n }\n \n // @!has - '//section[@id=\"impl-Tr%3CT%3E\"]/h3[@class=\"code-header in-band\"]' '~const'\n // @has - '//section[@id=\"impl-Tr%3CT%3E\"]/h3[@class=\"code-header in-band\"]/a[@class=\"trait\"]' 'Clone'\n // @!has - '//section[@id=\"impl-Tr%3CT%3E\"]/h3[@class=\"code-header in-band\"]/span[@class=\"where\"]' '~const'\n // @has - '//section[@id=\"impl-Tr%3CT%3E\"]/h3[@class=\"code-header in-band\"]/span[@class=\"where fmt-newline\"]' ': Clone'\n-impl<T: ~const Clone> const Tr<T> for T where Option<T>: ~const Clone {\n-    fn a<A: ~const Clone>() where Option<A>: ~const Clone {}\n+impl<T: ~const Clone + ~const Destruct> const Tr<T> for T\n+where\n+    Option<T>: ~const Clone + ~const Destruct,\n+{\n+    fn a<A: ~const Clone + ~const Destruct>()\n+    where\n+        Option<A>: ~const Clone + ~const Destruct,\n+    {\n+    }\n }\n \n // @!has foo/fn.foo.html '//pre[@class=\"rust fn\"]/code/a[@class=\"trait\"]' '~const'\n // @has - '//pre[@class=\"rust fn\"]/code/a[@class=\"trait\"]' 'Clone'\n // @!has - '//pre[@class=\"rust fn\"]/code/span[@class=\"where fmt-newline\"]' '~const'\n // @has - '//pre[@class=\"rust fn\"]/code/span[@class=\"where fmt-newline\"]' ': Clone'\n-pub const fn foo<F: ~const Clone>() where Option<F>: ~const Clone {\n+pub const fn foo<F: ~const Clone + ~const Destruct>()\n+where\n+    Option<F>: ~const Clone + ~const Destruct,\n+{\n     F::a()\n }\n \n@@ -44,7 +60,10 @@ impl<T> S<T> {\n     // @has - '//section[@id=\"method.foo\"]/h4[@class=\"code-header\"]/a[@class=\"trait\"]' 'Clone'\n     // @!has - '//section[@id=\"method.foo\"]/h4[@class=\"code-header\"]/span[@class=\"where\"]' '~const'\n     // @has - '//section[@id=\"method.foo\"]/h4[@class=\"code-header\"]/span[@class=\"where fmt-newline\"]' ': Clone'\n-    pub const fn foo<B: ~const Clone>() where B: ~const Clone {\n+    pub const fn foo<B: ~const Clone + ~const Destruct>()\n+    where\n+        B: ~const Clone + ~const Destruct,\n+    {\n         B::a()\n     }\n }"}]}