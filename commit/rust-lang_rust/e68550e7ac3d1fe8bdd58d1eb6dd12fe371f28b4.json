{"sha": "e68550e7ac3d1fe8bdd58d1eb6dd12fe371f28b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ODU1MGU3YWMzZDFmZThiZGQ1OGQxZWI2ZGQxMmZlMzcxZjI4YjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-22T23:06:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-22T23:06:51Z"}, "message": "auto merge of #13085 : edwardw/rust/saddest-cell, r=cmr", "tree": {"sha": "cfed18270238a2b2fd3828b59783cd01227b2482", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfed18270238a2b2fd3828b59783cd01227b2482"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e68550e7ac3d1fe8bdd58d1eb6dd12fe371f28b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e68550e7ac3d1fe8bdd58d1eb6dd12fe371f28b4", "html_url": "https://github.com/rust-lang/rust/commit/e68550e7ac3d1fe8bdd58d1eb6dd12fe371f28b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e68550e7ac3d1fe8bdd58d1eb6dd12fe371f28b4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f430c44262cc4965ece75835204ef8b60b4d604", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f430c44262cc4965ece75835204ef8b60b4d604", "html_url": "https://github.com/rust-lang/rust/commit/6f430c44262cc4965ece75835204ef8b60b4d604"}, {"sha": "7c3ed86e5a57b6cfa0872e15a478079a1871122f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c3ed86e5a57b6cfa0872e15a478079a1871122f", "html_url": "https://github.com/rust-lang/rust/commit/7c3ed86e5a57b6cfa0872e15a478079a1871122f"}], "stats": {"total": 21, "additions": 10, "deletions": 11}, "files": [{"sha": "ebb813f6d2433cdcaff0cd015009f45e57d6da84", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e68550e7ac3d1fe8bdd58d1eb6dd12fe371f28b4/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e68550e7ac3d1fe8bdd58d1eb6dd12fe371f28b4/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=e68550e7ac3d1fe8bdd58d1eb6dd12fe371f28b4", "patch": "@@ -1185,7 +1185,7 @@ struct DynamicFailureHandler<'a> {\n     bcx: &'a Block<'a>,\n     sp: Span,\n     msg: InternedString,\n-    finished: @Cell<Option<BasicBlockRef>>,\n+    finished: Cell<Option<BasicBlockRef>>,\n }\n \n impl<'a> DynamicFailureHandler<'a> {\n@@ -1927,7 +1927,7 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n     let chk = {\n         if ty::type_is_empty(tcx, t) {\n             // Special case for empty types\n-            let fail_cx = @Cell::new(None);\n+            let fail_cx = Cell::new(None);\n             let fail_handler = ~DynamicFailureHandler {\n                 bcx: scope_cx,\n                 sp: discr_expr.span,"}, {"sha": "adf3ac0e17d1a21c76e18644a351967e288f2f84", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e68550e7ac3d1fe8bdd58d1eb6dd12fe371f28b4/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e68550e7ac3d1fe8bdd58d1eb6dd12fe371f28b4/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e68550e7ac3d1fe8bdd58d1eb6dd12fe371f28b4", "patch": "@@ -77,7 +77,6 @@ use parse::token;\n use parse::{new_sub_parser_from_file, ParseSess};\n use owned_slice::OwnedSlice;\n \n-use std::cell::Cell;\n use collections::HashSet;\n use std::kinds::marker;\n use std::mem::replace;\n@@ -2202,12 +2201,12 @@ impl<'a> Parser<'a> {\n         // unification of Matcher's and TokenTree's would vastly improve\n         // the interpolation of Matcher's\n         maybe_whole!(self, NtMatchers);\n-        let name_idx = @Cell::new(0u);\n+        let mut name_idx = 0u;\n         match self.token {\n             token::LBRACE | token::LPAREN | token::LBRACKET => {\n                 let other_delimiter = token::flip_delimiter(&self.token);\n                 self.bump();\n-                self.parse_matcher_subseq_upto(name_idx, &other_delimiter)\n+                self.parse_matcher_subseq_upto(&mut name_idx, &other_delimiter)\n             }\n             _ => self.fatal(\"expected open delimiter\")\n         }\n@@ -2217,7 +2216,7 @@ impl<'a> Parser<'a> {\n     // Otherwise, `$( ( )` would be a valid Matcher, and `$( () )` would be\n     // invalid. It's similar to common::parse_seq.\n     pub fn parse_matcher_subseq_upto(&mut self,\n-                                     name_idx: @Cell<uint>,\n+                                     name_idx: &mut uint,\n                                      ket: &token::Token)\n                                      -> Vec<Matcher> {\n         let mut ret_val = Vec::new();\n@@ -2234,27 +2233,27 @@ impl<'a> Parser<'a> {\n         return ret_val;\n     }\n \n-    pub fn parse_matcher(&mut self, name_idx: @Cell<uint>) -> Matcher {\n+    pub fn parse_matcher(&mut self, name_idx: &mut uint) -> Matcher {\n         let lo = self.span.lo;\n \n         let m = if self.token == token::DOLLAR {\n             self.bump();\n             if self.token == token::LPAREN {\n-                let name_idx_lo = name_idx.get();\n+                let name_idx_lo = *name_idx;\n                 self.bump();\n                 let ms = self.parse_matcher_subseq_upto(name_idx,\n                                                         &token::RPAREN);\n                 if ms.len() == 0u {\n                     self.fatal(\"repetition body must be nonempty\");\n                 }\n                 let (sep, zerok) = self.parse_sep_and_zerok();\n-                MatchSeq(ms, sep, zerok, name_idx_lo, name_idx.get())\n+                MatchSeq(ms, sep, zerok, name_idx_lo, *name_idx)\n             } else {\n                 let bound_to = self.parse_ident();\n                 self.expect(&token::COLON);\n                 let nt_name = self.parse_ident();\n-                let m = MatchNonterminal(bound_to, nt_name, name_idx.get());\n-                name_idx.set(name_idx.get() + 1u);\n+                let m = MatchNonterminal(bound_to, nt_name, *name_idx);\n+                *name_idx += 1;\n                 m\n             }\n         } else {"}]}