{"sha": "f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "node_id": "C_kwDOAAsO6NoAKGYxOGMzOWU5OGNkNWY1Yzg0YmU2YzE2NzFkOWE0M2RjYTVmZTEwZjU", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2023-03-15T00:58:48Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2023-03-15T00:58:48Z"}, "message": "Merge from rustc", "tree": {"sha": "88c74d646060429f93b7790a9c7fad32a4c38a78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88c74d646060429f93b7790a9c7fad32a4c38a78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "html_url": "https://github.com/rust-lang/rust/commit/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a96b6a4449b2f4126cdc3e352cf7e8145affb7f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a96b6a4449b2f4126cdc3e352cf7e8145affb7f4", "html_url": "https://github.com/rust-lang/rust/commit/a96b6a4449b2f4126cdc3e352cf7e8145affb7f4"}, {"sha": "2adf2cd2f743e13d79fd4669bd6f673023a243f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2adf2cd2f743e13d79fd4669bd6f673023a243f2", "html_url": "https://github.com/rust-lang/rust/commit/2adf2cd2f743e13d79fd4669bd6f673023a243f2"}], "stats": {"total": 32752, "additions": 23128, "deletions": 9624}, "files": [{"sha": "d29c15fe712f301a375385e3ad9d624937721371", "filename": ".gitattributes", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -9,7 +9,6 @@\n src/etc/installer/gfx/* binary\n src/vendor/** -text\n Cargo.lock linguist-generated=false\n-config.toml.example linguist-language=TOML\n \n # Older git versions try to fix line endings on images and fonts, this prevents it.\n *.png binary"}, {"sha": "3873a020b75ead0e837202df675cbfd652368fc2", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -443,7 +443,7 @@ jobs:\n             os: windows-latest-xl\n           - name: dist-x86_64-msvc\n             env:\n-              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=x86_64-pc-windows-msvc --target=x86_64-pc-windows-msvc --enable-full-tools --enable-profiler --set rust.lto=thin\"\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=x86_64-pc-windows-msvc --target=x86_64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n               SCRIPT: PGO_HOST=x86_64-pc-windows-msvc python src/ci/stage-build.py python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n             os: windows-latest-xl"}, {"sha": "9a59f455fe9afdf4156bb99f3f54bf07d2df6b59", "filename": ".reuse/dep5", "status": "modified", "additions": 82, "deletions": 6, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/.reuse%2Fdep5", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/.reuse%2Fdep5", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.reuse%2Fdep5?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,23 +1,99 @@\n+# WARNING: this metadata is currently incomplete, do not rely on it yet.\n+\n Format: https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/\n Files-Excluded:\n  src/llvm-project\n \n-Files: *\n+# Note that we're explicitly listing the individual files at the root of the\n+# repository rather than just having `Files: *`. This is explicitly done to\n+# help downstream forks of the Rust compiler: this way, the files they add\n+# won't be automatically marked as authored by the Rust project.\n+Files: compiler/*\n+       library/*\n+       tests/*\n+       src/*\n+       .github/*\n+       Cargo.lock\n+       Cargo.toml\n+       CODE_OF_CONDUCT.md\n+       config.example.toml\n+       configure\n+       CONTRIBUTING.md\n+       COPYRIGHT\n+       LICENSE-APACHE\n+       LICENSE-MIT\n+       README.md\n+       RELEASES.md\n+       rustfmt.toml\n+       triagebot.toml\n+       x\n+       x.ps1\n+       x.py\n+       .editorconfig\n+       .git-blame-ignore-revs\n+       .gitattributes\n+       .gitignore\n+       .gitmodules\n+       .mailmap\n Copyright: The Rust Project Developers (see https://thanks.rust-lang.org)\n License: MIT or Apache-2.0\n \n+Files: compiler/rustc_apfloat/*\n+Copyright: LLVM APFloat authors\n+           The Rust Project Developers (see https://thanks.rust-lang.org)\n+License: NCSA AND (MIT OR Apache-2.0)\n+\n+Files: compiler/rustc_codegen_cranelift/src/cranelift_native.rs\n+Copyright: The Cranelift Project Developers\n+           The Rust Project Developers (see https://thanks.rust-lang.org)\n+License: Apache-2.0 WITH LLVM-exception AND (Apache-2.0 OR MIT)\n+\n+Files: compiler/rustc_llvm/llvm-wrapper/SymbolWrapper.cpp\n+Copyright: LLVM authors\n+           The Rust Project Developers (see https://thanks.rust-lang.org)\n+License: Apache-2.0 WITH LLVM-exception AND (Apache-2.0 OR MIT)\n+\n+Files: library/core/src/unicode/unicode_data.rs\n+Copyright: 1991-2022 Unicode, Inc. All rights reserved.\n+License: Unicode-DFS-2016\n+\n+Files: library/std/src/sync/mpmc/*\n+Copyright: 2019 The Crossbeam Project Developers\n+           The Rust Project Developers (see https://thanks.rust-lang.org)\n+License: MIT OR Apache-2.0\n+\n+Files: library/std/src/sys/unix/locks/fuchsia_mutex.rs\n+Copyright: 2016 The Fuchsia Authors\n+           The Rust Project Developers (see https://thanks.rust-lang.org)\n+License: BSD-2-Clause AND (MIT OR Apache-2.0)\n+\n+Files: src/test/rustdoc/auxiliary/enum-primitive.rs\n+Copyright: 2015 Anders Kaseorg <andersk@mit.edu>\n+License: MIT\n+\n Files: src/librustdoc/html/static/fonts/FiraSans*\n-Copyright: 2014, Mozilla Foundation, 2014, Telefonica S.A.\n+Copyright: 2014, Mozilla Foundation\n+           2014, Telefonica S.A.\n License: OFL-1.1\n \n Files: src/librustdoc/html/static/fonts/NanumBarun*\n Copyright: 2010 NAVER Corporation\n License: OFL-1.1\n \n Files: src/librustdoc/html/static/fonts/SourceCodePro*\n-Copyright: 2010, 2012 Adobe Systems Incorporated\n+       src/librustdoc/html/static/fonts/SourceSerif4*\n+Copyright: 2010, 2012, 2014-2023, Adobe Systems Incorporated\n License: OFL-1.1\n \n-Files: src/librustdoc/html/static/fonts/SourceSerif4*\n-Copyright: 2014-2021 Adobe Systems Incorporated\n-License: OFL-1.1\n+Files: src/librustdoc/html/static/css/normalize.css\n+Copyright: Nicolas Gallagher and Jonathan Neal\n+License: MIT\n+\n+Files: src/librustdoc/html/static/css/themes/ayu.css\n+Copyright: Ike Ku, Jessica Stokes, Leon Guan\n+           The Rust Project Developers (see https://thanks.rust-lang.org)\n+License: MIT OR Apache-2.0\n+\n+Files: src/doc/rustc-dev-guide/mermaid.min.js\n+Copyright: Knut Sveidqvist\n+License: MIT"}, {"sha": "51332919fe755ee18e988f01504de1b83e94d49f", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -738,7 +738,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy\"\n-version = \"0.1.69\"\n+version = \"0.1.70\"\n dependencies = [\n  \"clap 4.1.4\",\n  \"clippy_lints\",\n@@ -781,7 +781,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy_lints\"\n-version = \"0.1.69\"\n+version = \"0.1.70\"\n dependencies = [\n  \"cargo_metadata 0.15.3\",\n  \"clippy_utils\",\n@@ -804,7 +804,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy_utils\"\n-version = \"0.1.69\"\n+version = \"0.1.70\"\n dependencies = [\n  \"arrayvec 0.7.0\",\n  \"if_chain\",\n@@ -1150,7 +1150,7 @@ checksum = \"a0afaad2b26fa326569eb264b1363e8ae3357618c43982b3f285f0774ce76b69\"\n \n [[package]]\n name = \"declare_clippy_lint\"\n-version = \"0.1.69\"\n+version = \"0.1.70\"\n dependencies = [\n  \"itertools\",\n  \"quote\","}, {"sha": "5f662b354cd40cd5339d5aa05d74b15405138230", "filename": "LICENSES/BSD-2-Clause.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/LICENSES%2FBSD-2-Clause.txt", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/LICENSES%2FBSD-2-Clause.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FBSD-2-Clause.txt?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -0,0 +1,9 @@\n+Copyright (c) <year> <owner> \n+\n+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n+\n+1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n+\n+2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."}, {"sha": "cf5413effa25a89cae2ef0de21ade82e3672cb3b", "filename": "LICENSES/NCSA.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/LICENSES%2FNCSA.txt", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/LICENSES%2FNCSA.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FNCSA.txt?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -0,0 +1,15 @@\n+University of Illinois/NCSA Open Source License\n+\n+Copyright (c) <Year> <Owner Organization Name>. All rights reserved.\n+\n+Developed by: <Name of Development Group> <Name of Institution> <URL for Development Group/Institution>\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal with the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n+\n+     * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimers.\n+\n+     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimers in the documentation and/or other materials provided with the distribution.\n+\n+     * Neither the names of <Name of Development Group, Name of Institution>, nor the names of its contributors may be used to endorse or promote products derived from this Software without specific prior written permission.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE SOFTWARE."}, {"sha": "71fd6ac5e12e1703f2d2445393326649d30a49f5", "filename": "LICENSES/Unicode-DFS-2016.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/LICENSES%2FUnicode-DFS-2016.txt", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/LICENSES%2FUnicode-DFS-2016.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FUnicode-DFS-2016.txt?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -0,0 +1,22 @@\n+UNICODE, INC. LICENSE AGREEMENT - DATA FILES AND SOFTWARE\n+\n+Unicode Data Files include all data files under the directories http://www.unicode.org/Public/, http://www.unicode.org/reports/, http://www.unicode.org/cldr/data/, http://source.icu-project.org/repos/icu/, and http://www.unicode.org/utility/trac/browser/.\n+\n+Unicode Data Files do not include PDF online code charts under the directory http://www.unicode.org/Public/.\n+\n+Software includes any source code published in the Unicode Standard or under the directories http://www.unicode.org/Public/, http://www.unicode.org/reports/, http://www.unicode.org/cldr/data/, http://source.icu-project.org/repos/icu/, and http://www.unicode.org/utility/trac/browser/.\n+\n+NOTICE TO USER: Carefully read the following legal agreement. BY DOWNLOADING, INSTALLING, COPYING OR OTHERWISE USING UNICODE INC.'S DATA FILES (\"DATA FILES\"), AND/OR SOFTWARE (\"SOFTWARE\"), YOU UNEQUIVOCALLY ACCEPT, AND AGREE TO BE BOUND BY, ALL OF THE TERMS AND CONDITIONS OF THIS AGREEMENT. IF YOU DO NOT AGREE, DO NOT DOWNLOAD, INSTALL, COPY, DISTRIBUTE OR USE THE DATA FILES OR SOFTWARE.\n+\n+COPYRIGHT AND PERMISSION NOTICE\n+\n+Copyright \u00a9 1991-2016 Unicode, Inc. All rights reserved. Distributed under the Terms of Use in http://www.unicode.org/copyright.html.\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy of the Unicode data files and any associated documentation (the \"Data Files\") or Unicode software and any associated documentation (the \"Software\") to deal in the Data Files or Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, and/or sell copies of the Data Files or Software, and to permit persons to whom the Data Files or Software are furnished to do so, provided that either\n+\n+     (a) this copyright and permission notice appear with all copies of the Data Files or Software, or\n+     (b) this copyright and permission notice appear in associated Documentation.\n+\n+THE DATA FILES AND SOFTWARE ARE PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THE DATA FILES OR SOFTWARE.\n+\n+Except as contained in this notice, the name of a copyright holder shall not be used in advertising or otherwise to promote the sale, use or other dealings in these Data Files or Software without prior written authorization of the copyright holder."}, {"sha": "c19e129a9207aaefa4226af6d1f4fc1a11e1fb1f", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -99,7 +99,7 @@ See [the rustc-dev-guide for more info][sysllvm].\n    The Rust build system uses a file named `config.toml` in the root of the\n    source tree to determine various configuration settings for the build.\n    Set up the defaults intended for distros to get started. You can see a full\n-   list of options in `config.toml.example`.\n+   list of options in `config.example.toml`.\n \n    ```sh\n    printf 'profile = \"user\" \\nchangelog-seen = 2 \\n' > config.toml"}, {"sha": "434b978ae3151caa16781f2cddca9c9f5b8e5b46", "filename": "compiler/rustc/src/main.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2Fsrc%2Fmain.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -24,6 +24,15 @@\n // The two crates we link to here, `std` and `rustc_driver`, are both dynamic\n // libraries. So we must reference jemalloc symbols one way or another, because\n // this file is the only object code in the rustc executable.\n+//\n+// NOTE: if you are reading this comment because you want to set a custom `global_allocator` for\n+// benchmarking, consider using the benchmarks in the `rustc-perf` collector suite instead:\n+// https://github.com/rust-lang/rustc-perf/blob/master/collector/README.md#profiling\n+//\n+// NOTE: if you are reading this comment because you want to replace jemalloc with another allocator\n+// to compare their performance, see\n+// https://github.com/rust-lang/rust/commit/b90cfc887c31c3e7a9e6d462e2464db1fe506175#diff-43914724af6e464c1da2171e4a9b6c7e607d5bc1203fa95c0ab85be4122605ef\n+// for an example of how to do so.\n \n #[unix_sigpipe = \"sig_dfl\"]\n fn main() {"}, {"sha": "6503bf2bab7627c84d47829563aa12294b8ffd86", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1230,7 +1230,6 @@ impl Expr {\n \n     pub fn precedence(&self) -> ExprPrecedence {\n         match self.kind {\n-            ExprKind::Box(_) => ExprPrecedence::Box,\n             ExprKind::Array(_) => ExprPrecedence::Array,\n             ExprKind::ConstBlock(_) => ExprPrecedence::ConstBlock,\n             ExprKind::Call(..) => ExprPrecedence::Call,\n@@ -1291,8 +1290,7 @@ impl Expr {\n     /// To a first-order approximation, is this a pattern?\n     pub fn is_approximately_pattern(&self) -> bool {\n         match &self.peel_parens().kind {\n-            ExprKind::Box(_)\n-            | ExprKind::Array(_)\n+            ExprKind::Array(_)\n             | ExprKind::Call(_, _)\n             | ExprKind::Tup(_)\n             | ExprKind::Lit(_)\n@@ -1363,8 +1361,6 @@ pub struct StructExpr {\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum ExprKind {\n-    /// A `box x` expression.\n-    Box(P<Expr>),\n     /// An array (`[a, b, c, d]`)\n     Array(ThinVec<P<Expr>>),\n     /// Allow anonymous constants from an inline `const` block"}, {"sha": "45a5a3ecb53f0624a852808d0d154ba1ef16ac86", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1316,7 +1316,6 @@ pub fn noop_visit_expr<T: MutVisitor>(\n     vis: &mut T,\n ) {\n     match kind {\n-        ExprKind::Box(expr) => vis.visit_expr(expr),\n         ExprKind::Array(exprs) => visit_thin_exprs(exprs, vis),\n         ExprKind::ConstBlock(anon_const) => {\n             vis.visit_anon_const(anon_const);"}, {"sha": "607b77705cf83987acf0038e8d1683c48148e117", "filename": "compiler/rustc_ast/src/util/classify.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -35,7 +35,6 @@ pub fn expr_trailing_brace(mut expr: &ast::Expr) -> Option<&ast::Expr> {\n             | Assign(_, e, _)\n             | AssignOp(_, _, e)\n             | Binary(_, _, e)\n-            | Box(e)\n             | Break(_, Some(e))\n             | Let(_, e, _)\n             | Range(_, Some(e), _)"}, {"sha": "9a4da6d439600f955f39198b3acd5fd9e56edac7", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -772,7 +772,6 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n \n     match &expression.kind {\n-        ExprKind::Box(subexpression) => visitor.visit_expr(subexpression),\n         ExprKind::Array(subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }"}, {"sha": "3ccd84398ec2720b45a71eb71dcbb1cae73f3a10", "filename": "compiler/rustc_ast_lowering/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast_lowering%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast_lowering%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_ast_lowering/locales/en-US.ftl"}, {"sha": "181f94ab74f93320110f2532557f6f80d721051d", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 27, "deletions": 38, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -32,7 +32,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub(super) fn lower_expr_mut(&mut self, e: &Expr) -> hir::Expr<'hir> {\n         ensure_sufficient_stack(|| {\n             match &e.kind {\n-                // Paranthesis expression does not have a HirId and is handled specially.\n+                // Parenthesis expression does not have a HirId and is handled specially.\n                 ExprKind::Paren(ex) => {\n                     let mut ex = self.lower_expr_mut(ex);\n                     // Include parens in span, but only if it is a super-span.\n@@ -63,14 +63,27 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ExprKind::ForLoop(pat, head, body, opt_label) => {\n                     return self.lower_expr_for(e, pat, head, body, *opt_label);\n                 }\n+                // Similarly, async blocks do not use `e.id` but rather `closure_node_id`.\n+                ExprKind::Async(capture_clause, closure_node_id, block) => {\n+                    let hir_id = self.lower_node_id(*closure_node_id);\n+                    self.lower_attrs(hir_id, &e.attrs);\n+                    return self.make_async_expr(\n+                        *capture_clause,\n+                        hir_id,\n+                        *closure_node_id,\n+                        None,\n+                        e.span,\n+                        hir::AsyncGeneratorKind::Block,\n+                        |this| this.with_new_scopes(|this| this.lower_block_expr(block)),\n+                    );\n+                }\n                 _ => (),\n             }\n \n             let hir_id = self.lower_node_id(e.id);\n             self.lower_attrs(hir_id, &e.attrs);\n \n             let kind = match &e.kind {\n-                ExprKind::Box(inner) => hir::ExprKind::Box(self.lower_expr(inner)),\n                 ExprKind::Array(exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n                 ExprKind::ConstBlock(anon_const) => {\n                     let anon_const = self.lower_anon_const(anon_const);\n@@ -174,15 +187,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     self.arena.alloc_from_iter(arms.iter().map(|x| self.lower_arm(x))),\n                     hir::MatchSource::Normal,\n                 ),\n-                ExprKind::Async(capture_clause, closure_node_id, block) => self.make_async_expr(\n-                    *capture_clause,\n-                    hir_id,\n-                    *closure_node_id,\n-                    None,\n-                    e.span,\n-                    hir::AsyncGeneratorKind::Block,\n-                    |this| this.with_new_scopes(|this| this.lower_block_expr(block)),\n-                ),\n                 ExprKind::Await(expr) => {\n                     let dot_await_span = if expr.span.hi() < e.span.hi() {\n                         let span_with_whitespace = self\n@@ -316,7 +320,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ),\n                 ExprKind::Try(sub_expr) => self.lower_expr_try(e.span, sub_expr),\n \n-                ExprKind::Paren(_) | ExprKind::ForLoop(..) => unreachable!(\"already handled\"),\n+                ExprKind::Paren(_) | ExprKind::ForLoop(..) | ExprKind::Async(..) => {\n+                    unreachable!(\"already handled\")\n+                }\n \n                 ExprKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", e.span),\n             };\n@@ -578,9 +584,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     /// This results in:\n     ///\n     /// ```text\n-    /// std::future::identity_future(static move? |_task_context| -> <ret_ty> {\n+    /// static move? |_task_context| -> <ret_ty> {\n     ///     <body>\n-    /// })\n+    /// }\n     /// ```\n     pub(super) fn make_async_expr(\n         &mut self,\n@@ -591,7 +597,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         span: Span,\n         async_gen_kind: hir::AsyncGeneratorKind,\n         body: impl FnOnce(&mut Self) -> hir::Expr<'hir>,\n-    ) -> hir::ExprKind<'hir> {\n+    ) -> hir::Expr<'hir> {\n         let output = ret_ty.unwrap_or_else(|| hir::FnRetTy::DefaultReturn(self.lower_span(span)));\n \n         // Resume argument type: `ResumeTy`\n@@ -656,13 +662,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         };\n \n         let hir_id = self.lower_node_id(closure_node_id);\n-        let unstable_span =\n-            self.mark_span_with_reason(DesugaringKind::Async, span, self.allow_gen_future.clone());\n-\n         if self.tcx.features().closure_track_caller\n             && let Some(attrs) = self.attrs.get(&outer_hir_id.local_id)\n             && attrs.into_iter().any(|attr| attr.has_name(sym::track_caller))\n         {\n+            let unstable_span =\n+                self.mark_span_with_reason(DesugaringKind::Async, span, self.allow_gen_future.clone());\n             self.lower_attrs(\n                 hir_id,\n                 &[Attribute {\n@@ -681,22 +686,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             );\n         }\n \n-        let generator = hir::Expr { hir_id, kind: generator_kind, span: self.lower_span(span) };\n-\n-        // FIXME(swatinem):\n-        // For some reason, the async block needs to flow through *any*\n-        // call (like the identity function), as otherwise type and lifetime\n-        // inference have a hard time figuring things out.\n-        // Without this, we would get:\n-        // E0720 in tests/ui/impl-trait/in-trait/default-body-with-rpit.rs\n-        // E0700 in tests/ui/self/self_lifetime-async.rs\n-\n-        // `future::identity_future`:\n-        let identity_future =\n-            self.expr_lang_item_path(unstable_span, hir::LangItem::IdentityFuture, None);\n-\n-        // `future::identity_future(generator)`:\n-        hir::ExprKind::Call(self.arena.alloc(identity_future), arena_vec![self; generator])\n+        hir::Expr { hir_id, kind: generator_kind, span: self.lower_span(span) }\n     }\n \n     /// Desugar `<expr>.await` into:\n@@ -1002,7 +992,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n \n             // Transform `async |x: u8| -> X { ... }` into\n-            // `|x: u8| identity_future(|| -> X { ... })`.\n+            // `|x: u8| || -> X { ... }`.\n             let body_id = this.lower_fn_body(&outer_decl, |this| {\n                 let async_ret_ty = if let FnRetTy::Ty(ty) = &decl.output {\n                     let itctx = ImplTraitContext::Disallowed(ImplTraitPosition::AsyncBlock);\n@@ -1011,16 +1001,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     None\n                 };\n \n-                let async_body = this.make_async_expr(\n+                this.make_async_expr(\n                     capture_clause,\n                     closure_hir_id,\n                     inner_closure_id,\n                     async_ret_ty,\n                     body.span,\n                     hir::AsyncGeneratorKind::Closure,\n                     |this| this.with_new_scopes(|this| this.lower_expr_mut(body)),\n-                );\n-                this.expr(fn_decl_span, async_body)\n+                )\n             });\n             body_id\n         });"}, {"sha": "9a117ac9a3cf7c1fcef0d314859bccbbe5b15225", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1180,7 +1180,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 },\n             );\n \n-            (this.arena.alloc_from_iter(parameters), this.expr(body.span, async_expr))\n+            (this.arena.alloc_from_iter(parameters), async_expr)\n         })\n     }\n "}, {"sha": "ea7fa02521e44f6ed251b9fe812f20641c495ec3", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 28, "deletions": 33, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -92,7 +92,7 @@ mod lifetime_collector;\n mod pat;\n mod path;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n struct LoweringContext<'a, 'hir> {\n     tcx: TyCtxt<'hir>,\n@@ -435,7 +435,9 @@ fn compute_hir_hash(\n \n pub fn lower_to_hir(tcx: TyCtxt<'_>, (): ()) -> hir::Crate<'_> {\n     let sess = tcx.sess;\n-    tcx.ensure().output_filenames(());\n+    // Queries that borrow `resolver_for_lowering`.\n+    tcx.ensure_with_value().output_filenames(());\n+    tcx.ensure_with_value().early_lint_checks(());\n     let (mut resolver, krate) = tcx.resolver_for_lowering(()).steal();\n \n     let ast_index = index_crate(&resolver.node_id_to_def_id, &krate);\n@@ -463,8 +465,10 @@ pub fn lower_to_hir(tcx: TyCtxt<'_>, (): ()) -> hir::Crate<'_> {\n         rustc_span::hygiene::clear_syntax_context_map();\n     }\n \n-    let hir_hash = compute_hir_hash(tcx, &owners);\n-    hir::Crate { owners, hir_hash }\n+    // Don't hash unless necessary, because it's expensive.\n+    let opt_hir_hash =\n+        if tcx.sess.needs_crate_hash() { Some(compute_hir_hash(tcx, &owners)) } else { None };\n+    hir::Crate { owners, opt_hir_hash }\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -657,42 +661,33 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         bodies.sort_by_key(|(k, _)| *k);\n         let bodies = SortedMap::from_presorted_elements(bodies);\n-        let (hash_including_bodies, hash_without_bodies) = self.hash_owner(node, &bodies);\n-        let (nodes, parenting) =\n-            index::index_hir(self.tcx.sess, &*self.tcx.definitions_untracked(), node, &bodies);\n-        let nodes = hir::OwnerNodes { hash_including_bodies, hash_without_bodies, nodes, bodies };\n-        let attrs = {\n-            let hash = self.tcx.with_stable_hashing_context(|mut hcx| {\n+\n+        // Don't hash unless necessary, because it's expensive.\n+        let (opt_hash_including_bodies, attrs_hash) = if self.tcx.sess.needs_crate_hash() {\n+            self.tcx.with_stable_hashing_context(|mut hcx| {\n+                let mut stable_hasher = StableHasher::new();\n+                hcx.with_hir_bodies(node.def_id(), &bodies, |hcx| {\n+                    node.hash_stable(hcx, &mut stable_hasher)\n+                });\n+                let h1 = stable_hasher.finish();\n+\n                 let mut stable_hasher = StableHasher::new();\n                 attrs.hash_stable(&mut hcx, &mut stable_hasher);\n-                stable_hasher.finish()\n-            });\n-            hir::AttributeMap { map: attrs, hash }\n+                let h2 = stable_hasher.finish();\n+\n+                (Some(h1), Some(h2))\n+            })\n+        } else {\n+            (None, None)\n         };\n+        let (nodes, parenting) =\n+            index::index_hir(self.tcx.sess, &*self.tcx.definitions_untracked(), node, &bodies);\n+        let nodes = hir::OwnerNodes { opt_hash_including_bodies, nodes, bodies };\n+        let attrs = hir::AttributeMap { map: attrs, opt_hash: attrs_hash };\n \n         self.arena.alloc(hir::OwnerInfo { nodes, parenting, attrs, trait_map })\n     }\n \n-    /// Hash the HIR node twice, one deep and one shallow hash. This allows to differentiate\n-    /// queries which depend on the full HIR tree and those which only depend on the item signature.\n-    fn hash_owner(\n-        &mut self,\n-        node: hir::OwnerNode<'hir>,\n-        bodies: &SortedMap<hir::ItemLocalId, &'hir hir::Body<'hir>>,\n-    ) -> (Fingerprint, Fingerprint) {\n-        self.tcx.with_stable_hashing_context(|mut hcx| {\n-            let mut stable_hasher = StableHasher::new();\n-            hcx.with_hir_bodies(node.def_id(), bodies, |hcx| {\n-                node.hash_stable(hcx, &mut stable_hasher)\n-            });\n-            let hash_including_bodies = stable_hasher.finish();\n-            let mut stable_hasher = StableHasher::new();\n-            hcx.without_hir_bodies(|hcx| node.hash_stable(hcx, &mut stable_hasher));\n-            let hash_without_bodies = stable_hasher.finish();\n-            (hash_including_bodies, hash_without_bodies)\n-        })\n-    }\n-\n     /// This method allocates a new `HirId` for the given `NodeId` and stores it in\n     /// the `LoweringContext`'s `NodeId => HirId` map.\n     /// Take care not to call this method if the resulting `HirId` is then not"}, {"sha": "747bd52b22c7d6b14fe9ffdb88d5a4bdd4877113", "filename": "compiler/rustc_ast_passes/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast_passes%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast_passes%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_ast_passes/locales/en-US.ftl"}, {"sha": "6a5d5614b1cb91ebd80210cf7dbb9d62e03e4ad6", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -337,9 +337,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::TyKind::Never => {\n                 gate_feature_post!(&self, never_type, ty.span, \"the `!` type is experimental\");\n             }\n-            ast::TyKind::TraitObject(_, ast::TraitObjectSyntax::DynStar, ..) => {\n-                gate_feature_post!(&self, dyn_star, ty.span, \"dyn* trait objects are unstable\");\n-            }\n             _ => {}\n         }\n         visit::walk_ty(self, ty)\n@@ -395,14 +392,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n     fn visit_expr(&mut self, e: &'a ast::Expr) {\n         match e.kind {\n-            ast::ExprKind::Box(_) => {\n-                gate_feature_post!(\n-                    &self,\n-                    box_syntax,\n-                    e.span,\n-                    \"box expression syntax is experimental; you can call `Box::new` instead\"\n-                );\n-            }\n             ast::ExprKind::Type(..) => {\n                 if self.sess.parse_sess.span_diagnostic.err_count() == 0 {\n                     // To avoid noise about type ascription in common syntax errors,\n@@ -425,14 +414,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::ExprKind::TryBlock(_) => {\n                 gate_feature_post!(&self, try_blocks, e.span, \"`try` expression is experimental\");\n             }\n-            ast::ExprKind::Closure(box ast::Closure { constness: ast::Const::Yes(_), .. }) => {\n-                gate_feature_post!(\n-                    &self,\n-                    const_closures,\n-                    e.span,\n-                    \"const closures are experimental\"\n-                );\n-            }\n             _ => {}\n         }\n         visit::walk_expr(self, e)\n@@ -594,6 +575,8 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n     gate_all!(inline_const_pat, \"inline-const in pattern position is experimental\");\n     gate_all!(associated_const_equality, \"associated const equality is incomplete\");\n     gate_all!(yeet_expr, \"`do yeet` expression is experimental\");\n+    gate_all!(dyn_star, \"`dyn*` trait objects are experimental\");\n+    gate_all!(const_closures, \"const closures are experimental\");\n \n     // All uses of `gate_all!` below this point were added in #65742,\n     // and subsequently disabled (with the non-early gating readded).\n@@ -613,7 +596,6 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n     gate_all!(box_patterns, \"box pattern syntax is experimental\");\n     gate_all!(exclusive_range_pattern, \"exclusive range pattern syntax is experimental\");\n     gate_all!(try_blocks, \"`try` blocks are unstable\");\n-    gate_all!(box_syntax, \"box expression syntax is experimental; you can call `Box::new` instead\");\n     gate_all!(type_ascription, \"type ascription is experimental\");\n \n     visit::walk_crate(&mut visitor, krate);"}, {"sha": "e2c666604b3c36058772e8949c25cb7e5b6688ce", "filename": "compiler/rustc_ast_passes/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -21,4 +21,4 @@ pub mod feature_gate;\n pub mod node_count;\n pub mod show_span;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }"}, {"sha": "e2f63641ffa53b74a5b9eea4656b2690f48756d3", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -244,6 +244,10 @@ impl<'a> State<'a> {\n             (&ast::ExprKind::Let { .. }, _) if !parser::needs_par_as_let_scrutinee(prec) => {\n                 parser::PREC_FORCE_PAREN\n             }\n+            // For a binary expression like `(match () { _ => a }) OP b`, the parens are required\n+            // otherwise the parser would interpret `match () { _ => a }` as a statement,\n+            // with the remaining `OP b` not making sense. So we force parens.\n+            (&ast::ExprKind::Match(..), _) => parser::PREC_FORCE_PAREN,\n             _ => left_prec,\n         };\n \n@@ -292,10 +296,6 @@ impl<'a> State<'a> {\n         self.ibox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Expr(expr));\n         match &expr.kind {\n-            ast::ExprKind::Box(expr) => {\n-                self.word_space(\"box\");\n-                self.print_expr_maybe_paren(expr, parser::PREC_PREFIX);\n-            }\n             ast::ExprKind::Array(exprs) => {\n                 self.print_expr_vec(exprs);\n             }"}, {"sha": "a7f8c993d4225316129e515ef4e2a84bbe872137", "filename": "compiler/rustc_attr/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_attr%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_attr%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_attr/locales/en-US.ftl"}, {"sha": "49818c14f275b2284759289072caf2fc95a70c27", "filename": "compiler/rustc_attr/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -26,4 +26,4 @@ pub use rustc_ast::attr::*;\n \n pub(crate) use rustc_ast::HashStableContext;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }"}, {"sha": "a3b6b5e8138b68ed2e84b37abad09be4ef2577ac", "filename": "compiler/rustc_borrowck/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_borrowck%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_borrowck%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_borrowck/locales/en-US.ftl"}, {"sha": "7c88205da3b9a5ca40bb38d7cef3cd65922be174", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1985,16 +1985,18 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let (place_desc, note) = if let Some(place_desc) = opt_place_desc {\n             let local_kind = if let Some(local) = borrow.borrowed_place.as_local() {\n                 match self.body.local_kind(local) {\n-                    LocalKind::ReturnPointer | LocalKind::Temp => {\n-                        bug!(\"temporary or return pointer with a name\")\n+                    LocalKind::Temp if self.body.local_decls[local].is_user_variable() => {\n+                        \"local variable \"\n                     }\n-                    LocalKind::Var => \"local variable \",\n                     LocalKind::Arg\n                         if !self.upvars.is_empty() && local == ty::CAPTURE_STRUCT_LOCAL =>\n                     {\n                         \"variable captured by `move` \"\n                     }\n                     LocalKind::Arg => \"function parameter \",\n+                    LocalKind::ReturnPointer | LocalKind::Temp => {\n+                        bug!(\"temporary or return pointer with a name\")\n+                    }\n                 }\n             } else {\n                 \"local data \"\n@@ -2008,16 +2010,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 self.prefixes(borrow.borrowed_place.as_ref(), PrefixSet::All).last().unwrap();\n             let local = root_place.local;\n             match self.body.local_kind(local) {\n-                LocalKind::ReturnPointer | LocalKind::Temp => {\n-                    (\"temporary value\".to_string(), \"temporary value created here\".to_string())\n-                }\n                 LocalKind::Arg => (\n                     \"function parameter\".to_string(),\n                     \"function parameter borrowed here\".to_string(),\n                 ),\n-                LocalKind::Var => {\n+                LocalKind::Temp if self.body.local_decls[local].is_user_variable() => {\n                     (\"local binding\".to_string(), \"local binding introduced here\".to_string())\n                 }\n+                LocalKind::ReturnPointer | LocalKind::Temp => {\n+                    (\"temporary value\".to_string(), \"temporary value created here\".to_string())\n+                }\n             }\n         };\n \n@@ -2482,15 +2484,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let (place_description, assigned_span) = match local_decl {\n             Some(LocalDecl {\n                 local_info:\n-                    Some(box LocalInfo::User(\n-                        ClearCrossCrate::Clear\n-                        | ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                    ClearCrossCrate::Set(\n+                        box LocalInfo::User(BindingForm::Var(VarBindingForm {\n                             opt_match_place: None,\n                             ..\n-                        })),\n-                    ))\n-                    | Some(box LocalInfo::StaticRef { .. })\n-                    | None,\n+                        }))\n+                        | box LocalInfo::StaticRef { .. }\n+                        | box LocalInfo::Boring,\n+                    ),\n                 ..\n             })\n             | None => (self.describe_any_place(place.as_ref()), assigned_span),"}, {"sha": "62b3f3ecfc32f21cbee976fac14a6e5eedd71fb4", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -6,8 +6,8 @@ use rustc_hir::intravisit::Visitor;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::mir::{\n-    Body, CastKind, ConstraintCategory, FakeReadCause, Local, Location, Operand, Place, Rvalue,\n-    Statement, StatementKind, TerminatorKind,\n+    Body, CastKind, ConstraintCategory, FakeReadCause, Local, LocalInfo, Location, Operand, Place,\n+    Rvalue, Statement, StatementKind, TerminatorKind,\n };\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::{self, RegionVid, TyCtxt};\n@@ -220,7 +220,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                         );\n                         err.span_label(body.source_info(drop_loc).span, message);\n \n-                        if let Some(info) = &local_decl.is_block_tail {\n+                        if let LocalInfo::BlockTailTemp(info) = local_decl.local_info() {\n                             if info.tail_result_is_ignored {\n                                 // #85581: If the first mutable borrow's scope contains\n                                 // the second borrow, this suggestion isn't helpful."}, {"sha": "611abb01238b80ecab7e9c74c81ead0b2a053e62", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -196,10 +196,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         if self.body.local_decls[local].is_ref_for_guard() {\n                             continue;\n                         }\n-                        if let Some(box LocalInfo::StaticRef { def_id, .. }) =\n-                            &self.body.local_decls[local].local_info\n+                        if let LocalInfo::StaticRef { def_id, .. } =\n+                            *self.body.local_decls[local].local_info()\n                         {\n-                            buf.push_str(self.infcx.tcx.item_name(*def_id).as_str());\n+                            buf.push_str(self.infcx.tcx.item_name(def_id).as_str());\n                             ok = Ok(());\n                             continue;\n                         }"}, {"sha": "3662bec0c76360cc9be71fb33f5f0e34f4c4d97c", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -102,14 +102,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         //\n                         // opt_match_place is None for let [mut] x = ... statements,\n                         // whether or not the right-hand side is a place expression\n-                        if let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n-                            VarBindingForm {\n-                                opt_match_place: Some((opt_match_place, match_span)),\n-                                binding_mode: _,\n-                                opt_ty_info: _,\n-                                pat_span: _,\n-                            },\n-                        )))) = local_decl.local_info\n+                        if let LocalInfo::User(BindingForm::Var(VarBindingForm {\n+                            opt_match_place: Some((opt_match_place, match_span)),\n+                            binding_mode: _,\n+                            opt_ty_info: _,\n+                            pat_span: _,\n+                        })) = *local_decl.local_info()\n                         {\n                             let stmt_source_info = self.body.source_info(location);\n                             self.append_binding_error(\n@@ -478,9 +476,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let mut suggestions: Vec<(Span, String, String)> = Vec::new();\n         for local in binds_to {\n             let bind_to = &self.body.local_decls[*local];\n-            if let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n-                VarBindingForm { pat_span, .. },\n-            )))) = bind_to.local_info\n+            if let LocalInfo::User(BindingForm::Var(VarBindingForm { pat_span, .. })) =\n+                *bind_to.local_info()\n             {\n                 let Ok(pat_snippet) =\n                     self.infcx.tcx.sess.source_map().span_to_snippet(pat_span) else { continue; };"}, {"sha": "bad08451adf08cc9abb0d0beed37446a21d83636", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 38, "deletions": 54, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -7,7 +7,7 @@ use rustc_middle::mir::{Mutability, Place, PlaceRef, ProjectionElem};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::{\n     hir::place::PlaceBase,\n-    mir::{self, BindingForm, ClearCrossCrate, Local, LocalDecl, LocalInfo, LocalKind, Location},\n+    mir::{self, BindingForm, Local, LocalDecl, LocalInfo, LocalKind, Location},\n };\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, Symbol};\n@@ -105,8 +105,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     reason = String::new();\n                 } else {\n                     item_msg = access_place_desc;\n-                    let local_info = &self.body.local_decls[local].local_info;\n-                    if let Some(box LocalInfo::StaticRef { def_id, .. }) = *local_info {\n+                    let local_info = self.body.local_decls[local].local_info();\n+                    if let LocalInfo::StaticRef { def_id, .. } = *local_info {\n                         let static_name = &self.infcx.tcx.item_name(def_id);\n                         reason = format!(\", as `{static_name}` is an immutable static item\");\n                     } else {\n@@ -305,15 +305,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     ..\n                 }) = &self.body[location.block].statements.get(location.statement_index)\n                 {\n-                    match decl.local_info {\n-                        Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n-                            mir::VarBindingForm {\n-                                binding_mode: ty::BindingMode::BindByValue(Mutability::Not),\n-                                opt_ty_info: Some(sp),\n-                                opt_match_place: _,\n-                                pat_span: _,\n-                            },\n-                        )))) => {\n+                    match *decl.local_info() {\n+                        LocalInfo::User(BindingForm::Var(mir::VarBindingForm {\n+                            binding_mode: ty::BindingMode::BindByValue(Mutability::Not),\n+                            opt_ty_info: Some(sp),\n+                            opt_match_place: _,\n+                            pat_span: _,\n+                        })) => {\n                             if suggest {\n                                 err.span_note(sp, \"the binding is already a mutable borrow\");\n                             }\n@@ -346,10 +344,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     }\n                 } else if decl.mutability.is_not() {\n                     if matches!(\n-                        decl.local_info,\n-                        Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::ImplicitSelf(\n-                            hir::ImplicitSelfKind::MutRef\n-                        ),)))\n+                        decl.local_info(),\n+                        LocalInfo::User(BindingForm::ImplicitSelf(hir::ImplicitSelfKind::MutRef))\n                     ) {\n                         err.note(\n                             \"as `Self` may be unsized, this call attempts to take `&mut &mut self`\",\n@@ -482,22 +478,18 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 match self.local_names[local] {\n                     Some(name) if !local_decl.from_compiler_desugaring() => {\n-                        let label = match local_decl.local_info.as_deref().unwrap() {\n-                            LocalInfo::User(ClearCrossCrate::Set(\n-                                mir::BindingForm::ImplicitSelf(_),\n-                            )) => {\n+                        let label = match *local_decl.local_info() {\n+                            LocalInfo::User(mir::BindingForm::ImplicitSelf(_)) => {\n                                 let (span, suggestion) =\n                                     suggest_ampmut_self(self.infcx.tcx, local_decl);\n                                 Some((true, span, suggestion))\n                             }\n \n-                            LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n-                                mir::VarBindingForm {\n-                                    binding_mode: ty::BindingMode::BindByValue(_),\n-                                    opt_ty_info,\n-                                    ..\n-                                },\n-                            ))) => {\n+                            LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n+                                binding_mode: ty::BindingMode::BindByValue(_),\n+                                opt_ty_info,\n+                                ..\n+                            })) => {\n                                 // check if the RHS is from desugaring\n                                 let opt_assignment_rhs_span =\n                                     self.body.find_assignments(local).first().map(|&location| {\n@@ -534,16 +526,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                                 self.infcx.tcx,\n                                                 local_decl,\n                                                 opt_assignment_rhs_span,\n-                                                *opt_ty_info,\n+                                                opt_ty_info,\n                                             )\n                                         } else {\n-                                            match local_decl.local_info.as_deref() {\n-                                                Some(LocalInfo::User(ClearCrossCrate::Set(\n-                                                    mir::BindingForm::Var(mir::VarBindingForm {\n-                                                        opt_ty_info: None,\n-                                                        ..\n-                                                    }),\n-                                                ))) => {\n+                                            match local_decl.local_info() {\n+                                                LocalInfo::User(mir::BindingForm::Var(\n+                                                    mir::VarBindingForm {\n+                                                        opt_ty_info: None, ..\n+                                                    },\n+                                                )) => {\n                                                     let (span, sugg) = suggest_ampmut_self(\n                                                         self.infcx.tcx,\n                                                         local_decl,\n@@ -555,7 +546,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                                     self.infcx.tcx,\n                                                     local_decl,\n                                                     opt_assignment_rhs_span,\n-                                                    *opt_ty_info,\n+                                                    opt_ty_info,\n                                                 ),\n                                             }\n                                         };\n@@ -564,21 +555,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                 }\n                             }\n \n-                            LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n-                                mir::VarBindingForm {\n-                                    binding_mode: ty::BindingMode::BindByReference(_),\n-                                    ..\n-                                },\n-                            ))) => {\n+                            LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n+                                binding_mode: ty::BindingMode::BindByReference(_),\n+                                ..\n+                            })) => {\n                                 let pattern_span = local_decl.source_info.span;\n                                 suggest_ref_mut(self.infcx.tcx, pattern_span)\n                                     .map(|replacement| (true, pattern_span, replacement))\n                             }\n \n-                            LocalInfo::User(ClearCrossCrate::Clear) => {\n-                                bug!(\"saw cleared local state\")\n-                            }\n-\n                             _ => unreachable!(),\n                         };\n \n@@ -1151,20 +1136,19 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n pub fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<Symbol>) -> bool {\n     debug!(\"local_info: {:?}, ty.kind(): {:?}\", local_decl.local_info, local_decl.ty.kind());\n \n-    match local_decl.local_info.as_deref() {\n+    match *local_decl.local_info() {\n         // Check if mutably borrowing a mutable reference.\n-        Some(LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n-            mir::VarBindingForm {\n-                binding_mode: ty::BindingMode::BindByValue(Mutability::Not), ..\n-            },\n-        )))) => matches!(local_decl.ty.kind(), ty::Ref(_, _, hir::Mutability::Mut)),\n-        Some(LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf(kind)))) => {\n+        LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n+            binding_mode: ty::BindingMode::BindByValue(Mutability::Not),\n+            ..\n+        })) => matches!(local_decl.ty.kind(), ty::Ref(_, _, hir::Mutability::Mut)),\n+        LocalInfo::User(mir::BindingForm::ImplicitSelf(kind)) => {\n             // Check if the user variable is a `&mut self` and we can therefore\n             // suggest removing the `&mut`.\n             //\n             // Deliberately fall into this case for all implicit self types,\n             // so that we don't fall in to the next case with them.\n-            *kind == hir::ImplicitSelfKind::MutRef\n+            kind == hir::ImplicitSelfKind::MutRef\n         }\n         _ if Some(kw::SelfLower) == local_name => {\n             // Otherwise, check if the name is the `self` keyword - in which case"}, {"sha": "5e77f6b190a69d0d2b762febc958587dd57a9bcf", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -100,7 +100,7 @@ use places_conflict::{places_conflict, PlaceConflictBias};\n use region_infer::RegionInferenceContext;\n use renumber::RegionCtxt;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n // FIXME(eddyb) perhaps move this somewhere more centrally.\n #[derive(Debug)]"}, {"sha": "748c8b9e4420ca389123bd3a706a7582685427b3", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -325,7 +325,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         if errors.is_empty() {\n             definition_ty\n         } else {\n-            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors);\n             self.tcx.ty_error(reported)\n         }\n     }"}, {"sha": "53fef4d75bf67a4f2dc3dadd9813d220db1eb223", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1180,10 +1180,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         }\n                     }\n                     Some(l)\n-                        if matches!(\n-                            body.local_decls[l].local_info,\n-                            Some(box LocalInfo::AggregateTemp)\n-                        ) =>\n+                        if matches!(body.local_decls[l].local_info(), LocalInfo::AggregateTemp) =>\n                     {\n                         ConstraintCategory::Usage\n                     }\n@@ -1684,7 +1681,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // - maybe we should make that a warning.\n                 return;\n             }\n-            LocalKind::Var | LocalKind::Temp => {}\n+            LocalKind::Temp => {}\n         }\n \n         // When `unsized_fn_params` or `unsized_locals` is enabled, only function calls"}, {"sha": "4d088e27b364ae36762db7512961333e7a34849f", "filename": "compiler/rustc_builtin_macros/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_builtin_macros/locales/en-US.ftl"}, {"sha": "8c1579baacb08775c9126449c1dd7274d9a2e6d3", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 4, "deletions": 31, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -203,17 +203,6 @@ pub fn parse_asm_args<'a>(\n         // Validate the order of named, positional & explicit register operands and\n         // clobber_abi/options. We do this at the end once we have the full span\n         // of the argument available.\n-        if !args.options_spans.is_empty() {\n-            diag.struct_span_err(span, \"arguments are not allowed after options\")\n-                .span_labels(args.options_spans.clone(), \"previous options\")\n-                .span_label(span, \"argument\")\n-                .emit();\n-        } else if let Some((_, abi_span)) = args.clobber_abis.last() {\n-            diag.struct_span_err(span, \"arguments are not allowed after clobber_abi\")\n-                .span_label(*abi_span, \"clobber_abi\")\n-                .span_label(span, \"argument\")\n-                .emit();\n-        }\n         if explicit_reg {\n             if name.is_some() {\n                 diag.struct_span_err(span, \"explicit register arguments cannot have names\").emit();\n@@ -227,17 +216,6 @@ pub fn parse_asm_args<'a>(\n                     .emit();\n                 continue;\n             }\n-            if !args.reg_args.is_empty() {\n-                let mut err = diag.struct_span_err(\n-                    span,\n-                    \"named arguments cannot follow explicit register arguments\",\n-                );\n-                err.span_label(span, \"named argument\");\n-                for pos in &args.reg_args {\n-                    err.span_label(args.operands[*pos].1, \"explicit register argument\");\n-                }\n-                err.emit();\n-            }\n             args.named_args.insert(name, slot);\n         } else {\n             if !args.named_args.is_empty() || !args.reg_args.is_empty() {\n@@ -478,15 +456,6 @@ fn parse_clobber_abi<'a>(p: &mut Parser<'a>, args: &mut AsmArgs) -> PResult<'a,\n \n     let full_span = span_start.to(p.prev_token.span);\n \n-    if !args.options_spans.is_empty() {\n-        let mut err = p\n-            .sess\n-            .span_diagnostic\n-            .struct_span_err(full_span, \"clobber_abi is not allowed after options\");\n-        err.span_labels(args.options_spans.clone(), \"options\");\n-        return Err(err);\n-    }\n-\n     match &new_abis[..] {\n         // should have errored above during parsing\n         [] => unreachable!(),\n@@ -699,6 +668,10 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n                                         args.operands[idx].1,\n                                         \"explicit register arguments cannot be used in the asm template\",\n                                     );\n+                                    err.span_help(\n+                                        args.operands[idx].1,\n+                                        \"use the register name directly in the assembly code\",\n+                                    );\n                                 }\n                                 err.emit();\n                                 None"}, {"sha": "5d8f4db76f9b17ef7f780f8e5efc7d5c7052a481", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -290,7 +290,6 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             | ExprKind::Async(_, _, _)\n             | ExprKind::Await(_)\n             | ExprKind::Block(_, _)\n-            | ExprKind::Box(_)\n             | ExprKind::Break(_, _)\n             | ExprKind::Closure(_)\n             | ExprKind::ConstBlock(_)"}, {"sha": "36682bbe0708f88babcb29aee81c064ce452f7c3", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -42,6 +42,18 @@ pub fn expand_concat(\n                     has_errors = true;\n                 }\n             },\n+            // We also want to allow negative numeric literals.\n+            ast::ExprKind::Unary(ast::UnOp::Neg, ref expr) if let ast::ExprKind::Lit(token_lit) = expr.kind => {\n+                match ast::LitKind::from_token_lit(token_lit) {\n+                    Ok(ast::LitKind::Int(i, _)) => accumulator.push_str(&format!(\"-{i}\")),\n+                    Ok(ast::LitKind::Float(f, _)) => accumulator.push_str(&format!(\"-{f}\")),\n+                    Err(err) => {\n+                        report_lit_error(&cx.sess.parse_sess, err, token_lit, e.span);\n+                        has_errors = true;\n+                    }\n+                    _ => missing_literal.push(e.span),\n+                }\n+            }\n             ast::ExprKind::IncludedBytes(..) => {\n                 cx.span_err(e.span, \"cannot concatenate a byte string literal\")\n             }\n@@ -53,9 +65,10 @@ pub fn expand_concat(\n             }\n         }\n     }\n+\n     if !missing_literal.is_empty() {\n         let mut err = cx.struct_span_err(missing_literal, \"expected a literal\");\n-        err.note(\"only literals (like `\\\"foo\\\"`, `42` and `3.14`) can be passed to `concat!()`\");\n+        err.note(\"only literals (like `\\\"foo\\\"`, `-42` and `3.14`) can be passed to `concat!()`\");\n         err.emit();\n         return DummyResult::any(sp);\n     } else if has_errors {"}, {"sha": "6b3053fdfac7e81ca8f5efc57cf9b9f61b5aef7a", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1052,6 +1052,7 @@ impl<'a> MethodDef<'a> {\n     ///         ::core::hash::Hash::hash(&{ self.y }, state)\n     ///     }\n     /// }\n+    /// ```\n     fn expand_struct_method_body<'b>(\n         &self,\n         cx: &mut ExtCtxt<'_>,"}, {"sha": "db2ef7fba4b8ea2baeec25f3d04103d4eeee14af", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 44, "deletions": 35, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -36,6 +36,21 @@ enum PositionUsedAs {\n }\n use PositionUsedAs::*;\n \n+struct MacroInput {\n+    fmtstr: P<Expr>,\n+    args: FormatArguments,\n+    /// Whether the first argument was a string literal or a result from eager macro expansion.\n+    /// If it's not a string literal, we disallow implicit arugment capturing.\n+    ///\n+    /// This does not correspond to whether we can treat spans to the literal normally, as the whole\n+    /// invocation might be the result of another macro expansion, in which case this flag may still be true.\n+    ///\n+    /// See [RFC 2795] for more information.\n+    ///\n+    /// [RFC 2795]: https://rust-lang.github.io/rfcs/2795-format-args-implicit-identifiers.html#macro-hygiene\n+    is_direct_literal: bool,\n+}\n+\n /// Parses the arguments from the given list of tokens, returning the diagnostic\n /// if there's a parse error so we can continue parsing other format!\n /// expressions.\n@@ -45,11 +60,7 @@ use PositionUsedAs::*;\n /// ```text\n /// Ok((fmtstr, parsed arguments))\n /// ```\n-fn parse_args<'a>(\n-    ecx: &mut ExtCtxt<'a>,\n-    sp: Span,\n-    tts: TokenStream,\n-) -> PResult<'a, (P<Expr>, FormatArguments)> {\n+fn parse_args<'a>(ecx: &mut ExtCtxt<'a>, sp: Span, tts: TokenStream) -> PResult<'a, MacroInput> {\n     let mut args = FormatArguments::new();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n@@ -59,25 +70,21 @@ fn parse_args<'a>(\n     }\n \n     let first_token = &p.token;\n-    let fmtstr = match first_token.kind {\n-        token::TokenKind::Literal(token::Lit {\n-            kind: token::LitKind::Str | token::LitKind::StrRaw(_),\n-            ..\n-        }) => {\n-            // If the first token is a string literal, then a format expression\n-            // is constructed from it.\n-            //\n-            // This allows us to properly handle cases when the first comma\n-            // after the format string is mistakenly replaced with any operator,\n-            // which cause the expression parser to eat too much tokens.\n-            p.parse_literal_maybe_minus()?\n-        }\n-        _ => {\n-            // Otherwise, we fall back to the expression parser.\n-            p.parse_expr()?\n-        }\n+\n+    let fmtstr = if let token::Literal(lit) = first_token.kind && matches!(lit.kind, token::Str | token::StrRaw(_)) {\n+        // This allows us to properly handle cases when the first comma\n+        // after the format string is mistakenly replaced with any operator,\n+        // which cause the expression parser to eat too much tokens.\n+        p.parse_literal_maybe_minus()?\n+    } else {\n+        // Otherwise, we fall back to the expression parser.\n+        p.parse_expr()?\n     };\n \n+    // Only allow implicit captures to be used when the argument is a direct literal\n+    // instead of a macro expanding to one.\n+    let is_direct_literal = matches!(fmtstr.kind, ExprKind::Lit(_));\n+\n     let mut first = true;\n \n     while p.token != token::Eof {\n@@ -147,17 +154,19 @@ fn parse_args<'a>(\n             }\n         }\n     }\n-    Ok((fmtstr, args))\n+    Ok(MacroInput { fmtstr, args, is_direct_literal })\n }\n \n-pub fn make_format_args(\n+fn make_format_args(\n     ecx: &mut ExtCtxt<'_>,\n-    efmt: P<Expr>,\n-    mut args: FormatArguments,\n+    input: MacroInput,\n     append_newline: bool,\n ) -> Result<FormatArgs, ()> {\n     let msg = \"format argument must be a string literal\";\n-    let unexpanded_fmt_span = efmt.span;\n+    let unexpanded_fmt_span = input.fmtstr.span;\n+\n+    let MacroInput { fmtstr: efmt, mut args, is_direct_literal } = input;\n+\n     let (fmt_str, fmt_style, fmt_span) = match expr_to_spanned_string(ecx, efmt, msg) {\n         Ok(mut fmt) if append_newline => {\n             fmt.0 = Symbol::intern(&format!(\"{}\\n\", fmt.0));\n@@ -208,11 +217,11 @@ pub fn make_format_args(\n         }\n     }\n \n-    let is_literal = parser.is_literal;\n+    let is_source_literal = parser.is_source_literal;\n \n     if !parser.errors.is_empty() {\n         let err = parser.errors.remove(0);\n-        let sp = if is_literal {\n+        let sp = if is_source_literal {\n             fmt_span.from_inner(InnerSpan::new(err.span.start, err.span.end))\n         } else {\n             // The format string could be another macro invocation, e.g.:\n@@ -230,7 +239,7 @@ pub fn make_format_args(\n         if let Some(note) = err.note {\n             e.note(&note);\n         }\n-        if let Some((label, span)) = err.secondary_label && is_literal {\n+        if let Some((label, span)) = err.secondary_label && is_source_literal {\n             e.span_label(fmt_span.from_inner(InnerSpan::new(span.start, span.end)), label);\n         }\n         if err.should_be_replaced_with_positional_argument {\n@@ -256,7 +265,7 @@ pub fn make_format_args(\n     }\n \n     let to_span = |inner_span: rustc_parse_format::InnerSpan| {\n-        is_literal.then(|| {\n+        is_source_literal.then(|| {\n             fmt_span.from_inner(InnerSpan { start: inner_span.start, end: inner_span.end })\n         })\n     };\n@@ -304,7 +313,7 @@ pub fn make_format_args(\n                     // Name not found in `args`, so we add it as an implicitly captured argument.\n                     let span = span.unwrap_or(fmt_span);\n                     let ident = Ident::new(name, span);\n-                    let expr = if is_literal {\n+                    let expr = if is_direct_literal {\n                         ecx.expr_ident(span, ident)\n                     } else {\n                         // For the moment capturing variables from format strings expanded from macros is\n@@ -814,7 +823,7 @@ fn report_invalid_references(\n         // for `println!(\"{7:7$}\", 1);`\n         indexes.sort();\n         indexes.dedup();\n-        let span: MultiSpan = if !parser.is_literal || parser.arg_places.is_empty() {\n+        let span: MultiSpan = if !parser.is_source_literal || parser.arg_places.is_empty() {\n             MultiSpan::from_span(fmt_span)\n         } else {\n             MultiSpan::from_spans(invalid_refs.iter().filter_map(|&(_, span, _, _)| span).collect())\n@@ -855,8 +864,8 @@ fn expand_format_args_impl<'cx>(\n ) -> Box<dyn base::MacResult + 'cx> {\n     sp = ecx.with_def_site_ctxt(sp);\n     match parse_args(ecx, sp, tts) {\n-        Ok((efmt, args)) => {\n-            if let Ok(format_args) = make_format_args(ecx, efmt, args, nl) {\n+        Ok(input) => {\n+            if let Ok(format_args) = make_format_args(ecx, input, nl) {\n                 MacEager::expr(ecx.expr(sp, ExprKind::FormatArgs(P(format_args))))\n             } else {\n                 MacEager::expr(DummyResult::raw_expr(sp, true))"}, {"sha": "71177b8789baf2fea89080cbc8f1f9428dd9ac0a", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -56,7 +56,7 @@ pub mod proc_macro_harness;\n pub mod standard_library_imports;\n pub mod test_harness;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n     let mut register = |name, kind| resolver.register_builtin_macro(name, kind);"}, {"sha": "4ede2fe4efe82777918ed7cebcefbfe13137872d", "filename": "compiler/rustc_codegen_cranelift/example/alloc_example.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,4 +1,4 @@\n-#![feature(start, core_intrinsics, alloc_error_handler, box_syntax)]\n+#![feature(start, core_intrinsics, alloc_error_handler)]\n #![no_std]\n \n extern crate alloc;\n@@ -29,7 +29,7 @@ fn alloc_error_handler(_: alloc::alloc::Layout) -> ! {\n \n #[start]\n fn main(_argc: isize, _argv: *const *const u8) -> isize {\n-    let world: Box<&str> = box \"Hello World!\\0\";\n+    let world: Box<&str> = Box::new(\"Hello World!\\0\");\n     unsafe {\n         puts(*world as *const str as *const u8);\n     }"}, {"sha": "e64daf96b01c92f26dac3a49d21adc43dc6d8975", "filename": "compiler/rustc_codegen_cranelift/example/alloc_system.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,12 +1,6 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n+// SPDX-License-Identifier: MIT OR Apache-2.0\n+// SPDX-FileCopyrightText: The Rust Project Developers (see https://thanks.rust-lang.org)\n+\n #![no_std]\n \n pub struct System;"}, {"sha": "04e7795bbfa160845b0d61ea47bcde22ac021822", "filename": "compiler/rustc_codegen_cranelift/example/mini_core_hello_world.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,4 +1,4 @@\n-#![feature(no_core, lang_items, never_type, linkage, extern_types, thread_local, box_syntax)]\n+#![feature(no_core, lang_items, never_type, linkage, extern_types, thread_local)]\n #![no_core]\n #![allow(dead_code, non_camel_case_types)]\n \n@@ -178,7 +178,7 @@ fn main() {\n         let ptr: *const i8 = hello as *const [u8] as *const i8;\n         puts(ptr);\n \n-        let world: Box<&str> = box \"World!\\0\";\n+        let world: Box<&str> = Box::new(\"World!\\0\");\n         puts(*world as *const str as *const i8);\n         world as Box<dyn SomeTrait>;\n \n@@ -238,10 +238,10 @@ fn main() {\n         }\n     }\n \n-    let _ = box NoisyDrop {\n+    let _ = Box::new(NoisyDrop {\n         text: \"Boxed outer got dropped!\\0\",\n         inner: NoisyDropInner,\n-    } as Box<dyn SomeTrait>;\n+    }) as Box<dyn SomeTrait>;\n \n     const FUNC_REF: Option<fn()> = Some(main);\n     match FUNC_REF {"}, {"sha": "2c246ceb37d54fa43940774b79a359f39c346da3", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -4,6 +4,7 @@\n use crate::prelude::*;\n \n use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n+use rustc_codegen_ssa::base::allocator_kind_for_codegen;\n use rustc_session::config::OomStrategy;\n use rustc_span::symbol::sym;\n \n@@ -13,24 +14,15 @@ pub(crate) fn codegen(\n     module: &mut impl Module,\n     unwind_context: &mut UnwindContext,\n ) -> bool {\n-    let any_dynamic_crate = tcx.dependency_formats(()).iter().any(|(_, list)| {\n-        use rustc_middle::middle::dependency_format::Linkage;\n-        list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n-    });\n-    if any_dynamic_crate {\n-        false\n-    } else if let Some(kind) = tcx.allocator_kind(()) {\n-        codegen_inner(\n-            module,\n-            unwind_context,\n-            kind,\n-            tcx.alloc_error_handler_kind(()).unwrap(),\n-            tcx.sess.opts.unstable_opts.oom,\n-        );\n-        true\n-    } else {\n-        false\n-    }\n+    let Some(kind) = allocator_kind_for_codegen(tcx) else { return false };\n+    codegen_inner(\n+        module,\n+        unwind_context,\n+        kind,\n+        tcx.alloc_error_handler_kind(()).unwrap(),\n+        tcx.sess.opts.unstable_opts.oom,\n+    );\n+    true\n }\n \n fn codegen_inner("}, {"sha": "754e7931412daa8fe46632a74b3a27b13e2a639b", "filename": "compiler/rustc_codegen_gcc/example/alloc_example.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_example.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,4 +1,4 @@\n-#![feature(start, box_syntax, core_intrinsics, alloc_error_handler, lang_items)]\n+#![feature(start, core_intrinsics, alloc_error_handler, lang_items)]\n #![no_std]\n \n extern crate alloc;\n@@ -38,7 +38,7 @@ unsafe extern \"C\" fn _Unwind_Resume() {\n \n #[start]\n fn main(_argc: isize, _argv: *const *const u8) -> isize {\n-    let world: Box<&str> = box \"Hello World!\\0\";\n+    let world: Box<&str> = Box::new(\"Hello World!\\0\");\n     unsafe {\n         puts(*world as *const str as *const u8);\n     }"}, {"sha": "9ec18da90d819986856eb55ab47394ce6335195c", "filename": "compiler/rustc_codegen_gcc/example/alloc_system.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,12 +1,6 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n+// SPDX-License-Identifier: MIT OR Apache-2.0\n+// SPDX-FileCopyrightText: The Rust Project Developers (see https://thanks.rust-lang.org)\n+\n #![no_std]\n #![feature(allocator_api, rustc_private)]\n #![cfg_attr(any(unix, target_os = \"redox\"), feature(libc))]"}, {"sha": "cff26077740b03c0896b85440376d8c2b3a52623", "filename": "compiler/rustc_codegen_gcc/example/mini_core_hello_world.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core_hello_world.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,7 +1,7 @@\n // Adapted from https://github.com/sunfishcode/mir2cranelift/blob/master/rust-examples/nocore-hello-world.rs\n \n #![feature(\n-    no_core, unboxed_closures, start, lang_items, box_syntax, never_type, linkage,\n+    no_core, unboxed_closures, start, lang_items, never_type, linkage,\n     extern_types, thread_local\n )]\n #![no_core]\n@@ -163,7 +163,7 @@ fn main() {\n         let ptr: *const u8 = hello as *const [u8] as *const u8;\n         puts(ptr);\n \n-        let world: Box<&str> = box \"World!\\0\";\n+        let world: Box<&str> = Box::new(\"World!\\0\");\n         puts(*world as *const str as *const u8);\n         world as Box<dyn SomeTrait>;\n \n@@ -223,10 +223,10 @@ fn main() {\n         }\n     }\n \n-    let _ = box NoisyDrop {\n+    let _ = Box::new(NoisyDrop {\n         text: \"Boxed outer got dropped!\\0\",\n         inner: NoisyDropInner,\n-    } as Box<dyn SomeTrait>;\n+    }) as Box<dyn SomeTrait>;\n \n     const FUNC_REF: Option<fn()> = Some(main);\n     #[allow(unreachable_code)]"}, {"sha": "5e2e7f25a2c084974d2e36e0a6a01bd1a5ccde48", "filename": "compiler/rustc_codegen_gcc/example/mod_bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_gcc%2Fexample%2Fmod_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_gcc%2Fexample%2Fmod_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fmod_bench.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,4 +1,4 @@\n-#![feature(start, box_syntax, core_intrinsics, lang_items)]\n+#![feature(start, core_intrinsics, lang_items)]\n #![no_std]\n \n #[link(name = \"c\")]"}, {"sha": "0a94a08f8dca86fec574ab0833925d5f9b0df2e0", "filename": "compiler/rustc_codegen_gcc/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_gcc%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_gcc%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_codegen_gcc/locales/en-US.ftl"}, {"sha": "0b661505acc00c0c415f00793f63f1f24576648d", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -87,7 +87,7 @@ use rustc_span::Symbol;\n use rustc_span::fatal_error::FatalError;\n use tempfile::TempDir;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n pub struct PrintOnPanic<F: Fn() -> String>(pub F);\n "}, {"sha": "e5df417370bb9030abf8ad18fe765b4bc0f265fc", "filename": "compiler/rustc_codegen_llvm/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_llvm%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_llvm%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_codegen_llvm/locales/en-US.ftl"}, {"sha": "978141917c6b0cac9882ab22b0d0445084de4fd8", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/native.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -438,6 +438,7 @@ fn build_enum_variant_member_di_node<'ll, 'tcx>(\n ///         DW_TAG_structure_type            (type of variant 1)\n ///         DW_TAG_structure_type            (type of variant 2)\n ///         DW_TAG_structure_type            (type of variant 3)\n+/// ```\n struct VariantMemberInfo<'a, 'll> {\n     variant_index: VariantIdx,\n     variant_name: Cow<'a, str>,"}, {"sha": "8dafe1b750b33acd8bcdd136e42f51a8358ba2de", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -84,7 +84,7 @@ mod type_of;\n mod va_arg;\n mod value;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n #[derive(Clone)]\n pub struct LlvmCodegenBackend(());"}, {"sha": "8fe5f8d50abe2aa9696ccb519f2c4e7b7b3079db", "filename": "compiler/rustc_codegen_ssa/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_ssa%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_ssa%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_codegen_ssa/locales/en-US.ftl"}, {"sha": "23e2b272410e6b99b950ff52a675adb2b642db92", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -720,6 +720,7 @@ impl<'a> Linker for GccLinker<'a> {\n                 let mut arg = OsString::from(\"--version-script=\");\n                 arg.push(path);\n                 self.linker_arg(arg);\n+                self.linker_arg(\"--no-undefined-version\");\n             }\n         }\n     }"}, {"sha": "7b58e55dbe84a8f24af945bb5089a66dbd6ae5e6", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,3 +1,5 @@\n+use crate::base::allocator_kind_for_codegen;\n+\n use std::collections::hash_map::Entry::*;\n \n use rustc_ast::expand::allocator::ALLOCATOR_METHODS;\n@@ -200,7 +202,8 @@ fn exported_symbols_provider_local(\n         ));\n     }\n \n-    if tcx.allocator_kind(()).is_some() {\n+    // Mark allocator shim symbols as exported only if they were generated.\n+    if allocator_kind_for_codegen(tcx).is_some() {\n         for symbol_name in ALLOCATOR_METHODS\n             .iter()\n             .map(|method| format!(\"__rust_{}\", method.name))"}, {"sha": "abc510e360d56657d4c1b5c09f21579b1286fa5f", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -13,6 +13,7 @@ use crate::mir::place::PlaceRef;\n use crate::traits::*;\n use crate::{CachedModuleCodegen, CompiledModule, CrateInfo, MemFlags, ModuleCodegen, ModuleKind};\n \n+use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n@@ -545,6 +546,23 @@ pub fn collect_debugger_visualizers_transitive(\n         .collect::<BTreeSet<_>>()\n }\n \n+/// Decide allocator kind to codegen. If `Some(_)` this will be the same as\n+/// `tcx.allocator_kind`, but it may be `None` in more cases (e.g. if using\n+/// allocator definitions from a dylib dependency).\n+pub fn allocator_kind_for_codegen(tcx: TyCtxt<'_>) -> Option<AllocatorKind> {\n+    // If the crate doesn't have an `allocator_kind` set then there's definitely\n+    // no shim to generate. Otherwise we also check our dependency graph for all\n+    // our output crate types. If anything there looks like its a `Dynamic`\n+    // linkage, then it's already got an allocator shim and we'll be using that\n+    // one instead. If nothing exists then it's our job to generate the\n+    // allocator!\n+    let any_dynamic_crate = tcx.dependency_formats(()).iter().any(|(_, list)| {\n+        use rustc_middle::middle::dependency_format::Linkage;\n+        list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n+    });\n+    if any_dynamic_crate { None } else { tcx.allocator_kind(()) }\n+}\n+\n pub fn codegen_crate<B: ExtraBackendMethods>(\n     backend: B,\n     tcx: TyCtxt<'_>,\n@@ -615,20 +633,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     );\n \n     // Codegen an allocator shim, if necessary.\n-    //\n-    // If the crate doesn't have an `allocator_kind` set then there's definitely\n-    // no shim to generate. Otherwise we also check our dependency graph for all\n-    // our output crate types. If anything there looks like its a `Dynamic`\n-    // linkage, then it's already got an allocator shim and we'll be using that\n-    // one instead. If nothing exists then it's our job to generate the\n-    // allocator!\n-    let any_dynamic_crate = tcx.dependency_formats(()).iter().any(|(_, list)| {\n-        use rustc_middle::middle::dependency_format::Linkage;\n-        list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n-    });\n-    let allocator_module = if any_dynamic_crate {\n-        None\n-    } else if let Some(kind) = tcx.allocator_kind(()) {\n+    if let Some(kind) = allocator_kind_for_codegen(tcx) {\n         let llmod_id =\n             cgu_name_builder.build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"allocator\")).to_string();\n         let module_llvm = tcx.sess.time(\"write_allocator_module\", || {\n@@ -642,13 +647,10 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n             )\n         });\n \n-        Some(ModuleCodegen { name: llmod_id, module_llvm, kind: ModuleKind::Allocator })\n-    } else {\n-        None\n-    };\n-\n-    if let Some(allocator_module) = allocator_module {\n-        ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, allocator_module);\n+        ongoing_codegen.submit_pre_codegened_module_to_llvm(\n+            tcx,\n+            ModuleCodegen { name: llmod_id, module_llvm, kind: ModuleKind::Allocator },\n+        );\n     }\n \n     // For better throughput during parallel processing by LLVM, we used to sort"}, {"sha": "f9bb8359208e326c2517f4b107b0deb644b15172", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -247,6 +247,9 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n                     // Note that this is also allowed if `actually_rustdoc` so\n                     // if a target is documenting some wasm-specific code then\n                     // it's not spuriously denied.\n+                    //\n+                    // This exception needs to be kept in sync with allowing\n+                    // `#[target_feature]` on `main` and `start`.\n                 } else if !tcx.features().target_feature_11 {\n                     let mut err = feature_err(\n                         &tcx.sess.parse_sess,"}, {"sha": "8e721a84eaf49858c3941980f8cb32fb36516a5e", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -56,7 +56,7 @@ pub mod mono_item;\n pub mod target_features;\n pub mod traits;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n pub struct ModuleCodegen<M> {\n     /// The name of the module. When the crate may be saved between"}, {"sha": "6e32c28a42c65c2b1ad4a55b025c7c27bf580426", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -241,12 +241,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn debug_introduce_local(&self, bx: &mut Bx, local: mir::Local) {\n         let full_debug_info = bx.sess().opts.debuginfo == DebugInfo::Full;\n \n-        // FIXME(eddyb) maybe name the return place as `_0` or `return`?\n-        if local == mir::RETURN_PLACE && !self.mir.local_decls[mir::RETURN_PLACE].is_user_variable()\n-        {\n-            return;\n-        }\n-\n         let vars = match &self.per_local_var_debug_info {\n             Some(per_local) => &per_local[local],\n             None => return,\n@@ -303,7 +297,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         let local_ref = &self.locals[local];\n \n-        let name = if bx.sess().fewer_names() {\n+        // FIXME Should the return place be named?\n+        let name = if bx.sess().fewer_names() || local == mir::RETURN_PLACE {\n             None\n         } else {\n             Some(match whole_local_var.or(fallback_var.clone()) {"}, {"sha": "5cffca5230a8f4c3f6193f7b2dbbfda68eb54015", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -258,6 +258,10 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     // Apply debuginfo to the newly allocated locals.\n     fx.debug_introduce_locals(&mut start_bx);\n \n+    // The builders will be created separately for each basic block at `codegen_block`.\n+    // So drop the builder of `start_llbb` to avoid having two at the same time.\n+    drop(start_bx);\n+\n     // Codegen the body of each block using reverse postorder\n     for (bb, _) in traversal::reverse_postorder(&mir) {\n         fx.codegen_block(bb);"}, {"sha": "754b085f1a83229a14c14152b9ded4bfb2841dc4", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -192,7 +192,7 @@ const X86_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"fxsr\", None),\n     (\"gfni\", Some(sym::avx512_target_feature)),\n     (\"lzcnt\", None),\n-    (\"movbe\", Some(sym::movbe_target_feature)),\n+    (\"movbe\", None),\n     (\"pclmulqdq\", None),\n     (\"popcnt\", None),\n     (\"rdrand\", None),\n@@ -394,7 +394,6 @@ pub fn from_target_feature(\n                 Some(sym::sse4a_target_feature) => rust_features.sse4a_target_feature,\n                 Some(sym::tbm_target_feature) => rust_features.tbm_target_feature,\n                 Some(sym::wasm_target_feature) => rust_features.wasm_target_feature,\n-                Some(sym::movbe_target_feature) => rust_features.movbe_target_feature,\n                 Some(sym::rtm_target_feature) => rust_features.rtm_target_feature,\n                 Some(sym::ermsb_target_feature) => rust_features.ermsb_target_feature,\n                 Some(sym::bpf_target_feature) => rust_features.bpf_target_feature,\n@@ -442,7 +441,7 @@ fn asm_target_features(tcx: TyCtxt<'_>, did: DefId) -> &FxIndexSet<Symbol> {\n pub fn check_target_feature_trait_unsafe(tcx: TyCtxt<'_>, id: LocalDefId, attr_span: Span) {\n     if let DefKind::AssocFn = tcx.def_kind(id) {\n         let parent_id = tcx.local_parent(id);\n-        if let DefKind::Impl { of_trait: true } = tcx.def_kind(parent_id) {\n+        if let DefKind::Trait | DefKind::Impl { of_trait: true } = tcx.def_kind(parent_id) {\n             tcx.sess\n                 .struct_span_err(\n                     attr_span,"}, {"sha": "33bb116d6fa23f01c513d1b34b0d7e8ed9007070", "filename": "compiler/rustc_const_eval/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_const_eval%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_const_eval%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_const_eval/locales/en-US.ftl"}, {"sha": "0918ffcd9821442a92ef261da3c2204f9606d4a2", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -536,24 +536,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         local: mir::Local,\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n-        // `const_prop` runs into this with an invalid (empty) frame, so we\n-        // have to support that case (mostly by skipping all caching).\n-        match frame.locals.get(local).and_then(|state| state.layout.get()) {\n-            None => {\n-                let layout = from_known_layout(self.tcx, self.param_env, layout, || {\n-                    let local_ty = frame.body.local_decls[local].ty;\n-                    let local_ty =\n-                        self.subst_from_frame_and_normalize_erasing_regions(frame, local_ty)?;\n-                    self.layout_of(local_ty)\n-                })?;\n-                if let Some(state) = frame.locals.get(local) {\n-                    // Layouts of locals are requested a lot, so we cache them.\n-                    state.layout.set(Some(layout));\n-                }\n-                Ok(layout)\n-            }\n-            Some(layout) => Ok(layout),\n+        let state = &frame.locals[local];\n+        if let Some(layout) = state.layout.get() {\n+            return Ok(layout);\n         }\n+\n+        let layout = from_known_layout(self.tcx, self.param_env, layout, || {\n+            let local_ty = frame.body.local_decls[local].ty;\n+            let local_ty = self.subst_from_frame_and_normalize_erasing_regions(frame, local_ty)?;\n+            self.layout_of(local_ty)\n+        })?;\n+\n+        // Layouts of locals are requested a lot, so we cache them.\n+        state.layout.set(Some(layout));\n+        Ok(layout)\n     }\n \n     /// Returns the actual dynamic size and alignment of the place at the given type."}, {"sha": "16b83af91ac951fb25b65d0a1bbfe1d5f7d28858", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -39,7 +39,7 @@ use rustc_macros::fluent_messages;\n use rustc_middle::ty;\n use rustc_middle::ty::query::Providers;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n pub fn provide(providers: &mut Providers) {\n     const_eval::provide(providers);"}, {"sha": "f775b47966786b157552b067b474272d7cbfd71d", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -643,7 +643,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                 if base_ty.is_unsafe_ptr() {\n                     if proj_base.is_empty() {\n                         let decl = &self.body.local_decls[place_local];\n-                        if let Some(box LocalInfo::StaticRef { def_id, .. }) = decl.local_info {\n+                        if let LocalInfo::StaticRef { def_id, .. } = *decl.local_info() {\n                             let span = decl.source_info.span;\n                             self.check_static(def_id, span);\n                             return;\n@@ -770,7 +770,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n \n                         let errors = ocx.select_all_or_error();\n                         if !errors.is_empty() {\n-                            infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+                            infcx.err_ctxt().report_fulfillment_errors(&errors);\n                         }\n                     }\n "}, {"sha": "c0f5b3725b36d355d854164931bb38b6de83b7cc", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -704,7 +704,7 @@ pub mod ty {\n \n         fn importance(&self) -> DiagnosticImportance {\n             match self.0 {\n-                mir::LocalKind::Var | mir::LocalKind::Temp => DiagnosticImportance::Secondary,\n+                mir::LocalKind::Temp => DiagnosticImportance::Secondary,\n                 mir::LocalKind::ReturnPointer | mir::LocalKind::Arg => {\n                     DiagnosticImportance::Primary\n                 }"}, {"sha": "648a86d32fcf33b7252d0408d05cd14b393ca359", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -106,8 +106,9 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n         debug!(\"visit_local: index={:?} context={:?} location={:?}\", index, context, location);\n         // We're only interested in temporaries and the return place\n         match self.ccx.body.local_kind(index) {\n-            LocalKind::Temp | LocalKind::ReturnPointer => {}\n-            LocalKind::Arg | LocalKind::Var => return,\n+            LocalKind::Arg => return,\n+            LocalKind::Temp if self.ccx.body.local_decls[index].is_user_variable() => return,\n+            LocalKind::ReturnPointer | LocalKind::Temp => {}\n         }\n \n         // Ignore drops, if the temp gets promoted,"}, {"sha": "f19b1ff6426177c16eb24dd9093bfa268cb21464", "filename": "compiler/rustc_driver_impl/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_driver_impl%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_driver_impl%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_driver_impl/locales/en-US.ftl"}, {"sha": "555917c8b5e9c1cb3aefd4b77bae0ab9226f3ae1", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -64,7 +64,7 @@ use crate::session_diagnostics::{\n     RLinkWrongFileType, RlinkNotAFile, RlinkUnableToRead,\n };\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n pub static DEFAULT_LOCALE_RESOURCES: &[&str] = &[\n     // tidy-alphabetical-start\n@@ -331,6 +331,7 @@ fn run_compiler(\n             if let Some(ppm) = &sess.opts.pretty {\n                 if ppm.needs_ast_map() {\n                     queries.global_ctxt()?.enter(|tcx| {\n+                        tcx.ensure().early_lint_checks(());\n                         pretty::print_after_hir_lowering(tcx, *ppm);\n                         Ok(())\n                     })?;"}, {"sha": "f03f8a6605f664d82b6d695d29261eb494ef060a", "filename": "compiler/rustc_error_codes/src/error_codes/E0010.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0010.md", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0010.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0010.md?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -5,7 +5,5 @@ the heap at runtime, and therefore cannot be done at compile time.\n Erroneous code example:\n \n ```compile_fail,E0010\n-#![feature(box_syntax)]\n-\n-const CON : Box<i32> = box 0;\n+const CON : Vec<i32> = vec![1, 2, 3];\n ```"}, {"sha": "b18e8758d712e60ef96f2279efd66ec9cce2c26e", "filename": "compiler/rustc_error_codes/src/error_codes/E0368.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0368.md", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0368.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0368.md?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -41,7 +41,7 @@ impl Add for Foo {\n \n fn main() {\n     let mut x: Foo = Foo(5);\n-    x += Foo(7); // error, `+= cannot be applied to the type `Foo`\n+    x += Foo(7); // error, `+=` cannot be applied to the type `Foo`\n }\n ```\n "}, {"sha": "84d55d524267ebbdf9130a356dd6cd8fde8c763b", "filename": "compiler/rustc_error_codes/src/error_codes/E0710.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0710.md", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0710.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0710.md?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -3,14 +3,14 @@ An unknown tool name was found in a scoped lint.\n Erroneous code examples:\n \n ```compile_fail,E0710\n-#[allow(clipp::filter_map)] // error!`\n+#[allow(clipp::filter_map)] // error!\n fn main() {\n     // business logic\n }\n ```\n \n ```compile_fail,E0710\n-#[warn(clipp::filter_map)] // error!`\n+#[warn(clipp::filter_map)] // error!\n fn main() {\n     // business logic\n }"}, {"sha": "e62923744482260f697a0083a88241a34cb0bc74", "filename": "compiler/rustc_error_messages/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_error_messages%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_error_messages%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_error_messages/locales/en-US.ftl"}, {"sha": "301dacc28248245edc31205bcf3e2be6eb3a3ff8", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -34,7 +34,7 @@ use intl_memoizer::IntlLangMemoizer;\n pub use fluent_bundle::{self, types::FluentType, FluentArgs, FluentError, FluentValue};\n pub use unic_langid::{langid, LanguageIdentifier};\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n pub type FluentBundle = fluent_bundle::bundle::FluentBundle<FluentResource, IntlLangMemoizer>;\n "}, {"sha": "dde1d6c0a819c6560d36ad532c4ef9c42e772793", "filename": "compiler/rustc_errors/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_errors%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_errors%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_errors/locales/en-US.ftl"}, {"sha": "bab4f31e77702b952069b6de32f365b00bf04f8c", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -76,7 +76,7 @@ pub use snippet::Style;\n pub type PErr<'a> = DiagnosticBuilder<'a, ErrorGuaranteed>;\n pub type PResult<'a, T> = Result<T, PErr<'a>>;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n // `PResult` is used a lot. Make sure it doesn't unintentionally get bigger.\n // (See also the comment on `DiagnosticBuilderInner`'s `diagnostic` field.)"}, {"sha": "cfae781bdee5fea39d1b0b6f3c648b16e0b60a47", "filename": "compiler/rustc_expand/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_expand%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_expand%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_expand/locales/en-US.ftl"}, {"sha": "713e4fbbdce2364b855db30b2604080ce2a4409a", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -12,13 +12,13 @@ use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{AssocCtxt, Visitor};\n use rustc_ast::{self as ast, AttrVec, Attribute, HasAttrs, Item, NodeId, PatKind};\n use rustc_attr::{self as attr, Deprecation, Stability};\n-use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_errors::{\n     Applicability, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, MultiSpan, PResult,\n };\n use rustc_lint_defs::builtin::PROC_MACRO_BACK_COMPAT;\n-use rustc_lint_defs::{BufferedEarlyLint, BuiltinLintDiagnostics};\n+use rustc_lint_defs::{BufferedEarlyLint, BuiltinLintDiagnostics, RegisteredTools};\n use rustc_parse::{self, parser, MACRO_ARGUMENTS};\n use rustc_session::errors::report_lit_error;\n use rustc_session::{parse::ParseSess, Limit, Session};\n@@ -947,14 +947,14 @@ pub trait ResolverExpand {\n     fn declare_proc_macro(&mut self, id: NodeId);\n \n     /// Tools registered with `#![register_tool]` and used by tool attributes and lints.\n-    fn registered_tools(&self) -> &FxHashSet<Ident>;\n+    fn registered_tools(&self) -> &RegisteredTools;\n }\n \n pub trait LintStoreExpand {\n     fn pre_expansion_lint(\n         &self,\n         sess: &Session,\n-        registered_tools: &FxHashSet<Ident>,\n+        registered_tools: &RegisteredTools,\n         node_id: NodeId,\n         attrs: &[Attribute],\n         items: &[P<Item>],"}, {"sha": "ced7531c3fe7e8e8b4bcbe541ef1c197cdb2f9bc", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -64,4 +64,4 @@ mod mut_visit {\n     mod tests;\n }\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }"}, {"sha": "b1d9cea277397102a427e9b93a20e1e557e83e63", "filename": "compiler/rustc_expand/src/mbe/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,19 +1,18 @@\n-use std::borrow::Cow;\n-\n use crate::base::{DummyResult, ExtCtxt, MacResult};\n use crate::expand::{parse_ast_fragment, AstFragmentKind};\n use crate::mbe::{\n     macro_parser::{MatcherLoc, NamedParseResult, ParseResult::*, TtParser},\n     macro_rules::{try_match_macro, Tracker},\n };\n-use rustc_ast::token::{self, Token};\n+use rustc_ast::token::{self, Token, TokenKind};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast_pretty::pprust;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage};\n use rustc_parse::parser::{Parser, Recovery};\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n+use std::borrow::Cow;\n \n use super::macro_rules::{parser_from_cx, NoopTracker};\n \n@@ -63,6 +62,13 @@ pub(super) fn failed_to_match_macro<'cx>(\n         err.note(format!(\"while trying to match {remaining_matcher}\"));\n     }\n \n+    if let MatcherLoc::Token { token: expected_token } = &remaining_matcher\n+        && (matches!(expected_token.kind, TokenKind::Interpolated(_))\n+            || matches!(token.kind, TokenKind::Interpolated(_)))\n+    {\n+        err.note(\"captured metavariables except for `$tt`, `$ident` and `$lifetime` cannot be compared to other tokens\");\n+    }\n+\n     // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`\n     if let Some((arg, comma_span)) = arg.add_comma() {\n         for lhs in lhses {"}, {"sha": "ac93dd555b7a4c5f0d7a54aa51425bf760b7eab8", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -90,7 +90,7 @@ declare_features! (\n     (accepted, clone_closures, \"1.26.0\", Some(44490), None),\n     /// Allows coercing non capturing closures to function pointers.\n     (accepted, closure_to_fn_coercion, \"1.19.0\", Some(39817), None),\n-    /// Allows using `cmpxchg16b` from `core::arch::x86_64`.\n+    /// Allows using the CMPXCHG16B target feature.\n     (accepted, cmpxchg16b_target_feature, \"CURRENT_RUSTC_VERSION\", Some(44839), None),\n     /// Allows usage of the `compile_error!` macro.\n     (accepted, compile_error, \"1.20.0\", Some(40872), None),\n@@ -238,6 +238,8 @@ declare_features! (\n     (accepted, min_const_unsafe_fn, \"1.33.0\", Some(55607), None),\n     /// Allows using `Self` and associated types in struct expressions and patterns.\n     (accepted, more_struct_aliases, \"1.16.0\", Some(37544), None),\n+    /// Allows using the MOVBE target feature.\n+    (accepted, movbe_target_feature, \"CURRENT_RUSTC_VERSION\", Some(44839), None),\n     /// Allows patterns with concurrent by-move and by-ref bindings.\n     /// For example, you can write `Foo(a, ref b)` where `a` is by-move and `b` is by-ref.\n     (accepted, move_ref_pattern, \"1.49.0\", Some(68354), None),"}, {"sha": "c893b34b4ac25e357f612f449c340a711007fcc7", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -200,8 +200,6 @@ declare_features! (\n     (active, auto_traits, \"1.50.0\", Some(13231), None),\n     /// Allows using `box` in patterns (RFC 469).\n     (active, box_patterns, \"1.0.0\", Some(29641), None),\n-    /// Allows using the `box $expr` syntax.\n-    (active, box_syntax, \"1.0.0\", Some(49733), None),\n     /// Allows `#[doc(notable_trait)]`.\n     /// Renamed from `doc_spotlight`.\n     (active, doc_notable_trait, \"1.52.0\", Some(45040), None),\n@@ -259,7 +257,6 @@ declare_features! (\n     (active, ermsb_target_feature, \"1.49.0\", Some(44839), None),\n     (active, hexagon_target_feature, \"1.27.0\", Some(44839), None),\n     (active, mips_target_feature, \"1.27.0\", Some(44839), None),\n-    (active, movbe_target_feature, \"1.34.0\", Some(44839), None),\n     (active, powerpc_target_feature, \"1.27.0\", Some(44839), None),\n     (active, riscv_target_feature, \"1.45.0\", Some(44839), None),\n     (active, rtm_target_feature, \"1.35.0\", Some(44839), None),"}, {"sha": "48d9fbfa6d2619e71a2262cee0c5e1e986b04c66", "filename": "compiler/rustc_feature/src/removed.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -52,6 +52,8 @@ declare_features! (\n     (removed, allow_fail, \"1.19.0\", Some(46488), None, Some(\"removed due to no clear use cases\")),\n     (removed, await_macro, \"1.38.0\", Some(50547), None,\n      Some(\"subsumed by `.await` syntax\")),\n+    /// Allows using the `box $expr` syntax.\n+    (removed, box_syntax, \"CURRENT_RUSTC_VERSION\", Some(49733), None, Some(\"replaced with `#[rustc_box]`\")),\n     /// Allows capturing disjoint fields in a closure/generator (RFC 2229).\n     (removed, capture_disjoint_fields, \"1.49.0\", Some(53488), None, Some(\"stabilized in Rust 2021\")),\n     /// Allows comparing raw pointers during const eval."}, {"sha": "f00a5f24e45459f1a2156f3c8b7775eecb6fa166", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -815,12 +815,13 @@ pub struct ParentedNode<'tcx> {\n #[derive(Debug)]\n pub struct AttributeMap<'tcx> {\n     pub map: SortedMap<ItemLocalId, &'tcx [Attribute]>,\n-    pub hash: Fingerprint,\n+    // Only present when the crate hash is needed.\n+    pub opt_hash: Option<Fingerprint>,\n }\n \n impl<'tcx> AttributeMap<'tcx> {\n     pub const EMPTY: &'static AttributeMap<'static> =\n-        &AttributeMap { map: SortedMap::new(), hash: Fingerprint::ZERO };\n+        &AttributeMap { map: SortedMap::new(), opt_hash: Some(Fingerprint::ZERO) };\n \n     #[inline]\n     pub fn get(&self, id: ItemLocalId) -> &'tcx [Attribute] {\n@@ -832,10 +833,9 @@ impl<'tcx> AttributeMap<'tcx> {\n /// These nodes are mapped by `ItemLocalId` alongside the index of their parent node.\n /// The HIR tree, including bodies, is pre-hashed.\n pub struct OwnerNodes<'tcx> {\n-    /// Pre-computed hash of the full HIR.\n-    pub hash_including_bodies: Fingerprint,\n-    /// Pre-computed hash of the item signature, without recursing into the body.\n-    pub hash_without_bodies: Fingerprint,\n+    /// Pre-computed hash of the full HIR. Used in the crate hash. Only present\n+    /// when incr. comp. is enabled.\n+    pub opt_hash_including_bodies: Option<Fingerprint>,\n     /// Full HIR for the current owner.\n     // The zeroth node's parent should never be accessed: the owner's parent is computed by the\n     // hir_owner_parent query. It is set to `ItemLocalId::INVALID` to force an ICE if accidentally\n@@ -872,8 +872,7 @@ impl fmt::Debug for OwnerNodes<'_> {\n                     .collect::<Vec<_>>(),\n             )\n             .field(\"bodies\", &self.bodies)\n-            .field(\"hash_without_bodies\", &self.hash_without_bodies)\n-            .field(\"hash_including_bodies\", &self.hash_including_bodies)\n+            .field(\"opt_hash_including_bodies\", &self.opt_hash_including_bodies)\n             .finish()\n     }\n }\n@@ -940,7 +939,8 @@ impl<T> MaybeOwner<T> {\n #[derive(Debug)]\n pub struct Crate<'hir> {\n     pub owners: IndexVec<LocalDefId, MaybeOwner<&'hir OwnerInfo<'hir>>>,\n-    pub hir_hash: Fingerprint,\n+    // Only present when incr. comp. is enabled.\n+    pub opt_hir_hash: Option<Fingerprint>,\n }\n \n #[derive(Debug, HashStable_Generic)]"}, {"sha": "72ff317d45d6ec8a798275623a55734f74f054c0", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -296,7 +296,6 @@ language_item_table! {\n     // FIXME(swatinem): the following lang items are used for async lowering and\n     // should become obsolete eventually.\n     ResumeTy,                sym::ResumeTy,            resume_ty,                  Target::Struct,         GenericRequirement::None;\n-    IdentityFuture,          sym::identity_future,     identity_future_fn,         Target::Fn,             GenericRequirement::None;\n     GetContext,              sym::get_context,         get_context_fn,             Target::Fn,             GenericRequirement::None;\n \n     Context,                 sym::Context,             context,                    Target::Struct,         GenericRequirement::None;"}, {"sha": "97fa710b35499f0f4879365245007321c33a0588", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -100,24 +100,23 @@ impl<'tcx, HirCtx: crate::HashStableContext> HashStable<HirCtx> for OwnerNodes<'\n         // `local_id_to_def_id` is also ignored because is dependent on the body, then just hashing\n         // the body satisfies the condition of two nodes being different have different\n         // `hash_stable` results.\n-        let OwnerNodes { hash_including_bodies, hash_without_bodies: _, nodes: _, bodies: _ } =\n-            *self;\n-        hash_including_bodies.hash_stable(hcx, hasher);\n+        let OwnerNodes { opt_hash_including_bodies, nodes: _, bodies: _ } = *self;\n+        opt_hash_including_bodies.unwrap().hash_stable(hcx, hasher);\n     }\n }\n \n impl<'tcx, HirCtx: crate::HashStableContext> HashStable<HirCtx> for AttributeMap<'tcx> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        // We ignore the `map` since it refers to information included in `hash` which is hashed in\n-        // the collector and used for the crate hash.\n-        let AttributeMap { hash, map: _ } = *self;\n-        hash.hash_stable(hcx, hasher);\n+        // We ignore the `map` since it refers to information included in `opt_hash` which is\n+        // hashed in the collector and used for the crate hash.\n+        let AttributeMap { opt_hash, map: _ } = *self;\n+        opt_hash.unwrap().hash_stable(hcx, hasher);\n     }\n }\n \n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Crate<'_> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        let Crate { owners: _, hir_hash } = self;\n-        hir_hash.hash_stable(hcx, hasher)\n+        let Crate { owners: _, opt_hir_hash } = self;\n+        opt_hir_hash.unwrap().hash_stable(hcx, hasher)\n     }\n }"}, {"sha": "0105cbf36dee2459d8b761e0ae0f871e4424249e", "filename": "compiler/rustc_hir_analysis/messages.ftl", "status": "renamed", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -42,6 +42,9 @@ hir_analysis_assoc_type_binding_not_allowed =\n     associated type bindings are not allowed here\n     .label = associated type not allowed here\n \n+hir_analysis_parenthesized_fn_trait_expansion =\n+    parenthesized trait syntax expands to `{$expanded_type}`\n+\n hir_analysis_typeof_reserved_keyword_used =\n     `typeof` is a reserved keyword but unimplemented\n     .suggestion = consider replacing `typeof(...)` with an actual type\n@@ -125,9 +128,14 @@ hir_analysis_where_clause_on_main = `main` function is not allowed to have a `wh\n hir_analysis_track_caller_on_main = `main` function is not allowed to be `#[track_caller]`\n     .suggestion = remove this annotation\n \n+hir_analysis_target_feature_on_main = `main` function is not allowed to have `#[target_feature]`\n+\n hir_analysis_start_not_track_caller = `start` is not allowed to be `#[track_caller]`\n     .label = `start` is not allowed to be `#[track_caller]`\n \n+hir_analysis_start_not_target_feature = `start` is not allowed to have `#[target_feature]`\n+    .label = `start` is not allowed to have `#[target_feature]`\n+\n hir_analysis_start_not_async = `start` is not allowed to be `async`\n     .label = `start` is not allowed to be `async`\n ", "previous_filename": "compiler/rustc_hir_analysis/locales/en-US.ftl"}, {"sha": "156334fe785b9aac901ce8b3487c0b9e22dd0781", "filename": "compiler/rustc_hir_analysis/src/astconv/errors.rs", "status": "modified", "additions": 72, "deletions": 35, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,10 +1,14 @@\n use crate::astconv::AstConv;\n-use crate::errors::{ManualImplementation, MissingTypeParams};\n+use crate::errors::{\n+    AssocTypeBindingNotAllowed, ManualImplementation, MissingTypeParams,\n+    ParenthesizedFnTraitExpansion,\n+};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{pluralize, struct_span_err, Applicability, Diagnostic, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::FulfillmentError;\n+use rustc_middle::ty::TyCtxt;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::parse::feature_err;\n use rustc_span::edit_distance::find_best_match_for_name;\n@@ -78,43 +82,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             // Do not suggest the other syntax if we are in trait impl:\n             // the desugaring would contain an associated type constraint.\n             if !is_impl {\n-                let args = trait_segment\n-                    .args\n-                    .as_ref()\n-                    .and_then(|args| args.args.get(0))\n-                    .and_then(|arg| match arg {\n-                        hir::GenericArg::Type(ty) => match ty.kind {\n-                            hir::TyKind::Tup(t) => t\n-                                .iter()\n-                                .map(|e| sess.source_map().span_to_snippet(e.span))\n-                                .collect::<Result<Vec<_>, _>>()\n-                                .map(|a| a.join(\", \")),\n-                            _ => sess.source_map().span_to_snippet(ty.span),\n-                        }\n-                        .map(|s| format!(\"({})\", s))\n-                        .ok(),\n-                        _ => None,\n-                    })\n-                    .unwrap_or_else(|| \"()\".to_string());\n-                let ret = trait_segment\n-                    .args()\n-                    .bindings\n-                    .iter()\n-                    .find_map(|b| match (b.ident.name == sym::Output, &b.kind) {\n-                        (true, hir::TypeBindingKind::Equality { term }) => {\n-                            let span = match term {\n-                                hir::Term::Ty(ty) => ty.span,\n-                                hir::Term::Const(c) => self.tcx().hir().span(c.hir_id),\n-                            };\n-                            sess.source_map().span_to_snippet(span).ok()\n-                        }\n-                        _ => None,\n-                    })\n-                    .unwrap_or_else(|| \"()\".to_string());\n                 err.span_suggestion(\n                     span,\n                     \"use parenthetical notation instead\",\n-                    format!(\"{}{} -> {}\", trait_segment.ident, args, ret),\n+                    fn_trait_to_string(self.tcx(), trait_segment, true),\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n@@ -629,3 +600,69 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         err.emit();\n     }\n }\n+\n+/// Emits an error regarding forbidden type binding associations\n+pub fn prohibit_assoc_ty_binding(\n+    tcx: TyCtxt<'_>,\n+    span: Span,\n+    segment: Option<(&hir::PathSegment<'_>, Span)>,\n+) {\n+    tcx.sess.emit_err(AssocTypeBindingNotAllowed { span, fn_trait_expansion: if let Some((segment, span)) = segment && segment.args().parenthesized {\n+        Some(ParenthesizedFnTraitExpansion { span, expanded_type: fn_trait_to_string(tcx, segment, false) })\n+    } else {\n+        None\n+    }});\n+}\n+\n+pub(crate) fn fn_trait_to_string(\n+    tcx: TyCtxt<'_>,\n+    trait_segment: &hir::PathSegment<'_>,\n+    parenthesized: bool,\n+) -> String {\n+    let args = trait_segment\n+        .args\n+        .as_ref()\n+        .and_then(|args| args.args.get(0))\n+        .and_then(|arg| match arg {\n+            hir::GenericArg::Type(ty) => match ty.kind {\n+                hir::TyKind::Tup(t) => t\n+                    .iter()\n+                    .map(|e| tcx.sess.source_map().span_to_snippet(e.span))\n+                    .collect::<Result<Vec<_>, _>>()\n+                    .map(|a| a.join(\", \")),\n+                _ => tcx.sess.source_map().span_to_snippet(ty.span),\n+            }\n+            .map(|s| {\n+                // `s.empty()` checks to see if the type is the unit tuple, if so we don't want a comma\n+                if parenthesized || s.is_empty() { format!(\"({})\", s) } else { format!(\"({},)\", s) }\n+            })\n+            .ok(),\n+            _ => None,\n+        })\n+        .unwrap_or_else(|| \"()\".to_string());\n+\n+    let ret = trait_segment\n+        .args()\n+        .bindings\n+        .iter()\n+        .find_map(|b| match (b.ident.name == sym::Output, &b.kind) {\n+            (true, hir::TypeBindingKind::Equality { term }) => {\n+                let span = match term {\n+                    hir::Term::Ty(ty) => ty.span,\n+                    hir::Term::Const(c) => tcx.hir().span(c.hir_id),\n+                };\n+\n+                (span != tcx.hir().span(trait_segment.hir_id))\n+                    .then_some(tcx.sess.source_map().span_to_snippet(span).ok())\n+                    .flatten()\n+            }\n+            _ => None,\n+        })\n+        .unwrap_or_else(|| \"()\".to_string());\n+\n+    if parenthesized {\n+        format!(\"{}{} -> {}\", trait_segment.ident, args, ret)\n+    } else {\n+        format!(\"{}<{}, Output={}>\", trait_segment.ident, args, ret)\n+    }\n+}"}, {"sha": "2f4963f6bc311aaf3a3ea2b2bab66cd538b1fcdf", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,9 +1,8 @@\n use super::IsMethodCall;\n use crate::astconv::{\n-    CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n-    GenericArgCountResult, GenericArgPosition,\n+    errors::prohibit_assoc_ty_binding, CreateSubstsForGenericArgsCtxt, ExplicitLateBound,\n+    GenericArgCountMismatch, GenericArgCountResult, GenericArgPosition,\n };\n-use crate::errors::AssocTypeBindingNotAllowed;\n use crate::structured_errors::{GenericArgsInfo, StructuredDiagnostic, WrongNumberOfGenericArgs};\n use rustc_ast::ast::ParamKindOrd;\n use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorGuaranteed, MultiSpan};\n@@ -433,7 +432,7 @@ pub(crate) fn check_generic_arg_count(\n         (gen_pos != GenericArgPosition::Type || infer_args) && !gen_args.has_lifetime_params();\n \n     if gen_pos != GenericArgPosition::Type && let Some(b) = gen_args.bindings.first() {\n-            prohibit_assoc_ty_binding(tcx, b.span);\n+             prohibit_assoc_ty_binding(tcx, b.span, None);\n         }\n \n     let explicit_late_bound =\n@@ -589,11 +588,6 @@ pub(crate) fn check_generic_arg_count(\n     }\n }\n \n-/// Emits an error regarding forbidden type binding associations\n-pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_>, span: Span) {\n-    tcx.sess.emit_err(AssocTypeBindingNotAllowed { span });\n-}\n-\n /// Prohibits explicit lifetime arguments if late-bound lifetime parameters\n /// are present. This is used both for datatypes and function calls.\n pub(crate) fn prohibit_explicit_late_bound_lifetimes("}, {"sha": "3cd4c4afe866ee8f866ff61664f404ded829e081", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -5,9 +5,8 @@\n mod errors;\n pub mod generics;\n \n-use crate::astconv::generics::{\n-    check_generic_arg_count, create_substs_for_generic_args, prohibit_assoc_ty_binding,\n-};\n+use crate::astconv::errors::prohibit_assoc_ty_binding;\n+use crate::astconv::generics::{check_generic_arg_count, create_substs_for_generic_args};\n use crate::bounds::Bounds;\n use crate::collect::HirPlaceholderCollector;\n use crate::errors::{\n@@ -295,7 +294,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             ty::BoundConstness::NotConst,\n         );\n         if let Some(b) = item_segment.args().bindings.first() {\n-            prohibit_assoc_ty_binding(self.tcx(), b.span);\n+            prohibit_assoc_ty_binding(self.tcx(), b.span, Some((item_segment, span)));\n         }\n \n         substs\n@@ -631,7 +630,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         );\n \n         if let Some(b) = item_segment.args().bindings.first() {\n-            prohibit_assoc_ty_binding(self.tcx(), b.span);\n+            prohibit_assoc_ty_binding(self.tcx(), b.span, Some((item_segment, span)));\n         }\n \n         args\n@@ -825,7 +824,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             constness,\n         );\n         if let Some(b) = trait_segment.args().bindings.first() {\n-            prohibit_assoc_ty_binding(self.tcx(), b.span);\n+            prohibit_assoc_ty_binding(self.tcx(), b.span, Some((trait_segment, span)));\n         }\n         self.tcx().mk_trait_ref(trait_def_id, substs)\n     }\n@@ -2596,7 +2595,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         for segment in segments {\n             // Only emit the first error to avoid overloading the user with error messages.\n             if let Some(b) = segment.args().bindings.first() {\n-                prohibit_assoc_ty_binding(self.tcx(), b.span);\n+                prohibit_assoc_ty_binding(self.tcx(), b.span, None);\n                 return true;\n             }\n         }\n@@ -3049,10 +3048,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             &hir::TyKind::OpaqueDef(item_id, lifetimes, in_trait) => {\n                 let opaque_ty = tcx.hir().item(item_id);\n-                let def_id = item_id.owner_id.to_def_id();\n \n                 match opaque_ty.kind {\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => {\n+                        let local_def_id = item_id.owner_id.def_id;\n+                        // If this is an RPITIT and we are using the new RPITIT lowering scheme, we\n+                        // generate the def_id of an associated type for the trait and return as\n+                        // type a projection.\n+                        let def_id = if in_trait && tcx.lower_impl_trait_in_trait_to_assoc_ty() {\n+                            tcx.associated_item_for_impl_trait_in_trait(local_def_id).to_def_id()\n+                        } else {\n+                            local_def_id.to_def_id()\n+                        };\n                         self.impl_trait_ty_to_ty(def_id, lifetimes, origin, in_trait)\n                     }\n                     ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),"}, {"sha": "14dc9d8918000bdbfbbdba6e5108821f5f01e680", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -444,7 +444,7 @@ fn check_opaque_meets_bounds<'tcx>(\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+        infcx.err_ctxt().report_fulfillment_errors(&errors);\n     }\n     match origin {\n         // Checked when type checking the function containing them.\n@@ -1545,6 +1545,6 @@ pub(super) fn check_generator_obligations(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let errors = fulfillment_cx.select_all_or_error(&infcx);\n     debug!(?errors);\n     if !errors.is_empty() {\n-        infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+        infcx.err_ctxt().report_fulfillment_errors(&errors);\n     }\n }"}, {"sha": "6e6f8c1533bfea5a90fa848042d0e344b9353e8f", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -320,7 +320,7 @@ fn compare_method_predicate_entailment<'tcx>(\n                 });\n             }\n             CheckImpliedWfMode::Skip => {\n-                let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+                let reported = infcx.err_ctxt().report_fulfillment_errors(&errors);\n                 return Err(reported);\n             }\n         }\n@@ -720,7 +720,7 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n     // RPITs.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors);\n         return Err(reported);\n     }\n \n@@ -830,7 +830,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for ImplTraitInTraitCollector<'_, 'tcx> {\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         if let ty::Alias(ty::Projection, proj) = ty.kind()\n-            && self.interner().def_kind(proj.def_id) == DefKind::ImplTraitPlaceholder\n+            && self.interner().is_impl_trait_in_trait(proj.def_id)\n         {\n             if let Some((ty, _)) = self.types.get(&proj.def_id) {\n                 return *ty;\n@@ -1731,7 +1731,7 @@ pub(super) fn compare_impl_const_raw(\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        return Err(infcx.err_ctxt().report_fulfillment_errors(&errors, None));\n+        return Err(infcx.err_ctxt().report_fulfillment_errors(&errors));\n     }\n \n     let outlives_environment = OutlivesEnvironment::new(param_env);\n@@ -1831,7 +1831,7 @@ fn compare_type_predicate_entailment<'tcx>(\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors);\n         return Err(reported);\n     }\n \n@@ -1995,13 +1995,20 @@ pub(super) fn check_type_bounds<'tcx>(\n     let infcx = tcx.infer_ctxt().build();\n     let ocx = ObligationCtxt::new(&infcx);\n \n-    let impl_ty_span = match tcx.hir().get_by_def_id(impl_ty_def_id) {\n-        hir::Node::TraitItem(hir::TraitItem {\n-            kind: hir::TraitItemKind::Type(_, Some(ty)),\n-            ..\n-        }) => ty.span,\n-        hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Type(ty), .. }) => ty.span,\n-        _ => bug!(),\n+    // A synthetic impl Trait for RPITIT desugaring has no HIR, which we currently use to get the\n+    // span for an impl's associated type. Instead, for these, use the def_span for the synthesized\n+    // associated type.\n+    let impl_ty_span = if tcx.opt_rpitit_info(impl_ty.def_id).is_some() {\n+        tcx.def_span(impl_ty_def_id)\n+    } else {\n+        match tcx.hir().get_by_def_id(impl_ty_def_id) {\n+            hir::Node::TraitItem(hir::TraitItem {\n+                kind: hir::TraitItemKind::Type(_, Some(ty)),\n+                ..\n+            }) => ty.span,\n+            hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Type(ty), .. }) => ty.span,\n+            _ => bug!(),\n+        }\n     };\n     let assumed_wf_types = ocx.assumed_wf_types(param_env, impl_ty_span, impl_ty_def_id);\n \n@@ -2044,7 +2051,7 @@ pub(super) fn check_type_bounds<'tcx>(\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors);\n         return Err(reported);\n     }\n "}, {"sha": "71050864ce0c514a2f914eb6a38cae8e4b521c0f", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -111,7 +111,7 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n \n     let errors = wfcx.select_all_or_error();\n     if !errors.is_empty() {\n-        infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+        infcx.err_ctxt().report_fulfillment_errors(&errors);\n         return;\n     }\n "}, {"sha": "5e8f69677cf3dc9cd81469d43c6dc846eced363e", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -345,7 +345,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n                     }),\n                 );\n                 if !errors.is_empty() {\n-                    infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+                    infcx.err_ctxt().report_fulfillment_errors(&errors);\n                 }\n \n                 // Finally, resolve all regions.\n@@ -585,7 +585,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n         predicate_for_trait_def(tcx, param_env, cause, trait_def_id, 0, [source, target]);\n     let errors = traits::fully_solve_obligation(&infcx, predicate);\n     if !errors.is_empty() {\n-        infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+        infcx.err_ctxt().report_fulfillment_errors(&errors);\n     }\n \n     // Finally, resolve all regions."}, {"sha": "07a33bcbb509bf847ed6789911ff55581ad59985", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -11,7 +11,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n-use rustc_middle::ty::fast_reject::{simplify_type, SimplifiedType, TreatParams};\n+use rustc_middle::ty::fast_reject::{simplify_type, SimplifiedType, TreatParams, TreatProjections};\n use rustc_middle::ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n \n@@ -99,7 +99,12 @@ impl<'tcx> InherentCollect<'tcx> {\n                 }\n             }\n \n-            if let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsInfer) {\n+            if let Some(simp) = simplify_type(\n+                self.tcx,\n+                self_ty,\n+                TreatParams::AsCandidateKey,\n+                TreatProjections::AsCandidateKey,\n+            ) {\n                 self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id);\n             } else {\n                 bug!(\"unexpected self type: {:?}\", self_ty);\n@@ -159,7 +164,12 @@ impl<'tcx> InherentCollect<'tcx> {\n             }\n         }\n \n-        if let Some(simp) = simplify_type(self.tcx, ty, TreatParams::AsInfer) {\n+        if let Some(simp) = simplify_type(\n+            self.tcx,\n+            ty,\n+            TreatParams::AsCandidateKey,\n+            TreatProjections::AsCandidateKey,\n+        ) {\n             self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id);\n         } else {\n             bug!(\"unexpected primitive type: {:?}\", ty);"}, {"sha": "7dce29cc0bbe39b748f60ab0180d9ebcc4917921", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -3,7 +3,7 @@ use crate::astconv::AstConv;\n use rustc_hir as hir;\n use rustc_infer::traits::util;\n use rustc_middle::ty::subst::InternalSubsts;\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty::{self, ImplTraitInTraitData, Ty, TyCtxt};\n use rustc_span::def_id::DefId;\n use rustc_span::Span;\n \n@@ -58,17 +58,10 @@ fn opaque_type_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     opaque_def_id: DefId,\n     ast_bounds: &'tcx [hir::GenericBound<'tcx>],\n+    item_ty: Ty<'tcx>,\n     span: Span,\n-    in_trait: bool,\n ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n     ty::print::with_no_queries!({\n-        let substs = InternalSubsts::identity_for_item(tcx, opaque_def_id);\n-        let item_ty = if in_trait {\n-            tcx.mk_projection(opaque_def_id, substs)\n-        } else {\n-            tcx.mk_opaque(opaque_def_id, substs)\n-        };\n-\n         let icx = ItemCtxt::new(tcx, opaque_def_id);\n         let mut bounds = icx.astconv().compute_bounds(item_ty, ast_bounds);\n         // Opaque types are implicitly sized unless a `?Sized` bound is found\n@@ -83,7 +76,18 @@ pub(super) fn explicit_item_bounds(\n     tcx: TyCtxt<'_>,\n     def_id: DefId,\n ) -> &'_ [(ty::Predicate<'_>, Span)] {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+    // If the def_id is about an RPITIT, delegate explicit_item_bounds to the opaque_def_id that\n+    // generated the synthesized associate type.\n+    let rpitit_info = if let Some(ImplTraitInTraitData::Trait { opaque_def_id, .. }) =\n+        tcx.opt_rpitit_info(def_id)\n+    {\n+        Some(opaque_def_id)\n+    } else {\n+        None\n+    };\n+\n+    let bounds_def_id = rpitit_info.unwrap_or(def_id);\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(bounds_def_id.expect_local());\n     match tcx.hir().get(hir_id) {\n         hir::Node::TraitItem(hir::TraitItem {\n             kind: hir::TraitItemKind::Type(bounds, _),\n@@ -94,7 +98,15 @@ pub(super) fn explicit_item_bounds(\n             kind: hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds, in_trait, .. }),\n             span,\n             ..\n-        }) => opaque_type_bounds(tcx, def_id, bounds, *span, *in_trait),\n+        }) => {\n+            let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+            let item_ty = if *in_trait || rpitit_info.is_some() {\n+                tcx.mk_projection(def_id, substs)\n+            } else {\n+                tcx.mk_opaque(def_id, substs)\n+            };\n+            opaque_type_bounds(tcx, bounds_def_id, bounds, item_ty, *span)\n+        }\n         _ => bug!(\"item_bounds called on {:?}\", def_id),\n     }\n }"}, {"sha": "fe44fabf57df9473771de23abc6462117b5e5da9", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -9,7 +9,8 @@ use rustc_middle::ty::print::with_forced_trimmed_paths;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{\n-    self, IsSuggestable, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitableExt,\n+    self, ImplTraitInTraitData, IsSuggestable, Ty, TyCtxt, TypeFolder, TypeSuperFoldable,\n+    TypeVisitableExt,\n };\n use rustc_span::symbol::Ident;\n use rustc_span::{Span, DUMMY_SP};\n@@ -244,6 +245,24 @@ fn get_path_containing_arg_in_pat<'hir>(\n }\n \n pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>> {\n+    // If we are computing `type_of` the synthesized associated type for an RPITIT in the impl\n+    // side, use `collect_return_position_impl_trait_in_trait_tys` to infer the value of the\n+    // associated type in the impl.\n+    if let Some(ImplTraitInTraitData::Impl { fn_def_id, .. }) = tcx.opt_rpitit_info(def_id) {\n+        match tcx.collect_return_position_impl_trait_in_trait_tys(fn_def_id) {\n+            Ok(map) => {\n+                let assoc_item = tcx.associated_item(def_id);\n+                return ty::EarlyBinder(map[&assoc_item.trait_item_def_id.unwrap()]);\n+            }\n+            Err(_) => {\n+                return ty::EarlyBinder(tcx.ty_error_with_message(\n+                    DUMMY_SP,\n+                    \"Could not collect return position impl trait in trait tys\",\n+                ));\n+            }\n+        }\n+    }\n+\n     let def_id = def_id.expect_local();\n     use rustc_hir::*;\n "}, {"sha": "f57197edeb74dd377bfff053220be6484a593977", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -129,6 +129,18 @@ pub struct AssocTypeBindingNotAllowed {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n+\n+    #[subdiagnostic]\n+    pub fn_trait_expansion: Option<ParenthesizedFnTraitExpansion>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[help(hir_analysis_parenthesized_fn_trait_expansion)]\n+pub struct ParenthesizedFnTraitExpansion {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub expanded_type: String,\n }\n \n #[derive(Diagnostic)]\n@@ -315,6 +327,14 @@ pub(crate) struct TrackCallerOnMain {\n     pub annotated: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_target_feature_on_main)]\n+pub(crate) struct TargetFeatureOnMain {\n+    #[primary_span]\n+    #[label(hir_analysis_target_feature_on_main)]\n+    pub main: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(hir_analysis_start_not_track_caller)]\n pub(crate) struct StartTrackCaller {\n@@ -324,6 +344,15 @@ pub(crate) struct StartTrackCaller {\n     pub start: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_start_not_target_feature)]\n+pub(crate) struct StartTargetFeature {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub start: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(hir_analysis_start_not_async, code = \"E0752\")]\n pub(crate) struct StartAsync {"}, {"sha": "58dd03811f78cf04ed5245ea8ec1114105860452", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -174,7 +174,7 @@ fn get_impl_substs(\n \n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        ocx.infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+        ocx.infcx.err_ctxt().report_fulfillment_errors(&errors);\n         return None;\n     }\n "}, {"sha": "62abcbbdc9f6ead17c722c393c587dee83234b38", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -120,7 +120,7 @@ use std::ops::Not;\n use astconv::AstConv;\n use bounds::Bounds;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_>, decl: &hir::FnDecl<'_>, abi: Abi, span: Span) {\n     const CONVENTIONS_UNSTABLE: &str = \"`C`, `cdecl`, `win64`, `sysv64` or `efiapi`\";\n@@ -176,7 +176,7 @@ fn require_same_types<'tcx>(\n     match &errors[..] {\n         [] => true,\n         errors => {\n-            infcx.err_ctxt().report_fulfillment_errors(errors, None);\n+            infcx.err_ctxt().report_fulfillment_errors(errors);\n             false\n         }\n     }\n@@ -283,6 +283,15 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         error = true;\n     }\n \n+    if !tcx.codegen_fn_attrs(main_def_id).target_features.is_empty()\n+        // Calling functions with `#[target_feature]` is not unsafe on WASM, see #84988\n+        && !tcx.sess.target.is_like_wasm\n+        && !tcx.sess.opts.actually_rustdoc\n+    {\n+        tcx.sess.emit_err(errors::TargetFeatureOnMain { main: main_span });\n+        error = true;\n+    }\n+\n     if error {\n         return;\n     }\n@@ -309,7 +318,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         ocx.register_bound(cause, param_env, norm_return_ty, term_did);\n         let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n-            infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+            infcx.err_ctxt().report_fulfillment_errors(&errors);\n             error = true;\n         }\n         // now we can take the return type of the given main function\n@@ -373,6 +382,18 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n                             });\n                             error = true;\n                         }\n+                        if attr.has_name(sym::target_feature)\n+                            // Calling functions with `#[target_feature]` is\n+                            // not unsafe on WASM, see #84988\n+                            && !tcx.sess.target.is_like_wasm\n+                            && !tcx.sess.opts.actually_rustdoc\n+                        {\n+                            tcx.sess.emit_err(errors::StartTargetFeature {\n+                                span: attr.span,\n+                                start: start_span,\n+                            });\n+                            error = true;\n+                        }\n                     }\n \n                     if error {"}, {"sha": "d715b03e40ebfe761afee13cf19a25a9a272c69b", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1367,8 +1367,8 @@ impl<'a> State<'a> {\n         self.ann.pre(self, AnnNode::Expr(expr));\n         match expr.kind {\n             hir::ExprKind::Box(expr) => {\n-                self.word_space(\"box\");\n-                self.print_expr_maybe_paren(expr, parser::PREC_PREFIX);\n+                self.word_space(\"Box::new\");\n+                self.print_call_post(std::slice::from_ref(expr));\n             }\n             hir::ExprKind::Array(exprs) => {\n                 self.print_expr_vec(exprs);"}, {"sha": "2c537bf4064ae9b7c5645423c879ca0f091fc893", "filename": "compiler/rustc_hir_typeck/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_typeck%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_typeck%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_hir_typeck/locales/en-US.ftl"}, {"sha": "ecbe4a97dd96750fc6f6ed77516863d0046a2fef", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -311,9 +311,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let fn_decl_span = if hir.body(body).generator_kind\n                 == Some(hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Closure))\n             {\n-                // Actually need to unwrap a few more layers of HIR to get to\n+                // Actually need to unwrap one more layer of HIR to get to\n                 // the _real_ closure...\n-                let async_closure = hir.parent_id(hir.parent_id(parent_hir_id));\n+                let async_closure = hir.parent_id(parent_hir_id);\n                 if let hir::Node::Expr(hir::Expr {\n                     kind: hir::ExprKind::Closure(&hir::Closure { fn_decl_span, .. }),\n                     .."}, {"sha": "773ac0e40c571c433d9c4fbb32c05593735c48c6", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -398,7 +398,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// Here:\n     /// - E would be `fn(&u32) -> &u32`.\n-    /// - S would be `fn(&u32) ->\n+    /// - S would be `fn(&u32) -> ?T`\n     /// - E' is `&'!0 u32 -> &'!0 u32`\n     /// - S' is `&'?0 u32 -> ?T`\n     ///"}, {"sha": "4720306e159e5b8dbf1673eeebce287660afb373", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -581,7 +581,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if !errors.is_empty() {\n             self.adjust_fulfillment_errors_for_expr_obligation(&mut errors);\n-            self.err_ctxt().report_fulfillment_errors(&errors, self.inh.body_id);\n+            self.err_ctxt().report_fulfillment_errors(&errors);\n         }\n     }\n \n@@ -594,7 +594,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if !result.is_empty() {\n             mutate_fulfillment_errors(&mut result);\n             self.adjust_fulfillment_errors_for_expr_obligation(&mut result);\n-            self.err_ctxt().report_fulfillment_errors(&result, self.inh.body_id);\n+            self.err_ctxt().report_fulfillment_errors(&result);\n         }\n     }\n \n@@ -924,12 +924,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 hir_id,\n                 kind: hir::ExprKind::Closure(..),\n                 ..\n-            }) if let Some(Node::Expr(&hir::Expr {\n-                hir_id,\n-                kind: hir::ExprKind::Call(..),\n-                ..\n-            })) = self.tcx.hir().find_parent(hir_id) &&\n-            let Some(Node::Item(&hir::Item {\n+            }) if let Some(Node::Item(&hir::Item {\n                 ident,\n                 kind: hir::ItemKind::Fn(ref sig, ..),\n                 ..\n@@ -1411,7 +1406,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             let e = self.tainted_by_errors().unwrap_or_else(|| {\n                 self.err_ctxt()\n-                    .emit_inference_failure_err((**self).body_id, sp, ty.into(), E0282, true)\n+                    .emit_inference_failure_err(self.body_id, sp, ty.into(), E0282, true)\n                     .emit()\n             });\n             let err = self.tcx.ty_error(e);"}, {"sha": "4110b176b41b1f8f6bc8726abf81f6df98140bc2", "filename": "compiler/rustc_hir_typeck/src/inherited.rs", "status": "modified", "additions": 7, "deletions": 43, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -4,7 +4,6 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::HirIdMap;\n-use rustc_infer::infer;\n use rustc_infer::infer::{DefiningAnchor, InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -58,8 +57,6 @@ pub struct Inherited<'tcx> {\n     pub(super) deferred_generator_interiors:\n         RefCell<Vec<(LocalDefId, hir::BodyId, Ty<'tcx>, hir::GeneratorKind)>>,\n \n-    pub(super) body_id: Option<hir::BodyId>,\n-\n     /// Whenever we introduce an adjustment from `!` into a type variable,\n     /// we record that type variable here. This is later used to inform\n     /// fallback. See the `fallback` module for details.\n@@ -75,48 +72,16 @@ impl<'tcx> Deref for Inherited<'tcx> {\n     }\n }\n \n-/// A temporary returned by `Inherited::build(...)`. This is necessary\n-/// for multiple `InferCtxt` to share the same `typeck_results`\n-/// without using `Rc` or something similar.\n-pub struct InheritedBuilder<'tcx> {\n-    infcx: infer::InferCtxtBuilder<'tcx>,\n-    def_id: LocalDefId,\n-    typeck_results: RefCell<ty::TypeckResults<'tcx>>,\n-}\n-\n impl<'tcx> Inherited<'tcx> {\n-    pub fn build(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> InheritedBuilder<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Self {\n         let hir_owner = tcx.hir().local_def_id_to_hir_id(def_id).owner;\n \n-        InheritedBuilder {\n-            infcx: tcx\n-                .infer_ctxt()\n-                .ignoring_regions()\n-                .with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id)),\n-            def_id,\n-            typeck_results: RefCell::new(ty::TypeckResults::new(hir_owner)),\n-        }\n-    }\n-}\n-\n-impl<'tcx> InheritedBuilder<'tcx> {\n-    pub fn enter<F, R>(mut self, f: F) -> R\n-    where\n-        F: FnOnce(&Inherited<'tcx>) -> R,\n-    {\n-        let def_id = self.def_id;\n-        f(&Inherited::new(self.infcx.build(), def_id, self.typeck_results))\n-    }\n-}\n-\n-impl<'tcx> Inherited<'tcx> {\n-    fn new(\n-        infcx: InferCtxt<'tcx>,\n-        def_id: LocalDefId,\n-        typeck_results: RefCell<ty::TypeckResults<'tcx>>,\n-    ) -> Self {\n-        let tcx = infcx.tcx;\n-        let body_id = tcx.hir().maybe_body_owned_by(def_id);\n+        let infcx = tcx\n+            .infer_ctxt()\n+            .ignoring_regions()\n+            .with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id))\n+            .build();\n+        let typeck_results = RefCell::new(ty::TypeckResults::new(hir_owner));\n \n         Inherited {\n             typeck_results,\n@@ -130,7 +95,6 @@ impl<'tcx> Inherited<'tcx> {\n             deferred_asm_checks: RefCell::new(Vec::new()),\n             deferred_generator_interiors: RefCell::new(Vec::new()),\n             diverging_type_vars: RefCell::new(Default::default()),\n-            body_id,\n             infer_var_info: RefCell::new(Default::default()),\n         }\n     }"}, {"sha": "d9c56134b662e9670000785d630cff89e2a2ba6b", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 116, "deletions": 120, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -45,13 +45,14 @@ mod rvalue_scopes;\n mod upvar;\n mod writeback;\n \n-pub use diverges::Diverges;\n-pub use expectation::Expectation;\n-pub use fn_ctxt::*;\n-pub use inherited::{Inherited, InheritedBuilder};\n+pub use fn_ctxt::FnCtxt;\n+pub use inherited::Inherited;\n \n use crate::check::check_fn;\n use crate::coercion::DynamicCoerceMany;\n+use crate::diverges::Diverges;\n+use crate::expectation::Expectation;\n+use crate::fn_ctxt::RawTy;\n use crate::gather_locals::GatherLocalsVisitor;\n use rustc_data_structures::unord::UnordSet;\n use rustc_errors::{\n@@ -74,7 +75,7 @@ use rustc_session::Session;\n use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::{sym, Span};\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n #[macro_export]\n macro_rules! type_error_struct {\n@@ -105,10 +106,9 @@ pub struct LocalTy<'tcx> {\n /// (notably closures), `typeck_results(def_id)` would wind up\n /// redirecting to the owning function.\n fn primary_body_of(\n-    tcx: TyCtxt<'_>,\n-    id: hir::HirId,\n+    node: Node<'_>,\n ) -> Option<(hir::BodyId, Option<&hir::Ty<'_>>, Option<&hir::FnSig<'_>>)> {\n-    match tcx.hir().get(id) {\n+    match node {\n         Node::Item(item) => match item.kind {\n             hir::ItemKind::Const(ty, body) | hir::ItemKind::Static(ty, _, body) => {\n                 Some((body, Some(ty), None))\n@@ -142,8 +142,7 @@ fn has_typeck_results(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     }\n \n     if let Some(def_id) = def_id.as_local() {\n-        let id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        primary_body_of(tcx, id).is_some()\n+        primary_body_of(tcx.hir().get_by_def_id(def_id)).is_some()\n     } else {\n         false\n     }\n@@ -198,143 +197,140 @@ fn typeck_with_fallback<'tcx>(\n     }\n \n     let id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    let node = tcx.hir().get(id);\n     let span = tcx.hir().span(id);\n \n     // Figure out what primary body this item has.\n-    let (body_id, body_ty, fn_sig) = primary_body_of(tcx, id).unwrap_or_else(|| {\n+    let (body_id, body_ty, fn_sig) = primary_body_of(node).unwrap_or_else(|| {\n         span_bug!(span, \"can't type-check body of {:?}\", def_id);\n     });\n     let body = tcx.hir().body(body_id);\n \n-    let typeck_results = Inherited::build(tcx, def_id).enter(|inh| {\n-        let param_env = tcx.param_env(def_id);\n-        let param_env = if tcx.has_attr(def_id.to_def_id(), sym::rustc_do_not_const_check) {\n-            param_env.without_const()\n+    let param_env = tcx.param_env(def_id);\n+    let param_env = if tcx.has_attr(def_id.to_def_id(), sym::rustc_do_not_const_check) {\n+        param_env.without_const()\n+    } else {\n+        param_env\n+    };\n+    let inh = Inherited::new(tcx, def_id);\n+    let mut fcx = FnCtxt::new(&inh, param_env, def_id);\n+\n+    if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n+        let fn_sig = if rustc_hir_analysis::collect::get_infer_ret_ty(&decl.output).is_some() {\n+            fcx.astconv().ty_of_fn(id, header.unsafety, header.abi, decl, None, None)\n         } else {\n-            param_env\n+            tcx.fn_sig(def_id).subst_identity()\n         };\n-        let mut fcx = FnCtxt::new(&inh, param_env, def_id);\n-\n-        if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n-            let fn_sig = if rustc_hir_analysis::collect::get_infer_ret_ty(&decl.output).is_some() {\n-                fcx.astconv().ty_of_fn(id, header.unsafety, header.abi, decl, None, None)\n-            } else {\n-                tcx.fn_sig(def_id).subst_identity()\n-            };\n \n-            check_abi(tcx, id, span, fn_sig.abi());\n+        check_abi(tcx, id, span, fn_sig.abi());\n \n-            // Compute the function signature from point of view of inside the fn.\n-            let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), fn_sig);\n-            let fn_sig = fcx.normalize(body.value.span, fn_sig);\n+        // Compute the function signature from point of view of inside the fn.\n+        let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), fn_sig);\n+        let fn_sig = fcx.normalize(body.value.span, fn_sig);\n \n-            check_fn(&mut fcx, fn_sig, decl, def_id, body, None);\n-        } else {\n-            let expected_type = body_ty\n-                .and_then(|ty| match ty.kind {\n-                    hir::TyKind::Infer => Some(fcx.astconv().ast_ty_to_ty(ty)),\n-                    _ => None,\n-                })\n-                .unwrap_or_else(|| match tcx.hir().get(id) {\n-                    Node::AnonConst(_) => match tcx.hir().get(tcx.hir().parent_id(id)) {\n-                        Node::Expr(&hir::Expr {\n-                            kind: hir::ExprKind::ConstBlock(ref anon_const),\n-                            ..\n-                        }) if anon_const.hir_id == id => fcx.next_ty_var(TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::TypeInference,\n-                            span,\n-                        }),\n-                        Node::Ty(&hir::Ty {\n-                            kind: hir::TyKind::Typeof(ref anon_const), ..\n-                        }) if anon_const.hir_id == id => fcx.next_ty_var(TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::TypeInference,\n-                            span,\n-                        }),\n-                        Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(asm), .. })\n-                        | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. }) => {\n-                            let operand_ty =\n-                                asm.operands.iter().find_map(|(op, _op_sp)| match op {\n-                                    hir::InlineAsmOperand::Const { anon_const }\n-                                        if anon_const.hir_id == id =>\n-                                    {\n-                                        // Inline assembly constants must be integers.\n-                                        Some(fcx.next_int_var())\n-                                    }\n-                                    hir::InlineAsmOperand::SymFn { anon_const }\n-                                        if anon_const.hir_id == id =>\n-                                    {\n-                                        Some(fcx.next_ty_var(TypeVariableOrigin {\n-                                            kind: TypeVariableOriginKind::MiscVariable,\n-                                            span,\n-                                        }))\n-                                    }\n-                                    _ => None,\n-                                });\n-                            operand_ty.unwrap_or_else(fallback)\n+        check_fn(&mut fcx, fn_sig, decl, def_id, body, None);\n+    } else {\n+        let expected_type = if let Some(&hir::Ty { kind: hir::TyKind::Infer, span, .. }) = body_ty {\n+            Some(fcx.next_ty_var(TypeVariableOrigin {\n+                kind: TypeVariableOriginKind::TypeInference,\n+                span,\n+            }))\n+        } else if let Node::AnonConst(_) = node {\n+            match tcx.hir().get(tcx.hir().parent_id(id)) {\n+                Node::Expr(&hir::Expr {\n+                    kind: hir::ExprKind::ConstBlock(ref anon_const), ..\n+                }) if anon_const.hir_id == id => Some(fcx.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::TypeInference,\n+                    span,\n+                })),\n+                Node::Ty(&hir::Ty { kind: hir::TyKind::Typeof(ref anon_const), .. })\n+                    if anon_const.hir_id == id =>\n+                {\n+                    Some(fcx.next_ty_var(TypeVariableOrigin {\n+                        kind: TypeVariableOriginKind::TypeInference,\n+                        span,\n+                    }))\n+                }\n+                Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(asm), .. })\n+                | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. }) => {\n+                    asm.operands.iter().find_map(|(op, _op_sp)| match op {\n+                        hir::InlineAsmOperand::Const { anon_const } if anon_const.hir_id == id => {\n+                            // Inline assembly constants must be integers.\n+                            Some(fcx.next_int_var())\n+                        }\n+                        hir::InlineAsmOperand::SymFn { anon_const } if anon_const.hir_id == id => {\n+                            Some(fcx.next_ty_var(TypeVariableOrigin {\n+                                kind: TypeVariableOriginKind::MiscVariable,\n+                                span,\n+                            }))\n                         }\n-                        _ => fallback(),\n-                    },\n-                    _ => fallback(),\n-                });\n+                        _ => None,\n+                    })\n+                }\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        };\n+        let expected_type = expected_type.unwrap_or_else(fallback);\n \n-            let expected_type = fcx.normalize(body.value.span, expected_type);\n-            fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n+        let expected_type = fcx.normalize(body.value.span, expected_type);\n+        fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n \n-            // Gather locals in statics (because of block expressions).\n-            GatherLocalsVisitor::new(&fcx).visit_body(body);\n+        // Gather locals in statics (because of block expressions).\n+        GatherLocalsVisitor::new(&fcx).visit_body(body);\n \n-            fcx.check_expr_coercable_to_type(&body.value, expected_type, None);\n+        fcx.check_expr_coercable_to_type(&body.value, expected_type, None);\n \n-            fcx.write_ty(id, expected_type);\n-        };\n+        fcx.write_ty(id, expected_type);\n+    };\n \n-        fcx.type_inference_fallback();\n-\n-        // Even though coercion casts provide type hints, we check casts after fallback for\n-        // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.\n-        fcx.check_casts();\n-        fcx.select_obligations_where_possible(|_| {});\n-\n-        // Closure and generator analysis may run after fallback\n-        // because they don't constrain other type variables.\n-        // Closure analysis only runs on closures. Therefore they only need to fulfill non-const predicates (as of now)\n-        let prev_constness = fcx.param_env.constness();\n-        fcx.param_env = fcx.param_env.without_const();\n-        fcx.closure_analyze(body);\n-        fcx.param_env = fcx.param_env.with_constness(prev_constness);\n-        assert!(fcx.deferred_call_resolutions.borrow().is_empty());\n-        // Before the generator analysis, temporary scopes shall be marked to provide more\n-        // precise information on types to be captured.\n-        fcx.resolve_rvalue_scopes(def_id.to_def_id());\n-\n-        for (ty, span, code) in fcx.deferred_sized_obligations.borrow_mut().drain(..) {\n-            let ty = fcx.normalize(span, ty);\n-            fcx.require_type_is_sized(ty, span, code);\n-        }\n+    fcx.type_inference_fallback();\n+\n+    // Even though coercion casts provide type hints, we check casts after fallback for\n+    // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.\n+    fcx.check_casts();\n+    fcx.select_obligations_where_possible(|_| {});\n+\n+    // Closure and generator analysis may run after fallback\n+    // because they don't constrain other type variables.\n+    // Closure analysis only runs on closures. Therefore they only need to fulfill non-const predicates (as of now)\n+    let prev_constness = fcx.param_env.constness();\n+    fcx.param_env = fcx.param_env.without_const();\n+    fcx.closure_analyze(body);\n+    fcx.param_env = fcx.param_env.with_constness(prev_constness);\n+    assert!(fcx.deferred_call_resolutions.borrow().is_empty());\n+    // Before the generator analysis, temporary scopes shall be marked to provide more\n+    // precise information on types to be captured.\n+    fcx.resolve_rvalue_scopes(def_id.to_def_id());\n+\n+    for (ty, span, code) in fcx.deferred_sized_obligations.borrow_mut().drain(..) {\n+        let ty = fcx.normalize(span, ty);\n+        fcx.require_type_is_sized(ty, span, code);\n+    }\n \n-        fcx.select_obligations_where_possible(|_| {});\n+    fcx.select_obligations_where_possible(|_| {});\n \n-        debug!(pending_obligations = ?fcx.fulfillment_cx.borrow().pending_obligations());\n+    debug!(pending_obligations = ?fcx.fulfillment_cx.borrow().pending_obligations());\n \n-        // This must be the last thing before `report_ambiguity_errors`.\n-        fcx.resolve_generator_interiors(def_id.to_def_id());\n+    // This must be the last thing before `report_ambiguity_errors`.\n+    fcx.resolve_generator_interiors(def_id.to_def_id());\n \n-        debug!(pending_obligations = ?fcx.fulfillment_cx.borrow().pending_obligations());\n+    debug!(pending_obligations = ?fcx.fulfillment_cx.borrow().pending_obligations());\n \n-        if let None = fcx.infcx.tainted_by_errors() {\n-            fcx.report_ambiguity_errors();\n-        }\n+    if let None = fcx.infcx.tainted_by_errors() {\n+        fcx.report_ambiguity_errors();\n+    }\n \n-        if let None = fcx.infcx.tainted_by_errors() {\n-            fcx.check_transmutes();\n-        }\n+    if let None = fcx.infcx.tainted_by_errors() {\n+        fcx.check_transmutes();\n+    }\n \n-        fcx.check_asms();\n+    fcx.check_asms();\n \n-        fcx.infcx.skip_region_resolution();\n+    fcx.infcx.skip_region_resolution();\n \n-        fcx.resolve_type_vars_in_body(body)\n-    });\n+    let typeck_results = fcx.resolve_type_vars_in_body(body);\n \n     // Consistency check our TypeckResults instance can hold all ItemLocalIds\n     // it will need to hold."}, {"sha": "3254a9303423653ab216c395f383ac65e3ea0f6a", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -15,6 +15,7 @@ use rustc_infer::infer::canonical::OriginalQueryValues;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n use rustc_middle::middle::stability;\n+use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::AssocItem;\n use rustc_middle::ty::GenericParamDefKind;\n@@ -699,7 +700,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     }\n \n     fn assemble_inherent_candidates_for_incoherent_ty(&mut self, self_ty: Ty<'tcx>) {\n-        let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsInfer) else {\n+        let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsCandidateKey, TreatProjections::AsCandidateKey) else {\n             bug!(\"unexpected incoherent type: {:?}\", self_ty)\n         };\n         for &impl_def_id in self.tcx.incoherent_impls(simp) {\n@@ -1338,6 +1339,7 @@ impl<'tcx> Pick<'tcx> {\n                     container: _,\n                     trait_item_def_id: _,\n                     fn_has_self_parameter: _,\n+                    opt_rpitit_info: _,\n                 },\n             kind: _,\n             import_ids: _,"}, {"sha": "7055d9257ec90902c55124077e48874d5dfa4c7a", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -25,6 +25,7 @@ use rustc_infer::infer::{\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::traits::util::supertraits;\n use rustc_middle::ty::fast_reject::DeepRejectCtxt;\n+use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::print::{with_crate_prefix, with_forced_trimmed_paths};\n use rustc_middle::ty::{self, GenericArgKind, Ty, TyCtxt, TypeVisitableExt};\n@@ -1257,7 +1258,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let target_ty = self\n                 .autoderef(sugg_span, rcvr_ty)\n                 .find(|(rcvr_ty, _)| {\n-                    DeepRejectCtxt { treat_obligation_params: TreatParams::AsInfer }\n+                    DeepRejectCtxt { treat_obligation_params: TreatParams::AsCandidateKey }\n                         .types_may_unify(*rcvr_ty, impl_ty)\n                 })\n                 .map_or(impl_ty, |(ty, _)| ty)\n@@ -1516,7 +1517,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .into_iter()\n             .any(|info| self.associated_value(info.def_id, item_name).is_some());\n         let found_assoc = |ty: Ty<'tcx>| {\n-            simplify_type(tcx, ty, TreatParams::AsInfer)\n+            simplify_type(tcx, ty, TreatParams::AsCandidateKey, TreatProjections::AsCandidateKey)\n                 .and_then(|simp| {\n                     tcx.incoherent_impls(simp)\n                         .iter()\n@@ -2645,9 +2646,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // FIXME: Even though negative bounds are not implemented, we could maybe handle\n                 // cases where a positive bound implies a negative impl.\n                 (candidates, Vec::new())\n-            } else if let Some(simp_rcvr_ty) =\n-                simplify_type(self.tcx, rcvr_ty, TreatParams::AsPlaceholder)\n-            {\n+            } else if let Some(simp_rcvr_ty) = simplify_type(\n+                self.tcx,\n+                rcvr_ty,\n+                TreatParams::ForLookup,\n+                TreatProjections::ForLookup,\n+            ) {\n                 let mut potential_candidates = Vec::new();\n                 let mut explicitly_negative = Vec::new();\n                 for candidate in candidates {\n@@ -2660,8 +2664,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         })\n                         .any(|imp_did| {\n                             let imp = self.tcx.impl_trait_ref(imp_did).unwrap().subst_identity();\n-                            let imp_simp =\n-                                simplify_type(self.tcx, imp.self_ty(), TreatParams::AsPlaceholder);\n+                            let imp_simp = simplify_type(\n+                                self.tcx,\n+                                imp.self_ty(),\n+                                TreatParams::ForLookup,\n+                                TreatProjections::ForLookup,\n+                            );\n                             imp_simp.map_or(false, |s| s == simp_rcvr_ty)\n                         })\n                     {"}, {"sha": "37783bc91bb8c821420e7a73909b2141bb7c858f", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -148,10 +148,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         rhs_ty,\n                         op,\n                     );\n-                    self.demand_suptype(expr.span, builtin_return_ty, return_ty);\n+                    self.demand_eqtype(expr.span, builtin_return_ty, return_ty);\n+                    builtin_return_ty\n+                } else {\n+                    return_ty\n                 }\n-\n-                return_ty\n             }\n         }\n     }"}, {"sha": "af588b16d593b38259358f4a2984fddc2c3f9c1b", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -748,7 +748,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n                 .infcx\n                 .err_ctxt()\n                 .emit_inference_failure_err(\n-                    Some(self.body.id()),\n+                    self.tcx.hir().body_owner_def_id(self.body.id()),\n                     self.span.to_span(self.tcx),\n                     p.into(),\n                     E0282,"}, {"sha": "4852ee0d9595cce228848c111ade539948223938", "filename": "compiler/rustc_incremental/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_incremental%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_incremental%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_incremental/locales/en-US.ftl"}, {"sha": "df958e4a61f4ed685130267657662b5c0a732fb0", "filename": "compiler/rustc_incremental/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -35,4 +35,4 @@ pub use persist::{build_dep_graph, load_dep_graph, DepGraphFuture};\n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_macros::fluent_messages;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }"}, {"sha": "4deae9f41c712d53bd83a8614b3fc22b1206d5b9", "filename": "compiler/rustc_incremental/src/persist/fs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -297,10 +297,12 @@ pub fn prepare_session_directory(\n /// renaming it to `s-{timestamp}-{svh}` and releasing the file lock.\n /// If there have been compilation errors, however, this function will just\n /// delete the presumably invalid session directory.\n-pub fn finalize_session_directory(sess: &Session, svh: Svh) {\n+pub fn finalize_session_directory(sess: &Session, svh: Option<Svh>) {\n     if sess.opts.incremental.is_none() {\n         return;\n     }\n+    // The svh is always produced when incr. comp. is enabled.\n+    let svh = svh.unwrap();\n \n     let _timer = sess.timer(\"incr_comp_finalize_session_directory\");\n "}, {"sha": "15780898dc6ab42110da1b11fd2db6f0d6768482", "filename": "compiler/rustc_infer/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_infer%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_infer%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_infer/locales/en-US.ftl"}, {"sha": "8ac82653c0ee80294cfe7c757793eb6e1ba0b36a", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -411,15 +411,28 @@ impl<'cx, 'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::Infer(ty::IntVar(_)) => self.canonicalize_ty_var(\n-                CanonicalVarInfo { kind: CanonicalVarKind::Ty(CanonicalTyVarKind::Int) },\n-                t,\n-            ),\n-\n-            ty::Infer(ty::FloatVar(_)) => self.canonicalize_ty_var(\n-                CanonicalVarInfo { kind: CanonicalVarKind::Ty(CanonicalTyVarKind::Float) },\n-                t,\n-            ),\n+            ty::Infer(ty::IntVar(vid)) => {\n+                let nt = self.infcx.opportunistic_resolve_int_var(vid);\n+                if nt != t {\n+                    return self.fold_ty(nt);\n+                } else {\n+                    self.canonicalize_ty_var(\n+                        CanonicalVarInfo { kind: CanonicalVarKind::Ty(CanonicalTyVarKind::Int) },\n+                        t,\n+                    )\n+                }\n+            }\n+            ty::Infer(ty::FloatVar(vid)) => {\n+                let nt = self.infcx.opportunistic_resolve_float_var(vid);\n+                if nt != t {\n+                    return self.fold_ty(nt);\n+                } else {\n+                    self.canonicalize_ty_var(\n+                        CanonicalVarInfo { kind: CanonicalVarKind::Ty(CanonicalTyVarKind::Float) },\n+                        t,\n+                    )\n+                }\n+            }\n \n             ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n                 bug!(\"encountered a fresh type during canonicalization\")"}, {"sha": "a2332797e8680d6c810ce960c4e5ef78809cd218", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -34,7 +34,6 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::infer::canonical::OriginalQueryValues;\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use rustc_middle::traits::query::NoSolution;\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n@@ -119,20 +118,30 @@ impl<'tcx> InferCtxt<'tcx> {\n                 self.unify_float_variable(!a_is_expected, v_id, v)\n             }\n \n-            // All other cases of inference are errors\n-            (&ty::Infer(_), _) | (_, &ty::Infer(_)) => {\n-                Err(TypeError::Sorts(ty::relate::expected_found(relation, a, b)))\n+            // We don't expect `TyVar` or `Fresh*` vars at this point with lazy norm.\n+            (\n+                ty::Alias(AliasKind::Projection, _),\n+                ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)),\n+            )\n+            | (\n+                ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)),\n+                ty::Alias(AliasKind::Projection, _),\n+            ) if self.tcx.trait_solver_next() => {\n+                bug!()\n             }\n \n-            (ty::Alias(AliasKind::Projection, _), _) if self.tcx.trait_solver_next() => {\n+            (_, ty::Alias(AliasKind::Projection, _)) | (ty::Alias(AliasKind::Projection, _), _)\n+                if self.tcx.trait_solver_next() =>\n+            {\n                 relation.register_type_equate_obligation(a, b);\n-                Ok(b)\n-            }\n-            (_, ty::Alias(AliasKind::Projection, _)) if self.tcx.trait_solver_next() => {\n-                relation.register_type_equate_obligation(b, a);\n                 Ok(a)\n             }\n \n+            // All other cases of inference are errors\n+            (&ty::Infer(_), _) | (_, &ty::Infer(_)) => {\n+                Err(TypeError::Sorts(ty::relate::expected_found(relation, a, b)))\n+            }\n+\n             _ => ty::relate::super_relate_tys(relation, a, b),\n         }\n     }\n@@ -161,9 +170,9 @@ impl<'tcx> InferCtxt<'tcx> {\n         //\n         // This probe is probably not strictly necessary but it seems better to be safe and not accidentally find\n         // ourselves with a check to find bugs being required for code to compile because it made inference progress.\n-        self.probe(|_| {\n+        let compatible_types = self.probe(|_| {\n             if a.ty() == b.ty() {\n-                return;\n+                return Ok(());\n             }\n \n             // We don't have access to trait solving machinery in `rustc_infer` so the logic for determining if the\n@@ -173,15 +182,24 @@ impl<'tcx> InferCtxt<'tcx> {\n                 (relation.param_env(), a.ty(), b.ty()),\n                 &mut OriginalQueryValues::default(),\n             );\n-\n-            if let Err(NoSolution) = self.tcx.check_tys_might_be_eq(canonical) {\n+            self.tcx.check_tys_might_be_eq(canonical).map_err(|_| {\n                 self.tcx.sess.delay_span_bug(\n                     DUMMY_SP,\n                     &format!(\"cannot relate consts of different types (a={:?}, b={:?})\", a, b,),\n-                );\n-            }\n+                )\n+            })\n         });\n \n+        // If the consts have differing types, just bail with a const error with\n+        // the expected const's type. Specifically, we don't want const infer vars\n+        // to do any type shapeshifting before and after resolution.\n+        if let Err(guar) = compatible_types {\n+            return Ok(self.tcx.const_error_with_guaranteed(\n+                if relation.a_is_expected() { a.ty() } else { b.ty() },\n+                guar,\n+            ));\n+        }\n+\n         match (a.kind(), b.kind()) {\n             (\n                 ty::ConstKind::Infer(InferConst::Var(a_vid)),"}, {"sha": "bde16fad82162c05dc5dee317a9ced70626fbdc9", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -10,7 +10,7 @@ use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed, IntoDiagnosticArg};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def::{CtorOf, DefKind, Namespace};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{Body, Closure, Expr, ExprKind, FnRetTy, HirId, Local, LocalSource};\n use rustc_middle::hir::nested_filter;\n@@ -386,7 +386,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     #[instrument(level = \"debug\", skip(self, error_code))]\n     pub fn emit_inference_failure_err(\n         &self,\n-        body_id: Option<hir::BodyId>,\n+        body_def_id: LocalDefId,\n         failure_span: Span,\n         arg: GenericArg<'tcx>,\n         error_code: TypeAnnotationNeeded,\n@@ -403,8 +403,10 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         };\n \n         let mut local_visitor = FindInferSourceVisitor::new(&self, typeck_results, arg);\n-        if let Some(body_id) = body_id {\n-            let expr = self.tcx.hir().expect_expr(body_id.hir_id);\n+        if let Some(body_id) = self.tcx.hir().maybe_body_owned_by(\n+            self.tcx.typeck_root_def_id(body_def_id.to_def_id()).expect_local(),\n+        ) {\n+            let expr = self.tcx.hir().body(body_id).value;\n             local_visitor.visit_expr(expr);\n         }\n "}, {"sha": "22c1e3871175e8782a946e7c102c7f7dedf275dc", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -104,7 +104,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let (mention_influencer, influencer_point) =\n             if sup_origin.span().overlaps(param.param_ty_span) {\n                 // Account for `async fn` like in `async-await/issues/issue-62097.rs`.\n-                // The desugaring of `async `fn`s causes `sup_origin` and `param` to point at the same\n+                // The desugaring of `async fn`s causes `sup_origin` and `param` to point at the same\n                 // place (but with different `ctxt`, hence `overlaps` instead of `==` above).\n                 //\n                 // This avoids the following:"}, {"sha": "4a834957959dbef27b8df1247ed235c198fd1d9f", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1363,6 +1363,28 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.inner.borrow_mut().const_unification_table().find(var)\n     }\n \n+    /// Resolves an int var to a rigid int type, if it was constrained to one,\n+    /// or else the root int var in the unification table.\n+    pub fn opportunistic_resolve_int_var(&self, vid: ty::IntVid) -> Ty<'tcx> {\n+        let mut inner = self.inner.borrow_mut();\n+        if let Some(value) = inner.int_unification_table().probe_value(vid) {\n+            value.to_type(self.tcx)\n+        } else {\n+            self.tcx.mk_int_var(inner.int_unification_table().find(vid))\n+        }\n+    }\n+\n+    /// Resolves a float var to a rigid int type, if it was constrained to one,\n+    /// or else the root float var in the unification table.\n+    pub fn opportunistic_resolve_float_var(&self, vid: ty::FloatVid) -> Ty<'tcx> {\n+        let mut inner = self.inner.borrow_mut();\n+        if let Some(value) = inner.float_unification_table().probe_value(vid) {\n+            value.to_type(self.tcx)\n+        } else {\n+            self.tcx.mk_float_var(inner.float_unification_table().find(vid))\n+        }\n+    }\n+\n     /// Where possible, replaces type/const variables in\n     /// `value` with their final value. Note that region variables\n     /// are unaffected. If a type/const variable has not been unified, it"}, {"sha": "738a1237651520c1a46cd5147b97f8847086024b", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -41,4 +41,4 @@ mod errors;\n pub mod infer;\n pub mod traits;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }"}, {"sha": "77c67c14ecc55a88685987b502f98e1eca4aa77d", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -53,6 +53,12 @@ pub struct Obligation<'tcx, T> {\n     pub recursion_depth: usize,\n }\n \n+impl<'tcx, P> From<Obligation<'tcx, P>> for solve::Goal<'tcx, P> {\n+    fn from(value: Obligation<'tcx, P>) -> Self {\n+        solve::Goal { param_env: value.param_env, predicate: value.predicate }\n+    }\n+}\n+\n pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n "}, {"sha": "37994899a2038acb3eb4aac39127f73c2c684820", "filename": "compiler/rustc_interface/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_interface%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_interface%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_interface/locales/en-US.ftl"}, {"sha": "15e0267107519d60fbdeceece16dd02a5ffbe035", "filename": "compiler/rustc_interface/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -31,4 +31,4 @@ pub use queries::Queries;\n #[cfg(test)]\n mod tests;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }"}, {"sha": "71bdd4df95ba384298d31552890d262cbf1bbbf4", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -11,7 +11,7 @@ use rustc_data_structures::parallel;\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n use rustc_errors::PResult;\n-use rustc_expand::base::{ExtCtxt, LintStoreExpand, ResolverExpand};\n+use rustc_expand::base::{ExtCtxt, LintStoreExpand};\n use rustc_hir::def_id::{StableCrateId, LOCAL_CRATE};\n use rustc_lint::{unerased_lint_store, BufferedEarlyLint, EarlyCheckNode, LintStore};\n use rustc_metadata::creader::CStore;\n@@ -26,7 +26,7 @@ use rustc_plugin_impl as plugin;\n use rustc_query_impl::{OnDiskCache, Queries as TcxQueries};\n use rustc_resolve::Resolver;\n use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType};\n-use rustc_session::cstore::{CrateStoreDyn, MetadataLoader, Untracked};\n+use rustc_session::cstore::{MetadataLoader, Untracked};\n use rustc_session::output::filename_for_input;\n use rustc_session::search_paths::PathKind;\n use rustc_session::{Limit, Session};\n@@ -178,7 +178,7 @@ fn configure_and_expand(mut krate: ast::Crate, resolver: &mut Resolver<'_, '_>)\n     let sess = tcx.sess;\n     let lint_store = unerased_lint_store(tcx);\n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n-    pre_expansion_lint(sess, lint_store, resolver.registered_tools(), &krate, crate_name);\n+    pre_expansion_lint(sess, lint_store, tcx.registered_tools(()), &krate, crate_name);\n     rustc_builtin_macros::register_builtin_macros(resolver);\n \n     krate = sess.time(\"crate_injection\", || {\n@@ -302,6 +302,16 @@ fn configure_and_expand(mut krate: ast::Crate, resolver: &mut Resolver<'_, '_>)\n \n     // Done with macro expansion!\n \n+    resolver.resolve_crate(&krate);\n+\n+    krate\n+}\n+\n+fn early_lint_checks(tcx: TyCtxt<'_>, (): ()) {\n+    let sess = tcx.sess;\n+    let (resolver, krate) = &*tcx.resolver_for_lowering(()).borrow();\n+    let mut lint_buffer = resolver.lint_buffer.steal();\n+\n     if sess.opts.unstable_opts.input_stats {\n         eprintln!(\"Post-expansion node count: {}\", count_nodes(&krate));\n     }\n@@ -310,8 +320,6 @@ fn configure_and_expand(mut krate: ast::Crate, resolver: &mut Resolver<'_, '_>)\n         hir_stats::print_ast_stats(&krate, \"POST EXPANSION AST STATS\", \"ast-stats-2\");\n     }\n \n-    resolver.resolve_crate(&krate);\n-\n     // Needs to go *after* expansion to be able to check the results of macro expansion.\n     sess.time(\"complete_gated_feature_checking\", || {\n         rustc_ast_passes::feature_gate::check_crate(&krate, sess);\n@@ -321,7 +329,7 @@ fn configure_and_expand(mut krate: ast::Crate, resolver: &mut Resolver<'_, '_>)\n     sess.parse_sess.buffered_lints.with_lock(|buffered_lints| {\n         info!(\"{} parse sess buffered_lints\", buffered_lints.len());\n         for early_lint in buffered_lints.drain(..) {\n-            resolver.lint_buffer().add_early_lint(early_lint);\n+            lint_buffer.add_early_lint(early_lint);\n         }\n     });\n \n@@ -340,20 +348,16 @@ fn configure_and_expand(mut krate: ast::Crate, resolver: &mut Resolver<'_, '_>)\n         }\n     });\n \n-    sess.time(\"early_lint_checks\", || {\n-        let lint_buffer = Some(std::mem::take(resolver.lint_buffer()));\n-        rustc_lint::check_ast_node(\n-            sess,\n-            false,\n-            lint_store,\n-            resolver.registered_tools(),\n-            lint_buffer,\n-            rustc_lint::BuiltinCombinedEarlyLintPass::new(),\n-            &krate,\n-        )\n-    });\n-\n-    krate\n+    let lint_store = unerased_lint_store(tcx);\n+    rustc_lint::check_ast_node(\n+        sess,\n+        false,\n+        lint_store,\n+        tcx.registered_tools(()),\n+        Some(lint_buffer),\n+        rustc_lint::BuiltinCombinedEarlyLintPass::new(),\n+        &**krate,\n+    )\n }\n \n // Returns all the paths that correspond to generated files.\n@@ -438,13 +442,9 @@ fn escape_dep_env(symbol: Symbol) -> String {\n     escaped\n }\n \n-fn write_out_deps(\n-    sess: &Session,\n-    cstore: &CrateStoreDyn,\n-    outputs: &OutputFilenames,\n-    out_filenames: &[PathBuf],\n-) {\n+fn write_out_deps(tcx: TyCtxt<'_>, outputs: &OutputFilenames, out_filenames: &[PathBuf]) {\n     // Write out dependency rules to the dep-info file if requested\n+    let sess = tcx.sess;\n     if !sess.opts.output_types.contains_key(&OutputType::DepInfo) {\n         return;\n     }\n@@ -492,9 +492,8 @@ fn write_out_deps(\n                 }\n             }\n \n-            let cstore = cstore.as_any().downcast_ref::<CStore>().unwrap();\n-            for cnum in cstore.crates_untracked() {\n-                let source = cstore.crate_source_untracked(cnum);\n+            for &cnum in tcx.crates(()) {\n+                let source = tcx.used_crate_source(cnum);\n                 if let Some((path, _)) = &source.dylib {\n                     files.push(escape_dep_filename(&path.display().to_string()));\n                 }\n@@ -557,6 +556,7 @@ fn resolver_for_lowering<'tcx>(\n     (): (),\n ) -> &'tcx Steal<(ty::ResolverAstLowering, Lrc<ast::Crate>)> {\n     let arenas = Resolver::arenas();\n+    let _ = tcx.registered_tools(()); // Uses `crate_for_resolver`.\n     let krate = tcx.crate_for_resolver(()).steal();\n     let mut resolver = Resolver::new(tcx, &krate, &arenas);\n     let krate = configure_and_expand(krate, &mut resolver);\n@@ -607,7 +607,7 @@ fn output_filenames(tcx: TyCtxt<'_>, (): ()) -> Arc<OutputFilenames> {\n         }\n     }\n \n-    write_out_deps(sess, &*tcx.cstore_untracked(), &outputs, &output_paths);\n+    write_out_deps(tcx, &outputs, &output_paths);\n \n     let only_dep_info = sess.opts.output_types.contains_key(&OutputType::DepInfo)\n         && sess.opts.output_types.len() == 1;\n@@ -629,6 +629,7 @@ pub static DEFAULT_QUERY_PROVIDERS: LazyLock<Providers> = LazyLock::new(|| {\n     providers.hir_crate = rustc_ast_lowering::lower_to_hir;\n     providers.output_filenames = output_filenames;\n     providers.resolver_for_lowering = resolver_for_lowering;\n+    providers.early_lint_checks = early_lint_checks;\n     proc_macro_decls::provide(providers);\n     rustc_const_eval::provide(providers);\n     rustc_middle::hir::provide(providers);\n@@ -637,6 +638,7 @@ pub static DEFAULT_QUERY_PROVIDERS: LazyLock<Providers> = LazyLock::new(|| {\n     rustc_mir_transform::provide(providers);\n     rustc_monomorphize::provide(providers);\n     rustc_privacy::provide(providers);\n+    rustc_resolve::provide(providers);\n     rustc_hir_analysis::provide(providers);\n     rustc_hir_typeck::provide(providers);\n     ty::provide(providers);"}, {"sha": "58ad044b399b6d76b965517c3c1f4bd7574e8125", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -284,7 +284,11 @@ impl<'tcx> Queries<'tcx> {\n         let codegen_backend = self.codegen_backend().clone();\n \n         let (crate_hash, prepare_outputs, dep_graph) = self.global_ctxt()?.enter(|tcx| {\n-            (tcx.crate_hash(LOCAL_CRATE), tcx.output_filenames(()).clone(), tcx.dep_graph.clone())\n+            (\n+                if tcx.sess.needs_crate_hash() { Some(tcx.crate_hash(LOCAL_CRATE)) } else { None },\n+                tcx.output_filenames(()).clone(),\n+                tcx.dep_graph.clone(),\n+            )\n         });\n         let ongoing_codegen = self.ongoing_codegen()?.steal();\n \n@@ -308,7 +312,8 @@ pub struct Linker {\n     // compilation outputs\n     dep_graph: DepGraph,\n     prepare_outputs: Arc<OutputFilenames>,\n-    crate_hash: Svh,\n+    // Only present when incr. comp. is enabled.\n+    crate_hash: Option<Svh>,\n     ongoing_codegen: Box<dyn Any>,\n }\n "}, {"sha": "043892410ceaa8e8f5bd9d915472c562b0248d6d", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -110,7 +110,7 @@ pub fn create_session(\n     add_configuration(&mut cfg, &mut sess, &*codegen_backend);\n \n     let mut check_cfg = config::to_crate_check_config(check_cfg);\n-    check_cfg.fill_well_known();\n+    check_cfg.fill_well_known(&sess.target);\n \n     sess.parse_sess.config = cfg;\n     sess.parse_sess.check_config = check_cfg;"}, {"sha": "bb4d91247b81d04eefa2c80523d8fa6d8f1b6857", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -298,10 +298,10 @@ where\n         }\n         let tail = &tail[first_non_space..];\n         if let Some(c) = tail.chars().nth(0) {\n-            // For error reporting, we would like the span to contain the character that was not\n-            // skipped. The +1 is necessary to account for the leading \\ that started the escape.\n-            let end = start + first_non_space + c.len_utf8() + 1;\n             if c.is_whitespace() {\n+                // For error reporting, we would like the span to contain the character that was not\n+                // skipped. The +1 is necessary to account for the leading \\ that started the escape.\n+                let end = start + first_non_space + c.len_utf8() + 1;\n                 callback(start..end, Err(EscapeError::UnskippedWhitespaceWarning));\n             }\n         }"}, {"sha": "68e62c9789aed9fda1e5a0118d1642cd4f8c6f95", "filename": "compiler/rustc_lint/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_lint%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_lint%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_lint/locales/en-US.ftl"}, {"sha": "a14dc20fca369e701337454e4f0b6ca53245ba16", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -17,6 +17,11 @@ use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n declare_tool_lint! {\n+    /// The `default_hash_type` lint detects use of [`std::collections::HashMap`]/[`std::collections::HashSet`],\n+    /// suggesting the use of `FxHashMap`/`FxHashSet`.\n+    ///\n+    /// This can help as `FxHasher` can perform better than the default hasher. DOS protection is not\n+    /// required as input is assumed to be trusted.\n     pub rustc::DEFAULT_HASH_TYPES,\n     Allow,\n     \"forbid HashMap and HashSet and suggest the FxHash* variants\",\n@@ -67,6 +72,12 @@ fn typeck_results_of_method_fn<'tcx>(\n }\n \n declare_tool_lint! {\n+    /// The `potential_query_instability` lint detects use of methods which can lead to\n+    /// potential query instability, such as iterating over a `HashMap`.\n+    ///\n+    /// Due to the [incremental compilation](https://rustc-dev-guide.rust-lang.org/queries/incremental-compilation.html) model,\n+    /// queries must return deterministic, stable results. `HashMap` iteration order can change between compilations,\n+    /// and will introduce instability if query results expose the order.\n     pub rustc::POTENTIAL_QUERY_INSTABILITY,\n     Allow,\n     \"require explicit opt-in when using potentially unstable methods or functions\",\n@@ -92,13 +103,17 @@ impl LateLintPass<'_> for QueryStability {\n }\n \n declare_tool_lint! {\n+    /// The `usage_of_ty_tykind` lint detects usages of `ty::TyKind::<kind>`,\n+    /// where `ty::<kind>` would suffice.\n     pub rustc::USAGE_OF_TY_TYKIND,\n     Allow,\n     \"usage of `ty::TyKind` outside of the `ty::sty` module\",\n     report_in_external_macro: true\n }\n \n declare_tool_lint! {\n+    /// The `usage_of_qualified_ty` lint detects usages of `ty::TyKind`,\n+    /// where `Ty` should be used instead.\n     pub rustc::USAGE_OF_QUALIFIED_TY,\n     Allow,\n     \"using `ty::{Ty,TyCtxt}` instead of importing it\",\n@@ -254,6 +269,8 @@ fn gen_args(segment: &PathSegment<'_>) -> String {\n }\n \n declare_tool_lint! {\n+    /// The `lint_pass_impl_without_macro` detects manual implementations of a lint\n+    /// pass, without using [`declare_lint_pass`] or [`impl_lint_pass`].\n     pub rustc::LINT_PASS_IMPL_WITHOUT_MACRO,\n     Allow,\n     \"`impl LintPass` without the `declare_lint_pass!` or `impl_lint_pass!` macros\"\n@@ -285,6 +302,8 @@ impl EarlyLintPass for LintPassImpl {\n }\n \n declare_tool_lint! {\n+    /// The `existing_doc_keyword` lint detects use `#[doc()]` keywords\n+    /// that don't exist, e.g. `#[doc(keyword = \"..\")]`.\n     pub rustc::EXISTING_DOC_KEYWORD,\n     Allow,\n     \"Check that documented keywords in std and core actually exist\",\n@@ -325,13 +344,22 @@ impl<'tcx> LateLintPass<'tcx> for ExistingDocKeyword {\n }\n \n declare_tool_lint! {\n+    /// The `untranslatable_diagnostic` lint detects diagnostics created\n+    /// without using translatable Fluent strings.\n+    ///\n+    /// More details on translatable diagnostics can be found [here](https://rustc-dev-guide.rust-lang.org/diagnostics/translation.html).\n     pub rustc::UNTRANSLATABLE_DIAGNOSTIC,\n     Allow,\n     \"prevent creation of diagnostics which cannot be translated\",\n     report_in_external_macro: true\n }\n \n declare_tool_lint! {\n+    /// The `diagnostic_outside_of_impl` lint detects diagnostics created manually,\n+    /// and inside an `IntoDiagnostic`/`AddToDiagnostic` implementation,\n+    /// or a `#[derive(Diagnostic)]`/`#[derive(Subdiagnostic)]` expansion.\n+    ///\n+    /// More details on diagnostics implementations can be found [here](https://rustc-dev-guide.rust-lang.org/diagnostics/diagnostic-structs.html).\n     pub rustc::DIAGNOSTIC_OUTSIDE_OF_IMPL,\n     Allow,\n     \"prevent creation of diagnostics outside of `IntoDiagnostic`/`AddToDiagnostic` impls\",\n@@ -396,6 +424,8 @@ impl LateLintPass<'_> for Diagnostics {\n }\n \n declare_tool_lint! {\n+    /// The `bad_opt_access` lint detects accessing options by field instad of\n+    /// the wrapper function.\n     pub rustc::BAD_OPT_ACCESS,\n     Deny,\n     \"prevent using options by field access when there is a wrapper function\","}, {"sha": "a76229dd3524b2ed0ce13a9310817a542317a4cb", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -128,7 +128,7 @@ fn lint_expectations(tcx: TyCtxt<'_>, (): ()) -> Vec<(LintExpectationId, LintExp\n         },\n         warn_about_weird_lints: false,\n         store,\n-        registered_tools: &tcx.resolutions(()).registered_tools,\n+        registered_tools: &tcx.registered_tools(()),\n     };\n \n     builder.add_command_line();\n@@ -156,7 +156,7 @@ fn shallow_lint_levels_on(tcx: TyCtxt<'_>, owner: hir::OwnerId) -> ShallowLintLe\n         },\n         warn_about_weird_lints: false,\n         store,\n-        registered_tools: &tcx.resolutions(()).registered_tools,\n+        registered_tools: &tcx.registered_tools(()),\n     };\n \n     if owner == hir::CRATE_OWNER_ID {"}, {"sha": "b3578540516d000b98495ca9044220d37720318d", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -126,7 +126,7 @@ pub use rustc_session::lint::Level::{self, *};\n pub use rustc_session::lint::{BufferedEarlyLint, FutureIncompatibleInfo, Lint, LintId};\n pub use rustc_session::lint::{LintArray, LintPass};\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n pub fn provide(providers: &mut Providers) {\n     levels::provide(providers);"}, {"sha": "2fab82d55cd47022327cfd82e09f06c531024f4a", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1349,9 +1349,8 @@ declare_lint! {\n     /// ### Example\n     ///\n     /// ```rust\n-    /// #![feature(box_syntax)]\n     /// fn main() {\n-    ///     let a = (box [1, 2, 3]).len();\n+    ///     let a = Box::new([1, 2, 3]).len();\n     /// }\n     /// ```\n     ///\n@@ -1372,7 +1371,11 @@ declare_lint_pass!(UnusedAllocation => [UNUSED_ALLOCATION]);\n impl<'tcx> LateLintPass<'tcx> for UnusedAllocation {\n     fn check_expr(&mut self, cx: &LateContext<'_>, e: &hir::Expr<'_>) {\n         match e.kind {\n-            hir::ExprKind::Box(_) => {}\n+            hir::ExprKind::Call(path_expr, [_])\n+                if let hir::ExprKind::Path(qpath) = &path_expr.kind\n+                && let Some(did) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id()\n+                && cx.tcx.is_diagnostic_item(sym::box_new, did)\n+                => {}\n             _ => return,\n         }\n "}, {"sha": "6f22bdabff450e898fcf3141b718c631427526b9", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -8,7 +8,7 @@ extern crate rustc_macros;\n pub use self::Level::*;\n use rustc_ast::node_id::NodeId;\n use rustc_ast::{AttrId, Attribute};\n-use rustc_data_structures::fx::FxIndexMap;\n+use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n use rustc_error_messages::{DiagnosticMessage, MultiSpan};\n use rustc_hir::HashStableContext;\n@@ -533,6 +533,7 @@ pub enum BuiltinLintDiagnostics {\n \n /// Lints that are buffered up early on in the `Session` before the\n /// `LintLevels` is calculated.\n+#[derive(Debug)]\n pub struct BufferedEarlyLint {\n     /// The span of code that we are linting on.\n     pub span: MultiSpan,\n@@ -551,7 +552,7 @@ pub struct BufferedEarlyLint {\n     pub diagnostic: BuiltinLintDiagnostics,\n }\n \n-#[derive(Default)]\n+#[derive(Default, Debug)]\n pub struct LintBuffer {\n     pub map: FxIndexMap<NodeId, Vec<BufferedEarlyLint>>,\n }\n@@ -601,6 +602,8 @@ impl LintBuffer {\n     }\n }\n \n+pub type RegisteredTools = FxIndexSet<Ident>;\n+\n /// Declares a static item of type `&'static Lint`.\n ///\n /// See <https://rustc-dev-guide.rust-lang.org/diagnostics.html> for"}, {"sha": "0493d6b05d030483c9f4d3e83c658838eaaecb7e", "filename": "compiler/rustc_llvm/llvm-wrapper/SymbolWrapper.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_llvm%2Fllvm-wrapper%2FSymbolWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_llvm%2Fllvm-wrapper%2FSymbolWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FSymbolWrapper.cpp?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -9,7 +9,6 @@\n \n #include \"llvm/IR/LLVMContext.h\"\n #include \"llvm/Object/ObjectFile.h\"\n-#include \"llvm/ADT/Optional.h\"\n \n using namespace llvm;\n using namespace llvm::sys;"}, {"sha": "79b8b417257045a6b60f244acf4f4a0f7acc35d5", "filename": "compiler/rustc_metadata/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_metadata%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_metadata%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_metadata/locales/en-US.ftl"}, {"sha": "f870a1db82d9ca19bca3f38e635e9afcfc3db1ce", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_ast::{self as ast, *};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::MappedReadGuard;\n+use rustc_data_structures::sync::{MappedReadGuard, MappedWriteGuard, ReadGuard, WriteGuard};\n use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def_id::{CrateNum, LocalDefId, StableCrateId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n@@ -133,8 +133,14 @@ impl<'a> std::fmt::Debug for CrateDump<'a> {\n \n impl CStore {\n     pub fn from_tcx(tcx: TyCtxt<'_>) -> MappedReadGuard<'_, CStore> {\n-        MappedReadGuard::map(tcx.cstore_untracked(), |c| {\n-            c.as_any().downcast_ref::<CStore>().expect(\"`tcx.cstore` is not a `CStore`\")\n+        ReadGuard::map(tcx.untracked().cstore.read(), |cstore| {\n+            cstore.as_any().downcast_ref::<CStore>().expect(\"`tcx.cstore` is not a `CStore`\")\n+        })\n+    }\n+\n+    pub fn from_tcx_mut(tcx: TyCtxt<'_>) -> MappedWriteGuard<'_, CStore> {\n+        WriteGuard::map(tcx.untracked().cstore.write(), |cstore| {\n+            cstore.untracked_as_any().downcast_mut().expect(\"`tcx.cstore` is not a `CStore`\")\n         })\n     }\n \n@@ -268,9 +274,6 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n     ) -> Self {\n         CrateLoader { tcx, cstore, used_extern_options }\n     }\n-    pub fn cstore(&self) -> &CStore {\n-        &self.cstore\n-    }\n \n     fn existing_match(&self, name: Symbol, hash: Option<Svh>, kind: PathKind) -> Option<CrateNum> {\n         for (cnum, data) in self.cstore.iter_crate_data() {"}, {"sha": "08de828fbdba246e020a3231eb55a34a66709a7f", "filename": "compiler/rustc_metadata/src/fs.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -6,9 +6,9 @@ use crate::{encode_metadata, EncodedMetadata};\n use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{CrateType, OutputType};\n+use rustc_session::config::OutputType;\n use rustc_session::output::filename_for_metadata;\n-use rustc_session::Session;\n+use rustc_session::{MetadataKind, Session};\n use tempfile::Builder as TempFileBuilder;\n \n use std::fs;\n@@ -39,27 +39,6 @@ pub fn emit_wrapper_file(\n }\n \n pub fn encode_and_write_metadata(tcx: TyCtxt<'_>) -> (EncodedMetadata, bool) {\n-    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    enum MetadataKind {\n-        None,\n-        Uncompressed,\n-        Compressed,\n-    }\n-\n-    let metadata_kind = tcx\n-        .sess\n-        .crate_types()\n-        .iter()\n-        .map(|ty| match *ty {\n-            CrateType::Executable | CrateType::Staticlib | CrateType::Cdylib => MetadataKind::None,\n-\n-            CrateType::Rlib => MetadataKind::Uncompressed,\n-\n-            CrateType::Dylib | CrateType::ProcMacro => MetadataKind::Compressed,\n-        })\n-        .max()\n-        .unwrap_or(MetadataKind::None);\n-\n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n     let out_filename = filename_for_metadata(tcx.sess, crate_name, tcx.output_filenames(()));\n     // To avoid races with another rustc process scanning the output directory,\n@@ -76,6 +55,7 @@ pub fn encode_and_write_metadata(tcx: TyCtxt<'_>) -> (EncodedMetadata, bool) {\n \n     // Always create a file at `metadata_filename`, even if we have nothing to write to it.\n     // This simplifies the creation of the output `out_filename` when requested.\n+    let metadata_kind = tcx.sess.metadata_kind();\n     match metadata_kind {\n         MetadataKind::None => {\n             std::fs::File::create(&metadata_filename).unwrap_or_else(|err| {"}, {"sha": "98d9ad31fe07e383da6571466fc774dccd270642", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -47,4 +47,4 @@ pub use fs::{emit_wrapper_file, METADATA_FILENAME};\n pub use native_libs::find_native_static_library;\n pub use rmeta::{encode_metadata, EncodedMetadata, METADATA_HEADER};\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }"}, {"sha": "ca26e1497aaf76e7a6105695be14ce83de6a7d7a", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 21, "deletions": 34, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -30,7 +30,6 @@ use rustc_session::cstore::{\n };\n use rustc_session::Session;\n use rustc_span::hygiene::ExpnIndex;\n-use rustc_span::source_map::{respan, Spanned};\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{self, BytePos, ExpnId, Pos, Span, SyntaxContext, DUMMY_SP};\n \n@@ -311,8 +310,11 @@ impl<T: ParameterizedOverTcx> LazyArray<T> {\n impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n-        debug_assert!(self.tcx.is_some(), \"missing TyCtxt in DecodeContext\");\n-        self.tcx.unwrap()\n+        let Some(tcx) = self.tcx else {\n+            bug!(\"No TyCtxt found for decoding. \\\n+                You need to explicitly pass `(crate_metadata_ref, tcx)` to `decode` instead of just `crate_metadata_ref`.\");\n+        };\n+        tcx\n     }\n \n     #[inline]\n@@ -454,7 +456,12 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for ast::AttrId {\n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for SyntaxContext {\n     fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> SyntaxContext {\n         let cdata = decoder.cdata();\n-        let sess = decoder.sess.unwrap();\n+\n+        let Some(sess) = decoder.sess else {\n+            bug!(\"Cannot decode SyntaxContext without Session.\\\n+                You need to explicitly pass `(crate_metadata_ref, tcx)` to `decode` instead of just `crate_metadata_ref`.\");\n+        };\n+\n         let cname = cdata.root.name;\n         rustc_span::hygiene::decode_syntax_context(decoder, &cdata.hygiene_context, |_, id| {\n             debug!(\"SpecializedDecoder<SyntaxContext>: decoding {}\", id);\n@@ -471,7 +478,11 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for SyntaxContext {\n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for ExpnId {\n     fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> ExpnId {\n         let local_cdata = decoder.cdata();\n-        let sess = decoder.sess.unwrap();\n+\n+        let Some(sess) = decoder.sess else {\n+            bug!(\"Cannot decode ExpnId without Session. \\\n+                You need to explicitly pass `(crate_metadata_ref, tcx)` to `decode` instead of just `crate_metadata_ref`.\");\n+        };\n \n         let cnum = CrateNum::decode(decoder);\n         let index = u32::decode(decoder);\n@@ -520,7 +531,8 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n         let hi = lo + len;\n \n         let Some(sess) = decoder.sess else {\n-            bug!(\"Cannot decode Span without Session.\")\n+            bug!(\"Cannot decode Span without Session. \\\n+                You need to explicitly pass `(crate_metadata_ref, tcx)` to `decode` instead of just `crate_metadata_ref`.\")\n         };\n \n         // Index of the file in the corresponding crate's list of encoded files.\n@@ -917,7 +929,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self.root.tables.generics_of.get(self, item_id).unwrap().decode((self, sess))\n     }\n \n-    fn get_visibility(self, id: DefIndex) -> ty::Visibility<DefId> {\n+    fn get_visibility(self, id: DefIndex) -> Visibility<DefId> {\n         self.root\n             .tables\n             .visibility\n@@ -1083,6 +1095,8 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             trait_item_def_id: self.get_trait_item_def_id(id),\n             container,\n             fn_has_self_parameter: has_self,\n+            // FIXME(-Zlower-impl-trait-in-trait-to-assoc-ty): We need to encode this\n+            opt_rpitit_info: None,\n         }\n     }\n \n@@ -1121,33 +1135,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, sess))\n     }\n \n-    fn get_struct_field_names(\n-        self,\n-        id: DefIndex,\n-        sess: &'a Session,\n-    ) -> impl Iterator<Item = Spanned<Symbol>> + 'a {\n-        self.root\n-            .tables\n-            .children\n-            .get(self, id)\n-            .expect(\"fields not encoded for a struct\")\n-            .decode(self)\n-            .map(move |index| respan(self.get_span(index, sess), self.item_name(index)))\n-    }\n-\n-    fn get_struct_field_visibilities(\n-        self,\n-        id: DefIndex,\n-    ) -> impl Iterator<Item = Visibility<DefId>> + 'a {\n-        self.root\n-            .tables\n-            .children\n-            .get(self, id)\n-            .expect(\"fields not encoded for a struct\")\n-            .decode(self)\n-            .map(move |field_index| self.get_visibility(field_index))\n-    }\n-\n     fn get_inherent_implementations_for_type(\n         self,\n         tcx: TyCtxt<'tcx>,"}, {"sha": "6c5e8863010850e40abe3b648cd320665c1707cf", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 35, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -15,12 +15,12 @@ use rustc_middle::middle::exported_symbols::ExportedSymbol;\n use rustc_middle::middle::stability::DeprecationEntry;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::{ExternProviders, Providers};\n-use rustc_middle::ty::{self, TyCtxt, Visibility};\n-use rustc_session::cstore::{CrateSource, CrateStore};\n+use rustc_middle::ty::{self, TyCtxt};\n+use rustc_session::cstore::CrateStore;\n use rustc_session::{Session, StableCrateId};\n use rustc_span::hygiene::{ExpnHash, ExpnId};\n-use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::{kw, Symbol};\n+use rustc_span::Span;\n \n use rustc_data_structures::sync::Lrc;\n use std::any::Any;\n@@ -501,35 +501,18 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n             tcx.arena\n                 .alloc_slice(&CStore::from_tcx(tcx).crate_dependencies_in_postorder(LOCAL_CRATE))\n         },\n-        crates: |tcx, ()| tcx.arena.alloc_from_iter(CStore::from_tcx(tcx).crates_untracked()),\n+        crates: |tcx, ()| {\n+            tcx.arena.alloc_from_iter(CStore::from_tcx(tcx).iter_crate_data().map(|(cnum, _)| cnum))\n+        },\n         ..*providers\n     };\n }\n \n impl CStore {\n-    pub fn struct_field_names_untracked<'a>(\n-        &'a self,\n-        def: DefId,\n-        sess: &'a Session,\n-    ) -> impl Iterator<Item = Spanned<Symbol>> + 'a {\n-        self.get_crate_data(def.krate).get_struct_field_names(def.index, sess)\n-    }\n-\n-    pub fn struct_field_visibilities_untracked(\n-        &self,\n-        def: DefId,\n-    ) -> impl Iterator<Item = Visibility<DefId>> + '_ {\n-        self.get_crate_data(def.krate).get_struct_field_visibilities(def.index)\n-    }\n-\n     pub fn ctor_untracked(&self, def: DefId) -> Option<(CtorKind, DefId)> {\n         self.get_crate_data(def.krate).get_ctor(def.index)\n     }\n \n-    pub fn visibility_untracked(&self, def: DefId) -> Visibility<DefId> {\n-        self.get_crate_data(def.krate).get_visibility(def.index)\n-    }\n-\n     pub fn module_children_untracked<'a>(\n         &'a self,\n         def_id: DefId,\n@@ -566,14 +549,6 @@ impl CStore {\n         )\n     }\n \n-    pub fn fn_has_self_parameter_untracked(&self, def: DefId, sess: &Session) -> bool {\n-        self.get_crate_data(def.krate).get_fn_has_self_parameter(def.index, sess)\n-    }\n-\n-    pub fn crate_source_untracked(&self, cnum: CrateNum) -> Lrc<CrateSource> {\n-        self.get_crate_data(cnum).source.clone()\n-    }\n-\n     pub fn get_span_untracked(&self, def_id: DefId, sess: &Session) -> Span {\n         self.get_crate_data(def_id.krate).get_span(def_id.index, sess)\n     }\n@@ -582,10 +557,6 @@ impl CStore {\n         self.get_crate_data(def.krate).def_kind(def.index)\n     }\n \n-    pub fn crates_untracked(&self) -> impl Iterator<Item = CrateNum> + '_ {\n-        self.iter_crate_data().map(|(cnum, _)| cnum)\n-    }\n-\n     pub fn item_generics_num_lifetimes(&self, def_id: DefId, sess: &Session) -> usize {\n         self.get_crate_data(def_id.krate).get_generics(def_id.index, sess).own_counts().lifetimes\n     }"}, {"sha": "bbab8a62a2bce98fa4a9cc083c49a64e4e935daa", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -26,7 +26,7 @@ use rustc_middle::middle::exported_symbols::{\n use rustc_middle::mir::interpret;\n use rustc_middle::traits::specialization_graph;\n use rustc_middle::ty::codec::TyEncoder;\n-use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n+use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams, TreatProjections};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_middle::util::common::to_readable_str;\n@@ -1104,7 +1104,7 @@ fn should_encode_const(def_kind: DefKind) -> bool {\n // We only encode impl trait in trait when using `lower-impl-trait-in-trait-to-assoc-ty` unstable\n // option.\n fn should_encode_fn_impl_trait_in_trait<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n-    if tcx.sess.opts.unstable_opts.lower_impl_trait_in_trait_to_assoc_ty\n+    if tcx.lower_impl_trait_in_trait_to_assoc_ty()\n         && let Some(assoc_item) = tcx.opt_associated_item(def_id)\n         && assoc_item.container == ty::AssocItemContainer::TraitContainer\n         && assoc_item.kind == ty::AssocKind::Fn\n@@ -1858,7 +1858,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     let simplified_self_ty = fast_reject::simplify_type(\n                         self.tcx,\n                         trait_ref.self_ty(),\n-                        TreatParams::AsInfer,\n+                        TreatParams::AsCandidateKey,\n+                        TreatProjections::AsCandidateKey,\n                     );\n \n                     fx_hash_map\n@@ -2050,13 +2051,13 @@ fn prefetch_mir(tcx: TyCtxt<'_>) {\n         let (encode_const, encode_opt) = should_encode_mir(tcx, def_id);\n \n         if encode_const {\n-            tcx.ensure().mir_for_ctfe(def_id);\n+            tcx.ensure_with_value().mir_for_ctfe(def_id);\n         }\n         if encode_opt {\n-            tcx.ensure().optimized_mir(def_id);\n+            tcx.ensure_with_value().optimized_mir(def_id);\n         }\n         if encode_opt || encode_const {\n-            tcx.ensure().promoted_mir(def_id);\n+            tcx.ensure_with_value().promoted_mir(def_id);\n         }\n     })\n }"}, {"sha": "4f4e5c6a2c9c2218bed43d2e41ec213e9b4aa2e0", "filename": "compiler/rustc_middle/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_middle/locales/en-US.ftl"}, {"sha": "72907fba5e62ce23712c6a9b21989ad7592907f3", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -108,6 +108,7 @@ macro_rules! arena_types {\n             // (during lowering) and the `librustc_middle` arena (for decoding MIR)\n             [decode] asm_template: rustc_ast::InlineAsmTemplatePiece,\n             [decode] used_trait_imports: rustc_data_structures::unord::UnordSet<rustc_hir::def_id::LocalDefId>,\n+            [decode] registered_tools: rustc_middle::ty::RegisteredTools,\n             [decode] is_late_bound_map: rustc_data_structures::fx::FxIndexSet<rustc_hir::ItemLocalId>,\n             [decode] impl_source: rustc_middle::traits::ImplSource<'tcx, ()>,\n "}, {"sha": "746cf4885893260e214fbfa744dad26e1cf19413", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1134,7 +1134,7 @@ impl<'hir> intravisit::Map<'hir> for Map<'hir> {\n pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n     debug_assert_eq!(crate_num, LOCAL_CRATE);\n     let krate = tcx.hir_crate(());\n-    let hir_body_hash = krate.hir_hash;\n+    let hir_body_hash = krate.opt_hir_hash.expect(\"HIR hash missing while computing crate hash\");\n \n     let upstream_crates = upstream_crates(tcx);\n "}, {"sha": "403b2b650886e1c69884baa37290f555eeb4142f", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -8,7 +8,6 @@ pub mod place;\n \n use crate::ty::query::Providers;\n use crate::ty::{ImplSubject, TyCtxt};\n-use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -24,14 +23,15 @@ use rustc_span::{ExpnId, DUMMY_SP};\n #[derive(Copy, Clone, Debug)]\n pub struct Owner<'tcx> {\n     node: OwnerNode<'tcx>,\n-    hash_without_bodies: Fingerprint,\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Owner<'tcx> {\n     #[inline]\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let Owner { node: _, hash_without_bodies } = self;\n-        hash_without_bodies.hash_stable(hcx, hasher)\n+        // Perform a shallow hash instead using the deep hash saved in `OwnerNodes`. This lets us\n+        // differentiate queries that depend on the full HIR tree from those that only depend on\n+        // the item signature.\n+        hcx.without_hir_bodies(|hcx| self.node.hash_stable(hcx, hasher));\n     }\n }\n \n@@ -123,7 +123,7 @@ pub fn provide(providers: &mut Providers) {\n     providers.hir_owner = |tcx, id| {\n         let owner = tcx.hir_crate(()).owners.get(id.def_id)?.as_owner()?;\n         let node = owner.node();\n-        Some(Owner { node, hash_without_bodies: owner.nodes.hash_without_bodies })\n+        Some(Owner { node })\n     };\n     providers.opt_local_def_id_to_hir_id = |tcx, id| {\n         let owner = tcx.hir_crate(()).owners[id].map(|_| ());\n@@ -177,7 +177,6 @@ pub fn provide(providers: &mut Providers) {\n         }\n     };\n     providers.opt_def_kind = |tcx, def_id| tcx.hir().opt_def_kind(def_id.expect_local());\n-    providers.opt_rpitit_info = |_, _| None;\n     providers.all_local_trait_impls = |tcx, ()| &tcx.resolutions(()).trait_impls;\n     providers.expn_that_defined = |tcx, id| {\n         let id = id.expect_local();"}, {"sha": "45c4a1057d2dfc1971c36fd0adb7636591381457", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -109,4 +109,4 @@ pub mod util {\n // Allows macros to refer to this crate as `::rustc_middle`\n extern crate self as rustc_middle;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }"}, {"sha": "7d515bb0f5a4630adf445622478b1f5181b89b92", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 38, "deletions": 41, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -401,8 +401,6 @@ impl<'tcx> Body<'tcx> {\n             LocalKind::ReturnPointer\n         } else if index < self.arg_count + 1 {\n             LocalKind::Arg\n-        } else if self.local_decls[local].is_user_variable() {\n-            LocalKind::Var\n         } else {\n             LocalKind::Temp\n         }\n@@ -572,6 +570,13 @@ impl<T> ClearCrossCrate<T> {\n         }\n     }\n \n+    pub fn as_mut(&mut self) -> ClearCrossCrate<&mut T> {\n+        match self {\n+            ClearCrossCrate::Clear => ClearCrossCrate::Clear,\n+            ClearCrossCrate::Set(v) => ClearCrossCrate::Set(v),\n+        }\n+    }\n+\n     pub fn assert_crate_local(self) -> T {\n         match self {\n             ClearCrossCrate::Clear => bug!(\"unwrapping cross-crate data\"),\n@@ -661,9 +666,7 @@ impl Atom for Local {\n /// Classifies locals into categories. See `Body::local_kind`.\n #[derive(Clone, Copy, PartialEq, Eq, Debug, HashStable)]\n pub enum LocalKind {\n-    /// User-declared variable binding.\n-    Var,\n-    /// Compiler-introduced temporary.\n+    /// User-declared variable binding or compiler-introduced temporary.\n     Temp,\n     /// Function argument.\n     Arg,\n@@ -760,7 +763,7 @@ pub struct LocalDecl<'tcx> {\n     pub mutability: Mutability,\n \n     // FIXME(matthewjasper) Don't store in this in `Body`\n-    pub local_info: Option<Box<LocalInfo<'tcx>>>,\n+    pub local_info: ClearCrossCrate<Box<LocalInfo<'tcx>>>,\n \n     /// `true` if this is an internal local.\n     ///\n@@ -778,13 +781,6 @@ pub struct LocalDecl<'tcx> {\n     /// generator.\n     pub internal: bool,\n \n-    /// If this local is a temporary and `is_block_tail` is `Some`,\n-    /// then it is a temporary created for evaluation of some\n-    /// subexpression of some block's tail expression (with no\n-    /// intervening statement context).\n-    // FIXME(matthewjasper) Don't store in this in `Body`\n-    pub is_block_tail: Option<BlockTailInfo>,\n-\n     /// The type of this local.\n     pub ty: Ty<'tcx>,\n \n@@ -890,21 +886,31 @@ pub enum LocalInfo<'tcx> {\n     /// The `BindingForm` is solely used for local diagnostics when generating\n     /// warnings/errors when compiling the current crate, and therefore it need\n     /// not be visible across crates.\n-    User(ClearCrossCrate<BindingForm<'tcx>>),\n+    User(BindingForm<'tcx>),\n     /// A temporary created that references the static with the given `DefId`.\n     StaticRef { def_id: DefId, is_thread_local: bool },\n     /// A temporary created that references the const with the given `DefId`\n     ConstRef { def_id: DefId },\n     /// A temporary created during the creation of an aggregate\n     /// (e.g. a temporary for `foo` in `MyStruct { my_field: foo }`)\n     AggregateTemp,\n+    /// A temporary created for evaluation of some subexpression of some block's tail expression\n+    /// (with no intervening statement context).\n+    // FIXME(matthewjasper) Don't store in this in `Body`\n+    BlockTailTemp(BlockTailInfo),\n     /// A temporary created during the pass `Derefer` to avoid it's retagging\n     DerefTemp,\n     /// A temporary created for borrow checking.\n     FakeBorrow,\n+    /// A local without anything interesting about it.\n+    Boring,\n }\n \n impl<'tcx> LocalDecl<'tcx> {\n+    pub fn local_info(&self) -> &LocalInfo<'tcx> {\n+        &**self.local_info.as_ref().assert_crate_local()\n+    }\n+\n     /// Returns `true` only if local is a binding that can itself be\n     /// made mutable via the addition of the `mut` keyword, namely\n     /// something like the occurrences of `x` in:\n@@ -913,15 +919,15 @@ impl<'tcx> LocalDecl<'tcx> {\n     /// - or `match ... { C(x) => ... }`\n     pub fn can_be_made_mutable(&self) -> bool {\n         matches!(\n-            self.local_info,\n-            Some(box LocalInfo::User(ClearCrossCrate::Set(\n+            self.local_info(),\n+            LocalInfo::User(\n                 BindingForm::Var(VarBindingForm {\n                     binding_mode: ty::BindingMode::BindByValue(_),\n                     opt_ty_info: _,\n                     opt_match_place: _,\n                     pat_span: _,\n                 }) | BindingForm::ImplicitSelf(ImplicitSelfKind::Imm),\n-            )))\n+            )\n         )\n     }\n \n@@ -930,54 +936,51 @@ impl<'tcx> LocalDecl<'tcx> {\n     /// mutable bindings, but the inverse does not necessarily hold).\n     pub fn is_nonref_binding(&self) -> bool {\n         matches!(\n-            self.local_info,\n-            Some(box LocalInfo::User(ClearCrossCrate::Set(\n+            self.local_info(),\n+            LocalInfo::User(\n                 BindingForm::Var(VarBindingForm {\n                     binding_mode: ty::BindingMode::BindByValue(_),\n                     opt_ty_info: _,\n                     opt_match_place: _,\n                     pat_span: _,\n                 }) | BindingForm::ImplicitSelf(_),\n-            )))\n+            )\n         )\n     }\n \n     /// Returns `true` if this variable is a named variable or function\n     /// parameter declared by the user.\n     #[inline]\n     pub fn is_user_variable(&self) -> bool {\n-        matches!(self.local_info, Some(box LocalInfo::User(_)))\n+        matches!(self.local_info(), LocalInfo::User(_))\n     }\n \n     /// Returns `true` if this is a reference to a variable bound in a `match`\n     /// expression that is used to access said variable for the guard of the\n     /// match arm.\n     pub fn is_ref_for_guard(&self) -> bool {\n-        matches!(\n-            self.local_info,\n-            Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::RefForGuard)))\n-        )\n+        matches!(self.local_info(), LocalInfo::User(BindingForm::RefForGuard))\n     }\n \n     /// Returns `Some` if this is a reference to a static item that is used to\n     /// access that static.\n     pub fn is_ref_to_static(&self) -> bool {\n-        matches!(self.local_info, Some(box LocalInfo::StaticRef { .. }))\n+        matches!(self.local_info(), LocalInfo::StaticRef { .. })\n     }\n \n     /// Returns `Some` if this is a reference to a thread-local static item that is used to\n     /// access that static.\n     pub fn is_ref_to_thread_local(&self) -> bool {\n-        match self.local_info {\n-            Some(box LocalInfo::StaticRef { is_thread_local, .. }) => is_thread_local,\n+        match self.local_info() {\n+            LocalInfo::StaticRef { is_thread_local, .. } => *is_thread_local,\n             _ => false,\n         }\n     }\n \n     /// Returns `true` if this is a DerefTemp\n     pub fn is_deref_temp(&self) -> bool {\n-        match self.local_info {\n-            Some(box LocalInfo::DerefTemp) => return true,\n+        match self.local_info() {\n+            LocalInfo::DerefTemp => return true,\n             _ => (),\n         }\n         return false;\n@@ -1001,9 +1004,8 @@ impl<'tcx> LocalDecl<'tcx> {\n     pub fn with_source_info(ty: Ty<'tcx>, source_info: SourceInfo) -> Self {\n         LocalDecl {\n             mutability: Mutability::Mut,\n-            local_info: None,\n+            local_info: ClearCrossCrate::Set(Box::new(LocalInfo::Boring)),\n             internal: false,\n-            is_block_tail: None,\n             ty,\n             user_ty: None,\n             source_info,\n@@ -1023,14 +1025,6 @@ impl<'tcx> LocalDecl<'tcx> {\n         self.mutability = Mutability::Not;\n         self\n     }\n-\n-    /// Converts `self` into same `LocalDecl` except tagged as internal temporary.\n-    #[inline]\n-    pub fn block_tail(mut self, info: BlockTailInfo) -> Self {\n-        assert!(self.is_block_tail.is_none());\n-        self.is_block_tail = Some(info);\n-        self\n-    }\n }\n \n #[derive(Clone, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n@@ -1999,6 +1993,9 @@ impl BorrowKind {\n }\n \n impl BinOp {\n+    /// The checkable operators are those whose overflow checking behavior is controlled by\n+    /// -Coverflow-checks option. The remaining operators have either no overflow conditions (e.g.,\n+    /// BitAnd, BitOr, BitXor) or are always checked for overflow (e.g., Div, Rem).\n     pub fn is_checkable(self) -> bool {\n         use self::BinOp::*;\n         matches!(self, Add | Sub | Mul | Shl | Shr)\n@@ -3088,7 +3085,7 @@ mod size_asserts {\n     use rustc_data_structures::static_assert_size;\n     // tidy-alphabetical-start\n     static_assert_size!(BasicBlockData<'_>, 144);\n-    static_assert_size!(LocalDecl<'_>, 56);\n+    static_assert_size!(LocalDecl<'_>, 40);\n     static_assert_size!(Statement<'_>, 32);\n     static_assert_size!(StatementKind<'_>, 16);\n     static_assert_size!(Terminator<'_>, 112);"}, {"sha": "eb860c04de203a559de2a79cfa992f27456aff62", "filename": "compiler/rustc_middle/src/mir/patch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpatch.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -72,12 +72,12 @@ impl<'tcx> MirPatch<'tcx> {\n         &mut self,\n         ty: Ty<'tcx>,\n         span: Span,\n-        local_info: Option<Box<LocalInfo<'tcx>>>,\n+        local_info: LocalInfo<'tcx>,\n     ) -> Local {\n         let index = self.next_local;\n         self.next_local += 1;\n         let mut new_decl = LocalDecl::new(ty, span).internal();\n-        new_decl.local_info = local_info;\n+        **new_decl.local_info.as_mut().assert_crate_local() = local_info;\n         self.new_locals.push(new_decl);\n         Local::new(index as usize)\n     }"}, {"sha": "7e51953599d5a17fdf7b8a27669bd3086a5029f3", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -123,6 +123,7 @@ fn dump_matched_mir_node<'tcx, F>(\n         // see notes on #41697 above\n         let def_path =\n             ty::print::with_forced_impl_filename_line!(tcx.def_path_str(body.source.def_id()));\n+        // ignore-tidy-odd-backticks the literal below is fine\n         write!(file, \"// MIR for `{}\", def_path)?;\n         match body.source.promoted {\n             None => write!(file, \"`\")?,"}, {"sha": "cffdd7ff37f220d720d5c2cc05e72652457cd111", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -804,7 +804,6 @@ macro_rules! make_mir_visitor {\n                     source_info,\n                     internal: _,\n                     local_info: _,\n-                    is_block_tail: _,\n                 } = local_decl;\n \n                 self.visit_ty($(& $mutability)? *ty, TyContext::LocalDecl {"}, {"sha": "75f05c4af23da2670f0d1f2d80478ae057664f07", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -26,6 +26,15 @@ rustc_queries! {\n         desc { \"triggering a delay span bug\" }\n     }\n \n+    query registered_tools(_: ()) -> &'tcx ty::RegisteredTools {\n+        arena_cache\n+        desc { \"compute registered tools for crate\" }\n+    }\n+\n+    query early_lint_checks(_: ()) -> () {\n+        desc { \"perform lints prior to macro expansion\" }\n+    }\n+\n     query resolutions(_: ()) -> &'tcx ty::ResolverGlobalCtxt {\n         feedable\n         no_hash\n@@ -1152,14 +1161,6 @@ rustc_queries! {\n         feedable\n     }\n \n-    /// The `opt_rpitit_info` query returns the pair of the def id of the function where the RPIT\n-    /// is defined and the opaque def id if any.\n-    query opt_rpitit_info(def_id: DefId) -> Option<ty::ImplTraitInTraitData> {\n-        desc { |tcx| \"opt_rpitit_info `{}`\", tcx.def_path_str(def_id) }\n-        cache_on_disk_if { def_id.is_local() }\n-        feedable\n-    }\n-\n     /// Gets the span for the definition.\n     query def_span(def_id: DefId) -> Span {\n         desc { |tcx| \"looking up span for `{}`\", tcx.def_path_str(def_id) }\n@@ -1324,6 +1325,7 @@ rustc_queries! {\n     /// might want to use `reveal_all()` method to change modes.\n     query param_env(def_id: DefId) -> ty::ParamEnv<'tcx> {\n         desc { |tcx| \"computing normalized predicates of `{}`\", tcx.def_path_str(def_id) }\n+        feedable\n     }\n \n     /// Like `param_env`, but returns the `ParamEnv` in `Reveal::All` mode."}, {"sha": "92d3e73e683cd832ec640ab1f3a6ed332795aca0", "filename": "compiler/rustc_middle/src/traits/solve.rs", "status": "modified", "additions": 94, "deletions": 2, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,12 +1,104 @@\n use std::ops::ControlFlow;\n \n use rustc_data_structures::intern::Interned;\n+use rustc_query_system::cache::Cache;\n \n-use crate::infer::canonical::QueryRegionConstraints;\n+use crate::infer::canonical::{CanonicalVarValues, QueryRegionConstraints};\n+use crate::traits::query::NoSolution;\n+use crate::traits::Canonical;\n use crate::ty::{\n-    FallibleTypeFolder, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeVisitable, TypeVisitor,\n+    self, FallibleTypeFolder, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeVisitable,\n+    TypeVisitor,\n };\n \n+pub type EvaluationCache<'tcx> = Cache<CanonicalGoal<'tcx>, QueryResult<'tcx>>;\n+\n+/// A goal is a statement, i.e. `predicate`, we want to prove\n+/// given some assumptions, i.e. `param_env`.\n+///\n+/// Most of the time the `param_env` contains the `where`-bounds of the function\n+/// we're currently typechecking while the `predicate` is some trait bound.\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub struct Goal<'tcx, P> {\n+    pub param_env: ty::ParamEnv<'tcx>,\n+    pub predicate: P,\n+}\n+\n+impl<'tcx, P> Goal<'tcx, P> {\n+    pub fn new(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: impl ToPredicate<'tcx, P>,\n+    ) -> Goal<'tcx, P> {\n+        Goal { param_env, predicate: predicate.to_predicate(tcx) }\n+    }\n+\n+    /// Updates the goal to one with a different `predicate` but the same `param_env`.\n+    pub fn with<Q>(self, tcx: TyCtxt<'tcx>, predicate: impl ToPredicate<'tcx, Q>) -> Goal<'tcx, Q> {\n+        Goal { param_env: self.param_env, predicate: predicate.to_predicate(tcx) }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub struct Response<'tcx> {\n+    pub var_values: CanonicalVarValues<'tcx>,\n+    /// Additional constraints returned by this query.\n+    pub external_constraints: ExternalConstraints<'tcx>,\n+    pub certainty: Certainty,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub enum Certainty {\n+    Yes,\n+    Maybe(MaybeCause),\n+}\n+\n+impl Certainty {\n+    pub const AMBIGUOUS: Certainty = Certainty::Maybe(MaybeCause::Ambiguity);\n+\n+    /// When proving multiple goals using **AND**, e.g. nested obligations for an impl,\n+    /// use this function to unify the certainty of these goals\n+    pub fn unify_and(self, other: Certainty) -> Certainty {\n+        match (self, other) {\n+            (Certainty::Yes, Certainty::Yes) => Certainty::Yes,\n+            (Certainty::Yes, Certainty::Maybe(_)) => other,\n+            (Certainty::Maybe(_), Certainty::Yes) => self,\n+            (Certainty::Maybe(MaybeCause::Overflow), Certainty::Maybe(MaybeCause::Overflow)) => {\n+                Certainty::Maybe(MaybeCause::Overflow)\n+            }\n+            // If at least one of the goals is ambiguous, hide the overflow as the ambiguous goal\n+            // may still result in failure.\n+            (Certainty::Maybe(MaybeCause::Ambiguity), Certainty::Maybe(_))\n+            | (Certainty::Maybe(_), Certainty::Maybe(MaybeCause::Ambiguity)) => {\n+                Certainty::Maybe(MaybeCause::Ambiguity)\n+            }\n+        }\n+    }\n+}\n+\n+/// Why we failed to evaluate a goal.\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub enum MaybeCause {\n+    /// We failed due to ambiguity. This ambiguity can either\n+    /// be a true ambiguity, i.e. there are multiple different answers,\n+    /// or we hit a case where we just don't bother, e.g. `?x: Trait` goals.\n+    Ambiguity,\n+    /// We gave up due to an overflow, most often by hitting the recursion limit.\n+    Overflow,\n+}\n+\n+pub type CanonicalGoal<'tcx, T = ty::Predicate<'tcx>> = Canonical<'tcx, Goal<'tcx, T>>;\n+\n+pub type CanonicalResponse<'tcx> = Canonical<'tcx, Response<'tcx>>;\n+\n+/// The result of evaluating a canonical query.\n+///\n+/// FIXME: We use a different type than the existing canonical queries. This is because\n+/// we need to add a `Certainty` for `overflow` and may want to restructure this code without\n+/// having to worry about changes to currently used code. Once we've made progress on this\n+/// solver, merge the two responses again.\n+pub type QueryResult<'tcx> = Result<CanonicalResponse<'tcx>, NoSolution>;\n+\n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n pub struct ExternalConstraints<'tcx>(pub(crate) Interned<'tcx, ExternalConstraintsData<'tcx>>);\n "}, {"sha": "090b769323add1f004850217f53817e413b1ebe1", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -30,6 +30,11 @@ pub struct AssocItem {\n     /// Whether this is a method with an explicit self\n     /// as its first parameter, allowing method calls.\n     pub fn_has_self_parameter: bool,\n+\n+    /// `Some` if the associated item (an associated type) comes from the\n+    /// return-position `impl Trait` in trait desugaring. The `ImplTraitInTraitData`\n+    /// provides additional information about its source.\n+    pub opt_rpitit_info: Option<ty::ImplTraitInTraitData>,\n }\n \n impl AssocItem {"}, {"sha": "42101f6b93152a446030f803285b5c29f101f38d", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -135,6 +135,9 @@ impl<'tcx> Const<'tcx> {\n                 _,\n                 &hir::Path { res: Res::Def(DefKind::ConstParam, def_id), .. },\n             )) => {\n+                // Use the type from the param's definition, since we can resolve it,\n+                // not the expected parameter type from WithOptConstParam.\n+                let param_ty = tcx.type_of(def_id).subst_identity();\n                 match tcx.named_bound_var(expr.hir_id) {\n                     Some(rbv::ResolvedArg::EarlyBound(_)) => {\n                         // Find the name and index of the const parameter by indexing the generics of\n@@ -143,14 +146,14 @@ impl<'tcx> Const<'tcx> {\n                         let generics = tcx.generics_of(item_def_id);\n                         let index = generics.param_def_id_to_index[&def_id];\n                         let name = tcx.item_name(def_id);\n-                        Some(tcx.mk_const(ty::ParamConst::new(index, name), ty))\n+                        Some(tcx.mk_const(ty::ParamConst::new(index, name), param_ty))\n                     }\n                     Some(rbv::ResolvedArg::LateBound(debruijn, index, _)) => Some(tcx.mk_const(\n                         ty::ConstKind::Bound(debruijn, ty::BoundVar::from_u32(index)),\n-                        ty,\n+                        param_ty,\n                     )),\n                     Some(rbv::ResolvedArg::Error(guar)) => {\n-                        Some(tcx.const_error_with_guaranteed(ty, guar))\n+                        Some(tcx.const_error_with_guaranteed(param_ty, guar))\n                     }\n                     arg => bug!(\"unexpected bound var resolution for {:?}: {arg:?}\", expr.hir_id),\n                 }"}, {"sha": "d5ba0785fa6d4fa3aaf4686fa9e2ce4056115b86", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -17,6 +17,7 @@ use crate::mir::{\n };\n use crate::thir::Thir;\n use crate::traits;\n+use crate::traits::solve;\n use crate::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::{\n@@ -537,6 +538,9 @@ pub struct GlobalCtxt<'tcx> {\n     /// Merge this with `selection_cache`?\n     pub evaluation_cache: traits::EvaluationCache<'tcx>,\n \n+    /// Caches the results of goal evaluation in the new solver.\n+    pub new_solver_evaluation_cache: solve::EvaluationCache<'tcx>,\n+\n     /// Data layout specification for the current target.\n     pub data_layout: TargetDataLayout,\n \n@@ -712,6 +716,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             pred_rcache: Default::default(),\n             selection_cache: Default::default(),\n             evaluation_cache: Default::default(),\n+            new_solver_evaluation_cache: Default::default(),\n             data_layout,\n             alloc_map: Lock::new(interpret::AllocMap::new()),\n         }\n@@ -2440,6 +2445,18 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn trait_solver_next(self) -> bool {\n         self.sess.opts.unstable_opts.trait_solver == rustc_session::config::TraitSolver::Next\n     }\n+\n+    pub fn lower_impl_trait_in_trait_to_assoc_ty(self) -> bool {\n+        self.sess.opts.unstable_opts.lower_impl_trait_in_trait_to_assoc_ty\n+    }\n+\n+    pub fn is_impl_trait_in_trait(self, def_id: DefId) -> bool {\n+        if self.lower_impl_trait_in_trait_to_assoc_ty() {\n+            self.opt_rpitit_info(def_id).is_some()\n+        } else {\n+            self.def_kind(def_id) == DefKind::ImplTraitPlaceholder\n+        }\n+    }\n }\n \n impl<'tcx> TyCtxtAt<'tcx> {"}, {"sha": "aff6c77e039af5e8b3d5e41426c1012a9d30fd13", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -151,12 +151,8 @@ impl<'tcx> TypeError<'tcx> {\n             .into(),\n             RegionsPlaceholderMismatch => \"one type is more general than the other\".into(),\n             ArgumentSorts(values, _) | Sorts(values) => {\n-                let mut expected = values.expected.sort_string(tcx);\n-                let mut found = values.found.sort_string(tcx);\n-                if expected == found {\n-                    expected = values.expected.sort_string(tcx);\n-                    found = values.found.sort_string(tcx);\n-                }\n+                let expected = values.expected.sort_string(tcx);\n+                let found = values.found.sort_string(tcx);\n                 report_maybe_different(&expected, &found).into()\n             }\n             Traits(values) => {"}, {"sha": "ee505742be9a039e4a7c125cc30542337e66120e", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 39, "deletions": 24, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -51,15 +51,35 @@ pub enum SimplifiedType {\n /// generic parameters as if they were inference variables in that case.\n #[derive(PartialEq, Eq, Debug, Clone, Copy)]\n pub enum TreatParams {\n-    /// Treat parameters as placeholders in the given environment.\n+    /// Treat parameters as infer vars. This is the correct mode for caching\n+    /// an impl's type for lookup.\n+    AsCandidateKey,\n+    /// Treat parameters as placeholders in the given environment. This is the\n+    /// correct mode for *lookup*, as during candidate selection.\n+    ForLookup,\n+}\n+\n+/// During fast-rejection, we have the choice of treating projection types\n+/// as either simplifyable or not, depending on whether we expect the projection\n+/// to be normalized/rigid.\n+#[derive(PartialEq, Eq, Debug, Clone, Copy)]\n+pub enum TreatProjections {\n+    /// In candidates, we may be able to normalize the projection\n+    /// after instantiating the candidate and equating it with a goal.\n     ///\n-    /// Note that this also causes us to treat projections as if they were\n-    /// placeholders. This is only correct if the given projection cannot\n-    /// be normalized in the current context. Even if normalization fails,\n-    /// it may still succeed later if the projection contains any inference\n-    /// variables.\n-    AsPlaceholder,\n-    AsInfer,\n+    /// We must assume that the `impl<T> Trait<T> for <T as Id>::This`\n+    /// can apply to all self types so we don't return a simplified type\n+    /// for `<T as Id>::This`.\n+    AsCandidateKey,\n+    /// In the old solver we don't try to normalize projections\n+    /// when looking up impls and only access them by using the\n+    /// current self type. This means that if the self type is\n+    /// a projection which could later be normalized, we must not\n+    /// treat it as rigid.\n+    ForLookup,\n+    /// We can treat projections in the self type as opaque as\n+    /// we separately look up impls for the normalized self type.\n+    NextSolverLookup,\n }\n \n /// Tries to simplify a type by only returning the outermost injective\u00b9 layer, if one exists.\n@@ -87,6 +107,7 @@ pub fn simplify_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     treat_params: TreatParams,\n+    treat_projections: TreatProjections,\n ) -> Option<SimplifiedType> {\n     match *ty.kind() {\n         ty::Bool => Some(BoolSimplifiedType),\n@@ -115,19 +136,13 @@ pub fn simplify_type<'tcx>(\n         ty::FnPtr(f) => Some(FunctionSimplifiedType(f.skip_binder().inputs().len())),\n         ty::Placeholder(..) => Some(PlaceholderSimplifiedType),\n         ty::Param(_) => match treat_params {\n-            TreatParams::AsPlaceholder => Some(PlaceholderSimplifiedType),\n-            TreatParams::AsInfer => None,\n+            TreatParams::ForLookup => Some(PlaceholderSimplifiedType),\n+            TreatParams::AsCandidateKey => None,\n         },\n-        ty::Alias(..) => match treat_params {\n-            // When treating `ty::Param` as a placeholder, projections also\n-            // don't unify with anything else as long as they are fully normalized.\n-            //\n-            // We will have to be careful with lazy normalization here.\n-            TreatParams::AsPlaceholder if !ty.has_non_region_infer() => {\n-                debug!(\"treating `{}` as a placeholder\", ty);\n-                Some(PlaceholderSimplifiedType)\n-            }\n-            TreatParams::AsPlaceholder | TreatParams::AsInfer => None,\n+        ty::Alias(..) => match treat_projections {\n+            TreatProjections::ForLookup if !ty.needs_infer() => Some(PlaceholderSimplifiedType),\n+            TreatProjections::NextSolverLookup => Some(PlaceholderSimplifiedType),\n+            TreatProjections::AsCandidateKey | TreatProjections::ForLookup => None,\n         },\n         ty::Foreign(def_id) => Some(ForeignSimplifiedType(def_id)),\n         ty::Bound(..) | ty::Infer(_) | ty::Error(_) => None,\n@@ -295,8 +310,8 @@ impl DeepRejectCtxt {\n             // Depending on the value of `treat_obligation_params`, we either\n             // treat generic parameters like placeholders or like inference variables.\n             ty::Param(_) => match self.treat_obligation_params {\n-                TreatParams::AsPlaceholder => false,\n-                TreatParams::AsInfer => true,\n+                TreatParams::ForLookup => false,\n+                TreatParams::AsCandidateKey => true,\n             },\n \n             ty::Infer(_) => true,\n@@ -333,8 +348,8 @@ impl DeepRejectCtxt {\n         let k = impl_ct.kind();\n         match obligation_ct.kind() {\n             ty::ConstKind::Param(_) => match self.treat_obligation_params {\n-                TreatParams::AsPlaceholder => false,\n-                TreatParams::AsInfer => true,\n+                TreatParams::ForLookup => false,\n+                TreatParams::AsCandidateKey => true,\n             },\n \n             // As we don't necessarily eagerly evaluate constants,"}, {"sha": "04d7de531c26b3630e681c09d3d6e9b71ef92aad", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -34,6 +34,7 @@ use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::steal::Steal;\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n@@ -44,6 +45,8 @@ use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_serialize::{Decodable, Encodable};\n+use rustc_session::lint::LintBuffer;\n+pub use rustc_session::lint::RegisteredTools;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{ExpnId, ExpnKind, Span};\n@@ -148,8 +151,6 @@ mod typeck_results;\n \n // Data types\n \n-pub type RegisteredTools = FxHashSet<Ident>;\n-\n pub struct ResolverOutputs {\n     pub global_ctxt: ResolverGlobalCtxt,\n     pub ast_lowering: ResolverAstLowering,\n@@ -175,7 +176,6 @@ pub struct ResolverGlobalCtxt {\n     /// Mapping from ident span to path span for paths that don't exist as written, but that\n     /// exist under `std`. For example, wrote `str::from_utf8` instead of `std::str::from_utf8`.\n     pub confused_type_with_std_module: FxHashMap<Span, Span>,\n-    pub registered_tools: RegisteredTools,\n     pub doc_link_resolutions: FxHashMap<LocalDefId, DocLinkResMap>,\n     pub doc_link_traits_in_scope: FxHashMap<LocalDefId, Vec<DefId>>,\n     pub all_macro_rules: FxHashMap<Symbol, Res<ast::NodeId>>,\n@@ -209,6 +209,9 @@ pub struct ResolverAstLowering {\n     pub builtin_macro_kinds: FxHashMap<LocalDefId, MacroKind>,\n     /// List functions and methods for which lifetime elision was successful.\n     pub lifetime_elision_allowed: FxHashSet<ast::NodeId>,\n+\n+    /// Lints that were emitted by the resolver and early lints.\n+    pub lint_buffer: Steal<LintBuffer>,\n }\n \n #[derive(Clone, Copy, Debug)]\n@@ -995,7 +998,7 @@ impl<'tcx> Term<'tcx> {\n \n     pub fn is_infer(&self) -> bool {\n         match self.unpack() {\n-            TermKind::Ty(ty) => ty.is_ty_or_numeric_infer(),\n+            TermKind::Ty(ty) => ty.is_ty_var(),\n             TermKind::Const(ct) => ct.is_ct_infer(),\n         }\n     }\n@@ -2067,7 +2070,9 @@ pub enum ImplOverlapKind {\n     Issue33140,\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+/// Useful source information about where a desugared associated type for an\n+/// RPITIT originated from.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Encodable, Decodable, HashStable)]\n pub enum ImplTraitInTraitData {\n     Trait { fn_def_id: DefId, opaque_def_id: DefId },\n     Impl { fn_def_id: DefId },\n@@ -2210,6 +2215,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    /// If the def-id is an associated type that was desugared from a\n+    /// return-position `impl Trait` from a trait, then provide the source info\n+    /// about where that RPITIT came from.\n+    pub fn opt_rpitit_info(self, def_id: DefId) -> Option<ImplTraitInTraitData> {\n+        if let DefKind::AssocTy = self.def_kind(def_id) {\n+            self.associated_item(def_id).opt_rpitit_info\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn find_field_index(self, ident: Ident, variant: &VariantDef) -> Option<usize> {\n         variant\n             .fields"}, {"sha": "05219efe5f54d06c1e4be37dd90794c9c5d143e4", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -99,6 +99,11 @@ pub struct TyCtxtEnsure<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n }\n \n+#[derive(Copy, Clone)]\n+pub struct TyCtxtEnsureWithValue<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+}\n+\n impl<'tcx> TyCtxt<'tcx> {\n     /// Returns a transparent wrapper for `TyCtxt`, which ensures queries\n     /// are executed instead of just returning their results.\n@@ -107,6 +112,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         TyCtxtEnsure { tcx: self }\n     }\n \n+    /// Returns a transparent wrapper for `TyCtxt`, which ensures queries\n+    /// are executed instead of just returning their results.\n+    ///\n+    /// This version verifies that the computed result exists in the cache before returning.\n+    #[inline(always)]\n+    pub fn ensure_with_value(self) -> TyCtxtEnsureWithValue<'tcx> {\n+        TyCtxtEnsureWithValue { tcx: self }\n+    }\n+\n     /// Returns a transparent wrapper for `TyCtxt` which uses\n     /// `span` as the location of queries performed through it.\n     #[inline(always)]\n@@ -252,6 +266,36 @@ macro_rules! define_callbacks {\n             )*\n         }\n \n+        $(\n+            // Ensure that keys grow no larger than 64 bytes\n+            #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+            const _: () = {\n+                if mem::size_of::<query_keys::$name<'static>>() > 64 {\n+                    panic!(\"{}\", concat!(\n+                        \"the query `\",\n+                        stringify!($name),\n+                        \"` has a key type `\",\n+                        stringify!($($K)*),\n+                        \"` that is too large\"\n+                    ));\n+                }\n+            };\n+\n+            // Ensure that values grow no larger than 64 bytes\n+            #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+            const _: () = {\n+                if mem::size_of::<query_values::$name<'static>>() > 64 {\n+                    panic!(\"{}\", concat!(\n+                        \"the query `\",\n+                        stringify!($name),\n+                        \"` has a value type `\",\n+                        stringify!($V),\n+                        \"` that is too large\"\n+                    ));\n+                }\n+            };\n+        )*\n+\n         pub struct QueryArenas<'tcx> {\n             $($(#[$attr])* pub $name: query_if_arena!([$($modifiers)*]\n                 (WorkerLocal<TypedArena<<$V as Deref>::Target>>)\n@@ -284,7 +328,31 @@ macro_rules! define_callbacks {\n \n                 match try_get_cached(self.tcx, &self.tcx.query_system.caches.$name, &key) {\n                     Some(_) => return,\n-                    None => self.tcx.queries.$name(self.tcx, DUMMY_SP, key, QueryMode::Ensure),\n+                    None => self.tcx.queries.$name(\n+                        self.tcx,\n+                        DUMMY_SP,\n+                        key,\n+                        QueryMode::Ensure { check_cache: false },\n+                    ),\n+                };\n+            })*\n+        }\n+\n+        impl<'tcx> TyCtxtEnsureWithValue<'tcx> {\n+            $($(#[$attr])*\n+            #[inline(always)]\n+            pub fn $name(self, key: query_helper_param_ty!($($K)*)) {\n+                let key = key.into_query_param();\n+                opt_remap_env_constness!([$($modifiers)*][key]);\n+\n+                match try_get_cached(self.tcx, &self.tcx.query_system.caches.$name, &key) {\n+                    Some(_) => return,\n+                    None => self.tcx.queries.$name(\n+                        self.tcx,\n+                        DUMMY_SP,\n+                        key,\n+                        QueryMode::Ensure { check_cache: true },\n+                    ),\n                 };\n             })*\n         }"}, {"sha": "bf2b121f704afcbcb55dd44ca800ab424ea9f84d", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,5 +1,5 @@\n use crate::traits::specialization_graph;\n-use crate::ty::fast_reject::{self, SimplifiedType, TreatParams};\n+use crate::ty::fast_reject::{self, SimplifiedType, TreatParams, TreatProjections};\n use crate::ty::visit::TypeVisitableExt;\n use crate::ty::{Ident, Ty, TyCtxt};\n use hir::def_id::LOCAL_CRATE;\n@@ -118,16 +118,32 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Iterate over every impl that could possibly match the self type `self_ty`.\n     ///\n     /// `trait_def_id` MUST BE the `DefId` of a trait.\n-    pub fn for_each_relevant_impl<F: FnMut(DefId)>(\n+    pub fn for_each_relevant_impl(\n         self,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n-        mut f: F,\n+        f: impl FnMut(DefId),\n     ) {\n-        let _: Option<()> = self.find_map_relevant_impl(trait_def_id, self_ty, |did| {\n-            f(did);\n-            None\n-        });\n+        self.for_each_relevant_impl_treating_projections(\n+            trait_def_id,\n+            self_ty,\n+            TreatProjections::ForLookup,\n+            f,\n+        )\n+    }\n+\n+    pub fn for_each_relevant_impl_treating_projections(\n+        self,\n+        trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+        treat_projections: TreatProjections,\n+        mut f: impl FnMut(DefId),\n+    ) {\n+        let _: Option<()> =\n+            self.find_map_relevant_impl(trait_def_id, self_ty, treat_projections, |did| {\n+                f(did);\n+                None\n+            });\n     }\n \n     /// `trait_def_id` MUST BE the `DefId` of a trait.\n@@ -137,7 +153,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         self_ty: Ty<'tcx>,\n     ) -> impl Iterator<Item = DefId> + 'tcx {\n         let impls = self.trait_impls_of(trait_def_id);\n-        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsInfer) {\n+        if let Some(simp) = fast_reject::simplify_type(\n+            self,\n+            self_ty,\n+            TreatParams::AsCandidateKey,\n+            TreatProjections::AsCandidateKey,\n+        ) {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 return impls.iter().copied();\n             }\n@@ -150,11 +171,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// the first non-none value.\n     ///\n     /// `trait_def_id` MUST BE the `DefId` of a trait.\n-    pub fn find_map_relevant_impl<T, F: FnMut(DefId) -> Option<T>>(\n+    pub fn find_map_relevant_impl<T>(\n         self,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n-        mut f: F,\n+        treat_projections: TreatProjections,\n+        mut f: impl FnMut(DefId) -> Option<T>,\n     ) -> Option<T> {\n         // FIXME: This depends on the set of all impls for the trait. That is\n         // unfortunate wrt. incremental compilation.\n@@ -169,14 +191,13 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         }\n \n-        // Note that we're using `TreatParams::AsPlaceholder` to query `non_blanket_impls` while using\n-        // `TreatParams::AsInfer` while actually adding them.\n-        //\n         // This way, when searching for some impl for `T: Trait`, we do not look at any impls\n         // whose outer level is not a parameter or projection. Especially for things like\n         // `T: Clone` this is incredibly useful as we would otherwise look at all the impls\n         // of `Clone` for `Option<T>`, `Vec<T>`, `ConcreteType` and so on.\n-        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsPlaceholder) {\n+        if let Some(simp) =\n+            fast_reject::simplify_type(self, self_ty, TreatParams::ForLookup, treat_projections)\n+        {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 for &impl_def_id in impls {\n                     if let result @ Some(_) = f(impl_def_id) {\n@@ -237,9 +258,12 @@ pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> Trait\n             continue;\n         }\n \n-        if let Some(simplified_self_ty) =\n-            fast_reject::simplify_type(tcx, impl_self_ty, TreatParams::AsInfer)\n-        {\n+        if let Some(simplified_self_ty) = fast_reject::simplify_type(\n+            tcx,\n+            impl_self_ty,\n+            TreatParams::AsCandidateKey,\n+            TreatProjections::AsCandidateKey,\n+        ) {\n             impls.non_blanket_impls.entry(simplified_self_ty).or_default().push(impl_def_id);\n         } else {\n             impls.blanket_impls.push(impl_def_id);"}, {"sha": "b0f6127baa5d42073b3d6b6ed49243bc23eabaed", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -2,6 +2,7 @@\n \n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::mir;\n+use crate::ty::fast_reject::TreatProjections;\n use crate::ty::layout::IntegerExt;\n use crate::ty::{\n     self, FallibleTypeFolder, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n@@ -363,14 +364,20 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.ensure().coherent_trait(drop_trait);\n \n         let ty = self.type_of(adt_did).subst_identity();\n-        let (did, constness) = self.find_map_relevant_impl(drop_trait, ty, |impl_did| {\n-            if let Some(item_id) = self.associated_item_def_ids(impl_did).first() {\n-                if validate(self, impl_did).is_ok() {\n-                    return Some((*item_id, self.constness(impl_did)));\n+        let (did, constness) = self.find_map_relevant_impl(\n+            drop_trait,\n+            ty,\n+            // FIXME: This could also be some other mode, like \"unexpected\"\n+            TreatProjections::ForLookup,\n+            |impl_did| {\n+                if let Some(item_id) = self.associated_item_def_ids(impl_did).first() {\n+                    if validate(self, impl_did).is_ok() {\n+                        return Some((*item_id, self.constness(impl_did)));\n+                    }\n                 }\n-            }\n-            None\n-        })?;\n+                None\n+            },\n+        )?;\n \n         Some(ty::Destructor { did, constness })\n     }"}, {"sha": "93e7fb330e093e165a6f38dd37701af5eb535874", "filename": "compiler/rustc_mir_build/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_build%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_build%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_mir_build/locales/en-US.ftl"}, {"sha": "6941da331fc58d9975fb1c5552236788f9d6b88f", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -20,7 +20,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<Operand<'tcx>> {\n         let local_scope = self.local_scope();\n-        self.as_operand(block, Some(local_scope), expr, None, NeedsTemporary::Maybe)\n+        self.as_operand(block, Some(local_scope), expr, LocalInfo::Boring, NeedsTemporary::Maybe)\n     }\n \n     /// Returns an operand suitable for use until the end of the current scope expression and\n@@ -102,7 +102,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         mut block: BasicBlock,\n         scope: Option<region::Scope>,\n         expr: &Expr<'tcx>,\n-        local_info: Option<Box<LocalInfo<'tcx>>>,\n+        local_info: LocalInfo<'tcx>,\n         needs_temporary: NeedsTemporary,\n     ) -> BlockAnd<Operand<'tcx>> {\n         let this = self;\n@@ -124,8 +124,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             Category::Constant | Category::Place | Category::Rvalue(..) => {\n                 let operand = unpack!(block = this.as_temp(block, scope, expr, Mutability::Mut));\n-                if this.local_decls[operand].local_info.is_none() {\n-                    this.local_decls[operand].local_info = local_info;\n+                // Overwrite temp local info if we have something more interesting to record.\n+                if !matches!(local_info, LocalInfo::Boring) {\n+                    let decl_info = this.local_decls[operand].local_info.as_mut().assert_crate_local();\n+                    if let LocalInfo::Boring | LocalInfo::BlockTailTemp(_) = **decl_info {\n+                        **decl_info = local_info;\n+                    }\n                 }\n                 block.and(Operand::Move(Place::from(operand)))\n             }\n@@ -178,6 +182,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n-        this.as_operand(block, scope, expr, None, NeedsTemporary::Maybe)\n+        this.as_operand(block, scope, expr, LocalInfo::Boring, NeedsTemporary::Maybe)\n     }\n }"}, {"sha": "b8115f5aa186027c9267109f54e7a2cda0ff84fa", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -63,7 +63,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             block,\n                             scope,\n                             &this.thir[value],\n-                            None,\n+                            LocalInfo::Boring,\n                             NeedsTemporary::No\n                         )\n                     );\n@@ -73,18 +73,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             ExprKind::Binary { op, lhs, rhs } => {\n                 let lhs = unpack!(\n                     block =\n-                        this.as_operand(block, scope, &this.thir[lhs], None, NeedsTemporary::Maybe)\n+                        this.as_operand(block, scope, &this.thir[lhs], LocalInfo::Boring, NeedsTemporary::Maybe)\n                 );\n                 let rhs = unpack!(\n                     block =\n-                        this.as_operand(block, scope, &this.thir[rhs], None, NeedsTemporary::No)\n+                        this.as_operand(block, scope, &this.thir[rhs], LocalInfo::Boring, NeedsTemporary::No)\n                 );\n                 this.build_binary_op(block, op, expr_span, expr.ty, lhs, rhs)\n             }\n             ExprKind::Unary { op, arg } => {\n                 let arg = unpack!(\n                     block =\n-                        this.as_operand(block, scope, &this.thir[arg], None, NeedsTemporary::No)\n+                        this.as_operand(block, scope, &this.thir[arg], LocalInfo::Boring, NeedsTemporary::No)\n                 );\n                 // Check for -MIN on signed integers\n                 if this.check_overflow && op == UnOp::Neg && expr.ty.is_signed() {\n@@ -259,7 +259,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 } else {\n                     let ty = source.ty;\n                     let source = unpack!(\n-                        block = this.as_operand(block, scope, source, None, NeedsTemporary::No)\n+                        block = this.as_operand(block, scope, source, LocalInfo::Boring, NeedsTemporary::No)\n                     );\n                     (source, ty)\n                 };\n@@ -272,7 +272,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             ExprKind::Pointer { cast, source } => {\n                 let source = unpack!(\n                     block =\n-                        this.as_operand(block, scope, &this.thir[source], None, NeedsTemporary::No)\n+                        this.as_operand(block, scope, &this.thir[source], LocalInfo::Boring, NeedsTemporary::No)\n                 );\n                 block.and(Rvalue::Cast(CastKind::Pointer(cast), source, expr.ty))\n             }\n@@ -314,7 +314,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 block,\n                                 scope,\n                                 &this.thir[f],\n-                                None,\n+                                LocalInfo::Boring,\n                                 NeedsTemporary::Maybe\n                             )\n                         )\n@@ -335,7 +335,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 block,\n                                 scope,\n                                 &this.thir[f],\n-                                None,\n+                                LocalInfo::Boring,\n                                 NeedsTemporary::Maybe\n                             )\n                         )\n@@ -423,7 +423,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                                 block,\n                                                 scope,\n                                                 upvar,\n-                                                None,\n+                                                LocalInfo::Boring,\n                                                 NeedsTemporary::Maybe\n                                             )\n                                         )\n@@ -502,7 +502,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     Some(Category::Rvalue(RvalueFunc::AsRvalue) | Category::Constant)\n                 ));\n                 let operand =\n-                    unpack!(block = this.as_operand(block, scope, expr, None, NeedsTemporary::No));\n+                    unpack!(block = this.as_operand(block, scope, expr, LocalInfo::Boring, NeedsTemporary::No));\n                 block.and(Rvalue::Use(operand))\n             }\n         }\n@@ -622,7 +622,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         } else {\n             // For a non-const, we may need to generate an appropriate `Drop`\n             let value_operand =\n-                unpack!(block = this.as_operand(block, scope, value, None, NeedsTemporary::No));\n+                unpack!(block = this.as_operand(block, scope, value, LocalInfo::Boring, NeedsTemporary::No));\n             if let Operand::Move(to_drop) = value_operand {\n                 let success = this.cfg.start_new_block();\n                 this.cfg.terminate("}, {"sha": "c8910c272b1bbfcd1bac25c7284bca3937abf978", "filename": "compiler/rustc_mir_build/src/build/expr/as_temp.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -49,29 +49,28 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             debug!(\"creating temp {:?} with block_context: {:?}\", local_decl, this.block_context);\n-            // Find out whether this temp is being created within the\n-            // tail expression of a block whose result is ignored.\n-            if let Some(tail_info) = this.block_context.currently_in_block_tail() {\n-                local_decl = local_decl.block_tail(tail_info);\n-            }\n-            match expr.kind {\n+            let local_info = match expr.kind {\n                 ExprKind::StaticRef { def_id, .. } => {\n                     assert!(!this.tcx.is_thread_local_static(def_id));\n                     local_decl.internal = true;\n-                    local_decl.local_info =\n-                        Some(Box::new(LocalInfo::StaticRef { def_id, is_thread_local: false }));\n+                    LocalInfo::StaticRef { def_id, is_thread_local: false }\n                 }\n                 ExprKind::ThreadLocalRef(def_id) => {\n                     assert!(this.tcx.is_thread_local_static(def_id));\n                     local_decl.internal = true;\n-                    local_decl.local_info =\n-                        Some(Box::new(LocalInfo::StaticRef { def_id, is_thread_local: true }));\n+                    LocalInfo::StaticRef { def_id, is_thread_local: true }\n                 }\n                 ExprKind::NamedConst { def_id, .. } | ExprKind::ConstParam { def_id, .. } => {\n-                    local_decl.local_info = Some(Box::new(LocalInfo::ConstRef { def_id }));\n+                    LocalInfo::ConstRef { def_id }\n                 }\n-                _ => {}\n-            }\n+                // Find out whether this temp is being created within the\n+                // tail expression of a block whose result is ignored.\n+                _ if let Some(tail_info) = this.block_context.currently_in_block_tail() => {\n+                    LocalInfo::BlockTailTemp(tail_info)\n+                }\n+                _ => LocalInfo::Boring,\n+            };\n+            **local_decl.local_info.as_mut().assert_crate_local() = local_info;\n             this.local_decls.push(local_decl)\n         };\n         let temp_place = Place::from(temp);"}, {"sha": "ebe8ea25ad3af04001fa781cac4d75868e1d8a5d", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -328,15 +328,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let fields_map: FxHashMap<_, _> = fields\n                     .into_iter()\n                     .map(|f| {\n-                        let local_info = Box::new(LocalInfo::AggregateTemp);\n                         (\n                             f.name,\n                             unpack!(\n                                 block = this.as_operand(\n                                     block,\n                                     Some(scope),\n                                     &this.thir[f.expr],\n-                                    Some(local_info),\n+                                    LocalInfo::AggregateTemp,\n                                     NeedsTemporary::Maybe,\n                                 )\n                             ),\n@@ -526,7 +525,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         block,\n                         Some(scope),\n                         &this.thir[value],\n-                        None,\n+                        LocalInfo::Boring,\n                         NeedsTemporary::No\n                     )\n                 );"}, {"sha": "22785dfd2ce0e18b13a157858cde04cd822cb86b", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -588,8 +588,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // let PATTERN = ... might not even exist until we do the assignment.\n         // so we set it here instead.\n         if set_match_place {\n-            let mut candidate_ref = &candidate;\n-            while let Some(next) = {\n+            let mut next = Some(&candidate);\n+            while let Some(candidate_ref) = next.take() {\n                 for binding in &candidate_ref.bindings {\n                     let local = self.var_local_id(binding.var_id, OutsideGuard);\n                     // `try_to_place` may fail if it is unable to resolve the given\n@@ -607,19 +607,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // };\n                     // ```\n                     if let Some(place) = initializer.try_to_place(self) {\n-                        let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                        let LocalInfo::User(BindingForm::Var(\n                             VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n-                        )))) = self.local_decls[local].local_info else {\n+                        )) = **self.local_decls[local].local_info.as_mut().assert_crate_local() else {\n                             bug!(\"Let binding to non-user variable.\")\n                         };\n                         *match_place = Some(place);\n                     }\n                 }\n                 // All of the subcandidates should bind the same locals, so we\n                 // only visit the first one.\n-                candidate_ref.subcandidates.get(0)\n-            } {\n-                candidate_ref = next;\n+                next = candidate_ref.subcandidates.get(0)\n             }\n         }\n \n@@ -1756,7 +1754,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let fake_borrow_ty = tcx.mk_imm_ref(tcx.lifetimes.re_erased, fake_borrow_deref_ty);\n                 let mut fake_borrow_temp = LocalDecl::new(fake_borrow_ty, temp_span);\n                 fake_borrow_temp.internal = self.local_decls[matched_place.local].internal;\n-                fake_borrow_temp.local_info = Some(Box::new(LocalInfo::FakeBorrow));\n+                fake_borrow_temp.local_info = ClearCrossCrate::Set(Box::new(LocalInfo::FakeBorrow));\n                 let fake_borrow_temp = self.local_decls.push(fake_borrow_temp);\n \n                 (matched_place, fake_borrow_temp)\n@@ -1888,6 +1886,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // let place = Foo::new();\n         // match place { Foo { .. } if { let tmp1 = &place; inspect(*tmp1) }\n         //     => { let tmp2 = place; feed(tmp2) }, ... }\n+        // ```\n         //\n         // And an input like:\n         //\n@@ -2225,8 +2224,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             user_ty: if user_ty.is_empty() { None } else { Some(Box::new(user_ty)) },\n             source_info,\n             internal: false,\n-            is_block_tail: None,\n-            local_info: Some(Box::new(LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+            local_info: ClearCrossCrate::Set(Box::new(LocalInfo::User(BindingForm::Var(\n                 VarBindingForm {\n                     binding_mode,\n                     // hypothetically, `visit_primary_bindings` could try to unzip\n@@ -2237,7 +2235,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     opt_match_place,\n                     pat_span,\n                 },\n-            ))))),\n+            )))),\n         };\n         let for_arm_body = self.local_decls.push(local);\n         self.var_debug_info.push(VarDebugInfo {\n@@ -2254,10 +2252,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 user_ty: None,\n                 source_info,\n                 internal: false,\n-                is_block_tail: None,\n-                local_info: Some(Box::new(LocalInfo::User(ClearCrossCrate::Set(\n-                    BindingForm::RefForGuard,\n-                )))),\n+                local_info: ClearCrossCrate::Set(Box::new(LocalInfo::User(BindingForm::RefForGuard))),\n             });\n             self.var_debug_info.push(VarDebugInfo {\n                 name,"}, {"sha": "6814fd4cb35e0c1dd17c691271f14f5a3d27afa2", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -48,17 +48,14 @@ pub(crate) fn mir_built(\n /// Construct the MIR for a given `DefId`.\n fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_> {\n     // Ensure unsafeck and abstract const building is ran before we steal the THIR.\n-    // We can't use `ensure()` for `thir_abstract_const` as it doesn't compute the query\n-    // if inputs are green. This can cause ICEs when calling `thir_abstract_const` after\n-    // THIR has been stolen if we haven't computed this query yet.\n     match def {\n         ty::WithOptConstParam { did, const_param_did: Some(const_param_did) } => {\n-            tcx.ensure().thir_check_unsafety_for_const_arg((did, const_param_did));\n-            drop(tcx.thir_abstract_const_of_const_arg((did, const_param_did)));\n+            tcx.ensure_with_value().thir_check_unsafety_for_const_arg((did, const_param_did));\n+            tcx.ensure_with_value().thir_abstract_const_of_const_arg((did, const_param_did));\n         }\n         ty::WithOptConstParam { did, const_param_did: None } => {\n-            tcx.ensure().thir_check_unsafety(did);\n-            drop(tcx.thir_abstract_const(did));\n+            tcx.ensure_with_value().thir_check_unsafety(did);\n+            tcx.ensure_with_value().thir_abstract_const(did);\n         }\n     }\n \n@@ -879,20 +876,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 } => {\n                     self.local_decls[local].mutability = mutability;\n                     self.local_decls[local].source_info.scope = self.source_scope;\n-                    self.local_decls[local].local_info = if let Some(kind) = param.self_kind {\n-                        Some(Box::new(LocalInfo::User(ClearCrossCrate::Set(\n+                    **self.local_decls[local].local_info.as_mut().assert_crate_local() = if let Some(kind) = param.self_kind {\n+                        LocalInfo::User(\n                             BindingForm::ImplicitSelf(kind),\n-                        ))))\n+                        )\n                     } else {\n                         let binding_mode = ty::BindingMode::BindByValue(mutability);\n-                        Some(Box::new(LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                        LocalInfo::User(BindingForm::Var(\n                             VarBindingForm {\n                                 binding_mode,\n                                 opt_ty_info: param.ty_span,\n                                 opt_match_place: Some((None, span)),\n                                 pat_span: span,\n                             },\n-                        )))))\n+                        ))\n                     };\n                     self.var_indices.insert(var, LocalsForNode::One(local));\n                 }"}, {"sha": "0470919757897bd2c894d253eba2bdfe45db91a8", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -28,7 +28,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_macros::fluent_messages;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n pub fn provide(providers: &mut Providers) {\n     providers.check_match = thir::pattern::check_match;"}, {"sha": "988541525088367d86439fb99cbecf25753c2466", "filename": "compiler/rustc_mir_dataflow/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_dataflow%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_dataflow%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_mir_dataflow/locales/en-US.ftl"}, {"sha": "4ed6f7e90ff9a51bfe98a13e27ab06e892402b59", "filename": "compiler/rustc_mir_dataflow/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -46,7 +46,7 @@ pub mod storage;\n pub mod un_derefer;\n pub mod value_analysis;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n pub(crate) mod indexes {\n     pub(crate) use super::move_paths::MovePathIndex;"}, {"sha": "3d32c586554d50fe11235385bf7faec831636c84", "filename": "compiler/rustc_mir_transform/src/check_const_item_mutation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -24,7 +24,7 @@ struct ConstMutationChecker<'a, 'tcx> {\n \n impl<'tcx> ConstMutationChecker<'_, 'tcx> {\n     fn is_const_item(&self, local: Local) -> Option<DefId> {\n-        if let Some(box LocalInfo::ConstRef { def_id }) = self.body.local_decls[local].local_info {\n+        if let LocalInfo::ConstRef { def_id } = *self.body.local_decls[local].local_info() {\n             Some(def_id)\n         } else {\n             None"}, {"sha": "c4d058e8ecbf6adee41c2a15df285dcd58dc50f5", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -182,7 +182,7 @@ impl<'tcx> Visitor<'tcx> for UnsafetyChecker<'_, 'tcx> {\n             // If the projection root is an artificial local that we introduced when\n             // desugaring `static`, give a more specific error message\n             // (avoid the general \"raw pointer\" clause below, that would only be confusing).\n-            if let Some(box LocalInfo::StaticRef { def_id, .. }) = decl.local_info {\n+            if let LocalInfo::StaticRef { def_id, .. } = *decl.local_info() {\n                 if self.tcx.is_mutable_static(def_id) {\n                     self.require_unsafe(\n                         UnsafetyViolationKind::General,"}, {"sha": "de7b8c63fc87a02f686402e9f83da630898fb0fc", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 100, "deletions": 169, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,12 +1,9 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n-use std::cell::Cell;\n-\n use either::Right;\n \n use rustc_const_eval::const_eval::CheckAlignment;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::DefKind;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n@@ -17,16 +14,16 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::{self, ConstKind, Instance, ParamEnv, Ty, TyCtxt, TypeVisitableExt};\n-use rustc_span::{def_id::DefId, Span};\n+use rustc_span::{def_id::DefId, Span, DUMMY_SP};\n use rustc_target::abi::{self, Align, HasDataLayout, Size, TargetDataLayout};\n use rustc_target::spec::abi::Abi as CallAbi;\n use rustc_trait_selection::traits;\n \n use crate::MirPass;\n use rustc_const_eval::interpret::{\n     self, compile_time_machine, AllocId, ConstAllocation, ConstValue, CtfeValidationMode, Frame,\n-    ImmTy, Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemoryKind, OpTy, PlaceTy,\n-    Pointer, Scalar, StackPopCleanup, StackPopUnwind,\n+    ImmTy, Immediate, InterpCx, InterpResult, LocalValue, MemoryKind, OpTy, PlaceTy, Pointer,\n+    Scalar, StackPopCleanup, StackPopUnwind,\n };\n \n /// The maximum number of bytes that we'll allocate space for a local or the return value.\n@@ -154,24 +151,12 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n pub struct ConstPropMachine<'mir, 'tcx> {\n     /// The virtual call stack.\n     stack: Vec<Frame<'mir, 'tcx>>,\n-    /// `OnlyInsideOwnBlock` locals that were written in the current block get erased at the end.\n-    pub written_only_inside_own_block_locals: FxHashSet<Local>,\n-    /// Locals that need to be cleared after every block terminates.\n-    pub only_propagate_inside_block_locals: BitSet<Local>,\n     pub can_const_prop: IndexVec<Local, ConstPropMode>,\n }\n \n impl ConstPropMachine<'_, '_> {\n-    pub fn new(\n-        only_propagate_inside_block_locals: BitSet<Local>,\n-        can_const_prop: IndexVec<Local, ConstPropMode>,\n-    ) -> Self {\n-        Self {\n-            stack: Vec::new(),\n-            written_only_inside_own_block_locals: Default::default(),\n-            only_propagate_inside_block_locals,\n-            can_const_prop,\n-        }\n+    pub fn new(can_const_prop: IndexVec<Local, ConstPropMode>) -> Self {\n+        Self { stack: Vec::new(), can_const_prop }\n     }\n }\n \n@@ -257,16 +242,14 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         frame: usize,\n         local: Local,\n     ) -> InterpResult<'tcx, &'a mut interpret::Operand<Self::Provenance>> {\n-        if ecx.machine.can_const_prop[local] == ConstPropMode::NoPropagation {\n-            throw_machine_stop_str!(\"tried to write to a local that is marked as not propagatable\")\n-        }\n-        if frame == 0 && ecx.machine.only_propagate_inside_block_locals.contains(local) {\n-            trace!(\n-                \"mutating local {:?} which is restricted to its block. \\\n-                Will remove it from const-prop after block is finished.\",\n-                local\n-            );\n-            ecx.machine.written_only_inside_own_block_locals.insert(local);\n+        assert_eq!(frame, 0);\n+        match ecx.machine.can_const_prop[local] {\n+            ConstPropMode::NoPropagation => {\n+                throw_machine_stop_str!(\n+                    \"tried to write to a local that is marked as not propagatable\"\n+                )\n+            }\n+            ConstPropMode::OnlyInsideOwnBlock | ConstPropMode::FullConstProp => {}\n         }\n         ecx.machine.stack[frame].locals[local].access_mut()\n     }\n@@ -328,9 +311,6 @@ struct ConstPropagator<'mir, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n     local_decls: &'mir IndexVec<Local, LocalDecl<'tcx>>,\n-    // Because we have `MutVisitor` we can't obtain the `SourceInfo` from a `Location`. So we store\n-    // the last known `SourceInfo` here and just keep revisiting it.\n-    source_info: Option<SourceInfo>,\n }\n \n impl<'tcx> LayoutOfHelpers<'tcx> for ConstPropagator<'_, 'tcx> {\n@@ -374,17 +354,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let param_env = tcx.param_env_reveal_all_normalized(def_id);\n \n         let can_const_prop = CanConstProp::check(tcx, param_env, body);\n-        let mut only_propagate_inside_block_locals = BitSet::new_empty(can_const_prop.len());\n-        for (l, mode) in can_const_prop.iter_enumerated() {\n-            if *mode == ConstPropMode::OnlyInsideOwnBlock {\n-                only_propagate_inside_block_locals.insert(l);\n-            }\n-        }\n         let mut ecx = InterpCx::new(\n             tcx,\n             tcx.def_span(def_id),\n             param_env,\n-            ConstPropMachine::new(only_propagate_inside_block_locals, can_const_prop),\n+            ConstPropMachine::new(can_const_prop),\n         );\n \n         let ret_layout = ecx\n@@ -411,13 +385,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         )\n         .expect(\"failed to push initial stack frame\");\n \n-        ConstPropagator {\n-            ecx,\n-            tcx,\n-            param_env,\n-            local_decls: &dummy_body.local_decls,\n-            source_info: None,\n-        }\n+        ConstPropagator { ecx, tcx, param_env, local_decls: &dummy_body.local_decls }\n     }\n \n     fn get_const(&self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n@@ -446,10 +414,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     /// Remove `local` from the pool of `Locals`. Allows writing to them,\n     /// but not reading from them anymore.\n     fn remove_const(ecx: &mut InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>, local: Local) {\n-        ecx.frame_mut().locals[local] = LocalState {\n-            value: LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit)),\n-            layout: Cell::new(None),\n-        };\n+        ecx.frame_mut().locals[local].value =\n+            LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit));\n     }\n \n     /// Returns the value, if any, of evaluating `c`.\n@@ -492,19 +458,15 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                         scalar,\n                     )) = *value\n                     {\n-                        *operand = self.operand_from_scalar(\n-                            scalar,\n-                            value.layout.ty,\n-                            self.source_info.unwrap().span,\n-                        );\n+                        *operand = self.operand_from_scalar(scalar, value.layout.ty);\n                     }\n                 }\n             }\n             Operand::Constant(_) => (),\n         }\n     }\n \n-    fn const_prop(&mut self, rvalue: &Rvalue<'tcx>, place: Place<'tcx>) -> Option<()> {\n+    fn check_rvalue(&mut self, rvalue: &Rvalue<'tcx>) -> Option<()> {\n         // Perform any special handling for specific Rvalue types.\n         // Generally, checks here fall into one of two categories:\n         //   1. Additional checking to provide useful lints to the user\n@@ -561,7 +523,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return None;\n         }\n \n-        self.eval_rvalue_with_identities(rvalue, place)\n+        Some(())\n     }\n \n     // Attempt to use algebraic identities to eliminate constant expressions\n@@ -621,20 +583,24 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n \n     /// Creates a new `Operand::Constant` from a `Scalar` value\n-    fn operand_from_scalar(&self, scalar: Scalar, ty: Ty<'tcx>, span: Span) -> Operand<'tcx> {\n+    fn operand_from_scalar(&self, scalar: Scalar, ty: Ty<'tcx>) -> Operand<'tcx> {\n         Operand::Constant(Box::new(Constant {\n-            span,\n+            span: DUMMY_SP,\n             user_ty: None,\n             literal: ConstantKind::from_scalar(self.tcx, scalar, ty),\n         }))\n     }\n \n-    fn replace_with_const(\n-        &mut self,\n-        rval: &mut Rvalue<'tcx>,\n-        value: &OpTy<'tcx>,\n-        source_info: SourceInfo,\n-    ) {\n+    fn replace_with_const(&mut self, place: Place<'tcx>, rval: &mut Rvalue<'tcx>) {\n+        // This will return None if the above `const_prop` invocation only \"wrote\" a\n+        // type whose creation requires no write. E.g. a generator whose initial state\n+        // consists solely of uninitialized memory (so it doesn't capture any locals).\n+        let Some(ref value) = self.get_const(place) else { return };\n+        if !self.should_const_prop(value) {\n+            return;\n+        }\n+        trace!(\"replacing {:?}={:?} with {:?}\", place, rval, value);\n+\n         if let Rvalue::Use(Operand::Constant(c)) = rval {\n             match c.literal {\n                 ConstantKind::Ty(c) if matches!(c.kind(), ConstKind::Unevaluated(..)) => {}\n@@ -664,11 +630,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         if let Some(Right(imm)) = imm {\n             match *imm {\n                 interpret::Immediate::Scalar(scalar) => {\n-                    *rval = Rvalue::Use(self.operand_from_scalar(\n-                        scalar,\n-                        value.layout.ty,\n-                        source_info.span,\n-                    ));\n+                    *rval = Rvalue::Use(self.operand_from_scalar(scalar, value.layout.ty));\n                 }\n                 Immediate::ScalarPair(..) => {\n                     // Found a value represented as a pair. For now only do const-prop if the type\n@@ -701,7 +663,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                                 let const_val = ConstValue::ByRef { alloc, offset: Size::ZERO };\n                                 let literal = ConstantKind::Val(const_val, ty);\n                                 *rval = Rvalue::Use(Operand::Constant(Box::new(Constant {\n-                                    span: source_info.span,\n+                                    span: DUMMY_SP,\n                                     user_ty: None,\n                                     literal,\n                                 })));\n@@ -730,6 +692,19 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             _ => false,\n         }\n     }\n+\n+    fn ensure_not_propagated(&mut self, local: Local) {\n+        if cfg!(debug_assertions) {\n+            assert!(\n+                self.get_const(local.into()).is_none()\n+                    || self\n+                        .layout_of(self.local_decls[local].ty)\n+                        .map_or(true, |layout| layout.is_zst()),\n+                \"failed to remove values for `{local:?}`, value={:?}\",\n+                self.get_const(local.into()),\n+            )\n+        }\n+    }\n }\n \n /// The mode that `ConstProp` is allowed to run in for a given `Local`.\n@@ -739,8 +714,6 @@ pub enum ConstPropMode {\n     FullConstProp,\n     /// The `Local` can only be propagated into and from its own block.\n     OnlyInsideOwnBlock,\n-    /// The `Local` can be propagated into but reads cannot be propagated.\n-    OnlyPropagateInto,\n     /// The `Local` cannot be part of propagation at all. Any statement\n     /// referencing it either for reading or writing will not get propagated.\n     NoPropagation,\n@@ -750,8 +723,6 @@ pub struct CanConstProp {\n     can_const_prop: IndexVec<Local, ConstPropMode>,\n     // False at the beginning. Once set, no more assignments are allowed to that local.\n     found_assignment: BitSet<Local>,\n-    // Cache of locals' information\n-    local_kinds: IndexVec<Local, LocalKind>,\n }\n \n impl CanConstProp {\n@@ -764,10 +735,6 @@ impl CanConstProp {\n         let mut cpv = CanConstProp {\n             can_const_prop: IndexVec::from_elem(ConstPropMode::FullConstProp, &body.local_decls),\n             found_assignment: BitSet::new_empty(body.local_decls.len()),\n-            local_kinds: IndexVec::from_fn_n(\n-                |local| body.local_kind(local),\n-                body.local_decls.len(),\n-            ),\n         };\n         for (local, val) in cpv.can_const_prop.iter_enumerated_mut() {\n             let ty = body.local_decls[local].ty;\n@@ -780,24 +747,10 @@ impl CanConstProp {\n                     continue;\n                 }\n             }\n-            // Cannot use args at all\n-            // Cannot use locals because if x < y { y - x } else { x - y } would\n-            //        lint for x != y\n-            // FIXME(oli-obk): lint variables until they are used in a condition\n-            // FIXME(oli-obk): lint if return value is constant\n-            if cpv.local_kinds[local] == LocalKind::Arg {\n-                *val = ConstPropMode::OnlyPropagateInto;\n-                trace!(\n-                    \"local {:?} can't be const propagated because it's a function argument\",\n-                    local\n-                );\n-            } else if cpv.local_kinds[local] == LocalKind::Var {\n-                *val = ConstPropMode::OnlyInsideOwnBlock;\n-                trace!(\n-                    \"local {:?} will only be propagated inside its block, because it's a user variable\",\n-                    local\n-                );\n-            }\n+        }\n+        // Consider that arguments are assigned on entry.\n+        for arg in body.args_iter() {\n+            cpv.found_assignment.insert(arg);\n         }\n         cpv.visit_body(&body);\n         cpv.can_const_prop\n@@ -827,7 +780,6 @@ impl Visitor<'_> for CanConstProp {\n                         // states as applicable.\n                         ConstPropMode::OnlyInsideOwnBlock => {}\n                         ConstPropMode::NoPropagation => {}\n-                        ConstPropMode::OnlyPropagateInto => {}\n                         other @ ConstPropMode::FullConstProp => {\n                             trace!(\n                                 \"local {:?} can't be propagated because of multiple assignments. Previous state: {:?}\",\n@@ -892,42 +844,23 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         self.eval_constant(constant);\n     }\n \n-    fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n-        trace!(\"visit_statement: {:?}\", statement);\n-        let source_info = statement.source_info;\n-        self.source_info = Some(source_info);\n-        match statement.kind {\n-            StatementKind::Assign(box (place, ref mut rval)) => {\n-                let can_const_prop = self.ecx.machine.can_const_prop[place.local];\n-                if let Some(()) = self.const_prop(rval, place) {\n-                    // This will return None if the above `const_prop` invocation only \"wrote\" a\n-                    // type whose creation requires no write. E.g. a generator whose initial state\n-                    // consists solely of uninitialized memory (so it doesn't capture any locals).\n-                    if let Some(ref value) = self.get_const(place) && self.should_const_prop(value) {\n-                        trace!(\"replacing {:?} with {:?}\", rval, value);\n-                        self.replace_with_const(rval, value, source_info);\n-                        if can_const_prop == ConstPropMode::FullConstProp\n-                            || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n-                        {\n-                            trace!(\"propagated into {:?}\", place);\n-                        }\n-                    }\n-                    match can_const_prop {\n-                        ConstPropMode::OnlyInsideOwnBlock => {\n-                            trace!(\n-                                \"found local restricted to its block. \\\n-                                Will remove it from const-prop after block is finished. Local: {:?}\",\n-                                place.local\n-                            );\n-                        }\n-                        ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n-                            trace!(\"can't propagate into {:?}\", place);\n-                            if place.local != RETURN_PLACE {\n-                                Self::remove_const(&mut self.ecx, place.local);\n-                            }\n-                        }\n-                        ConstPropMode::FullConstProp => {}\n-                    }\n+    fn visit_assign(\n+        &mut self,\n+        place: &mut Place<'tcx>,\n+        rvalue: &mut Rvalue<'tcx>,\n+        location: Location,\n+    ) {\n+        self.super_assign(place, rvalue, location);\n+\n+        let Some(()) = self.check_rvalue(rvalue) else { return };\n+\n+        match self.ecx.machine.can_const_prop[place.local] {\n+            // Do nothing if the place is indirect.\n+            _ if place.is_indirect() => {}\n+            ConstPropMode::NoPropagation => self.ensure_not_propagated(place.local),\n+            ConstPropMode::OnlyInsideOwnBlock | ConstPropMode::FullConstProp => {\n+                if let Some(()) = self.eval_rvalue_with_identities(rvalue, *place) {\n+                    self.replace_with_const(*place, rvalue);\n                 } else {\n                     // Const prop failed, so erase the destination, ensuring that whatever happens\n                     // from here on, does not know about the previous value.\n@@ -947,37 +880,45 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                     Self::remove_const(&mut self.ecx, place.local);\n                 }\n             }\n+        }\n+    }\n+\n+    fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n+        trace!(\"visit_statement: {:?}\", statement);\n+\n+        // We want to evaluate operands before any change to the assigned-to value,\n+        // so we recurse first.\n+        self.super_statement(statement, location);\n+\n+        match statement.kind {\n             StatementKind::SetDiscriminant { ref place, .. } => {\n                 match self.ecx.machine.can_const_prop[place.local] {\n+                    // Do nothing if the place is indirect.\n+                    _ if place.is_indirect() => {}\n+                    ConstPropMode::NoPropagation => self.ensure_not_propagated(place.local),\n                     ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n                         if self.ecx.statement(statement).is_ok() {\n                             trace!(\"propped discriminant into {:?}\", place);\n                         } else {\n                             Self::remove_const(&mut self.ecx, place.local);\n                         }\n                     }\n-                    ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n-                        Self::remove_const(&mut self.ecx, place.local);\n-                    }\n                 }\n             }\n-            StatementKind::StorageLive(local) | StatementKind::StorageDead(local) => {\n+            StatementKind::StorageLive(local) => {\n                 let frame = self.ecx.frame_mut();\n-                frame.locals[local].value = if let StatementKind::StorageLive(_) = statement.kind {\n-                    LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit))\n-                } else {\n-                    LocalValue::Dead\n-                };\n+                frame.locals[local].value =\n+                    LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit));\n+            }\n+            StatementKind::StorageDead(local) => {\n+                let frame = self.ecx.frame_mut();\n+                frame.locals[local].value = LocalValue::Dead;\n             }\n             _ => {}\n         }\n-\n-        self.super_statement(statement, location);\n     }\n \n     fn visit_terminator(&mut self, terminator: &mut Terminator<'tcx>, location: Location) {\n-        let source_info = terminator.source_info;\n-        self.source_info = Some(source_info);\n         self.super_terminator(terminator, location);\n \n         match &mut terminator.kind {\n@@ -987,11 +928,7 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                     && self.should_const_prop(value)\n                 {\n                     trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                    *cond = self.operand_from_scalar(\n-                        value_const,\n-                        self.tcx.types.bool,\n-                        source_info.span,\n-                    );\n+                    *cond = self.operand_from_scalar(value_const, self.tcx.types.bool);\n                 }\n             }\n             TerminatorKind::SwitchInt { ref mut discr, .. } => {\n@@ -1026,23 +963,17 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         // We remove all Locals which are restricted in propagation to their containing blocks and\n         // which were modified in the current block.\n         // Take it out of the ecx so we can get a mutable reference to the ecx for `remove_const`.\n-        let mut locals = std::mem::take(&mut self.ecx.machine.written_only_inside_own_block_locals);\n-        for &local in locals.iter() {\n-            Self::remove_const(&mut self.ecx, local);\n-        }\n-        locals.clear();\n-        // Put it back so we reuse the heap of the storage\n-        self.ecx.machine.written_only_inside_own_block_locals = locals;\n-        if cfg!(debug_assertions) {\n-            // Ensure we are correctly erasing locals with the non-debug-assert logic.\n-            for local in self.ecx.machine.only_propagate_inside_block_locals.iter() {\n-                assert!(\n-                    self.get_const(local.into()).is_none()\n-                        || self\n-                            .layout_of(self.local_decls[local].ty)\n-                            .map_or(true, |layout| layout.is_zst())\n-                )\n+        let can_const_prop = std::mem::take(&mut self.ecx.machine.can_const_prop);\n+        for (local, &mode) in can_const_prop.iter_enumerated() {\n+            match mode {\n+                ConstPropMode::FullConstProp => {}\n+                ConstPropMode::NoPropagation => self.ensure_not_propagated(local),\n+                ConstPropMode::OnlyInsideOwnBlock => {\n+                    Self::remove_const(&mut self.ecx, local);\n+                    self.ensure_not_propagated(local);\n+                }\n             }\n         }\n+        self.ecx.machine.can_const_prop = can_const_prop;\n     }\n }"}, {"sha": "68e50070e56e17cbc2b463aac36d7c60f4cc9c7e", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 95, "deletions": 108, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,24 +1,17 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n-use std::cell::Cell;\n-\n use either::{Left, Right};\n \n use rustc_const_eval::interpret::Immediate;\n use rustc_const_eval::interpret::{\n-    self, InterpCx, InterpResult, LocalState, LocalValue, MemoryKind, OpTy, Scalar, StackPopCleanup,\n+    self, InterpCx, InterpResult, LocalValue, MemoryKind, OpTy, Scalar, StackPopCleanup,\n };\n use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n-use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::visit::Visitor;\n-use rustc_middle::mir::{\n-    AssertKind, BinOp, Body, Constant, Local, LocalDecl, Location, Operand, Place, Rvalue,\n-    SourceInfo, SourceScope, SourceScopeData, Statement, StatementKind, Terminator, TerminatorKind,\n-    UnOp, RETURN_PLACE,\n-};\n+use rustc_middle::mir::*;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::{\n@@ -185,17 +178,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let param_env = tcx.param_env_reveal_all_normalized(def_id);\n \n         let can_const_prop = CanConstProp::check(tcx, param_env, body);\n-        let mut only_propagate_inside_block_locals = BitSet::new_empty(can_const_prop.len());\n-        for (l, mode) in can_const_prop.iter_enumerated() {\n-            if *mode == ConstPropMode::OnlyInsideOwnBlock {\n-                only_propagate_inside_block_locals.insert(l);\n-            }\n-        }\n         let mut ecx = InterpCx::new(\n             tcx,\n             tcx.def_span(def_id),\n             param_env,\n-            ConstPropMachine::new(only_propagate_inside_block_locals, can_const_prop),\n+            ConstPropMachine::new(can_const_prop),\n         );\n \n         let ret_layout = ecx\n@@ -258,10 +245,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     /// Remove `local` from the pool of `Locals`. Allows writing to them,\n     /// but not reading from them anymore.\n     fn remove_const(ecx: &mut InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>, local: Local) {\n-        ecx.frame_mut().locals[local] = LocalState {\n-            value: LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit)),\n-            layout: Cell::new(None),\n-        };\n+        ecx.frame_mut().locals[local].value =\n+            LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit));\n     }\n \n     fn lint_root(&self, source_info: SourceInfo) -> Option<HirId> {\n@@ -420,12 +405,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         Some(())\n     }\n \n-    fn const_prop(\n-        &mut self,\n-        rvalue: &Rvalue<'tcx>,\n-        source_info: SourceInfo,\n-        place: Place<'tcx>,\n-    ) -> Option<()> {\n+    fn check_rvalue(&mut self, rvalue: &Rvalue<'tcx>, source_info: SourceInfo) -> Option<()> {\n         // Perform any special handling for specific Rvalue types.\n         // Generally, checks here fall into one of two categories:\n         //   1. Additional checking to provide useful lints to the user\n@@ -501,7 +481,20 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return None;\n         }\n \n-        self.use_ecx(source_info, |this| this.ecx.eval_rvalue_into_place(rvalue, place))\n+        Some(())\n+    }\n+\n+    fn ensure_not_propagated(&mut self, local: Local) {\n+        if cfg!(debug_assertions) {\n+            assert!(\n+                self.get_const(local.into()).is_none()\n+                    || self\n+                        .layout_of(self.local_decls[local].ty)\n+                        .map_or(true, |layout| layout.is_zst()),\n+                \"failed to remove values for `{local:?}`, value={:?}\",\n+                self.get_const(local.into()),\n+            )\n+        }\n     }\n }\n \n@@ -522,82 +515,78 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         self.eval_constant(constant, self.source_info.unwrap());\n     }\n \n+    fn visit_assign(&mut self, place: &Place<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n+        self.super_assign(place, rvalue, location);\n+\n+        let source_info = self.source_info.unwrap();\n+        let Some(()) = self.check_rvalue(rvalue, source_info) else { return };\n+\n+        match self.ecx.machine.can_const_prop[place.local] {\n+            // Do nothing if the place is indirect.\n+            _ if place.is_indirect() => {}\n+            ConstPropMode::NoPropagation => self.ensure_not_propagated(place.local),\n+            ConstPropMode::OnlyInsideOwnBlock | ConstPropMode::FullConstProp => {\n+                if self\n+                    .use_ecx(source_info, |this| this.ecx.eval_rvalue_into_place(rvalue, *place))\n+                    .is_none()\n+                {\n+                    // Const prop failed, so erase the destination, ensuring that whatever happens\n+                    // from here on, does not know about the previous value.\n+                    // This is important in case we have\n+                    // ```rust\n+                    // let mut x = 42;\n+                    // x = SOME_MUTABLE_STATIC;\n+                    // // x must now be uninit\n+                    // ```\n+                    // FIXME: we overzealously erase the entire local, because that's easier to\n+                    // implement.\n+                    trace!(\n+                        \"propagation into {:?} failed.\n+                        Nuking the entire site from orbit, it's the only way to be sure\",\n+                        place,\n+                    );\n+                    Self::remove_const(&mut self.ecx, place.local);\n+                }\n+            }\n+        }\n+    }\n+\n     fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n         trace!(\"visit_statement: {:?}\", statement);\n         let source_info = statement.source_info;\n         self.source_info = Some(source_info);\n-        if let StatementKind::Assign(box (place, ref rval)) = statement.kind {\n-            let can_const_prop = self.ecx.machine.can_const_prop[place.local];\n-            if let Some(()) = self.const_prop(rval, source_info, place) {\n-                match can_const_prop {\n-                    ConstPropMode::OnlyInsideOwnBlock => {\n-                        trace!(\n-                            \"found local restricted to its block. \\\n-                                Will remove it from const-prop after block is finished. Local: {:?}\",\n-                            place.local\n-                        );\n-                    }\n-                    ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n-                        trace!(\"can't propagate into {:?}\", place);\n-                        if place.local != RETURN_PLACE {\n+\n+        // We want to evaluate operands before any change to the assigned-to value,\n+        // so we recurse first.\n+        self.super_statement(statement, location);\n+\n+        match statement.kind {\n+            StatementKind::SetDiscriminant { ref place, .. } => {\n+                match self.ecx.machine.can_const_prop[place.local] {\n+                    // Do nothing if the place is indirect.\n+                    _ if place.is_indirect() => {}\n+                    ConstPropMode::NoPropagation => self.ensure_not_propagated(place.local),\n+                    ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n+                        if self.use_ecx(source_info, |this| this.ecx.statement(statement)).is_some()\n+                        {\n+                            trace!(\"propped discriminant into {:?}\", place);\n+                        } else {\n                             Self::remove_const(&mut self.ecx, place.local);\n                         }\n                     }\n-                    ConstPropMode::FullConstProp => {}\n                 }\n-            } else {\n-                // Const prop failed, so erase the destination, ensuring that whatever happens\n-                // from here on, does not know about the previous value.\n-                // This is important in case we have\n-                // ```rust\n-                // let mut x = 42;\n-                // x = SOME_MUTABLE_STATIC;\n-                // // x must now be uninit\n-                // ```\n-                // FIXME: we overzealously erase the entire local, because that's easier to\n-                // implement.\n-                trace!(\n-                    \"propagation into {:?} failed.\n-                        Nuking the entire site from orbit, it's the only way to be sure\",\n-                    place,\n-                );\n-                Self::remove_const(&mut self.ecx, place.local);\n             }\n-        } else {\n-            match statement.kind {\n-                StatementKind::SetDiscriminant { ref place, .. } => {\n-                    match self.ecx.machine.can_const_prop[place.local] {\n-                        ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n-                            if self\n-                                .use_ecx(source_info, |this| this.ecx.statement(statement))\n-                                .is_some()\n-                            {\n-                                trace!(\"propped discriminant into {:?}\", place);\n-                            } else {\n-                                Self::remove_const(&mut self.ecx, place.local);\n-                            }\n-                        }\n-                        ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n-                            Self::remove_const(&mut self.ecx, place.local);\n-                        }\n-                    }\n-                }\n-                StatementKind::StorageLive(local) | StatementKind::StorageDead(local) => {\n-                    let frame = self.ecx.frame_mut();\n-                    frame.locals[local].value =\n-                        if let StatementKind::StorageLive(_) = statement.kind {\n-                            LocalValue::Live(interpret::Operand::Immediate(\n-                                interpret::Immediate::Uninit,\n-                            ))\n-                        } else {\n-                            LocalValue::Dead\n-                        };\n-                }\n-                _ => {}\n+            StatementKind::StorageLive(local) => {\n+                let frame = self.ecx.frame_mut();\n+                frame.locals[local].value =\n+                    LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit));\n+            }\n+            StatementKind::StorageDead(local) => {\n+                let frame = self.ecx.frame_mut();\n+                frame.locals[local].value = LocalValue::Dead;\n             }\n+            _ => {}\n         }\n-\n-        self.super_statement(statement, location);\n     }\n \n     fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n@@ -694,27 +683,25 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n             | TerminatorKind::Call { .. }\n             | TerminatorKind::InlineAsm { .. } => {}\n         }\n+    }\n+\n+    fn visit_basic_block_data(&mut self, block: BasicBlock, data: &BasicBlockData<'tcx>) {\n+        self.super_basic_block_data(block, data);\n \n         // We remove all Locals which are restricted in propagation to their containing blocks and\n         // which were modified in the current block.\n         // Take it out of the ecx so we can get a mutable reference to the ecx for `remove_const`.\n-        let mut locals = std::mem::take(&mut self.ecx.machine.written_only_inside_own_block_locals);\n-        for &local in locals.iter() {\n-            Self::remove_const(&mut self.ecx, local);\n-        }\n-        locals.clear();\n-        // Put it back so we reuse the heap of the storage\n-        self.ecx.machine.written_only_inside_own_block_locals = locals;\n-        if cfg!(debug_assertions) {\n-            // Ensure we are correctly erasing locals with the non-debug-assert logic.\n-            for local in self.ecx.machine.only_propagate_inside_block_locals.iter() {\n-                assert!(\n-                    self.get_const(local.into()).is_none()\n-                        || self\n-                            .layout_of(self.local_decls[local].ty)\n-                            .map_or(true, |layout| layout.is_zst())\n-                )\n+        let can_const_prop = std::mem::take(&mut self.ecx.machine.can_const_prop);\n+        for (local, &mode) in can_const_prop.iter_enumerated() {\n+            match mode {\n+                ConstPropMode::FullConstProp => {}\n+                ConstPropMode::NoPropagation => self.ensure_not_propagated(local),\n+                ConstPropMode::OnlyInsideOwnBlock => {\n+                    Self::remove_const(&mut self.ecx, local);\n+                    self.ensure_not_propagated(local);\n+                }\n             }\n         }\n+        self.ecx.machine.can_const_prop = can_const_prop;\n     }\n }"}, {"sha": "49028ca4e5ec88287ccba9a35cecb1984cd02257", "filename": "compiler/rustc_mir_transform/src/coverage/graph.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -537,29 +537,29 @@ impl TraverseCoverageGraphWithLoops {\n             \"TraverseCoverageGraphWithLoops::next - context_stack: {:?}\",\n             self.context_stack.iter().rev().collect::<Vec<_>>()\n         );\n-        while let Some(next_bcb) = {\n-            // Strip contexts with empty worklists from the top of the stack\n-            while self.context_stack.last().map_or(false, |context| context.worklist.is_empty()) {\n+\n+        while let Some(context) = self.context_stack.last_mut() {\n+            if let Some(next_bcb) = context.worklist.pop() {\n+                if !self.visited.insert(next_bcb) {\n+                    debug!(\"Already visited: {:?}\", next_bcb);\n+                    continue;\n+                }\n+                debug!(\"Visiting {:?}\", next_bcb);\n+                if self.backedges[next_bcb].len() > 0 {\n+                    debug!(\"{:?} is a loop header! Start a new TraversalContext...\", next_bcb);\n+                    self.context_stack.push(TraversalContext {\n+                        loop_backedges: Some((self.backedges[next_bcb].clone(), next_bcb)),\n+                        worklist: Vec::new(),\n+                    });\n+                }\n+                self.extend_worklist(basic_coverage_blocks, next_bcb);\n+                return Some(next_bcb);\n+            } else {\n+                // Strip contexts with empty worklists from the top of the stack\n                 self.context_stack.pop();\n             }\n-            // Pop the next bcb off of the current context_stack. If none, all BCBs were visited.\n-            self.context_stack.last_mut().map_or(None, |context| context.worklist.pop())\n-        } {\n-            if !self.visited.insert(next_bcb) {\n-                debug!(\"Already visited: {:?}\", next_bcb);\n-                continue;\n-            }\n-            debug!(\"Visiting {:?}\", next_bcb);\n-            if self.backedges[next_bcb].len() > 0 {\n-                debug!(\"{:?} is a loop header! Start a new TraversalContext...\", next_bcb);\n-                self.context_stack.push(TraversalContext {\n-                    loop_backedges: Some((self.backedges[next_bcb].clone(), next_bcb)),\n-                    worklist: Vec::new(),\n-                });\n-            }\n-            self.extend_worklist(basic_coverage_blocks, next_bcb);\n-            return Some(next_bcb);\n         }\n+\n         None\n     }\n "}, {"sha": "5ecb2d6a6313e4565b9660841ecbf751d9b029c8", "filename": "compiler/rustc_mir_transform/src/coverage/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -577,5 +577,5 @@ fn get_body_span<'tcx>(\n fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, hir_body: &'tcx rustc_hir::Body<'tcx>) -> u64 {\n     // FIXME(cjgillot) Stop hashing HIR manually here.\n     let owner = hir_body.id().hir_id.owner;\n-    tcx.hir_owner_nodes(owner).unwrap().hash_including_bodies.to_smaller_hash()\n+    tcx.hir_owner_nodes(owner).unwrap().opt_hash_including_bodies.unwrap().to_smaller_hash()\n }"}, {"sha": "b8a5b92be4a6a1e78c5722366a71eca187625402", "filename": "compiler/rustc_mir_transform/src/deref_separator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Fderef_separator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Fderef_separator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fderef_separator.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -40,7 +40,7 @@ impl<'tcx> MutVisitor<'tcx> for DerefChecker<'tcx> {\n                     let temp = self.patcher.new_internal_with_info(\n                         ty,\n                         self.local_decls[p_ref.local].source_info.span,\n-                        Some(Box::new(LocalInfo::DerefTemp)),\n+                        LocalInfo::DerefTemp,\n                     );\n \n                     // We are adding current p_ref's projections to our"}, {"sha": "35e7efed87a972ff91d7d45aa733fd22850c9978", "filename": "compiler/rustc_mir_transform/src/dest_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -788,7 +788,7 @@ impl<'tcx> Visitor<'tcx> for FindAssignments<'_, '_, 'tcx> {\n fn is_local_required(local: Local, body: &Body<'_>) -> bool {\n     match body.local_kind(local) {\n         LocalKind::Arg | LocalKind::ReturnPointer => true,\n-        LocalKind::Var | LocalKind::Temp => false,\n+        LocalKind::Temp => false,\n     }\n }\n "}, {"sha": "e6875fad3068d8777e7f53a38c0c3ff78768558f", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -924,13 +924,19 @@ fn compute_layout<'tcx>(\n         debug!(?decl);\n \n         let ignore_for_traits = if tcx.sess.opts.unstable_opts.drop_tracking_mir {\n+            // Do not `assert_crate_local` here, as post-borrowck cleanup may have already cleared\n+            // the information. This is alright, since `ignore_for_traits` is only relevant when\n+            // this code runs on pre-cleanup MIR, and `ignore_for_traits = false` is the safer\n+            // default.\n             match decl.local_info {\n                 // Do not include raw pointers created from accessing `static` items, as those could\n                 // well be re-created by another access to the same static.\n-                Some(box LocalInfo::StaticRef { is_thread_local, .. }) => !is_thread_local,\n+                ClearCrossCrate::Set(box LocalInfo::StaticRef { is_thread_local, .. }) => {\n+                    !is_thread_local\n+                }\n                 // Fake borrows are only read by fake reads, so do not have any reality in\n                 // post-analysis MIR.\n-                Some(box LocalInfo::FakeBorrow) => true,\n+                ClearCrossCrate::Set(box LocalInfo::FakeBorrow) => true,\n                 _ => false,\n             }\n         } else {"}, {"sha": "9447a2ff040950fe44db4c1561cc1503acd4ea04", "filename": "compiler/rustc_mir_transform/src/large_enums.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Flarge_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Flarge_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flarge_enums.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -158,10 +158,12 @@ impl EnumSizeOpt {\n                             tmp_ty,\n                         ),\n                     };\n-                    let rval = Rvalue::Use(Operand::Constant(box (constant_vals)));\n+                    let rval = Rvalue::Use(Operand::Constant(Box::new(constant_vals)));\n \n-                    let const_assign =\n-                        Statement { source_info, kind: StatementKind::Assign(box (place, rval)) };\n+                    let const_assign = Statement {\n+                        source_info,\n+                        kind: StatementKind::Assign(Box::new((place, rval))),\n+                    };\n \n                     let discr_place = Place::from(\n                         local_decls\n@@ -170,48 +172,51 @@ impl EnumSizeOpt {\n \n                     let store_discr = Statement {\n                         source_info,\n-                        kind: StatementKind::Assign(box (discr_place, Rvalue::Discriminant(*rhs))),\n+                        kind: StatementKind::Assign(Box::new((\n+                            discr_place,\n+                            Rvalue::Discriminant(*rhs),\n+                        ))),\n                     };\n \n                     let discr_cast_place =\n                         Place::from(local_decls.push(LocalDecl::new(tcx.types.usize, span)));\n \n                     let cast_discr = Statement {\n                         source_info,\n-                        kind: StatementKind::Assign(box (\n+                        kind: StatementKind::Assign(Box::new((\n                             discr_cast_place,\n                             Rvalue::Cast(\n                                 CastKind::IntToInt,\n                                 Operand::Copy(discr_place),\n                                 tcx.types.usize,\n                             ),\n-                        )),\n+                        ))),\n                     };\n \n                     let size_place =\n                         Place::from(local_decls.push(LocalDecl::new(tcx.types.usize, span)));\n \n                     let store_size = Statement {\n                         source_info,\n-                        kind: StatementKind::Assign(box (\n+                        kind: StatementKind::Assign(Box::new((\n                             size_place,\n                             Rvalue::Use(Operand::Copy(Place {\n                                 local: size_array_local,\n                                 projection: tcx\n                                     .mk_place_elems(&[PlaceElem::Index(discr_cast_place.local)]),\n                             })),\n-                        )),\n+                        ))),\n                     };\n \n                     let dst =\n                         Place::from(local_decls.push(LocalDecl::new(tcx.mk_mut_ptr(ty), span)));\n \n                     let dst_ptr = Statement {\n                         source_info,\n-                        kind: StatementKind::Assign(box (\n+                        kind: StatementKind::Assign(Box::new((\n                             dst,\n                             Rvalue::AddressOf(Mutability::Mut, *lhs),\n-                        )),\n+                        ))),\n                     };\n \n                     let dst_cast_ty = tcx.mk_mut_ptr(tcx.types.u8);\n@@ -220,21 +225,21 @@ impl EnumSizeOpt {\n \n                     let dst_cast = Statement {\n                         source_info,\n-                        kind: StatementKind::Assign(box (\n+                        kind: StatementKind::Assign(Box::new((\n                             dst_cast_place,\n                             Rvalue::Cast(CastKind::PtrToPtr, Operand::Copy(dst), dst_cast_ty),\n-                        )),\n+                        ))),\n                     };\n \n                     let src =\n                         Place::from(local_decls.push(LocalDecl::new(tcx.mk_imm_ptr(ty), span)));\n \n                     let src_ptr = Statement {\n                         source_info,\n-                        kind: StatementKind::Assign(box (\n+                        kind: StatementKind::Assign(Box::new((\n                             src,\n                             Rvalue::AddressOf(Mutability::Not, *rhs),\n-                        )),\n+                        ))),\n                     };\n \n                     let src_cast_ty = tcx.mk_imm_ptr(tcx.types.u8);\n@@ -243,24 +248,24 @@ impl EnumSizeOpt {\n \n                     let src_cast = Statement {\n                         source_info,\n-                        kind: StatementKind::Assign(box (\n+                        kind: StatementKind::Assign(Box::new((\n                             src_cast_place,\n                             Rvalue::Cast(CastKind::PtrToPtr, Operand::Copy(src), src_cast_ty),\n-                        )),\n+                        ))),\n                     };\n \n                     let deinit_old =\n-                        Statement { source_info, kind: StatementKind::Deinit(box dst) };\n+                        Statement { source_info, kind: StatementKind::Deinit(Box::new(dst)) };\n \n                     let copy_bytes = Statement {\n                         source_info,\n-                        kind: StatementKind::Intrinsic(\n-                            box NonDivergingIntrinsic::CopyNonOverlapping(CopyNonOverlapping {\n+                        kind: StatementKind::Intrinsic(Box::new(\n+                            NonDivergingIntrinsic::CopyNonOverlapping(CopyNonOverlapping {\n                                 src: Operand::Copy(src_cast_place),\n                                 dst: Operand::Copy(dst_cast_place),\n                                 count: Operand::Copy(size_place),\n                             }),\n-                        ),\n+                        )),\n                     };\n \n                     let store_dead = Statement {"}, {"sha": "50c3023b02bd79b797a158b05ef295b05989c43f", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,7 +1,6 @@\n #![allow(rustc::potential_query_instability)]\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n-#![feature(box_syntax)]\n #![feature(let_chains)]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]\n@@ -30,9 +29,9 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::visit::Visitor as _;\n use rustc_middle::mir::{\n-    traversal, AnalysisPhase, Body, ConstQualifs, Constant, LocalDecl, MirPass, MirPhase, Operand,\n-    Place, ProjectionElem, Promoted, RuntimePhase, Rvalue, SourceInfo, Statement, StatementKind,\n-    TerminatorKind,\n+    traversal, AnalysisPhase, Body, ClearCrossCrate, ConstQualifs, Constant, LocalDecl, MirPass,\n+    MirPhase, Operand, Place, ProjectionElem, Promoted, RuntimePhase, Rvalue, SourceInfo,\n+    Statement, StatementKind, TerminatorKind,\n };\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt, TypeVisitableExt};\n@@ -278,14 +277,14 @@ fn mir_const(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> &Steal<\n     // Unsafety check uses the raw mir, so make sure it is run.\n     if !tcx.sess.opts.unstable_opts.thir_unsafeck {\n         if let Some(param_did) = def.const_param_did {\n-            tcx.ensure().unsafety_check_result_for_const_arg((def.did, param_did));\n+            tcx.ensure_with_value().unsafety_check_result_for_const_arg((def.did, param_did));\n         } else {\n-            tcx.ensure().unsafety_check_result(def.did);\n+            tcx.ensure_with_value().unsafety_check_result(def.did);\n         }\n     }\n \n     // has_ffi_unwind_calls query uses the raw mir, so make sure it is run.\n-    tcx.ensure().has_ffi_unwind_calls(def.did);\n+    tcx.ensure_with_value().has_ffi_unwind_calls(def.did);\n \n     let mut body = tcx.mir_built(def).steal();\n \n@@ -433,7 +432,7 @@ fn mir_drops_elaborated_and_const_checked(\n     if tcx.sess.opts.unstable_opts.drop_tracking_mir\n         && let DefKind::Generator = tcx.def_kind(def.did)\n     {\n-        tcx.ensure().mir_generator_witnesses(def.did);\n+        tcx.ensure_with_value().mir_generator_witnesses(def.did);\n     }\n     let mir_borrowck = tcx.mir_borrowck_opt_const_arg(def);\n \n@@ -444,7 +443,7 @@ fn mir_drops_elaborated_and_const_checked(\n \n         // Do not compute the mir call graph without said call graph actually being used.\n         if inline::Inline.is_enabled(&tcx.sess) {\n-            let _ = tcx.mir_inliner_callees(ty::InstanceDef::Item(def));\n+            tcx.ensure_with_value().mir_inliner_callees(ty::InstanceDef::Item(def));\n         }\n     }\n \n@@ -533,6 +532,12 @@ fn run_runtime_cleanup_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         &[&lower_intrinsics::LowerIntrinsics, &simplify::SimplifyCfg::new(\"elaborate-drops\")];\n \n     pm::run_passes(tcx, body, passes, Some(MirPhase::Runtime(RuntimePhase::PostCleanup)));\n+\n+    // Clear this by anticipation. Optimizations and runtime MIR have no reason to look\n+    // into this information, which is meant for borrowck diagnostics.\n+    for decl in &mut body.local_decls {\n+        decl.local_info = ClearCrossCrate::Clear;\n+    }\n }\n \n fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n@@ -613,7 +618,7 @@ fn inner_optimized_mir(tcx: TyCtxt<'_>, did: LocalDefId) -> Body<'_> {\n         // Run the `mir_for_ctfe` query, which depends on `mir_drops_elaborated_and_const_checked`\n         // which we are going to steal below. Thus we need to run `mir_for_ctfe` first, so it\n         // computes and caches its result.\n-        Some(hir::ConstContext::ConstFn) => tcx.ensure().mir_for_ctfe(did),\n+        Some(hir::ConstContext::ConstFn) => tcx.ensure_with_value().mir_for_ctfe(did),\n         None => {}\n         Some(other) => panic!(\"do not use `optimized_mir` for constants: {:?}\", other),\n     }"}, {"sha": "b6e73eaad5095904d143fdcb2f63e7d52a4ac3a3", "filename": "compiler/rustc_mir_transform/src/nrvo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -102,7 +102,7 @@ fn local_eligible_for_nrvo(body: &mut mir::Body<'_>) -> Option<Local> {\n             mir::LocalKind::Arg => return None,\n \n             mir::LocalKind::ReturnPointer => bug!(\"Return place was assigned to itself?\"),\n-            mir::LocalKind::Var | mir::LocalKind::Temp => {}\n+            mir::LocalKind::Temp => {}\n         }\n \n         // If multiple different locals are copied to the return place. We can't pick a"}, {"sha": "6cea6a603f336564c77b24dc8930eeaa48fc9ca7", "filename": "compiler/rustc_monomorphize/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_monomorphize%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_monomorphize%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_monomorphize/locales/en-US.ftl"}, {"sha": "5000fb71937d492641c7925188b40bb3b27e3051", "filename": "compiler/rustc_monomorphize/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -23,7 +23,7 @@ mod partitioning;\n mod polymorphize;\n mod util;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n fn custom_coerce_unsize_info<'tcx>(\n     tcx: TyCtxtAt<'tcx>,"}, {"sha": "c39ada95a4ec47a012e266cedd14eb4b8bbb0436", "filename": "compiler/rustc_parse/messages.ftl", "status": "renamed", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_parse%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_parse%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -709,7 +709,7 @@ parse_zero_chars = empty character literal\n parse_lone_slash = invalid trailing slash in literal\n     .label = {parse_lone_slash}\n \n-parse_unskipped_whitespace = non-ASCII whitespace symbol '{$ch}' is not skipped\n+parse_unskipped_whitespace = whitespace symbol '{$ch}' is not skipped\n     .label = {parse_unskipped_whitespace}\n \n parse_multiple_skipped_lines = multiple lines skipped by escaped newline\n@@ -731,3 +731,6 @@ parse_unknown_start_of_token = unknown start of token: {$escaped}\n         [one] once more\n         *[other] {$repeats} more times\n     }\n+\n+parse_box_syntax_removed = `box_syntax` has been removed\n+    .suggestion = use `Box::new()` instead", "previous_filename": "compiler/rustc_parse/locales/en-US.ftl"}, {"sha": "af0c3026c6605acd9734bc3c0691b8d80ceb112e", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -2300,3 +2300,16 @@ impl HelpUseLatestEdition {\n         }\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_box_syntax_removed)]\n+pub struct BoxSyntaxRemoved<'a> {\n+    #[primary_span]\n+    #[suggestion(\n+        code = \"Box::new({code})\",\n+        applicability = \"machine-applicable\",\n+        style = \"verbose\"\n+    )]\n+    pub span: Span,\n+    pub code: &'a str,\n+}"}, {"sha": "17466cd0e6dceaef681497e167b4b831119226a6", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -36,7 +36,7 @@ pub mod validate_attr;\n \n mod errors;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n // A bunch of utility functions of the form `parse_<thing>_from_<source>`\n // where <thing> includes crate, expr, item, stmt, tts, and one that"}, {"sha": "296eb4d653cdd83991b2387520a7fbf3db10f567", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -8,6 +8,7 @@ use super::{\n \n use crate::errors;\n use crate::maybe_recover_from_interpolated_ty_qpath;\n+use ast::{Path, PathSegment};\n use core::mem;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, Token, TokenKind};\n@@ -29,6 +30,7 @@ use rustc_session::errors::{report_lit_error, ExprParenthesesNeeded};\n use rustc_session::lint::builtin::BREAK_WITH_LABEL_AND_LOOP;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::source_map::{self, Span, Spanned};\n+use rustc_span::symbol::kw::PathRoot;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Pos};\n use thin_vec::{thin_vec, ThinVec};\n@@ -636,11 +638,27 @@ impl<'a> Parser<'a> {\n         self.parse_expr_unary(lo, UnOp::Not)\n     }\n \n-    /// Parse `box expr`.\n+    /// Parse `box expr` - this syntax has been removed, but we still parse this\n+    /// for now to provide an automated way to fix usages of it\n     fn parse_expr_box(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n         let (span, expr) = self.parse_expr_prefix_common(lo)?;\n-        self.sess.gated_spans.gate(sym::box_syntax, span);\n-        Ok((span, ExprKind::Box(expr)))\n+        let code = self.sess.source_map().span_to_snippet(span.with_lo(lo.hi())).unwrap();\n+        self.sess.emit_err(errors::BoxSyntaxRemoved { span, code: code.trim() });\n+        // So typechecking works, parse `box <expr>` as `::std::boxed::Box::new(expr)`\n+        let path = Path {\n+            span,\n+            segments: [\n+                PathSegment::from_ident(Ident::with_dummy_span(PathRoot)),\n+                PathSegment::from_ident(Ident::with_dummy_span(sym::std)),\n+                PathSegment::from_ident(Ident::from_str(\"boxed\")),\n+                PathSegment::from_ident(Ident::from_str(\"Box\")),\n+                PathSegment::from_ident(Ident::with_dummy_span(sym::new)),\n+            ]\n+            .into(),\n+            tokens: None,\n+        };\n+        let path = self.mk_expr(span, ExprKind::Path(None, path));\n+        Ok((span, self.mk_call(path, ThinVec::from([expr]))))\n     }\n \n     fn is_mistaken_not_ident_negation(&self) -> bool {\n@@ -2105,7 +2123,7 @@ impl<'a> Parser<'a> {\n             ClosureBinder::NotPresent\n         };\n \n-        let constness = self.parse_closure_constness(Case::Sensitive);\n+        let constness = self.parse_closure_constness();\n \n         let movability =\n             if self.eat_keyword(kw::Static) { Movability::Static } else { Movability::Movable };"}, {"sha": "3251dd6d0c6fbff002a555cc41b25afd11d0b8a3", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1196,9 +1196,13 @@ impl<'a> Parser<'a> {\n         self.parse_constness_(case, false)\n     }\n \n-    /// Parses constness for closures\n-    fn parse_closure_constness(&mut self, case: Case) -> Const {\n-        self.parse_constness_(case, true)\n+    /// Parses constness for closures (case sensitive, feature-gated)\n+    fn parse_closure_constness(&mut self) -> Const {\n+        let constness = self.parse_constness_(Case::Sensitive, true);\n+        if let Const::Yes(span) = constness {\n+            self.sess.gated_spans.gate(sym::const_closures, span);\n+        }\n+        constness\n     }\n \n     fn parse_constness_(&mut self, case: Case, is_closure: bool) -> Const {"}, {"sha": "3d9d2cc62e3851c810de5b0bba579f8db7f47c20", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -624,10 +624,12 @@ impl<'a> Parser<'a> {\n     ///\n     /// Note that this does *not* parse bare trait objects.\n     fn parse_dyn_ty(&mut self, impl_dyn_multi: &mut bool) -> PResult<'a, TyKind> {\n+        let lo = self.token.span;\n         self.bump(); // `dyn`\n \n         // parse dyn* types\n         let syntax = if self.eat(&TokenKind::BinOp(token::Star)) {\n+            self.sess.gated_spans.gate(sym::dyn_star, lo.to(self.prev_token.span));\n             TraitObjectSyntax::DynStar\n         } else {\n             TraitObjectSyntax::Dyn"}, {"sha": "1c5410c5658c61d91e4add7c7e1ea4e66b7cc30c", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 45, "deletions": 9, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -14,6 +14,7 @@\n // We want to be able to build this crate with a stable compiler, so no\n // `#![feature]` attributes should be added.\n \n+use rustc_lexer::unescape;\n pub use Alignment::*;\n pub use Count::*;\n pub use Piece::*;\n@@ -234,8 +235,10 @@ pub struct Parser<'a> {\n     last_opening_brace: Option<InnerSpan>,\n     /// Whether the source string is comes from `println!` as opposed to `format!` or `print!`\n     append_newline: bool,\n-    /// Whether this formatting string is a literal or it comes from a macro.\n-    pub is_literal: bool,\n+    /// Whether this formatting string was written directly in the source. This controls whether we\n+    /// can use spans to refer into it and give better error messages.\n+    /// N.B: This does _not_ control whether implicit argument captures can be used.\n+    pub is_source_literal: bool,\n     /// Start position of the current line.\n     cur_line_start: usize,\n     /// Start and end byte offset of every line of the format string. Excludes\n@@ -262,7 +265,7 @@ impl<'a> Iterator for Parser<'a> {\n                     } else {\n                         let arg = self.argument(lbrace_end);\n                         if let Some(rbrace_pos) = self.must_consume('}') {\n-                            if self.is_literal {\n+                            if self.is_source_literal {\n                                 let lbrace_byte_pos = self.to_span_index(pos);\n                                 let rbrace_byte_pos = self.to_span_index(rbrace_pos);\n \n@@ -302,7 +305,7 @@ impl<'a> Iterator for Parser<'a> {\n                 _ => Some(String(self.string(pos))),\n             }\n         } else {\n-            if self.is_literal {\n+            if self.is_source_literal {\n                 let span = self.span(self.cur_line_start, self.input.len());\n                 if self.line_spans.last() != Some(&span) {\n                     self.line_spans.push(span);\n@@ -322,8 +325,8 @@ impl<'a> Parser<'a> {\n         append_newline: bool,\n         mode: ParseMode,\n     ) -> Parser<'a> {\n-        let input_string_kind = find_width_map_from_snippet(snippet, style);\n-        let (width_map, is_literal) = match input_string_kind {\n+        let input_string_kind = find_width_map_from_snippet(s, snippet, style);\n+        let (width_map, is_source_literal) = match input_string_kind {\n             InputStringKind::Literal { width_mappings } => (width_mappings, true),\n             InputStringKind::NotALiteral => (Vec::new(), false),\n         };\n@@ -339,7 +342,7 @@ impl<'a> Parser<'a> {\n             width_map,\n             last_opening_brace: None,\n             append_newline,\n-            is_literal,\n+            is_source_literal,\n             cur_line_start: 0,\n             line_spans: vec![],\n         }\n@@ -532,13 +535,13 @@ impl<'a> Parser<'a> {\n                 '{' | '}' => {\n                     return &self.input[start..pos];\n                 }\n-                '\\n' if self.is_literal => {\n+                '\\n' if self.is_source_literal => {\n                     self.line_spans.push(self.span(self.cur_line_start, pos));\n                     self.cur_line_start = pos + 1;\n                     self.cur.next();\n                 }\n                 _ => {\n-                    if self.is_literal && pos == self.cur_line_start && c.is_whitespace() {\n+                    if self.is_source_literal && pos == self.cur_line_start && c.is_whitespace() {\n                         self.cur_line_start = pos + c.len_utf8();\n                     }\n                     self.cur.next();\n@@ -890,6 +893,7 @@ impl<'a> Parser<'a> {\n /// written code (code snippet) and the `InternedString` that gets processed in the `Parser`\n /// in order to properly synthesise the intra-string `Span`s for error diagnostics.\n fn find_width_map_from_snippet(\n+    input: &str,\n     snippet: Option<string::String>,\n     str_style: Option<usize>,\n ) -> InputStringKind {\n@@ -902,8 +906,27 @@ fn find_width_map_from_snippet(\n         return InputStringKind::Literal { width_mappings: Vec::new() };\n     }\n \n+    // Strip quotes.\n     let snippet = &snippet[1..snippet.len() - 1];\n \n+    // Macros like `println` add a newline at the end. That technically doens't make them \"literals\" anymore, but it's fine\n+    // since we will never need to point our spans there, so we lie about it here by ignoring it.\n+    // Since there might actually be newlines in the source code, we need to normalize away all trailing newlines.\n+    // If we only trimmed it off the input, `format!(\"\\n\")` would cause a mismatch as here we they actually match up.\n+    // Alternatively, we could just count the trailing newlines and only trim one from the input if they don't match up.\n+    let input_no_nl = input.trim_end_matches('\\n');\n+    let Some(unescaped) = unescape_string(snippet) else {\n+        return InputStringKind::NotALiteral;\n+    };\n+\n+    let unescaped_no_nl = unescaped.trim_end_matches('\\n');\n+\n+    if unescaped_no_nl != input_no_nl {\n+        // The source string that we're pointing at isn't our input, so spans pointing at it will be incorrect.\n+        // This can for example happen with proc macros that respan generated literals.\n+        return InputStringKind::NotALiteral;\n+    }\n+\n     let mut s = snippet.char_indices();\n     let mut width_mappings = vec![];\n     while let Some((pos, c)) = s.next() {\n@@ -986,6 +1009,19 @@ fn find_width_map_from_snippet(\n     InputStringKind::Literal { width_mappings }\n }\n \n+fn unescape_string(string: &str) -> Option<string::String> {\n+    let mut buf = string::String::new();\n+    let mut ok = true;\n+    unescape::unescape_literal(string, unescape::Mode::Str, &mut |_, unescaped_char| {\n+        match unescaped_char {\n+            Ok(c) => buf.push(c),\n+            Err(_) => ok = false,\n+        }\n+    });\n+\n+    ok.then_some(buf)\n+}\n+\n // Assert a reasonable size for `Piece`\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Piece<'_>, 16);"}, {"sha": "3fa78efc290ba2406cd46cd7723e2dbf2460fd1c", "filename": "compiler/rustc_passes/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_passes%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_passes%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_passes/locales/en-US.ftl"}, {"sha": "c8d371dd0846b8c2c0dcc27146a5e22ec8d14165", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -2215,7 +2215,7 @@ impl CheckAttrVisitor<'_> {\n             // `fn(TokenStream) -> TokenStream` after some substitution of generic arguments.\n             //\n             // Properly checking this means pulling in additional `rustc` crates, so we don't.\n-            let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsInfer };\n+            let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsCandidateKey };\n \n             if sig.abi != Abi::Rust {\n                 tcx.sess.emit_err(errors::ProcMacroInvalidAbi {"}, {"sha": "ec1e1d0054b3fc63203b2e1239dd74b29a9c93ae", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -243,6 +243,12 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n                 continue;\n             }\n \n+            // Avoid accessing the HIR for the synthesized associated type generated for RPITITs.\n+            if self.tcx.opt_rpitit_info(id.to_def_id()).is_some() {\n+                self.live_symbols.insert(id);\n+                continue;\n+            }\n+\n             // in the case of tuple struct constructors we want to check the item, not the generated\n             // tuple struct constructor function\n             let id = self.struct_constructors.get(&id).copied().unwrap_or(id);"}, {"sha": "3e0d53029ef995bce40160725cb524b96b8af0b3", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -565,7 +565,7 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n         record_variants!(\n             (self, e, e.kind, Id::None, ast, Expr, ExprKind),\n             [\n-                Box, Array, ConstBlock, Call, MethodCall, Tup, Binary, Unary, Lit, Cast, Type, Let,\n+                Array, ConstBlock, Call, MethodCall, Tup, Binary, Unary, Lit, Cast, Type, Let,\n                 If, While, ForLoop, Loop, Match, Closure, Block, Async, Await, TryBlock, Assign,\n                 AssignOp, Field, Index, Range, Underscore, Path, AddrOf, Break, Continue, Ret,\n                 InlineAsm, FormatArgs, MacCall, Struct, Repeat, Paren, Try, Yield, Yeet, IncludedBytes, Err"}, {"sha": "b7e07aff42bf27631b2c2550aca032c41105552b", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -42,7 +42,7 @@ pub mod stability;\n mod upvars;\n mod weak_lang_items;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n pub fn provide(providers: &mut Providers) {\n     check_attr::provide(providers);"}, {"sha": "8db32a42c1deac0c1a01520c4e0cfe607c85b028", "filename": "compiler/rustc_plugin_impl/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_plugin_impl%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_plugin_impl%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_plugin_impl%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_plugin_impl/locales/en-US.ftl"}, {"sha": "672189e22cfc633fd9e0510865d3534023aaf935", "filename": "compiler/rustc_plugin_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_plugin_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_plugin_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_plugin_impl%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -18,7 +18,7 @@ use rustc_macros::fluent_messages;\n mod errors;\n pub mod load;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n /// Structure used to register plugins.\n ///"}, {"sha": "a26d1b2b381e83024f1bd110aab18d0e3753821d", "filename": "compiler/rustc_privacy/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_privacy%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_privacy%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_privacy/locales/en-US.ftl"}, {"sha": "ef7c68c1a335ac523af196392969c9804cc97df0", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -46,7 +46,7 @@ use errors::{\n     UnnamedItemIsPrivate,\n };\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n ////////////////////////////////////////////////////////////////////////////////\n /// Generic infrastructure used to implement specific visitors below."}, {"sha": "035bfe978f20831702974893202fff28305b1053", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -31,6 +31,7 @@ use rustc_span::Span;\n #[macro_use]\n mod plumbing;\n pub use plumbing::QueryCtxt;\n+use rustc_query_system::dep_graph::SerializedDepNodeIndex;\n use rustc_query_system::query::*;\n #[cfg(parallel_compiler)]\n pub use rustc_query_system::query::{deadlock, QueryContext};"}, {"sha": "35b7e5919e42ac99b15ed723c2f98177760995a9", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -388,6 +388,12 @@ impl<'sess> OnDiskCache<'sess> {\n         debug_assert!(prev.is_none());\n     }\n \n+    /// Return whether the cached query result can be decoded.\n+    pub fn loadable_from_disk(&self, dep_node_index: SerializedDepNodeIndex) -> bool {\n+        self.query_result_index.contains_key(&dep_node_index)\n+        // with_decoder is infallible, so we can stop here\n+    }\n+\n     /// Returns the cached query result if there is something in the cache for\n     /// the given `SerializedDepNodeIndex`; otherwise returns `None`.\n     pub fn try_load_query_result<'tcx, T>(\n@@ -398,7 +404,9 @@ impl<'sess> OnDiskCache<'sess> {\n     where\n         T: for<'a> Decodable<CacheDecoder<'a, 'tcx>>,\n     {\n-        self.load_indexed(tcx, dep_node_index, &self.query_result_index)\n+        let opt_value = self.load_indexed(tcx, dep_node_index, &self.query_result_index);\n+        debug_assert_eq!(opt_value.is_some(), self.loadable_from_disk(dep_node_index));\n+        opt_value\n     }\n \n     /// Stores side effect emitted during computation of an anonymous query.\n@@ -428,8 +436,8 @@ impl<'sess> OnDiskCache<'sess> {\n         T: for<'a> Decodable<CacheDecoder<'a, 'tcx>>,\n     {\n         let pos = index.get(&dep_node_index).cloned()?;\n-\n-        self.with_decoder(tcx, pos, |decoder| Some(decode_tagged(decoder, dep_node_index)))\n+        let value = self.with_decoder(tcx, pos, |decoder| decode_tagged(decoder, dep_node_index));\n+        Some(value)\n     }\n \n     fn with_decoder<'a, 'tcx, T, F: for<'s> FnOnce(&mut CacheDecoder<'s, 'tcx>) -> T>("}, {"sha": "ca3c3997df003d43d55277cbc3b227578396cf21", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -364,6 +364,14 @@ where\n     }\n }\n \n+pub(crate) fn loadable_from_disk<'tcx>(tcx: QueryCtxt<'tcx>, id: SerializedDepNodeIndex) -> bool {\n+    if let Some(cache) = tcx.on_disk_cache().as_ref() {\n+        cache.loadable_from_disk(id)\n+    } else {\n+        false\n+    }\n+}\n+\n pub(crate) fn try_load_from_disk<'tcx, V>(\n     tcx: QueryCtxt<'tcx>,\n     id: SerializedDepNodeIndex,\n@@ -535,6 +543,21 @@ macro_rules! define_queries {\n                 })\n             }\n \n+            #[inline]\n+            fn loadable_from_disk(\n+                self,\n+                _qcx: QueryCtxt<'tcx>,\n+                _key: &Self::Key,\n+                _index: SerializedDepNodeIndex,\n+            ) -> bool {\n+                should_ever_cache_on_disk!([$($modifiers)*] {\n+                    self.cache_on_disk(_qcx.tcx, _key) &&\n+                        $crate::plumbing::loadable_from_disk(_qcx, _index)\n+                } {\n+                    false\n+                })\n+            }\n+\n             #[inline(always)]\n             fn anon(self) -> bool {\n                 is_anon!([$($modifiers)*])"}, {"sha": "870e824039cb6a86abe94b83344c74dd327dbc1c", "filename": "compiler/rustc_query_system/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_query_system%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_query_system%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_query_system/locales/en-US.ftl"}, {"sha": "8a9a12386064f41c6c3bf5858ed31d05dc8254e6", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 161, "deletions": 128, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -70,7 +70,7 @@ impl DepNodeColor {\n     }\n }\n \n-struct DepGraphData<K: DepKind> {\n+pub struct DepGraphData<K: DepKind> {\n     /// The new encoding of the dependency graph, optimized for red/green\n     /// tracking. The `current` field is the dependency graph of only the\n     /// current compilation session: We don't merge the previous dep-graph into\n@@ -168,6 +168,11 @@ impl<K: DepKind> DepGraph<K> {\n         DepGraph { data: None, virtual_dep_node_index: Lrc::new(AtomicU32::new(0)) }\n     }\n \n+    #[inline]\n+    pub fn data(&self) -> Option<&DepGraphData<K>> {\n+        self.data.as_deref()\n+    }\n+\n     /// Returns `true` if we are actually building the full dep-graph, and `false` otherwise.\n     #[inline]\n     pub fn is_fully_enabled(&self) -> bool {\n@@ -252,6 +257,38 @@ impl<K: DepKind> DepGraph<K> {\n         K::with_deps(TaskDepsRef::Forbid, op)\n     }\n \n+    #[inline(always)]\n+    pub fn with_task<Ctxt: HasDepContext<DepKind = K>, A: Debug, R>(\n+        &self,\n+        key: DepNode<K>,\n+        cx: Ctxt,\n+        arg: A,\n+        task: fn(Ctxt, A) -> R,\n+        hash_result: Option<fn(&mut StableHashingContext<'_>, &R) -> Fingerprint>,\n+    ) -> (R, DepNodeIndex) {\n+        match self.data() {\n+            Some(data) => data.with_task(key, cx, arg, task, hash_result),\n+            None => (task(cx, arg), self.next_virtual_depnode_index()),\n+        }\n+    }\n+\n+    pub fn with_anon_task<Tcx: DepContext<DepKind = K>, OP, R>(\n+        &self,\n+        cx: Tcx,\n+        dep_kind: K,\n+        op: OP,\n+    ) -> (R, DepNodeIndex)\n+    where\n+        OP: FnOnce() -> R,\n+    {\n+        match self.data() {\n+            Some(data) => data.with_anon_task(cx, dep_kind, op),\n+            None => (op(), self.next_virtual_depnode_index()),\n+        }\n+    }\n+}\n+\n+impl<K: DepKind> DepGraphData<K> {\n     /// Starts a new dep-graph task. Dep-graph tasks are specified\n     /// using a free function (`task`) and **not** a closure -- this\n     /// is intentional because we want to exercise tight control over\n@@ -288,29 +325,6 @@ impl<K: DepKind> DepGraph<K> {\n         task: fn(Ctxt, A) -> R,\n         hash_result: Option<fn(&mut StableHashingContext<'_>, &R) -> Fingerprint>,\n     ) -> (R, DepNodeIndex) {\n-        if self.is_fully_enabled() {\n-            self.with_task_impl(key, cx, arg, task, hash_result)\n-        } else {\n-            // Incremental compilation is turned off. We just execute the task\n-            // without tracking. We still provide a dep-node index that uniquely\n-            // identifies the task so that we have a cheap way of referring to\n-            // the query for self-profiling.\n-            (task(cx, arg), self.next_virtual_depnode_index())\n-        }\n-    }\n-\n-    #[inline(always)]\n-    fn with_task_impl<Ctxt: HasDepContext<DepKind = K>, A: Debug, R>(\n-        &self,\n-        key: DepNode<K>,\n-        cx: Ctxt,\n-        arg: A,\n-        task: fn(Ctxt, A) -> R,\n-        hash_result: Option<fn(&mut StableHashingContext<'_>, &R) -> Fingerprint>,\n-    ) -> (R, DepNodeIndex) {\n-        // This function is only called when the graph is enabled.\n-        let data = self.data.as_ref().unwrap();\n-\n         // If the following assertion triggers, it can have two reasons:\n         // 1. Something is wrong with DepNode creation, either here or\n         //    in `DepGraph::try_mark_green()`.\n@@ -351,9 +365,9 @@ impl<K: DepKind> DepGraph<K> {\n         let print_status = cfg!(debug_assertions) && dcx.sess().opts.unstable_opts.dep_tasks;\n \n         // Intern the new `DepNode`.\n-        let (dep_node_index, prev_and_color) = data.current.intern_node(\n+        let (dep_node_index, prev_and_color) = self.current.intern_node(\n             dcx.profiler(),\n-            &data.previous,\n+            &self.previous,\n             key,\n             edges,\n             current_fingerprint,\n@@ -364,12 +378,12 @@ impl<K: DepKind> DepGraph<K> {\n \n         if let Some((prev_index, color)) = prev_and_color {\n             debug_assert!(\n-                data.colors.get(prev_index).is_none(),\n+                self.colors.get(prev_index).is_none(),\n                 \"DepGraph::with_task() - Duplicate DepNodeColor \\\n                             insertion for {key:?}\"\n             );\n \n-            data.colors.insert(prev_index, color);\n+            self.colors.insert(prev_index, color);\n         }\n \n         (result, dep_node_index)\n@@ -388,57 +402,55 @@ impl<K: DepKind> DepGraph<K> {\n     {\n         debug_assert!(!cx.is_eval_always(dep_kind));\n \n-        if let Some(ref data) = self.data {\n-            let task_deps = Lock::new(TaskDeps::default());\n-            let result = K::with_deps(TaskDepsRef::Allow(&task_deps), op);\n-            let task_deps = task_deps.into_inner();\n-            let task_deps = task_deps.reads;\n-\n-            let dep_node_index = match task_deps.len() {\n-                0 => {\n-                    // Because the dep-node id of anon nodes is computed from the sets of its\n-                    // dependencies we already know what the ID of this dependency-less node is\n-                    // going to be (i.e. equal to the precomputed\n-                    // `SINGLETON_DEPENDENCYLESS_ANON_NODE`). As a consequence we can skip creating\n-                    // a `StableHasher` and sending the node through interning.\n-                    DepNodeIndex::SINGLETON_DEPENDENCYLESS_ANON_NODE\n-                }\n-                1 => {\n-                    // When there is only one dependency, don't bother creating a node.\n-                    task_deps[0]\n-                }\n-                _ => {\n-                    // The dep node indices are hashed here instead of hashing the dep nodes of the\n-                    // dependencies. These indices may refer to different nodes per session, but this isn't\n-                    // a problem here because we that ensure the final dep node hash is per session only by\n-                    // combining it with the per session random number `anon_id_seed`. This hash only need\n-                    // to map the dependencies to a single value on a per session basis.\n-                    let mut hasher = StableHasher::new();\n-                    task_deps.hash(&mut hasher);\n-\n-                    let target_dep_node = DepNode {\n-                        kind: dep_kind,\n-                        // Fingerprint::combine() is faster than sending Fingerprint\n-                        // through the StableHasher (at least as long as StableHasher\n-                        // is so slow).\n-                        hash: data.current.anon_id_seed.combine(hasher.finish()).into(),\n-                    };\n+        let task_deps = Lock::new(TaskDeps::default());\n+        let result = K::with_deps(TaskDepsRef::Allow(&task_deps), op);\n+        let task_deps = task_deps.into_inner();\n+        let task_deps = task_deps.reads;\n+\n+        let dep_node_index = match task_deps.len() {\n+            0 => {\n+                // Because the dep-node id of anon nodes is computed from the sets of its\n+                // dependencies we already know what the ID of this dependency-less node is\n+                // going to be (i.e. equal to the precomputed\n+                // `SINGLETON_DEPENDENCYLESS_ANON_NODE`). As a consequence we can skip creating\n+                // a `StableHasher` and sending the node through interning.\n+                DepNodeIndex::SINGLETON_DEPENDENCYLESS_ANON_NODE\n+            }\n+            1 => {\n+                // When there is only one dependency, don't bother creating a node.\n+                task_deps[0]\n+            }\n+            _ => {\n+                // The dep node indices are hashed here instead of hashing the dep nodes of the\n+                // dependencies. These indices may refer to different nodes per session, but this isn't\n+                // a problem here because we that ensure the final dep node hash is per session only by\n+                // combining it with the per session random number `anon_id_seed`. This hash only need\n+                // to map the dependencies to a single value on a per session basis.\n+                let mut hasher = StableHasher::new();\n+                task_deps.hash(&mut hasher);\n+\n+                let target_dep_node = DepNode {\n+                    kind: dep_kind,\n+                    // Fingerprint::combine() is faster than sending Fingerprint\n+                    // through the StableHasher (at least as long as StableHasher\n+                    // is so slow).\n+                    hash: self.current.anon_id_seed.combine(hasher.finish()).into(),\n+                };\n \n-                    data.current.intern_new_node(\n-                        cx.profiler(),\n-                        target_dep_node,\n-                        task_deps,\n-                        Fingerprint::ZERO,\n-                    )\n-                }\n-            };\n+                self.current.intern_new_node(\n+                    cx.profiler(),\n+                    target_dep_node,\n+                    task_deps,\n+                    Fingerprint::ZERO,\n+                )\n+            }\n+        };\n \n-            (result, dep_node_index)\n-        } else {\n-            (op(), self.next_virtual_depnode_index())\n-        }\n+        (result, dep_node_index)\n     }\n+}\n \n+impl<K: DepKind> DepGraph<K> {\n     #[inline]\n     pub fn read_index(&self, dep_node_index: DepNodeIndex) {\n         if let Some(ref data) = self.data {\n@@ -519,9 +531,9 @@ impl<K: DepKind> DepGraph<K> {\n             // value to an existing node.\n             //\n             // For sanity, we still check that the loaded stable hash and the new one match.\n-            if let Some(dep_node_index) = self.dep_node_index_of_opt(&node) {\n+            if let Some(dep_node_index) = data.dep_node_index_of_opt(&node) {\n                 let _current_fingerprint =\n-                    crate::query::incremental_verify_ich(cx, result, &node, hash_result);\n+                    crate::query::incremental_verify_ich(cx, data, result, &node, hash_result);\n \n                 #[cfg(debug_assertions)]\n                 if hash_result.is_some() {\n@@ -577,32 +589,57 @@ impl<K: DepKind> DepGraph<K> {\n             self.next_virtual_depnode_index()\n         }\n     }\n+}\n \n+impl<K: DepKind> DepGraphData<K> {\n     #[inline]\n-    pub fn dep_node_index_of(&self, dep_node: &DepNode<K>) -> DepNodeIndex {\n-        self.dep_node_index_of_opt(dep_node).unwrap()\n+    pub fn dep_node_index_of_opt(&self, dep_node: &DepNode<K>) -> Option<DepNodeIndex> {\n+        if let Some(prev_index) = self.previous.node_to_index_opt(dep_node) {\n+            self.current.prev_index_to_index.lock()[prev_index]\n+        } else {\n+            self.current\n+                .new_node_to_index\n+                .get_shard_by_value(dep_node)\n+                .lock()\n+                .get(dep_node)\n+                .copied()\n+        }\n     }\n \n     #[inline]\n-    pub fn dep_node_index_of_opt(&self, dep_node: &DepNode<K>) -> Option<DepNodeIndex> {\n-        let data = self.data.as_ref().unwrap();\n-        let current = &data.current;\n+    pub fn dep_node_exists(&self, dep_node: &DepNode<K>) -> bool {\n+        self.dep_node_index_of_opt(dep_node).is_some()\n+    }\n \n-        if let Some(prev_index) = data.previous.node_to_index_opt(dep_node) {\n-            current.prev_index_to_index.lock()[prev_index]\n+    fn node_color(&self, dep_node: &DepNode<K>) -> Option<DepNodeColor> {\n+        if let Some(prev_index) = self.previous.node_to_index_opt(dep_node) {\n+            self.colors.get(prev_index)\n         } else {\n-            current.new_node_to_index.get_shard_by_value(dep_node).lock().get(dep_node).copied()\n+            // This is a node that did not exist in the previous compilation session.\n+            None\n         }\n     }\n \n-    #[inline]\n-    pub fn dep_node_exists(&self, dep_node: &DepNode<K>) -> bool {\n-        self.data.is_some() && self.dep_node_index_of_opt(dep_node).is_some()\n+    /// Returns true if the given node has been marked as green during the\n+    /// current compilation session. Used in various assertions\n+    pub fn is_green(&self, dep_node: &DepNode<K>) -> bool {\n+        self.node_color(dep_node).map_or(false, |c| c.is_green())\n     }\n \n     #[inline]\n     pub fn prev_fingerprint_of(&self, dep_node: &DepNode<K>) -> Option<Fingerprint> {\n-        self.data.as_ref().unwrap().previous.fingerprint_of(dep_node)\n+        self.previous.fingerprint_of(dep_node)\n+    }\n+\n+    pub fn mark_debug_loaded_from_disk(&self, dep_node: DepNode<K>) {\n+        self.debug_loaded_from_disk.lock().insert(dep_node);\n+    }\n+}\n+\n+impl<K: DepKind> DepGraph<K> {\n+    #[inline]\n+    pub fn dep_node_exists(&self, dep_node: &DepNode<K>) -> bool {\n+        self.data.as_ref().and_then(|data| data.dep_node_index_of_opt(dep_node)).is_some()\n     }\n \n     /// Checks whether a previous work product exists for `v` and, if\n@@ -617,10 +654,6 @@ impl<K: DepKind> DepGraph<K> {\n         &self.data.as_ref().unwrap().previous_work_products\n     }\n \n-    pub fn mark_debug_loaded_from_disk(&self, dep_node: DepNode<K>) {\n-        self.data.as_ref().unwrap().debug_loaded_from_disk.lock().insert(dep_node);\n-    }\n-\n     pub fn debug_was_loaded_from_disk(&self, dep_node: DepNode<K>) -> bool {\n         self.data.as_ref().unwrap().debug_loaded_from_disk.lock().contains(&dep_node)\n     }\n@@ -645,17 +678,22 @@ impl<K: DepKind> DepGraph<K> {\n \n     fn node_color(&self, dep_node: &DepNode<K>) -> Option<DepNodeColor> {\n         if let Some(ref data) = self.data {\n-            if let Some(prev_index) = data.previous.node_to_index_opt(dep_node) {\n-                return data.colors.get(prev_index);\n-            } else {\n-                // This is a node that did not exist in the previous compilation session.\n-                return None;\n-            }\n+            return data.node_color(dep_node);\n         }\n \n         None\n     }\n \n+    pub fn try_mark_green<Qcx: QueryContext<DepKind = K>>(\n+        &self,\n+        qcx: Qcx,\n+        dep_node: &DepNode<K>,\n+    ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n+        self.data().and_then(|data| data.try_mark_green(qcx, dep_node))\n+    }\n+}\n+\n+impl<K: DepKind> DepGraphData<K> {\n     /// Try to mark a node index for the node dep_node.\n     ///\n     /// A node will have an index, when it's already been marked green, or when we can mark it\n@@ -668,43 +706,39 @@ impl<K: DepKind> DepGraph<K> {\n     ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n         debug_assert!(!qcx.dep_context().is_eval_always(dep_node.kind));\n \n-        // Return None if the dep graph is disabled\n-        let data = self.data.as_ref()?;\n-\n         // Return None if the dep node didn't exist in the previous session\n-        let prev_index = data.previous.node_to_index_opt(dep_node)?;\n+        let prev_index = self.previous.node_to_index_opt(dep_node)?;\n \n-        match data.colors.get(prev_index) {\n+        match self.colors.get(prev_index) {\n             Some(DepNodeColor::Green(dep_node_index)) => return Some((prev_index, dep_node_index)),\n             Some(DepNodeColor::Red) => return None,\n             None => {}\n         }\n \n-        let backtrace = backtrace_printer(qcx.dep_context().sess(), data, prev_index);\n+        let backtrace = backtrace_printer(qcx.dep_context().sess(), self, prev_index);\n \n         // This DepNode and the corresponding query invocation existed\n         // in the previous compilation session too, so we can try to\n         // mark it as green by recursively marking all of its\n         // dependencies green.\n         let ret = self\n-            .try_mark_previous_green(qcx, data, prev_index, &dep_node)\n+            .try_mark_previous_green(qcx, prev_index, &dep_node)\n             .map(|dep_node_index| (prev_index, dep_node_index));\n \n         // We succeeded, no backtrace.\n         backtrace.disable();\n         return ret;\n     }\n \n-    #[instrument(skip(self, qcx, data, parent_dep_node_index), level = \"debug\")]\n+    #[instrument(skip(self, qcx, parent_dep_node_index), level = \"debug\")]\n     fn try_mark_parent_green<Qcx: QueryContext<DepKind = K>>(\n         &self,\n         qcx: Qcx,\n-        data: &DepGraphData<K>,\n         parent_dep_node_index: SerializedDepNodeIndex,\n         dep_node: &DepNode<K>,\n     ) -> Option<()> {\n-        let dep_dep_node_color = data.colors.get(parent_dep_node_index);\n-        let dep_dep_node = &data.previous.index_to_node(parent_dep_node_index);\n+        let dep_dep_node_color = self.colors.get(parent_dep_node_index);\n+        let dep_dep_node = &self.previous.index_to_node(parent_dep_node_index);\n \n         match dep_dep_node_color {\n             Some(DepNodeColor::Green(_)) => {\n@@ -733,8 +767,7 @@ impl<K: DepKind> DepGraph<K> {\n                 dep_dep_node, dep_dep_node.hash,\n             );\n \n-            let node_index =\n-                self.try_mark_previous_green(qcx, data, parent_dep_node_index, dep_dep_node);\n+            let node_index = self.try_mark_previous_green(qcx, parent_dep_node_index, dep_dep_node);\n \n             if node_index.is_some() {\n                 debug!(\"managed to MARK dependency {dep_dep_node:?} as green\",);\n@@ -750,7 +783,7 @@ impl<K: DepKind> DepGraph<K> {\n             return None;\n         }\n \n-        let dep_dep_node_color = data.colors.get(parent_dep_node_index);\n+        let dep_dep_node_color = self.colors.get(parent_dep_node_index);\n \n         match dep_dep_node_color {\n             Some(DepNodeColor::Green(_)) => {\n@@ -783,30 +816,29 @@ impl<K: DepKind> DepGraph<K> {\n     }\n \n     /// Try to mark a dep-node which existed in the previous compilation session as green.\n-    #[instrument(skip(self, qcx, data, prev_dep_node_index), level = \"debug\")]\n+    #[instrument(skip(self, qcx, prev_dep_node_index), level = \"debug\")]\n     fn try_mark_previous_green<Qcx: QueryContext<DepKind = K>>(\n         &self,\n         qcx: Qcx,\n-        data: &DepGraphData<K>,\n         prev_dep_node_index: SerializedDepNodeIndex,\n         dep_node: &DepNode<K>,\n     ) -> Option<DepNodeIndex> {\n         #[cfg(not(parallel_compiler))]\n         {\n             debug_assert!(!self.dep_node_exists(dep_node));\n-            debug_assert!(data.colors.get(prev_dep_node_index).is_none());\n+            debug_assert!(self.colors.get(prev_dep_node_index).is_none());\n         }\n \n         // We never try to mark eval_always nodes as green\n         debug_assert!(!qcx.dep_context().is_eval_always(dep_node.kind));\n \n-        debug_assert_eq!(data.previous.index_to_node(prev_dep_node_index), *dep_node);\n+        debug_assert_eq!(self.previous.index_to_node(prev_dep_node_index), *dep_node);\n \n-        let prev_deps = data.previous.edge_targets_from(prev_dep_node_index);\n+        let prev_deps = self.previous.edge_targets_from(prev_dep_node_index);\n \n         for &dep_dep_node_index in prev_deps {\n-            let backtrace = backtrace_printer(qcx.dep_context().sess(), data, dep_dep_node_index);\n-            let success = self.try_mark_parent_green(qcx, data, dep_dep_node_index, dep_node);\n+            let backtrace = backtrace_printer(qcx.dep_context().sess(), self, dep_dep_node_index);\n+            let success = self.try_mark_parent_green(qcx, dep_dep_node_index, dep_node);\n             backtrace.disable();\n             success?;\n         }\n@@ -819,9 +851,9 @@ impl<K: DepKind> DepGraph<K> {\n \n         // We allocating an entry for the node in the current dependency graph and\n         // adding all the appropriate edges imported from the previous graph\n-        let dep_node_index = data.current.promote_node_and_deps_to_current(\n+        let dep_node_index = self.current.promote_node_and_deps_to_current(\n             qcx.dep_context().profiler(),\n-            &data.previous,\n+            &self.previous,\n             prev_dep_node_index,\n         );\n \n@@ -833,20 +865,20 @@ impl<K: DepKind> DepGraph<K> {\n \n         #[cfg(not(parallel_compiler))]\n         debug_assert!(\n-            data.colors.get(prev_dep_node_index).is_none(),\n+            self.colors.get(prev_dep_node_index).is_none(),\n             \"DepGraph::try_mark_previous_green() - Duplicate DepNodeColor \\\n                       insertion for {dep_node:?}\"\n         );\n \n         if !side_effects.is_empty() {\n-            self.with_query_deserialization(|| {\n-                self.emit_side_effects(qcx, data, dep_node_index, side_effects)\n+            qcx.dep_context().dep_graph().with_query_deserialization(|| {\n+                self.emit_side_effects(qcx, dep_node_index, side_effects)\n             });\n         }\n \n         // ... and finally storing a \"Green\" entry in the color map.\n         // Multiple threads can all write the same color here\n-        data.colors.insert(prev_dep_node_index, DepNodeColor::Green(dep_node_index));\n+        self.colors.insert(prev_dep_node_index, DepNodeColor::Green(dep_node_index));\n \n         debug!(\"successfully marked {dep_node:?} as green\");\n         Some(dep_node_index)\n@@ -859,11 +891,10 @@ impl<K: DepKind> DepGraph<K> {\n     fn emit_side_effects<Qcx: QueryContext<DepKind = K>>(\n         &self,\n         qcx: Qcx,\n-        data: &DepGraphData<K>,\n         dep_node_index: DepNodeIndex,\n         side_effects: QuerySideEffects,\n     ) {\n-        let mut processed = data.processed_side_effects.lock();\n+        let mut processed = self.processed_side_effects.lock();\n \n         if processed.insert(dep_node_index) {\n             // We were the first to insert the node in the set so this thread\n@@ -879,7 +910,9 @@ impl<K: DepKind> DepGraph<K> {\n             }\n         }\n     }\n+}\n \n+impl<K: DepKind> DepGraph<K> {\n     /// Returns true if the given node has been marked as red during the\n     /// current compilation session. Used in various assertions\n     pub fn is_red(&self, dep_node: &DepNode<K>) -> bool {"}, {"sha": "5a7b9ae2ab436cb6054219324993252c8f5f6997", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -6,7 +6,8 @@ mod serialized;\n \n pub use dep_node::{DepKindStruct, DepNode, DepNodeParams, WorkProductId};\n pub use graph::{\n-    hash_result, DepGraph, DepNodeColor, DepNodeIndex, TaskDeps, TaskDepsRef, WorkProduct,\n+    hash_result, DepGraph, DepGraphData, DepNodeColor, DepNodeIndex, TaskDeps, TaskDepsRef,\n+    WorkProduct,\n };\n pub use query::DepGraphQuery;\n pub use serialized::{SerializedDepGraph, SerializedDepNodeIndex};"}, {"sha": "bb812b006e9745cd83828785e8ccd0c5b35e57f2", "filename": "compiler/rustc_query_system/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -30,4 +30,4 @@ pub use error::LayoutOfDepth;\n pub use error::QueryOverflow;\n pub use values::Value;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }"}, {"sha": "a0aeb812af968124f211fa6202335da3c32ed499", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -43,6 +43,8 @@ pub trait QueryConfig<Qcx: QueryContext>: Copy {\n \n     fn try_load_from_disk(self, qcx: Qcx, idx: &Self::Key) -> TryLoadFromDisk<Qcx, Self::Value>;\n \n+    fn loadable_from_disk(self, qcx: Qcx, key: &Self::Key, idx: SerializedDepNodeIndex) -> bool;\n+\n     fn anon(self) -> bool;\n     fn eval_always(self) -> bool;\n     fn depth_limit(self) -> bool;"}, {"sha": "005512cf53e25843f788635dfd97dfe87d00d0f1", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 103, "deletions": 58, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -2,8 +2,8 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::HasDepContext;\n use crate::dep_graph::{DepContext, DepKind, DepNode, DepNodeIndex, DepNodeParams};\n+use crate::dep_graph::{DepGraphData, HasDepContext};\n use crate::ich::StableHashingContext;\n use crate::query::caches::QueryCache;\n use crate::query::job::{report_cycle, QueryInfo, QueryJob, QueryJobId, QueryJobInfo};\n@@ -17,7 +17,7 @@ use rustc_data_structures::profiling::TimingGuard;\n #[cfg(parallel_compiler)]\n use rustc_data_structures::sharded::Sharded;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_data_structures::sync::Lock;\n+use rustc_data_structures::sync::{Lock, LockGuard};\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed, FatalError};\n use rustc_session::Session;\n use rustc_span::{Span, DUMMY_SP};\n@@ -178,16 +178,13 @@ where\n     fn try_start<'b, Qcx>(\n         qcx: &'b Qcx,\n         state: &'b QueryState<K, Qcx::DepKind>,\n+        mut state_lock: LockGuard<'b, FxHashMap<K, QueryResult<Qcx::DepKind>>>,\n         span: Span,\n         key: K,\n     ) -> TryGetJob<'b, K, D>\n     where\n         Qcx: QueryContext + HasDepContext<DepKind = D>,\n     {\n-        #[cfg(parallel_compiler)]\n-        let mut state_lock = state.active.get_shard_by_value(&key).lock();\n-        #[cfg(not(parallel_compiler))]\n-        let mut state_lock = state.active.lock();\n         let lock = &mut *state_lock;\n         let current_job_id = qcx.current_query_job();\n \n@@ -362,7 +359,25 @@ where\n     Qcx: QueryContext,\n {\n     let state = query.query_state(qcx);\n-    match JobOwner::<'_, Q::Key, Qcx::DepKind>::try_start(&qcx, state, span, key) {\n+    #[cfg(parallel_compiler)]\n+    let state_lock = state.active.get_shard_by_value(&key).lock();\n+    #[cfg(not(parallel_compiler))]\n+    let state_lock = state.active.lock();\n+\n+    // For the parallel compiler we need to check both the query cache and query state structures\n+    // while holding the state lock to ensure that 1) the query has not yet completed and 2) the\n+    // query is not still executing. Without checking the query cache here, we can end up\n+    // re-executing the query since `try_start` only checks that the query is not currently\n+    // executing, but another thread may have already completed the query and stores it result\n+    // in the query cache.\n+    if cfg!(parallel_compiler) && qcx.dep_context().sess().threads() > 1 {\n+        if let Some((value, index)) = query.query_cache(qcx).lookup(&key) {\n+            qcx.dep_context().profiler().query_cache_hit(index.into());\n+            return (value, Some(index));\n+        }\n+    }\n+\n+    match JobOwner::<'_, Q::Key, Qcx::DepKind>::try_start(&qcx, state, state_lock, span, key) {\n         TryGetJob::NotYetStarted(job) => {\n             let (result, dep_node_index) = execute_job(query, qcx, key.clone(), dep_node, job.id);\n             let cache = query.query_cache(qcx);\n@@ -411,32 +426,34 @@ where\n     Qcx: QueryContext,\n {\n     let dep_graph = qcx.dep_context().dep_graph();\n+    let dep_graph_data = match dep_graph.data() {\n+        // Fast path for when incr. comp. is off.\n+        None => {\n+            // Fingerprint the key, just to assert that it doesn't\n+            // have anything we don't consider hashable\n+            if cfg!(debug_assertions) {\n+                let _ = key.to_fingerprint(*qcx.dep_context());\n+            }\n \n-    // Fast path for when incr. comp. is off.\n-    if !dep_graph.is_fully_enabled() {\n-        // Fingerprint the key, just to assert that it doesn't\n-        // have anything we don't consider hashable\n-        if cfg!(debug_assertions) {\n-            let _ = key.to_fingerprint(*qcx.dep_context());\n-        }\n-\n-        let prof_timer = qcx.dep_context().profiler().query_provider();\n-        let result = qcx.start_query(job_id, query.depth_limit(), None, || query.compute(qcx, key));\n-        let dep_node_index = dep_graph.next_virtual_depnode_index();\n-        prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n+            let prof_timer = qcx.dep_context().profiler().query_provider();\n+            let result =\n+                qcx.start_query(job_id, query.depth_limit(), None, || query.compute(qcx, key));\n+            let dep_node_index = dep_graph.next_virtual_depnode_index();\n+            prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n+\n+            // Similarly, fingerprint the result to assert that\n+            // it doesn't have anything not considered hashable.\n+            if cfg!(debug_assertions) && let Some(hash_result) = query.hash_result()\n+            {\n+                qcx.dep_context().with_stable_hashing_context(|mut hcx| {\n+                    hash_result(&mut hcx, &result);\n+                });\n+            }\n \n-        // Similarly, fingerprint the result to assert that\n-        // it doesn't have anything not considered hashable.\n-        if cfg!(debug_assertions)\n-            && let Some(hash_result) = query.hash_result()\n-        {\n-            qcx.dep_context().with_stable_hashing_context(|mut hcx| {\n-                hash_result(&mut hcx, &result);\n-            });\n+            return (result, dep_node_index);\n         }\n-\n-        return (result, dep_node_index);\n-    }\n+        Some(data) => data,\n+    };\n \n     if !query.anon() && !query.eval_always() {\n         // `to_dep_node` is expensive for some `DepKind`s.\n@@ -446,7 +463,7 @@ where\n         // The diagnostics for this query will be promoted to the current session during\n         // `try_mark_green()`, so we can ignore them here.\n         if let Some(ret) = qcx.start_query(job_id, false, None, || {\n-            try_load_from_disk_and_cache_in_memory(query, qcx, &key, &dep_node)\n+            try_load_from_disk_and_cache_in_memory(query, dep_graph_data, qcx, &key, &dep_node)\n         }) {\n             return ret;\n         }\n@@ -458,7 +475,7 @@ where\n     let (result, dep_node_index) =\n         qcx.start_query(job_id, query.depth_limit(), Some(&diagnostics), || {\n             if query.anon() {\n-                return dep_graph.with_anon_task(*qcx.dep_context(), query.dep_kind(), || {\n+                return dep_graph_data.with_anon_task(*qcx.dep_context(), query.dep_kind(), || {\n                     query.compute(qcx, key)\n                 });\n             }\n@@ -467,7 +484,7 @@ where\n             let dep_node =\n                 dep_node_opt.unwrap_or_else(|| query.construct_dep_node(*qcx.dep_context(), &key));\n \n-            dep_graph.with_task(\n+            dep_graph_data.with_task(\n                 dep_node,\n                 (qcx, query),\n                 key,\n@@ -495,6 +512,7 @@ where\n #[inline(always)]\n fn try_load_from_disk_and_cache_in_memory<Q, Qcx>(\n     query: Q,\n+    dep_graph_data: &DepGraphData<Qcx::DepKind>,\n     qcx: Qcx,\n     key: &Q::Key,\n     dep_node: &DepNode<Qcx::DepKind>,\n@@ -506,10 +524,9 @@ where\n     // Note this function can be called concurrently from the same query\n     // We must ensure that this is handled correctly.\n \n-    let dep_graph = qcx.dep_context().dep_graph();\n-    let (prev_dep_node_index, dep_node_index) = dep_graph.try_mark_green(qcx, &dep_node)?;\n+    let (prev_dep_node_index, dep_node_index) = dep_graph_data.try_mark_green(qcx, &dep_node)?;\n \n-    debug_assert!(dep_graph.is_green(dep_node));\n+    debug_assert!(dep_graph_data.is_green(dep_node));\n \n     // First we try to load the result from the on-disk cache.\n     // Some things are never cached on disk.\n@@ -519,23 +536,22 @@ where\n         // The call to `with_query_deserialization` enforces that no new `DepNodes`\n         // are created during deserialization. See the docs of that method for more\n         // details.\n-        let result =\n-            dep_graph.with_query_deserialization(|| try_load_from_disk(qcx, prev_dep_node_index));\n+        let result = qcx\n+            .dep_context()\n+            .dep_graph()\n+            .with_query_deserialization(|| try_load_from_disk(qcx, prev_dep_node_index));\n \n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n         if let Some(result) = result {\n             if std::intrinsics::unlikely(\n                 qcx.dep_context().sess().opts.unstable_opts.query_dep_graph,\n             ) {\n-                dep_graph.mark_debug_loaded_from_disk(*dep_node)\n+                dep_graph_data.mark_debug_loaded_from_disk(*dep_node)\n             }\n \n-            let prev_fingerprint = qcx\n-                .dep_context()\n-                .dep_graph()\n-                .prev_fingerprint_of(dep_node)\n-                .unwrap_or(Fingerprint::ZERO);\n+            let prev_fingerprint =\n+                dep_graph_data.prev_fingerprint_of(dep_node).unwrap_or(Fingerprint::ZERO);\n             // If `-Zincremental-verify-ich` is specified, re-hash results from\n             // the cache and make sure that they have the expected fingerprint.\n             //\n@@ -547,7 +563,13 @@ where\n             if std::intrinsics::unlikely(\n                 try_verify || qcx.dep_context().sess().opts.unstable_opts.incremental_verify_ich,\n             ) {\n-                incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query.hash_result());\n+                incremental_verify_ich(\n+                    *qcx.dep_context(),\n+                    dep_graph_data,\n+                    &result,\n+                    dep_node,\n+                    query.hash_result(),\n+                );\n             }\n \n             return Some((result, dep_node_index));\n@@ -557,16 +579,23 @@ where\n         // can be forced from `DepNode`.\n         debug_assert!(\n             !qcx.dep_context().fingerprint_style(dep_node.kind).reconstructible(),\n-            \"missing on-disk cache entry for {dep_node:?}\"\n+            \"missing on-disk cache entry for reconstructible {dep_node:?}\"\n         );\n     }\n \n+    // Sanity check for the logic in `ensure`: if the node is green and the result loadable,\n+    // we should actually be able to load it.\n+    debug_assert!(\n+        !query.loadable_from_disk(qcx, &key, prev_dep_node_index),\n+        \"missing on-disk cache entry for loadable {dep_node:?}\"\n+    );\n+\n     // We could not load a result from the on-disk cache, so\n     // recompute.\n     let prof_timer = qcx.dep_context().profiler().query_provider();\n \n     // The dep-graph for this computation is already in-place.\n-    let result = dep_graph.with_ignore(|| query.compute(qcx, *key));\n+    let result = qcx.dep_context().dep_graph().with_ignore(|| query.compute(qcx, *key));\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -579,15 +608,22 @@ where\n     //\n     // See issue #82920 for an example of a miscompilation that would get turned into\n     // an ICE by this check\n-    incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query.hash_result());\n+    incremental_verify_ich(\n+        *qcx.dep_context(),\n+        dep_graph_data,\n+        &result,\n+        dep_node,\n+        query.hash_result(),\n+    );\n \n     Some((result, dep_node_index))\n }\n \n #[inline]\n-#[instrument(skip(tcx, result, hash_result), level = \"debug\")]\n+#[instrument(skip(tcx, dep_graph_data, result, hash_result), level = \"debug\")]\n pub(crate) fn incremental_verify_ich<Tcx, V: Debug>(\n     tcx: Tcx,\n+    dep_graph_data: &DepGraphData<Tcx::DepKind>,\n     result: &V,\n     dep_node: &DepNode<Tcx::DepKind>,\n     hash_result: Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>,\n@@ -596,15 +632,15 @@ where\n     Tcx: DepContext,\n {\n     assert!(\n-        tcx.dep_graph().is_green(dep_node),\n+        dep_graph_data.is_green(dep_node),\n         \"fingerprint for green query instance not loaded from cache: {dep_node:?}\",\n     );\n \n     let new_hash = hash_result.map_or(Fingerprint::ZERO, |f| {\n         tcx.with_stable_hashing_context(|mut hcx| f(&mut hcx, result))\n     });\n \n-    let old_hash = tcx.dep_graph().prev_fingerprint_of(dep_node);\n+    let old_hash = dep_graph_data.prev_fingerprint_of(dep_node);\n \n     if Some(new_hash) != old_hash {\n         incremental_verify_ich_failed(\n@@ -704,6 +740,7 @@ fn ensure_must_run<Q, Qcx>(\n     query: Q,\n     qcx: Qcx,\n     key: &Q::Key,\n+    check_cache: bool,\n ) -> (bool, Option<DepNode<Qcx::DepKind>>)\n where\n     Q: QueryConfig<Qcx>,\n@@ -719,28 +756,36 @@ where\n     let dep_node = query.construct_dep_node(*qcx.dep_context(), key);\n \n     let dep_graph = qcx.dep_context().dep_graph();\n-    match dep_graph.try_mark_green(qcx, &dep_node) {\n+    let serialized_dep_node_index = match dep_graph.try_mark_green(qcx, &dep_node) {\n         None => {\n             // A None return from `try_mark_green` means that this is either\n             // a new dep node or that the dep node has already been marked red.\n             // Either way, we can't call `dep_graph.read()` as we don't have the\n             // DepNodeIndex. We must invoke the query itself. The performance cost\n             // this introduces should be negligible as we'll immediately hit the\n             // in-memory cache, or another query down the line will.\n-            (true, Some(dep_node))\n+            return (true, Some(dep_node));\n         }\n-        Some((_, dep_node_index)) => {\n+        Some((serialized_dep_node_index, dep_node_index)) => {\n             dep_graph.read_index(dep_node_index);\n             qcx.dep_context().profiler().query_cache_hit(dep_node_index.into());\n-            (false, None)\n+            serialized_dep_node_index\n         }\n+    };\n+\n+    // We do not need the value at all, so do not check the cache.\n+    if !check_cache {\n+        return (false, None);\n     }\n+\n+    let loadable = query.loadable_from_disk(qcx, key, serialized_dep_node_index);\n+    (!loadable, Some(dep_node))\n }\n \n #[derive(Debug)]\n pub enum QueryMode {\n     Get,\n-    Ensure,\n+    Ensure { check_cache: bool },\n }\n \n #[inline(always)]\n@@ -755,8 +800,8 @@ where\n     Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n {\n-    let dep_node = if let QueryMode::Ensure = mode {\n-        let (must_run, dep_node) = ensure_must_run(query, qcx, &key);\n+    let dep_node = if let QueryMode::Ensure { check_cache } = mode {\n+        let (must_run, dep_node) = ensure_must_run(query, qcx, &key, check_cache);\n         if !must_run {\n             return None;\n         }"}, {"sha": "817bb83ed786a6ed3a8267397b5bc0e958da03d1", "filename": "compiler/rustc_resolve/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_resolve%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_resolve%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_resolve/locales/en-US.ftl"}, {"sha": "362ef693c48d5b5576fde410a454fd102f6df021", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 47, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -29,7 +29,6 @@ use rustc_middle::metadata::ModChild;\n use rustc_middle::{bug, ty};\n use rustc_session::cstore::CrateStore;\n use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind};\n-use rustc_span::source_map::respan;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n \n@@ -130,12 +129,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     };\n \n                     let expn_id = self.cstore().module_expansion_untracked(def_id, &self.tcx.sess);\n-                    let span = self.cstore().get_span_untracked(def_id, &self.tcx.sess);\n                     Some(self.new_module(\n                         parent,\n                         ModuleKind::Def(def_kind, def_id, name),\n                         expn_id,\n-                        span,\n+                        self.def_span(def_id),\n                         // FIXME: Account for `#[no_implicit_prelude]` attributes.\n                         parent.map_or(false, |module| module.no_implicit_prelude),\n                     ))\n@@ -328,13 +326,13 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn insert_field_names_local(&mut self, def_id: DefId, vdata: &ast::VariantData) {\n-        let field_names = vdata\n-            .fields()\n-            .iter()\n-            .map(|field| respan(field.span, field.ident.map_or(kw::Empty, |ident| ident.name)))\n-            .collect();\n-        self.r.field_names.insert(def_id, field_names);\n+    fn insert_field_def_ids(&mut self, def_id: LocalDefId, vdata: &ast::VariantData) {\n+        if vdata.fields().iter().any(|field| field.is_placeholder) {\n+            // The fields are not expanded yet.\n+            return;\n+        }\n+        let def_ids = vdata.fields().iter().map(|field| self.r.local_def_id(field.id).to_def_id());\n+        self.r.field_def_ids.insert(def_id, self.r.tcx.arena.alloc_from_iter(def_ids));\n     }\n \n     fn insert_field_visibilities_local(&mut self, def_id: DefId, vdata: &ast::VariantData) {\n@@ -346,12 +344,6 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         self.r.field_visibility_spans.insert(def_id, field_vis);\n     }\n \n-    fn insert_field_names_extern(&mut self, def_id: DefId) {\n-        let field_names =\n-            self.r.cstore().struct_field_names_untracked(def_id, self.r.tcx.sess).collect();\n-        self.r.field_names.insert(def_id, field_names);\n-    }\n-\n     fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n         // If any statements are items, we need to create an anonymous module\n         block\n@@ -749,7 +741,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n                 // Record field names for error reporting.\n-                self.insert_field_names_local(def_id, vdata);\n+                self.insert_field_def_ids(local_def_id, vdata);\n                 self.insert_field_visibilities_local(def_id, vdata);\n \n                 // If this is a tuple or unit struct, define a name\n@@ -789,7 +781,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n \n                     self.r\n                         .struct_constructors\n-                        .insert(def_id, (ctor_res, ctor_vis.to_def_id(), ret_fields));\n+                        .insert(local_def_id, (ctor_res, ctor_vis.to_def_id(), ret_fields));\n                 }\n             }\n \n@@ -798,7 +790,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n                 // Record field names for error reporting.\n-                self.insert_field_names_local(def_id, vdata);\n+                self.insert_field_def_ids(local_def_id, vdata);\n                 self.insert_field_visibilities_local(def_id, vdata);\n             }\n \n@@ -1004,32 +996,6 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             | Res::SelfCtor(..)\n             | Res::Err => bug!(\"unexpected resolution: {:?}\", res),\n         }\n-        // Record some extra data for better diagnostics.\n-        match res {\n-            Res::Def(DefKind::Struct, def_id) => {\n-                let cstore = self.r.cstore();\n-                if let Some((ctor_kind, ctor_def_id)) = cstore.ctor_untracked(def_id) {\n-                    let ctor_res = Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id);\n-                    let ctor_vis = cstore.visibility_untracked(ctor_def_id);\n-                    let field_visibilities =\n-                        cstore.struct_field_visibilities_untracked(def_id).collect();\n-                    drop(cstore);\n-                    self.r\n-                        .struct_constructors\n-                        .insert(def_id, (ctor_res, ctor_vis, field_visibilities));\n-                } else {\n-                    drop(cstore);\n-                }\n-                self.insert_field_names_extern(def_id)\n-            }\n-            Res::Def(DefKind::Union, def_id) => self.insert_field_names_extern(def_id),\n-            Res::Def(DefKind::AssocFn, def_id) => {\n-                if self.r.cstore().fn_has_self_parameter_untracked(def_id, self.r.tcx.sess) {\n-                    self.r.has_self.insert(def_id);\n-                }\n-            }\n-            _ => {}\n-        }\n     }\n \n     fn add_macro_use_binding(\n@@ -1426,7 +1392,7 @@ impl<'a, 'b, 'tcx> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                 AssocItemKind::Const(..) => (DefKind::AssocConst, ValueNS),\n                 AssocItemKind::Fn(box Fn { ref sig, .. }) => {\n                     if sig.decl.has_self() {\n-                        self.r.has_self.insert(def_id);\n+                        self.r.has_self.insert(local_def_id);\n                     }\n                     (DefKind::AssocFn, ValueNS)\n                 }\n@@ -1540,7 +1506,7 @@ impl<'a, 'b, 'tcx> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         }\n \n         // Record field names for error reporting.\n-        self.insert_field_names_local(def_id.to_def_id(), &variant.data);\n+        self.insert_field_def_ids(def_id, &variant.data);\n         self.insert_field_visibilities_local(def_id.to_def_id(), &variant.data);\n \n         visit::walk_variant(self, variant);"}, {"sha": "44a3d4e628ebce8b13a0f30c04ad6fd5004ab461", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 30, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -12,7 +12,7 @@ use rustc_errors::{struct_span_err, SuggestionStyle};\n use rustc_feature::BUILTIN_ATTRIBUTES;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind, PerNS};\n-use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n use rustc_hir::PrimTy;\n use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n@@ -555,25 +555,22 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         return err;\n                     }\n                     Res::SelfTyAlias { alias_to: def_id, .. } => {\n-                        if let Some(impl_span) = self.opt_span(def_id) {\n-                            err.span_label(\n-                                reduce_impl_span_to_impl_keyword(sm, impl_span),\n-                                \"`Self` type implicitly declared here, by this `impl`\",\n-                            );\n-                        }\n+                        err.span_label(\n+                            reduce_impl_span_to_impl_keyword(sm, self.def_span(def_id)),\n+                            \"`Self` type implicitly declared here, by this `impl`\",\n+                        );\n                         err.span_label(span, \"use a type here instead\");\n                         return err;\n                     }\n                     Res::Def(DefKind::TyParam, def_id) => {\n-                        if let Some(span) = self.opt_span(def_id) {\n-                            err.span_label(span, \"type parameter from outer function\");\n-                        }\n+                        err.span_label(self.def_span(def_id), \"type parameter from outer function\");\n                         def_id\n                     }\n                     Res::Def(DefKind::ConstParam, def_id) => {\n-                        if let Some(span) = self.opt_span(def_id) {\n-                            err.span_label(span, \"const parameter from outer function\");\n-                        }\n+                        err.span_label(\n+                            self.def_span(def_id),\n+                            \"const parameter from outer function\",\n+                        );\n                         def_id\n                     }\n                     _ => {\n@@ -589,7 +586,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // Try to retrieve the span of the function signature and generate a new\n                     // message with a local type or const parameter.\n                     let sugg_msg = \"try using a local generic parameter instead\";\n-                    let name = self.opt_name(def_id).unwrap_or(sym::T);\n+                    let name = self.tcx.item_name(def_id);\n                     let (span, snippet) = if span.is_empty() {\n                         let snippet = format!(\"<{}>\", name);\n                         (span, snippet)\n@@ -1216,15 +1213,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // a note about editions\n                             let note = if let Some(did) = did {\n                                 let requires_note = !did.is_local()\n-                                    && this.cstore().item_attrs_untracked(did, this.tcx.sess).any(\n+                                    && this.tcx.get_attrs(did, sym::rustc_diagnostic_item).any(\n                                         |attr| {\n-                                            if attr.has_name(sym::rustc_diagnostic_item) {\n-                                                [sym::TryInto, sym::TryFrom, sym::FromIterator]\n-                                                    .map(|x| Some(x))\n-                                                    .contains(&attr.value_str())\n-                                            } else {\n-                                                false\n-                                            }\n+                                            [sym::TryInto, sym::TryFrom, sym::FromIterator]\n+                                                .map(|x| Some(x))\n+                                                .contains(&attr.value_str())\n                                         },\n                                     );\n \n@@ -1373,8 +1366,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n         if ident.name == kw::Default\n             && let ModuleKind::Def(DefKind::Enum, def_id, _) = parent_scope.module.kind\n-            && let Some(span) = self.opt_span(def_id)\n         {\n+            let span = self.def_span(def_id);\n             let source_map = self.tcx.sess.source_map();\n             let head_span = source_map.guess_head_span(span);\n             if let Ok(head) = source_map.span_to_snippet(head_span) {\n@@ -1450,11 +1443,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Some(suggestion) if suggestion.candidate == kw::Underscore => return false,\n             Some(suggestion) => suggestion,\n         };\n-        let def_span = suggestion.res.opt_def_id().and_then(|def_id| match def_id.krate {\n-            LOCAL_CRATE => self.opt_span(def_id),\n-            _ => Some(self.cstore().get_span_untracked(def_id, self.tcx.sess)),\n-        });\n-        if let Some(def_span) = def_span {\n+        if let Some(def_span) = suggestion.res.opt_def_id().map(|def_id| self.def_span(def_id)) {\n             if span.overlaps(def_span) {\n                 // Don't suggest typo suggestion for itself like in the following:\n                 // error[E0423]: expected function, tuple struct or tuple variant, found struct `X`\n@@ -1592,8 +1581,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         )) = binding.kind\n         {\n             let def_id = self.tcx.parent(ctor_def_id);\n-            let fields = self.field_names.get(&def_id)?;\n-            return fields.iter().map(|name| name.span).reduce(Span::to); // None for `struct Foo()`\n+            return self\n+                .field_def_ids(def_id)?\n+                .iter()\n+                .map(|&field_id| self.def_span(field_id))\n+                .reduce(Span::to); // None for `struct Foo()`\n         }\n         None\n     }"}, {"sha": "eff10e5af9fe879d849ca3df0b7ddc6718de8e28", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -3376,7 +3376,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                         participle: \"defined\",\n                         article: res.article(),\n                         shadowed_binding: res,\n-                        shadowed_binding_span: self.r.opt_span(def_id).expect(\"const parameter defined outside of local crate\"),\n+                        shadowed_binding_span: self.r.def_span(def_id),\n                     }\n                 );\n                 None"}, {"sha": "805c2ff280d8be69ed9e627beeece02ec0191d7f", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 85, "deletions": 61, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -19,7 +19,7 @@ use rustc_errors::{\n use rustc_hir as hir;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind};\n-use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n use rustc_hir::PrimTy;\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n@@ -166,13 +166,6 @@ impl TypoCandidate {\n }\n \n impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n-    fn def_span(&self, def_id: DefId) -> Option<Span> {\n-        match def_id.krate {\n-            LOCAL_CRATE => self.r.opt_span(def_id),\n-            _ => Some(self.r.cstore().get_span_untracked(def_id, self.r.tcx.sess)),\n-        }\n-    }\n-\n     fn make_base_error(\n         &mut self,\n         path: &[Segment],\n@@ -191,7 +184,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 span,\n                 span_label: match res {\n                     Res::Def(kind, def_id) if kind == DefKind::TyParam => {\n-                        self.def_span(def_id).map(|span| (span, \"found this type parameter\"))\n+                        Some((self.r.def_span(def_id), \"found this type parameter\"))\n                     }\n                     _ => None,\n                 },\n@@ -1295,28 +1288,30 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 }\n                 PathSource::Expr(_) | PathSource::TupleStruct(..) | PathSource::Pat => {\n                     let span = find_span(&source, err);\n-                    if let Some(span) = self.def_span(def_id) {\n-                        err.span_label(span, &format!(\"`{}` defined here\", path_str));\n-                    }\n+                    err.span_label(self.r.def_span(def_id), &format!(\"`{path_str}` defined here\"));\n                     let (tail, descr, applicability) = match source {\n                         PathSource::Pat | PathSource::TupleStruct(..) => {\n                             (\"\", \"pattern\", Applicability::MachineApplicable)\n                         }\n                         _ => (\": val\", \"literal\", Applicability::HasPlaceholders),\n                     };\n-                    let (fields, applicability) = match self.r.field_names.get(&def_id) {\n-                        Some(fields) => (\n-                            fields\n+\n+                    let field_ids = self.r.field_def_ids(def_id);\n+                    let (fields, applicability) = match field_ids {\n+                        Some(field_ids) => (\n+                            field_ids\n                                 .iter()\n-                                .map(|f| format!(\"{}{}\", f.node, tail))\n+                                .map(|&field_id| {\n+                                    format!(\"{}{tail}\", self.r.tcx.item_name(field_id))\n+                                })\n                                 .collect::<Vec<String>>()\n                                 .join(\", \"),\n                             applicability,\n                         ),\n                         None => (\"/* fields */\".to_string(), Applicability::HasPlaceholders),\n                     };\n-                    let pad = match self.r.field_names.get(&def_id) {\n-                        Some(fields) if fields.is_empty() => \"\",\n+                    let pad = match field_ids {\n+                        Some(field_ids) if field_ids.is_empty() => \"\",\n                         _ => \" \",\n                     };\n                     err.span_suggestion(\n@@ -1359,17 +1354,14 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 if self.r.tcx.sess.is_nightly_build() {\n                     let msg = \"you might have meant to use `#![feature(trait_alias)]` instead of a \\\n                                `type` alias\";\n-                    if let Some(span) = self.def_span(def_id) {\n-                        if let Ok(snip) = self.r.tcx.sess.source_map().span_to_snippet(span) {\n-                            // The span contains a type alias so we should be able to\n-                            // replace `type` with `trait`.\n-                            let snip = snip.replacen(\"type\", \"trait\", 1);\n-                            err.span_suggestion(span, msg, snip, Applicability::MaybeIncorrect);\n-                        } else {\n-                            err.span_help(span, msg);\n-                        }\n+                    let span = self.r.def_span(def_id);\n+                    if let Ok(snip) = self.r.tcx.sess.source_map().span_to_snippet(span) {\n+                        // The span contains a type alias so we should be able to\n+                        // replace `type` with `trait`.\n+                        let snip = snip.replacen(\"type\", \"trait\", 1);\n+                        err.span_suggestion(span, msg, snip, Applicability::MaybeIncorrect);\n                     } else {\n-                        err.help(msg);\n+                        err.span_help(span, msg);\n                     }\n                 }\n             }\n@@ -1408,19 +1400,38 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 self.suggest_using_enum_variant(err, source, def_id, span);\n             }\n             (Res::Def(DefKind::Struct, def_id), source) if ns == ValueNS => {\n-                let (ctor_def, ctor_vis, fields) =\n-                    if let Some(struct_ctor) = self.r.struct_constructors.get(&def_id).cloned() {\n-                        if let PathSource::Expr(Some(parent)) = source {\n-                            if let ExprKind::Field(..) | ExprKind::MethodCall(..) = parent.kind {\n-                                bad_struct_syntax_suggestion(def_id);\n-                                return true;\n-                            }\n+                let struct_ctor = match def_id.as_local() {\n+                    Some(def_id) => self.r.struct_constructors.get(&def_id).cloned(),\n+                    None => {\n+                        let ctor = self.r.cstore().ctor_untracked(def_id);\n+                        ctor.map(|(ctor_kind, ctor_def_id)| {\n+                            let ctor_res =\n+                                Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id);\n+                            let ctor_vis = self.r.tcx.visibility(ctor_def_id);\n+                            let field_visibilities = self\n+                                .r\n+                                .tcx\n+                                .associated_item_def_ids(def_id)\n+                                .iter()\n+                                .map(|field_id| self.r.tcx.visibility(field_id))\n+                                .collect();\n+                            (ctor_res, ctor_vis, field_visibilities)\n+                        })\n+                    }\n+                };\n+\n+                let (ctor_def, ctor_vis, fields) = if let Some(struct_ctor) = struct_ctor {\n+                    if let PathSource::Expr(Some(parent)) = source {\n+                        if let ExprKind::Field(..) | ExprKind::MethodCall(..) = parent.kind {\n+                            bad_struct_syntax_suggestion(def_id);\n+                            return true;\n                         }\n-                        struct_ctor\n-                    } else {\n-                        bad_struct_syntax_suggestion(def_id);\n-                        return true;\n-                    };\n+                    }\n+                    struct_ctor\n+                } else {\n+                    bad_struct_syntax_suggestion(def_id);\n+                    return true;\n+                };\n \n                 let is_accessible = self.r.is_accessible_from(ctor_vis, self.parent_scope.module);\n                 if !is_expected(ctor_def) || is_accessible {\n@@ -1444,10 +1455,12 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                         );\n \n                         // Use spans of the tuple struct definition.\n-                        self.r\n-                            .field_names\n-                            .get(&def_id)\n-                            .map(|fields| fields.iter().map(|f| f.span).collect::<Vec<_>>())\n+                        self.r.field_def_ids(def_id).map(|field_ids| {\n+                            field_ids\n+                                .iter()\n+                                .map(|&field_id| self.r.def_span(field_id))\n+                                .collect::<Vec<_>>()\n+                        })\n                     }\n                     _ => None,\n                 };\n@@ -1493,9 +1506,10 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 match source {\n                     PathSource::Expr(_) | PathSource::TupleStruct(..) | PathSource::Pat => {\n                         let span = find_span(&source, err);\n-                        if let Some(span) = self.def_span(def_id) {\n-                            err.span_label(span, &format!(\"`{}` defined here\", path_str));\n-                        }\n+                        err.span_label(\n+                            self.r.def_span(def_id),\n+                            &format!(\"`{path_str}` defined here\"),\n+                        );\n                         err.span_suggestion(\n                             span,\n                             \"use this syntax instead\",\n@@ -1508,12 +1522,10 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             }\n             (Res::Def(DefKind::Ctor(_, CtorKind::Fn), ctor_def_id), _) if ns == ValueNS => {\n                 let def_id = self.r.tcx.parent(ctor_def_id);\n-                if let Some(span) = self.def_span(def_id) {\n-                    err.span_label(span, &format!(\"`{}` defined here\", path_str));\n-                }\n-                let fields = self.r.field_names.get(&def_id).map_or_else(\n+                err.span_label(self.r.def_span(def_id), &format!(\"`{path_str}` defined here\"));\n+                let fields = self.r.field_def_ids(def_id).map_or_else(\n                     || \"/* fields */\".to_string(),\n-                    |fields| vec![\"_\"; fields.len()].join(\", \"),\n+                    |field_ids| vec![\"_\"; field_ids.len()].join(\", \"),\n                 );\n                 err.span_suggestion(\n                     span,\n@@ -1594,8 +1606,11 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                     if let Some(Res::Def(DefKind::Struct | DefKind::Union, did)) =\n                         resolution.full_res()\n                     {\n-                        if let Some(field_names) = self.r.field_names.get(&did) {\n-                            if field_names.iter().any(|&field_name| ident.name == field_name.node) {\n+                        if let Some(field_ids) = self.r.field_def_ids(did) {\n+                            if field_ids\n+                                .iter()\n+                                .any(|&field_id| ident.name == self.r.tcx.item_name(field_id))\n+                            {\n                                 return Some(AssocSuggestion::Field);\n                             }\n                         }\n@@ -1630,7 +1645,17 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             ) {\n                 let res = binding.res();\n                 if filter_fn(res) {\n-                    if self.r.has_self.contains(&res.def_id()) {\n+                    let def_id = res.def_id();\n+                    let has_self = match def_id.as_local() {\n+                        Some(def_id) => self.r.has_self.contains(&def_id),\n+                        None => self\n+                            .r\n+                            .tcx\n+                            .fn_arg_names(def_id)\n+                            .first()\n+                            .map_or(false, |ident| ident.name == kw::SelfLower),\n+                    };\n+                    if has_self {\n                         return Some(AssocSuggestion::MethodWithSelf { called });\n                     } else {\n                         match res {\n@@ -1999,11 +2024,12 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         } else {\n             let needs_placeholder = |ctor_def_id: DefId, kind: CtorKind| {\n                 let def_id = self.r.tcx.parent(ctor_def_id);\n-                let has_no_fields = self.r.field_names.get(&def_id).map_or(false, |f| f.is_empty());\n                 match kind {\n                     CtorKind::Const => false,\n-                    CtorKind::Fn if has_no_fields => false,\n-                    _ => true,\n+                    CtorKind::Fn => !self\n+                        .r\n+                        .field_def_ids(def_id)\n+                        .map_or(false, |field_ids| field_ids.is_empty()),\n                 }\n             };\n \n@@ -2064,9 +2090,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         };\n \n         if def_id.is_local() {\n-            if let Some(span) = self.def_span(def_id) {\n-                err.span_note(span, \"the enum is defined here\");\n-            }\n+            err.span_note(self.r.def_span(def_id), \"the enum is defined here\");\n         }\n     }\n "}, {"sha": "cd90fd3ef84d882ffb0d9a5faa18a7402056e281", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 33, "deletions": 40, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -27,14 +27,15 @@ use rustc_ast::{self as ast, NodeId, CRATE_NODE_ID};\n use rustc_ast::{AngleBracketedArg, Crate, Expr, ExprKind, GenericArg, GenericArgs, LitKind, Path};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::intern::Interned;\n+use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{Lrc, MappedReadGuard};\n use rustc_errors::{\n     Applicability, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed, SubdiagnosticMessage,\n };\n use rustc_expand::base::{DeriveResolutions, SyntaxExtension, SyntaxExtensionKind};\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorOf, DefKind, DocLinkResMap, LifetimeRes, PartialRes, PerNS};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LocalDefIdMap, LocalDefIdSet};\n use rustc_hir::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::TraitCandidate;\n@@ -47,10 +48,8 @@ use rustc_middle::span_bug;\n use rustc_middle::ty::{self, MainDefinition, RegisteredTools, TyCtxt};\n use rustc_middle::ty::{ResolverGlobalCtxt, ResolverOutputs};\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_session::cstore::CrateStore;\n use rustc_session::lint::LintBuffer;\n use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind, SyntaxContext, Transparency};\n-use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -80,7 +79,7 @@ mod late;\n mod macros;\n pub mod rustdoc;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n enum Weak {\n     Yes,\n@@ -880,11 +879,8 @@ pub struct Resolver<'a, 'tcx> {\n     extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'a>>,\n \n     /// N.B., this is used only for better diagnostics, not name resolution itself.\n-    has_self: FxHashSet<DefId>,\n-\n-    /// Names of fields of an item `DefId` accessible with dot syntax.\n-    /// Used for hints during error reporting.\n-    field_names: FxHashMap<DefId, Vec<Spanned<Symbol>>>,\n+    has_self: LocalDefIdSet,\n+    field_def_ids: LocalDefIdMap<&'tcx [DefId]>,\n \n     /// Span of the privacy modifier in fields of an item `DefId` accessible with dot syntax.\n     /// Used for hints during error reporting.\n@@ -965,7 +961,7 @@ pub struct Resolver<'a, 'tcx> {\n     /// A small map keeping true kinds of built-in macros that appear to be fn-like on\n     /// the surface (`macro` items in libcore), but are actually attributes or derives.\n     builtin_macro_kinds: FxHashMap<LocalDefId, MacroKind>,\n-    registered_tools: RegisteredTools,\n+    registered_tools: &'tcx RegisteredTools,\n     macro_use_prelude: FxHashMap<Symbol, &'a NameBinding<'a>>,\n     macro_map: FxHashMap<DefId, MacroData>,\n     dummy_ext_bang: Lrc<SyntaxExtension>,\n@@ -1008,7 +1004,7 @@ pub struct Resolver<'a, 'tcx> {\n     /// Table for mapping struct IDs into struct constructor IDs,\n     /// it's not used during normal resolution, only for better error reporting.\n     /// Also includes of list of each fields visibility\n-    struct_constructors: DefIdMap<(Res, ty::Visibility<DefId>, Vec<ty::Visibility<DefId>>)>,\n+    struct_constructors: LocalDefIdMap<(Res, ty::Visibility<DefId>, Vec<ty::Visibility<DefId>>)>,\n \n     /// Features enabled for this crate.\n     active_features: FxHashSet<Symbol>,\n@@ -1233,7 +1229,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        let registered_tools = macros::registered_tools(tcx.sess, &krate.attrs);\n+        let registered_tools = tcx.registered_tools(());\n \n         let features = tcx.sess.features_untracked();\n \n@@ -1248,8 +1244,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             prelude: None,\n             extern_prelude,\n \n-            has_self: FxHashSet::default(),\n-            field_names: FxHashMap::default(),\n+            has_self: Default::default(),\n+            field_def_ids: Default::default(),\n             field_visibility_spans: FxHashMap::default(),\n \n             determined_imports: Vec::new(),\n@@ -1408,7 +1404,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             trait_impls: self.trait_impls,\n             proc_macros,\n             confused_type_with_std_module,\n-            registered_tools: self.registered_tools,\n             doc_link_resolutions: self.doc_link_resolutions,\n             doc_link_traits_in_scope: self.doc_link_traits_in_scope,\n             all_macro_rules: self.all_macro_rules,\n@@ -1426,6 +1421,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             trait_map: self.trait_map,\n             builtin_macro_kinds: self.builtin_macro_kinds,\n             lifetime_elision_allowed: self.lifetime_elision_allowed,\n+            lint_buffer: Steal::new(self.lint_buffer),\n         };\n         ResolverOutputs { global_ctxt, ast_lowering }\n     }\n@@ -1435,9 +1431,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn crate_loader<T>(&mut self, f: impl FnOnce(&mut CrateLoader<'_, '_>) -> T) -> T {\n-        let mut cstore = self.tcx.untracked().cstore.write();\n-        let cstore = cstore.untracked_as_any().downcast_mut().unwrap();\n-        f(&mut CrateLoader::new(self.tcx, &mut *cstore, &mut self.used_extern_options))\n+        f(&mut CrateLoader::new(\n+            self.tcx,\n+            &mut CStore::from_tcx_mut(self.tcx),\n+            &mut self.used_extern_options,\n+        ))\n     }\n \n     fn cstore(&self) -> MappedReadGuard<'_, CStore> {\n@@ -1849,20 +1847,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         &mut self,\n         path_str: &str,\n         ns: Namespace,\n-        mut parent_scope: ParentScope<'a>,\n+        parent_scope: ParentScope<'a>,\n     ) -> Option<Res> {\n         let mut segments =\n             Vec::from_iter(path_str.split(\"::\").map(Ident::from_str).map(Segment::from_ident));\n         if let Some(segment) = segments.first_mut() {\n-            if segment.ident.name == kw::Crate {\n-                // FIXME: `resolve_path` always resolves `crate` to the current crate root, but\n-                // rustdoc wants it to resolve to the `parent_scope`'s crate root. This trick of\n-                // replacing `crate` with `self` and changing the current module should achieve\n-                // the same effect.\n-                segment.ident.name = kw::SelfLower;\n-                parent_scope.module =\n-                    self.expect_module(parent_scope.module.def_id().krate.as_def_id());\n-            } else if segment.ident.name == kw::Empty {\n+            if segment.ident.name == kw::Empty {\n                 segment.ident.name = kw::PathRoot;\n             }\n         }\n@@ -1877,20 +1867,19 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n-    #[inline]\n-    fn opt_span(&self, def_id: DefId) -> Option<Span> {\n-        def_id.as_local().map(|def_id| self.tcx.source_span(def_id))\n+    /// Retrieves definition span of the given `DefId`.\n+    fn def_span(&self, def_id: DefId) -> Span {\n+        match def_id.as_local() {\n+            Some(def_id) => self.tcx.source_span(def_id),\n+            None => self.cstore().get_span_untracked(def_id, self.tcx.sess),\n+        }\n     }\n \n-    /// Retrieves the name of the given `DefId`.\n-    #[inline]\n-    fn opt_name(&self, def_id: DefId) -> Option<Symbol> {\n-        let def_key = match def_id.as_local() {\n-            Some(def_id) => self.tcx.definitions_untracked().def_key(def_id),\n-            None => self.cstore().def_key(def_id),\n-        };\n-        def_key.get_opt_name()\n+    fn field_def_ids(&self, def_id: DefId) -> Option<&'tcx [DefId]> {\n+        match def_id.as_local() {\n+            Some(def_id) => self.field_def_ids.get(&def_id).copied(),\n+            None => Some(self.tcx.associated_item_def_ids(def_id)),\n+        }\n     }\n \n     /// Checks if an expression refers to a function marked with\n@@ -2040,3 +2029,7 @@ impl Finalize {\n         Finalize { node_id, path_span, root_span, report_private: true }\n     }\n }\n+\n+pub fn provide(providers: &mut ty::query::Providers) {\n+    providers.registered_tools = macros::registered_tools;\n+}"}, {"sha": "37153854f7e7f7c49e03a5a87b817c98a5c2bb2d", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -8,7 +8,6 @@ use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment};\n use rustc_ast::{self as ast, Inline, ItemKind, ModKind, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_attr::StabilityLevel;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, Applicability};\n@@ -20,11 +19,11 @@ use rustc_hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc_hir::def_id::{CrateNum, LocalDefId};\n use rustc_middle::middle::stability;\n use rustc_middle::ty::RegisteredTools;\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::builtin::{LEGACY_DERIVE_HELPERS, SOFT_UNSTABLE};\n use rustc_session::lint::builtin::{UNUSED_MACROS, UNUSED_MACRO_RULES};\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::feature_err;\n-use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{self, ExpnData, ExpnKind, LocalExpnId};\n use rustc_span::hygiene::{AstPass, MacroKind};\n@@ -111,23 +110,28 @@ fn fast_print_path(path: &ast::Path) -> Symbol {\n     }\n }\n \n-pub(crate) fn registered_tools(sess: &Session, attrs: &[ast::Attribute]) -> FxHashSet<Ident> {\n-    let mut registered_tools = FxHashSet::default();\n-    for attr in sess.filter_by_name(attrs, sym::register_tool) {\n+pub(crate) fn registered_tools(tcx: TyCtxt<'_>, (): ()) -> RegisteredTools {\n+    let mut registered_tools = RegisteredTools::default();\n+    let krate = tcx.crate_for_resolver(()).borrow();\n+    for attr in tcx.sess.filter_by_name(&krate.attrs, sym::register_tool) {\n         for nested_meta in attr.meta_item_list().unwrap_or_default() {\n             match nested_meta.ident() {\n                 Some(ident) => {\n                     if let Some(old_ident) = registered_tools.replace(ident) {\n                         let msg = format!(\"{} `{}` was already registered\", \"tool\", ident);\n-                        sess.struct_span_err(ident.span, &msg)\n+                        tcx.sess\n+                            .struct_span_err(ident.span, &msg)\n                             .span_label(old_ident.span, \"already registered here\")\n                             .emit();\n                     }\n                 }\n                 None => {\n                     let msg = format!(\"`{}` only accepts identifiers\", sym::register_tool);\n                     let span = nested_meta.span();\n-                    sess.struct_span_err(span, &msg).span_label(span, \"not an identifier\").emit();\n+                    tcx.sess\n+                        .struct_span_err(span, &msg)\n+                        .span_label(span, \"not an identifier\")\n+                        .emit();\n                 }\n             }\n         }"}, {"sha": "ff53f22d43f9316c829295dcf962e1fee21a875c", "filename": "compiler/rustc_session/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_session%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_session%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_session/locales/en-US.ftl"}, {"sha": "485c3f554625abb3f456988b702ae0c998a3a9c9", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1137,7 +1137,7 @@ impl CrateCheckConfig {\n     }\n \n     /// Fills a `CrateCheckConfig` with well-known configuration values.\n-    fn fill_well_known_values(&mut self) {\n+    fn fill_well_known_values(&mut self, current_target: &Target) {\n         if !self.well_known_values {\n             return;\n         }\n@@ -1229,6 +1229,7 @@ impl CrateCheckConfig {\n             for target in TARGETS\n                 .iter()\n                 .map(|target| Target::expect_builtin(&TargetTriple::from_triple(target)))\n+                .chain(iter::once(current_target.clone()))\n             {\n                 values_target_os.insert(Symbol::intern(&target.options.os));\n                 values_target_family\n@@ -1243,9 +1244,9 @@ impl CrateCheckConfig {\n         }\n     }\n \n-    pub fn fill_well_known(&mut self) {\n+    pub fn fill_well_known(&mut self, current_target: &Target) {\n         self.fill_well_known_names();\n-        self.fill_well_known_values();\n+        self.fill_well_known_values(current_target);\n     }\n }\n "}, {"sha": "74aef7851634bf107ffa7fa0581920b12b2768d1", "filename": "compiler/rustc_session/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_session%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_session%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -42,7 +42,7 @@ pub mod output;\n \n pub use getopts;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n /// Requirements for a `StableHashingContext` to be used in this crate.\n /// This is a hack to allow using the `HashStable_Generic` derive macro"}, {"sha": "fdacf814dd6726c2a37e1714b6654c131cceac73", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -224,6 +224,13 @@ pub struct PerfStats {\n     pub normalize_projection_ty: AtomicUsize,\n }\n \n+#[derive(PartialEq, Eq, PartialOrd, Ord)]\n+pub enum MetadataKind {\n+    None,\n+    Uncompressed,\n+    Compressed,\n+}\n+\n impl Session {\n     pub fn miri_unleashed_feature(&self, span: Span, feature_gate: Option<Symbol>) {\n         self.miri_unleashed_features.lock().push((span, feature_gate));\n@@ -287,6 +294,38 @@ impl Session {\n         self.crate_types.get().unwrap().as_slice()\n     }\n \n+    pub fn needs_crate_hash(&self) -> bool {\n+        // Why is the crate hash needed for these configurations?\n+        // - debug_assertions: for the \"fingerprint the result\" check in\n+        //   `rustc_query_system::query::plumbing::execute_job`.\n+        // - incremental: for query lookups.\n+        // - needs_metadata: for putting into crate metadata.\n+        // - instrument_coverage: for putting into coverage data (see\n+        //   `hash_mir_source`).\n+        cfg!(debug_assertions)\n+            || self.opts.incremental.is_some()\n+            || self.needs_metadata()\n+            || self.instrument_coverage()\n+    }\n+\n+    pub fn metadata_kind(&self) -> MetadataKind {\n+        self.crate_types()\n+            .iter()\n+            .map(|ty| match *ty {\n+                CrateType::Executable | CrateType::Staticlib | CrateType::Cdylib => {\n+                    MetadataKind::None\n+                }\n+                CrateType::Rlib => MetadataKind::Uncompressed,\n+                CrateType::Dylib | CrateType::ProcMacro => MetadataKind::Compressed,\n+            })\n+            .max()\n+            .unwrap_or(MetadataKind::None)\n+    }\n+\n+    pub fn needs_metadata(&self) -> bool {\n+        self.metadata_kind() != MetadataKind::None\n+    }\n+\n     pub fn init_crate_types(&self, crate_types: Vec<CrateType>) {\n         self.crate_types.set(crate_types).expect(\"`crate_types` was initialized twice\")\n     }"}, {"sha": "a1cb810a4293bbc7e0e6d2fd9701d0ebe6f00688", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -100,6 +100,9 @@ pub trait FileLoader {\n \n     /// Read the contents of a UTF-8 file into memory.\n     fn read_file(&self, path: &Path) -> io::Result<String>;\n+\n+    /// Read the contents of a potentially non-UTF-8 file into memory.\n+    fn read_binary_file(&self, path: &Path) -> io::Result<Vec<u8>>;\n }\n \n /// A FileLoader that uses std::fs to load real files.\n@@ -113,6 +116,10 @@ impl FileLoader for RealFileLoader {\n     fn read_file(&self, path: &Path) -> io::Result<String> {\n         fs::read_to_string(path)\n     }\n+\n+    fn read_binary_file(&self, path: &Path) -> io::Result<Vec<u8>> {\n+        fs::read(path)\n+    }\n }\n \n /// This is a [SourceFile] identifier that is used to correlate source files between\n@@ -220,9 +227,7 @@ impl SourceMap {\n     /// Unlike `load_file`, guarantees that no normalization like BOM-removal\n     /// takes place.\n     pub fn load_binary_file(&self, path: &Path) -> io::Result<Vec<u8>> {\n-        // Ideally, this should use `self.file_loader`, but it can't\n-        // deal with binary files yet.\n-        let bytes = fs::read(path)?;\n+        let bytes = self.file_loader.read_binary_file(path)?;\n \n         // We need to add file to the `SourceMap`, so that it is present\n         // in dep-info. There's also an edge case that file might be both"}, {"sha": "d8b5b25aaeebdc39de681c401476291f8ea54d54", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -429,6 +429,7 @@ symbols! {\n         borrowck_graphviz_format,\n         borrowck_graphviz_postflow,\n         box_free,\n+        box_new,\n         box_patterns,\n         box_syntax,\n         bpf_target_feature,\n@@ -791,7 +792,6 @@ symbols! {\n         i64,\n         i8,\n         ident,\n-        identity_future,\n         if_let,\n         if_let_guard,\n         if_while_or_patterns,"}, {"sha": "b7d48280f46198d3b72e42a9f8937723d8b2a10e", "filename": "compiler/rustc_symbol_mangling/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_symbol_mangling%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_symbol_mangling%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_symbol_mangling/locales/en-US.ftl"}, {"sha": "c2fd3304f2b37998f880ce6b57da3e4af6054885", "filename": "compiler/rustc_symbol_mangling/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -119,7 +119,7 @@ pub mod errors;\n pub mod test;\n pub mod typeid;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n /// This function computes the symbol name for the given `instance` and the\n /// given instantiating crate. That is, if you know that instance X is"}, {"sha": "14eb4a5502d5c2f2df139f117eba5e09f5793cf9", "filename": "compiler/rustc_trait_selection/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_trait_selection/locales/en-US.ftl"}, {"sha": "f866cb016e2a601134fe952855d14dea79557701", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -44,4 +44,4 @@ pub mod infer;\n pub mod solve;\n pub mod traits;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }"}, {"sha": "891ea0cdebe5031be8908d1a92551530a3267713", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -2,11 +2,13 @@\n \n #[cfg(doc)]\n use super::trait_goals::structural_traits::*;\n-use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n+use super::EvalCtxt;\n use itertools::Itertools;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::elaborate_predicates;\n+use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, MaybeCause, QueryResult};\n+use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use std::fmt::Debug;\n@@ -247,7 +249,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     ///\n     /// To deal with this, we first try to normalize the self type and add the candidates for the normalized\n     /// self type to the list of candidates in case that succeeds. Note that we can't just eagerly return in\n-    /// this case as projections as self types add `\n+    /// this case as projections as self types add\n+    // FIXME complete the unfinished sentence above\n     fn assemble_candidates_after_normalizing_self_ty<G: GoalKind<'tcx>>(\n         &mut self,\n         goal: Goal<'tcx, G>,\n@@ -297,9 +300,10 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         candidates: &mut Vec<Candidate<'tcx>>,\n     ) {\n         let tcx = self.tcx();\n-        tcx.for_each_relevant_impl(\n+        tcx.for_each_relevant_impl_treating_projections(\n             goal.predicate.trait_def_id(tcx),\n             goal.predicate.self_ty(),\n+            TreatProjections::NextSolverLookup,\n             |impl_def_id| match G::consider_impl_candidate(self, goal, impl_def_id) {\n                 Ok(result) => candidates\n                     .push(Candidate { source: CandidateSource::Impl(impl_def_id), result }),"}, {"sha": "7ee4f33230630d0a55a93f0000985a8301708aa9", "filename": "compiler/rustc_trait_selection/src/solve/canonical/canonicalize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -278,16 +278,16 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n                     Err(ui) => CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui)),\n                 }\n             }\n-            ty::Infer(ty::IntVar(_)) => {\n-                let nt = self.infcx.shallow_resolve(t);\n+            ty::Infer(ty::IntVar(vid)) => {\n+                let nt = self.infcx.opportunistic_resolve_int_var(vid);\n                 if nt != t {\n                     return self.fold_ty(nt);\n                 } else {\n                     CanonicalVarKind::Ty(CanonicalTyVarKind::Int)\n                 }\n             }\n-            ty::Infer(ty::FloatVar(_)) => {\n-                let nt = self.infcx.shallow_resolve(t);\n+            ty::Infer(ty::FloatVar(vid)) => {\n+                let nt = self.infcx.opportunistic_resolve_float_var(vid);\n                 if nt != t {\n                     return self.fold_ty(nt);\n                 } else {"}, {"sha": "ca438a103cf342b4655d573c43b7799b0fdc8aa6", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -93,37 +93,42 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         };\n \n         // Guard against `<T as Trait<?0>>::Assoc = ?0>`.\n-        struct ContainsTerm<'tcx> {\n+        struct ContainsTerm<'a, 'tcx> {\n             term: ty::Term<'tcx>,\n+            infcx: &'a InferCtxt<'tcx>,\n         }\n-        impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ContainsTerm<'tcx> {\n+        impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ContainsTerm<'_, 'tcx> {\n             type BreakTy = ();\n             fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                if t.needs_infer() {\n-                    if ty::Term::from(t) == self.term {\n-                        ControlFlow::Break(())\n-                    } else {\n-                        t.super_visit_with(self)\n-                    }\n+                if let Some(vid) = t.ty_vid()\n+                    && let ty::TermKind::Ty(term) = self.term.unpack()\n+                    && let Some(term_vid) = term.ty_vid()\n+                    && self.infcx.root_var(vid) == self.infcx.root_var(term_vid)\n+                {\n+                    ControlFlow::Break(())\n+                } else if t.has_non_region_infer() {\n+                    t.super_visit_with(self)\n                 } else {\n                     ControlFlow::Continue(())\n                 }\n             }\n \n             fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                if c.needs_infer() {\n-                    if ty::Term::from(c) == self.term {\n-                        ControlFlow::Break(())\n-                    } else {\n-                        c.super_visit_with(self)\n-                    }\n+                if let ty::ConstKind::Infer(ty::InferConst::Var(vid)) = c.kind()\n+                    && let ty::TermKind::Const(term) = self.term.unpack()\n+                    && let ty::ConstKind::Infer(ty::InferConst::Var(term_vid)) = term.kind()\n+                    && self.infcx.root_const_var(vid) == self.infcx.root_const_var(term_vid)\n+                {\n+                    ControlFlow::Break(())\n+                } else if c.has_non_region_infer() {\n+                    c.super_visit_with(self)\n                 } else {\n                     ControlFlow::Continue(())\n                 }\n             }\n         }\n \n-        let mut visitor = ContainsTerm { term: goal.predicate.term };\n+        let mut visitor = ContainsTerm { infcx: self.infcx, term: goal.predicate.term };\n \n         term_is_infer\n             && goal.predicate.projection_ty.visit_with(&mut visitor).is_continue()"}, {"sha": "55d361b120441cc616fa73430fc998166e571db4", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 5, "deletions": 92, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -21,11 +21,13 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_infer::traits::query::NoSolution;\n-use rustc_infer::traits::Obligation;\n-use rustc_middle::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n+use rustc_middle::traits::solve::{\n+    CanonicalGoal, CanonicalResponse, Certainty, ExternalConstraints, ExternalConstraintsData,\n+    Goal, MaybeCause, QueryResult, Response,\n+};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{\n-    CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, ToPredicate, TypeOutlivesPredicate,\n+    CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, TypeOutlivesPredicate,\n };\n use rustc_span::DUMMY_SP;\n \n@@ -43,45 +45,6 @@ mod trait_goals;\n pub use eval_ctxt::EvalCtxt;\n pub use fulfill::FulfillmentCtxt;\n \n-/// A goal is a statement, i.e. `predicate`, we want to prove\n-/// given some assumptions, i.e. `param_env`.\n-///\n-/// Most of the time the `param_env` contains the `where`-bounds of the function\n-/// we're currently typechecking while the `predicate` is some trait bound.\n-#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n-pub struct Goal<'tcx, P> {\n-    param_env: ty::ParamEnv<'tcx>,\n-    predicate: P,\n-}\n-\n-impl<'tcx, P> Goal<'tcx, P> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        predicate: impl ToPredicate<'tcx, P>,\n-    ) -> Goal<'tcx, P> {\n-        Goal { param_env, predicate: predicate.to_predicate(tcx) }\n-    }\n-\n-    /// Updates the goal to one with a different `predicate` but the same `param_env`.\n-    fn with<Q>(self, tcx: TyCtxt<'tcx>, predicate: impl ToPredicate<'tcx, Q>) -> Goal<'tcx, Q> {\n-        Goal { param_env: self.param_env, predicate: predicate.to_predicate(tcx) }\n-    }\n-}\n-\n-impl<'tcx, P> From<Obligation<'tcx, P>> for Goal<'tcx, P> {\n-    fn from(obligation: Obligation<'tcx, P>) -> Goal<'tcx, P> {\n-        Goal { param_env: obligation.param_env, predicate: obligation.predicate }\n-    }\n-}\n-#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n-pub struct Response<'tcx> {\n-    pub var_values: CanonicalVarValues<'tcx>,\n-    /// Additional constraints returned by this query.\n-    pub external_constraints: ExternalConstraints<'tcx>,\n-    pub certainty: Certainty,\n-}\n-\n trait CanonicalResponseExt {\n     fn has_no_inference_or_external_constraints(&self) -> bool;\n }\n@@ -94,56 +57,6 @@ impl<'tcx> CanonicalResponseExt for Canonical<'tcx, Response<'tcx>> {\n     }\n }\n \n-#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n-pub enum Certainty {\n-    Yes,\n-    Maybe(MaybeCause),\n-}\n-\n-impl Certainty {\n-    pub const AMBIGUOUS: Certainty = Certainty::Maybe(MaybeCause::Ambiguity);\n-\n-    /// When proving multiple goals using **AND**, e.g. nested obligations for an impl,\n-    /// use this function to unify the certainty of these goals\n-    pub fn unify_and(self, other: Certainty) -> Certainty {\n-        match (self, other) {\n-            (Certainty::Yes, Certainty::Yes) => Certainty::Yes,\n-            (Certainty::Yes, Certainty::Maybe(_)) => other,\n-            (Certainty::Maybe(_), Certainty::Yes) => self,\n-            (Certainty::Maybe(MaybeCause::Overflow), Certainty::Maybe(MaybeCause::Overflow)) => {\n-                Certainty::Maybe(MaybeCause::Overflow)\n-            }\n-            // If at least one of the goals is ambiguous, hide the overflow as the ambiguous goal\n-            // may still result in failure.\n-            (Certainty::Maybe(MaybeCause::Ambiguity), Certainty::Maybe(_))\n-            | (Certainty::Maybe(_), Certainty::Maybe(MaybeCause::Ambiguity)) => {\n-                Certainty::Maybe(MaybeCause::Ambiguity)\n-            }\n-        }\n-    }\n-}\n-\n-/// Why we failed to evaluate a goal.\n-#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n-pub enum MaybeCause {\n-    /// We failed due to ambiguity. This ambiguity can either\n-    /// be a true ambiguity, i.e. there are multiple different answers,\n-    /// or we hit a case where we just don't bother, e.g. `?x: Trait` goals.\n-    Ambiguity,\n-    /// We gave up due to an overflow, most often by hitting the recursion limit.\n-    Overflow,\n-}\n-\n-type CanonicalGoal<'tcx, T = ty::Predicate<'tcx>> = Canonical<'tcx, Goal<'tcx, T>>;\n-type CanonicalResponse<'tcx> = Canonical<'tcx, Response<'tcx>>;\n-/// The result of evaluating a canonical query.\n-///\n-/// FIXME: We use a different type than the existing canonical queries. This is because\n-/// we need to add a `Certainty` for `overflow` and may want to restructure this code without\n-/// having to worry about changes to currently used code. Once we've made progress on this\n-/// solver, merge the two responses again.\n-pub type QueryResult<'tcx> = Result<CanonicalResponse<'tcx>, NoSolution>;\n-\n pub trait InferCtxtEvalExt<'tcx> {\n     /// Evaluates a goal from **outside** of the trait solver.\n     ///"}, {"sha": "dbb8e722c8f6ff29aa7c5a5d6d8658e5e75237ba", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -2,7 +2,7 @@ use crate::traits::{specialization_graph, translate_substs};\n \n use super::assembly;\n use super::trait_goals::structural_traits;\n-use super::{Certainty, EvalCtxt, Goal, QueryResult};\n+use super::EvalCtxt;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n@@ -11,6 +11,7 @@ use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::specialization_graph::LeafDef;\n use rustc_infer::traits::Reveal;\n+use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, QueryResult};\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::ProjectionPredicate;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -183,7 +184,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n \n         let goal_trait_ref = goal.predicate.projection_ty.trait_ref(tcx);\n         let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n-        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n+        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::ForLookup };\n         if iter::zip(goal_trait_ref.substs, impl_trait_ref.skip_binder().substs)\n             .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n         {\n@@ -512,7 +513,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n     fn consider_builtin_dyn_upcast_candidates(\n         _ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-    ) -> Vec<super::CanonicalResponse<'tcx>> {\n+    ) -> Vec<CanonicalResponse<'tcx>> {\n         bug!(\"`Unsize` does not have an associated type: {:?}\", goal);\n     }\n "}, {"sha": "d1b4fa554c5f2f5e1e3a73009d9be82cdade3cc4", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/cache.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -8,12 +8,10 @@\n //!\n //! FIXME(@lcnr): Write that section, feel free to ping me if you need help here\n //! before then or if I still haven't done that before January 2023.\n-use super::overflow::OverflowData;\n use super::StackDepth;\n-use crate::solve::{CanonicalGoal, QueryResult};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::traits::solve::{CanonicalGoal, QueryResult};\n \n rustc_index::newtype_index! {\n     pub struct EntryIndex {}\n@@ -98,26 +96,3 @@ impl<'tcx> ProvisionalCache<'tcx> {\n         self.entries[entry_index].response\n     }\n }\n-\n-pub(super) fn try_move_finished_goal_to_global_cache<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    overflow_data: &mut OverflowData,\n-    stack: &IndexVec<super::StackDepth, super::StackElem<'tcx>>,\n-    goal: CanonicalGoal<'tcx>,\n-    response: QueryResult<'tcx>,\n-) {\n-    // We move goals to the global cache if we either did not hit an overflow or if it's\n-    // the root goal as that will now always hit the same overflow limit.\n-    //\n-    // NOTE: We cannot move any non-root goals to the global cache even if their final result\n-    // isn't impacted by the overflow as that goal still has unstable query dependencies\n-    // because it didn't go its full depth.\n-    //\n-    // FIXME(@lcnr): We could still cache subtrees which are not impacted by overflow though.\n-    // Tracking that info correctly isn't trivial, so I haven't implemented it for now.\n-    let should_cache_globally = !overflow_data.did_overflow() || stack.is_empty();\n-    if should_cache_globally {\n-        // FIXME: move the provisional entry to the global cache.\n-        let _ = (tcx, goal, response);\n-    }\n-}"}, {"sha": "f1b840aac556abfaf4d2d45278a5f0eb02c4f57d", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 61, "deletions": 46, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -2,11 +2,12 @@ mod cache;\n mod overflow;\n \n use self::cache::ProvisionalEntry;\n-use super::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n pub(super) use crate::solve::search_graph::overflow::OverflowHandler;\n use cache::ProvisionalCache;\n use overflow::OverflowData;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::dep_graph::DepKind;\n+use rustc_middle::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n use rustc_middle::ty::TyCtxt;\n use std::{collections::hash_map::Entry, mem};\n \n@@ -139,10 +140,9 @@ impl<'tcx> SearchGraph<'tcx> {\n     /// updated the provisional cache and we have to recompute the current goal.\n     ///\n     /// FIXME: Refer to the rustc-dev-guide entry once it exists.\n-    #[instrument(level = \"debug\", skip(self, tcx, actual_goal), ret)]\n+    #[instrument(level = \"debug\", skip(self, actual_goal), ret)]\n     fn try_finalize_goal(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n         actual_goal: CanonicalGoal<'tcx>,\n         response: QueryResult<'tcx>,\n     ) -> bool {\n@@ -176,72 +176,87 @@ impl<'tcx> SearchGraph<'tcx> {\n             self.stack.push(StackElem { goal, has_been_used: false });\n             false\n         } else {\n-            self.try_move_finished_goal_to_global_cache(tcx, stack_elem);\n             true\n         }\n     }\n \n-    fn try_move_finished_goal_to_global_cache(\n+    pub(super) fn with_new_goal(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n-        stack_elem: StackElem<'tcx>,\n-    ) {\n-        let StackElem { goal, .. } = stack_elem;\n+        canonical_goal: CanonicalGoal<'tcx>,\n+        mut loop_body: impl FnMut(&mut Self) -> QueryResult<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(result) = tcx.new_solver_evaluation_cache.get(&canonical_goal, tcx) {\n+            return result;\n+        }\n+\n+        match self.try_push_stack(tcx, canonical_goal) {\n+            Ok(()) => {}\n+            // Our goal is already on the stack, eager return.\n+            Err(response) => return response,\n+        }\n+\n+        // This is for global caching, so we properly track query dependencies.\n+        // Everything that affects the `Result` should be performed within this\n+        // `with_anon_task` closure.\n+        let (result, dep_node) = tcx.dep_graph.with_anon_task(tcx, DepKind::TraitSelect, || {\n+            self.repeat_while_none(\n+                |this| {\n+                    let result = this.deal_with_overflow(tcx, canonical_goal);\n+                    let _ = this.stack.pop().unwrap();\n+                    result\n+                },\n+                |this| {\n+                    let result = loop_body(this);\n+                    this.try_finalize_goal(canonical_goal, result).then(|| result)\n+                },\n+            )\n+        });\n+\n         let cache = &mut self.provisional_cache;\n-        let provisional_entry_index = *cache.lookup_table.get(&goal).unwrap();\n+        let provisional_entry_index = *cache.lookup_table.get(&canonical_goal).unwrap();\n         let provisional_entry = &mut cache.entries[provisional_entry_index];\n         let depth = provisional_entry.depth;\n \n         // If not, we're done with this goal.\n         //\n         // Check whether that this goal doesn't depend on a goal deeper on the stack\n-        // and if so, move it and all nested goals to the global cache.\n+        // and if so, move it to the global cache.\n         //\n         // Note that if any nested goal were to depend on something deeper on the stack,\n         // this would have also updated the depth of the current goal.\n         if depth == self.stack.next_index() {\n-            for (i, entry) in cache.entries.drain_enumerated(provisional_entry_index.index()..) {\n+            // If the current goal is the head of a cycle, we drop all other\n+            // cycle participants without moving them to the global cache.\n+            let other_cycle_participants = provisional_entry_index.index() + 1;\n+            for (i, entry) in cache.entries.drain_enumerated(other_cycle_participants..) {\n                 let actual_index = cache.lookup_table.remove(&entry.goal);\n                 debug_assert_eq!(Some(i), actual_index);\n                 debug_assert!(entry.depth == depth);\n-                cache::try_move_finished_goal_to_global_cache(\n-                    tcx,\n-                    &mut self.overflow_data,\n-                    &self.stack,\n-                    entry.goal,\n-                    entry.response,\n-                );\n             }\n-        }\n-    }\n \n-    pub(super) fn with_new_goal(\n-        &mut self,\n-        tcx: TyCtxt<'tcx>,\n-        canonical_goal: CanonicalGoal<'tcx>,\n-        mut loop_body: impl FnMut(&mut Self) -> QueryResult<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        match self.try_push_stack(tcx, canonical_goal) {\n-            Ok(()) => {}\n-            // Our goal is already on the stack, eager return.\n-            Err(response) => return response,\n+            let current_goal = cache.entries.pop().unwrap();\n+            let actual_index = cache.lookup_table.remove(&current_goal.goal);\n+            debug_assert_eq!(Some(provisional_entry_index), actual_index);\n+            debug_assert!(current_goal.depth == depth);\n+\n+            // We move the root goal to the global cache if we either did not hit an overflow or if it's\n+            // the root goal as that will now always hit the same overflow limit.\n+            //\n+            // NOTE: We cannot move any non-root goals to the global cache. When replaying the root goal's\n+            // dependencies, our non-root goal may no longer appear as child of the root goal.\n+            //\n+            // See https://github.com/rust-lang/rust/pull/108071 for some additional context.\n+            let should_cache_globally = !self.overflow_data.did_overflow() || self.stack.is_empty();\n+            if should_cache_globally {\n+                tcx.new_solver_evaluation_cache.insert(\n+                    current_goal.goal,\n+                    dep_node,\n+                    current_goal.response,\n+                );\n+            }\n         }\n \n-        self.repeat_while_none(\n-            |this| {\n-                let result = this.deal_with_overflow(tcx, canonical_goal);\n-                let stack_elem = this.stack.pop().unwrap();\n-                this.try_move_finished_goal_to_global_cache(tcx, stack_elem);\n-                result\n-            },\n-            |this| {\n-                let result = loop_body(this);\n-                if this.try_finalize_goal(tcx, canonical_goal, result) {\n-                    Some(result)\n-                } else {\n-                    None\n-                }\n-            },\n-        )\n+        result\n     }\n }"}, {"sha": "7c9e63f529b5503a78a9d606fba3b1eb5fc8f329", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/overflow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,10 +1,11 @@\n use rustc_infer::infer::canonical::Canonical;\n use rustc_infer::traits::query::NoSolution;\n+use rustc_middle::traits::solve::{Certainty, MaybeCause, QueryResult};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Limit;\n \n use super::SearchGraph;\n-use crate::solve::{response_no_constraints, Certainty, EvalCtxt, MaybeCause, QueryResult};\n+use crate::solve::{response_no_constraints, EvalCtxt};\n \n /// When detecting a solver overflow, we return ambiguity. Overflow can be\n /// *hidden* by either a fatal error in an **AND** or a trivial success in an **OR**."}, {"sha": "7878539817cfb928fc8a6a0d4237cb7fa3b8113f", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -2,13 +2,13 @@\n \n use std::iter;\n \n-use super::assembly;\n-use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, QueryResult};\n+use super::{assembly, EvalCtxt};\n use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::supertraits;\n-use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n+use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, QueryResult};\n+use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams, TreatProjections};\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n use rustc_middle::ty::{TraitPredicate, TypeVisitableExt};\n use rustc_span::DUMMY_SP;\n@@ -36,7 +36,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         let tcx = ecx.tcx();\n \n         let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n-        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n+        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::ForLookup };\n         if iter::zip(goal.predicate.trait_ref.substs, impl_trait_ref.skip_binder().substs)\n             .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n         {\n@@ -135,9 +135,15 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         // currently instead lint patterns which can be used to\n         // exploit this unsoundness on stable, see #93367 for\n         // more details.\n+        //\n+        // Using `TreatProjections::NextSolverLookup` is fine here because\n+        // `instantiate_constituent_tys_for_auto_trait` returns nothing for\n+        // projection types anyways. So it doesn't really matter what we do\n+        // here, and this is faster.\n         if let Some(def_id) = ecx.tcx().find_map_relevant_impl(\n             goal.predicate.def_id(),\n             goal.predicate.self_ty(),\n+            TreatProjections::NextSolverLookup,\n             Some,\n         ) {\n             debug!(?def_id, ?goal, \"disqualified auto-trait implementation\");"}, {"sha": "96a4b76af550fd5c9eb26d0782114f4514dee93c", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -75,7 +75,7 @@ pub fn overlapping_impls(\n     // Before doing expensive operations like entering an inference context, do\n     // a quick check via fast_reject to tell if the impl headers could possibly\n     // unify.\n-    let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsInfer };\n+    let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsCandidateKey };\n     let impl1_ref = tcx.impl_trait_ref(impl1_def_id);\n     let impl2_ref = tcx.impl_trait_ref(impl2_def_id);\n     let may_overlap = match (impl1_ref, impl2_ref) {"}, {"sha": "41ffaeeac1c11ffa67b4f7c97c1d3d594191abb9", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 75, "deletions": 69, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -24,16 +24,15 @@ use rustc_errors::{\n };\n use rustc_hir as hir;\n use rustc_hir::def::Namespace;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n-use rustc_hir::GenericParam;\n-use rustc_hir::Item;\n-use rustc_hir::Node;\n+use rustc_hir::{GenericParam, Item, Node};\n use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::{InferOk, TypeTrace};\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n+use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::print::{with_forced_trimmed_paths, FmtPrinter, Print};\n use rustc_middle::ty::{\n@@ -126,11 +125,7 @@ pub trait TypeErrCtxtExt<'tcx> {\n             + Print<'tcx, FmtPrinter<'tcx, 'tcx>, Output = FmtPrinter<'tcx, 'tcx>>,\n         <T as Print<'tcx, FmtPrinter<'tcx, 'tcx>>>::Error: std::fmt::Debug;\n \n-    fn report_fulfillment_errors(\n-        &self,\n-        errors: &[FulfillmentError<'tcx>],\n-        body_id: Option<hir::BodyId>,\n-    ) -> ErrorGuaranteed;\n+    fn report_fulfillment_errors(&self, errors: &[FulfillmentError<'tcx>]) -> ErrorGuaranteed;\n \n     fn report_overflow_obligation<T>(\n         &self,\n@@ -388,11 +383,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n }\n \n impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n-    fn report_fulfillment_errors(\n-        &self,\n-        errors: &[FulfillmentError<'tcx>],\n-        body_id: Option<hir::BodyId>,\n-    ) -> ErrorGuaranteed {\n+    fn report_fulfillment_errors(&self, errors: &[FulfillmentError<'tcx>]) -> ErrorGuaranteed {\n         #[derive(Debug)]\n         struct ErrorDescriptor<'tcx> {\n             predicate: ty::Predicate<'tcx>,\n@@ -469,7 +460,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         for from_expansion in [false, true] {\n             for (error, suppressed) in iter::zip(errors, &is_suppressed) {\n                 if !suppressed && error.obligation.cause.span.from_expansion() == from_expansion {\n-                    self.report_fulfillment_error(error, body_id);\n+                    self.report_fulfillment_error(error);\n                 }\n             }\n         }\n@@ -955,8 +946,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             );\n                         }\n \n-                        let body_hir_id =\n-                            self.tcx.hir().local_def_id_to_hir_id(obligation.cause.body_id);\n+                        let body_def_id = obligation.cause.body_id;\n                         // Try to report a help message\n                         if is_fn_trait\n                             && let Ok((implemented_kind, params)) = self.type_implements_fn_trait(\n@@ -1035,9 +1025,9 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             // Can't show anything else useful, try to find similar impls.\n                             let impl_candidates = self.find_similar_impl_candidates(trait_predicate);\n                             if !self.report_similar_impl_candidates(\n-                                impl_candidates,\n+                                &impl_candidates,\n                                 trait_ref,\n-                                body_hir_id,\n+                                body_def_id,\n                                 &mut err,\n                                 true,\n                             ) {\n@@ -1071,14 +1061,21 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                     let impl_candidates =\n                                         self.find_similar_impl_candidates(trait_pred);\n                                     self.report_similar_impl_candidates(\n-                                        impl_candidates,\n+                                        &impl_candidates,\n                                         trait_ref,\n-                                        body_hir_id,\n+                                        body_def_id,\n                                         &mut err,\n                                         true,\n                                     );\n                                 }\n                             }\n+\n+                            self.maybe_suggest_convert_to_slice(\n+                                &mut err,\n+                                trait_ref,\n+                                impl_candidates.as_slice(),\n+                                span,\n+                            );\n                         }\n \n                         // Changing mutability doesn't make a difference to whether we have\n@@ -1494,11 +1491,7 @@ trait InferCtxtPrivExt<'tcx> {\n     // `error` occurring implies that `cond` occurs.\n     fn error_implies(&self, cond: ty::Predicate<'tcx>, error: ty::Predicate<'tcx>) -> bool;\n \n-    fn report_fulfillment_error(\n-        &self,\n-        error: &FulfillmentError<'tcx>,\n-        body_id: Option<hir::BodyId>,\n-    );\n+    fn report_fulfillment_error(&self, error: &FulfillmentError<'tcx>);\n \n     fn report_projection_error(\n         &self,\n@@ -1529,9 +1522,9 @@ trait InferCtxtPrivExt<'tcx> {\n \n     fn report_similar_impl_candidates(\n         &self,\n-        impl_candidates: Vec<ImplCandidate<'tcx>>,\n+        impl_candidates: &[ImplCandidate<'tcx>],\n         trait_ref: ty::PolyTraitRef<'tcx>,\n-        body_id: hir::HirId,\n+        body_def_id: LocalDefId,\n         err: &mut Diagnostic,\n         other: bool,\n     ) -> bool;\n@@ -1561,11 +1554,7 @@ trait InferCtxtPrivExt<'tcx> {\n         trait_ref_and_ty: ty::Binder<'tcx, (ty::TraitPredicate<'tcx>, Ty<'tcx>)>,\n     ) -> PredicateObligation<'tcx>;\n \n-    fn maybe_report_ambiguity(\n-        &self,\n-        obligation: &PredicateObligation<'tcx>,\n-        body_id: Option<hir::BodyId>,\n-    );\n+    fn maybe_report_ambiguity(&self, obligation: &PredicateObligation<'tcx>);\n \n     fn predicate_can_apply(\n         &self,\n@@ -1647,11 +1636,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    fn report_fulfillment_error(\n-        &self,\n-        error: &FulfillmentError<'tcx>,\n-        body_id: Option<hir::BodyId>,\n-    ) {\n+    fn report_fulfillment_error(&self, error: &FulfillmentError<'tcx>) {\n         match error.code {\n             FulfillmentErrorCode::CodeSelectionError(ref selection_error) => {\n                 self.report_selection_error(\n@@ -1664,7 +1649,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 self.report_projection_error(&error.obligation, e);\n             }\n             FulfillmentErrorCode::CodeAmbiguity => {\n-                self.maybe_report_ambiguity(&error.obligation, body_id);\n+                self.maybe_report_ambiguity(&error.obligation);\n             }\n             FulfillmentErrorCode::CodeSubtypeError(ref expected_found, ref err) => {\n                 self.report_mismatched_types(\n@@ -1815,12 +1800,17 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     })\n                     .and_then(|(trait_assoc_item, id)| {\n                         let trait_assoc_ident = trait_assoc_item.ident(self.tcx);\n-                        self.tcx.find_map_relevant_impl(id, proj.projection_ty.self_ty(), |did| {\n-                            self.tcx\n-                                .associated_items(did)\n-                                .in_definition_order()\n-                                .find(|assoc| assoc.ident(self.tcx) == trait_assoc_ident)\n-                        })\n+                        self.tcx.find_map_relevant_impl(\n+                            id,\n+                            proj.projection_ty.self_ty(),\n+                            TreatProjections::ForLookup,\n+                            |did| {\n+                                self.tcx\n+                                    .associated_items(did)\n+                                    .in_definition_order()\n+                                    .find(|assoc| assoc.ident(self.tcx) == trait_assoc_ident)\n+                            },\n+                        )\n                     })\n                     .and_then(|item| match self.tcx.hir().get_if_local(item.def_id) {\n                         Some(\n@@ -2027,9 +2017,9 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n     fn report_similar_impl_candidates(\n         &self,\n-        impl_candidates: Vec<ImplCandidate<'tcx>>,\n+        impl_candidates: &[ImplCandidate<'tcx>],\n         trait_ref: ty::PolyTraitRef<'tcx>,\n-        body_id: hir::HirId,\n+        body_def_id: LocalDefId,\n         err: &mut Diagnostic,\n         other: bool,\n     ) -> bool {\n@@ -2120,9 +2110,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         // FIXME(compiler-errors): This could be generalized, both to\n                         // be more granular, and probably look past other `#[fundamental]`\n                         // types, too.\n-                        self.tcx\n-                            .visibility(def.did())\n-                            .is_accessible_from(body_id.owner.def_id, self.tcx)\n+                        self.tcx.visibility(def.did()).is_accessible_from(body_def_id, self.tcx)\n                     } else {\n                         true\n                     }\n@@ -2138,7 +2126,8 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         // Prefer more similar candidates first, then sort lexicographically\n         // by their normalized string representation.\n         let mut normalized_impl_candidates_and_similarities = impl_candidates\n-            .into_iter()\n+            .iter()\n+            .copied()\n             .map(|ImplCandidate { trait_ref, similarity }| {\n                 // FIXME(compiler-errors): This should be using `NormalizeExt::normalize`\n                 let normalized = self\n@@ -2193,7 +2182,12 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         trait_ref: &ty::PolyTraitRef<'tcx>,\n     ) -> bool {\n         let get_trait_impl = |trait_def_id| {\n-            self.tcx.find_map_relevant_impl(trait_def_id, trait_ref.skip_binder().self_ty(), Some)\n+            self.tcx.find_map_relevant_impl(\n+                trait_def_id,\n+                trait_ref.skip_binder().self_ty(),\n+                TreatProjections::ForLookup,\n+                Some,\n+            )\n         };\n         let required_trait_path = self.tcx.def_path_str(trait_ref.def_id());\n         let traits_with_same_path: std::collections::BTreeSet<_> = self\n@@ -2231,11 +2225,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    fn maybe_report_ambiguity(\n-        &self,\n-        obligation: &PredicateObligation<'tcx>,\n-        body_id: Option<hir::BodyId>,\n-    ) {\n+    fn maybe_report_ambiguity(&self, obligation: &PredicateObligation<'tcx>) {\n         // Unable to successfully determine, probably means\n         // insufficient type information, but could mean\n         // ambiguous impls. The latter *ought* to be a\n@@ -2277,7 +2267,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 if self.tcx.lang_items().sized_trait() == Some(trait_ref.def_id()) {\n                     if let None = self.tainted_by_errors() {\n                         self.emit_inference_failure_err(\n-                            body_id,\n+                            obligation.cause.body_id,\n                             span,\n                             trait_ref.self_ty().skip_binder().into(),\n                             ErrorCode::E0282,\n@@ -2304,7 +2294,13 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 let subst = data.trait_ref.substs.iter().find(|s| s.has_non_region_infer());\n \n                 let mut err = if let Some(subst) = subst {\n-                    self.emit_inference_failure_err(body_id, span, subst, ErrorCode::E0283, true)\n+                    self.emit_inference_failure_err(\n+                        obligation.cause.body_id,\n+                        span,\n+                        subst,\n+                        ErrorCode::E0283,\n+                        true,\n+                    )\n                 } else {\n                     struct_span_err!(\n                         self.tcx.sess,\n@@ -2348,12 +2344,10 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 predicate.to_opt_poly_trait_pred().unwrap(),\n                             );\n                             if impl_candidates.len() < 10 {\n-                                let hir =\n-                                    self.tcx.hir().local_def_id_to_hir_id(obligation.cause.body_id);\n                                 self.report_similar_impl_candidates(\n-                                    impl_candidates,\n+                                    impl_candidates.as_slice(),\n                                     trait_ref,\n-                                    body_id.map(|id| id.hir_id).unwrap_or(hir),\n+                                    obligation.cause.body_id,\n                                     &mut err,\n                                     false,\n                                 );\n@@ -2375,9 +2369,9 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     self.suggest_fully_qualified_path(&mut err, def_id, span, trait_ref.def_id());\n                 }\n \n-                if let (Some(body_id), Some(ty::subst::GenericArgKind::Type(_))) =\n-                    (body_id, subst.map(|subst| subst.unpack()))\n+                if let Some(ty::subst::GenericArgKind::Type(_)) = subst.map(|subst| subst.unpack())\n                 {\n+                    let body_id = self.tcx.hir().body_owned_by(obligation.cause.body_id);\n                     let mut expr_finder = FindExprBySpan::new(span);\n                     expr_finder.visit_expr(&self.tcx.hir().body(body_id).value);\n \n@@ -2473,7 +2467,13 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     return;\n                 }\n \n-                self.emit_inference_failure_err(body_id, span, arg, ErrorCode::E0282, false)\n+                self.emit_inference_failure_err(\n+                    obligation.cause.body_id,\n+                    span,\n+                    arg,\n+                    ErrorCode::E0282,\n+                    false,\n+                )\n             }\n \n             ty::PredicateKind::Subtype(data) => {\n@@ -2487,7 +2487,13 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 let SubtypePredicate { a_is_expected: _, a, b } = data;\n                 // both must be type variables, or the other would've been instantiated\n                 assert!(a.is_ty_var() && b.is_ty_var());\n-                self.emit_inference_failure_err(body_id, span, a.into(), ErrorCode::E0282, true)\n+                self.emit_inference_failure_err(\n+                    obligation.cause.body_id,\n+                    span,\n+                    a.into(),\n+                    ErrorCode::E0282,\n+                    true,\n+                )\n             }\n             ty::PredicateKind::Clause(ty::Clause::Projection(data)) => {\n                 if predicate.references_error() || self.tainted_by_errors().is_some() {\n@@ -2501,7 +2507,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     .find(|g| g.has_non_region_infer());\n                 if let Some(subst) = subst {\n                     let mut err = self.emit_inference_failure_err(\n-                        body_id,\n+                        obligation.cause.body_id,\n                         span,\n                         subst,\n                         ErrorCode::E0284,\n@@ -2530,7 +2536,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 let subst = data.walk().find(|g| g.is_non_region_infer());\n                 if let Some(subst) = subst {\n                     let err = self.emit_inference_failure_err(\n-                        body_id,\n+                        obligation.cause.body_id,\n                         span,\n                         subst,\n                         ErrorCode::E0284,"}, {"sha": "5541c0850753d2d26025a628b3f59fb3702c2cbb", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 78, "deletions": 10, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,7 +1,7 @@\n // ignore-tidy-filelength\n \n use super::{\n-    DefIdOrName, FindExprBySpan, Obligation, ObligationCause, ObligationCauseCode,\n+    DefIdOrName, FindExprBySpan, ImplCandidate, Obligation, ObligationCause, ObligationCauseCode,\n     PredicateObligation,\n };\n \n@@ -382,6 +382,14 @@ pub trait TypeErrCtxtExt<'tcx> {\n         body_id: hir::HirId,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Vec<Option<(Span, (DefId, Ty<'tcx>))>>;\n+\n+    fn maybe_suggest_convert_to_slice(\n+        &self,\n+        err: &mut Diagnostic,\n+        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        candidate_impls: &[ImplCandidate<'tcx>],\n+        span: Span,\n+    );\n }\n \n fn predicate_constraint(generics: &hir::Generics<'_>, pred: ty::Predicate<'_>) -> (Span, String) {\n@@ -2220,7 +2228,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         // - `BuiltinDerivedObligation` with a generator witness (A)\n         // - `BuiltinDerivedObligation` with a generator (A)\n         // - `BuiltinDerivedObligation` with `impl std::future::Future` (A)\n-        // - `BindingObligation` with `impl_send (Send requirement)\n+        // - `BindingObligation` with `impl_send` (Send requirement)\n         //\n         // The first obligation in the chain is the most useful and has the generator that captured\n         // the type. The last generator (`outer_generator` below) has information about where the\n@@ -3025,8 +3033,6 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     }\n                 };\n \n-                let identity_future = tcx.require_lang_item(LangItem::IdentityFuture, None);\n-\n                 // Don't print the tuple of capture types\n                 'print: {\n                     if !is_upvar_tys_infer_tuple {\n@@ -3039,12 +3045,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 None => err.note(&msg),\n                             },\n                             ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) => {\n-                                // Avoid printing the future from `core::future::identity_future`, it's not helpful\n-                                if tcx.parent(*def_id) == identity_future {\n-                                    break 'print;\n-                                }\n-\n-                                // If the previous type is `identity_future`, this is the future generated by the body of an async function.\n+                                // If the previous type is async fn, this is the future generated by the body of an async function.\n                                 // Avoid printing it twice (it was already printed in the `ty::Generator` arm below).\n                                 let is_future = tcx.ty_is_opaque_future(ty);\n                                 debug!(\n@@ -3826,6 +3827,73 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         }\n         assocs_in_this_method\n     }\n+\n+    /// If the type that failed selection is an array or a reference to an array,\n+    /// but the trait is implemented for slices, suggest that the user converts\n+    /// the array into a slice.\n+    fn maybe_suggest_convert_to_slice(\n+        &self,\n+        err: &mut Diagnostic,\n+        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        candidate_impls: &[ImplCandidate<'tcx>],\n+        span: Span,\n+    ) {\n+        // Three cases where we can make a suggestion:\n+        // 1. `[T; _]` (array of T)\n+        // 2. `&[T; _]` (reference to array of T)\n+        // 3. `&mut [T; _]` (mutable reference to array of T)\n+        let (element_ty, mut mutability) = match *trait_ref.skip_binder().self_ty().kind() {\n+            ty::Array(element_ty, _) => (element_ty, None),\n+\n+            ty::Ref(_, pointee_ty, mutability) => match *pointee_ty.kind() {\n+                ty::Array(element_ty, _) => (element_ty, Some(mutability)),\n+                _ => return,\n+            },\n+\n+            _ => return,\n+        };\n+\n+        // Go through all the candidate impls to see if any of them is for\n+        // slices of `element_ty` with `mutability`.\n+        let mut is_slice = |candidate: Ty<'tcx>| match *candidate.kind() {\n+            ty::RawPtr(ty::TypeAndMut { ty: t, mutbl: m }) | ty::Ref(_, t, m) => {\n+                if matches!(*t.kind(), ty::Slice(e) if e == element_ty)\n+                    && m == mutability.unwrap_or(m)\n+                {\n+                    // Use the candidate's mutability going forward.\n+                    mutability = Some(m);\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+            _ => false,\n+        };\n+\n+        // Grab the first candidate that matches, if any, and make a suggestion.\n+        if let Some(slice_ty) = candidate_impls\n+            .iter()\n+            .map(|trait_ref| trait_ref.trait_ref.self_ty())\n+            .filter(|t| is_slice(*t))\n+            .next()\n+        {\n+            let msg = &format!(\"convert the array to a `{}` slice instead\", slice_ty);\n+\n+            if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                let mut suggestions = vec![];\n+                if snippet.starts_with('&') {\n+                } else if let Some(hir::Mutability::Mut) = mutability {\n+                    suggestions.push((span.shrink_to_lo(), \"&mut \".into()));\n+                } else {\n+                    suggestions.push((span.shrink_to_lo(), \"&\".into()));\n+                }\n+                suggestions.push((span.shrink_to_hi(), \"[..]\".into()));\n+                err.multipart_suggestion_verbose(msg, suggestions, Applicability::MaybeIncorrect);\n+            } else {\n+                err.span_help(span, msg);\n+            }\n+        }\n+    }\n }\n \n /// Add a hint to add a missing borrow or remove an unnecessary one."}, {"sha": "bfeda88a6d40ce2817b9ddf778e643eb610c7318", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -210,7 +210,7 @@ fn do_normalize_predicates<'tcx>(\n     let predicates = match fully_normalize(&infcx, cause, elaborated_env, predicates) {\n         Ok(predicates) => predicates,\n         Err(errors) => {\n-            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors);\n             return Err(reported);\n         }\n     };"}, {"sha": "f84b2f4428d1a26c8ae71a503151fac849ef392c", "filename": "compiler/rustc_trait_selection/src/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,9 +1,9 @@\n+use rustc_middle::traits::solve::{Certainty, Goal, MaybeCause};\n use rustc_middle::ty;\n-use rustc_session::config::TraitSolver;\n \n use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::InferCtxt;\n-use crate::solve::{Certainty, Goal, InferCtxtEvalExt, MaybeCause};\n+use crate::solve::InferCtxtEvalExt;\n use crate::traits::{EvaluationResult, OverflowError, PredicateObligation, SelectionContext};\n \n pub trait InferCtxtExt<'tcx> {\n@@ -79,13 +79,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             _ => obligation.param_env.without_const(),\n         };\n \n-        if self.tcx.sess.opts.unstable_opts.trait_solver != TraitSolver::Next {\n-            let c_pred = self.canonicalize_query_keep_static(\n-                param_env.and(obligation.predicate),\n-                &mut _orig_values,\n-            );\n-            self.tcx.at(obligation.cause.span()).evaluate_obligation(c_pred)\n-        } else {\n+        if self.tcx.trait_solver_next() {\n             self.probe(|snapshot| {\n                 if let Ok((_, certainty)) =\n                     self.evaluate_root_goal(Goal::new(self.tcx, param_env, obligation.predicate))\n@@ -110,6 +104,12 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n                     Ok(EvaluationResult::EvaluatedToErr)\n                 }\n             })\n+        } else {\n+            let c_pred = self.canonicalize_query_keep_static(\n+                param_env.and(obligation.predicate),\n+                &mut _orig_values,\n+            );\n+            self.tcx.at(obligation.cause.span()).evaluate_obligation(c_pred)\n         }\n     }\n "}, {"sha": "3182af989f05a565592755863faa044c939e11db", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -9,6 +9,7 @@ use hir::LangItem;\n use rustc_hir as hir;\n use rustc_infer::traits::ObligationCause;\n use rustc_infer::traits::{Obligation, SelectionError, TraitObligation};\n+use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::{self, Ty, TypeVisitableExt};\n use rustc_target::spec::abi::Abi;\n \n@@ -783,6 +784,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let relevant_impl = self.tcx().find_map_relevant_impl(\n                     self.tcx().require_lang_item(LangItem::Drop, None),\n                     obligation.predicate.skip_binder().trait_ref.self_ty(),\n+                    TreatProjections::ForLookup,\n                     Some,\n                 );\n "}, {"sha": "ee41d840bae926e17bf4860c91352508870fbabe", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -601,10 +601,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(?obligation, \"confirm_fn_pointer_candidate\");\n \n         let tcx = self.tcx();\n-        let self_ty = self\n+\n+        let Some(self_ty) = self\n             .infcx\n-            .shallow_resolve(obligation.self_ty().no_bound_vars())\n-            .expect(\"fn pointer should not capture bound vars from predicate\");\n+            .shallow_resolve(obligation.self_ty().no_bound_vars()) else\n+        {\n+            // FIXME: Ideally we'd support `for<'a> fn(&'a ()): Fn(&'a ())`,\n+            // but we do not currently. Luckily, such a bound is not\n+            // particularly useful, so we don't expect users to write\n+            // them often.\n+            return Err(SelectionError::Unimplemented);\n+        };\n+\n         let sig = self_ty.fn_sig(tcx);\n         let trait_ref = closure_trait_ref_and_return_type(\n             tcx,"}, {"sha": "38cdaddc1e707c286693e3cd5c6e6d947fde9114", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 74, "deletions": 48, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -50,7 +50,6 @@ use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::SubstsRef;\n use rustc_middle::ty::{self, EarlyBinder, PolyProjectionPredicate, ToPolyTraitRef, ToPredicate};\n use rustc_middle::ty::{Ty, TyCtxt, TypeFoldable, TypeVisitableExt};\n-use rustc_session::config::TraitSolver;\n use rustc_span::symbol::sym;\n \n use std::cell::{Cell, RefCell};\n@@ -465,14 +464,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         if candidates.len() > 1 {\n             let mut i = 0;\n             while i < candidates.len() {\n-                let is_dup = (0..candidates.len()).filter(|&j| i != j).any(|j| {\n+                let should_drop_i = (0..candidates.len()).filter(|&j| i != j).any(|j| {\n                     self.candidate_should_be_dropped_in_favor_of(\n                         &candidates[i],\n                         &candidates[j],\n                         needs_infer,\n-                    )\n+                    ) == DropVictim::Yes\n                 });\n-                if is_dup {\n+                if should_drop_i {\n                     debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n                     candidates.swap_remove(i);\n                 } else {\n@@ -545,13 +544,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n         self.evaluation_probe(|this| {\n-            if this.tcx().sess.opts.unstable_opts.trait_solver != TraitSolver::Next {\n+            if this.tcx().trait_solver_next() {\n+                this.evaluate_predicates_recursively_in_new_solver([obligation.clone()])\n+            } else {\n                 this.evaluate_predicate_recursively(\n                     TraitObligationStackList::empty(&ProvisionalEvaluationCache::default()),\n                     obligation.clone(),\n                 )\n-            } else {\n-                this.evaluate_predicates_recursively_in_new_solver([obligation.clone()])\n             }\n         })\n     }\n@@ -591,7 +590,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     where\n         I: IntoIterator<Item = PredicateObligation<'tcx>> + std::fmt::Debug,\n     {\n-        if self.tcx().sess.opts.unstable_opts.trait_solver != TraitSolver::Next {\n+        if self.tcx().trait_solver_next() {\n+            self.evaluate_predicates_recursively_in_new_solver(predicates)\n+        } else {\n             let mut result = EvaluatedToOk;\n             for obligation in predicates {\n                 let eval = self.evaluate_predicate_recursively(stack, obligation.clone())?;\n@@ -604,8 +605,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n             Ok(result)\n-        } else {\n-            self.evaluate_predicates_recursively_in_new_solver(predicates)\n         }\n     }\n \n@@ -1842,16 +1841,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ProjectionMatchesProjection::No\n         }\n     }\n+}\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    // WINNOW\n-    //\n-    // Winnowing is the process of attempting to resolve ambiguity by\n-    // probing further. During the winnowing process, we unify all\n-    // type variables and then we also attempt to evaluate recursive\n-    // bounds to see if they are satisfied.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+enum DropVictim {\n+    Yes,\n+    No,\n+}\n \n-    /// Returns `true` if `victim` should be dropped in favor of\n+/// ## Winnowing\n+///\n+/// Winnowing is the process of attempting to resolve ambiguity by\n+/// probing further. During the winnowing process, we unify all\n+/// type variables and then we also attempt to evaluate recursive\n+/// bounds to see if they are satisfied.\n+impl<'tcx> SelectionContext<'_, 'tcx> {\n+    /// Returns `DropVictim::Yes` if `victim` should be dropped in favor of\n     /// `other`. Generally speaking we will drop duplicate\n     /// candidates and prefer where-clause candidates.\n     ///\n@@ -1861,9 +1866,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         victim: &EvaluatedCandidate<'tcx>,\n         other: &EvaluatedCandidate<'tcx>,\n         needs_infer: bool,\n-    ) -> bool {\n+    ) -> DropVictim {\n         if victim.candidate == other.candidate {\n-            return true;\n+            return DropVictim::Yes;\n         }\n \n         // Check if a bound would previously have been removed when normalizing\n@@ -1887,11 +1892,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // FIXME(@jswrenn): this should probably be more sophisticated\n-            (TransmutabilityCandidate, _) | (_, TransmutabilityCandidate) => false,\n+            (TransmutabilityCandidate, _) | (_, TransmutabilityCandidate) => DropVictim::No,\n \n             // (*)\n-            (BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_), _) => true,\n-            (_, BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_)) => false,\n+            (BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_), _) => {\n+                DropVictim::Yes\n+            }\n+            (_, BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_)) => {\n+                DropVictim::No\n+            }\n \n             (ParamCandidate(other), ParamCandidate(victim)) => {\n                 let same_except_bound_vars = other.skip_binder().trait_ref\n@@ -1905,28 +1914,27 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // or the current one if tied (they should both evaluate to the same answer). This is\n                     // probably best characterized as a \"hack\", since we might prefer to just do our\n                     // best to *not* create essentially duplicate candidates in the first place.\n-                    other.bound_vars().len() <= victim.bound_vars().len()\n+                    if other.bound_vars().len() <= victim.bound_vars().len() {\n+                        DropVictim::Yes\n+                    } else {\n+                        DropVictim::No\n+                    }\n                 } else if other.skip_binder().trait_ref == victim.skip_binder().trait_ref\n                     && victim.skip_binder().constness == ty::BoundConstness::NotConst\n                     && other.skip_binder().polarity == victim.skip_binder().polarity\n                 {\n                     // Drop otherwise equivalent non-const candidates in favor of const candidates.\n-                    true\n+                    DropVictim::Yes\n                 } else {\n-                    false\n+                    DropVictim::No\n                 }\n             }\n \n             // Drop otherwise equivalent non-const fn pointer candidates\n-            (FnPointerCandidate { .. }, FnPointerCandidate { is_const: false }) => true,\n+            (FnPointerCandidate { .. }, FnPointerCandidate { is_const: false }) => DropVictim::Yes,\n \n-            // Global bounds from the where clause should be ignored\n-            // here (see issue #50825). Otherwise, we have a where\n-            // clause so don't go around looking for impls.\n-            // Arbitrarily give param candidates priority\n-            // over projection and object candidates.\n             (\n-                ParamCandidate(ref cand),\n+                ParamCandidate(ref other_cand),\n                 ImplCandidate(..)\n                 | ClosureCandidate { .. }\n                 | GeneratorCandidate\n@@ -1939,11 +1947,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | TraitAliasCandidate\n                 | ObjectCandidate(_)\n                 | ProjectionCandidate(..),\n-            ) => !is_global(cand),\n-            (ObjectCandidate(_) | ProjectionCandidate(..), ParamCandidate(ref cand)) => {\n+            ) => {\n+                if is_global(other_cand) {\n+                    DropVictim::No\n+                } else {\n+                    // We have a where clause so don't go around looking\n+                    // for impls. Arbitrarily give param candidates priority\n+                    // over projection and object candidates.\n+                    //\n+                    // Global bounds from the where clause should be ignored\n+                    // here (see issue #50825).\n+                    DropVictim::Yes\n+                }\n+            }\n+            (ObjectCandidate(_) | ProjectionCandidate(..), ParamCandidate(ref victim_cand)) => {\n                 // Prefer these to a global where-clause bound\n                 // (see issue #50825).\n-                is_global(cand)\n+                if is_global(victim_cand) { DropVictim::Yes } else { DropVictim::No }\n             }\n             (\n                 ImplCandidate(_)\n@@ -1956,18 +1976,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { has_nested: true }\n                 | TraitAliasCandidate,\n-                ParamCandidate(ref cand),\n+                ParamCandidate(ref victim_cand),\n             ) => {\n                 // Prefer these to a global where-clause bound\n                 // (see issue #50825).\n-                is_global(cand) && other.evaluation.must_apply_modulo_regions()\n+                if is_global(victim_cand) && other.evaluation.must_apply_modulo_regions() {\n+                    DropVictim::Yes\n+                } else {\n+                    DropVictim::No\n+                }\n             }\n \n             (ProjectionCandidate(i, _), ProjectionCandidate(j, _))\n             | (ObjectCandidate(i), ObjectCandidate(j)) => {\n                 // Arbitrarily pick the lower numbered candidate for backwards\n                 // compatibility reasons. Don't let this affect inference.\n-                i < j && !needs_infer\n+                if i < j && !needs_infer { DropVictim::Yes } else { DropVictim::No }\n             }\n             (ObjectCandidate(_), ProjectionCandidate(..))\n             | (ProjectionCandidate(..), ObjectCandidate(_)) => {\n@@ -1987,7 +2011,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate,\n-            ) => true,\n+            ) => DropVictim::Yes,\n \n             (\n                 ImplCandidate(..)\n@@ -2001,7 +2025,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate,\n                 ObjectCandidate(_) | ProjectionCandidate(..),\n-            ) => false,\n+            ) => DropVictim::No,\n \n             (&ImplCandidate(other_def), &ImplCandidate(victim_def)) => {\n                 // See if we can toss out `victim` based on specialization.\n@@ -2014,7 +2038,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let tcx = self.tcx();\n                 if other.evaluation.must_apply_modulo_regions() {\n                     if tcx.specializes((other_def, victim_def)) {\n-                        return true;\n+                        return DropVictim::Yes;\n                     }\n                 }\n \n@@ -2060,13 +2084,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             // will then correctly report an inference error, since the\n                             // existence of multiple marker trait impls tells us nothing\n                             // about which one should actually apply.\n-                            !needs_infer\n+                            if needs_infer { DropVictim::No } else { DropVictim::Yes }\n                         }\n-                        Some(_) => true,\n-                        None => false,\n+                        Some(_) => DropVictim::Yes,\n+                        None => DropVictim::No,\n                     }\n                 } else {\n-                    false\n+                    DropVictim::No\n                 }\n             }\n \n@@ -2092,10 +2116,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { has_nested: true }\n                 | TraitAliasCandidate,\n-            ) => false,\n+            ) => DropVictim::No,\n         }\n     }\n+}\n \n+impl<'tcx> SelectionContext<'_, 'tcx> {\n     fn sized_conditions(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n@@ -2532,7 +2558,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // We can avoid creating type variables and doing the full\n         // substitution if we find that any of the input types, when\n         // simplified, do not match.\n-        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n+        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::ForLookup };\n         iter::zip(obligation.predicate.skip_binder().trait_ref.substs, impl_trait_ref.substs)\n             .any(|(obl, imp)| !drcx.generic_args_may_unify(obl, imp))\n     }"}, {"sha": "fcfb60b26030f4d5696d8bce23aa16d543577d3e", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -99,10 +99,10 @@ pub fn translate_substs<'tcx>(\n             }\n \n             fulfill_implication(infcx, param_env, source_trait_ref, target_impl).unwrap_or_else(\n-                |_| {\n+                |()| {\n                     bug!(\n-                        \"When translating substitutions for specialization, the expected \\\n-                         specialization failed to hold\"\n+                        \"When translating substitutions from {source_impl:?} to {target_impl:?}, \\\n+                        the expected specialization failed to hold\"\n                     )\n                 },\n             )"}, {"sha": "cd665d9471db23a393370c81e5b9193758f85f86", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -3,7 +3,7 @@ use super::OverlapError;\n use crate::traits;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n+use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams, TreatProjections};\n use rustc_middle::ty::{self, TyCtxt, TypeVisitableExt};\n \n pub use rustc_middle::traits::specialization_graph::*;\n@@ -49,8 +49,12 @@ impl<'tcx> ChildrenExt<'tcx> for Children {\n     /// Insert an impl into this set of children without comparing to any existing impls.\n     fn insert_blindly(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap().skip_binder();\n-        if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsInfer)\n-        {\n+        if let Some(st) = fast_reject::simplify_type(\n+            tcx,\n+            trait_ref.self_ty(),\n+            TreatParams::AsCandidateKey,\n+            TreatProjections::AsCandidateKey,\n+        ) {\n             debug!(\"insert_blindly: impl_def_id={:?} st={:?}\", impl_def_id, st);\n             self.non_blanket_impls.entry(st).or_default().push(impl_def_id)\n         } else {\n@@ -65,8 +69,12 @@ impl<'tcx> ChildrenExt<'tcx> for Children {\n     fn remove_existing(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap().skip_binder();\n         let vec: &mut Vec<DefId>;\n-        if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsInfer)\n-        {\n+        if let Some(st) = fast_reject::simplify_type(\n+            tcx,\n+            trait_ref.self_ty(),\n+            TreatParams::AsCandidateKey,\n+            TreatProjections::AsCandidateKey,\n+        ) {\n             debug!(\"remove_existing: impl_def_id={:?} st={:?}\", impl_def_id, st);\n             vec = self.non_blanket_impls.get_mut(&st).unwrap();\n         } else {\n@@ -302,7 +310,12 @@ impl<'tcx> GraphExt<'tcx> for Graph {\n \n         let mut parent = trait_def_id;\n         let mut last_lint = None;\n-        let simplified = fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsInfer);\n+        let simplified = fast_reject::simplify_type(\n+            tcx,\n+            trait_ref.self_ty(),\n+            TreatParams::AsCandidateKey,\n+            TreatProjections::AsCandidateKey,\n+        );\n \n         // Descend the specialization tree, where `parent` is the current parent node.\n         loop {"}, {"sha": "abe65a0e3fef06415599478dad5d702316a7a6df", "filename": "compiler/rustc_ty_utils/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ty_utils%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ty_utils%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fmessages.ftl?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "compiler/rustc_ty_utils/locales/en-US.ftl"}, {"sha": "867974749d5fe32bf86f3e5da9798a38fe60423c", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 56, "deletions": 22, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -22,7 +22,7 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n     let item = tcx.hir().expect_item(def_id.expect_local());\n     match item.kind {\n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n-            if tcx.sess.opts.unstable_opts.lower_impl_trait_in_trait_to_assoc_ty {\n+            if tcx.lower_impl_trait_in_trait_to_assoc_ty() {\n                 // We collect RPITITs for each trait method's return type and create a\n                 // corresponding associated item using associated_items_for_impl_trait_in_trait\n                 // query.\n@@ -53,7 +53,7 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n             }\n         }\n         hir::ItemKind::Impl(ref impl_) => {\n-            if tcx.sess.opts.unstable_opts.lower_impl_trait_in_trait_to_assoc_ty {\n+            if tcx.lower_impl_trait_in_trait_to_assoc_ty() {\n                 // We collect RPITITs for each trait method's return type, on the impl side too and\n                 // create a corresponding associated item using\n                 // associated_items_for_impl_trait_in_trait query.\n@@ -153,6 +153,7 @@ fn associated_item_from_trait_item_ref(trait_item_ref: &hir::TraitItemRef) -> ty\n         trait_item_def_id: Some(owner_id.to_def_id()),\n         container: ty::TraitContainer,\n         fn_has_self_parameter: has_self,\n+        opt_rpitit_info: None,\n     }\n }\n \n@@ -171,6 +172,7 @@ fn associated_item_from_impl_item_ref(impl_item_ref: &hir::ImplItemRef) -> ty::A\n         trait_item_def_id: impl_item_ref.trait_item_def_id,\n         container: ty::ImplContainer,\n         fn_has_self_parameter: has_self,\n+        opt_rpitit_info: None,\n     }\n }\n \n@@ -262,19 +264,17 @@ fn associated_item_for_impl_trait_in_trait(\n     // Copy span of the opaque.\n     trait_assoc_ty.def_ident_span(Some(span));\n \n-    // Add the def_id of the function and opaque that generated this synthesized associated type.\n-    trait_assoc_ty.opt_rpitit_info(Some(ImplTraitInTraitData::Trait {\n-        fn_def_id,\n-        opaque_def_id: opaque_ty_def_id.to_def_id(),\n-    }));\n-\n     trait_assoc_ty.associated_item(ty::AssocItem {\n         name: kw::Empty,\n         kind: ty::AssocKind::Type,\n         def_id,\n         trait_item_def_id: None,\n         container: ty::TraitContainer,\n         fn_has_self_parameter: false,\n+        opt_rpitit_info: Some(ImplTraitInTraitData::Trait {\n+            fn_def_id,\n+            opaque_def_id: opaque_ty_def_id.to_def_id(),\n+        }),\n     });\n \n     // Copy visility of the containing function.\n@@ -301,9 +301,6 @@ fn associated_item_for_impl_trait_in_trait(\n     // There are no inferred outlives for the synthesized associated type.\n     trait_assoc_ty.inferred_outlives_of(&[]);\n \n-    // FIXME implement this.\n-    trait_assoc_ty.explicit_item_bounds(&[]);\n-\n     local_def_id\n }\n \n@@ -315,11 +312,12 @@ fn impl_associated_item_for_impl_trait_in_trait(\n     trait_assoc_def_id: LocalDefId,\n     impl_fn_def_id: LocalDefId,\n ) -> LocalDefId {\n-    let impl_def_id = tcx.local_parent(impl_fn_def_id);\n+    let impl_local_def_id = tcx.local_parent(impl_fn_def_id);\n+    let impl_def_id = impl_local_def_id.to_def_id();\n \n     // FIXME fix the span, we probably want the def_id of the return type of the function\n     let span = tcx.def_span(impl_fn_def_id);\n-    let impl_assoc_ty = tcx.at(span).create_def(impl_def_id, DefPathData::ImplTraitAssocTy);\n+    let impl_assoc_ty = tcx.at(span).create_def(impl_local_def_id, DefPathData::ImplTraitAssocTy);\n \n     let local_def_id = impl_assoc_ty.def_id();\n     let def_id = local_def_id.to_def_id();\n@@ -330,27 +328,63 @@ fn impl_associated_item_for_impl_trait_in_trait(\n     // `opt_local_def_id_to_hir_id` with `None`.\n     impl_assoc_ty.opt_local_def_id_to_hir_id(None);\n \n-    // Add the def_id of the function that generated this synthesized associated type.\n-    impl_assoc_ty.opt_rpitit_info(Some(ImplTraitInTraitData::Impl {\n-        fn_def_id: impl_fn_def_id.to_def_id(),\n-    }));\n-\n     impl_assoc_ty.associated_item(ty::AssocItem {\n         name: kw::Empty,\n         kind: ty::AssocKind::Type,\n         def_id,\n         trait_item_def_id: Some(trait_assoc_def_id.to_def_id()),\n         container: ty::ImplContainer,\n         fn_has_self_parameter: false,\n+        opt_rpitit_info: Some(ImplTraitInTraitData::Impl { fn_def_id: impl_fn_def_id.to_def_id() }),\n     });\n \n+    // Copy param_env of the containing function. The synthesized associated type doesn't have\n+    // extra predicates to assume.\n+    impl_assoc_ty.param_env(tcx.param_env(impl_fn_def_id));\n+\n     // Copy impl_defaultness of the containing function.\n     impl_assoc_ty.impl_defaultness(tcx.impl_defaultness(impl_fn_def_id));\n \n-    // Copy generics_of the trait's associated item.\n-    // FIXME: This is not correct, in particular the parent is going to be wrong. So we would need\n-    // to copy from trait_assoc_def_id and adjust things.\n-    impl_assoc_ty.generics_of(tcx.generics_of(trait_assoc_def_id).clone());\n+    // Copy generics_of the trait's associated item but the impl as the parent.\n+    impl_assoc_ty.generics_of({\n+        let trait_assoc_generics = tcx.generics_of(trait_assoc_def_id);\n+        let trait_assoc_parent_count = trait_assoc_generics.parent_count;\n+        let mut params = trait_assoc_generics.params.clone();\n+\n+        let parent_generics = tcx.generics_of(impl_def_id);\n+        let parent_count = parent_generics.parent_count + parent_generics.params.len();\n+\n+        let mut impl_fn_params = tcx.generics_of(impl_fn_def_id).params.clone();\n+\n+        for param in &mut params {\n+            param.index = param.index + parent_count as u32 + impl_fn_params.len() as u32\n+                - trait_assoc_parent_count as u32;\n+        }\n+\n+        impl_fn_params.extend(params);\n+        params = impl_fn_params;\n+\n+        let param_def_id_to_index =\n+            params.iter().map(|param| (param.def_id, param.index)).collect();\n+\n+        ty::Generics {\n+            parent: Some(impl_def_id),\n+            parent_count,\n+            params,\n+            param_def_id_to_index,\n+            has_self: false,\n+            has_late_bound_regions: trait_assoc_generics.has_late_bound_regions,\n+        }\n+    });\n+\n+    // There are no predicates for the synthesized associated type.\n+    impl_assoc_ty.explicit_predicates_of(ty::GenericPredicates {\n+        parent: Some(impl_def_id),\n+        predicates: &[],\n+    });\n+\n+    // There are no inferred outlives for the synthesized associated type.\n+    impl_assoc_ty.inferred_outlives_of(&[]);\n \n     local_def_id\n }"}, {"sha": "3865a8f32236abe34a277cce56b24c63c0e84998", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -33,7 +33,7 @@ pub mod representability;\n mod structural_match;\n mod ty;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n pub fn provide(providers: &mut Providers) {\n     abi::provide(providers);"}, {"sha": "c8ed1f365f1a8ce216cf48373801f752fe8f8a5c", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -3,8 +3,8 @@ use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::ty::{\n-    self, Binder, EarlyBinder, Predicate, PredicateKind, ToPredicate, Ty, TyCtxt,\n-    TypeSuperVisitable, TypeVisitable, TypeVisitor,\n+    self, Binder, EarlyBinder, ImplTraitInTraitData, Predicate, PredicateKind, ToPredicate, Ty,\n+    TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n };\n use rustc_session::config::TraitSolver;\n use rustc_span::def_id::{DefId, CRATE_DEF_ID};\n@@ -117,6 +117,15 @@ fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> &[Ty<'_>] {\n \n /// See `ParamEnv` struct definition for details.\n fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n+    // When computing the param_env of an RPITIT, copy param_env of the containing function. The\n+    // synthesized associated type doesn't have extra predicates to assume.\n+    let def_id =\n+        if let Some(ImplTraitInTraitData::Trait { fn_def_id, .. }) = tcx.opt_rpitit_info(def_id) {\n+            fn_def_id\n+        } else {\n+            def_id\n+        };\n+\n     // Compute the bounds on Self and the type parameters.\n     let ty::InstantiatedPredicates { mut predicates, .. } =\n         tcx.predicates_of(def_id).instantiate_identity(tcx);"}, {"sha": "3a053d4c6a997da7434fb893353cafac17831cfb", "filename": "compiler/rustc_type_ir/src/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_type_ir%2Fsrc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_type_ir%2Fsrc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Ffold.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -18,7 +18,7 @@\n //!     It defines a \"skeleton\" of how they should be folded.\n //! - `TypeSuperFoldable`. This is implemented only for each type of interest,\n //!   and defines the folding \"skeleton\" for these types.\n-//! - `TypeFolder`/`FallibleTypeFolder. One of these is implemented for each\n+//! - `TypeFolder`/`FallibleTypeFolder`. One of these is implemented for each\n //!   folder. This defines how types of interest are folded.\n //!\n //! This means each fold is a mixture of (a) generic folding operations, and (b)"}, {"sha": "62e699eefd706cf9e13d323e050f48d6b6bfb9d5", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -167,7 +167,7 @@ pub enum TyKind<I: Interner> {\n     /// lifetimes bound by the witness itself.\n     ///\n     /// This variant is only using when `drop_tracking_mir` is set.\n-    /// This contains the `DefId` and the `SubstRef` of the generator.\n+    /// This contains the `DefId` and the `SubstsRef` of the generator.\n     /// The actual witness types are computed on MIR by the `mir_generator_witnesses` query.\n     ///\n     /// Looking at the following example, the witness for this generator"}, {"sha": "dee0d8f254b63596dfded6caf64c7c197dbcb9ab", "filename": "config.example.toml", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/config.example.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/config.example.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.example.toml?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "previous_filename": "config.toml.example"}, {"sha": "241b11c3f5f5219650c8f534156426eca0be8364", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -214,6 +214,7 @@ impl<T> Box<T> {\n     #[inline(always)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use]\n+    #[rustc_diagnostic_item = \"box_new\"]\n     pub fn new(x: T) -> Self {\n         #[rustc_box]\n         Box::new(x)"}, {"sha": "0be274a3822d3ac58608f3badfe556f7ee54d0a1", "filename": "library/alloc/src/collections/vec_deque/drain.rs", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -52,36 +52,22 @@ impl<'a, T, A: Allocator> Drain<'a, T, A> {\n         }\n     }\n \n-    // Only returns pointers to the slices, as that's\n-    // all we need to drop them. May only be called if `self.remaining != 0`.\n+    // Only returns pointers to the slices, as that's all we need\n+    // to drop them. May only be called if `self.remaining != 0`.\n     unsafe fn as_slices(&self) -> (*mut [T], *mut [T]) {\n         unsafe {\n             let deque = self.deque.as_ref();\n-            // FIXME: This is doing almost exactly the same thing as the else branch in `VecDeque::slice_ranges`.\n-            // Unfortunately, we can't just call `slice_ranges` here, as the deque's `len` is currently\n-            // just `drain_start`, so the range check would (almost) always panic. Between temporarily\n-            // adjusting the deques `len` to call `slice_ranges`, and just copy pasting the `slice_ranges`\n-            // implementation, this seemed like the less hacky solution, though it might be good to\n-            // find a better one in the future.\n-\n-            // because `self.remaining != 0`, we know that `self.idx < deque.original_len`, so it's a valid\n-            // logical index.\n-            let wrapped_start = deque.to_physical_idx(self.idx);\n-\n-            let head_len = deque.capacity() - wrapped_start;\n-\n-            let (a_range, b_range) = if head_len >= self.remaining {\n-                (wrapped_start..wrapped_start + self.remaining, 0..0)\n-            } else {\n-                let tail_len = self.remaining - head_len;\n-                (wrapped_start..deque.capacity(), 0..tail_len)\n-            };\n-\n-            // SAFETY: the range `self.idx..self.idx+self.remaining` lies strictly inside\n-            // the range `0..deque.original_len`. because of this, and because of the fact\n-            // that we acquire `a_range` and `b_range` exactly like `slice_ranges` would,\n-            // it's guaranteed that `a_range` and `b_range` represent valid ranges into\n-            // the deques buffer.\n+\n+            // We know that `self.idx + self.remaining <= deque.len <= usize::MAX`, so this won't overflow.\n+            let logical_remaining_range = self.idx..self.idx + self.remaining;\n+\n+            // SAFETY: `logical_remaining_range` represents the\n+            // range into the logical buffer of elements that\n+            // haven't been drained yet, so they're all initialized,\n+            // and `slice::range(start..end, end) == start..end`,\n+            // so the preconditions for `slice_ranges` are met.\n+            let (a_range, b_range) =\n+                deque.slice_ranges(logical_remaining_range.clone(), logical_remaining_range.end);\n             (deque.buffer_range(a_range), deque.buffer_range(b_range))\n         }\n     }"}, {"sha": "48e907e402ccf2462ddaa917d8c0a63bf9239503", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1156,7 +1156,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_slices(&self) -> (&[T], &[T]) {\n-        let (a_range, b_range) = self.slice_ranges(..);\n+        let (a_range, b_range) = self.slice_ranges(.., self.len);\n         // SAFETY: `slice_ranges` always returns valid ranges into\n         // the physical buffer.\n         unsafe { (&*self.buffer_range(a_range), &*self.buffer_range(b_range)) }\n@@ -1190,7 +1190,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {\n-        let (a_range, b_range) = self.slice_ranges(..);\n+        let (a_range, b_range) = self.slice_ranges(.., self.len);\n         // SAFETY: `slice_ranges` always returns valid ranges into\n         // the physical buffer.\n         unsafe { (&mut *self.buffer_range(a_range), &mut *self.buffer_range(b_range)) }\n@@ -1232,19 +1232,28 @@ impl<T, A: Allocator> VecDeque<T, A> {\n \n     /// Given a range into the logical buffer of the deque, this function\n     /// return two ranges into the physical buffer that correspond to\n-    /// the given range.\n-    fn slice_ranges<R>(&self, range: R) -> (Range<usize>, Range<usize>)\n+    /// the given range. The `len` parameter should usually just be `self.len`;\n+    /// the reason it's passed explicitly is that if the deque is wrapped in\n+    /// a `Drain`, then `self.len` is not actually the length of the deque.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is always safe to call. For the resulting ranges to be valid\n+    /// ranges into the physical buffer, the caller must ensure that the result of\n+    /// calling `slice::range(range, ..len)` represents a valid range into the\n+    /// logical buffer, and that all elements in that range are initialized.\n+    fn slice_ranges<R>(&self, range: R, len: usize) -> (Range<usize>, Range<usize>)\n     where\n         R: RangeBounds<usize>,\n     {\n-        let Range { start, end } = slice::range(range, ..self.len);\n+        let Range { start, end } = slice::range(range, ..len);\n         let len = end - start;\n \n         if len == 0 {\n             (0..0, 0..0)\n         } else {\n-            // `slice::range` guarantees that `start <= end <= self.len`.\n-            // because `len != 0`, we know that `start < end`, so `start < self.len`\n+            // `slice::range` guarantees that `start <= end <= len`.\n+            // because `len != 0`, we know that `start < end`, so `start < len`\n             // and the indexing is valid.\n             let wrapped_start = self.to_physical_idx(start);\n \n@@ -1290,7 +1299,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        let (a_range, b_range) = self.slice_ranges(range);\n+        let (a_range, b_range) = self.slice_ranges(range, self.len);\n         // SAFETY: The ranges returned by `slice_ranges`\n         // are valid ranges into the physical buffer, so\n         // it's ok to pass them to `buffer_range` and\n@@ -1330,7 +1339,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        let (a_range, b_range) = self.slice_ranges(range);\n+        let (a_range, b_range) = self.slice_ranges(range, self.len);\n         // SAFETY: The ranges returned by `slice_ranges`\n         // are valid ranges into the physical buffer, so\n         // it's ok to pass them to `buffer_range` and"}, {"sha": "77b0447b345ec9a91a22e3695a00997e0429ec58", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -681,6 +681,24 @@ impl<T> Rc<T> {\n             Err(this)\n         }\n     }\n+\n+    /// Returns the inner value, if the `Rc` has exactly one strong reference.\n+    ///\n+    /// Otherwise, [`None`] is returned and the `Rc` is dropped.\n+    ///\n+    /// This will succeed even if there are outstanding weak references.\n+    ///\n+    /// If `Rc::into_inner` is called on every clone of this `Rc`,\n+    /// it is guaranteed that exactly one of the calls returns the inner value.\n+    /// This means in particular that the inner value is not dropped.\n+    ///\n+    /// This is equivalent to `Rc::try_unwrap(...).ok()`. (Note that these are not equivalent for\n+    /// `Arc`, due to race conditions that do not apply to `Rc`.)\n+    #[inline]\n+    #[unstable(feature = \"rc_into_inner\", issue = \"106894\")]\n+    pub fn into_inner(this: Self) -> Option<T> {\n+        Rc::try_unwrap(this).ok()\n+    }\n }\n \n impl<T> Rc<[T]> {"}, {"sha": "2784108e0e63509101a225f716a2a1625d743350", "filename": "library/alloc/src/rc/tests.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Falloc%2Fsrc%2Frc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Falloc%2Fsrc%2Frc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc%2Ftests.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -151,6 +151,21 @@ fn try_unwrap() {\n     assert_eq!(Rc::try_unwrap(x), Ok(5));\n }\n \n+#[test]\n+fn into_inner() {\n+    let x = Rc::new(3);\n+    assert_eq!(Rc::into_inner(x), Some(3));\n+\n+    let x = Rc::new(4);\n+    let y = Rc::clone(&x);\n+    assert_eq!(Rc::into_inner(x), None);\n+    assert_eq!(Rc::into_inner(y), Some(4));\n+\n+    let x = Rc::new(5);\n+    let _w = Rc::downgrade(&x);\n+    assert_eq!(Rc::into_inner(x), Some(5));\n+}\n+\n #[test]\n fn into_from_raw() {\n     let x = Rc::new(Box::new(\"hello\"));"}, {"sha": "f37573c6f27f4aa91f93683183ae0579a2bdcc7d", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -51,8 +51,16 @@ mod tests;\n ///\n /// Going above this limit will abort your program (although not\n /// necessarily) at _exactly_ `MAX_REFCOUNT + 1` references.\n+/// Trying to go above it might call a `panic` (if not actually going above it).\n+///\n+/// This is a global invariant, and also applies when using a compare-exchange loop.\n+///\n+/// See comment in `Arc::clone`.\n const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n \n+/// The error in case either counter reaches above `MAX_REFCOUNT`, and we can `panic` safely.\n+const INTERNAL_OVERFLOW_ERROR: &str = \"Arc counter overflow\";\n+\n #[cfg(not(sanitize = \"thread\"))]\n macro_rules! acquire {\n     ($x:expr) => {\n@@ -1104,6 +1112,9 @@ impl<T: ?Sized> Arc<T> {\n                 continue;\n             }\n \n+            // We can't allow the refcount to increase much past `MAX_REFCOUNT`.\n+            assert!(cur <= MAX_REFCOUNT, \"{}\", INTERNAL_OVERFLOW_ERROR);\n+\n             // NOTE: this code currently ignores the possibility of overflow\n             // into usize::MAX; in general both Rc and Arc need to be adjusted\n             // to deal with overflow.\n@@ -1519,6 +1530,11 @@ impl<T: ?Sized> Clone for Arc<T> {\n         // the worst already happened and we actually do overflow the `usize` counter. However, that\n         // requires the counter to grow from `isize::MAX` to `usize::MAX` between the increment\n         // above and the `abort` below, which seems exceedingly unlikely.\n+        //\n+        // This is a global invariant, and also applies when using a compare-exchange loop to increment\n+        // counters in other methods.\n+        // Otherwise, the counter could be brought to an almost-overflow using a compare-exchange loop,\n+        // and then overflow using a few `fetch_add`s.\n         if old_size > MAX_REFCOUNT {\n             abort();\n         }\n@@ -2180,9 +2196,7 @@ impl<T: ?Sized> Weak<T> {\n                     return None;\n                 }\n                 // See comments in `Arc::clone` for why we do this (for `mem::forget`).\n-                if n > MAX_REFCOUNT {\n-                    abort();\n-                }\n+                assert!(n <= MAX_REFCOUNT, \"{}\", INTERNAL_OVERFLOW_ERROR);\n                 Some(n + 1)\n             })\n             .ok()"}, {"sha": "b1d3a9fa8ac9035239a7aae6cb5d3a530d3e6cf3", "filename": "library/alloc/src/tests.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Falloc%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Falloc%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ftests.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -4,7 +4,6 @@ use core::any::Any;\n use core::clone::Clone;\n use core::convert::TryInto;\n use core::ops::Deref;\n-use core::result::Result::{Err, Ok};\n \n use std::boxed::Box;\n \n@@ -15,32 +14,25 @@ fn test_owned_clone() {\n     assert!(a == b);\n }\n \n-#[derive(PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq)]\n struct Test;\n \n #[test]\n fn any_move() {\n     let a = Box::new(8) as Box<dyn Any>;\n     let b = Box::new(Test) as Box<dyn Any>;\n \n-    match a.downcast::<i32>() {\n-        Ok(a) => {\n-            assert!(a == Box::new(8));\n-        }\n-        Err(..) => panic!(),\n-    }\n-    match b.downcast::<Test>() {\n-        Ok(a) => {\n-            assert!(a == Box::new(Test));\n-        }\n-        Err(..) => panic!(),\n-    }\n+    let a: Box<i32> = a.downcast::<i32>().unwrap();\n+    assert_eq!(*a, 8);\n+\n+    let b: Box<Test> = b.downcast::<Test>().unwrap();\n+    assert_eq!(*b, Test);\n \n     let a = Box::new(8) as Box<dyn Any>;\n     let b = Box::new(Test) as Box<dyn Any>;\n \n-    assert!(a.downcast::<Box<Test>>().is_err());\n-    assert!(b.downcast::<Box<i32>>().is_err());\n+    assert!(a.downcast::<Box<i32>>().is_err());\n+    assert!(b.downcast::<Box<Test>>().is_err());\n }\n \n #[test]"}, {"sha": "9d1720acf36637f2651ff55d86a0e6b7db22a8be", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -209,6 +209,12 @@ pub use once::OnceCell;\n \n /// A mutable memory location.\n ///\n+/// # Memory layout\n+///\n+/// `Cell<T>` has the same [memory layout and caveats as\n+/// `UnsafeCell<T>`](UnsafeCell#memory-layout). In particular, this means that\n+/// `Cell<T>` has the same in-memory representation as its inner type `T`.\n+///\n /// # Examples\n ///\n /// In this example, you can see that `Cell<T>` enables mutation inside an"}, {"sha": "a74a56bc5b2094ba8886009651f0f1711bd09c6a", "filename": "library/core/src/convert/num.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -172,7 +172,18 @@ impl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\"\n #[stable(feature = \"float_from_bool\", since = \"1.68.0\")]\n #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n impl const From<bool> for f32 {\n-    /// Converts `bool` to `f32` losslessly.\n+    /// Converts `bool` to `f32` losslessly. The resulting value is positive\n+    /// `0.0` for `false` and `1.0` for `true` values.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// let x: f32 = false.into();\n+    /// assert_eq!(x, 0.0);\n+    /// assert!(x.is_sign_positive());\n+    ///\n+    /// let y: f32 = true.into();\n+    /// assert_eq!(y, 1.0);\n+    /// ```\n     #[inline]\n     fn from(small: bool) -> Self {\n         small as u8 as Self\n@@ -181,7 +192,18 @@ impl const From<bool> for f32 {\n #[stable(feature = \"float_from_bool\", since = \"1.68.0\")]\n #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n impl const From<bool> for f64 {\n-    /// Converts `bool` to `f64` losslessly.\n+    /// Converts `bool` to `f64` losslessly. The resulting value is positive\n+    /// `0.0` for `false` and `1.0` for `true` values.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// let x: f64 = false.into();\n+    /// assert_eq!(x, 0.0);\n+    /// assert!(x.is_sign_positive());\n+    ///\n+    /// let y: f64 = true.into();\n+    /// assert_eq!(y, 1.0);\n+    /// ```\n     #[inline]\n     fn from(small: bool) -> Self {\n         small as u8 as Self"}, {"sha": "04f02d47f92cb058f9aa84154f8675f6b7838db4", "filename": "library/core/src/future/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -67,14 +67,10 @@ pub unsafe fn get_context<'a, 'b>(cx: ResumeTy) -> &'a mut Context<'b> {\n     unsafe { &mut *cx.0.as_ptr().cast() }\n }\n \n-// FIXME(swatinem): This fn is currently needed to work around shortcomings\n-// in type and lifetime inference.\n-// See the comment at the bottom of `LoweringContext::make_async_expr` and\n-// <https://github.com/rust-lang/rust/issues/104826>.\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[inline]\n-#[lang = \"identity_future\"]\n+#[cfg_attr(bootstrap, lang = \"identity_future\")]\n pub const fn identity_future<O, Fut: Future<Output = O>>(f: Fut) -> Fut {\n     f\n }"}, {"sha": "06d22d84aedcca715aeab43f694403ab72529227", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1147,12 +1147,10 @@ macro_rules! nonzero_min_max_unsigned {\n                 /// # Examples\n                 ///\n                 /// ```\n-                /// #![feature(nonzero_min_max)]\n-                ///\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::MIN.get(), 1\", stringify!($Int), \");\")]\n                 /// ```\n-                #[unstable(feature = \"nonzero_min_max\", issue = \"89065\")]\n+                #[stable(feature = \"nonzero_min_max\", since = \"CURRENT_RUSTC_VERSION\")]\n                 pub const MIN: Self = Self::new(1).unwrap();\n \n                 /// The largest value that can be represented by this non-zero\n@@ -1162,12 +1160,10 @@ macro_rules! nonzero_min_max_unsigned {\n                 /// # Examples\n                 ///\n                 /// ```\n-                /// #![feature(nonzero_min_max)]\n-                ///\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::MAX.get(), \", stringify!($Int), \"::MAX);\")]\n                 /// ```\n-                #[unstable(feature = \"nonzero_min_max\", issue = \"89065\")]\n+                #[stable(feature = \"nonzero_min_max\", since = \"CURRENT_RUSTC_VERSION\")]\n                 pub const MAX: Self = Self::new(<$Int>::MAX).unwrap();\n             }\n         )+\n@@ -1189,12 +1185,10 @@ macro_rules! nonzero_min_max_signed {\n                 /// # Examples\n                 ///\n                 /// ```\n-                /// #![feature(nonzero_min_max)]\n-                ///\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::MIN.get(), \", stringify!($Int), \"::MIN);\")]\n                 /// ```\n-                #[unstable(feature = \"nonzero_min_max\", issue = \"89065\")]\n+                #[stable(feature = \"nonzero_min_max\", since = \"CURRENT_RUSTC_VERSION\")]\n                 pub const MIN: Self = Self::new(<$Int>::MIN).unwrap();\n \n                 /// The largest value that can be represented by this non-zero\n@@ -1208,12 +1202,10 @@ macro_rules! nonzero_min_max_signed {\n                 /// # Examples\n                 ///\n                 /// ```\n-                /// #![feature(nonzero_min_max)]\n-                ///\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::MAX.get(), \", stringify!($Int), \"::MAX);\")]\n                 /// ```\n-                #[unstable(feature = \"nonzero_min_max\", issue = \"89065\")]\n+                #[stable(feature = \"nonzero_min_max\", since = \"CURRENT_RUSTC_VERSION\")]\n                 pub const MAX: Self = Self::new(<$Int>::MAX).unwrap();\n             }\n         )+"}, {"sha": "0f2475a8bdea60435df0e26d2a04c8a68b019e5f", "filename": "library/core/src/option.rs", "status": "modified", "additions": 83, "deletions": 37, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -735,22 +735,47 @@ impl<T> Option<T> {\n         }\n     }\n \n-    const fn get_some_offset() -> isize {\n-        if mem::size_of::<Option<T>>() == mem::size_of::<T>() {\n-            // niche optimization means the `T` is always stored at the same position as the Option.\n-            0\n+    /// This is a guess at how many bytes into the option the payload can be found.\n+    ///\n+    /// For niche-optimized types it's correct because it's pigeon-holed to only\n+    /// one possible place.  For other types, it's usually correct today, but\n+    /// tweaks to the layout algorithm (particularly expansions of\n+    /// `-Z randomize-layout`) might make it incorrect at any point.\n+    ///\n+    /// It's guaranteed to be a multiple of alignment (so will always give a\n+    /// correctly-aligned location) and to be within the allocated object, so\n+    /// is valid to use with `offset` and to use for a zero-sized read.\n+    ///\n+    /// FIXME: This is a horrible hack, but allows a nice optimization.  It should\n+    /// be replaced with `offset_of!` once that works on enum variants.\n+    const SOME_BYTE_OFFSET_GUESS: isize = {\n+        let some_uninit = Some(mem::MaybeUninit::<T>::uninit());\n+        let payload_ref = some_uninit.as_ref().unwrap();\n+        // SAFETY: `as_ref` gives an address inside the existing `Option`,\n+        // so both pointers are derived from the same thing and the result\n+        // cannot overflow an `isize`.\n+        let offset = unsafe { <*const _>::byte_offset_from(payload_ref, &some_uninit) };\n+\n+        // The offset is into the object, so it's guaranteed to be non-negative.\n+        assert!(offset >= 0);\n+\n+        // The payload and the overall option are aligned,\n+        // so the offset will be a multiple of the alignment too.\n+        assert!((offset as usize) % mem::align_of::<T>() == 0);\n+\n+        let max_offset = mem::size_of::<Self>() - mem::size_of::<T>();\n+        if offset as usize <= max_offset {\n+            // There's enough space after this offset for a `T` to exist without\n+            // overflowing the bounds of the object, so let's try it.\n+            offset\n         } else {\n-            assert!(mem::size_of::<Option<T>>() == mem::size_of::<Option<mem::MaybeUninit<T>>>());\n-            let some_uninit = Some(mem::MaybeUninit::<T>::uninit());\n-            // SAFETY: This gets the byte offset of the `Some(_)` value following the fact that\n-            // niche optimization is not active, and thus Option<T> and Option<MaybeUninit<t>> share\n-            // the same layout.\n-            unsafe {\n-                (some_uninit.as_ref().unwrap() as *const mem::MaybeUninit<T>)\n-                    .byte_offset_from(&some_uninit as *const Option<mem::MaybeUninit<T>>)\n-            }\n+            // The offset guess is definitely wrong, so use the address\n+            // of the original option since we have it already.\n+            // This also correctly handles the case of layout-optimized enums\n+            // where `max_offset == 0` and thus this is the only possibility.\n+            0\n         }\n-    }\n+    };\n \n     /// Returns a slice of the contained value, if any. If this is `None`, an\n     /// empty slice is returned. This can be useful to have a single type of\n@@ -784,18 +809,28 @@ impl<T> Option<T> {\n     #[must_use]\n     #[unstable(feature = \"option_as_slice\", issue = \"108545\")]\n     pub fn as_slice(&self) -> &[T] {\n-        // SAFETY: This is sound as long as `get_some_offset` returns the\n-        // correct offset. Though in the `None` case, the slice may be located\n-        // at a pointer pointing into padding, the fact that the slice is\n-        // empty, and the padding is at a properly aligned position for a\n-        // value of that type makes it sound.\n-        unsafe {\n-            slice::from_raw_parts(\n-                (self as *const Option<T>).wrapping_byte_offset(Self::get_some_offset())\n-                    as *const T,\n-                self.is_some() as usize,\n-            )\n-        }\n+        let payload_ptr: *const T =\n+            // The goal here is that both arms here are calculating exactly\n+            // the same pointer, and thus it'll be folded away when the guessed\n+            // offset is correct, but if the guess is wrong for some reason\n+            // it'll at least still be sound, just no longer optimal.\n+            if let Some(payload) = self {\n+                payload\n+            } else {\n+                let self_ptr: *const Self = self;\n+                // SAFETY: `SOME_BYTE_OFFSET_GUESS` guarantees that its value is\n+                // such that this will be in-bounds of the object.\n+                unsafe { self_ptr.byte_offset(Self::SOME_BYTE_OFFSET_GUESS).cast() }\n+            };\n+        let len = usize::from(self.is_some());\n+\n+        // SAFETY: When the `Option` is `Some`, we're using the actual pointer\n+        // to the payload, with a length of 1, so this is equivalent to\n+        // `slice::from_ref`, and thus is safe.\n+        // When the `Option` is `None`, the length used is 0, so to be safe it\n+        // just needs to be aligned, which it is because `&self` is aligned and\n+        // the offset used is a multiple of alignment.\n+        unsafe { slice::from_raw_parts(payload_ptr, len) }\n     }\n \n     /// Returns a mutable slice of the contained value, if any. If this is\n@@ -840,17 +875,28 @@ impl<T> Option<T> {\n     #[must_use]\n     #[unstable(feature = \"option_as_slice\", issue = \"108545\")]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n-        // SAFETY: This is sound as long as `get_some_offset` returns the\n-        // correct offset. Though in the `None` case, the slice may be located\n-        // at a pointer pointing into padding, the fact that the slice is\n-        // empty, and the padding is at a properly aligned position for a\n-        // value of that type makes it sound.\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                (self as *mut Option<T>).wrapping_byte_offset(Self::get_some_offset()) as *mut T,\n-                self.is_some() as usize,\n-            )\n-        }\n+        let payload_ptr: *mut T =\n+            // The goal here is that both arms here are calculating exactly\n+            // the same pointer, and thus it'll be folded away when the guessed\n+            // offset is correct, but if the guess is wrong for some reason\n+            // it'll at least still be sound, just no longer optimal.\n+            if let Some(payload) = self {\n+                payload\n+            } else {\n+                let self_ptr: *mut Self = self;\n+                // SAFETY: `SOME_BYTE_OFFSET_GUESS` guarantees that its value is\n+                // such that this will be in-bounds of the object.\n+                unsafe { self_ptr.byte_offset(Self::SOME_BYTE_OFFSET_GUESS).cast() }\n+            };\n+        let len = usize::from(self.is_some());\n+\n+        // SAFETY: When the `Option` is `Some`, we're using the actual pointer\n+        // to the payload, with a length of 1, so this is equivalent to\n+        // `slice::from_mut`, and thus is safe.\n+        // When the `Option` is `None`, the length used is 0, so to be safe it\n+        // just needs to be aligned, which it is because `&self` is aligned and\n+        // the offset used is a multiple of alignment.\n+        unsafe { slice::from_raw_parts_mut(payload_ptr, len) }\n     }\n \n     /////////////////////////////////////////////////////////////////////////"}, {"sha": "839afc57f85d2c66392ff2dc6805cfabb2bb0cb1", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -61,14 +61,14 @@ impl<T: ?Sized> *const T {\n \n     /// Use the pointer value in a new pointer of another type.\n     ///\n-    /// In case `val` is a (fat) pointer to an unsized type, this operation\n+    /// In case `meta` is a (fat) pointer to an unsized type, this operation\n     /// will ignore the pointer part, whereas for (thin) pointers to sized\n     /// types, this has the same effect as a simple cast.\n     ///\n     /// The resulting pointer will have provenance of `self`, i.e., for a fat\n     /// pointer, this operation is semantically the same as creating a new\n     /// fat pointer with the data pointer value of `self` but the metadata of\n-    /// `val`.\n+    /// `meta`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "f41be46abc96fd1699899fd25bca54214ba3b0f6", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -691,7 +691,7 @@ where\n #[inline(always)]\n #[must_use]\n #[unstable(feature = \"ptr_from_ref\", issue = \"106116\")]\n-pub fn from_ref<T: ?Sized>(r: &T) -> *const T {\n+pub const fn from_ref<T: ?Sized>(r: &T) -> *const T {\n     r\n }\n \n@@ -702,7 +702,7 @@ pub fn from_ref<T: ?Sized>(r: &T) -> *const T {\n #[inline(always)]\n #[must_use]\n #[unstable(feature = \"ptr_from_ref\", issue = \"106116\")]\n-pub fn from_mut<T: ?Sized>(r: &mut T) -> *mut T {\n+pub const fn from_mut<T: ?Sized>(r: &mut T) -> *mut T {\n     r\n }\n "}, {"sha": "ece5244e9a99ce21eac96a804fa141cade8eb55b", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -60,14 +60,14 @@ impl<T: ?Sized> *mut T {\n \n     /// Use the pointer value in a new pointer of another type.\n     ///\n-    /// In case `val` is a (fat) pointer to an unsized type, this operation\n+    /// In case `meta` is a (fat) pointer to an unsized type, this operation\n     /// will ignore the pointer part, whereas for (thin) pointers to sized\n     /// types, this has the same effect as a simple cast.\n     ///\n     /// The resulting pointer will have provenance of `self`, i.e., for a fat\n     /// pointer, this operation is semantically the same as creating a new\n     /// fat pointer with the data pointer value of `self` but the metadata of\n-    /// `val`.\n+    /// `meta`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "123561873a668160c953697c2963e20b9c89767a", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -960,6 +960,7 @@ impl AtomicBool {\n     /// ```ignore (extern-declaration)\n     /// # fn main() {\n     /// use std::sync::atomic::AtomicBool;\n+    ///\n     /// extern \"C\" {\n     ///     fn my_atomic_op(arg: *mut bool);\n     /// }\n@@ -971,7 +972,8 @@ impl AtomicBool {\n     /// # }\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"atomic_mut_ptr\", reason = \"recently added\", issue = \"66893\")]\n+    #[stable(feature = \"atomic_as_ptr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[rustc_const_stable(feature = \"atomic_as_ptr\", since = \"CURRENT_RUSTC_VERSION\")]\n     pub const fn as_ptr(&self) -> *mut bool {\n         self.v.get().cast()\n     }\n@@ -1890,7 +1892,6 @@ impl<T> AtomicPtr<T> {\n     /// # Examples\n     ///\n     /// ```ignore (extern-declaration)\n-    /// #![feature(atomic_mut_ptr)]\n     /// use std::sync::atomic::AtomicPtr;\n     ///\n     /// extern \"C\" {\n@@ -1906,7 +1907,8 @@ impl<T> AtomicPtr<T> {\n     /// }\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"atomic_mut_ptr\", reason = \"recently added\", issue = \"66893\")]\n+    #[stable(feature = \"atomic_as_ptr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[rustc_const_stable(feature = \"atomic_as_ptr\", since = \"CURRENT_RUSTC_VERSION\")]\n     pub const fn as_ptr(&self) -> *mut *mut T {\n         self.p.get()\n     }\n@@ -2859,9 +2861,8 @@ macro_rules! atomic_int {\n             /// # }\n             /// ```\n             #[inline]\n-            #[unstable(feature = \"atomic_mut_ptr\",\n-                   reason = \"recently added\",\n-                   issue = \"66893\")]\n+            #[stable(feature = \"atomic_as_ptr\", since = \"CURRENT_RUSTC_VERSION\")]\n+            #[rustc_const_stable(feature = \"atomic_as_ptr\", since = \"CURRENT_RUSTC_VERSION\")]\n             pub const fn as_ptr(&self) -> *mut $int_type {\n                 self.v.get()\n             }"}, {"sha": "4e7b6080835002b6101811241b3ca69ae13f6a64", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -274,7 +274,6 @@\n #![feature(utf8_chunks)]\n //\n // Library features (core):\n-#![feature(atomic_mut_ptr)]\n #![feature(char_internals)]\n #![feature(core_intrinsics)]\n #![feature(duration_constants)]"}, {"sha": "dbc18f7827e60ac8d7f9810063b7057af03a919d", "filename": "library/std/src/path.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1498,7 +1498,6 @@ impl PathBuf {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(path_as_mut_os_str)]\n     /// use std::path::{Path, PathBuf};\n     ///\n     /// let mut path = PathBuf::from(\"/foo\");\n@@ -1510,7 +1509,7 @@ impl PathBuf {\n     /// path.as_mut_os_string().push(\"baz\");\n     /// assert_eq!(path, Path::new(\"/foo/barbaz\"));\n     /// ```\n-    #[unstable(feature = \"path_as_mut_os_str\", issue = \"105021\")]\n+    #[stable(feature = \"path_as_mut_os_str\", since = \"CURRENT_RUSTC_VERSION\")]\n     #[must_use]\n     #[inline]\n     pub fn as_mut_os_string(&mut self) -> &mut OsString {\n@@ -2066,7 +2065,6 @@ impl Path {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(path_as_mut_os_str)]\n     /// use std::path::{Path, PathBuf};\n     ///\n     /// let mut path = PathBuf::from(\"Foo.TXT\");\n@@ -2076,7 +2074,7 @@ impl Path {\n     /// path.as_mut_os_str().make_ascii_lowercase();\n     /// assert_eq!(path, Path::new(\"foo.txt\"));\n     /// ```\n-    #[unstable(feature = \"path_as_mut_os_str\", issue = \"105021\")]\n+    #[stable(feature = \"path_as_mut_os_str\", since = \"CURRENT_RUSTC_VERSION\")]\n     #[must_use]\n     #[inline]\n     pub fn as_mut_os_str(&mut self) -> &mut OsStr {"}, {"sha": "2b8782ddf4482c6ba242e79730a81a1896c81cc6", "filename": "library/std/src/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -12,6 +12,7 @@\n \n pub mod alloc;\n pub mod small_c_string;\n+pub mod thread_local;\n \n #[cfg(test)]\n mod tests;"}, {"sha": "2addcc4a759d0382c55ef5d3779a08ccefa6213e", "filename": "library/std/src/sys/common/thread_local/fast_local.rs", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Ffast_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Ffast_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Ffast_local.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -0,0 +1,276 @@\n+#[doc(hidden)]\n+#[macro_export]\n+#[allow_internal_unstable(\n+    thread_local_internals,\n+    cfg_target_thread_local,\n+    thread_local,\n+    libstd_thread_internals\n+)]\n+#[allow_internal_unsafe]\n+macro_rules! __thread_local_inner {\n+    // used to generate the `LocalKey` value for const-initialized thread locals\n+    (@key $t:ty, const $init:expr) => {{\n+        #[cfg_attr(not(windows), inline)] // see comments below\n+        #[deny(unsafe_op_in_unsafe_fn)]\n+        unsafe fn __getit(\n+            _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+        ) -> $crate::option::Option<&'static $t> {\n+            const INIT_EXPR: $t = $init;\n+            // If the platform has support for `#[thread_local]`, use it.\n+            #[thread_local]\n+            static mut VAL: $t = INIT_EXPR;\n+\n+            // If a dtor isn't needed we can do something \"very raw\" and\n+            // just get going.\n+            if !$crate::mem::needs_drop::<$t>() {\n+                unsafe {\n+                    return $crate::option::Option::Some(&VAL)\n+                }\n+            }\n+\n+            // 0 == dtor not registered\n+            // 1 == dtor registered, dtor not run\n+            // 2 == dtor registered and is running or has run\n+            #[thread_local]\n+            static mut STATE: $crate::primitive::u8 = 0;\n+\n+            unsafe extern \"C\" fn destroy(ptr: *mut $crate::primitive::u8) {\n+                let ptr = ptr as *mut $t;\n+\n+                unsafe {\n+                    $crate::debug_assert_eq!(STATE, 1);\n+                    STATE = 2;\n+                    $crate::ptr::drop_in_place(ptr);\n+                }\n+            }\n+\n+            unsafe {\n+                match STATE {\n+                    // 0 == we haven't registered a destructor, so do\n+                    //   so now.\n+                    0 => {\n+                        $crate::thread::__LocalKeyInner::<$t>::register_dtor(\n+                            $crate::ptr::addr_of_mut!(VAL) as *mut $crate::primitive::u8,\n+                            destroy,\n+                        );\n+                        STATE = 1;\n+                        $crate::option::Option::Some(&VAL)\n+                    }\n+                    // 1 == the destructor is registered and the value\n+                    //   is valid, so return the pointer.\n+                    1 => $crate::option::Option::Some(&VAL),\n+                    // otherwise the destructor has already run, so we\n+                    // can't give access.\n+                    _ => $crate::option::Option::None,\n+                }\n+            }\n+        }\n+\n+        unsafe {\n+            $crate::thread::LocalKey::new(__getit)\n+        }\n+    }};\n+\n+    // used to generate the `LocalKey` value for `thread_local!`\n+    (@key $t:ty, $init:expr) => {\n+        {\n+            #[inline]\n+            fn __init() -> $t { $init }\n+\n+            // When reading this function you might ask \"why is this inlined\n+            // everywhere other than Windows?\", and that's a very reasonable\n+            // question to ask. The short story is that it segfaults rustc if\n+            // this function is inlined. The longer story is that Windows looks\n+            // to not support `extern` references to thread locals across DLL\n+            // boundaries. This appears to at least not be supported in the ABI\n+            // that LLVM implements.\n+            //\n+            // Because of this we never inline on Windows, but we do inline on\n+            // other platforms (where external references to thread locals\n+            // across DLLs are supported). A better fix for this would be to\n+            // inline this function on Windows, but only for \"statically linked\"\n+            // components. For example if two separately compiled rlibs end up\n+            // getting linked into a DLL then it's fine to inline this function\n+            // across that boundary. It's only not fine to inline this function\n+            // across a DLL boundary. Unfortunately rustc doesn't currently\n+            // have this sort of logic available in an attribute, and it's not\n+            // clear that rustc is even equipped to answer this (it's more of a\n+            // Cargo question kinda). This means that, unfortunately, Windows\n+            // gets the pessimistic path for now where it's never inlined.\n+            //\n+            // The issue of \"should enable on Windows sometimes\" is #84933\n+            #[cfg_attr(not(windows), inline)]\n+            unsafe fn __getit(\n+                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+            ) -> $crate::option::Option<&'static $t> {\n+                #[thread_local]\n+                static __KEY: $crate::thread::__LocalKeyInner<$t> =\n+                    $crate::thread::__LocalKeyInner::<$t>::new();\n+\n+                // FIXME: remove the #[allow(...)] marker when macros don't\n+                // raise warning for missing/extraneous unsafe blocks anymore.\n+                // See https://github.com/rust-lang/rust/issues/74838.\n+                #[allow(unused_unsafe)]\n+                unsafe {\n+                    __KEY.get(move || {\n+                        if let $crate::option::Option::Some(init) = init {\n+                            if let $crate::option::Option::Some(value) = init.take() {\n+                                return value;\n+                            } else if $crate::cfg!(debug_assertions) {\n+                                $crate::unreachable!(\"missing default value\");\n+                            }\n+                        }\n+                        __init()\n+                    })\n+                }\n+            }\n+\n+            unsafe {\n+                $crate::thread::LocalKey::new(__getit)\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n+        $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n+            $crate::__thread_local_inner!(@key $t, $($init)*);\n+    }\n+}\n+\n+#[doc(hidden)]\n+pub mod fast {\n+    use super::super::lazy::LazyKeyInner;\n+    use crate::cell::Cell;\n+    use crate::sys::thread_local_dtor::register_dtor;\n+    use crate::{fmt, mem, panic};\n+\n+    #[derive(Copy, Clone)]\n+    enum DtorState {\n+        Unregistered,\n+        Registered,\n+        RunningOrHasRun,\n+    }\n+\n+    // This data structure has been carefully constructed so that the fast path\n+    // only contains one branch on x86. That optimization is necessary to avoid\n+    // duplicated tls lookups on OSX.\n+    //\n+    // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n+    pub struct Key<T> {\n+        // If `LazyKeyInner::get` returns `None`, that indicates either:\n+        //   * The value has never been initialized\n+        //   * The value is being recursively initialized\n+        //   * The value has already been destroyed or is being destroyed\n+        // To determine which kind of `None`, check `dtor_state`.\n+        //\n+        // This is very optimizer friendly for the fast path - initialized but\n+        // not yet dropped.\n+        inner: LazyKeyInner<T>,\n+\n+        // Metadata to keep track of the state of the destructor. Remember that\n+        // this variable is thread-local, not global.\n+        dtor_state: Cell<DtorState>,\n+    }\n+\n+    impl<T> fmt::Debug for Key<T> {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.debug_struct(\"Key\").finish_non_exhaustive()\n+        }\n+    }\n+\n+    impl<T> Key<T> {\n+        pub const fn new() -> Key<T> {\n+            Key { inner: LazyKeyInner::new(), dtor_state: Cell::new(DtorState::Unregistered) }\n+        }\n+\n+        // note that this is just a publicly-callable function only for the\n+        // const-initialized form of thread locals, basically a way to call the\n+        // free `register_dtor` function defined elsewhere in std.\n+        pub unsafe fn register_dtor(a: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n+            unsafe {\n+                register_dtor(a, dtor);\n+            }\n+        }\n+\n+        pub unsafe fn get<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n+            // SAFETY: See the definitions of `LazyKeyInner::get` and\n+            // `try_initialize` for more information.\n+            //\n+            // The caller must ensure no mutable references are ever active to\n+            // the inner cell or the inner T when this is called.\n+            // The `try_initialize` is dependant on the passed `init` function\n+            // for this.\n+            unsafe {\n+                match self.inner.get() {\n+                    Some(val) => Some(val),\n+                    None => self.try_initialize(init),\n+                }\n+            }\n+        }\n+\n+        // `try_initialize` is only called once per fast thread local variable,\n+        // except in corner cases where thread_local dtors reference other\n+        // thread_local's, or it is being recursively initialized.\n+        //\n+        // Macos: Inlining this function can cause two `tlv_get_addr` calls to\n+        // be performed for every call to `Key::get`.\n+        // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n+        #[inline(never)]\n+        unsafe fn try_initialize<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n+            // SAFETY: See comment above (this function doc).\n+            if !mem::needs_drop::<T>() || unsafe { self.try_register_dtor() } {\n+                // SAFETY: See comment above (this function doc).\n+                Some(unsafe { self.inner.initialize(init) })\n+            } else {\n+                None\n+            }\n+        }\n+\n+        // `try_register_dtor` is only called once per fast thread local\n+        // variable, except in corner cases where thread_local dtors reference\n+        // other thread_local's, or it is being recursively initialized.\n+        unsafe fn try_register_dtor(&self) -> bool {\n+            match self.dtor_state.get() {\n+                DtorState::Unregistered => {\n+                    // SAFETY: dtor registration happens before initialization.\n+                    // Passing `self` as a pointer while using `destroy_value<T>`\n+                    // is safe because the function will build a pointer to a\n+                    // Key<T>, which is the type of self and so find the correct\n+                    // size.\n+                    unsafe { register_dtor(self as *const _ as *mut u8, destroy_value::<T>) };\n+                    self.dtor_state.set(DtorState::Registered);\n+                    true\n+                }\n+                DtorState::Registered => {\n+                    // recursively initialized\n+                    true\n+                }\n+                DtorState::RunningOrHasRun => false,\n+            }\n+        }\n+    }\n+\n+    unsafe extern \"C\" fn destroy_value<T>(ptr: *mut u8) {\n+        let ptr = ptr as *mut Key<T>;\n+\n+        // SAFETY:\n+        //\n+        // The pointer `ptr` has been built just above and comes from\n+        // `try_register_dtor` where it is originally a Key<T> coming from `self`,\n+        // making it non-NUL and of the correct type.\n+        //\n+        // Right before we run the user destructor be sure to set the\n+        // `Option<T>` to `None`, and `dtor_state` to `RunningOrHasRun`. This\n+        // causes future calls to `get` to run `try_initialize_drop` again,\n+        // which will now fail, and return `None`.\n+        //\n+        // Wrap the call in a catch to ensure unwinding is caught in the event\n+        // a panic takes place in a destructor.\n+        if let Err(_) = panic::catch_unwind(panic::AssertUnwindSafe(|| unsafe {\n+            let value = (*ptr).inner.take();\n+            (*ptr).dtor_state.set(DtorState::RunningOrHasRun);\n+            drop(value);\n+        })) {\n+            rtabort!(\"thread local panicked on drop\");\n+        }\n+    }\n+}"}, {"sha": "1fee84a04349cde2d2382f9c484ff725f457161e", "filename": "library/std/src/sys/common/thread_local/mod.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -0,0 +1,109 @@\n+//! The following module declarations are outside cfg_if because the internal\n+//! `__thread_local_internal` macro does not seem to be exported properly when using cfg_if\n+#![unstable(feature = \"thread_local_internals\", reason = \"should not be necessary\", issue = \"none\")]\n+\n+#[cfg(all(target_thread_local, not(all(target_family = \"wasm\", not(target_feature = \"atomics\")))))]\n+mod fast_local;\n+#[cfg(all(\n+    not(target_thread_local),\n+    not(all(target_family = \"wasm\", not(target_feature = \"atomics\")))\n+))]\n+mod os_local;\n+#[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n+mod static_local;\n+\n+#[cfg(not(test))]\n+cfg_if::cfg_if! {\n+    if #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))] {\n+        #[doc(hidden)]\n+        pub use static_local::statik::Key;\n+    } else if #[cfg(all(target_thread_local, not(all(target_family = \"wasm\", not(target_feature = \"atomics\")))))] {\n+        #[doc(hidden)]\n+        pub use fast_local::fast::Key;\n+    } else if #[cfg(all(not(target_thread_local), not(all(target_family = \"wasm\", not(target_feature = \"atomics\")))))] {\n+        #[doc(hidden)]\n+        pub use os_local::os::Key;\n+    }\n+}\n+\n+#[doc(hidden)]\n+#[cfg(test)]\n+pub use realstd::thread::__LocalKeyInner as Key;\n+\n+mod lazy {\n+    use crate::cell::UnsafeCell;\n+    use crate::hint;\n+    use crate::mem;\n+\n+    pub struct LazyKeyInner<T> {\n+        inner: UnsafeCell<Option<T>>,\n+    }\n+\n+    impl<T> LazyKeyInner<T> {\n+        pub const fn new() -> LazyKeyInner<T> {\n+            LazyKeyInner { inner: UnsafeCell::new(None) }\n+        }\n+\n+        pub unsafe fn get(&self) -> Option<&'static T> {\n+            // SAFETY: The caller must ensure no reference is ever handed out to\n+            // the inner cell nor mutable reference to the Option<T> inside said\n+            // cell. This make it safe to hand a reference, though the lifetime\n+            // of 'static is itself unsafe, making the get method unsafe.\n+            unsafe { (*self.inner.get()).as_ref() }\n+        }\n+\n+        /// The caller must ensure that no reference is active: this method\n+        /// needs unique access.\n+        pub unsafe fn initialize<F: FnOnce() -> T>(&self, init: F) -> &'static T {\n+            // Execute the initialization up front, *then* move it into our slot,\n+            // just in case initialization fails.\n+            let value = init();\n+            let ptr = self.inner.get();\n+\n+            // SAFETY:\n+            //\n+            // note that this can in theory just be `*ptr = Some(value)`, but due to\n+            // the compiler will currently codegen that pattern with something like:\n+            //\n+            //      ptr::drop_in_place(ptr)\n+            //      ptr::write(ptr, Some(value))\n+            //\n+            // Due to this pattern it's possible for the destructor of the value in\n+            // `ptr` (e.g., if this is being recursively initialized) to re-access\n+            // TLS, in which case there will be a `&` and `&mut` pointer to the same\n+            // value (an aliasing violation). To avoid setting the \"I'm running a\n+            // destructor\" flag we just use `mem::replace` which should sequence the\n+            // operations a little differently and make this safe to call.\n+            //\n+            // The precondition also ensures that we are the only one accessing\n+            // `self` at the moment so replacing is fine.\n+            unsafe {\n+                let _ = mem::replace(&mut *ptr, Some(value));\n+            }\n+\n+            // SAFETY: With the call to `mem::replace` it is guaranteed there is\n+            // a `Some` behind `ptr`, not a `None` so `unreachable_unchecked`\n+            // will never be reached.\n+            unsafe {\n+                // After storing `Some` we want to get a reference to the contents of\n+                // what we just stored. While we could use `unwrap` here and it should\n+                // always work it empirically doesn't seem to always get optimized away,\n+                // which means that using something like `try_with` can pull in\n+                // panicking code and cause a large size bloat.\n+                match *ptr {\n+                    Some(ref x) => x,\n+                    None => hint::unreachable_unchecked(),\n+                }\n+            }\n+        }\n+\n+        /// The other methods hand out references while taking &self.\n+        /// As such, callers of this method must ensure no `&` and `&mut` are\n+        /// available and used at the same time.\n+        #[allow(unused)]\n+        pub unsafe fn take(&mut self) -> Option<T> {\n+            // SAFETY: See doc comment for this method.\n+            unsafe { (*self.inner.get()).take() }\n+        }\n+    }\n+}"}, {"sha": "6f6560c4aa94998708483a73ed2c43117a7df2d2", "filename": "library/std/src/sys/common/thread_local/os_local.rs", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fos_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fos_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fos_local.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -0,0 +1,217 @@\n+#[doc(hidden)]\n+#[macro_export]\n+#[allow_internal_unstable(\n+    thread_local_internals,\n+    cfg_target_thread_local,\n+    thread_local,\n+    libstd_thread_internals\n+)]\n+#[allow_internal_unsafe]\n+macro_rules! __thread_local_inner {\n+    // used to generate the `LocalKey` value for const-initialized thread locals\n+    (@key $t:ty, const $init:expr) => {{\n+        #[cfg_attr(not(windows), inline)] // see comments below\n+        #[deny(unsafe_op_in_unsafe_fn)]\n+        unsafe fn __getit(\n+            _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+        ) -> $crate::option::Option<&'static $t> {\n+            const INIT_EXPR: $t = $init;\n+\n+                        // On platforms without `#[thread_local]` we fall back to the\n+            // same implementation as below for os thread locals.\n+            #[inline]\n+            const fn __init() -> $t { INIT_EXPR }\n+            static __KEY: $crate::thread::__LocalKeyInner<$t> =\n+                $crate::thread::__LocalKeyInner::new();\n+            #[allow(unused_unsafe)]\n+            unsafe {\n+                __KEY.get(move || {\n+                    if let $crate::option::Option::Some(init) = _init {\n+                        if let $crate::option::Option::Some(value) = init.take() {\n+                            return value;\n+                        } else if $crate::cfg!(debug_assertions) {\n+                            $crate::unreachable!(\"missing initial value\");\n+                        }\n+                    }\n+                    __init()\n+                })\n+            }\n+        }\n+\n+        unsafe {\n+            $crate::thread::LocalKey::new(__getit)\n+        }\n+    }};\n+\n+    // used to generate the `LocalKey` value for `thread_local!`\n+    (@key $t:ty, $init:expr) => {\n+        {\n+            #[inline]\n+            fn __init() -> $t { $init }\n+\n+            // When reading this function you might ask \"why is this inlined\n+            // everywhere other than Windows?\", and that's a very reasonable\n+            // question to ask. The short story is that it segfaults rustc if\n+            // this function is inlined. The longer story is that Windows looks\n+            // to not support `extern` references to thread locals across DLL\n+            // boundaries. This appears to at least not be supported in the ABI\n+            // that LLVM implements.\n+            //\n+            // Because of this we never inline on Windows, but we do inline on\n+            // other platforms (where external references to thread locals\n+            // across DLLs are supported). A better fix for this would be to\n+            // inline this function on Windows, but only for \"statically linked\"\n+            // components. For example if two separately compiled rlibs end up\n+            // getting linked into a DLL then it's fine to inline this function\n+            // across that boundary. It's only not fine to inline this function\n+            // across a DLL boundary. Unfortunately rustc doesn't currently\n+            // have this sort of logic available in an attribute, and it's not\n+            // clear that rustc is even equipped to answer this (it's more of a\n+            // Cargo question kinda). This means that, unfortunately, Windows\n+            // gets the pessimistic path for now where it's never inlined.\n+            //\n+            // The issue of \"should enable on Windows sometimes\" is #84933\n+            #[cfg_attr(not(windows), inline)]\n+            unsafe fn __getit(\n+                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+            ) -> $crate::option::Option<&'static $t> {\n+                static __KEY: $crate::thread::__LocalKeyInner<$t> =\n+                    $crate::thread::__LocalKeyInner::new();\n+\n+                // FIXME: remove the #[allow(...)] marker when macros don't\n+                // raise warning for missing/extraneous unsafe blocks anymore.\n+                // See https://github.com/rust-lang/rust/issues/74838.\n+                #[allow(unused_unsafe)]\n+                unsafe {\n+                    __KEY.get(move || {\n+                        if let $crate::option::Option::Some(init) = init {\n+                            if let $crate::option::Option::Some(value) = init.take() {\n+                                return value;\n+                            } else if $crate::cfg!(debug_assertions) {\n+                                $crate::unreachable!(\"missing default value\");\n+                            }\n+                        }\n+                        __init()\n+                    })\n+                }\n+            }\n+\n+            unsafe {\n+                $crate::thread::LocalKey::new(__getit)\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n+        $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n+            $crate::__thread_local_inner!(@key $t, $($init)*);\n+    }\n+}\n+\n+#[doc(hidden)]\n+pub mod os {\n+    use super::super::lazy::LazyKeyInner;\n+    use crate::cell::Cell;\n+    use crate::sys_common::thread_local_key::StaticKey as OsStaticKey;\n+    use crate::{fmt, marker, panic, ptr};\n+\n+    /// Use a regular global static to store this key; the state provided will then be\n+    /// thread-local.\n+    pub struct Key<T> {\n+        // OS-TLS key that we'll use to key off.\n+        os: OsStaticKey,\n+        marker: marker::PhantomData<Cell<T>>,\n+    }\n+\n+    impl<T> fmt::Debug for Key<T> {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.debug_struct(\"Key\").finish_non_exhaustive()\n+        }\n+    }\n+\n+    unsafe impl<T> Sync for Key<T> {}\n+\n+    struct Value<T: 'static> {\n+        inner: LazyKeyInner<T>,\n+        key: &'static Key<T>,\n+    }\n+\n+    impl<T: 'static> Key<T> {\n+        #[rustc_const_unstable(feature = \"thread_local_internals\", issue = \"none\")]\n+        pub const fn new() -> Key<T> {\n+            Key { os: OsStaticKey::new(Some(destroy_value::<T>)), marker: marker::PhantomData }\n+        }\n+\n+        /// It is a requirement for the caller to ensure that no mutable\n+        /// reference is active when this method is called.\n+        pub unsafe fn get(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n+            // SAFETY: See the documentation for this method.\n+            let ptr = unsafe { self.os.get() as *mut Value<T> };\n+            if ptr.addr() > 1 {\n+                // SAFETY: the check ensured the pointer is safe (its destructor\n+                // is not running) + it is coming from a trusted source (self).\n+                if let Some(ref value) = unsafe { (*ptr).inner.get() } {\n+                    return Some(value);\n+                }\n+            }\n+            // SAFETY: At this point we are sure we have no value and so\n+            // initializing (or trying to) is safe.\n+            unsafe { self.try_initialize(init) }\n+        }\n+\n+        // `try_initialize` is only called once per os thread local variable,\n+        // except in corner cases where thread_local dtors reference other\n+        // thread_local's, or it is being recursively initialized.\n+        unsafe fn try_initialize(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n+            // SAFETY: No mutable references are ever handed out meaning getting\n+            // the value is ok.\n+            let ptr = unsafe { self.os.get() as *mut Value<T> };\n+            if ptr.addr() == 1 {\n+                // destructor is running\n+                return None;\n+            }\n+\n+            let ptr = if ptr.is_null() {\n+                // If the lookup returned null, we haven't initialized our own\n+                // local copy, so do that now.\n+                let ptr = Box::into_raw(Box::new(Value { inner: LazyKeyInner::new(), key: self }));\n+                // SAFETY: At this point we are sure there is no value inside\n+                // ptr so setting it will not affect anyone else.\n+                unsafe {\n+                    self.os.set(ptr as *mut u8);\n+                }\n+                ptr\n+            } else {\n+                // recursive initialization\n+                ptr\n+            };\n+\n+            // SAFETY: ptr has been ensured as non-NUL just above an so can be\n+            // dereferenced safely.\n+            unsafe { Some((*ptr).inner.initialize(init)) }\n+        }\n+    }\n+\n+    unsafe extern \"C\" fn destroy_value<T: 'static>(ptr: *mut u8) {\n+        // SAFETY:\n+        //\n+        // The OS TLS ensures that this key contains a null value when this\n+        // destructor starts to run. We set it back to a sentinel value of 1 to\n+        // ensure that any future calls to `get` for this thread will return\n+        // `None`.\n+        //\n+        // Note that to prevent an infinite loop we reset it back to null right\n+        // before we return from the destructor ourselves.\n+        //\n+        // Wrap the call in a catch to ensure unwinding is caught in the event\n+        // a panic takes place in a destructor.\n+        if let Err(_) = panic::catch_unwind(|| unsafe {\n+            let ptr = Box::from_raw(ptr as *mut Value<T>);\n+            let key = ptr.key;\n+            key.os.set(ptr::invalid_mut(1));\n+            drop(ptr);\n+            key.os.set(ptr::null_mut());\n+        }) {\n+            rtabort!(\"thread local panicked on drop\");\n+        }\n+    }\n+}"}, {"sha": "ec4f2a12b7ee4a277412b40a1abefa88a87b3da5", "filename": "library/std/src/sys/common/thread_local/static_local.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fstatic_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fstatic_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fstatic_local.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -0,0 +1,115 @@\n+#[doc(hidden)]\n+#[macro_export]\n+#[allow_internal_unstable(\n+    thread_local_internals,\n+    cfg_target_thread_local,\n+    thread_local,\n+    libstd_thread_internals\n+)]\n+#[allow_internal_unsafe]\n+macro_rules! __thread_local_inner {\n+    // used to generate the `LocalKey` value for const-initialized thread locals\n+    (@key $t:ty, const $init:expr) => {{\n+        #[inline] // see comments below\n+        #[deny(unsafe_op_in_unsafe_fn)]\n+        unsafe fn __getit(\n+            _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+        ) -> $crate::option::Option<&'static $t> {\n+            const INIT_EXPR: $t = $init;\n+\n+            // wasm without atomics maps directly to `static mut`, and dtors\n+            // aren't implemented because thread dtors aren't really a thing\n+            // on wasm right now\n+            //\n+            // FIXME(#84224) this should come after the `target_thread_local`\n+            // block.\n+            static mut VAL: $t = INIT_EXPR;\n+            unsafe { $crate::option::Option::Some(&VAL) }\n+        }\n+\n+        unsafe {\n+            $crate::thread::LocalKey::new(__getit)\n+        }\n+    }};\n+\n+    // used to generate the `LocalKey` value for `thread_local!`\n+    (@key $t:ty, $init:expr) => {\n+        {\n+            #[inline]\n+            fn __init() -> $t { $init }\n+            #[inline]\n+            unsafe fn __getit(\n+                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+            ) -> $crate::option::Option<&'static $t> {\n+                static __KEY: $crate::thread::__LocalKeyInner<$t> =\n+                    $crate::thread::__LocalKeyInner::new();\n+\n+                // FIXME: remove the #[allow(...)] marker when macros don't\n+                // raise warning for missing/extraneous unsafe blocks anymore.\n+                // See https://github.com/rust-lang/rust/issues/74838.\n+                #[allow(unused_unsafe)]\n+                unsafe {\n+                    __KEY.get(move || {\n+                        if let $crate::option::Option::Some(init) = init {\n+                            if let $crate::option::Option::Some(value) = init.take() {\n+                                return value;\n+                            } else if $crate::cfg!(debug_assertions) {\n+                                $crate::unreachable!(\"missing default value\");\n+                            }\n+                        }\n+                        __init()\n+                    })\n+                }\n+            }\n+\n+            unsafe {\n+                $crate::thread::LocalKey::new(__getit)\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n+        $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n+            $crate::__thread_local_inner!(@key $t, $($init)*);\n+    }\n+}\n+\n+/// On some targets like wasm there's no threads, so no need to generate\n+/// thread locals and we can instead just use plain statics!\n+#[doc(hidden)]\n+pub mod statik {\n+    use super::super::lazy::LazyKeyInner;\n+    use crate::fmt;\n+\n+    pub struct Key<T> {\n+        inner: LazyKeyInner<T>,\n+    }\n+\n+    unsafe impl<T> Sync for Key<T> {}\n+\n+    impl<T> fmt::Debug for Key<T> {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.debug_struct(\"Key\").finish_non_exhaustive()\n+        }\n+    }\n+\n+    impl<T> Key<T> {\n+        pub const fn new() -> Key<T> {\n+            Key { inner: LazyKeyInner::new() }\n+        }\n+\n+        pub unsafe fn get(&self, init: impl FnOnce() -> T) -> Option<&'static T> {\n+            // SAFETY: The caller must ensure no reference is ever handed out to\n+            // the inner cell nor mutable reference to the Option<T> inside said\n+            // cell. This make it safe to hand a reference, though the lifetime\n+            // of 'static is itself unsafe, making the get method unsafe.\n+            let value = unsafe {\n+                match self.inner.get() {\n+                    Some(ref value) => value,\n+                    None => self.inner.initialize(init),\n+                }\n+            };\n+\n+            Some(value)\n+        }\n+    }\n+}"}, {"sha": "427d8ff6f2e4de429c3d86e1a2f10ca19d9753f7", "filename": "library/std/src/sys/hermit/futex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffutex.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -16,7 +16,7 @@ pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -\n \n     let r = unsafe {\n         abi::futex_wait(\n-            futex.as_mut_ptr(),\n+            futex.as_ptr(),\n             expected,\n             timespec.as_ref().map_or(null(), |t| t as *const abi::timespec),\n             abi::FUTEX_RELATIVE_TIMEOUT,\n@@ -28,12 +28,12 @@ pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -\n \n #[inline]\n pub fn futex_wake(futex: &AtomicU32) -> bool {\n-    unsafe { abi::futex_wake(futex.as_mut_ptr(), 1) > 0 }\n+    unsafe { abi::futex_wake(futex.as_ptr(), 1) > 0 }\n }\n \n #[inline]\n pub fn futex_wake_all(futex: &AtomicU32) {\n     unsafe {\n-        abi::futex_wake(futex.as_mut_ptr(), i32::MAX);\n+        abi::futex_wake(futex.as_ptr(), i32::MAX);\n     }\n }"}, {"sha": "743e93a2fd4dbc5f8c6f526629d3c7bd0e80c5b8", "filename": "library/std/src/sys/hermit/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -15,7 +15,6 @@\n \n #![allow(missing_docs, nonstandard_style, unsafe_op_in_unsafe_fn)]\n \n-use crate::intrinsics;\n use crate::os::raw::c_char;\n \n pub mod alloc;"}, {"sha": "7fdf03acc14d92c0c716122469a1ee86bc7c5b2f", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 0, "deletions": 567, "changes": 567, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -173,200 +173,6 @@ macro_rules! thread_local {\n     );\n }\n \n-#[doc(hidden)]\n-#[unstable(feature = \"thread_local_internals\", reason = \"should not be necessary\", issue = \"none\")]\n-#[macro_export]\n-#[allow_internal_unstable(thread_local_internals, cfg_target_thread_local, thread_local)]\n-#[allow_internal_unsafe]\n-macro_rules! __thread_local_inner {\n-    // used to generate the `LocalKey` value for const-initialized thread locals\n-    (@key $t:ty, const $init:expr) => {{\n-        #[cfg_attr(not(windows), inline)] // see comments below\n-        #[deny(unsafe_op_in_unsafe_fn)]\n-        unsafe fn __getit(\n-            _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n-        ) -> $crate::option::Option<&'static $t> {\n-            const INIT_EXPR: $t = $init;\n-\n-            // wasm without atomics maps directly to `static mut`, and dtors\n-            // aren't implemented because thread dtors aren't really a thing\n-            // on wasm right now\n-            //\n-            // FIXME(#84224) this should come after the `target_thread_local`\n-            // block.\n-            #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n-            {\n-                static mut VAL: $t = INIT_EXPR;\n-                unsafe { $crate::option::Option::Some(&VAL) }\n-            }\n-\n-            // If the platform has support for `#[thread_local]`, use it.\n-            #[cfg(all(\n-                target_thread_local,\n-                not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-            ))]\n-            {\n-                #[thread_local]\n-                static mut VAL: $t = INIT_EXPR;\n-\n-                // If a dtor isn't needed we can do something \"very raw\" and\n-                // just get going.\n-                if !$crate::mem::needs_drop::<$t>() {\n-                    unsafe {\n-                        return $crate::option::Option::Some(&VAL)\n-                    }\n-                }\n-\n-                // 0 == dtor not registered\n-                // 1 == dtor registered, dtor not run\n-                // 2 == dtor registered and is running or has run\n-                #[thread_local]\n-                static mut STATE: $crate::primitive::u8 = 0;\n-\n-                unsafe extern \"C\" fn destroy(ptr: *mut $crate::primitive::u8) {\n-                    let ptr = ptr as *mut $t;\n-\n-                    unsafe {\n-                        $crate::debug_assert_eq!(STATE, 1);\n-                        STATE = 2;\n-                        $crate::ptr::drop_in_place(ptr);\n-                    }\n-                }\n-\n-                unsafe {\n-                    match STATE {\n-                        // 0 == we haven't registered a destructor, so do\n-                        //   so now.\n-                        0 => {\n-                            $crate::thread::__FastLocalKeyInner::<$t>::register_dtor(\n-                                $crate::ptr::addr_of_mut!(VAL) as *mut $crate::primitive::u8,\n-                                destroy,\n-                            );\n-                            STATE = 1;\n-                            $crate::option::Option::Some(&VAL)\n-                        }\n-                        // 1 == the destructor is registered and the value\n-                        //   is valid, so return the pointer.\n-                        1 => $crate::option::Option::Some(&VAL),\n-                        // otherwise the destructor has already run, so we\n-                        // can't give access.\n-                        _ => $crate::option::Option::None,\n-                    }\n-                }\n-            }\n-\n-            // On platforms without `#[thread_local]` we fall back to the\n-            // same implementation as below for os thread locals.\n-            #[cfg(all(\n-                not(target_thread_local),\n-                not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-            ))]\n-            {\n-                #[inline]\n-                const fn __init() -> $t { INIT_EXPR }\n-                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n-                    $crate::thread::__OsLocalKeyInner::new();\n-                #[allow(unused_unsafe)]\n-                unsafe {\n-                    __KEY.get(move || {\n-                        if let $crate::option::Option::Some(init) = _init {\n-                            if let $crate::option::Option::Some(value) = init.take() {\n-                                return value;\n-                            } else if $crate::cfg!(debug_assertions) {\n-                                $crate::unreachable!(\"missing initial value\");\n-                            }\n-                        }\n-                        __init()\n-                    })\n-                }\n-            }\n-        }\n-\n-        unsafe {\n-            $crate::thread::LocalKey::new(__getit)\n-        }\n-    }};\n-\n-    // used to generate the `LocalKey` value for `thread_local!`\n-    (@key $t:ty, $init:expr) => {\n-        {\n-            #[inline]\n-            fn __init() -> $t { $init }\n-\n-            // When reading this function you might ask \"why is this inlined\n-            // everywhere other than Windows?\", and that's a very reasonable\n-            // question to ask. The short story is that it segfaults rustc if\n-            // this function is inlined. The longer story is that Windows looks\n-            // to not support `extern` references to thread locals across DLL\n-            // boundaries. This appears to at least not be supported in the ABI\n-            // that LLVM implements.\n-            //\n-            // Because of this we never inline on Windows, but we do inline on\n-            // other platforms (where external references to thread locals\n-            // across DLLs are supported). A better fix for this would be to\n-            // inline this function on Windows, but only for \"statically linked\"\n-            // components. For example if two separately compiled rlibs end up\n-            // getting linked into a DLL then it's fine to inline this function\n-            // across that boundary. It's only not fine to inline this function\n-            // across a DLL boundary. Unfortunately rustc doesn't currently\n-            // have this sort of logic available in an attribute, and it's not\n-            // clear that rustc is even equipped to answer this (it's more of a\n-            // Cargo question kinda). This means that, unfortunately, Windows\n-            // gets the pessimistic path for now where it's never inlined.\n-            //\n-            // The issue of \"should enable on Windows sometimes\" is #84933\n-            #[cfg_attr(not(windows), inline)]\n-            unsafe fn __getit(\n-                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n-            ) -> $crate::option::Option<&'static $t> {\n-                #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n-                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n-                    $crate::thread::__StaticLocalKeyInner::new();\n-\n-                #[thread_local]\n-                #[cfg(all(\n-                    target_thread_local,\n-                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-                ))]\n-                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n-                    $crate::thread::__FastLocalKeyInner::new();\n-\n-                #[cfg(all(\n-                    not(target_thread_local),\n-                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-                ))]\n-                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n-                    $crate::thread::__OsLocalKeyInner::new();\n-\n-                // FIXME: remove the #[allow(...)] marker when macros don't\n-                // raise warning for missing/extraneous unsafe blocks anymore.\n-                // See https://github.com/rust-lang/rust/issues/74838.\n-                #[allow(unused_unsafe)]\n-                unsafe {\n-                    __KEY.get(move || {\n-                        if let $crate::option::Option::Some(init) = init {\n-                            if let $crate::option::Option::Some(value) = init.take() {\n-                                return value;\n-                            } else if $crate::cfg!(debug_assertions) {\n-                                $crate::unreachable!(\"missing default value\");\n-                            }\n-                        }\n-                        __init()\n-                    })\n-                }\n-            }\n-\n-            unsafe {\n-                $crate::thread::LocalKey::new(__getit)\n-            }\n-        }\n-    };\n-    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n-        $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n-            $crate::__thread_local_inner!(@key $t, $($init)*);\n-    }\n-}\n-\n /// An error returned by [`LocalKey::try_with`](struct.LocalKey.html#method.try_with).\n #[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\n #[non_exhaustive]\n@@ -779,376 +585,3 @@ impl<T: 'static> LocalKey<RefCell<T>> {\n         self.with(|cell| cell.replace(value))\n     }\n }\n-\n-mod lazy {\n-    use crate::cell::UnsafeCell;\n-    use crate::hint;\n-    use crate::mem;\n-\n-    pub struct LazyKeyInner<T> {\n-        inner: UnsafeCell<Option<T>>,\n-    }\n-\n-    impl<T> LazyKeyInner<T> {\n-        pub const fn new() -> LazyKeyInner<T> {\n-            LazyKeyInner { inner: UnsafeCell::new(None) }\n-        }\n-\n-        pub unsafe fn get(&self) -> Option<&'static T> {\n-            // SAFETY: The caller must ensure no reference is ever handed out to\n-            // the inner cell nor mutable reference to the Option<T> inside said\n-            // cell. This make it safe to hand a reference, though the lifetime\n-            // of 'static is itself unsafe, making the get method unsafe.\n-            unsafe { (*self.inner.get()).as_ref() }\n-        }\n-\n-        /// The caller must ensure that no reference is active: this method\n-        /// needs unique access.\n-        pub unsafe fn initialize<F: FnOnce() -> T>(&self, init: F) -> &'static T {\n-            // Execute the initialization up front, *then* move it into our slot,\n-            // just in case initialization fails.\n-            let value = init();\n-            let ptr = self.inner.get();\n-\n-            // SAFETY:\n-            //\n-            // note that this can in theory just be `*ptr = Some(value)`, but due to\n-            // the compiler will currently codegen that pattern with something like:\n-            //\n-            //      ptr::drop_in_place(ptr)\n-            //      ptr::write(ptr, Some(value))\n-            //\n-            // Due to this pattern it's possible for the destructor of the value in\n-            // `ptr` (e.g., if this is being recursively initialized) to re-access\n-            // TLS, in which case there will be a `&` and `&mut` pointer to the same\n-            // value (an aliasing violation). To avoid setting the \"I'm running a\n-            // destructor\" flag we just use `mem::replace` which should sequence the\n-            // operations a little differently and make this safe to call.\n-            //\n-            // The precondition also ensures that we are the only one accessing\n-            // `self` at the moment so replacing is fine.\n-            unsafe {\n-                let _ = mem::replace(&mut *ptr, Some(value));\n-            }\n-\n-            // SAFETY: With the call to `mem::replace` it is guaranteed there is\n-            // a `Some` behind `ptr`, not a `None` so `unreachable_unchecked`\n-            // will never be reached.\n-            unsafe {\n-                // After storing `Some` we want to get a reference to the contents of\n-                // what we just stored. While we could use `unwrap` here and it should\n-                // always work it empirically doesn't seem to always get optimized away,\n-                // which means that using something like `try_with` can pull in\n-                // panicking code and cause a large size bloat.\n-                match *ptr {\n-                    Some(ref x) => x,\n-                    None => hint::unreachable_unchecked(),\n-                }\n-            }\n-        }\n-\n-        /// The other methods hand out references while taking &self.\n-        /// As such, callers of this method must ensure no `&` and `&mut` are\n-        /// available and used at the same time.\n-        #[allow(unused)]\n-        pub unsafe fn take(&mut self) -> Option<T> {\n-            // SAFETY: See doc comment for this method.\n-            unsafe { (*self.inner.get()).take() }\n-        }\n-    }\n-}\n-\n-/// On some targets like wasm there's no threads, so no need to generate\n-/// thread locals and we can instead just use plain statics!\n-#[doc(hidden)]\n-#[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n-pub mod statik {\n-    use super::lazy::LazyKeyInner;\n-    use crate::fmt;\n-\n-    pub struct Key<T> {\n-        inner: LazyKeyInner<T>,\n-    }\n-\n-    unsafe impl<T> Sync for Key<T> {}\n-\n-    impl<T> fmt::Debug for Key<T> {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            f.debug_struct(\"Key\").finish_non_exhaustive()\n-        }\n-    }\n-\n-    impl<T> Key<T> {\n-        pub const fn new() -> Key<T> {\n-            Key { inner: LazyKeyInner::new() }\n-        }\n-\n-        pub unsafe fn get(&self, init: impl FnOnce() -> T) -> Option<&'static T> {\n-            // SAFETY: The caller must ensure no reference is ever handed out to\n-            // the inner cell nor mutable reference to the Option<T> inside said\n-            // cell. This make it safe to hand a reference, though the lifetime\n-            // of 'static is itself unsafe, making the get method unsafe.\n-            let value = unsafe {\n-                match self.inner.get() {\n-                    Some(ref value) => value,\n-                    None => self.inner.initialize(init),\n-                }\n-            };\n-\n-            Some(value)\n-        }\n-    }\n-}\n-\n-#[doc(hidden)]\n-#[cfg(all(target_thread_local, not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),))]\n-pub mod fast {\n-    use super::lazy::LazyKeyInner;\n-    use crate::cell::Cell;\n-    use crate::sys::thread_local_dtor::register_dtor;\n-    use crate::{fmt, mem, panic};\n-\n-    #[derive(Copy, Clone)]\n-    enum DtorState {\n-        Unregistered,\n-        Registered,\n-        RunningOrHasRun,\n-    }\n-\n-    // This data structure has been carefully constructed so that the fast path\n-    // only contains one branch on x86. That optimization is necessary to avoid\n-    // duplicated tls lookups on OSX.\n-    //\n-    // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n-    pub struct Key<T> {\n-        // If `LazyKeyInner::get` returns `None`, that indicates either:\n-        //   * The value has never been initialized\n-        //   * The value is being recursively initialized\n-        //   * The value has already been destroyed or is being destroyed\n-        // To determine which kind of `None`, check `dtor_state`.\n-        //\n-        // This is very optimizer friendly for the fast path - initialized but\n-        // not yet dropped.\n-        inner: LazyKeyInner<T>,\n-\n-        // Metadata to keep track of the state of the destructor. Remember that\n-        // this variable is thread-local, not global.\n-        dtor_state: Cell<DtorState>,\n-    }\n-\n-    impl<T> fmt::Debug for Key<T> {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            f.debug_struct(\"Key\").finish_non_exhaustive()\n-        }\n-    }\n-\n-    impl<T> Key<T> {\n-        pub const fn new() -> Key<T> {\n-            Key { inner: LazyKeyInner::new(), dtor_state: Cell::new(DtorState::Unregistered) }\n-        }\n-\n-        // note that this is just a publicly-callable function only for the\n-        // const-initialized form of thread locals, basically a way to call the\n-        // free `register_dtor` function defined elsewhere in std.\n-        pub unsafe fn register_dtor(a: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n-            unsafe {\n-                register_dtor(a, dtor);\n-            }\n-        }\n-\n-        pub unsafe fn get<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n-            // SAFETY: See the definitions of `LazyKeyInner::get` and\n-            // `try_initialize` for more information.\n-            //\n-            // The caller must ensure no mutable references are ever active to\n-            // the inner cell or the inner T when this is called.\n-            // The `try_initialize` is dependant on the passed `init` function\n-            // for this.\n-            unsafe {\n-                match self.inner.get() {\n-                    Some(val) => Some(val),\n-                    None => self.try_initialize(init),\n-                }\n-            }\n-        }\n-\n-        // `try_initialize` is only called once per fast thread local variable,\n-        // except in corner cases where thread_local dtors reference other\n-        // thread_local's, or it is being recursively initialized.\n-        //\n-        // Macos: Inlining this function can cause two `tlv_get_addr` calls to\n-        // be performed for every call to `Key::get`.\n-        // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n-        #[inline(never)]\n-        unsafe fn try_initialize<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n-            // SAFETY: See comment above (this function doc).\n-            if !mem::needs_drop::<T>() || unsafe { self.try_register_dtor() } {\n-                // SAFETY: See comment above (this function doc).\n-                Some(unsafe { self.inner.initialize(init) })\n-            } else {\n-                None\n-            }\n-        }\n-\n-        // `try_register_dtor` is only called once per fast thread local\n-        // variable, except in corner cases where thread_local dtors reference\n-        // other thread_local's, or it is being recursively initialized.\n-        unsafe fn try_register_dtor(&self) -> bool {\n-            match self.dtor_state.get() {\n-                DtorState::Unregistered => {\n-                    // SAFETY: dtor registration happens before initialization.\n-                    // Passing `self` as a pointer while using `destroy_value<T>`\n-                    // is safe because the function will build a pointer to a\n-                    // Key<T>, which is the type of self and so find the correct\n-                    // size.\n-                    unsafe { register_dtor(self as *const _ as *mut u8, destroy_value::<T>) };\n-                    self.dtor_state.set(DtorState::Registered);\n-                    true\n-                }\n-                DtorState::Registered => {\n-                    // recursively initialized\n-                    true\n-                }\n-                DtorState::RunningOrHasRun => false,\n-            }\n-        }\n-    }\n-\n-    unsafe extern \"C\" fn destroy_value<T>(ptr: *mut u8) {\n-        let ptr = ptr as *mut Key<T>;\n-\n-        // SAFETY:\n-        //\n-        // The pointer `ptr` has been built just above and comes from\n-        // `try_register_dtor` where it is originally a Key<T> coming from `self`,\n-        // making it non-NUL and of the correct type.\n-        //\n-        // Right before we run the user destructor be sure to set the\n-        // `Option<T>` to `None`, and `dtor_state` to `RunningOrHasRun`. This\n-        // causes future calls to `get` to run `try_initialize_drop` again,\n-        // which will now fail, and return `None`.\n-        //\n-        // Wrap the call in a catch to ensure unwinding is caught in the event\n-        // a panic takes place in a destructor.\n-        if let Err(_) = panic::catch_unwind(panic::AssertUnwindSafe(|| unsafe {\n-            let value = (*ptr).inner.take();\n-            (*ptr).dtor_state.set(DtorState::RunningOrHasRun);\n-            drop(value);\n-        })) {\n-            rtabort!(\"thread local panicked on drop\");\n-        }\n-    }\n-}\n-\n-#[doc(hidden)]\n-#[cfg(all(\n-    not(target_thread_local),\n-    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-))]\n-pub mod os {\n-    use super::lazy::LazyKeyInner;\n-    use crate::cell::Cell;\n-    use crate::sys_common::thread_local_key::StaticKey as OsStaticKey;\n-    use crate::{fmt, marker, panic, ptr};\n-\n-    /// Use a regular global static to store this key; the state provided will then be\n-    /// thread-local.\n-    pub struct Key<T> {\n-        // OS-TLS key that we'll use to key off.\n-        os: OsStaticKey,\n-        marker: marker::PhantomData<Cell<T>>,\n-    }\n-\n-    impl<T> fmt::Debug for Key<T> {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            f.debug_struct(\"Key\").finish_non_exhaustive()\n-        }\n-    }\n-\n-    unsafe impl<T> Sync for Key<T> {}\n-\n-    struct Value<T: 'static> {\n-        inner: LazyKeyInner<T>,\n-        key: &'static Key<T>,\n-    }\n-\n-    impl<T: 'static> Key<T> {\n-        #[rustc_const_unstable(feature = \"thread_local_internals\", issue = \"none\")]\n-        pub const fn new() -> Key<T> {\n-            Key { os: OsStaticKey::new(Some(destroy_value::<T>)), marker: marker::PhantomData }\n-        }\n-\n-        /// It is a requirement for the caller to ensure that no mutable\n-        /// reference is active when this method is called.\n-        pub unsafe fn get(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n-            // SAFETY: See the documentation for this method.\n-            let ptr = unsafe { self.os.get() as *mut Value<T> };\n-            if ptr.addr() > 1 {\n-                // SAFETY: the check ensured the pointer is safe (its destructor\n-                // is not running) + it is coming from a trusted source (self).\n-                if let Some(ref value) = unsafe { (*ptr).inner.get() } {\n-                    return Some(value);\n-                }\n-            }\n-            // SAFETY: At this point we are sure we have no value and so\n-            // initializing (or trying to) is safe.\n-            unsafe { self.try_initialize(init) }\n-        }\n-\n-        // `try_initialize` is only called once per os thread local variable,\n-        // except in corner cases where thread_local dtors reference other\n-        // thread_local's, or it is being recursively initialized.\n-        unsafe fn try_initialize(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n-            // SAFETY: No mutable references are ever handed out meaning getting\n-            // the value is ok.\n-            let ptr = unsafe { self.os.get() as *mut Value<T> };\n-            if ptr.addr() == 1 {\n-                // destructor is running\n-                return None;\n-            }\n-\n-            let ptr = if ptr.is_null() {\n-                // If the lookup returned null, we haven't initialized our own\n-                // local copy, so do that now.\n-                let ptr = Box::into_raw(Box::new(Value { inner: LazyKeyInner::new(), key: self }));\n-                // SAFETY: At this point we are sure there is no value inside\n-                // ptr so setting it will not affect anyone else.\n-                unsafe {\n-                    self.os.set(ptr as *mut u8);\n-                }\n-                ptr\n-            } else {\n-                // recursive initialization\n-                ptr\n-            };\n-\n-            // SAFETY: ptr has been ensured as non-NUL just above an so can be\n-            // dereferenced safely.\n-            unsafe { Some((*ptr).inner.initialize(init)) }\n-        }\n-    }\n-\n-    unsafe extern \"C\" fn destroy_value<T: 'static>(ptr: *mut u8) {\n-        // SAFETY:\n-        //\n-        // The OS TLS ensures that this key contains a null value when this\n-        // destructor starts to run. We set it back to a sentinel value of 1 to\n-        // ensure that any future calls to `get` for this thread will return\n-        // `None`.\n-        //\n-        // Note that to prevent an infinite loop we reset it back to null right\n-        // before we return from the destructor ourselves.\n-        //\n-        // Wrap the call in a catch to ensure unwinding is caught in the event\n-        // a panic takes place in a destructor.\n-        if let Err(_) = panic::catch_unwind(|| unsafe {\n-            let ptr = Box::from_raw(ptr as *mut Value<T>);\n-            let key = ptr.key;\n-            key.os.set(ptr::invalid_mut(1));\n-            drop(ptr);\n-            key.os.set(ptr::null_mut());\n-        }) {\n-            rtabort!(\"thread local panicked on drop\");\n-        }\n-    }\n-}"}, {"sha": "b9aaf5f6e15dbb58571c3f68f30d7d71609c17f7", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -203,44 +203,9 @@ pub use self::local::{AccessError, LocalKey};\n // by the elf linker. \"static\" is for single-threaded platforms where a global\n // static is sufficient.\n \n-#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n-#[cfg(not(test))]\n-#[cfg(all(\n-    target_thread_local,\n-    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-))]\n-#[doc(hidden)]\n-pub use self::local::fast::Key as __FastLocalKeyInner;\n-// when building for tests, use real std's type\n-#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n-#[cfg(test)]\n-#[cfg(all(\n-    target_thread_local,\n-    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-))]\n-pub use realstd::thread::__FastLocalKeyInner;\n-\n-#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n-#[cfg(not(test))]\n-#[cfg(all(\n-    not(target_thread_local),\n-    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-))]\n #[doc(hidden)]\n-pub use self::local::os::Key as __OsLocalKeyInner;\n-// when building for tests, use real std's type\n-#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n-#[cfg(test)]\n-#[cfg(all(\n-    not(target_thread_local),\n-    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-))]\n-pub use realstd::thread::__OsLocalKeyInner;\n-\n #[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n-#[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n-#[doc(hidden)]\n-pub use self::local::statik::Key as __StaticLocalKeyInner;\n+pub use crate::sys::common::thread_local::Key as __LocalKeyInner;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Builder"}, {"sha": "54d0d8a8ec25ec6d97b31ba82b184df89bf12af5", "filename": "src/bootstrap/CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCHANGELOG.md?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -47,6 +47,7 @@ The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).\n - Add `--keep-stage-std`, which behaves like `keep-stage` but allows the stage\n   0 compiler artifacts (i.e., stage1/bin/rustc) to be rebuilt if changed\n   [#77120](https://github.com/rust-lang/rust/pull/77120).\n+- File locking is now used to avoid collisions between multiple running instances of `x.py` (e.g. when using `rust-analyzer` and `x.py` at the same time). Note that Solaris and possibly other non Unix and non Windows systems don't support it [#108607](https://github.com/rust-lang/rust/pull/108607). This might possibly lead to build data corruption.\n \n \n ## [Version 1] - 2020-09-11"}, {"sha": "afe3fc1741b30e91d7b36a3f82b80aa157e53fef", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -32,7 +32,6 @@ test = false\n [dependencies]\n build_helper = { path = \"../tools/build_helper\" }\n cmake = \"0.1.38\"\n-fd-lock = \"3.0.8\"\n filetime = \"0.2\"\n getopts = \"0.2.19\"\n cc = \"1.0.69\"\n@@ -56,6 +55,10 @@ walkdir = \"2\"\n # Dependencies needed by the build-metrics feature\n sysinfo = { version = \"0.26.0\", optional = true }\n \n+# Solaris doesn't support flock() and thus fd-lock is not option now\n+[target.'cfg(not(target_os = \"solaris\"))'.dependencies]\n+fd-lock = \"3.0.8\"\n+\n [target.'cfg(windows)'.dependencies.winapi]\n version = \"0.3\"\n features = ["}, {"sha": "253d504d7bdb57fbb496eb3d524c056d244b9646", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -185,7 +185,7 @@ Some general areas that you may be interested in modifying are:\n If you make a major change, please remember to:\n \n + Update `VERSION` in `src/bootstrap/main.rs`.\n-* Update `changelog-seen = N` in `config.toml.example`.\n+* Update `changelog-seen = N` in `config.example.toml`.\n * Add an entry in `src/bootstrap/CHANGELOG.md`.\n \n A 'major change' includes"}, {"sha": "912d875e445ea2e3bd1e90a44f67dac8f8760b3d", "filename": "src/bootstrap/bin/main.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fmain.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -7,15 +7,18 @@\n \n use std::env;\n \n-use bootstrap::{t, Build, Config, Subcommand, VERSION};\n+#[cfg(all(any(unix, windows), not(target_os = \"solaris\")))]\n+use bootstrap::t;\n+use bootstrap::{Build, Config, Subcommand, VERSION};\n \n fn main() {\n     let args = env::args().skip(1).collect::<Vec<_>>();\n     let config = Config::parse(&args);\n \n-    let mut build_lock;\n-    let _build_lock_guard;\n-    if cfg!(any(unix, windows)) {\n+    #[cfg(all(any(unix, windows), not(target_os = \"solaris\")))]\n+    {\n+        let mut build_lock;\n+        let _build_lock_guard;\n         let path = config.out.join(\"lock\");\n         build_lock = fd_lock::RwLock::new(t!(std::fs::File::create(&path)));\n         _build_lock_guard = match build_lock.try_write() {\n@@ -30,9 +33,9 @@ fn main() {\n                 t!(build_lock.write())\n             }\n         };\n-    } else {\n-        println!(\"warning: file locking not supported for target, not locking build directory\");\n     }\n+    #[cfg(any(not(any(unix, windows)), target_os = \"solaris\"))]\n+    println!(\"warning: file locking not supported for target, not locking build directory\");\n \n     // check_version warnings are not printed during setup\n     let changelog_suggestion =\n@@ -44,8 +47,8 @@ fn main() {\n     if suggest_setup {\n         println!(\"warning: you have not made a `config.toml`\");\n         println!(\n-            \"help: consider running `./x.py setup` or copying `config.toml.example` by running \\\n-            `cp config.toml.example config.toml`\"\n+            \"help: consider running `./x.py setup` or copying `config.example.toml` by running \\\n+            `cp config.example.toml config.toml`\"\n         );\n     } else if let Some(suggestion) = &changelog_suggestion {\n         println!(\"{}\", suggestion);\n@@ -57,8 +60,8 @@ fn main() {\n     if suggest_setup {\n         println!(\"warning: you have not made a `config.toml`\");\n         println!(\n-            \"help: consider running `./x.py setup` or copying `config.toml.example` by running \\\n-            `cp config.toml.example config.toml`\"\n+            \"help: consider running `./x.py setup` or copying `config.example.toml` by running \\\n+            `cp config.example.toml config.toml`\"\n         );\n     } else if let Some(suggestion) = &changelog_suggestion {\n         println!(\"{}\", suggestion);\n@@ -125,7 +128,7 @@ fn get_lock_owner(f: &std::path::Path) -> Option<u64> {\n     })\n }\n \n-#[cfg(not(target_os = \"linux\"))]\n+#[cfg(not(any(target_os = \"linux\", target_os = \"solaris\")))]\n fn get_lock_owner(_: &std::path::Path) -> Option<u64> {\n     // FIXME: Implement on other OS's\n     None"}, {"sha": "bb07ca1908e1c28927e8bee568734df6f47eb985", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -741,6 +741,7 @@ impl<'a> Builder<'a> {\n                 doc::EmbeddedBook,\n                 doc::EditionGuide,\n                 doc::StyleGuide,\n+                doc::Tidy,\n             ),\n             Kind::Dist => describe!(\n                 dist::Docs,"}, {"sha": "fc5aa8a245d2dd1eb125165ca5bd4961a18274a9", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -55,7 +55,7 @@ pub enum DryRun {\n /// Note that this structure is not decoded directly into, but rather it is\n /// filled out from the decoded forms of the structs below. For documentation\n /// each field, see the corresponding fields in\n-/// `config.toml.example`.\n+/// `config.example.toml`.\n #[derive(Default)]\n #[cfg_attr(test, derive(Clone))]\n pub struct Config {\n@@ -325,7 +325,7 @@ impl std::str::FromStr for SplitDebuginfo {\n \n impl SplitDebuginfo {\n     /// Returns the default `-Csplit-debuginfo` value for the current target. See the comment for\n-    /// `rust.split-debuginfo` in `config.toml.example`.\n+    /// `rust.split-debuginfo` in `config.example.toml`.\n     fn default_for_platform(target: &str) -> Self {\n         if target.contains(\"apple\") {\n             SplitDebuginfo::Unpacked"}, {"sha": "16dc8c63abc96e989ac6016c37a80a378b46fee2", "filename": "src/bootstrap/config/tests.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2Fconfig%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2Fconfig%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig%2Ftests.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,5 +1,5 @@\n use super::{Config, TomlConfig};\n-use std::path::Path;\n+use std::{env, path::Path};\n \n fn toml(config: &str) -> impl '_ + Fn(&Path) -> TomlConfig {\n     |&_| toml::from_str(config).unwrap()\n@@ -33,4 +33,35 @@ fn download_ci_llvm() {\n     ));\n }\n \n-// FIXME: add test for detecting `src` and `out`\n+#[test]\n+fn detect_src_and_out() {\n+    let cfg = parse(\"\");\n+\n+    // This will bring absolute form of `src/bootstrap` path\n+    let current_dir = std::env::current_dir().unwrap();\n+\n+    // get `src` by moving into project root path\n+    let expected_src = current_dir.ancestors().nth(2).unwrap();\n+\n+    assert_eq!(&cfg.src, expected_src);\n+\n+    // This should bring output path of bootstrap in absolute form\n+    let cargo_target_dir = env::var_os(\"CARGO_TARGET_DIR\")\n+        .expect(\"CARGO_TARGET_DIR must been provided for the test environment from bootstrap\");\n+\n+    // Move to `build` from `build/bootstrap`\n+    let expected_out = Path::new(&cargo_target_dir).parent().unwrap();\n+    assert_eq!(&cfg.out, expected_out);\n+\n+    let args: Vec<String> = env::args().collect();\n+\n+    // Another test for `out` as a sanity check\n+    //\n+    // This will bring something similar to:\n+    //     `{config_toml_place}/build/bootstrap/debug/deps/bootstrap-c7ee91d5661e2804`\n+    // `{config_toml_place}` can be anywhere, not just in the rust project directory.\n+    let dep = Path::new(args.first().unwrap());\n+    let expected_out = dep.ancestors().nth(4).unwrap();\n+\n+    assert_eq!(&cfg.out, expected_out);\n+}"}, {"sha": "b326ae402aa6bf91046476d9f98bdc05b7f7db04", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -194,7 +194,7 @@ def err(msg):\n     print('')\n     print('This configure script is a thin configuration shim over the true')\n     print('configuration system, `config.toml`. You can explore the comments')\n-    print('in `config.toml.example` next to this configure script to see')\n+    print('in `config.example.toml` next to this configure script to see')\n     print('more information about what each option is. Additionally you can')\n     print('pass `--set` as an argument to set arbitrary key/value pairs')\n     print('in the TOML configuration if desired')\n@@ -367,7 +367,7 @@ def set(key, value):\n \n set('build.configure-args', sys.argv[1:])\n \n-# \"Parse\" the `config.toml.example` file into the various sections, and we'll\n+# \"Parse\" the `config.example.toml` file into the various sections, and we'll\n # use this as a template of a `config.toml` to write out which preserves\n # all the various comments and whatnot.\n #\n@@ -380,7 +380,7 @@ def set(key, value):\n targets = {}\n top_level_keys = []\n \n-for line in open(rust_dir + '/config.toml.example').read().split(\"\\n\"):\n+for line in open(rust_dir + '/config.example.toml').read().split(\"\\n\"):\n     if cur_section == None:\n         if line.count('=') == 1:\n             top_level_key = line.split('=')[0]"}, {"sha": "a3d9cb3e10c217090524e16b8c7b2426e959baf7", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -967,7 +967,7 @@ impl Step for PlainSourceTarball {\n             \"RELEASES.md\",\n             \"configure\",\n             \"x.py\",\n-            \"config.toml.example\",\n+            \"config.example.toml\",\n             \"Cargo.toml\",\n             \"Cargo.lock\",\n         ];"}, {"sha": "36fdd4abf4ffce6c02e61c9c31d1072a7a080923", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -882,6 +882,7 @@ tool_doc!(\n         // \"cargo-credential-wincred\",\n     ]\n );\n+tool_doc!(Tidy, \"tidy\", \"src/tools/tidy\", [\"tidy\"]);\n \n #[derive(Ord, PartialOrd, Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct ErrorIndex {"}, {"sha": "040e36ea5f8d8d22547ca7f2575b83a6ee2c424e", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -216,7 +216,7 @@ pub(crate) fn is_ci_llvm_available(config: &Config, asserts: bool) -> bool {\n \n /// Returns true if we're running in CI with modified LLVM (and thus can't download it)\n pub(crate) fn is_ci_llvm_modified(config: &Config) -> bool {\n-    CiEnv::is_ci() && {\n+    CiEnv::is_ci() && config.rust_info.is_managed_git_subrepository() && {\n         // We assume we have access to git, so it's okay to unconditionally pass\n         // `true` here.\n         let llvm_sha = detect_llvm_sha(config, true);\n@@ -286,7 +286,7 @@ impl Step for Llvm {\n             (true, true) => \"RelWithDebInfo\",\n         };\n \n-        // NOTE: remember to also update `config.toml.example` when changing the\n+        // NOTE: remember to also update `config.example.toml` when changing the\n         // defaults!\n         let llvm_targets = match &builder.config.llvm_targets {\n             Some(s) => s,"}, {"sha": "515890aef8df8677a3135d31fe002794e01ca7e7", "filename": "src/ci/docker/host-x86_64/mingw-check/Dockerfile", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -52,4 +52,6 @@ ENV SCRIPT python3 ../x.py --stage 2 test src/tools/expand-yaml-anchors && \\\n            reuse lint && \\\n            # Runs checks to ensure that there are no ES5 issues in our JS code.\n            es-check es6 ../src/librustdoc/html/static/js/*.js && \\\n-           eslint -c ../src/librustdoc/html/static/.eslintrc.js ../src/librustdoc/html/static/js/*.js\n+           eslint -c ../src/librustdoc/html/static/.eslintrc.js ../src/librustdoc/html/static/js/*.js && \\\n+           eslint -c ../src/tools/rustdoc-js/.eslintrc.js ../src/tools/rustdoc-js/tester.js && \\\n+           eslint -c ../src/tools/rustdoc-gui/.eslintrc.js ../src/tools/rustdoc-gui/tester.js"}, {"sha": "a007bf183ee119fedc868b7f9302c857e75a5f8c", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-14/Dockerfile", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14%2FDockerfile?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -62,6 +62,4 @@ ENV SCRIPT ../x.py --stage 2 test --exclude src/tools/tidy && \\\n            # work.\n            #\n            ../x.ps1 --stage 2 test tests/ui --pass=check \\\n-                             --host='' --target=i686-unknown-linux-gnu && \\\n-           # Run tidy at the very end, after all the other tests.\n-           python2.7 ../x.py --stage 2 test src/tools/tidy\n+                             --host='' --target=i686-unknown-linux-gnu"}, {"sha": "b490b76666302eea50c3dbac642085eba54de080", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -673,7 +673,6 @@ jobs:\n                 --target=x86_64-pc-windows-msvc\n                 --enable-full-tools\n                 --enable-profiler\n-                --set rust.lto=thin\n               SCRIPT: PGO_HOST=x86_64-pc-windows-msvc python src/ci/stage-build.py python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n             <<: *job-windows-xl"}, {"sha": "37561924b7d4f1b0d54dd56d4dfd694889a96bc6", "filename": "src/ci/github-actions/problem_matchers.json", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fci%2Fgithub-actions%2Fproblem_matchers.json", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fci%2Fgithub-actions%2Fproblem_matchers.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fproblem_matchers.json?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -0,0 +1,15 @@\n+{\n+    \"problemMatcher\": [\n+        {\n+            \"owner\": \"tidy-error-file-line\",\n+            \"pattern\": [\n+                {\n+                    \"regexp\": \"^tidy error: /checkout/(.+):(\\\\d+): (.+)$\",\n+                    \"file\": 1,\n+                    \"line\": 2,\n+                    \"message\": 3\n+                }\n+            ]\n+        }\n+    ]\n+}"}, {"sha": "44875b54ddc4d283029f5bfbad9b285bb5457439", "filename": "src/ci/scripts/collect-cpu-stats.sh", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fci%2Fscripts%2Fcollect-cpu-stats.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fci%2Fscripts%2Fcollect-cpu-stats.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fcollect-cpu-stats.sh?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -6,4 +6,5 @@\n set -euo pipefail\n IFS=$'\\n\\t'\n \n-python3 src/ci/cpu-usage-over-time.py &> cpu-usage.csv &\n+mkdir -p build\n+python3 src/ci/cpu-usage-over-time.py &> build/cpu-usage.csv &"}, {"sha": "55e75800d91c4f62e7b5e58bb7387e9a2930725a", "filename": "src/ci/scripts/run-build-from-ci.sh", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fci%2Fscripts%2Frun-build-from-ci.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fci%2Fscripts%2Frun-build-from-ci.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Frun-build-from-ci.sh?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -10,6 +10,8 @@ source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n export CI=\"true\"\n export SRC=.\n \n+echo \"::add-matcher::src/ci/github-actions/problem_matchers.json\"\n+\n # Remove any preexisting rustup installation since it can interfere\n # with the cargotest step and its auto-detection of things like Clippy in\n # the environment"}, {"sha": "9755edb6dce58936285edc463f0779495a393d29", "filename": "src/ci/scripts/upload-artifacts.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fci%2Fscripts%2Fupload-artifacts.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fci%2Fscripts%2Fupload-artifacts.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fupload-artifacts.sh?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -23,7 +23,7 @@ if [[ \"${DEPLOY-0}\" -eq \"1\" ]] || [[ \"${DEPLOY_ALT-0}\" -eq \"1\" ]]; then\n fi\n \n # CPU usage statistics.\n-cp cpu-usage.csv \"${upload_dir}/cpu-${CI_JOB_NAME}.csv\"\n+cp build/cpu-usage.csv \"${upload_dir}/cpu-${CI_JOB_NAME}.csv\"\n \n # Build metrics generated by x.py.\n cp \"${build_dir}/metrics.json\" \"${upload_dir}/metrics-${CI_JOB_NAME}.json\""}, {"sha": "504fe51156d3f056252bce8060c4f50ef4370df8", "filename": "src/doc/footer.inc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fdoc%2Ffooter.inc", "raw_url": "https://github.com/rust-lang/rust/raw/f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5/src%2Fdoc%2Ffooter.inc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ffooter.inc?ref=f18c39e98cd5f5c84be6c1671d9a43dca5fe10f5", "patch": "@@ -1,7 +1,9 @@\n+<!-- REUSE-IgnoreStart -->\n <footer><p>\n Copyright &copy; 2011 The Rust Project Developers. Licensed under the\n <a href=\"http://www.apache.org/licenses/LICENSE-2.0\">Apache License, Version 2.0</a>\n or the <a href=\"https://opensource.org/licenses/MIT\">MIT license</a>, at your option.\n </p><p>\n This file may not be copied, modified, or distributed except according to those terms.\n </p></footer>\n+<!-- REUSE-IgnoreEnd -->"}]}