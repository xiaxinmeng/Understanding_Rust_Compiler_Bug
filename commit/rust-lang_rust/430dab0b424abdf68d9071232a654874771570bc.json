{"sha": "430dab0b424abdf68d9071232a654874771570bc", "node_id": "C_kwDOAAsO6NoAKDQzMGRhYjBiNDI0YWJkZjY4ZDkwNzEyMzJhNjU0ODc0NzcxNTcwYmM", "commit": {"author": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2023-01-24T23:24:25Z"}, "committer": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2023-01-24T23:24:30Z"}, "message": "implement builtin candidate", "tree": {"sha": "0079d33690ad32a96873666095faa9d898651e79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0079d33690ad32a96873666095faa9d898651e79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/430dab0b424abdf68d9071232a654874771570bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/430dab0b424abdf68d9071232a654874771570bc", "html_url": "https://github.com/rust-lang/rust/commit/430dab0b424abdf68d9071232a654874771570bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/430dab0b424abdf68d9071232a654874771570bc/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "html_url": "https://github.com/rust-lang/rust/commit/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7"}], "stats": {"total": 129, "additions": 129, "deletions": 0}, "files": [{"sha": "0b642fcba281249da01b21d4af4ece7fe96c2636", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/430dab0b424abdf68d9071232a654874771570bc/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/430dab0b424abdf68d9071232a654874771570bc/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=430dab0b424abdf68d9071232a654874771570bc", "patch": "@@ -133,6 +133,11 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy + Eq {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n+\n+    fn consider_builtin_pointee_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n@@ -259,6 +264,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             G::consider_builtin_fn_trait_candidates(self, goal, kind)\n         } else if lang_items.tuple_trait() == Some(trait_def_id) {\n             G::consider_builtin_tuple_candidate(self, goal)\n+        } else if lang_items.pointee_trait() == Some(trait_def_id) {\n+            G::consider_builtin_pointee_candidate(self, goal)\n         } else {\n             Err(NoSolution)\n         };"}, {"sha": "914a1d6a66a672940151c564846ead87a4056aa8", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/430dab0b424abdf68d9071232a654874771570bc/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/430dab0b424abdf68d9071232a654874771570bc/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=430dab0b424abdf68d9071232a654874771570bc", "patch": "@@ -7,6 +7,7 @@ use super::{Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n+use rustc_hir::LangItem;\n use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::specialization_graph::LeafDef;\n@@ -391,6 +392,97 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n     ) -> QueryResult<'tcx> {\n         bug!(\"`Tuple` does not have an associated type: {:?}\", goal);\n     }\n+\n+    fn consider_builtin_pointee_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        let tcx = ecx.tcx();\n+        ecx.infcx.probe(|_| {\n+            let metadata_ty = match goal.predicate.self_ty().kind() {\n+                ty::Bool\n+                | ty::Char\n+                | ty::Int(..)\n+                | ty::Uint(..)\n+                | ty::Float(..)\n+                | ty::Array(..)\n+                | ty::RawPtr(..)\n+                | ty::Ref(..)\n+                | ty::FnDef(..)\n+                | ty::FnPtr(..)\n+                | ty::Closure(..)\n+                | ty::Infer(ty::IntVar(..) | ty::FloatVar(..))\n+                | ty::Generator(..)\n+                | ty::GeneratorWitness(..)\n+                | ty::Never\n+                | ty::Foreign(..) => tcx.types.unit,\n+\n+                ty::Error(e) => tcx.ty_error_with_guaranteed(*e),\n+\n+                ty::Str | ty::Slice(_) => tcx.types.usize,\n+\n+                ty::Dynamic(_, _, _) => {\n+                    let dyn_metadata = tcx.require_lang_item(LangItem::DynMetadata, None);\n+                    tcx.bound_type_of(dyn_metadata)\n+                        .subst(tcx, &[ty::GenericArg::from(goal.predicate.self_ty())])\n+                }\n+\n+                ty::Infer(ty::TyVar(..)) | ty::Alias(_, _) | ty::Param(_) | ty::Placeholder(..) => {\n+                    // FIXME(erica_solver, ptr_metadata): It would also be possible to return a `Ok(Ambig)` with no constraints.\n+                    let sized_predicate = ty::Binder::dummy(tcx.at(DUMMY_SP).mk_trait_ref(\n+                        LangItem::Sized,\n+                        [ty::GenericArg::from(goal.predicate.self_ty())],\n+                    ))\n+                    .without_const();\n+\n+                    let mut nested_goals = ecx.infcx.eq(\n+                        goal.param_env,\n+                        goal.predicate.term.ty().unwrap(),\n+                        tcx.types.unit,\n+                    )?;\n+                    nested_goals.push(goal.with(tcx, sized_predicate));\n+\n+                    return ecx.evaluate_all_and_make_canonical_response(nested_goals);\n+                }\n+\n+                ty::Adt(def, substs) if def.is_struct() => {\n+                    match def.non_enum_variant().fields.last() {\n+                        None => tcx.types.unit,\n+                        Some(field_def) => {\n+                            let self_ty = field_def.ty(tcx, substs);\n+                            let new_goal = goal.with(\n+                                tcx,\n+                                ty::Binder::dummy(goal.predicate.with_self_ty(tcx, self_ty)),\n+                            );\n+                            return ecx.evaluate_all_and_make_canonical_response(vec![new_goal]);\n+                        }\n+                    }\n+                }\n+                ty::Adt(_, _) => tcx.types.unit,\n+\n+                ty::Tuple(elements) => match elements.last() {\n+                    None => tcx.types.unit,\n+                    Some(&self_ty) => {\n+                        let new_goal = goal.with(\n+                            tcx,\n+                            ty::Binder::dummy(goal.predicate.with_self_ty(tcx, self_ty)),\n+                        );\n+                        return ecx.evaluate_all_and_make_canonical_response(vec![new_goal]);\n+                    }\n+                },\n+\n+                ty::Infer(ty::FreshTy(..) | ty::FreshIntTy(..) | ty::FreshFloatTy(..))\n+                | ty::Bound(..) => bug!(\n+                    \"unexpected self ty `{:?}` when normalizing `<T as Pointee>::Metadata`\",\n+                    goal.predicate.self_ty()\n+                ),\n+            };\n+\n+            let nested_goals =\n+                ecx.infcx.eq(goal.param_env, goal.predicate.term.ty().unwrap(), metadata_ty)?;\n+            ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+        })\n+    }\n }\n \n /// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code."}, {"sha": "67bd2495665465d254ec83cc927ce42b0471c975", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/430dab0b424abdf68d9071232a654874771570bc/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/430dab0b424abdf68d9071232a654874771570bc/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=430dab0b424abdf68d9071232a654874771570bc", "patch": "@@ -185,6 +185,13 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             Err(NoSolution)\n         }\n     }\n+\n+    fn consider_builtin_pointee_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        _goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        ecx.make_canonical_response(Certainty::Yes)\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {"}, {"sha": "fa6ee2e2daf643727fe1f0264af0d777fad0f938", "filename": "tests/ui/traits/new-solver/pointee.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/430dab0b424abdf68d9071232a654874771570bc/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/430dab0b424abdf68d9071232a654874771570bc/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointee.rs?ref=430dab0b424abdf68d9071232a654874771570bc", "patch": "@@ -0,0 +1,23 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+#![feature(ptr_metadata)]\n+\n+use std::ptr::{DynMetadata, Pointee};\n+\n+trait Trait<U> {}\n+struct MyDst<T: ?Sized>(T);\n+\n+fn works<T>() {\n+    let _: <T as Pointee>::Metadata = ();\n+    let _: <[T] as Pointee>::Metadata = 1_usize;\n+    let _: <str as Pointee>::Metadata = 1_usize;\n+    let _: <dyn Trait<T> as Pointee>::Metadata = give::<DynMetadata<dyn Trait<T>>>();\n+    let _: <MyDst<T> as Pointee>::Metadata = ();\n+    let _: <((((([u8],),),),),) as Pointee>::Metadata = 1_usize;\n+}\n+\n+fn give<U>() -> U {\n+    loop {}\n+}\n+\n+fn main() {}"}]}