{"sha": "5011ae46a14fa30fd247b51ffe71e0bab1a63d04", "node_id": "C_kwDOAAsO6NoAKDUwMTFhZTQ2YTE0ZmEzMGZkMjQ3YjUxZmZlNzFlMGJhYjFhNjNkMDQ", "commit": {"author": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-04-16T13:27:54Z"}, "committer": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-05-23T21:49:04Z"}, "message": "Refactor call terminator to always hold a destination place", "tree": {"sha": "78ee0b0979c9d941a0d02acc6018845e9b0c8671", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78ee0b0979c9d941a0d02acc6018845e9b0c8671"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5011ae46a14fa30fd247b51ffe71e0bab1a63d04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5011ae46a14fa30fd247b51ffe71e0bab1a63d04", "html_url": "https://github.com/rust-lang/rust/commit/5011ae46a14fa30fd247b51ffe71e0bab1a63d04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5011ae46a14fa30fd247b51ffe71e0bab1a63d04/comments", "author": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9025cebac5dc98cc96b72b6e17dd8ad1c77929a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9025cebac5dc98cc96b72b6e17dd8ad1c77929a", "html_url": "https://github.com/rust-lang/rust/commit/d9025cebac5dc98cc96b72b6e17dd8ad1c77929a"}], "stats": {"total": 137, "additions": 66, "deletions": 71}, "files": [{"sha": "decb784199064d921027e56ace03ad8c775513aa", "filename": "src/abi/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5011ae46a14fa30fd247b51ffe71e0bab1a63d04/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011ae46a14fa30fd247b51ffe71e0bab1a63d04/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=5011ae46a14fa30fd247b51ffe71e0bab1a63d04", "patch": "@@ -312,13 +312,14 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     source_info: mir::SourceInfo,\n     func: &Operand<'tcx>,\n     args: &[Operand<'tcx>],\n-    mir_dest: Option<(Place<'tcx>, BasicBlock)>,\n+    destination: Place<'tcx>,\n+    target: Option<BasicBlock>,\n ) {\n     let fn_ty = fx.monomorphize(func.ty(fx.mir, fx.tcx));\n     let fn_sig =\n         fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n \n-    let destination = mir_dest.map(|(place, bb)| (codegen_place(fx, place), bb));\n+    let ret_place = codegen_place(fx, destination);\n \n     // Handle special calls like instrinsics and empty drop glue.\n     let instance = if let ty::FnDef(def_id, substs) = *fn_ty.kind() {\n@@ -333,7 +334,8 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 &fx.tcx.symbol_name(instance).name,\n                 substs,\n                 args,\n-                destination,\n+                ret_place,\n+                target,\n             );\n             return;\n         }\n@@ -344,14 +346,15 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                     fx,\n                     instance,\n                     args,\n-                    destination,\n+                    ret_place,\n+                    target,\n                     source_info,\n                 );\n                 return;\n             }\n             InstanceDef::DropGlue(_, None) => {\n                 // empty drop glue - a nop.\n-                let (_, dest) = destination.expect(\"Non terminating drop_in_place_real???\");\n+                let dest = target.expect(\"Non terminating drop_in_place_real???\");\n                 let ret_block = fx.get_block(dest);\n                 fx.bcx.ins().jump(ret_block, &[]);\n                 return;\n@@ -377,7 +380,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         .unwrap_or(false);\n     if is_cold {\n         fx.bcx.set_cold_block(fx.bcx.current_block().unwrap());\n-        if let Some((_place, destination_block)) = destination {\n+        if let Some(destination_block) = target {\n             fx.bcx.set_cold_block(fx.get_block(destination_block));\n         }\n     }\n@@ -459,7 +462,6 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         }\n     };\n \n-    let ret_place = destination.map(|(place, _)| place);\n     self::returning::codegen_with_call_return_arg(fx, &fn_abi.ret, ret_place, |fx, return_ptr| {\n         let call_args = return_ptr\n             .into_iter()\n@@ -511,7 +513,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         call_inst\n     });\n \n-    if let Some((_, dest)) = destination {\n+    if let Some(dest) = target {\n         let ret_block = fx.get_block(dest);\n         fx.bcx.ins().jump(ret_block, &[]);\n     } else {"}, {"sha": "ff3bb2dfd000f679f1a4d9779685443e7c7745b1", "filename": "src/abi/returning.rs", "status": "modified", "additions": 18, "deletions": 33, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5011ae46a14fa30fd247b51ffe71e0bab1a63d04/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011ae46a14fa30fd247b51ffe71e0bab1a63d04/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=5011ae46a14fa30fd247b51ffe71e0bab1a63d04", "patch": "@@ -56,23 +56,22 @@ pub(super) fn codegen_return_param<'tcx>(\n pub(super) fn codegen_with_call_return_arg<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     ret_arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n-    ret_place: Option<CPlace<'tcx>>,\n+    ret_place: CPlace<'tcx>,\n     f: impl FnOnce(&mut FunctionCx<'_, '_, 'tcx>, Option<Value>) -> Inst,\n ) {\n     let (ret_temp_place, return_ptr) = match ret_arg_abi.mode {\n         PassMode::Ignore => (None, None),\n-        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => match ret_place {\n-            Some(ret_place) if matches!(ret_place.inner(), CPlaceInner::Addr(_, None)) => {\n+        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n+            if matches!(ret_place.inner(), CPlaceInner::Addr(_, None)) {\n                 // This is an optimization to prevent unnecessary copies of the return value when\n                 // the return place is already a memory place as opposed to a register.\n                 // This match arm can be safely removed.\n                 (None, Some(ret_place.to_ptr().get_addr(fx)))\n-            }\n-            _ => {\n+            } else {\n                 let place = CPlace::new_stack_slot(fx, ret_arg_abi.layout);\n                 (Some(place), Some(place.to_ptr().get_addr(fx)))\n             }\n-        },\n+        }\n         PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n             unreachable!(\"unsized return value\")\n         }\n@@ -84,39 +83,25 @@ pub(super) fn codegen_with_call_return_arg<'tcx>(\n     match ret_arg_abi.mode {\n         PassMode::Ignore => {}\n         PassMode::Direct(_) => {\n-            if let Some(ret_place) = ret_place {\n-                let ret_val = fx.bcx.inst_results(call_inst)[0];\n-                ret_place.write_cvalue(fx, CValue::by_val(ret_val, ret_arg_abi.layout));\n-            }\n+            let ret_val = fx.bcx.inst_results(call_inst)[0];\n+            ret_place.write_cvalue(fx, CValue::by_val(ret_val, ret_arg_abi.layout));\n         }\n         PassMode::Pair(_, _) => {\n-            if let Some(ret_place) = ret_place {\n-                let ret_val_a = fx.bcx.inst_results(call_inst)[0];\n-                let ret_val_b = fx.bcx.inst_results(call_inst)[1];\n-                ret_place.write_cvalue(\n-                    fx,\n-                    CValue::by_val_pair(ret_val_a, ret_val_b, ret_arg_abi.layout),\n-                );\n-            }\n+            let ret_val_a = fx.bcx.inst_results(call_inst)[0];\n+            let ret_val_b = fx.bcx.inst_results(call_inst)[1];\n+            ret_place\n+                .write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_arg_abi.layout));\n         }\n         PassMode::Cast(cast) => {\n-            if let Some(ret_place) = ret_place {\n-                let results = fx\n-                    .bcx\n-                    .inst_results(call_inst)\n-                    .iter()\n-                    .copied()\n-                    .collect::<SmallVec<[Value; 2]>>();\n-                let result =\n-                    super::pass_mode::from_casted_value(fx, &results, ret_place.layout(), cast);\n-                ret_place.write_cvalue(fx, result);\n-            }\n+            let results =\n+                fx.bcx.inst_results(call_inst).iter().copied().collect::<SmallVec<[Value; 2]>>();\n+            let result =\n+                super::pass_mode::from_casted_value(fx, &results, ret_place.layout(), cast);\n+            ret_place.write_cvalue(fx, result);\n         }\n         PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n-            if let (Some(ret_place), Some(ret_temp_place)) = (ret_place, ret_temp_place) {\n-                // Both ret_place and ret_temp_place must be Some. If ret_place is None, this is\n-                // a non-returning call. If ret_temp_place is None, it is not necessary to copy the\n-                // return value.\n+            if let Some(ret_temp_place) = ret_temp_place {\n+                // If ret_temp_place is None, it is not necessary to copy the return value.\n                 let ret_temp_value = ret_temp_place.to_cvalue(fx);\n                 ret_place.write_cvalue(fx, ret_temp_value);\n             }"}, {"sha": "3fe112d794b4413c67f311c3aff143057a591d18", "filename": "src/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5011ae46a14fa30fd247b51ffe71e0bab1a63d04/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011ae46a14fa30fd247b51ffe71e0bab1a63d04/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=5011ae46a14fa30fd247b51ffe71e0bab1a63d04", "patch": "@@ -393,6 +393,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n                 func,\n                 args,\n                 destination,\n+                target,\n                 fn_span,\n                 cleanup: _,\n                 from_hir_call: _,\n@@ -404,6 +405,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n                         func,\n                         args,\n                         *destination,\n+                        *target,\n                     )\n                 });\n             }"}, {"sha": "7d2e3e52f34434c7cd500131096d60f5bca25abd", "filename": "src/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5011ae46a14fa30fd247b51ffe71e0bab1a63d04/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011ae46a14fa30fd247b51ffe71e0bab1a63d04/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=5011ae46a14fa30fd247b51ffe71e0bab1a63d04", "patch": "@@ -542,8 +542,8 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n                     | TerminatorKind::FalseEdge { .. }\n                     | TerminatorKind::FalseUnwind { .. } => unreachable!(),\n                     TerminatorKind::InlineAsm { .. } => return None,\n-                    TerminatorKind::Call { destination: Some((call_place, _)), .. }\n-                        if call_place == place =>\n+                    TerminatorKind::Call { destination, target: Some(_), .. }\n+                        if destination == place =>\n                     {\n                         return None;\n                     }"}, {"sha": "77ac46540a9ba88f8c65b47eb18d8e225f1b2555", "filename": "src/intrinsics/llvm.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5011ae46a14fa30fd247b51ffe71e0bab1a63d04/src%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011ae46a14fa30fd247b51ffe71e0bab1a63d04/src%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fllvm.rs?ref=5011ae46a14fa30fd247b51ffe71e0bab1a63d04", "patch": "@@ -10,10 +10,9 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n     intrinsic: &str,\n     _substs: SubstsRef<'tcx>,\n     args: &[mir::Operand<'tcx>],\n-    destination: Option<(CPlace<'tcx>, BasicBlock)>,\n+    ret: CPlace<'tcx>,\n+    target: Option<BasicBlock>,\n ) {\n-    let ret = destination.unwrap().0;\n-\n     intrinsic_match! {\n         fx, intrinsic, args,\n         _ => {\n@@ -126,7 +125,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n         };\n     }\n \n-    let dest = destination.expect(\"all llvm intrinsics used by stdlib should return\").1;\n+    let dest = target.expect(\"all llvm intrinsics used by stdlib should return\");\n     let ret_block = fx.get_block(dest);\n     fx.bcx.ins().jump(ret_block, &[]);\n }"}, {"sha": "f8c69d46d1f67a5be8898d79245a0a7b1f069dd0", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5011ae46a14fa30fd247b51ffe71e0bab1a63d04/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5011ae46a14fa30fd247b51ffe71e0bab1a63d04/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=5011ae46a14fa30fd247b51ffe71e0bab1a63d04", "patch": "@@ -217,35 +217,42 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     instance: Instance<'tcx>,\n     args: &[mir::Operand<'tcx>],\n-    destination: Option<(CPlace<'tcx>, BasicBlock)>,\n+    destination: CPlace<'tcx>,\n+    target: Option<BasicBlock>,\n     source_info: mir::SourceInfo,\n ) {\n     let intrinsic = fx.tcx.item_name(instance.def_id());\n     let substs = instance.substs;\n \n-    let ret = match destination {\n-        Some((place, _)) => place,\n-        None => {\n-            // Insert non returning intrinsics here\n-            match intrinsic {\n-                sym::abort => {\n-                    fx.bcx.ins().trap(TrapCode::User(0));\n-                }\n-                sym::transmute => {\n-                    crate::base::codegen_panic(fx, \"Transmuting to uninhabited type.\", source_info);\n-                }\n-                _ => unimplemented!(\"unsupported instrinsic {}\", intrinsic),\n+    let target = if let Some(target) = target {\n+        target\n+    } else {\n+        // Insert non returning intrinsics here\n+        match intrinsic {\n+            sym::abort => {\n+                fx.bcx.ins().trap(TrapCode::User(0));\n             }\n-            return;\n+            sym::transmute => {\n+                crate::base::codegen_panic(fx, \"Transmuting to uninhabited type.\", source_info);\n+            }\n+            _ => unimplemented!(\"unsupported instrinsic {}\", intrinsic),\n         }\n+        return;\n     };\n \n     if intrinsic.as_str().starts_with(\"simd_\") {\n-        self::simd::codegen_simd_intrinsic_call(fx, intrinsic, substs, args, ret, source_info.span);\n-        let ret_block = fx.get_block(destination.expect(\"SIMD intrinsics don't diverge\").1);\n+        self::simd::codegen_simd_intrinsic_call(\n+            fx,\n+            intrinsic,\n+            substs,\n+            args,\n+            destination,\n+            source_info.span,\n+        );\n+        let ret_block = fx.get_block(target);\n         fx.bcx.ins().jump(ret_block, &[]);\n-    } else if codegen_float_intrinsic_call(fx, intrinsic, args, ret) {\n-        let ret_block = fx.get_block(destination.expect(\"Float intrinsics don't diverge\").1);\n+    } else if codegen_float_intrinsic_call(fx, intrinsic, args, destination) {\n+        let ret_block = fx.get_block(target);\n         fx.bcx.ins().jump(ret_block, &[]);\n     } else {\n         codegen_regular_intrinsic_call(\n@@ -254,9 +261,9 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             intrinsic,\n             substs,\n             args,\n-            ret,\n-            source_info,\n             destination,\n+            Some(target),\n+            source_info,\n         );\n     }\n }\n@@ -339,8 +346,8 @@ fn codegen_regular_intrinsic_call<'tcx>(\n     substs: SubstsRef<'tcx>,\n     args: &[mir::Operand<'tcx>],\n     ret: CPlace<'tcx>,\n+    destination: Option<BasicBlock>,\n     source_info: mir::SourceInfo,\n-    destination: Option<(CPlace<'tcx>, BasicBlock)>,\n ) {\n     let usize_layout = fx.layout_of(fx.tcx.types.usize);\n \n@@ -761,7 +768,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                     if fx.tcx.is_compiler_builtins(LOCAL_CRATE) {\n                         // special case for compiler-builtins to avoid having to patch it\n                         crate::trap::trap_unimplemented(fx, \"128bit atomics not yet supported\");\n-                        let ret_block = fx.get_block(destination.unwrap().1);\n+                        let ret_block = fx.get_block(destination.unwrap());\n                         fx.bcx.ins().jump(ret_block, &[]);\n                         return;\n                     } else {\n@@ -789,7 +796,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                     if fx.tcx.is_compiler_builtins(LOCAL_CRATE) {\n                         // special case for compiler-builtins to avoid having to patch it\n                         crate::trap::trap_unimplemented(fx, \"128bit atomics not yet supported\");\n-                        let ret_block = fx.get_block(destination.unwrap().1);\n+                        let ret_block = fx.get_block(destination.unwrap());\n                         fx.bcx.ins().jump(ret_block, &[]);\n                         return;\n                     } else {\n@@ -1130,6 +1137,6 @@ fn codegen_regular_intrinsic_call<'tcx>(\n         };\n     }\n \n-    let ret_block = fx.get_block(destination.unwrap().1);\n+    let ret_block = fx.get_block(destination.unwrap());\n     fx.bcx.ins().jump(ret_block, &[]);\n }"}]}