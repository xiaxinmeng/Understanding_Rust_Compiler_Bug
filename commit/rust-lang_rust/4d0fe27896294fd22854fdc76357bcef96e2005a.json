{"sha": "4d0fe27896294fd22854fdc76357bcef96e2005a", "node_id": "C_kwDOAAsO6NoAKDRkMGZlMjc4OTYyOTRmZDIyODU0ZmRjNzYzNTdiY2VmOTZlMjAwNWE", "commit": {"author": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2022-02-15T22:49:16Z"}, "committer": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2022-04-26T01:12:15Z"}, "message": "Replace suggest_constraining_param with suggest_restricting_param_bound\nto fix incorrect suggestion for trait bounds involving binary operators.\nFixes #93927, #92347, #93744.", "tree": {"sha": "3f210a441871a9cd8174768b90ded20e1e59bdc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f210a441871a9cd8174768b90ded20e1e59bdc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d0fe27896294fd22854fdc76357bcef96e2005a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d0fe27896294fd22854fdc76357bcef96e2005a", "html_url": "https://github.com/rust-lang/rust/commit/4d0fe27896294fd22854fdc76357bcef96e2005a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d0fe27896294fd22854fdc76357bcef96e2005a/comments", "author": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18b53cefdf7456bf68937b08e377b7e622a115c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/18b53cefdf7456bf68937b08e377b7e622a115c2", "html_url": "https://github.com/rust-lang/rust/commit/18b53cefdf7456bf68937b08e377b7e622a115c2"}], "stats": {"total": 169, "additions": 80, "deletions": 89}, "files": [{"sha": "3be04ef6d21069a985dd0b945337baacbb5075d5", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 29, "deletions": 77, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/4d0fe27896294fd22854fdc76357bcef96e2005a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d0fe27896294fd22854fdc76357bcef96e2005a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=4d0fe27896294fd22854fdc76357bcef96e2005a", "patch": "@@ -11,13 +11,12 @@ use rustc_middle::ty::adjustment::{\n };\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::TyKind::{Adt, Array, Char, FnDef, Never, Ref, Str, Tuple, Uint};\n-use rustc_middle::ty::{\n-    self, suggest_constraining_type_param, Ty, TyCtxt, TypeFoldable, TypeVisitor,\n-};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::suggestions::InferCtxtExt as _;\n use rustc_trait_selection::traits::{FulfillmentError, TraitEngine, TraitEngineExt};\n \n use std::ops::ControlFlow;\n@@ -266,7 +265,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Err(_) if lhs_ty.references_error() || rhs_ty.references_error() => self.tcx.ty_error(),\n             Err(errors) => {\n                 let source_map = self.tcx.sess.source_map();\n-                let (mut err, missing_trait, use_output) = match is_assign {\n+                let (mut err, missing_trait, _use_output) = match is_assign {\n                     IsAssign::Yes => {\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n@@ -449,40 +448,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // concatenation (e.g., \"Hello \" + \"World!\"). This means\n                         // we don't want the note in the else clause to be emitted\n                     } else if let [ty] = &visitor.0[..] {\n-                        if let ty::Param(p) = *ty.kind() {\n-                            // Check if the method would be found if the type param wasn't\n-                            // involved. If so, it means that adding a trait bound to the param is\n-                            // enough. Otherwise we do not give the suggestion.\n-                            let mut eraser = TypeParamEraser(self, expr.span);\n-                            let needs_bound = self\n-                                .lookup_op_method(\n-                                    eraser.fold_ty(lhs_ty),\n-                                    Some(eraser.fold_ty(rhs_ty)),\n-                                    Some(rhs_expr),\n-                                    Op::Binary(op, is_assign),\n-                                )\n-                                .is_ok();\n-                            if needs_bound {\n-                                suggest_constraining_param(\n-                                    self.tcx,\n-                                    self.body_id,\n-                                    &mut err,\n-                                    *ty,\n-                                    rhs_ty,\n-                                    missing_trait,\n-                                    p,\n-                                    use_output,\n-                                );\n-                            } else if *ty != lhs_ty {\n-                                // When we know that a missing bound is responsible, we don't show\n-                                // this note as it is redundant.\n-                                err.note(&format!(\n-                                    \"the trait `{missing_trait}` is not implemented for `{lhs_ty}`\"\n-                                ));\n-                            }\n-                        } else {\n-                            bug!(\"type param visitor stored a non type param: {:?}\", ty.kind());\n+                        // Look for a TraitPredicate in the Fulfillment errors,\n+                        // and use it to generate a suggestion.\n+                        //\n+                        // Note that lookup_op_method must be called again but\n+                        // with a specific rhs_ty instead of a placeholder so\n+                        // the resulting predicate generates a more specific\n+                        // suggestion for the user.\n+                        let errors = self\n+                        .lookup_op_method(lhs_ty, &[rhs_ty], Op::Binary(op, is_assign))\n+                        .unwrap_err();\n+                    let predicates = errors\n+                        .into_iter()\n+                        .filter_map(|error| error.obligation.predicate.to_opt_poly_trait_pred())\n+                        .collect::<Vec<_>>();\n+                    if !predicates.is_empty() {\n+                        for pred in predicates {\n+                            self.infcx.suggest_restricting_param_bound(&mut err,\n+                                pred,\n+                                self.body_id,\n+                            );\n                         }\n+                     } else if *ty != lhs_ty {\n+                        // When we know that a missing bound is responsible, we don't show\n+                        // this note as it is redundant.\n+                        err.note(&format!(\n+                            \"the trait `{missing_trait}` is not implemented for `{lhs_ty}`\"\n+                        ));                    \n                     }\n                 }\n                 err.emit();\n@@ -973,46 +965,6 @@ fn is_builtin_binop<'tcx>(lhs: Ty<'tcx>, rhs: Ty<'tcx>, op: hir::BinOp) -> bool\n     }\n }\n \n-fn suggest_constraining_param(\n-    tcx: TyCtxt<'_>,\n-    body_id: hir::HirId,\n-    mut err: &mut Diagnostic,\n-    lhs_ty: Ty<'_>,\n-    rhs_ty: Ty<'_>,\n-    missing_trait: &str,\n-    p: ty::ParamTy,\n-    set_output: bool,\n-) {\n-    let hir = tcx.hir();\n-    let msg = &format!(\"`{lhs_ty}` might need a bound for `{missing_trait}`\");\n-    // Try to find the def-id and details for the parameter p. We have only the index,\n-    // so we have to find the enclosing function's def-id, then look through its declared\n-    // generic parameters to get the declaration.\n-    let def_id = hir.body_owner_def_id(hir::BodyId { hir_id: body_id });\n-    let generics = tcx.generics_of(def_id);\n-    let param_def_id = generics.type_param(&p, tcx).def_id;\n-    if let Some(generics) = param_def_id\n-        .as_local()\n-        .map(|id| hir.local_def_id_to_hir_id(id))\n-        .and_then(|id| hir.find_by_def_id(hir.get_parent_item(id)))\n-        .as_ref()\n-        .and_then(|node| node.generics())\n-    {\n-        let output = if set_output { format!(\"<Output = {rhs_ty}>\") } else { String::new() };\n-        suggest_constraining_type_param(\n-            tcx,\n-            generics,\n-            &mut err,\n-            &lhs_ty.to_string(),\n-            &format!(\"{missing_trait}{output}\"),\n-            None,\n-        );\n-    } else {\n-        let span = tcx.def_span(param_def_id);\n-        err.span_label(span, msg);\n-    }\n-}\n-\n struct TypeParamVisitor<'tcx>(Vec<Ty<'tcx>>);\n \n impl<'tcx> TypeVisitor<'tcx> for TypeParamVisitor<'tcx> {"}, {"sha": "de27c9785e65a40f65270fc63cee1a59263a830b", "filename": "src/test/ui/binop/issue-93927.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4d0fe27896294fd22854fdc76357bcef96e2005a/src%2Ftest%2Fui%2Fbinop%2Fissue-93927.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d0fe27896294fd22854fdc76357bcef96e2005a/src%2Ftest%2Fui%2Fbinop%2Fissue-93927.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fissue-93927.rs?ref=4d0fe27896294fd22854fdc76357bcef96e2005a", "patch": "@@ -0,0 +1,20 @@\n+// Regression test for #93927: suggested trait bound for T should be Eq, not PartialEq\n+struct MyType<T>(T);\n+\n+impl<T> PartialEq for MyType<T>\n+where\n+    T: Eq,\n+{\n+    fn eq(&self, other: &Self) -> bool {\n+        true\n+    }\n+}\n+\n+fn cond<T: PartialEq>(val: MyType<T>) -> bool {\n+    val == val\n+    //~^ ERROR binary operation `==` cannot be applied to type `MyType<T>`\n+}\n+\n+fn main() {\n+    cond(MyType(0));\n+}"}, {"sha": "75558b502f9dc6e057e0e56dedd680c065ec0d34", "filename": "src/test/ui/binop/issue-93927.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4d0fe27896294fd22854fdc76357bcef96e2005a/src%2Ftest%2Fui%2Fbinop%2Fissue-93927.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d0fe27896294fd22854fdc76357bcef96e2005a/src%2Ftest%2Fui%2Fbinop%2Fissue-93927.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fissue-93927.stderr?ref=4d0fe27896294fd22854fdc76357bcef96e2005a", "patch": "@@ -0,0 +1,16 @@\n+error[E0369]: binary operation `==` cannot be applied to type `MyType<T>`\n+  --> $DIR/issue-93927.rs:14:9\n+   |\n+LL |     val == val\n+   |     --- ^^ --- MyType<T>\n+   |     |\n+   |     MyType<T>\n+   |\n+help: consider further restricting this bound\n+   |\n+LL | fn cond<T: PartialEq + std::cmp::Eq>(val: MyType<T>) -> bool {\n+   |                      ++++++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0369`."}, {"sha": "8eddfe21e30fa2bccddeedabed31dacc270cbaf6", "filename": "src/test/ui/generic-associated-types/missing-bounds.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d0fe27896294fd22854fdc76357bcef96e2005a/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4d0fe27896294fd22854fdc76357bcef96e2005a/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed?ref=4d0fe27896294fd22854fdc76357bcef96e2005a", "patch": "@@ -24,7 +24,7 @@ impl<B: Add + Add<Output = B>> Add for C<B> {\n \n struct D<B>(B);\n \n-impl<B: std::ops::Add<Output = B>> Add for D<B> {\n+impl<B: std::ops::Add> Add for D<B> {\n     type Output = Self;\n \n     fn add(self, rhs: Self) -> Self {"}, {"sha": "25db846109854a08f6e7a4536313a7603d358577", "filename": "src/test/ui/generic-associated-types/missing-bounds.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d0fe27896294fd22854fdc76357bcef96e2005a/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d0fe27896294fd22854fdc76357bcef96e2005a/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr?ref=4d0fe27896294fd22854fdc76357bcef96e2005a", "patch": "@@ -66,8 +66,8 @@ LL |         Self(self.0 + rhs.0)\n    |\n help: consider restricting type parameter `B`\n    |\n-LL | impl<B: std::ops::Add<Output = B>> Add for D<B> {\n-   |       +++++++++++++++++++++++++++\n+LL | impl<B: std::ops::Add> Add for D<B> {\n+   |       +++++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/missing-bounds.rs:42:14"}, {"sha": "07409e9834a4642a903373d3221ac5a89a31736c", "filename": "src/test/ui/issues/issue-35668.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d0fe27896294fd22854fdc76357bcef96e2005a/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d0fe27896294fd22854fdc76357bcef96e2005a/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr?ref=4d0fe27896294fd22854fdc76357bcef96e2005a", "patch": "@@ -6,10 +6,10 @@ LL |     a.iter().map(|a| a*a)\n    |                      |\n    |                      &T\n    |\n-help: consider restricting type parameter `T`\n+help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n    |\n-LL | fn func<'a, T: std::ops::Mul<Output = &T>>(a: &'a [T]) -> impl Iterator<Item=&'a T> {\n-   |              ++++++++++++++++++++++++++++\n+LL | fn func<'a, T>(a: &'a [T]) -> impl Iterator<Item=&'a T> where &T: Mul<&T> {\n+   |                                                         +++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "fe5e2b5816fdfe7ce79a78919610f398e2801a12", "filename": "src/test/ui/suggestions/invalid-bin-op.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4d0fe27896294fd22854fdc76357bcef96e2005a/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d0fe27896294fd22854fdc76357bcef96e2005a/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr?ref=4d0fe27896294fd22854fdc76357bcef96e2005a", "patch": "@@ -11,11 +11,14 @@ note: an implementation of `PartialEq<_>` might be missing for `S<T>`\n    |\n LL | struct S<T>(T);\n    | ^^^^^^^^^^^^^^^ must implement `PartialEq<_>`\n-   = note: the trait `std::cmp::PartialEq` is not implemented for `S<T>`\n help: consider annotating `S<T>` with `#[derive(PartialEq)]`\n    |\n LL | #[derive(PartialEq)]\n    |\n+help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+   |\n+LL | pub fn foo<T>(s: S<T>, t: S<T>) where S<T>: PartialEq {\n+   |                                 +++++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "3ae6bf130cc7e8b9cb95dad9ca88685183f1a6ba", "filename": "src/test/ui/traits/resolution-in-overloaded-op.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d0fe27896294fd22854fdc76357bcef96e2005a/src%2Ftest%2Fui%2Ftraits%2Fresolution-in-overloaded-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d0fe27896294fd22854fdc76357bcef96e2005a/src%2Ftest%2Fui%2Ftraits%2Fresolution-in-overloaded-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fresolution-in-overloaded-op.stderr?ref=4d0fe27896294fd22854fdc76357bcef96e2005a", "patch": "@@ -6,10 +6,10 @@ LL |     a * b\n    |     |\n    |     &T\n    |\n-help: consider further restricting this bound\n+help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n    |\n-LL | fn foo<T: MyMul<f64, f64> + std::ops::Mul<Output = f64>>(a: &T, b: f64) -> f64 {\n-   |                           +++++++++++++++++++++++++++++\n+LL | fn foo<T: MyMul<f64, f64>>(a: &T, b: f64) -> f64 where &T: Mul<f64> {\n+   |                                                  ++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "fe156a8845396b2e346f012a67483faadb69c68b", "filename": "src/test/ui/type/type-check/missing_trait_impl.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d0fe27896294fd22854fdc76357bcef96e2005a/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d0fe27896294fd22854fdc76357bcef96e2005a/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.stderr?ref=4d0fe27896294fd22854fdc76357bcef96e2005a", "patch": "@@ -8,8 +8,8 @@ LL |     let z = x + y;\n    |\n help: consider restricting type parameter `T`\n    |\n-LL | fn foo<T: std::ops::Add<Output = T>>(x: T, y: T) {\n-   |         +++++++++++++++++++++++++++\n+LL | fn foo<T: std::ops::Add>(x: T, y: T) {\n+   |         +++++++++++++++\n \n error[E0368]: binary assignment operation `+=` cannot be applied to type `T`\n   --> $DIR/missing_trait_impl.rs:9:5"}]}