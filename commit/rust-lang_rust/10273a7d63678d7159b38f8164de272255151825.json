{"sha": "10273a7d63678d7159b38f8164de272255151825", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwMjczYTdkNjM2NzhkNzE1OWIzOGY4MTY0ZGUyNzIyNTUxNTE4MjU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-10T10:27:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-10T10:27:16Z"}, "message": "Merge #9545\n\n9545: Record autoderef adjustments r=flodiebold a=Veykril\n\ncc #9475\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "cbf89a266c52889688d1093c096bfa1be45e3080", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbf89a266c52889688d1093c096bfa1be45e3080"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10273a7d63678d7159b38f8164de272255151825", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg6XYECRBK7hj4Ov3rIwAApPIIAJ8IjIwuRskT1jaVoVQPVpNC\n7q2PmznWKK5oviI2I4ykaUKbk7Xsy1O/GAs7S8mGLDwDxYK+5O6oZFJ6ppSQTj0R\nV+S3GYfAiuCZNCjBN3pv1Bmmv5kHjTO/IhETxTHnNHjvPMvSsTsLS2wAxA3xk+K+\n/sGelCAp6pUhxVp8DZ28HnDcAZ+PWHaOEp1D1Fkny8QykzkC7WwPFmWcgULjuudq\n8gmmt0wtjLsfrcVHQZ5WT5GUe21Rqc3mMGQXoY8O5HgwRbZmK1Y7t29CSI9W+/Qb\nrrkUNNDTdv4avZo+YfCoJtgcTmnZWarQKSXhl+rh02GEW2D8JS414I2mrClaFzs=\n=xwky\n-----END PGP SIGNATURE-----\n", "payload": "tree cbf89a266c52889688d1093c096bfa1be45e3080\nparent 10ac4e5c0d04bd6b2b6d14aa7ce9e54390d5f12d\nparent 69e65118205dbde3601f01b9565537ed8004411e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1625912836 +0000\ncommitter GitHub <noreply@github.com> 1625912836 +0000\n\nMerge #9545\n\n9545: Record autoderef adjustments r=flodiebold a=Veykril\n\ncc #9475\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10273a7d63678d7159b38f8164de272255151825", "html_url": "https://github.com/rust-lang/rust/commit/10273a7d63678d7159b38f8164de272255151825", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10273a7d63678d7159b38f8164de272255151825/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10ac4e5c0d04bd6b2b6d14aa7ce9e54390d5f12d", "url": "https://api.github.com/repos/rust-lang/rust/commits/10ac4e5c0d04bd6b2b6d14aa7ce9e54390d5f12d", "html_url": "https://github.com/rust-lang/rust/commit/10ac4e5c0d04bd6b2b6d14aa7ce9e54390d5f12d"}, {"sha": "69e65118205dbde3601f01b9565537ed8004411e", "url": "https://api.github.com/repos/rust-lang/rust/commits/69e65118205dbde3601f01b9565537ed8004411e", "html_url": "https://github.com/rust-lang/rust/commit/69e65118205dbde3601f01b9565537ed8004411e"}], "stats": {"total": 247, "additions": 167, "deletions": 80}, "files": [{"sha": "fbbb0c8208a373823a13d18fd36da74c274f4112", "filename": "crates/hir_ty/src/autoderef.rs", "status": "modified", "additions": 73, "deletions": 2, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/10273a7d63678d7159b38f8164de272255151825/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10273a7d63678d7159b38f8164de272255151825/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs?ref=10273a7d63678d7159b38f8164de272255151825", "patch": "@@ -13,12 +13,83 @@ use log::{info, warn};\n \n use crate::{\n     db::HirDatabase, static_lifetime, AliasEq, AliasTy, BoundVar, Canonical, CanonicalVarKinds,\n-    DebruijnIndex, InEnvironment, Interner, ProjectionTyExt, Solution, Substitution, Ty, TyBuilder,\n-    TyKind,\n+    DebruijnIndex, Environment, InEnvironment, Interner, ProjectionTyExt, Solution, Substitution,\n+    Ty, TyBuilder, TyKind,\n };\n \n+pub(crate) enum AutoderefKind {\n+    Builtin,\n+    Overloaded,\n+}\n+\n+pub(crate) struct Autoderef<'db> {\n+    db: &'db dyn HirDatabase,\n+    ty: Canonical<Ty>,\n+    at_start: bool,\n+    krate: Option<CrateId>,\n+    environment: Environment,\n+    steps: Vec<(AutoderefKind, Ty)>,\n+}\n+\n+impl<'db> Autoderef<'db> {\n+    pub(crate) fn new(\n+        db: &'db dyn HirDatabase,\n+        krate: Option<CrateId>,\n+        ty: InEnvironment<Canonical<Ty>>,\n+    ) -> Self {\n+        let InEnvironment { goal: ty, environment } = ty;\n+        Autoderef { db, ty, at_start: true, environment, krate, steps: Vec::new() }\n+    }\n+\n+    pub(crate) fn step_count(&self) -> usize {\n+        self.steps.len()\n+    }\n+\n+    pub(crate) fn steps(&self) -> &[(AutoderefKind, chalk_ir::Ty<Interner>)] {\n+        &self.steps\n+    }\n+\n+    pub(crate) fn final_ty(&self) -> Ty {\n+        self.ty.value.clone()\n+    }\n+}\n+\n+impl Iterator for Autoderef<'_> {\n+    type Item = (Canonical<Ty>, usize);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.at_start {\n+            self.at_start = false;\n+            return Some((self.ty.clone(), 0));\n+        }\n+\n+        if self.steps.len() >= AUTODEREF_RECURSION_LIMIT {\n+            return None;\n+        }\n+\n+        let (kind, new_ty) = if let Some(derefed) = builtin_deref(&self.ty.value) {\n+            (AutoderefKind::Builtin, Canonical { value: derefed, binders: self.ty.binders.clone() })\n+        } else {\n+            (\n+                AutoderefKind::Overloaded,\n+                deref_by_trait(\n+                    self.db,\n+                    self.krate?,\n+                    InEnvironment { goal: &self.ty, environment: self.environment.clone() },\n+                )?,\n+            )\n+        };\n+\n+        self.steps.push((kind, self.ty.value.clone()));\n+        self.ty = new_ty;\n+\n+        Some((self.ty.clone(), self.step_count()))\n+    }\n+}\n+\n const AUTODEREF_RECURSION_LIMIT: usize = 10;\n \n+// FIXME: replace uses of this with Autoderef above\n pub fn autoderef<'a>(\n     db: &'a dyn HirDatabase,\n     krate: Option<CrateId>,"}, {"sha": "d2e999a730f715defdb17e2596b893a614c6b1e2", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 50, "deletions": 15, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/10273a7d63678d7159b38f8164de272255151825/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10273a7d63678d7159b38f8164de272255151825/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=10273a7d63678d7159b38f8164de272255151825", "patch": "@@ -5,14 +5,17 @@\n //! See <https://doc.rust-lang.org/nomicon/coercions.html> and\n //! `librustc_typeck/check/coercion.rs`.\n \n+use std::iter;\n+\n use chalk_ir::{cast::Cast, Goal, Mutability, TyVariableKind};\n use hir_def::{expr::ExprId, lang_item::LangItemTarget};\n+use stdx::always;\n \n use crate::{\n-    autoderef,\n+    autoderef::{Autoderef, AutoderefKind},\n     infer::{\n-        Adjust, Adjustment, AutoBorrow, InferOk, InferResult, InferenceContext, PointerCast,\n-        TypeError, TypeMismatch,\n+        Adjust, Adjustment, AutoBorrow, InferOk, InferResult, InferenceContext, OverloadedDeref,\n+        PointerCast, TypeError, TypeMismatch,\n     },\n     static_lifetime, Canonical, DomainGoal, FnPointer, FnSig, InEnvironment, Interner, Solution,\n     Substitution, Ty, TyBuilder, TyExt, TyKind,\n@@ -241,9 +244,10 @@ impl<'a> InferenceContext<'a> {\n     /// To match `A` with `B`, autoderef will be performed,\n     /// calling `deref`/`deref_mut` where necessary.\n     fn coerce_ref(&mut self, from_ty: Ty, to_ty: &Ty, to_mt: Mutability) -> CoerceResult {\n-        match from_ty.kind(&Interner) {\n-            TyKind::Ref(mt, _, _) => {\n-                coerce_mutabilities(*mt, to_mt)?;\n+        let from_mt = match from_ty.kind(&Interner) {\n+            &TyKind::Ref(mt, _, _) => {\n+                coerce_mutabilities(mt, to_mt)?;\n+                mt\n             }\n             _ => return self.unify_and(&from_ty, to_ty, identity),\n         };\n@@ -254,8 +258,8 @@ impl<'a> InferenceContext<'a> {\n         // details of coercion errors though, so I think it's useful to leave\n         // the structure like it is.\n \n-        let canonicalized = self.canonicalize(from_ty);\n-        let autoderef = autoderef::autoderef(\n+        let canonicalized = self.canonicalize(from_ty.clone());\n+        let mut autoderef = Autoderef::new(\n             self.db,\n             self.resolver.krate(),\n             InEnvironment {\n@@ -266,7 +270,7 @@ impl<'a> InferenceContext<'a> {\n         let mut first_error = None;\n         let mut found = None;\n \n-        for (autoderefs, referent_ty) in autoderef.enumerate() {\n+        for (referent_ty, autoderefs) in autoderef.by_ref() {\n             if autoderefs == 0 {\n                 // Don't let this pass, otherwise it would cause\n                 // &T to autoref to &&T.\n@@ -324,12 +328,43 @@ impl<'a> InferenceContext<'a> {\n                 return Err(err);\n             }\n         };\n-        // FIXME: record overloaded deref adjustments\n-        success(\n-            vec![Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(to_mt)), target: ty.clone() }],\n-            ty,\n-            goals,\n-        )\n+        if ty == from_ty && from_mt == Mutability::Not && autoderef.step_count() == 1 {\n+            // As a special case, if we would produce `&'a *x`, that's\n+            // a total no-op. We end up with the type `&'a T` just as\n+            // we started with.  In that case, just skip it\n+            // altogether. This is just an optimization.\n+            //\n+            // Note that for `&mut`, we DO want to reborrow --\n+            // otherwise, this would be a move, which might be an\n+            // error. For example `foo(self.x)` where `self` and\n+            // `self.x` both have `&mut `type would be a move of\n+            // `self.x`, but we auto-coerce it to `foo(&mut *self.x)`,\n+            // which is a borrow.\n+            always!(to_mt == Mutability::Not); // can only coerce &T -> &U\n+            return success(vec![], ty, goals);\n+        }\n+\n+        let mut adjustments = self.auto_deref_adjust_steps(&autoderef);\n+        adjustments\n+            .push(Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(to_mt)), target: ty.clone() });\n+\n+        success(adjustments, ty, goals)\n+    }\n+\n+    pub(super) fn auto_deref_adjust_steps(&self, autoderef: &Autoderef<'_>) -> Vec<Adjustment> {\n+        let steps = autoderef.steps();\n+        let targets =\n+            steps.iter().skip(1).map(|(_, ty)| ty.clone()).chain(iter::once(autoderef.final_ty()));\n+        steps\n+            .iter()\n+            .map(|(kind, _source)| match kind {\n+                // We do not know what kind of deref we require at this point yet\n+                AutoderefKind::Overloaded => Some(OverloadedDeref(Mutability::Not)),\n+                AutoderefKind::Builtin => None,\n+            })\n+            .zip(targets)\n+            .map(|(autoderef, target)| Adjustment { kind: Adjust::Deref(autoderef), target })\n+            .collect()\n     }\n \n     /// Attempts to coerce from the type of a Rust function item into a function pointer."}, {"sha": "f1bc6895c82cb63e093db7528eac813c4d3c48b3", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/10273a7d63678d7159b38f8164de272255151825/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10273a7d63678d7159b38f8164de272255151825/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=10273a7d63678d7159b38f8164de272255151825", "patch": "@@ -1,7 +1,10 @@\n //! Type inference for expressions.\n \n-use std::iter::{repeat, repeat_with};\n-use std::{mem, sync::Arc};\n+use std::{\n+    iter::{repeat, repeat_with},\n+    mem,\n+    sync::Arc,\n+};\n \n use chalk_ir::{cast::Cast, fold::Shift, Mutability, TyVariableKind};\n use hir_def::{\n@@ -15,7 +18,8 @@ use stdx::always;\n use syntax::ast::RangeOp;\n \n use crate::{\n-    autoderef, consteval,\n+    autoderef::{self, Autoderef},\n+    consteval,\n     infer::coerce::CoerceMany,\n     lower::lower_to_chalk_mutability,\n     mapping::from_chalk,\n@@ -314,22 +318,27 @@ impl<'a> InferenceContext<'a> {\n             Expr::Call { callee, args } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n                 let canonicalized = self.canonicalize(callee_ty.clone());\n-                let mut derefs = autoderef(\n+                let mut derefs = Autoderef::new(\n                     self.db,\n                     self.resolver.krate(),\n                     InEnvironment {\n                         goal: canonicalized.value.clone(),\n                         environment: self.table.trait_env.env.clone(),\n                     },\n                 );\n-                let (param_tys, ret_ty): (Vec<Ty>, Ty) = derefs\n-                    .find_map(|callee_deref_ty| {\n-                        self.callable_sig(\n-                            &canonicalized.decanonicalize_ty(callee_deref_ty.value),\n-                            args.len(),\n-                        )\n-                    })\n-                    .unwrap_or((Vec::new(), self.err_ty()));\n+                let res = derefs.by_ref().find_map(|(callee_deref_ty, _)| {\n+                    self.callable_sig(\n+                        &canonicalized.decanonicalize_ty(callee_deref_ty.value),\n+                        args.len(),\n+                    )\n+                });\n+                let (param_tys, ret_ty): (Vec<Ty>, Ty) = match res {\n+                    Some(res) => {\n+                        self.write_expr_adj(*callee, self.auto_deref_adjust_steps(&derefs));\n+                        res\n+                    }\n+                    None => (Vec::new(), self.err_ty()),\n+                };\n                 self.register_obligations_for_call(&callee_ty);\n                 self.check_call_arguments(args, &param_tys);\n                 self.normalize_associated_types_in(ret_ty)\n@@ -467,15 +476,16 @@ impl<'a> InferenceContext<'a> {\n             Expr::Field { expr, name } => {\n                 let receiver_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 let canonicalized = self.canonicalize(receiver_ty);\n-                let ty = autoderef::autoderef(\n+\n+                let mut autoderef = Autoderef::new(\n                     self.db,\n                     self.resolver.krate(),\n                     InEnvironment {\n                         goal: canonicalized.value.clone(),\n                         environment: self.trait_env.env.clone(),\n                     },\n-                )\n-                .find_map(|derefed_ty| {\n+                );\n+                let ty = autoderef.by_ref().find_map(|(derefed_ty, _)| {\n                     let def_db = self.db.upcast();\n                     let module = self.resolver.module();\n                     let is_visible = |field_id: &FieldId| {\n@@ -524,8 +534,14 @@ impl<'a> InferenceContext<'a> {\n                         }\n                         _ => None,\n                     }\n-                })\n-                .unwrap_or_else(|| self.err_ty());\n+                });\n+                let ty = match ty {\n+                    Some(ty) => {\n+                        self.write_expr_adj(*expr, self.auto_deref_adjust_steps(&autoderef));\n+                        ty\n+                    }\n+                    None => self.err_ty(),\n+                };\n                 let ty = self.insert_type_vars(ty);\n                 self.normalize_associated_types_in(ty)\n             }"}, {"sha": "2026a42682121970b32d114996ed7bcb152bcf39", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10273a7d63678d7159b38f8164de272255151825/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10273a7d63678d7159b38f8164de272255151825/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=10273a7d63678d7159b38f8164de272255151825", "patch": "@@ -112,6 +112,7 @@ pub type Canonical<T> = chalk_ir::Canonical<T>;\n pub type FnSig = chalk_ir::FnSig<Interner>;\n \n pub type InEnvironment<T> = chalk_ir::InEnvironment<T>;\n+pub type Environment = chalk_ir::Environment<Interner>;\n pub type DomainGoal = chalk_ir::DomainGoal<Interner>;\n pub type Goal = chalk_ir::Goal<Interner>;\n pub type AliasEq = chalk_ir::AliasEq<Interner>;"}, {"sha": "1e30e2e8c1d7d37a7be580d3c9fe5ff221e851c4", "filename": "crates/hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10273a7d63678d7159b38f8164de272255151825/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10273a7d63678d7159b38f8164de272255151825/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=10273a7d63678d7159b38f8164de272255151825", "patch": "@@ -236,6 +236,7 @@ fn takes_ref_str(x: &str) {}\n fn returns_string() -> String { loop {} }\n fn test() {\n     takes_ref_str(&{ returns_string() });\n+               // ^^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(None), Deref(Some(OverloadedDeref(Not))), Borrow(Ref(Not))\n }\n \"#,\n     );"}, {"sha": "3bf67281f2be44309da54101d49b48452c3c292c", "filename": "crates/hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 9, "deletions": 46, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/10273a7d63678d7159b38f8164de272255151825/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10273a7d63678d7159b38f8164de272255151825/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=10273a7d63678d7159b38f8164de272255151825", "patch": "@@ -1,5 +1,7 @@\n use expect_test::expect;\n \n+use crate::tests::check;\n+\n use super::{check_infer, check_types};\n \n #[test]\n@@ -1137,7 +1139,7 @@ fn main() {\n \n #[test]\n fn autoderef_visibility_field() {\n-    check_infer(\n+    check(\n         r#\"\n //- minicore: deref\n mod a {\n@@ -1158,33 +1160,18 @@ mod a {\n mod b {\n     fn foo() {\n         let x = super::a::Bar::new().0;\n+             // ^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(Some(OverloadedDeref(Not)))\n+             // ^^^^^^^^^^^^^^^^^^^^^^ type: char\n     }\n }\n-        \"#,\n-        expect![[r#\"\n-            107..138 '{     ...     }': Bar\n-            121..125 'Self': Bar(i32) -> Bar\n-            121..128 'Self(0)': Bar\n-            126..127 '0': i32\n-            226..230 'self': &Bar\n-            240..273 '{     ...     }': &Foo\n-            254..263 '&Foo('z')': &Foo\n-            255..258 'Foo': Foo(char) -> Foo\n-            255..263 'Foo('z')': Foo\n-            259..262 ''z'': char\n-            303..350 '{     ...     }': ()\n-            317..318 'x': char\n-            321..339 'super:...r::new': fn new() -> Bar\n-            321..341 'super:...:new()': Bar\n-            321..343 'super:...ew().0': char\n-        \"#]],\n+\"#,\n     )\n }\n \n #[test]\n fn autoderef_visibility_method() {\n     cov_mark::check!(autoderef_candidate_not_visible);\n-    check_infer(\n+    check(\n         r#\"\n //- minicore: deref\n mod a {\n@@ -1213,34 +1200,10 @@ mod a {\n mod b {\n     fn foo() {\n         let x = super::a::Bar::new().mango();\n+             // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type: char\n     }\n }\n-        \"#,\n-        expect![[r#\"\n-            75..79 'self': &Foo\n-            89..119 '{     ...     }': char\n-            103..107 'self': &Foo\n-            103..109 'self.0': char\n-            195..226 '{     ...     }': Bar\n-            209..213 'Self': Bar(i32) -> Bar\n-            209..216 'Self(0)': Bar\n-            214..215 '0': i32\n-            245..249 'self': &Bar\n-            258..288 '{     ...     }': i32\n-            272..276 'self': &Bar\n-            272..278 'self.0': i32\n-            376..380 'self': &Bar\n-            390..423 '{     ...     }': &Foo\n-            404..413 '&Foo('z')': &Foo\n-            405..408 'Foo': Foo(char) -> Foo\n-            405..413 'Foo('z')': Foo\n-            409..412 ''z'': char\n-            453..506 '{     ...     }': ()\n-            467..468 'x': char\n-            471..489 'super:...r::new': fn new() -> Bar\n-            471..491 'super:...:new()': Bar\n-            471..499 'super:...ango()': char\n-        \"#]],\n+\"#,\n     )\n }\n "}]}