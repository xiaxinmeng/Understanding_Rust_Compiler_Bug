{"sha": "f2c8707abbedee2587b5653a42e0860a101f0ddf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYzg3MDdhYmJlZGVlMjU4N2I1NjUzYTQyZTA4NjBhMTAxZjBkZGY=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-12-30T21:08:57Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-08-22T18:23:31Z"}, "message": "Remove force_query_with_job.", "tree": {"sha": "aa3c1e6d85319e163be1c9f262eeb2f9a399387b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa3c1e6d85319e163be1c9f262eeb2f9a399387b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2c8707abbedee2587b5653a42e0860a101f0ddf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2c8707abbedee2587b5653a42e0860a101f0ddf", "html_url": "https://github.com/rust-lang/rust/commit/f2c8707abbedee2587b5653a42e0860a101f0ddf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2c8707abbedee2587b5653a42e0860a101f0ddf/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef4becdce4198107507734246f6ffd053d0b8c67", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef4becdce4198107507734246f6ffd053d0b8c67", "html_url": "https://github.com/rust-lang/rust/commit/ef4becdce4198107507734246f6ffd053d0b8c67"}], "stats": {"total": 141, "additions": 53, "deletions": 88}, "files": [{"sha": "e81a09d343df71e973aad15b4b80c92404375dde", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 53, "deletions": 88, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/f2c8707abbedee2587b5653a42e0860a101f0ddf/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c8707abbedee2587b5653a42e0860a101f0ddf/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=f2c8707abbedee2587b5653a42e0860a101f0ddf", "patch": "@@ -17,7 +17,7 @@ use rustc_data_structures::profiling::TimingGuard;\n use rustc_data_structures::sharded::{get_shard_index_by_hash, Sharded};\n use rustc_data_structures::sync::{Lock, LockGuard};\n use rustc_data_structures::thin_vec::ThinVec;\n-use rustc_errors::{Diagnostic, DiagnosticBuilder, FatalError};\n+use rustc_errors::{DiagnosticBuilder, FatalError};\n use rustc_span::{Span, DUMMY_SP};\n use std::cell::Cell;\n use std::collections::hash_map::Entry;\n@@ -304,15 +304,6 @@ where\n     }\n }\n \n-fn with_diagnostics<F, R>(f: F) -> (R, ThinVec<Diagnostic>)\n-where\n-    F: FnOnce(Option<&Lock<ThinVec<Diagnostic>>>) -> R,\n-{\n-    let diagnostics = Lock::new(ThinVec::new());\n-    let result = f(Some(&diagnostics));\n-    (result, diagnostics.into_inner())\n-}\n-\n impl<'tcx, D, K> Drop for JobOwner<'tcx, D, K>\n where\n     D: Copy + Clone + Eq + Hash,\n@@ -452,7 +443,7 @@ where\n fn execute_job<CTX, K, V>(\n     tcx: CTX,\n     key: K,\n-    dep_node: Option<DepNode<CTX::DepKind>>,\n+    mut dep_node_opt: Option<DepNode<CTX::DepKind>>,\n     query: &QueryVtable<CTX, K, V>,\n     job_id: QueryJobId<CTX::DepKind>,\n     compute: fn(CTX::DepContext, K) -> V,\n@@ -473,45 +464,66 @@ where\n         return (result, dep_node_index);\n     }\n \n-    if query.anon {\n-        let prof_timer = tcx.dep_context().profiler().query_provider();\n-\n-        let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n-            tcx.start_query(job_id, diagnostics, || {\n-                dep_graph.with_anon_task(*tcx.dep_context(), query.dep_kind, || {\n-                    compute(*tcx.dep_context(), key)\n-                })\n-            })\n-        });\n+    if !query.anon && !query.eval_always {\n+        // `to_dep_node` is expensive for some `DepKind`s.\n+        let dep_node =\n+            dep_node_opt.get_or_insert_with(|| query.to_dep_node(*tcx.dep_context(), &key));\n \n-        prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n+        // The diagnostics for this query will be promoted to the current session during\n+        // `try_mark_green()`, so we can ignore them here.\n+        if let Some(ret) = tcx.start_query(job_id, None, || {\n+            try_load_from_disk_and_cache_in_memory(tcx, &key, &dep_node, query, compute)\n+        }) {\n+            return ret;\n+        }\n+    }\n \n-        let side_effects = QuerySideEffects { diagnostics };\n+    let prof_timer = tcx.dep_context().profiler().query_provider();\n+    let diagnostics = Lock::new(ThinVec::new());\n \n-        if unlikely!(!side_effects.is_empty()) {\n-            tcx.store_side_effects_for_anon_node(dep_node_index, side_effects);\n+    let (result, dep_node_index) = tcx.start_query(job_id, Some(&diagnostics), || {\n+        if query.anon {\n+            return dep_graph.with_anon_task(*tcx.dep_context(), query.dep_kind, || {\n+                compute(*tcx.dep_context(), key)\n+            });\n         }\n \n-        (result, dep_node_index)\n-    } else if query.eval_always {\n         // `to_dep_node` is expensive for some `DepKind`s.\n-        let dep_node = dep_node.unwrap_or_else(|| query.to_dep_node(*tcx.dep_context(), &key));\n-        force_query_with_job(tcx, key, job_id, dep_node, query, compute)\n-    } else {\n-        // `to_dep_node` is expensive for some `DepKind`s.\n-        let dep_node = dep_node.unwrap_or_else(|| query.to_dep_node(*tcx.dep_context(), &key));\n-        // The diagnostics for this query will be\n-        // promoted to the current session during\n-        // `try_mark_green()`, so we can ignore them here.\n-        let loaded = tcx.start_query(job_id, None, || {\n-            try_load_from_disk_and_cache_in_memory(tcx, &key, &dep_node, query, compute)\n-        });\n-        if let Some((result, dep_node_index)) = loaded {\n-            (result, dep_node_index)\n+        let dep_node = dep_node_opt.unwrap_or_else(|| query.to_dep_node(*tcx.dep_context(), &key));\n+\n+        if query.eval_always {\n+            tcx.dep_context().dep_graph().with_eval_always_task(\n+                dep_node,\n+                *tcx.dep_context(),\n+                key,\n+                compute,\n+                query.hash_result,\n+            )\n+        } else {\n+            tcx.dep_context().dep_graph().with_task(\n+                dep_node,\n+                *tcx.dep_context(),\n+                key,\n+                compute,\n+                query.hash_result,\n+            )\n+        }\n+    });\n+\n+    prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n+\n+    let diagnostics = diagnostics.into_inner();\n+    let side_effects = QuerySideEffects { diagnostics };\n+\n+    if unlikely!(!side_effects.is_empty()) {\n+        if query.anon {\n+            tcx.store_side_effects_for_anon_node(dep_node_index, side_effects);\n         } else {\n-            force_query_with_job(tcx, key, job_id, dep_node, query, compute)\n+            tcx.store_side_effects(dep_node_index, side_effects);\n         }\n     }\n+\n+    (result, dep_node_index)\n }\n \n fn try_load_from_disk_and_cache_in_memory<CTX, K, V>(\n@@ -641,53 +653,6 @@ fn incremental_verify_ich<CTX, K, V: Debug>(\n     }\n }\n \n-fn force_query_with_job<CTX, K, V>(\n-    tcx: CTX,\n-    key: K,\n-    job_id: QueryJobId<CTX::DepKind>,\n-    dep_node: DepNode<CTX::DepKind>,\n-    query: &QueryVtable<CTX, K, V>,\n-    compute: fn(CTX::DepContext, K) -> V,\n-) -> (V, DepNodeIndex)\n-where\n-    CTX: QueryContext,\n-    K: Debug,\n-{\n-    let prof_timer = tcx.dep_context().profiler().query_provider();\n-\n-    let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n-        tcx.start_query(job_id, diagnostics, || {\n-            if query.eval_always {\n-                tcx.dep_context().dep_graph().with_eval_always_task(\n-                    dep_node,\n-                    *tcx.dep_context(),\n-                    key,\n-                    compute,\n-                    query.hash_result,\n-                )\n-            } else {\n-                tcx.dep_context().dep_graph().with_task(\n-                    dep_node,\n-                    *tcx.dep_context(),\n-                    key,\n-                    compute,\n-                    query.hash_result,\n-                )\n-            }\n-        })\n-    });\n-\n-    prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n-\n-    let side_effects = QuerySideEffects { diagnostics };\n-\n-    if unlikely!(!side_effects.is_empty()) && dep_node.kind != DepKind::NULL {\n-        tcx.store_side_effects(dep_node_index, side_effects);\n-    }\n-\n-    (result, dep_node_index)\n-}\n-\n /// Ensure that either this query has all green inputs or been executed.\n /// Executing `query::ensure(D)` is considered a read of the dep-node `D`.\n /// Returns true if the query should still run."}]}