{"sha": "595cad929cb1ef81e80f93194137a94ad857d823", "node_id": "C_kwDOAAsO6NoAKDU5NWNhZDkyOWNiMWVmODFlODBmOTMxOTQxMzdhOTRhZDg1N2Q4MjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-22T13:36:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-22T13:36:24Z"}, "message": "Auto merge of #2035 - RalfJung:small-bitmask, r=RalfJung\n\nportable-simd: test bitmasks smaller than a byte\n\nBlocked on https://github.com/rust-lang/portable-simd/pull/267 propagating to the [rustc repo](https://github.com/rust-lang/rust/tree/master/library/portable-simd)", "tree": {"sha": "9adcc93353578f8d6d5e9a15c3eca44e6a5b2009", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9adcc93353578f8d6d5e9a15c3eca44e6a5b2009"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/595cad929cb1ef81e80f93194137a94ad857d823", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/595cad929cb1ef81e80f93194137a94ad857d823", "html_url": "https://github.com/rust-lang/rust/commit/595cad929cb1ef81e80f93194137a94ad857d823", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/595cad929cb1ef81e80f93194137a94ad857d823/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cb9ccb28442342c7450d516c7a168abbca3e327", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cb9ccb28442342c7450d516c7a168abbca3e327", "html_url": "https://github.com/rust-lang/rust/commit/1cb9ccb28442342c7450d516c7a168abbca3e327"}, {"sha": "45eeaa362bfd3193b508123fac1163c8c3a1ab3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/45eeaa362bfd3193b508123fac1163c8c3a1ab3b", "html_url": "https://github.com/rust-lang/rust/commit/45eeaa362bfd3193b508123fac1163c8c3a1ab3b"}], "stats": {"total": 69, "additions": 34, "deletions": 35}, "files": [{"sha": "b54ff9e100ed063aab157bd71491cbb319b01e2f", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/595cad929cb1ef81e80f93194137a94ad857d823/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/595cad929cb1ef81e80f93194137a94ad857d823/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=595cad929cb1ef81e80f93194137a94ad857d823", "patch": "@@ -1 +1 @@\n-e7a9c1141698bc4557b9da3d3fce2bf75339427f\n+41419e70366962c9a878bfe673ef4df38db6f7f1"}, {"sha": "d29b356d268dcbab00d8b2074e0ebe65dca15a53", "filename": "tests/fail/intrinsics/simd-float-to-int.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/595cad929cb1ef81e80f93194137a94ad857d823/tests%2Ffail%2Fintrinsics%2Fsimd-float-to-int.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/595cad929cb1ef81e80f93194137a94ad857d823/tests%2Ffail%2Fintrinsics%2Fsimd-float-to-int.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fintrinsics%2Fsimd-float-to-int.stderr?ref=595cad929cb1ef81e80f93194137a94ad857d823", "patch": "@@ -1,19 +1,18 @@\n error: Undefined Behavior: `float_to_int_unchecked` intrinsic called on 3.40282347E+38 which cannot be represented in target type `i32`\n-  --> RUSTLIB/core/src/../../portable-simd/crates/core_simd/src/round.rs:LL:CC\n+  --> RUSTLIB/core/src/../../portable-simd/crates/core_simd/src/vector.rs:LL:CC\n    |\n-LL | implement! { f32 }\n-   | ^^^^^^^^^^^^^^^^^^ `float_to_int_unchecked` intrinsic called on 3.40282347E+38 which cannot be represented in target type `i32`\n+LL |         unsafe { intrinsics::simd_cast(self) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `float_to_int_unchecked` intrinsic called on 3.40282347E+38 which cannot be represented in target type `i32`\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: backtrace:\n-   = note: inside `core::core_simd::round::<impl std::simd::Simd<f32, 2>>::to_int_unchecked::<i32>` at RUSTLIB/core/src/../../portable-simd/crates/core_simd/src/round.rs:LL:CC\n+   = note: inside `std::simd::Simd::<f32, 2>::to_int_unchecked::<i32>` at RUSTLIB/core/src/../../portable-simd/crates/core_simd/src/vector.rs:LL:CC\n note: inside `main` at $DIR/simd-float-to-int.rs:LL:CC\n   --> $DIR/simd-float-to-int.rs:LL:CC\n    |\n LL |         let _x: i32x2 = f32x2::from_array([f32::MAX, f32::MIN]).to_int_unchecked();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `implement` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "ec70eea6b17718589a73b4ac73501cfe44490fde", "filename": "tests/pass/portable-simd.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/595cad929cb1ef81e80f93194137a94ad857d823/tests%2Fpass%2Fportable-simd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/595cad929cb1ef81e80f93194137a94ad857d823/tests%2Fpass%2Fportable-simd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fportable-simd.rs?ref=595cad929cb1ef81e80f93194137a94ad857d823", "patch": "@@ -13,20 +13,20 @@ fn simd_ops_f32() {\n     assert_eq!(a / f32x4::splat(2.0), f32x4::splat(5.0));\n     assert_eq!(a % b, f32x4::from_array([0.0, 0.0, 1.0, 2.0]));\n     assert_eq!(b.abs(), f32x4::from_array([1.0, 2.0, 3.0, 4.0]));\n-    assert_eq!(a.max(b * f32x4::splat(4.0)), f32x4::from_array([10.0, 10.0, 12.0, 10.0]));\n-    assert_eq!(a.min(b * f32x4::splat(4.0)), f32x4::from_array([4.0, 8.0, 10.0, -16.0]));\n+    assert_eq!(a.simd_max(b * f32x4::splat(4.0)), f32x4::from_array([10.0, 10.0, 12.0, 10.0]));\n+    assert_eq!(a.simd_min(b * f32x4::splat(4.0)), f32x4::from_array([4.0, 8.0, 10.0, -16.0]));\n \n     assert_eq!(a.mul_add(b, a), (a * b) + a);\n     assert_eq!(b.mul_add(b, a), (b * b) + a);\n     assert_eq!((a * a).sqrt(), a);\n     assert_eq!((b * b).sqrt(), b.abs());\n \n-    assert_eq!(a.lanes_eq(f32x4::splat(5.0) * b), Mask::from_array([false, true, false, false]));\n-    assert_eq!(a.lanes_ne(f32x4::splat(5.0) * b), Mask::from_array([true, false, true, true]));\n-    assert_eq!(a.lanes_le(f32x4::splat(5.0) * b), Mask::from_array([false, true, true, false]));\n-    assert_eq!(a.lanes_lt(f32x4::splat(5.0) * b), Mask::from_array([false, false, true, false]));\n-    assert_eq!(a.lanes_ge(f32x4::splat(5.0) * b), Mask::from_array([true, true, false, true]));\n-    assert_eq!(a.lanes_gt(f32x4::splat(5.0) * b), Mask::from_array([true, false, false, true]));\n+    assert_eq!(a.simd_eq(f32x4::splat(5.0) * b), Mask::from_array([false, true, false, false]));\n+    assert_eq!(a.simd_ne(f32x4::splat(5.0) * b), Mask::from_array([true, false, true, true]));\n+    assert_eq!(a.simd_le(f32x4::splat(5.0) * b), Mask::from_array([false, true, true, false]));\n+    assert_eq!(a.simd_lt(f32x4::splat(5.0) * b), Mask::from_array([false, false, true, false]));\n+    assert_eq!(a.simd_ge(f32x4::splat(5.0) * b), Mask::from_array([true, true, false, true]));\n+    assert_eq!(a.simd_gt(f32x4::splat(5.0) * b), Mask::from_array([true, false, false, true]));\n \n     assert_eq!(a.reduce_sum(), 40.0);\n     assert_eq!(b.reduce_sum(), 2.0);\n@@ -38,13 +38,13 @@ fn simd_ops_f32() {\n     assert_eq!(b.reduce_min(), -4.0);\n \n     assert_eq!(\n-        f32x2::from_array([0.0, f32::NAN]).max(f32x2::from_array([f32::NAN, 0.0])),\n+        f32x2::from_array([0.0, f32::NAN]).simd_max(f32x2::from_array([f32::NAN, 0.0])),\n         f32x2::from_array([0.0, 0.0])\n     );\n     assert_eq!(f32x2::from_array([0.0, f32::NAN]).reduce_max(), 0.0);\n     assert_eq!(f32x2::from_array([f32::NAN, 0.0]).reduce_max(), 0.0);\n     assert_eq!(\n-        f32x2::from_array([0.0, f32::NAN]).min(f32x2::from_array([f32::NAN, 0.0])),\n+        f32x2::from_array([0.0, f32::NAN]).simd_min(f32x2::from_array([f32::NAN, 0.0])),\n         f32x2::from_array([0.0, 0.0])\n     );\n     assert_eq!(f32x2::from_array([0.0, f32::NAN]).reduce_min(), 0.0);\n@@ -62,20 +62,20 @@ fn simd_ops_f64() {\n     assert_eq!(a / f64x4::splat(2.0), f64x4::splat(5.0));\n     assert_eq!(a % b, f64x4::from_array([0.0, 0.0, 1.0, 2.0]));\n     assert_eq!(b.abs(), f64x4::from_array([1.0, 2.0, 3.0, 4.0]));\n-    assert_eq!(a.max(b * f64x4::splat(4.0)), f64x4::from_array([10.0, 10.0, 12.0, 10.0]));\n-    assert_eq!(a.min(b * f64x4::splat(4.0)), f64x4::from_array([4.0, 8.0, 10.0, -16.0]));\n+    assert_eq!(a.simd_max(b * f64x4::splat(4.0)), f64x4::from_array([10.0, 10.0, 12.0, 10.0]));\n+    assert_eq!(a.simd_min(b * f64x4::splat(4.0)), f64x4::from_array([4.0, 8.0, 10.0, -16.0]));\n \n     assert_eq!(a.mul_add(b, a), (a * b) + a);\n     assert_eq!(b.mul_add(b, a), (b * b) + a);\n     assert_eq!((a * a).sqrt(), a);\n     assert_eq!((b * b).sqrt(), b.abs());\n \n-    assert_eq!(a.lanes_eq(f64x4::splat(5.0) * b), Mask::from_array([false, true, false, false]));\n-    assert_eq!(a.lanes_ne(f64x4::splat(5.0) * b), Mask::from_array([true, false, true, true]));\n-    assert_eq!(a.lanes_le(f64x4::splat(5.0) * b), Mask::from_array([false, true, true, false]));\n-    assert_eq!(a.lanes_lt(f64x4::splat(5.0) * b), Mask::from_array([false, false, true, false]));\n-    assert_eq!(a.lanes_ge(f64x4::splat(5.0) * b), Mask::from_array([true, true, false, true]));\n-    assert_eq!(a.lanes_gt(f64x4::splat(5.0) * b), Mask::from_array([true, false, false, true]));\n+    assert_eq!(a.simd_eq(f64x4::splat(5.0) * b), Mask::from_array([false, true, false, false]));\n+    assert_eq!(a.simd_ne(f64x4::splat(5.0) * b), Mask::from_array([true, false, true, true]));\n+    assert_eq!(a.simd_le(f64x4::splat(5.0) * b), Mask::from_array([false, true, true, false]));\n+    assert_eq!(a.simd_lt(f64x4::splat(5.0) * b), Mask::from_array([false, false, true, false]));\n+    assert_eq!(a.simd_ge(f64x4::splat(5.0) * b), Mask::from_array([true, true, false, true]));\n+    assert_eq!(a.simd_gt(f64x4::splat(5.0) * b), Mask::from_array([true, false, false, true]));\n \n     assert_eq!(a.reduce_sum(), 40.0);\n     assert_eq!(b.reduce_sum(), 2.0);\n@@ -87,13 +87,13 @@ fn simd_ops_f64() {\n     assert_eq!(b.reduce_min(), -4.0);\n \n     assert_eq!(\n-        f64x2::from_array([0.0, f64::NAN]).max(f64x2::from_array([f64::NAN, 0.0])),\n+        f64x2::from_array([0.0, f64::NAN]).simd_max(f64x2::from_array([f64::NAN, 0.0])),\n         f64x2::from_array([0.0, 0.0])\n     );\n     assert_eq!(f64x2::from_array([0.0, f64::NAN]).reduce_max(), 0.0);\n     assert_eq!(f64x2::from_array([f64::NAN, 0.0]).reduce_max(), 0.0);\n     assert_eq!(\n-        f64x2::from_array([0.0, f64::NAN]).min(f64x2::from_array([f64::NAN, 0.0])),\n+        f64x2::from_array([0.0, f64::NAN]).simd_min(f64x2::from_array([f64::NAN, 0.0])),\n         f64x2::from_array([0.0, 0.0])\n     );\n     assert_eq!(f64x2::from_array([0.0, f64::NAN]).reduce_min(), 0.0);\n@@ -113,8 +113,8 @@ fn simd_ops_i32() {\n     assert_eq!(a % b, i32x4::from_array([0, 0, 1, 2]));\n     assert_eq!(i32x2::splat(i32::MIN) % i32x2::splat(-1), i32x2::splat(0));\n     assert_eq!(b.abs(), i32x4::from_array([1, 2, 3, 4]));\n-    assert_eq!(a.max(b * i32x4::splat(4)), i32x4::from_array([10, 10, 12, 10]));\n-    assert_eq!(a.min(b * i32x4::splat(4)), i32x4::from_array([4, 8, 10, -16]));\n+    assert_eq!(a.simd_max(b * i32x4::splat(4)), i32x4::from_array([10, 10, 12, 10]));\n+    assert_eq!(a.simd_min(b * i32x4::splat(4)), i32x4::from_array([4, 8, 10, -16]));\n \n     assert_eq!(\n         i8x4::from_array([i8::MAX, -23, 23, i8::MIN]).saturating_add(i8x4::from_array([\n@@ -160,12 +160,12 @@ fn simd_ops_i32() {\n     assert_eq!(b | i32x4::splat(2), i32x4::from_array([3, 2, 3, -2]));\n     assert_eq!(b ^ i32x4::splat(2), i32x4::from_array([3, 0, 1, -2]));\n \n-    assert_eq!(a.lanes_eq(i32x4::splat(5) * b), Mask::from_array([false, true, false, false]));\n-    assert_eq!(a.lanes_ne(i32x4::splat(5) * b), Mask::from_array([true, false, true, true]));\n-    assert_eq!(a.lanes_le(i32x4::splat(5) * b), Mask::from_array([false, true, true, false]));\n-    assert_eq!(a.lanes_lt(i32x4::splat(5) * b), Mask::from_array([false, false, true, false]));\n-    assert_eq!(a.lanes_ge(i32x4::splat(5) * b), Mask::from_array([true, true, false, true]));\n-    assert_eq!(a.lanes_gt(i32x4::splat(5) * b), Mask::from_array([true, false, false, true]));\n+    assert_eq!(a.simd_eq(i32x4::splat(5) * b), Mask::from_array([false, true, false, false]));\n+    assert_eq!(a.simd_ne(i32x4::splat(5) * b), Mask::from_array([true, false, true, true]));\n+    assert_eq!(a.simd_le(i32x4::splat(5) * b), Mask::from_array([false, true, true, false]));\n+    assert_eq!(a.simd_lt(i32x4::splat(5) * b), Mask::from_array([false, false, true, false]));\n+    assert_eq!(a.simd_ge(i32x4::splat(5) * b), Mask::from_array([true, true, false, true]));\n+    assert_eq!(a.simd_gt(i32x4::splat(5) * b), Mask::from_array([true, false, false, true]));\n \n     assert_eq!(a.reduce_sum(), 40);\n     assert_eq!(b.reduce_sum(), 2);\n@@ -201,7 +201,7 @@ fn simd_mask() {\n     let values = [false, false, false, true];\n     let mask = Mask::<i64, 4>::from_array(values);\n     let bitmask = mask.to_bitmask();\n-    // FIXME fails until https://github.com/rust-lang/portable-simd/pull/267 lands: assert_eq!(bitmask, 0b1000);\n+    assert_eq!(bitmask, 0b1000);\n     assert_eq!(Mask::<i64, 4>::from_bitmask(bitmask), mask);\n }\n "}]}