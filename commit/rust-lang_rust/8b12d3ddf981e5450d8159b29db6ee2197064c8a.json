{"sha": "8b12d3ddf981e5450d8159b29db6ee2197064c8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiMTJkM2RkZjk4MWU1NDUwZDgxNTliMjlkYjZlZTIxOTcwNjRjOGE=", "commit": {"author": {"name": "GuillaumeGomez", "email": "guillaume1.gomez@gmail.com", "date": "2015-02-03T22:31:06Z"}, "committer": {"name": "GuillaumeGomez", "email": "guillaume1.gomez@gmail.com", "date": "2015-02-06T10:59:10Z"}, "message": "Libsyntax has been updated", "tree": {"sha": "b15555d7f66257a4a2dbd58aa6e14db9a3521f61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b15555d7f66257a4a2dbd58aa6e14db9a3521f61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b12d3ddf981e5450d8159b29db6ee2197064c8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b12d3ddf981e5450d8159b29db6ee2197064c8a", "html_url": "https://github.com/rust-lang/rust/commit/8b12d3ddf981e5450d8159b29db6ee2197064c8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b12d3ddf981e5450d8159b29db6ee2197064c8a/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12f1f4c5467b0f4cbdb66c67eca7e5227dbb1284", "url": "https://api.github.com/repos/rust-lang/rust/commits/12f1f4c5467b0f4cbdb66c67eca7e5227dbb1284", "html_url": "https://github.com/rust-lang/rust/commit/12f1f4c5467b0f4cbdb66c67eca7e5227dbb1284"}], "stats": {"total": 214, "additions": 93, "deletions": 121}, "files": [{"sha": "38985a8ce4035bf55737d00cb29310c44127755b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -249,11 +249,11 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n                             span_warn!(cx.tcx.sess, p.span, E0170,\n                                 \"pattern binding `{}` is named the same as one \\\n                                  of the variants of the type `{}`\",\n-                                token::get_ident(ident.node).get(), ty_to_string(cx.tcx, pat_ty));\n+                                token::get_ident(&ident.node)[], ty_to_string(cx.tcx, pat_ty));\n                             span_help!(cx.tcx.sess, p.span,\n                                 \"if you meant to match on a variant, \\\n                                  consider making the path in the pattern qualified: `{}::{}`\",\n-                                ty_to_string(cx.tcx, pat_ty), token::get_ident(ident.node).get());\n+                                ty_to_string(cx.tcx, pat_ty), &token::get_ident(ident.node)[]);\n                         }\n                     }\n                 }"}, {"sha": "c33d10bfbab39aaef7a08149d03304f76cfe0230", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -329,7 +329,7 @@ mod svh_visitor {\n             // macro invocations, namely macro_rules definitions,\n             // *can* appear as items, even in the expanded crate AST.\n \n-            if macro_name(mac).get() == \"macro_rules\" {\n+            if &macro_name(mac)[] == \"macro_rules\" {\n                 // Pretty-printing definition to a string strips out\n                 // surface artifacts (currently), such as the span\n                 // information, yielding a content-based hash."}, {"sha": "7849b7548c4bd9d24bebb62007563bbb868a6acd", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -68,7 +68,6 @@ use std::fmt::Show;\n use std::num::Int;\n use std::rc::Rc;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n-use std::ops::Deref;\n \n // FIXME #6993: in librustc, uses of \"ident\" should be replaced\n // by just \"Name\".\n@@ -113,13 +112,13 @@ impl fmt::Display for Ident {\n impl fmt::Debug for Name {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Name(nm) = *self;\n-        write!(f, \"{:?}({})\", token::get_name(*self).deref(), nm)\n+        write!(f, \"{:?}({})\", token::get_name(*self), nm)\n     }\n }\n \n impl fmt::Display for Name {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(token::get_name(*self).deref(), f)\n+        fmt::Display::fmt(&token::get_name(*self)[], f)\n     }\n }\n \n@@ -175,7 +174,7 @@ impl Name {\n     pub fn as_str<'a>(&'a self) -> &'a str {\n         unsafe {\n             // FIXME #12938: can't use copy_lifetime since &str isn't a &T\n-            ::std::mem::transmute::<&str,&str>(token::get_name(*self).deref())\n+            ::std::mem::transmute::<&str,&str>(&token::get_name(*self)[])\n         }\n     }\n \n@@ -194,7 +193,7 @@ pub type Mrk = u32;\n \n impl Encodable for Ident {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(token::get_ident(*self).deref())\n+        s.emit_str(&token::get_ident(*self)[])\n     }\n }\n "}, {"sha": "b8d4c90f74523fdb48c575dd7b13c0079ed7288b", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -23,12 +23,11 @@ use visit;\n \n use std::cmp;\n use std::u32;\n-use std::ops::Deref;\n \n pub fn path_name_i(idents: &[Ident]) -> String {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n     idents.iter().map(|i| {\n-        token::get_ident(*i).deref().to_string()\n+        token::get_ident(*i).to_string()\n     }).collect::<Vec<String>>().connect(\"::\")\n }\n "}, {"sha": "cd82d7c9b14890905173744fe7c5d0f156db24d4", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -29,7 +29,6 @@ use std::cell::{RefCell, Cell};\n use std::collections::BitvSet;\n use std::collections::HashSet;\n use std::fmt;\n-use std::ops::Deref;\n \n thread_local! { static USED_ATTRS: RefCell<BitvSet> = RefCell::new(BitvSet::new()) }\n \n@@ -45,7 +44,7 @@ pub fn is_used(attr: &Attribute) -> bool {\n \n pub trait AttrMetaMethods {\n     fn check_name(&self, name: &str) -> bool {\n-        name == self.name().deref()\n+        name == &self.name()[]\n     }\n \n     /// Retrieve the name of the meta item, e.g. `foo` in `#[foo]`,\n@@ -63,7 +62,7 @@ pub trait AttrMetaMethods {\n \n impl AttrMetaMethods for Attribute {\n     fn check_name(&self, name: &str) -> bool {\n-        let matches = name == self.name().deref();\n+        let matches = name == &self.name()[];\n         if matches {\n             mark_used(self);\n         }\n@@ -143,7 +142,7 @@ impl AttributeMethods for Attribute {\n             let meta = mk_name_value_item_str(\n                 InternedString::new(\"doc\"),\n                 token::intern_and_get_ident(&strip_doc_comment_decoration(\n-                        comment.deref())[]));\n+                        &comment[])[]));\n             if self.node.style == ast::AttrOuter {\n                 f(&mk_attr_outer(self.node.id, meta))\n             } else {\n@@ -210,7 +209,7 @@ pub fn mk_attr_outer(id: AttrId, item: P<MetaItem>) -> Attribute {\n pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos,\n                            hi: BytePos)\n                            -> Attribute {\n-    let style = doc_comment_style(text.deref());\n+    let style = doc_comment_style(&text[]);\n     let lit = spanned(lo, hi, ast::LitStr(text, ast::CookedStr));\n     let attr = Attribute_ {\n         id: id,\n@@ -327,11 +326,11 @@ pub fn requests_inline(attrs: &[Attribute]) -> bool {\n /// Tests if a cfg-pattern matches the cfg set\n pub fn cfg_matches(diagnostic: &SpanHandler, cfgs: &[P<MetaItem>], cfg: &ast::MetaItem) -> bool {\n     match cfg.node {\n-        ast::MetaList(ref pred, ref mis) if pred.deref() == \"any\" =>\n+        ast::MetaList(ref pred, ref mis) if &pred[] == \"any\" =>\n             mis.iter().any(|mi| cfg_matches(diagnostic, cfgs, &**mi)),\n-        ast::MetaList(ref pred, ref mis) if pred.deref() == \"all\" =>\n+        ast::MetaList(ref pred, ref mis) if &pred[] == \"all\" =>\n             mis.iter().all(|mi| cfg_matches(diagnostic, cfgs, &**mi)),\n-        ast::MetaList(ref pred, ref mis) if pred.deref() == \"not\" => {\n+        ast::MetaList(ref pred, ref mis) if &pred[] == \"not\" => {\n             if mis.len() != 1 {\n                 diagnostic.span_err(cfg.span, \"expected 1 cfg-pattern\");\n                 return false;\n@@ -383,7 +382,7 @@ fn find_stability_generic<'a,\n \n     'outer: for attr in attrs {\n         let tag = attr.name();\n-        let tag = tag.deref();\n+        let tag = &tag[];\n         if tag != \"deprecated\" && tag != \"unstable\" && tag != \"stable\" {\n             continue // not a stability level\n         }\n@@ -405,7 +404,7 @@ fn find_stability_generic<'a,\n                             }\n                         }\n                     }\n-                    if meta.name().deref() == \"since\" {\n+                    if &meta.name()[] == \"since\" {\n                         match meta.value_str() {\n                             Some(v) => since = Some(v),\n                             None => {\n@@ -414,7 +413,7 @@ fn find_stability_generic<'a,\n                             }\n                         }\n                     }\n-                    if meta.name().deref() == \"reason\" {\n+                    if &meta.name()[] == \"reason\" {\n                         match meta.value_str() {\n                             Some(v) => reason = Some(v),\n                             None => {\n@@ -522,11 +521,11 @@ pub fn find_repr_attrs(diagnostic: &SpanHandler, attr: &Attribute) -> Vec<ReprAt\n             for item in items {\n                 match item.node {\n                     ast::MetaWord(ref word) => {\n-                        let hint = match word.deref() {\n+                        let hint = match &word[] {\n                             // Can't use \"extern\" because it's not a lexical identifier.\n                             \"C\" => Some(ReprExtern),\n                             \"packed\" => Some(ReprPacked),\n-                            _ => match int_type_of_word(word.deref()) {\n+                            _ => match int_type_of_word(&word[]) {\n                                 Some(ity) => Some(ReprInt(item.span, ity)),\n                                 None => {\n                                     // Not a word we recognize"}, {"sha": "4a3c1f48252fc2a87bc62905b5bbda484ebd88b9", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -10,7 +10,6 @@\n \n use std::cell::RefCell;\n use std::collections::BTreeMap;\n-use std::ops::Deref;\n \n use ast;\n use ast::{Ident, Name, TokenTree};\n@@ -59,7 +58,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n         match diagnostics.insert(code.name, span) {\n             Some(previous_span) => {\n                 ecx.span_warn(span, &format!(\n-                    \"diagnostic code {} already used\", token::get_ident(code).deref()\n+                    \"diagnostic code {} already used\", &token::get_ident(code)[]\n                 )[]);\n                 ecx.span_note(previous_span, \"previous invocation\");\n             },\n@@ -70,7 +69,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n     with_registered_diagnostics(|diagnostics| {\n         if !diagnostics.contains_key(&code.name) {\n             ecx.span_err(span, &format!(\n-                \"used diagnostic code {} not registered\", token::get_ident(code).deref()\n+                \"used diagnostic code {} not registered\", &token::get_ident(code)[]\n             )[]);\n         }\n     });\n@@ -95,12 +94,12 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n     with_registered_diagnostics(|diagnostics| {\n         if diagnostics.insert(code.name, description).is_some() {\n             ecx.span_err(span, &format!(\n-                \"diagnostic code {} already registered\", token::get_ident(*code).deref()\n+                \"diagnostic code {} already registered\", &token::get_ident(*code)[]\n             )[]);\n         }\n     });\n     let sym = Ident::new(token::gensym(&(\n-        \"__register_diagnostic_\".to_string() + token::get_ident(*code).deref()\n+        \"__register_diagnostic_\".to_string() + &token::get_ident(*code)[]\n     )[]));\n     MacItems::new(vec![quote_item!(ecx, mod $sym {}).unwrap()].into_iter())\n }"}, {"sha": "8c710545cb0e8bf2ad2012e5b03fd17d8dbcc70c", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -22,8 +22,6 @@ use parse::token::InternedString;\n use parse::token;\n use ptr::P;\n \n-use std::ops::Deref;\n-\n enum State {\n     Asm,\n     Outputs,\n@@ -104,7 +102,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     // It's the opposite of '=&' which means that the memory\n                     // cannot be shared with any other operand (usually when\n                     // a register is clobbered early.)\n-                    let output = match constraint.deref().slice_shift_char() {\n+                    let output = match constraint.slice_shift_char() {\n                         Some(('=', _)) => None,\n                         Some(('+', operand)) => {\n                             Some(token::intern_and_get_ident(&format!(\n@@ -131,9 +129,9 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n                     let (constraint, _str_style) = p.parse_str();\n \n-                    if constraint.deref().starts_with(\"=\") {\n+                    if constraint.starts_with(\"=\") {\n                         cx.span_err(p.last_span, \"input operand constraint contains '='\");\n-                    } else if constraint.deref().starts_with(\"+\") {\n+                    } else if constraint.starts_with(\"+\") {\n                         cx.span_err(p.last_span, \"input operand constraint contains '+'\");\n                     }\n \n@@ -215,7 +213,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     MacExpr::new(P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprInlineAsm(ast::InlineAsm {\n-            asm: token::intern_and_get_ident(asm.deref()),\n+            asm: token::intern_and_get_ident(&asm[]),\n             asm_str_style: asm_str_style.unwrap(),\n             outputs: outputs,\n             inputs: inputs,"}, {"sha": "b5f6893a8c279f933ec8475f652a896c1938cca9", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -28,7 +28,6 @@ use fold::Folder;\n \n use std::collections::HashMap;\n use std::rc::Rc;\n-use std::ops::Deref;\n \n pub trait ItemDecorator {\n     fn expand(&self,\n@@ -791,7 +790,7 @@ pub fn get_single_str_from_tts(cx: &mut ExtCtxt,\n         cx.span_err(sp, &format!(\"{} takes 1 argument\", name)[]);\n     }\n     expr_to_string(cx, ret, \"argument must be a string literal\").map(|(s, _)| {\n-        s.deref().to_string()\n+        s.to_string()\n     })\n }\n "}, {"sha": "55faf692e98f31867e2bba6e9b16da40cbf982bc", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -21,8 +21,6 @@ use parse::token::InternedString;\n use parse::token;\n use ptr::P;\n \n-use std::ops::Deref;\n-\n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n     pub use ext;\n@@ -577,7 +575,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn expr_field_access(&self, sp: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n         let field_name = token::get_ident(ident);\n         let field_span = Span {\n-            lo: sp.lo - Pos::from_usize(field_name.deref().len()),\n+            lo: sp.lo - Pos::from_usize(field_name.len()),\n             hi: sp.hi,\n             expn_id: sp.expn_id,\n         };"}, {"sha": "849d8bff36575aedba9333c731acf2156e3da9f7", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -15,7 +15,6 @@ use ext::build::AstBuilder;\n use parse::token;\n \n use std::string::String;\n-use std::ops::Deref;\n \n pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                          sp: codemap::Span,\n@@ -33,7 +32,7 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                     ast::LitStr(ref s, _) |\n                     ast::LitFloat(ref s, _) |\n                     ast::LitFloatUnsuffixed(ref s) => {\n-                        accumulator.push_str(s.deref());\n+                        accumulator.push_str(&s[]);\n                     }\n                     ast::LitChar(c) => {\n                         accumulator.push(c);"}, {"sha": "14de5803604af1898d2af7b4a1e91776a337c7c1", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -16,8 +16,6 @@ use parse::token;\n use parse::token::{str_to_ident};\n use ptr::P;\n \n-use std::ops::Deref;\n-\n pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                               -> Box<base::MacResult+'cx> {\n     let mut res_str = String::new();\n@@ -33,7 +31,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]\n         } else {\n             match *e {\n                 ast::TtToken(_, token::Ident(ident, _)) => {\n-                    res_str.push_str(token::get_ident(ident).deref())\n+                    res_str.push_str(&token::get_ident(ident)[])\n                 },\n                 _ => {\n                     cx.span_err(sp, \"concat_idents! requires ident args.\");"}, {"sha": "1c82ca5d2add78c3f772675cb1b78d51f284b9fb", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -15,8 +15,6 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use ptr::P;\n \n-use std::ops::Deref;\n-\n pub fn expand_deriving_bound<F>(cx: &mut ExtCtxt,\n                                 span: Span,\n                                 mitem: &MetaItem,\n@@ -26,7 +24,7 @@ pub fn expand_deriving_bound<F>(cx: &mut ExtCtxt,\n {\n     let name = match mitem.node {\n         MetaWord(ref tname) => {\n-            match tname.deref() {\n+            match &tname[] {\n                 \"Copy\" => \"Copy\",\n                 \"Send\" | \"Sync\" => {\n                     return cx.span_err(span,"}, {"sha": "28573ef757b1295c7efc55eefe6e1e92f5048213", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -189,7 +189,6 @@ use self::StructType::*;\n \n use std::cell::RefCell;\n use std::vec;\n-use std::ops::Deref;\n \n use abi::Abi;\n use abi;\n@@ -364,7 +363,7 @@ impl<'a> TraitDef<'a> {\n         // generated implementations are linted\n         let mut attrs = newitem.attrs.clone();\n         attrs.extend(item.attrs.iter().filter(|a| {\n-            match a.name().deref() {\n+            match &a.name()[] {\n                 \"allow\" | \"warn\" | \"deny\" | \"forbid\" => true,\n                 _ => false,\n             }"}, {"sha": "318b748ad7ff22354064a61319fd198d165828fb", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -18,8 +18,6 @@ use ext::base::ExtCtxt;\n use codemap::Span;\n use ptr::P;\n \n-use std::ops::Deref;\n-\n pub mod bounds;\n pub mod clone;\n pub mod encodable;\n@@ -76,7 +74,7 @@ pub fn expand_meta_derive(cx: &mut ExtCtxt,\n                                                    |i| push(i)))\n                         }\n \n-                        match tname.deref() {\n+                        match &tname[] {\n                             \"Clone\" => expand!(clone::expand_deriving_clone),\n \n                             \"Hash\" => expand!(hash::expand_deriving_hash),"}, {"sha": "49f766eb957a8fd0653e2cf682e81d989aec0a95", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -20,7 +20,6 @@ use parse::token;\n use ptr::P;\n \n use std::collections::HashMap;\n-use std::ops::Deref;\n \n pub fn expand_deriving_show<F>(cx: &mut ExtCtxt,\n                                span: Span,\n@@ -73,7 +72,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n         }\n     };\n \n-    let mut format_string = String::from_str(token::get_ident(name).deref());\n+    let mut format_string = String::from_str(&token::get_ident(name)[]);\n     // the internal fields we're actually formatting\n     let mut exprs = Vec::new();\n \n@@ -108,7 +107,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n \n                     let name = token::get_ident(field.name.unwrap());\n                     format_string.push_str(\" \");\n-                    format_string.push_str(name.deref());\n+                    format_string.push_str(&name[]);\n                     format_string.push_str(\": {:?}\");\n \n                     exprs.push(field.self_.clone());"}, {"sha": "2298686e8c1bb741e9ca8b414fd8f4db13b52903", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -23,7 +23,6 @@ use parse::token;\n \n use std::env;\n use std::os;\n-use std::ops::Deref;\n \n pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                               -> Box<base::MacResult+'cx> {\n@@ -103,9 +102,9 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         }\n     }\n \n-    let e = match os::getenv(var.deref()) {\n+    let e = match os::getenv(&var[]) {\n         None => {\n-            cx.span_err(sp, msg.deref());\n+            cx.span_err(sp, &msg[]);\n             cx.expr_usize(sp, 0)\n         }\n         Some(s) => cx.expr_str(sp, token::intern_and_get_ident(&s[]))"}, {"sha": "e43ca9db8b1ceb1e04c824342e4a65daad2cbd52", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -32,8 +32,6 @@ use util::small_vector::SmallVector;\n use visit;\n use visit::Visitor;\n \n-use std::ops::Deref;\n-\n pub fn expand_type(t: P<ast::Ty>,\n                    fld: &mut MacroExpander,\n                    impl_ty: Option<P<ast::Ty>>)\n@@ -377,7 +375,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                     fld.cx.span_err(\n                         pth.span,\n                         &format!(\"macro undefined: '{}!'\",\n-                                extnamestr.deref())[]);\n+                                &extnamestr[])[]);\n \n                     // let compilation continue\n                     None\n@@ -387,7 +385,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                         fld.cx.bt_push(ExpnInfo {\n                                 call_site: span,\n                                 callee: NameAndSpan {\n-                                    name: extnamestr.deref().to_string(),\n+                                    name: extnamestr.to_string(),\n                                     format: MacroBang,\n                                     span: exp_span,\n                                 },\n@@ -413,7 +411,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                                 fld.cx.span_err(\n                                     pth.span,\n                                     &format!(\"non-expression macro in expression position: {}\",\n-                                            &extnamestr.deref()[]\n+                                            &extnamestr[]\n                                             )[]);\n                                 return None;\n                             }\n@@ -424,7 +422,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                         fld.cx.span_err(\n                             pth.span,\n                             &format!(\"'{}' is not a tt-style macro\",\n-                                    extnamestr.deref())[]);\n+                                    &extnamestr[])[]);\n                         None\n                     }\n                 }\n@@ -508,14 +506,14 @@ fn expand_item_modifiers(mut it: P<ast::Item>, fld: &mut MacroExpander)\n     for attr in &modifiers {\n         let mname = attr.name();\n \n-        match fld.cx.syntax_env.find(&intern(mname.deref())) {\n+        match fld.cx.syntax_env.find(&intern(&mname[])) {\n             Some(rc) => match *rc {\n                 Modifier(ref mac) => {\n                     attr::mark_used(attr);\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: attr.span,\n                         callee: NameAndSpan {\n-                            name: mname.deref().to_string(),\n+                            name: mname.to_string(),\n                             format: MacroAttribute,\n                             span: None,\n                         }\n@@ -615,7 +613,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: it.span,\n                         callee: NameAndSpan {\n-                            name: extnamestr.deref().to_string(),\n+                            name: extnamestr.to_string(),\n                             format: MacroBang,\n                             span: span\n                         }\n@@ -628,13 +626,13 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n                         fld.cx.span_err(path_span,\n                                         &format!(\"macro {}! expects an ident argument\",\n-                                                extnamestr.deref())[]);\n+                                                &extnamestr[])[]);\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: it.span,\n                         callee: NameAndSpan {\n-                            name: extnamestr.deref().to_string(),\n+                            name: extnamestr.to_string(),\n                             format: MacroBang,\n                             span: span\n                         }\n@@ -653,7 +651,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: it.span,\n                         callee: NameAndSpan {\n-                            name: extnamestr.deref().to_string(),\n+                            name: extnamestr.to_string(),\n                             format: MacroBang,\n                             span: None,\n                         }\n@@ -679,7 +677,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                 _ => {\n                     fld.cx.span_err(it.span,\n                                     &format!(\"{}! is not legal in item position\",\n-                                            extnamestr.deref())[]);\n+                                            &extnamestr[])[]);\n                     return SmallVector::zero();\n                 }\n             }\n@@ -698,7 +696,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n         None => {\n             fld.cx.span_err(path_span,\n                             &format!(\"non-item macro in item position: {}\",\n-                                    extnamestr.deref())[]);\n+                                    &extnamestr[])[]);\n             return SmallVector::zero();\n         }\n     };\n@@ -952,7 +950,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: span,\n                         callee: NameAndSpan {\n-                            name: extnamestr.deref().to_string(),\n+                            name: extnamestr.to_string(),\n                             format: MacroBang,\n                             span: tt_span\n                         }\n@@ -970,7 +968,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                                 pth.span,\n                                 &format!(\n                                     \"non-pattern macro in pattern position: {}\",\n-                                    extnamestr.deref()\n+                                    &extnamestr[]\n                                     )[]\n                             );\n                             return DummyResult::raw_pat(span);\n@@ -983,7 +981,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                 _ => {\n                     fld.cx.span_err(span,\n                                     &format!(\"{}! is not legal in pattern position\",\n-                                            extnamestr.deref())[]);\n+                                            &extnamestr[])[]);\n                     return DummyResult::raw_pat(span);\n                 }\n             }\n@@ -1067,7 +1065,7 @@ fn expand_annotatable(a: Annotatable,\n     for attr in a.attrs() {\n         let mname = attr.name();\n \n-        match fld.cx.syntax_env.find(&intern(mname.deref())) {\n+        match fld.cx.syntax_env.find(&intern(&mname[])) {\n             Some(rc) => match *rc {\n                 Decorator(ref dec) => {\n                     let it = match a {\n@@ -1081,7 +1079,7 @@ fn expand_annotatable(a: Annotatable,\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: attr.span,\n                         callee: NameAndSpan {\n-                            name: mname.deref().to_string(),\n+                            name: mname.to_string(),\n                             format: MacroAttribute,\n                             span: None\n                         }\n@@ -1182,7 +1180,7 @@ fn modifiers(attrs: &Vec<ast::Attribute>,\n              fld: &MacroExpander)\n              -> (Vec<ast::Attribute>, Vec<ast::Attribute>) {\n     attrs.iter().cloned().partition(|attr| {\n-        match fld.cx.syntax_env.find(&intern(attr.name().deref())) {\n+        match fld.cx.syntax_env.find(&intern(&attr.name()[])) {\n             Some(rc) => match *rc {\n                 Modifier(_) => true,\n                 _ => false\n@@ -1197,7 +1195,7 @@ fn multi_modifiers(attrs: &[ast::Attribute],\n                    fld: &MacroExpander)\n                    -> (Vec<ast::Attribute>, Vec<ast::Attribute>) {\n     attrs.iter().cloned().partition(|attr| {\n-        match fld.cx.syntax_env.find(&intern(attr.name().deref())) {\n+        match fld.cx.syntax_env.find(&intern(&attr.name()[])) {\n             Some(rc) => match *rc {\n                 MultiModifier(_) => true,\n                 _ => false\n@@ -1222,14 +1220,14 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n     for attr in &modifiers {\n         let mname = attr.name();\n \n-        match fld.cx.syntax_env.find(&intern(mname.deref())) {\n+        match fld.cx.syntax_env.find(&intern(&mname[])) {\n             Some(rc) => match *rc {\n                 MultiModifier(ref mac) => {\n                     attr::mark_used(attr);\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: attr.span,\n                         callee: NameAndSpan {\n-                            name: mname.deref().to_string(),\n+                            name: mname.to_string(),\n                             format: MacroAttribute,\n                             span: None,\n                         }"}, {"sha": "af357e45a7c7aa05776ef0dbe3d890e8e01bb942", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -23,7 +23,6 @@ use ptr::P;\n \n use std::collections::HashMap;\n use std::iter::repeat;\n-use std::ops::Deref;\n \n #[derive(PartialEq)]\n enum ArgumentType {\n@@ -119,7 +118,8 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 }\n             };\n             let interned_name = token::get_ident(ident);\n-            let name = interned_name.deref();\n+            let name = &interned_name[];\n+\n             p.expect(&token::Eq);\n             let e = p.parse_expr();\n             match names.get(name) {\n@@ -673,7 +673,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         None => return DummyResult::raw_expr(sp)\n     };\n \n-    let mut parser = parse::Parser::new(fmt.deref());\n+    let mut parser = parse::Parser::new(&fmt[]);\n+\n     loop {\n         match parser.next() {\n             Some(piece) => {"}, {"sha": "67990895d071affa20ed0b129ef4b395e0adc9ec", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -25,8 +25,6 @@ use ptr::P;\n ///  as antiquotes (splices).\n \n pub mod rt {\n-    use std::ops::Deref;\n-\n     use ast;\n     use codemap::Spanned;\n     use ext::base::ExtCtxt;\n@@ -163,7 +161,7 @@ pub mod rt {\n \n     impl ToSource for ast::Ident {\n         fn to_source(&self) -> String {\n-            token::get_ident(*self).deref().to_string()\n+            token::get_ident(*self).to_string()\n         }\n     }\n "}, {"sha": "be02ba5ddc2209ff0fc6775f8c11a16fffb30740", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -22,7 +22,6 @@ use util::small_vector::SmallVector;\n \n use std::old_io::File;\n use std::rc::Rc;\n-use std::ops::Deref;\n \n // These macros all relate to the file system; they either return\n // the column/row/filename of the expression, or they include\n@@ -74,7 +73,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     let string = cx.mod_path()\n                    .iter()\n-                   .map(|x| token::get_ident(*x).deref().to_string())\n+                   .map(|x| token::get_ident(*x).to_string())\n                    .collect::<Vec<String>>()\n                    .connect(\"::\");\n     base::MacExpr::new(cx.expr_str("}, {"sha": "21c65d7fbf64695436c375c5cde54af4d95cbe2c", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -99,7 +99,6 @@ use std::mem;\n use std::rc::Rc;\n use std::collections::HashMap;\n use std::collections::hash_map::Entry::{Vacant, Occupied};\n-use std::ops::Deref;\n \n // To avoid costly uniqueness checks, we require that `MatchSeq` always has\n // a nonempty body.\n@@ -230,7 +229,7 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n                         p_s.span_diagnostic\n                            .span_fatal(sp,\n                                        &format!(\"duplicated bind name: {}\",\n-                                               string.deref())[])\n+                                               &string[])[])\n                     }\n                 }\n             }\n@@ -488,7 +487,7 @@ pub fn parse(sess: &ParseSess,\n                     let name_string = token::get_ident(name);\n                     let match_cur = ei.match_cur;\n                     (&mut ei.matches[match_cur]).push(Rc::new(MatchedNonterminal(\n-                        parse_nt(&mut rust_parser, span, name_string.deref()))));\n+                        parse_nt(&mut rust_parser, span, &name_string[]))));\n                     ei.idx += 1us;\n                     ei.match_cur += 1;\n                   }"}, {"sha": "26d16c1c720afc70978ff872a7966e5bcd38f937", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -21,6 +21,7 @@\n //! For the purpose of future feature-tracking, once code for detection of feature\n //! gate usage is added, *do not remove it again* even once the feature\n //! becomes stable.\n+\n use self::Status::*;\n \n use abi::RustIntrinsic;\n@@ -36,7 +37,6 @@ use parse::token::{self, InternedString};\n \n use std::slice;\n use std::ascii::AsciiExt;\n-use std::ops::Deref;\n \n // If you change this list without updating src/doc/reference.md, @cmr will be sad\n // Don't ever remove anything from this list; set them to 'Removed'.\n@@ -252,7 +252,7 @@ impl<'a> PostExpansionVisitor<'a> {\n \n impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     fn visit_name(&mut self, sp: Span, name: ast::Name) {\n-        if !token::get_name(name).deref().is_ascii() {\n+        if !token::get_name(name).is_ascii() {\n             self.gate_feature(\"non_ascii_idents\", sp,\n                               \"non-ascii idents are not fully supported.\");\n         }\n@@ -379,7 +379,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n \n         let links_to_llvm = match attr::first_attr_value_str_by_name(&i.attrs,\n                                                                      \"link_name\") {\n-            Some(val) => val.deref().starts_with(\"llvm.\"),\n+            Some(val) => val.starts_with(\"llvm.\"),\n             _ => false\n         };\n         if links_to_llvm {"}, {"sha": "3107f47de7859b83613478b5a193f0ef06221a3e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -84,7 +84,6 @@ use std::mem;\n use std::num::Float;\n use std::rc::Rc;\n use std::slice;\n-use std::ops::Deref;\n \n bitflags! {\n     flags Restrictions: u8 {\n@@ -5134,7 +5133,7 @@ impl<'a> Parser<'a> {\n                 outer_attrs, \"path\") {\n             Some(d) => (dir_path.join(d), true),\n             None => {\n-                let mod_name = mod_string.deref().to_string();\n+                let mod_name = mod_string.to_string();\n                 let default_path_str = format!(\"{}.rs\", mod_name);\n                 let secondary_path_str = format!(\"{}/mod.rs\", mod_name);\n                 let default_path = dir_path.join(&default_path_str[]);\n@@ -5146,7 +5145,7 @@ impl<'a> Parser<'a> {\n                     self.span_err(id_sp,\n                                   \"cannot declare a new module at this location\");\n                     let this_module = match self.mod_path_stack.last() {\n-                        Some(name) => name.deref().to_string(),\n+                        Some(name) => name.to_string(),\n                         None => self.root_module_name.as_ref().unwrap().clone(),\n                     };\n                     self.span_note(id_sp,\n@@ -5192,7 +5191,7 @@ impl<'a> Parser<'a> {\n         };\n \n         self.eval_src_mod_from_path(file_path, owns_directory,\n-                                    mod_string.deref().to_string(), id_sp)\n+                                    mod_string.to_string(), id_sp)\n     }\n \n     fn eval_src_mod_from_path(&mut self,"}, {"sha": "45f4f044ea4d1ff7502cecf0fbed90c9e880eb6a", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -639,7 +639,7 @@ impl BytesContainer for InternedString {\n         // of `BytesContainer`, which is itself a workaround for the lack of\n         // DST.\n         unsafe {\n-            let this = self.deref();\n+            let this = &self[];\n             mem::transmute::<&[u8],&[u8]>(this.container_as_bytes())\n         }\n     }"}, {"sha": "a244c9de62b4cfbe9561347fd4c68a76226a91de", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -30,7 +30,6 @@ use ptr::P;\n use std::{ascii, mem};\n use std::old_io::{self, IoResult};\n use std::iter;\n-use std::ops::Deref;\n \n pub enum AnnNode<'a> {\n     NodeIdent(&'a ast::Ident),\n@@ -259,7 +258,7 @@ pub fn token_to_string(tok: &Token) -> String {\n         }\n \n         /* Name components */\n-        token::Ident(s, _)          => token::get_ident(s).deref().to_string(),\n+        token::Ident(s, _)          => token::get_ident(s).to_string(),\n         token::Lifetime(s)          => format!(\"{}\", token::get_ident(s)),\n         token::Underscore           => \"_\".to_string(),\n \n@@ -799,7 +798,7 @@ impl<'a> State<'a> {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                      \"extern crate\")[]));\n                 if let Some((ref p, style)) = *optional_path {\n-                    try!(self.print_string(p.deref(), style));\n+                    try!(self.print_string(p, style));\n                     try!(space(&mut self.s));\n                     try!(word(&mut self.s, \"as\"));\n                     try!(space(&mut self.s));\n@@ -1314,7 +1313,7 @@ impl<'a> State<'a> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(attr.span.lo));\n         if attr.node.is_sugared_doc {\n-            word(&mut self.s, attr.value_str().unwrap().deref())\n+            word(&mut self.s, &attr.value_str().unwrap()[])\n         } else {\n             match attr.node.style {\n                 ast::AttrInner => try!(word(&mut self.s, \"#![\")),\n@@ -1848,17 +1847,17 @@ impl<'a> State<'a> {\n             ast::ExprInlineAsm(ref a) => {\n                 try!(word(&mut self.s, \"asm!\"));\n                 try!(self.popen());\n-                try!(self.print_string(a.asm.deref(), a.asm_str_style));\n+                try!(self.print_string(&a.asm[], a.asm_str_style));\n                 try!(self.word_space(\":\"));\n \n                 try!(self.commasep(Inconsistent, &a.outputs[],\n                                    |s, &(ref co, ref o, is_rw)| {\n-                    match co.deref().slice_shift_char() {\n+                    match co.slice_shift_char() {\n                         Some(('=', operand)) if is_rw => {\n                             try!(s.print_string(&format!(\"+{}\", operand)[],\n                                                 ast::CookedStr))\n                         }\n-                        _ => try!(s.print_string(co.deref(), ast::CookedStr))\n+                        _ => try!(s.print_string(&co[], ast::CookedStr))\n                     }\n                     try!(s.popen());\n                     try!(s.print_expr(&**o));\n@@ -1870,7 +1869,7 @@ impl<'a> State<'a> {\n \n                 try!(self.commasep(Inconsistent, &a.inputs[],\n                                    |s, &(ref co, ref o)| {\n-                    try!(s.print_string(co.deref(), ast::CookedStr));\n+                    try!(s.print_string(&co[], ast::CookedStr));\n                     try!(s.popen());\n                     try!(s.print_expr(&**o));\n                     try!(s.pclose());\n@@ -1881,7 +1880,7 @@ impl<'a> State<'a> {\n \n                 try!(self.commasep(Inconsistent, &a.clobbers[],\n                                    |s, co| {\n-                    try!(s.print_string(co.deref(), ast::CookedStr));\n+                    try!(s.print_string(&co[], ast::CookedStr));\n                     Ok(())\n                 }));\n \n@@ -1955,7 +1954,7 @@ impl<'a> State<'a> {\n             let encoded = ident.encode_with_hygiene();\n             try!(word(&mut self.s, &encoded[]))\n         } else {\n-            try!(word(&mut self.s, token::get_ident(ident).deref()))\n+            try!(word(&mut self.s, &token::get_ident(ident)[]))\n         }\n         self.ann.post(self, NodeIdent(&ident))\n     }\n@@ -1965,7 +1964,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) -> IoResult<()> {\n-        try!(word(&mut self.s, token::get_name(name).deref()));\n+        try!(word(&mut self.s, &token::get_name(name)[]));\n         self.ann.post(self, NodeName(&name))\n     }\n \n@@ -2533,15 +2532,15 @@ impl<'a> State<'a> {\n         try!(self.ibox(indent_unit));\n         match item.node {\n             ast::MetaWord(ref name) => {\n-                try!(word(&mut self.s, name.deref()));\n+                try!(word(&mut self.s, &name[]));\n             }\n             ast::MetaNameValue(ref name, ref value) => {\n-                try!(self.word_space(name.deref()));\n+                try!(self.word_space(&name[]));\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_literal(value));\n             }\n             ast::MetaList(ref name, ref items) => {\n-                try!(word(&mut self.s, name.deref()));\n+                try!(word(&mut self.s, &name[]));\n                 try!(self.popen());\n                 try!(self.commasep(Consistent,\n                                    &items[],\n@@ -2732,7 +2731,7 @@ impl<'a> State<'a> {\n             _ => ()\n         }\n         match lit.node {\n-            ast::LitStr(ref st, style) => self.print_string(st.deref(), style),\n+            ast::LitStr(ref st, style) => self.print_string(&st[], style),\n             ast::LitByte(byte) => {\n                 let mut res = String::from_str(\"b'\");\n                 ascii::escape_default(byte, |c| res.push(c as char));\n@@ -2773,10 +2772,10 @@ impl<'a> State<'a> {\n                 word(&mut self.s,\n                      &format!(\n                          \"{}{}\",\n-                         f.deref(),\n+                         &f[],\n                          &ast_util::float_ty_to_string(t)[])[])\n             }\n-            ast::LitFloatUnsuffixed(ref f) => word(&mut self.s, f.deref()),\n+            ast::LitFloatUnsuffixed(ref f) => word(&mut self.s, &f[]),\n             ast::LitBool(val) => {\n                 if val { word(&mut self.s, \"true\") } else { word(&mut self.s, \"false\") }\n             }"}, {"sha": "ddebf07ece59dc51d5bc65adf71c5789eee0a9d6", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b12d3ddf981e5450d8159b29db6ee2197064c8a/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=8b12d3ddf981e5450d8159b29db6ee2197064c8a", "patch": "@@ -37,8 +37,6 @@ use {ast, ast_util};\n use ptr::P;\n use util::small_vector::SmallVector;\n \n-use std::ops::Deref;\n-\n enum ShouldFail {\n     No,\n     Yes(Option<InternedString>),\n@@ -514,7 +512,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n     });\n     let reexport = cx.reexport_test_harness_main.as_ref().map(|s| {\n         // building `use <ident> = __test::main`\n-        let reexport_ident = token::str_to_ident(s.deref());\n+        let reexport_ident = token::str_to_ident(&s[]);\n \n         let use_path =\n             nospan(ast::ViewPathSimple(reexport_ident,\n@@ -577,7 +575,7 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n \n fn is_test_crate(krate: &ast::Crate) -> bool {\n     match attr::find_crate_name(&krate.attrs[]) {\n-        Some(ref s) if \"test\" == &s.deref()[] => true,\n+        Some(ref s) if \"test\" == &s[] => true,\n         _ => false\n     }\n }"}]}