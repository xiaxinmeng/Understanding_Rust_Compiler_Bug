{"sha": "ab92ea526d455b402efbccc7160c8aec0237c88f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiOTJlYTUyNmQ0NTViNDAyZWZiY2NjNzE2MGM4YWVjMDIzN2M4OGY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-29T03:36:08Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-08T06:43:39Z"}, "message": "std: Modernize the local_data api\n\nThis commit brings the local_data api up to modern rust standards with a few key\nimprovements:\n\n* The `pop` and `set` methods have been combined into one method, `replace`\n\n* The `get_mut` method has been removed. All interior mutability should be done\n  through `RefCell`.\n\n* All functionality is now exposed as a method on the keys themselves. Instead\n  of importing std::local_data, you now use \"key.replace()\" and \"key.get()\".\n\n* All closures have been removed in favor of RAII functionality. This means that\n  get() and get_mut() no long require closures, but rather return\n  Option<SmartPointer> where the smart pointer takes care of relinquishing the\n  borrow and also implements the necessary Deref traits\n\n* The modify() function was removed to cut the local_data interface down to its\n  bare essentials (similarly to how RefCell removed set/get).\n\n[breaking-change]", "tree": {"sha": "92e748f3e3496a48ac68dd290a0a08aa342740a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92e748f3e3496a48ac68dd290a0a08aa342740a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab92ea526d455b402efbccc7160c8aec0237c88f", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab92ea526d455b402efbccc7160c8aec0237c88f", "html_url": "https://github.com/rust-lang/rust/commit/ab92ea526d455b402efbccc7160c8aec0237c88f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab92ea526d455b402efbccc7160c8aec0237c88f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef6daf9935da103f1b915a5c9904794da79b0b60", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef6daf9935da103f1b915a5c9904794da79b0b60", "html_url": "https://github.com/rust-lang/rust/commit/ef6daf9935da103f1b915a5c9904794da79b0b60"}], "stats": {"total": 1101, "additions": 442, "deletions": 659}, "files": [{"sha": "2d1de87fe0665d221e698fdd615d72fb225040dc", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 33, "deletions": 37, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -1617,8 +1617,7 @@ mod test_map {\n     use std::cmp::Equiv;\n     use std::hash::Hash;\n     use std::iter::{Iterator,range_inclusive,range_step_inclusive};\n-    use std::local_data;\n-    use std::vec;\n+    use std::cell::RefCell;\n \n     struct KindaIntLike(int);\n \n@@ -1657,7 +1656,7 @@ mod test_map {\n         assert_eq!(*m.find(&2).unwrap(), 4);\n     }\n \n-    local_data_key!(drop_vector: vec::Vec<int>)\n+    local_data_key!(drop_vector: RefCell<Vec<int>>)\n \n     #[deriving(Hash, Eq, TotalEq)]\n     struct Dropable {\n@@ -1667,75 +1666,72 @@ mod test_map {\n \n     impl Dropable {\n         fn new(k: uint) -> Dropable {\n-            local_data::get_mut(drop_vector,\n-                |v| { v.unwrap().as_mut_slice()[k] += 1; });\n+            let v = drop_vector.get().unwrap();\n+            v.borrow_mut().as_mut_slice()[k] += 1;\n \n             Dropable { k: k }\n         }\n     }\n \n     impl Drop for Dropable {\n         fn drop(&mut self) {\n-            local_data::get_mut(drop_vector, |v|\n-                { v.unwrap().as_mut_slice()[self.k] -= 1; });\n+            let v = drop_vector.get().unwrap();\n+            v.borrow_mut().as_mut_slice()[self.k] -= 1;\n         }\n     }\n \n     #[test]\n     fn test_drops() {\n-        local_data::set(drop_vector, vec::Vec::from_elem(200, 0));\n+        drop_vector.replace(Some(RefCell::new(Vec::from_elem(200, 0))));\n \n         {\n             let mut m = HashMap::new();\n \n-            local_data::get(drop_vector, |v| {\n-                for i in range(0u, 200) {\n-                    assert_eq!(v.unwrap().as_slice()[i], 0);\n-                }\n-            });\n+            let v = drop_vector.get().unwrap();\n+            for i in range(0u, 200) {\n+                assert_eq!(v.borrow().as_slice()[i], 0);\n+            }\n+            drop(v);\n \n             for i in range(0u, 100) {\n                 let d1 = Dropable::new(i);\n                 let d2 = Dropable::new(i+100);\n                 m.insert(d1, d2);\n             }\n \n-            local_data::get(drop_vector, |v| {\n-                for i in range(0u, 200) {\n-                    assert_eq!(v.unwrap().as_slice()[i], 1);\n-                }\n-            });\n+            let v = drop_vector.get().unwrap();\n+            for i in range(0u, 200) {\n+                assert_eq!(v.borrow().as_slice()[i], 1);\n+            }\n+            drop(v);\n \n             for i in range(0u, 50) {\n                 let k = Dropable::new(i);\n                 let v = m.pop(&k);\n \n                 assert!(v.is_some());\n \n-                local_data::get(drop_vector, |v| {\n-                    assert_eq!(v.unwrap().as_slice()[i], 1);\n-                    assert_eq!(v.unwrap().as_slice()[i+100], 1);\n-                });\n+                let v = drop_vector.get().unwrap();\n+                assert_eq!(v.borrow().as_slice()[i], 1);\n+                assert_eq!(v.borrow().as_slice()[i+100], 1);\n             }\n \n-            local_data::get(drop_vector, |v| {\n-                for i in range(0u, 50) {\n-                    assert_eq!(v.unwrap().as_slice()[i], 0);\n-                    assert_eq!(v.unwrap().as_slice()[i+100], 0);\n-                }\n+            let v = drop_vector.get().unwrap();\n+            for i in range(0u, 50) {\n+                assert_eq!(v.borrow().as_slice()[i], 0);\n+                assert_eq!(v.borrow().as_slice()[i+100], 0);\n+            }\n \n-                for i in range(50u, 100) {\n-                    assert_eq!(v.unwrap().as_slice()[i], 1);\n-                    assert_eq!(v.unwrap().as_slice()[i+100], 1);\n-                }\n-            });\n+            for i in range(50u, 100) {\n+                assert_eq!(v.borrow().as_slice()[i], 1);\n+                assert_eq!(v.borrow().as_slice()[i+100], 1);\n+            }\n         }\n \n-        local_data::get(drop_vector, |v| {\n-            for i in range(0u, 200) {\n-                assert_eq!(v.unwrap().as_slice()[i], 0);\n-            }\n-        });\n+        let v = drop_vector.get().unwrap();\n+        for i in range(0u, 200) {\n+            assert_eq!(v.borrow().as_slice()[i], 0);\n+        }\n     }\n \n     #[test]"}, {"sha": "09e9cd83f3d4fdbe20db7c14bfeb4a4cd7426231", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -122,7 +122,6 @@ use std::cast;\n use std::fmt;\n use std::io::LineBufferedWriter;\n use std::io;\n-use std::local_data;\n use std::os;\n use std::rt;\n use std::slice;\n@@ -228,7 +227,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: &fmt::Arguments) {\n     // Completely remove the local logger from TLS in case anyone attempts to\n     // frob the slot while we're doing the logging. This will destroy any logger\n     // set during logging.\n-    let mut logger = local_data::pop(local_logger).unwrap_or_else(|| {\n+    let mut logger = local_logger.replace(None).unwrap_or_else(|| {\n         box DefaultLogger { handle: io::stderr() } as Box<Logger:Send>\n     });\n     logger.log(&LogRecord {\n@@ -238,7 +237,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: &fmt::Arguments) {\n         module_path: loc.module_path,\n         line: loc.line,\n     });\n-    local_data::set(local_logger, logger);\n+    local_logger.replace(Some(logger));\n }\n \n /// Getter for the global log level. This is a function so that it can be called\n@@ -250,9 +249,7 @@ pub fn log_level() -> u32 { unsafe { LOG_LEVEL } }\n /// Replaces the task-local logger with the specified logger, returning the old\n /// logger.\n pub fn set_logger(logger: Box<Logger:Send>) -> Option<Box<Logger:Send>> {\n-    let prev = local_data::pop(local_logger);\n-    local_data::set(local_logger, logger);\n-    return prev;\n+    local_logger.replace(Some(logger))\n }\n \n /// A LogRecord is created by the logging macros, and passed as the only"}, {"sha": "cb27f2f0ff82166eca0f770cb954272d48ace3f6", "filename": "src/librand/lib.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -79,7 +79,6 @@ println!(\"{:?}\", tuple_ptr)\n use std::cast;\n use std::io::IoResult;\n use std::kinds::marker;\n-use std::local_data;\n use std::strbuf::StrBuf;\n \n pub use isaac::{IsaacRng, Isaac64Rng};\n@@ -581,9 +580,6 @@ pub struct TaskRng {\n     marker: marker::NoSend,\n }\n \n-// used to make space in TLS for a random number generator\n-local_data_key!(TASK_RNG_KEY: Box<TaskRngInner>)\n-\n /// Retrieve the lazily-initialized task-local random number\n /// generator, seeded by the system. Intended to be used in method\n /// chaining style, e.g. `task_rng().gen::<int>()`.\n@@ -596,7 +592,10 @@ local_data_key!(TASK_RNG_KEY: Box<TaskRngInner>)\n /// the same sequence always. If absolute consistency is required,\n /// explicitly select an RNG, e.g. `IsaacRng` or `Isaac64Rng`.\n pub fn task_rng() -> TaskRng {\n-    local_data::get_mut(TASK_RNG_KEY, |rng| match rng {\n+    // used to make space in TLS for a random number generator\n+    local_data_key!(TASK_RNG_KEY: Box<TaskRngInner>)\n+\n+    match TASK_RNG_KEY.get() {\n         None => {\n             let r = match StdRng::new() {\n                 Ok(r) => r,\n@@ -607,12 +606,15 @@ pub fn task_rng() -> TaskRng {\n                                                         TaskRngReseeder);\n             let ptr = &mut *rng as *mut TaskRngInner;\n \n-            local_data::set(TASK_RNG_KEY, rng);\n+            TASK_RNG_KEY.replace(Some(rng));\n \n             TaskRng { rng: ptr, marker: marker::NoSend }\n         }\n-        Some(rng) => TaskRng { rng: &mut **rng, marker: marker::NoSend }\n-    })\n+        Some(rng) => TaskRng {\n+            rng: &**rng as *_ as *mut TaskRngInner,\n+            marker: marker::NoSend\n+        }\n+    }\n }\n \n impl Rng for TaskRng {"}, {"sha": "7b342b7cb95a7f88a7155d71c34999a558637cf8", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -74,7 +74,6 @@ use arena::TypedArena;\n use libc::c_uint;\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n-use std::local_data;\n use std::rc::Rc;\n use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic};\n use syntax::ast_util::{local_def, is_local};\n@@ -88,43 +87,37 @@ use syntax::{ast, ast_util, ast_map};\n \n use time;\n \n-local_data_key!(task_local_insn_key: Vec<&'static str> )\n+local_data_key!(task_local_insn_key: RefCell<Vec<&'static str>>)\n \n pub fn with_insn_ctxt(blk: |&[&'static str]|) {\n-    local_data::get(task_local_insn_key, |c| {\n-        match c {\n-            Some(ctx) => blk(ctx.as_slice()),\n-            None => ()\n-        }\n-    })\n+    match task_local_insn_key.get() {\n+        Some(ctx) => blk(ctx.borrow().as_slice()),\n+        None => ()\n+    }\n }\n \n pub fn init_insn_ctxt() {\n-    local_data::set(task_local_insn_key, Vec::new());\n+    task_local_insn_key.replace(Some(RefCell::new(Vec::new())));\n }\n \n pub struct _InsnCtxt { _x: () }\n \n #[unsafe_destructor]\n impl Drop for _InsnCtxt {\n     fn drop(&mut self) {\n-        local_data::modify(task_local_insn_key, |c| {\n-            c.map(|mut ctx| {\n-                ctx.pop();\n-                ctx\n-            })\n-        })\n+        match task_local_insn_key.get() {\n+            Some(ctx) => { ctx.borrow_mut().pop(); }\n+            None => {}\n+        }\n     }\n }\n \n pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     debug!(\"new InsnCtxt: {}\", s);\n-    local_data::modify(task_local_insn_key, |c| {\n-        c.map(|mut ctx| {\n-            ctx.push(s);\n-            ctx\n-        })\n-    });\n+    match task_local_insn_key.get() {\n+        Some(ctx) => ctx.borrow_mut().push(s),\n+        None => {}\n+    }\n     _InsnCtxt { _x: () }\n }\n "}, {"sha": "5ddae0c1bfef6358a43eb3d1d547e15e52a308a7", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -14,23 +14,21 @@ use syntax::ast;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-use std::local_data;\n-\n use time;\n \n pub fn time<T, U>(do_it: bool, what: &str, u: U, f: |U| -> T) -> T {\n     local_data_key!(depth: uint);\n     if !do_it { return f(u); }\n \n-    let old = local_data::get(depth, |d| d.map(|a| *a).unwrap_or(0));\n-    local_data::set(depth, old + 1);\n+    let old = depth.get().map(|d| *d).unwrap_or(0);\n+    depth.replace(Some(old + 1));\n \n     let start = time::precise_time_s();\n     let rv = f(u);\n     let end = time::precise_time_s();\n \n     println!(\"{}time: {:3.3f} s\\t{}\", \"  \".repeat(old), end - start, what);\n-    local_data::set(depth, old);\n+    depth.replace(Some(old));\n \n     rv\n }"}, {"sha": "be0fd85525df8b5de4825e22102164a476c17e1f", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -26,7 +26,6 @@ use rustc::metadata::cstore;\n use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n \n-use std::local_data;\n use std::strbuf::StrBuf;\n \n use core;\n@@ -77,7 +76,7 @@ pub struct Crate {\n \n impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n     fn clean(&self) -> Crate {\n-        let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n+        let cx = super::ctxtkey.get().unwrap();\n \n         let mut externs = Vec::new();\n         cx.sess().cstore.iter_crate_data(|n, meta| {\n@@ -251,7 +250,7 @@ impl Clean<Item> for doctree::Module {\n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n         let where = {\n-            let ctxt = local_data::get(super::ctxtkey, |x| *x.unwrap());\n+            let ctxt = super::ctxtkey.get().unwrap();\n             let cm = ctxt.sess().codemap();\n             let outer = cm.lookup_char_pos(self.where_outer.lo);\n             let inner = cm.lookup_char_pos(self.where_inner.lo);\n@@ -726,7 +725,7 @@ impl Clean<Type> for ast::Ty {\n     fn clean(&self) -> Type {\n         use syntax::ast::*;\n         debug!(\"cleaning type `{:?}`\", self);\n-        let ctxt = local_data::get(super::ctxtkey, |x| *x.unwrap());\n+        let ctxt = super::ctxtkey.get().unwrap();\n         let codemap = ctxt.sess().codemap();\n         debug!(\"span corresponds to `{}`\", codemap.span_to_str(self.span));\n         match self.node {\n@@ -909,7 +908,7 @@ pub struct Span {\n \n impl Clean<Span> for syntax::codemap::Span {\n     fn clean(&self) -> Span {\n-        let ctxt = local_data::get(super::ctxtkey, |x| *x.unwrap());\n+        let ctxt = super::ctxtkey.get().unwrap();\n         let cm = ctxt.sess().codemap();\n         let filename = cm.span_to_filename(*self);\n         let lo = cm.lookup_char_pos(self.lo);\n@@ -1237,7 +1236,7 @@ trait ToSource {\n impl ToSource for syntax::codemap::Span {\n     fn to_src(&self) -> ~str {\n         debug!(\"converting span {:?} to snippet\", self.clean());\n-        let ctxt = local_data::get(super::ctxtkey, |x| x.unwrap().clone());\n+        let ctxt = super::ctxtkey.get().unwrap();\n         let cm = ctxt.sess().codemap().clone();\n         let sn = match cm.span_to_snippet(*self) {\n             Some(x) => x,\n@@ -1292,7 +1291,7 @@ fn name_from_pat(p: &ast::Pat) -> ~str {\n /// Given a Type, resolve it using the def_map\n fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound> >,\n                 id: ast::NodeId) -> Type {\n-    let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n+    let cx = super::ctxtkey.get().unwrap();\n     let tycx = match cx.maybe_typed {\n         core::Typed(ref tycx) => tycx,\n         // If we're extracting tests, this return value doesn't matter.\n@@ -1351,7 +1350,7 @@ fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {\n }\n \n fn resolve_def(id: ast::NodeId) -> Option<ast::DefId> {\n-    let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n+    let cx = super::ctxtkey.get().unwrap();\n     match cx.maybe_typed {\n         core::Typed(ref tcx) => {\n             tcx.def_map.borrow().find(&id).map(|&d| ast_util::def_id_of_def(d))"}, {"sha": "1916e053e98a1336d397a6f0327fe266721b5d86", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -20,7 +20,6 @@ use syntax;\n \n use std::cell::RefCell;\n use std::os;\n-use std::local_data;\n use collections::HashSet;\n \n use visit_ast::RustdocVisitor;\n@@ -109,7 +108,7 @@ pub fn run_core(libs: HashSet<Path>, cfgs: Vec<~str>, path: &Path)\n                 -> (clean::Crate, CrateAnalysis) {\n     let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs);\n     let ctxt = @ctxt;\n-    local_data::set(super::ctxtkey, ctxt);\n+    super::ctxtkey.replace(Some(ctxt));\n \n     let krate = {\n         let mut v = RustdocVisitor::new(ctxt, Some(&analysis));"}, {"sha": "223f9341b73f786e6daa9d39e088fabe87f69dd3", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 60, "deletions": 69, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -17,7 +17,6 @@\n \n use std::fmt;\n use std::io;\n-use std::local_data;\n use std::strbuf::StrBuf;\n \n use syntax::ast;\n@@ -206,78 +205,72 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n         generics.push_str(\"&gt;\");\n     }\n \n-    // Did someone say rightward-drift?\n-    local_data::get(current_location_key, |loc| {\n-        let loc = loc.unwrap();\n-\n-        local_data::get(cache_key, |cache| {\n-            let cache = cache.unwrap();\n-            let abs_root = root(&**cache, loc.as_slice());\n-            let rel_root = match path.segments.get(0).name.as_slice() {\n-                \"self\" => Some(\"./\".to_owned()),\n-                _ => None,\n-            };\n-\n-            if print_all {\n-                let amt = path.segments.len() - 1;\n-                match rel_root {\n-                    Some(root) => {\n-                        let mut root = StrBuf::from_str(root);\n-                        for seg in path.segments.slice_to(amt).iter() {\n-                            if \"super\" == seg.name || \"self\" == seg.name {\n-                                try!(write!(w, \"{}::\", seg.name));\n-                            } else {\n-                                root.push_str(seg.name);\n-                                root.push_str(\"/\");\n-                                try!(write!(w, \"<a class='mod'\n-                                                    href='{}index.html'>{}</a>::\",\n-                                              root.as_slice(),\n-                                              seg.name));\n-                            }\n-                        }\n-                    }\n-                    None => {\n-                        for seg in path.segments.slice_to(amt).iter() {\n-                            try!(write!(w, \"{}::\", seg.name));\n-                        }\n+    let loc = current_location_key.get().unwrap();\n+    let cache = cache_key.get().unwrap();\n+    let abs_root = root(&**cache, loc.as_slice());\n+    let rel_root = match path.segments.get(0).name.as_slice() {\n+        \"self\" => Some(\"./\".to_owned()),\n+        _ => None,\n+    };\n+\n+    if print_all {\n+        let amt = path.segments.len() - 1;\n+        match rel_root {\n+            Some(root) => {\n+                let mut root = StrBuf::from_str(root);\n+                for seg in path.segments.slice_to(amt).iter() {\n+                    if \"super\" == seg.name || \"self\" == seg.name {\n+                        try!(write!(w, \"{}::\", seg.name));\n+                    } else {\n+                        root.push_str(seg.name);\n+                        root.push_str(\"/\");\n+                        try!(write!(w, \"<a class='mod'\n+                                            href='{}index.html'>{}</a>::\",\n+                                      root.as_slice(),\n+                                      seg.name));\n                     }\n                 }\n             }\n-\n-            match info(&**cache) {\n-                // This is a documented path, link to it!\n-                Some((ref fqp, shortty)) if abs_root.is_some() => {\n-                    let mut url = StrBuf::from_str(abs_root.unwrap());\n-                    let to_link = fqp.slice_to(fqp.len() - 1);\n-                    for component in to_link.iter() {\n-                        url.push_str(*component);\n-                        url.push_str(\"/\");\n-                    }\n-                    match shortty {\n-                        item_type::Module => {\n-                            url.push_str(*fqp.last().unwrap());\n-                            url.push_str(\"/index.html\");\n-                        }\n-                        _ => {\n-                            url.push_str(shortty.to_static_str());\n-                            url.push_str(\".\");\n-                            url.push_str(*fqp.last().unwrap());\n-                            url.push_str(\".html\");\n-                        }\n-                    }\n-\n-                    try!(write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>\",\n-                                  shortty, url, fqp.connect(\"::\"), last.name));\n+            None => {\n+                for seg in path.segments.slice_to(amt).iter() {\n+                    try!(write!(w, \"{}::\", seg.name));\n                 }\n+            }\n+        }\n+    }\n \n+    match info(&**cache) {\n+        // This is a documented path, link to it!\n+        Some((ref fqp, shortty)) if abs_root.is_some() => {\n+            let mut url = StrBuf::from_str(abs_root.unwrap());\n+            let to_link = fqp.slice_to(fqp.len() - 1);\n+            for component in to_link.iter() {\n+                url.push_str(*component);\n+                url.push_str(\"/\");\n+            }\n+            match shortty {\n+                item_type::Module => {\n+                    url.push_str(*fqp.last().unwrap());\n+                    url.push_str(\"/index.html\");\n+                }\n                 _ => {\n-                    try!(write!(w, \"{}\", last.name));\n+                    url.push_str(shortty.to_static_str());\n+                    url.push_str(\".\");\n+                    url.push_str(*fqp.last().unwrap());\n+                    url.push_str(\".html\");\n                 }\n             }\n-            try!(write!(w, \"{}\", generics.as_slice()));\n-            Ok(())\n-        })\n-    })\n+\n+            try!(write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>\",\n+                          shortty, url, fqp.connect(\"::\"), last.name));\n+        }\n+\n+        _ => {\n+            try!(write!(w, \"{}\", last.name));\n+        }\n+    }\n+    try!(write!(w, \"{}\", generics.as_slice()));\n+    Ok(())\n }\n \n /// Helper to render type parameters\n@@ -302,10 +295,8 @@ impl fmt::Show for clean::Type {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::TyParamBinder(id) | clean::Generic(id) => {\n-                local_data::get(cache_key, |cache| {\n-                    let m = cache.unwrap();\n-                    f.buf.write(m.typarams.get(&id).as_bytes())\n-                })\n+                let m = cache_key.get().unwrap();\n+                f.buf.write(m.typarams.get(&id).as_bytes())\n             }\n             clean::ResolvedPath{id, typarams: ref tp, path: ref path} => {\n                 try!(resolved_path(f.buf, id, path, false));"}, {"sha": "0141df34a6c229986e552b79abbb52ff32efa390", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -27,11 +27,11 @@\n #![allow(non_camel_case_types)]\n \n use libc;\n+use std::cell::RefCell;\n use std::fmt;\n use std::io;\n-use std::local_data;\n-use std::str;\n use std::slice;\n+use std::str;\n use collections::HashMap;\n \n use html::toc::TocBuilder;\n@@ -139,7 +139,7 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n     }\n }\n \n-local_data_key!(used_header_map: HashMap<~str, uint>)\n+local_data_key!(used_header_map: RefCell<HashMap<~str, uint>>)\n \n pub fn render(w: &mut io::Writer, s: &str, print_toc: bool) -> fmt::Result {\n     extern fn block(ob: *mut hoedown_buffer, text: *hoedown_buffer,\n@@ -216,15 +216,12 @@ pub fn render(w: &mut io::Writer, s: &str, print_toc: bool) -> fmt::Result {\n         let opaque = unsafe { &mut *((*opaque).opaque as *mut MyOpaque) };\n \n         // Make sure our hyphenated ID is unique for this page\n-        let id = local_data::get_mut(used_header_map, |map| {\n-            let map = map.unwrap();\n-            match map.find_mut(&id) {\n-                None => {}\n-                Some(a) => { *a += 1; return format!(\"{}-{}\", id, *a - 1) }\n-            }\n-            map.insert(id.clone(), 1);\n-            id.clone()\n-        });\n+        let map = used_header_map.get().unwrap();\n+        let id = match map.borrow_mut().find_mut(&id) {\n+            None => id,\n+            Some(a) => { *a += 1; format!(\"{}-{}\", id, *a - 1) }\n+        };\n+        map.borrow_mut().insert(id.clone(), 1);\n \n         let sec = match opaque.toc_builder {\n             Some(ref mut builder) => {\n@@ -348,7 +345,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n /// used at the beginning of rendering an entire HTML page to reset from the\n /// previous state (if any).\n pub fn reset_headers() {\n-    local_data::set(used_header_map, HashMap::new())\n+    used_header_map.replace(Some(RefCell::new(HashMap::new())));\n }\n \n impl<'a> fmt::Show for Markdown<'a> {"}, {"sha": "fe80d26d10933c284c2f9ced198a89d630e6f352", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 72, "deletions": 82, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -37,7 +37,6 @@ use collections::{HashMap, HashSet};\n use std::fmt;\n use std::io::{fs, File, BufferedWriter, MemWriter, BufferedReader};\n use std::io;\n-use std::local_data;\n use std::str;\n use std::strbuf::StrBuf;\n \n@@ -243,24 +242,22 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     }\n \n     // Crawl the crate to build various caches used for the output\n-    let mut cache = local_data::get(::analysiskey, |analysis| {\n-        let public_items = analysis.map(|a| a.public_items.clone());\n-        let public_items = public_items.unwrap_or(NodeSet::new());\n-        Cache {\n-            impls: HashMap::new(),\n-            typarams: HashMap::new(),\n-            paths: HashMap::new(),\n-            traits: HashMap::new(),\n-            implementors: HashMap::new(),\n-            stack: Vec::new(),\n-            parent_stack: Vec::new(),\n-            search_index: Vec::new(),\n-            extern_locations: HashMap::new(),\n-            privmod: false,\n-            public_items: public_items,\n-            orphan_methods: Vec::new(),\n-        }\n-    });\n+    let public_items = ::analysiskey.get().map(|a| a.public_items.clone());\n+    let public_items = public_items.unwrap_or(NodeSet::new());\n+    let mut cache = Cache {\n+        impls: HashMap::new(),\n+        typarams: HashMap::new(),\n+        paths: HashMap::new(),\n+        traits: HashMap::new(),\n+        implementors: HashMap::new(),\n+        stack: Vec::new(),\n+        parent_stack: Vec::new(),\n+        search_index: Vec::new(),\n+        extern_locations: HashMap::new(),\n+        privmod: false,\n+        public_items: public_items,\n+        orphan_methods: Vec::new(),\n+    };\n     cache.stack.push(krate.name.clone());\n     krate = cache.fold_crate(krate);\n \n@@ -833,7 +830,7 @@ impl Context {\n         item.name = Some(krate.name);\n \n         // using a rwarc makes this parallelizable in the future\n-        local_data::set(cache_key, Arc::new(cache));\n+        cache_key.replace(Some(Arc::new(cache)));\n \n         let mut work = vec!((self, item));\n         loop {\n@@ -859,7 +856,7 @@ impl Context {\n             info!(\"Rendering an item to {}\", w.path().display());\n             // A little unfortunate that this is done like this, but it sure\n             // does make formatting *a lot* nicer.\n-            local_data::set(current_location_key, cx.current.clone());\n+            current_location_key.replace(Some(cx.current.clone()));\n \n             let mut title = StrBuf::from_str(cx.current.connect(\"::\"));\n             if pushname {\n@@ -1299,31 +1296,28 @@ fn item_trait(w: &mut Writer, it: &clean::Item,\n         try!(write!(w, \"</div>\"));\n     }\n \n-    local_data::get(cache_key, |cache| {\n-        let cache = cache.unwrap();\n-        match cache.implementors.find(&it.id) {\n-            Some(implementors) => {\n-                try!(write!(w, \"\n-                    <h2 id='implementors'>Implementors</h2>\n-                    <ul class='item-list'>\n-                \"));\n-                for i in implementors.iter() {\n-                    match *i {\n-                        PathType(ref ty) => {\n-                            try!(write!(w, \"<li><code>{}</code></li>\", *ty));\n-                        }\n-                        OtherType(ref generics, ref trait_, ref for_) => {\n-                            try!(write!(w, \"<li><code>impl{} {} for {}</code></li>\",\n-                                          *generics, *trait_, *for_));\n-                        }\n+    match cache_key.get().unwrap().implementors.find(&it.id) {\n+        Some(implementors) => {\n+            try!(write!(w, \"\n+                <h2 id='implementors'>Implementors</h2>\n+                <ul class='item-list'>\n+            \"));\n+            for i in implementors.iter() {\n+                match *i {\n+                    PathType(ref ty) => {\n+                        try!(write!(w, \"<li><code>{}</code></li>\", *ty));\n+                    }\n+                    OtherType(ref generics, ref trait_, ref for_) => {\n+                        try!(write!(w, \"<li><code>impl{} {} for {}</code></li>\",\n+                                      *generics, *trait_, *for_));\n                     }\n                 }\n-                try!(write!(w, \"</ul>\"));\n             }\n-            None => {}\n+            try!(write!(w, \"</ul>\"));\n         }\n-        Ok(())\n-    })\n+        None => {}\n+    }\n+    Ok(())\n }\n \n fn render_method(w: &mut Writer, meth: &clean::Item) -> fmt::Result {\n@@ -1550,51 +1544,48 @@ fn render_struct(w: &mut Writer, it: &clean::Item,\n }\n \n fn render_methods(w: &mut Writer, it: &clean::Item) -> fmt::Result {\n-    local_data::get(cache_key, |cache| {\n-        let c = cache.unwrap();\n-        match c.impls.find(&it.id) {\n-            Some(v) => {\n-                let mut non_trait = v.iter().filter(|p| {\n-                    p.ref0().trait_.is_none()\n-                });\n-                let non_trait = non_trait.collect::<Vec<&(clean::Impl, Option<~str>)>>();\n-                let mut traits = v.iter().filter(|p| {\n-                    p.ref0().trait_.is_some()\n-                });\n-                let traits = traits.collect::<Vec<&(clean::Impl, Option<~str>)>>();\n-\n-                if non_trait.len() > 0 {\n-                    try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n-                    for &(ref i, ref dox) in non_trait.move_iter() {\n+    match cache_key.get().unwrap().impls.find(&it.id) {\n+        Some(v) => {\n+            let mut non_trait = v.iter().filter(|p| {\n+                p.ref0().trait_.is_none()\n+            });\n+            let non_trait = non_trait.collect::<Vec<&(clean::Impl, Option<~str>)>>();\n+            let mut traits = v.iter().filter(|p| {\n+                p.ref0().trait_.is_some()\n+            });\n+            let traits = traits.collect::<Vec<&(clean::Impl, Option<~str>)>>();\n+\n+            if non_trait.len() > 0 {\n+                try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n+                for &(ref i, ref dox) in non_trait.move_iter() {\n+                    try!(render_impl(w, i, dox));\n+                }\n+            }\n+            if traits.len() > 0 {\n+                try!(write!(w, \"<h2 id='implementations'>Trait \\\n+                                  Implementations</h2>\"));\n+                let mut any_derived = false;\n+                for & &(ref i, ref dox) in traits.iter() {\n+                    if !i.derived {\n                         try!(render_impl(w, i, dox));\n+                    } else {\n+                        any_derived = true;\n                     }\n                 }\n-                if traits.len() > 0 {\n-                    try!(write!(w, \"<h2 id='implementations'>Trait \\\n-                                      Implementations</h2>\"));\n-                    let mut any_derived = false;\n-                    for & &(ref i, ref dox) in traits.iter() {\n-                        if !i.derived {\n+                if any_derived {\n+                    try!(write!(w, \"<h3 id='derived_implementations'>Derived Implementations \\\n+                                </h3>\"));\n+                    for &(ref i, ref dox) in traits.move_iter() {\n+                        if i.derived {\n                             try!(render_impl(w, i, dox));\n-                        } else {\n-                            any_derived = true;\n-                        }\n-                    }\n-                    if any_derived {\n-                        try!(write!(w, \"<h3 id='derived_implementations'>Derived Implementations \\\n-                                    </h3>\"));\n-                        for &(ref i, ref dox) in traits.move_iter() {\n-                            if i.derived {\n-                                try!(render_impl(w, i, dox));\n-                            }\n                         }\n                     }\n                 }\n             }\n-            None => {}\n         }\n-        Ok(())\n-    })\n+        None => {}\n+    }\n+    Ok(())\n }\n \n fn render_impl(w: &mut Writer, i: &clean::Impl,\n@@ -1644,9 +1635,8 @@ fn render_impl(w: &mut Writer, i: &clean::Impl,\n     match trait_id {\n         None => {}\n         Some(id) => {\n-            try!(local_data::get(cache_key, |cache| {\n-                let cache = cache.unwrap();\n-                match cache.traits.find(&id) {\n+            try!({\n+                match cache_key.get().unwrap().traits.find(&id) {\n                     Some(t) => {\n                         for method in t.methods.iter() {\n                             let n = method.item().name.clone();\n@@ -1661,7 +1651,7 @@ fn render_impl(w: &mut Writer, i: &clean::Impl,\n                     None => {}\n                 }\n                 Ok(())\n-            }))\n+            })\n         }\n     }\n     try!(write!(w, \"</div>\"));"}, {"sha": "a79c8b30bbad2d86815d34d8f9cf4af527c2cbdb", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -28,7 +28,6 @@ extern crate time;\n extern crate log;\n extern crate libc;\n \n-use std::local_data;\n use std::io;\n use std::io::{File, MemWriter};\n use std::str;\n@@ -276,7 +275,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n                        &cr)\n     }).unwrap();\n     info!(\"finished with rustc\");\n-    local_data::set(analysiskey, analysis);\n+    analysiskey.replace(Some(analysis));\n \n     // Process all of the crate attributes, extracting plugin metadata along\n     // with the passes which we are supposed to run."}, {"sha": "38d1b2a14e10482203d044cbc07cd9ab26548d44", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -11,7 +11,6 @@\n use collections::HashSet;\n use rustc::util::nodemap::NodeSet;\n use std::cmp;\n-use std::local_data;\n use std::strbuf::StrBuf;\n use std::uint;\n use syntax::ast;\n@@ -86,13 +85,11 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n \n /// Strip private items from the point of view of a crate or externally from a\n /// crate, specified by the `xcrate` flag.\n-pub fn strip_private(krate: clean::Crate) -> plugins::PluginResult {\n+pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n     // This stripper collects all *retained* nodes.\n     let mut retained = HashSet::new();\n-    let exported_items = local_data::get(super::analysiskey, |analysis| {\n-        analysis.unwrap().exported_items.clone()\n-    });\n-    let mut krate = krate;\n+    let analysis = super::analysiskey.get().unwrap();\n+    let exported_items = analysis.exported_items.clone();\n \n     // strip all private items\n     {"}, {"sha": "898f5856694353f06f556dc3ce39140312715497", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -12,7 +12,6 @@ use std::cell::RefCell;\n use std::char;\n use std::io;\n use std::io::{Process, TempDir};\n-use std::local_data;\n use std::os;\n use std::str;\n use std::strbuf::StrBuf;\n@@ -75,7 +74,7 @@ pub fn run(input: &str,\n         maybe_typed: core::NotTyped(sess),\n         src: input_path,\n     };\n-    local_data::set(super::ctxtkey, ctx);\n+    super::ctxtkey.replace(Some(ctx));\n \n     let mut v = RustdocVisitor::new(ctx, None);\n     v.visit(&ctx.krate);"}, {"sha": "c3c04c5470fee02be7849e2a901acfda010219f0", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 191, "deletions": 346, "changes": 537, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -23,16 +23,14 @@ named and annotated. This name is then passed to the functions in this module to\n modify/read the slot specified by the key.\n \n ```rust\n-use std::local_data;\n-\n local_data_key!(key_int: int)\n local_data_key!(key_vector: ~[int])\n \n-local_data::set(key_int, 3);\n-local_data::get(key_int, |opt| assert_eq!(opt.map(|x| *x), Some(3)));\n+key_int.replace(Some(3));\n+assert_eq!(*key_int.get().unwrap(), 3);\n \n-local_data::set(key_vector, ~[4]);\n-local_data::get(key_vector, |opt| assert_eq!(*opt.unwrap(), ~[4]));\n+key_vector.replace(Some(~[4]));\n+assert_eq!(*key_vector.get().unwrap(), ~[4]);\n ```\n \n */\n@@ -43,9 +41,12 @@ local_data::get(key_vector, |opt| assert_eq!(*opt.unwrap(), ~[4]));\n use cast;\n use iter::{Iterator};\n use kinds::Send;\n+use kinds::marker;\n use mem::replace;\n+use ops::{Drop, Deref};\n use option::{None, Option, Some};\n use owned::Box;\n+use raw;\n use rt::task::{Task, LocalStorage};\n use slice::{ImmutableVector, MutableVector};\n use vec::Vec;\n@@ -66,7 +67,7 @@ pub type Key<T> = &'static KeyValue<T>;\n #[allow(missing_doc)]\n pub enum KeyValue<T> { Key }\n \n-#[allow(missing_doc)]\n+#[doc(hidden)]\n trait LocalData {}\n impl<T: 'static> LocalData for T {}\n \n@@ -91,7 +92,7 @@ impl<T: 'static> LocalData for T {}\n // n.b. If TLS is used heavily in future, this could be made more efficient with\n //      a proper map.\n #[doc(hidden)]\n-pub type Map = Vec<Option<(*u8, TLSValue, LoanState)>>;\n+pub type Map = Vec<Option<(*u8, TLSValue, uint)>>;\n type TLSValue = Box<LocalData:Send>;\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n@@ -111,243 +112,156 @@ unsafe fn get_local_map() -> &mut Map {\n             *slot = Some(vec!());\n             match *slot {\n                 Some(ref mut map_ptr) => { return map_ptr }\n-                None => abort()\n+                None => unreachable!(),\n             }\n         }\n     }\n }\n \n-#[deriving(Eq)]\n-enum LoanState {\n-    NoLoan, ImmLoan, MutLoan\n-}\n-\n-impl LoanState {\n-    fn describe(&self) -> &'static str {\n-        match *self {\n-            NoLoan => \"no loan\",\n-            ImmLoan => \"immutable\",\n-            MutLoan => \"mutable\"\n-        }\n-    }\n-}\n-\n fn key_to_key_value<T: 'static>(key: Key<T>) -> *u8 {\n-    unsafe { cast::transmute(key) }\n+    key as *KeyValue<T> as *u8\n }\n \n-/// Removes a task-local value from task-local storage. This will return\n-/// Some(value) if the key was present in TLS, otherwise it will return None.\n+/// An RAII immutable reference to a task-local value.\n ///\n-/// A runtime assertion will be triggered it removal of TLS value is attempted\n-/// while the value is still loaned out via `get` or `get_mut`.\n-pub fn pop<T: 'static>(key: Key<T>) -> Option<T> {\n-    let map = unsafe { get_local_map() };\n-    let key_value = key_to_key_value(key);\n-\n-    for entry in map.mut_iter() {\n-        match *entry {\n-            Some((k, _, loan)) if k == key_value => {\n-                if loan != NoLoan {\n-                    fail!(\"TLS value cannot be removed because it is currently \\\n-                          borrowed as {}\", loan.describe());\n-                }\n-                // Move the data out of the `entry` slot via prelude::replace.\n-                // This is guaranteed to succeed because we already matched\n-                // on `Some` above.\n-                let data = match replace(entry, None) {\n-                    Some((_, data, _)) => data,\n-                    None => abort()\n-                };\n-\n-                // Move `data` into transmute to get out the memory that it\n-                // owns, we must free it manually later.\n-                let (_vtable, alloc): (uint, Box<T>) = unsafe {\n-                    cast::transmute(data)\n-                };\n-\n-                // Now that we own `alloc`, we can just move out of it as we\n-                // would with any other data.\n-                return Some(*alloc);\n-            }\n-            _ => {}\n-        }\n-    }\n-    return None;\n+/// The task-local data can be accessed through this value, and when this\n+/// structure is dropped it will return the borrow on the data.\n+pub struct Ref<T> {\n+    ptr: &'static T,\n+    key: Key<T>,\n+    index: uint,\n+    nosend: marker::NoSend,\n }\n \n-/// Retrieves a value from TLS. The closure provided is yielded `Some` of a\n-/// reference to the value located in TLS if one exists, or `None` if the key\n-/// provided is not present in TLS currently.\n-///\n-/// It is considered a runtime error to attempt to get a value which is already\n-/// on loan via the `get_mut` method provided.\n-pub fn get<T: 'static, U>(key: Key<T>, f: |Option<&T>| -> U) -> U {\n-    get_with(key, ImmLoan, f)\n-}\n-\n-/// Retrieves a mutable value from TLS. The closure provided is yielded `Some`\n-/// of a reference to the mutable value located in TLS if one exists, or `None`\n-/// if the key provided is not present in TLS currently.\n-///\n-/// It is considered a runtime error to attempt to get a value which is already\n-/// on loan via this or the `get` methods.\n-pub fn get_mut<T: 'static, U>(key: Key<T>, f: |Option<&mut T>| -> U) -> U {\n-    get_with(key, MutLoan, |x| {\n-        match x {\n-            None => f(None),\n-            // We're violating a lot of compiler guarantees with this\n-            // invocation of `transmute`, but we're doing runtime checks to\n-            // ensure that it's always valid (only one at a time).\n-            //\n-            // there is no need to be upset!\n-            Some(x) => { f(Some(unsafe { cast::transmute::<&_, &mut _>(x) })) }\n-        }\n-    })\n-}\n+impl<T: 'static> KeyValue<T> {\n+    /// Replaces a value in task local storage.\n+    ///\n+    /// If this key is already present in TLS, then the previous value is\n+    /// replaced with the provided data, and then returned.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will fail if this key is present in TLS and currently on\n+    /// loan with the `get` method.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// local_data_key!(foo: int)\n+    ///\n+    /// assert_eq!(foo.replace(Some(10)), None);\n+    /// assert_eq!(foo.replace(Some(4)), Some(10));\n+    /// assert_eq!(foo.replace(None), Some(4));\n+    /// ```\n+    pub fn replace(&'static self, data: Option<T>) -> Option<T> {\n+        let map = unsafe { get_local_map() };\n+        let keyval = key_to_key_value(self);\n+\n+        // When the task-local map is destroyed, all the data needs to be\n+        // cleaned up. For this reason we can't do some clever tricks to store\n+        // '~T' as a '*c_void' or something like that. To solve the problem, we\n+        // cast everything to a trait (LocalData) which is then stored inside\n+        // the map.  Upon destruction of the map, all the objects will be\n+        // destroyed and the traits have enough information about them to\n+        // destroy themselves.\n+        //\n+        // Additionally, the type of the local data map must ascribe to Send, so\n+        // we do the transmute here to add the Send bound back on. This doesn't\n+        // actually matter because TLS will always own the data (until its moved\n+        // out) and we're not actually sending it to other schedulers or\n+        // anything.\n+        let newval = data.map(|d| {\n+            let d = box d as Box<LocalData>;\n+            let d: Box<LocalData:Send> = unsafe { cast::transmute(d) };\n+            (keyval, d, 0)\n+        });\n \n-fn get_with<T:'static,\n-            U>(\n-            key: Key<T>,\n-            state: LoanState,\n-            f: |Option<&T>| -> U)\n-            -> U {\n-    // This function must be extremely careful. Because TLS can store owned\n-    // values, and we must have some form of `get` function other than `pop`,\n-    // this function has to give a `&` reference back to the caller.\n-    //\n-    // One option is to return the reference, but this cannot be sound because\n-    // the actual lifetime of the object is not known. The slot in TLS could not\n-    // be modified until the object goes out of scope, but the TLS code cannot\n-    // know when this happens.\n-    //\n-    // For this reason, the reference is yielded to a specified closure. This\n-    // way the TLS code knows exactly what the lifetime of the yielded pointer\n-    // is, allowing callers to acquire references to owned data. This is also\n-    // sound so long as measures are taken to ensure that while a TLS slot is\n-    // loaned out to a caller, it's not modified recursively.\n-    let map = unsafe { get_local_map() };\n-    let key_value = key_to_key_value(key);\n-\n-    let pos = map.iter().position(|entry| {\n-        match *entry {\n-            Some((k, _, _)) if k == key_value => true, _ => false\n-        }\n-    });\n-    match pos {\n-        None => { return f(None); }\n-        Some(i) => {\n-            let ret;\n-            let mut return_loan = false;\n-            match *map.get_mut(i) {\n-                Some((_, ref data, ref mut loan)) => {\n-                    match (state, *loan) {\n-                        (_, NoLoan) => {\n-                            *loan = state;\n-                            return_loan = true;\n-                        }\n-                        (ImmLoan, ImmLoan) => {}\n-                        (want, cur) => {\n-                            fail!(\"TLS slot cannot be borrowed as {} because \\\n-                                    it is already borrowed as {}\",\n-                                  want.describe(), cur.describe());\n-                        }\n-                    }\n-                    // data was created with `box T as Box<LocalData>`, so we\n-                    // extract pointer part of the trait, (as Box<T>), and\n-                    // then use compiler coercions to achieve a '&' pointer.\n-                    unsafe {\n-                        match *cast::transmute::<&TLSValue,\n-                                                 &(uint, Box<T>)>(data){\n-                            (_vtable, ref alloc) => {\n-                                let value: &T = *alloc;\n-                                ret = f(Some(value));\n-                            }\n-                        }\n-                    }\n-                }\n-                _ => abort()\n+        let pos = match self.find(map) {\n+            Some((i, _, &0)) => Some(i),\n+            Some((_, _, _)) => fail!(\"TLS value cannot be replaced because it \\\n+                                      is already borrowed\"),\n+            None => map.iter().position(|entry| entry.is_none()),\n+        };\n+\n+        match pos {\n+            Some(i) => {\n+                replace(map.get_mut(i), newval).map(|(_, data, _)| {\n+                    // Move `data` into transmute to get out the memory that it\n+                    // owns, we must free it manually later.\n+                    let t: raw::TraitObject = unsafe { cast::transmute(data) };\n+                    let alloc: Box<T> = unsafe { cast::transmute(t.data) };\n+\n+                    // Now that we own `alloc`, we can just move out of it as we\n+                    // would with any other data.\n+                    *alloc\n+                })\n             }\n-\n-            // n.b. 'data' and 'loans' are both invalid pointers at the point\n-            // 'f' returned because `f` could have appended more TLS items which\n-            // in turn relocated the vector. Hence we do another lookup here to\n-            // fixup the loans.\n-            if return_loan {\n-                match *map.get_mut(i) {\n-                    Some((_, _, ref mut loan)) => { *loan = NoLoan; }\n-                    None => abort()\n-                }\n+            None => {\n+                map.push(newval);\n+                None\n             }\n-            return ret;\n         }\n     }\n-}\n \n-fn abort() -> ! {\n-    use intrinsics;\n-    unsafe { intrinsics::abort() }\n-}\n+    /// Borrows a value from TLS.\n+    ///\n+    /// If `None` is returned, then this key is not present in TLS. If `Some` is\n+    /// returned, then the returned data is a smart pointer representing a new\n+    /// loan on this TLS key. While on loan, this key cannot be altered via the\n+    /// `replace` method.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// local_data_key!(key: int)\n+    ///\n+    /// assert!(key.get().is_none());\n+    ///\n+    /// key.replace(Some(3));\n+    /// assert_eq!(*key.get().unwrap(), 3);\n+    /// ```\n+    pub fn get(&'static self) -> Option<Ref<T>> {\n+        let map = unsafe { get_local_map() };\n+\n+        self.find(map).map(|(pos, data, loan)| {\n+            *loan += 1;\n+\n+            // data was created with `~T as ~LocalData`, so we extract\n+            // pointer part of the trait, (as ~T), and then use\n+            // compiler coercions to achieve a '&' pointer.\n+            let ptr = unsafe {\n+                let data = data as *Box<LocalData:Send> as *raw::TraitObject;\n+                &mut *((*data).data as *mut T)\n+            };\n+            Ref { ptr: ptr, index: pos, nosend: marker::NoSend, key: self }\n+        })\n+    }\n \n-/// Inserts a value into task local storage. If the key is already present in\n-/// TLS, then the previous value is removed and replaced with the provided data.\n-///\n-/// It is considered a runtime error to attempt to set a key which is currently\n-/// on loan via the `get` or `get_mut` methods.\n-pub fn set<T: 'static>(key: Key<T>, data: T) {\n-    let map = unsafe { get_local_map() };\n-    let keyval = key_to_key_value(key);\n-\n-    // When the task-local map is destroyed, all the data needs to be cleaned\n-    // up. For this reason we can't do some clever tricks to store 'Box<T>' as\n-    // a '*c_void' or something like that. To solve the problem, we cast\n-    // everything to a trait (LocalData) which is then stored inside the map.\n-    // Upon destruction of the map, all the objects will be destroyed and the\n-    // traits have enough information about them to destroy themselves.\n-    let data = box data as Box<LocalData:>;\n-\n-    fn insertion_position(map: &mut Map,\n-                          key: *u8) -> Option<uint> {\n-        // First see if the map contains this key already\n-        let curspot = map.iter().position(|entry| {\n+    fn find<'a>(&'static self,\n+                map: &'a mut Map) -> Option<(uint, &'a TLSValue, &'a mut uint)>{\n+        let key_value = key_to_key_value(self);\n+        map.mut_iter().enumerate().filter_map(|(i, entry)| {\n             match *entry {\n-                Some((ekey, _, loan)) if key == ekey => {\n-                    if loan != NoLoan {\n-                        fail!(\"TLS value cannot be overwritten because it is\n-                               already borrowed as {}\", loan.describe())\n-                    }\n-                    true\n+                Some((k, ref data, ref mut loan)) if k == key_value => {\n+                    Some((i, data, loan))\n                 }\n-                _ => false,\n+                _ => None\n             }\n-        });\n-        // If it doesn't contain the key, just find a slot that's None\n-        match curspot {\n-            Some(i) => Some(i),\n-            None => map.iter().position(|entry| entry.is_none())\n-        }\n+        }).next()\n     }\n+}\n \n-    // The type of the local data map must ascribe to Send, so we do the\n-    // transmute here to add the Send bound back on. This doesn't actually\n-    // matter because TLS will always own the data (until its moved out) and\n-    // we're not actually sending it to other schedulers or anything.\n-    let data: Box<LocalData:Send> = unsafe { cast::transmute(data) };\n-    match insertion_position(map, keyval) {\n-        Some(i) => { *map.get_mut(i) = Some((keyval, data, NoLoan)); }\n-        None => { map.push(Some((keyval, data, NoLoan))); }\n-    }\n+impl<T: 'static> Deref<T> for Ref<T> {\n+    fn deref<'a>(&'a self) -> &'a T { self.ptr }\n }\n \n-/// Modifies a task-local value by temporarily removing it from task-local\n-/// storage and then re-inserting if `Some` is returned from the closure.\n-///\n-/// This function will have the same runtime errors as generated from `pop` and\n-/// `set` (the key must not currently be on loan\n-pub fn modify<T: 'static>(key: Key<T>, f: |Option<T>| -> Option<T>) {\n-    match f(pop(key)) {\n-        Some(next) => { set(key, next); }\n-        None => {}\n+#[unsafe_destructor]\n+impl<T: 'static> Drop for Ref<T> {\n+    fn drop(&mut self) {\n+        let map = unsafe { get_local_map() };\n+\n+        let (_, _, ref mut loan) = *map.get_mut(self.index).get_mut_ref();\n+        *loan -= 1;\n     }\n }\n \n@@ -362,55 +276,36 @@ mod tests {\n     #[test]\n     fn test_tls_multitask() {\n         static my_key: Key<~str> = &Key;\n-        set(my_key, \"parent data\".to_owned());\n+        my_key.replace(Some(\"parent data\".to_owned()));\n         task::spawn(proc() {\n             // TLS shouldn't carry over.\n-            assert!(get(my_key, |k| k.map(|k| (*k).clone())).is_none());\n-            set(my_key, \"child data\".to_owned());\n-            assert!(get(my_key, |k| k.map(|k| (*k).clone())).unwrap() ==\n-                    \"child data\".to_owned());\n+            assert!(my_key.get().is_none());\n+            my_key.replace(Some(\"child data\".to_owned()));\n+            assert!(my_key.get().get_ref().as_slice() == \"child data\");\n             // should be cleaned up for us\n         });\n+\n         // Must work multiple times\n-        assert!(get(my_key, |k| k.map(|k| (*k).clone())).unwrap() == \"parent data\".to_owned());\n-        assert!(get(my_key, |k| k.map(|k| (*k).clone())).unwrap() == \"parent data\".to_owned());\n-        assert!(get(my_key, |k| k.map(|k| (*k).clone())).unwrap() == \"parent data\".to_owned());\n+        assert!(my_key.get().unwrap().as_slice() == \"parent data\");\n+        assert!(my_key.get().unwrap().as_slice() == \"parent data\");\n+        assert!(my_key.get().unwrap().as_slice() == \"parent data\");\n     }\n \n     #[test]\n     fn test_tls_overwrite() {\n         static my_key: Key<~str> = &Key;\n-        set(my_key, \"first data\".to_owned());\n-        set(my_key, \"next data\".to_owned()); // Shouldn't leak.\n-        assert!(get(my_key, |k| k.map(|k| (*k).clone())).unwrap() == \"next data\".to_owned());\n+        my_key.replace(Some(\"first data\".to_owned()));\n+        my_key.replace(Some(\"next data\".to_owned())); // Shouldn't leak.\n+        assert!(my_key.get().unwrap().as_slice() == \"next data\");\n     }\n \n     #[test]\n     fn test_tls_pop() {\n         static my_key: Key<~str> = &Key;\n-        set(my_key, \"weasel\".to_owned());\n-        assert!(pop(my_key).unwrap() == \"weasel\".to_owned());\n+        my_key.replace(Some(\"weasel\".to_owned()));\n+        assert!(my_key.replace(None).unwrap() == \"weasel\".to_owned());\n         // Pop must remove the data from the map.\n-        assert!(pop(my_key).is_none());\n-    }\n-\n-    #[test]\n-    fn test_tls_modify() {\n-        static my_key: Key<~str> = &Key;\n-        modify(my_key, |data| {\n-            match data {\n-                Some(ref val) => fail!(\"unwelcome value: {}\", *val),\n-                None           => Some(\"first data\".to_owned())\n-            }\n-        });\n-        modify(my_key, |data| {\n-            match data.as_ref().map(|s| s.as_slice()) {\n-                Some(\"first data\") => Some(\"next data\".to_owned()),\n-                Some(ref val)       => fail!(\"wrong value: {}\", *val),\n-                None                 => fail!(\"missing value\")\n-            }\n-        });\n-        assert!(pop(my_key).unwrap() == \"next data\".to_owned());\n+        assert!(my_key.replace(None).is_none());\n     }\n \n     #[test]\n@@ -423,7 +318,7 @@ mod tests {\n         // a stack smaller than 1 MB.\n         static my_key: Key<~str> = &Key;\n         task::spawn(proc() {\n-            set(my_key, \"hax\".to_owned());\n+            my_key.replace(Some(\"hax\".to_owned()));\n         });\n     }\n \n@@ -433,28 +328,27 @@ mod tests {\n         static box_key: Key<@()> = &Key;\n         static int_key: Key<int> = &Key;\n         task::spawn(proc() {\n-            set(str_key, \"string data\".to_owned());\n-            set(box_key, @());\n-            set(int_key, 42);\n+            str_key.replace(Some(\"string data\".to_owned()));\n+            box_key.replace(Some(@()));\n+            int_key.replace(Some(42));\n         });\n     }\n \n     #[test]\n-    #[allow(dead_code)]\n     fn test_tls_overwrite_multiple_types() {\n         static str_key: Key<~str> = &Key;\n         static box_key: Key<@()> = &Key;\n         static int_key: Key<int> = &Key;\n         task::spawn(proc() {\n-            set(str_key, \"string data\".to_owned());\n-            set(str_key, \"string data 2\".to_owned());\n-            set(box_key, @());\n-            set(box_key, @());\n-            set(int_key, 42);\n+            str_key.replace(Some(\"string data\".to_owned()));\n+            str_key.replace(Some(\"string data 2\".to_owned()));\n+            box_key.replace(Some(@()));\n+            box_key.replace(Some(@()));\n+            int_key.replace(Some(42));\n             // This could cause a segfault if overwriting-destruction is done\n             // with the crazy polymorphic transmute rather than the provided\n             // finaliser.\n-            set(int_key, 31337);\n+            int_key.replace(Some(31337));\n         });\n     }\n \n@@ -464,60 +358,41 @@ mod tests {\n         static str_key: Key<~str> = &Key;\n         static box_key: Key<@()> = &Key;\n         static int_key: Key<int> = &Key;\n-        set(str_key, \"parent data\".to_owned());\n-        set(box_key, @());\n+        str_key.replace(Some(\"parent data\".to_owned()));\n+        box_key.replace(Some(@()));\n         task::spawn(proc() {\n-            // spawn_linked\n-            set(str_key, \"string data\".to_owned());\n-            set(box_key, @());\n-            set(int_key, 42);\n+            str_key.replace(Some(\"string data\".to_owned()));\n+            box_key.replace(Some(@()));\n+            int_key.replace(Some(42));\n             fail!();\n         });\n         // Not quite nondeterministic.\n-        set(int_key, 31337);\n+        int_key.replace(Some(31337));\n         fail!();\n     }\n \n     #[test]\n     fn test_static_pointer() {\n         static key: Key<&'static int> = &Key;\n         static VALUE: int = 0;\n-        let v: &'static int = &VALUE;\n-        set(key, v);\n+        key.replace(Some(&VALUE));\n     }\n \n     #[test]\n     fn test_owned() {\n         static key: Key<Box<int>> = &Key;\n-        set(key, box 1);\n-\n-        get(key, |v| {\n-            get(key, |v| {\n-                get(key, |v| {\n-                    assert_eq!(**v.unwrap(), 1);\n-                });\n-                assert_eq!(**v.unwrap(), 1);\n-            });\n-            assert_eq!(**v.unwrap(), 1);\n-        });\n-        set(key, box 2);\n-        get(key, |v| {\n-            assert_eq!(**v.unwrap(), 2);\n-        })\n-    }\n-\n-    #[test]\n-    fn test_get_mut() {\n-        static key: Key<int> = &Key;\n-        set(key, 1);\n-\n-        get_mut(key, |v| {\n-            *v.unwrap() = 2;\n-        });\n-\n-        get(key, |v| {\n-            assert_eq!(*v.unwrap(), 2);\n-        })\n+        key.replace(Some(box 1));\n+\n+        {\n+            let k1 = key.get().unwrap();\n+            let k2 = key.get().unwrap();\n+            let k3 = key.get().unwrap();\n+            assert_eq!(**k1, 1);\n+            assert_eq!(**k2, 1);\n+            assert_eq!(**k3, 1);\n+        }\n+        key.replace(Some(box 2));\n+        assert_eq!(**key.get().unwrap(), 2);\n     }\n \n     #[test]\n@@ -527,56 +402,26 @@ mod tests {\n         static key3: Key<int> = &Key;\n         static key4: Key<int> = &Key;\n         static key5: Key<int> = &Key;\n-        set(key1, 1);\n-        set(key2, 2);\n-        set(key3, 3);\n-        set(key4, 4);\n-        set(key5, 5);\n-\n-        get(key1, |x| assert_eq!(*x.unwrap(), 1));\n-        get(key2, |x| assert_eq!(*x.unwrap(), 2));\n-        get(key3, |x| assert_eq!(*x.unwrap(), 3));\n-        get(key4, |x| assert_eq!(*x.unwrap(), 4));\n-        get(key5, |x| assert_eq!(*x.unwrap(), 5));\n+        key1.replace(Some(1));\n+        key2.replace(Some(2));\n+        key3.replace(Some(3));\n+        key4.replace(Some(4));\n+        key5.replace(Some(5));\n+\n+        assert_eq!(*key1.get().unwrap(), 1);\n+        assert_eq!(*key2.get().unwrap(), 2);\n+        assert_eq!(*key3.get().unwrap(), 3);\n+        assert_eq!(*key4.get().unwrap(), 4);\n+        assert_eq!(*key5.get().unwrap(), 5);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_nested_get_set1() {\n         static key: Key<int> = &Key;\n-        set(key, 4);\n-        get(key, |_| {\n-            set(key, 4);\n-        })\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_nested_get_mut2() {\n-        static key: Key<int> = &Key;\n-        set(key, 4);\n-        get(key, |_| {\n-            get_mut(key, |_| {})\n-        })\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_nested_get_mut3() {\n-        static key: Key<int> = &Key;\n-        set(key, 4);\n-        get_mut(key, |_| {\n-            get(key, |_| {})\n-        })\n-    }\n+        key.replace(Some(4));\n \n-    #[test]\n-    #[should_fail]\n-    fn test_nested_get_mut4() {\n-        static key: Key<int> = &Key;\n-        set(key, 4);\n-        get_mut(key, |_| {\n-            get_mut(key, |_| {})\n-        })\n+        let _k = key.get();\n+        key.replace(Some(4));\n     }\n }"}, {"sha": "1efe56756eddebced081f29b246cc564c47d2a3c", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -289,12 +289,10 @@ macro_rules! println(\n /// # Example\n ///\n /// ```\n-/// use std::local_data;\n-///\n /// local_data_key!(my_integer: int)\n ///\n-/// local_data::set(my_integer, 2);\n-/// local_data::get(my_integer, |val| println!(\"{}\", val.map(|i| *i)));\n+/// my_integer.replace(Some(2));\n+/// println!(\"{}\", my_integer.get().map(|a| *a));\n /// ```\n #[macro_export]\n macro_rules! local_data_key("}, {"sha": "68d8c446cf9a98462358949db6144b0920fffd9b", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -414,13 +414,12 @@ mod test {\n \n     #[test]\n     fn tls() {\n-        use local_data;\n         local_data_key!(key: @~str)\n-        local_data::set(key, @\"data\".to_owned());\n-        assert!(*local_data::get(key, |k| k.map(|k| *k)).unwrap() == \"data\".to_owned());\n+        key.replace(Some(@\"data\".to_owned()));\n+        assert_eq!(key.get().unwrap().as_slice(), \"data\");\n         local_data_key!(key2: @~str)\n-        local_data::set(key2, @\"data\".to_owned());\n-        assert!(*local_data::get(key2, |k| k.map(|k| *k)).unwrap() == \"data\".to_owned());\n+        key2.replace(Some(@\"data\".to_owned()));\n+        assert_eq!(key2.get().unwrap().as_slice(), \"data\");\n     }\n \n     #[test]"}, {"sha": "35800048d2872fd9d79c766d8287756438a149aa", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -3112,7 +3112,6 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_from_elem_fail() {\n-        use cast;\n         use cell::Cell;\n         use rc::Rc;\n "}, {"sha": "6ac3becf0b68dc2030ca0c2c404e059eca72b246", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -18,7 +18,6 @@\n use ast::{Ident, Mrk, Name, SyntaxContext};\n \n use std::cell::RefCell;\n-use std::local_data;\n use std::rc::Rc;\n \n use collections::HashMap;\n@@ -91,17 +90,14 @@ fn new_rename_internal(id: Ident,\n pub fn with_sctable<T>(op: |&SCTable| -> T) -> T {\n     local_data_key!(sctable_key: Rc<SCTable>)\n \n-    local_data::get(sctable_key, |opt_ts| {\n-        let table = match opt_ts {\n-            None => {\n-                let ts = Rc::new(new_sctable_internal());\n-                local_data::set(sctable_key, ts.clone());\n-                ts\n-            }\n-            Some(ts) => ts.clone()\n-        };\n-        op(&*table)\n-    })\n+    match sctable_key.get() {\n+        Some(ts) => op(&**ts),\n+        None => {\n+            let ts = Rc::new(new_sctable_internal());\n+            sctable_key.replace(Some(ts.clone()));\n+            op(&*ts)\n+        }\n+    }\n }\n \n // Make a fresh syntax context table with EmptyCtxt in slot zero\n@@ -154,17 +150,14 @@ type ResolveTable = HashMap<(Name,SyntaxContext),Name>;\n fn with_resolve_table_mut<T>(op: |&mut ResolveTable| -> T) -> T {\n     local_data_key!(resolve_table_key: Rc<RefCell<ResolveTable>>)\n \n-    local_data::get(resolve_table_key, |opt_ts| {\n-        let table = match opt_ts {\n-            None => {\n-                let ts = Rc::new(RefCell::new(HashMap::new()));\n-                local_data::set(resolve_table_key, ts.clone());\n-                ts\n-            }\n-            Some(ts) => ts.clone()\n-        };\n-        op(&mut *table.borrow_mut())\n-    })\n+    match resolve_table_key.get() {\n+        Some(ts) => op(&mut *ts.borrow_mut()),\n+        None => {\n+            let ts = Rc::new(RefCell::new(HashMap::new()));\n+            resolve_table_key.replace(Some(ts.clone()));\n+            op(&mut *ts.borrow_mut())\n+        }\n+    }\n }\n \n // Resolve a syntax object to a name, per MTWT."}, {"sha": "131e744d83d0cd3cf2ab3f72b4aba1e50b5ba290", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -19,7 +19,6 @@ use util::interner;\n use serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::cast;\n use std::fmt;\n-use std::local_data;\n use std::path::BytesContainer;\n use std::rc::Rc;\n use std::strbuf::StrBuf;\n@@ -529,11 +528,11 @@ pub type IdentInterner = StrInterner;\n // FIXME(eddyb) #8726 This should probably use a task-local reference.\n pub fn get_ident_interner() -> Rc<IdentInterner> {\n     local_data_key!(key: Rc<::parse::token::IdentInterner>)\n-    match local_data::get(key, |k| k.map(|k| k.clone())) {\n-        Some(interner) => interner,\n+    match key.get() {\n+        Some(interner) => interner.clone(),\n         None => {\n             let interner = Rc::new(mk_fresh_ident_interner());\n-            local_data::set(key, interner.clone());\n+            key.replace(Some(interner.clone()));\n             interner\n         }\n     }"}, {"sha": "670673fe047cc00bd2144583aa1810150d965f4f", "filename": "src/test/auxiliary/macro_crate_outlive_expansion_phase.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Ftest%2Fauxiliary%2Fmacro_crate_outlive_expansion_phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Ftest%2Fauxiliary%2Fmacro_crate_outlive_expansion_phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_outlive_expansion_phase.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -15,7 +15,6 @@\n extern crate syntax;\n \n use std::any::Any;\n-use std::local_data;\n use syntax::ast::Name;\n use syntax::ext::base::SyntaxExtension;\n \n@@ -30,6 +29,6 @@ impl Drop for Foo {\n #[macro_registrar]\n pub fn registrar(_: |Name, SyntaxExtension|) {\n     local_data_key!(foo: Box<Any:Send>);\n-    local_data::set(foo, box Foo { foo: 10 } as Box<Any:Send>);\n+    foo.replace(Some(box Foo { foo: 10 } as Box<Any:Send>));\n }\n "}, {"sha": "2344bd0f090fdbe1c40cdee4dd3264fec770dde9", "filename": "src/test/compile-fail/core-tls-store-pointer.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -10,8 +10,6 @@\n \n // Testing that we can't store a reference it task-local storage\n \n-use std::local_data;\n-\n local_data_key!(key: @&int)\n //~^ ERROR missing lifetime specifier\n "}, {"sha": "ec0e656cc292740d5294cc0a65b7d720a58daaf9", "filename": "src/test/compile-fail/macro-local-data-key-priv.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Ftest%2Fcompile-fail%2Fmacro-local-data-key-priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Ftest%2Fcompile-fail%2Fmacro-local-data-key-priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-local-data-key-priv.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::local_data;\n-\n // check that the local data keys are private by default.\n \n mod bar {\n     local_data_key!(baz: f64)\n }\n \n fn main() {\n-    local_data::set(bar::baz, -10.0);\n+    bar::baz.replace(Some(-10.0));\n     //~^ ERROR static `baz` is private\n }"}, {"sha": "730b0b08d451abda2f3ba88e005a09303164d430", "filename": "src/test/run-pass/macro-local-data-key.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Ftest%2Frun-pass%2Fmacro-local-data-key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab92ea526d455b402efbccc7160c8aec0237c88f/src%2Ftest%2Frun-pass%2Fmacro-local-data-key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-local-data-key.rs?ref=ab92ea526d455b402efbccc7160c8aec0237c88f", "patch": "@@ -8,21 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::local_data;\n-\n local_data_key!(foo: int)\n \n mod bar {\n     local_data_key!(pub baz: f64)\n }\n \n pub fn main() {\n-    local_data::get(foo, |x| assert!(x.is_none()));\n-    local_data::get(bar::baz, |y| assert!(y.is_none()));\n+    assert!(foo.get().is_none());\n+    assert!(bar::baz.get().is_none());\n \n-    local_data::set(foo, 3);\n-    local_data::set(bar::baz, -10.0);\n+    foo.replace(Some(3));\n+    bar::baz.replace(Some(-10.0));\n \n-    local_data::get(foo, |x| assert_eq!(*x.unwrap(), 3));\n-    local_data::get(bar::baz, |y| assert_eq!(*y.unwrap(), -10.0));\n+    assert_eq!(*foo.get().unwrap(), 3);\n+    assert_eq!(*bar::baz.get().unwrap(), -10.0);\n }"}]}