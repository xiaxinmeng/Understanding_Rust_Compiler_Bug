{"sha": "eba459a5c2abf1c6869f0947e297b0805cdc27ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViYTQ1OWE1YzJhYmYxYzY4NjlmMDk0N2UyOTdiMDgwNWNkYzI3ZWY=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-18T05:20:11Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-18T05:20:11Z"}, "message": "shard out misc section on lifetimes properly", "tree": {"sha": "ea285100a69fc546992b8d47fcf171ae2b76b07e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea285100a69fc546992b8d47fcf171ae2b76b07e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eba459a5c2abf1c6869f0947e297b0805cdc27ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eba459a5c2abf1c6869f0947e297b0805cdc27ef", "html_url": "https://github.com/rust-lang/rust/commit/eba459a5c2abf1c6869f0947e297b0805cdc27ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eba459a5c2abf1c6869f0947e297b0805cdc27ef/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1b899e57a7aa5cec0380900465e0d7d443762d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1b899e57a7aa5cec0380900465e0d7d443762d2", "html_url": "https://github.com/rust-lang/rust/commit/d1b899e57a7aa5cec0380900465e0d7d443762d2"}], "stats": {"total": 358, "additions": 357, "deletions": 1}, "files": [{"sha": "b0d75bfc85c9600b0dce5e517ae7c927da797a59", "filename": "src/doc/tarpl/SUMMARY.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eba459a5c2abf1c6869f0947e297b0805cdc27ef/src%2Fdoc%2Ftarpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/eba459a5c2abf1c6869f0947e297b0805cdc27ef/src%2Fdoc%2Ftarpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2FSUMMARY.md?ref=eba459a5c2abf1c6869f0947e297b0805cdc27ef", "patch": "@@ -15,7 +15,9 @@\n \t* [Unbounded Lifetimes](unbounded-lifetimes.md)\n \t* [Higher-Rank Trait Bounds](hrtb.md)\n \t* [Subtyping and Variance](subtyping.md)\n-\t* [Misc](lifetime-misc.md)\n+\t* [Drop Check](dropck.md)\n+\t* [PhantomData](phantom-data.md)\n+\t* [Splitting Lifetimes](lifetime-splitting.md)\n * [Type Conversions](conversions.md)\n \t* [Coercions](coercions.md)\n \t* [The Dot Operator](dot-operator.md)"}, {"sha": "e1a25f513c7faebe27b87929559a7ab263e6d6ca", "filename": "src/doc/tarpl/dropck.md", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/eba459a5c2abf1c6869f0947e297b0805cdc27ef/src%2Fdoc%2Ftarpl%2Fdropck.md", "raw_url": "https://github.com/rust-lang/rust/raw/eba459a5c2abf1c6869f0947e297b0805cdc27ef/src%2Fdoc%2Ftarpl%2Fdropck.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdropck.md?ref=eba459a5c2abf1c6869f0947e297b0805cdc27ef", "patch": "@@ -0,0 +1,127 @@\n+% Drop Check\n+\n+We have seen how lifetimes provide us some fairly simple rules for ensuring\n+that never read dangling references. However up to this point we have only ever\n+interacted with the *outlives* relationship in an inclusive manner. That is,\n+when we talked about `'a: 'b`, it was ok for `'a` to live *exactly* as long as\n+`'b`. At first glance, this seems to be a meaningless distinction. Nothing ever\n+gets dropped at the same time as another, right? This is why we used the\n+following desugarring of `let` statements:\n+\n+```rust\n+let x;\n+let y;\n+```\n+\n+```rust\n+{\n+    let x;\n+    {\n+        let y;\n+    }\n+}\n+```\n+\n+Each creates its own scope, clearly establishing that one drops before the\n+other. However, what if we do the following?\n+\n+```rust\n+let (x, y) = (vec![], vec![]);\n+```\n+\n+Does either value strictly outlive the other? The answer is in fact *no*,\n+neither value  strictly outlives the other. Of course, one of x or y will be\n+dropped before the other, but the actual order is not specified. Tuples aren't\n+special in this regard; composite structures just don't guarantee their\n+destruction order as of Rust 1.0.\n+\n+We *could* specify this for the fields of built-in composites like tuples and\n+structs. However, what about something like Vec? Vec has to manually drop its\n+elements via pure-library code. In general, anything that implements Drop has\n+a chance to fiddle with its innards during its final death knell. Therefore\n+the compiler can't sufficiently reason about the actual destruction order\n+of the contents of any type that implements Drop.\n+\n+So why do we care? We care because if the type system isn't careful, it could\n+accidentally make dangling pointers. Consider the following simple program:\n+\n+```rust\n+struct Inspector<'a>(&'a u8);\n+\n+fn main() {\n+    let (days, inspector);\n+    days = Box::new(1);\n+    inspector = Inspector(&days);\n+}\n+```\n+\n+This program is totally sound and compiles today. The fact that `days` does\n+not *strictly* outlive `inspector` doesn't matter. As long as the `inspector`\n+is alive, so is days.\n+\n+However if we add a destructor, the program will no longer compile!\n+\n+```rust,ignore\n+struct Inspector<'a>(&'a u8);\n+\n+impl<'a> Drop for Inspector<'a> {\n+    fn drop(&mut self) {\n+        println!(\"I was only {} days from retirement!\", self.0);\n+    }\n+}\n+\n+fn main() {\n+    let (days, inspector);\n+    days = Box::new(1);\n+    inspector = Inspector(&days);\n+    // Let's say `days` happens to get dropped first.\n+    // Then when Inspector is dropped, it will try to read free'd memory!\n+}\n+```\n+\n+```text\n+<anon>:12:28: 12:32 error: `days` does not live long enough\n+<anon>:12     inspector = Inspector(&days);\n+                                     ^~~~\n+<anon>:9:11: 15:2 note: reference must be valid for the block at 9:10...\n+<anon>:9 fn main() {\n+<anon>:10     let (days, inspector);\n+<anon>:11     days = Box::new(1);\n+<anon>:12     inspector = Inspector(&days);\n+<anon>:13     // Let's say `days` happens to get dropped first.\n+<anon>:14     // Then when Inspector is dropped, it will try to read free'd memory!\n+          ...\n+<anon>:10:27: 15:2 note: ...but borrowed value is only valid for the block suffix following statement 0 at 10:26\n+<anon>:10     let (days, inspector);\n+<anon>:11     days = Box::new(1);\n+<anon>:12     inspector = Inspector(&days);\n+<anon>:13     // Let's say `days` happens to get dropped first.\n+<anon>:14     // Then when Inspector is dropped, it will try to read free'd memory!\n+<anon>:15 }\n+```\n+\n+Implementing Drop lets the Inspector execute some arbitrary code *during* its\n+death. This means it can potentially observe that types that are supposed to\n+live as long as it does actually were destroyed first.\n+\n+Interestingly, only *generic* types need to worry about this. If they aren't\n+generic, then the only lifetimes they can harbor are `'static`, which will truly\n+live *forever*. This is why this problem is referred to as *sound generic drop*.\n+Sound generic drop is enforced by the *drop checker*. As of this writing, some\n+of the finer details of how the drop checker validates types is totally up in\n+the air. However The Big Rule is the subtlety that we have focused on this whole\n+section:\n+\n+**For a generic type to soundly implement drop, it must strictly outlive all of\n+its generic arguments.**\n+\n+This rule is sufficient but not necessary to satisfy the drop checker. That is,\n+if your type obeys this rule then it's *definitely* sound to drop. However\n+there are special cases where you can fail to satisfy this, but still\n+successfully pass the borrow checker. These are the precise rules that are\n+currently up in the air.\n+\n+It turns out that when writing unsafe code, we generally don't need to\n+worry at all about doing the right thing for the drop checker. However there\n+is *one* special case that you need to worry about, which we will look at in\n+the next section."}, {"sha": "7ab2d379ffd5991dce6f4c994bb4cb12cd3383aa", "filename": "src/doc/tarpl/lifetime-splitting.md", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/eba459a5c2abf1c6869f0947e297b0805cdc27ef/src%2Fdoc%2Ftarpl%2Flifetime-splitting.md", "raw_url": "https://github.com/rust-lang/rust/raw/eba459a5c2abf1c6869f0947e297b0805cdc27ef/src%2Fdoc%2Ftarpl%2Flifetime-splitting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Flifetime-splitting.md?ref=eba459a5c2abf1c6869f0947e297b0805cdc27ef", "patch": "@@ -0,0 +1,140 @@\n+% Splitting Lifetimes\n+\n+The mutual exclusion property of mutable references can be very limiting when\n+working with a composite structure. The borrow checker understands some basic stuff, but\n+will fall over pretty easily. It *does* understand structs sufficiently to\n+know that it's possible to borrow disjoint fields of a struct simultaneously.\n+So this works today:\n+\n+```rust\n+struct Foo {\n+    a: i32,\n+    b: i32,\n+    c: i32,\n+}\n+\n+let mut x = Foo {a: 0, b: 0, c: 0};\n+let a = &mut x.a;\n+let b = &mut x.b;\n+let c = &x.c;\n+*b += 1;\n+let c2 = &x.c;\n+*a += 10;\n+println!(\"{} {} {} {}\", a, b, c, c2);\n+```\n+\n+However borrowck doesn't understand arrays or slices in any way, so this doesn't\n+work:\n+\n+```rust,ignore\n+let x = [1, 2, 3];\n+let a = &mut x[0];\n+let b = &mut x[1];\n+println!(\"{} {}\", a, b);\n+```\n+\n+```text\n+<anon>:3:18: 3:22 error: cannot borrow immutable indexed content `x[..]` as mutable\n+<anon>:3     let a = &mut x[0];\n+                          ^~~~\n+<anon>:4:18: 4:22 error: cannot borrow immutable indexed content `x[..]` as mutable\n+<anon>:4     let b = &mut x[1];\n+                          ^~~~\n+error: aborting due to 2 previous errors\n+```\n+\n+While it was plausible that borrowck could understand this simple case, it's\n+pretty clearly hopeless for borrowck to understand disjointness in general\n+container types like a tree, especially if distinct keys actually *do* map\n+to the same value.\n+\n+In order to \"teach\" borrowck that what we're doing is ok, we need to drop down\n+to unsafe code. For instance, mutable slices expose a `split_at_mut` function that\n+consumes the slice and returns *two* mutable slices. One for everything to the\n+left of the index, and one for everything to the right. Intuitively we know this\n+is safe because the slices don't alias. However the implementation requires some\n+unsafety:\n+\n+```rust,ignore\n+fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n+    unsafe {\n+        let self2: &mut [T] = mem::transmute_copy(&self);\n+\n+        (ops::IndexMut::index_mut(self, ops::RangeTo { end: mid } ),\n+         ops::IndexMut::index_mut(self2, ops::RangeFrom { start: mid } ))\n+    }\n+}\n+```\n+\n+This is pretty plainly dangerous. We use transmute to duplicate the slice with an\n+*unbounded* lifetime, so that it can be treated as disjoint from the other until\n+we unify them when we return.\n+\n+However more subtle is how iterators that yield mutable references work.\n+The iterator trait is defined as follows:\n+\n+```rust\n+trait Iterator {\n+    type Item;\n+\n+    fn next(&mut self) -> Option<Self::Item>;\n+}\n+```\n+\n+Given this definition, Self::Item has *no* connection to `self`. This means\n+that we can call `next` several times in a row, and hold onto all the results\n+*concurrently*. This is perfectly fine for by-value iterators, which have exactly\n+these semantics. It's also actually fine for shared references, as they admit\n+arbitrarily many references to the same thing (although the\n+iterator needs to be a separate object from the thing being shared). But mutable\n+references make this a mess. At first glance, they might seem completely\n+incompatible with this API, as it would produce multiple mutable references to\n+the same object!\n+\n+However it actually *does* work, exactly because iterators are one-shot objects.\n+Everything an IterMut yields will be yielded *at most* once, so we don't *actually*\n+ever yield multiple mutable references to the same piece of data.\n+\n+In general all mutable iterators require *some* unsafe code *somewhere*, though.\n+Whether it's raw pointers, or safely composing on top of *another* IterMut.\n+\n+For instance, VecDeque's IterMut:\n+\n+```rust,ignore\n+struct IterMut<'a, T:'a> {\n+    // The whole backing array. Some of these indices are initialized!\n+    ring: &'a mut [T],\n+    tail: usize,\n+    head: usize,\n+}\n+\n+impl<'a, T> Iterator for IterMut<'a, T> {\n+    type Item = &'a mut T;\n+\n+    fn next(&mut self) -> Option<&'a mut T> {\n+        if self.tail == self.head {\n+            return None;\n+        }\n+        let tail = self.tail;\n+        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n+\n+        unsafe {\n+            // might as well do unchecked indexing since wrap_index has us\n+            // in-bounds, and many of the \"middle\" indices are uninitialized\n+            // anyway.\n+            let elem = self.ring.get_unchecked_mut(tail);\n+\n+            // round-trip through a raw pointer to unbound the lifetime from\n+            // ourselves\n+            Some(&mut *(elem as *mut _))\n+        }\n+    }\n+}\n+```\n+\n+A very subtle but interesting detail in this design is that it *relies on\n+privacy to be sound*. Borrowck works on some very simple rules. One of those rules\n+is that if we have a live &mut Foo and Foo contains an &mut Bar, then that &mut\n+Bar is *also* live. Since IterMut is always live when `next` can be called, if\n+`ring` were public then we could mutate `ring` while outstanding mutable borrows\n+to it exist!"}, {"sha": "034f31784295df76ba3fdc05b2e9bd40cee91fe3", "filename": "src/doc/tarpl/phantom-data.md", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/eba459a5c2abf1c6869f0947e297b0805cdc27ef/src%2Fdoc%2Ftarpl%2Fphantom-data.md", "raw_url": "https://github.com/rust-lang/rust/raw/eba459a5c2abf1c6869f0947e297b0805cdc27ef/src%2Fdoc%2Ftarpl%2Fphantom-data.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fphantom-data.md?ref=eba459a5c2abf1c6869f0947e297b0805cdc27ef", "patch": "@@ -0,0 +1,87 @@\n+% PhantomData\n+\n+When working with unsafe code, we can often end up in a situation where\n+types or lifetimes are logically associated with a struct, but not actually\n+part of a field. This most commonly occurs with lifetimes. For instance, the\n+`Iter` for `&'a [T]` is (approximately) defined as follows:\n+\n+```rust,ignore\n+struct Iter<'a, T: 'a> {\n+    ptr: *const T,\n+    end: *const T,\n+}\n+```\n+\n+However because `'a` is unused within the struct's body, it's *unbounded*.\n+Because of the troubles this has historically caused, unbounded lifetimes and\n+types are *illegal* in struct definitions. Therefore we must somehow refer\n+to these types in the body. Correctly doing this is necessary to have\n+correct variance and drop checking.\n+\n+We do this using *PhantomData*, which is a special marker type. PhantomData\n+consumes no space, but simulates a field of the given type for the purpose of\n+static analysis. This was deemed to be less error-prone than explicitly telling\n+the type-system the kind of variance that you want, while also providing other\n+useful such as the information needed by drop check.\n+\n+Iter logically contains a bunch of `&'a T`s, so this is exactly what we tell\n+the PhantomData to simulate:\n+\n+```\n+use std::marker;\n+\n+struct Iter<'a, T: 'a> {\n+    ptr: *const T,\n+    end: *const T,\n+    _marker: marker::PhantomData<&'a T>,\n+}\n+```\n+\n+and that's it. The lifetime will be bounded, and your iterator will be variant\n+over `'a` and `T`. Everything Just Works.\n+\n+Another important example is Vec, which is (approximately) defined as follows:\n+\n+```\n+struct Vec<T> {\n+    data: *const T, // *const for variance!\n+    len: usize,\n+    cap: usize,\n+}\n+```\n+\n+Unlike the previous example it *appears* that everything is exactly as we\n+want. Every generic argument to Vec shows up in the at least one field.\n+Good to go!\n+\n+Nope.\n+\n+The drop checker will generously determine that Vec<T> does not own any values\n+of type T. This will in turn make it conclude that it does *not* need to worry\n+about Vec dropping any T's in its destructor for determining drop check\n+soundness. This will in turn allow people to create unsoundness using\n+Vec's destructor.\n+\n+In order to tell dropck that we *do* own values of type T, and therefore may\n+drop some T's when *we* drop, we must add an extra PhantomData saying exactly\n+that:\n+\n+```\n+use std::marker;\n+\n+struct Vec<T> {\n+    data: *const T, // *const for covariance!\n+    len: usize,\n+    cap: usize,\n+    _marker: marker::PhantomData<T>,\n+}\n+```\n+\n+Raw pointers that own an allocation is such a pervasive pattern that the\n+standard library made a utility for itself called `Unique<T>` which:\n+\n+* wraps a `*const T` for variance\n+* includes a `PhantomData<T>`,\n+* auto-derives Send/Sync as if T was contained\n+* marks the pointer as NonZero for the null-pointer optimization\n+"}]}