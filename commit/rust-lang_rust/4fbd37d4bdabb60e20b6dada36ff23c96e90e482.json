{"sha": "4fbd37d4bdabb60e20b6dada36ff23c96e90e482", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmYmQzN2Q0YmRhYmI2MGUyMGI2ZGFkYTM2ZmYyM2M5NmU5MGU0ODI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-31T05:34:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-31T05:34:20Z"}, "message": "auto merge of #8135 : dim-an/rust/master, r=pcwalton\n\nFix std::getopt::opts_str\r\n\r\nCloses #6492 (std::getopt::opts_str fails for arguments other than the first one).", "tree": {"sha": "241454d2abee309d670312be8a939dfc9887e04e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/241454d2abee309d670312be8a939dfc9887e04e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fbd37d4bdabb60e20b6dada36ff23c96e90e482", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fbd37d4bdabb60e20b6dada36ff23c96e90e482", "html_url": "https://github.com/rust-lang/rust/commit/4fbd37d4bdabb60e20b6dada36ff23c96e90e482", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fbd37d4bdabb60e20b6dada36ff23c96e90e482/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38d62feec1e65ba5ed57235355053782ca15b5ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/38d62feec1e65ba5ed57235355053782ca15b5ff", "html_url": "https://github.com/rust-lang/rust/commit/38d62feec1e65ba5ed57235355053782ca15b5ff"}, {"sha": "ef7e94550ccfdcf9d114c3eb6f0f9279742c611f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef7e94550ccfdcf9d114c3eb6f0f9279742c611f", "html_url": "https://github.com/rust-lang/rust/commit/ef7e94550ccfdcf9d114c3eb6f0f9279742c611f"}], "stats": {"total": 65, "additions": 47, "deletions": 18}, "files": [{"sha": "e2543017a8d6805fd2b7ac55fb0f05a0ccf70b7b", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 47, "deletions": 18, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/4fbd37d4bdabb60e20b6dada36ff23c96e90e482/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fbd37d4bdabb60e20b6dada36ff23c96e90e482/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=4fbd37d4bdabb60e20b6dada36ff23c96e90e482", "patch": "@@ -140,7 +140,9 @@ pub fn optflag(name: &str) -> Opt {\n     return Opt {name: mkname(name), hasarg: No, occur: Optional};\n }\n \n-/// Create an option that is optional and does not take an argument\n+/** Create an option that is optional, does not take an argument,\n+  * and may occur multiple times.\n+  */\n pub fn optflagmulti(name: &str) -> Opt {\n     return Opt {name: mkname(name), hasarg: No, occur: Multi};\n }\n@@ -369,7 +371,14 @@ fn opt_vals(mm: &Matches, nm: &str) -> ~[Optval] {\n     };\n }\n \n-fn opt_val(mm: &Matches, nm: &str) -> Optval { opt_vals(mm, nm)[0].clone() }\n+fn opt_val(mm: &Matches, nm: &str) -> Option<Optval> {\n+    let vals = opt_vals(mm, nm);\n+    if (vals.is_empty()) {\n+        None\n+    } else {\n+        Some(opt_vals(mm, nm)[0].clone())\n+    }\n+}\n \n /// Returns true if an option was matched\n pub fn opt_present(mm: &Matches, nm: &str) -> bool {\n@@ -400,7 +409,10 @@ pub fn opts_present(mm: &Matches, names: &[~str]) -> bool {\n  * argument\n  */\n pub fn opt_str(mm: &Matches, nm: &str) -> ~str {\n-    return match opt_val(mm, nm) { Val(s) => s, _ => fail!() };\n+    return match opt_val(mm, nm) {\n+        Some(Val(s)) => s,\n+        _ => fail!()\n+    };\n }\n \n /**\n@@ -412,7 +424,7 @@ pub fn opt_str(mm: &Matches, nm: &str) -> ~str {\n pub fn opts_str(mm: &Matches, names: &[~str]) -> ~str {\n     for names.iter().advance |nm| {\n         match opt_val(mm, *nm) {\n-          Val(ref s) => return (*s).clone(),\n+          Some(Val(ref s)) => return (*s).clone(),\n           _ => ()\n         }\n     }\n@@ -1318,24 +1330,41 @@ mod tests {\n \n     #[test]\n     fn test_multi() {\n-        let args = ~[~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\"];\n         let opts = ~[optopt(\"e\"), optopt(\"encrypt\"), optopt(\"f\")];\n-        let matches = &match getopts(args, opts) {\n+\n+        let args_single = ~[~\"-e\", ~\"foo\"];\n+        let matches_single = &match getopts(args_single, opts) {\n+          result::Ok(m) => m,\n+          result::Err(_) => fail!()\n+        };\n+        assert!(opts_present(matches_single, [~\"e\"]));\n+        assert!(opts_present(matches_single, [~\"encrypt\", ~\"e\"]));\n+        assert!(opts_present(matches_single, [~\"e\", ~\"encrypt\"]));\n+        assert!(!opts_present(matches_single, [~\"encrypt\"]));\n+        assert!(!opts_present(matches_single, [~\"thing\"]));\n+        assert!(!opts_present(matches_single, []));\n+\n+        assert_eq!(opts_str(matches_single, [~\"e\"]), ~\"foo\");\n+        assert_eq!(opts_str(matches_single, [~\"e\", ~\"encrypt\"]), ~\"foo\");\n+        assert_eq!(opts_str(matches_single, [~\"encrypt\", ~\"e\"]), ~\"foo\");\n+\n+        let args_both = ~[~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\"];\n+        let matches_both = &match getopts(args_both, opts) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert!(opts_present(matches, [~\"e\"]));\n-        assert!(opts_present(matches, [~\"encrypt\"]));\n-        assert!(opts_present(matches, [~\"encrypt\", ~\"e\"]));\n-        assert!(opts_present(matches, [~\"e\", ~\"encrypt\"]));\n-        assert!(!opts_present(matches, [~\"f\"]));\n-        assert!(!opts_present(matches, [~\"thing\"]));\n-        assert!(!opts_present(matches, []));\n-\n-        assert_eq!(opts_str(matches, [~\"e\"]), ~\"foo\");\n-        assert_eq!(opts_str(matches, [~\"encrypt\"]), ~\"foo\");\n-        assert_eq!(opts_str(matches, [~\"e\", ~\"encrypt\"]), ~\"foo\");\n-        assert_eq!(opts_str(matches, [~\"encrypt\", ~\"e\"]), ~\"foo\");\n+        assert!(opts_present(matches_both, [~\"e\"]));\n+        assert!(opts_present(matches_both, [~\"encrypt\"]));\n+        assert!(opts_present(matches_both, [~\"encrypt\", ~\"e\"]));\n+        assert!(opts_present(matches_both, [~\"e\", ~\"encrypt\"]));\n+        assert!(!opts_present(matches_both, [~\"f\"]));\n+        assert!(!opts_present(matches_both, [~\"thing\"]));\n+        assert!(!opts_present(matches_both, []));\n+\n+        assert_eq!(opts_str(matches_both, [~\"e\"]), ~\"foo\");\n+        assert_eq!(opts_str(matches_both, [~\"encrypt\"]), ~\"foo\");\n+        assert_eq!(opts_str(matches_both, [~\"e\", ~\"encrypt\"]), ~\"foo\");\n+        assert_eq!(opts_str(matches_both, [~\"encrypt\", ~\"e\"]), ~\"foo\");\n     }\n \n     #[test]"}]}