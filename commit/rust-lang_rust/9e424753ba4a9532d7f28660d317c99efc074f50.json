{"sha": "9e424753ba4a9532d7f28660d317c99efc074f50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllNDI0NzUzYmE0YTk1MzJkN2YyODY2MGQzMTdjOTllZmMwNzRmNTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-29T11:52:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-29T11:52:02Z"}, "message": "Auto merge of #802 - RalfJung:machine, r=RalfJung\n\nsome lib.rs refactoring\n\nTaken out of https://github.com/rust-lang/miri/pull/799 so that we can land it now and resolve merge conflicts instead of dragging them along.\n\nSplits lib.rs into machine.rs for the machine state and trait impl, and eval.rs for the main evaluator loop and setting up the initial stack frame.", "tree": {"sha": "4c52de35b96406ec5d464982cc50f9a25ca08ec4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c52de35b96406ec5d464982cc50f9a25ca08ec4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e424753ba4a9532d7f28660d317c99efc074f50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e424753ba4a9532d7f28660d317c99efc074f50", "html_url": "https://github.com/rust-lang/rust/commit/9e424753ba4a9532d7f28660d317c99efc074f50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e424753ba4a9532d7f28660d317c99efc074f50/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc969f1a4c24dcd9a2c3a4ce6e55faef7b711062", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc969f1a4c24dcd9a2c3a4ce6e55faef7b711062", "html_url": "https://github.com/rust-lang/rust/commit/bc969f1a4c24dcd9a2c3a4ce6e55faef7b711062"}, {"sha": "67d3779b0ce5a1f2e735e4497af5321a9000105a", "url": "https://api.github.com/repos/rust-lang/rust/commits/67d3779b0ce5a1f2e735e4497af5321a9000105a", "html_url": "https://github.com/rust-lang/rust/commit/67d3779b0ce5a1f2e735e4497af5321a9000105a"}], "stats": {"total": 1265, "additions": 642, "deletions": 623}, "files": [{"sha": "5f7d85b7445f7eaa25f234de97248f8ba8fe1702", "filename": "src/eval.rs", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/9e424753ba4a9532d7f28660d317c99efc074f50/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e424753ba4a9532d7f28660d317c99efc074f50/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=9e424753ba4a9532d7f28660d317c99efc074f50", "patch": "@@ -0,0 +1,248 @@\n+use rand::rngs::StdRng;\n+use rand::SeedableRng;\n+\n+use syntax::source_map::DUMMY_SP;\n+use rustc::ty::{self, TyCtxt};\n+use rustc::ty::layout::{LayoutOf, Size, Align};\n+use rustc::hir::def_id::DefId;\n+use rustc::mir;\n+\n+use crate::{\n+    InterpResult, InterpError, InterpretCx, StackPopCleanup, struct_error,\n+    Scalar, Tag, Pointer,\n+    MiriMemoryKind, Evaluator, TlsEvalContextExt,\n+};\n+\n+/// Configuration needed to spawn a Miri instance.\n+#[derive(Clone)]\n+pub struct MiriConfig {\n+    pub validate: bool,\n+    pub args: Vec<String>,\n+\n+    // The seed to use when non-determinism is required (e.g. getrandom())\n+    pub seed: Option<u64>\n+}\n+\n+// Used by priroda.\n+pub fn create_ecx<'mir, 'tcx: 'mir>(\n+    tcx: TyCtxt<'tcx>,\n+    main_id: DefId,\n+    config: MiriConfig,\n+) -> InterpResult<'tcx, InterpretCx<'mir, 'tcx, Evaluator<'tcx>>> {\n+    let mut ecx = InterpretCx::new(\n+        tcx.at(syntax::source_map::DUMMY_SP),\n+        ty::ParamEnv::reveal_all(),\n+        Evaluator::new(config.validate),\n+    );\n+\n+    // FIXME: InterpretCx::new should take an initial MemoryExtra\n+    ecx.memory_mut().extra.rng = config.seed.map(StdRng::seed_from_u64);\n+    \n+    let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n+    let main_mir = ecx.load_mir(main_instance.def)?;\n+\n+    if !main_mir.return_ty().is_unit() || main_mir.arg_count != 0 {\n+        return err!(Unimplemented(\n+            \"miri does not support main functions without `fn()` type signatures\"\n+                .to_owned(),\n+        ));\n+    }\n+\n+    let start_id = tcx.lang_items().start_fn().unwrap();\n+    let main_ret_ty = tcx.fn_sig(main_id).output();\n+    let main_ret_ty = main_ret_ty.no_bound_vars().unwrap();\n+    let start_instance = ty::Instance::resolve(\n+        ecx.tcx.tcx,\n+        ty::ParamEnv::reveal_all(),\n+        start_id,\n+        ecx.tcx.mk_substs(\n+            ::std::iter::once(ty::subst::Kind::from(main_ret_ty)))\n+        ).unwrap();\n+    let start_mir = ecx.load_mir(start_instance.def)?;\n+\n+    if start_mir.arg_count != 3 {\n+        return err!(AbiViolation(format!(\n+            \"'start' lang item should have three arguments, but has {}\",\n+            start_mir.arg_count\n+        )));\n+    }\n+\n+    // Return value (in static memory so that it does not count as leak).\n+    let ret = ecx.layout_of(start_mir.return_ty())?;\n+    let ret_ptr = ecx.allocate(ret, MiriMemoryKind::Static.into());\n+\n+    // Push our stack frame.\n+    ecx.push_stack_frame(\n+        start_instance,\n+        // There is no call site.\n+        DUMMY_SP,\n+        start_mir,\n+        Some(ret_ptr.into()),\n+        StackPopCleanup::None { cleanup: true },\n+    )?;\n+\n+    let mut args = ecx.frame().body.args_iter();\n+\n+    // First argument: pointer to `main()`.\n+    let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance);\n+    let dest = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n+    ecx.write_scalar(Scalar::Ptr(main_ptr), dest)?;\n+\n+    // Second argument (argc): `1`.\n+    let dest = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n+    let argc = Scalar::from_uint(config.args.len() as u128, dest.layout.size);\n+    ecx.write_scalar(argc, dest)?;\n+    // Store argc for macOS's `_NSGetArgc`.\n+    {\n+        let argc_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into());\n+        ecx.write_scalar(argc, argc_place.into())?;\n+        ecx.machine.argc = Some(argc_place.ptr.to_ptr()?);\n+    }\n+\n+    // FIXME: extract main source file path.\n+    // Third argument (`argv`): created from `config.args`.\n+    let dest = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n+    // For Windows, construct a command string with all the aguments.\n+    let mut cmd = String::new();\n+    for arg in config.args.iter() {\n+        if !cmd.is_empty() {\n+            cmd.push(' ');\n+        }\n+        cmd.push_str(&*shell_escape::windows::escape(arg.as_str().into()));\n+    }\n+    // Don't forget `0` terminator.\n+    cmd.push(std::char::from_u32(0).unwrap());\n+    // Collect the pointers to the individual strings.\n+    let mut argvs = Vec::<Pointer<Tag>>::new();\n+    for arg in config.args {\n+        // Add `0` terminator.\n+        let mut arg = arg.into_bytes();\n+        arg.push(0);\n+        argvs.push(ecx.memory_mut().allocate_static_bytes(arg.as_slice(), MiriMemoryKind::Static.into()));\n+    }\n+    // Make an array with all these pointers, in the Miri memory.\n+    let argvs_layout = ecx.layout_of(ecx.tcx.mk_array(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8), argvs.len() as u64))?;\n+    let argvs_place = ecx.allocate(argvs_layout, MiriMemoryKind::Env.into());\n+    for (idx, arg) in argvs.into_iter().enumerate() {\n+        let place = ecx.mplace_field(argvs_place, idx as u64)?;\n+        ecx.write_scalar(Scalar::Ptr(arg), place.into())?;\n+    }\n+    ecx.memory_mut().mark_immutable(argvs_place.to_ptr()?.alloc_id)?;\n+    // Write a pointer to that place as the argument.\n+    let argv = argvs_place.ptr;\n+    ecx.write_scalar(argv, dest)?;\n+    // Store `argv` for macOS `_NSGetArgv`.\n+    {\n+        let argv_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into());\n+        ecx.write_scalar(argv, argv_place.into())?;\n+        ecx.machine.argv = Some(argv_place.ptr.to_ptr()?);\n+    }\n+    // Store command line as UTF-16 for Windows `GetCommandLineW`.\n+    {\n+        let tcx = &{ecx.tcx.tcx};\n+        let cmd_utf16: Vec<u16> = cmd.encode_utf16().collect();\n+        let cmd_ptr = ecx.memory_mut().allocate(\n+            Size::from_bytes(cmd_utf16.len() as u64 * 2),\n+            Align::from_bytes(2).unwrap(),\n+            MiriMemoryKind::Env.into(),\n+        );\n+        ecx.machine.cmd_line = Some(cmd_ptr);\n+        // Store the UTF-16 string.\n+        let char_size = Size::from_bytes(2);\n+        let cmd_alloc = ecx.memory_mut().get_mut(cmd_ptr.alloc_id)?;\n+        let mut cur_ptr = cmd_ptr;\n+        for &c in cmd_utf16.iter() {\n+            cmd_alloc.write_scalar(\n+                tcx,\n+                cur_ptr,\n+                Scalar::from_uint(c, char_size).into(),\n+                char_size,\n+            )?;\n+            cur_ptr = cur_ptr.offset(char_size, tcx)?;\n+        }\n+    }\n+ \n+    assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n+\n+    Ok(ecx)\n+}\n+\n+pub fn eval_main<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    main_id: DefId,\n+    config: MiriConfig,\n+) {\n+    let mut ecx = match create_ecx(tcx, main_id, config) {\n+        Ok(ecx) => ecx,\n+        Err(mut err) => {\n+            err.print_backtrace();\n+            panic!(\"Miri initialziation error: {}\", err.kind)\n+        }\n+    };\n+\n+    // Perform the main execution.\n+    let res: InterpResult = (|| {\n+        ecx.run()?;\n+        ecx.run_tls_dtors()\n+    })();\n+\n+    // Process the result.\n+    match res {\n+        Ok(()) => {\n+            let leaks = ecx.memory().leak_report();\n+            // Disable the leak test on some platforms where we do not\n+            // correctly implement TLS destructors.\n+            let target_os = ecx.tcx.tcx.sess.target.target.target_os.to_lowercase();\n+            let ignore_leaks = target_os == \"windows\" || target_os == \"macos\";\n+            if !ignore_leaks && leaks != 0 {\n+                tcx.sess.err(\"the evaluated program leaked memory\");\n+            }\n+        }\n+        Err(mut e) => {\n+            // Special treatment for some error kinds\n+            let msg = match e.kind {\n+                InterpError::Exit(code) => std::process::exit(code),\n+                InterpError::NoMirFor(..) =>\n+                    format!(\"{}. Did you set `MIRI_SYSROOT` to a Miri-enabled sysroot? You can prepare one with `cargo miri setup`.\", e),\n+                _ => e.to_string()\n+            };\n+            e.print_backtrace();\n+            if let Some(frame) = ecx.stack().last() {\n+                let block = &frame.body.basic_blocks()[frame.block];\n+                let span = if frame.stmt < block.statements.len() {\n+                    block.statements[frame.stmt].source_info.span\n+                } else {\n+                    block.terminator().source_info.span\n+                };\n+\n+                let msg = format!(\"Miri evaluation error: {}\", msg);\n+                let mut err = struct_error(ecx.tcx.tcx.at(span), msg.as_str());\n+                let frames = ecx.generate_stacktrace(None);\n+                err.span_label(span, msg);\n+                // We iterate with indices because we need to look at the next frame (the caller).\n+                for idx in 0..frames.len() {\n+                    let frame_info = &frames[idx];\n+                    let call_site_is_local = frames.get(idx+1).map_or(false,\n+                        |caller_info| caller_info.instance.def_id().is_local());\n+                    if call_site_is_local {\n+                        err.span_note(frame_info.call_site, &frame_info.to_string());\n+                    } else {\n+                        err.note(&frame_info.to_string());\n+                    }\n+                }\n+                err.emit();\n+            } else {\n+                ecx.tcx.sess.err(&msg);\n+            }\n+\n+            for (i, frame) in ecx.stack().iter().enumerate() {\n+                trace!(\"-------------------\");\n+                trace!(\"Frame {}\", i);\n+                trace!(\"    return: {:?}\", frame.return_place.map(|p| *p));\n+                for (i, local) in frame.locals.iter().enumerate() {\n+                    trace!(\"    local {}: {:?}\", i, local.value);\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "f65eef557c967260fafc1c0b7dc6d6ca0425a7e8", "filename": "src/helpers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e424753ba4a9532d7f28660d317c99efc074f50/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e424753ba4a9532d7f28660d317c99efc074f50/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=9e424753ba4a9532d7f28660d317c99efc074f50", "patch": "@@ -1,6 +1,6 @@\n use std::mem;\n \n-use rustc::ty::{self, layout};\n+use rustc::ty::{self, layout::{self, Size}};\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n \n use crate::*;"}, {"sha": "ab9e9854c34cbd84ea27ccd14ebce84f47945557", "filename": "src/lib.rs", "status": "modified", "additions": 8, "deletions": 570, "changes": 578, "blob_url": "https://github.com/rust-lang/rust/blob/9e424753ba4a9532d7f28660d317c99efc074f50/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e424753ba4a9532d7f28660d317c99efc074f50/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=9e424753ba4a9532d7f28660d317c99efc074f50", "patch": "@@ -21,39 +21,24 @@ mod range_map;\n mod mono_hash_map;\n mod stacked_borrows;\n mod intptrcast;\n-mod memory;\n+mod machine;\n+mod eval;\n \n-use std::collections::HashMap;\n-use std::borrow::Cow;\n-use std::rc::Rc;\n-\n-use rand::rngs::StdRng;\n-use rand::SeedableRng;\n-\n-use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n-use rustc::ty::layout::{LayoutOf, Size, Align};\n-use rustc::hir::def_id::DefId;\n-use rustc::mir;\n+// Make all those symbols available in the same place as our own.\n pub use rustc_mir::interpret::*;\n // Resolve ambiguity.\n pub use rustc_mir::interpret::{self, AllocMap, PlaceTy};\n-use syntax::attr;\n-use syntax::source_map::DUMMY_SP;\n-use syntax::symbol::sym;\n \n pub use crate::fn_call::EvalContextExt as MissingFnsEvalContextExt;\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::intrinsic::EvalContextExt as IntrinsicEvalContextExt;\n pub use crate::tls::{EvalContextExt as TlsEvalContextExt, TlsData};\n-use crate::range_map::RangeMap;\n-#[allow(unused_imports)] // FIXME: rustc bug, issue <https://github.com/rust-lang/rust/issues/53682>.\n+pub use crate::range_map::RangeMap;\n pub use crate::helpers::{EvalContextExt as HelpersEvalContextExt};\n-use crate::mono_hash_map::MonoHashMap;\n-pub use crate::stacked_borrows::{EvalContextExt as StackedBorEvalContextExt};\n-use crate::memory::AllocExtra;\n-\n-// Used by priroda.\n-pub use crate::stacked_borrows::{Tag, Permission, Stack, Stacks, Item};\n+pub use crate::mono_hash_map::MonoHashMap;\n+pub use crate::stacked_borrows::{EvalContextExt as StackedBorEvalContextExt, Tag, Permission, Stack, Stacks, Item};\n+pub use crate::machine::{MemoryExtra, AllocExtra, MiriMemoryKind, Evaluator, MiriEvalContext, MiriEvalContextExt};\n+pub use crate::eval::{eval_main, create_ecx, MiriConfig};\n \n /// Insert rustc arguments at the beginning of the argument list that Miri wants to be\n /// set per default, for maximal validation power.\n@@ -62,550 +47,3 @@ pub fn miri_default_args() -> &'static [&'static str] {\n     // set, which happens in `bootstrap/bin/rustc.rs` in the rustc sources.\n     &[\"-Zalways-encode-mir\", \"-Zmir-emit-retag\", \"-Zmir-opt-level=0\", \"--cfg=miri\"]\n }\n-\n-/// Configuration needed to spawn a Miri instance.\n-#[derive(Clone)]\n-pub struct MiriConfig {\n-    pub validate: bool,\n-    pub args: Vec<String>,\n-\n-    // The seed to use when non-determinism is required (e.g. getrandom())\n-    pub seed: Option<u64>\n-}\n-\n-// Used by priroda.\n-pub fn create_ecx<'mir, 'tcx: 'mir>(\n-    tcx: TyCtxt<'tcx>,\n-    main_id: DefId,\n-    config: MiriConfig,\n-) -> InterpResult<'tcx, InterpretCx<'mir, 'tcx, Evaluator<'tcx>>> {\n-    let mut ecx = InterpretCx::new(\n-        tcx.at(syntax::source_map::DUMMY_SP),\n-        ty::ParamEnv::reveal_all(),\n-        Evaluator::new(config.validate),\n-    );\n-\n-    // FIXME: InterpretCx::new should take an initial MemoryExtra\n-    ecx.memory_mut().extra.rng = config.seed.map(StdRng::seed_from_u64);\n-    \n-    let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n-    let main_mir = ecx.load_mir(main_instance.def)?;\n-\n-    if !main_mir.return_ty().is_unit() || main_mir.arg_count != 0 {\n-        return err!(Unimplemented(\n-            \"miri does not support main functions without `fn()` type signatures\"\n-                .to_owned(),\n-        ));\n-    }\n-\n-    let start_id = tcx.lang_items().start_fn().unwrap();\n-    let main_ret_ty = tcx.fn_sig(main_id).output();\n-    let main_ret_ty = main_ret_ty.no_bound_vars().unwrap();\n-    let start_instance = ty::Instance::resolve(\n-        ecx.tcx.tcx,\n-        ty::ParamEnv::reveal_all(),\n-        start_id,\n-        ecx.tcx.mk_substs(\n-            ::std::iter::once(ty::subst::Kind::from(main_ret_ty)))\n-        ).unwrap();\n-    let start_mir = ecx.load_mir(start_instance.def)?;\n-\n-    if start_mir.arg_count != 3 {\n-        return err!(AbiViolation(format!(\n-            \"'start' lang item should have three arguments, but has {}\",\n-            start_mir.arg_count\n-        )));\n-    }\n-\n-    // Return value (in static memory so that it does not count as leak).\n-    let ret = ecx.layout_of(start_mir.return_ty())?;\n-    let ret_ptr = ecx.allocate(ret, MiriMemoryKind::Static.into());\n-\n-    // Push our stack frame.\n-    ecx.push_stack_frame(\n-        start_instance,\n-        // There is no call site.\n-        DUMMY_SP,\n-        start_mir,\n-        Some(ret_ptr.into()),\n-        StackPopCleanup::None { cleanup: true },\n-    )?;\n-\n-    let mut args = ecx.frame().body.args_iter();\n-\n-    // First argument: pointer to `main()`.\n-    let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance);\n-    let dest = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n-    ecx.write_scalar(Scalar::Ptr(main_ptr), dest)?;\n-\n-    // Second argument (argc): `1`.\n-    let dest = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n-    let argc = Scalar::from_uint(config.args.len() as u128, dest.layout.size);\n-    ecx.write_scalar(argc, dest)?;\n-    // Store argc for macOS's `_NSGetArgc`.\n-    {\n-        let argc_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into());\n-        ecx.write_scalar(argc, argc_place.into())?;\n-        ecx.machine.argc = Some(argc_place.ptr.to_ptr()?);\n-    }\n-\n-    // FIXME: extract main source file path.\n-    // Third argument (`argv`): created from `config.args`.\n-    let dest = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n-    // For Windows, construct a command string with all the aguments.\n-    let mut cmd = String::new();\n-    for arg in config.args.iter() {\n-        if !cmd.is_empty() {\n-            cmd.push(' ');\n-        }\n-        cmd.push_str(&*shell_escape::windows::escape(arg.as_str().into()));\n-    }\n-    // Don't forget `0` terminator.\n-    cmd.push(std::char::from_u32(0).unwrap());\n-    // Collect the pointers to the individual strings.\n-    let mut argvs = Vec::<Pointer<Tag>>::new();\n-    for arg in config.args {\n-        // Add `0` terminator.\n-        let mut arg = arg.into_bytes();\n-        arg.push(0);\n-        argvs.push(ecx.memory_mut().allocate_static_bytes(arg.as_slice(), MiriMemoryKind::Static.into()));\n-    }\n-    // Make an array with all these pointers, in the Miri memory.\n-    let argvs_layout = ecx.layout_of(ecx.tcx.mk_array(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8), argvs.len() as u64))?;\n-    let argvs_place = ecx.allocate(argvs_layout, MiriMemoryKind::Env.into());\n-    for (idx, arg) in argvs.into_iter().enumerate() {\n-        let place = ecx.mplace_field(argvs_place, idx as u64)?;\n-        ecx.write_scalar(Scalar::Ptr(arg), place.into())?;\n-    }\n-    ecx.memory_mut().mark_immutable(argvs_place.to_ptr()?.alloc_id)?;\n-    // Write a pointer to that place as the argument.\n-    let argv = argvs_place.ptr;\n-    ecx.write_scalar(argv, dest)?;\n-    // Store `argv` for macOS `_NSGetArgv`.\n-    {\n-        let argv_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into());\n-        ecx.write_scalar(argv, argv_place.into())?;\n-        ecx.machine.argv = Some(argv_place.ptr.to_ptr()?);\n-    }\n-    // Store command line as UTF-16 for Windows `GetCommandLineW`.\n-    {\n-        let tcx = &{ecx.tcx.tcx};\n-        let cmd_utf16: Vec<u16> = cmd.encode_utf16().collect();\n-        let cmd_ptr = ecx.memory_mut().allocate(\n-            Size::from_bytes(cmd_utf16.len() as u64 * 2),\n-            Align::from_bytes(2).unwrap(),\n-            MiriMemoryKind::Env.into(),\n-        );\n-        ecx.machine.cmd_line = Some(cmd_ptr);\n-        // Store the UTF-16 string.\n-        let char_size = Size::from_bytes(2);\n-        let cmd_alloc = ecx.memory_mut().get_mut(cmd_ptr.alloc_id)?;\n-        let mut cur_ptr = cmd_ptr;\n-        for &c in cmd_utf16.iter() {\n-            cmd_alloc.write_scalar(\n-                tcx,\n-                cur_ptr,\n-                Scalar::from_uint(c, char_size).into(),\n-                char_size,\n-            )?;\n-            cur_ptr = cur_ptr.offset(char_size, tcx)?;\n-        }\n-    }\n- \n-    assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n-\n-    Ok(ecx)\n-}\n-\n-pub fn eval_main<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    main_id: DefId,\n-    config: MiriConfig,\n-) {\n-    let mut ecx = match create_ecx(tcx, main_id, config) {\n-        Ok(ecx) => ecx,\n-        Err(mut err) => {\n-            err.print_backtrace();\n-            panic!(\"Miri initialziation error: {}\", err.kind)\n-        }\n-    };\n-\n-    // Perform the main execution.\n-    let res: InterpResult = (|| {\n-        ecx.run()?;\n-        ecx.run_tls_dtors()\n-    })();\n-\n-    // Process the result.\n-    match res {\n-        Ok(()) => {\n-            let leaks = ecx.memory().leak_report();\n-            // Disable the leak test on some platforms where we do not\n-            // correctly implement TLS destructors.\n-            let target_os = ecx.tcx.tcx.sess.target.target.target_os.to_lowercase();\n-            let ignore_leaks = target_os == \"windows\" || target_os == \"macos\";\n-            if !ignore_leaks && leaks != 0 {\n-                tcx.sess.err(\"the evaluated program leaked memory\");\n-            }\n-        }\n-        Err(mut e) => {\n-            // Special treatment for some error kinds\n-            let msg = match e.kind {\n-                InterpError::Exit(code) => std::process::exit(code),\n-                InterpError::NoMirFor(..) =>\n-                    format!(\"{}. Did you set `MIRI_SYSROOT` to a Miri-enabled sysroot? You can prepare one with `cargo miri setup`.\", e),\n-                _ => e.to_string()\n-            };\n-            e.print_backtrace();\n-            if let Some(frame) = ecx.stack().last() {\n-                let block = &frame.body.basic_blocks()[frame.block];\n-                let span = if frame.stmt < block.statements.len() {\n-                    block.statements[frame.stmt].source_info.span\n-                } else {\n-                    block.terminator().source_info.span\n-                };\n-\n-                let msg = format!(\"Miri evaluation error: {}\", msg);\n-                let mut err = struct_error(ecx.tcx.tcx.at(span), msg.as_str());\n-                let frames = ecx.generate_stacktrace(None);\n-                err.span_label(span, msg);\n-                // We iterate with indices because we need to look at the next frame (the caller).\n-                for idx in 0..frames.len() {\n-                    let frame_info = &frames[idx];\n-                    let call_site_is_local = frames.get(idx+1).map_or(false,\n-                        |caller_info| caller_info.instance.def_id().is_local());\n-                    if call_site_is_local {\n-                        err.span_note(frame_info.call_site, &frame_info.to_string());\n-                    } else {\n-                        err.note(&frame_info.to_string());\n-                    }\n-                }\n-                err.emit();\n-            } else {\n-                ecx.tcx.sess.err(&msg);\n-            }\n-\n-            for (i, frame) in ecx.stack().iter().enumerate() {\n-                trace!(\"-------------------\");\n-                trace!(\"Frame {}\", i);\n-                trace!(\"    return: {:?}\", frame.return_place.map(|p| *p));\n-                for (i, local) in frame.locals.iter().enumerate() {\n-                    trace!(\"    local {}: {:?}\", i, local.value);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub enum MiriMemoryKind {\n-    /// `__rust_alloc` memory.\n-    Rust,\n-    /// `malloc` memory.\n-    C,\n-    /// Part of env var emulation.\n-    Env,\n-    /// Statics.\n-    Static,\n-}\n-\n-impl Into<MemoryKind<MiriMemoryKind>> for MiriMemoryKind {\n-    #[inline(always)]\n-    fn into(self) -> MemoryKind<MiriMemoryKind> {\n-        MemoryKind::Machine(self)\n-    }\n-}\n-\n-impl MayLeak for MiriMemoryKind {\n-    #[inline(always)]\n-    fn may_leak(self) -> bool {\n-        use self::MiriMemoryKind::*;\n-        match self {\n-            Rust | C => false,\n-            Env | Static => true,\n-        }\n-    }\n-}\n-\n-pub struct Evaluator<'tcx> {\n-    /// Environment variables set by `setenv`.\n-    /// Miri does not expose env vars from the host to the emulated program.\n-    pub(crate) env_vars: HashMap<Vec<u8>, Pointer<Tag>>,\n-\n-    /// Program arguments (`Option` because we can only initialize them after creating the ecx).\n-    /// These are *pointers* to argc/argv because macOS.\n-    /// We also need the full command line as one string because of Windows.\n-    pub(crate) argc: Option<Pointer<Tag>>,\n-    pub(crate) argv: Option<Pointer<Tag>>,\n-    pub(crate) cmd_line: Option<Pointer<Tag>>,\n-\n-    /// Last OS error.\n-    pub(crate) last_error: u32,\n-\n-    /// TLS state.\n-    pub(crate) tls: TlsData<'tcx>,\n-\n-    /// Whether to enforce the validity invariant.\n-    pub(crate) validate: bool,\n-}\n-\n-impl<'tcx> Evaluator<'tcx> {\n-    fn new(validate: bool) -> Self {\n-        Evaluator {\n-            env_vars: HashMap::default(),\n-            argc: None,\n-            argv: None,\n-            cmd_line: None,\n-            last_error: 0,\n-            tls: TlsData::default(),\n-            validate,\n-        }\n-    }\n-}\n-\n-// FIXME: rustc issue <https://github.com/rust-lang/rust/issues/47131>.\n-#[allow(dead_code)]\n-type MiriEvalContext<'mir, 'tcx> = InterpretCx<'mir, 'tcx, Evaluator<'tcx>>;\n-\n-// A little trait that's useful to be inherited by extension traits.\n-pub trait MiriEvalContextExt<'mir, 'tcx> {\n-    fn eval_context_ref(&self) -> &MiriEvalContext<'mir, 'tcx>;\n-    fn eval_context_mut(&mut self) -> &mut MiriEvalContext<'mir, 'tcx>;\n-}\n-impl<'mir, 'tcx> MiriEvalContextExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx> {\n-    #[inline(always)]\n-    fn eval_context_ref(&self) -> &MiriEvalContext<'mir, 'tcx> {\n-        self\n-    }\n-    #[inline(always)]\n-    fn eval_context_mut(&mut self) -> &mut MiriEvalContext<'mir, 'tcx> {\n-        self\n-    }\n-}\n-\n-impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n-    type MemoryKinds = MiriMemoryKind;\n-\n-    type FrameExtra = stacked_borrows::CallId;\n-    type MemoryExtra = memory::MemoryExtra;\n-    type AllocExtra = memory::AllocExtra;\n-    type PointerTag = Tag;\n-\n-    type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Tag, Self::AllocExtra>)>;\n-\n-    const STATIC_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::Static);\n-\n-    #[inline(always)]\n-    fn enforce_validity(ecx: &InterpretCx<'mir, 'tcx, Self>) -> bool {\n-        ecx.machine.validate\n-    }\n-\n-    /// Returns `Ok()` when the function was handled; fail otherwise.\n-    #[inline(always)]\n-    fn find_fn(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n-        instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: Option<PlaceTy<'tcx, Tag>>,\n-        ret: Option<mir::BasicBlock>,\n-    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n-        ecx.find_fn(instance, args, dest, ret)\n-    }\n-\n-    #[inline(always)]\n-    fn call_intrinsic(\n-        ecx: &mut rustc_mir::interpret::InterpretCx<'mir, 'tcx, Self>,\n-        instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: PlaceTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx> {\n-        ecx.call_intrinsic(instance, args, dest)\n-    }\n-\n-    #[inline(always)]\n-    fn ptr_op(\n-        ecx: &rustc_mir::interpret::InterpretCx<'mir, 'tcx, Self>,\n-        bin_op: mir::BinOp,\n-        left: ImmTy<'tcx, Tag>,\n-        right: ImmTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx, (Scalar<Tag>, bool)> {\n-        ecx.ptr_op(bin_op, left, right)\n-    }\n-\n-    fn box_alloc(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n-        dest: PlaceTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx> {\n-        trace!(\"box_alloc for {:?}\", dest.layout.ty);\n-        // Call the `exchange_malloc` lang item.\n-        let malloc = ecx.tcx.lang_items().exchange_malloc_fn().unwrap();\n-        let malloc = ty::Instance::mono(ecx.tcx.tcx, malloc);\n-        let malloc_mir = ecx.load_mir(malloc.def)?;\n-        ecx.push_stack_frame(\n-            malloc,\n-            malloc_mir.span,\n-            malloc_mir,\n-            Some(dest),\n-            // Don't do anything when we are done. The `statement()` function will increment\n-            // the old stack frame's stmt counter to the next statement, which means that when\n-            // `exchange_malloc` returns, we go on evaluating exactly where we want to be.\n-            StackPopCleanup::None { cleanup: true },\n-        )?;\n-\n-        let mut args = ecx.frame().body.args_iter();\n-        let layout = ecx.layout_of(dest.layout.ty.builtin_deref(false).unwrap().ty)?;\n-\n-        // First argument: `size`.\n-        // (`0` is allowed here -- this is expected to be handled by the lang item).\n-        let arg = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n-        let size = layout.size.bytes();\n-        ecx.write_scalar(Scalar::from_uint(size, arg.layout.size), arg)?;\n-\n-        // Second argument: `align`.\n-        let arg = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n-        let align = layout.align.abi.bytes();\n-        ecx.write_scalar(Scalar::from_uint(align, arg.layout.size), arg)?;\n-\n-        // No more arguments.\n-        assert!(\n-            args.next().is_none(),\n-            \"`exchange_malloc` lang item has more arguments than expected\"\n-        );\n-        Ok(())\n-    }\n-\n-    fn find_foreign_static(\n-        def_id: DefId,\n-        tcx: TyCtxtAt<'tcx>,\n-    ) -> InterpResult<'tcx, Cow<'tcx, Allocation>> {\n-        let attrs = tcx.get_attrs(def_id);\n-        let link_name = match attr::first_attr_value_str_by_name(&attrs, sym::link_name) {\n-            Some(name) => name.as_str(),\n-            None => tcx.item_name(def_id).as_str(),\n-        };\n-\n-        let alloc = match link_name.get() {\n-            \"__cxa_thread_atexit_impl\" => {\n-                // This should be all-zero, pointer-sized.\n-                let size = tcx.data_layout.pointer_size;\n-                let data = vec![0; size.bytes() as usize];\n-                Allocation::from_bytes(&data, tcx.data_layout.pointer_align.abi)\n-            }\n-            _ => return err!(Unimplemented(\n-                    format!(\"can't access foreign static: {}\", link_name),\n-                )),\n-        };\n-        Ok(Cow::Owned(alloc))\n-    }\n-\n-    #[inline(always)]\n-    fn before_terminator(_ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx>\n-    {\n-        // We are not interested in detecting loops.\n-        Ok(())\n-    }\n-\n-    fn tag_allocation<'b>(\n-        id: AllocId,\n-        alloc: Cow<'b, Allocation>,\n-        kind: Option<MemoryKind<Self::MemoryKinds>>,\n-        memory: &Memory<'mir, 'tcx, Self>,\n-    ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag) {\n-        let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n-        let alloc = alloc.into_owned();\n-        let (stacks, base_tag) = Stacks::new_allocation(\n-            id,\n-            Size::from_bytes(alloc.bytes.len() as u64),\n-            Rc::clone(&memory.extra.stacked_borrows),\n-            kind,\n-        );\n-        if kind != MiriMemoryKind::Static.into() {\n-            assert!(alloc.relocations.is_empty(), \"Only statics can come initialized with inner pointers\");\n-            // Now we can rely on the inner pointers being static, too.\n-        }\n-        let mut memory_extra = memory.extra.stacked_borrows.borrow_mut();\n-        let alloc: Allocation<Tag, Self::AllocExtra> = Allocation {\n-            bytes: alloc.bytes,\n-            relocations: Relocations::from_presorted(\n-                alloc.relocations.iter()\n-                    // The allocations in the relocations (pointers stored *inside* this allocation)\n-                    // all get the base pointer tag.\n-                    .map(|&(offset, ((), alloc))| (offset, (memory_extra.static_base_ptr(alloc), alloc)))\n-                    .collect()\n-            ),\n-            undef_mask: alloc.undef_mask,\n-            align: alloc.align,\n-            mutability: alloc.mutability,\n-            extra: AllocExtra {\n-                stacked_borrows: stacks,\n-                intptrcast: Default::default(),\n-            },\n-        };\n-        (Cow::Owned(alloc), base_tag)\n-    }\n-\n-    #[inline(always)]\n-    fn tag_static_base_pointer(\n-        id: AllocId,\n-        memory: &Memory<'mir, 'tcx, Self>,\n-    ) -> Self::PointerTag {\n-        memory.extra.stacked_borrows.borrow_mut().static_base_ptr(id)\n-    }\n-\n-    #[inline(always)]\n-    fn retag(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n-        kind: mir::RetagKind,\n-        place: PlaceTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx> {\n-        if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag || !Self::enforce_validity(ecx) {\n-            // No tracking, or no retagging. The latter is possible because a dependency of ours\n-            // might be called with different flags than we are, so there are `Retag`\n-            // statements but we do not want to execute them.\n-            // Also, honor the whitelist in `enforce_validity` because otherwise we might retag\n-            // uninitialized data.\n-             Ok(())\n-        } else {\n-            ecx.retag(kind, place)\n-        }\n-    }\n-\n-    #[inline(always)]\n-    fn stack_push(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n-    ) -> InterpResult<'tcx, stacked_borrows::CallId> {\n-        Ok(ecx.memory().extra.stacked_borrows.borrow_mut().new_call())\n-    }\n-\n-    #[inline(always)]\n-    fn stack_pop(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n-        extra: stacked_borrows::CallId,\n-    ) -> InterpResult<'tcx> {\n-        Ok(ecx.memory().extra.stacked_borrows.borrow_mut().end_call(extra))\n-    }\n-\n-    fn int_to_ptr(\n-        int: u64,\n-        memory: &Memory<'mir, 'tcx, Self>,\n-    ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n-        if int == 0 {\n-            err!(InvalidNullPointerUsage)\n-        } else if memory.extra.rng.is_none() {\n-            err!(ReadBytesAsPointer)\n-        } else {\n-           intptrcast::GlobalState::int_to_ptr(int, memory)\n-        }\n-    }\n- \n-    fn ptr_to_int(\n-        ptr: Pointer<Self::PointerTag>,\n-        memory: &Memory<'mir, 'tcx, Self>,\n-    ) -> InterpResult<'tcx, u64> {\n-        if memory.extra.rng.is_none() {\n-            err!(ReadPointerAsBytes)\n-        } else {\n-            intptrcast::GlobalState::ptr_to_int(ptr, memory)\n-        }\n-    }\n-}"}, {"sha": "eb177fa2a1859f770176da6570fd0c5e7143260e", "filename": "src/machine.rs", "status": "added", "additions": 384, "deletions": 0, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/9e424753ba4a9532d7f28660d317c99efc074f50/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e424753ba4a9532d7f28660d317c99efc074f50/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=9e424753ba4a9532d7f28660d317c99efc074f50", "patch": "@@ -0,0 +1,384 @@\n+use std::rc::Rc;\n+use std::borrow::Cow;\n+use std::collections::HashMap;\n+\n+use rand::rngs::StdRng;\n+\n+use syntax::attr;\n+use syntax::symbol::sym;\n+use rustc::hir::def_id::DefId;\n+use rustc::ty::{self, layout::{Size, LayoutOf}, query::TyCtxtAt};\n+use rustc::mir;\n+\n+use crate::*;\n+\n+/// Extra memory kinds\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum MiriMemoryKind {\n+    /// `__rust_alloc` memory.\n+    Rust,\n+    /// `malloc` memory.\n+    C,\n+    /// Part of env var emulation.\n+    Env,\n+    /// Statics.\n+    Static,\n+}\n+\n+impl Into<MemoryKind<MiriMemoryKind>> for MiriMemoryKind {\n+    #[inline(always)]\n+    fn into(self) -> MemoryKind<MiriMemoryKind> {\n+        MemoryKind::Machine(self)\n+    }\n+}\n+\n+/// Extra per-allocation data\n+#[derive(Debug, Clone)]\n+pub struct AllocExtra {\n+    pub stacked_borrows: stacked_borrows::AllocExtra,\n+    pub intptrcast: intptrcast::AllocExtra,\n+}\n+\n+/// Extra global memory data\n+#[derive(Default, Clone, Debug)]\n+pub struct MemoryExtra {\n+    pub stacked_borrows: stacked_borrows::MemoryExtra,\n+    pub intptrcast: intptrcast::MemoryExtra,\n+    /// The random number generator to use if Miri is running in non-deterministic mode and to\n+    /// enable intptrcast\n+    pub(crate) rng: Option<StdRng>\n+}\n+\n+impl MemoryExtra {\n+    pub fn with_rng(rng: Option<StdRng>) -> Self {\n+        MemoryExtra {\n+            stacked_borrows: Default::default(),\n+            intptrcast: Default::default(),\n+            rng,\n+        }\n+    }\n+}\n+\n+/// The machine itself.\n+pub struct Evaluator<'tcx> {\n+    /// Environment variables set by `setenv`.\n+    /// Miri does not expose env vars from the host to the emulated program.\n+    pub(crate) env_vars: HashMap<Vec<u8>, Pointer<Tag>>,\n+\n+    /// Program arguments (`Option` because we can only initialize them after creating the ecx).\n+    /// These are *pointers* to argc/argv because macOS.\n+    /// We also need the full command line as one string because of Windows.\n+    pub(crate) argc: Option<Pointer<Tag>>,\n+    pub(crate) argv: Option<Pointer<Tag>>,\n+    pub(crate) cmd_line: Option<Pointer<Tag>>,\n+\n+    /// Last OS error.\n+    pub(crate) last_error: u32,\n+\n+    /// TLS state.\n+    pub(crate) tls: TlsData<'tcx>,\n+\n+    /// Whether to enforce the validity invariant.\n+    pub(crate) validate: bool,\n+}\n+\n+impl<'tcx> Evaluator<'tcx> {\n+    pub(crate) fn new(validate: bool) -> Self {\n+        Evaluator {\n+            env_vars: HashMap::default(),\n+            argc: None,\n+            argv: None,\n+            cmd_line: None,\n+            last_error: 0,\n+            tls: TlsData::default(),\n+            validate,\n+        }\n+    }\n+}\n+\n+/// A rustc InterpretCx for Miri.\n+pub type MiriEvalContext<'mir, 'tcx> = InterpretCx<'mir, 'tcx, Evaluator<'tcx>>;\n+\n+/// A little trait that's useful to be inherited by extension traits.\n+pub trait MiriEvalContextExt<'mir, 'tcx> {\n+    fn eval_context_ref(&self) -> &MiriEvalContext<'mir, 'tcx>;\n+    fn eval_context_mut(&mut self) -> &mut MiriEvalContext<'mir, 'tcx>;\n+}\n+impl<'mir, 'tcx> MiriEvalContextExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx> {\n+    #[inline(always)]\n+    fn eval_context_ref(&self) -> &MiriEvalContext<'mir, 'tcx> {\n+        self\n+    }\n+    #[inline(always)]\n+    fn eval_context_mut(&mut self) -> &mut MiriEvalContext<'mir, 'tcx> {\n+        self\n+    }\n+}\n+\n+/// Machine hook implementations.\n+impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n+    type MemoryKinds = MiriMemoryKind;\n+\n+    type FrameExtra = stacked_borrows::CallId;\n+    type MemoryExtra = MemoryExtra;\n+    type AllocExtra = AllocExtra;\n+    type PointerTag = Tag;\n+\n+    type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Tag, Self::AllocExtra>)>;\n+\n+    const STATIC_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::Static);\n+\n+    #[inline(always)]\n+    fn enforce_validity(ecx: &InterpretCx<'mir, 'tcx, Self>) -> bool {\n+        ecx.machine.validate\n+    }\n+\n+    /// Returns `Ok()` when the function was handled; fail otherwise.\n+    #[inline(always)]\n+    fn find_fn(\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: Option<PlaceTy<'tcx, Tag>>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n+        ecx.find_fn(instance, args, dest, ret)\n+    }\n+\n+    #[inline(always)]\n+    fn call_intrinsic(\n+        ecx: &mut rustc_mir::interpret::InterpretCx<'mir, 'tcx, Self>,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: PlaceTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx> {\n+        ecx.call_intrinsic(instance, args, dest)\n+    }\n+\n+    #[inline(always)]\n+    fn ptr_op(\n+        ecx: &rustc_mir::interpret::InterpretCx<'mir, 'tcx, Self>,\n+        bin_op: mir::BinOp,\n+        left: ImmTy<'tcx, Tag>,\n+        right: ImmTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, (Scalar<Tag>, bool)> {\n+        ecx.ptr_op(bin_op, left, right)\n+    }\n+\n+    fn box_alloc(\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        dest: PlaceTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx> {\n+        trace!(\"box_alloc for {:?}\", dest.layout.ty);\n+        // Call the `exchange_malloc` lang item.\n+        let malloc = ecx.tcx.lang_items().exchange_malloc_fn().unwrap();\n+        let malloc = ty::Instance::mono(ecx.tcx.tcx, malloc);\n+        let malloc_mir = ecx.load_mir(malloc.def)?;\n+        ecx.push_stack_frame(\n+            malloc,\n+            malloc_mir.span,\n+            malloc_mir,\n+            Some(dest),\n+            // Don't do anything when we are done. The `statement()` function will increment\n+            // the old stack frame's stmt counter to the next statement, which means that when\n+            // `exchange_malloc` returns, we go on evaluating exactly where we want to be.\n+            StackPopCleanup::None { cleanup: true },\n+        )?;\n+\n+        let mut args = ecx.frame().body.args_iter();\n+        let layout = ecx.layout_of(dest.layout.ty.builtin_deref(false).unwrap().ty)?;\n+\n+        // First argument: `size`.\n+        // (`0` is allowed here -- this is expected to be handled by the lang item).\n+        let arg = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n+        let size = layout.size.bytes();\n+        ecx.write_scalar(Scalar::from_uint(size, arg.layout.size), arg)?;\n+\n+        // Second argument: `align`.\n+        let arg = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n+        let align = layout.align.abi.bytes();\n+        ecx.write_scalar(Scalar::from_uint(align, arg.layout.size), arg)?;\n+\n+        // No more arguments.\n+        assert!(\n+            args.next().is_none(),\n+            \"`exchange_malloc` lang item has more arguments than expected\"\n+        );\n+        Ok(())\n+    }\n+\n+    fn find_foreign_static(\n+        def_id: DefId,\n+        tcx: TyCtxtAt<'tcx>,\n+    ) -> InterpResult<'tcx, Cow<'tcx, Allocation>> {\n+        let attrs = tcx.get_attrs(def_id);\n+        let link_name = match attr::first_attr_value_str_by_name(&attrs, sym::link_name) {\n+            Some(name) => name.as_str(),\n+            None => tcx.item_name(def_id).as_str(),\n+        };\n+\n+        let alloc = match link_name.get() {\n+            \"__cxa_thread_atexit_impl\" => {\n+                // This should be all-zero, pointer-sized.\n+                let size = tcx.data_layout.pointer_size;\n+                let data = vec![0; size.bytes() as usize];\n+                Allocation::from_bytes(&data, tcx.data_layout.pointer_align.abi)\n+            }\n+            _ => return err!(Unimplemented(\n+                    format!(\"can't access foreign static: {}\", link_name),\n+                )),\n+        };\n+        Ok(Cow::Owned(alloc))\n+    }\n+\n+    #[inline(always)]\n+    fn before_terminator(_ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx>\n+    {\n+        // We are not interested in detecting loops.\n+        Ok(())\n+    }\n+\n+    fn tag_allocation<'b>(\n+        id: AllocId,\n+        alloc: Cow<'b, Allocation>,\n+        kind: Option<MemoryKind<Self::MemoryKinds>>,\n+        memory: &Memory<'mir, 'tcx, Self>,\n+    ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag) {\n+        let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n+        let alloc = alloc.into_owned();\n+        let (stacks, base_tag) = Stacks::new_allocation(\n+            id,\n+            Size::from_bytes(alloc.bytes.len() as u64),\n+            Rc::clone(&memory.extra.stacked_borrows),\n+            kind,\n+        );\n+        if kind != MiriMemoryKind::Static.into() {\n+            assert!(alloc.relocations.is_empty(), \"Only statics can come initialized with inner pointers\");\n+            // Now we can rely on the inner pointers being static, too.\n+        }\n+        let mut memory_extra = memory.extra.stacked_borrows.borrow_mut();\n+        let alloc: Allocation<Tag, Self::AllocExtra> = Allocation {\n+            bytes: alloc.bytes,\n+            relocations: Relocations::from_presorted(\n+                alloc.relocations.iter()\n+                    // The allocations in the relocations (pointers stored *inside* this allocation)\n+                    // all get the base pointer tag.\n+                    .map(|&(offset, ((), alloc))| (offset, (memory_extra.static_base_ptr(alloc), alloc)))\n+                    .collect()\n+            ),\n+            undef_mask: alloc.undef_mask,\n+            align: alloc.align,\n+            mutability: alloc.mutability,\n+            extra: AllocExtra {\n+                stacked_borrows: stacks,\n+                intptrcast: Default::default(),\n+            },\n+        };\n+        (Cow::Owned(alloc), base_tag)\n+    }\n+\n+    #[inline(always)]\n+    fn tag_static_base_pointer(\n+        id: AllocId,\n+        memory: &Memory<'mir, 'tcx, Self>,\n+    ) -> Self::PointerTag {\n+        memory.extra.stacked_borrows.borrow_mut().static_base_ptr(id)\n+    }\n+\n+    #[inline(always)]\n+    fn retag(\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        kind: mir::RetagKind,\n+        place: PlaceTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx> {\n+        if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag || !Self::enforce_validity(ecx) {\n+            // No tracking, or no retagging. The latter is possible because a dependency of ours\n+            // might be called with different flags than we are, so there are `Retag`\n+            // statements but we do not want to execute them.\n+            // Also, honor the whitelist in `enforce_validity` because otherwise we might retag\n+            // uninitialized data.\n+             Ok(())\n+        } else {\n+            ecx.retag(kind, place)\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn stack_push(\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+    ) -> InterpResult<'tcx, stacked_borrows::CallId> {\n+        Ok(ecx.memory().extra.stacked_borrows.borrow_mut().new_call())\n+    }\n+\n+    #[inline(always)]\n+    fn stack_pop(\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        extra: stacked_borrows::CallId,\n+    ) -> InterpResult<'tcx> {\n+        Ok(ecx.memory().extra.stacked_borrows.borrow_mut().end_call(extra))\n+    }\n+\n+    fn int_to_ptr(\n+        int: u64,\n+        memory: &Memory<'mir, 'tcx, Self>,\n+    ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n+        if int == 0 {\n+            err!(InvalidNullPointerUsage)\n+        } else if memory.extra.rng.is_none() {\n+            err!(ReadBytesAsPointer)\n+        } else {\n+           intptrcast::GlobalState::int_to_ptr(int, memory)\n+        }\n+    }\n+\n+    fn ptr_to_int(\n+        ptr: Pointer<Self::PointerTag>,\n+        memory: &Memory<'mir, 'tcx, Self>,\n+    ) -> InterpResult<'tcx, u64> {\n+        if memory.extra.rng.is_none() {\n+            err!(ReadPointerAsBytes)\n+        } else {\n+            intptrcast::GlobalState::ptr_to_int(ptr, memory)\n+        }\n+    }\n+}\n+\n+impl AllocationExtra<Tag> for AllocExtra {\n+    #[inline(always)]\n+    fn memory_read<'tcx>(\n+        alloc: &Allocation<Tag, AllocExtra>,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> InterpResult<'tcx> {\n+        alloc.extra.stacked_borrows.memory_read(ptr, size)\n+    }\n+\n+    #[inline(always)]\n+    fn memory_written<'tcx>(\n+        alloc: &mut Allocation<Tag, AllocExtra>,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> InterpResult<'tcx> {\n+        alloc.extra.stacked_borrows.memory_written(ptr, size)\n+    }\n+\n+    #[inline(always)]\n+    fn memory_deallocated<'tcx>(\n+        alloc: &mut Allocation<Tag, AllocExtra>,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> InterpResult<'tcx> {\n+        alloc.extra.stacked_borrows.memory_deallocated(ptr, size)\n+    }\n+}\n+\n+impl MayLeak for MiriMemoryKind {\n+    #[inline(always)]\n+    fn may_leak(self) -> bool {\n+        use self::MiriMemoryKind::*;\n+        match self {\n+            Rust | C => false,\n+            Env | Static => true,\n+        }\n+    }\n+}"}, {"sha": "ea8f01a808c0434e5697acda9c5bdbdc38976f96", "filename": "src/memory.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/bc969f1a4c24dcd9a2c3a4ce6e55faef7b711062/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc969f1a4c24dcd9a2c3a4ce6e55faef7b711062/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=bc969f1a4c24dcd9a2c3a4ce6e55faef7b711062", "patch": "@@ -1,51 +0,0 @@\n-use rand::rngs::StdRng;\n-\n-use rustc_mir::interpret::{Pointer, Allocation, AllocationExtra, InterpResult};\n-use rustc_target::abi::Size;\n-\n-use crate::{stacked_borrows, intptrcast};\n-use crate::stacked_borrows::Tag;\n-\n-#[derive(Default, Clone, Debug)]\n-pub struct MemoryExtra {\n-    pub stacked_borrows: stacked_borrows::MemoryExtra,\n-    pub intptrcast: intptrcast::MemoryExtra,\n-    /// The random number generator to use if Miri is running in non-deterministic mode and to\n-    /// enable intptrcast\n-    pub(crate) rng: Option<StdRng>\n-}\n-\n-#[derive(Debug, Clone)]\n-pub struct AllocExtra {\n-    pub stacked_borrows: stacked_borrows::AllocExtra,\n-    pub intptrcast: intptrcast::AllocExtra,\n-}\n-\n-impl AllocationExtra<Tag> for AllocExtra {\n-    #[inline(always)]\n-    fn memory_read<'tcx>(\n-        alloc: &Allocation<Tag, AllocExtra>,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx> {\n-        alloc.extra.stacked_borrows.memory_read(ptr, size)\n-    }\n-\n-    #[inline(always)]\n-    fn memory_written<'tcx>(\n-        alloc: &mut Allocation<Tag, AllocExtra>,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx> {\n-        alloc.extra.stacked_borrows.memory_written(ptr, size)\n-    }\n-\n-    #[inline(always)]\n-    fn memory_deallocated<'tcx>(\n-        alloc: &mut Allocation<Tag, AllocExtra>,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx> {\n-        alloc.extra.stacked_borrows.memory_deallocated(ptr, size)\n-    }\n-}"}, {"sha": "0e25de7da5a95282c4f4b901c0d75d14b614f55a", "filename": "src/operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e424753ba4a9532d7f28660d317c99efc074f50/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e424753ba4a9532d7f28660d317c99efc074f50/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=9e424753ba4a9532d7f28660d317c99efc074f50", "patch": "@@ -1,4 +1,4 @@\n-use rustc::ty::Ty;\n+use rustc::ty::{Ty, layout::{Size, LayoutOf}};\n use rustc::mir;\n \n use crate::*;"}]}