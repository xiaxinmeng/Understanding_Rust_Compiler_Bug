{"sha": "35873a95d4df2eaa3199a5bda6043fd91d1f9165", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ODczYTk1ZDRkZjJlYWEzMTk5YTViZGE2MDQzZmQ5MWQxZjkxNjU=", "commit": {"author": {"name": "Jesse Ruderman", "email": "jruderman@gmail.com", "date": "2011-09-20T04:57:43Z"}, "committer": {"name": "Jesse Ruderman", "email": "jruderman@gmail.com", "date": "2011-09-20T04:57:43Z"}, "message": "Fuzzer: add ability to run the generated programs", "tree": {"sha": "b160c78e1c223d334b4915fd61c7a2470e4b6de2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b160c78e1c223d334b4915fd61c7a2470e4b6de2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35873a95d4df2eaa3199a5bda6043fd91d1f9165", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35873a95d4df2eaa3199a5bda6043fd91d1f9165", "html_url": "https://github.com/rust-lang/rust/commit/35873a95d4df2eaa3199a5bda6043fd91d1f9165", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35873a95d4df2eaa3199a5bda6043fd91d1f9165/comments", "author": {"login": "jruderman", "id": 692547, "node_id": "MDQ6VXNlcjY5MjU0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/692547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jruderman", "html_url": "https://github.com/jruderman", "followers_url": "https://api.github.com/users/jruderman/followers", "following_url": "https://api.github.com/users/jruderman/following{/other_user}", "gists_url": "https://api.github.com/users/jruderman/gists{/gist_id}", "starred_url": "https://api.github.com/users/jruderman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jruderman/subscriptions", "organizations_url": "https://api.github.com/users/jruderman/orgs", "repos_url": "https://api.github.com/users/jruderman/repos", "events_url": "https://api.github.com/users/jruderman/events{/privacy}", "received_events_url": "https://api.github.com/users/jruderman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jruderman", "id": 692547, "node_id": "MDQ6VXNlcjY5MjU0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/692547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jruderman", "html_url": "https://github.com/jruderman", "followers_url": "https://api.github.com/users/jruderman/followers", "following_url": "https://api.github.com/users/jruderman/following{/other_user}", "gists_url": "https://api.github.com/users/jruderman/gists{/gist_id}", "starred_url": "https://api.github.com/users/jruderman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jruderman/subscriptions", "organizations_url": "https://api.github.com/users/jruderman/orgs", "repos_url": "https://api.github.com/users/jruderman/repos", "events_url": "https://api.github.com/users/jruderman/events{/privacy}", "received_events_url": "https://api.github.com/users/jruderman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "107f1292eb99d5e1163a8ece8d2ce65cad1d561a", "url": "https://api.github.com/repos/rust-lang/rust/commits/107f1292eb99d5e1163a8ece8d2ce65cad1d561a", "html_url": "https://github.com/rust-lang/rust/commit/107f1292eb99d5e1163a8ece8d2ce65cad1d561a"}], "stats": {"total": 113, "additions": 91, "deletions": 22}, "files": [{"sha": "05b36f61ada077d4c7df9943535075cebfe484a0", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 91, "deletions": 22, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/35873a95d4df2eaa3199a5bda6043fd91d1f9165/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35873a95d4df2eaa3199a5bda6043fd91d1f9165/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=35873a95d4df2eaa3199a5bda6043fd91d1f9165", "patch": "@@ -1,11 +1,11 @@\n use std;\n use rustc;\n \n-import std::{fs, io, getopts, vec, str, uint, option};\n+import std::{fs, io, getopts, vec, str, int, uint, option};\n import std::getopts::{optopt, opt_present, opt_str};\n import std::io::stdout;\n \n-import rustc::syntax::{ast, fold, visit, codemap};\n+import rustc::syntax::{ast, ast_util, fold, visit, codemap};\n import rustc::syntax::parse::parser;\n import rustc::syntax::print::pprust;\n \n@@ -152,6 +152,7 @@ fn replace_expr_in_crate(crate: ast::crate, i: uint, newexpr: ast::expr) ->\n     *crate2\n }\n \n+\n // Replace the |i|th ty (in fold order) of |crate| with |newty|.\n fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::ty) ->\n    ast::crate {\n@@ -206,9 +207,9 @@ fn check_variants_T<T>(\n     let L = vec::len(things);\n \n     if L < 100u {\n-        for each i: uint in under(uint::min(L, 20u)) {\n+        for each i: uint in under(uint::min(L, 10u)) {\n             log_err \"Replacing... \" + stringifier(@things[i]);\n-            for each j: uint in under(uint::min(L, 5u)) {\n+            for each j: uint in under(uint::min(L, 10u)) {\n                 log_err \"With... \" + stringifier(@things[j]);\n                 let crate2 = @replacer(crate, i, things[j]);\n                 // It would be best to test the *crate* for stability, but testing the\n@@ -219,8 +220,9 @@ fn check_variants_T<T>(\n                                                     io::string_reader(\"\"), _,\n                                                     pprust::no_ann()));\n                 check_roundtrip_convergence(str3, 1u);\n-                //let file_label = #fmt(\"buggy_%s_%s_%u_%u.rs\", last_part(filename), thing_label, i, j);\n-                //check_whole_compiler(str3, file_label);\n+                //let file_label = #fmt(\"rusttmp/%s_%s_%u_%u\", last_part(filename), thing_label, i, j);\n+                //let safe_to_run = !(content_is_dangerous_to_run(str3) || has_raw_pointers(*crate2));\n+                //check_whole_compiler(str3, file_label, safe_to_run);\n             }\n         }\n     }\n@@ -232,36 +234,80 @@ fn last_part(filename: str) -> str {\n   str::slice(filename, ix as uint + 1u, str::byte_len(filename) - 3u)\n }\n \n-tag compile_result { known_bug(str); passed(str); failed(str); }\n+tag happiness { passed; cleanly_rejected(str); known_bug(str); failed(str); }\n \n // We'd find more bugs if we could take an AST here, but\n // - that would find many \"false positives\" or unimportant bugs\n // - that would be tricky, requiring use of tasks or serialization or randomness.\n // This seems to find plenty of bugs as it is :)\n-fn check_whole_compiler(code: str, suggested_filename: str) {\n-    let filename = \"test.rs\";\n+fn check_whole_compiler(code: str, suggested_filename_prefix: str, allow_running: bool) {\n+    let filename = suggested_filename_prefix + \".rs\";\n     write_file(filename, code);\n-    alt check_whole_compiler_inner(filename) {\n-      known_bug(s) {\n-        log_err \"Ignoring known bug: \" + s;\n+\n+    let compile_result = check_compiling(filename);\n+\n+    let run_result = alt (compile_result, allow_running) {\n+      (passed., true) { check_running(suggested_filename_prefix) }\n+      (h, _) { h }\n+    };\n+\n+    alt run_result {\n+      passed. | cleanly_rejected(_) | known_bug(_) {\n+        removeIfExists(suggested_filename_prefix);\n+        removeIfExists(suggested_filename_prefix + \".rs\");\n+        removeDirIfExists(suggested_filename_prefix + \".dSYM\");\n       }\n       failed(s) {\n         log_err \"check_whole_compiler failure: \" + s;\n-        write_file(suggested_filename, code);\n-        log_err \"Saved as: \" + suggested_filename;\n+        log_err \"Saved as: \" + filename;\n       }\n-      passed(_) { }\n     }\n }\n \n-fn check_whole_compiler_inner(filename: str) -> compile_result {\n+fn removeIfExists(filename: str) {\n+    // So sketchy!\n+    assert !contains(filename, \" \");\n+    std::run::program_output(\"bash\", [\"-c\", \"rm \" + filename]);\n+}\n+\n+fn removeDirIfExists(filename: str) {\n+    // So sketchy!\n+    assert !contains(filename, \" \");\n+    std::run::program_output(\"bash\", [\"-c\", \"rm -r \" + filename]);\n+}\n+\n+fn check_running(exe_filename: str) -> happiness {\n+    let p = std::run::program_output(\"/Users/jruderman/scripts/timed_run_rust_program.py\", [exe_filename]);\n+    let comb = p.out + \"\\n\" + p.err;\n+    if str::byte_len(comb) > 1u {\n+        log_err \"comb comb comb: \" + comb;\n+    }\n+\n+    if contains(comb, \"Assertion failed:\") {\n+        failed(\"C++ assertion failure\")\n+    } else if contains(comb, \"malloc\") {\n+        failed(\"Mentioned malloc\")\n+    } else if contains(comb, \"leaked memory in rust main loop\") {\n+        failed(\"Leaked\") // might also use exit code 134\n+    } else {\n+        alt p.status {\n+            0         { passed }\n+            100       { cleanly_rejected(\"running: explicit fail\") }\n+            101 | 247 { cleanly_rejected(\"running: timed out\") }\n+            245 | 246 { known_bug(\"https://github.com/graydon/rust/issues/32 ??\") }\n+            rc        { failed(\"exited with status \" + int::str(rc)) }\n+        }\n+    }\n+}\n+\n+fn check_compiling(filename: str) -> happiness {\n     /*\n     let p = std::run::program_output(\n             \"/Users/jruderman/code/rust/build/stage1/rustc\",\n             [\"-c\", filename]);\n     */\n \n-    let p = std::run::program_output(\"bash\", [\"-c\", \"DYLD_LIBRARY_PATH=/Users/jruderman/code/rust/build/stage0/lib:/Users/jruderman/code/rust/build/rustllvm/ /Users/jruderman/code/rust/build/stage1/rustc -c \" + filename]);\n+    let p = std::run::program_output(\"bash\", [\"-c\", \"DYLD_LIBRARY_PATH=/Users/jruderman/code/rust/build/stage0/lib:/Users/jruderman/code/rust/build/rustllvm/ /Users/jruderman/code/rust/build/stage1/rustc \" + filename]);\n \n     //log_err #fmt(\"Status: %d\", p.status);\n     if p.err != \"\" {\n@@ -276,16 +322,14 @@ fn check_whole_compiler_inner(filename: str) -> compile_result {\n             failed(\"Unfamiliar error message\")\n         }\n     } else if p.status == 0 {\n-        passed(\"Accepted the input program\")\n+        passed\n     } else if contains(p.out, \"Out of stack space, sorry\") {\n         known_bug(\"Recursive types - https://github.com/graydon/rust/issues/742\")\n     } else if contains(p.out, \"Assertion !cx.terminated failed\") {\n         known_bug(\"https://github.com/graydon/rust/issues/893 or https://github.com/graydon/rust/issues/894\")\n //  } else if contains(p.out, \"upcall fail 'non-exhaustive match failure', ../src/comp/middle/trans.rs\") {\n     } else if contains(p.out, \"trans_rec expected a rec but found _|_\") {\n         known_bug(\"https://github.com/graydon/rust/issues/924\")\n-    } else if contains(p.out, \"Assertion failed: (alloc->magic == MAGIC)\") {\n-        known_bug(\"https://github.com/graydon/rust/issues/934\")\n     } else if contains(p.out, \"Assertion failed: (S->getType()->isPointerTy() && \\\"Invalid cast\\\")\") {\n         known_bug(\"https://github.com/graydon/rust/issues/935\")\n     } else if contains(p.out, \"Ptr must be a pointer to Val type\") {\n@@ -295,7 +339,7 @@ fn check_whole_compiler_inner(filename: str) -> compile_result {\n         failed(\"Looks like an llvm assertion failure\")\n \n     } else if contains(p.out, \"internal compiler error fail called with unsupported type _|_\") {\n-        known_bug(\"https://github.com/graydon/rust/issues/930\")\n+        known_bug(\"https://github.com/graydon/rust/issues/942\")\n     } else if contains(p.out, \"internal compiler error Translating unsupported cast\") {\n         known_bug(\"https://github.com/graydon/rust/issues/932\")\n     } else if contains(p.out, \"internal compiler error sequence_element_type called on non-sequence value\") {\n@@ -309,7 +353,7 @@ fn check_whole_compiler_inner(filename: str) -> compile_result {\n         failed(\"internal compiler error\")\n \n     } else if contains(p.out, \"error:\") {\n-        passed(\"Rejected the input program cleanly\")\n+        cleanly_rejected(\"rejected with span_error\")\n     } else {\n         log_err p.status;\n         log_err \"!Stdout: \" + p.out;\n@@ -330,6 +374,31 @@ fn parse_and_print(code: str) -> str {\n                                         pprust::no_ann()));\n }\n \n+fn has_raw_pointers(c: ast::crate) -> bool {\n+    let has_rp = @mutable false;\n+    fn visit_ty(flag: @mutable bool, t: @ast::ty) {\n+        alt t.node {\n+          ast::ty_ptr(_) { *flag = true; }\n+          _ { }\n+        }\n+    }\n+    let v =\n+        visit::mk_simple_visitor(@{visit_ty: bind visit_ty(has_rp, _)\n+                                      with *visit::default_simple_visitor()});\n+    visit::visit_crate(c, (), v);\n+    ret *has_rp;\n+}\n+\n+fn content_is_dangerous_to_run(code: str) -> bool {\n+    let dangerous_patterns =\n+        [\"import\", // espeically fs, run\n+         \"native\",\n+         \"unsafe\"];\n+\n+    for p: str in dangerous_patterns { if contains(code, p) { ret true; } }\n+    ret false;\n+}\n+\n fn content_is_dangerous_to_modify(code: str) -> bool {\n     let dangerous_patterns =\n         [\"#macro\", // not safe to steal things inside of it, because they have a special syntax"}]}