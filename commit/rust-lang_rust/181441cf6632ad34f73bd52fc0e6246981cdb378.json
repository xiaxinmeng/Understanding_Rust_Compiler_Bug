{"sha": "181441cf6632ad34f73bd52fc0e6246981cdb378", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MTQ0MWNmNjYzMmFkMzRmNzNiZDUyZmMwZTYyNDY5ODFjZGIzNzg=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-18T09:08:56Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-18T16:51:06Z"}, "message": "Rollup merge of #23461 - alexcrichton:feat-char-at, r=aturon\n\n This commit clarifies some of the unstable features in the `str` module by\nmoving them out of the blanket `core` and `collections` features.\n\nThe following methods were moved to the `str_char` feature which generally\nencompasses decoding specific characters from a `str` and dealing with the\nresult. It is unclear if any of these methods need to be stabilized for 1.0 and\nthe most conservative route for now is to continue providing them but to leave\nthem as unstable under a more specific name.\n\n* `is_char_boundary`\n* `char_at`\n* `char_range_at`\n* `char_at_reverse`\n* `char_range_at_reverse`\n* `slice_shift_char`\n\nThe following methods were moved into the generic `unicode` feature as they are\nspecifically enabled by the `unicode` crate itself.\n\n* `nfd_chars`\n* `nfkd_chars`\n* `nfc_chars`\n* `graphemes`\n* `grapheme_indices`\n* `width`", "tree": {"sha": "3dc301cfc13445829b50200d1bf442c60c7d91a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dc301cfc13445829b50200d1bf442c60c7d91a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/181441cf6632ad34f73bd52fc0e6246981cdb378", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/181441cf6632ad34f73bd52fc0e6246981cdb378", "html_url": "https://github.com/rust-lang/rust/commit/181441cf6632ad34f73bd52fc0e6246981cdb378", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/181441cf6632ad34f73bd52fc0e6246981cdb378/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46f649c479ce40f3b4590590dda6c2895e8d60f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/46f649c479ce40f3b4590590dda6c2895e8d60f6", "html_url": "https://github.com/rust-lang/rust/commit/46f649c479ce40f3b4590590dda6c2895e8d60f6"}, {"sha": "aa88da63179b8ccd3b809e98b489c25199b06cf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa88da63179b8ccd3b809e98b489c25199b06cf7", "html_url": "https://github.com/rust-lang/rust/commit/aa88da63179b8ccd3b809e98b489c25199b06cf7"}], "stats": {"total": 248, "additions": 156, "deletions": 92}, "files": [{"sha": "a754bd950f7f6006709fac0e228eda7cb706c8ec", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=181441cf6632ad34f73bd52fc0e6246981cdb378", "patch": "@@ -1052,22 +1052,22 @@ fn scan_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n-    let range = haystack.char_range_at(*idx);\n-    if range.ch != needle {\n+    let ch = haystack.char_at(*idx);\n+    if ch != needle {\n         return false;\n     }\n-    *idx = range.next;\n+    *idx += ch.len_utf8();\n     return true;\n }\n \n fn scan_integer(haystack: &str, idx: &mut uint) -> bool {\n     let mut i = *idx;\n     while i < haystack.len() {\n-        let range = haystack.char_range_at(i);\n-        if range.ch < '0' || '9' < range.ch {\n+        let ch = haystack.char_at(i);\n+        if ch < '0' || '9' < ch {\n             break;\n         }\n-        i = range.next;\n+        i += ch.len_utf8();\n     }\n     if i == *idx {\n         return false;\n@@ -1083,9 +1083,9 @@ fn scan_string(haystack: &str, needle: &str, idx: &mut uint) -> bool {\n         if haystack_i >= haystack.len() {\n             return false;\n         }\n-        let range = haystack.char_range_at(haystack_i);\n-        haystack_i = range.next;\n-        if !scan_char(needle, range.ch, &mut needle_i) {\n+        let ch = haystack.char_at(haystack_i);\n+        haystack_i += ch.len_utf8();\n+        if !scan_char(needle, ch, &mut needle_i) {\n             return false;\n         }\n     }"}, {"sha": "c4a014967633321e10a765c2c9a53edfe87bb738", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=181441cf6632ad34f73bd52fc0e6246981cdb378", "patch": "@@ -35,6 +35,7 @@\n #![feature(unique)]\n #![feature(unsafe_no_drop_flag)]\n #![feature(step_by)]\n+#![feature(str_char)]\n #![cfg_attr(test, feature(rand, rustc_private, test))]\n #![cfg_attr(test, allow(deprecated))] // rand\n "}, {"sha": "781fc4f2ed002b5027af9a11a21701c5b548c711", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 102, "deletions": 56, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=181441cf6632ad34f73bd52fc0e6246981cdb378", "patch": "@@ -175,7 +175,9 @@ enum DecompositionType {\n ///\n /// For use with the `std::iter` module.\n #[derive(Clone)]\n-#[unstable(feature = \"collections\")]\n+#[unstable(feature = \"unicode\",\n+           reason = \"this functionality may be replaced with a more generic \\\n+                     unicode crate on crates.io\")]\n pub struct Decompositions<'a> {\n     kind: DecompositionType,\n     iter: Chars<'a>,\n@@ -266,7 +268,9 @@ enum RecompositionState {\n ///\n /// For use with the `std::iter` module.\n #[derive(Clone)]\n-#[unstable(feature = \"collections\")]\n+#[unstable(feature = \"unicode\",\n+           reason = \"this functionality may be replaced with a more generic \\\n+                     unicode crate on crates.io\")]\n pub struct Recompositions<'a> {\n     iter: Decompositions<'a>,\n     state: RecompositionState,\n@@ -472,8 +476,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// Returns an iterator over the string in Unicode Normalization Form D\n     /// (canonical decomposition).\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may be moved to libunicode\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     fn nfd_chars(&self) -> Decompositions {\n         Decompositions {\n             iter: self[..].chars(),\n@@ -486,8 +491,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// Returns an iterator over the string in Unicode Normalization Form KD\n     /// (compatibility decomposition).\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may be moved to libunicode\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     fn nfkd_chars(&self) -> Decompositions {\n         Decompositions {\n             iter: self[..].chars(),\n@@ -500,8 +506,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// An Iterator over the string in Unicode Normalization Form C\n     /// (canonical decomposition followed by canonical composition).\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may be moved to libunicode\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     fn nfc_chars(&self) -> Recompositions {\n         Recompositions {\n             iter: self.nfd_chars(),\n@@ -515,8 +522,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// An Iterator over the string in Unicode Normalization Form KC\n     /// (compatibility decomposition followed by canonical composition).\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may be moved to libunicode\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     fn nfkc_chars(&self) -> Recompositions {\n         Recompositions {\n             iter: self.nfkd_chars(),\n@@ -1023,8 +1031,11 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// // third byte of `\u8001`\n     /// assert!(!s.is_char_boundary(8));\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"naming is uncertain with container conventions\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"it is unclear whether this method pulls its weight \\\n+                         with the existence of the char_indices iterator or \\\n+                         this method may want to be replaced with checked \\\n+                         slicing\")]\n     fn is_char_boundary(&self, index: usize) -> bool {\n         core_str::StrExt::is_char_boundary(&self[..], index)\n     }\n@@ -1069,8 +1080,10 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// 14: a\n     /// 15: m\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"naming is uncertain with container conventions\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"often replaced by char_indices, this method may \\\n+                         be removed in favor of just char_at() or eventually \\\n+                         removed altogether\")]\n     fn char_range_at(&self, start: usize) -> CharRange {\n         core_str::StrExt::char_range_at(&self[..], start)\n     }\n@@ -1117,8 +1130,10 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// 6: \u534e\n     /// 3: \u4e2d\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"naming is uncertain with container conventions\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"often replaced by char_indices, this method may \\\n+                         be removed in favor of just char_at() or eventually \\\n+                         removed altogether\")]\n     fn char_range_at_reverse(&self, start: usize) -> CharRange {\n         core_str::StrExt::char_range_at_reverse(&self[..], start)\n     }\n@@ -1137,8 +1152,12 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(s.char_at(1), 'b');\n     /// assert_eq!(s.char_at(2), '\u03c0');\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"naming is uncertain with container conventions\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"frequently replaced by the chars() iterator, this \\\n+                         method may be removed or possibly renamed in the \\\n+                         future; it is normally replaced by chars/char_indices \\\n+                         iterators or by getting the first char from a \\\n+                         subslice\")]\n     fn char_at(&self, i: usize) -> char {\n         core_str::StrExt::char_at(&self[..], i)\n     }\n@@ -1157,8 +1176,10 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(s.char_at_reverse(1), 'a');\n     /// assert_eq!(s.char_at_reverse(2), 'b');\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"naming is uncertain with container conventions\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"see char_at for more details, but reverse semantics \\\n+                         are also somewhat unclear, especially with which \\\n+                         cases generate panics\")]\n     fn char_at_reverse(&self, i: usize) -> char {\n         core_str::StrExt::char_at_reverse(&self[..], i)\n     }\n@@ -1297,8 +1318,10 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(c, '\u00f6');\n     /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"awaiting conventions about shifting and slices\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"awaiting conventions about shifting and slices and \\\n+                         may not be warranted with the existence of the chars \\\n+                         and/or char_indices iterators\")]\n     fn slice_shift_char(&self) -> Option<(char, &str)> {\n         core_str::StrExt::slice_shift_char(&self[..])\n     }\n@@ -1421,8 +1444,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// assert_eq!(gr2.as_slice(), b);\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may only be provided by libunicode\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     fn graphemes(&self, is_extended: bool) -> Graphemes {\n         UnicodeStr::graphemes(&self[..], is_extended)\n     }\n@@ -1438,8 +1462,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// assert_eq!(gr_inds.as_slice(), b);\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may only be provided by libunicode\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n         UnicodeStr::grapheme_indices(&self[..], is_extended)\n     }\n@@ -1467,13 +1492,15 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// Control characters have zero width.\n     ///\n-    /// `is_cjk` determines behavior for characters in the Ambiguous category: if `is_cjk` is\n-    /// `true`, these are 2 columns wide; otherwise, they are 1. In CJK locales, `is_cjk` should be\n-    /// `true`, else it should be `false`.\n-    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/) recommends that these\n-    /// characters be treated as 1 column (i.e., `is_cjk = false`) if the locale is unknown.\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may only be provided by libunicode\")]\n+    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n+    /// if `is_cjk` is `true`, these are 2 columns wide; otherwise, they are 1.\n+    /// In CJK locales, `is_cjk` should be `true`, else it should be `false`.\n+    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n+    /// recommends that these characters be treated as 1 column (i.e., `is_cjk =\n+    /// false`) if the locale is unknown.\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     fn width(&self, is_cjk: bool) -> usize {\n         UnicodeStr::width(&self[..], is_cjk)\n     }\n@@ -1615,8 +1642,9 @@ impl str {\n     /// Returns an iterator over the string in Unicode Normalization Form D\n     /// (canonical decomposition).\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may be moved to libunicode\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     pub fn nfd_chars(&self) -> Decompositions {\n         Decompositions {\n             iter: self[..].chars(),\n@@ -1629,8 +1657,9 @@ impl str {\n     /// Returns an iterator over the string in Unicode Normalization Form KD\n     /// (compatibility decomposition).\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may be moved to libunicode\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     pub fn nfkd_chars(&self) -> Decompositions {\n         Decompositions {\n             iter: self[..].chars(),\n@@ -1643,8 +1672,9 @@ impl str {\n     /// An Iterator over the string in Unicode Normalization Form C\n     /// (canonical decomposition followed by canonical composition).\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may be moved to libunicode\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     pub fn nfc_chars(&self) -> Recompositions {\n         Recompositions {\n             iter: self.nfd_chars(),\n@@ -1658,8 +1688,9 @@ impl str {\n     /// An Iterator over the string in Unicode Normalization Form KC\n     /// (compatibility decomposition followed by canonical composition).\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may be moved to libunicode\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     pub fn nfkc_chars(&self) -> Recompositions {\n         Recompositions {\n             iter: self.nfkd_chars(),\n@@ -2172,8 +2203,11 @@ impl str {\n     /// // third byte of `\u8001`\n     /// assert!(!s.is_char_boundary(8));\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"naming is uncertain with container conventions\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"it is unclear whether this method pulls its weight \\\n+                         with the existence of the char_indices iterator or \\\n+                         this method may want to be replaced with checked \\\n+                         slicing\")]\n     pub fn is_char_boundary(&self, index: usize) -> bool {\n         core_str::StrExt::is_char_boundary(&self[..], index)\n     }\n@@ -2218,8 +2252,10 @@ impl str {\n     /// 14: a\n     /// 15: m\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"naming is uncertain with container conventions\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"often replaced by char_indices, this method may \\\n+                         be removed in favor of just char_at() or eventually \\\n+                         removed altogether\")]\n     pub fn char_range_at(&self, start: usize) -> CharRange {\n         core_str::StrExt::char_range_at(&self[..], start)\n     }\n@@ -2266,8 +2302,10 @@ impl str {\n     /// 6: \u534e\n     /// 3: \u4e2d\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"naming is uncertain with container conventions\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"often replaced by char_indices, this method may \\\n+                         be removed in favor of just char_at_reverse() or \\\n+                         eventually removed altogether\")]\n     pub fn char_range_at_reverse(&self, start: usize) -> CharRange {\n         core_str::StrExt::char_range_at_reverse(&self[..], start)\n     }\n@@ -2286,8 +2324,12 @@ impl str {\n     /// assert_eq!(s.char_at(1), 'b');\n     /// assert_eq!(s.char_at(2), '\u03c0');\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"naming is uncertain with container conventions\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"frequently replaced by the chars() iterator, this \\\n+                         method may be removed or possibly renamed in the \\\n+                         future; it is normally replaced by chars/char_indices \\\n+                         iterators or by getting the first char from a \\\n+                         subslice\")]\n     pub fn char_at(&self, i: usize) -> char {\n         core_str::StrExt::char_at(&self[..], i)\n     }\n@@ -2306,8 +2348,10 @@ impl str {\n     /// assert_eq!(s.char_at_reverse(1), 'a');\n     /// assert_eq!(s.char_at_reverse(2), 'b');\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"naming is uncertain with container conventions\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"see char_at for more details, but reverse semantics \\\n+                         are also somewhat unclear, especially with which \\\n+                         cases generate panics\")]\n     pub fn char_at_reverse(&self, i: usize) -> char {\n         core_str::StrExt::char_at_reverse(&self[..], i)\n     }\n@@ -2446,8 +2490,10 @@ impl str {\n     /// assert_eq!(c, '\u00f6');\n     /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"awaiting conventions about shifting and slices\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"awaiting conventions about shifting and slices and \\\n+                         may not be warranted with the existence of the chars \\\n+                         and/or char_indices iterators\")]\n     pub fn slice_shift_char(&self) -> Option<(char, &str)> {\n         core_str::StrExt::slice_shift_char(&self[..])\n     }\n@@ -2570,7 +2616,7 @@ impl str {\n     ///\n     /// assert_eq!(gr2.as_slice(), b);\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     pub fn graphemes(&self, is_extended: bool) -> Graphemes {\n         UnicodeStr::graphemes(&self[..], is_extended)\n@@ -2587,7 +2633,7 @@ impl str {\n     ///\n     /// assert_eq!(gr_inds.as_slice(), b);\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     pub fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n         UnicodeStr::grapheme_indices(&self[..], is_extended)\n@@ -2621,7 +2667,7 @@ impl str {\n     /// `true`, else it should be `false`.\n     /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/) recommends that these\n     /// characters be treated as 1 column (i.e., `is_cjk = false`) if the locale is unknown.\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     pub fn width(&self, is_cjk: bool) -> usize {\n         UnicodeStr::width(&self[..], is_cjk)"}, {"sha": "2a5f8db049689e870fb3e7782e2bdbb4962b3908", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=181441cf6632ad34f73bd52fc0e6246981cdb378", "patch": "@@ -29,7 +29,7 @@ use unicode::str as unicode_str;\n use unicode::str::Utf16Item;\n \n use borrow::{Cow, IntoCow};\n-use str::{self, CharRange, FromStr, Utf8Error};\n+use str::{self, FromStr, Utf8Error};\n use vec::{DerefVec, Vec, as_vec};\n \n /// A growable string stored as a UTF-8 encoded buffer.\n@@ -561,9 +561,9 @@ impl String {\n             return None\n         }\n \n-        let CharRange {ch, next} = self.char_range_at_reverse(len);\n+        let ch = self.char_at_reverse(len);\n         unsafe {\n-            self.vec.set_len(next);\n+            self.vec.set_len(len - ch.len_utf8());\n         }\n         Some(ch)\n     }\n@@ -595,7 +595,8 @@ impl String {\n         let len = self.len();\n         assert!(idx <= len);\n \n-        let CharRange { ch, next } = self.char_range_at(idx);\n+        let ch = self.char_at(idx);\n+        let next = idx + ch.len_utf8();\n         unsafe {\n             ptr::copy(self.vec.as_mut_ptr().offset(idx as isize),\n                       self.vec.as_ptr().offset(next as isize),"}, {"sha": "6b83338e1d2103f4c26b758469934ef3e84da77e", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=181441cf6632ad34f73bd52fc0e6246981cdb378", "patch": "@@ -18,6 +18,7 @@\n \n use self::OldSearcher::{TwoWay, TwoWayLong};\n \n+use char::CharExt;\n use clone::Clone;\n use cmp::{self, Eq};\n use default::Default;\n@@ -1112,8 +1113,10 @@ static UTF8_CHAR_WIDTH: [u8; 256] = [\n /// the next `char` in a string.  This can be used as a data structure\n /// for iterating over the UTF-8 bytes of a string.\n #[derive(Copy)]\n-#[unstable(feature = \"core\",\n-           reason = \"naming is uncertain with container conventions\")]\n+#[unstable(feature = \"str_char\",\n+           reason = \"existence of this struct is uncertain as it is frequently \\\n+                     able to be replaced with char.len_utf8() and/or \\\n+                     char/char_indices iterators\")]\n pub struct CharRange {\n     /// Current `char`\n     pub ch: char,\n@@ -1646,8 +1649,8 @@ impl StrExt for str {\n         if self.is_empty() {\n             None\n         } else {\n-            let CharRange {ch, next} = self.char_range_at(0);\n-            let next_s = unsafe { self.slice_unchecked(next, self.len()) };\n+            let ch = self.char_at(0);\n+            let next_s = unsafe { self.slice_unchecked(ch.len_utf8(), self.len()) };\n             Some((ch, next_s))\n         }\n     }"}, {"sha": "206fdd243c783ab154fc90b1e67123d974f1875c", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=181441cf6632ad34f73bd52fc0e6246981cdb378", "patch": "@@ -92,11 +92,10 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![deny(missing_docs)]\n-#![feature(collections)]\n #![feature(int_uint)]\n #![feature(staged_api)]\n-#![feature(core)]\n #![feature(str_words)]\n+#![feature(str_char)]\n #![cfg_attr(test, feature(rustc_private))]\n \n #[cfg(test)] #[macro_use] extern crate log;\n@@ -620,8 +619,8 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                 let mut j = 1;\n                 names = Vec::new();\n                 while j < curlen {\n-                    let range = cur.char_range_at(j);\n-                    let opt = Short(range.ch);\n+                    let ch = cur.char_at(j);\n+                    let opt = Short(ch);\n \n                     /* In a series of potential options (eg. -aheJ), if we\n                        see one which takes an argument, we assume all\n@@ -642,12 +641,13 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                         No => false\n                     };\n \n-                    if arg_follows && range.next < curlen {\n-                        i_arg = Some((&cur[range.next..curlen]).to_string());\n+                    let next = j + ch.len_utf8();\n+                    if arg_follows && next < curlen {\n+                        i_arg = Some((&cur[next..curlen]).to_string());\n                         break;\n                     }\n \n-                    j = range.next;\n+                    j = next;\n                 }\n             }\n             let mut name_pos = 0;"}, {"sha": "97ed391fdfc7842470d6ba283928c6f6bf0f6369", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=181441cf6632ad34f73bd52fc0e6246981cdb378", "patch": "@@ -42,6 +42,7 @@\n #![feature(io)]\n #![feature(path_ext)]\n #![feature(str_words)]\n+#![feature(str_char)]\n #![cfg_attr(test, feature(test))]\n \n extern crate arena;"}, {"sha": "0071e4434efa4a5ae8cc1aff523c887388c41c67", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=181441cf6632ad34f73bd52fc0e6246981cdb378", "patch": "@@ -38,6 +38,7 @@\n #![feature(exit_status)]\n #![feature(io)]\n #![feature(set_stdio)]\n+#![feature(unicode)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "99b3393c003de840856e6511268a6bd1d318be51", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=181441cf6632ad34f73bd52fc0e6246981cdb378", "patch": "@@ -41,6 +41,7 @@\n #![feature(unsafe_destructor)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n+#![feature(str_char)]\n #![cfg_attr(test, feature(test))]\n \n extern crate syntax;"}, {"sha": "31c270dca6bba1fa612d6c18da71362b4cc33916", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=181441cf6632ad34f73bd52fc0e6246981cdb378", "patch": "@@ -37,6 +37,7 @@ Core encoding and decoding interfaces.\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]\n+#![feature(str_char)]\n #![cfg_attr(test, feature(test))]\n \n // test harness access"}, {"sha": "41d5b3ce75ec7e02f6c082451d76a1aca93973a1", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=181441cf6632ad34f73bd52fc0e6246981cdb378", "patch": "@@ -127,6 +127,7 @@\n #![feature(int_uint)]\n #![feature(unique)]\n #![feature(allow_internal_unstable)]\n+#![feature(str_char)]\n #![cfg_attr(test, feature(test, rustc_private))]\n \n // Don't link to std. We are std."}, {"sha": "9f217bba00ab6e2b30b280c953a72032aed578a4", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=181441cf6632ad34f73bd52fc0e6246981cdb378", "patch": "@@ -38,6 +38,7 @@\n #![feature(std_misc)]\n #![feature(unicode)]\n #![feature(path_ext)]\n+#![feature(str_char)]\n \n extern crate arena;\n extern crate fmt_macros;"}, {"sha": "277f5365db3eca6883cf06531db133c44a64e4ae", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=181441cf6632ad34f73bd52fc0e6246981cdb378", "patch": "@@ -20,7 +20,6 @@ use parse::lexer;\n use print::pprust;\n \n use std::io::Read;\n-use std::str;\n use std::usize;\n \n #[derive(Clone, Copy, PartialEq)]\n@@ -210,11 +209,11 @@ fn all_whitespace(s: &str, col: CharPos) -> Option<usize> {\n     let mut col = col.to_usize();\n     let mut cursor: usize = 0;\n     while col > 0 && cursor < len {\n-        let r: str::CharRange = s.char_range_at(cursor);\n-        if !r.ch.is_whitespace() {\n+        let ch = s.char_at(cursor);\n+        if !ch.is_whitespace() {\n             return None;\n         }\n-        cursor = r.next;\n+        cursor += ch.len_utf8();\n         col -= 1;\n     }\n     return Some(cursor);"}, {"sha": "bb8f9da89171c96c8dea5b39f7de55a071ae2e1a", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=181441cf6632ad34f73bd52fc0e6246981cdb378", "patch": "@@ -22,7 +22,6 @@ use std::fmt;\n use std::mem::replace;\n use std::num;\n use std::rc::Rc;\n-use std::str;\n \n pub use ext::tt::transcribe::{TtReader, new_tt_reader, new_tt_reader_with_doc_flag};\n \n@@ -291,7 +290,8 @@ impl<'a> StringReader<'a> {\n                           s: &'b str, errmsg: &'b str) -> Cow<'b, str> {\n         let mut i = 0;\n         while i < s.len() {\n-            let str::CharRange { ch, next } = s.char_range_at(i);\n+            let ch = s.char_at(i);\n+            let next = i + ch.len_utf8();\n             if ch == '\\r' {\n                 if next < s.len() && s.char_at(next) == '\\n' {\n                     return translate_crlf_(self, start, s, errmsg, i).into_cow();\n@@ -309,7 +309,8 @@ impl<'a> StringReader<'a> {\n             let mut buf = String::with_capacity(s.len());\n             let mut j = 0;\n             while i < s.len() {\n-                let str::CharRange { ch, next } = s.char_range_at(i);\n+                let ch = s.char_at(i);\n+                let next = i + ch.len_utf8();\n                 if ch == '\\r' {\n                     if j < i { buf.push_str(&s[j..i]); }\n                     j = next;\n@@ -335,10 +336,11 @@ impl<'a> StringReader<'a> {\n         if current_byte_offset < self.source_text.len() {\n             assert!(self.curr.is_some());\n             let last_char = self.curr.unwrap();\n-            let next = self.source_text.char_range_at(current_byte_offset);\n-            let byte_offset_diff = next.next - current_byte_offset;\n+            let ch = self.source_text.char_at(current_byte_offset);\n+            let next = current_byte_offset + ch.len_utf8();\n+            let byte_offset_diff = next - current_byte_offset;\n             self.pos = self.pos + Pos::from_usize(byte_offset_diff);\n-            self.curr = Some(next.ch);\n+            self.curr = Some(ch);\n             self.col = self.col + CharPos(1);\n             if last_char == '\\n' {\n                 self.filemap.next_line(self.last_pos);\n@@ -370,7 +372,7 @@ impl<'a> StringReader<'a> {\n         let offset = self.byte_offset(self.pos).to_usize();\n         let s = &self.source_text[..];\n         if offset >= s.len() { return None }\n-        let str::CharRange { next, .. } = s.char_range_at(offset);\n+        let next = offset + s.char_at(offset).len_utf8();\n         if next < s.len() {\n             Some(s.char_at(next))\n         } else {"}, {"sha": "f517dca53cdd20366324ceae83dd523a55597220", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=181441cf6632ad34f73bd52fc0e6246981cdb378", "patch": "@@ -60,6 +60,7 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n+#![feature(str_char)]\n #![feature(path_ext)]\n #![cfg_attr(windows, feature(libc))]\n "}, {"sha": "0fbc98ea73cfbc4898aa953267b50eb6590accf4", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/181441cf6632ad34f73bd52fc0e6246981cdb378/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=181441cf6632ad34f73bd52fc0e6246981cdb378", "patch": "@@ -244,7 +244,7 @@ impl<'a> Iterator for Graphemes<'a> {\n         }\n \n         self.cat = if take_curr {\n-            idx = self.string.char_range_at(idx).next;\n+            idx = idx + len_utf8(self.string.char_at(idx));\n             None\n         } else {\n             Some(cat)\n@@ -256,6 +256,11 @@ impl<'a> Iterator for Graphemes<'a> {\n     }\n }\n \n+#[cfg(stage0)]\n+fn len_utf8(c: char) -> usize { UCharExt::len_utf8(c) }\n+#[cfg(not(stage0))]\n+fn len_utf8(c: char) -> usize { c.len_utf8() }\n+\n impl<'a> DoubleEndedIterator for Graphemes<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> {"}]}