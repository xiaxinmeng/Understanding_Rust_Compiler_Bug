{"sha": "78b674152ed09f2e7f30f0080171b43e11f56f31", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4YjY3NDE1MmVkMDlmMmU3ZjMwZjAwODAxNzFiNDNlMTFmNTZmMzE=", "commit": {"author": {"name": "Andrew Poelstra", "email": "apoelstra@wpsoftware.net", "date": "2014-07-02T17:17:27Z"}, "committer": {"name": "Andrew Poelstra", "email": "apoelstra@wpsoftware.net", "date": "2014-07-02T19:36:02Z"}, "message": "collections::bitv: change constructors for `Bitv` and `BitvSet`\n\n`Bitv::new` has been renamed `Bitv::with_capacity`. The new function\n`Bitv::new` now creates a `Bitv` with no elements.\n\nThe new function `BitvSet::with_capacity` creates a `BitvSet` with\na specified capacity.", "tree": {"sha": "2dc330564cababd8e9e60e136769919ae7ed5bd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dc330564cababd8e9e60e136769919ae7ed5bd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78b674152ed09f2e7f30f0080171b43e11f56f31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78b674152ed09f2e7f30f0080171b43e11f56f31", "html_url": "https://github.com/rust-lang/rust/commit/78b674152ed09f2e7f30f0080171b43e11f56f31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78b674152ed09f2e7f30f0080171b43e11f56f31/comments", "author": {"login": "apoelstra", "id": 1351933, "node_id": "MDQ6VXNlcjEzNTE5MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apoelstra", "html_url": "https://github.com/apoelstra", "followers_url": "https://api.github.com/users/apoelstra/followers", "following_url": "https://api.github.com/users/apoelstra/following{/other_user}", "gists_url": "https://api.github.com/users/apoelstra/gists{/gist_id}", "starred_url": "https://api.github.com/users/apoelstra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions", "organizations_url": "https://api.github.com/users/apoelstra/orgs", "repos_url": "https://api.github.com/users/apoelstra/repos", "events_url": "https://api.github.com/users/apoelstra/events{/privacy}", "received_events_url": "https://api.github.com/users/apoelstra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apoelstra", "id": 1351933, "node_id": "MDQ6VXNlcjEzNTE5MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apoelstra", "html_url": "https://github.com/apoelstra", "followers_url": "https://api.github.com/users/apoelstra/followers", "following_url": "https://api.github.com/users/apoelstra/following{/other_user}", "gists_url": "https://api.github.com/users/apoelstra/gists{/gist_id}", "starred_url": "https://api.github.com/users/apoelstra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions", "organizations_url": "https://api.github.com/users/apoelstra/orgs", "repos_url": "https://api.github.com/users/apoelstra/repos", "events_url": "https://api.github.com/users/apoelstra/events{/privacy}", "received_events_url": "https://api.github.com/users/apoelstra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9eb81edfea77603b1cf742817dd46a8b1ec0455e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9eb81edfea77603b1cf742817dd46a8b1ec0455e", "html_url": "https://github.com/rust-lang/rust/commit/9eb81edfea77603b1cf742817dd46a8b1ec0455e"}], "stats": {"total": 156, "additions": 84, "deletions": 72}, "files": [{"sha": "fdd690ccdd9ac344df0c29992dc7bd14322f12b1", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 81, "deletions": 69, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/78b674152ed09f2e7f30f0080171b43e11f56f31/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b674152ed09f2e7f30f0080171b43e11f56f31/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=78b674152ed09f2e7f30f0080171b43e11f56f31", "patch": "@@ -31,7 +31,7 @@ use vec::Vec;\n /// ```rust\n /// use collections::bitv::Bitv;\n ///\n-/// let mut bv = Bitv::new(10, false);\n+/// let mut bv = Bitv::with_capacity(10, false);\n ///\n /// // insert all primes less than 10\n /// bv.set(2, true);\n@@ -126,9 +126,14 @@ impl Bitv {\n         }\n     }\n \n-    /// Creates an empty Bitv that holds `nbits` elements, setting each element\n+    /// Creates an empty Bitv\n+    pub fn new() -> Bitv {\n+        Bitv { storage: Vec::new(), nbits: 0 }\n+    }\n+\n+    /// Creates a Bitv that holds `nbits` elements, setting each element\n     /// to `init`.\n-    pub fn new(nbits: uint, init: bool) -> Bitv {\n+    pub fn with_capacity(nbits: uint, init: bool) -> Bitv {\n         Bitv {\n             storage: Vec::from_elem((nbits + uint::BITS - 1) / uint::BITS,\n                                     if init { !0u } else { 0u }),\n@@ -226,7 +231,7 @@ impl Bitv {\n     ///\n     /// ```rust\n     /// use collections::bitv::Bitv;\n-    /// let mut bv = Bitv::new(10, false);\n+    /// let mut bv = Bitv::with_capacity(10, false);\n     /// bv.set(1, true);\n     /// bv.set(2, true);\n     /// bv.set(3, true);\n@@ -441,7 +446,7 @@ pub fn from_bytes(bytes: &[u8]) -> Bitv {\n  * index is `f(index)`.\n  */\n pub fn from_fn(len: uint, f: |index: uint| -> bool) -> Bitv {\n-    let mut bitv = Bitv::new(len, false);\n+    let mut bitv = Bitv::with_capacity(len, false);\n     for i in range(0u, len) {\n         bitv.set(i, f(i));\n     }\n@@ -450,7 +455,7 @@ pub fn from_fn(len: uint, f: |index: uint| -> bool) -> Bitv {\n \n impl Default for Bitv {\n     #[inline]\n-    fn default() -> Bitv { Bitv::new(0, false) }\n+    fn default() -> Bitv { Bitv::new() }\n }\n \n impl Collection for Bitv {\n@@ -467,7 +472,7 @@ impl Mutable for Bitv {\n \n impl FromIterator<bool> for Bitv {\n     fn from_iter<I:Iterator<bool>>(iterator: I) -> Bitv {\n-        let mut ret = Bitv::new(0, false);\n+        let mut ret = Bitv::new();\n         ret.extend(iterator);\n         ret\n     }\n@@ -609,7 +614,14 @@ impl BitvSet {\n     /// Creates a new bit vector set with initially no contents\n     #[inline]\n     pub fn new() -> BitvSet {\n-        BitvSet(Bitv::new(0, false))\n+        BitvSet(Bitv::new())\n+    }\n+\n+    /// Creates a new bit vector set with initially no contents, able to\n+    /// hold `nbits` elements without resizing\n+    #[inline]\n+    pub fn with_capacity(nbits: uint) -> BitvSet {\n+        BitvSet(Bitv::with_capacity(nbits, false))\n     }\n \n     /// Creates a new bit vector set from the given bit vector\n@@ -994,31 +1006,31 @@ mod tests {\n \n     #[test]\n     fn test_to_str() {\n-        let zerolen = Bitv::new(0u, false);\n+        let zerolen = Bitv::new();\n         assert_eq!(zerolen.to_str().as_slice(), \"\");\n \n-        let eightbits = Bitv::new(8u, false);\n+        let eightbits = Bitv::with_capacity(8u, false);\n         assert_eq!(eightbits.to_str().as_slice(), \"00000000\")\n     }\n \n     #[test]\n     fn test_0_elements() {\n-        let act = Bitv::new(0u, false);\n+        let act = Bitv::new();\n         let exp = Vec::from_elem(0u, false);\n         assert!(act.eq_vec(exp.as_slice()));\n     }\n \n     #[test]\n     fn test_1_element() {\n-        let mut act = Bitv::new(1u, false);\n+        let mut act = Bitv::with_capacity(1u, false);\n         assert!(act.eq_vec([false]));\n-        act = Bitv::new(1u, true);\n+        act = Bitv::with_capacity(1u, true);\n         assert!(act.eq_vec([true]));\n     }\n \n     #[test]\n     fn test_2_elements() {\n-        let mut b = bitv::Bitv::new(2, false);\n+        let mut b = bitv::Bitv::with_capacity(2, false);\n         b.set(0, true);\n         b.set(1, false);\n         assert_eq!(b.to_str().as_slice(), \"10\");\n@@ -1029,16 +1041,16 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::new(10u, false);\n+        act = Bitv::with_capacity(10u, false);\n         assert!((act.eq_vec(\n                     [false, false, false, false, false, false, false, false, false, false])));\n         // all 1\n \n-        act = Bitv::new(10u, true);\n+        act = Bitv::with_capacity(10u, true);\n         assert!((act.eq_vec([true, true, true, true, true, true, true, true, true, true])));\n         // mixed\n \n-        act = Bitv::new(10u, false);\n+        act = Bitv::with_capacity(10u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -1047,7 +1059,7 @@ mod tests {\n         assert!((act.eq_vec([true, true, true, true, true, false, false, false, false, false])));\n         // mixed\n \n-        act = Bitv::new(10u, false);\n+        act = Bitv::with_capacity(10u, false);\n         act.set(5u, true);\n         act.set(6u, true);\n         act.set(7u, true);\n@@ -1056,7 +1068,7 @@ mod tests {\n         assert!((act.eq_vec([false, false, false, false, false, true, true, true, true, true])));\n         // mixed\n \n-        act = Bitv::new(10u, false);\n+        act = Bitv::with_capacity(10u, false);\n         act.set(0u, true);\n         act.set(3u, true);\n         act.set(6u, true);\n@@ -1069,21 +1081,21 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::new(31u, false);\n+        act = Bitv::with_capacity(31u, false);\n         assert!(act.eq_vec(\n                 [false, false, false, false, false, false, false, false, false, false, false,\n                 false, false, false, false, false, false, false, false, false, false, false, false,\n                 false, false, false, false, false, false, false, false]));\n         // all 1\n \n-        act = Bitv::new(31u, true);\n+        act = Bitv::with_capacity(31u, true);\n         assert!(act.eq_vec(\n                 [true, true, true, true, true, true, true, true, true, true, true, true, true,\n                 true, true, true, true, true, true, true, true, true, true, true, true, true, true,\n                 true, true, true, true]));\n         // mixed\n \n-        act = Bitv::new(31u, false);\n+        act = Bitv::with_capacity(31u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -1098,7 +1110,7 @@ mod tests {\n                 false, false, false, false, false, false]));\n         // mixed\n \n-        act = Bitv::new(31u, false);\n+        act = Bitv::with_capacity(31u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -1113,7 +1125,7 @@ mod tests {\n                 false, false, false, false, false, false, false]));\n         // mixed\n \n-        act = Bitv::new(31u, false);\n+        act = Bitv::with_capacity(31u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -1127,7 +1139,7 @@ mod tests {\n                 false, true, true, true, true, true, true, true]));\n         // mixed\n \n-        act = Bitv::new(31u, false);\n+        act = Bitv::with_capacity(31u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n@@ -1142,21 +1154,21 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::new(32u, false);\n+        act = Bitv::with_capacity(32u, false);\n         assert!(act.eq_vec(\n                 [false, false, false, false, false, false, false, false, false, false, false,\n                 false, false, false, false, false, false, false, false, false, false, false, false,\n                 false, false, false, false, false, false, false, false, false]));\n         // all 1\n \n-        act = Bitv::new(32u, true);\n+        act = Bitv::with_capacity(32u, true);\n         assert!(act.eq_vec(\n                 [true, true, true, true, true, true, true, true, true, true, true, true, true,\n                 true, true, true, true, true, true, true, true, true, true, true, true, true, true,\n                 true, true, true, true, true]));\n         // mixed\n \n-        act = Bitv::new(32u, false);\n+        act = Bitv::with_capacity(32u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -1171,7 +1183,7 @@ mod tests {\n                 false, false, false, false, false, false, false]));\n         // mixed\n \n-        act = Bitv::new(32u, false);\n+        act = Bitv::with_capacity(32u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -1186,7 +1198,7 @@ mod tests {\n                 false, false, false, false, false, false, false, false]));\n         // mixed\n \n-        act = Bitv::new(32u, false);\n+        act = Bitv::with_capacity(32u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -1201,7 +1213,7 @@ mod tests {\n                 false, true, true, true, true, true, true, true, true]));\n         // mixed\n \n-        act = Bitv::new(32u, false);\n+        act = Bitv::with_capacity(32u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n@@ -1217,21 +1229,21 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::new(33u, false);\n+        act = Bitv::with_capacity(33u, false);\n         assert!(act.eq_vec(\n                 [false, false, false, false, false, false, false, false, false, false, false,\n                 false, false, false, false, false, false, false, false, false, false, false, false,\n                 false, false, false, false, false, false, false, false, false, false]));\n         // all 1\n \n-        act = Bitv::new(33u, true);\n+        act = Bitv::with_capacity(33u, true);\n         assert!(act.eq_vec(\n                 [true, true, true, true, true, true, true, true, true, true, true, true, true,\n                 true, true, true, true, true, true, true, true, true, true, true, true, true, true,\n                 true, true, true, true, true, true]));\n         // mixed\n \n-        act = Bitv::new(33u, false);\n+        act = Bitv::with_capacity(33u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -1246,7 +1258,7 @@ mod tests {\n                 false, false, false, false, false, false, false, false]));\n         // mixed\n \n-        act = Bitv::new(33u, false);\n+        act = Bitv::with_capacity(33u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -1261,7 +1273,7 @@ mod tests {\n                 false, false, false, false, false, false, false, false, false]));\n         // mixed\n \n-        act = Bitv::new(33u, false);\n+        act = Bitv::with_capacity(33u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -1276,7 +1288,7 @@ mod tests {\n                 false, true, true, true, true, true, true, true, true, false]));\n         // mixed\n \n-        act = Bitv::new(33u, false);\n+        act = Bitv::with_capacity(33u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n@@ -1290,37 +1302,37 @@ mod tests {\n \n     #[test]\n     fn test_equal_differing_sizes() {\n-        let v0 = Bitv::new(10u, false);\n-        let v1 = Bitv::new(11u, false);\n+        let v0 = Bitv::with_capacity(10u, false);\n+        let v1 = Bitv::with_capacity(11u, false);\n         assert!(v0 != v1);\n     }\n \n     #[test]\n     fn test_equal_greatly_differing_sizes() {\n-        let v0 = Bitv::new(10u, false);\n-        let v1 = Bitv::new(110u, false);\n+        let v0 = Bitv::with_capacity(10u, false);\n+        let v1 = Bitv::with_capacity(110u, false);\n         assert!(v0 != v1);\n     }\n \n     #[test]\n     fn test_equal_sneaky_small() {\n-        let mut a = bitv::Bitv::new(1, false);\n+        let mut a = bitv::Bitv::with_capacity(1, false);\n         a.set(0, true);\n \n-        let mut b = bitv::Bitv::new(1, true);\n+        let mut b = bitv::Bitv::with_capacity(1, true);\n         b.set(0, true);\n \n         assert_eq!(a, b);\n     }\n \n     #[test]\n     fn test_equal_sneaky_big() {\n-        let mut a = bitv::Bitv::new(100, false);\n+        let mut a = bitv::Bitv::with_capacity(100, false);\n         for i in range(0u, 100) {\n             a.set(i, true);\n         }\n \n-        let mut b = bitv::Bitv::new(100, true);\n+        let mut b = bitv::Bitv::with_capacity(100, true);\n         for i in range(0u, 100) {\n             b.set(i, true);\n         }\n@@ -1337,11 +1349,11 @@ mod tests {\n \n     #[test]\n     fn test_to_bytes() {\n-        let mut bv = Bitv::new(3, true);\n+        let mut bv = Bitv::with_capacity(3, true);\n         bv.set(1, false);\n         assert_eq!(bv.to_bytes(), vec!(0b10100000));\n \n-        let mut bv = Bitv::new(9, false);\n+        let mut bv = Bitv::with_capacity(9, false);\n         bv.set(2, true);\n         bv.set(8, true);\n         assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n@@ -1385,7 +1397,7 @@ mod tests {\n         let lengths = [10, 64, 100];\n         for &b in bools.iter() {\n             for &l in lengths.iter() {\n-                let bitset = BitvSet::from_bitv(Bitv::new(l, b));\n+                let bitset = BitvSet::from_bitv(Bitv::with_capacity(l, b));\n                 assert_eq!(bitset.contains(&1u), b)\n                 assert_eq!(bitset.contains(&(l-1u)), b)\n                 assert!(!bitset.contains(&l))\n@@ -1395,8 +1407,8 @@ mod tests {\n \n     #[test]\n     fn test_small_difference() {\n-        let mut b1 = Bitv::new(3, false);\n-        let mut b2 = Bitv::new(3, false);\n+        let mut b1 = Bitv::with_capacity(3, false);\n+        let mut b2 = Bitv::with_capacity(3, false);\n         b1.set(0, true);\n         b1.set(1, true);\n         b2.set(1, true);\n@@ -1409,8 +1421,8 @@ mod tests {\n \n     #[test]\n     fn test_big_difference() {\n-        let mut b1 = Bitv::new(100, false);\n-        let mut b2 = Bitv::new(100, false);\n+        let mut b1 = Bitv::with_capacity(100, false);\n+        let mut b2 = Bitv::with_capacity(100, false);\n         b1.set(0, true);\n         b1.set(40, true);\n         b2.set(40, true);\n@@ -1423,7 +1435,7 @@ mod tests {\n \n     #[test]\n     fn test_small_clear() {\n-        let mut b = Bitv::new(14, true);\n+        let mut b = Bitv::with_capacity(14, true);\n         b.clear();\n         BitvSet::from_bitv(b).iter().advance(|i| {\n             fail!(\"found 1 at {:?}\", i)\n@@ -1432,7 +1444,7 @@ mod tests {\n \n     #[test]\n     fn test_big_clear() {\n-        let mut b = Bitv::new(140, true);\n+        let mut b = Bitv::with_capacity(140, true);\n         b.clear();\n         BitvSet::from_bitv(b).iter().advance(|i| {\n             fail!(\"found 1 at {:?}\", i)\n@@ -1441,7 +1453,7 @@ mod tests {\n \n     #[test]\n     fn test_bitv_masking() {\n-        let b = Bitv::new(140, true); \n+        let b = Bitv::with_capacity(140, true);\n         let mut bs = BitvSet::from_bitv(b);\n         assert!(bs.contains(&139));\n         assert!(!bs.contains(&140));\n@@ -1664,7 +1676,7 @@ mod tests {\n \n     #[test]\n     fn test_bitv_push_pop() {\n-        let mut s = Bitv::new(5 * uint::BITS - 2, false);\n+        let mut s = Bitv::with_capacity(5 * uint::BITS - 2, false);\n         assert_eq!(s.len(), 5 * uint::BITS - 2);\n         assert_eq!(s.get(5 * uint::BITS - 3), false);\n         s.push(true);\n@@ -1687,28 +1699,28 @@ mod tests {\n \n     #[test]\n     fn test_bitv_truncate() {\n-        let mut s = Bitv::new(5 * uint::BITS, true);\n+        let mut s = Bitv::with_capacity(5 * uint::BITS, true);\n \n-        assert_eq!(s, Bitv::new(5 * uint::BITS, true));\n+        assert_eq!(s, Bitv::with_capacity(5 * uint::BITS, true));\n         assert_eq!(s.len(), 5 * uint::BITS);\n         s.truncate(4 * uint::BITS);\n-        assert_eq!(s, Bitv::new(4 * uint::BITS, true));\n+        assert_eq!(s, Bitv::with_capacity(4 * uint::BITS, true));\n         assert_eq!(s.len(), 4 * uint::BITS);\n         // Truncating to a size > s.len() should be a noop\n         s.truncate(5 * uint::BITS);\n-        assert_eq!(s, Bitv::new(4 * uint::BITS, true));\n+        assert_eq!(s, Bitv::with_capacity(4 * uint::BITS, true));\n         assert_eq!(s.len(), 4 * uint::BITS);\n         s.truncate(3 * uint::BITS - 10);\n-        assert_eq!(s, Bitv::new(3 * uint::BITS - 10, true));\n+        assert_eq!(s, Bitv::with_capacity(3 * uint::BITS - 10, true));\n         assert_eq!(s.len(), 3 * uint::BITS - 10);\n         s.truncate(0);\n-        assert_eq!(s, Bitv::new(0, true));\n+        assert_eq!(s, Bitv::with_capacity(0, true));\n         assert_eq!(s.len(), 0);\n     }\n \n     #[test]\n     fn test_bitv_reserve() {\n-        let mut s = Bitv::new(5 * uint::BITS, true);\n+        let mut s = Bitv::with_capacity(5 * uint::BITS, true);\n         // Check capacity\n         assert_eq!(s.capacity(), 5 * uint::BITS);\n         s.reserve(2 * uint::BITS);\n@@ -1781,7 +1793,7 @@ mod tests {\n     #[bench]\n     fn bench_bitv_big(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = Bitv::new(BENCH_BITS, false);\n+        let mut bitv = Bitv::with_capacity(BENCH_BITS, false);\n         b.iter(|| {\n             bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n             &bitv\n@@ -1791,7 +1803,7 @@ mod tests {\n     #[bench]\n     fn bench_bitv_small(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = Bitv::new(uint::BITS, false);\n+        let mut bitv = Bitv::with_capacity(uint::BITS, false);\n         b.iter(|| {\n             bitv.set((r.next_u32() as uint) % uint::BITS, true);\n             &bitv\n@@ -1820,16 +1832,16 @@ mod tests {\n \n     #[bench]\n     fn bench_bitv_big_union(b: &mut Bencher) {\n-        let mut b1 = Bitv::new(BENCH_BITS, false);\n-        let b2 = Bitv::new(BENCH_BITS, false);\n+        let mut b1 = Bitv::with_capacity(BENCH_BITS, false);\n+        let b2 = Bitv::with_capacity(BENCH_BITS, false);\n         b.iter(|| {\n             b1.union(&b2);\n         })\n     }\n \n     #[bench]\n     fn bench_btv_small_iter(b: &mut Bencher) {\n-        let bitv = Bitv::new(uint::BITS, false);\n+        let bitv = Bitv::with_capacity(uint::BITS, false);\n         b.iter(|| {\n             let mut _sum = 0;\n             for pres in bitv.iter() {\n@@ -1840,7 +1852,7 @@ mod tests {\n \n     #[bench]\n     fn bench_bitv_big_iter(b: &mut Bencher) {\n-        let bitv = Bitv::new(BENCH_BITS, false);\n+        let bitv = Bitv::with_capacity(BENCH_BITS, false);\n         b.iter(|| {\n             let mut _sum = 0;\n             for pres in bitv.iter() {"}, {"sha": "3823a7033f5a61c536ab9a57ed5a81d5660d8aa7", "filename": "src/test/run-pass/bitv-perf-test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78b674152ed09f2e7f30f0080171b43e11f56f31/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b674152ed09f2e7f30f0080171b43e11f56f31/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs?ref=78b674152ed09f2e7f30f0080171b43e11f56f31", "patch": "@@ -13,8 +13,8 @@ extern crate collections;\n use std::collections::Bitv;\n \n fn bitv_test() {\n-    let mut v1 = box Bitv::new(31, false);\n-    let v2 = box Bitv::new(31, true);\n+    let mut v1 = box Bitv::with_capacity(31, false);\n+    let v2 = box Bitv::with_capacity(31, true);\n     v1.union(v2);\n }\n "}, {"sha": "255807b4c0e6912334626fea79a92ac0edaf8e12", "filename": "src/test/run-pass/issue-11736.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78b674152ed09f2e7f30f0080171b43e11f56f31/src%2Ftest%2Frun-pass%2Fissue-11736.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b674152ed09f2e7f30f0080171b43e11f56f31/src%2Ftest%2Frun-pass%2Fissue-11736.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11736.rs?ref=78b674152ed09f2e7f30f0080171b43e11f56f31", "patch": "@@ -16,7 +16,7 @@ use std::collections::Bitv;\n fn main() {\n     // Generate sieve of Eratosthenes for n up to 1e6\n     let n = 1000000u;\n-    let sieve = Bitv::new(n+1, true);\n+    let sieve = Bitv::with_capacity(n+1, true);\n     let limit: uint = (n as f32).sqrt() as uint;\n     for i in range(2, limit+1) {\n         if sieve[i] {"}]}