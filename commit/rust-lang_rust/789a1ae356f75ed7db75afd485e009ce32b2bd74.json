{"sha": "789a1ae356f75ed7db75afd485e009ce32b2bd74", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4OWExYWUzNTZmNzVlZDdkYjc1YWZkNDg1ZTAwOWNlMzJiMmJkNzQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-21T13:20:18Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-21T13:20:18Z"}, "message": "Clean up a number of TODOs in the trans modules\n\nRename the ones that I didn't handle to FIXME", "tree": {"sha": "43659136118952f195e20c79a9b5c7a6fb922901", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43659136118952f195e20c79a9b5c7a6fb922901"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/789a1ae356f75ed7db75afd485e009ce32b2bd74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/789a1ae356f75ed7db75afd485e009ce32b2bd74", "html_url": "https://github.com/rust-lang/rust/commit/789a1ae356f75ed7db75afd485e009ce32b2bd74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/789a1ae356f75ed7db75afd485e009ce32b2bd74/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9691ce18a2674e322be4b2e8f2e44888eb957170", "url": "https://api.github.com/repos/rust-lang/rust/commits/9691ce18a2674e322be4b2e8f2e44888eb957170", "html_url": "https://github.com/rust-lang/rust/commit/9691ce18a2674e322be4b2e8f2e44888eb957170"}], "stats": {"total": 569, "additions": 272, "deletions": 297}, "files": [{"sha": "8827f27d1ed8c9d43086b4c84985594dc0ecfdef", "filename": "src/comp/middle/trans/alt.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=789a1ae356f75ed7db75afd485e009ce32b2bd74", "patch": "@@ -38,12 +38,12 @@ enum opt_result {\n     range_result(result, result),\n }\n fn trans_opt(bcx: block, o: opt) -> opt_result {\n-    let ccx = bcx_ccx(bcx), bcx = bcx;\n+    let ccx = bcx.ccx(), bcx = bcx;\n     alt o {\n       lit(l) {\n         alt l.node {\n           ast::expr_lit(@{node: ast::lit_str(s), _}) {\n-            let strty = ty::mk_str(bcx_tcx(bcx));\n+            let strty = ty::mk_str(bcx.tcx());\n             let cell = empty_dest_cell();\n             bcx = tvec::trans_str(bcx, s, by_val(cell));\n             add_clean_temp(bcx, *cell, strty);\n@@ -526,7 +526,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef], f: mk_fail,\n                 llvm::LLVMAddCase(sw, r.val, opt_cx.llbb);\n                 bcx = r.bcx;\n               }\n-              _ { bcx_tcx(bcx).sess.bug(\"Someone forgot to\\\n+              _ { bcx.tcx().sess.bug(\"Someone forgot to\\\n                     document an invariant in compile_submatch\"); }\n             }\n           }\n@@ -599,10 +599,10 @@ fn make_phi_bindings(bcx: block, map: [exit_node],\n     if success {\n         // Copy references that the alias analysis considered unsafe\n         ids.values {|node_id|\n-            if bcx_ccx(bcx).copy_map.contains_key(node_id) {\n+            if bcx.ccx().copy_map.contains_key(node_id) {\n                 let local = alt bcx.fcx.lllocals.find(node_id) {\n                   some(local_mem(x)) { x }\n-                  _ { bcx_tcx(bcx).sess.bug(\"Someone \\\n+                  _ { bcx.tcx().sess.bug(\"Someone \\\n                         forgot to document an invariant in \\\n                         make_phi_bindings\"); }\n                 };\n@@ -628,7 +628,7 @@ fn trans_alt(bcx: block, expr: @ast::expr, arms: [ast::arm],\n \n fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm],\n                    dest: dest) -> block {\n-    let bcx = scope_cx, tcx = bcx_tcx(bcx);\n+    let bcx = scope_cx, tcx = bcx.tcx();\n     let bodies = [], match = [];\n \n     let {bcx, val, _} = trans_temp_expr(bcx, expr);\n@@ -690,7 +690,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n     let ccx = bcx.fcx.ccx, bcx = bcx;\n \n     // Necessary since bind_irrefutable_pat is called outside trans_alt\n-    alt normalize_pat(bcx_tcx(bcx), pat).node {\n+    alt normalize_pat(bcx.tcx(), pat).node {\n       ast::pat_ident(_,inner) {\n         if make_copy || ccx.copy_map.contains_key(pat.id) {\n             let ty = node_id_type(bcx, pat.id);"}, {"sha": "b1603f352205ffb805e6c949ee294050702eca26", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 147, "deletions": 153, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=789a1ae356f75ed7db75afd485e009ce32b2bd74", "patch": "@@ -294,18 +294,18 @@ fn trans_native_call(cx: block, externs: hashmap<str, ValueRef>,\n         get_simple_extern_fn(cx, externs, llmod, name, n);\n     let call_args: [ValueRef] = [];\n     for a: ValueRef in args {\n-        call_args += [ZExtOrBitCast(cx, a, bcx_ccx(cx).int_type)];\n+        call_args += [ZExtOrBitCast(cx, a, cx.ccx().int_type)];\n     }\n     ret Call(cx, llnative, call_args);\n }\n \n fn trans_free(cx: block, v: ValueRef) -> block {\n-    Call(cx, bcx_ccx(cx).upcalls.free, [PointerCast(cx, v, T_ptr(T_i8()))]);\n+    Call(cx, cx.ccx().upcalls.free, [PointerCast(cx, v, T_ptr(T_i8()))]);\n     cx\n }\n \n fn trans_shared_free(cx: block, v: ValueRef) -> block {\n-    Call(cx, bcx_ccx(cx).upcalls.shared_free,\n+    Call(cx, cx.ccx().upcalls.shared_free,\n          [PointerCast(cx, v, T_ptr(T_i8()))]);\n     ret cx;\n }\n@@ -330,17 +330,16 @@ fn dynastack_alloca(cx: block, t: TypeRef, n: ValueRef, ty: ty::t) ->\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(t)); }\n     let bcx = cx;\n     let dy_cx = raw_block(cx.fcx, cx.fcx.lldynamicallocas);\n-    alt bcx_fcx(cx).llobstacktoken {\n+    alt cx.fcx.llobstacktoken {\n       none {\n-        bcx_fcx(cx).llobstacktoken =\n-            some(mk_obstack_token(bcx_ccx(cx), cx.fcx));\n+        cx.fcx.llobstacktoken = some(mk_obstack_token(cx.ccx(), cx.fcx));\n       }\n       some(_) {/* no-op */ }\n     }\n \n-    let dynastack_alloc = bcx_ccx(bcx).upcalls.dynastack_alloc;\n+    let dynastack_alloc = bcx.ccx().upcalls.dynastack_alloc;\n     let llsz = Mul(dy_cx,\n-                   C_uint(bcx_ccx(bcx), llsize_of_real(bcx_ccx(bcx), t)),\n+                   C_uint(bcx.ccx(), llsize_of_real(bcx.ccx(), t)),\n                    n);\n \n     let lltydesc = get_tydesc_simple(cx, ty, false).val;\n@@ -367,7 +366,7 @@ fn ptr_offs(bcx: block, base: ValueRef, sz: ValueRef) -> ValueRef {\n // to a given type.\n fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n    ValueRef {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     let bumped = ptr_offs(bcx, base, sz);\n     if check type_has_static_size(ccx, t) {\n         let typ = T_ptr(type_of(ccx, t));\n@@ -411,13 +410,13 @@ fn GEP_tup_like(bcx: block, t: ty::t, base: ValueRef, ixs: [int])\n         be compute_off(bcx, off, comp_t, ixs, n+1u);\n     }\n \n-    if !ty::type_has_dynamic_size(bcx_tcx(bcx), t) {\n+    if !ty::type_has_dynamic_size(bcx.tcx(), t) {\n         ret rslt(bcx, GEPi(bcx, base, ixs));\n     }\n \n     #debug[\"GEP_tup_like(t=%s,base=%s,ixs=%?)\",\n-           ty_to_str(bcx_tcx(bcx), t),\n-           val_str(bcx_ccx(bcx).tn, base),\n+           ty_to_str(bcx.tcx(), t),\n+           val_str(bcx.ccx().tn, base),\n            ixs];\n \n     // We require that ixs start with 0 and we expect the input to be a\n@@ -426,7 +425,7 @@ fn GEP_tup_like(bcx: block, t: ty::t, base: ValueRef, ixs: [int])\n     assert ixs[0] == 0;\n \n     let (bcx, off, tar_t) = {\n-        compute_off(bcx, C_int(bcx_ccx(bcx), 0), t, ixs, 1u)\n+        compute_off(bcx, C_int(bcx.ccx(), 0), t, ixs, 1u)\n     };\n     ret rslt(bcx, bump_ptr(bcx, tar_t, base, off));\n }\n@@ -440,7 +439,7 @@ fn GEP_enum(cx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n            variant_id: ast::def_id, ty_substs: [ty::t],\n            ix: uint) : valid_variant_index(ix, cx, enum_id, variant_id) ->\n    result {\n-    let variant = ty::enum_variant_with_id(bcx_tcx(cx), enum_id, variant_id);\n+    let variant = ty::enum_variant_with_id(cx.tcx(), enum_id, variant_id);\n     // Synthesize a tuple type so that GEP_tup_like() can work its magic.\n     // Separately, store the type of the element we're interested in.\n \n@@ -450,7 +449,7 @@ fn GEP_enum(cx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n     for aty: ty::t in arg_tys {\n             // Would be nice to have a way of stating the invariant\n             // that ty_substs is valid for aty\n-        let arg_ty = ty::substitute_type_params(bcx_tcx(cx), ty_substs, aty);\n+        let arg_ty = ty::substitute_type_params(cx.tcx(), ty_substs, aty);\n         true_arg_tys += [arg_ty];\n     }\n \n@@ -460,12 +459,12 @@ fn GEP_enum(cx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n     // error can't happen here, but that's in the future.)\n     let elem_ty = true_arg_tys[ix];\n \n-    let tup_ty = ty::mk_tup(bcx_tcx(cx), true_arg_tys);\n+    let tup_ty = ty::mk_tup(cx.tcx(), true_arg_tys);\n     // Cast the blob pointer to the appropriate type, if we need to (i.e. if\n     // the blob pointer isn't dynamically sized).\n \n     let llunionptr: ValueRef;\n-    let ccx = bcx_ccx(cx);\n+    let ccx = cx.ccx();\n     if check type_has_static_size(ccx, tup_ty) {\n         let llty = type_of(ccx, tup_ty);\n         llunionptr = TruncOrBitCast(cx, llblobptr, T_ptr(llty));\n@@ -475,12 +474,10 @@ fn GEP_enum(cx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n     let rs = GEP_tup_like(cx, tup_ty, llunionptr, [0, ix as int]);\n     // Cast the result to the appropriate type, if necessary.\n \n-    let rs_ccx = bcx_ccx(rs.bcx);\n-    let val =\n-        if check type_has_static_size(rs_ccx, elem_ty) {\n-            let llelemty = type_of(rs_ccx, elem_ty);\n-            PointerCast(rs.bcx, rs.val, T_ptr(llelemty))\n-        } else { rs.val };\n+    let val = if check type_has_static_size(ccx, elem_ty) {\n+        let llelemty = type_of(ccx, elem_ty);\n+        PointerCast(rs.bcx, rs.val, T_ptr(llelemty))\n+    } else { rs.val };\n \n     ret rslt(rs.bcx, val);\n }\n@@ -491,9 +488,9 @@ fn trans_shared_malloc(cx: block, llptr_ty: TypeRef, llsize: ValueRef)\n    -> result {\n     // FIXME: need a table to collect tydesc globals.\n \n-    let tydesc = C_null(T_ptr(bcx_ccx(cx).tydesc_type));\n+    let tydesc = C_null(T_ptr(cx.ccx().tydesc_type));\n     let rval =\n-        Call(cx, bcx_ccx(cx).upcalls.shared_malloc,\n+        Call(cx, cx.ccx().upcalls.shared_malloc,\n              [llsize, tydesc]);\n     ret rslt(cx, PointerCast(cx, rval, llptr_ty));\n }\n@@ -506,7 +503,7 @@ fn trans_shared_malloc(cx: block, llptr_ty: TypeRef, llsize: ValueRef)\n fn opaque_box_body(bcx: block,\n                       body_t: ty::t,\n                       boxptr: ValueRef) -> ValueRef {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     let boxptr = PointerCast(bcx, boxptr, T_ptr(T_box_header(ccx)));\n     let bodyptr = GEPi(bcx, boxptr, [1]);\n     if check type_has_static_size(ccx, body_t) {\n@@ -521,11 +518,11 @@ fn opaque_box_body(bcx: block,\n // header.\n fn trans_malloc_boxed_raw(bcx: block, t: ty::t,\n                           &static_ti: option<@tydesc_info>) -> result {\n-    let bcx = bcx, ccx = bcx_ccx(bcx);\n+    let bcx = bcx, ccx = bcx.ccx();\n \n     // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n     // wants.\n-    let box_ptr = ty::mk_imm_box(bcx_tcx(bcx), t);\n+    let box_ptr = ty::mk_imm_box(bcx.tcx(), t);\n     check (type_has_static_size(ccx, box_ptr));\n     let llty = type_of(ccx, box_ptr);\n \n@@ -567,7 +564,7 @@ fn field_of_tydesc(cx: block, t: ty::t, escapes: bool, field: int) ->\n fn linearize_ty_params(cx: block, t: ty::t) ->\n    {params: [uint], descs: [ValueRef]} {\n     let param_vals = [], param_defs = [];\n-    ty::walk_ty(bcx_tcx(cx), t) {|t|\n+    ty::walk_ty(cx.tcx(), t) {|t|\n         alt ty::get(t).struct {\n           ty::ty_param(pid, _) {\n             if !vec::any(param_defs, {|d| d == pid}) {\n@@ -585,14 +582,14 @@ fn trans_stack_local_derived_tydesc(cx: block, llsz: ValueRef,\n                                     llalign: ValueRef, llroottydesc: ValueRef,\n                                     llfirstparam: ValueRef, n_params: uint)\n     -> ValueRef {\n-    let llmyroottydesc = alloca(cx, bcx_ccx(cx).tydesc_type);\n+    let llmyroottydesc = alloca(cx, cx.ccx().tydesc_type);\n \n     // By convention, desc 0 is the root descriptor.\n     let llroottydesc = Load(cx, llroottydesc);\n     Store(cx, llroottydesc, llmyroottydesc);\n \n     // Store a pointer to the rest of the descriptors.\n-    let ccx = bcx_ccx(cx);\n+    let ccx = cx.ccx();\n     store_inbounds(cx, llfirstparam, llmyroottydesc,\n                    [0, abi::tydesc_field_first_param]);\n     store_inbounds(cx, C_uint(ccx, n_params), llmyroottydesc,\n@@ -620,12 +617,12 @@ fn get_derived_tydesc(cx: block, t: ty::t, escapes: bool,\n       none {/* fall through */ }\n     }\n \n-    bcx_ccx(cx).stats.n_derived_tydescs += 1u;\n+    cx.ccx().stats.n_derived_tydescs += 1u;\n     let bcx = raw_block(cx.fcx, cx.fcx.llderivedtydescs);\n     let tys = linearize_ty_params(bcx, t);\n-    let root_ti = get_static_tydesc(bcx_ccx(bcx), t, tys.params);\n+    let root_ti = get_static_tydesc(bcx.ccx(), t, tys.params);\n     static_ti = some(root_ti);\n-    lazily_emit_all_tydesc_glue(bcx_ccx(cx), static_ti);\n+    lazily_emit_all_tydesc_glue(cx.ccx(), static_ti);\n     let root = root_ti.tydesc;\n     let sz = size_of(bcx, t);\n     bcx = sz.bcx;\n@@ -634,13 +631,13 @@ fn get_derived_tydesc(cx: block, t: ty::t, escapes: bool,\n \n     // Store the captured type descriptors in an alloca if the caller isn't\n     // promising to do so itself.\n-    let n_params = ty::count_ty_params(bcx_tcx(bcx), t);\n+    let n_params = ty::count_ty_params(bcx.tcx(), t);\n \n     assert n_params == tys.params.len();\n     assert n_params == tys.descs.len();\n \n     let llparamtydescs =\n-        alloca(bcx, T_array(T_ptr(bcx_ccx(bcx).tydesc_type), n_params + 1u));\n+        alloca(bcx, T_array(T_ptr(bcx.ccx().tydesc_type), n_params + 1u));\n     let i = 0;\n \n     // If the type descriptor escapes, we need to add in the root as\n@@ -657,11 +654,11 @@ fn get_derived_tydesc(cx: block, t: ty::t, escapes: bool,\n \n     let llfirstparam =\n         PointerCast(bcx, llparamtydescs,\n-                    T_ptr(T_ptr(bcx_ccx(bcx).tydesc_type)));\n+                    T_ptr(T_ptr(bcx.ccx().tydesc_type)));\n \n     let v;\n     if escapes {\n-        let ccx = bcx_ccx(bcx);\n+        let ccx = bcx.ccx();\n         let td_val =\n             Call(bcx, ccx.upcalls.get_type_desc,\n                  [C_null(T_ptr(T_nil())), sz.val,\n@@ -695,7 +692,7 @@ fn get_tydesc(cx: block, t: ty::t, escapes: bool,\n         ret get_derived_tydesc(cx, t, escapes, static_ti);\n     }\n     // Otherwise, generate a tydesc if necessary, and return it.\n-    let info = get_static_tydesc(bcx_ccx(cx), t, []);\n+    let info = get_static_tydesc(cx.ccx(), t, []);\n     static_ti = some(info);\n     ret rslt(cx, info.tydesc);\n }\n@@ -731,7 +728,7 @@ fn set_always_inline(f: ValueRef) {\n }\n \n fn set_custom_stack_growth_fn(f: ValueRef) {\n-    // TODO: Remove this hack to work around the lack of u64 in the FFI.\n+    // FIXME: Remove this hack to work around the lack of u64 in the FFI.\n     llvm::LLVMAddFunctionAttr(f, 0u as c_uint, 1u as c_uint);\n }\n \n@@ -920,7 +917,7 @@ fn make_take_glue(cx: block, v: ValueRef, t: ty::t) {\n         // sendable type descriptors are basically unique pointers,\n         // they must be cloned when copied:\n         let r = Load(bcx, v);\n-        let s = Call(bcx, bcx_ccx(bcx).upcalls.create_shared_type_desc, [r]);\n+        let s = Call(bcx, bcx.ccx().upcalls.create_shared_type_desc, [r]);\n         Store(bcx, s, v);\n         bcx\n       }\n@@ -944,7 +941,7 @@ fn make_take_glue(cx: block, v: ValueRef, t: ty::t) {\n }\n \n fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) -> block {\n-    let ccx = bcx_ccx(cx);\n+    let ccx = cx.ccx();\n     maybe_validate_box(cx, box_ptr);\n     let rc_ptr = GEPi(cx, box_ptr, [0, abi::box_field_refcnt]);\n     let rc = Load(cx, rc_ptr);\n@@ -957,7 +954,7 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n     // v is a pointer to the actual box component of the type here. The\n     // ValueRef will have the wrong type here (make_generic_glue is casting\n     // everything to a pointer to the type that the glue acts on).\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     let bcx = alt ty::get(t).struct {\n       ty::ty_box(body_mt) {\n         let v = PointerCast(bcx, v, type_of(ccx, t));\n@@ -983,7 +980,7 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n       ty::ty_send_type {\n         // sendable type descriptors are basically unique pointers,\n         // they must be freed.\n-        let ccx = bcx_ccx(bcx);\n+        let ccx = bcx.ccx();\n         let v = PointerCast(bcx, v, T_ptr(ccx.tydesc_type));\n         Call(bcx, ccx.upcalls.free_shared_type_desc, [v]);\n         bcx\n@@ -1001,7 +998,7 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n \n fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     let bcx = alt ty::get(t).struct {\n       ty::ty_box(_) | ty::ty_opaque_box {\n         decr_refcnt_maybe_free(bcx, Load(bcx, v0), t)\n@@ -1034,7 +1031,7 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n \n fn trans_res_drop(bcx: block, rs: ValueRef, did: ast::def_id,\n                   inner_t: ty::t, tps: [ty::t]) -> block {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     let inner_t_s = ty::substitute_type_params(ccx.tcx, tps, inner_t);\n     let tup_ty = ty::mk_tup(ccx.tcx, [ty::mk_int(ccx.tcx), inner_t_s]);\n \n@@ -1070,14 +1067,14 @@ fn maybe_validate_box(_cx: block, _box_ptr: ValueRef) {\n     // bugs.  But do not commit with this uncommented!  Big performance hit.\n \n     // let cx = _cx, box_ptr = _box_ptr;\n-    // let ccx = bcx_ccx(cx);\n+    // let ccx = cx.ccx();\n     // warn_not_to_commit(ccx, \"validate_box() is uncommented\");\n     // let raw_box_ptr = PointerCast(cx, box_ptr, T_ptr(T_i8()));\n     // Call(cx, ccx.upcalls.validate_box, [raw_box_ptr]);\n }\n \n fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t) -> block {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     maybe_validate_box(bcx, box_ptr);\n \n     let llbox_ty = T_opaque_box_ptr(ccx);\n@@ -1120,7 +1117,7 @@ fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n       }\n       _ {\n         // Should never get here, because t is scalar.\n-        bcx_ccx(cx).sess.bug(\"non-scalar type passed to \\\n+        cx.sess().bug(\"non-scalar type passed to \\\n                                  compare_scalar_types\");\n       }\n     }\n@@ -1131,7 +1128,7 @@ fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n                          nt: scalar_type, op: ast::binop) -> ValueRef {\n     fn die_(cx: block) -> ! {\n-        bcx_tcx(cx).sess.bug(\"compare_scalar_values: must be a\\\n+        cx.tcx().sess.bug(\"compare_scalar_values: must be a\\\n           comparison operator\");\n     }\n     let die = bind die_(cx);\n@@ -1205,7 +1202,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                     f: val_and_ty_fn) -> block {\n         if variant.args.len() == 0u { ret cx; }\n         let fn_ty = variant.ctor_ty;\n-        let ccx = bcx_ccx(cx);\n+        let ccx = cx.ccx();\n         let cx = cx;\n         alt ty::get(fn_ty).struct {\n           ty::ty_fn({inputs: args, _}) {\n@@ -1222,7 +1219,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n             }\n           }\n           // Precondition?\n-          _ { bcx_tcx(cx).sess.bug(\"iter_variant: not a function type\"); }\n+          _ { cx.tcx().sess.bug(\"iter_variant: not a function type\"); }\n         }\n         ret cx;\n     }\n@@ -1249,23 +1246,23 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         }\n       }\n       ty::ty_res(_, inner, tps) {\n-        let tcx = bcx_tcx(cx);\n+        let tcx = cx.tcx();\n         let inner1 = ty::substitute_type_params(tcx, tps, inner);\n         let inner_t_s = ty::substitute_type_params(tcx, tps, inner);\n         let tup_t = ty::mk_tup(tcx, [ty::mk_int(tcx), inner_t_s]);\n         let {bcx: bcx, val: llfld_a} = GEP_tup_like(cx, tup_t, av, [0, 1]);\n         ret f(bcx, llfld_a, inner1);\n       }\n       ty::ty_enum(tid, tps) {\n-        let variants = ty::enum_variants(bcx_tcx(cx), tid);\n+        let variants = ty::enum_variants(cx.tcx(), tid);\n         let n_variants = (*variants).len();\n \n         // Cast the enums to types we can GEP into.\n         if n_variants == 1u {\n             ret iter_variant(cx, av, variants[0], tps, tid, f);\n         }\n \n-        let ccx = bcx_ccx(cx);\n+        let ccx = cx.ccx();\n         let llenumty = T_opaque_enum_ptr(ccx);\n         let av_enum = PointerCast(cx, av, llenumty);\n         let lldiscrim_a_ptr = GEPi(cx, av_enum, [0, 0]);\n@@ -1274,7 +1271,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n \n         // NB: we must hit the discriminant first so that structural\n         // comparison know not to proceed when the discriminants differ.\n-        cx = f(cx, lldiscrim_a_ptr, ty::mk_int(bcx_tcx(cx)));\n+        cx = f(cx, lldiscrim_a_ptr, ty::mk_int(cx.tcx()));\n         let unr_cx = sub_block(cx, \"enum-iter-unr\");\n         Unreachable(unr_cx);\n         let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb, n_variants);\n@@ -1291,7 +1288,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         }\n         ret next_cx;\n       }\n-      _ { bcx_ccx(cx).sess.unimpl(\"type in iter_structural_ty\"); }\n+      _ { cx.sess().unimpl(\"type in iter_structural_ty\"); }\n     }\n     ret cx;\n }\n@@ -1370,7 +1367,7 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: int,\n \n fn call_tydesc_glue_full(cx: block, v: ValueRef, tydesc: ValueRef,\n                          field: int, static_ti: option<@tydesc_info>) {\n-    lazily_emit_tydesc_glue(bcx_ccx(cx), field, static_ti);\n+    lazily_emit_tydesc_glue(cx.ccx(), field, static_ti);\n \n     let static_glue_fn = none;\n     alt static_ti {\n@@ -1435,7 +1432,7 @@ fn call_cmp_glue(cx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n         GEPi(bcx, lltydesc, [0, abi::tydesc_field_first_param]);\n     lltydescs = Load(bcx, lltydescs);\n \n-    let llfn = bcx_ccx(bcx).upcalls.cmp_type;\n+    let llfn = bcx.ccx().upcalls.cmp_type;\n \n     let llcmpresultptr = alloca(bcx, T_i1());\n     Call(bcx, llfn, [llcmpresultptr, lltydesc, lltydescs,\n@@ -1444,14 +1441,14 @@ fn call_cmp_glue(cx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n }\n \n fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n-    if ty::type_needs_drop(bcx_tcx(cx), t) {\n+    if ty::type_needs_drop(cx.tcx(), t) {\n         ret call_tydesc_glue(cx, v, t, abi::tydesc_field_take_glue);\n     }\n     ret cx;\n }\n \n fn drop_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n-    if ty::type_needs_drop(bcx_tcx(cx), t) {\n+    if ty::type_needs_drop(cx.tcx(), t) {\n         ret call_tydesc_glue(cx, v, t, abi::tydesc_field_drop_glue);\n     }\n     ret cx;\n@@ -1464,7 +1461,7 @@ fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n         decr_refcnt_maybe_free(bcx, v, t)\n       }\n       // Precondition?\n-      _ { bcx_tcx(bcx).sess.bug(\"drop_ty_immediate: non-box ty\"); }\n+      _ { bcx.tcx().sess.bug(\"drop_ty_immediate: non-box ty\"); }\n     }\n }\n \n@@ -1482,19 +1479,19 @@ fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> result {\n }\n \n fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n-    if ty::type_needs_drop(bcx_tcx(cx), t) {\n+    if ty::type_needs_drop(cx.tcx(), t) {\n         ret call_tydesc_glue(cx, v, t, abi::tydesc_field_free_glue);\n     }\n     ret cx;\n }\n \n fn call_memmove(cx: block, dst: ValueRef, src: ValueRef,\n                 n_bytes: ValueRef) -> result {\n-    // TODO: Provide LLVM with better alignment information when the alignment\n+    // FIXME: Provide LLVM with better alignment information when the alignment\n     // is statically known (it must be nothing more than a constant int, or\n     // LLVM complains -- not even a constant element of a tydesc works).\n \n-    let ccx = bcx_ccx(cx);\n+    let ccx = cx.ccx();\n     let key = alt ccx.sess.targ_cfg.arch {\n       session::arch_x86 | session::arch_arm { \"llvm.memmove.p0i8.p0i8.i32\" }\n       session::arch_x86_64 { \"llvm.memmove.p0i8.p0i8.i64\" }\n@@ -1515,7 +1512,7 @@ fn call_memmove(cx: block, dst: ValueRef, src: ValueRef,\n \n fn memmove_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) ->\n     block {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     if check type_has_static_size(ccx, t) {\n         if ty::type_is_structural(t) {\n             let llsz = llsize_of(ccx, type_of(ccx, t));\n@@ -1558,7 +1555,7 @@ fn copy_val(cx: block, action: copy_action, dst: ValueRef,\n \n fn copy_val_no_check(bcx: block, action: copy_action, dst: ValueRef,\n                      src: ValueRef, t: ty::t) -> block {\n-    let ccx = bcx_ccx(bcx), bcx = bcx;\n+    let ccx = bcx.ccx(), bcx = bcx;\n     if ty::type_is_scalar(t) {\n         Store(bcx, src, dst);\n         ret bcx;\n@@ -1588,7 +1585,7 @@ fn copy_val_no_check(bcx: block, action: copy_action, dst: ValueRef,\n fn move_val(cx: block, action: copy_action, dst: ValueRef,\n             src: lval_result, t: ty::t) -> block {\n     let src_val = src.val;\n-    let tcx = bcx_tcx(cx), cx = cx;\n+    let tcx = cx.tcx(), cx = cx;\n     if ty::type_is_scalar(t) {\n         if src.kind == owned { src_val = Load(cx, src_val); }\n         Store(cx, src_val, dst);\n@@ -1612,7 +1609,7 @@ fn move_val(cx: block, action: copy_action, dst: ValueRef,\n         ret cx;\n     }\n     /* FIXME: suggests a type constraint */\n-    bcx_ccx(cx).sess.bug(\"unexpected type in trans::move_val: \" +\n+    cx.sess().bug(\"unexpected type in trans::move_val: \" +\n                              ty_to_str(tcx, t));\n }\n \n@@ -1649,15 +1646,15 @@ fn trans_lit(cx: block, lit: ast::lit, dest: dest) -> block {\n     alt lit.node {\n       ast::lit_str(s) { ret tvec::trans_str(cx, s, dest); }\n       _ {\n-        ret store_in_dest(cx, trans_crate_lit(bcx_ccx(cx), lit), dest);\n+        ret store_in_dest(cx, trans_crate_lit(cx.ccx(), lit), dest);\n       }\n     }\n }\n \n fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n                un_expr: @ast::expr, dest: dest) -> block {\n     // Check for user-defined method call\n-    alt bcx_ccx(bcx).method_map.find(un_expr.id) {\n+    alt bcx.ccx().method_map.find(un_expr.id) {\n       some(origin) {\n         let callee_id = ast_util::op_expr_callee_id(un_expr);\n         let fty = node_id_type(bcx, callee_id);\n@@ -1688,7 +1685,7 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n         // Cast the body type to the type of the value. This is needed to\n         // make enums work, since enums have a different LLVM type depending\n         // on whether they're boxed or not\n-        let ccx = bcx_ccx(bcx);\n+        let ccx = bcx.ccx();\n         if check type_has_static_size(ccx, e_ty) {\n             let llety = T_ptr(type_of(ccx, e_ty));\n             body = PointerCast(bcx, body, llety);\n@@ -1701,7 +1698,7 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n         ret uniq::trans_uniq(bcx, e, un_expr.id, dest);\n       }\n       ast::deref {\n-        bcx_ccx(bcx).sess.bug(\"deref expressions should have been \\\n+        bcx.sess().bug(\"deref expressions should have been \\\n                                translated using trans_lval(), not \\\n                                trans_unary()\");\n       }\n@@ -1722,7 +1719,7 @@ fn trans_compare(cx: block, op: ast::binop, lhs: ValueRef,\n       ast::lt | ast::ge { llop = C_u8(abi::cmp_glue_op_lt); }\n       ast::le | ast::gt { llop = C_u8(abi::cmp_glue_op_le); }\n       // Precondition?\n-      _ { bcx_tcx(cx).sess.bug(\"trans_compare got\\\n+      _ { cx.tcx().sess.bug(\"trans_compare got\\\n               non-comparison-op\"); }\n     }\n \n@@ -1734,7 +1731,7 @@ fn trans_compare(cx: block, op: ast::binop, lhs: ValueRef,\n       ast::ne | ast::ge | ast::gt {\n         ret rslt(rs.bcx, Not(rs.bcx, rs.val));\n       }\n-      _ { bcx_tcx(cx).sess.bug(\"trans_compare got\\\n+      _ { cx.tcx().sess.bug(\"trans_compare got\\\n               non-comparison-op\"); }\n     }\n }\n@@ -1799,7 +1796,7 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n     assert (lhs_res.kind == owned);\n \n     // A user-defined operator method\n-    alt bcx_ccx(bcx).method_map.find(ex.id) {\n+    alt bcx.ccx().method_map.find(ex.id) {\n       some(origin) {\n         let callee_id = ast_util::op_expr_callee_id(ex);\n         let fty = node_id_type(bcx, callee_id);\n@@ -1840,7 +1837,7 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n fn autoderef(cx: block, v: ValueRef, t: ty::t) -> result_t {\n     let v1: ValueRef = v;\n     let t1: ty::t = t;\n-    let ccx = bcx_ccx(cx);\n+    let ccx = cx.ccx();\n     while true {\n         alt ty::get(t1).struct {\n           ty::ty_box(mt) {\n@@ -1912,7 +1909,7 @@ fn trans_lazy_binop(bcx: block, op: lazy_binop_ty, a: @ast::expr,\n fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n                 rhs: @ast::expr, dest: dest, ex: @ast::expr) -> block {\n     // User-defined operators\n-    alt bcx_ccx(bcx).method_map.find(ex.id) {\n+    alt bcx.ccx().method_map.find(ex.id) {\n       some(origin) {\n         let callee_id = ast_util::op_expr_callee_id(ex);\n         let fty = node_id_type(bcx, callee_id);\n@@ -2037,7 +2034,7 @@ fn trans_if(cx: block, cond: @ast::expr, thn: ast::blk,\n             trans_block(else_cx, blk, else_dest)\n           }\n           // would be nice to have a constraint on ifs\n-          _ { bcx_tcx(cx).sess.bug(\"Strange alternative in if\"); }\n+          _ { cx.tcx().sess.bug(\"Strange alternative in if\"); }\n         }\n       }\n       _ { else_cx }\n@@ -2056,14 +2053,14 @@ fn trans_for(cx: block, local: @ast::local, seq: @ast::expr,\n                                         body.span);\n         Br(bcx, scope_cx.llbb);\n         let curr = PointerCast(bcx, curr,\n-                               T_ptr(type_of_or_i8(bcx_ccx(bcx), t)));\n+                               T_ptr(type_of_or_i8(bcx.ccx(), t)));\n         let bcx = alt::bind_irrefutable_pat(scope_cx, local.node.pat,\n                                                   curr, false);\n         bcx = trans_block(bcx, body, ignore);\n         cleanup_and_Br(bcx, scope_cx, next_cx.llbb);\n         ret next_cx;\n     }\n-    let ccx = bcx_ccx(cx);\n+    let ccx = cx.ccx();\n     let next_cx = sub_block(cx, \"next\");\n     let seq_ty = expr_ty(cx, seq);\n     let {bcx: bcx, val: seq} = trans_temp_expr(cx, seq);\n@@ -2141,7 +2138,7 @@ type lval_maybe_callee = {bcx: block,\n                           generic: generic_callee};\n \n fn null_env_ptr(bcx: block) -> ValueRef {\n-    C_null(T_opaque_box_ptr(bcx_ccx(bcx)))\n+    C_null(T_opaque_box_ptr(bcx.ccx()))\n }\n \n fn lval_from_local_var(bcx: block, r: local_var_result) -> lval_result {\n@@ -2235,7 +2232,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n                   substs: option<([ty::t], typeck::dict_res)>)\n     -> lval_maybe_callee {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     let tys = node_id_type_params(bcx, id);\n     let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n     // The awkwardness below mostly stems from the fact that we're mixing\n@@ -2283,7 +2280,7 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n \n     // FIXME: Need to support external crust functions\n     if fn_id.crate == ast::local_crate {\n-        alt bcx_tcx(bcx).def_map.find(id) {\n+        alt bcx.tcx().def_map.find(id) {\n           some(ast::def_fn(_, ast::crust_fn)) {\n             // Crust functions are just opaque pointers\n             let val = PointerCast(bcx, val, T_ptr(T_i8()));\n@@ -2297,7 +2294,6 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n     if tys.len() > 0u {\n         let tydescs = [], tis = [];\n         for t in tys {\n-            // TODO: Doesn't always escape.\n             let ti = none;\n             let td = get_tydesc(bcx, t, true, ti);\n             tis += [ti];\n@@ -2356,23 +2352,23 @@ fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n       ast::def_self(did) {\n         let slf = option::get(cx.fcx.llself);\n         let ptr = PointerCast(cx, slf.v,\n-                              T_ptr(type_of_or_i8(bcx_ccx(cx), slf.t)));\n+                              T_ptr(type_of_or_i8(cx.ccx(), slf.t)));\n         ret {val: ptr, kind: owned};\n       }\n       _ {\n-        bcx_ccx(cx).sess.unimpl(\"unsupported def type in trans_local_def\");\n+        cx.sess().unimpl(\"unsupported def type in trans_local_def\");\n       }\n     }\n }\n \n fn trans_path(cx: block, id: ast::node_id)\n     -> lval_maybe_callee {\n-    ret trans_var(cx, bcx_tcx(cx).def_map.get(id), id);\n+    ret trans_var(cx, cx.tcx().def_map.get(id), id);\n }\n \n fn trans_var(cx: block, def: ast::def, id: ast::node_id)\n     -> lval_maybe_callee {\n-    let ccx = bcx_ccx(cx);\n+    let ccx = cx.ccx();\n     alt def {\n       ast::def_fn(did, _) {\n         ret lval_static_fn(cx, did, id, none);\n@@ -2420,7 +2416,7 @@ fn trans_rec_field(bcx: block, base: @ast::expr,\n     let fields = alt ty::get(ty).struct {\n             ty::ty_rec(fs) { fs }\n             // Constraint?\n-            _ { bcx_tcx(bcx).sess.span_bug(base.span, \"trans_rec_field:\\\n+            _ { bcx.tcx().sess.span_bug(base.span, \"trans_rec_field:\\\n                  base expr has non-record type\"); }\n         };\n     let ix = option::get(ty::field_idx(field, fields));\n@@ -2436,12 +2432,12 @@ fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n     let ix = trans_temp_expr(lv.bcx, idx);\n     let v = lv.val;\n     let bcx = ix.bcx;\n-    let ccx = bcx_ccx(cx);\n+    let ccx = cx.ccx();\n \n     // Cast to an LLVM integer. Rust is less strict than LLVM in this regard.\n     let ix_val;\n-    let ix_size = llsize_of_real(bcx_ccx(cx), val_ty(ix.val));\n-    let int_size = llsize_of_real(bcx_ccx(cx), ccx.int_type);\n+    let ix_size = llsize_of_real(cx.ccx(), val_ty(ix.val));\n+    let int_size = llsize_of_real(cx.ccx(), ccx.int_type);\n     if ix_size < int_size {\n         ix_val = ZExt(bcx, ix.val, ccx.int_type);\n     } else if ix_size > int_size {\n@@ -2451,9 +2447,9 @@ fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n     let unit_ty = node_id_type(cx, ex.id);\n     let unit_sz = size_of(bcx, unit_ty);\n     bcx = unit_sz.bcx;\n-    maybe_name_value(bcx_ccx(cx), unit_sz.val, \"unit_sz\");\n+    maybe_name_value(cx.ccx(), unit_sz.val, \"unit_sz\");\n     let scaled_ix = Mul(bcx, ix_val, unit_sz.val);\n-    maybe_name_value(bcx_ccx(cx), scaled_ix, \"scaled_ix\");\n+    maybe_name_value(cx.ccx(), scaled_ix, \"scaled_ix\");\n     let lim = tvec::get_fill(bcx, v);\n     let body = tvec::get_dataptr(bcx, v, type_of_or_i8(ccx, unit_ty));\n     let bounds_check = ICmp(bcx, lib::llvm::IntUGE, scaled_ix, lim);\n@@ -2473,7 +2469,7 @@ fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n }\n \n fn expr_is_lval(bcx: block, e: @ast::expr) -> bool {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     ty::expr_is_lval(ccx.method_map, e)\n }\n \n@@ -2483,12 +2479,12 @@ fn trans_callee(bcx: block, e: @ast::expr) -> lval_maybe_callee {\n       ast::expr_field(base, ident, _) {\n         // Lval means this is a record field, so not a method\n         if !expr_is_lval(bcx, e) {\n-            alt bcx_ccx(bcx).method_map.find(e.id) {\n+            alt bcx.ccx().method_map.find(e.id) {\n               some(origin) { // An impl method\n                 ret impl::trans_method_callee(bcx, e.id, base, origin);\n               }\n               // Precondition?\n-              _ { bcx_tcx(bcx).sess.span_bug(e.span, \"trans_callee: weird\\\n+              _ { bcx.tcx().sess.span_bug(e.span, \"trans_callee: weird\\\n                     expr\"); }\n             }\n         }\n@@ -2516,7 +2512,7 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n         ret trans_index(cx, e, base, idx);\n       }\n       ast::expr_unary(ast::deref, base) {\n-        let ccx = bcx_ccx(cx);\n+        let ccx = cx.ccx();\n         let sub = trans_temp_expr(cx, base);\n         let t = expr_ty(cx, base);\n         let val = alt ty::get(t).struct {\n@@ -2537,13 +2533,13 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n           ty::ty_ptr(_) | ty::ty_uniq(_) { sub.val }\n           // Precondition?\n           _ {\n-            bcx_tcx(cx).sess.span_bug(e.span, \"trans_lval:\\\n+            cx.tcx().sess.span_bug(e.span, \"trans_lval:\\\n                                                Weird argument in deref\");\n           }\n         };\n         ret lval_owned(sub.bcx, val);\n       }\n-      _ { bcx_ccx(cx).sess.span_bug(e.span, \"non-lval in trans_lval\"); }\n+      _ { cx.sess().span_bug(e.span, \"non-lval in trans_lval\"); }\n     }\n }\n \n@@ -2597,7 +2593,7 @@ fn float_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n \n fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n               dest: dest) -> block {\n-    let ccx = bcx_ccx(cx);\n+    let ccx = cx.ccx();\n     let t_out = node_id_type(cx, id);\n     alt ty::get(t_out).struct {\n       ty::ty_iface(_, _) { ret impl::trans_cast(cx, e, id, dest); }\n@@ -2670,7 +2666,7 @@ fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n \n fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef,\n                   e: @ast::expr) -> result {\n-    let ccx = bcx_ccx(cx);\n+    let ccx = cx.ccx();\n     let e_ty = expr_ty(cx, e);\n     let is_bot = ty::type_is_bot(e_ty);\n     let lv = trans_temp_lval(cx, e);\n@@ -2747,7 +2743,7 @@ fn trans_args(cx: block, llenv: ValueRef,\n     let llargs: [ValueRef] = [];\n     let lltydescs: [ValueRef] = [];\n \n-    let ccx = bcx_ccx(cx);\n+    let ccx = cx.ccx();\n     let bcx = cx;\n \n     let retty = ty::ty_fn_ret(fn_ty), full_retty = retty;\n@@ -2846,7 +2842,7 @@ fn trans_call_inner(in_cx: block, fn_expr_ty: ty::t,\n     -> block {\n     with_scope(in_cx, \"call\") {|cx|\n         let f_res = get_callee(cx);\n-        let bcx = f_res.bcx, ccx = bcx_ccx(cx);\n+        let bcx = f_res.bcx, ccx = cx.ccx();\n \n         let faddr = f_res.val;\n         let llenv, dict_param = none;\n@@ -2958,7 +2954,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     // The exception handling personality function. This is the C++\n     // personality function __gxx_personality_v0, wrapped in our naming\n     // convention.\n-    let personality = bcx_ccx(bcx).upcalls.rust_personality;\n+    let personality = bcx.ccx().upcalls.rust_personality;\n     // The only landing pad clause will be 'cleanup'\n     let llretval = LandingPad(pad_bcx, llretty, personality, 1u);\n     // The landing pad block is a cleanup\n@@ -2967,7 +2963,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     // Because we may have unwound across a stack boundary, we must call into\n     // the runtime to figure out which stack segment we are on and place the\n     // stack limit back into the TLS.\n-    Call(pad_bcx, bcx_ccx(bcx).upcalls.reset_stack_limit, []);\n+    Call(pad_bcx, bcx.ccx().upcalls.reset_stack_limit, []);\n \n     // We store the retval in a function-central alloca, so that calls to\n     // Resume can find it.\n@@ -2995,7 +2991,7 @@ fn trans_tup(bcx: block, elts: [@ast::expr], id: ast::node_id,\n         ret bcx;\n       }\n       save_in(pos) { pos }\n-      _ { bcx_tcx(bcx).sess.bug(\"trans_tup: weird dest\"); }\n+      _ { bcx.tcx().sess.bug(\"trans_tup: weird dest\"); }\n     };\n     let temp_cleanups = [], i = 0;\n     for e in elts {\n@@ -3023,12 +3019,12 @@ fn trans_rec(bcx: block, fields: [ast::field],\n         ret bcx;\n       }\n       save_in(pos) { pos }\n-      _ { bcx_tcx(bcx).sess.bug(\"trans_rec: weird dest\"); }\n+      _ { bcx.tcx().sess.bug(\"trans_rec: weird dest\"); }\n     };\n \n     let ty_fields = alt ty::get(t).struct {\n       ty::ty_rec(f) { f }\n-      _ { bcx_tcx(bcx).sess.bug(\"trans_rec: id doesn't\\\n+      _ { bcx.tcx().sess.bug(\"trans_rec: id doesn't\\\n            have a record type\") } };\n     let temp_cleanups = [];\n     for fld in fields {\n@@ -3116,7 +3112,7 @@ fn trans_temp_expr(bcx: block, e: @ast::expr) -> result {\n // - exprs returning nil or bot always get dest=ignore\n // - exprs with non-immediate type never get dest=by_val\n fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n-    let tcx = bcx_tcx(bcx);\n+    let tcx = bcx.tcx();\n     debuginfo::update_source_pos(bcx, e.span);\n \n     #debug[\"trans_expr(%s,%?)\", expr_to_str(e), dest];\n@@ -3192,7 +3188,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n       }\n       ast::expr_index(base, idx) {\n         // If it is here, it's not an lval, so this is a user-defined index op\n-        let origin = bcx_ccx(bcx).method_map.get(e.id);\n+        let origin = bcx.ccx().method_map.get(e.id);\n         let callee_id = ast_util::op_expr_callee_id(e);\n         let fty = node_id_type(bcx, callee_id);\n         ret trans_call_inner(bcx, fty, {|bcx|\n@@ -3244,7 +3240,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n            check the value of that variable, doing nothing\n            if it's set to false and acting like a check\n            otherwise. */\n-        let c = get_extern_const(bcx_ccx(bcx).externs, bcx_ccx(bcx).llmod,\n+        let c = get_extern_const(bcx.ccx().externs, bcx.ccx().llmod,\n                                  \"check_claims\", T_bool());\n         ret with_cond(bcx, Load(bcx, c)) {|bcx|\n             trans_check_expr(bcx, a, \"Claim\")\n@@ -3269,7 +3265,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n         assert kind == owned;\n         ret store_temp_expr(bcx, DROP_EXISTING, addr, src_r,\n                             expr_ty(bcx, src),\n-                            bcx_ccx(bcx).last_uses.contains_key(src.id));\n+                            bcx.ccx().last_uses.contains_key(src.id));\n       }\n       ast::expr_move(dst, src) {\n         // FIXME: calculate copy init-ness in typestate.\n@@ -3296,14 +3292,14 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n         assert dest == ignore;\n         ret trans_assign_op(bcx, e, op, dst, src);\n       }\n-      _ { bcx_tcx(bcx).sess.span_bug(e.span, \"trans_expr reached\\\n+      _ { bcx.tcx().sess.span_bug(e.span, \"trans_expr reached\\\n              fall-through case\"); }\n \n     }\n }\n \n fn lval_to_dps(bcx: block, e: @ast::expr, dest: dest) -> block {\n-    let lv = trans_lval(bcx, e), ccx = bcx_ccx(bcx);\n+    let lv = trans_lval(bcx, e), ccx = bcx.ccx();\n     let {bcx, val, kind} = lv;\n     let last_use = kind == owned && ccx.last_uses.contains_key(e.id);\n     let ty = expr_ty(bcx, e);\n@@ -3368,7 +3364,7 @@ fn load_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n }\n \n fn trans_log(lvl: @ast::expr, bcx: block, e: @ast::expr) -> block {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     if ty::type_is_bot(expr_ty(bcx, lvl)) {\n        ret trans_expr(bcx, lvl, ignore);\n     }\n@@ -3427,7 +3423,7 @@ fn trans_fail_expr(bcx: block, sp_opt: option<span>,\n     let bcx = bcx;\n     alt fail_expr {\n       some(expr) {\n-        let ccx = bcx_ccx(bcx), tcx = ccx.tcx;\n+        let ccx = bcx.ccx(), tcx = ccx.tcx;\n         let expr_res = trans_temp_expr(bcx, expr);\n         let e_ty = expr_ty(bcx, expr);\n         bcx = expr_res.bcx;\n@@ -3440,7 +3436,7 @@ fn trans_fail_expr(bcx: block, sp_opt: option<span>,\n         } else if bcx.unreachable || ty::type_is_bot(e_ty) {\n             ret bcx;\n         } else {\n-            bcx_ccx(bcx).sess.span_bug(\n+            bcx.sess().span_bug(\n                 expr.span, \"fail called with unsupported type \" +\n                 ty_to_str(tcx, e_ty));\n         }\n@@ -3451,28 +3447,28 @@ fn trans_fail_expr(bcx: block, sp_opt: option<span>,\n \n fn trans_fail(bcx: block, sp_opt: option<span>, fail_str: str) ->\n     block {\n-    let V_fail_str = C_cstr(bcx_ccx(bcx), fail_str);\n+    let V_fail_str = C_cstr(bcx.ccx(), fail_str);\n     ret trans_fail_value(bcx, sp_opt, V_fail_str);\n }\n \n fn trans_fail_value(bcx: block, sp_opt: option<span>,\n                     V_fail_str: ValueRef) -> block {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     let V_filename;\n     let V_line;\n     alt sp_opt {\n       some(sp) {\n-        let sess = bcx_ccx(bcx).sess;\n+        let sess = bcx.sess();\n         let loc = codemap::lookup_char_pos(sess.parse_sess.cm, sp.lo);\n-        V_filename = C_cstr(bcx_ccx(bcx), loc.file.name);\n+        V_filename = C_cstr(bcx.ccx(), loc.file.name);\n         V_line = loc.line as int;\n       }\n-      none { V_filename = C_cstr(bcx_ccx(bcx), \"<runtime>\"); V_line = 0; }\n+      none { V_filename = C_cstr(bcx.ccx(), \"<runtime>\"); V_line = 0; }\n     }\n     let V_str = PointerCast(bcx, V_fail_str, T_ptr(T_i8()));\n     V_filename = PointerCast(bcx, V_filename, T_ptr(T_i8()));\n     let args = [V_str, V_filename, C_int(ccx, V_line)];\n-    let bcx = invoke(bcx, bcx_ccx(bcx).upcalls._fail, args);\n+    let bcx = invoke(bcx, bcx.ccx().upcalls._fail, args);\n     Unreachable(bcx);\n     ret bcx;\n }\n@@ -3499,7 +3495,7 @@ fn trans_break_cont(bcx: block, to_end: bool)\n         unwind = alt check unwind.parent {\n           parent_some(cx) { cx }\n           parent_none {\n-            bcx_ccx(bcx).sess.bug\n+            bcx.sess().bug\n                 (if to_end { \"break\" } else { \"cont\" } + \" outside a loop\");\n           }\n         };\n@@ -3528,7 +3524,7 @@ fn trans_ret(bcx: block, e: option<@ast::expr>) -> block {\n     ret bcx;\n }\n \n-fn build_return(bcx: block) { Br(bcx, bcx_fcx(bcx).llreturn); }\n+fn build_return(bcx: block) { Br(bcx, bcx.fcx.llreturn); }\n \n // fn trans_be(cx: &block, e: &@ast::expr) -> result {\n fn trans_be(cx: block, e: @ast::expr) : ast_util::is_call_expr(e) ->\n@@ -3542,15 +3538,15 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n     let ty = node_id_type(bcx, local.node.id);\n     let llptr = alt bcx.fcx.lllocals.find(local.node.id) {\n       some(local_mem(v)) { v }\n-      some(_) { bcx_tcx(bcx).sess.span_bug(local.span,\n+      some(_) { bcx.tcx().sess.span_bug(local.span,\n                         \"init_local: Someone forgot to document why it's\\\n                          safe to assume local.node.init must be local_mem!\");\n       }\n       // This is a local that is kept immediate\n       none {\n         let initexpr = alt local.node.init {\n                 some({expr, _}) { expr }\n-                none { bcx_tcx(bcx).sess.span_bug(local.span,\n+                none { bcx.tcx().sess.span_bug(local.span,\n                         \"init_local: Someone forgot to document why it's\\\n                          safe to assume local.node.init isn't none!\"); }\n             };\n@@ -3586,7 +3582,7 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n fn zero_alloca(cx: block, llptr: ValueRef, t: ty::t)\n     -> block {\n     let bcx = cx;\n-    let ccx = bcx_ccx(cx);\n+    let ccx = cx.ccx();\n     if check type_has_static_size(ccx, t) {\n         let llty = type_of(ccx, t);\n         Store(bcx, C_null(llty), llptr);\n@@ -3610,7 +3606,7 @@ fn zero_alloca(cx: block, llptr: ValueRef, t: ty::t)\n fn trans_stmt(cx: block, s: ast::stmt) -> block {\n     #debug[\"trans_expr(%s)\", stmt_to_str(s)];\n \n-    if (!bcx_ccx(cx).sess.opts.no_asm_comments) {\n+    if (!cx.sess().opts.no_asm_comments) {\n         add_span_comment(cx, s.span, stmt_to_str(s));\n     }\n \n@@ -3626,15 +3622,15 @@ fn trans_stmt(cx: block, s: ast::stmt) -> block {\n           ast::decl_local(locals) {\n             for local in locals {\n                 bcx = init_local(bcx, local);\n-                if bcx_ccx(cx).sess.opts.extra_debuginfo {\n+                if cx.sess().opts.extra_debuginfo {\n                     debuginfo::create_local_var(bcx, local);\n                 }\n             }\n           }\n           ast::decl_item(i) { trans_item(cx.fcx.ccx, *i); }\n         }\n       }\n-      _ { bcx_ccx(cx).sess.unimpl(\"stmt variant\"); }\n+      _ { cx.sess().unimpl(\"stmt variant\"); }\n     }\n \n     ret bcx;\n@@ -3805,7 +3801,7 @@ fn with_cond(bcx: block, val: ValueRef, f: fn(block) -> block) -> block {\n \n fn trans_fn_cleanups(fcx: @fn_ctxt, cx: block) {\n     option::may(fcx.llobstacktoken) {|lltoken|\n-        Call(cx, fcx_ccx(fcx).upcalls.dynastack_free, [lltoken]);\n+        Call(cx, fcx.ccx.upcalls.dynastack_free, [lltoken]);\n     }\n }\n \n@@ -3826,7 +3822,7 @@ fn block_locals(b: ast::blk, it: fn(@ast::local)) {\n }\n \n fn alloc_ty(cx: block, t: ty::t) -> result {\n-    let bcx = cx, ccx = bcx_ccx(cx);\n+    let bcx = cx, ccx = cx.ccx();\n     let llty = type_of(ccx, t);\n     let val = if type_has_static_size(ccx, t) {\n         alloca(bcx, llty)\n@@ -3853,12 +3849,12 @@ fn alloc_ty(cx: block, t: ty::t) -> result {\n \n fn alloc_local(cx: block, local: @ast::local) -> block {\n     let t = node_id_type(cx, local.node.id);\n-    let p = normalize_pat(bcx_tcx(cx), local.node.pat);\n+    let p = normalize_pat(cx.tcx(), local.node.pat);\n     let is_simple = alt p.node {\n       ast::pat_ident(_, none) { true } _ { false }\n     };\n     // Do not allocate space for locals that can be kept immediate.\n-    let ccx = bcx_ccx(cx);\n+    let ccx = cx.ccx();\n     if is_simple && !ccx.mutbl_map.contains_key(local.node.pat.id) &&\n        !ccx.last_uses.contains_key(local.node.pat.id) &&\n        ty::type_is_immediate(t) {\n@@ -3870,7 +3866,7 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n     let r = alloc_ty(cx, t);\n     alt p.node {\n       ast::pat_ident(pth, none) {\n-        if bcx_ccx(cx).sess.opts.debuginfo {\n+        if cx.sess().opts.debuginfo {\n             let _: () = str::as_buf(path_to_ident(pth), {|buf|\n                 llvm::LLVMSetValueName(r.val, buf)\n             });\n@@ -3978,10 +3974,8 @@ fn new_fn_ctxt(ccx: @crate_ctxt, path: path, llfndecl: ValueRef,\n // field of the fn_ctxt with\n fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: self_arg,\n                              args: [ast::arg], ty_params: [ast::ty_param]) {\n-    // Skip the implicit arguments 0, and 1.  TODO: Pull out 2u and define\n-    // it as a constant, since we're using it in several places in trans this\n-    // way.\n-    let arg_n = 2u;\n+    // Skip the implicit arguments 0, and 1.\n+    let arg_n = first_tp_arg;\n     alt ty_self {\n       impl_self(tt) {\n         cx.llself = some({v: cx.llenv, t: tt});\n@@ -3992,7 +3986,7 @@ fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: self_arg,\n         let lltydesc = llvm::LLVMGetParam(cx.llfn, arg_n as c_uint);\n         let dicts = none;\n         arg_n += 1u;\n-        for bound in *fcx_tcx(cx).ty_param_bounds.get(tp.id) {\n+        for bound in *cx.ccx.tcx.ty_param_bounds.get(tp.id) {\n             alt bound {\n               ty::bound_iface(_) {\n                 let dict = llvm::LLVMGetParam(cx.llfn, arg_n as c_uint);\n@@ -4023,7 +4017,7 @@ fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: self_arg,\n \n fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: block, args: [ast::arg],\n                         arg_tys: [ty::arg]) -> block {\n-    let tcx = bcx_tcx(bcx);\n+    let tcx = bcx.tcx();\n     let arg_n: uint = 0u, bcx = bcx;\n     let epic_fail = fn@() -> ! {\n         tcx.sess.bug(\"Someone forgot\\\n@@ -4048,7 +4042,7 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: block, args: [ast::arg],\n           }\n           ast::by_ref {}\n         }\n-        if fcx_ccx(fcx).sess.opts.extra_debuginfo {\n+        if fcx.ccx.sess.opts.extra_debuginfo {\n             debuginfo::create_arg(bcx, args[arg_n], args[arg_n].ty.span);\n         }\n         arg_n += 1u;\n@@ -4223,9 +4217,9 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n         // If this argument to this function is a enum, it'll have come in to\n         // this function as an opaque blob due to the way that type_of()\n         // works. So we have to cast to the destination's view of the type.\n-        let llarg = alt fcx.llargs.find(va.id) { some(local_mem(x)) { x }\n-          _ { bcx_tcx(bcx).sess.span_fatal(variant.span, \"Someone forgot\\\n-                to document an invariant in trans_tag_variant\"); } };\n+        let llarg = alt check fcx.llargs.find(va.id) {\n+          some(local_mem(x)) { x }\n+        };\n         let arg_ty = arg_tys[i].ty;\n         if ty::type_has_params(arg_ty) {\n             lldestptr = PointerCast(bcx, lldestptr, val_ty(llarg));\n@@ -4527,14 +4521,14 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n // on the stack).\n fn create_real_fn_pair(cx: block, llfnty: TypeRef, llfn: ValueRef,\n                        llenvptr: ValueRef) -> ValueRef {\n-    let pair = alloca(cx, T_fn_pair(bcx_ccx(cx), llfnty));\n+    let pair = alloca(cx, T_fn_pair(cx.ccx(), llfnty));\n     fill_fn_pair(cx, pair, llfn, llenvptr);\n     ret pair;\n }\n \n fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n                 llenvptr: ValueRef) {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     let code_cell = GEPi(bcx, pair, [0, abi::fn_field_code]);\n     Store(bcx, llfn, code_cell);\n     let env_cell = GEPi(bcx, pair, [0, abi::fn_field_box]);\n@@ -4716,7 +4710,7 @@ fn trans_constants(ccx: @crate_ctxt, crate: @ast::crate) {\n }\n \n fn vp2i(cx: block, v: ValueRef) -> ValueRef {\n-    let ccx = bcx_ccx(cx);\n+    let ccx = cx.ccx();\n     ret PtrToInt(cx, v, ccx.int_type);\n }\n \n@@ -4778,9 +4772,9 @@ fn declare_dbg_intrinsics(llmod: ModuleRef,\n \n fn trap(bcx: block) {\n     let v: [ValueRef] = [];\n-    alt bcx_ccx(bcx).intrinsics.find(\"llvm.trap\") {\n+    alt bcx.ccx().intrinsics.find(\"llvm.trap\") {\n       some(x) { Call(bcx, x, v); }\n-      _ { bcx_ccx(bcx).sess.bug(\"unbound llvm.trap in trap\"); }\n+      _ { bcx.sess().bug(\"unbound llvm.trap in trap\"); }\n     }\n }\n "}, {"sha": "91dcb34713570b352fee69c39cf176f37ea2738d", "filename": "src/comp/middle/trans/build.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs?ref=789a1ae356f75ed7db75afd485e009ce32b2bd74", "patch": "@@ -6,8 +6,7 @@ import codemap::span;\n import lib::llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef, ModuleRef};\n import lib::llvm::{Opcode, IntPredicate, RealPredicate, True, False,\n                    CallConv};\n-import common::{block, T_ptr, T_nil, T_i8, T_i1, T_void,\n-                T_fn, val_ty, bcx_ccx, C_i32, val_str};\n+import common::*;\n \n fn B(cx: block) -> BuilderRef {\n     let b = *cx.fcx.ccx.builder;\n@@ -95,8 +94,8 @@ fn Invoke(cx: block, Fn: ValueRef, Args: [ValueRef],\n     assert (!cx.terminated);\n     cx.terminated = true;\n     #debug[\"Invoke(%s with arguments (%s))\",\n-           val_str(bcx_ccx(cx).tn, Fn),\n-           str::connect(vec::map(Args, {|a|val_str(bcx_ccx(cx).tn, a)}),\n+           val_str(cx.ccx().tn, Fn),\n+           str::connect(vec::map(Args, {|a|val_str(cx.ccx().tn, a)}),\n                         \", \")];\n     unsafe {\n         llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n@@ -518,7 +517,7 @@ fn _UndefReturn(cx: block, Fn: ValueRef) -> ValueRef {\n }\n \n fn add_span_comment(bcx: block, sp: span, text: str) {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     if (!ccx.sess.opts.no_asm_comments) {\n         let s = text + \" (\" + codemap::span_to_str(sp, ccx.sess.codemap)\n             + \")\";\n@@ -528,7 +527,7 @@ fn add_span_comment(bcx: block, sp: span, text: str) {\n }\n \n fn add_comment(bcx: block, text: str) {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     if (!ccx.sess.opts.no_asm_comments) {\n         check str::is_not_empty(\"$\");\n         let sanitized = str::replace(text, \"$\", \"\");"}, {"sha": "e6cd6d07b7402662c7f3a2717f7d4c9481a2cc7c", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=789a1ae356f75ed7db75afd485e009ce32b2bd74", "patch": "@@ -167,12 +167,11 @@ fn allocate_cbox(bcx: block,\n                  cdata_ty: ty::t)\n     -> (block, ValueRef, [ValueRef]) {\n \n-    // let ccx = bcx_ccx(bcx);\n-    let ccx = bcx_ccx(bcx), tcx = ccx.tcx;\n+    let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n     fn nuke_ref_count(bcx: block, box: ValueRef) {\n         // Initialize ref count to arbitrary value for debugging:\n-        let ccx = bcx_ccx(bcx);\n+        let ccx = bcx.ccx();\n         let box = PointerCast(bcx, box, T_opaque_box_ptr(ccx));\n         let ref_cnt = GEPi(bcx, box, [0, abi::box_field_refcnt]);\n         let rc = C_int(ccx, 0x12345678);\n@@ -183,7 +182,7 @@ fn allocate_cbox(bcx: block,\n                          cdata_ty: ty::t,\n                          box: ValueRef,\n                          &ti: option::t<@tydesc_info>) -> block {\n-        let ccx = bcx_ccx(bcx);\n+        let ccx = bcx.ccx();\n         let bound_tydesc = GEPi(bcx, box, [0, abi::box_field_tydesc]);\n         let {bcx, val: td} = base::get_tydesc(bcx, cdata_ty, true, ti);\n         let td = Call(bcx, ccx.upcalls.create_shared_type_desc, [td]);\n@@ -228,7 +227,7 @@ type closure_result = {\n };\n \n fn cast_if_we_can(bcx: block, llbox: ValueRef, t: ty::t) -> ValueRef {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     if check type_has_static_size(ccx, t) {\n         let llty = type_of(ccx, t);\n         ret PointerCast(bcx, llbox, llty);\n@@ -255,13 +254,12 @@ fn store_environment(\n             td\n           }\n           ty::ck_uniq {\n-            Call(bcx, bcx_ccx(bcx).upcalls.create_shared_type_desc, [td])\n+            Call(bcx, bcx.ccx().upcalls.create_shared_type_desc, [td])\n           }\n         };\n     }\n \n-    let ccx = bcx_ccx(bcx);\n-    let tcx = bcx_tcx(bcx);\n+    let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n     // compute the shape of the closure\n     let (cdata_ty, bound_tys) =\n@@ -356,7 +354,7 @@ fn build_closure(bcx0: block,\n     // If we need to, package up the iterator body to call\n     let env_vals = [];\n     let bcx = bcx0;\n-    let tcx = bcx_tcx(bcx);\n+    let tcx = bcx.tcx();\n \n     // Package up the captured upvars\n     vec::iter(cap_vars) { |cap_var|\n@@ -449,7 +447,7 @@ fn trans_expr_fn(bcx: block,\n                  cap_clause: ast::capture_clause,\n                  dest: dest) -> block {\n     if dest == ignore { ret bcx; }\n-    let ccx = bcx_ccx(bcx), bcx = bcx;\n+    let ccx = bcx.ccx(), bcx = bcx;\n     let fty = node_id_type(bcx, id);\n     let llfnty = type_of_fn_from_ty(ccx, fty, []);\n     let sub_path = bcx.fcx.path + [path_name(\"anon\")];\n@@ -493,7 +491,7 @@ fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n                 f_res: lval_maybe_callee,\n                 args: [option<@ast::expr>], pair_ty: ty::t,\n                 dest: dest) -> block {\n-    let ccx = bcx_ccx(cx);\n+    let ccx = cx.ccx();\n     let bound: [@ast::expr] = [];\n     for argopt: option<@ast::expr> in args {\n         alt argopt { none { } some(e) { bound += [e]; } }\n@@ -579,7 +577,7 @@ fn make_fn_glue(\n     glue_fn: fn@(block, v: ValueRef, t: ty::t) -> block)\n     -> block {\n     let bcx = cx;\n-    let tcx = bcx_tcx(cx);\n+    let tcx = cx.tcx();\n \n     let fn_env = fn@(ck: ty::closure_kind) -> block {\n         let box_cell_v = GEPi(cx, v, [0, abi::fn_field_box]);\n@@ -613,8 +611,7 @@ fn make_opaque_cbox_take_glue(\n     }\n \n     // Hard case, a deep copy:\n-    let ccx = bcx_ccx(bcx);\n-    let tcx = bcx_tcx(bcx);\n+    let ccx = bcx.ccx(), tcx = ccx.tcx;\n     let llopaquecboxty = T_opaque_box_ptr(ccx);\n     let cbox_in = Load(bcx, cboxptr);\n     with_cond(bcx, IsNotNull(bcx, cbox_in)) {|bcx|\n@@ -657,11 +654,11 @@ fn make_opaque_cbox_drop_glue(\n       ty::ck_block { bcx }\n       ty::ck_box {\n         decr_refcnt_maybe_free(bcx, Load(bcx, cboxptr),\n-                               ty::mk_opaque_closure_ptr(bcx_tcx(bcx), ck))\n+                               ty::mk_opaque_closure_ptr(bcx.tcx(), ck))\n       }\n       ty::ck_uniq {\n         free_ty(bcx, Load(bcx, cboxptr),\n-                ty::mk_opaque_closure_ptr(bcx_tcx(bcx), ck))\n+                ty::mk_opaque_closure_ptr(bcx.tcx(), ck))\n       }\n     }\n }\n@@ -676,8 +673,7 @@ fn make_opaque_cbox_free_glue(\n       ty::ck_box | ty::ck_uniq { /* hard cases: */ }\n     }\n \n-    let ccx = bcx_ccx(bcx);\n-    let tcx = bcx_tcx(bcx);\n+    let ccx = bcx.ccx(), tcx = ccx.tcx;\n     with_cond(bcx, IsNotNull(bcx, cbox)) {|bcx|\n         // Load the type descr found in the cbox\n         let lltydescty = T_ptr(ccx.tydesc_type);\n@@ -862,7 +858,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n         fcx.lltyparams += [{desc: dsc, dicts: dicts}];\n     }\n \n-    let a: uint = 2u; // retptr, env come first\n+    let a: uint = first_tp_arg; // retptr, env come first\n     let b: int = starting_idx;\n     let outgoing_arg_index: uint = 0u;\n     let llout_arg_tys: [TypeRef] ="}, {"sha": "2fcd42a4d9da4186de34f07d143f75144decee2e", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=789a1ae356f75ed7db75afd485e009ce32b2bd74", "patch": "@@ -68,10 +68,6 @@ resource BuilderRef_res(B: BuilderRef) { llvm::LLVMDisposeBuilder(B); }\n \n // Crate context.  Every crate we compile has one of these.\n type crate_ctxt =\n-    // A mapping from the def_id of each item in this crate to the address\n-    // of the first instruction of the item's definition in the executable\n-    // we're generating.\n-    // TODO: hashmap<tup(tag_id,subtys), @tag_info>\n     {sess: session::session,\n      llmod: ModuleRef,\n      td: target_data,\n@@ -233,14 +229,14 @@ fn scope_clean_changed(info: scope_info) {\n }\n \n fn add_clean(cx: block, val: ValueRef, ty: ty::t) {\n-    if !ty::type_needs_drop(bcx_tcx(cx), ty) { ret; }\n+    if !ty::type_needs_drop(cx.tcx(), ty) { ret; }\n     in_scope_cx(cx) {|info|\n         info.cleanups += [clean(bind drop_ty(_, val, ty))];\n         scope_clean_changed(info);\n     }\n }\n fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n-    if !ty::type_needs_drop(bcx_tcx(cx), ty) { ret; }\n+    if !ty::type_needs_drop(cx.tcx(), ty) { ret; }\n     fn do_drop(bcx: block, val: ValueRef, ty: ty::t) ->\n        block {\n         if ty::type_is_immediate(ty) {\n@@ -255,7 +251,7 @@ fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n     }\n }\n fn add_clean_temp_mem(cx: block, val: ValueRef, ty: ty::t) {\n-    if !ty::type_needs_drop(bcx_tcx(cx), ty) { ret; }\n+    if !ty::type_needs_drop(cx.tcx(), ty) { ret; }\n     in_scope_cx(cx) {|info|\n         info.cleanups += [clean_temp(val, bind drop_ty(_, val, ty))];\n         scope_clean_changed(info);\n@@ -365,6 +361,9 @@ type block = @{\n     fcx: @fn_ctxt\n };\n \n+// First two args are retptr, env\n+const first_tp_arg: uint = 2u;\n+\n // FIXME: we should be able to use option<@block_parent> here but\n // the infinite-enum check in rustboot gets upset.\n enum block_parent { parent_none, parent_some(block), }\n@@ -409,14 +408,12 @@ fn block_parent(cx: block) -> block {\n }\n \n // Accessors\n-// TODO: When we have overloading, simplify these names!\n \n-pure fn bcx_tcx(bcx: block) -> ty::ctxt { ret bcx.fcx.ccx.tcx; }\n-pure fn bcx_ccx(bcx: block) -> @crate_ctxt { ret bcx.fcx.ccx; }\n-pure fn bcx_fcx(bcx: block) -> @fn_ctxt { ret bcx.fcx; }\n-pure fn fcx_ccx(fcx: @fn_ctxt) -> @crate_ctxt { ret fcx.ccx; }\n-pure fn fcx_tcx(fcx: @fn_ctxt) -> ty::ctxt { ret fcx.ccx.tcx; }\n-pure fn ccx_tcx(ccx: @crate_ctxt) -> ty::ctxt { ret ccx.tcx; }\n+impl bxc_cxs for block {\n+    fn ccx() -> @crate_ctxt { self.fcx.ccx }\n+    fn tcx() -> ty::ctxt { self.fcx.ccx.tcx }\n+    fn sess() -> session { self.fcx.ccx.sess }\n+}\n \n // LLVM type constructors.\n fn T_void() -> TypeRef {\n@@ -611,7 +608,7 @@ fn T_array(t: TypeRef, n: uint) -> TypeRef {\n \n // Interior vector.\n //\n-// TODO: Support user-defined vector sizes.\n+// FIXME: Support user-defined vector sizes.\n fn T_vec2(targ_cfg: @session::config, t: TypeRef) -> TypeRef {\n     ret T_struct([T_int(targ_cfg), // fill\n                   T_int(targ_cfg), // alloc\n@@ -850,7 +847,7 @@ pure fn valid_variant_index(ix: uint, cx: block, enum_id: ast::def_id,\n     // change. (We're not adding new variants during trans.)\n     unchecked{\n         let variant =\n-            ty::enum_variant_with_id(bcx_tcx(cx), enum_id, variant_id);\n+            ty::enum_variant_with_id(cx.tcx(), enum_id, variant_id);\n         ix < variant.args.len()\n     }\n }\n@@ -897,7 +894,7 @@ fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n }\n \n fn align_to(cx: block, off: ValueRef, align: ValueRef) -> ValueRef {\n-    let mask = build::Sub(cx, align, C_int(bcx_ccx(cx), 1));\n+    let mask = build::Sub(cx, align, C_int(cx.ccx(), 1));\n     let bumped = build::Add(cx, off, mask);\n     ret build::And(cx, bumped, build::Not(cx, mask));\n }\n@@ -915,7 +912,7 @@ fn path_str(p: path) -> str {\n }\n \n fn node_id_type(bcx: block, id: ast::node_id) -> ty::t {\n-    let tcx = bcx_tcx(bcx);\n+    let tcx = bcx.tcx();\n     let t = ty::node_id_to_type(tcx, id);\n     alt bcx.fcx.param_substs {\n       some(substs) { ty::substitute_type_params(tcx, substs.tys, t) }\n@@ -926,7 +923,7 @@ fn expr_ty(bcx: block, ex: @ast::expr) -> ty::t {\n     node_id_type(bcx, ex.id)\n }\n fn node_id_type_params(bcx: block, id: ast::node_id) -> [ty::t] {\n-    let tcx = bcx_tcx(bcx);\n+    let tcx = bcx.tcx();\n     let params = ty::node_id_to_type_params(tcx, id);\n     alt bcx.fcx.param_substs {\n       some(substs) {"}, {"sha": "13b9d7673d3465a5aa689f77e8589e10bdb96505", "filename": "src/comp/middle/trans/debuginfo.rs", "status": "modified", "additions": 25, "deletions": 32, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=789a1ae356f75ed7db75afd485e009ce32b2bd74", "patch": "@@ -225,7 +225,7 @@ fn line_from_span(cm: codemap::codemap, sp: span) -> uint {\n }\n \n fn create_block(cx: block) -> @metadata<block_md> {\n-    let cache = get_cache(bcx_ccx(cx));\n+    let cache = get_cache(cx.ccx());\n     let cx = cx;\n     while option::is_none(cx.block_span) {\n         alt cx.parent {\n@@ -235,10 +235,10 @@ fn create_block(cx: block) -> @metadata<block_md> {\n     }\n     let sp = option::get(cx.block_span);\n \n-    let start = codemap::lookup_char_pos(bcx_ccx(cx).sess.codemap,\n+    let start = codemap::lookup_char_pos(cx.sess().codemap,\n                                          sp.lo);\n     let fname = start.file.name;\n-    let end = codemap::lookup_char_pos(bcx_ccx(cx).sess.codemap,\n+    let end = codemap::lookup_char_pos(cx.sess().codemap,\n                                        sp.hi);\n     let tg = LexicalBlockTag;\n     /*alt cached_metadata::<@metadata<block_md>>(\n@@ -252,7 +252,7 @@ fn create_block(cx: block) -> @metadata<block_md> {\n         parent_none { create_function(cx.fcx).node }\n         parent_some(bcx) { create_block(bcx).node }\n     };\n-    let file_node = create_file(bcx_ccx(cx), fname);\n+    let file_node = create_file(cx.ccx(), fname);\n     let unique_id = alt cache.find(LexicalBlockTag) {\n       option::some(v) { vec::len(v) as int }\n       option::none { 0 }\n@@ -434,11 +434,10 @@ fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname);\n     //let cu_node = create_compile_unit_metadata(cx, fname);\n-    let tcx = ccx_tcx(cx);\n-    let uint_t = ty::mk_uint(tcx);\n+    let uint_t = ty::mk_uint(cx.tcx);\n     let refcount_type = create_basic_type(cx, uint_t,\n                                           ast::ty_uint(ast::ty_u), span);\n-    let scx = create_structure(file_node, ty_to_str(ccx_tcx(cx), outer), 0);\n+    let scx = create_structure(file_node, ty_to_str(cx.tcx, outer), 0);\n     add_member(scx, \"refcnt\", 0, sys::size_of::<uint>() as int,\n                sys::align_of::<uint>() as int, refcount_type.node);\n     add_member(scx, \"boxed\", 0, 8, //XXX member_size_and_align(??)\n@@ -487,16 +486,15 @@ fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n     let fname = filename_from_span(cx, vec_ty_span);\n     let file_node = create_file(cx, fname);\n     let elem_ty_md = create_ty(cx, elem_t, elem_ty);\n-    let tcx = ccx_tcx(cx);\n-    let scx = create_structure(file_node, ty_to_str(tcx, vec_t), 0);\n-    let size_t_type = create_basic_type(cx, ty::mk_uint(tcx),\n+    let scx = create_structure(file_node, ty_to_str(cx.tcx, vec_t), 0);\n+    let size_t_type = create_basic_type(cx, ty::mk_uint(cx.tcx),\n                                         ast::ty_uint(ast::ty_u), vec_ty_span);\n     add_member(scx, \"fill\", 0, sys::size_of::<ctypes::size_t>() as int,\n                sys::align_of::<ctypes::size_t>() as int, size_t_type.node);\n     add_member(scx, \"alloc\", 0, sys::size_of::<ctypes::size_t>() as int,\n                sys::align_of::<ctypes::size_t>() as int, size_t_type.node);\n     let subrange = llmdnode([lltag(SubrangeTag), lli64(0), lli64(0)]);\n-    let (arr_size, arr_align) = member_size_and_align(tcx, elem_ty);\n+    let (arr_size, arr_align) = member_size_and_align(cx.tcx, elem_ty);\n     let data_ptr = create_composite_type(ArrayTypeTag, \"\", file_node.node, 0,\n                                          arr_size, arr_align, 0,\n                                          option::some(elem_ty_md.node),\n@@ -640,14 +638,14 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n       }\n \n       ast::ty_vec(mt) {\n-        let inner_t = ty::sequence_element_type(ccx_tcx(cx), t);\n+        let inner_t = ty::sequence_element_type(cx.tcx, t);\n         let inner_ast_t = t_to_ty(cx, inner_t, mt.ty.span);\n         let v = create_vec(cx, t, inner_t, ty.span, inner_ast_t);\n         ret create_pointer_type(cx, t, ty.span, v);\n       }\n \n       ast::ty_path(_, id) {\n-        alt ccx_tcx(cx).def_map.get(id) {\n+        alt cx.tcx.def_map.get(id) {\n           ast::def_prim_ty(pty) {\n             ret create_basic_type(cx, t, pty, ty.span);\n           }\n@@ -679,7 +677,7 @@ fn create_var(type_tag: int, context: ValueRef, name: str, file: ValueRef,\n \n fn create_local_var(bcx: block, local: @ast::local)\n     -> @metadata<local_var_md> unsafe {\n-    let cx = bcx_ccx(bcx);\n+    let cx = bcx.ccx();\n     let cache = get_cache(cx);\n     let tg = AutoVariableTag;\n     alt cached_metadata::<@metadata<local_var_md>>(\n@@ -688,10 +686,10 @@ fn create_local_var(bcx: block, local: @ast::local)\n       option::none {}\n     }\n \n-    let name = path_to_ident(alt pat_util::normalize_pat(bcx_tcx(bcx),\n+    let name = path_to_ident(alt pat_util::normalize_pat(bcx.tcx(),\n                                            local.node.pat).node {\n       ast::pat_ident(ident, _) { ident /*XXX deal w/ optional node binding*/ }\n-      _ { bcx_tcx(bcx).sess.span_bug(local.span, \"create_local_var: \\\n+      _ { bcx.tcx().sess.span_bug(local.span, \"create_local_var: \\\n              weird pattern in local\"); }\n      });\n     let loc = codemap::lookup_char_pos(cx.sess.codemap,\n@@ -711,13 +709,13 @@ fn create_local_var(bcx: block, local: @ast::local)\n     let llptr = alt bcx.fcx.lllocals.find(local.node.id) {\n       option::some(local_mem(v)) { v }\n       option::some(_) {\n-        bcx_tcx(bcx).sess.span_bug(local.span, \"local is bound to \\\n+        bcx.tcx().sess.span_bug(local.span, \"local is bound to \\\n                 something weird\");\n       }\n       option::none {\n         alt bcx.fcx.lllocals.get(local.node.pat.id) {\n           local_imm(v) { v }\n-          _ { bcx_tcx(bcx).sess.span_bug(local.span, \"local is bound to \\\n+          _ { bcx.tcx().sess.span_bug(local.span, \"local is bound to \\\n                 something weird\"); }\n         }\n       }\n@@ -730,8 +728,7 @@ fn create_local_var(bcx: block, local: @ast::local)\n \n fn create_arg(bcx: block, arg: ast::arg, sp: span)\n     -> @metadata<argument_md> unsafe {\n-    let fcx = bcx_fcx(bcx);\n-    let cx = fcx_ccx(fcx);\n+    let fcx = bcx.fcx, cx = fcx.ccx;\n     let cache = get_cache(cx);\n     let tg = ArgVariableTag;\n     alt cached_metadata::<@metadata<argument_md>>(\n@@ -740,9 +737,6 @@ fn create_arg(bcx: block, arg: ast::arg, sp: span)\n       option::none {}\n     }\n \n-    /*let arg_n = alt cx.ast_map.get(arg.id) {\n-      ast_map::node_arg(_, n) { n - 2u }\n-    };*/\n     let loc = codemap::lookup_char_pos(cx.sess.codemap,\n                                        sp.lo);\n     let ty = node_id_type(bcx, arg.id);\n@@ -764,10 +758,10 @@ fn create_arg(bcx: block, arg: ast::arg, sp: span)\n }\n \n fn update_source_pos(cx: block, s: span) {\n-    if !bcx_ccx(cx).sess.opts.debuginfo {\n+    if !cx.sess().opts.debuginfo {\n         ret;\n     }\n-    let cm = bcx_ccx(cx).sess.codemap;\n+    let cm = cx.sess().codemap;\n     let blockmd = create_block(cx);\n     let loc = codemap::lookup_char_pos(cm, s.lo);\n     let scopedata = [lli32(loc.line as int),\n@@ -779,7 +773,7 @@ fn update_source_pos(cx: block, s: span) {\n }\n \n fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n-    let cx = fcx_ccx(fcx);\n+    let cx = fcx.ccx;\n     let dbg_cx = option::get(cx.dbg_cx);\n \n     #debug(\"~~\");\n@@ -794,7 +788,7 @@ fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n           ast::item_fn(decl, _, _) | ast::item_res(decl, _, _, _, _) {\n             (item.ident, decl.output, item.id)\n           }\n-          _ { fcx_tcx(fcx).sess.span_bug(item.span, \"create_function: item \\\n+          _ { fcx.ccx.sess.span_bug(item.span, \"create_function: item \\\n                 bound to non-function\"); }\n         }\n       }\n@@ -806,7 +800,7 @@ fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n             ast::item_res(decl, _, _, _, ctor_id) {\n               (item.ident, decl.output, ctor_id)\n             }\n-            _ { fcx_tcx(fcx).sess.span_bug(item.span, \"create_function: \\\n+            _ { fcx.ccx.sess.span_bug(item.span, \"create_function: \\\n                   expected an item_res here\"); }\n           }\n       }\n@@ -818,11 +812,11 @@ fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n           ast::expr_fn_block(decl, _) {\n             (dbg_cx.names(\"fn\"), decl.output, expr.id)\n           }\n-          _ { fcx_tcx(fcx).sess.span_bug(expr.span, \"create_function: \\\n+          _ { fcx.ccx.sess.span_bug(expr.span, \"create_function: \\\n                   expected an expr_fn or fn_block here\"); }\n         }\n       }\n-      _ { fcx_tcx(fcx).sess.bug(\"create_function: unexpected \\\n+      _ { fcx.ccx.sess.bug(\"create_function: unexpected \\\n             sort of node\"); }\n     };\n \n@@ -846,8 +840,7 @@ fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n     let ty_node = if cx.sess.opts.extra_debuginfo {\n         alt ret_ty.node {\n           ast::ty_nil { llnull() }\n-          _ { create_ty(cx, ty::node_id_to_type(ccx_tcx(cx), id),\n-                        ret_ty).node }\n+          _ { create_ty(cx, ty::node_id_to_type(cx.tcx, id), ret_ty).node }\n         }\n     } else {\n         llnull()"}, {"sha": "8ca3d8577dc365deffd250c74d0dc2c6639f79c9", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=789a1ae356f75ed7db75afd485e009ce32b2bd74", "patch": "@@ -63,7 +63,7 @@ fn trans_self_arg(bcx: block, base: @ast::expr) -> result {\n     let basety = expr_ty(bcx, base);\n     let m_by_ref = ast::expl(ast::by_ref);\n     trans_arg_expr(bcx, {mode: m_by_ref, ty: basety},\n-                   T_ptr(type_of_or_i8(bcx_ccx(bcx), basety)), base)\n+                   T_ptr(type_of_or_i8(bcx.ccx(), basety)), base)\n }\n \n fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n@@ -110,7 +110,7 @@ fn wrapper_fn_ty(ccx: @crate_ctxt, dict_ty: TypeRef, fty: ty::t,\n fn trans_vtable_callee(bcx: block, env: callee_env, dict: ValueRef,\n                        callee_id: ast::node_id, iface_id: ast::def_id,\n                        n_method: uint) -> lval_maybe_callee {\n-    let bcx = bcx, ccx = bcx_ccx(bcx), tcx = ccx.tcx;\n+    let bcx = bcx, ccx = bcx.ccx(), tcx = ccx.tcx;\n     let method = ty::iface_methods(tcx, iface_id)[n_method];\n     let {ty: fty, llty: llfty} =\n         wrapper_fn_ty(ccx, val_ty(dict), node_id_type(bcx, callee_id),\n@@ -146,7 +146,7 @@ fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n                               substs: param_substs) -> lval_maybe_callee {\n     alt find_dict_in_fn_ctxt(substs, n_param, n_bound) {\n       typeck::dict_static(impl_did, tys, sub_origins) {\n-        let tcx = bcx_tcx(bcx);\n+        let tcx = bcx.tcx();\n         if impl_did.crate != ast::local_crate {\n             ret trans_param_callee(bcx, callee_id, base, iface_id,\n                                    n_method, n_param, n_bound);\n@@ -296,8 +296,9 @@ fn trans_impl_wrapper(ccx: @crate_ctxt, pt: path,\n     let env_ty = T_ptr(T_struct([T_ptr(T_i8())] + extra_ptrs));\n     let n_extra_ptrs = extra_ptrs.len();\n \n-    let wrap_args = [T_ptr(T_dict())] + vec::slice(real_args, 0u, 2u) +\n-        vec::slice(real_args, 2u + n_extra_ptrs, real_args.len());\n+    let wrap_args = [T_ptr(T_dict())] +\n+        vec::slice(real_args, 0u, first_tp_arg) +\n+        vec::slice(real_args, first_tp_arg + n_extra_ptrs, real_args.len());\n     let llfn_ty = T_fn(wrap_args, real_ret);\n     trans_wrapper(ccx, pt, llfn_ty, {|llfn, bcx|\n         let dict = PointerCast(bcx, LLVMGetParam(llfn, 0 as c_uint), env_ty);\n@@ -397,7 +398,7 @@ fn dict_is_static(tcx: ty::ctxt, origin: typeck::dict_origin) -> bool {\n }\n \n fn get_dict(bcx: block, origin: typeck::dict_origin) -> result {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     alt origin {\n       typeck::dict_static(impl_did, tys, sub_origins) {\n         if dict_is_static(ccx.tcx, origin) {\n@@ -455,7 +456,7 @@ fn dict_id(tcx: ty::ctxt, origin: typeck::dict_origin) -> dict_id {\n \n fn get_static_dict(bcx: block, origin: typeck::dict_origin)\n     -> ValueRef {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     let id = dict_id(ccx.tcx, origin);\n     alt ccx.dicts.find(id) {\n       some(d) { ret d; }\n@@ -476,7 +477,7 @@ fn get_static_dict(bcx: block, origin: typeck::dict_origin)\n \n fn get_dict_ptrs(bcx: block, origin: typeck::dict_origin)\n     -> {bcx: block, ptrs: [ValueRef]} {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     fn get_vtable(ccx: @crate_ctxt, did: ast::def_id) -> ValueRef {\n         if did.crate == ast::local_crate {\n             ccx.item_ids.get(did.node)\n@@ -512,15 +513,15 @@ fn get_dict_ptrs(bcx: block, origin: typeck::dict_origin)\n         {bcx: bcx, ptrs: [get_vtable(ccx, did)]}\n       }\n       _ {\n-        bcx_tcx(bcx).sess.bug(\"Unexpected dict_param in get_dict_ptrs\");\n+        bcx.tcx().sess.bug(\"Unexpected dict_param in get_dict_ptrs\");\n       }\n     }\n }\n \n fn trans_cast(bcx: block, val: @ast::expr, id: ast::node_id, dest: dest)\n     -> block {\n     if dest == ignore { ret trans_expr(bcx, val, ignore); }\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     let v_ty = expr_ty(bcx, val);\n     let {bcx, box, body} = trans_malloc_boxed(bcx, v_ty);\n     add_clean_free(bcx, box, false);"}, {"sha": "e42e866a1ef6e3a35b8a8b251daf5f505982ef0e", "filename": "src/comp/middle/trans/native.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs?ref=789a1ae356f75ed7db75afd485e009ce32b2bd74", "patch": "@@ -214,7 +214,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n                       llwrapfn: ValueRef, llargbundle: ValueRef,\n                       num_tps: uint) {\n             let i = 0u, n = vec::len(tys.arg_tys);\n-            let implicit_args = 2u + num_tps; // ret + env\n+            let implicit_args = first_tp_arg + num_tps; // ret + env\n             while i < n {\n                 let llargval = llvm::LLVMGetParam(\n                     llwrapfn,\n@@ -290,7 +290,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n             let n = vec::len(tys.arg_tys);\n             let llretptr = load_inbounds(bcx, llargbundle, [0, n as int]);\n             llargvals += [llretptr];\n-            let llenvptr = C_null(T_opaque_box_ptr(bcx_ccx(bcx)));\n+            let llenvptr = C_null(T_opaque_box_ptr(bcx.ccx()));\n             llargvals += [llenvptr];\n             while i < n {\n                 let llargval = load_inbounds(bcx, llargbundle, [0, i as int]);"}, {"sha": "c73aed68addab6c82e3329fec1a801fac9130d1d", "filename": "src/comp/middle/trans/shape.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fshape.rs?ref=789a1ae356f75ed7db75afd485e009ce32b2bd74", "patch": "@@ -6,11 +6,7 @@ import lib::llvm::{True, False, ModuleRef, TypeRef, ValueRef};\n import driver::session;\n import driver::session::session;\n import trans::base;\n-import middle::trans::common::{crate_ctxt, val_ty, C_bytes, C_int,\n-                               C_named_struct, C_struct, T_enum_variant,\n-                               block, result, rslt, bcx_ccx, bcx_tcx,\n-                               type_has_static_size, umax, umin, align_to,\n-                               tydesc_info};\n+import middle::trans::common::*;\n import back::abi;\n import middle::ty;\n import middle::ty::field;\n@@ -102,12 +98,12 @@ fn mk_global(ccx: @crate_ctxt, name: str, llval: ValueRef, internal: bool) ->\n // alignment at least as large as any other variant of the enum. This is an\n // important performance optimization.\n //\n-// TODO: Use this in dynamic_size_of() as well.\n+// FIXME: Use this in dynamic_size_of() as well.\n \n fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n     // Compute the minimum and maximum size and alignment for each variant.\n     //\n-    // TODO: We could do better here; e.g. we know that any variant that\n+    // FIXME: We could do better here; e.g. we know that any variant that\n     // contains (T,T) must be as least as large as any variant that contains\n     // just T.\n     let ranges = [];\n@@ -117,7 +113,7 @@ fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n         let {a: min_size, b: min_align} = {a: 0u, b: 0u};\n         for elem_t: ty::t in variant.args {\n             if ty::type_has_params(elem_t) {\n-                // TODO: We could do better here; this causes us to\n+                // FIXME: We could do better here; this causes us to\n                 // conservatively assume that (int, T) has minimum size 0,\n                 // when in fact it has minimum size sizeof(int).\n                 bounded = false;\n@@ -183,7 +179,7 @@ fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n // Computes the static size of a enum, without using mk_tup(), which is\n // bad for performance.\n //\n-// TODO: Migrate trans over to use this.\n+// FIXME: Migrate trans over to use this.\n \n fn round_up(size: u16, align: u8) -> u16 {\n     assert (align >= 1u8);\n@@ -606,7 +602,7 @@ type tag_metrics = {\n };\n \n fn size_of(bcx: block, t: ty::t) -> result {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     if check type_has_static_size(ccx, t) {\n         rslt(bcx, llsize_of(ccx, base::type_of(ccx, t)))\n     } else {\n@@ -616,7 +612,7 @@ fn size_of(bcx: block, t: ty::t) -> result {\n }\n \n fn align_of(bcx: block, t: ty::t) -> result {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     if check type_has_static_size(ccx, t) {\n         rslt(bcx, llalign_of(ccx, base::type_of(ccx, t)))\n     } else {\n@@ -626,7 +622,7 @@ fn align_of(bcx: block, t: ty::t) -> result {\n }\n \n fn metrics(bcx: block, t: ty::t) -> metrics {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     if check type_has_static_size(ccx, t) {\n         let llty = base::type_of(ccx, t);\n         { bcx: bcx, sz: llsize_of(ccx, llty), align: llalign_of(ccx, llty) }\n@@ -699,8 +695,8 @@ fn dynamic_metrics(cx: block, t: ty::t) -> metrics {\n         //     is aligned to max alignment of interior.\n         //\n \n-        let off = C_int(bcx_ccx(cx), 0);\n-        let max_align = C_int(bcx_ccx(cx), 1);\n+        let off = C_int(cx.ccx(), 0);\n+        let max_align = C_int(cx.ccx(), 1);\n         let bcx = cx;\n         for e: ty::t in elts {\n             let elt_align = align_of(bcx, e);\n@@ -734,17 +730,17 @@ fn dynamic_metrics(cx: block, t: ty::t) -> metrics {\n       }\n       ty::ty_enum(tid, tps) {\n         let bcx = cx;\n-        let ccx = bcx_ccx(bcx);\n+        let ccx = bcx.ccx();\n \n         let compute_max_variant_size = fn@(bcx: block) -> result {\n             // Compute max(variant sizes).\n             let bcx = bcx;\n             let max_size: ValueRef = C_int(ccx, 0);\n-            let variants = ty::enum_variants(bcx_tcx(bcx), tid);\n+            let variants = ty::enum_variants(bcx.tcx(), tid);\n             for variant: ty::variant_info in *variants {\n                 // Perform type substitution on the raw argument types.\n                 let tys = vec::map(variant.args) {|raw_ty|\n-                    ty::substitute_type_params(bcx_tcx(cx), tps, raw_ty)\n+                    ty::substitute_type_params(cx.tcx(), tps, raw_ty)\n                 };\n                 let rslt = align_elements(bcx, tys);\n                 bcx = rslt.bcx;\n@@ -766,7 +762,7 @@ fn dynamic_metrics(cx: block, t: ty::t) -> metrics {\n       }\n       _ {\n         // Precondition?\n-        bcx_tcx(cx).sess.bug(\"dynamic_metrics: type has static \\\n+        cx.tcx().sess.bug(\"dynamic_metrics: type has static \\\n           size\");\n       }\n     }\n@@ -802,7 +798,7 @@ fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n //fn tag_payload_offs(bcx: block, tag_id: ast::def_id, tps: [ty::t])\n //    -> ValueRef {\n //    alt tag_kind(tag_id) {\n-//      tk_unit | tk_enum | tk_newtype { C_int(bcx_ccx(bcx), 0) }\n+//      tk_unit | tk_enum | tk_newtype { C_int(bcx.ccx(), 0) }\n //      tk_complex {\n //        compute_tag_metrics(tag_id, tps)\n //      }"}, {"sha": "04734fe2960f419d52c190aead84d2245d9b5589", "filename": "src/comp/middle/trans/tvec.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs?ref=789a1ae356f75ed7db75afd485e009ce32b2bd74", "patch": "@@ -26,7 +26,7 @@ fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n }\n \n fn alloc_raw(bcx: block, fill: ValueRef, alloc: ValueRef) -> result {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     let llvecty = ccx.opaque_vec_type;\n     let vecsize = Add(bcx, alloc, llsize_of(ccx, llvecty));\n     let {bcx: bcx, val: vecptr} =\n@@ -44,8 +44,8 @@ type alloc_result =\n      llunitty: TypeRef};\n \n fn alloc(bcx: block, vec_ty: ty::t, elts: uint) -> alloc_result {\n-    let ccx = bcx_ccx(bcx);\n-    let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n+    let ccx = bcx.ccx();\n+    let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     let llunitty = type_of_or_i8(ccx, unit_ty);\n     let llvecty = T_vec(ccx, llunitty);\n     let {bcx: bcx, val: unit_sz} = size_of(bcx, unit_ty);\n@@ -67,22 +67,22 @@ fn alloc(bcx: block, vec_ty: ty::t, elts: uint) -> alloc_result {\n }\n \n fn duplicate(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     let fill = get_fill(bcx, vptr);\n     let size = Add(bcx, fill, llsize_of(ccx, ccx.opaque_vec_type));\n     let {bcx: bcx, val: newptr} =\n         trans_shared_malloc(bcx, val_ty(vptr), size);\n     let bcx = call_memmove(bcx, newptr, vptr, size).bcx;\n-    let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n+    let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     Store(bcx, fill, GEPi(bcx, newptr, [0, abi::vec_elt_alloc]));\n-    if ty::type_needs_drop(bcx_tcx(bcx), unit_ty) {\n+    if ty::type_needs_drop(bcx.tcx(), unit_ty) {\n         bcx = iter_vec(bcx, newptr, vec_ty, base::take_ty);\n     }\n     ret rslt(bcx, newptr);\n }\n fn make_free_glue(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n    block {\n-    let tcx = bcx_tcx(bcx), unit_ty = ty::sequence_element_type(tcx, vec_ty);\n+    let tcx = bcx.tcx(), unit_ty = ty::sequence_element_type(tcx, vec_ty);\n     base::with_cond(bcx, IsNotNull(bcx, vptr)) {|bcx|\n         let bcx = if ty::type_needs_drop(tcx, unit_ty) {\n             iter_vec(bcx, vptr, vec_ty, base::drop_ty)\n@@ -93,7 +93,7 @@ fn make_free_glue(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n \n fn trans_vec(bcx: block, args: [@ast::expr], id: ast::node_id,\n              dest: dest) -> block {\n-    let ccx = bcx_ccx(bcx), bcx = bcx;\n+    let ccx = bcx.ccx(), bcx = bcx;\n     if dest == base::ignore {\n         for arg in args {\n             bcx = base::trans_expr(bcx, arg, base::ignore);\n@@ -113,7 +113,7 @@ fn trans_vec(bcx: block, args: [@ast::expr], id: ast::node_id,\n     let dataptr = get_dataptr(bcx, vptr, llunitty);\n     let i = 0u, temp_cleanups = [vptr];\n     for e in args {\n-        let lleltptr = if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n+        let lleltptr = if ty::type_has_dynamic_size(bcx.tcx(), unit_ty) {\n             InBoundsGEP(bcx, dataptr, [Mul(bcx, C_uint(ccx, i), llunitsz)])\n         } else { InBoundsGEP(bcx, dataptr, [C_uint(ccx, i)]) };\n         bcx = base::trans_expr_save_in(bcx, e, lleltptr);\n@@ -128,9 +128,9 @@ fn trans_vec(bcx: block, args: [@ast::expr], id: ast::node_id,\n fn trans_str(bcx: block, s: str, dest: dest) -> block {\n     let veclen = str::len_bytes(s) + 1u; // +1 for \\0\n     let {bcx: bcx, val: sptr, _} =\n-        alloc(bcx, ty::mk_str(bcx_tcx(bcx)), veclen);\n+        alloc(bcx, ty::mk_str(bcx.tcx()), veclen);\n \n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     let llcstr = C_cstr(ccx, s);\n     let bcx =\n         call_memmove(bcx, get_dataptr(bcx, sptr, T_i8()), llcstr,\n@@ -141,9 +141,9 @@ fn trans_str(bcx: block, s: str, dest: dest) -> block {\n fn trans_append(cx: block, vec_ty: ty::t, lhsptr: ValueRef,\n                 rhs: ValueRef) -> block {\n     // Cast to opaque interior vector types if necessary.\n-    let ccx = bcx_ccx(cx);\n-    let unit_ty = ty::sequence_element_type(bcx_tcx(cx), vec_ty);\n-    let dynamic = ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty);\n+    let ccx = cx.ccx();\n+    let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n+    let dynamic = ty::type_has_dynamic_size(cx.tcx(), unit_ty);\n     let (lhsptr, rhs) =\n         if !dynamic {\n             (lhsptr, rhs)\n@@ -156,7 +156,7 @@ fn trans_append(cx: block, vec_ty: ty::t, lhsptr: ValueRef,\n       ty::ty_vec(_) { false }\n       _ {\n           // precondition?\n-          bcx_tcx(cx).sess.bug(\"Bad argument type in trans_append\");\n+          cx.tcx().sess.bug(\"Bad argument type in trans_append\");\n       }\n     };\n \n@@ -171,7 +171,7 @@ fn trans_append(cx: block, vec_ty: ty::t, lhsptr: ValueRef,\n     if strings { new_fill = Sub(bcx, new_fill, C_int(ccx, 1)); }\n     let opaque_lhs = PointerCast(bcx, lhsptr,\n                                  T_ptr(T_ptr(ccx.opaque_vec_type)));\n-    Call(bcx, bcx_ccx(cx).upcalls.vec_grow,\n+    Call(bcx, cx.ccx().upcalls.vec_grow,\n          [opaque_lhs, new_fill]);\n     // Was overwritten if we resized\n     let lhs = Load(bcx, lhsptr);\n@@ -204,8 +204,8 @@ fn trans_append(cx: block, vec_ty: ty::t, lhsptr: ValueRef,\n \n fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n                         vals: [@ast::expr]) -> block {\n-    let ccx = bcx_ccx(bcx);\n-    let elt_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n+    let ccx = bcx.ccx();\n+    let elt_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     let ti = none;\n     let {bcx: bcx, val: td} = get_tydesc(bcx, elt_ty, false, ti);\n     base::lazily_emit_tydesc_glue(ccx, abi::tydesc_field_take_glue, ti);\n@@ -217,20 +217,20 @@ fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n         let r = base::spill_if_immediate(bcx, elt, elt_ty);\n         let spilled = r.val;\n         bcx = r.bcx;\n-        Call(bcx, bcx_ccx(bcx).upcalls.vec_push,\n+        Call(bcx, bcx.ccx().upcalls.vec_push,\n              [opaque_v, td, PointerCast(bcx, spilled, T_ptr(T_i8()))]);\n     }\n     ret bcx;\n }\n \n fn trans_add(bcx: block, vec_ty: ty::t, lhs: ValueRef,\n              rhs: ValueRef, dest: dest) -> block {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx.ccx();\n     let strings = alt ty::get(vec_ty).struct {\n       ty::ty_str { true }\n       _ { false }\n     };\n-    let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n+    let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     let llunitty = type_of_or_i8(ccx, unit_ty);\n     let {bcx: bcx, val: llunitsz} = size_of(bcx, unit_ty);\n \n@@ -245,12 +245,12 @@ fn trans_add(bcx: block, vec_ty: ty::t, lhs: ValueRef,\n         (bcx, get_dataptr(bcx, new_vec_ptr, llunitty));\n     let copy_fn = fn@(bcx: block, addr: ValueRef,\n                       _ty: ty::t) -> block {\n-        let ccx = bcx_ccx(bcx);\n+        let ccx = bcx.ccx();\n         let write_ptr = Load(bcx, write_ptr_ptr);\n         let bcx = copy_val(bcx, INIT, write_ptr,\n                            load_if_immediate(bcx, addr, unit_ty), unit_ty);\n         let incr =\n-            if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n+            if ty::type_has_dynamic_size(bcx.tcx(), unit_ty) {\n                 llunitsz\n             } else {\n                 C_int(ccx, 1)\n@@ -271,15 +271,15 @@ type iter_vec_block = fn(block, ValueRef, ty::t) -> block;\n \n fn iter_vec_raw(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n                 fill: ValueRef, f: iter_vec_block) -> block {\n-    let ccx = bcx_ccx(bcx);\n-    let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n+    let ccx = bcx.ccx();\n+    let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     let llunitty = type_of_or_i8(ccx, unit_ty);\n     let {bcx: bcx, val: unit_sz} = size_of(bcx, unit_ty);\n     let vptr = PointerCast(bcx, vptr, T_ptr(T_vec(ccx, llunitty)));\n     let data_ptr = get_dataptr(bcx, vptr, llunitty);\n \n     // Calculate the last pointer address we want to handle.\n-    // TODO: Optimize this when the size of the unit type is statically\n+    // FIXME: Optimize this when the size of the unit type is statically\n     // known to not use pointer casts, which tend to confuse LLVM.\n     let data_end_ptr = pointer_add(bcx, data_ptr, fill);\n \n@@ -294,7 +294,7 @@ fn iter_vec_raw(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n     CondBr(header_cx, not_yet_at_end, body_cx.llbb, next_cx.llbb);\n     body_cx = f(body_cx, data_ptr, unit_ty);\n     let increment =\n-        if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n+        if ty::type_has_dynamic_size(bcx.tcx(), unit_ty) {\n             unit_sz\n         } else { C_int(ccx, 1) };\n     AddIncomingToPhi(data_ptr, InBoundsGEP(body_cx, data_ptr, [increment]),\n@@ -305,8 +305,7 @@ fn iter_vec_raw(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n \n fn iter_vec(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n             f: iter_vec_block) -> block {\n-    let ccx = bcx_ccx(bcx);\n-    let vptr = PointerCast(bcx, vptr, T_ptr(ccx.opaque_vec_type));\n+    let vptr = PointerCast(bcx, vptr, T_ptr(bcx.ccx().opaque_vec_type));\n     ret iter_vec_raw(bcx, vptr, vec_ty, get_fill(bcx, vptr), f);\n }\n "}, {"sha": "b2ff6577762dc5c9fd3dc27244824740aa528b13", "filename": "src/comp/middle/trans/uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789a1ae356f75ed7db75afd485e009ce32b2bd74/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs?ref=789a1ae356f75ed7db75afd485e009ce32b2bd74", "patch": "@@ -24,7 +24,7 @@ fn alloc_uniq(cx: block, uniq_ty: ty::t) -> result {\n     bcx = r.bcx;\n     let llsz = r.val;\n \n-    let llptrty = T_ptr(type_of(bcx_ccx(bcx), contents_ty));\n+    let llptrty = T_ptr(type_of(bcx.ccx(), contents_ty));\n \n     r = trans_shared_malloc(bcx, llptrty, llsz);\n     bcx = r.bcx;"}]}