{"sha": "3ee630bbee1e35933b6296e4749fcdd882a81f90", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlZTYzMGJiZWUxZTM1OTMzYjYyOTZlNDc0OWZjZGQ4ODJhODFmOTA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-22T13:24:36Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-22T14:05:38Z"}, "message": "Add ty::new_ty_hash, clean up comparing of ty::t's", "tree": {"sha": "f6212bebe860842be34253aaa2c5f5823ea893ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6212bebe860842be34253aaa2c5f5823ea893ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ee630bbee1e35933b6296e4749fcdd882a81f90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ee630bbee1e35933b6296e4749fcdd882a81f90", "html_url": "https://github.com/rust-lang/rust/commit/3ee630bbee1e35933b6296e4749fcdd882a81f90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ee630bbee1e35933b6296e4749fcdd882a81f90/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2e077c831b5ef43780d18631170807ba0623270", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2e077c831b5ef43780d18631170807ba0623270", "html_url": "https://github.com/rust-lang/rust/commit/e2e077c831b5ef43780d18631170807ba0623270"}], "stats": {"total": 79, "additions": 30, "deletions": 49}, "files": [{"sha": "169a1354f98681de13f77068225c343e474cd691", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ee630bbee1e35933b6296e4749fcdd882a81f90/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee630bbee1e35933b6296e4749fcdd882a81f90/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=3ee630bbee1e35933b6296e4749fcdd882a81f90", "patch": "@@ -653,7 +653,7 @@ fn encode_hash(ebml_w: ebml::writer, hash: str) {\n \n fn encode_metadata(cx: @crate_ctxt, crate: @crate) -> str {\n \n-    let abbrevs = map::mk_hashmap(ty::hash_ty, ty::eq_ty);\n+    let abbrevs = ty::new_ty_hash();\n     let ecx = @{ccx: cx, type_abbrevs: abbrevs};\n \n     let string_w = io::string_writer();"}, {"sha": "19b1578b29afd13baf436c477fdfda6c5b0d284e", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3ee630bbee1e35933b6296e4749fcdd882a81f90/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee630bbee1e35933b6296e4749fcdd882a81f90/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=3ee630bbee1e35933b6296e4749fcdd882a81f90", "patch": "@@ -267,8 +267,7 @@ fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n     let cache = get_cache(cx);\n     let tg = BasicTypeDescriptorTag;\n     alt cached_metadata::<@metadata<tydesc_md>>(\n-        cache, tg,\n-        {|md| ty::hash_ty(t) == ty::hash_ty(md.data.hash)}) {\n+        cache, tg, {|md| t == md.data.hash}) {\n       option::some(md) { ret md; }\n       option::none. {}\n     }\n@@ -311,7 +310,7 @@ fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n                   lli32(0), //XXX flags?\n                   lli32(encoding)];\n     let llnode = llmdnode(lldata);\n-    let mdval = @{node: llnode, data: {hash: ty::hash_ty(t)}};\n+    let mdval = @{node: llnode, data: {hash: t}};\n     update_cache(cache, tg, tydesc_metadata(mdval));\n     add_named_metadata(cx, \"llvm.dbg.ty\", llnode);\n     ret mdval;\n@@ -333,7 +332,7 @@ fn create_pointer_type(cx: @crate_ctxt, t: ty::t, span: codemap::span,\n     //let cu_node = create_compile_unit(cx, fname);\n     let llnode = create_derived_type(tg, file_node.node, \"\", 0, size * 8,\n                                      align * 8, 0, pointee.node);\n-    let mdval = @{node: llnode, data: {hash: ty::hash_ty(t)}};\n+    let mdval = @{node: llnode, data: {hash: t}};\n     //update_cache(cache, tg, tydesc_metadata(mdval));\n     add_named_metadata(cx, \"llvm.dbg.ty\", llnode);\n     ret mdval;"}, {"sha": "786ab1886c8643127a49df80479ab14f016993cf", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3ee630bbee1e35933b6296e4749fcdd882a81f90/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee630bbee1e35933b6296e4749fcdd882a81f90/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=3ee630bbee1e35933b6296e4749fcdd882a81f90", "patch": "@@ -4348,7 +4348,7 @@ fn new_fn_ctxt_w_id(cx: @local_ctxt, sp: span, llfndecl: ValueRef,\n           lllocals: new_int_hash::<local_val>(),\n           llupvars: new_int_hash::<ValueRef>(),\n           mutable lltydescs: [],\n-          derived_tydescs: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n+          derived_tydescs: ty::new_ty_hash(),\n           id: id,\n           ret_style: rstyle,\n           sp: sp,\n@@ -5642,13 +5642,6 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n     tn.associate(\"taskptr\", taskptr_type);\n     let tydesc_type = T_tydesc(targ_cfg);\n     tn.associate(\"tydesc\", tydesc_type);\n-    let hasher = ty::hash_ty;\n-    let eqer = ty::eq_ty;\n-    let tag_sizes = map::mk_hashmap::<ty::t, uint>(hasher, eqer);\n-    let tydescs = map::mk_hashmap::<ty::t, @tydesc_info>(hasher, eqer);\n-    let lltypes = map::mk_hashmap::<ty::t, TypeRef>(hasher, eqer);\n-    let sha1s = map::mk_hashmap::<ty::t, str>(hasher, eqer);\n-    let short_names = map::mk_hashmap::<ty::t, str>(hasher, eqer);\n     let crate_map = decl_crate_map(sess, link_meta.name, llmod);\n     let dbg_cx = if sess.get_opts().debuginfo {\n         option::some(@{llmetadata: map::new_int_hash(),\n@@ -5669,18 +5662,18 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           item_symbols: new_int_hash::<str>(),\n           mutable main_fn: none::<ValueRef>,\n           link_meta: link_meta,\n-          tag_sizes: tag_sizes,\n+          tag_sizes: ty::new_ty_hash(),\n           discrims: ast_util::new_def_id_hash::<ValueRef>(),\n           discrim_symbols: new_int_hash::<str>(),\n           consts: new_int_hash::<ValueRef>(),\n           obj_methods: new_int_hash::<()>(),\n-          tydescs: tydescs,\n+          tydescs: ty::new_ty_hash(),\n           module_data: new_str_hash::<ValueRef>(),\n-          lltypes: lltypes,\n+          lltypes: ty::new_ty_hash(),\n           names: namegen(0),\n           sha: sha,\n-          type_sha1s: sha1s,\n-          type_short_names: short_names,\n+          type_sha1s: ty::new_ty_hash(),\n+          type_short_names: ty::new_ty_hash(),\n           tcx: tcx,\n           mut_map: mut_map,\n           copy_map: copy_map,"}, {"sha": "a1cb5cd371b6f3bade7c2e98720ae71cfb2d9703", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 20, "deletions": 31, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/3ee630bbee1e35933b6296e4749fcdd882a81f90/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee630bbee1e35933b6296e4749fcdd882a81f90/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=3ee630bbee1e35933b6296e4749fcdd882a81f90", "patch": "@@ -36,7 +36,6 @@ export constr_table;\n export count_ty_params;\n export ctxt;\n export def_has_ty_params;\n-export eq_ty;\n export expr_has_ty_params;\n export expr_ty;\n export expr_ty_params_and_ty;\n@@ -47,7 +46,6 @@ export field_idx;\n export get_field;\n export fm_general;\n export get_element_type;\n-export hash_ty;\n export idx_nil;\n export is_binopable;\n export is_pred_ty;\n@@ -103,6 +101,7 @@ export stmt_node_id;\n export sty;\n export substitute_type_params;\n export t;\n+export new_ty_hash;\n export tag_variants;\n export tag_variant_with_id;\n export ty_param_substs_opt_and_ty;\n@@ -398,12 +397,16 @@ fn mk_rcache() -> creader_cache {\n     ret map::mk_hashmap(hash_cache_entry, eq_cache_entries);\n }\n \n+fn new_ty_hash<copy V>() -> map::hashmap<t, V> { map::new_uint_hash() }\n \n fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n            freevars: freevars::freevar_map) -> ctxt {\n     let ntt: node_type_table =\n         @smallintmap::mk::<ty::ty_param_substs_opt_and_ty>();\n     let tcache = new_def_hash::<ty::ty_param_kinds_and_ty>();\n+    fn eq_raw_ty(&&a: @raw_t, &&b: @raw_t) -> bool {\n+        ret a.hash == b.hash && a.struct == b.struct;\n+    }\n     let ts = @interner::mk::<@raw_t>(hash_raw_ty, eq_raw_ty);\n     let cx =\n         @{ts: ts,\n@@ -414,9 +417,9 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n           freevars: freevars,\n           tcache: tcache,\n           rcache: mk_rcache(),\n-          short_names_cache: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n-          needs_drop_cache: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n-          kind_cache: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n+          short_names_cache: new_ty_hash(),\n+          needs_drop_cache: new_ty_hash(),\n+          kind_cache: new_ty_hash(),\n           ast_ty_to_ty_cache:\n               map::mk_hashmap(ast_util::hash_ty, ast_util::eq_ty),\n           tag_var_cache: @smallintmap::mk()};\n@@ -1233,8 +1236,7 @@ fn type_autoderef(cx: ctxt, t: ty::t) -> ty::t {\n     ret t1;\n }\n \n-// Type hashing. This function is private to this module (and slow); external\n-// users should use `hash_ty()` instead.\n+// Type hashing.\n fn hash_type_structure(st: sty) -> uint {\n     fn hash_uint(id: uint, n: uint) -> uint {\n         let h = id;\n@@ -1249,7 +1251,7 @@ fn hash_type_structure(st: sty) -> uint {\n     }\n     fn hash_subty(id: uint, subty: t) -> uint {\n         let h = id;\n-        h += (h << 5u) + hash_ty(subty);\n+        h += (h << 5u) + subty;\n         ret h;\n     }\n     fn hash_subtys(id: uint, subtys: [t]) -> uint {\n@@ -1284,8 +1286,8 @@ fn hash_type_structure(st: sty) -> uint {\n \n     fn hash_fn(id: uint, args: [arg], rty: t) -> uint {\n         let h = id;\n-        for a: arg in args { h += (h << 5u) + hash_ty(a.ty); }\n-        h += (h << 5u) + hash_ty(rty);\n+        for a: arg in args { h += (h << 5u) + a.ty; }\n+        h += (h << 5u) + rty;\n         ret h;\n     }\n     alt st {\n@@ -1308,14 +1310,14 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_str. { ret 17u; }\n       ty_tag(did, tys) {\n         let h = hash_def(18u, did);\n-        for typ: t in tys { h += (h << 5u) + hash_ty(typ); }\n+        for typ: t in tys { h += (h << 5u) + typ; }\n         ret h;\n       }\n       ty_box(mt) { ret hash_subty(19u, mt.ty); }\n       ty_vec(mt) { ret hash_subty(21u, mt.ty); }\n       ty_rec(fields) {\n         let h = 26u;\n-        for f: field in fields { h += (h << 5u) + hash_ty(f.mt.ty); }\n+        for f: field in fields { h += (h << 5u) + f.mt.ty; }\n         ret h;\n       }\n       ty_tup(ts) { ret hash_subtys(25u, ts); }\n@@ -1354,13 +1356,6 @@ fn hash_type_structure(st: sty) -> uint {\n \n fn hash_raw_ty(&&rt: @raw_t) -> uint { ret rt.hash; }\n \n-fn hash_ty(&&typ: t) -> uint { ret typ; }\n-\n-\n-// Type equality. This function is private to this module (and slow); external\n-// users should use `eq_ty()` instead.\n-fn eq_int(&&x: uint, &&y: uint) -> bool { ret x == y; }\n-\n fn arg_eq<T>(eq: fn(T, T) -> bool, a: @sp_constr_arg<T>, b: @sp_constr_arg<T>)\n    -> bool {\n     alt a.node {\n@@ -1389,6 +1384,7 @@ fn args_eq<T>(eq: fn(T, T) -> bool, a: [@sp_constr_arg<T>],\n }\n \n fn constr_eq(c: @constr, d: @constr) -> bool {\n+    fn eq_int(&&x: uint, &&y: uint) -> bool { ret x == y; }\n     ret path_to_str(c.node.path) == path_to_str(d.node.path) &&\n             // FIXME: hack\n             args_eq(eq_int, c.node.args, d.node.args);\n@@ -1401,16 +1397,6 @@ fn constrs_eq(cs: [@constr], ds: [@constr]) -> bool {\n     ret true;\n }\n \n-// This function is private to this module.\n-fn eq_raw_ty(&&a: @raw_t, &&b: @raw_t) -> bool {\n-    ret a.hash == b.hash && a.struct == b.struct;\n-}\n-\n-\n-// This is the equality function the public should use. It works as long as\n-// the types are interned.\n-fn eq_ty(&&a: t, &&b: t) -> bool { a == b }\n-\n // Type lookups\n fn node_id_to_ty_param_substs_opt_and_ty(cx: ctxt, id: ast::node_id) ->\n    ty_param_substs_opt_and_ty {\n@@ -2088,12 +2074,15 @@ mod unify {\n \n     fn unify_step(cx: @ctxt, expected: t, actual: t,\n                   variance: variance) -> result {\n-        // TODO: rewrite this using tuple pattern matching when available, to\n+        // FIXME: rewrite this using tuple pattern matching when available, to\n         // avoid all this rightward drift and spikiness.\n+        // NOTE: we have tuple matching now, but that involves copying the\n+        // matched elements into a tuple first, which is expensive, since sty\n+        // holds vectors, which are currently unique\n \n         // Fast path.\n+        if expected == actual { ret ures_ok(expected); }\n \n-        if eq_ty(expected, actual) { ret ures_ok(expected); }\n         // Stage 1: Handle the cases in which one side or another is a type\n         // variable.\n "}]}