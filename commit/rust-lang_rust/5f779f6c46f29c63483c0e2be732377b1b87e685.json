{"sha": "5f779f6c46f29c63483c0e2be732377b1b87e685", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNzc5ZjZjNDZmMjljNjM0ODNjMGUyYmU3MzIzNzdiMWI4N2U2ODU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-10-25T11:24:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-25T11:24:43Z"}, "message": "Merge #2066\n\n2066: insert space after `->` r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "10e0a683d2426b7fba25bccc50f3808371202e56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10e0a683d2426b7fba25bccc50f3808371202e56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f779f6c46f29c63483c0e2be732377b1b87e685", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdstt7CRBK7hj4Ov3rIwAAdHIIAC5i1xtpfRBmgCTSw9pQj3T7\nJz28Y8AxWuDg6o8wxbcTWiG0F2Eq6Y4tJDcWl/LffdKjshQklsgpv6dqjfsh9jxz\nMcaiLRd87zLAdSXi0+OUfM2cQ0oU2VXUUvuM+yG4uvBn8nUW0KdsdkdGmND3RNmN\nJro/fbxNyXBIAAChnpo0YqeEjAPV+7WwD977HFI/QeVB79mdXbKNtzl9+Xq1NcJq\nfEX022uv/I8KvEgsNaSKF7HbQum0d8hXHj8sD6Lt+fiB0qnsoWAYZZeUbcj9I48w\nMPyq2hLG3+z/Ng8YL3796AJ7hhXfcJ1UEb/68Kr6pEVbpWZ2NSnDtDaT8q1YrfM=\n=9Z/K\n-----END PGP SIGNATURE-----\n", "payload": "tree 10e0a683d2426b7fba25bccc50f3808371202e56\nparent 4ab384c19d30e2ea1ead5886dfc1efc05521f075\nparent d5cd8b5be2a146abe75c0aa322f2313240c8f23c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1572002683 +0000\ncommitter GitHub <noreply@github.com> 1572002683 +0000\n\nMerge #2066\n\n2066: insert space after `->` r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f779f6c46f29c63483c0e2be732377b1b87e685", "html_url": "https://github.com/rust-lang/rust/commit/5f779f6c46f29c63483c0e2be732377b1b87e685", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f779f6c46f29c63483c0e2be732377b1b87e685/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ab384c19d30e2ea1ead5886dfc1efc05521f075", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ab384c19d30e2ea1ead5886dfc1efc05521f075", "html_url": "https://github.com/rust-lang/rust/commit/4ab384c19d30e2ea1ead5886dfc1efc05521f075"}, {"sha": "d5cd8b5be2a146abe75c0aa322f2313240c8f23c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5cd8b5be2a146abe75c0aa322f2313240c8f23c", "html_url": "https://github.com/rust-lang/rust/commit/d5cd8b5be2a146abe75c0aa322f2313240c8f23c"}], "stats": {"total": 636, "additions": 358, "deletions": 278}, "files": [{"sha": "d0188da4493e6f19550dd141babbfc572a9b8462", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 16, "deletions": 113, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/5f779f6c46f29c63483c0e2be732377b1b87e685/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f779f6c46f29c63483c0e2be732377b1b87e685/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=5f779f6c46f29c63483c0e2be732377b1b87e685", "patch": "@@ -14,6 +14,7 @@ mod db;\n pub mod mock_analysis;\n mod symbol_index;\n mod change;\n+mod source_change;\n mod feature_flags;\n \n mod status;\n@@ -54,8 +55,6 @@ use ra_db::{\n     CheckCanceled, FileLoader, SourceDatabase,\n };\n use ra_syntax::{SourceFile, TextRange, TextUnit};\n-use ra_text_edit::TextEdit;\n-use relative_path::RelativePathBuf;\n \n use crate::{db::LineIndexDatabase, symbol_index::FileSymbol};\n \n@@ -73,6 +72,7 @@ pub use crate::{\n     line_index_utils::translate_offset_with_edit,\n     references::{ReferenceSearchResult, SearchScope},\n     runnables::{Runnable, RunnableKind},\n+    source_change::{FileSystemEdit, SourceChange, SourceFileEdit},\n     syntax_highlighting::HighlightedRange,\n };\n \n@@ -83,99 +83,6 @@ pub use ra_db::{\n \n pub type Cancelable<T> = Result<T, Canceled>;\n \n-#[derive(Debug)]\n-pub struct SourceChange {\n-    pub label: String,\n-    pub source_file_edits: Vec<SourceFileEdit>,\n-    pub file_system_edits: Vec<FileSystemEdit>,\n-    pub cursor_position: Option<FilePosition>,\n-}\n-\n-impl SourceChange {\n-    /// Creates a new SourceChange with the given label\n-    /// from the edits.\n-    pub(crate) fn from_edits<L: Into<String>>(\n-        label: L,\n-        source_file_edits: Vec<SourceFileEdit>,\n-        file_system_edits: Vec<FileSystemEdit>,\n-    ) -> Self {\n-        SourceChange {\n-            label: label.into(),\n-            source_file_edits,\n-            file_system_edits,\n-            cursor_position: None,\n-        }\n-    }\n-\n-    /// Creates a new SourceChange with the given label,\n-    /// containing only the given `SourceFileEdits`.\n-    pub(crate) fn source_file_edits<L: Into<String>>(label: L, edits: Vec<SourceFileEdit>) -> Self {\n-        SourceChange {\n-            label: label.into(),\n-            source_file_edits: edits,\n-            file_system_edits: vec![],\n-            cursor_position: None,\n-        }\n-    }\n-\n-    /// Creates a new SourceChange with the given label,\n-    /// containing only the given `FileSystemEdits`.\n-    pub(crate) fn file_system_edits<L: Into<String>>(label: L, edits: Vec<FileSystemEdit>) -> Self {\n-        SourceChange {\n-            label: label.into(),\n-            source_file_edits: vec![],\n-            file_system_edits: edits,\n-            cursor_position: None,\n-        }\n-    }\n-\n-    /// Creates a new SourceChange with the given label,\n-    /// containing only a single `SourceFileEdit`.\n-    pub(crate) fn source_file_edit<L: Into<String>>(label: L, edit: SourceFileEdit) -> Self {\n-        SourceChange::source_file_edits(label, vec![edit])\n-    }\n-\n-    /// Creates a new SourceChange with the given label\n-    /// from the given `FileId` and `TextEdit`\n-    pub(crate) fn source_file_edit_from<L: Into<String>>(\n-        label: L,\n-        file_id: FileId,\n-        edit: TextEdit,\n-    ) -> Self {\n-        SourceChange::source_file_edit(label, SourceFileEdit { file_id, edit })\n-    }\n-\n-    /// Creates a new SourceChange with the given label\n-    /// from the given `FileId` and `TextEdit`\n-    pub(crate) fn file_system_edit<L: Into<String>>(label: L, edit: FileSystemEdit) -> Self {\n-        SourceChange::file_system_edits(label, vec![edit])\n-    }\n-\n-    /// Sets the cursor position to the given `FilePosition`\n-    pub(crate) fn with_cursor(mut self, cursor_position: FilePosition) -> Self {\n-        self.cursor_position = Some(cursor_position);\n-        self\n-    }\n-\n-    /// Sets the cursor position to the given `FilePosition`\n-    pub(crate) fn with_cursor_opt(mut self, cursor_position: Option<FilePosition>) -> Self {\n-        self.cursor_position = cursor_position;\n-        self\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct SourceFileEdit {\n-    pub file_id: FileId,\n-    pub edit: TextEdit,\n-}\n-\n-#[derive(Debug)]\n-pub enum FileSystemEdit {\n-    CreateFile { source_root: SourceRootId, path: RelativePathBuf },\n-    MoveFile { src: FileId, dst_source_root: SourceRootId, dst_path: RelativePathBuf },\n-}\n-\n #[derive(Debug)]\n pub struct Diagnostic {\n     pub message: String,\n@@ -407,24 +314,20 @@ impl Analysis {\n         self.with_db(|db| typing::on_enter(&db, position))\n     }\n \n-    /// Returns an edit which should be applied after `=` was typed. Primarily,\n-    /// this works when adding `let =`.\n-    // FIXME: use a snippet completion instead of this hack here.\n-    pub fn on_eq_typed(&self, position: FilePosition) -> Cancelable<Option<SourceChange>> {\n-        self.with_db(|db| {\n-            let parse = db.parse(position.file_id);\n-            let file = parse.tree();\n-            let edit = typing::on_eq_typed(&file, position.offset)?;\n-            Some(SourceChange::source_file_edit(\n-                \"add semicolon\",\n-                SourceFileEdit { edit, file_id: position.file_id },\n-            ))\n-        })\n-    }\n-\n-    /// Returns an edit which should be applied when a dot ('.') is typed on a blank line, indenting the line appropriately.\n-    pub fn on_dot_typed(&self, position: FilePosition) -> Cancelable<Option<SourceChange>> {\n-        self.with_db(|db| typing::on_dot_typed(&db, position))\n+    /// Returns an edit which should be applied after a character was typed.\n+    ///\n+    /// This is useful for some on-the-fly fixups, like adding `;` to `let =`\n+    /// automatically.\n+    pub fn on_char_typed(\n+        &self,\n+        position: FilePosition,\n+        char_typed: char,\n+    ) -> Cancelable<Option<SourceChange>> {\n+        // Fast path to not even parse the file.\n+        if !typing::TRIGGER_CHARS.contains(char_typed) {\n+            return Ok(None);\n+        }\n+        self.with_db(|db| typing::on_char_typed(&db, position, char_typed))\n     }\n \n     /// Returns a tree representation of symbols in the file. Useful to draw a"}, {"sha": "4e63bbf6f0c891c7e259cb61d3e11c83867fa8da", "filename": "crates/ra_ide_api/src/source_change.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/5f779f6c46f29c63483c0e2be732377b1b87e685/crates%2Fra_ide_api%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f779f6c46f29c63483c0e2be732377b1b87e685/crates%2Fra_ide_api%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsource_change.rs?ref=5f779f6c46f29c63483c0e2be732377b1b87e685", "patch": "@@ -0,0 +1,119 @@\n+//! This modules defines type to represent changes to the source code, that flow\n+//! from the server to the client.\n+//!\n+//! It can be viewed as a dual for `AnalysisChange`.\n+\n+use ra_text_edit::TextEdit;\n+use relative_path::RelativePathBuf;\n+\n+use crate::{FileId, FilePosition, SourceRootId, TextUnit};\n+\n+#[derive(Debug)]\n+pub struct SourceChange {\n+    pub label: String,\n+    pub source_file_edits: Vec<SourceFileEdit>,\n+    pub file_system_edits: Vec<FileSystemEdit>,\n+    pub cursor_position: Option<FilePosition>,\n+}\n+\n+impl SourceChange {\n+    /// Creates a new SourceChange with the given label\n+    /// from the edits.\n+    pub(crate) fn from_edits<L: Into<String>>(\n+        label: L,\n+        source_file_edits: Vec<SourceFileEdit>,\n+        file_system_edits: Vec<FileSystemEdit>,\n+    ) -> Self {\n+        SourceChange {\n+            label: label.into(),\n+            source_file_edits,\n+            file_system_edits,\n+            cursor_position: None,\n+        }\n+    }\n+\n+    /// Creates a new SourceChange with the given label,\n+    /// containing only the given `SourceFileEdits`.\n+    pub(crate) fn source_file_edits<L: Into<String>>(label: L, edits: Vec<SourceFileEdit>) -> Self {\n+        SourceChange {\n+            label: label.into(),\n+            source_file_edits: edits,\n+            file_system_edits: vec![],\n+            cursor_position: None,\n+        }\n+    }\n+\n+    /// Creates a new SourceChange with the given label,\n+    /// containing only the given `FileSystemEdits`.\n+    pub(crate) fn file_system_edits<L: Into<String>>(label: L, edits: Vec<FileSystemEdit>) -> Self {\n+        SourceChange {\n+            label: label.into(),\n+            source_file_edits: vec![],\n+            file_system_edits: edits,\n+            cursor_position: None,\n+        }\n+    }\n+\n+    /// Creates a new SourceChange with the given label,\n+    /// containing only a single `SourceFileEdit`.\n+    pub(crate) fn source_file_edit<L: Into<String>>(label: L, edit: SourceFileEdit) -> Self {\n+        SourceChange::source_file_edits(label, vec![edit])\n+    }\n+\n+    /// Creates a new SourceChange with the given label\n+    /// from the given `FileId` and `TextEdit`\n+    pub(crate) fn source_file_edit_from<L: Into<String>>(\n+        label: L,\n+        file_id: FileId,\n+        edit: TextEdit,\n+    ) -> Self {\n+        SourceChange::source_file_edit(label, SourceFileEdit { file_id, edit })\n+    }\n+\n+    /// Creates a new SourceChange with the given label\n+    /// from the given `FileId` and `TextEdit`\n+    pub(crate) fn file_system_edit<L: Into<String>>(label: L, edit: FileSystemEdit) -> Self {\n+        SourceChange::file_system_edits(label, vec![edit])\n+    }\n+\n+    /// Sets the cursor position to the given `FilePosition`\n+    pub(crate) fn with_cursor(mut self, cursor_position: FilePosition) -> Self {\n+        self.cursor_position = Some(cursor_position);\n+        self\n+    }\n+\n+    /// Sets the cursor position to the given `FilePosition`\n+    pub(crate) fn with_cursor_opt(mut self, cursor_position: Option<FilePosition>) -> Self {\n+        self.cursor_position = cursor_position;\n+        self\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct SourceFileEdit {\n+    pub file_id: FileId,\n+    pub edit: TextEdit,\n+}\n+\n+#[derive(Debug)]\n+pub enum FileSystemEdit {\n+    CreateFile { source_root: SourceRootId, path: RelativePathBuf },\n+    MoveFile { src: FileId, dst_source_root: SourceRootId, dst_path: RelativePathBuf },\n+}\n+\n+pub(crate) struct SingleFileChange {\n+    pub label: String,\n+    pub edit: TextEdit,\n+    pub cursor_position: Option<TextUnit>,\n+}\n+\n+impl SingleFileChange {\n+    pub(crate) fn into_source_change(self, file_id: FileId) -> SourceChange {\n+        SourceChange {\n+            label: self.label,\n+            source_file_edits: vec![SourceFileEdit { file_id, edit: self.edit }],\n+            file_system_edits: Vec::new(),\n+            cursor_position: self.cursor_position.map(|offset| FilePosition { file_id, offset }),\n+        }\n+    }\n+}"}, {"sha": "26a3111fd80dbfba97092dd11e89cac466c41d0a", "filename": "crates/ra_ide_api/src/typing.rs", "status": "modified", "additions": 193, "deletions": 159, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/5f779f6c46f29c63483c0e2be732377b1b87e685/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f779f6c46f29c63483c0e2be732377b1b87e685/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs?ref=5f779f6c46f29c63483c0e2be732377b1b87e685", "patch": "@@ -1,4 +1,17 @@\n-//! FIXME: write short doc here\n+//! This module handles auto-magic editing actions applied together with users\n+//! edits. For example, if the user typed\n+//!\n+//! ```text\n+//!     foo\n+//!         .bar()\n+//!         .baz()\n+//!     |   // <- cursor is here\n+//! ```\n+//!\n+//! and types `.` next, we want to indent the dot.\n+//!\n+//! Language server executes such typing assists synchronously. That is, they\n+//! block user's typing and should be pretty fast for this reason!\n \n use ra_db::{FilePosition, SourceDatabase};\n use ra_fmt::leading_indent;\n@@ -11,7 +24,7 @@ use ra_syntax::{\n };\n use ra_text_edit::{TextEdit, TextEditBuilder};\n \n-use crate::{db::RootDatabase, SourceChange, SourceFileEdit};\n+use crate::{db::RootDatabase, source_change::SingleFileChange, SourceChange, SourceFileEdit};\n \n pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<SourceChange> {\n     let parse = db.parse(position.file_id);\n@@ -68,39 +81,67 @@ fn node_indent(file: &SourceFile, token: &SyntaxToken) -> Option<SmolStr> {\n     Some(text[pos..].into())\n }\n \n-pub fn on_eq_typed(file: &SourceFile, eq_offset: TextUnit) -> Option<TextEdit> {\n-    assert_eq!(file.syntax().text().char_at(eq_offset), Some('='));\n-    let let_stmt: ast::LetStmt = find_node_at_offset(file.syntax(), eq_offset)?;\n+pub(crate) const TRIGGER_CHARS: &str = \".=>\";\n+\n+pub(crate) fn on_char_typed(\n+    db: &RootDatabase,\n+    position: FilePosition,\n+    char_typed: char,\n+) -> Option<SourceChange> {\n+    assert!(TRIGGER_CHARS.contains(char_typed));\n+    let file = &db.parse(position.file_id).tree();\n+    assert_eq!(file.syntax().text().char_at(position.offset), Some(char_typed));\n+    let single_file_change = on_char_typed_inner(file, position.offset, char_typed)?;\n+    Some(single_file_change.into_source_change(position.file_id))\n+}\n+\n+fn on_char_typed_inner(\n+    file: &SourceFile,\n+    offset: TextUnit,\n+    char_typed: char,\n+) -> Option<SingleFileChange> {\n+    assert!(TRIGGER_CHARS.contains(char_typed));\n+    match char_typed {\n+        '.' => on_dot_typed(file, offset),\n+        '=' => on_eq_typed(file, offset),\n+        '>' => on_arrow_typed(file, offset),\n+        _ => unreachable!(),\n+    }\n+}\n+\n+/// Returns an edit which should be applied after `=` was typed. Primarily,\n+/// this works when adding `let =`.\n+// FIXME: use a snippet completion instead of this hack here.\n+fn on_eq_typed(file: &SourceFile, offset: TextUnit) -> Option<SingleFileChange> {\n+    assert_eq!(file.syntax().text().char_at(offset), Some('='));\n+    let let_stmt: ast::LetStmt = find_node_at_offset(file.syntax(), offset)?;\n     if let_stmt.has_semi() {\n         return None;\n     }\n     if let Some(expr) = let_stmt.initializer() {\n         let expr_range = expr.syntax().text_range();\n-        if expr_range.contains(eq_offset) && eq_offset != expr_range.start() {\n+        if expr_range.contains(offset) && offset != expr_range.start() {\n             return None;\n         }\n-        if file.syntax().text().slice(eq_offset..expr_range.start()).contains_char('\\n') {\n+        if file.syntax().text().slice(offset..expr_range.start()).contains_char('\\n') {\n             return None;\n         }\n     } else {\n         return None;\n     }\n     let offset = let_stmt.syntax().text_range().end();\n-    let mut edit = TextEditBuilder::default();\n-    edit.insert(offset, \";\".to_string());\n-    Some(edit.finish())\n+    Some(SingleFileChange {\n+        label: \"add semicolon\".to_string(),\n+        edit: TextEdit::insert(offset, \";\".to_string()),\n+        cursor_position: None,\n+    })\n }\n \n-pub(crate) fn on_dot_typed(db: &RootDatabase, position: FilePosition) -> Option<SourceChange> {\n-    let parse = db.parse(position.file_id);\n-    assert_eq!(parse.tree().syntax().text().char_at(position.offset), Some('.'));\n-\n-    let whitespace = parse\n-        .tree()\n-        .syntax()\n-        .token_at_offset(position.offset)\n-        .left_biased()\n-        .and_then(ast::Whitespace::cast)?;\n+/// Returns an edit which should be applied when a dot ('.') is typed on a blank line, indenting the line appropriately.\n+fn on_dot_typed(file: &SourceFile, offset: TextUnit) -> Option<SingleFileChange> {\n+    assert_eq!(file.syntax().text().char_at(offset), Some('.'));\n+    let whitespace =\n+        file.syntax().token_at_offset(offset).left_biased().and_then(ast::Whitespace::cast)?;\n \n     let current_indent = {\n         let text = whitespace.text();\n@@ -117,20 +158,36 @@ pub(crate) fn on_dot_typed(db: &RootDatabase, position: FilePosition) -> Option<\n     if current_indent_len == target_indent_len {\n         return None;\n     }\n-    let mut edit = TextEditBuilder::default();\n-    edit.replace(\n-        TextRange::from_to(position.offset - current_indent_len, position.offset),\n-        target_indent,\n-    );\n-\n-    let res = SourceChange::source_file_edit_from(\"reindent dot\", position.file_id, edit.finish())\n-        .with_cursor(FilePosition {\n-            offset: position.offset + target_indent_len - current_indent_len\n-                + TextUnit::of_char('.'),\n-            file_id: position.file_id,\n-        });\n-\n-    Some(res)\n+\n+    Some(SingleFileChange {\n+        label: \"reindent dot\".to_string(),\n+        edit: TextEdit::replace(\n+            TextRange::from_to(offset - current_indent_len, offset),\n+            target_indent,\n+        ),\n+        cursor_position: Some(\n+            offset + target_indent_len - current_indent_len + TextUnit::of_char('.'),\n+        ),\n+    })\n+}\n+\n+/// Adds a space after an arrow when `fn foo() { ... }` is turned into `fn foo() -> { ... }`\n+fn on_arrow_typed(file: &SourceFile, offset: TextUnit) -> Option<SingleFileChange> {\n+    let file_text = file.syntax().text();\n+    assert_eq!(file_text.char_at(offset), Some('>'));\n+    let after_arrow = offset + TextUnit::of_char('>');\n+    if file_text.char_at(after_arrow) != Some('{') {\n+        return None;\n+    }\n+    if find_node_at_offset::<ast::RetType>(file.syntax(), offset).is_none() {\n+        return None;\n+    }\n+\n+    Some(SingleFileChange {\n+        label: \"add space after return type\".to_string(),\n+        edit: TextEdit::insert(after_arrow, \" \".to_string()),\n+        cursor_position: Some(after_arrow),\n+    })\n }\n \n #[cfg(test)]\n@@ -142,21 +199,87 @@ mod tests {\n     use super::*;\n \n     #[test]\n-    fn test_on_eq_typed() {\n-        fn type_eq(before: &str, after: &str) {\n+    fn test_on_enter() {\n+        fn apply_on_enter(before: &str) -> Option<String> {\n             let (offset, before) = extract_offset(before);\n-            let mut edit = TextEditBuilder::default();\n-            edit.insert(offset, \"=\".to_string());\n-            let before = edit.finish().apply(&before);\n-            let parse = SourceFile::parse(&before);\n-            if let Some(result) = on_eq_typed(&parse.tree(), offset) {\n-                let actual = result.apply(&before);\n-                assert_eq_text!(after, &actual);\n-            } else {\n-                assert_eq_text!(&before, after)\n-            };\n+            let (analysis, file_id) = single_file(&before);\n+            let result = analysis.on_enter(FilePosition { offset, file_id }).unwrap()?;\n+\n+            assert_eq!(result.source_file_edits.len(), 1);\n+            let actual = result.source_file_edits[0].edit.apply(&before);\n+            let actual = add_cursor(&actual, result.cursor_position.unwrap().offset);\n+            Some(actual)\n+        }\n+\n+        fn do_check(before: &str, after: &str) {\n+            let actual = apply_on_enter(before).unwrap();\n+            assert_eq_text!(after, &actual);\n+        }\n+\n+        fn do_check_noop(text: &str) {\n+            assert!(apply_on_enter(text).is_none())\n+        }\n+\n+        do_check(\n+            r\"\n+/// Some docs<|>\n+fn foo() {\n+}\n+\",\n+            r\"\n+/// Some docs\n+/// <|>\n+fn foo() {\n+}\n+\",\n+        );\n+        do_check(\n+            r\"\n+impl S {\n+    /// Some<|> docs.\n+    fn foo() {}\n+}\n+\",\n+            r\"\n+impl S {\n+    /// Some\n+    /// <|> docs.\n+    fn foo() {}\n+}\n+\",\n+        );\n+        do_check_noop(r\"<|>//! docz\");\n+    }\n+\n+    fn do_type_char(char_typed: char, before: &str) -> Option<(String, SingleFileChange)> {\n+        let (offset, before) = extract_offset(before);\n+        let edit = TextEdit::insert(offset, char_typed.to_string());\n+        let before = edit.apply(&before);\n+        let parse = SourceFile::parse(&before);\n+        on_char_typed_inner(&parse.tree(), offset, char_typed)\n+            .map(|it| (it.edit.apply(&before), it))\n+    }\n+\n+    fn type_char(char_typed: char, before: &str, after: &str) {\n+        let (actual, file_change) = do_type_char(char_typed, before)\n+            .expect(&format!(\"typing `{}` did nothing\", char_typed));\n+\n+        if after.contains(\"<|>\") {\n+            let (offset, after) = extract_offset(after);\n+            assert_eq_text!(&after, &actual);\n+            assert_eq!(file_change.cursor_position, Some(offset))\n+        } else {\n+            assert_eq_text!(after, &actual);\n         }\n+    }\n \n+    fn type_char_noop(char_typed: char, before: &str) {\n+        let file_change = do_type_char(char_typed, before);\n+        assert!(file_change.is_none())\n+    }\n+\n+    #[test]\n+    fn test_on_eq_typed() {\n         //     do_check(r\"\n         // fn foo() {\n         //     let foo =<|>\n@@ -166,7 +289,8 @@ mod tests {\n         //     let foo =;\n         // }\n         // \");\n-        type_eq(\n+        type_char(\n+            '=',\n             r\"\n fn foo() {\n     let foo <|> 1 + 1\n@@ -191,24 +315,10 @@ fn foo() {\n         // \");\n     }\n \n-    fn type_dot(before: &str, after: &str) {\n-        let (offset, before) = extract_offset(before);\n-        let mut edit = TextEditBuilder::default();\n-        edit.insert(offset, \".\".to_string());\n-        let before = edit.finish().apply(&before);\n-        let (analysis, file_id) = single_file(&before);\n-        if let Some(result) = analysis.on_dot_typed(FilePosition { offset, file_id }).unwrap() {\n-            assert_eq!(result.source_file_edits.len(), 1);\n-            let actual = result.source_file_edits[0].edit.apply(&before);\n-            assert_eq_text!(after, &actual);\n-        } else {\n-            assert_eq_text!(&before, after)\n-        };\n-    }\n-\n     #[test]\n     fn indents_new_chain_call() {\n-        type_dot(\n+        type_char(\n+            '.',\n             r\"\n             pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n                 self.child_impl(db, name)\n@@ -222,25 +332,21 @@ fn foo() {\n             }\n             \",\n         );\n-        type_dot(\n+        type_char_noop(\n+            '.',\n             r\"\n             pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n                 self.child_impl(db, name)\n                     <|>\n             }\n             \",\n-            r\"\n-            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-                self.child_impl(db, name)\n-                    .\n-            }\n-            \",\n         )\n     }\n \n     #[test]\n     fn indents_new_chain_call_with_semi() {\n-        type_dot(\n+        type_char(\n+            '.',\n             r\"\n             pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n                 self.child_impl(db, name)\n@@ -254,25 +360,21 @@ fn foo() {\n             }\n             \",\n         );\n-        type_dot(\n+        type_char_noop(\n+            '.',\n             r\"\n             pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n                 self.child_impl(db, name)\n                     <|>;\n             }\n             \",\n-            r\"\n-            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-                self.child_impl(db, name)\n-                    .;\n-            }\n-            \",\n         )\n     }\n \n     #[test]\n     fn indents_continued_chain_call() {\n-        type_dot(\n+        type_char(\n+            '.',\n             r\"\n             pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n                 self.child_impl(db, name)\n@@ -288,27 +390,22 @@ fn foo() {\n             }\n             \",\n         );\n-        type_dot(\n+        type_char_noop(\n+            '.',\n             r\"\n             pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n                 self.child_impl(db, name)\n                     .first()\n                     <|>\n             }\n             \",\n-            r\"\n-            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-                self.child_impl(db, name)\n-                    .first()\n-                    .\n-            }\n-            \",\n         );\n     }\n \n     #[test]\n     fn indents_middle_of_chain_call() {\n-        type_dot(\n+        type_char(\n+            '.',\n             r\"\n             fn source_impl() {\n                 let var = enum_defvariant_list().unwrap()\n@@ -326,7 +423,8 @@ fn foo() {\n             }\n             \",\n         );\n-        type_dot(\n+        type_char_noop(\n+            '.',\n             r\"\n             fn source_impl() {\n                 let var = enum_defvariant_list().unwrap()\n@@ -335,95 +433,31 @@ fn foo() {\n                     .unwrap();\n             }\n             \",\n-            r\"\n-            fn source_impl() {\n-                let var = enum_defvariant_list().unwrap()\n-                    .\n-                    .nth(92)\n-                    .unwrap();\n-            }\n-            \",\n         );\n     }\n \n     #[test]\n     fn dont_indent_freestanding_dot() {\n-        type_dot(\n+        type_char_noop(\n+            '.',\n             r\"\n             pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n                 <|>\n             }\n             \",\n-            r\"\n-            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-                .\n-            }\n-            \",\n         );\n-        type_dot(\n+        type_char_noop(\n+            '.',\n             r\"\n             pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n             <|>\n             }\n             \",\n-            r\"\n-            pub fn child(&self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<Module>> {\n-            .\n-            }\n-            \",\n         );\n     }\n \n     #[test]\n-    fn test_on_enter() {\n-        fn apply_on_enter(before: &str) -> Option<String> {\n-            let (offset, before) = extract_offset(before);\n-            let (analysis, file_id) = single_file(&before);\n-            let result = analysis.on_enter(FilePosition { offset, file_id }).unwrap()?;\n-\n-            assert_eq!(result.source_file_edits.len(), 1);\n-            let actual = result.source_file_edits[0].edit.apply(&before);\n-            let actual = add_cursor(&actual, result.cursor_position.unwrap().offset);\n-            Some(actual)\n-        }\n-\n-        fn do_check(before: &str, after: &str) {\n-            let actual = apply_on_enter(before).unwrap();\n-            assert_eq_text!(after, &actual);\n-        }\n-\n-        fn do_check_noop(text: &str) {\n-            assert!(apply_on_enter(text).is_none())\n-        }\n-\n-        do_check(\n-            r\"\n-/// Some docs<|>\n-fn foo() {\n-}\n-\",\n-            r\"\n-/// Some docs\n-/// <|>\n-fn foo() {\n-}\n-\",\n-        );\n-        do_check(\n-            r\"\n-impl S {\n-    /// Some<|> docs.\n-    fn foo() {}\n-}\n-\",\n-            r\"\n-impl S {\n-    /// Some\n-    /// <|> docs.\n-    fn foo() {}\n-}\n-\",\n-        );\n-        do_check_noop(r\"<|>//! docz\");\n+    fn adds_space_after_return_type() {\n+        type_char('>', \"fn foo() -<|>{ 92 }\", \"fn foo() -><|> { 92 }\")\n     }\n }"}, {"sha": "eea0965edbea6d77ea1eaf4828e685b490c2a6d2", "filename": "crates/ra_lsp_server/src/caps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f779f6c46f29c63483c0e2be732377b1b87e685/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f779f6c46f29c63483c0e2be732377b1b87e685/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs?ref=5f779f6c46f29c63483c0e2be732377b1b87e685", "patch": "@@ -38,7 +38,7 @@ pub fn server_capabilities() -> ServerCapabilities {\n         document_range_formatting_provider: None,\n         document_on_type_formatting_provider: Some(DocumentOnTypeFormattingOptions {\n             first_trigger_character: \"=\".to_string(),\n-            more_trigger_character: Some(vec![\".\".to_string()]),\n+            more_trigger_character: Some(vec![\".\".to_string(), \">\".to_string()]),\n         }),\n         selection_range_provider: Some(GenericCapability::default()),\n         folding_range_provider: Some(FoldingRangeProviderCapability::Simple(true)),"}, {"sha": "16fb0726600a754b867601fe9b265a657d4d3502", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5f779f6c46f29c63483c0e2be732377b1b87e685/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f779f6c46f29c63483c0e2be732377b1b87e685/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=5f779f6c46f29c63483c0e2be732377b1b87e685", "patch": "@@ -132,6 +132,7 @@ pub fn handle_on_enter(\n     }\n }\n \n+// Don't forget to add new trigger characters to `ServerCapabilities` in `caps.rs`.\n pub fn handle_on_type_formatting(\n     world: WorldSnapshot,\n     params: req::DocumentOnTypeFormattingParams,\n@@ -144,12 +145,17 @@ pub fn handle_on_type_formatting(\n     // in `ra_ide_api`, the `on_type` invariant is that\n     // `text.char_at(position) == typed_char`.\n     position.offset = position.offset - TextUnit::of_char('.');\n+    let char_typed = params.ch.chars().next().unwrap_or('\\0');\n \n-    let edit = match params.ch.as_str() {\n-        \"=\" => world.analysis().on_eq_typed(position),\n-        \".\" => world.analysis().on_dot_typed(position),\n-        _ => return Ok(None),\n-    }?;\n+    // We have an assist that inserts ` ` after typing `->` in `fn foo() ->{`,\n+    // but it requires precise cursor positioning to work, and one can't\n+    // position the cursor with on_type formatting. So, let's just toggle this\n+    // feature off here, hoping that we'll enable it one day, \ud83d\ude3f.\n+    if char_typed == '>' {\n+        return Ok(None);\n+    }\n+\n+    let edit = world.analysis().on_char_typed(position, char_typed)?;\n     let mut edit = match edit {\n         Some(it) => it,\n         None => return Ok(None),"}, {"sha": "413c7d782eb588464a778ce177346fae87f12fc1", "filename": "crates/ra_text_edit/src/text_edit.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5f779f6c46f29c63483c0e2be732377b1b87e685/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f779f6c46f29c63483c0e2be732377b1b87e685/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs?ref=5f779f6c46f29c63483c0e2be732377b1b87e685", "patch": "@@ -32,6 +32,24 @@ impl TextEditBuilder {\n }\n \n impl TextEdit {\n+    pub fn insert(offset: TextUnit, text: String) -> TextEdit {\n+        let mut builder = TextEditBuilder::default();\n+        builder.insert(offset, text);\n+        builder.finish()\n+    }\n+\n+    pub fn delete(range: TextRange) -> TextEdit {\n+        let mut builder = TextEditBuilder::default();\n+        builder.delete(range);\n+        builder.finish()\n+    }\n+\n+    pub fn replace(range: TextRange, replace_with: String) -> TextEdit {\n+        let mut builder = TextEditBuilder::default();\n+        builder.replace(range, replace_with);\n+        builder.finish()\n+    }\n+\n     pub(crate) fn from_atoms(mut atoms: Vec<AtomTextEdit>) -> TextEdit {\n         atoms.sort_by_key(|a| (a.delete.start(), a.delete.end()));\n         for (a1, a2) in atoms.iter().zip(atoms.iter().skip(1)) {"}]}