{"sha": "d340f28a815ba53a4d35801242eec7fca3718731", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzNDBmMjhhODE1YmE1M2E0ZDM1ODAxMjQyZWVjN2ZjYTM3MTg3MzE=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-06-20T16:34:43Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-06-20T17:12:06Z"}, "message": "test_utils: Make overlapping annotations possible", "tree": {"sha": "75591383ae02ea2bd5d99925759d3e6e73254ccd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75591383ae02ea2bd5d99925759d3e6e73254ccd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d340f28a815ba53a4d35801242eec7fca3718731", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d340f28a815ba53a4d35801242eec7fca3718731", "html_url": "https://github.com/rust-lang/rust/commit/d340f28a815ba53a4d35801242eec7fca3718731", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d340f28a815ba53a4d35801242eec7fca3718731/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04fbdce426ac8e618ac8b5d136c58cf3427bdd6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c", "html_url": "https://github.com/rust-lang/rust/commit/04fbdce426ac8e618ac8b5d136c58cf3427bdd6c"}], "stats": {"total": 50, "additions": 44, "deletions": 6}, "files": [{"sha": "d9c22c1803e1d5334864565545defbfce2149658", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d340f28a815ba53a4d35801242eec7fca3718731/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d340f28a815ba53a4d35801242eec7fca3718731/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=d340f28a815ba53a4d35801242eec7fca3718731", "patch": "@@ -11,6 +11,7 @@ mod fixture;\n mod assert_linear;\n \n use std::{\n+    collections::BTreeMap,\n     convert::{TryFrom, TryInto},\n     env, fs,\n     path::{Path, PathBuf},\n@@ -205,14 +206,25 @@ pub fn add_cursor(text: &str, offset: TextSize) -> String {\n ///\n /// // ^^^ first line\n /// //   | second line\n+///\n+/// Annotations point to the last line that actually was long enough for the\n+/// range, not counting annotations themselves. So overlapping annotations are\n+/// possible:\n+/// ```no_run\n+/// // stuff        other stuff\n+/// // ^^ 'st'\n+/// // ^^^^^ 'stuff'\n+/// //              ^^^^^^^^^^^ 'other stuff'\n+/// ```\n pub fn extract_annotations(text: &str) -> Vec<(TextRange, String)> {\n     let mut res = Vec::new();\n-    let mut prev_line_start: Option<TextSize> = Some(0.into());\n+    // map from line length to beginning of last line that had that length\n+    let mut line_start_map = BTreeMap::new();\n     let mut line_start: TextSize = 0.into();\n     let mut prev_line_annotations: Vec<(TextSize, usize)> = Vec::new();\n     for line in text.split_inclusive('\\n') {\n         let mut this_line_annotations = Vec::new();\n-        if let Some(idx) = line.find(\"//\") {\n+        let line_length = if let Some(idx) = line.find(\"//\") {\n             let annotation_offset = TextSize::of(&line[..idx + \"//\".len()]);\n             for annotation in extract_line_annotations(&line[idx + \"//\".len()..]) {\n                 match annotation {\n@@ -222,7 +234,9 @@ pub fn extract_annotations(text: &str) -> Vec<(TextRange, String)> {\n                         let range = if file {\n                             TextRange::up_to(TextSize::of(text))\n                         } else {\n-                            range + prev_line_start.unwrap()\n+                            let line_start = line_start_map.range(range.end()..).next().unwrap();\n+\n+                            range + line_start.1\n                         };\n                         res.push((range, content))\n                     }\n@@ -238,9 +252,14 @@ pub fn extract_annotations(text: &str) -> Vec<(TextRange, String)> {\n                     }\n                 }\n             }\n-        }\n+            idx.try_into().unwrap()\n+        } else {\n+            TextSize::of(line)\n+        };\n+\n+        line_start_map = line_start_map.split_off(&line_length);\n+        line_start_map.insert(line_length, line_start);\n \n-        prev_line_start = Some(line_start);\n         line_start += TextSize::of(line);\n \n         prev_line_annotations = this_line_annotations;\n@@ -296,7 +315,7 @@ fn extract_line_annotations(mut line: &str) -> Vec<LineAnnotation> {\n }\n \n #[test]\n-fn test_extract_annotations() {\n+fn test_extract_annotations_1() {\n     let text = stdx::trim_indent(\n         r#\"\n fn main() {\n@@ -321,6 +340,25 @@ fn main() {\n     assert_eq!(res[3].0.len(), 115);\n }\n \n+#[test]\n+fn test_extract_annotations_2() {\n+    let text = stdx::trim_indent(\n+        r#\"\n+fn main() {\n+    (x,   y);\n+   //^ a\n+      //  ^ b\n+  //^^^^^^^^ c\n+}\"#,\n+    );\n+    let res = extract_annotations(&text)\n+        .into_iter()\n+        .map(|(range, ann)| (&text[range], ann))\n+        .collect::<Vec<_>>();\n+\n+    assert_eq!(res, [(\"x\", \"a\".into()), (\"y\", \"b\".into()), (\"(x,   y)\", \"c\".into())]);\n+}\n+\n /// Returns `false` if slow tests should not run, otherwise returns `true` and\n /// also creates a file at `./target/.slow_tests_cookie` which serves as a flag\n /// that slow tests did run."}]}