{"sha": "45cf3cfde2c32f5b27c469ef1b5f04dd195fb462", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1Y2YzY2ZkZTJjMzJmNWIyN2M0NjllZjFiNWYwNGRkMTk1ZmI0NjI=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-08-27T07:44:46Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-08-27T07:44:54Z"}, "message": "Update for changes in rustc.", "tree": {"sha": "4524a8b652ea4cd37e75c669a0936a9f241760ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4524a8b652ea4cd37e75c669a0936a9f241760ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45cf3cfde2c32f5b27c469ef1b5f04dd195fb462", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45cf3cfde2c32f5b27c469ef1b5f04dd195fb462", "html_url": "https://github.com/rust-lang/rust/commit/45cf3cfde2c32f5b27c469ef1b5f04dd195fb462", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45cf3cfde2c32f5b27c469ef1b5f04dd195fb462/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2", "url": "https://api.github.com/repos/rust-lang/rust/commits/90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2", "html_url": "https://github.com/rust-lang/rust/commit/90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2"}], "stats": {"total": 229, "additions": 121, "deletions": 108}, "files": [{"sha": "0217a26fddd24ba0d01ca9ab56441268d1401143", "filename": "Cargo.lock", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/45cf3cfde2c32f5b27c469ef1b5f04dd195fb462/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/45cf3cfde2c32f5b27c469ef1b5f04dd195fb462/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=45cf3cfde2c32f5b27c469ef1b5f04dd195fb462", "patch": "@@ -3,8 +3,8 @@ name = \"miri\"\n version = \"0.1.0\"\n dependencies = [\n  \"byteorder 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiletest_rs 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"env_logger 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiletest_rs 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -24,7 +24,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"compiletest_rs\"\n-version = \"0.2.0\"\n+version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -33,19 +33,19 @@ dependencies = [\n \n [[package]]\n name = \"env_logger\"\n-version = \"0.3.3\"\n+version = \"0.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.1.71 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.1.73 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"kernel32-sys\"\n version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"winapi 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -56,7 +56,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.12\"\n+version = \"0.2.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -77,24 +77,24 @@ name = \"memchr\"\n version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"regex\"\n-version = \"0.1.71\"\n+version = \"0.1.73\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"aho-corasick 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex-syntax 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex-syntax 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"thread_local 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"regex-syntax\"\n-version = \"0.3.3\"\n+version = \"0.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -108,7 +108,7 @@ version = \"2.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -126,11 +126,30 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"winapi\"\n-version = \"0.2.7\"\n+version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"winapi-build\"\n version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[metadata]\n+\"checksum aho-corasick 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2b3fb52b09c1710b961acb35390d514be82e4ac96a9969a8e38565a29b878dc9\"\n+\"checksum byteorder 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"96c8b41881888cc08af32d47ac4edd52bc7fa27fef774be47a92443756451304\"\n+\"checksum compiletest_rs 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0bcddebf582c5c035cce855a89596eb686cc40b9e77da1026fba735dcca2fbd3\"\n+\"checksum env_logger 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"82dcb9ceed3868a03b335657b85a159736c961900f7e7747d3b0b97b9ccb5ccb\"\n+\"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n+\"checksum lazy_static 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"49247ec2a285bb3dcb23cbd9c35193c025e7251bfce77c1d5da97e6362dffe7f\"\n+\"checksum libc 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"23e3757828fa702a20072c37ff47938e9dd331b92fac6e223d26d4b7a55f7ee2\"\n+\"checksum log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab83497bf8bf4ed2a74259c1c802351fcd67a65baa86394b6ba73c36f4838054\"\n+\"checksum log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3d382732ea0fbc09790c4899db3255bdea0fc78b54bf234bd18a63bb603915b6\"\n+\"checksum memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d8b629fb514376c675b98c1421e80b151d3817ac42d7c667717d282761418d20\"\n+\"checksum regex 0.1.73 (registry+https://github.com/rust-lang/crates.io-index)\" = \"56b7ee9f764ecf412c6e2fff779bca4b22980517ae335a21aeaf4e32625a5df2\"\n+\"checksum regex-syntax 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"31040aad7470ad9d8c46302dcffba337bb4289ca5da2e3cd6e37b64109a85199\"\n+\"checksum rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6159e4e6e559c81bd706afe9c8fd68f547d3e851ce12e76b1de7914bab61691b\"\n+\"checksum thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a9539db560102d1cef46b8b78ce737ff0bb64e7e18d35b2a5688f7d097d0ff03\"\n+\"checksum thread_local 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"55dd963dbaeadc08aa7266bf7f91c3154a7805e32bb94b820b769d2ef3b4744d\"\n+\"checksum utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a1ca13c08c41c9c3e04224ed9ff80461d97e121589ff27c753a16cb10830ae0f\"\n+\"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n+\"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\""}, {"sha": "728266a755d64c998040ca9b9ffece70d24b0bc5", "filename": "src/bin/miri.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/45cf3cfde2c32f5b27c469ef1b5f04dd195fb462/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cf3cfde2c32f5b27c469ef1b5f04dd195fb462/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=45cf3cfde2c32f5b27c469ef1b5f04dd195fb462", "patch": "@@ -33,8 +33,9 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n \n             let tcx = state.tcx.unwrap();\n             let mir_map = state.mir_map.unwrap();\n-            let (node_id, _) = state.session.entry_fn.borrow()\n+            let (entry_node_id, _) = state.session.entry_fn.borrow()\n                 .expect(\"no main or start function found\");\n+            let entry_def_id = tcx.map.local_def_id(entry_node_id);\n \n             let krate = state.hir_crate.as_ref().unwrap();\n             let mut memory_size = 100*1024*1024; // 100MB\n@@ -66,9 +67,12 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n                 }\n             }\n \n-            let mut mir_map = MirMap { map: mir_map.map.clone() };\n-            run_mir_passes(tcx, &mut mir_map);\n-            eval_main(tcx, &mir_map, node_id, memory_size, step_limit, stack_limit);\n+            let mut mir_map_copy = MirMap::new(tcx.dep_graph.clone());\n+            for def_id in mir_map.map.keys() {\n+                mir_map_copy.map.insert(def_id, mir_map.map.get(&def_id).unwrap().clone());\n+            }\n+            run_mir_passes(tcx, &mut mir_map_copy);\n+            eval_main(tcx, &mir_map_copy, entry_def_id, memory_size, step_limit, stack_limit);\n \n             state.session.abort_if_errors();\n         });"}, {"sha": "5ef423f21fb417b6b1c6eb9c428de8e1d63d8683", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 29, "deletions": 39, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/45cf3cfde2c32f5b27c469ef1b5f04dd195fb462/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cf3cfde2c32f5b27c469ef1b5f04dd195fb462/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=45cf3cfde2c32f5b27c469ef1b5f04dd195fb462", "patch": "@@ -2,7 +2,7 @@ use rustc::middle::const_val;\n use rustc::hir::def_id::DefId;\n use rustc::mir::mir_map::MirMap;\n use rustc::mir::repr as mir;\n-use rustc::traits::ProjectionMode;\n+use rustc::traits::Reveal;\n use rustc::ty::layout::{self, Layout, Size};\n use rustc::ty::subst::{self, Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -12,7 +12,6 @@ use std::cell::RefCell;\n use std::ops::Deref;\n use std::rc::Rc;\n use std::iter;\n-use syntax::ast;\n use syntax::codemap::{self, DUMMY_SP};\n \n use error::{EvalError, EvalResult};\n@@ -148,15 +147,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn alloc_ret_ptr(&mut self, output_ty: ty::FnOutput<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, Option<Pointer>> {\n-        match output_ty {\n-            ty::FnConverging(ty) => {\n-                let size = self.type_size_with_substs(ty, substs);\n-                let align = self.type_align_with_substs(ty, substs);\n-                self.memory.allocate(size, align).map(Some)\n-            }\n-            ty::FnDiverging => Ok(None),\n-        }\n+    pub fn alloc_ret_ptr(&mut self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, Pointer> {\n+        let size = self.type_size_with_substs(ty, substs);\n+        let align = self.type_align_with_substs(ty, substs);\n+        self.memory.allocate(size, align)\n     }\n \n     pub fn memory(&self) -> &Memory<'a, 'tcx> {\n@@ -251,22 +245,21 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     pub fn load_mir(&self, def_id: DefId) -> CachedMir<'a, 'tcx> {\n-        match self.tcx.map.as_local_node_id(def_id) {\n-            Some(node_id) => CachedMir::Ref(self.mir_map.map.get(&node_id).unwrap()),\n-            None => {\n-                let mut mir_cache = self.mir_cache.borrow_mut();\n-                if let Some(mir) = mir_cache.get(&def_id) {\n-                    return CachedMir::Owned(mir.clone());\n-                }\n-\n-                let cs = &self.tcx.sess.cstore;\n-                let mir = cs.maybe_get_item_mir(self.tcx, def_id).unwrap_or_else(|| {\n-                    panic!(\"no mir for `{}`\", self.tcx.item_path_str(def_id));\n-                });\n-                let cached = Rc::new(mir);\n-                mir_cache.insert(def_id, cached.clone());\n-                CachedMir::Owned(cached)\n+        if def_id.is_local() {\n+            CachedMir::Ref(self.mir_map.map.get(&def_id).unwrap())\n+        } else {\n+            let mut mir_cache = self.mir_cache.borrow_mut();\n+            if let Some(mir) = mir_cache.get(&def_id) {\n+                return CachedMir::Owned(mir.clone());\n             }\n+\n+            let cs = &self.tcx.sess.cstore;\n+            let mir = cs.maybe_get_item_mir(self.tcx, def_id).unwrap_or_else(|| {\n+                panic!(\"no mir for `{}`\", self.tcx.item_path_str(def_id));\n+            });\n+            let cached = Rc::new(mir);\n+            mir_cache.insert(def_id, cached.clone());\n+            CachedMir::Owned(cached)\n         }\n     }\n \n@@ -299,7 +292,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // TODO(solson): Is this inefficient? Needs investigation.\n         let ty = self.monomorphize(ty, substs);\n \n-        self.tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+        self.tcx.normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n             // TODO(solson): Report this error properly.\n             ty.layout(&infcx).unwrap()\n         })\n@@ -755,7 +748,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Temp(i) => self.frame().locals[self.frame().temp_offset + i.index()],\n \n             Static(def_id) => {\n-                let substs = self.tcx.mk_substs(subst::Substs::empty());\n+                let substs = subst::Substs::empty(self.tcx);\n                 let cid = ConstantId {\n                     def_id: def_id,\n                     substs: substs,\n@@ -846,11 +839,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n-        self.monomorphize(self.mir().lvalue_ty(self.tcx, lvalue).to_ty(self.tcx), self.substs())\n+        self.monomorphize(lvalue.ty(&self.mir(), self.tcx).to_ty(self.tcx), self.substs())\n     }\n \n     fn operand_ty(&self, operand: &mir::Operand<'tcx>) -> Ty<'tcx> {\n-        self.monomorphize(self.mir().operand_ty(self.tcx, operand), self.substs())\n+        self.monomorphize(operand.ty(&self.mir(), self.tcx), self.substs())\n     }\n \n     fn move_(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n@@ -961,21 +954,19 @@ impl<'mir, 'tcx: 'mir> Deref for CachedMir<'mir, 'tcx> {\n pub fn eval_main<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir_map: &'a MirMap<'tcx>,\n-    node_id: ast::NodeId,\n+    def_id: DefId,\n     memory_size: usize,\n     step_limit: u64,\n     stack_limit: usize,\n ) {\n-    let mir = mir_map.map.get(&node_id).expect(\"no mir for main function\");\n-    let def_id = tcx.map.local_def_id(node_id);\n+    let mir = mir_map.map.get(&def_id).expect(\"no mir for main function\");\n     let mut ecx = EvalContext::new(tcx, mir_map, memory_size, stack_limit);\n-    let substs = tcx.mk_substs(subst::Substs::empty());\n+    let substs = subst::Substs::empty(tcx);\n     let return_ptr = ecx.alloc_ret_ptr(mir.return_ty, substs)\n-                        .expect(\"should at least be able to allocate space for the main function's return value\")\n-                        .expect(\"main function should not be diverging\");\n+        .expect(\"should at least be able to allocate space for the main function's return value\");\n \n     ecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, Some(return_ptr))\n-       .expect(\"could not allocate first stack frame\");\n+        .expect(\"could not allocate first stack frame\");\n \n     if mir.arg_decls.len() == 2 {\n         // start function\n@@ -1018,8 +1009,7 @@ fn report(tcx: TyCtxt, ecx: &EvalContext, e: EvalError) {\n         struct Instance<'tcx>(DefId, &'tcx subst::Substs<'tcx>);\n         impl<'tcx> fmt::Display for Instance<'tcx> {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                ppaux::parameterized(f, self.1, self.0, ppaux::Ns::Value, &[],\n-                    |tcx| Some(tcx.lookup_item_type(self.0).generics))\n+                ppaux::parameterized(f, self.1, self.0, ppaux::Ns::Value, &[])\n             }\n         }\n         err.span_note(span, &format!(\"inside call to {}\", Instance(def_id, substs)));"}, {"sha": "75dc7ee0941cc9a53e8232208f6c68d2c136b2f6", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45cf3cfde2c32f5b27c469ef1b5f04dd195fb462/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cf3cfde2c32f5b27c469ef1b5f04dd195fb462/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=45cf3cfde2c32f5b27c469ef1b5f04dd195fb462", "patch": "@@ -66,8 +66,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> EvalResult<'tcx, ()> {\n         trace!(\"{:?}\", stmt);\n-        let mir::StatementKind::Assign(ref lvalue, ref rvalue) = stmt.kind;\n-        self.eval_assignment(lvalue, rvalue)?;\n+\n+        use rustc::mir::repr::StatementKind::*;\n+        match stmt.kind {\n+            Assign(ref lvalue, ref rvalue) => self.eval_assignment(lvalue, rvalue)?,\n+            SetDiscriminant { .. } => unimplemented!(),\n+\n+            // Miri can safely ignore these. Only translation needs them.\n+            StorageLive(_) | StorageDead(_) => {}\n+        }\n+\n         self.frame_mut().stmt += 1;\n         Ok(())\n     }\n@@ -110,7 +118,6 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n         let mir = self.ecx.load_mir(def_id);\n         self.try(|this| {\n             let ptr = this.ecx.alloc_ret_ptr(mir.return_ty, substs)?;\n-            let ptr = ptr.expect(\"there's no such thing as an unreachable static\");\n             this.ecx.statics.insert(cid.clone(), ptr);\n             this.ecx.push_stack_frame(def_id, span, mir, substs, Some(ptr))\n         });\n@@ -155,7 +162,6 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                 let return_ty = mir.return_ty;\n                 self.try(|this| {\n                     let return_ptr = this.ecx.alloc_ret_ptr(return_ty, cid.substs)?;\n-                    let return_ptr = return_ptr.expect(\"there's no such thing as an unreachable static\");\n                     let mir = CachedMir::Owned(Rc::new(mir));\n                     this.ecx.statics.insert(cid.clone(), return_ptr);\n                     this.ecx.push_stack_frame(this.def_id, constant.span, mir, this.substs, Some(return_ptr))\n@@ -167,7 +173,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n     fn visit_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>, context: LvalueContext) {\n         self.super_lvalue(lvalue, context);\n         if let mir::Lvalue::Static(def_id) = *lvalue {\n-            let substs = self.ecx.tcx.mk_substs(subst::Substs::empty());\n+            let substs = subst::Substs::empty(self.ecx.tcx);\n             let span = self.span;\n             self.global_item(def_id, substs, span);\n         }"}, {"sha": "b8f8b132088a51edab312f624b0ea79a365402b4", "filename": "src/interpreter/terminator.rs", "status": "modified", "additions": 37, "deletions": 43, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/45cf3cfde2c32f5b27c469ef1b5f04dd195fb462/src%2Finterpreter%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cf3cfde2c32f5b27c469ef1b5f04dd195fb462/src%2Finterpreter%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator.rs?ref=45cf3cfde2c32f5b27c469ef1b5f04dd195fb462", "patch": "@@ -1,9 +1,9 @@\n use rustc::hir::def_id::DefId;\n use rustc::mir::repr as mir;\n-use rustc::traits::{self, ProjectionMode};\n+use rustc::traits::{self, Reveal};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::layout::Layout;\n-use rustc::ty::subst::{self, Substs};\n+use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt, BareFnTy};\n use std::rc::Rc;\n use std::iter;\n@@ -150,37 +150,29 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         use syntax::abi::Abi;\n         match fn_ty.abi {\n             Abi::RustIntrinsic => {\n-                let name = self.tcx.item_name(def_id).as_str();\n-                match fn_ty.sig.0.output {\n-                    ty::FnConverging(ty) => {\n-                        let layout = self.type_layout(ty);\n-                        let ret = return_ptr.unwrap();\n-                        self.call_intrinsic(&name, substs, args, ret, layout)\n-                    }\n-                    ty::FnDiverging => unimplemented!(),\n-                }\n+                let ty = fn_ty.sig.0.output;\n+                let layout = self.type_layout(ty);\n+                let ret = return_ptr.unwrap();\n+                self.call_intrinsic(def_id, substs, args, ret, layout)\n             }\n \n             Abi::C => {\n-                match fn_ty.sig.0.output {\n-                    ty::FnConverging(ty) => {\n-                        let size = self.type_size(ty);\n-                        self.call_c_abi(def_id, args, return_ptr.unwrap(), size)\n-                    }\n-                    ty::FnDiverging => unimplemented!(),\n-                }\n+                let ty = fn_ty.sig.0.output;\n+                let size = self.type_size(ty);\n+                self.call_c_abi(def_id, args, return_ptr.unwrap(), size)\n             }\n \n             Abi::Rust | Abi::RustCall => {\n                 // TODO(solson): Adjust the first argument when calling a Fn or\n                 // FnMut closure via FnOnce::call_once.\n \n                 // Only trait methods can have a Self parameter.\n-                let (resolved_def_id, resolved_substs) = if substs.self_ty().is_some() {\n-                    self.trait_method(def_id, substs)\n-                } else {\n-                    (def_id, substs)\n-                };\n+                let (resolved_def_id, resolved_substs) =\n+                    if let Some(trait_id) = self.tcx.trait_of_item(def_id) {\n+                        self.trait_method(trait_id, def_id, substs)\n+                    } else {\n+                        (def_id, substs)\n+                    };\n \n                 let mut arg_srcs = Vec::new();\n                 for arg in args {\n@@ -265,7 +257,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     fn call_intrinsic(\n         &mut self,\n-        name: &str,\n+        def_id: DefId,\n         substs: &'tcx Substs<'tcx>,\n         args: &[mir::Operand<'tcx>],\n         dest: Pointer,\n@@ -275,10 +267,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             .map(|arg| self.eval_operand(arg))\n             .collect();\n         let args_ptrs = args_res?;\n-\n         let pointer_size = self.memory.pointer_size();\n \n-        match name {\n+        match &self.tcx.item_name(def_id).as_str()[..] {\n             \"add_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Add, &args[0], &args[1], dest, dest_layout)?,\n             \"sub_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Sub, &args[0], &args[1], dest, dest_layout)?,\n             \"mul_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Mul, &args[0], &args[1], dest, dest_layout)?,\n@@ -287,7 +278,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"assume\" => {}\n \n             \"copy_nonoverlapping\" => {\n-                let elem_ty = *substs.types.get(subst::FnSpace, 0);\n+                let elem_ty = substs.types[0];\n                 let elem_size = self.type_size(elem_ty);\n                 let elem_align = self.type_align(elem_ty);\n                 let src = self.memory.read_ptr(args_ptrs[0])?;\n@@ -297,7 +288,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"discriminant_value\" => {\n-                let ty = *substs.types.get(subst::FnSpace, 0);\n+                let ty = substs.types[0];\n                 let adt_ptr = self.memory.read_ptr(args_ptrs[0])?;\n                 let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n                 self.memory.write_uint(dest, discr_val, 8)?;\n@@ -308,19 +299,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"init\" => self.memory.write_repeat(dest, 0, dest_layout.size(&self.tcx.data_layout).bytes() as usize)?,\n \n             \"min_align_of\" => {\n-                let elem_ty = *substs.types.get(subst::FnSpace, 0);\n+                let elem_ty = substs.types[0];\n                 let elem_align = self.type_align(elem_ty);\n                 self.memory.write_uint(dest, elem_align as u64, pointer_size)?;\n             }\n \n             \"move_val_init\" => {\n-                let ty = *substs.types.get(subst::FnSpace, 0);\n+                let ty = substs.types[0];\n                 let ptr = self.memory.read_ptr(args_ptrs[0])?;\n                 self.move_(args_ptrs[1], ptr, ty)?;\n             }\n \n             \"offset\" => {\n-                let pointee_ty = *substs.types.get(subst::FnSpace, 0);\n+                let pointee_ty = substs.types[0];\n                 let pointee_size = self.type_size(pointee_ty) as isize;\n                 let ptr_arg = args_ptrs[0];\n                 let offset = self.memory.read_isize(args_ptrs[1])?;\n@@ -342,21 +333,23 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"overflowing_sub\" => {\n                 self.intrinsic_overflowing(mir::BinOp::Sub, &args[0], &args[1], dest)?;\n             }\n+\n             \"overflowing_mul\" => {\n                 self.intrinsic_overflowing(mir::BinOp::Mul, &args[0], &args[1], dest)?;\n             }\n+\n             \"overflowing_add\" => {\n                 self.intrinsic_overflowing(mir::BinOp::Add, &args[0], &args[1], dest)?;\n             }\n \n             \"size_of\" => {\n-                let ty = *substs.types.get(subst::FnSpace, 0);\n+                let ty = substs.types[0];\n                 let size = self.type_size(ty) as u64;\n                 self.memory.write_uint(dest, size, pointer_size)?;\n             }\n \n             \"size_of_val\" => {\n-                let ty = *substs.types.get(subst::FnSpace, 0);\n+                let ty = substs.types[0];\n                 if self.type_is_sized(ty) {\n                     let size = self.type_size(ty) as u64;\n                     self.memory.write_uint(dest, size, pointer_size)?;\n@@ -376,7 +369,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"transmute\" => {\n-                let ty = *substs.types.get(subst::FnSpace, 0);\n+                let ty = substs.types[0];\n                 self.move_(args_ptrs[0], dest, ty)?;\n             }\n             \"uninit\" => self.memory.mark_definedness(dest, dest_layout.size(&self.tcx.data_layout).bytes() as usize, false)?,\n@@ -464,7 +457,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn fulfill_obligation(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> traits::Vtable<'tcx, ()> {\n         // Do the initial selection for the obligation. This yields the shallow result we are\n         // looking for -- that is, what specific impl.\n-        self.tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+        self.tcx.normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n             let mut selcx = traits::SelectionContext::new(&infcx);\n \n             let obligation = traits::Obligation::new(\n@@ -486,21 +479,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     /// Trait method, which has to be resolved to an impl method.\n     fn trait_method(\n         &self,\n+        trait_id: DefId,\n         def_id: DefId,\n         substs: &'tcx Substs<'tcx>\n     ) -> (DefId, &'tcx Substs<'tcx>) {\n-        let method_item = self.tcx.impl_or_trait_item(def_id);\n-        let trait_id = method_item.container().id();\n-        let trait_ref = ty::Binder(substs.to_trait_ref(self.tcx, trait_id));\n+        let trait_ref = ty::TraitRef::from_method(self.tcx, trait_id, substs);\n+        let trait_ref = self.tcx.normalize_associated_type(&ty::Binder(trait_ref));\n+\n         match self.fulfill_obligation(trait_ref) {\n             traits::VtableImpl(vtable_impl) => {\n                 let impl_did = vtable_impl.impl_def_id;\n                 let mname = self.tcx.item_name(def_id);\n                 // Create a concatenated set of substitutions which includes those from the impl\n                 // and those from the method:\n-                let impl_substs = vtable_impl.substs.with_method_from(substs);\n-                let substs = self.tcx.mk_substs(impl_substs);\n-                let mth = get_impl_method(self.tcx, impl_did, substs, mname);\n+                let mth = get_impl_method(self.tcx, substs, impl_did, vtable_impl.substs, mname);\n \n                 (mth.method.def_id, mth.substs)\n             }\n@@ -573,8 +565,9 @@ struct ImplMethod<'tcx> {\n /// Locates the applicable definition of a method, given its name.\n fn get_impl_method<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    impl_def_id: DefId,\n     substs: &'tcx Substs<'tcx>,\n+    impl_def_id: DefId,\n+    impl_substs: &'tcx Substs<'tcx>,\n     name: ast::Name,\n ) -> ImplMethod<'tcx> {\n     assert!(!substs.types.needs_infer());\n@@ -584,7 +577,8 @@ fn get_impl_method<'a, 'tcx>(\n \n     match trait_def.ancestors(impl_def_id).fn_defs(tcx, name).next() {\n         Some(node_item) => {\n-            let substs = tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+            let substs = tcx.normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n+                let substs = substs.rebase_onto(tcx, trait_def_id, impl_substs);\n                 let substs = traits::translate_substs(&infcx, impl_def_id,\n                                                       substs, node_item.node);\n                 tcx.lift(&substs).unwrap_or_else(|| {"}, {"sha": "f35aad87270ed3e02ea176455c0cce8e4a824a90", "filename": "tests/compile-fail/cast_fn_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cf3cfde2c32f5b27c469ef1b5f04dd195fb462/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cf3cfde2c32f5b27c469ef1b5f04dd195fb462/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr.rs?ref=45cf3cfde2c32f5b27c469ef1b5f04dd195fb462", "patch": "@@ -1,7 +1,7 @@\n-fn main() { //~ ERROR tried to call a function of type\n+fn main() {\n     fn f() {}\n \n-    let g = unsafe {\n+    let g = unsafe { //~ ERROR tried to call a function of type\n         std::mem::transmute::<fn(), fn(i32)>(f)\n     };\n "}, {"sha": "c7d25a663159cb61a4efceb67388661ae7b88205", "filename": "tests/compile-fail/execute_memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cf3cfde2c32f5b27c469ef1b5f04dd195fb462/tests%2Fcompile-fail%2Fexecute_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cf3cfde2c32f5b27c469ef1b5f04dd195fb462/tests%2Fcompile-fail%2Fexecute_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fexecute_memory.rs?ref=45cf3cfde2c32f5b27c469ef1b5f04dd195fb462", "patch": "@@ -1,10 +1,10 @@\n #![feature(box_syntax)]\n \n-// FIXME: This span is wrong.\n-fn main() { //~ ERROR: tried to treat a memory pointer as a function pointer\n+fn main() {\n     let x = box 42;\n     unsafe {\n         let f = std::mem::transmute::<Box<i32>, fn()>(x);\n+        //~^ ERROR: tried to treat a memory pointer as a function pointer\n         f()\n     }\n }"}]}