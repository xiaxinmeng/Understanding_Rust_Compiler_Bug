{"sha": "feaad623a12aeb1ce4ee3dabf251e36ccdfe7107", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlYWFkNjIzYTEyYWViMWNlNGVlM2RhYmYyNTFlMzZjY2RmZTcxMDc=", "commit": {"author": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2014-06-23T22:13:11Z"}, "committer": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2014-07-04T00:33:41Z"}, "message": "liburl: Remove some unnecessary allocations.\n\nSome signatures have changed from String to &str returns.\n\nTo fix, call to_string() on the returned value.\n\n[breaking-change]", "tree": {"sha": "ea4dace5bcc7a1d84b0b03ff6189aa90d357c005", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea4dace5bcc7a1d84b0b03ff6189aa90d357c005"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/feaad623a12aeb1ce4ee3dabf251e36ccdfe7107", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/feaad623a12aeb1ce4ee3dabf251e36ccdfe7107", "html_url": "https://github.com/rust-lang/rust/commit/feaad623a12aeb1ce4ee3dabf251e36ccdfe7107", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/feaad623a12aeb1ce4ee3dabf251e36ccdfe7107/comments", "author": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11b093425d44b9e14c4c3cace4d7ee691c56e25b", "url": "https://api.github.com/repos/rust-lang/rust/commits/11b093425d44b9e14c4c3cace4d7ee691c56e25b", "html_url": "https://github.com/rust-lang/rust/commit/11b093425d44b9e14c4c3cace4d7ee691c56e25b"}], "stats": {"total": 327, "additions": 161, "deletions": 166}, "files": [{"sha": "55c7867208042844b085da70226b0041a2dc180a", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 161, "deletions": 166, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/feaad623a12aeb1ce4ee3dabf251e36ccdfe7107/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feaad623a12aeb1ce4ee3dabf251e36ccdfe7107/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=feaad623a12aeb1ce4ee3dabf251e36ccdfe7107", "patch": "@@ -51,7 +51,7 @@ pub struct Url {\n     /// A domain name or IP address.  For example, `example.com`.\n     pub host: String,\n     /// A TCP port number, for example `8080`.\n-    pub port: Option<String>,\n+    pub port: Option<u16>,\n     /// The path component of a URL, for example `/foo/bar?baz=qux#quz`.\n     pub path: Path,\n }\n@@ -84,7 +84,7 @@ impl Url {\n     pub fn new(scheme: String,\n                user: Option<UserInfo>,\n                host: String,\n-               port: Option<String>,\n+               port: Option<u16>,\n                path: String,\n                query: Query,\n                fragment: Option<String>)\n@@ -113,16 +113,23 @@ impl Url {\n         let (scheme, rest) = try!(get_scheme(rawurl));\n \n         // authority\n-        let (userinfo, host, port, rest) = try!(get_authority(rest.as_slice()));\n+        let (userinfo, host, port, rest) = try!(get_authority(rest));\n \n         // path\n         let has_authority = host.len() > 0;\n-        let (path, rest) = try!(get_path(rest.as_slice(), has_authority));\n+        let (path, rest) = try!(get_path(rest, has_authority));\n \n         // query and fragment\n-        let (query, fragment) = try!(get_query_fragment(rest.as_slice()));\n-\n-        Ok(Url::new(scheme, userinfo, host, port, path, query, fragment))\n+        let (query, fragment) = try!(get_query_fragment(rest));\n+\n+        let url = Url::new(scheme.to_string(),\n+                            userinfo,\n+                            host.to_string(),\n+                            port,\n+                            path,\n+                            query,\n+                            fragment);\n+        Ok(url)\n     }\n }\n \n@@ -438,65 +445,50 @@ pub fn query_to_str(query: &Query) -> String {\n     })\n }\n \n-/**\n- * Returns a tuple of the URI scheme and the rest of the URI, or a parsing error.\n- *\n- * Does not include the separating `:` character.\n- *\n- * # Example\n- *\n- * ```rust\n- * use url::get_scheme;\n- *\n- * let scheme = match get_scheme(\"https://example.com/\") {\n- *     Ok((sch, _)) => sch,\n- *     Err(_) => \"(None)\".to_string(),\n- * };\n- * println!(\"Scheme in use: {}.\", scheme); // Scheme in use: https.\n- * ```\n- */\n-pub fn get_scheme(rawurl: &str) -> DecodeResult<(String, String)> {\n+/// Returns a tuple of the URI scheme and the rest of the URI, or a parsing error.\n+///\n+/// Does not include the separating `:` character.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use url::get_scheme;\n+///\n+/// let scheme = match get_scheme(\"https://example.com/\") {\n+///     Ok((sch, _)) => sch,\n+///     Err(_) => \"(None)\",\n+/// };\n+/// println!(\"Scheme in use: {}.\", scheme); // Scheme in use: https.\n+/// ```\n+pub fn get_scheme<'a>(rawurl: &'a str) -> DecodeResult<(&'a str, &'a str)> {\n     for (i,c) in rawurl.chars().enumerate() {\n-        match c {\n-          'A' .. 'Z' | 'a' .. 'z' => continue,\n-          '0' .. '9' | '+' | '-' | '.' => {\n-            if i == 0 {\n-                return Err(\"url: Scheme must begin with a \\\n-                            letter.\".to_string());\n+        let result = match c {\n+            'A' .. 'Z'\n+            | 'a' .. 'z' => continue,\n+            '0' .. '9' | '+' | '-' | '.' => {\n+                if i != 0 { continue }\n+\n+                Err(\"url: Scheme must begin with a letter.\".to_string())\n             }\n-            continue;\n-          }\n-          ':' => {\n-            if i == 0 {\n-                return Err(\"url: Scheme cannot be empty.\".to_string());\n-            } else {\n-                return Ok((rawurl.slice(0,i).to_string(),\n-                           rawurl.slice(i+1,rawurl.len()).to_string()));\n+            ':' => {\n+                if i == 0 {\n+                    Err(\"url: Scheme cannot be empty.\".to_string())\n+                } else {\n+                    Ok((rawurl.slice(0,i), rawurl.slice(i+1,rawurl.len())))\n+                }\n             }\n-          }\n-          _ => {\n-            return Err(\"url: Invalid character in scheme.\".to_string());\n-          }\n-        }\n-    };\n-    return Err(\"url: Scheme must be terminated with a colon.\".to_string());\n-}\n+            _ => Err(\"url: Invalid character in scheme.\".to_string()),\n+        };\n \n-#[deriving(Clone, PartialEq)]\n-enum Input {\n-    Digit, // all digits\n-    Hex, // digits and letters a-f\n-    Unreserved // all other legal characters\n+        return result;\n+    }\n+\n+    Err(\"url: Scheme must be terminated with a colon.\".to_string())\n }\n \n // returns userinfo, host, port, and unparsed part, or an error\n-fn get_authority(rawurl: &str) ->\n-    DecodeResult<(Option<UserInfo>, String, Option<String>, String)> {\n-    if !rawurl.starts_with(\"//\") {\n-        // there is no authority.\n-        return Ok((None, \"\".to_string(), None, rawurl.to_str()));\n-    }\n-\n+fn get_authority<'a>(rawurl: &'a str) ->\n+    DecodeResult<(Option<UserInfo>, &'a str, Option<u16>, &'a str)> {\n     enum State {\n         Start, // starting state\n         PassHostPort, // could be in user or port\n@@ -506,40 +498,52 @@ fn get_authority(rawurl: &str) ->\n         InPort // are in port\n     }\n \n+    #[deriving(Clone, PartialEq)]\n+    enum Input {\n+        Digit, // all digits\n+        Hex, // digits and letters a-f\n+        Unreserved // all other legal characters\n+    }\n+\n+    if !rawurl.starts_with(\"//\") {\n+        // there is no authority.\n+        return Ok((None, \"\", None, rawurl));\n+    }\n+\n     let len = rawurl.len();\n     let mut st = Start;\n     let mut input = Digit; // most restricted, start here.\n \n     let mut userinfo = None;\n-    let mut host = \"\".to_string();\n+    let mut host = \"\";\n     let mut port = None;\n \n     let mut colon_count = 0u;\n     let mut pos = 0;\n     let mut begin = 2;\n     let mut end = len;\n \n-    for (i,c) in rawurl.chars().enumerate() {\n-        if i < 2 { continue; } // ignore the leading //\n-\n+    for (i,c) in rawurl.chars().enumerate()\n+                               // ignore the leading '//' handled by early return\n+                               .skip(2) {\n         // deal with input class first\n         match c {\n-          '0' .. '9' => (),\n-          'A' .. 'F' | 'a' .. 'f' => {\n-            if input == Digit {\n-                input = Hex;\n+            '0' .. '9' => (),\n+            'A' .. 'F'\n+            | 'a' .. 'f' => {\n+                if input == Digit {\n+                    input = Hex;\n+                }\n             }\n-          }\n-          'G' .. 'Z' | 'g' .. 'z' | '-' | '.' | '_' | '~' | '%' |\n-          '&' |'\\'' | '(' | ')' | '+' | '!' | '*' | ',' | ';' | '=' => {\n-            input = Unreserved;\n-          }\n-          ':' | '@' | '?' | '#' | '/' => {\n-            // separators, don't change anything\n-          }\n-          _ => {\n-            return Err(\"Illegal character in authority\".to_string());\n-          }\n+            'G' .. 'Z'\n+            | 'g' .. 'z'\n+            | '-' | '.' | '_' | '~' | '%'\n+            | '&' |'\\'' | '(' | ')' | '+'\n+            | '!' | '*' | ',' | ';' | '=' => input = Unreserved,\n+            ':' | '@' | '?' | '#' | '/' => {\n+                // separators, don't change anything\n+            }\n+            _ => return Err(\"Illegal character in authority\".to_string()),\n         }\n \n         // now process states\n@@ -563,7 +567,7 @@ fn get_authority(rawurl: &str) ->\n                 pos = i;\n                 if input == Unreserved {\n                     // must be port\n-                    host = rawurl.slice(begin, i).to_string();\n+                    host = rawurl.slice(begin, i);\n                     st = InPort;\n                 } else {\n                     // can't be sure whether this is an ipv6 address or a port\n@@ -572,21 +576,18 @@ fn get_authority(rawurl: &str) ->\n               }\n               Ip6Port => {\n                 if input == Unreserved {\n-                    return Err(\"Illegal characters in \\\n-                                authority.\".to_string());\n+                    return Err(\"Illegal characters in authority.\".to_string());\n                 }\n                 st = Ip6Host;\n               }\n               Ip6Host => {\n                 if colon_count > 7 {\n-                    host = rawurl.slice(begin, i).to_string();\n+                    host = rawurl.slice(begin, i);\n                     pos = i;\n                     st = InPort;\n                 }\n               }\n-              _ => {\n-                return Err(\"Invalid ':' in authority.\".to_string());\n-              }\n+              _ => return Err(\"Invalid ':' in authority.\".to_string()),\n             }\n             input = Digit; // reset input class\n           }\n@@ -606,9 +607,7 @@ fn get_authority(rawurl: &str) ->\n                 userinfo = Some(UserInfo::new(user, Some(pass)));\n                 st = InHost;\n               }\n-              _ => {\n-                return Err(\"Invalid '@' in authority.\".to_string());\n-              }\n+              _ => return Err(\"Invalid '@' in authority.\".to_string()),\n             }\n             begin = i+1;\n           }\n@@ -623,43 +622,53 @@ fn get_authority(rawurl: &str) ->\n \n     // finish up\n     match st {\n-      Start => {\n-        host = rawurl.slice(begin, end).to_string();\n-      }\n-      PassHostPort | Ip6Port => {\n+      Start => host = rawurl.slice(begin, end),\n+      PassHostPort\n+      | Ip6Port => {\n         if input != Digit {\n             return Err(\"Non-digit characters in port.\".to_string());\n         }\n-        host = rawurl.slice(begin, pos).to_string();\n-        port = Some(rawurl.slice(pos+1, end).to_string());\n-      }\n-      Ip6Host | InHost => {\n-        host = rawurl.slice(begin, end).to_string();\n+        host = rawurl.slice(begin, pos);\n+        port = Some(rawurl.slice(pos+1, end));\n       }\n+      Ip6Host\n+      | InHost => host = rawurl.slice(begin, end),\n       InPort => {\n         if input != Digit {\n             return Err(\"Non-digit characters in port.\".to_string());\n         }\n-        port = Some(rawurl.slice(pos+1, end).to_string());\n+        port = Some(rawurl.slice(pos+1, end));\n       }\n     }\n \n-    let rest = rawurl.slice(end, len).to_string();\n-    return Ok((userinfo, host, port, rest));\n+    let rest = rawurl.slice(end, len);\n+    // If we have a port string, ensure it parses to u16.\n+    let port = match port {\n+        None => None,\n+        opt => match opt.and_then(|p| FromStr::from_str(p)) {\n+            None => return Err(format!(\"Failed to parse port: {}\", port)),\n+            opt => opt\n+        }\n+    };\n+\n+    Ok((userinfo, host, port, rest))\n }\n \n \n // returns the path and unparsed part of url, or an error\n-fn get_path(rawurl: &str, authority: bool) -> DecodeResult<(String, String)> {\n+fn get_path<'a>(rawurl: &'a str, is_authority: bool)\n+                                            -> DecodeResult<(String, &'a str)> {\n     let len = rawurl.len();\n     let mut end = len;\n     for (i,c) in rawurl.chars().enumerate() {\n         match c {\n-          'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '&' |'\\'' | '(' | ')' | '.'\n-          | '@' | ':' | '%' | '/' | '+' | '!' | '*' | ',' | ';' | '='\n-          | '_' | '-' | '~' => {\n-            continue;\n-          }\n+          'A' .. 'Z'\n+          | 'a' .. 'z'\n+          | '0' .. '9'\n+          | '&' |'\\'' | '(' | ')' | '.'\n+          | '@' | ':' | '%' | '/' | '+'\n+          | '!' | '*' | ',' | ';' | '='\n+          | '_' | '-' | '~' => continue,\n           '?' | '#' => {\n             end = i;\n             break;\n@@ -668,68 +677,53 @@ fn get_path(rawurl: &str, authority: bool) -> DecodeResult<(String, String)> {\n         }\n     }\n \n-    if authority && end != 0 && !rawurl.starts_with(\"/\") {\n+    if is_authority && end != 0 && !rawurl.starts_with(\"/\") {\n         Err(\"Non-empty path must begin with \\\n             '/' in presence of authority.\".to_string())\n     } else {\n         Ok((try!(decode_component(rawurl.slice(0, end))),\n-            rawurl.slice(end, len).to_string()))\n+            rawurl.slice(end, len)))\n     }\n }\n \n // returns the parsed query and the fragment, if present\n fn get_query_fragment(rawurl: &str) -> DecodeResult<(Query, Option<String>)> {\n-    if !rawurl.starts_with(\"?\") {\n-        if rawurl.starts_with(\"#\") {\n-            let f = try!(decode_component(rawurl.slice(1, rawurl.len())));\n-            return Ok((vec!(), Some(f)));\n-        } else {\n-            return Ok((vec!(), None));\n-        }\n-    }\n-    let (q, r) = split_char_first(rawurl.slice(1, rawurl.len()), '#');\n-    let f = if r.len() != 0 {\n-        Some(try!(decode_component(r)))\n-    } else {\n-        None\n+    let (before_fragment, raw_fragment) = split_char_first(rawurl, '#');\n+\n+    // Parse the fragment if available\n+    let fragment = match raw_fragment {\n+        \"\" => None,\n+        raw => Some(try!(decode_component(raw)))\n     };\n \n-    Ok((try!(query_from_str(q)), f))\n+    match before_fragment.slice_shift_char() {\n+        (Some('?'), rest) => Ok((try!(query_from_str(rest)), fragment)),\n+        (None, \"\") => Ok((vec!(), fragment)),\n+        _ => Err(format!(\"Query didn't start with '?': '{}..'\", before_fragment)),\n+    }\n }\n \n impl FromStr for Url {\n     fn from_str(s: &str) -> Option<Url> {\n-        match Url::parse(s) {\n-            Ok(url) => Some(url),\n-            Err(_) => None\n-        }\n+        Url::parse(s).ok()\n     }\n }\n \n impl FromStr for Path {\n     fn from_str(s: &str) -> Option<Path> {\n-        match Path::parse(s) {\n-            Ok(path) => Some(path),\n-            Err(_) => None\n-        }\n+        Path::parse(s).ok()\n     }\n }\n \n impl fmt::Show for Url {\n-    /**\n-     * Converts a URL from `Url` to string representation.\n-     *\n-     * # Arguments\n-     *\n-     * `url` - a URL.\n-     *\n-     * # Returns\n-     *\n-     * A string that contains the formatted URL. Note that this will usually\n-     * be an inverse of `from_str` but might strip out unneeded separators;\n-     * for example, \"http://somehost.com?\", when parsed and formatted, will\n-     * result in just \"http://somehost.com\".\n-     */\n+    /// Converts a URL from `Url` to string representation.\n+    ///\n+    /// # Returns\n+    ///\n+    /// A string that contains the formatted URL. Note that this will usually\n+    /// be an inverse of `from_str` but might strip out unneeded separators;\n+    /// for example, \"http://somehost.com?\", when parsed and formatted, will\n+    /// result in just \"http://somehost.com\".\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"{}:\", self.scheme));\n \n@@ -797,40 +791,39 @@ fn test_get_authority() {\n     let (u, h, p, r) = get_authority(\n         \"//user:pass@rust-lang.org/something\").unwrap();\n     assert_eq!(u, Some(UserInfo::new(\"user\".to_string(), Some(\"pass\".to_string()))));\n-    assert_eq!(h, \"rust-lang.org\".to_string());\n+    assert_eq!(h, \"rust-lang.org\");\n     assert!(p.is_none());\n-    assert_eq!(r, \"/something\".to_string());\n+    assert_eq!(r, \"/something\");\n \n     let (u, h, p, r) = get_authority(\n         \"//rust-lang.org:8000?something\").unwrap();\n     assert!(u.is_none());\n-    assert_eq!(h, \"rust-lang.org\".to_string());\n-    assert_eq!(p, Some(\"8000\".to_string()));\n-    assert_eq!(r, \"?something\".to_string());\n+    assert_eq!(h, \"rust-lang.org\");\n+    assert_eq!(p, Some(8000));\n+    assert_eq!(r, \"?something\");\n \n-    let (u, h, p, r) = get_authority(\n-        \"//rust-lang.org#blah\").unwrap();\n+    let (u, h, p, r) = get_authority(\"//rust-lang.org#blah\").unwrap();\n     assert!(u.is_none());\n-    assert_eq!(h, \"rust-lang.org\".to_string());\n+    assert_eq!(h, \"rust-lang.org\");\n     assert!(p.is_none());\n-    assert_eq!(r, \"#blah\".to_string());\n+    assert_eq!(r, \"#blah\");\n \n     // ipv6 tests\n     let (_, h, _, _) = get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334#blah\").unwrap();\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_string());\n+    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n \n     let (_, h, p, _) = get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\").unwrap();\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_string());\n-    assert_eq!(p, Some(\"8000\".to_string()));\n+    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n+    assert_eq!(p, Some(8000));\n \n     let (u, h, p, _) = get_authority(\n         \"//us:p@2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"\n     ).unwrap();\n     assert_eq!(u, Some(UserInfo::new(\"us\".to_string(), Some(\"p\".to_string()))));\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\".to_string());\n-    assert_eq!(p, Some(\"8000\".to_string()));\n+    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n+    assert_eq!(p, Some(8000));\n \n     // invalid authorities;\n     assert!(get_authority(\"//user:pass@rust-lang:something\").is_err());\n@@ -839,25 +832,27 @@ fn test_get_authority() {\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:800a\").is_err());\n     assert!(get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000:00\").is_err());\n+    // outside u16 range\n+    assert!(get_authority(\"//user:pass@rust-lang:65536\").is_err());\n \n     // these parse as empty, because they don't start with '//'\n     let (_, h, _, _) = get_authority(\"user:pass@rust-lang\").unwrap();\n-    assert_eq!(h, \"\".to_string());\n+    assert_eq!(h, \"\");\n     let (_, h, _, _) = get_authority(\"rust-lang.org\").unwrap();\n-    assert_eq!(h, \"\".to_string());\n+    assert_eq!(h, \"\");\n }\n \n #[test]\n fn test_get_path() {\n     let (p, r) = get_path(\"/something+%20orother\", true).unwrap();\n     assert_eq!(p, \"/something+ orother\".to_string());\n-    assert_eq!(r, \"\".to_string());\n+    assert_eq!(r, \"\");\n     let (p, r) = get_path(\"test@email.com#fragment\", false).unwrap();\n     assert_eq!(p, \"test@email.com\".to_string());\n-    assert_eq!(r, \"#fragment\".to_string());\n+    assert_eq!(r, \"#fragment\");\n     let (p, r) = get_path(\"/gen/:addr=?q=v\", false).unwrap();\n     assert_eq!(p, \"/gen/:addr=\".to_string());\n-    assert_eq!(r, \"?q=v\".to_string());\n+    assert_eq!(r, \"?q=v\");\n \n     //failure cases\n     assert!(get_path(\"something?q\", true).is_err());\n@@ -879,7 +874,7 @@ mod tests {\n         assert_eq!(&u.scheme, &\"http\".to_string());\n         assert_eq!(&u.user, &Some(UserInfo::new(\"user\".to_string(), Some(\"pass\".to_string()))));\n         assert_eq!(&u.host, &\"rust-lang.org\".to_string());\n-        assert_eq!(&u.port, &Some(\"8080\".to_string()));\n+        assert_eq!(&u.port, &Some(8080));\n         assert_eq!(&u.path.path, &\"/doc/~u\".to_string());\n         assert_eq!(&u.path.query, &vec!((\"s\".to_string(), \"v\".to_string())));\n         assert_eq!(&u.path.fragment, &Some(\"something\".to_string()));\n@@ -917,14 +912,14 @@ mod tests {\n         let url = from_str::<Url>(urlstr).unwrap();\n         assert_eq!(&url.scheme, &\"scheme\".to_string());\n         assert_eq!(&url.host, &\"host\".to_string());\n-        assert_eq!(&url.port, &Some(\"1234\".to_string()));\n+        assert_eq!(&url.port, &Some(1234));\n         // is empty path really correct? Other tests think so\n         assert_eq!(&url.path.path, &\"\".to_string());\n         let urlstr = \"scheme://host:1234/\";\n         let url = from_str::<Url>(urlstr).unwrap();\n         assert_eq!(&url.scheme, &\"scheme\".to_string());\n         assert_eq!(&url.host, &\"host\".to_string());\n-        assert_eq!(&url.port, &Some(\"1234\".to_string()));\n+        assert_eq!(&url.port, &Some(1234));\n         assert_eq!(&url.path.path, &\"/\".to_string());\n     }\n "}]}