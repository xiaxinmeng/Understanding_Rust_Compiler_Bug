{"sha": "5986d2190f2a8b646ff693288153cdb5d1e1746d", "node_id": "C_kwDOAAsO6NoAKDU5ODZkMjE5MGYyYThiNjQ2ZmY2OTMyODgxNTNjZGI1ZDFlMTc0NmQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-28T15:11:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-28T15:11:24Z"}, "message": "Auto merge of #12899 - Veykril:compl-qualifier, r=Veykril\n\nfix: Do completions in path qualifier position\n\nFixes https://github.com/rust-lang/rust-analyzer/issues/12566\n\nNot too happy with the duplication needed for this, but it is what it is. Completions in path qualifiers will have to be filtered properly still, but its better to show too many completions for this than too few for now.", "tree": {"sha": "82026c54f97d822abebfbae6f9fed7e05538a0b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82026c54f97d822abebfbae6f9fed7e05538a0b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5986d2190f2a8b646ff693288153cdb5d1e1746d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5986d2190f2a8b646ff693288153cdb5d1e1746d", "html_url": "https://github.com/rust-lang/rust/commit/5986d2190f2a8b646ff693288153cdb5d1e1746d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5986d2190f2a8b646ff693288153cdb5d1e1746d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02c240ff81014d65bf615bab49626df5653d80a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/02c240ff81014d65bf615bab49626df5653d80a0", "html_url": "https://github.com/rust-lang/rust/commit/02c240ff81014d65bf615bab49626df5653d80a0"}, {"sha": "74abd44a265d6daded813ccb48ed599d835ea532", "url": "https://api.github.com/repos/rust-lang/rust/commits/74abd44a265d6daded813ccb48ed599d835ea532", "html_url": "https://github.com/rust-lang/rust/commit/74abd44a265d6daded813ccb48ed599d835ea532"}], "stats": {"total": 203, "additions": 118, "deletions": 85}, "files": [{"sha": "bafaeb502ad752ce9f349827f7b65f62c5d816ee", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5986d2190f2a8b646ff693288153cdb5d1e1746d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5986d2190f2a8b646ff693288153cdb5d1e1746d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=5986d2190f2a8b646ff693288153cdb5d1e1746d", "patch": "@@ -11,7 +11,14 @@ pub(crate) fn complete_expr_path(\n     acc: &mut Completions,\n     ctx: &CompletionContext<'_>,\n     path_ctx @ PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n-    &ExprCtx {\n+    expr_ctx: &ExprCtx,\n+) {\n+    let _p = profile::span(\"complete_expr_path\");\n+    if !ctx.qualifier_ctx.none() {\n+        return;\n+    }\n+\n+    let &ExprCtx {\n         in_block_expr,\n         in_loop_body,\n         after_if_expr,\n@@ -23,12 +30,7 @@ pub(crate) fn complete_expr_path(\n         ref impl_,\n         in_match_guard,\n         ..\n-    }: &ExprCtx,\n-) {\n-    let _p = profile::span(\"complete_expr_path\");\n-    if !ctx.qualifier_ctx.none() {\n-        return;\n-    }\n+    } = expr_ctx;\n \n     let wants_mut_token =\n         ref_expr_parent.as_ref().map(|it| it.mut_token().is_none()).unwrap_or(false);"}, {"sha": "76fc74c01d22c9de932c567bfdbdf0b369bf791c", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 109, "deletions": 78, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/5986d2190f2a8b646ff693288153cdb5d1e1746d/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5986d2190f2a8b646ff693288153cdb5d1e1746d/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=5986d2190f2a8b646ff693288153cdb5d1e1746d", "patch": "@@ -592,7 +592,7 @@ impl<'a> CompletionContext<'a> {\n             has_call_parens: false,\n             has_macro_bang: false,\n             qualified: Qualified::No,\n-            parent: path.parent_path(),\n+            parent: None,\n             path: path.clone(),\n             kind: PathKind::Item { kind: ItemListKind::SourceFile },\n             has_type_args: false,\n@@ -827,92 +827,123 @@ impl<'a> CompletionContext<'a> {\n             PathKind::Type { location: location.unwrap_or(TypeLocation::Other) }\n         };\n \n+        let mut kind_macro_call = |it: ast::MacroCall| {\n+            path_ctx.has_macro_bang = it.excl_token().is_some();\n+            let parent = it.syntax().parent()?;\n+            // Any path in an item list will be treated as a macro call by the parser\n+            let kind = match_ast! {\n+                match parent {\n+                    ast::MacroExpr(expr) => make_path_kind_expr(expr.into()),\n+                    ast::MacroPat(it) => PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())},\n+                    ast::MacroType(ty) => make_path_kind_type(ty.into()),\n+                    ast::ItemList(_) => PathKind::Item { kind: ItemListKind::Module },\n+                    ast::AssocItemList(_) => PathKind::Item { kind: match parent.parent() {\n+                        Some(it) => match_ast! {\n+                            match it {\n+                                ast::Trait(_) => ItemListKind::Trait,\n+                                ast::Impl(it) => if it.trait_().is_some() {\n+                                    ItemListKind::TraitImpl(find_node_in_file_compensated(sema, original_file, &it))\n+                                } else {\n+                                    ItemListKind::Impl\n+                                },\n+                                _ => return None\n+                            }\n+                        },\n+                        None => return None,\n+                    } },\n+                    ast::ExternItemList(_) => PathKind::Item { kind: ItemListKind::ExternBlock },\n+                    ast::SourceFile(_) => PathKind::Item { kind: ItemListKind::SourceFile },\n+                    _ => return None,\n+                }\n+            };\n+            Some(kind)\n+        };\n+        let make_path_kind_attr = |meta: ast::Meta| {\n+            let attr = meta.parent_attr()?;\n+            let kind = attr.kind();\n+            let attached = attr.syntax().parent()?;\n+            let is_trailing_outer_attr = kind != AttrKind::Inner\n+                && non_trivia_sibling(attr.syntax().clone().into(), syntax::Direction::Next)\n+                    .is_none();\n+            let annotated_item_kind =\n+                if is_trailing_outer_attr { None } else { Some(attached.kind()) };\n+            Some(PathKind::Attr { attr_ctx: AttrCtx { kind, annotated_item_kind } })\n+        };\n+\n         // Infer the path kind\n         let parent = path.syntax().parent()?;\n         let kind = match_ast! {\n-                match parent {\n-                    ast::PathType(it) => make_path_kind_type(it.into()),\n-                    ast::PathExpr(it) => {\n-                        if let Some(p) = it.syntax().parent() {\n-                            if ast::ExprStmt::can_cast(p.kind()) {\n-                                if let Some(kind) = inbetween_body_and_decl_check(p) {\n-                                    return Some(make_res(NameRefKind::Keyword(kind)));\n-                                }\n+            match parent {\n+                ast::PathType(it) => make_path_kind_type(it.into()),\n+                ast::PathExpr(it) => {\n+                    if let Some(p) = it.syntax().parent() {\n+                        if ast::ExprStmt::can_cast(p.kind()) {\n+                            if let Some(kind) = inbetween_body_and_decl_check(p) {\n+                                return Some(make_res(NameRefKind::Keyword(kind)));\n                             }\n                         }\n+                    }\n \n-                        path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n+                    path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n \n-                        make_path_kind_expr(it.into())\n-                    },\n-                    ast::TupleStructPat(it) => {\n-                        path_ctx.has_call_parens = true;\n-                        PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n-                    },\n-                    ast::RecordPat(it) => {\n-                        path_ctx.has_call_parens = true;\n-                        PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n-                    },\n-                    ast::PathPat(it) => {\n-                        PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n-                    },\n-                    ast::MacroCall(it) => {\n-                        // A macro call in this position is usually a result of parsing recovery, so check that\n-                        if let Some(kind) = inbetween_body_and_decl_check(it.syntax().clone()) {\n-                            return Some(make_res(NameRefKind::Keyword(kind)));\n-                        }\n+                    make_path_kind_expr(it.into())\n+                },\n+                ast::TupleStructPat(it) => {\n+                    path_ctx.has_call_parens = true;\n+                    PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n+                },\n+                ast::RecordPat(it) => {\n+                    path_ctx.has_call_parens = true;\n+                    PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n+                },\n+                ast::PathPat(it) => {\n+                    PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n+                },\n+                ast::MacroCall(it) => {\n+                    // A macro call in this position is usually a result of parsing recovery, so check that\n+                    if let Some(kind) = inbetween_body_and_decl_check(it.syntax().clone()) {\n+                        return Some(make_res(NameRefKind::Keyword(kind)));\n+                    }\n \n-                        path_ctx.has_macro_bang = it.excl_token().is_some();\n-                        let parent = it.syntax().parent()?;\n-                        // Any path in an item list will be treated as a macro call by the parser\n-                        match_ast! {\n-                            match parent {\n-                                ast::MacroExpr(expr) => make_path_kind_expr(expr.into()),\n-                                ast::MacroPat(it) => PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())},\n-                                ast::MacroType(ty) => make_path_kind_type(ty.into()),\n-                                ast::ItemList(_) => PathKind::Item { kind: ItemListKind::Module },\n-                                ast::AssocItemList(_) => PathKind::Item { kind: match parent.parent() {\n-                                    Some(it) => match_ast! {\n-                                        match it {\n-                                            ast::Trait(_) => ItemListKind::Trait,\n-                                            ast::Impl(it) => if it.trait_().is_some() {\n-                                                ItemListKind::TraitImpl(find_node_in_file_compensated(sema, original_file, &it))\n-                                            } else {\n-                                                ItemListKind::Impl\n-                                            },\n-                                            _ => return None\n-                                        }\n-                                    },\n-                                    None => return None,\n-                                } },\n-                                ast::ExternItemList(_) => PathKind::Item { kind: ItemListKind::ExternBlock },\n-                                ast::SourceFile(_) => PathKind::Item { kind: ItemListKind::SourceFile },\n-                                _ => return None,\n-                            }\n-                        }\n-                    },\n-                    ast::Meta(meta) => {\n-                        let attr = meta.parent_attr()?;\n-                        let kind = attr.kind();\n-                        let attached = attr.syntax().parent()?;\n-                        let is_trailing_outer_attr = kind != AttrKind::Inner\n-                            && non_trivia_sibling(attr.syntax().clone().into(), syntax::Direction::Next).is_none();\n-                        let annotated_item_kind = if is_trailing_outer_attr {\n-                            None\n-                        } else {\n-                            Some(attached.kind())\n-                        };\n-                        PathKind::Attr {\n-                            attr_ctx: AttrCtx {\n-                                kind,\n-                                annotated_item_kind,\n-                            }\n+                    kind_macro_call(it)?\n+                },\n+                ast::Meta(meta) => make_path_kind_attr(meta)?,\n+                ast::Visibility(it) => PathKind::Vis { has_in_token: it.in_token().is_some() },\n+                ast::UseTree(_) => PathKind::Use,\n+                // completing inside a qualifier\n+                ast::Path(parent) => {\n+                    path_ctx.parent = Some(parent.clone());\n+                    let parent = iter::successors(Some(parent), |it| it.parent_path()).last()?.syntax().parent()?;\n+                    match_ast! {\n+                        match parent {\n+                            ast::PathType(it) => make_path_kind_type(it.into()),\n+                            ast::PathExpr(it) => {\n+                                path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n+\n+                                make_path_kind_expr(it.into())\n+                            },\n+                            ast::TupleStructPat(it) => {\n+                                path_ctx.has_call_parens = true;\n+                                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n+                            },\n+                            ast::RecordPat(it) => {\n+                                path_ctx.has_call_parens = true;\n+                                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n+                            },\n+                            ast::PathPat(it) => {\n+                                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n+                            },\n+                            ast::MacroCall(it) => {\n+                                kind_macro_call(it)?\n+                            },\n+                            ast::Meta(meta) => make_path_kind_attr(meta)?,\n+                            ast::Visibility(it) => PathKind::Vis { has_in_token: it.in_token().is_some() },\n+                            ast::UseTree(_) => PathKind::Use,\n+                            _ => return None,\n                         }\n-                    },\n-                    ast::Visibility(it) => PathKind::Vis { has_in_token: it.in_token().is_some() },\n-                    ast::UseTree(_) => PathKind::Use,\n-                    _ => return None,\n-\n+                    }\n+                },\n+                _ => return None,\n             }\n         };\n "}]}