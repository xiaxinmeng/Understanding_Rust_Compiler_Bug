{"sha": "e9f1b063295c48c97e239ce479b08f192a3eece4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5ZjFiMDYzMjk1YzQ4Yzk3ZTIzOWNlNDc5YjA4ZjE5MmEzZWVjZTQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-09-14T09:58:20Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-09-15T22:57:06Z"}, "message": "Use ast attributes every where (remove HIR attributes).\n\nThis could be a [breaking-change] if your lint or syntax extension (is that even possible?) uses HIR attributes or literals.", "tree": {"sha": "d0f72439a2b01ecdba8675bf82d37f92eeec7950", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0f72439a2b01ecdba8675bf82d37f92eeec7950"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9f1b063295c48c97e239ce479b08f192a3eece4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9f1b063295c48c97e239ce479b08f192a3eece4", "html_url": "https://github.com/rust-lang/rust/commit/e9f1b063295c48c97e239ce479b08f192a3eece4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9f1b063295c48c97e239ce479b08f192a3eece4/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2e13e822a73e0ea46ae9e21afdd3155fc997f6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2e13e822a73e0ea46ae9e21afdd3155fc997f6d", "html_url": "https://github.com/rust-lang/rust/commit/d2e13e822a73e0ea46ae9e21afdd3155fc997f6d"}], "stats": {"total": 3635, "additions": 1072, "deletions": 2563}, "files": [{"sha": "03a52e3cfe46968a45ffafaf733ceb71c9260b35", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -17,7 +17,7 @@ use metadata::inline::InlinedItem as II;\n use middle::def_id::DefId;\n \n use syntax::abi;\n-use syntax::ast::{Name, NodeId, Ident, CRATE_NODE_ID, DUMMY_NODE_ID};\n+use syntax::ast::{self, Name, NodeId, Ident, CRATE_NODE_ID, DUMMY_NODE_ID};\n use syntax::codemap::{Span, Spanned};\n use syntax::parse::token;\n \n@@ -538,7 +538,7 @@ impl<'ast> Map<'ast> {\n \n     /// Given a node ID, get a list of of attributes associated with the AST\n     /// corresponding to the Node ID\n-    pub fn attrs(&self, id: NodeId) -> &'ast [Attribute] {\n+    pub fn attrs(&self, id: NodeId) -> &'ast [ast::Attribute] {\n         let attrs = match self.find(id) {\n             Some(NodeItem(i)) => Some(&i.attrs[..]),\n             Some(NodeForeignItem(fi)) => Some(&fi.attrs[..]),"}, {"sha": "afc33c0a12c7d10514f3e706b03688b51552e6e1", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 7, "deletions": 41, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -37,13 +37,13 @@ use std::cell::RefCell;\n use std::cmp;\n use std::mem;\n use syntax::ast_util::IdVisitingOperation;\n-use rustc_front::attr::{self, AttrMetaMethods};\n-use rustc_front::util;\n+use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n use syntax::ast;\n use rustc_front::hir;\n use rustc_front::visit::{self, Visitor, FnKind};\n+use rustc_front::util;\n use syntax::visit::Visitor as SyntaxVisitor;\n use syntax::diagnostic;\n \n@@ -286,7 +286,7 @@ macro_rules! run_lints { ($cx:expr, $f:ident, $($args:expr),*) => ({\n /// Parse the lint attributes into a vector, with `Err`s for malformed lint\n /// attributes. Writing this as an iterator is an enormous mess.\n // See also the hir version just below.\n-pub fn gather_attrs(attrs: &[hir::Attribute])\n+pub fn gather_attrs(attrs: &[ast::Attribute])\n                     -> Vec<Result<(InternedString, Level, Span), Span>> {\n     let mut out = vec!();\n     for attr in attrs {\n@@ -299,39 +299,7 @@ pub fn gather_attrs(attrs: &[hir::Attribute])\n \n         let meta = &attr.node.value;\n         let metas = match meta.node {\n-            hir::MetaList(_, ref metas) => metas,\n-            _ => {\n-                out.push(Err(meta.span));\n-                continue;\n-            }\n-        };\n-\n-        for meta in metas {\n-            out.push(match meta.node {\n-                hir::MetaWord(ref lint_name) => Ok((lint_name.clone(), level, meta.span)),\n-                _ => Err(meta.span),\n-            });\n-        }\n-    }\n-    out\n-}\n-// Copy-pasted from the above function :-(\n-pub fn gather_attrs_from_hir(attrs: &[::rustc_front::hir::Attribute])\n-                             -> Vec<Result<(InternedString, Level, Span), Span>> {\n-    use ::rustc_front::attr::AttrMetaMethods;\n-\n-    let mut out = vec!();\n-    for attr in attrs {\n-        let level = match Level::from_str(&attr.name()) {\n-            None => continue,\n-            Some(lvl) => lvl,\n-        };\n-\n-        ::rustc_front::attr::mark_used(attr);\n-\n-        let meta = &attr.node.value;\n-        let metas = match meta.node {\n-            ::rustc_front::hir::MetaList(_, ref metas) => metas,\n+            ast::MetaList(_, ref metas) => metas,\n             _ => {\n                 out.push(Err(meta.span));\n                 continue;\n@@ -340,9 +308,7 @@ pub fn gather_attrs_from_hir(attrs: &[::rustc_front::hir::Attribute])\n \n         for meta in metas {\n             out.push(match meta.node {\n-                ::rustc_front::hir::MetaWord(ref lint_name) => {\n-                    Ok((lint_name.clone(), level, meta.span))\n-                }\n+                ast::MetaWord(ref lint_name) => Ok((lint_name.clone(), level, meta.span)),\n                 _ => Err(meta.span),\n             });\n         }\n@@ -454,7 +420,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n     /// current lint context, call the provided function, then reset the\n     /// lints in effect to their previous state.\n     fn with_lint_attrs<F>(&mut self,\n-                          attrs: &[hir::Attribute],\n+                          attrs: &[ast::Attribute],\n                           f: F) where\n         F: FnOnce(&mut Context),\n     {\n@@ -675,7 +641,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n         visit::walk_path(self, p);\n     }\n \n-    fn visit_attribute(&mut self, attr: &hir::Attribute) {\n+    fn visit_attribute(&mut self, attr: &ast::Attribute) {\n         run_lints!(self, check_attribute, attr);\n     }\n }"}, {"sha": "11a1852ed2509c2f0a3f75efbab9d9b8c6154bc0", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -39,7 +39,7 @@ use syntax::ast;\n use rustc_front::hir;\n \n pub use lint::context::{Context, LintStore, raw_emit_lint, check_crate, gather_attrs,\n-                        gather_attrs_from_hir, GatherNodeLevels};\n+                        GatherNodeLevels};\n \n /// Specification of a single lint.\n #[derive(Copy, Clone, Debug)]\n@@ -158,14 +158,14 @@ pub trait LintPass {\n     fn check_explicit_self(&mut self, _: &Context, _: &hir::ExplicitSelf) { }\n     fn check_mac(&mut self, _: &Context, _: &ast::Mac) { }\n     fn check_path(&mut self, _: &Context, _: &hir::Path, _: ast::NodeId) { }\n-    fn check_attribute(&mut self, _: &Context, _: &hir::Attribute) { }\n+    fn check_attribute(&mut self, _: &Context, _: &ast::Attribute) { }\n \n     /// Called when entering a syntax node that can have lint attributes such\n     /// as `#[allow(...)]`. Called with *all* the attributes of that node.\n-    fn enter_lint_attrs(&mut self, _: &Context, _: &[hir::Attribute]) { }\n+    fn enter_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) { }\n \n     /// Counterpart to `enter_lint_attrs`.\n-    fn exit_lint_attrs(&mut self, _: &Context, _: &[hir::Attribute]) { }\n+    fn exit_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) { }\n }\n \n /// A lint pass boxed up as a trait object."}, {"sha": "90b7b1c960b5b65d8ef7175fb4e89ab7dcac4f6d", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -33,13 +33,11 @@ use syntax::abi;\n use syntax::codemap::{self, Span, mk_sp, Pos};\n use syntax::parse;\n use syntax::attr;\n+use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::InternedString;\n use syntax::util::small_vector::SmallVector;\n use rustc_front::visit;\n use rustc_front::hir;\n-use rustc_front::attr as attr_front;\n-use rustc_front::attr::AttrMetaMethods;\n-use rustc_front::lowering::unlower_attribute;\n use log;\n \n pub struct LocalCrateReader<'a, 'b:'a> {\n@@ -79,10 +77,9 @@ fn dump_crates(cstore: &CStore) {\n fn should_link(i: &ast::Item) -> bool {\n     !attr::contains_name(&i.attrs, \"no_link\")\n }\n-\n // Dup for the hir\n fn should_link_hir(i: &hir::Item) -> bool {\n-    !attr_front::contains_name(&i.attrs, \"no_link\")\n+    !attr::contains_name(&i.attrs, \"no_link\")\n }\n \n struct CrateInfo {\n@@ -329,7 +326,7 @@ impl<'a> CrateReader<'a> {\n         let attrs = decoder::get_crate_attributes(data);\n         for attr in &attrs {\n             if &attr.name()[..] == \"staged_api\" {\n-                match attr.node.value.node { hir::MetaWord(_) => return true, _ => (/*pass*/) }\n+                match attr.node.value.node { ast::MetaWord(_) => return true, _ => (/*pass*/) }\n             }\n         }\n \n@@ -483,7 +480,7 @@ impl<'a> CrateReader<'a> {\n                 p.abort_if_errors();\n                 macros.push(ast::MacroDef {\n                     ident: name.ident(),\n-                    attrs: attrs.iter().map(|a| unlower_attribute(a)).collect(),\n+                    attrs: attrs,\n                     id: ast::DUMMY_NODE_ID,\n                     span: span,\n                     imported_from: Some(item.ident),"}, {"sha": "88d73b3feb3908e1bf877175b9476a101770f076", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -21,7 +21,7 @@ use util::nodemap::FnvHashMap;\n \n use std::rc::Rc;\n use syntax::ast;\n-use rustc_front::attr;\n+use syntax::attr;\n use rustc_front::hir;\n \n #[derive(Copy, Clone)]\n@@ -186,7 +186,7 @@ pub fn get_methods_if_impl(cstore: &cstore::CStore,\n \n pub fn get_item_attrs(cstore: &cstore::CStore,\n                       def_id: DefId)\n-                      -> Vec<hir::Attribute> {\n+                      -> Vec<ast::Attribute> {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_item_attrs(&*cdata, def_id.node)\n }\n@@ -197,7 +197,7 @@ pub fn get_struct_field_names(cstore: &cstore::CStore, def: DefId) -> Vec<ast::N\n }\n \n pub fn get_struct_field_attrs(cstore: &cstore::CStore, def: DefId) -> FnvHashMap<ast::NodeId,\n-        Vec<hir::Attribute>> {\n+        Vec<ast::Attribute>> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_struct_field_attrs(&*cdata)\n }"}, {"sha": "5f60fa8ff40e3122577adf66ff406cd745e389a3", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -27,7 +27,7 @@ use std::rc::Rc;\n use std::path::PathBuf;\n use flate::Bytes;\n use syntax::ast;\n-use rustc_front::attr;\n+use syntax::attr;\n use syntax::codemap;\n use syntax::parse::token;\n use syntax::parse::token::IdentInterner;"}, {"sha": "050e04bff8307113be98644b1c17fdc0486c9e68", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -16,7 +16,6 @@ pub use self::DefLike::*;\n use self::Family::*;\n \n use front::map as ast_map;\n-use rustc_front::print::pprust;\n use rustc_front::hir;\n \n use back::svh::Svh;\n@@ -46,12 +45,13 @@ use std::str;\n use rbml::reader;\n use rbml;\n use serialize::Decodable;\n-use rustc_front::attr;\n+use syntax::attr;\n use syntax::parse::token::{IdentInterner, special_idents};\n use syntax::parse::token;\n use syntax::ast;\n use syntax::abi;\n use syntax::codemap;\n+use syntax::print::pprust;\n use syntax::ptr::P;\n \n \n@@ -1041,7 +1041,7 @@ pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n \n pub fn get_item_attrs(cdata: Cmd,\n                       orig_node_id: ast::NodeId)\n-                      -> Vec<hir::Attribute> {\n+                      -> Vec<ast::Attribute> {\n     // The attributes for a tuple struct are attached to the definition, not the ctor;\n     // we assume that someone passing in a tuple struct ctor is actually wanting to\n     // look at the definition\n@@ -1051,7 +1051,7 @@ pub fn get_item_attrs(cdata: Cmd,\n     get_attributes(item)\n }\n \n-pub fn get_struct_field_attrs(cdata: Cmd) -> FnvHashMap<ast::NodeId, Vec<hir::Attribute>> {\n+pub fn get_struct_field_attrs(cdata: Cmd) -> FnvHashMap<ast::NodeId, Vec<ast::Attribute>> {\n     let data = rbml::Doc::new(cdata.data());\n     let fields = reader::get_doc(data, tag_struct_fields);\n     reader::tagged_docs(fields, tag_struct_field).map(|field| {\n@@ -1079,7 +1079,7 @@ pub fn get_struct_field_names(intr: &IdentInterner, cdata: Cmd, id: ast::NodeId)\n     })).collect()\n }\n \n-fn get_meta_items(md: rbml::Doc) -> Vec<P<hir::MetaItem>> {\n+fn get_meta_items(md: rbml::Doc) -> Vec<P<ast::MetaItem>> {\n     reader::tagged_docs(md, tag_meta_item_word).map(|meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = token::intern_and_get_ident(nd.as_str_slice());\n@@ -1100,7 +1100,7 @@ fn get_meta_items(md: rbml::Doc) -> Vec<P<hir::MetaItem>> {\n     })).collect()\n }\n \n-fn get_attributes(md: rbml::Doc) -> Vec<hir::Attribute> {\n+fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n     match reader::maybe_get_doc(md, tag_attributes) {\n         Some(attrs_d) => {\n             reader::tagged_docs(attrs_d, tag_attribute).map(|attr_doc| {\n@@ -1113,9 +1113,9 @@ fn get_attributes(md: rbml::Doc) -> Vec<hir::Attribute> {\n                 assert_eq!(meta_items.len(), 1);\n                 let meta_item = meta_items.into_iter().nth(0).unwrap();\n                 codemap::Spanned {\n-                    node: hir::Attribute_ {\n+                    node: ast::Attribute_ {\n                         id: attr::mk_attr_id(),\n-                        style: hir::AttrOuter,\n+                        style: ast::AttrOuter,\n                         value: meta_item,\n                         is_sugared_doc: is_sugared_doc,\n                     },\n@@ -1139,7 +1139,7 @@ fn list_crate_attributes(md: rbml::Doc, hash: &Svh,\n     write!(out, \"\\n\\n\")\n }\n \n-pub fn get_crate_attributes(data: &[u8]) -> Vec<hir::Attribute> {\n+pub fn get_crate_attributes(data: &[u8]) -> Vec<ast::Attribute> {\n     get_attributes(rbml::Doc::new(data))\n }\n \n@@ -1337,7 +1337,7 @@ pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<ast::NodeId> {\n }\n \n pub fn each_exported_macro<F>(data: &[u8], intr: &IdentInterner, mut f: F) where\n-    F: FnMut(ast::Name, Vec<hir::Attribute>, String) -> bool,\n+    F: FnMut(ast::Name, Vec<ast::Attribute>, String) -> bool,\n {\n     let macros = reader::get_doc(rbml::Doc::new(data), tag_macro_defs);\n     for macro_doc in reader::tagged_docs(macros, tag_macro_def) {"}, {"sha": "83dc2f04e4682e948d5921309827a4db2985cf05", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 77, "deletions": 77, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -34,17 +34,17 @@ use std::io::prelude::*;\n use std::io::{Cursor, SeekFrom};\n use std::rc::Rc;\n use syntax::abi;\n-use syntax::ast::{NodeId, Name, CRATE_NODE_ID, CrateNum};\n+use syntax::ast::{self, NodeId, Name, CRATE_NODE_ID, CrateNum};\n+use syntax::attr;\n+use syntax::attr::AttrMetaMethods;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token::special_idents;\n use syntax;\n use rbml::writer::Encoder;\n \n-use rustc_front::hir as ast;\n+use rustc_front::hir;\n use rustc_front::visit::Visitor;\n use rustc_front::visit;\n-use rustc_front::attr;\n-use rustc_front::attr::AttrMetaMethods;\n use front::map::{LinkedPath, PathElem, PathElems};\n use front::map as ast_map;\n \n@@ -272,7 +272,7 @@ fn encode_struct_fields(rbml_w: &mut Encoder,\n fn encode_enum_variant_info(ecx: &EncodeContext,\n                             rbml_w: &mut Encoder,\n                             id: NodeId,\n-                            vis: ast::Visibility,\n+                            vis: hir::Visibility,\n                             index: &mut Vec<IndexEntry>) {\n     debug!(\"encode_enum_variant_info(id={})\", id);\n \n@@ -445,12 +445,12 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n /// top-level items that are sub-items of the given item. Specifically:\n ///\n /// * For newtype structs, iterates through the node ID of the constructor.\n-fn each_auxiliary_node_id<F>(item: &ast::Item, callback: F) -> bool where\n+fn each_auxiliary_node_id<F>(item: &hir::Item, callback: F) -> bool where\n     F: FnOnce(NodeId) -> bool,\n {\n     let mut continue_ = true;\n     match item.node {\n-        ast::ItemStruct(ref struct_def, _) => {\n+        hir::ItemStruct(ref struct_def, _) => {\n             // If this is a newtype struct, return the constructor.\n             match struct_def.ctor_id {\n                 Some(ctor_id) if !struct_def.fields.is_empty() &&\n@@ -496,12 +496,12 @@ fn encode_reexports(ecx: &EncodeContext,\n \n fn encode_info_for_mod(ecx: &EncodeContext,\n                        rbml_w: &mut Encoder,\n-                       md: &ast::Mod,\n+                       md: &hir::Mod,\n                        attrs: &[ast::Attribute],\n                        id: NodeId,\n                        path: PathElems,\n                        name: Name,\n-                       vis: ast::Visibility) {\n+                       vis: hir::Visibility) {\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id(rbml_w, DefId::local(id));\n     encode_family(rbml_w, 'm');\n@@ -519,7 +519,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n             true\n         });\n \n-        if let ast::ItemImpl(..) = item.node {\n+        if let hir::ItemImpl(..) = item.node {\n             let (ident, did) = (item.ident, item.id);\n             debug!(\"(encoding info for module) ... encoding impl {} ({}/{})\",\n                    ident,\n@@ -536,7 +536,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     encode_stability(rbml_w, stab);\n \n     // Encode the reexports of this module, if this module is public.\n-    if vis == ast::Public {\n+    if vis == hir::Public {\n         debug!(\"(encoding info for module) encoding reexports for {}\", id);\n         encode_reexports(ecx, rbml_w, id, path);\n     }\n@@ -546,26 +546,26 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n }\n \n fn encode_struct_field_family(rbml_w: &mut Encoder,\n-                              visibility: ast::Visibility) {\n+                              visibility: hir::Visibility) {\n     encode_family(rbml_w, match visibility {\n-        ast::Public => 'g',\n-        ast::Inherited => 'N'\n+        hir::Public => 'g',\n+        hir::Inherited => 'N'\n     });\n }\n \n-fn encode_visibility(rbml_w: &mut Encoder, visibility: ast::Visibility) {\n+fn encode_visibility(rbml_w: &mut Encoder, visibility: hir::Visibility) {\n     let ch = match visibility {\n-        ast::Public => 'y',\n-        ast::Inherited => 'i',\n+        hir::Public => 'y',\n+        hir::Inherited => 'i',\n     };\n     rbml_w.wr_tagged_u8(tag_items_data_item_visibility, ch as u8);\n }\n \n-fn encode_constness(rbml_w: &mut Encoder, constness: ast::Constness) {\n+fn encode_constness(rbml_w: &mut Encoder, constness: hir::Constness) {\n     rbml_w.start_tag(tag_items_data_item_constness);\n     let ch = match constness {\n-        ast::Constness::Const => 'c',\n-        ast::Constness::NotConst => 'n',\n+        hir::Constness::Const => 'c',\n+        hir::Constness::NotConst => 'n',\n     };\n     rbml_w.wr_str(&ch.to_string());\n     rbml_w.end_tag();\n@@ -593,10 +593,10 @@ fn encode_explicit_self(rbml_w: &mut Encoder,\n         }\n     }\n \n-    fn encode_mutability(m: ast::Mutability) -> u8 {\n+    fn encode_mutability(m: hir::Mutability) -> u8 {\n         match m {\n-            ast::MutImmutable => 'i' as u8,\n-            ast::MutMutable => 'm' as u8,\n+            hir::MutImmutable => 'i' as u8,\n+            hir::MutMutable => 'm' as u8,\n         }\n     }\n }\n@@ -784,7 +784,7 @@ fn encode_info_for_associated_const(ecx: &EncodeContext,\n                                     associated_const: &ty::AssociatedConst,\n                                     impl_path: PathElems,\n                                     parent_id: NodeId,\n-                                    impl_item_opt: Option<&ast::ImplItem>) {\n+                                    impl_item_opt: Option<&hir::ImplItem>) {\n     debug!(\"encode_info_for_associated_const({:?},{:?})\",\n            associated_const.def_id,\n            associated_const.name);\n@@ -822,7 +822,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                     impl_path: PathElems,\n                                     is_default_impl: bool,\n                                     parent_id: NodeId,\n-                                    impl_item_opt: Option<&ast::ImplItem>) {\n+                                    impl_item_opt: Option<&hir::ImplItem>) {\n \n     debug!(\"encode_info_for_method: {:?} {:?}\", m.def_id,\n            m.name);\n@@ -841,13 +841,13 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     let elem = ast_map::PathName(m.name);\n     encode_path(rbml_w, impl_path.chain(Some(elem)));\n     if let Some(impl_item) = impl_item_opt {\n-        if let ast::MethodImplItem(ref sig, _) = impl_item.node {\n+        if let hir::MethodImplItem(ref sig, _) = impl_item.node {\n             encode_attributes(rbml_w, &impl_item.attrs);\n             let scheme = ecx.tcx.lookup_item_type(m.def_id);\n             let any_types = !scheme.generics.types.is_empty();\n             let needs_inline = any_types || is_default_impl ||\n                                attr::requests_inline(&impl_item.attrs);\n-            if needs_inline || sig.constness == ast::Constness::Const {\n+            if needs_inline || sig.constness == hir::Constness::Const {\n                 encode_inlined_item(ecx, rbml_w, InlinedItemRef::ImplItem(DefId::local(parent_id),\n                                                                impl_item));\n             }\n@@ -867,7 +867,7 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                              associated_type: &ty::AssociatedType<'tcx>,\n                                              impl_path: PathElems,\n                                              parent_id: NodeId,\n-                                             impl_item_opt: Option<&ast::ImplItem>) {\n+                                             impl_item_opt: Option<&hir::ImplItem>) {\n     debug!(\"encode_info_for_associated_type({:?},{:?})\",\n            associated_type.def_id,\n            associated_type.name);\n@@ -903,11 +903,11 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n }\n \n fn encode_method_argument_names(rbml_w: &mut Encoder,\n-                                decl: &ast::FnDecl) {\n+                                decl: &hir::FnDecl) {\n     rbml_w.start_tag(tag_method_argument_names);\n     for arg in &decl.inputs {\n         let tag = tag_method_argument_name;\n-        if let ast::PatIdent(_, ref path1, _) = arg.pat.node {\n+        if let hir::PatIdent(_, ref path1, _) = arg.pat.node {\n             let name = path1.node.name.as_str();\n             rbml_w.wr_tagged_bytes(tag, name.as_bytes());\n         } else {\n@@ -982,13 +982,13 @@ fn encode_stability(rbml_w: &mut Encoder, stab_opt: Option<&attr::Stability>) {\n \n fn encode_info_for_item(ecx: &EncodeContext,\n                         rbml_w: &mut Encoder,\n-                        item: &ast::Item,\n+                        item: &hir::Item,\n                         index: &mut Vec<IndexEntry>,\n                         path: PathElems,\n-                        vis: ast::Visibility) {\n+                        vis: hir::Visibility) {\n     let tcx = ecx.tcx;\n \n-    fn add_to_index(item: &ast::Item, rbml_w: &mut Encoder,\n+    fn add_to_index(item: &hir::Item, rbml_w: &mut Encoder,\n                     index: &mut Vec<IndexEntry>) {\n         index.push(IndexEntry {\n             node: item.id,\n@@ -1003,11 +1003,11 @@ fn encode_info_for_item(ecx: &EncodeContext,\n     let stab = stability::lookup(tcx, DefId::local(item.id));\n \n     match item.node {\n-      ast::ItemStatic(_, m, _) => {\n+      hir::ItemStatic(_, m, _) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n-        if m == ast::MutMutable {\n+        if m == hir::MutMutable {\n             encode_family(rbml_w, 'b');\n         } else {\n             encode_family(rbml_w, 'c');\n@@ -1021,7 +1021,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_attributes(rbml_w, &item.attrs);\n         rbml_w.end_tag();\n       }\n-      ast::ItemConst(_, _) => {\n+      hir::ItemConst(_, _) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -1035,7 +1035,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_stability(rbml_w, stab);\n         rbml_w.end_tag();\n       }\n-      ast::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n+      hir::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -1046,7 +1046,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs);\n         let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n-        if needs_inline || constness == ast::Constness::Const {\n+        if needs_inline || constness == hir::Constness::Const {\n             encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n         }\n         if tps_len == 0 {\n@@ -1058,7 +1058,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_method_argument_names(rbml_w, &**decl);\n         rbml_w.end_tag();\n       }\n-      ast::ItemMod(ref m) => {\n+      hir::ItemMod(ref m) => {\n         add_to_index(item, rbml_w, index);\n         encode_info_for_mod(ecx,\n                             rbml_w,\n@@ -1069,7 +1069,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                             item.ident.name,\n                             item.vis);\n       }\n-      ast::ItemForeignMod(ref fm) => {\n+      hir::ItemForeignMod(ref fm) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -1086,7 +1086,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_stability(rbml_w, stab);\n         rbml_w.end_tag();\n       }\n-      ast::ItemTy(..) => {\n+      hir::ItemTy(..) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -1098,7 +1098,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_stability(rbml_w, stab);\n         rbml_w.end_tag();\n       }\n-      ast::ItemEnum(ref enum_definition, _) => {\n+      hir::ItemEnum(ref enum_definition, _) => {\n         add_to_index(item, rbml_w, index);\n \n         rbml_w.start_tag(tag_items_data_item);\n@@ -1128,7 +1128,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                  vis,\n                                  index);\n       }\n-      ast::ItemStruct(ref struct_def, _) => {\n+      hir::ItemStruct(ref struct_def, _) => {\n         let def = ecx.tcx.lookup_adt_def(def_id);\n         let variant = def.struct_variant();\n \n@@ -1174,7 +1174,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             None => {}\n         }\n       }\n-      ast::ItemDefaultImpl(unsafety, _) => {\n+      hir::ItemDefaultImpl(unsafety, _) => {\n           add_to_index(item, rbml_w, index);\n           rbml_w.start_tag(tag_items_data_item);\n           encode_def_id(rbml_w, def_id);\n@@ -1186,7 +1186,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n           encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n           rbml_w.end_tag();\n       }\n-      ast::ItemImpl(unsafety, polarity, _, _, ref ty, ref ast_items) => {\n+      hir::ItemImpl(unsafety, polarity, _, _, ref ty, ref ast_items) => {\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n         let impl_items = tcx.impl_items.borrow();\n@@ -1212,7 +1212,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n \n         match ty.node {\n-            ast::TyPath(None, ref path) if path.segments.len() == 1 => {\n+            hir::TyPath(None, ref path) if path.segments.len() == 1 => {\n                 let name = path.segments.last().unwrap().identifier.name;\n                 encode_impl_type_basename(rbml_w, name);\n             }\n@@ -1289,7 +1289,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n         }\n       }\n-      ast::ItemTrait(_, _, _, ref ms) => {\n+      hir::ItemTrait(_, _, _, ref ms) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -1429,11 +1429,11 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             let trait_item = &*ms[i];\n             encode_attributes(rbml_w, &trait_item.attrs);\n             match trait_item.node {\n-                ast::ConstTraitItem(_, _) => {\n+                hir::ConstTraitItem(_, _) => {\n                     encode_inlined_item(ecx, rbml_w,\n                                         InlinedItemRef::TraitItem(def_id, trait_item));\n                 }\n-                ast::MethodTraitItem(ref sig, ref body) => {\n+                hir::MethodTraitItem(ref sig, ref body) => {\n                     // If this is a static method, we've already\n                     // encoded this.\n                     if is_nonstatic_method {\n@@ -1453,21 +1453,21 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     encode_method_argument_names(rbml_w, &sig.decl);\n                 }\n \n-                ast::TypeTraitItem(..) => {}\n+                hir::TypeTraitItem(..) => {}\n             }\n \n             rbml_w.end_tag();\n         }\n       }\n-      ast::ItemExternCrate(_) | ast::ItemUse(_) => {\n+      hir::ItemExternCrate(_) | hir::ItemUse(_) => {\n         // these are encoded separately\n       }\n     }\n }\n \n fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 rbml_w: &mut Encoder,\n-                                nitem: &ast::ForeignItem,\n+                                nitem: &hir::ForeignItem,\n                                 index: &mut Vec<IndexEntry>,\n                                 path: PathElems,\n                                 abi: abi::Abi) {\n@@ -1480,7 +1480,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n     encode_def_id(rbml_w, DefId::local(nitem.id));\n     encode_visibility(rbml_w, nitem.vis);\n     match nitem.node {\n-      ast::ForeignItemFn(ref fndecl, _) => {\n+      hir::ForeignItemFn(ref fndecl, _) => {\n         encode_family(rbml_w, FN_FAMILY);\n         encode_bounds_and_type_for_item(rbml_w, ecx, nitem.id);\n         encode_name(rbml_w, nitem.ident.name);\n@@ -1493,7 +1493,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         encode_symbol(ecx, rbml_w, nitem.id);\n         encode_method_argument_names(rbml_w, &*fndecl);\n       }\n-      ast::ForeignItemStatic(_, mutbl) => {\n+      hir::ForeignItemStatic(_, mutbl) => {\n         if mutbl {\n             encode_family(rbml_w, 'b');\n         } else {\n@@ -1511,9 +1511,9 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n     rbml_w.end_tag();\n }\n \n-fn my_visit_expr(_e: &ast::Expr) { }\n+fn my_visit_expr(_e: &hir::Expr) { }\n \n-fn my_visit_item(i: &ast::Item,\n+fn my_visit_item(i: &hir::Item,\n                  rbml_w: &mut Encoder,\n                  ecx: &EncodeContext,\n                  index: &mut Vec<IndexEntry>) {\n@@ -1522,7 +1522,7 @@ fn my_visit_item(i: &ast::Item,\n     });\n }\n \n-fn my_visit_foreign_item(ni: &ast::ForeignItem,\n+fn my_visit_foreign_item(ni: &hir::ForeignItem,\n                          rbml_w: &mut Encoder,\n                          ecx: &EncodeContext,\n                          index: &mut Vec<IndexEntry>) {\n@@ -1545,18 +1545,18 @@ struct EncodeVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n }\n \n impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n-    fn visit_expr(&mut self, ex: &ast::Expr) {\n+    fn visit_expr(&mut self, ex: &hir::Expr) {\n         visit::walk_expr(self, ex);\n         my_visit_expr(ex);\n     }\n-    fn visit_item(&mut self, i: &ast::Item) {\n+    fn visit_item(&mut self, i: &hir::Item) {\n         visit::walk_item(self, i);\n         my_visit_item(i,\n                       self.rbml_w_for_visit_item,\n                       self.ecx,\n                       self.index);\n     }\n-    fn visit_foreign_item(&mut self, ni: &ast::ForeignItem) {\n+    fn visit_foreign_item(&mut self, ni: &hir::ForeignItem) {\n         visit::walk_foreign_item(self, ni);\n         my_visit_foreign_item(ni,\n                               self.rbml_w_for_visit_item,\n@@ -1567,7 +1567,7 @@ impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n \n fn encode_info_for_items(ecx: &EncodeContext,\n                          rbml_w: &mut Encoder,\n-                         krate: &ast::Crate)\n+                         krate: &hir::Crate)\n                          -> Vec<IndexEntry> {\n     let mut index = Vec::new();\n     rbml_w.start_tag(tag_items_data);\n@@ -1582,7 +1582,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                         CRATE_NODE_ID,\n                         [].iter().cloned().chain(LinkedPath::empty()),\n                         syntax::parse::token::special_idents::invalid.name,\n-                        ast::Public);\n+                        hir::Public);\n \n     visit::walk_crate(&mut EncodeVisitor {\n         index: &mut index,\n@@ -1644,10 +1644,10 @@ fn encode_attributes(rbml_w: &mut Encoder, attrs: &[ast::Attribute]) {\n     rbml_w.end_tag();\n }\n \n-fn encode_unsafety(rbml_w: &mut Encoder, unsafety: ast::Unsafety) {\n+fn encode_unsafety(rbml_w: &mut Encoder, unsafety: hir::Unsafety) {\n     let byte: u8 = match unsafety {\n-        ast::Unsafety::Normal => 0,\n-        ast::Unsafety::Unsafe => 1,\n+        hir::Unsafety::Normal => 0,\n+        hir::Unsafety::Unsafe => 1,\n     };\n     rbml_w.wr_tagged_u8(tag_unsafety, byte);\n }\n@@ -1670,10 +1670,10 @@ fn encode_associated_type_names(rbml_w: &mut Encoder, names: &[Name]) {\n     rbml_w.end_tag();\n }\n \n-fn encode_polarity(rbml_w: &mut Encoder, polarity: ast::ImplPolarity) {\n+fn encode_polarity(rbml_w: &mut Encoder, polarity: hir::ImplPolarity) {\n     let byte: u8 = match polarity {\n-        ast::ImplPolarity::Positive => 0,\n-        ast::ImplPolarity::Negative => 1,\n+        hir::ImplPolarity::Positive => 0,\n+        hir::ImplPolarity::Negative => 1,\n     };\n     rbml_w.wr_tagged_u8(tag_polarity, byte);\n }\n@@ -1782,7 +1782,7 @@ fn encode_codemap(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n \n /// Serialize the text of the exported macros\n fn encode_macro_defs(rbml_w: &mut Encoder,\n-                     krate: &ast::Crate) {\n+                     krate: &hir::Crate) {\n     rbml_w.start_tag(tag_macro_defs);\n     for def in &krate.exported_macros {\n         rbml_w.start_tag(tag_macro_def);\n@@ -1798,13 +1798,13 @@ fn encode_macro_defs(rbml_w: &mut Encoder,\n     rbml_w.end_tag();\n }\n \n-fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &ast::Crate) {\n+fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &hir::Crate) {\n     struct StructFieldVisitor<'a, 'b:'a> {\n         rbml_w: &'a mut Encoder<'b>,\n     }\n \n     impl<'a, 'b, 'v> Visitor<'v> for StructFieldVisitor<'a, 'b> {\n-        fn visit_struct_field(&mut self, field: &ast::StructField) {\n+        fn visit_struct_field(&mut self, field: &hir::StructField) {\n             self.rbml_w.start_tag(tag_struct_field);\n             self.rbml_w.wr_tagged_u32(tag_struct_field_id, field.node.id);\n             encode_attributes(self.rbml_w, &field.node.attrs);\n@@ -1827,8 +1827,8 @@ struct ImplVisitor<'a, 'b:'a, 'c:'a, 'tcx:'b> {\n }\n \n impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        if let ast::ItemImpl(_, _, _, Some(ref trait_ref), _, _) = item.node {\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        if let hir::ItemImpl(_, _, _, Some(ref trait_ref), _, _) = item.node {\n             let def_id = self.ecx.tcx.def_map.borrow().get(&trait_ref.ref_id).unwrap().def_id();\n \n             // Load eagerly if this is an implementation of the Drop trait\n@@ -1856,7 +1856,7 @@ impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n ///\n /// * Implementations of traits not defined in this crate.\n fn encode_impls<'a>(ecx: &'a EncodeContext,\n-                    krate: &ast::Crate,\n+                    krate: &hir::Crate,\n                     rbml_w: &'a mut Encoder) {\n     rbml_w.start_tag(tag_impls);\n \n@@ -1872,7 +1872,7 @@ fn encode_impls<'a>(ecx: &'a EncodeContext,\n }\n \n fn encode_misc_info(ecx: &EncodeContext,\n-                    krate: &ast::Crate,\n+                    krate: &hir::Crate,\n                     rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_misc_info);\n     rbml_w.start_tag(tag_misc_info_crate_items);\n@@ -1956,7 +1956,7 @@ fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n #[allow(non_upper_case_globals)]\n pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 2 ];\n \n-pub fn encode_metadata(parms: EncodeParams, krate: &ast::Crate) -> Vec<u8> {\n+pub fn encode_metadata(parms: EncodeParams, krate: &hir::Crate) -> Vec<u8> {\n     let mut wr = Cursor::new(Vec::new());\n     encode_metadata_inner(&mut wr, parms, krate);\n \n@@ -1995,7 +1995,7 @@ pub fn encode_metadata(parms: EncodeParams, krate: &ast::Crate) -> Vec<u8> {\n \n fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n                          parms: EncodeParams,\n-                         krate: &ast::Crate) {\n+                         krate: &hir::Crate) {\n     struct Stats {\n         attr_bytes: u64,\n         dep_bytes: u64,"}, {"sha": "c4a133fa944841148d5fc88e07f50691d49bd1fb", "filename": "src/librustc/metadata/macro_import.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -21,7 +21,6 @@ use syntax::attr;\n use syntax::visit;\n use syntax::visit::Visitor;\n use syntax::attr::AttrMetaMethods;\n-use rustc_front::attr::AttrMetaMethods as FrontAttrMetaMethods;\n \n struct MacroLoader<'a> {\n     sess: &'a Session,"}, {"sha": "3176f5c9cc42f31bd544e7ce54e7bd3073fc7de9", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -27,6 +27,7 @@ use util::nodemap::FnvHashMap;\n use rustc_front::hir;\n \n use syntax::abi::Abi;\n+use syntax::ast;\n use syntax::diagnostic::SpanHandler;\n \n use rbml::writer::Encoder;\n@@ -65,26 +66,26 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n         ty::TyChar => mywrite!(w, \"c\"),\n         ty::TyInt(t) => {\n             match t {\n-                hir::TyIs => mywrite!(w, \"is\"),\n-                hir::TyI8 => mywrite!(w, \"MB\"),\n-                hir::TyI16 => mywrite!(w, \"MW\"),\n-                hir::TyI32 => mywrite!(w, \"ML\"),\n-                hir::TyI64 => mywrite!(w, \"MD\")\n+                ast::TyIs => mywrite!(w, \"is\"),\n+                ast::TyI8 => mywrite!(w, \"MB\"),\n+                ast::TyI16 => mywrite!(w, \"MW\"),\n+                ast::TyI32 => mywrite!(w, \"ML\"),\n+                ast::TyI64 => mywrite!(w, \"MD\")\n             }\n         }\n         ty::TyUint(t) => {\n             match t {\n-                hir::TyUs => mywrite!(w, \"us\"),\n-                hir::TyU8 => mywrite!(w, \"Mb\"),\n-                hir::TyU16 => mywrite!(w, \"Mw\"),\n-                hir::TyU32 => mywrite!(w, \"Ml\"),\n-                hir::TyU64 => mywrite!(w, \"Md\")\n+                ast::TyUs => mywrite!(w, \"us\"),\n+                ast::TyU8 => mywrite!(w, \"Mb\"),\n+                ast::TyU16 => mywrite!(w, \"Mw\"),\n+                ast::TyU32 => mywrite!(w, \"Ml\"),\n+                ast::TyU64 => mywrite!(w, \"Md\")\n             }\n         }\n         ty::TyFloat(t) => {\n             match t {\n-                hir::TyF32 => mywrite!(w, \"Mf\"),\n-                hir::TyF64 => mywrite!(w, \"MF\"),\n+                ast::TyF32 => mywrite!(w, \"Mf\"),\n+                ast::TyF64 => mywrite!(w, \"MF\"),\n             }\n         }\n         ty::TyEnum(def, substs) => {"}, {"sha": "2e6207b0df51e4e2c6c60a08bcf4993a030fb3c8", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -404,7 +404,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: hir:\n \n fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n     let node = match value {\n-        &ConstVal::Bool(b) => hir::LitBool(b),\n+        &ConstVal::Bool(b) => ast::LitBool(b),\n         _ => unreachable!()\n     };\n     P(hir::Expr {"}, {"sha": "11be35a24f5f74af8636fd44157456ea36acb94f", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -466,35 +466,35 @@ pub enum IntTy { I8, I16, I32, I64 }\n pub enum UintTy { U8, U16, U32, U64 }\n \n impl IntTy {\n-    pub fn from(tcx: &ty::ctxt, t: hir::IntTy) -> IntTy {\n-        let t = if let hir::TyIs = t {\n+    pub fn from(tcx: &ty::ctxt, t: ast::IntTy) -> IntTy {\n+        let t = if let ast::TyIs = t {\n             tcx.sess.target.int_type\n         } else {\n             t\n         };\n         match t {\n-            hir::TyIs => unreachable!(),\n-            hir::TyI8  => IntTy::I8,\n-            hir::TyI16 => IntTy::I16,\n-            hir::TyI32 => IntTy::I32,\n-            hir::TyI64 => IntTy::I64,\n+            ast::TyIs => unreachable!(),\n+            ast::TyI8  => IntTy::I8,\n+            ast::TyI16 => IntTy::I16,\n+            ast::TyI32 => IntTy::I32,\n+            ast::TyI64 => IntTy::I64,\n         }\n     }\n }\n \n impl UintTy {\n-    pub fn from(tcx: &ty::ctxt, t: hir::UintTy) -> UintTy {\n-        let t = if let hir::TyUs = t {\n+    pub fn from(tcx: &ty::ctxt, t: ast::UintTy) -> UintTy {\n+        let t = if let ast::TyUs = t {\n             tcx.sess.target.uint_type\n         } else {\n             t\n         };\n         match t {\n-            hir::TyUs => unreachable!(),\n-            hir::TyU8  => UintTy::U8,\n-            hir::TyU16 => UintTy::U16,\n-            hir::TyU32 => UintTy::U32,\n-            hir::TyU64 => UintTy::U64,\n+            ast::TyUs => unreachable!(),\n+            ast::TyU8  => UintTy::U8,\n+            ast::TyU16 => UintTy::U16,\n+            ast::TyU32 => UintTy::U32,\n+            ast::TyU64 => UintTy::U64,\n         }\n     }\n }\n@@ -1141,60 +1141,60 @@ fn cast_const<'tcx>(tcx: &ty::ctxt<'tcx>, val: ConstVal, ty: Ty) -> CastResult {\n \n     // Issue #23890: If isize/usize, then dispatch to appropriate target representation type\n     match (&ty.sty, tcx.sess.target.int_type, tcx.sess.target.uint_type) {\n-        (&ty::TyInt(hir::TyIs), hir::TyI32, _) => return convert_val!(i32, Int, i64),\n-        (&ty::TyInt(hir::TyIs), hir::TyI64, _) => return convert_val!(i64, Int, i64),\n-        (&ty::TyInt(hir::TyIs), _, _) => panic!(\"unexpected target.int_type\"),\n+        (&ty::TyInt(ast::TyIs), ast::TyI32, _) => return convert_val!(i32, Int, i64),\n+        (&ty::TyInt(ast::TyIs), ast::TyI64, _) => return convert_val!(i64, Int, i64),\n+        (&ty::TyInt(ast::TyIs), _, _) => panic!(\"unexpected target.int_type\"),\n \n-        (&ty::TyUint(hir::TyUs), _, hir::TyU32) => return convert_val!(u32, Uint, u64),\n-        (&ty::TyUint(hir::TyUs), _, hir::TyU64) => return convert_val!(u64, Uint, u64),\n-        (&ty::TyUint(hir::TyUs), _, _) => panic!(\"unexpected target.uint_type\"),\n+        (&ty::TyUint(ast::TyUs), _, ast::TyU32) => return convert_val!(u32, Uint, u64),\n+        (&ty::TyUint(ast::TyUs), _, ast::TyU64) => return convert_val!(u64, Uint, u64),\n+        (&ty::TyUint(ast::TyUs), _, _) => panic!(\"unexpected target.uint_type\"),\n \n         _ => {}\n     }\n \n     match ty.sty {\n-        ty::TyInt(hir::TyIs) => unreachable!(),\n-        ty::TyUint(hir::TyUs) => unreachable!(),\n+        ty::TyInt(ast::TyIs) => unreachable!(),\n+        ty::TyUint(ast::TyUs) => unreachable!(),\n \n-        ty::TyInt(hir::TyI8) => convert_val!(i8, Int, i64),\n-        ty::TyInt(hir::TyI16) => convert_val!(i16, Int, i64),\n-        ty::TyInt(hir::TyI32) => convert_val!(i32, Int, i64),\n-        ty::TyInt(hir::TyI64) => convert_val!(i64, Int, i64),\n+        ty::TyInt(ast::TyI8) => convert_val!(i8, Int, i64),\n+        ty::TyInt(ast::TyI16) => convert_val!(i16, Int, i64),\n+        ty::TyInt(ast::TyI32) => convert_val!(i32, Int, i64),\n+        ty::TyInt(ast::TyI64) => convert_val!(i64, Int, i64),\n \n-        ty::TyUint(hir::TyU8) => convert_val!(u8, Uint, u64),\n-        ty::TyUint(hir::TyU16) => convert_val!(u16, Uint, u64),\n-        ty::TyUint(hir::TyU32) => convert_val!(u32, Uint, u64),\n-        ty::TyUint(hir::TyU64) => convert_val!(u64, Uint, u64),\n+        ty::TyUint(ast::TyU8) => convert_val!(u8, Uint, u64),\n+        ty::TyUint(ast::TyU16) => convert_val!(u16, Uint, u64),\n+        ty::TyUint(ast::TyU32) => convert_val!(u32, Uint, u64),\n+        ty::TyUint(ast::TyU64) => convert_val!(u64, Uint, u64),\n \n-        ty::TyFloat(hir::TyF32) => convert_val!(f32, Float, f64),\n-        ty::TyFloat(hir::TyF64) => convert_val!(f64, Float, f64),\n+        ty::TyFloat(ast::TyF32) => convert_val!(f32, Float, f64),\n+        ty::TyFloat(ast::TyF64) => convert_val!(f64, Float, f64),\n         _ => Err(ErrKind::CannotCast),\n     }\n }\n \n-fn lit_to_const(lit: &hir::Lit, ty_hint: Option<Ty>) -> ConstVal {\n+fn lit_to_const(lit: &ast::Lit, ty_hint: Option<Ty>) -> ConstVal {\n     match lit.node {\n-        hir::LitStr(ref s, _) => Str((*s).clone()),\n-        hir::LitByteStr(ref data) => {\n+        ast::LitStr(ref s, _) => Str((*s).clone()),\n+        ast::LitByteStr(ref data) => {\n             ByteStr(data.clone())\n         }\n-        hir::LitByte(n) => Uint(n as u64),\n-        hir::LitChar(n) => Uint(n as u64),\n-        hir::LitInt(n, hir::SignedIntLit(_, hir::Plus)) => Int(n as i64),\n-        hir::LitInt(n, hir::UnsuffixedIntLit(hir::Plus)) => {\n+        ast::LitByte(n) => Uint(n as u64),\n+        ast::LitChar(n) => Uint(n as u64),\n+        ast::LitInt(n, ast::SignedIntLit(_, ast::Plus)) => Int(n as i64),\n+        ast::LitInt(n, ast::UnsuffixedIntLit(ast::Plus)) => {\n             match ty_hint.map(|ty| &ty.sty) {\n                 Some(&ty::TyUint(_)) => Uint(n),\n                 _ => Int(n as i64)\n             }\n         }\n-        hir::LitInt(n, hir::SignedIntLit(_, hir::Minus)) |\n-        hir::LitInt(n, hir::UnsuffixedIntLit(hir::Minus)) => Int(-(n as i64)),\n-        hir::LitInt(n, hir::UnsignedIntLit(_)) => Uint(n),\n-        hir::LitFloat(ref n, _) |\n-        hir::LitFloatUnsuffixed(ref n) => {\n+        ast::LitInt(n, ast::SignedIntLit(_, ast::Minus)) |\n+        ast::LitInt(n, ast::UnsuffixedIntLit(ast::Minus)) => Int(-(n as i64)),\n+        ast::LitInt(n, ast::UnsignedIntLit(_)) => Uint(n),\n+        ast::LitFloat(ref n, _) |\n+        ast::LitFloatUnsuffixed(ref n) => {\n             Float(n.parse::<f64>().unwrap() as f64)\n         }\n-        hir::LitBool(b) => Bool(b)\n+        ast::LitBool(b) => Bool(b)\n     }\n }\n "}, {"sha": "132efc1ff88269eb3e5875faea0ced62478b9722", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -24,6 +24,7 @@ use std::usize;\n use syntax::ast;\n use syntax::ast_util::IdRange;\n use syntax::print::pp;\n+use syntax::print::pprust::PrintState;\n use util::nodemap::NodeMap;\n use rustc_front::hir;\n use rustc_front::visit;"}, {"sha": "182bc067a7fc177134cc19973522dac3c61acf47", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -15,7 +15,6 @@\n use front::map as ast_map;\n use rustc_front::hir;\n use rustc_front::visit::{self, Visitor};\n-use rustc_front::attr::{self, AttrMetaMethods};\n \n use middle::{def, pat_util, privacy, ty};\n use middle::def_id::{DefId};\n@@ -24,6 +23,7 @@ use util::nodemap::NodeSet;\n \n use std::collections::HashSet;\n use syntax::{ast, codemap};\n+use syntax::attr::{self, AttrMetaMethods};\n \n // Any local node that may call something in its body block should be\n // explored. For example, if it's a live NodeItem that is a\n@@ -285,13 +285,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n }\n \n-fn has_allow_dead_code_or_lang_attr(attrs: &[hir::Attribute]) -> bool {\n+fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n     if attr::contains_name(attrs, \"lang\") {\n         return true;\n     }\n \n     let dead_code = lint::builtin::DEAD_CODE.name_lower();\n-    for attr in lint::gather_attrs_from_hir(attrs) {\n+    for attr in lint::gather_attrs(attrs) {\n         match attr {\n             Ok((ref name, lint::Allow, _))\n                 if &name[..] == dead_code => return true,"}, {"sha": "841859ffec42c6dc7ffeb7481bfafaea014f2020", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -12,10 +12,10 @@\n use front::map as ast_map;\n use session::{config, Session};\n use syntax::ast::NodeId;\n-use rustc_front::hir::{Item, ItemFn};\n-use rustc_front::attr;\n+use syntax::attr;\n use syntax::codemap::Span;\n use syntax::entry::EntryPointType;\n+use rustc_front::hir::{Item, ItemFn};\n use rustc_front::visit;\n use rustc_front::visit::Visitor;\n "}, {"sha": "03554a59655b162c4ef18e7819333a0e2cd7d7bf", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -48,8 +48,8 @@ use middle::ty::error::TypeError;\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n use middle::ty::relate::{Relate, RelateResult, TypeRelation};\n \n+use syntax::ast;\n use syntax::codemap::Span;\n-use rustc_front::hir;\n \n #[derive(Clone)]\n pub struct CombineFields<'a, 'tcx: 'a> {\n@@ -138,7 +138,7 @@ fn unify_integral_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n fn unify_float_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                                  vid_is_expected: bool,\n                                  vid: ty::FloatVid,\n-                                 val: hir::FloatTy)\n+                                 val: ast::FloatTy)\n                                  -> RelateResult<'tcx, Ty<'tcx>>\n {\n     try!(infcx\n@@ -388,7 +388,7 @@ fn int_unification_error<'tcx>(a_is_expected: bool, v: (ty::IntVarValue, ty::Int\n }\n \n fn float_unification_error<'tcx>(a_is_expected: bool,\n-                                 v: (hir::FloatTy, hir::FloatTy))\n+                                 v: (ast::FloatTy, ast::FloatTy))\n                                  -> TypeError<'tcx>\n {\n     let (a, b) = v;"}, {"sha": "41aa191ac24d210f23a3e36dd7cf84293ad6fe5c", "filename": "src/librustc/middle/infer/unify_key.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use syntax::ast;\n use middle::ty::{self, IntVarValue, Ty};\n use rustc_data_structures::unify::UnifyKey;\n-use rustc_front::hir as ast;\n \n pub trait ToType<'tcx> {\n     fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx>;"}, {"sha": "f0aa824c589d3050df829542601e43e94a10b38e", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -28,7 +28,8 @@ use middle::ty;\n use middle::weak_lang_items;\n use util::nodemap::FnvHashMap;\n \n-use rustc_front::attr::AttrMetaMethods;\n+use syntax::ast;\n+use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n use rustc_front::visit::Visitor;\n@@ -216,7 +217,7 @@ impl<'a> LanguageItemCollector<'a> {\n     }\n }\n \n-pub fn extract(attrs: &[hir::Attribute]) -> Option<InternedString> {\n+pub fn extract(attrs: &[ast::Attribute]) -> Option<InternedString> {\n     for attribute in attrs {\n         match attribute.value_str() {\n             Some(ref value) if attribute.check_name(\"lang\") => {"}, {"sha": "3fb3d575f93c6e3cabec67b688853965a58bcc56", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -26,8 +26,8 @@ use util::nodemap::NodeSet;\n use std::collections::HashSet;\n use syntax::abi;\n use syntax::ast;\n+use syntax::attr;\n use rustc_front::hir;\n-use rustc_front::attr;\n use rustc_front::visit::Visitor;\n use rustc_front::visit;\n "}, {"sha": "e29d432707104cfeceb01b97b36d12088418e43c", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -21,13 +21,13 @@ use metadata::csearch;\n use syntax::parse::token::InternedString;\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::ast;\n-use syntax::ast::NodeId;\n+use syntax::ast::{NodeId, Attribute};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n+use syntax::attr::{self, Stability, AttrMetaMethods};\n use util::nodemap::{DefIdMap, FnvHashSet, FnvHashMap};\n \n use rustc_front::hir;\n-use rustc_front::hir::{FnDecl, Attribute, Block, Crate, Item, Generics, StructField, Variant};\n-use rustc_front::attr::{self, Stability, AttrMetaMethods};\n+use rustc_front::hir::{FnDecl, Block, Crate, Item, Generics, StructField, Variant};\n use rustc_front::visit::{self, FnKind, Visitor};\n \n use std::mem::replace;\n@@ -237,7 +237,7 @@ impl<'tcx> Index<'tcx> {\n         for attr in &krate.attrs {\n             if &attr.name()[..] == \"staged_api\" {\n                 match attr.node.value.node {\n-                    hir::MetaWord(_) => {\n+                    ast::MetaWord(_) => {\n                         attr::mark_used(attr);\n                         is_staged_api = true;\n                     }"}, {"sha": "5248cb7f30e97fed681dd1285ab9e6226529e882", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -31,7 +31,7 @@ use middle::ty::fold::TypeFoldable;\n use std::collections::HashMap;\n use std::fmt;\n use syntax::codemap::Span;\n-use rustc_front::attr::{AttributeMethods, AttrMetaMethods};\n+use syntax::attr::{AttributeMethods, AttrMetaMethods};\n \n pub fn report_fulfillment_errors<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                            errors: &Vec<FulfillmentError<'tcx>>) {"}, {"sha": "8233b6b2b2b6e7a61f4a16e3f5ce45442b6814c2", "filename": "src/librustc/middle/ty/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcast.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -13,7 +13,7 @@\n \n use middle::ty::{self, Ty};\n \n-use rustc_front::hir as ast;\n+use syntax::ast;\n \n /// Types that are represented as ints.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]"}, {"sha": "afe88f70d945055a4ed325a317c18bc919489345", "filename": "src/librustc/middle/ty/contents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -16,7 +16,7 @@ use util::nodemap::FnvHashMap;\n use std::fmt;\n use std::ops;\n \n-use rustc_front::hir;\n+use syntax::ast;\n \n /// Type contents is how the type checker reasons about kinds.\n /// They track what kinds of things are found within a type.  You can\n@@ -182,7 +182,7 @@ impl<'tcx> ty::TyS<'tcx> {\n \n             let result = match ty.sty {\n                 // usize and isize are ffi-unsafe\n-                ty::TyUint(hir::TyUs) | ty::TyInt(hir::TyIs) => {\n+                ty::TyUint(ast::TyUs) | ty::TyInt(ast::TyIs) => {\n                     TC::None\n                 }\n "}, {"sha": "31e4765aaaa601862d9de2a30ecf0180ffe22639", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -41,11 +41,11 @@ use std::cell::{Cell, RefCell, Ref};\n use std::hash::{Hash, Hasher};\n use std::rc::Rc;\n use syntax::abi;\n-use syntax::ast::{Name, NodeId};\n+use syntax::ast::{self, Name, NodeId};\n+use syntax::attr;\n use syntax::parse::token::special_idents;\n \n use rustc_front::hir;\n-use rustc_front::attr;\n \n /// Internal storage\n pub struct CtxtArenas<'tcx> {\n@@ -146,18 +146,18 @@ impl<'tcx> CommonTypes<'tcx> {\n             bool: mk(TyBool),\n             char: mk(TyChar),\n             err: mk(TyError),\n-            isize: mk(TyInt(hir::TyIs)),\n-            i8: mk(TyInt(hir::TyI8)),\n-            i16: mk(TyInt(hir::TyI16)),\n-            i32: mk(TyInt(hir::TyI32)),\n-            i64: mk(TyInt(hir::TyI64)),\n-            usize: mk(TyUint(hir::TyUs)),\n-            u8: mk(TyUint(hir::TyU8)),\n-            u16: mk(TyUint(hir::TyU16)),\n-            u32: mk(TyUint(hir::TyU32)),\n-            u64: mk(TyUint(hir::TyU64)),\n-            f32: mk(TyFloat(hir::TyF32)),\n-            f64: mk(TyFloat(hir::TyF64)),\n+            isize: mk(TyInt(ast::TyIs)),\n+            i8: mk(TyInt(ast::TyI8)),\n+            i16: mk(TyInt(ast::TyI16)),\n+            i32: mk(TyInt(ast::TyI32)),\n+            i64: mk(TyInt(ast::TyI64)),\n+            usize: mk(TyUint(ast::TyUs)),\n+            u8: mk(TyUint(ast::TyU8)),\n+            u16: mk(TyUint(ast::TyU16)),\n+            u32: mk(TyUint(ast::TyU32)),\n+            u64: mk(TyUint(ast::TyU64)),\n+            f32: mk(TyFloat(ast::TyF32)),\n+            f64: mk(TyFloat(ast::TyF64)),\n         }\n     }\n }\n@@ -771,30 +771,30 @@ impl<'tcx> ctxt<'tcx> {\n         ctxt::intern_ty(&self.arenas.type_, &self.interner, st)\n     }\n \n-    pub fn mk_mach_int(&self, tm: hir::IntTy) -> Ty<'tcx> {\n+    pub fn mk_mach_int(&self, tm: ast::IntTy) -> Ty<'tcx> {\n         match tm {\n-            hir::TyIs   => self.types.isize,\n-            hir::TyI8   => self.types.i8,\n-            hir::TyI16  => self.types.i16,\n-            hir::TyI32  => self.types.i32,\n-            hir::TyI64  => self.types.i64,\n+            ast::TyIs   => self.types.isize,\n+            ast::TyI8   => self.types.i8,\n+            ast::TyI16  => self.types.i16,\n+            ast::TyI32  => self.types.i32,\n+            ast::TyI64  => self.types.i64,\n         }\n     }\n \n-    pub fn mk_mach_uint(&self, tm: hir::UintTy) -> Ty<'tcx> {\n+    pub fn mk_mach_uint(&self, tm: ast::UintTy) -> Ty<'tcx> {\n         match tm {\n-            hir::TyUs   => self.types.usize,\n-            hir::TyU8   => self.types.u8,\n-            hir::TyU16  => self.types.u16,\n-            hir::TyU32  => self.types.u32,\n-            hir::TyU64  => self.types.u64,\n+            ast::TyUs   => self.types.usize,\n+            ast::TyU8   => self.types.u8,\n+            ast::TyU16  => self.types.u16,\n+            ast::TyU32  => self.types.u32,\n+            ast::TyU64  => self.types.u64,\n         }\n     }\n \n-    pub fn mk_mach_float(&self, tm: hir::FloatTy) -> Ty<'tcx> {\n+    pub fn mk_mach_float(&self, tm: ast::FloatTy) -> Ty<'tcx> {\n         match tm {\n-            hir::TyF32  => self.types.f32,\n-            hir::TyF64  => self.types.f64,\n+            ast::TyF32  => self.types.f32,\n+            ast::TyF64  => self.types.f64,\n         }\n     }\n "}, {"sha": "ba7be3e2c994845dcf0d7692b47a94156b4cea21", "filename": "src/librustc/middle/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -15,7 +15,7 @@ use middle::ty::{self, BoundRegion, Region, Ty};\n \n use std::fmt;\n use syntax::abi;\n-use syntax::ast::Name;\n+use syntax::ast::{self, Name};\n use syntax::codemap::Span;\n \n use rustc_front::hir;\n@@ -49,7 +49,7 @@ pub enum TypeError<'tcx> {\n     Sorts(ExpectedFound<Ty<'tcx>>),\n     IntegerAsChar,\n     IntMismatch(ExpectedFound<ty::IntVarValue>),\n-    FloatMismatch(ExpectedFound<hir::FloatTy>),\n+    FloatMismatch(ExpectedFound<ast::FloatTy>),\n     Traits(ExpectedFound<DefId>),\n     BuiltinBoundsMismatch(ExpectedFound<ty::BuiltinBounds>),\n     VariadicMismatch(ExpectedFound<bool>),"}, {"sha": "77608f4012845d687c7054bc0fc4562202d83f8f", "filename": "src/librustc/middle/ty/fast_reject.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ffast_reject.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -10,7 +10,7 @@\n \n use middle::def_id::DefId;\n use middle::ty::{self, Ty};\n-use rustc_front::hir;\n+use syntax::ast;\n \n use self::SimplifiedType::*;\n \n@@ -19,9 +19,9 @@ use self::SimplifiedType::*;\n pub enum SimplifiedType {\n     BoolSimplifiedType,\n     CharSimplifiedType,\n-    IntSimplifiedType(hir::IntTy),\n-    UintSimplifiedType(hir::UintTy),\n-    FloatSimplifiedType(hir::FloatTy),\n+    IntSimplifiedType(ast::IntTy),\n+    UintSimplifiedType(ast::UintTy),\n+    FloatSimplifiedType(ast::FloatTy),\n     EnumSimplifiedType(DefId),\n     StrSimplifiedType,\n     VecSimplifiedType,"}, {"sha": "fdf23c455ba2ffa032c38e117d4334d77d7caec4", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -44,13 +44,13 @@ use std::slice;\n use std::vec::IntoIter;\n use std::collections::{HashMap, HashSet};\n use syntax::ast::{self, CrateNum, Name, NodeId};\n+use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::Span;\n use syntax::parse::token::{InternedString, special_idents};\n \n use rustc_front::hir;\n use rustc_front::hir::{ItemImpl, ItemTrait};\n use rustc_front::hir::{MutImmutable, MutMutable, Visibility};\n-use rustc_front::attr::{self, AttrMetaMethods};\n \n pub use self::sty::{Binder, DebruijnIndex};\n pub use self::sty::{BuiltinBound, BuiltinBounds, ExistentialBounds};\n@@ -563,8 +563,8 @@ pub struct ClosureUpvar<'tcx> {\n \n #[derive(Clone, Copy, PartialEq)]\n pub enum IntVarValue {\n-    IntType(hir::IntTy),\n-    UintType(hir::UintTy),\n+    IntType(ast::IntTy),\n+    UintType(ast::UintTy),\n }\n \n /// Default region to use for the bound of objects that are\n@@ -2337,7 +2337,7 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     /// Get the attributes of a definition.\n-    pub fn get_attrs(&self, did: DefId) -> Cow<'tcx, [hir::Attribute]> {\n+    pub fn get_attrs(&self, did: DefId) -> Cow<'tcx, [ast::Attribute]> {\n         if did.is_local() {\n             Cow::Borrowed(self.map.attrs(did.node))\n         } else {"}, {"sha": "2d578fd0ea54301d20594fddb6d96e145a85058f", "filename": "src/librustc/middle/ty/sty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -23,7 +23,7 @@ use std::fmt;\n use std::ops;\n use std::mem;\n use syntax::abi;\n-use syntax::ast::{Name, NodeId};\n+use syntax::ast::{self, Name, NodeId};\n use syntax::parse::token::special_idents;\n \n use rustc_front::hir;\n@@ -79,21 +79,21 @@ pub enum TypeVariants<'tcx> {\n     TyChar,\n \n     /// A primitive signed integer type. For example, `i32`.\n-    TyInt(hir::IntTy),\n+    TyInt(ast::IntTy),\n \n     /// A primitive unsigned integer type. For example, `u32`.\n-    TyUint(hir::UintTy),\n+    TyUint(ast::UintTy),\n \n     /// A primitive floating-point type. For example, `f64`.\n-    TyFloat(hir::FloatTy),\n+    TyFloat(ast::FloatTy),\n \n     /// An enumerated type, defined with `enum`.\n     ///\n     /// Substs here, possibly against intuition, *may* contain `TyParam`s.\n     /// That is, even after substitution it is possible that there are type\n     /// variables. This happens when the `TyEnum` corresponds to an enum\n     /// definition and not a concrete use of it. To get the correct `TyEnum`\n-    /// from the tcx, use the `NodeId` from the `hir::Ty` and look it up in\n+    /// from the tcx, use the `NodeId` from the `ast::Ty` and look it up in\n     /// the `ast_ty_to_ty_cache`. This is probably true for `TyStruct` as\n     /// well.\n     TyEnum(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n@@ -944,7 +944,7 @@ impl<'tcx> TyS<'tcx> {\n     pub fn sequence_element_type(&self, cx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             TyArray(ty, _) | TySlice(ty) => ty,\n-            TyStr => cx.mk_mach_uint(hir::TyU8),\n+            TyStr => cx.mk_mach_uint(ast::TyU8),\n             _ => cx.sess.bug(&format!(\"sequence_element_type called on non-sequence value: {}\",\n                                       self)),\n         }\n@@ -1035,7 +1035,7 @@ impl<'tcx> TyS<'tcx> {\n \n     pub fn is_uint(&self) -> bool {\n         match self.sty {\n-            TyInfer(IntVar(_)) | TyUint(hir::TyUs) => true,\n+            TyInfer(IntVar(_)) | TyUint(ast::TyUs) => true,\n             _ => false\n         }\n     }\n@@ -1081,7 +1081,7 @@ impl<'tcx> TyS<'tcx> {\n \n     pub fn is_machine(&self) -> bool {\n         match self.sty {\n-            TyInt(hir::TyIs) | TyUint(hir::TyUs) => false,\n+            TyInt(ast::TyIs) | TyUint(ast::TyUs) => false,\n             TyInt(..) | TyUint(..) | TyFloat(..) => true,\n             _ => false\n         }"}, {"sha": "3a90f3e0136e50d008b65b441e09deeede4b18e8", "filename": "src/librustc/middle/ty/util.rs", "status": "modified", "additions": 71, "deletions": 71, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -26,11 +26,11 @@ use util::num::ToPrimitive;\n \n use std::cmp;\n use std::hash::{Hash, SipHasher, Hasher};\n-use syntax::ast::Name;\n+use syntax::ast::{self, Name};\n+use syntax::attr::{self, AttrMetaMethods, SignedInt, UnsignedInt};\n use syntax::codemap::Span;\n \n use rustc_front::hir;\n-use rustc_front::attr::{self, AttrMetaMethods, SignedInt, UnsignedInt};\n \n pub trait IntTypeExt {\n     fn to_ty<'tcx>(&self, cx: &ty::ctxt<'tcx>) -> Ty<'tcx>;\n@@ -44,48 +44,48 @@ pub trait IntTypeExt {\n impl IntTypeExt for attr::IntType {\n     fn to_ty<'tcx>(&self, cx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n-            SignedInt(hir::TyI8)      => cx.types.i8,\n-            SignedInt(hir::TyI16)     => cx.types.i16,\n-            SignedInt(hir::TyI32)     => cx.types.i32,\n-            SignedInt(hir::TyI64)     => cx.types.i64,\n-            SignedInt(hir::TyIs)   => cx.types.isize,\n-            UnsignedInt(hir::TyU8)    => cx.types.u8,\n-            UnsignedInt(hir::TyU16)   => cx.types.u16,\n-            UnsignedInt(hir::TyU32)   => cx.types.u32,\n-            UnsignedInt(hir::TyU64)   => cx.types.u64,\n-            UnsignedInt(hir::TyUs) => cx.types.usize,\n+            SignedInt(ast::TyI8)      => cx.types.i8,\n+            SignedInt(ast::TyI16)     => cx.types.i16,\n+            SignedInt(ast::TyI32)     => cx.types.i32,\n+            SignedInt(ast::TyI64)     => cx.types.i64,\n+            SignedInt(ast::TyIs)   => cx.types.isize,\n+            UnsignedInt(ast::TyU8)    => cx.types.u8,\n+            UnsignedInt(ast::TyU16)   => cx.types.u16,\n+            UnsignedInt(ast::TyU32)   => cx.types.u32,\n+            UnsignedInt(ast::TyU64)   => cx.types.u64,\n+            UnsignedInt(ast::TyUs) => cx.types.usize,\n         }\n     }\n \n     fn i64_to_disr(&self, val: i64) -> Option<Disr> {\n         match *self {\n-            SignedInt(hir::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n-            SignedInt(hir::TyI16)   => val.to_i16() .map(|v| v as Disr),\n-            SignedInt(hir::TyI32)   => val.to_i32() .map(|v| v as Disr),\n-            SignedInt(hir::TyI64)   => val.to_i64() .map(|v| v as Disr),\n-            UnsignedInt(hir::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n-            UnsignedInt(hir::TyU16) => val.to_u16() .map(|v| v as Disr),\n-            UnsignedInt(hir::TyU32) => val.to_u32() .map(|v| v as Disr),\n-            UnsignedInt(hir::TyU64) => val.to_u64() .map(|v| v as Disr),\n-\n-            UnsignedInt(hir::TyUs) |\n-            SignedInt(hir::TyIs) => unreachable!(),\n+            SignedInt(ast::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n+            SignedInt(ast::TyI16)   => val.to_i16() .map(|v| v as Disr),\n+            SignedInt(ast::TyI32)   => val.to_i32() .map(|v| v as Disr),\n+            SignedInt(ast::TyI64)   => val.to_i64() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU16) => val.to_u16() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU32) => val.to_u32() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU64) => val.to_u64() .map(|v| v as Disr),\n+\n+            UnsignedInt(ast::TyUs) |\n+            SignedInt(ast::TyIs) => unreachable!(),\n         }\n     }\n \n     fn u64_to_disr(&self, val: u64) -> Option<Disr> {\n         match *self {\n-            SignedInt(hir::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n-            SignedInt(hir::TyI16)   => val.to_i16() .map(|v| v as Disr),\n-            SignedInt(hir::TyI32)   => val.to_i32() .map(|v| v as Disr),\n-            SignedInt(hir::TyI64)   => val.to_i64() .map(|v| v as Disr),\n-            UnsignedInt(hir::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n-            UnsignedInt(hir::TyU16) => val.to_u16() .map(|v| v as Disr),\n-            UnsignedInt(hir::TyU32) => val.to_u32() .map(|v| v as Disr),\n-            UnsignedInt(hir::TyU64) => val.to_u64() .map(|v| v as Disr),\n-\n-            UnsignedInt(hir::TyUs) |\n-            SignedInt(hir::TyIs) => unreachable!(),\n+            SignedInt(ast::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n+            SignedInt(ast::TyI16)   => val.to_i16() .map(|v| v as Disr),\n+            SignedInt(ast::TyI32)   => val.to_i32() .map(|v| v as Disr),\n+            SignedInt(ast::TyI64)   => val.to_i64() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU16) => val.to_u16() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU32) => val.to_u32() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU64) => val.to_u64() .map(|v| v as Disr),\n+\n+            UnsignedInt(ast::TyUs) |\n+            SignedInt(ast::TyIs) => unreachable!(),\n         }\n     }\n \n@@ -97,18 +97,18 @@ impl IntTypeExt for attr::IntType {\n             // SignedInt repr means we *want* to reinterpret the bits\n             // treating the highest bit of Disr as a sign-bit, so\n             // cast to i64 before range-checking.\n-            SignedInt(hir::TyI8)    => add1!((val as i64).to_i8()),\n-            SignedInt(hir::TyI16)   => add1!((val as i64).to_i16()),\n-            SignedInt(hir::TyI32)   => add1!((val as i64).to_i32()),\n-            SignedInt(hir::TyI64)   => add1!(Some(val as i64)),\n-\n-            UnsignedInt(hir::TyU8)  => add1!(val.to_u8()),\n-            UnsignedInt(hir::TyU16) => add1!(val.to_u16()),\n-            UnsignedInt(hir::TyU32) => add1!(val.to_u32()),\n-            UnsignedInt(hir::TyU64) => add1!(Some(val)),\n-\n-            UnsignedInt(hir::TyUs) |\n-            SignedInt(hir::TyIs) => unreachable!(),\n+            SignedInt(ast::TyI8)    => add1!((val as i64).to_i8()),\n+            SignedInt(ast::TyI16)   => add1!((val as i64).to_i16()),\n+            SignedInt(ast::TyI32)   => add1!((val as i64).to_i32()),\n+            SignedInt(ast::TyI64)   => add1!(Some(val as i64)),\n+\n+            UnsignedInt(ast::TyU8)  => add1!(val.to_u8()),\n+            UnsignedInt(ast::TyU16) => add1!(val.to_u16()),\n+            UnsignedInt(ast::TyU32) => add1!(val.to_u32()),\n+            UnsignedInt(ast::TyU64) => add1!(Some(val)),\n+\n+            UnsignedInt(ast::TyUs) |\n+            SignedInt(ast::TyIs) => unreachable!(),\n         }\n     }\n \n@@ -117,17 +117,17 @@ impl IntTypeExt for attr::IntType {\n     // full range from `i64::MIN` through `u64::MAX`.\n     fn disr_string(&self, val: Disr) -> String {\n         match *self {\n-            SignedInt(hir::TyI8)    => format!(\"{}\", val as i8 ),\n-            SignedInt(hir::TyI16)   => format!(\"{}\", val as i16),\n-            SignedInt(hir::TyI32)   => format!(\"{}\", val as i32),\n-            SignedInt(hir::TyI64)   => format!(\"{}\", val as i64),\n-            UnsignedInt(hir::TyU8)  => format!(\"{}\", val as u8 ),\n-            UnsignedInt(hir::TyU16) => format!(\"{}\", val as u16),\n-            UnsignedInt(hir::TyU32) => format!(\"{}\", val as u32),\n-            UnsignedInt(hir::TyU64) => format!(\"{}\", val as u64),\n-\n-            UnsignedInt(hir::TyUs) |\n-            SignedInt(hir::TyIs) => unreachable!(),\n+            SignedInt(ast::TyI8)    => format!(\"{}\", val as i8 ),\n+            SignedInt(ast::TyI16)   => format!(\"{}\", val as i16),\n+            SignedInt(ast::TyI32)   => format!(\"{}\", val as i32),\n+            SignedInt(ast::TyI64)   => format!(\"{}\", val as i64),\n+            UnsignedInt(ast::TyU8)  => format!(\"{}\", val as u8 ),\n+            UnsignedInt(ast::TyU16) => format!(\"{}\", val as u16),\n+            UnsignedInt(ast::TyU32) => format!(\"{}\", val as u32),\n+            UnsignedInt(ast::TyU64) => format!(\"{}\", val as u64),\n+\n+            UnsignedInt(ast::TyUs) |\n+            SignedInt(ast::TyIs) => unreachable!(),\n         }\n     }\n \n@@ -137,17 +137,17 @@ impl IntTypeExt for attr::IntType {\n         }\n         let val = val.unwrap_or(ty::INITIAL_DISCRIMINANT_VALUE);\n         match *self {\n-            SignedInt(hir::TyI8)    => add1!(val as i8 ),\n-            SignedInt(hir::TyI16)   => add1!(val as i16),\n-            SignedInt(hir::TyI32)   => add1!(val as i32),\n-            SignedInt(hir::TyI64)   => add1!(val as i64),\n-            UnsignedInt(hir::TyU8)  => add1!(val as u8 ),\n-            UnsignedInt(hir::TyU16) => add1!(val as u16),\n-            UnsignedInt(hir::TyU32) => add1!(val as u32),\n-            UnsignedInt(hir::TyU64) => add1!(val as u64),\n-\n-            UnsignedInt(hir::TyUs) |\n-            SignedInt(hir::TyIs) => unreachable!(),\n+            SignedInt(ast::TyI8)    => add1!(val as i8 ),\n+            SignedInt(ast::TyI16)   => add1!(val as i16),\n+            SignedInt(ast::TyI32)   => add1!(val as i32),\n+            SignedInt(ast::TyI64)   => add1!(val as i64),\n+            UnsignedInt(ast::TyU8)  => add1!(val as u8 ),\n+            UnsignedInt(ast::TyU16) => add1!(val as u16),\n+            UnsignedInt(ast::TyU32) => add1!(val as u32),\n+            UnsignedInt(ast::TyU64) => add1!(val as u64),\n+\n+            UnsignedInt(ast::TyUs) |\n+            SignedInt(ast::TyIs) => unreachable!(),\n         }\n     }\n }\n@@ -279,14 +279,14 @@ impl<'tcx> ty::ctxt<'tcx> {\n             //\n             // NB. Historically `fn enum_variants` generate i64 here, while\n             // rustc_typeck::check would generate isize.\n-            _ => SignedInt(hir::TyIs),\n+            _ => SignedInt(ast::TyIs),\n         };\n \n         let repr_type_ty = repr_type.to_ty(self);\n         let repr_type = match repr_type {\n-            SignedInt(hir::TyIs) =>\n+            SignedInt(ast::TyIs) =>\n                 SignedInt(self.sess.target.int_type),\n-            UnsignedInt(hir::TyUs) =>\n+            UnsignedInt(ast::TyUs) =>\n                 UnsignedInt(self.sess.target.uint_type),\n             other => other\n         };"}, {"sha": "96c8e5c7d5218cddbf35bc9536604b3b3d60cff4", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -15,6 +15,7 @@ use session::Session;\n use metadata::csearch;\n use middle::lang_items;\n \n+use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n use rustc_front::visit::Visitor;\n@@ -54,7 +55,7 @@ pub fn check_crate(krate: &hir::Crate,\n     verify(sess, items);\n }\n \n-pub fn link_name(attrs: &[hir::Attribute]) -> Option<InternedString> {\n+pub fn link_name(attrs: &[ast::Attribute]) -> Option<InternedString> {\n     lang_items::extract(attrs).and_then(|name| {\n         $(if &name[..] == stringify!($name) {\n             Some(InternedString::new(stringify!($sym)))"}, {"sha": "ea85b264261cd2d7027e3b7d2753be4700940674", "filename": "src/librustc/plugin/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fplugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fplugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fbuild.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -11,12 +11,12 @@\n //! Used by `rustc` when compiling a plugin crate.\n \n use syntax::ast;\n+use syntax::attr;\n use syntax::codemap::Span;\n use syntax::diagnostic;\n use rustc_front::visit;\n use rustc_front::visit::Visitor;\n use rustc_front::hir;\n-use rustc_front::attr;\n \n struct RegistrarFinder {\n     registrars: Vec<(ast::NodeId, Span)> ,"}, {"sha": "ad0eb4d53fe26b837d98e167d912ecb576375515", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -25,11 +25,9 @@ use rustc_back::target::Target;\n use lint;\n use metadata::cstore;\n \n-use syntax::ast;\n-use rustc_front::hir::{IntTy, UintTy};\n+use syntax::ast::{self, IntTy, UintTy};\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use rustc_front::hir;\n use syntax::diagnostic::{ColorConfig, Auto, Always, Never, SpanHandler};\n use syntax::parse;\n use syntax::parse::token::InternedString;\n@@ -669,8 +667,8 @@ pub fn build_target_config(opts: &Options, sp: &SpanHandler) -> Config {\n     };\n \n     let (int_type, uint_type) = match &target.target_pointer_width[..] {\n-        \"32\" => (hir::TyI32, hir::TyU32),\n-        \"64\" => (hir::TyI64, hir::TyU64),\n+        \"32\" => (ast::TyI32, ast::TyU32),\n+        \"64\" => (ast::TyI64, ast::TyU64),\n         w    => sp.handler().fatal(&format!(\"target specification was invalid: unrecognized \\\n                                              target-pointer-width {}\", w))\n     };"}, {"sha": "68bfa42f6f6cbd4623c1c342cea1705f1f1cf559", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -25,9 +25,10 @@ use middle::ty::fold::TypeFoldable;\n \n use std::fmt;\n use syntax::abi;\n+use syntax::ast;\n use syntax::parse::token;\n use syntax::ast::DUMMY_NODE_ID;\n-use rustc_front::hir as ast;\n+use rustc_front::hir;\n \n pub fn verbose() -> bool {\n     ty::tls::with(|tcx| tcx.sess.verbose())\n@@ -334,7 +335,7 @@ impl<'tcx> fmt::Debug for ty::TyS<'tcx> {\n impl<'tcx> fmt::Display for ty::TypeAndMut<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}{}\",\n-               if self.mutbl == ast::MutMutable { \"mut \" } else { \"\" },\n+               if self.mutbl == hir::MutMutable { \"mut \" } else { \"\" },\n                self.ty)\n     }\n }\n@@ -825,8 +826,8 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyBox(typ) => write!(f, \"Box<{}>\",  typ),\n             TyRawPtr(ref tm) => {\n                 write!(f, \"*{} {}\", match tm.mutbl {\n-                    ast::MutMutable => \"mut\",\n-                    ast::MutImmutable => \"const\",\n+                    hir::MutMutable => \"mut\",\n+                    hir::MutImmutable => \"const\",\n                 },  tm.ty)\n             }\n             TyRef(r, ref tm) => {\n@@ -853,7 +854,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 write!(f, \")\")\n             }\n             TyBareFn(opt_def_id, ref bare_fn) => {\n-                if bare_fn.unsafety == ast::Unsafety::Unsafe {\n+                if bare_fn.unsafety == hir::Unsafety::Unsafe {\n                     try!(write!(f, \"unsafe \"));\n                 }\n \n@@ -966,10 +967,10 @@ impl fmt::Display for ty::ExplicitSelfCategory {\n         f.write_str(match *self {\n             ty::StaticExplicitSelfCategory => \"static\",\n             ty::ByValueExplicitSelfCategory => \"self\",\n-            ty::ByReferenceExplicitSelfCategory(_, ast::MutMutable) => {\n+            ty::ByReferenceExplicitSelfCategory(_, hir::MutMutable) => {\n                 \"&mut self\"\n             }\n-            ty::ByReferenceExplicitSelfCategory(_, ast::MutImmutable) => \"&self\",\n+            ty::ByReferenceExplicitSelfCategory(_, hir::MutImmutable) => \"&self\",\n             ty::ByBoxExplicitSelfCategory => \"Box<self>\",\n         })\n     }"}, {"sha": "36fc814234d7f61da6590a72249426ffd033c141", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -232,7 +232,7 @@ mod svh_visitor {\n         SawExprTup,\n         SawExprBinary(hir::BinOp_),\n         SawExprUnary(hir::UnOp),\n-        SawExprLit(hir::Lit_),\n+        SawExprLit(ast::Lit_),\n         SawExprCast,\n         SawExprIf,\n         SawExprWhile,"}, {"sha": "cecbeacadecce738b6f2d4a02b13550ed28b028f", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -28,7 +28,7 @@ use std::mem;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n-use rustc_front::attr::AttrMetaMethods;\n+use syntax::attr::AttrMetaMethods;\n \n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n enum Fragment {"}, {"sha": "dc36a4ab93c6aefb4ea637b6e3a64f566494e64a", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -32,6 +32,7 @@ use syntax::ast;\n use syntax::codemap;\n use syntax::fold::{self, Folder};\n use syntax::print::{pp, pprust};\n+use syntax::print::pprust::PrintState;\n use syntax::ptr::P;\n use syntax::util::small_vector::SmallVector;\n "}, {"sha": "7041f29cffff8d9d9b5ddbf7873435bfcf352878", "filename": "src/librustc_front/attr.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_front%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_front%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fattr.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -15,8 +15,6 @@ pub use self::ReprAttr::*;\n pub use self::IntType::*;\n \n use hir;\n-use hir::{AttrId, Attribute, Attribute_, MetaItem, MetaWord, MetaNameValue, MetaList};\n-use lowering::{lower_attr_style, unlower_attribute};\n use syntax::codemap::{Span, Spanned, spanned, dummy_spanned};\n use syntax::codemap::BytePos;\n use syntax::diagnostic::SpanHandler;"}, {"sha": "0ff972f830f011f9aaa911f775a538d311471fca", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -12,7 +12,8 @@\n //! and returns a piece of the same type.\n \n use hir::*;\n-use syntax::ast::{Ident, NodeId, DUMMY_NODE_ID};\n+use syntax::ast::{Ident, NodeId, DUMMY_NODE_ID, Attribute, Attribute_, MetaItem};\n+use syntax::ast::{MetaWord, MetaList, MetaNameValue};\n use hir;\n use syntax::codemap::{respan, Span, Spanned};\n use syntax::owned_slice::OwnedSlice;"}, {"sha": "f329aa49daabc63e599a20e22096ec07c9f03966", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 1, "deletions": 231, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -11,36 +11,27 @@\n // The Rust HIR.\n \n pub use self::AsmDialect::*;\n-pub use self::AttrStyle::*;\n pub use self::BindingMode::*;\n pub use self::BinOp_::*;\n pub use self::BlockCheckMode::*;\n pub use self::CaptureClause::*;\n pub use self::Decl_::*;\n pub use self::ExplicitSelf_::*;\n pub use self::Expr_::*;\n-pub use self::FloatTy::*;\n pub use self::FunctionRetTy::*;\n pub use self::ForeignItem_::*;\n pub use self::ImplItem_::*;\n-pub use self::IntTy::*;\n pub use self::Item_::*;\n-pub use self::Lit_::*;\n-pub use self::LitIntType::*;\n-pub use self::MetaItem_::*;\n pub use self::Mutability::*;\n pub use self::Pat_::*;\n pub use self::PathListItem_::*;\n pub use self::PatWildKind::*;\n pub use self::PrimTy::*;\n-pub use self::Sign::*;\n pub use self::Stmt_::*;\n-pub use self::StrStyle::*;\n pub use self::StructFieldKind::*;\n pub use self::TraitItem_::*;\n pub use self::Ty_::*;\n pub use self::TyParamBound::*;\n-pub use self::UintTy::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n pub use self::VariantKind::*;\n@@ -51,6 +42,7 @@ pub use self::PathParameters::*;\n use syntax::codemap::{self, Span, Spanned, DUMMY_SP, ExpnId};\n use syntax::abi::Abi;\n use syntax::ast::{Name, Ident, NodeId, DUMMY_NODE_ID, TokenTree};\n+use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, CrateConfig};\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n@@ -59,7 +51,6 @@ use print::pprust;\n use util;\n \n use std::fmt;\n-use std::rc::Rc;\n use serialize::{Encodable, Encoder, Decoder};\n \n \n@@ -333,10 +324,6 @@ pub struct WhereEqPredicate {\n     pub ty: P<Ty>,\n }\n \n-/// The set of MetaItems that define the compilation environment of the crate,\n-/// used to drive conditional compilation\n-pub type CrateConfig = Vec<P<MetaItem>> ;\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Crate {\n     pub module: Mod,\n@@ -362,40 +349,6 @@ pub struct MacroDef {\n     pub body: Vec<TokenTree>,\n }\n \n-pub type MetaItem = Spanned<MetaItem_>;\n-\n-#[derive(Clone, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum MetaItem_ {\n-    MetaWord(InternedString),\n-    MetaList(InternedString, Vec<P<MetaItem>>),\n-    MetaNameValue(InternedString, Lit),\n-}\n-\n-// can't be derived because the MetaList requires an unordered comparison\n-impl PartialEq for MetaItem_ {\n-    fn eq(&self, other: &MetaItem_) -> bool {\n-        match *self {\n-            MetaWord(ref ns) => match *other {\n-                MetaWord(ref no) => (*ns) == (*no),\n-                _ => false\n-            },\n-            MetaNameValue(ref ns, ref vs) => match *other {\n-                MetaNameValue(ref no, ref vo) => {\n-                    (*ns) == (*no) && vs.node == vo.node\n-                }\n-                _ => false\n-            },\n-            MetaList(ref ns, ref miss) => match *other {\n-                MetaList(ref no, ref miso) => {\n-                    ns == no &&\n-                        miss.iter().all(|mi| miso.iter().any(|x| x.node == mi.node))\n-                }\n-                _ => false\n-            }\n-        }\n-    }\n-}\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Block {\n     /// Statements in a block\n@@ -787,72 +740,6 @@ pub enum CaptureClause {\n     CaptureByRef,\n }\n \n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub enum StrStyle {\n-    /// A regular string, like `\"foo\"`\n-    CookedStr,\n-    /// A raw string, like `r##\"foo\"##`\n-    ///\n-    /// The uint is the number of `#` symbols used\n-    RawStr(usize)\n-}\n-\n-/// A literal\n-pub type Lit = Spanned<Lit_>;\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub enum Sign {\n-    Minus,\n-    Plus\n-}\n-\n-impl Sign {\n-    pub fn new<T: IntSign>(n: T) -> Sign {\n-        n.sign()\n-    }\n-}\n-\n-pub trait IntSign {\n-    fn sign(&self) -> Sign;\n-}\n-macro_rules! doit {\n-    ($($t:ident)*) => ($(impl IntSign for $t {\n-        #[allow(unused_comparisons)]\n-        fn sign(&self) -> Sign {\n-            if *self < 0 {Minus} else {Plus}\n-        }\n-    })*)\n-}\n-doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub enum LitIntType {\n-    SignedIntLit(IntTy, Sign),\n-    UnsignedIntLit(UintTy),\n-    UnsuffixedIntLit(Sign)\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Lit_ {\n-    /// A string literal (`\"foo\"`)\n-    LitStr(InternedString, StrStyle),\n-    /// A byte string (`b\"foo\"`)\n-    LitByteStr(Rc<Vec<u8>>),\n-    /// A byte char (`b'f'`)\n-    LitByte(u8),\n-    /// A character literal (`'a'`)\n-    LitChar(char),\n-    /// An integer literal (`1u8`)\n-    LitInt(u64, LitIntType),\n-    /// A float literal (`1f64` or `1E10f64`)\n-    LitFloat(InternedString, FloatTy),\n-    /// A float literal without a suffix (`1.0 or 1.0E10`)\n-    LitFloatUnsuffixed(InternedString),\n-    /// A boolean literal\n-    LitBool(bool),\n-}\n-\n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -917,99 +804,6 @@ pub enum ImplItem_ {\n     TypeImplItem(P<Ty>),\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n-pub enum IntTy {\n-    TyIs,\n-    TyI8,\n-    TyI16,\n-    TyI32,\n-    TyI64,\n-}\n-\n-impl fmt::Debug for IntTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n-    }\n-}\n-\n-impl fmt::Display for IntTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", util::int_ty_to_string(*self, None))\n-    }\n-}\n-\n-impl IntTy {\n-    pub fn bit_width(&self) -> Option<usize> {\n-        Some(match *self {\n-            TyIs => return None,\n-            TyI8 => 8,\n-            TyI16 => 16,\n-            TyI32 => 32,\n-            TyI64 => 64,\n-        })\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n-pub enum UintTy {\n-    TyUs,\n-    TyU8,\n-    TyU16,\n-    TyU32,\n-    TyU64,\n-}\n-\n-impl UintTy {\n-    pub fn bit_width(&self) -> Option<usize> {\n-        Some(match *self {\n-            TyUs => return None,\n-            TyU8 => 8,\n-            TyU16 => 16,\n-            TyU32 => 32,\n-            TyU64 => 64,\n-        })\n-    }\n-}\n-\n-impl fmt::Debug for UintTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n-    }\n-}\n-\n-impl fmt::Display for UintTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", util::uint_ty_to_string(*self, None))\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n-pub enum FloatTy {\n-    TyF32,\n-    TyF64,\n-}\n-\n-impl fmt::Debug for FloatTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n-    }\n-}\n-\n-impl fmt::Display for FloatTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", util::float_ty_to_string(*self))\n-    }\n-}\n-\n-impl FloatTy {\n-    pub fn bit_width(&self) -> usize {\n-        match *self {\n-            TyF32 => 32,\n-            TyF64 => 64,\n-        }\n-    }\n-}\n-\n // Bind a type to an associated type: `A=Foo`.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TypeBinding {\n@@ -1316,30 +1110,6 @@ pub enum ViewPath_ {\n     ViewPathList(Path, Vec<PathListItem>)\n }\n \n-/// Meta-data associated with an item\n-pub type Attribute = Spanned<Attribute_>;\n-\n-/// Distinguishes between Attributes that decorate items and Attributes that\n-/// are contained as statements within items. These two cases need to be\n-/// distinguished for pretty-printing.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub enum AttrStyle {\n-    AttrOuter,\n-    AttrInner,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub struct AttrId(pub usize);\n-\n-/// Doc-comments are promoted to attributes that have is_sugared_doc = true\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct Attribute_ {\n-    pub id: AttrId,\n-    pub style: AttrStyle,\n-    pub value: P<MetaItem>,\n-    pub is_sugared_doc: bool,\n-}\n-\n /// TraitRef's appear in impls.\n ///\n /// resolve maps each TraitRef's ref_id to its defining trait; that's all"}, {"sha": "4c6d8505c81f02fdaa1e19bf2e5e91edfb09021a", "filename": "src/librustc_front/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_front%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_front%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flib.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -36,7 +36,6 @@\n #![feature(staged_api)]\n #![feature(str_char)]\n #![feature(filling_drop)]\n-#![feature(str_escape)]\n #![cfg_attr(test, feature(test))]\n \n extern crate serialize;\n@@ -50,7 +49,6 @@ pub mod hir;\n pub mod lowering;\n pub mod fold;\n pub mod visit;\n-pub mod attr;\n pub mod util;\n \n pub mod print {"}, {"sha": "38f9ec2c8e6bc71c97057170e7f5a8e296e5660c", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 12, "deletions": 217, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -18,10 +18,6 @@ use syntax::codemap::Spanned;\n use syntax::owned_slice::OwnedSlice;\n \n \n-pub fn lower_meta_items(meta_items: &Vec<P<MetaItem>>) -> Vec<P<hir::MetaItem>> {\n-    meta_items.iter().map(|x| lower_meta_item(x)).collect()\n-}\n-\n pub fn lower_view_path(view_path: &ViewPath) -> P<hir::ViewPath> {\n     P(Spanned {\n         node: match view_path.node {\n@@ -54,13 +50,9 @@ pub fn lower_view_path(view_path: &ViewPath) -> P<hir::ViewPath> {\n     })\n }\n \n-pub fn lower_attrs(attrs: &Vec<Attribute>) -> Vec<hir::Attribute> {\n-    attrs.iter().map(|x| lower_attribute(x)).collect()\n-}\n-\n pub fn lower_arm(arm: &Arm) -> hir::Arm {\n     hir::Arm {\n-        attrs: lower_attrs(&arm.attrs),\n+        attrs: arm.attrs.clone(),\n         pats: arm.pats.iter().map(|x| lower_pat(x)).collect(),\n         guard: arm.guard.as_ref().map(|ref x| lower_expr(x)),\n         body: lower_expr(&arm.body),\n@@ -144,7 +136,7 @@ pub fn lower_variant(v: &Variant) -> P<hir::Variant> {\n         node: hir::Variant_ {\n             id: v.node.id,\n             name: v.node.name,\n-            attrs: lower_attrs(&v.node.attrs),\n+            attrs: v.node.attrs.clone(),\n             kind: match v.node.kind {\n                 TupleVariantKind(ref variant_args) => {\n                     hir::TupleVariantKind(variant_args.iter().map(|ref x|\n@@ -212,31 +204,6 @@ pub fn lower_local(l: &Local) -> P<hir::Local> {\n         })\n }\n \n-pub fn lower_attribute(at: &Attribute) -> hir::Attribute {\n-    Spanned {\n-        node: hir::Attribute_ {\n-            id: hir::AttrId(at.node.id.0),\n-            style: lower_attr_style(at.node.style),\n-            value: lower_meta_item(&at.node.value),\n-            is_sugared_doc: at.node.is_sugared_doc,\n-        },\n-        span: at.span,\n-    }\n-}\n-\n-// FIXME we should probably just unify hir and ast Attributes.\n-pub fn unlower_attribute(at: &hir::Attribute) -> Attribute {\n-    Spanned {\n-        node: Attribute_ {\n-            id: AttrId(at.node.id.0),\n-            style: unlower_attr_style(at.node.style),\n-            value: unlower_meta_item(&at.node.value),\n-            is_sugared_doc: at.node.is_sugared_doc,\n-        },\n-        span: at.span,\n-    }\n-}\n-\n pub fn lower_explicit_self_underscore(es: &ExplicitSelf_) -> hir::ExplicitSelf_ {\n     match *es {\n         SelfStatic => hir::SelfStatic,\n@@ -261,33 +228,6 @@ pub fn lower_explicit_self(s: &ExplicitSelf) -> hir::ExplicitSelf {\n     Spanned { node: lower_explicit_self_underscore(&s.node), span: s.span }\n }\n \n-\n-pub fn lower_meta_item(mi: &MetaItem) -> P<hir::MetaItem> {\n-    P(Spanned {\n-        node: match mi.node {\n-            MetaWord(ref id) => hir::MetaWord(id.clone()),\n-            MetaList(ref id, ref mis) => {\n-                hir::MetaList(id.clone(), mis.iter().map(|mi| lower_meta_item(mi)).collect())\n-            }\n-            MetaNameValue(ref id, ref s) => hir::MetaNameValue(id.clone(), lower_lit(s))\n-        },\n-        span: mi.span,\n-    })\n-}\n-\n-pub fn unlower_meta_item(mi: &hir::MetaItem) -> P<MetaItem> {\n-    P(Spanned {\n-        node: match mi.node {\n-            hir::MetaWord(ref id) => MetaWord(id.clone()),\n-            hir::MetaList(ref id, ref mis) => {\n-                MetaList(id.clone(), mis.iter().map(|mi| unlower_meta_item(mi)).collect())\n-            }\n-            hir::MetaNameValue(ref id, ref s) => MetaNameValue(id.clone(), unlower_lit(s))\n-        },\n-        span: mi.span,\n-    })\n-}\n-\n pub fn lower_arg(arg: &Arg) -> hir::Arg {\n     hir::Arg { id: arg.id, pat: lower_pat(&arg.pat), ty: lower_ty(&arg.ty) }\n }\n@@ -424,7 +364,7 @@ pub fn lower_struct_field(f: &StructField) -> hir::StructField {\n             id: f.node.id,\n             kind: lower_struct_field_kind(&f.node.kind),\n             ty: lower_ty(&f.node.ty),\n-            attrs: lower_attrs(&f.node.attrs),\n+            attrs: f.node.attrs.clone(),\n         },\n         span: f.span,\n     }\n@@ -528,7 +468,7 @@ pub fn lower_trait_item(i: &TraitItem) -> P<hir::TraitItem> {\n     P(hir::TraitItem {\n             id: i.id,\n             ident: i.ident,\n-            attrs: lower_attrs(&i.attrs),\n+            attrs: i.attrs.clone(),\n             node: match i.node {\n             ConstTraitItem(ref ty, ref default) => {\n                 hir::ConstTraitItem(lower_ty(ty),\n@@ -551,7 +491,7 @@ pub fn lower_impl_item(i: &ImplItem) -> P<hir::ImplItem> {\n     P(hir::ImplItem {\n             id: i.id,\n             ident: i.ident,\n-            attrs: lower_attrs(&i.attrs),\n+            attrs: i.attrs.clone(),\n             vis: lower_visibility(i.vis),\n             node: match i.node  {\n             ConstImplItem(ref ty, ref expr) => {\n@@ -573,12 +513,10 @@ pub fn lower_mod(m: &Mod) -> hir::Mod {\n }\n \n pub fn lower_crate(c: &Crate) -> hir::Crate {\n-    let config = lower_meta_items(&c.config);\n-\n     hir::Crate {\n         module: lower_mod(&c.module),\n-        attrs: lower_attrs(&c.attrs),\n-        config: config,\n+        attrs: c.attrs.clone(),\n+        config: c.config.clone(),\n         span: c.span,\n         exported_macros: c.exported_macros.iter().map(|m| lower_macro_def(m)).collect(),\n     }\n@@ -587,7 +525,7 @@ pub fn lower_crate(c: &Crate) -> hir::Crate {\n pub fn lower_macro_def(m: &MacroDef) -> hir::MacroDef {\n     hir::MacroDef {\n         ident: m.ident,\n-        attrs: m.attrs.iter().map(|a| lower_attribute(a)).collect(),\n+        attrs: m.attrs.clone(),\n         id: m.id,\n         span: m.span,\n         imported_from: m.imported_from,\n@@ -610,7 +548,7 @@ pub fn lower_item_simple(i: &Item) -> hir::Item {\n     hir::Item {\n         id: i.id,\n         ident: i.ident,\n-        attrs: lower_attrs(&i.attrs),\n+        attrs: i.attrs.clone(),\n         node: node,\n         vis: lower_visibility(i.vis),\n         span: i.span,\n@@ -621,7 +559,7 @@ pub fn lower_foreign_item(i: &ForeignItem) -> P<hir::ForeignItem> {\n     P(hir::ForeignItem {\n             id: i.id,\n             ident: i.ident,\n-            attrs: lower_attrs(&i.attrs),\n+            attrs: i.attrs.clone(),\n             node: match i.node {\n             ForeignItemFn(ref fdec, ref generics) => {\n                 hir::ForeignItemFn(lower_fn_decl(fdec), lower_generics(generics))\n@@ -660,37 +598,6 @@ pub fn lower_constness(c: Constness) -> hir::Constness {\n     }\n }\n \n-pub fn lower_lit(l: &Lit) -> hir::Lit {\n-    Spanned {\n-        node: match l.node {\n-            LitStr(ref i, s) => hir::LitStr(i.clone(), lower_string_style(s)),\n-            LitByteStr(ref b) => hir::LitByteStr(b.clone()),\n-            LitByte(u) => hir::LitByte(u),\n-            LitChar(c) => hir::LitChar(c),\n-            LitInt(u, ref t) => hir::LitInt(u, lower_lit_int_type(t)),\n-            LitFloat(ref i, t) => hir::LitFloat(i.clone(), lower_float_ty(t)),\n-            LitFloatUnsuffixed(ref i) => hir::LitFloatUnsuffixed(i.clone()),\n-            LitBool(b) => hir::LitBool(b),\n-        },\n-        span: l.span,\n-    }\n-}\n-\n-pub fn unlower_lit(l: &hir::Lit) -> Lit {\n-    Spanned {\n-        node: match l.node {\n-            hir::LitStr(ref i, s) => LitStr(i.clone(), unlower_string_style(s)),\n-            hir::LitByteStr(ref b) => LitByteStr(b.clone()),\n-            hir::LitByte(u) => LitByte(u),\n-            hir::LitChar(c) => LitChar(c),\n-            hir::LitInt(u, ref t) => LitInt(u, unlower_lit_int_type(t)),\n-            hir::LitFloat(ref i, t) => LitFloat(i.clone(), unlower_float_ty(t)),\n-            hir::LitFloatUnsuffixed(ref i) => LitFloatUnsuffixed(i.clone()),\n-            hir::LitBool(b) => LitBool(b),\n-        },\n-        span: l.span,\n-    }\n-}\n pub fn lower_unop(u: UnOp) -> hir::UnOp {\n     match u {\n         UnUniq => hir::UnUniq,\n@@ -810,7 +717,7 @@ pub fn lower_expr(e: &Expr) -> P<hir::Expr> {\n                 ExprUnary(op, ref ohs) => {\n                     hir::ExprUnary(lower_unop(op), lower_expr(ohs))\n                 }\n-                ExprLit(ref l) => hir::ExprLit(P(lower_lit(l))),\n+                ExprLit(ref l) => hir::ExprLit(P((**l).clone())),\n                 ExprCast(ref expr, ref ty) => {\n                     hir::ExprCast(lower_expr(expr), lower_ty(ty))\n                 }\n@@ -891,7 +798,7 @@ pub fn lower_expr(e: &Expr) -> P<hir::Expr> {\n                         (c.clone(), lower_expr(out), *is_rw)\n                     }).collect(),\n                     asm: asm.clone(),\n-                    asm_str_style: lower_string_style(asm_str_style),\n+                    asm_str_style: asm_str_style,\n                     clobbers: clobbers.clone(),\n                     volatile: volatile,\n                     alignstack: alignstack,\n@@ -937,20 +844,6 @@ pub fn lower_stmt(s: &Stmt) -> P<hir::Stmt> {\n     }\n }\n \n-pub fn lower_string_style(s: StrStyle) -> hir::StrStyle {\n-    match s {\n-        CookedStr => hir::CookedStr,\n-        RawStr(u) => hir::RawStr(u),\n-    }\n-}\n-\n-pub fn unlower_string_style(s: hir::StrStyle) -> StrStyle {\n-    match s {\n-        hir::CookedStr => CookedStr,\n-        hir::RawStr(u) => RawStr(u),\n-    }\n-}\n-\n pub fn lower_match_source(m: &MatchSource) -> hir::MatchSource {\n     match *m {\n         MatchSource::Normal => hir::MatchSource::Normal,\n@@ -1027,107 +920,9 @@ pub fn lower_impl_polarity(i: ImplPolarity) -> hir::ImplPolarity {\n     }\n }\n \n-pub fn lower_float_ty(f: FloatTy) -> hir::FloatTy {\n-    match f {\n-        TyF32 => hir::TyF32,\n-        TyF64 => hir::TyF64,\n-    }\n-}\n-\n-pub fn unlower_float_ty(f: hir::FloatTy) -> FloatTy {\n-    match f {\n-        hir::TyF32 => TyF32,\n-        hir::TyF64 => TyF64,\n-    }\n-}\n-\n-pub fn lower_lit_int_type(i: &LitIntType) -> hir::LitIntType {\n-    match *i {\n-        SignedIntLit(i, s) => hir::SignedIntLit(lower_int_ty(i), lower_sign(s)),\n-        UnsignedIntLit(u) => hir::UnsignedIntLit(lower_uint_ty(u)),\n-        UnsuffixedIntLit(s) => hir::UnsuffixedIntLit(lower_sign(s)),\n-    }\n-}\n-\n-pub fn unlower_lit_int_type(i: &hir::LitIntType) -> LitIntType {\n-    match *i {\n-        hir::SignedIntLit(i, s) => SignedIntLit(unlower_int_ty(i), unlower_sign(s)),\n-        hir::UnsignedIntLit(u) => UnsignedIntLit(unlower_uint_ty(u)),\n-        hir::UnsuffixedIntLit(s) => UnsuffixedIntLit(unlower_sign(s)),\n-    }\n-}\n-\n-pub fn lower_int_ty(i: IntTy) -> hir::IntTy {\n-    match i {\n-        TyIs => hir::TyIs,\n-        TyI8 => hir::TyI8,\n-        TyI16 => hir::TyI16,\n-        TyI32 => hir::TyI32,\n-        TyI64 => hir::TyI64,\n-    }\n-}\n-\n-pub fn unlower_int_ty(i: hir::IntTy) -> IntTy {\n-    match i {\n-        hir::TyIs => TyIs,\n-        hir::TyI8 => TyI8,\n-        hir::TyI16 => TyI16,\n-        hir::TyI32 => TyI32,\n-        hir::TyI64 => TyI64,\n-    }\n-}\n-\n-pub fn lower_uint_ty(u: UintTy) -> hir::UintTy {\n-    match u {\n-        TyUs => hir::TyUs,\n-        TyU8 => hir::TyU8,\n-        TyU16 => hir::TyU16,\n-        TyU32 => hir::TyU32,\n-        TyU64 => hir::TyU64,\n-    }\n-}\n-\n-pub fn unlower_uint_ty(u: hir::UintTy) -> UintTy {\n-    match u {\n-        hir::TyUs => TyUs,\n-        hir::TyU8 => TyU8,\n-        hir::TyU16 => TyU16,\n-        hir::TyU32 => TyU32,\n-        hir::TyU64 => TyU64,\n-    }\n-}\n-\n-pub fn lower_sign(f: Sign) -> hir::Sign {\n-    match f {\n-        Minus => hir::Minus,\n-        Plus => hir::Plus,\n-    }\n-}\n-\n-pub fn unlower_sign(f: hir::Sign) -> Sign {\n-    match f {\n-        hir::Minus => Minus,\n-        hir::Plus => Plus,\n-    }\n-}\n-\n pub fn lower_trait_bound_modifier(f: TraitBoundModifier) -> hir::TraitBoundModifier {\n     match f {\n         TraitBoundModifier::None => hir::TraitBoundModifier::None,\n         TraitBoundModifier::Maybe => hir::TraitBoundModifier::Maybe,\n     }\n }\n-\n-pub fn lower_attr_style(f: AttrStyle) -> hir::AttrStyle {\n-    match f {\n-        AttrOuter => hir::AttrOuter,\n-        AttrInner => hir::AttrInner,\n-    }\n-}\n-\n-pub fn unlower_attr_style(f: hir::AttrStyle) -> AttrStyle {\n-    match f {\n-        hir::AttrOuter => AttrOuter,\n-        hir::AttrInner => AttrInner,\n-    }\n-}"}, {"sha": "7c5a46465f513163e2954a2d75b6059835a61a14", "filename": "src/librustc_front/print/pp.rs", "status": "removed", "additions": 0, "deletions": 686, "changes": 686, "blob_url": "https://github.com/rust-lang/rust/blob/d2e13e822a73e0ea46ae9e21afdd3155fc997f6d/src%2Flibrustc_front%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e13e822a73e0ea46ae9e21afdd3155fc997f6d/src%2Flibrustc_front%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpp.rs?ref=d2e13e822a73e0ea46ae9e21afdd3155fc997f6d", "patch": "@@ -1,686 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! This pretty-printer is a direct reimplementation of Philip Karlton's\n-//! Mesa pretty-printer, as described in appendix A of\n-//!\n-//!     STAN-CS-79-770: \"Pretty Printing\", by Derek C. Oppen.\n-//!     Stanford Department of Computer Science, 1979.\n-//!\n-//! The algorithm's aim is to break a stream into as few lines as possible\n-//! while respecting the indentation-consistency requirements of the enclosing\n-//! block, and avoiding breaking at silly places on block boundaries, for\n-//! example, between \"x\" and \")\" in \"x)\".\n-//!\n-//! I am implementing this algorithm because it comes with 20 pages of\n-//! documentation explaining its theory, and because it addresses the set of\n-//! concerns I've seen other pretty-printers fall down on. Weirdly. Even though\n-//! it's 32 years old. What can I say?\n-//!\n-//! Despite some redundancies and quirks in the way it's implemented in that\n-//! paper, I've opted to keep the implementation here as similar as I can,\n-//! changing only what was blatantly wrong, a typo, or sufficiently\n-//! non-idiomatic rust that it really stuck out.\n-//!\n-//! In particular you'll see a certain amount of churn related to INTEGER vs.\n-//! CARDINAL in the Mesa implementation. Mesa apparently interconverts the two\n-//! somewhat readily? In any case, I've used usize for indices-in-buffers and\n-//! ints for character-sizes-and-indentation-offsets. This respects the need\n-//! for ints to \"go negative\" while carrying a pending-calculation balance, and\n-//! helps differentiate all the numbers flying around internally (slightly).\n-//!\n-//! I also inverted the indentation arithmetic used in the print stack, since\n-//! the Mesa implementation (somewhat randomly) stores the offset on the print\n-//! stack in terms of margin-col rather than col itself. I store col.\n-//!\n-//! I also implemented a small change in the String token, in that I store an\n-//! explicit length for the string. For most tokens this is just the length of\n-//! the accompanying string. But it's necessary to permit it to differ, for\n-//! encoding things that are supposed to \"go on their own line\" -- certain\n-//! classes of comment and blank-line -- where relying on adjacent\n-//! hardbreak-like Break tokens with long blankness indication doesn't actually\n-//! work. To see why, consider when there is a \"thing that should be on its own\n-//! line\" between two long blocks, say functions. If you put a hardbreak after\n-//! each function (or before each) and the breaking algorithm decides to break\n-//! there anyways (because the functions themselves are long) you wind up with\n-//! extra blank lines. If you don't put hardbreaks you can wind up with the\n-//! \"thing which should be on its own line\" not getting its own line in the\n-//! rare case of \"really small functions\" or such. This re-occurs with comments\n-//! and explicit blank lines. So in those cases we use a string with a payload\n-//! we want isolated to a line and an explicit length that's huge, surrounded\n-//! by two zero-length breaks. The algorithm will try its best to fit it on a\n-//! line (which it can't) and so naturally place the content on its own line to\n-//! avoid combining it with other lines and making matters even worse.\n-\n-use std::io;\n-use std::string;\n-\n-#[derive(Clone, Copy, PartialEq)]\n-pub enum Breaks {\n-    Consistent,\n-    Inconsistent,\n-}\n-\n-#[derive(Clone, Copy)]\n-pub struct BreakToken {\n-    offset: isize,\n-    blank_space: isize\n-}\n-\n-#[derive(Clone, Copy)]\n-pub struct BeginToken {\n-    offset: isize,\n-    breaks: Breaks\n-}\n-\n-#[derive(Clone)]\n-pub enum Token {\n-    String(String, isize),\n-    Break(BreakToken),\n-    Begin(BeginToken),\n-    End,\n-    Eof,\n-}\n-\n-impl Token {\n-    pub fn is_eof(&self) -> bool {\n-        match *self {\n-            Token::Eof => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_hardbreak_tok(&self) -> bool {\n-        match *self {\n-            Token::Break(BreakToken {\n-                offset: 0,\n-                blank_space: bs\n-            }) if bs == SIZE_INFINITY =>\n-                true,\n-            _ =>\n-                false\n-        }\n-    }\n-}\n-\n-pub fn tok_str(token: &Token) -> String {\n-    match *token {\n-        Token::String(ref s, len) => format!(\"STR({},{})\", s, len),\n-        Token::Break(_) => \"BREAK\".to_string(),\n-        Token::Begin(_) => \"BEGIN\".to_string(),\n-        Token::End => \"END\".to_string(),\n-        Token::Eof => \"EOF\".to_string()\n-    }\n-}\n-\n-pub fn buf_str(toks: &[Token],\n-               szs: &[isize],\n-               left: usize,\n-               right: usize,\n-               lim: usize)\n-               -> String {\n-    let n = toks.len();\n-    assert_eq!(n, szs.len());\n-    let mut i = left;\n-    let mut l = lim;\n-    let mut s = string::String::from(\"[\");\n-    while i != right && l != 0 {\n-        l -= 1;\n-        if i != left {\n-            s.push_str(\", \");\n-        }\n-        s.push_str(&format!(\"{}={}\",\n-                           szs[i],\n-                           tok_str(&toks[i])));\n-        i += 1;\n-        i %= n;\n-    }\n-    s.push(']');\n-    s\n-}\n-\n-#[derive(Copy, Clone)]\n-pub enum PrintStackBreak {\n-    Fits,\n-    Broken(Breaks),\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct PrintStackElem {\n-    offset: isize,\n-    pbreak: PrintStackBreak\n-}\n-\n-const SIZE_INFINITY: isize = 0xffff;\n-\n-pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n-    // Yes 3, it makes the ring buffers big enough to never\n-    // fall behind.\n-    let n: usize = 3 * linewidth;\n-    debug!(\"mk_printer {}\", linewidth);\n-    let token = vec![Token::Eof; n];\n-    let size = vec![0_isize; n];\n-    let scan_stack = vec![0_usize; n];\n-    Printer {\n-        out: out,\n-        buf_len: n,\n-        margin: linewidth as isize,\n-        space: linewidth as isize,\n-        left: 0,\n-        right: 0,\n-        token: token,\n-        size: size,\n-        left_total: 0,\n-        right_total: 0,\n-        scan_stack: scan_stack,\n-        scan_stack_empty: true,\n-        top: 0,\n-        bottom: 0,\n-        print_stack: Vec::new(),\n-        pending_indentation: 0\n-    }\n-}\n-\n-\n-/// In case you do not have the paper, here is an explanation of what's going\n-/// on.\n-///\n-/// There is a stream of input tokens flowing through this printer.\n-///\n-/// The printer buffers up to 3N tokens inside itself, where N is linewidth.\n-/// Yes, linewidth is chars and tokens are multi-char, but in the worst\n-/// case every token worth buffering is 1 char long, so it's ok.\n-///\n-/// Tokens are String, Break, and Begin/End to delimit blocks.\n-///\n-/// Begin tokens can carry an offset, saying \"how far to indent when you break\n-/// inside here\", as well as a flag indicating \"consistent\" or \"inconsistent\"\n-/// breaking. Consistent breaking means that after the first break, no attempt\n-/// will be made to flow subsequent breaks together onto lines. Inconsistent\n-/// is the opposite. Inconsistent breaking example would be, say:\n-///\n-///  foo(hello, there, good, friends)\n-///\n-/// breaking inconsistently to become\n-///\n-///  foo(hello, there\n-///      good, friends);\n-///\n-/// whereas a consistent breaking would yield:\n-///\n-///  foo(hello,\n-///      there\n-///      good,\n-///      friends);\n-///\n-/// That is, in the consistent-break blocks we value vertical alignment\n-/// more than the ability to cram stuff onto a line. But in all cases if it\n-/// can make a block a one-liner, it'll do so.\n-///\n-/// Carrying on with high-level logic:\n-///\n-/// The buffered tokens go through a ring-buffer, 'tokens'. The 'left' and\n-/// 'right' indices denote the active portion of the ring buffer as well as\n-/// describing hypothetical points-in-the-infinite-stream at most 3N tokens\n-/// apart (i.e. \"not wrapped to ring-buffer boundaries\"). The paper will switch\n-/// between using 'left' and 'right' terms to denote the wrapped-to-ring-buffer\n-/// and point-in-infinite-stream senses freely.\n-///\n-/// There is a parallel ring buffer, 'size', that holds the calculated size of\n-/// each token. Why calculated? Because for Begin/End pairs, the \"size\"\n-/// includes everything between the pair. That is, the \"size\" of Begin is\n-/// actually the sum of the sizes of everything between Begin and the paired\n-/// End that follows. Since that is arbitrarily far in the future, 'size' is\n-/// being rewritten regularly while the printer runs; in fact most of the\n-/// machinery is here to work out 'size' entries on the fly (and give up when\n-/// they're so obviously over-long that \"infinity\" is a good enough\n-/// approximation for purposes of line breaking).\n-///\n-/// The \"input side\" of the printer is managed as an abstract process called\n-/// SCAN, which uses 'scan_stack', 'scan_stack_empty', 'top' and 'bottom', to\n-/// manage calculating 'size'. SCAN is, in other words, the process of\n-/// calculating 'size' entries.\n-///\n-/// The \"output side\" of the printer is managed by an abstract process called\n-/// PRINT, which uses 'print_stack', 'margin' and 'space' to figure out what to\n-/// do with each token/size pair it consumes as it goes. It's trying to consume\n-/// the entire buffered window, but can't output anything until the size is >=\n-/// 0 (sizes are set to negative while they're pending calculation).\n-///\n-/// So SCAN takes input and buffers tokens and pending calculations, while\n-/// PRINT gobbles up completed calculations and tokens from the buffer. The\n-/// theory is that the two can never get more than 3N tokens apart, because\n-/// once there's \"obviously\" too much data to fit on a line, in a size\n-/// calculation, SCAN will write \"infinity\" to the size and let PRINT consume\n-/// it.\n-///\n-/// In this implementation (following the paper, again) the SCAN process is\n-/// the method called 'pretty_print', and the 'PRINT' process is the method\n-/// called 'print'.\n-pub struct Printer<'a> {\n-    pub out: Box<io::Write+'a>,\n-    buf_len: usize,\n-    /// Width of lines we're constrained to\n-    margin: isize,\n-    /// Number of spaces left on line\n-    space: isize,\n-    /// Index of left side of input stream\n-    left: usize,\n-    /// Index of right side of input stream\n-    right: usize,\n-    /// Ring-buffer stream goes through\n-    token: Vec<Token> ,\n-    /// Ring-buffer of calculated sizes\n-    size: Vec<isize> ,\n-    /// Running size of stream \"...left\"\n-    left_total: isize,\n-    /// Running size of stream \"...right\"\n-    right_total: isize,\n-    /// Pseudo-stack, really a ring too. Holds the\n-    /// primary-ring-buffers index of the Begin that started the\n-    /// current block, possibly with the most recent Break after that\n-    /// Begin (if there is any) on top of it. Stuff is flushed off the\n-    /// bottom as it becomes irrelevant due to the primary ring-buffer\n-    /// advancing.\n-    scan_stack: Vec<usize> ,\n-    /// Top==bottom disambiguator\n-    scan_stack_empty: bool,\n-    /// Index of top of scan_stack\n-    top: usize,\n-    /// Index of bottom of scan_stack\n-    bottom: usize,\n-    /// Stack of blocks-in-progress being flushed by print\n-    print_stack: Vec<PrintStackElem> ,\n-    /// Buffered indentation to avoid writing trailing whitespace\n-    pending_indentation: isize,\n-}\n-\n-impl<'a> Printer<'a> {\n-    pub fn last_token(&mut self) -> Token {\n-        self.token[self.right].clone()\n-    }\n-    // be very careful with this!\n-    pub fn replace_last_token(&mut self, t: Token) {\n-        self.token[self.right] = t;\n-    }\n-    pub fn pretty_print(&mut self, token: Token) -> io::Result<()> {\n-        debug!(\"pp Vec<{},{}>\", self.left, self.right);\n-        match token {\n-          Token::Eof => {\n-            if !self.scan_stack_empty {\n-                self.check_stack(0);\n-                try!(self.advance_left());\n-            }\n-            self.indent(0);\n-            Ok(())\n-          }\n-          Token::Begin(b) => {\n-            if self.scan_stack_empty {\n-                self.left_total = 1;\n-                self.right_total = 1;\n-                self.left = 0;\n-                self.right = 0;\n-            } else { self.advance_right(); }\n-            debug!(\"pp Begin({})/buffer Vec<{},{}>\",\n-                   b.offset, self.left, self.right);\n-            self.token[self.right] = token;\n-            self.size[self.right] = -self.right_total;\n-            let right = self.right;\n-            self.scan_push(right);\n-            Ok(())\n-          }\n-          Token::End => {\n-            if self.scan_stack_empty {\n-                debug!(\"pp End/print Vec<{},{}>\", self.left, self.right);\n-                self.print(token, 0)\n-            } else {\n-                debug!(\"pp End/buffer Vec<{},{}>\", self.left, self.right);\n-                self.advance_right();\n-                self.token[self.right] = token;\n-                self.size[self.right] = -1;\n-                let right = self.right;\n-                self.scan_push(right);\n-                Ok(())\n-            }\n-          }\n-          Token::Break(b) => {\n-            if self.scan_stack_empty {\n-                self.left_total = 1;\n-                self.right_total = 1;\n-                self.left = 0;\n-                self.right = 0;\n-            } else { self.advance_right(); }\n-            debug!(\"pp Break({})/buffer Vec<{},{}>\",\n-                   b.offset, self.left, self.right);\n-            self.check_stack(0);\n-            let right = self.right;\n-            self.scan_push(right);\n-            self.token[self.right] = token;\n-            self.size[self.right] = -self.right_total;\n-            self.right_total += b.blank_space;\n-            Ok(())\n-          }\n-          Token::String(s, len) => {\n-            if self.scan_stack_empty {\n-                debug!(\"pp String('{}')/print Vec<{},{}>\",\n-                       s, self.left, self.right);\n-                self.print(Token::String(s, len), len)\n-            } else {\n-                debug!(\"pp String('{}')/buffer Vec<{},{}>\",\n-                       s, self.left, self.right);\n-                self.advance_right();\n-                self.token[self.right] = Token::String(s, len);\n-                self.size[self.right] = len;\n-                self.right_total += len;\n-                self.check_stream()\n-            }\n-          }\n-        }\n-    }\n-    pub fn check_stream(&mut self) -> io::Result<()> {\n-        debug!(\"check_stream Vec<{}, {}> with left_total={}, right_total={}\",\n-               self.left, self.right, self.left_total, self.right_total);\n-        if self.right_total - self.left_total > self.space {\n-            debug!(\"scan window is {}, longer than space on line ({})\",\n-                   self.right_total - self.left_total, self.space);\n-            if !self.scan_stack_empty {\n-                if self.left == self.scan_stack[self.bottom] {\n-                    debug!(\"setting {} to infinity and popping\", self.left);\n-                    let scanned = self.scan_pop_bottom();\n-                    self.size[scanned] = SIZE_INFINITY;\n-                }\n-            }\n-            try!(self.advance_left());\n-            if self.left != self.right {\n-                try!(self.check_stream());\n-            }\n-        }\n-        Ok(())\n-    }\n-    pub fn scan_push(&mut self, x: usize) {\n-        debug!(\"scan_push {}\", x);\n-        if self.scan_stack_empty {\n-            self.scan_stack_empty = false;\n-        } else {\n-            self.top += 1;\n-            self.top %= self.buf_len;\n-            assert!((self.top != self.bottom));\n-        }\n-        self.scan_stack[self.top] = x;\n-    }\n-    pub fn scan_pop(&mut self) -> usize {\n-        assert!((!self.scan_stack_empty));\n-        let x = self.scan_stack[self.top];\n-        if self.top == self.bottom {\n-            self.scan_stack_empty = true;\n-        } else {\n-            self.top += self.buf_len - 1; self.top %= self.buf_len;\n-        }\n-        return x;\n-    }\n-    pub fn scan_top(&mut self) -> usize {\n-        assert!((!self.scan_stack_empty));\n-        return self.scan_stack[self.top];\n-    }\n-    pub fn scan_pop_bottom(&mut self) -> usize {\n-        assert!((!self.scan_stack_empty));\n-        let x = self.scan_stack[self.bottom];\n-        if self.top == self.bottom {\n-            self.scan_stack_empty = true;\n-        } else {\n-            self.bottom += 1; self.bottom %= self.buf_len;\n-        }\n-        return x;\n-    }\n-    pub fn advance_right(&mut self) {\n-        self.right += 1;\n-        self.right %= self.buf_len;\n-        assert!((self.right != self.left));\n-    }\n-    pub fn advance_left(&mut self) -> io::Result<()> {\n-        debug!(\"advance_left Vec<{},{}>, sizeof({})={}\", self.left, self.right,\n-               self.left, self.size[self.left]);\n-\n-        let mut left_size = self.size[self.left];\n-\n-        while left_size >= 0 {\n-            let left = self.token[self.left].clone();\n-\n-            let len = match left {\n-                Token::Break(b) => b.blank_space,\n-                Token::String(_, len) => {\n-                    assert_eq!(len, left_size);\n-                    len\n-                }\n-                _ => 0\n-            };\n-\n-            try!(self.print(left, left_size));\n-\n-            self.left_total += len;\n-\n-            if self.left == self.right {\n-                break;\n-            }\n-\n-            self.left += 1;\n-            self.left %= self.buf_len;\n-\n-            left_size = self.size[self.left];\n-        }\n-\n-        Ok(())\n-    }\n-    pub fn check_stack(&mut self, k: isize) {\n-        if !self.scan_stack_empty {\n-            let x = self.scan_top();\n-            match self.token[x] {\n-                Token::Begin(_) => {\n-                    if k > 0 {\n-                        let popped = self.scan_pop();\n-                        self.size[popped] = self.size[x] + self.right_total;\n-                        self.check_stack(k - 1);\n-                    }\n-                }\n-                Token::End => {\n-                    // paper says + not =, but that makes no sense.\n-                    let popped = self.scan_pop();\n-                    self.size[popped] = 1;\n-                    self.check_stack(k + 1);\n-                }\n-                _ => {\n-                    let popped = self.scan_pop();\n-                    self.size[popped] = self.size[x] + self.right_total;\n-                    if k > 0 {\n-                        self.check_stack(k);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    pub fn print_newline(&mut self, amount: isize) -> io::Result<()> {\n-        debug!(\"NEWLINE {}\", amount);\n-        let ret = write!(self.out, \"\\n\");\n-        self.pending_indentation = 0;\n-        self.indent(amount);\n-        return ret;\n-    }\n-    pub fn indent(&mut self, amount: isize) {\n-        debug!(\"INDENT {}\", amount);\n-        self.pending_indentation += amount;\n-    }\n-    pub fn get_top(&mut self) -> PrintStackElem {\n-        let print_stack = &mut self.print_stack;\n-        let n = print_stack.len();\n-        if n != 0 {\n-            (*print_stack)[n - 1]\n-        } else {\n-            PrintStackElem {\n-                offset: 0,\n-                pbreak: PrintStackBreak::Broken(Breaks::Inconsistent)\n-            }\n-        }\n-    }\n-    pub fn print_str(&mut self, s: &str) -> io::Result<()> {\n-        while self.pending_indentation > 0 {\n-            try!(write!(self.out, \" \"));\n-            self.pending_indentation -= 1;\n-        }\n-        write!(self.out, \"{}\", s)\n-    }\n-    pub fn print(&mut self, token: Token, l: isize) -> io::Result<()> {\n-        debug!(\"print {} {} (remaining line space={})\", tok_str(&token), l,\n-               self.space);\n-        debug!(\"{}\", buf_str(&self.token,\n-                             &self.size,\n-                             self.left,\n-                             self.right,\n-                             6));\n-        match token {\n-          Token::Begin(b) => {\n-            if l > self.space {\n-                let col = self.margin - self.space + b.offset;\n-                debug!(\"print Begin -> push broken block at col {}\", col);\n-                self.print_stack.push(PrintStackElem {\n-                    offset: col,\n-                    pbreak: PrintStackBreak::Broken(b.breaks)\n-                });\n-            } else {\n-                debug!(\"print Begin -> push fitting block\");\n-                self.print_stack.push(PrintStackElem {\n-                    offset: 0,\n-                    pbreak: PrintStackBreak::Fits\n-                });\n-            }\n-            Ok(())\n-          }\n-          Token::End => {\n-            debug!(\"print End -> pop End\");\n-            let print_stack = &mut self.print_stack;\n-            assert!((!print_stack.is_empty()));\n-            print_stack.pop().unwrap();\n-            Ok(())\n-          }\n-          Token::Break(b) => {\n-            let top = self.get_top();\n-            match top.pbreak {\n-              PrintStackBreak::Fits => {\n-                debug!(\"print Break({}) in fitting block\", b.blank_space);\n-                self.space -= b.blank_space;\n-                self.indent(b.blank_space);\n-                Ok(())\n-              }\n-              PrintStackBreak::Broken(Breaks::Consistent) => {\n-                debug!(\"print Break({}+{}) in consistent block\",\n-                       top.offset, b.offset);\n-                let ret = self.print_newline(top.offset + b.offset);\n-                self.space = self.margin - (top.offset + b.offset);\n-                ret\n-              }\n-              PrintStackBreak::Broken(Breaks::Inconsistent) => {\n-                if l > self.space {\n-                    debug!(\"print Break({}+{}) w/ newline in inconsistent\",\n-                           top.offset, b.offset);\n-                    let ret = self.print_newline(top.offset + b.offset);\n-                    self.space = self.margin - (top.offset + b.offset);\n-                    ret\n-                } else {\n-                    debug!(\"print Break({}) w/o newline in inconsistent\",\n-                           b.blank_space);\n-                    self.indent(b.blank_space);\n-                    self.space -= b.blank_space;\n-                    Ok(())\n-                }\n-              }\n-            }\n-          }\n-          Token::String(s, len) => {\n-            debug!(\"print String({})\", s);\n-            assert_eq!(l, len);\n-            // assert!(l <= space);\n-            self.space -= len;\n-            self.print_str(&s[..])\n-          }\n-          Token::Eof => {\n-            // Eof should never get here.\n-            panic!();\n-          }\n-        }\n-    }\n-}\n-\n-// Convenience functions to talk to the printer.\n-//\n-// \"raw box\"\n-pub fn rbox(p: &mut Printer, indent: usize, b: Breaks) -> io::Result<()> {\n-    p.pretty_print(Token::Begin(BeginToken {\n-        offset: indent as isize,\n-        breaks: b\n-    }))\n-}\n-\n-pub fn ibox(p: &mut Printer, indent: usize) -> io::Result<()> {\n-    rbox(p, indent, Breaks::Inconsistent)\n-}\n-\n-pub fn cbox(p: &mut Printer, indent: usize) -> io::Result<()> {\n-    rbox(p, indent, Breaks::Consistent)\n-}\n-\n-pub fn break_offset(p: &mut Printer, n: usize, off: isize) -> io::Result<()> {\n-    p.pretty_print(Token::Break(BreakToken {\n-        offset: off,\n-        blank_space: n as isize\n-    }))\n-}\n-\n-pub fn end(p: &mut Printer) -> io::Result<()> {\n-    p.pretty_print(Token::End)\n-}\n-\n-pub fn eof(p: &mut Printer) -> io::Result<()> {\n-    p.pretty_print(Token::Eof)\n-}\n-\n-pub fn word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n-    p.pretty_print(Token::String(/* bad */ wrd.to_string(), wrd.len() as isize))\n-}\n-\n-pub fn huge_word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n-    p.pretty_print(Token::String(/* bad */ wrd.to_string(), SIZE_INFINITY))\n-}\n-\n-pub fn zero_word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n-    p.pretty_print(Token::String(/* bad */ wrd.to_string(), 0))\n-}\n-\n-pub fn spaces(p: &mut Printer, n: usize) -> io::Result<()> {\n-    break_offset(p, n, 0)\n-}\n-\n-pub fn zerobreak(p: &mut Printer) -> io::Result<()> {\n-    spaces(p, 0)\n-}\n-\n-pub fn space(p: &mut Printer) -> io::Result<()> {\n-    spaces(p, 1)\n-}\n-\n-pub fn hardbreak(p: &mut Printer) -> io::Result<()> {\n-    spaces(p, SIZE_INFINITY as usize)\n-}\n-\n-pub fn hardbreak_tok_offset(off: isize) -> Token {\n-    Token::Break(BreakToken {offset: off, blank_space: SIZE_INFINITY})\n-}\n-\n-pub fn hardbreak_tok() -> Token {\n-    hardbreak_tok_offset(0)\n-}"}, {"sha": "d8d85135dd8f5732458ff9704f5df089d7790494", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 41, "deletions": 357, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -18,18 +18,16 @@ use syntax::diagnostic;\n use syntax::parse::token::{self, BinOpToken};\n use syntax::parse::lexer::comments;\n use syntax::parse;\n-use syntax::print::pp::{self, break_offset, word, space, zerobreak, hardbreak};\n+use syntax::print::pp::{self, break_offset, word, space, hardbreak};\n use syntax::print::pp::{Breaks, eof};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n+use syntax::print::pprust::{self as ast_pp, PrintState};\n use syntax::ptr::P;\n \n use hir;\n use hir::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n-use attr::{AttrMetaMethods, AttributeMethods};\n \n-use std::ascii;\n use std::io::{self, Write, Read};\n-use std::iter;\n \n pub enum AnnNode<'a> {\n     NodeIdent(&'a ast::Ident),\n@@ -51,22 +49,39 @@ pub struct NoAnn;\n \n impl PpAnn for NoAnn {}\n \n-#[derive(Copy, Clone)]\n-pub struct CurrentCommentAndLiteral {\n-    cur_cmnt: usize,\n-    cur_lit: usize,\n-}\n \n pub struct State<'a> {\n     pub s: pp::Printer<'a>,\n     cm: Option<&'a CodeMap>,\n-    comments: Option<Vec<comments::Comment> >,\n-    literals: Option<Vec<comments::Literal> >,\n-    cur_cmnt_and_lit: CurrentCommentAndLiteral,\n+    comments: Option<Vec<comments::Comment>>,\n+    literals: Option<Vec<comments::Literal>>,\n+    cur_cmnt_and_lit: ast_pp::CurrentCommentAndLiteral,\n     boxes: Vec<pp::Breaks>,\n     ann: &'a (PpAnn+'a),\n }\n \n+impl<'a> PrintState<'a> for State<'a> {\n+    fn writer(&mut self) -> &mut pp::Printer<'a> {\n+        &mut self.s\n+    }\n+\n+    fn boxes(&mut self) -> &mut Vec<pp::Breaks> {\n+        &mut self.boxes\n+    }\n+\n+    fn comments(&mut self) -> &mut Option<Vec<comments::Comment>> {\n+        &mut self.comments\n+    }\n+\n+    fn cur_cmnt_and_lit(&mut self) -> &mut ast_pp::CurrentCommentAndLiteral {\n+        &mut self.cur_cmnt_and_lit\n+    }\n+\n+    fn literals(&self) -> &Option<Vec<comments::Literal>> {\n+        &self.literals\n+    }\n+}\n+\n pub fn rust_printer<'a>(writer: Box<Write+'a>) -> State<'a> {\n     static NO_ANN: NoAnn = NoAnn;\n     rust_printer_annotated(writer, &NO_ANN)\n@@ -79,7 +94,7 @@ pub fn rust_printer_annotated<'a>(writer: Box<Write+'a>,\n         cm: None,\n         comments: None,\n         literals: None,\n-        cur_cmnt_and_lit: CurrentCommentAndLiteral {\n+        cur_cmnt_and_lit: ast_pp::CurrentCommentAndLiteral {\n             cur_cmnt: 0,\n             cur_lit: 0\n         },\n@@ -154,9 +169,9 @@ impl<'a> State<'a> {\n         State {\n             s: pp::mk_printer(out, default_columns),\n             cm: Some(cm),\n-            comments: comments,\n-            literals: literals,\n-            cur_cmnt_and_lit: CurrentCommentAndLiteral {\n+            comments: comments.clone(),\n+            literals: literals.clone(),\n+            cur_cmnt_and_lit: ast_pp::CurrentCommentAndLiteral {\n                 cur_cmnt: 0,\n                 cur_lit: 0\n             },\n@@ -221,10 +236,6 @@ pub fn stmt_to_string(stmt: &hir::Stmt) -> String {\n     to_string(|s| s.print_stmt(stmt))\n }\n \n-pub fn attr_to_string(attr: &hir::Attribute) -> String {\n-    to_string(|s| s.print_attribute(attr))\n-}\n-\n pub fn item_to_string(i: &hir::Item) -> String {\n     to_string(|s| s.print_item(i))\n }\n@@ -283,18 +294,6 @@ pub fn block_to_string(blk: &hir::Block) -> String {\n     })\n }\n \n-pub fn meta_item_to_string(mi: &hir::MetaItem) -> String {\n-    to_string(|s| s.print_meta_item(mi))\n-}\n-\n-pub fn attribute_to_string(attr: &hir::Attribute) -> String {\n-    to_string(|s| s.print_attribute(attr))\n-}\n-\n-pub fn lit_to_string(l: &hir::Lit) -> String {\n-    to_string(|s| s.print_literal(l))\n-}\n-\n pub fn explicit_self_to_string(explicit_self: &hir::ExplicitSelf_) -> String {\n     to_string(|s| s.print_explicit_self(explicit_self, hir::MutImmutable).map(|_| {}))\n }\n@@ -324,43 +323,18 @@ fn needs_parentheses(expr: &hir::Expr) -> bool {\n }\n \n impl<'a> State<'a> {\n-    pub fn ibox(&mut self, u: usize) -> io::Result<()> {\n-        self.boxes.push(pp::Breaks::Inconsistent);\n-        pp::ibox(&mut self.s, u)\n-    }\n-\n-    pub fn end(&mut self) -> io::Result<()> {\n-        self.boxes.pop().unwrap();\n-        pp::end(&mut self.s)\n-    }\n-\n     pub fn cbox(&mut self, u: usize) -> io::Result<()> {\n         self.boxes.push(pp::Breaks::Consistent);\n         pp::cbox(&mut self.s, u)\n     }\n \n-    // \"raw box\"\n-    pub fn rbox(&mut self, u: usize, b: pp::Breaks) -> io::Result<()> {\n-        self.boxes.push(b);\n-        pp::rbox(&mut self.s, u, b)\n-    }\n-\n     pub fn nbsp(&mut self) -> io::Result<()> { word(&mut self.s, \" \") }\n \n     pub fn word_nbsp(&mut self, w: &str) -> io::Result<()> {\n         try!(word(&mut self.s, w));\n         self.nbsp()\n     }\n \n-    pub fn word_space(&mut self, w: &str) -> io::Result<()> {\n-        try!(word(&mut self.s, w));\n-        space(&mut self.s)\n-    }\n-\n-    pub fn popen(&mut self) -> io::Result<()> { word(&mut self.s, \"(\") }\n-\n-    pub fn pclose(&mut self) -> io::Result<()> { word(&mut self.s, \")\") }\n-\n     pub fn head(&mut self, w: &str) -> io::Result<()> {\n         // outer-box is consistent\n         try!(self.cbox(indent_unit));\n@@ -396,38 +370,12 @@ impl<'a> State<'a> {\n         self.bclose_(span, indent_unit)\n     }\n \n-    pub fn is_begin(&mut self) -> bool {\n-        match self.s.last_token() {\n-            pp::Token::Begin(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_end(&mut self) -> bool {\n-        match self.s.last_token() {\n-            pp::Token::End => true,\n-            _ => false,\n-        }\n-    }\n-\n-    // is this the beginning of a line?\n-    pub fn is_bol(&mut self) -> bool {\n-        self.s.last_token().is_eof() || self.s.last_token().is_hardbreak_tok()\n-    }\n-\n     pub fn in_cbox(&self) -> bool {\n         match self.boxes.last() {\n             Some(&last_box) => last_box == pp::Breaks::Consistent,\n             None => false\n         }\n     }\n-\n-    pub fn hardbreak_if_not_bol(&mut self) -> io::Result<()> {\n-        if !self.is_bol() {\n-            try!(hardbreak(&mut self.s))\n-        }\n-        Ok(())\n-    }\n     pub fn space_if_not_bol(&mut self) -> io::Result<()> {\n         if !self.is_bol() { try!(space(&mut self.s)); }\n         Ok(())\n@@ -457,18 +405,6 @@ impl<'a> State<'a> {\n         word(&mut self.s, \"*/\")\n     }\n \n-    pub fn commasep<T, F>(&mut self, b: Breaks, elts: &[T], mut op: F) -> io::Result<()> where\n-        F: FnMut(&mut State, &T) -> io::Result<()>,\n-    {\n-        try!(self.rbox(0, b));\n-        let mut first = true;\n-        for elt in elts {\n-            if first { first = false; } else { try!(self.word_space(\",\")); }\n-            try!(op(self, elt));\n-        }\n-        self.end()\n-    }\n-\n \n     pub fn commasep_cmnt<T, F, G>(&mut self,\n                                   b: Breaks,\n@@ -501,7 +437,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_mod(&mut self, _mod: &hir::Mod,\n-                     attrs: &[hir::Attribute]) -> io::Result<()> {\n+                     attrs: &[ast::Attribute]) -> io::Result<()> {\n         try!(self.print_inner_attributes(attrs));\n         for item in &_mod.items {\n             try!(self.print_item(&**item));\n@@ -510,7 +446,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_foreign_mod(&mut self, nmod: &hir::ForeignMod,\n-                             attrs: &[hir::Attribute]) -> io::Result<()> {\n+                             attrs: &[ast::Attribute]) -> io::Result<()> {\n         try!(self.print_inner_attributes(attrs));\n         for item in &nmod.items {\n             try!(self.print_foreign_item(&**item));\n@@ -694,7 +630,7 @@ impl<'a> State<'a> {\n                 if let Some(p) = *optional_path {\n                     let val = p.as_str();\n                     if val.contains(\"-\") {\n-                        try!(self.print_string(&val, hir::CookedStr));\n+                        try!(self.print_string(&val, ast::CookedStr));\n                     } else {\n                         try!(self.print_name(p));\n                     }\n@@ -1105,58 +1041,6 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodeSubItem(ii.id))\n     }\n \n-    pub fn print_outer_attributes(&mut self,\n-                                  attrs: &[hir::Attribute]) -> io::Result<()> {\n-        let mut count = 0;\n-        for attr in attrs {\n-            match attr.node.style {\n-                hir::AttrOuter => {\n-                    try!(self.print_attribute(attr));\n-                    count += 1;\n-                }\n-                _ => {/* fallthrough */ }\n-            }\n-        }\n-        if count > 0 {\n-            try!(self.hardbreak_if_not_bol());\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn print_inner_attributes(&mut self,\n-                                  attrs: &[hir::Attribute]) -> io::Result<()> {\n-        let mut count = 0;\n-        for attr in attrs {\n-            match attr.node.style {\n-                hir::AttrInner => {\n-                    try!(self.print_attribute(attr));\n-                    count += 1;\n-                }\n-                _ => {/* fallthrough */ }\n-            }\n-        }\n-        if count > 0 {\n-            try!(self.hardbreak_if_not_bol());\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn print_attribute(&mut self, attr: &hir::Attribute) -> io::Result<()> {\n-        try!(self.hardbreak_if_not_bol());\n-        try!(self.maybe_print_comment(attr.span.lo));\n-        if attr.node.is_sugared_doc {\n-            word(&mut self.s, &attr.value_str().unwrap())\n-        } else {\n-            match attr.node.style {\n-                hir::AttrInner => try!(word(&mut self.s, \"#![\")),\n-                hir::AttrOuter => try!(word(&mut self.s, \"#[\")),\n-            }\n-            try!(self.print_meta_item(&*attr.meta()));\n-            word(&mut self.s, \"]\")\n-        }\n-    }\n-\n-\n     pub fn print_stmt(&mut self, st: &hir::Stmt) -> io::Result<()> {\n         try!(self.maybe_print_comment(st.span.lo));\n         match st.node {\n@@ -1194,14 +1078,14 @@ impl<'a> State<'a> {\n \n     pub fn print_block_with_attrs(&mut self,\n                                   blk: &hir::Block,\n-                                  attrs: &[hir::Attribute]) -> io::Result<()> {\n+                                  attrs: &[ast::Attribute]) -> io::Result<()> {\n         self.print_block_maybe_unclosed(blk, indent_unit, attrs, true)\n     }\n \n     pub fn print_block_maybe_unclosed(&mut self,\n                                       blk: &hir::Block,\n                                       indented: usize,\n-                                      attrs: &[hir::Attribute],\n+                                      attrs: &[ast::Attribute],\n                                       close_box: bool) -> io::Result<()> {\n         match blk.rules {\n             hir::UnsafeBlock(..) | hir::PushUnsafeBlock(..) => try!(self.word_space(\"unsafe\")),\n@@ -1620,9 +1504,9 @@ impl<'a> State<'a> {\n                     match co.slice_shift_char() {\n                         Some(('=', operand)) if is_rw => {\n                             try!(s.print_string(&format!(\"+{}\", operand),\n-                                                hir::CookedStr))\n+                                                ast::CookedStr))\n                         }\n-                        _ => try!(s.print_string(&co, hir::CookedStr))\n+                        _ => try!(s.print_string(&co, ast::CookedStr))\n                     }\n                     try!(s.popen());\n                     try!(s.print_expr(&**o));\n@@ -1634,7 +1518,7 @@ impl<'a> State<'a> {\n \n                 try!(self.commasep(Inconsistent, &a.inputs,\n                                    |s, &(ref co, ref o)| {\n-                    try!(s.print_string(&co, hir::CookedStr));\n+                    try!(s.print_string(&co, ast::CookedStr));\n                     try!(s.popen());\n                     try!(s.print_expr(&**o));\n                     try!(s.pclose());\n@@ -1645,7 +1529,7 @@ impl<'a> State<'a> {\n \n                 try!(self.commasep(Inconsistent, &a.clobbers,\n                                    |s, co| {\n-                    try!(s.print_string(&co, hir::CookedStr));\n+                    try!(s.print_string(&co, ast::CookedStr));\n                     Ok(())\n                 }));\n \n@@ -1665,7 +1549,7 @@ impl<'a> State<'a> {\n                     try!(self.word_space(\":\"));\n                     try!(self.commasep(Inconsistent, &*options,\n                                        |s, &co| {\n-                        try!(s.print_string(co, hir::CookedStr));\n+                        try!(s.print_string(co, ast::CookedStr));\n                         Ok(())\n                     }));\n                 }\n@@ -2294,29 +2178,6 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_meta_item(&mut self, item: &hir::MetaItem) -> io::Result<()> {\n-        try!(self.ibox(indent_unit));\n-        match item.node {\n-            hir::MetaWord(ref name) => {\n-                try!(word(&mut self.s, &name));\n-            }\n-            hir::MetaNameValue(ref name, ref value) => {\n-                try!(self.word_space(&name[..]));\n-                try!(self.word_space(\"=\"));\n-                try!(self.print_literal(value));\n-            }\n-            hir::MetaList(ref name, ref items) => {\n-                try!(word(&mut self.s, &name));\n-                try!(self.popen());\n-                try!(self.commasep(Consistent,\n-                                   &items[..],\n-                                   |s, i| s.print_meta_item(&**i)));\n-                try!(self.pclose());\n-            }\n-        }\n-        self.end()\n-    }\n-\n     pub fn print_view_path(&mut self, vp: &hir::ViewPath) -> io::Result<()> {\n         match vp.node {\n             hir::ViewPathSimple(ident, ref path) => {\n@@ -2494,181 +2355,6 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_literal(&mut self, lit: &hir::Lit) -> io::Result<()> {\n-        try!(self.maybe_print_comment(lit.span.lo));\n-        match self.next_lit(lit.span.lo) {\n-            Some(ref ltrl) => {\n-                return word(&mut self.s, &(*ltrl).lit);\n-            }\n-            _ => ()\n-        }\n-        match lit.node {\n-            hir::LitStr(ref st, style) => self.print_string(&st, style),\n-            hir::LitByte(byte) => {\n-                let mut res = String::from(\"b'\");\n-                res.extend(ascii::escape_default(byte).map(|c| c as char));\n-                res.push('\\'');\n-                word(&mut self.s, &res[..])\n-            }\n-            hir::LitChar(ch) => {\n-                let mut res = String::from(\"'\");\n-                res.extend(ch.escape_default());\n-                res.push('\\'');\n-                word(&mut self.s, &res[..])\n-            }\n-            hir::LitInt(i, t) => {\n-                match t {\n-                    hir::SignedIntLit(st, hir::Plus) => {\n-                        word(&mut self.s,\n-                             &::util::int_ty_to_string(st, Some(i as i64)))\n-                    }\n-                    hir::SignedIntLit(st, hir::Minus) => {\n-                        let istr = ::util::int_ty_to_string(st, Some(-(i as i64)));\n-                        word(&mut self.s,\n-                             &format!(\"-{}\", istr))\n-                    }\n-                    hir::UnsignedIntLit(ut) => {\n-                        word(&mut self.s, &::util::uint_ty_to_string(ut, Some(i)))\n-                    }\n-                    hir::UnsuffixedIntLit(hir::Plus) => {\n-                        word(&mut self.s, &format!(\"{}\", i))\n-                    }\n-                    hir::UnsuffixedIntLit(hir::Minus) => {\n-                        word(&mut self.s, &format!(\"-{}\", i))\n-                    }\n-                }\n-            }\n-            hir::LitFloat(ref f, t) => {\n-                word(&mut self.s,\n-                     &format!(\n-                         \"{}{}\",\n-                         &f,\n-                         &::util::float_ty_to_string(t)))\n-            }\n-            hir::LitFloatUnsuffixed(ref f) => word(&mut self.s, &f[..]),\n-            hir::LitBool(val) => {\n-                if val { word(&mut self.s, \"true\") } else { word(&mut self.s, \"false\") }\n-            }\n-            hir::LitByteStr(ref v) => {\n-                let mut escaped: String = String::new();\n-                for &ch in v.iter() {\n-                    escaped.extend(ascii::escape_default(ch)\n-                                         .map(|c| c as char));\n-                }\n-                word(&mut self.s, &format!(\"b\\\"{}\\\"\", escaped))\n-            }\n-        }\n-    }\n-\n-    pub fn next_lit(&mut self, pos: BytePos) -> Option<comments::Literal> {\n-        match self.literals {\n-            Some(ref lits) => {\n-                while self.cur_cmnt_and_lit.cur_lit < lits.len() {\n-                    let ltrl = (*lits)[self.cur_cmnt_and_lit.cur_lit].clone();\n-                    if ltrl.pos > pos { return None; }\n-                    self.cur_cmnt_and_lit.cur_lit += 1;\n-                    if ltrl.pos == pos { return Some(ltrl); }\n-                }\n-                None\n-            }\n-            _ => None\n-        }\n-    }\n-\n-    pub fn maybe_print_comment(&mut self, pos: BytePos) -> io::Result<()> {\n-        loop {\n-            match self.next_comment() {\n-                Some(ref cmnt) => {\n-                    if (*cmnt).pos < pos {\n-                        try!(self.print_comment(cmnt));\n-                        self.cur_cmnt_and_lit.cur_cmnt += 1;\n-                    } else { break; }\n-                }\n-                _ => break\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn print_comment(&mut self,\n-                         cmnt: &comments::Comment) -> io::Result<()> {\n-        match cmnt.style {\n-            comments::Mixed => {\n-                assert_eq!(cmnt.lines.len(), 1);\n-                try!(zerobreak(&mut self.s));\n-                try!(word(&mut self.s, &cmnt.lines[0]));\n-                zerobreak(&mut self.s)\n-            }\n-            comments::Isolated => {\n-                try!(self.hardbreak_if_not_bol());\n-                for line in &cmnt.lines {\n-                    // Don't print empty lines because they will end up as trailing\n-                    // whitespace\n-                    if !line.is_empty() {\n-                        try!(word(&mut self.s, &line[..]));\n-                    }\n-                    try!(hardbreak(&mut self.s));\n-                }\n-                Ok(())\n-            }\n-            comments::Trailing => {\n-                try!(word(&mut self.s, \" \"));\n-                if cmnt.lines.len() == 1 {\n-                    try!(word(&mut self.s, &cmnt.lines[0]));\n-                    hardbreak(&mut self.s)\n-                } else {\n-                    try!(self.ibox(0));\n-                    for line in &cmnt.lines {\n-                        if !line.is_empty() {\n-                            try!(word(&mut self.s, &line[..]));\n-                        }\n-                        try!(hardbreak(&mut self.s));\n-                    }\n-                    self.end()\n-                }\n-            }\n-            comments::BlankLine => {\n-                // We need to do at least one, possibly two hardbreaks.\n-                let is_semi = match self.s.last_token() {\n-                    pp::Token::String(s, _) => \";\" == s,\n-                    _ => false\n-                };\n-                if is_semi || self.is_begin() || self.is_end() {\n-                    try!(hardbreak(&mut self.s));\n-                }\n-                hardbreak(&mut self.s)\n-            }\n-        }\n-    }\n-\n-    pub fn print_string(&mut self, st: &str,\n-                        style: hir::StrStyle) -> io::Result<()> {\n-        let st = match style {\n-            hir::CookedStr => {\n-                (format!(\"\\\"{}\\\"\", st.escape_default()))\n-            }\n-            hir::RawStr(n) => {\n-                (format!(\"r{delim}\\\"{string}\\\"{delim}\",\n-                         delim=repeat(\"#\", n),\n-                         string=st))\n-            }\n-        };\n-        word(&mut self.s, &st[..])\n-    }\n-\n-    pub fn next_comment(&mut self) -> Option<comments::Comment> {\n-        match self.comments {\n-            Some(ref cmnts) => {\n-                if self.cur_cmnt_and_lit.cur_cmnt < cmnts.len() {\n-                    Some(cmnts[self.cur_cmnt_and_lit.cur_cmnt].clone())\n-                } else {\n-                    None\n-                }\n-            }\n-            _ => None\n-        }\n-    }\n-\n     pub fn print_opt_abi_and_extern_if_nondefault(&mut self,\n                                                   opt_abi: Option<abi::Abi>)\n         -> io::Result<()> {\n@@ -2722,8 +2408,6 @@ impl<'a> State<'a> {\n     }\n }\n \n-fn repeat(s: &str, n: usize) -> String { iter::repeat(s).take(n).collect() }\n-\n // Dup'ed from parse::classify, but adapted for the HIR.\n /// Does this expression require a semicolon to be treated\n /// as a statement? The negation of this: 'can this expression"}, {"sha": "0a47da77a8fce2520565b4f1d5efc1a239778034", "filename": "src/librustc_front/util.rs", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_front%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_front%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Futil.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -338,64 +338,10 @@ pub fn compute_id_range_for_fn_body(fk: FnKind,\n     id_visitor.operation.result\n }\n \n-/// Returns true if this literal is a string and false otherwise.\n-pub fn lit_is_str(lit: &Lit) -> bool {\n-    match lit.node {\n-        LitStr(..) => true,\n-        _ => false,\n-    }\n-}\n-\n pub fn is_path(e: P<Expr>) -> bool {\n     match e.node { ExprPath(..) => true, _ => false }\n }\n \n-/// Get a string representation of a signed int type, with its value.\n-/// We want to avoid \"45int\" and \"-3int\" in favor of \"45\" and \"-3\"\n-pub fn int_ty_to_string(t: IntTy, val: Option<i64>) -> String {\n-    let s = match t {\n-        TyIs => \"isize\",\n-        TyI8 => \"i8\",\n-        TyI16 => \"i16\",\n-        TyI32 => \"i32\",\n-        TyI64 => \"i64\"\n-    };\n-\n-    match val {\n-        // cast to a u64 so we can correctly print INT64_MIN. All integral types\n-        // are parsed as u64, so we wouldn't want to print an extra negative\n-        // sign.\n-        Some(n) => format!(\"{}{}\", n as u64, s),\n-        None => s.to_string()\n-    }\n-}\n-\n-\n-/// Get a string representation of an unsigned int type, with its value.\n-/// We want to avoid \"42u\" in favor of \"42us\". \"42uint\" is right out.\n-pub fn uint_ty_to_string(t: UintTy, val: Option<u64>) -> String {\n-    let s = match t {\n-        TyUs => \"usize\",\n-        TyU8 => \"u8\",\n-        TyU16 => \"u16\",\n-        TyU32 => \"u32\",\n-        TyU64 => \"u64\"\n-    };\n-\n-    match val {\n-        Some(n) => format!(\"{}{}\", n, s),\n-        None => s.to_string()\n-    }\n-}\n-\n-pub fn float_ty_to_string(t: FloatTy) -> String {\n-    match t {\n-        TyF32 => \"f32\".to_string(),\n-        TyF64 => \"f64\".to_string(),\n-    }\n-}\n-\n-\n pub fn empty_generics() -> Generics {\n     Generics {\n         lifetimes: Vec::new(),"}, {"sha": "4a3e74fd3fef72a93da1ee8e1b20c7968746d22f", "filename": "src/librustc_front/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_front%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_front%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fvisit.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -24,7 +24,7 @@\n //! those that are created by the expansion of a macro.\n \n use syntax::abi::Abi;\n-use syntax::ast::{Ident, NodeId, CRATE_NODE_ID, Name};\n+use syntax::ast::{Ident, NodeId, CRATE_NODE_ID, Name, Attribute};\n use hir::*;\n use hir;\n use syntax::codemap::Span;"}, {"sha": "816b84f3d46b1171df0ecad002b0747241b6d6ac", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 58, "deletions": 62, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -46,18 +46,14 @@ use std::{cmp, slice};\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n \n use syntax::{abi, ast};\n-use syntax::attr as syntax_attr;\n+use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{self, Span};\n use syntax::feature_gate::{KNOWN_ATTRIBUTES, AttributeType};\n-use rustc_front::hir::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n+use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n use syntax::ptr::P;\n \n use rustc_front::hir;\n-\n-use rustc_front::attr::{self, AttrMetaMethods};\n use rustc_front::visit::{self, FnKind, Visitor};\n-use rustc_front::lowering::unlower_attribute;\n-\n use rustc_front::util::is_shift_binop;\n \n // hardwired lints from librustc\n@@ -80,7 +76,7 @@ impl LintPass for WhileTrue {\n     fn check_expr(&mut self, cx: &Context, e: &hir::Expr) {\n         if let hir::ExprWhile(ref cond, _, _) = e.node {\n             if let hir::ExprLit(ref lit) = cond.node {\n-                if let hir::LitBool(true) = lit.node {\n+                if let ast::LitBool(true) = lit.node {\n                     cx.span_lint(WHILE_TRUE, e.span,\n                                  \"denote infinite loops with loop { ... }\");\n                 }\n@@ -132,10 +128,10 @@ impl LintPass for TypeLimits {\n                 match expr.node  {\n                     hir::ExprLit(ref lit) => {\n                         match lit.node {\n-                            hir::LitInt(_, hir::UnsignedIntLit(_)) => {\n+                            ast::LitInt(_, ast::UnsignedIntLit(_)) => {\n                                 check_unsigned_negation_feature(cx, e.span);\n                             },\n-                            hir::LitInt(_, hir::UnsuffixedIntLit(_)) => {\n+                            ast::LitInt(_, ast::UnsuffixedIntLit(_)) => {\n                                 if let ty::TyUint(_) = cx.tcx.node_id_to_type(e.id).sty {\n                                     check_unsigned_negation_feature(cx, e.span);\n                                 }\n@@ -176,7 +172,7 @@ impl LintPass for TypeLimits {\n \n                     if let Some(bits) = opt_ty_bits {\n                         let exceeding = if let hir::ExprLit(ref lit) = r.node {\n-                            if let hir::LitInt(shift, _) = lit.node { shift >= bits }\n+                            if let ast::LitInt(shift, _) = lit.node { shift >= bits }\n                             else { false }\n                         } else {\n                             match eval_const_expr_partial(cx.tcx, &r, ExprTypeChecked) {\n@@ -196,9 +192,9 @@ impl LintPass for TypeLimits {\n                 match cx.tcx.node_id_to_type(e.id).sty {\n                     ty::TyInt(t) => {\n                         match lit.node {\n-                            hir::LitInt(v, hir::SignedIntLit(_, hir::Plus)) |\n-                            hir::LitInt(v, hir::UnsuffixedIntLit(hir::Plus)) => {\n-                                let int_type = if let hir::TyIs = t {\n+                            ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n+                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => {\n+                                let int_type = if let ast::TyIs = t {\n                                     cx.sess().target.int_type\n                                 } else {\n                                     t\n@@ -219,15 +215,15 @@ impl LintPass for TypeLimits {\n                         };\n                     },\n                     ty::TyUint(t) => {\n-                        let uint_type = if let hir::TyUs = t {\n+                        let uint_type = if let ast::TyUs = t {\n                             cx.sess().target.uint_type\n                         } else {\n                             t\n                         };\n                         let (min, max) = uint_ty_range(uint_type);\n                         let lit_val: u64 = match lit.node {\n-                            hir::LitByte(_v) => return,  // _v is u8, within range by definition\n-                            hir::LitInt(v, _) => v,\n+                            ast::LitByte(_v) => return,  // _v is u8, within range by definition\n+                            ast::LitInt(v, _) => v,\n                             _ => panic!()\n                         };\n                         if lit_val < min || lit_val > max {\n@@ -238,8 +234,8 @@ impl LintPass for TypeLimits {\n                     ty::TyFloat(t) => {\n                         let (min, max) = float_ty_range(t);\n                         let lit_val: f64 = match lit.node {\n-                            hir::LitFloat(ref v, _) |\n-                            hir::LitFloatUnsuffixed(ref v) => {\n+                            ast::LitFloat(ref v, _) |\n+                            ast::LitFloatUnsuffixed(ref v) => {\n                                 match v.parse() {\n                                     Ok(f) => f,\n                                     Err(_) => return\n@@ -282,50 +278,50 @@ impl LintPass for TypeLimits {\n \n         // for isize & usize, be conservative with the warnings, so that the\n         // warnings are consistent between 32- and 64-bit platforms\n-        fn int_ty_range(int_ty: hir::IntTy) -> (i64, i64) {\n+        fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n             match int_ty {\n-                hir::TyIs => (i64::MIN,        i64::MAX),\n-                hir::TyI8 =>    (i8::MIN  as i64, i8::MAX  as i64),\n-                hir::TyI16 =>   (i16::MIN as i64, i16::MAX as i64),\n-                hir::TyI32 =>   (i32::MIN as i64, i32::MAX as i64),\n-                hir::TyI64 =>   (i64::MIN,        i64::MAX)\n+                ast::TyIs => (i64::MIN,        i64::MAX),\n+                ast::TyI8 =>    (i8::MIN  as i64, i8::MAX  as i64),\n+                ast::TyI16 =>   (i16::MIN as i64, i16::MAX as i64),\n+                ast::TyI32 =>   (i32::MIN as i64, i32::MAX as i64),\n+                ast::TyI64 =>   (i64::MIN,        i64::MAX)\n             }\n         }\n \n-        fn uint_ty_range(uint_ty: hir::UintTy) -> (u64, u64) {\n+        fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n             match uint_ty {\n-                hir::TyUs => (u64::MIN,         u64::MAX),\n-                hir::TyU8 =>    (u8::MIN   as u64, u8::MAX   as u64),\n-                hir::TyU16 =>   (u16::MIN  as u64, u16::MAX  as u64),\n-                hir::TyU32 =>   (u32::MIN  as u64, u32::MAX  as u64),\n-                hir::TyU64 =>   (u64::MIN,         u64::MAX)\n+                ast::TyUs => (u64::MIN,         u64::MAX),\n+                ast::TyU8 =>    (u8::MIN   as u64, u8::MAX   as u64),\n+                ast::TyU16 =>   (u16::MIN  as u64, u16::MAX  as u64),\n+                ast::TyU32 =>   (u32::MIN  as u64, u32::MAX  as u64),\n+                ast::TyU64 =>   (u64::MIN,         u64::MAX)\n             }\n         }\n \n-        fn float_ty_range(float_ty: hir::FloatTy) -> (f64, f64) {\n+        fn float_ty_range(float_ty: ast::FloatTy) -> (f64, f64) {\n             match float_ty {\n-                hir::TyF32 => (f32::MIN as f64, f32::MAX as f64),\n-                hir::TyF64 => (f64::MIN,        f64::MAX)\n+                ast::TyF32 => (f32::MIN as f64, f32::MAX as f64),\n+                ast::TyF64 => (f64::MIN,        f64::MAX)\n             }\n         }\n \n-        fn int_ty_bits(int_ty: hir::IntTy, target_int_ty: hir::IntTy) -> u64 {\n+        fn int_ty_bits(int_ty: ast::IntTy, target_int_ty: ast::IntTy) -> u64 {\n             match int_ty {\n-                hir::TyIs => int_ty_bits(target_int_ty, target_int_ty),\n-                hir::TyI8 =>    i8::BITS  as u64,\n-                hir::TyI16 =>   i16::BITS as u64,\n-                hir::TyI32 =>   i32::BITS as u64,\n-                hir::TyI64 =>   i64::BITS as u64\n+                ast::TyIs => int_ty_bits(target_int_ty, target_int_ty),\n+                ast::TyI8 =>    i8::BITS  as u64,\n+                ast::TyI16 =>   i16::BITS as u64,\n+                ast::TyI32 =>   i32::BITS as u64,\n+                ast::TyI64 =>   i64::BITS as u64\n             }\n         }\n \n-        fn uint_ty_bits(uint_ty: hir::UintTy, target_uint_ty: hir::UintTy) -> u64 {\n+        fn uint_ty_bits(uint_ty: ast::UintTy, target_uint_ty: ast::UintTy) -> u64 {\n             match uint_ty {\n-                hir::TyUs => uint_ty_bits(target_uint_ty, target_uint_ty),\n-                hir::TyU8 =>    u8::BITS  as u64,\n-                hir::TyU16 =>   u16::BITS as u64,\n-                hir::TyU32 =>   u32::BITS as u64,\n-                hir::TyU64 =>   u64::BITS as u64\n+                ast::TyUs => uint_ty_bits(target_uint_ty, target_uint_ty),\n+                ast::TyU8 =>    u8::BITS  as u64,\n+                ast::TyU16 =>   u16::BITS as u64,\n+                ast::TyU32 =>   u32::BITS as u64,\n+                ast::TyU64 =>   u64::BITS as u64\n             }\n         }\n \n@@ -348,10 +344,10 @@ impl LintPass for TypeLimits {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i64 = match lit.node {\n                         hir::ExprLit(ref li) => match li.node {\n-                            hir::LitInt(v, hir::SignedIntLit(_, hir::Plus)) |\n-                            hir::LitInt(v, hir::UnsuffixedIntLit(hir::Plus)) => v as i64,\n-                            hir::LitInt(v, hir::SignedIntLit(_, hir::Minus)) |\n-                            hir::LitInt(v, hir::UnsuffixedIntLit(hir::Minus)) => -(v as i64),\n+                            ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n+                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => v as i64,\n+                            ast::LitInt(v, ast::SignedIntLit(_, ast::Minus)) |\n+                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Minus)) => -(v as i64),\n                             _ => return true\n                         },\n                         _ => panic!()\n@@ -362,7 +358,7 @@ impl LintPass for TypeLimits {\n                     let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n                     let lit_val: u64 = match lit.node {\n                         hir::ExprLit(ref li) => match li.node {\n-                            hir::LitInt(v, _) => v,\n+                            ast::LitInt(v, _) => v,\n                             _ => return true\n                         },\n                         _ => panic!()\n@@ -557,11 +553,11 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 FfiSafe\n             }\n \n-            ty::TyInt(hir::TyIs) => {\n+            ty::TyInt(ast::TyIs) => {\n                 FfiUnsafe(\"found Rust type `isize` in foreign module, while \\\n                           `libc::c_int` or `libc::c_long` should be used\")\n             }\n-            ty::TyUint(hir::TyUs) => {\n+            ty::TyUint(ast::TyUs) => {\n                 FfiUnsafe(\"found Rust type `usize` in foreign module, while \\\n                           `libc::c_uint` or `libc::c_ulong` should be used\")\n             }\n@@ -892,7 +888,7 @@ impl LintPass for UnusedAttributes {\n         lint_array!(UNUSED_ATTRIBUTES)\n     }\n \n-    fn check_attribute(&mut self, cx: &Context, attr: &hir::Attribute) {\n+    fn check_attribute(&mut self, cx: &Context, attr: &ast::Attribute) {\n         // Note that check_name() marks the attribute as used if it matches.\n         for &(ref name, ty, _) in KNOWN_ATTRIBUTES {\n             match ty {\n@@ -910,7 +906,7 @@ impl LintPass for UnusedAttributes {\n             }\n         }\n \n-        if !syntax_attr::is_used(&unlower_attribute(attr)) {\n+        if !attr::is_used(attr) {\n             cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n             // Is it a builtin attribute that must be used at the crate level?\n             let known_crate = KNOWN_ATTRIBUTES.iter().find(|&&(name, ty, _)| {\n@@ -927,9 +923,9 @@ impl LintPass for UnusedAttributes {\n                                                     }).is_some();\n             if  known_crate || plugin_crate {\n                 let msg = match attr.node.style {\n-                    hir::AttrOuter => \"crate-level attribute should be an inner \\\n+                    ast::AttrOuter => \"crate-level attribute should be an inner \\\n                                        attribute: add an exclamation mark: #![foo]\",\n-                    hir::AttrInner => \"crate-level attribute should be in the \\\n+                    ast::AttrInner => \"crate-level attribute should be in the \\\n                                        root module\",\n                 };\n                 cx.span_lint(UNUSED_ATTRIBUTES, attr.span, msg);\n@@ -1019,7 +1015,7 @@ impl LintPass for UnusedResults {\n             cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n         }\n \n-        fn check_must_use(cx: &Context, attrs: &[hir::Attribute], sp: Span) -> bool {\n+        fn check_must_use(cx: &Context, attrs: &[ast::Attribute], sp: Span) -> bool {\n             for attr in attrs {\n                 if attr.check_name(\"must_use\") {\n                     let mut msg = \"unused result which must be used\".to_string();\n@@ -1780,7 +1776,7 @@ impl MissingDoc {\n     fn check_missing_docs_attrs(&self,\n                                cx: &Context,\n                                id: Option<ast::NodeId>,\n-                               attrs: &[hir::Attribute],\n+                               attrs: &[ast::Attribute],\n                                sp: Span,\n                                desc: &'static str) {\n         // If we're building a test harness, then warning about\n@@ -1805,7 +1801,7 @@ impl MissingDoc {\n \n         let has_doc = attrs.iter().any(|a| {\n             match a.node.value.node {\n-                hir::MetaNameValue(ref name, _) if *name == \"doc\" => true,\n+                ast::MetaNameValue(ref name, _) if *name == \"doc\" => true,\n                 _ => false\n             }\n         });\n@@ -1821,7 +1817,7 @@ impl LintPass for MissingDoc {\n         lint_array!(MISSING_DOCS)\n     }\n \n-    fn enter_lint_attrs(&mut self, _: &Context, attrs: &[hir::Attribute]) {\n+    fn enter_lint_attrs(&mut self, _: &Context, attrs: &[ast::Attribute]) {\n         let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n             attr.check_name(\"doc\") && match attr.meta_item_list() {\n                 None => false,\n@@ -1831,7 +1827,7 @@ impl LintPass for MissingDoc {\n         self.doc_hidden_stack.push(doc_hidden);\n     }\n \n-    fn exit_lint_attrs(&mut self, _: &Context, _: &[hir::Attribute]) {\n+    fn exit_lint_attrs(&mut self, _: &Context, _: &[ast::Attribute]) {\n         self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n     }\n \n@@ -2573,7 +2569,7 @@ impl LintPass for UnstableFeatures {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNSTABLE_FEATURES)\n     }\n-    fn check_attribute(&mut self, ctx: &Context, attr: &hir::Attribute) {\n+    fn check_attribute(&mut self, ctx: &Context, attr: &ast::Attribute) {\n         if attr::contains_name(&[attr.node.value.clone()], \"feature\") {\n             if let Some(items) = attr.node.value.meta_item_list() {\n                 for item in items {"}, {"sha": "9b3514028afada6888c60eaa9540aa64bec8aa59", "filename": "src/librustc_mir/dump.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_mir%2Fdump.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_mir%2Fdump.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdump.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -32,9 +32,9 @@ use self::rustc::middle::region::CodeExtentData;\n use self::rustc::middle::ty::{self, Ty};\n use self::rustc::util::common::ErrorReported;\n use self::rustc_front::hir;\n-use self::rustc_front::attr::{AttrMetaMethods};\n use self::rustc_front::visit;\n use self::syntax::ast;\n+use self::syntax::attr::AttrMetaMethods;\n use self::syntax::codemap::Span;\n \n pub fn dump_crate(tcx: &ty::ctxt) {\n@@ -50,7 +50,7 @@ struct OuterDump<'a,'tcx:'a> {\n }\n \n impl<'a, 'tcx> OuterDump<'a, 'tcx> {\n-    fn visit_mir<OP>(&self, attributes: &'tcx [hir::Attribute], mut walk_op: OP)\n+    fn visit_mir<OP>(&self, attributes: &'tcx [ast::Attribute], mut walk_op: OP)\n         where OP: FnMut(&mut InnerDump<'a,'tcx>)\n     {\n         let mut built_mir = false;\n@@ -94,7 +94,7 @@ impl<'a, 'tcx> visit::Visitor<'tcx> for OuterDump<'a, 'tcx> {\n \n struct InnerDump<'a,'tcx:'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    attr: Option<&'a hir::Attribute>,\n+    attr: Option<&'a ast::Attribute>,\n }\n \n impl<'a, 'tcx> visit::Visitor<'tcx> for InnerDump<'a,'tcx> {"}, {"sha": "350253c5b533af0230f8ab4f6a549443eca51c5f", "filename": "src/librustc_mir/tcx/expr.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -23,6 +23,7 @@ use tcx::rustc::middle::pat_util;\n use tcx::rustc::middle::ty::{self, Ty};\n use tcx::rustc_front::hir;\n use tcx::rustc_front::util as hir_util;\n+use tcx::syntax::ast;\n use tcx::syntax::codemap::Span;\n use tcx::syntax::parse::token;\n use tcx::syntax::ptr::P;\n@@ -462,56 +463,56 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n fn convert_literal<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n                                expr_span: Span,\n                                expr_ty: Ty<'tcx>,\n-                               literal: &hir::Lit)\n+                               literal: &ast::Lit)\n                                -> Literal<Cx<'a,'tcx>>\n {\n     use repr::IntegralBits::*;\n     match (&literal.node, &expr_ty.sty) {\n-        (&hir::LitStr(ref text, _), _) =>\n+        (&ast::LitStr(ref text, _), _) =>\n             Literal::String { value: text.clone() },\n-        (&hir::LitByteStr(ref bytes), _) =>\n+        (&ast::LitByteStr(ref bytes), _) =>\n             Literal::Bytes { value: bytes.clone() },\n-        (&hir::LitByte(c), _) =>\n+        (&ast::LitByte(c), _) =>\n             Literal::Uint { bits: B8, value: c as u64 },\n-        (&hir::LitChar(c), _) =>\n+        (&ast::LitChar(c), _) =>\n             Literal::Char { c: c },\n-        (&hir::LitInt(v, _), &ty::TyUint(hir::TyU8)) =>\n+        (&ast::LitInt(v, _), &ty::TyUint(ast::TyU8)) =>\n             Literal::Uint { bits: B8, value: v },\n-        (&hir::LitInt(v, _), &ty::TyUint(hir::TyU16)) =>\n+        (&ast::LitInt(v, _), &ty::TyUint(ast::TyU16)) =>\n             Literal::Uint { bits: B16, value: v },\n-        (&hir::LitInt(v, _), &ty::TyUint(hir::TyU32)) =>\n+        (&ast::LitInt(v, _), &ty::TyUint(ast::TyU32)) =>\n             Literal::Uint { bits: B32, value: v },\n-        (&hir::LitInt(v, _), &ty::TyUint(hir::TyU64)) =>\n+        (&ast::LitInt(v, _), &ty::TyUint(ast::TyU64)) =>\n             Literal::Uint { bits: B64, value: v },\n-        (&hir::LitInt(v, _), &ty::TyUint(hir::TyUs)) =>\n+        (&ast::LitInt(v, _), &ty::TyUint(ast::TyUs)) =>\n             Literal::Uint { bits: BSize, value: v },\n-        (&hir::LitInt(v, hir::SignedIntLit(_, hir::Sign::Minus)), &ty::TyInt(hir::TyI8)) =>\n+        (&ast::LitInt(v, ast::SignedIntLit(_, ast::Sign::Minus)), &ty::TyInt(ast::TyI8)) =>\n             Literal::Int { bits: B8, value: -(v as i64) },\n-        (&hir::LitInt(v, hir::SignedIntLit(_, hir::Sign::Minus)), &ty::TyInt(hir::TyI16)) =>\n+        (&ast::LitInt(v, ast::SignedIntLit(_, ast::Sign::Minus)), &ty::TyInt(ast::TyI16)) =>\n             Literal::Int { bits: B16, value: -(v as i64) },\n-        (&hir::LitInt(v, hir::SignedIntLit(_, hir::Sign::Minus)), &ty::TyInt(hir::TyI32)) =>\n+        (&ast::LitInt(v, ast::SignedIntLit(_, ast::Sign::Minus)), &ty::TyInt(ast::TyI32)) =>\n             Literal::Int { bits: B32, value: -(v as i64) },\n-        (&hir::LitInt(v, hir::SignedIntLit(_, hir::Sign::Minus)), &ty::TyInt(hir::TyI64)) =>\n+        (&ast::LitInt(v, ast::SignedIntLit(_, ast::Sign::Minus)), &ty::TyInt(ast::TyI64)) =>\n             Literal::Int { bits: B64, value: -(v as i64) },\n-        (&hir::LitInt(v, hir::SignedIntLit(_, hir::Sign::Minus)), &ty::TyInt(hir::TyIs)) =>\n+        (&ast::LitInt(v, ast::SignedIntLit(_, ast::Sign::Minus)), &ty::TyInt(ast::TyIs)) =>\n             Literal::Int { bits: BSize, value: -(v as i64) },\n-        (&hir::LitInt(v, _), &ty::TyInt(hir::TyI8)) =>\n+        (&ast::LitInt(v, _), &ty::TyInt(ast::TyI8)) =>\n             Literal::Int { bits: B8, value: v as i64 },\n-        (&hir::LitInt(v, _), &ty::TyInt(hir::TyI16)) =>\n+        (&ast::LitInt(v, _), &ty::TyInt(ast::TyI16)) =>\n             Literal::Int { bits: B16, value: v as i64 },\n-        (&hir::LitInt(v, _), &ty::TyInt(hir::TyI32)) =>\n+        (&ast::LitInt(v, _), &ty::TyInt(ast::TyI32)) =>\n             Literal::Int { bits: B32, value: v as i64 },\n-        (&hir::LitInt(v, _), &ty::TyInt(hir::TyI64)) =>\n+        (&ast::LitInt(v, _), &ty::TyInt(ast::TyI64)) =>\n             Literal::Int { bits: B64, value: v as i64 },\n-        (&hir::LitInt(v, _), &ty::TyInt(hir::TyIs)) =>\n+        (&ast::LitInt(v, _), &ty::TyInt(ast::TyIs)) =>\n             Literal::Int { bits: BSize, value: v as i64 },\n-        (&hir::LitFloat(ref v, _), &ty::TyFloat(hir::TyF32)) |\n-        (&hir::LitFloatUnsuffixed(ref v), &ty::TyFloat(hir::TyF32)) =>\n+        (&ast::LitFloat(ref v, _), &ty::TyFloat(ast::TyF32)) |\n+        (&ast::LitFloatUnsuffixed(ref v), &ty::TyFloat(ast::TyF32)) =>\n             Literal::Float { bits: FloatBits::F32, value: v.parse::<f64>().unwrap() },\n-        (&hir::LitFloat(ref v, _), &ty::TyFloat(hir::TyF64)) |\n-        (&hir::LitFloatUnsuffixed(ref v), &ty::TyFloat(hir::TyF64)) =>\n+        (&ast::LitFloat(ref v, _), &ty::TyFloat(ast::TyF64)) |\n+        (&ast::LitFloatUnsuffixed(ref v), &ty::TyFloat(ast::TyF64)) =>\n             Literal::Float { bits: FloatBits::F64, value: v.parse::<f64>().unwrap() },\n-        (&hir::LitBool(v), _) =>\n+        (&ast::LitBool(v), _) =>\n             Literal::Bool { value: v },\n         (ref l, ref t) =>\n             cx.tcx.sess.span_bug("}, {"sha": "1a2498420faa27beea11d0e6a96651ecd37d6243", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -37,6 +37,7 @@ use rustc::middle::def::*;\n use rustc::middle::def_id::DefId;\n \n use syntax::ast::{Name, NodeId};\n+use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::special_idents;\n use syntax::codemap::{Span, DUMMY_SP};\n \n@@ -53,7 +54,6 @@ use rustc_front::hir::TupleVariantKind;\n use rustc_front::hir::UnnamedField;\n use rustc_front::hir::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use rustc_front::hir::Visibility;\n-use rustc_front::attr::AttrMetaMethods;\n use rustc_front::visit::{self, Visitor};\n \n use std::mem::replace;"}, {"sha": "8e34118957ebd8bfa5e6c8f5ceaf4c6318165f33", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -65,7 +65,8 @@ use rustc::util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n use rustc::util::lev_distance::lev_distance;\n \n use syntax::ast;\n-use syntax::ast::{Ident, Name, NodeId, CrateNum};\n+use syntax::ast::{Ident, Name, NodeId, CrateNum, TyIs, TyI8, TyI16, TyI32, TyI64};\n+use syntax::ast::{TyUs, TyU8, TyU16, TyU32, TyU64, TyF64, TyF32};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::mtwt;\n use syntax::parse::token::{self, special_names, special_idents};\n@@ -86,10 +87,8 @@ use rustc_front::hir::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n use rustc_front::hir::{Local, MethodImplItem};\n use rustc_front::hir::{Pat, PatEnum, PatIdent, PatLit, PatQPath};\n use rustc_front::hir::{PatRange, PatStruct, Path, PrimTy};\n-use rustc_front::hir::{TraitRef, Ty, TyBool, TyChar, TyF32};\n-use rustc_front::hir::{TyF64, TyFloat, TyIs, TyI8, TyI16, TyI32, TyI64, TyInt};\n-use rustc_front::hir::{TyPath, TyPtr};\n-use rustc_front::hir::{TyRptr, TyStr, TyUs, TyU8, TyU16, TyU32, TyU64, TyUint};\n+use rustc_front::hir::{TraitRef, Ty, TyBool, TyChar, TyFloat, TyInt};\n+use rustc_front::hir::{TyRptr, TyStr, TyUint, TyPath, TyPtr};\n use rustc_front::hir::TypeImplItem;\n use rustc_front::util::walk_pat;\n "}, {"sha": "83e33ede6f23fa1240c227c2921d85cfbe547c19", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -46,7 +46,6 @@ use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::attr::AttrMetaMethods;\n-use rustc_front::attr::AttrMetaMethods as FrontAttrMetaMethods;\n \n use rustc_front::hir;\n "}, {"sha": "aaa10aacd036ba2f4a2f37d2863d97f327dade30", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -905,7 +905,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                 compare_str(cx, lhs_data, lhs_len, rhs_data, rhs_len, rhs_t, debug_loc)\n             }\n             ty::TyArray(ty, _) | ty::TySlice(ty) => match ty.sty {\n-                ty::TyUint(hir::TyU8) => {\n+                ty::TyUint(ast::TyU8) => {\n                     // NOTE: cast &[u8] and &[u8; N] to &str and abuse the str_eq lang item,\n                     // which calls memcmp().\n                     let pat_len = val_ty(rhs).element_type().array_length();"}, {"sha": "de09e33ec142786b0f6442281c8b5a0e00ac65ea", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -51,9 +51,8 @@ use middle::subst;\n use middle::ty::{self, Ty};\n use middle::ty::Disr;\n use syntax::ast;\n-use rustc_front::attr;\n-use rustc_front::attr::IntType;\n-use rustc_front::hir;\n+use syntax::attr;\n+use syntax::attr::IntType;\n use trans::_match;\n use trans::build::*;\n use trans::cleanup;\n@@ -387,11 +386,11 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let ity = if use_align {\n                 // Use the overall alignment\n                 match align {\n-                    1 => attr::UnsignedInt(hir::TyU8),\n-                    2 => attr::UnsignedInt(hir::TyU16),\n-                    4 => attr::UnsignedInt(hir::TyU32),\n+                    1 => attr::UnsignedInt(ast::TyU8),\n+                    2 => attr::UnsignedInt(ast::TyU16),\n+                    4 => attr::UnsignedInt(ast::TyU32),\n                     8 if machine::llalign_of_min(cx, Type::i64(cx)) == 8 =>\n-                        attr::UnsignedInt(hir::TyU64),\n+                        attr::UnsignedInt(ast::TyU64),\n                     _ => min_ity // use min_ity as a fallback\n                 }\n             } else {\n@@ -583,12 +582,12 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n     // Lists of sizes to try.  u64 is always allowed as a fallback.\n     #[allow(non_upper_case_globals)]\n     const choose_shortest: &'static [IntType] = &[\n-        attr::UnsignedInt(hir::TyU8), attr::SignedInt(hir::TyI8),\n-        attr::UnsignedInt(hir::TyU16), attr::SignedInt(hir::TyI16),\n-        attr::UnsignedInt(hir::TyU32), attr::SignedInt(hir::TyI32)];\n+        attr::UnsignedInt(ast::TyU8), attr::SignedInt(ast::TyI8),\n+        attr::UnsignedInt(ast::TyU16), attr::SignedInt(ast::TyI16),\n+        attr::UnsignedInt(ast::TyU32), attr::SignedInt(ast::TyI32)];\n     #[allow(non_upper_case_globals)]\n     const at_least_32: &'static [IntType] = &[\n-        attr::UnsignedInt(hir::TyU32), attr::SignedInt(hir::TyI32)];\n+        attr::UnsignedInt(ast::TyU32), attr::SignedInt(ast::TyI32)];\n \n     let attempts;\n     match hint {\n@@ -622,7 +621,7 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n             return ity;\n         }\n     }\n-    return attr::UnsignedInt(hir::TyU64);\n+    return attr::UnsignedInt(ast::TyU64);\n }\n \n pub fn ll_inttype(cx: &CrateContext, ity: IntType) -> Type {"}, {"sha": "af4c2205e659b8067b981c67ff040b01b5921622", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -15,8 +15,9 @@ use middle::ty;\n use middle::infer;\n use session::config::NoDebugInfo;\n use syntax::abi;\n+pub use syntax::attr::InlineAttr;\n+use syntax::ast;\n use rustc_front::hir;\n-pub use rustc_front::attr::InlineAttr;\n use trans::base;\n use trans::common;\n use trans::context::CrateContext;\n@@ -90,8 +91,8 @@ pub fn set_optimize_for_size(val: ValueRef, optimize: bool) {\n \n /// Composite function which sets LLVM attributes for function depending on its AST (#[attribute])\n /// attributes.\n-pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[hir::Attribute], llfn: ValueRef) {\n-    use rustc_front::attr::*;\n+pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRef) {\n+    use syntax::attr::*;\n     inline(llfn, find_inline_attr(Some(ccx.sess().diagnostic()), attrs));\n \n     // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a"}, {"sha": "89bd247b893a856e0cd877c4c32c09cb28aba93e", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -95,9 +95,9 @@ use std::{i8, i16, i32, i64};\n use syntax::abi::{Rust, RustCall, RustIntrinsic, PlatformIntrinsic, Abi};\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n+use syntax::attr::AttrMetaMethods;\n+use syntax::attr;\n use rustc_front;\n-use rustc_front::attr::AttrMetaMethods;\n-use rustc_front::attr;\n use rustc_front::visit::Visitor;\n use rustc_front::visit;\n use rustc_front::hir;\n@@ -581,12 +581,12 @@ pub fn llty_and_min_for_signed_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         ty::TyInt(t) => {\n             let llty = Type::int_from_ty(cx.ccx(), t);\n             let min = match t {\n-                hir::TyIs if llty == Type::i32(cx.ccx()) => i32::MIN as u64,\n-                hir::TyIs => i64::MIN as u64,\n-                hir::TyI8 => i8::MIN as u64,\n-                hir::TyI16 => i16::MIN as u64,\n-                hir::TyI32 => i32::MIN as u64,\n-                hir::TyI64 => i64::MIN as u64,\n+                ast::TyIs if llty == Type::i32(cx.ccx()) => i32::MIN as u64,\n+                ast::TyIs => i64::MIN as u64,\n+                ast::TyI8 => i8::MIN as u64,\n+                ast::TyI16 => i16::MIN as u64,\n+                ast::TyI32 => i32::MIN as u64,\n+                ast::TyI64 => i64::MIN as u64,\n             };\n             (llty, min)\n         }\n@@ -1563,7 +1563,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                    llfndecl: ValueRef,\n                                    param_substs: &'tcx Substs<'tcx>,\n                                    fn_ast_id: ast::NodeId,\n-                                   _attributes: &[hir::Attribute],\n+                                   _attributes: &[ast::Attribute],\n                                    output_type: ty::FnOutput<'tcx>,\n                                    abi: Abi,\n                                    closure_env: closure::ClosureEnv<'b>) {\n@@ -1682,7 +1682,7 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                           llfndecl: ValueRef,\n                           param_substs: &'tcx Substs<'tcx>,\n                           id: ast::NodeId,\n-                          attrs: &[hir::Attribute]) {\n+                          attrs: &[ast::Attribute]) {\n     let _s = StatRecorder::new(ccx, ccx.tcx().map.path_to_string(id).to_string());\n     debug!(\"trans_fn(param_substs={:?})\", param_substs);\n     let _icx = push_ctxt(\"trans_fn\");\n@@ -2294,7 +2294,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n }\n \n fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, id: ast::NodeId,\n-                           ty: Ty<'tcx>, attrs: &[hir::Attribute]) -> String {\n+                           ty: Ty<'tcx>, attrs: &[ast::Attribute]) -> String {\n     match ccx.external_srcs().borrow().get(&id) {\n         Some(&did) => {\n             let sym = csearch::get_symbol(&ccx.sess().cstore, did);\n@@ -2492,7 +2492,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n }\n \n fn register_method(ccx: &CrateContext, id: ast::NodeId,\n-                   attrs: &[hir::Attribute], span: Span) -> ValueRef {\n+                   attrs: &[ast::Attribute], span: Span) -> ValueRef {\n     let mty = ccx.tcx().node_id_to_type(id);\n \n     let sym = exported_name(ccx, id, mty, &attrs);"}, {"sha": "0f06e3cbfa4224787a2baa842a57700314338c4d", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -41,30 +41,30 @@ use middle::ty::cast::{CastTy,IntTy};\n use util::nodemap::NodeMap;\n \n use rustc_front::hir;\n-use rustc_front::attr;\n \n use std::ffi::{CStr, CString};\n use libc::c_uint;\n use syntax::ast;\n+use syntax::attr;\n use syntax::parse::token;\n use syntax::ptr::P;\n \n pub type FnArgMap<'a> = Option<&'a NodeMap<ValueRef>>;\n \n-pub fn const_lit(cx: &CrateContext, e: &hir::Expr, lit: &hir::Lit)\n+pub fn const_lit(cx: &CrateContext, e: &hir::Expr, lit: &ast::Lit)\n     -> ValueRef {\n     let _icx = push_ctxt(\"trans_lit\");\n     debug!(\"const_lit: {:?}\", lit);\n     match lit.node {\n-        hir::LitByte(b) => C_integral(Type::uint_from_ty(cx, hir::TyU8), b as u64, false),\n-        hir::LitChar(i) => C_integral(Type::char(cx), i as u64, false),\n-        hir::LitInt(i, hir::SignedIntLit(t, _)) => {\n+        ast::LitByte(b) => C_integral(Type::uint_from_ty(cx, ast::TyU8), b as u64, false),\n+        ast::LitChar(i) => C_integral(Type::char(cx), i as u64, false),\n+        ast::LitInt(i, ast::SignedIntLit(t, _)) => {\n             C_integral(Type::int_from_ty(cx, t), i, true)\n         }\n-        hir::LitInt(u, hir::UnsignedIntLit(t)) => {\n+        ast::LitInt(u, ast::UnsignedIntLit(t)) => {\n             C_integral(Type::uint_from_ty(cx, t), u, false)\n         }\n-        hir::LitInt(i, hir::UnsuffixedIntLit(_)) => {\n+        ast::LitInt(i, ast::UnsuffixedIntLit(_)) => {\n             let lit_int_ty = cx.tcx().node_id_to_type(e.id);\n             match lit_int_ty.sty {\n                 ty::TyInt(t) => {\n@@ -79,10 +79,10 @@ pub fn const_lit(cx: &CrateContext, e: &hir::Expr, lit: &hir::Lit)\n                                 lit_int_ty))\n             }\n         }\n-        hir::LitFloat(ref fs, t) => {\n+        ast::LitFloat(ref fs, t) => {\n             C_floating(&fs, Type::float_from_ty(cx, t))\n         }\n-        hir::LitFloatUnsuffixed(ref fs) => {\n+        ast::LitFloatUnsuffixed(ref fs) => {\n             let lit_float_ty = cx.tcx().node_id_to_type(e.id);\n             match lit_float_ty.sty {\n                 ty::TyFloat(t) => {\n@@ -94,9 +94,9 @@ pub fn const_lit(cx: &CrateContext, e: &hir::Expr, lit: &hir::Lit)\n                 }\n             }\n         }\n-        hir::LitBool(b) => C_bool(cx, b),\n-        hir::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n-        hir::LitByteStr(ref data) => {\n+        ast::LitBool(b) => C_bool(cx, b),\n+        ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n+        ast::LitByteStr(ref data) => {\n             addr_of(cx, C_bytes(cx, &data[..]), \"byte_str\")\n         }\n     }\n@@ -898,7 +898,7 @@ pub fn trans_static(ccx: &CrateContext,\n                     m: hir::Mutability,\n                     expr: &hir::Expr,\n                     id: ast::NodeId,\n-                    attrs: &Vec<hir::Attribute>)\n+                    attrs: &Vec<ast::Attribute>)\n                     -> ValueRef {\n     unsafe {\n         let _icx = push_ctxt(\"trans_static\");"}, {"sha": "f7b0f37c9ff78bbbb337417310adede676f60942", "filename": "src/librustc_trans/trans/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -20,7 +20,7 @@ use session::config::NoDebugInfo;\n \n use std::ffi::CString;\n use std::ptr;\n-use rustc_front::attr;\n+use syntax::attr;\n \n \n /// Inserts a side-effect free instruction sequence that makes sure that the"}, {"sha": "33d79662d39daae0385c79d24c80a1e427c9f13e", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -27,7 +27,6 @@ use middle::def_id::DefId;\n use middle::pat_util;\n use middle::subst::{self, Substs};\n use rustc::front::map as hir_map;\n-use rustc_front;\n use rustc_front::hir;\n use trans::{type_of, adt, machine, monomorphize};\n use trans::common::{self, CrateContext, FunctionContext, Block};\n@@ -43,6 +42,7 @@ use std::ffi::CString;\n use std::path::Path;\n use std::ptr;\n use std::rc::Rc;\n+use syntax;\n use syntax::util::interner::Interner;\n use syntax::codemap::Span;\n use syntax::{ast, codemap};\n@@ -934,22 +934,22 @@ fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyBool => (\"bool\".to_string(), DW_ATE_boolean),\n         ty::TyChar => (\"char\".to_string(), DW_ATE_unsigned_char),\n         ty::TyInt(int_ty) => match int_ty {\n-            hir::TyIs => (\"isize\".to_string(), DW_ATE_signed),\n-            hir::TyI8 => (\"i8\".to_string(), DW_ATE_signed),\n-            hir::TyI16 => (\"i16\".to_string(), DW_ATE_signed),\n-            hir::TyI32 => (\"i32\".to_string(), DW_ATE_signed),\n-            hir::TyI64 => (\"i64\".to_string(), DW_ATE_signed)\n+            ast::TyIs => (\"isize\".to_string(), DW_ATE_signed),\n+            ast::TyI8 => (\"i8\".to_string(), DW_ATE_signed),\n+            ast::TyI16 => (\"i16\".to_string(), DW_ATE_signed),\n+            ast::TyI32 => (\"i32\".to_string(), DW_ATE_signed),\n+            ast::TyI64 => (\"i64\".to_string(), DW_ATE_signed)\n         },\n         ty::TyUint(uint_ty) => match uint_ty {\n-            hir::TyUs => (\"usize\".to_string(), DW_ATE_unsigned),\n-            hir::TyU8 => (\"u8\".to_string(), DW_ATE_unsigned),\n-            hir::TyU16 => (\"u16\".to_string(), DW_ATE_unsigned),\n-            hir::TyU32 => (\"u32\".to_string(), DW_ATE_unsigned),\n-            hir::TyU64 => (\"u64\".to_string(), DW_ATE_unsigned)\n+            ast::TyUs => (\"usize\".to_string(), DW_ATE_unsigned),\n+            ast::TyU8 => (\"u8\".to_string(), DW_ATE_unsigned),\n+            ast::TyU16 => (\"u16\".to_string(), DW_ATE_unsigned),\n+            ast::TyU32 => (\"u32\".to_string(), DW_ATE_unsigned),\n+            ast::TyU64 => (\"u64\".to_string(), DW_ATE_unsigned)\n         },\n         ty::TyFloat(float_ty) => match float_ty {\n-            hir::TyF32 => (\"f32\".to_string(), DW_ATE_float),\n-            hir::TyF64 => (\"f64\".to_string(), DW_ATE_float),\n+            ast::TyF32 => (\"f32\".to_string(), DW_ATE_float),\n+            ast::TyF64 => (\"f64\".to_string(), DW_ATE_float),\n         },\n         _ => cx.sess().bug(\"debuginfo::basic_type_metadata - t is invalid type\")\n     };\n@@ -1608,7 +1608,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         })\n         .collect();\n \n-    let discriminant_type_metadata = |inttype: rustc_front::attr::IntType| {\n+    let discriminant_type_metadata = |inttype: syntax::attr::IntType| {\n         let disr_type_key = (enum_def_id, inttype);\n         let cached_discriminant_type_metadata = debug_context(cx).created_enum_disr_types\n                                                                  .borrow()"}, {"sha": "10b9ee2ac7502cf375a98a193fc2664703dcf92d", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -31,7 +31,6 @@ use middle::infer::normalize_associated_type;\n use middle::subst::{self, Substs};\n use rustc_front;\n use rustc_front::hir;\n-use rustc_front::attr::IntType;\n \n use trans::common::{NodeIdAndSpan, CrateContext, FunctionContext, Block};\n use trans;\n@@ -49,6 +48,7 @@ use std::rc::Rc;\n \n use syntax::codemap::{Span, Pos};\n use syntax::{abi, ast, codemap};\n+use syntax::attr::IntType;\n use syntax::parse::token::{self, special_idents};\n \n pub mod gdb;"}, {"sha": "7400ec3cbcd4aceb19b7aeeda25f2ce99bdfe1b8", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -18,7 +18,7 @@ use middle::subst::{self, Substs};\n use middle::ty::{self, Ty};\n \n use rustc_front::hir;\n-\n+use syntax::ast;\n \n // Compute the name of the type as it should be stored in debuginfo. Does not do\n // any caching, i.e. calling the function twice with the same type will also do\n@@ -43,18 +43,18 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyBool              => output.push_str(\"bool\"),\n         ty::TyChar              => output.push_str(\"char\"),\n         ty::TyStr               => output.push_str(\"str\"),\n-        ty::TyInt(hir::TyIs)    => output.push_str(\"isize\"),\n-        ty::TyInt(hir::TyI8)    => output.push_str(\"i8\"),\n-        ty::TyInt(hir::TyI16)   => output.push_str(\"i16\"),\n-        ty::TyInt(hir::TyI32)   => output.push_str(\"i32\"),\n-        ty::TyInt(hir::TyI64)   => output.push_str(\"i64\"),\n-        ty::TyUint(hir::TyUs)   => output.push_str(\"usize\"),\n-        ty::TyUint(hir::TyU8)   => output.push_str(\"u8\"),\n-        ty::TyUint(hir::TyU16)  => output.push_str(\"u16\"),\n-        ty::TyUint(hir::TyU32)  => output.push_str(\"u32\"),\n-        ty::TyUint(hir::TyU64)  => output.push_str(\"u64\"),\n-        ty::TyFloat(hir::TyF32) => output.push_str(\"f32\"),\n-        ty::TyFloat(hir::TyF64) => output.push_str(\"f64\"),\n+        ty::TyInt(ast::TyIs)    => output.push_str(\"isize\"),\n+        ty::TyInt(ast::TyI8)    => output.push_str(\"i8\"),\n+        ty::TyInt(ast::TyI16)   => output.push_str(\"i16\"),\n+        ty::TyInt(ast::TyI32)   => output.push_str(\"i32\"),\n+        ty::TyInt(ast::TyI64)   => output.push_str(\"i64\"),\n+        ty::TyUint(ast::TyUs)   => output.push_str(\"usize\"),\n+        ty::TyUint(ast::TyU8)   => output.push_str(\"u8\"),\n+        ty::TyUint(ast::TyU16)  => output.push_str(\"u16\"),\n+        ty::TyUint(ast::TyU32)  => output.push_str(\"u32\"),\n+        ty::TyUint(ast::TyU64)  => output.push_str(\"u64\"),\n+        ty::TyFloat(ast::TyF32) => output.push_str(\"f32\"),\n+        ty::TyFloat(ast::TyF64) => output.push_str(\"f64\"),\n         ty::TyStruct(def, substs) |\n         ty::TyEnum(def, substs) => {\n             push_item_name(cx, def.did, qualified, output);"}, {"sha": "09d014a33823eeb80efc7d4e721625373eac636d", "filename": "src/librustc_trans/trans/debuginfo/utils.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -21,8 +21,6 @@ use trans::machine;\n use trans::common::{CrateContext, FunctionContext};\n use trans::type_::Type;\n \n-use rustc_front::hir;\n-\n use syntax::codemap::Span;\n use syntax::{ast, codemap};\n \n@@ -46,11 +44,11 @@ pub fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n     };\n }\n \n-pub fn contains_nodebug_attribute(attributes: &[hir::Attribute]) -> bool {\n+pub fn contains_nodebug_attribute(attributes: &[ast::Attribute]) -> bool {\n     attributes.iter().any(|attr| {\n-        let meta_item: &hir::MetaItem = &*attr.node.value;\n+        let meta_item: &ast::MetaItem = &*attr.node.value;\n         match meta_item.node {\n-            hir::MetaWord(ref value) => &value[..] == \"no_debug\",\n+            ast::MetaWord(ref value) => &value[..] == \"no_debug\",\n             _ => false\n         }\n     })"}, {"sha": "55c833b7686d83dae869d7ead16c93412b6d50d1", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -83,7 +83,7 @@ use trans::type_::Type;\n use rustc_front;\n use rustc_front::hir;\n \n-use syntax::{ast, codemap};\n+use syntax::{ast, ast_util, codemap};\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n use syntax::parse::token;\n@@ -1140,7 +1140,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         hir::ExprLit(ref lit) => {\n             match lit.node {\n-                hir::LitStr(ref s, _) => {\n+                ast::LitStr(ref s, _) => {\n                     tvec::trans_lit_str(bcx, expr, (*s).clone(), dest)\n                 }\n                 _ => {\n@@ -1549,7 +1549,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n fn trans_immediate_lit<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    expr: &hir::Expr,\n-                                   lit: &hir::Lit)\n+                                   lit: &ast::Lit)\n                                    -> DatumBlock<'blk, 'tcx, Expr> {\n     // must not be a string constant, that is a RvalueDpsExpr\n     let _icx = push_ctxt(\"trans_immediate_lit\");\n@@ -2381,8 +2381,8 @@ impl OverflowOpViaIntrinsic {\n         bcx.ccx().get_intrinsic(&name)\n     }\n     fn to_intrinsic_name(&self, tcx: &ty::ctxt, ty: Ty) -> &'static str {\n-        use rustc_front::hir::IntTy::*;\n-        use rustc_front::hir::UintTy::*;\n+        use syntax::ast::IntTy::*;\n+        use syntax::ast::UintTy::*;\n         use middle::ty::{TyInt, TyUint};\n \n         let new_sty = match ty.sty {\n@@ -2714,7 +2714,7 @@ fn expr_kind(tcx: &ty::ctxt, expr: &hir::Expr) -> ExprKind {\n             ExprKind::RvalueDps\n         }\n \n-        hir::ExprLit(ref lit) if rustc_front::util::lit_is_str(&**lit) => {\n+        hir::ExprLit(ref lit) if ast_util::lit_is_str(&**lit) => {\n             ExprKind::RvalueDps\n         }\n "}, {"sha": "38b4cc630f8c76c4e2faf8343a54f73dfe1961d7", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -35,12 +35,12 @@ use std::cmp;\n use libc::c_uint;\n use syntax::abi::{Cdecl, Aapcs, C, Win64, Abi};\n use syntax::abi::{PlatformIntrinsic, RustIntrinsic, Rust, RustCall, Stdcall, Fastcall, System};\n+use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token::{InternedString, special_idents};\n use syntax::ast;\n \n use rustc_front::print::pprust;\n-use rustc_front::attr;\n use rustc_front::hir;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -188,7 +188,7 @@ pub fn get_extern_fn(ccx: &CrateContext,\n pub fn register_foreign_item_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                           abi: Abi, fty: Ty<'tcx>,\n                                           name: &str,\n-                                          attrs: &[hir::Attribute])-> ValueRef {\n+                                          attrs: &[ast::Attribute])-> ValueRef {\n     debug!(\"register_foreign_item_fn(abi={:?}, \\\n             ty={:?}, \\\n             name={})\",\n@@ -577,7 +577,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                 decl: &hir::FnDecl,\n                                                 body: &hir::Block,\n-                                                attrs: &[hir::Attribute],\n+                                                attrs: &[ast::Attribute],\n                                                 llwrapfn: ValueRef,\n                                                 param_substs: &'tcx Substs<'tcx>,\n                                                 id: ast::NodeId,\n@@ -600,7 +600,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                decl: &hir::FnDecl,\n                                body: &hir::Block,\n                                param_substs: &'tcx Substs<'tcx>,\n-                               attrs: &[hir::Attribute],\n+                               attrs: &[ast::Attribute],\n                                id: ast::NodeId,\n                                hash: Option<&str>)\n                                -> ValueRef"}, {"sha": "d6f59bf5ca8511ff92d4b505cb82db8c835a5f13", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -38,10 +38,10 @@ use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty::MethodCall;\n \n use syntax::ast;\n+use syntax::attr;\n use syntax::codemap::DUMMY_SP;\n use syntax::ptr::P;\n \n-use rustc_front::attr;\n use rustc_front::visit;\n use rustc_front::hir;\n \n@@ -773,7 +773,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n fn opaque_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>, method_ty: &ty::BareFnTy<'tcx>)\n                           -> &'tcx ty::BareFnTy<'tcx> {\n     let mut inputs = method_ty.sig.0.inputs.clone();\n-    inputs[0] = tcx.mk_mut_ptr(tcx.mk_mach_int(hir::TyI8));\n+    inputs[0] = tcx.mk_mut_ptr(tcx.mk_mach_int(ast::TyI8));\n \n     tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: method_ty.unsafety,"}, {"sha": "73784919c139125f456846bd1248278c04edc894", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -28,10 +28,10 @@ use middle::ty::{self, HasTypeFlags, Ty};\n use rustc::front::map as hir_map;\n \n use rustc_front::hir;\n-use rustc_front::attr;\n \n use syntax::abi;\n use syntax::ast;\n+use syntax::attr;\n use std::hash::{Hasher, Hash, SipHasher};\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -146,7 +146,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ccx.monomorphized().borrow_mut().insert(hash_id.take().unwrap(), lldecl);\n         lldecl\n     };\n-    let setup_lldecl = |lldecl, attrs: &[hir::Attribute]| {\n+    let setup_lldecl = |lldecl, attrs: &[ast::Attribute]| {\n         base::update_linkage(ccx, lldecl, None, base::OriginalTranslation);\n         attributes::from_fn_attrs(ccx, attrs, lldecl);\n "}, {"sha": "c7e1af5853d11a48ca3b34eef95bb3cb75d3b3a6", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -30,6 +30,7 @@ use middle::ty::{self, Ty};\n \n use rustc_front::hir;\n \n+use syntax::ast;\n use syntax::parse::token::InternedString;\n \n #[derive(Copy, Clone)]\n@@ -91,7 +92,7 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Handle the \"...\" case (returns a slice since strings are always unsized):\n     if let hir::ExprLit(ref lit) = content_expr.node {\n-        if let hir::LitStr(ref s, _) = lit.node {\n+        if let ast::LitStr(ref s, _) = lit.node {\n             let scratch = rvalue_scratch_datum(bcx, vec_ty, \"\");\n             bcx = trans_lit_str(bcx,\n                                 content_expr,\n@@ -172,7 +173,7 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match content_expr.node {\n         hir::ExprLit(ref lit) => {\n             match lit.node {\n-                hir::LitStr(ref s, _) => {\n+                ast::LitStr(ref s, _) => {\n                     match dest {\n                         Ignore => return bcx,\n                         SaveIn(lldest) => {\n@@ -268,7 +269,7 @@ fn elements_required(bcx: Block, content_expr: &hir::Expr) -> usize {\n     match content_expr.node {\n         hir::ExprLit(ref lit) => {\n             match lit.node {\n-                hir::LitStr(ref s, _) => s.len(),\n+                ast::LitStr(ref s, _) => s.len(),\n                 _ => {\n                     bcx.tcx().sess.span_bug(content_expr.span,\n                                             \"unexpected evec content\")"}, {"sha": "c635d1ba233fd99fd8b5757647ebf8d61033d142", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -17,7 +17,7 @@ use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n use trans::context::CrateContext;\n use util::nodemap::FnvHashMap;\n \n-use rustc_front::hir;\n+use syntax::ast;\n \n use std::ffi::CString;\n use std::mem;\n@@ -125,30 +125,30 @@ impl Type {\n         }\n     }\n \n-    pub fn int_from_ty(ccx: &CrateContext, t: hir::IntTy) -> Type {\n+    pub fn int_from_ty(ccx: &CrateContext, t: ast::IntTy) -> Type {\n         match t {\n-            hir::TyIs => ccx.int_type(),\n-            hir::TyI8 => Type::i8(ccx),\n-            hir::TyI16 => Type::i16(ccx),\n-            hir::TyI32 => Type::i32(ccx),\n-            hir::TyI64 => Type::i64(ccx)\n+            ast::TyIs => ccx.int_type(),\n+            ast::TyI8 => Type::i8(ccx),\n+            ast::TyI16 => Type::i16(ccx),\n+            ast::TyI32 => Type::i32(ccx),\n+            ast::TyI64 => Type::i64(ccx)\n         }\n     }\n \n-    pub fn uint_from_ty(ccx: &CrateContext, t: hir::UintTy) -> Type {\n+    pub fn uint_from_ty(ccx: &CrateContext, t: ast::UintTy) -> Type {\n         match t {\n-            hir::TyUs => ccx.int_type(),\n-            hir::TyU8 => Type::i8(ccx),\n-            hir::TyU16 => Type::i16(ccx),\n-            hir::TyU32 => Type::i32(ccx),\n-            hir::TyU64 => Type::i64(ccx)\n+            ast::TyUs => ccx.int_type(),\n+            ast::TyU8 => Type::i8(ccx),\n+            ast::TyU16 => Type::i16(ccx),\n+            ast::TyU32 => Type::i32(ccx),\n+            ast::TyU64 => Type::i64(ccx)\n         }\n     }\n \n-    pub fn float_from_ty(ccx: &CrateContext, t: hir::FloatTy) -> Type {\n+    pub fn float_from_ty(ccx: &CrateContext, t: ast::FloatTy) -> Type {\n         match t {\n-            hir::TyF32 => Type::f32(ccx),\n-            hir::TyF64 => Type::f64(ccx),\n+            ast::TyF32 => Type::f32(ccx),\n+            ast::TyF64 => Type::f64(ccx),\n         }\n     }\n "}, {"sha": "b7a232822fe172323c46b1e26dcf125a960444e6", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -21,7 +21,7 @@ use middle::ty::{self, RegionEscape, Ty};\n use trans::type_::Type;\n \n use syntax::abi;\n-use rustc_front::hir;\n+use syntax::ast;\n \n // LLVM doesn't like objects that are too big. Issue #17913\n fn ensure_array_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -379,7 +379,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n                   let unsized_part = cx.tcx().struct_tail(ty);\n                   let info_ty = match unsized_part.sty {\n                       ty::TyStr | ty::TyArray(..) | ty::TySlice(_) => {\n-                          Type::uint_from_ty(cx, hir::TyUs)\n+                          Type::uint_from_ty(cx, ast::TyUs)\n                       }\n                       ty::TyTrait(_) => Type::vtable_ptr(cx),\n                       _ => panic!(\"Unexpected type returned from \\"}, {"sha": "08cda74e3170dd3cf3e802ff106cb775e16a275e", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -56,7 +56,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             // They can denote both statically and dynamically sized byte arrays\n             let mut pat_ty = expr_ty;\n             if let hir::ExprLit(ref lt) = lt.node {\n-                if let hir::LitByteStr(_) = lt.node {\n+                if let ast::LitByteStr(_) = lt.node {\n                     let expected_ty = structurally_resolved_type(fcx, pat.span, expected);\n                     if let ty::TyRef(_, mt) = expected_ty.sty {\n                         if let ty::TySlice(_) = mt.ty.sty {"}, {"sha": "13e5e46ed27002fe4109908a6976a6a5a7af164d", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -49,7 +49,8 @@ use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty::cast::{CastKind, CastTy};\n use syntax::codemap::Span;\n use rustc_front::hir;\n-use rustc_front::hir::UintTy::TyU8;\n+use syntax::ast;\n+use syntax::ast::UintTy::TyU8;\n \n \n /// Reifies a cast check to be checked once we have full type information for\n@@ -245,7 +246,7 @@ impl<'tcx> CastCheck<'tcx> {\n             (_, Int(Bool)) => Err(CastError::CastToBool),\n \n             // * -> Char\n-            (Int(U(hir::TyU8)), Int(Char)) => Ok(CastKind::U8CharCast), // u8-char-cast\n+            (Int(U(ast::TyU8)), Int(Char)) => Ok(CastKind::U8CharCast), // u8-char-cast\n             (_, Int(Char)) => Err(CastError::CastToChar),\n \n             // prim -> float,ptr"}, {"sha": "d87940bfa1eb27a3d36d9bd7a183093a7c4c9eca", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -22,6 +22,7 @@ use {CrateCtxt, require_same_types};\n \n use std::collections::{HashMap};\n use syntax::abi;\n+use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n use syntax::parse::token;\n@@ -470,22 +471,22 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n         },\n         // (The width we pass to LLVM doesn't concern the type checker.)\n         Integer(signed, bits, _llvm_width) => match (signed, bits, &t.sty) {\n-            (true,  8,  &ty::TyInt(hir::IntTy::TyI8)) |\n-            (false, 8,  &ty::TyUint(hir::UintTy::TyU8)) |\n-            (true,  16, &ty::TyInt(hir::IntTy::TyI16)) |\n-            (false, 16, &ty::TyUint(hir::UintTy::TyU16)) |\n-            (true,  32, &ty::TyInt(hir::IntTy::TyI32)) |\n-            (false, 32, &ty::TyUint(hir::UintTy::TyU32)) |\n-            (true,  64, &ty::TyInt(hir::IntTy::TyI64)) |\n-            (false, 64, &ty::TyUint(hir::UintTy::TyU64)) => {},\n+            (true,  8,  &ty::TyInt(ast::IntTy::TyI8)) |\n+            (false, 8,  &ty::TyUint(ast::UintTy::TyU8)) |\n+            (true,  16, &ty::TyInt(ast::IntTy::TyI16)) |\n+            (false, 16, &ty::TyUint(ast::UintTy::TyU16)) |\n+            (true,  32, &ty::TyInt(ast::IntTy::TyI32)) |\n+            (false, 32, &ty::TyUint(ast::UintTy::TyU32)) |\n+            (true,  64, &ty::TyInt(ast::IntTy::TyI64)) |\n+            (false, 64, &ty::TyUint(ast::UintTy::TyU64)) => {},\n             _ => simple_error(&format!(\"`{}`\", t),\n                               &format!(\"`{}{n}`\",\n                                        if signed {\"i\"} else {\"u\"},\n                                        n = bits)),\n         },\n         Float(bits) => match (bits, &t.sty) {\n-            (32, &ty::TyFloat(hir::FloatTy::TyF32)) |\n-            (64, &ty::TyFloat(hir::FloatTy::TyF64)) => {},\n+            (32, &ty::TyFloat(ast::FloatTy::TyF32)) |\n+            (64, &ty::TyFloat(ast::FloatTy::TyF64)) => {},\n             _ => simple_error(&format!(\"`{}`\", t),\n                               &format!(\"`f{n}`\", n = bits)),\n         },"}, {"sha": "c63b081c73c4872cb7afafb0eb0a6635f926083a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -319,51 +319,51 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 let lang_def_id = self.tcx().lang_items.mut_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyInt(hir::TyI8) => {\n+            ty::TyInt(ast::TyI8) => {\n                 let lang_def_id = self.tcx().lang_items.i8_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyInt(hir::TyI16) => {\n+            ty::TyInt(ast::TyI16) => {\n                 let lang_def_id = self.tcx().lang_items.i16_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyInt(hir::TyI32) => {\n+            ty::TyInt(ast::TyI32) => {\n                 let lang_def_id = self.tcx().lang_items.i32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyInt(hir::TyI64) => {\n+            ty::TyInt(ast::TyI64) => {\n                 let lang_def_id = self.tcx().lang_items.i64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyInt(hir::TyIs) => {\n+            ty::TyInt(ast::TyIs) => {\n                 let lang_def_id = self.tcx().lang_items.isize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyUint(hir::TyU8) => {\n+            ty::TyUint(ast::TyU8) => {\n                 let lang_def_id = self.tcx().lang_items.u8_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyUint(hir::TyU16) => {\n+            ty::TyUint(ast::TyU16) => {\n                 let lang_def_id = self.tcx().lang_items.u16_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyUint(hir::TyU32) => {\n+            ty::TyUint(ast::TyU32) => {\n                 let lang_def_id = self.tcx().lang_items.u32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyUint(hir::TyU64) => {\n+            ty::TyUint(ast::TyU64) => {\n                 let lang_def_id = self.tcx().lang_items.u64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyUint(hir::TyUs) => {\n+            ty::TyUint(ast::TyUs) => {\n                 let lang_def_id = self.tcx().lang_items.usize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyFloat(hir::TyF32) => {\n+            ty::TyFloat(ast::TyF32) => {\n                 let lang_def_id = self.tcx().lang_items.f32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyFloat(hir::TyF64) => {\n+            ty::TyFloat(ast::TyF64) => {\n                 let lang_def_id = self.tcx().lang_items.f64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }"}, {"sha": "51eee67df96ec767a8fadb16810978dab0db4eb6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -117,6 +117,8 @@ use std::mem::replace;\n use std::slice;\n use syntax::abi;\n use syntax::ast;\n+use syntax::attr;\n+use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{self, Span};\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::{self, InternedString};\n@@ -125,8 +127,6 @@ use syntax::ptr::P;\n use rustc_front::visit::{self, Visitor};\n use rustc_front::hir;\n use rustc_front::hir::Visibility;\n-use rustc_front::attr;\n-use rustc_front::attr::AttrMetaMethods;\n use rustc_front::hir::{Item, ItemImpl};\n use rustc_front::print::pprust;\n \n@@ -2309,7 +2309,7 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // First, try built-in indexing.\n     match (adjusted_ty.builtin_index(), &index_ty.sty) {\n-        (Some(ty), &ty::TyUint(hir::TyUs)) | (Some(ty), &ty::TyInfer(ty::IntVar(_))) => {\n+        (Some(ty), &ty::TyUint(ast::TyUs)) | (Some(ty), &ty::TyInfer(ty::IntVar(_))) => {\n             debug!(\"try_index_step: success, using built-in indexing\");\n             // If we had `[T; N]`, we should've caught it before unsizing to `[T]`.\n             assert!(!unsize);\n@@ -2573,21 +2573,21 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             let arg_ty = structurally_resolved_type(fcx, arg.span,\n                                                     fcx.expr_ty(&**arg));\n             match arg_ty.sty {\n-                ty::TyFloat(hir::TyF32) => {\n+                ty::TyFloat(ast::TyF32) => {\n                     fcx.type_error_message(arg.span,\n                                            |t| {\n                         format!(\"can't pass an {} to variadic \\\n                                  function, cast to c_double\", t)\n                     }, arg_ty, None);\n                 }\n-                ty::TyInt(hir::TyI8) | ty::TyInt(hir::TyI16) | ty::TyBool => {\n+                ty::TyInt(ast::TyI8) | ty::TyInt(ast::TyI16) | ty::TyBool => {\n                     fcx.type_error_message(arg.span, |t| {\n                         format!(\"can't pass {} to variadic \\\n                                  function, cast to c_int\",\n                                        t)\n                     }, arg_ty, None);\n                 }\n-                ty::TyUint(hir::TyU8) | ty::TyUint(hir::TyU16) => {\n+                ty::TyUint(ast::TyU8) | ty::TyUint(ast::TyU16) => {\n                     fcx.type_error_message(arg.span, |t| {\n                         format!(\"can't pass {} to variadic \\\n                                  function, cast to c_uint\",\n@@ -2616,23 +2616,23 @@ fn write_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n // AST fragment checking\n fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                       lit: &hir::Lit,\n+                       lit: &ast::Lit,\n                        expected: Expectation<'tcx>)\n                        -> Ty<'tcx>\n {\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n-        hir::LitStr(..) => tcx.mk_static_str(),\n-        hir::LitByteStr(ref v) => {\n+        ast::LitStr(..) => tcx.mk_static_str(),\n+        ast::LitByteStr(ref v) => {\n             tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic),\n                             tcx.mk_array(tcx.types.u8, v.len()))\n         }\n-        hir::LitByte(_) => tcx.types.u8,\n-        hir::LitChar(_) => tcx.types.char,\n-        hir::LitInt(_, hir::SignedIntLit(t, _)) => tcx.mk_mach_int(t),\n-        hir::LitInt(_, hir::UnsignedIntLit(t)) => tcx.mk_mach_uint(t),\n-        hir::LitInt(_, hir::UnsuffixedIntLit(_)) => {\n+        ast::LitByte(_) => tcx.types.u8,\n+        ast::LitChar(_) => tcx.types.char,\n+        ast::LitInt(_, ast::SignedIntLit(t, _)) => tcx.mk_mach_int(t),\n+        ast::LitInt(_, ast::UnsignedIntLit(t)) => tcx.mk_mach_uint(t),\n+        ast::LitInt(_, ast::UnsuffixedIntLit(_)) => {\n             let opt_ty = expected.to_option(fcx).and_then(|ty| {\n                 match ty.sty {\n                     ty::TyInt(_) | ty::TyUint(_) => Some(ty),\n@@ -2645,8 +2645,8 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             opt_ty.unwrap_or_else(\n                 || tcx.mk_int_var(fcx.infcx().next_int_var_id()))\n         }\n-        hir::LitFloat(_, t) => tcx.mk_mach_float(t),\n-        hir::LitFloatUnsuffixed(_) => {\n+        ast::LitFloat(_, t) => tcx.mk_mach_float(t),\n+        ast::LitFloatUnsuffixed(_) => {\n             let opt_ty = expected.to_option(fcx).and_then(|ty| {\n                 match ty.sty {\n                     ty::TyFloat(_) => Some(ty),\n@@ -2656,7 +2656,7 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             opt_ty.unwrap_or_else(\n                 || tcx.mk_float_var(fcx.infcx().next_float_var_id()))\n         }\n-        hir::LitBool(_) => tcx.types.bool\n+        ast::LitBool(_) => tcx.types.bool\n     }\n }\n \n@@ -4219,22 +4219,22 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     fn disr_in_range(ccx: &CrateCtxt,\n                      ty: attr::IntType,\n                      disr: ty::Disr) -> bool {\n-        fn uint_in_range(ccx: &CrateCtxt, ty: hir::UintTy, disr: ty::Disr) -> bool {\n+        fn uint_in_range(ccx: &CrateCtxt, ty: ast::UintTy, disr: ty::Disr) -> bool {\n             match ty {\n-                hir::TyU8 => disr as u8 as Disr == disr,\n-                hir::TyU16 => disr as u16 as Disr == disr,\n-                hir::TyU32 => disr as u32 as Disr == disr,\n-                hir::TyU64 => disr as u64 as Disr == disr,\n-                hir::TyUs => uint_in_range(ccx, ccx.tcx.sess.target.uint_type, disr)\n+                ast::TyU8 => disr as u8 as Disr == disr,\n+                ast::TyU16 => disr as u16 as Disr == disr,\n+                ast::TyU32 => disr as u32 as Disr == disr,\n+                ast::TyU64 => disr as u64 as Disr == disr,\n+                ast::TyUs => uint_in_range(ccx, ccx.tcx.sess.target.uint_type, disr)\n             }\n         }\n-        fn int_in_range(ccx: &CrateCtxt, ty: hir::IntTy, disr: ty::Disr) -> bool {\n+        fn int_in_range(ccx: &CrateCtxt, ty: ast::IntTy, disr: ty::Disr) -> bool {\n             match ty {\n-                hir::TyI8 => disr as i8 as Disr == disr,\n-                hir::TyI16 => disr as i16 as Disr == disr,\n-                hir::TyI32 => disr as i32 as Disr == disr,\n-                hir::TyI64 => disr as i64 as Disr == disr,\n-                hir::TyIs => int_in_range(ccx, ccx.tcx.sess.target.int_type, disr)\n+                ast::TyI8 => disr as i8 as Disr == disr,\n+                ast::TyI16 => disr as i16 as Disr == disr,\n+                ast::TyI32 => disr as i32 as Disr == disr,\n+                ast::TyI64 => disr as i64 as Disr == disr,\n+                ast::TyIs => int_in_range(ccx, ccx.tcx.sess.target.int_type, disr)\n             }\n         }\n         match ty {"}, {"sha": "43ae33ac596a0450bafafa7e0137e684a3e6c739", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -14,6 +14,7 @@\n use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::traits;\n use middle::ty;\n+use syntax::ast;\n use syntax::codemap::Span;\n use rustc_front::visit;\n use rustc_front::hir;\n@@ -119,84 +120,84 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                                                   \"*mut T\",\n                                                   item.span);\n                     }\n-                    ty::TyInt(hir::TyI8) => {\n+                    ty::TyInt(ast::TyI8) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.i8_impl(),\n                                                   \"i8\",\n                                                   \"i8\",\n                                                   item.span);\n                     }\n-                    ty::TyInt(hir::TyI16) => {\n+                    ty::TyInt(ast::TyI16) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.i16_impl(),\n                                                   \"i16\",\n                                                   \"i16\",\n                                                   item.span);\n                     }\n-                    ty::TyInt(hir::TyI32) => {\n+                    ty::TyInt(ast::TyI32) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.i32_impl(),\n                                                   \"i32\",\n                                                   \"i32\",\n                                                   item.span);\n                     }\n-                    ty::TyInt(hir::TyI64) => {\n+                    ty::TyInt(ast::TyI64) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.i64_impl(),\n                                                   \"i64\",\n                                                   \"i64\",\n                                                   item.span);\n                     }\n-                    ty::TyInt(hir::TyIs) => {\n+                    ty::TyInt(ast::TyIs) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.isize_impl(),\n                                                   \"isize\",\n                                                   \"isize\",\n                                                   item.span);\n                     }\n-                    ty::TyUint(hir::TyU8) => {\n+                    ty::TyUint(ast::TyU8) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.u8_impl(),\n                                                   \"u8\",\n                                                   \"u8\",\n                                                   item.span);\n                     }\n-                    ty::TyUint(hir::TyU16) => {\n+                    ty::TyUint(ast::TyU16) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.u16_impl(),\n                                                   \"u16\",\n                                                   \"u16\",\n                                                   item.span);\n                     }\n-                    ty::TyUint(hir::TyU32) => {\n+                    ty::TyUint(ast::TyU32) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.u32_impl(),\n                                                   \"u32\",\n                                                   \"u32\",\n                                                   item.span);\n                     }\n-                    ty::TyUint(hir::TyU64) => {\n+                    ty::TyUint(ast::TyU64) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.u64_impl(),\n                                                   \"u64\",\n                                                   \"u64\",\n                                                   item.span);\n                     }\n-                    ty::TyUint(hir::TyUs) => {\n+                    ty::TyUint(ast::TyUs) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.usize_impl(),\n                                                   \"usize\",\n                                                   \"usize\",\n                                                   item.span);\n                     }\n-                    ty::TyFloat(hir::TyF32) => {\n+                    ty::TyFloat(ast::TyF32) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.f32_impl(),\n                                                   \"f32\",\n                                                   \"f32\",\n                                                   item.span);\n                     }\n-                    ty::TyFloat(hir::TyF64) => {\n+                    ty::TyFloat(ast::TyF64) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.f64_impl(),\n                                                   \"f64\","}, {"sha": "f00e5465e47742a78bd8d37876b514aec5cb728e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -93,12 +93,12 @@ use std::rc::Rc;\n \n use syntax::abi;\n use syntax::ast;\n+use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n use syntax::ptr::P;\n use rustc_front::hir;\n use rustc_front::visit;\n-use rustc_front::attr;\n use rustc_front::print::pprust;\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "930bc831028f03df0a4ecef999916b2d289bbe81", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -13,7 +13,7 @@\n use std::collections::HashSet;\n \n use syntax::ast;\n-use rustc_front::attr::AttrMetaMethods;\n+use syntax::attr::AttrMetaMethods;\n use rustc_front::hir;\n \n use rustc::metadata::csearch;"}, {"sha": "8737957c0656144bb5d47aa97f711d3f79644ecc", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 43, "deletions": 45, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -27,6 +27,8 @@ pub use self::FunctionRetTy::*;\n use syntax;\n use syntax::abi;\n use syntax::ast;\n+use syntax::attr;\n+use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use syntax::codemap;\n use syntax::codemap::{DUMMY_SP, Pos, Spanned};\n use syntax::parse::token::{self, InternedString, special_idents};\n@@ -43,9 +45,6 @@ use rustc::middle::ty;\n use rustc::middle::stability;\n \n use rustc_front::hir;\n-use rustc_front::attr;\n-use rustc_front::attr::{AttributeMethods, AttrMetaMethods};\n-use rustc_front::lowering::unlower_attribute;\n \n use std::collections::HashMap;\n use std::path::PathBuf;\n@@ -143,8 +142,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n \n         // Figure out the name of this crate\n         let input = &cx.input;\n-        let attrs: Vec<_> = self.attrs.iter().map(|a| unlower_attribute(a)).collect();\n-        let name = link::find_crate_name(None, &attrs, input);\n+        let name = link::find_crate_name(None, &self.attrs, input);\n \n         // Clean the crate, translating the entire libsyntax AST to one that is\n         // understood by rustdoc.\n@@ -437,21 +435,21 @@ pub enum Attribute {\n     NameValue(String, String)\n }\n \n-impl Clean<Attribute> for hir::MetaItem {\n+impl Clean<Attribute> for ast::MetaItem {\n     fn clean(&self, cx: &DocContext) -> Attribute {\n         match self.node {\n-            hir::MetaWord(ref s) => Word(s.to_string()),\n-            hir::MetaList(ref s, ref l) => {\n+            ast::MetaWord(ref s) => Word(s.to_string()),\n+            ast::MetaList(ref s, ref l) => {\n                 List(s.to_string(), l.clean(cx))\n             }\n-            hir::MetaNameValue(ref s, ref v) => {\n+            ast::MetaNameValue(ref s, ref v) => {\n                 NameValue(s.to_string(), lit_to_string(v))\n             }\n         }\n     }\n }\n \n-impl Clean<Attribute> for hir::Attribute {\n+impl Clean<Attribute> for ast::Attribute {\n     fn clean(&self, cx: &DocContext) -> Attribute {\n         self.with_desugared_doc(|a| a.node.value.clean(cx))\n     }\n@@ -475,13 +473,13 @@ impl attr::AttrMetaMethods for Attribute {\n             _ => None,\n         }\n     }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<hir::MetaItem>]> { None }\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<ast::MetaItem>]> { None }\n     fn span(&self) -> codemap::Span { unimplemented!() }\n }\n impl<'a> attr::AttrMetaMethods for &'a Attribute {\n     fn name(&self) -> InternedString { (**self).name() }\n     fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n-    fn meta_item_list(&self) -> Option<&[P<hir::MetaItem>]> { None }\n+    fn meta_item_list(&self) -> Option<&[P<ast::MetaItem>]> { None }\n     fn span(&self) -> codemap::Span { unimplemented!() }\n }\n \n@@ -1626,18 +1624,18 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n         match self.sty {\n             ty::TyBool => Primitive(Bool),\n             ty::TyChar => Primitive(Char),\n-            ty::TyInt(hir::TyIs) => Primitive(Isize),\n-            ty::TyInt(hir::TyI8) => Primitive(I8),\n-            ty::TyInt(hir::TyI16) => Primitive(I16),\n-            ty::TyInt(hir::TyI32) => Primitive(I32),\n-            ty::TyInt(hir::TyI64) => Primitive(I64),\n-            ty::TyUint(hir::TyUs) => Primitive(Usize),\n-            ty::TyUint(hir::TyU8) => Primitive(U8),\n-            ty::TyUint(hir::TyU16) => Primitive(U16),\n-            ty::TyUint(hir::TyU32) => Primitive(U32),\n-            ty::TyUint(hir::TyU64) => Primitive(U64),\n-            ty::TyFloat(hir::TyF32) => Primitive(F32),\n-            ty::TyFloat(hir::TyF64) => Primitive(F64),\n+            ty::TyInt(ast::TyIs) => Primitive(Isize),\n+            ty::TyInt(ast::TyI8) => Primitive(I8),\n+            ty::TyInt(ast::TyI16) => Primitive(I16),\n+            ty::TyInt(ast::TyI32) => Primitive(I32),\n+            ty::TyInt(ast::TyI64) => Primitive(I64),\n+            ty::TyUint(ast::TyUs) => Primitive(Usize),\n+            ty::TyUint(ast::TyU8) => Primitive(U8),\n+            ty::TyUint(ast::TyU16) => Primitive(U16),\n+            ty::TyUint(ast::TyU32) => Primitive(U32),\n+            ty::TyUint(ast::TyU64) => Primitive(U64),\n+            ty::TyFloat(ast::TyF32) => Primitive(F32),\n+            ty::TyFloat(ast::TyF64) => Primitive(F64),\n             ty::TyStr => Primitive(Str),\n             ty::TyBox(t) => {\n                 let box_did = cx.tcx_opt().and_then(|tcx| {\n@@ -2515,23 +2513,23 @@ impl ToSource for syntax::codemap::Span {\n     }\n }\n \n-fn lit_to_string(lit: &hir::Lit) -> String {\n+fn lit_to_string(lit: &ast::Lit) -> String {\n     match lit.node {\n-        hir::LitStr(ref st, _) => st.to_string(),\n-        hir::LitByteStr(ref data) => format!(\"{:?}\", data),\n-        hir::LitByte(b) => {\n+        ast::LitStr(ref st, _) => st.to_string(),\n+        ast::LitByteStr(ref data) => format!(\"{:?}\", data),\n+        ast::LitByte(b) => {\n             let mut res = String::from(\"b'\");\n             for c in (b as char).escape_default() {\n                 res.push(c);\n             }\n             res.push('\\'');\n             res\n         },\n-        hir::LitChar(c) => format!(\"'{}'\", c),\n-        hir::LitInt(i, _t) => i.to_string(),\n-        hir::LitFloat(ref f, _t) => f.to_string(),\n-        hir::LitFloatUnsuffixed(ref f) => f.to_string(),\n-        hir::LitBool(b) => b.to_string(),\n+        ast::LitChar(c) => format!(\"'{}'\", c),\n+        ast::LitInt(i, _t) => i.to_string(),\n+        ast::LitFloat(ref f, _t) => f.to_string(),\n+        ast::LitFloatUnsuffixed(ref f) => f.to_string(),\n+        ast::LitBool(b) => b.to_string(),\n     }\n }\n \n@@ -2594,18 +2592,18 @@ fn resolve_type(cx: &DocContext,\n             hir::TyStr => return Primitive(Str),\n             hir::TyBool => return Primitive(Bool),\n             hir::TyChar => return Primitive(Char),\n-            hir::TyInt(hir::TyIs) => return Primitive(Isize),\n-            hir::TyInt(hir::TyI8) => return Primitive(I8),\n-            hir::TyInt(hir::TyI16) => return Primitive(I16),\n-            hir::TyInt(hir::TyI32) => return Primitive(I32),\n-            hir::TyInt(hir::TyI64) => return Primitive(I64),\n-            hir::TyUint(hir::TyUs) => return Primitive(Usize),\n-            hir::TyUint(hir::TyU8) => return Primitive(U8),\n-            hir::TyUint(hir::TyU16) => return Primitive(U16),\n-            hir::TyUint(hir::TyU32) => return Primitive(U32),\n-            hir::TyUint(hir::TyU64) => return Primitive(U64),\n-            hir::TyFloat(hir::TyF32) => return Primitive(F32),\n-            hir::TyFloat(hir::TyF64) => return Primitive(F64),\n+            hir::TyInt(ast::TyIs) => return Primitive(Isize),\n+            hir::TyInt(ast::TyI8) => return Primitive(I8),\n+            hir::TyInt(ast::TyI16) => return Primitive(I16),\n+            hir::TyInt(ast::TyI32) => return Primitive(I32),\n+            hir::TyInt(ast::TyI64) => return Primitive(I64),\n+            hir::TyUint(ast::TyUs) => return Primitive(Usize),\n+            hir::TyUint(ast::TyU8) => return Primitive(U8),\n+            hir::TyUint(ast::TyU16) => return Primitive(U16),\n+            hir::TyUint(ast::TyU32) => return Primitive(U32),\n+            hir::TyUint(ast::TyU64) => return Primitive(U64),\n+            hir::TyFloat(ast::TyF32) => return Primitive(F32),\n+            hir::TyFloat(ast::TyF64) => return Primitive(F64),\n         },\n         def::DefSelfTy(..) if path.segments.len() == 1 => {\n             return Generic(special_idents::type_self.name.to_string());"}, {"sha": "1a027a3d146360b04054b620cc5a0ab01e0acaf8", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -18,13 +18,13 @@ use syntax::codemap::Span;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast::{Ident, NodeId};\n+use syntax::attr;\n use syntax::ptr::P;\n use rustc_front::hir;\n-use rustc_front::attr;\n \n pub struct Module {\n     pub name: Option<Ident>,\n-    pub attrs: Vec<hir::Attribute>,\n+    pub attrs: Vec<ast::Attribute>,\n     pub where_outer: Span,\n     pub where_inner: Span,\n     pub extern_crates: Vec<ExternCrate>,\n@@ -100,7 +100,7 @@ pub struct Struct {\n     pub struct_type: StructType,\n     pub name: Ident,\n     pub generics: hir::Generics,\n-    pub attrs: Vec<hir::Attribute>,\n+    pub attrs: Vec<ast::Attribute>,\n     pub fields: Vec<hir::StructField>,\n     pub whence: Span,\n }\n@@ -110,15 +110,15 @@ pub struct Enum {\n     pub stab: Option<attr::Stability>,\n     pub variants: Vec<Variant>,\n     pub generics: hir::Generics,\n-    pub attrs: Vec<hir::Attribute>,\n+    pub attrs: Vec<ast::Attribute>,\n     pub id: NodeId,\n     pub whence: Span,\n     pub name: Ident,\n }\n \n pub struct Variant {\n     pub name: Ident,\n-    pub attrs: Vec<hir::Attribute>,\n+    pub attrs: Vec<ast::Attribute>,\n     pub kind: hir::VariantKind,\n     pub id: ast::NodeId,\n     pub vis: hir::Visibility,\n@@ -128,7 +128,7 @@ pub struct Variant {\n \n pub struct Function {\n     pub decl: hir::FnDecl,\n-    pub attrs: Vec<hir::Attribute>,\n+    pub attrs: Vec<ast::Attribute>,\n     pub id: NodeId,\n     pub name: Ident,\n     pub vis: hir::Visibility,\n@@ -145,7 +145,7 @@ pub struct Typedef {\n     pub gen: hir::Generics,\n     pub name: Ident,\n     pub id: ast::NodeId,\n-    pub attrs: Vec<hir::Attribute>,\n+    pub attrs: Vec<ast::Attribute>,\n     pub whence: Span,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n@@ -157,7 +157,7 @@ pub struct Static {\n     pub mutability: hir::Mutability,\n     pub expr: P<hir::Expr>,\n     pub name: Ident,\n-    pub attrs: Vec<hir::Attribute>,\n+    pub attrs: Vec<ast::Attribute>,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub id: ast::NodeId,\n@@ -168,7 +168,7 @@ pub struct Constant {\n     pub type_: P<hir::Ty>,\n     pub expr: P<hir::Expr>,\n     pub name: Ident,\n-    pub attrs: Vec<hir::Attribute>,\n+    pub attrs: Vec<ast::Attribute>,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub id: ast::NodeId,\n@@ -181,7 +181,7 @@ pub struct Trait {\n     pub items: Vec<P<hir::TraitItem>>, //should be TraitItem\n     pub generics: hir::Generics,\n     pub bounds: Vec<hir::TyParamBound>,\n-    pub attrs: Vec<hir::Attribute>,\n+    pub attrs: Vec<ast::Attribute>,\n     pub id: ast::NodeId,\n     pub whence: Span,\n     pub vis: hir::Visibility,\n@@ -195,7 +195,7 @@ pub struct Impl {\n     pub trait_: Option<hir::TraitRef>,\n     pub for_: P<hir::Ty>,\n     pub items: Vec<P<hir::ImplItem>>,\n-    pub attrs: Vec<hir::Attribute>,\n+    pub attrs: Vec<ast::Attribute>,\n     pub whence: Span,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n@@ -206,14 +206,14 @@ pub struct DefaultImpl {\n     pub unsafety: hir::Unsafety,\n     pub trait_: hir::TraitRef,\n     pub id: ast::NodeId,\n-    pub attrs: Vec<hir::Attribute>,\n+    pub attrs: Vec<ast::Attribute>,\n     pub whence: Span,\n }\n \n pub struct Macro {\n     pub name: Ident,\n     pub id: ast::NodeId,\n-    pub attrs: Vec<hir::Attribute>,\n+    pub attrs: Vec<ast::Attribute>,\n     pub whence: Span,\n     pub stab: Option<attr::Stability>,\n     pub imported_from: Option<Ident>,\n@@ -223,14 +223,14 @@ pub struct ExternCrate {\n     pub name: Ident,\n     pub path: Option<String>,\n     pub vis: hir::Visibility,\n-    pub attrs: Vec<hir::Attribute>,\n+    pub attrs: Vec<ast::Attribute>,\n     pub whence: Span,\n }\n \n pub struct Import {\n     pub id: NodeId,\n     pub vis: hir::Visibility,\n-    pub attrs: Vec<hir::Attribute>,\n+    pub attrs: Vec<ast::Attribute>,\n     pub node: hir::ViewPath_,\n     pub whence: Span,\n }"}, {"sha": "b34f1a01a2b0eaf04827ae9645b2ba25c168e6ab", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -52,10 +52,10 @@ use std::sync::Arc;\n use externalfiles::ExternalHtml;\n \n use serialize::json::{self, ToJson};\n-use syntax::{abi, ast};\n+use syntax::{abi, ast, attr};\n use rustc::middle::def_id::{DefId, LOCAL_CRATE};\n use rustc::util::nodemap::NodeSet;\n-use rustc_front::{hir, attr};\n+use rustc_front::hir;\n \n use clean::{self, SelfTy};\n use doctree;"}, {"sha": "2f47353fee7b299dca31520fb1afffdbdde54ca3", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -124,8 +124,8 @@ pub fn run(input: &str,\n \n // Look for #![doc(test(no_crate_inject))], used by crates in the std facade\n fn scrape_test_config(krate: &::rustc_front::hir::Crate) -> TestOptions {\n-    use rustc_front::attr::AttrMetaMethods;\n-    use rustc_front::print::pprust;\n+    use syntax::attr::AttrMetaMethods;\n+    use syntax::print::pprust;\n \n     let mut opts = TestOptions {\n         no_crate_inject: false,"}, {"sha": "e3fb13d13906d3b8a06d42a47e425bd850b13e05", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -16,14 +16,14 @@ use std::mem;\n \n use syntax::abi;\n use syntax::ast;\n+use syntax::attr;\n+use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n \n use rustc::front::map as hir_map;\n use rustc::middle::def_id::DefId;\n use rustc::middle::stability;\n \n-use rustc_front::attr;\n-use rustc_front::attr::AttrMetaMethods;\n use rustc_front::hir;\n \n use core;\n@@ -39,7 +39,7 @@ use doctree::*;\n \n pub struct RustdocVisitor<'a, 'tcx: 'a> {\n     pub module: Module,\n-    pub attrs: Vec<hir::Attribute>,\n+    pub attrs: Vec<ast::Attribute>,\n     pub cx: &'a core::DocContext<'a, 'tcx>,\n     pub analysis: Option<&'a core::CrateAnalysis>,\n     view_item_stack: HashSet<ast::NodeId>,\n@@ -146,7 +146,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         }\n     }\n \n-    pub fn visit_mod_contents(&mut self, span: Span, attrs: Vec<hir::Attribute> ,\n+    pub fn visit_mod_contents(&mut self, span: Span, attrs: Vec<ast::Attribute> ,\n                               vis: hir::Visibility, id: ast::NodeId,\n                               m: &hir::Mod,\n                               name: Option<ast::Ident>) -> Module {"}, {"sha": "b00ff85051c9a5b4407dbf3ca47702647a00f33c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 350, "deletions": 310, "changes": 660, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -54,8 +54,8 @@ impl PpAnn for NoAnn {}\n \n #[derive(Copy, Clone)]\n pub struct CurrentCommentAndLiteral {\n-    cur_cmnt: usize,\n-    cur_lit: usize,\n+    pub cur_cmnt: usize,\n+    pub cur_lit: usize,\n }\n \n pub struct State<'a> {\n@@ -450,43 +450,369 @@ fn needs_parentheses(expr: &ast::Expr) -> bool {\n     }\n }\n \n-impl<'a> State<'a> {\n-    pub fn ibox(&mut self, u: usize) -> io::Result<()> {\n-        self.boxes.push(pp::Breaks::Inconsistent);\n-        pp::ibox(&mut self.s, u)\n+pub trait PrintState<'a> {\n+    fn writer(&mut self) -> &mut pp::Printer<'a>;\n+    fn boxes(&mut self) -> &mut Vec<pp::Breaks>;\n+    fn comments(&mut self) -> &mut Option<Vec<comments::Comment>>;\n+    fn cur_cmnt_and_lit(&mut self) -> &mut CurrentCommentAndLiteral;\n+    fn literals(&self) -> &Option<Vec<comments::Literal>>;\n+\n+    fn word_space(&mut self, w: &str) -> io::Result<()> {\n+        try!(word(self.writer(), w));\n+        space(self.writer())\n     }\n \n-    pub fn end(&mut self) -> io::Result<()> {\n-        self.boxes.pop().unwrap();\n-        pp::end(&mut self.s)\n+    fn popen(&mut self) -> io::Result<()> { word(self.writer(), \"(\") }\n+\n+    fn pclose(&mut self) -> io::Result<()> { word(self.writer(), \")\") }\n+\n+    fn is_begin(&mut self) -> bool {\n+        match self.writer().last_token() {\n+            pp::Token::Begin(_) => true,\n+            _ => false,\n+        }\n     }\n \n-    pub fn cbox(&mut self, u: usize) -> io::Result<()> {\n-        self.boxes.push(pp::Breaks::Consistent);\n-        pp::cbox(&mut self.s, u)\n+    fn is_end(&mut self) -> bool {\n+        match self.writer().last_token() {\n+            pp::Token::End => true,\n+            _ => false,\n+        }\n+    }\n+\n+    // is this the beginning of a line?\n+    fn is_bol(&mut self) -> bool {\n+        self.writer().last_token().is_eof() || self.writer().last_token().is_hardbreak_tok()\n+    }\n+\n+    fn hardbreak_if_not_bol(&mut self) -> io::Result<()> {\n+        if !self.is_bol() {\n+            try!(hardbreak(self.writer()))\n+        }\n+        Ok(())\n     }\n \n     // \"raw box\"\n-    pub fn rbox(&mut self, u: usize, b: pp::Breaks) -> io::Result<()> {\n-        self.boxes.push(b);\n-        pp::rbox(&mut self.s, u, b)\n+    fn rbox(&mut self, u: usize, b: pp::Breaks) -> io::Result<()> {\n+        self.boxes().push(b);\n+        pp::rbox(self.writer(), u, b)\n     }\n \n-    pub fn nbsp(&mut self) -> io::Result<()> { word(&mut self.s, \" \") }\n+    fn ibox(&mut self, u: usize) -> io::Result<()> {\n+        self.boxes().push(pp::Breaks::Inconsistent);\n+        pp::ibox(self.writer(), u)\n+    }\n \n-    pub fn word_nbsp(&mut self, w: &str) -> io::Result<()> {\n-        try!(word(&mut self.s, w));\n-        self.nbsp()\n+    fn end(&mut self) -> io::Result<()> {\n+        self.boxes().pop().unwrap();\n+        pp::end(self.writer())\n     }\n \n-    pub fn word_space(&mut self, w: &str) -> io::Result<()> {\n-        try!(word(&mut self.s, w));\n-        space(&mut self.s)\n+    fn commasep<T, F>(&mut self, b: Breaks, elts: &[T], mut op: F) -> io::Result<()>\n+        where F: FnMut(&mut Self, &T) -> io::Result<()>,\n+    {\n+        try!(self.rbox(0, b));\n+        let mut first = true;\n+        for elt in elts {\n+            if first { first = false; } else { try!(self.word_space(\",\")); }\n+            try!(op(self, elt));\n+        }\n+        self.end()\n+    }\n+\n+\n+    fn next_lit(&mut self, pos: BytePos) -> Option<comments::Literal> {\n+        let mut cur_lit = self.cur_cmnt_and_lit().cur_lit;\n+\n+        let mut result = None;\n+\n+        if let &Some(ref lits) = self.literals()\n+        {\n+            while cur_lit < lits.len() {\n+                let ltrl = (*lits)[cur_lit].clone();\n+                if ltrl.pos > pos { break; }\n+                cur_lit += 1;\n+                if ltrl.pos == pos {\n+                    result = Some(ltrl);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        self.cur_cmnt_and_lit().cur_lit = cur_lit;\n+        result\n+    }\n+\n+    fn maybe_print_comment(&mut self, pos: BytePos) -> io::Result<()> {\n+        loop {\n+            match self.next_comment() {\n+                Some(ref cmnt) => {\n+                    if (*cmnt).pos < pos {\n+                        try!(self.print_comment(cmnt));\n+                        self.cur_cmnt_and_lit().cur_cmnt += 1;\n+                    } else { break; }\n+                }\n+                _ => break\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    fn print_comment(&mut self,\n+                     cmnt: &comments::Comment) -> io::Result<()> {\n+        match cmnt.style {\n+            comments::Mixed => {\n+                assert_eq!(cmnt.lines.len(), 1);\n+                try!(zerobreak(self.writer()));\n+                try!(word(self.writer(), &cmnt.lines[0]));\n+                zerobreak(self.writer())\n+            }\n+            comments::Isolated => {\n+                try!(self.hardbreak_if_not_bol());\n+                for line in &cmnt.lines {\n+                    // Don't print empty lines because they will end up as trailing\n+                    // whitespace\n+                    if !line.is_empty() {\n+                        try!(word(self.writer(), &line[..]));\n+                    }\n+                    try!(hardbreak(self.writer()));\n+                }\n+                Ok(())\n+            }\n+            comments::Trailing => {\n+                try!(word(self.writer(), \" \"));\n+                if cmnt.lines.len() == 1 {\n+                    try!(word(self.writer(), &cmnt.lines[0]));\n+                    hardbreak(self.writer())\n+                } else {\n+                    try!(self.ibox(0));\n+                    for line in &cmnt.lines {\n+                        if !line.is_empty() {\n+                            try!(word(self.writer(), &line[..]));\n+                        }\n+                        try!(hardbreak(self.writer()));\n+                    }\n+                    self.end()\n+                }\n+            }\n+            comments::BlankLine => {\n+                // We need to do at least one, possibly two hardbreaks.\n+                let is_semi = match self.writer().last_token() {\n+                    pp::Token::String(s, _) => \";\" == s,\n+                    _ => false\n+                };\n+                if is_semi || self.is_begin() || self.is_end() {\n+                    try!(hardbreak(self.writer()));\n+                }\n+                hardbreak(self.writer())\n+            }\n+        }\n+    }\n+\n+    fn next_comment(&mut self) -> Option<comments::Comment> {\n+        let cur_cmnt = self.cur_cmnt_and_lit().cur_cmnt;\n+        match *self.comments() {\n+            Some(ref cmnts) => {\n+                if cur_cmnt < cmnts.len() {\n+                    Some(cmnts[cur_cmnt].clone())\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None\n+        }\n+    }\n+\n+    fn print_literal(&mut self, lit: &ast::Lit) -> io::Result<()> {\n+        try!(self.maybe_print_comment(lit.span.lo));\n+        match self.next_lit(lit.span.lo) {\n+            Some(ref ltrl) => {\n+                return word(self.writer(), &(*ltrl).lit);\n+            }\n+            _ => ()\n+        }\n+        match lit.node {\n+            ast::LitStr(ref st, style) => self.print_string(&st, style),\n+            ast::LitByte(byte) => {\n+                let mut res = String::from(\"b'\");\n+                res.extend(ascii::escape_default(byte).map(|c| c as char));\n+                res.push('\\'');\n+                word(self.writer(), &res[..])\n+            }\n+            ast::LitChar(ch) => {\n+                let mut res = String::from(\"'\");\n+                res.extend(ch.escape_default());\n+                res.push('\\'');\n+                word(self.writer(), &res[..])\n+            }\n+            ast::LitInt(i, t) => {\n+                match t {\n+                    ast::SignedIntLit(st, ast::Plus) => {\n+                        word(self.writer(),\n+                             &ast_util::int_ty_to_string(st, Some(i as i64)))\n+                    }\n+                    ast::SignedIntLit(st, ast::Minus) => {\n+                        let istr = ast_util::int_ty_to_string(st, Some(-(i as i64)));\n+                        word(self.writer(),\n+                             &format!(\"-{}\", istr))\n+                    }\n+                    ast::UnsignedIntLit(ut) => {\n+                        word(self.writer(), &ast_util::uint_ty_to_string(ut, Some(i)))\n+                    }\n+                    ast::UnsuffixedIntLit(ast::Plus) => {\n+                        word(self.writer(), &format!(\"{}\", i))\n+                    }\n+                    ast::UnsuffixedIntLit(ast::Minus) => {\n+                        word(self.writer(), &format!(\"-{}\", i))\n+                    }\n+                }\n+            }\n+            ast::LitFloat(ref f, t) => {\n+                word(self.writer(),\n+                     &format!(\n+                         \"{}{}\",\n+                         &f,\n+                         &ast_util::float_ty_to_string(t)))\n+            }\n+            ast::LitFloatUnsuffixed(ref f) => word(self.writer(), &f[..]),\n+            ast::LitBool(val) => {\n+                if val { word(self.writer(), \"true\") } else { word(self.writer(), \"false\") }\n+            }\n+            ast::LitByteStr(ref v) => {\n+                let mut escaped: String = String::new();\n+                for &ch in v.iter() {\n+                    escaped.extend(ascii::escape_default(ch)\n+                                         .map(|c| c as char));\n+                }\n+                word(self.writer(), &format!(\"b\\\"{}\\\"\", escaped))\n+            }\n+        }\n+    }\n+\n+    fn print_string(&mut self, st: &str,\n+                    style: ast::StrStyle) -> io::Result<()> {\n+        let st = match style {\n+            ast::CookedStr => {\n+                (format!(\"\\\"{}\\\"\", st.escape_default()))\n+            }\n+            ast::RawStr(n) => {\n+                (format!(\"r{delim}\\\"{string}\\\"{delim}\",\n+                         delim=repeat(\"#\", n),\n+                         string=st))\n+            }\n+        };\n+        word(self.writer(), &st[..])\n+    }\n+\n+    fn print_inner_attributes(&mut self,\n+                                  attrs: &[ast::Attribute]) -> io::Result<()> {\n+        let mut count = 0;\n+        for attr in attrs {\n+            match attr.node.style {\n+                ast::AttrInner => {\n+                    try!(self.print_attribute(attr));\n+                    count += 1;\n+                }\n+                _ => {/* fallthrough */ }\n+            }\n+        }\n+        if count > 0 {\n+            try!(self.hardbreak_if_not_bol());\n+        }\n+        Ok(())\n+    }\n+\n+    fn print_outer_attributes(&mut self,\n+                              attrs: &[ast::Attribute]) -> io::Result<()> {\n+        let mut count = 0;\n+        for attr in attrs {\n+            match attr.node.style {\n+                ast::AttrOuter => {\n+                    try!(self.print_attribute(attr));\n+                    count += 1;\n+                }\n+                _ => {/* fallthrough */ }\n+            }\n+        }\n+        if count > 0 {\n+            try!(self.hardbreak_if_not_bol());\n+        }\n+        Ok(())\n+    }\n+\n+    fn print_attribute(&mut self, attr: &ast::Attribute) -> io::Result<()> {\n+        try!(self.hardbreak_if_not_bol());\n+        try!(self.maybe_print_comment(attr.span.lo));\n+        if attr.node.is_sugared_doc {\n+            word(self.writer(), &attr.value_str().unwrap())\n+        } else {\n+            match attr.node.style {\n+                ast::AttrInner => try!(word(self.writer(), \"#![\")),\n+                ast::AttrOuter => try!(word(self.writer(), \"#[\")),\n+            }\n+            try!(self.print_meta_item(&*attr.meta()));\n+            word(self.writer(), \"]\")\n+        }\n+    }\n+\n+    fn print_meta_item(&mut self, item: &ast::MetaItem) -> io::Result<()> {\n+        try!(self.ibox(indent_unit));\n+        match item.node {\n+            ast::MetaWord(ref name) => {\n+                try!(word(self.writer(), &name));\n+            }\n+            ast::MetaNameValue(ref name, ref value) => {\n+                try!(self.word_space(&name[..]));\n+                try!(self.word_space(\"=\"));\n+                try!(self.print_literal(value));\n+            }\n+            ast::MetaList(ref name, ref items) => {\n+                try!(word(self.writer(), &name));\n+                try!(self.popen());\n+                try!(self.commasep(Consistent,\n+                                   &items[..],\n+                                   |s, i| s.print_meta_item(&**i)));\n+                try!(self.pclose());\n+            }\n+        }\n+        self.end()\n+    }\n+}\n+\n+impl<'a> PrintState<'a> for State<'a> {\n+    fn writer(&mut self) -> &mut pp::Printer<'a> {\n+        &mut self.s\n+    }\n+\n+    fn boxes(&mut self) -> &mut Vec<pp::Breaks> {\n+        &mut self.boxes\n+    }\n+\n+    fn comments(&mut self) -> &mut Option<Vec<comments::Comment>> {\n+        &mut self.comments\n+    }\n+\n+    fn cur_cmnt_and_lit(&mut self) -> &mut CurrentCommentAndLiteral {\n+        &mut self.cur_cmnt_and_lit\n     }\n \n-    pub fn popen(&mut self) -> io::Result<()> { word(&mut self.s, \"(\") }\n+    fn literals(&self) -> &Option<Vec<comments::Literal>> {\n+        &self.literals\n+    }\n+}\n \n-    pub fn pclose(&mut self) -> io::Result<()> { word(&mut self.s, \")\") }\n+impl<'a> State<'a> {\n+    pub fn cbox(&mut self, u: usize) -> io::Result<()> {\n+        self.boxes.push(pp::Breaks::Consistent);\n+        pp::cbox(&mut self.s, u)\n+    }\n+\n+    pub fn nbsp(&mut self) -> io::Result<()> { word(&mut self.s, \" \") }\n+\n+    pub fn word_nbsp(&mut self, w: &str) -> io::Result<()> {\n+        try!(word(&mut self.s, w));\n+        self.nbsp()\n+    }\n \n     pub fn head(&mut self, w: &str) -> io::Result<()> {\n         // outer-box is consistent\n@@ -523,38 +849,13 @@ impl<'a> State<'a> {\n         self.bclose_(span, indent_unit)\n     }\n \n-    pub fn is_begin(&mut self) -> bool {\n-        match self.s.last_token() {\n-            pp::Token::Begin(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_end(&mut self) -> bool {\n-        match self.s.last_token() {\n-            pp::Token::End => true,\n-            _ => false,\n-        }\n-    }\n-\n-    // is this the beginning of a line?\n-    pub fn is_bol(&mut self) -> bool {\n-        self.s.last_token().is_eof() || self.s.last_token().is_hardbreak_tok()\n-    }\n-\n     pub fn in_cbox(&self) -> bool {\n         match self.boxes.last() {\n             Some(&last_box) => last_box == pp::Breaks::Consistent,\n             None => false\n         }\n     }\n \n-    pub fn hardbreak_if_not_bol(&mut self) -> io::Result<()> {\n-        if !self.is_bol() {\n-            try!(hardbreak(&mut self.s))\n-        }\n-        Ok(())\n-    }\n     pub fn space_if_not_bol(&mut self) -> io::Result<()> {\n         if !self.is_bol() { try!(space(&mut self.s)); }\n         Ok(())\n@@ -584,17 +885,6 @@ impl<'a> State<'a> {\n         word(&mut self.s, \"*/\")\n     }\n \n-    pub fn commasep<T, F>(&mut self, b: Breaks, elts: &[T], mut op: F) -> io::Result<()> where\n-        F: FnMut(&mut State, &T) -> io::Result<()>,\n-    {\n-        try!(self.rbox(0, b));\n-        let mut first = true;\n-        for elt in elts {\n-            if first { first = false; } else { try!(self.word_space(\",\")); }\n-            try!(op(self, elt));\n-        }\n-        self.end()\n-    }\n \n \n     pub fn commasep_cmnt<T, F, G>(&mut self,\n@@ -1326,58 +1616,6 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodeSubItem(ii.id))\n     }\n \n-    pub fn print_outer_attributes(&mut self,\n-                                  attrs: &[ast::Attribute]) -> io::Result<()> {\n-        let mut count = 0;\n-        for attr in attrs {\n-            match attr.node.style {\n-                ast::AttrOuter => {\n-                    try!(self.print_attribute(attr));\n-                    count += 1;\n-                }\n-                _ => {/* fallthrough */ }\n-            }\n-        }\n-        if count > 0 {\n-            try!(self.hardbreak_if_not_bol());\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn print_inner_attributes(&mut self,\n-                                  attrs: &[ast::Attribute]) -> io::Result<()> {\n-        let mut count = 0;\n-        for attr in attrs {\n-            match attr.node.style {\n-                ast::AttrInner => {\n-                    try!(self.print_attribute(attr));\n-                    count += 1;\n-                }\n-                _ => {/* fallthrough */ }\n-            }\n-        }\n-        if count > 0 {\n-            try!(self.hardbreak_if_not_bol());\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn print_attribute(&mut self, attr: &ast::Attribute) -> io::Result<()> {\n-        try!(self.hardbreak_if_not_bol());\n-        try!(self.maybe_print_comment(attr.span.lo));\n-        if attr.node.is_sugared_doc {\n-            word(&mut self.s, &attr.value_str().unwrap())\n-        } else {\n-            match attr.node.style {\n-                ast::AttrInner => try!(word(&mut self.s, \"#![\")),\n-                ast::AttrOuter => try!(word(&mut self.s, \"#[\")),\n-            }\n-            try!(self.print_meta_item(&*attr.meta()));\n-            word(&mut self.s, \"]\")\n-        }\n-    }\n-\n-\n     pub fn print_stmt(&mut self, st: &ast::Stmt) -> io::Result<()> {\n         try!(self.maybe_print_comment(st.span.lo));\n         match st.node {\n@@ -2620,29 +2858,6 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_meta_item(&mut self, item: &ast::MetaItem) -> io::Result<()> {\n-        try!(self.ibox(indent_unit));\n-        match item.node {\n-            ast::MetaWord(ref name) => {\n-                try!(word(&mut self.s, &name));\n-            }\n-            ast::MetaNameValue(ref name, ref value) => {\n-                try!(self.word_space(&name[..]));\n-                try!(self.word_space(\"=\"));\n-                try!(self.print_literal(value));\n-            }\n-            ast::MetaList(ref name, ref items) => {\n-                try!(word(&mut self.s, &name));\n-                try!(self.popen());\n-                try!(self.commasep(Consistent,\n-                                   &items[..],\n-                                   |s, i| s.print_meta_item(&**i)));\n-                try!(self.pclose());\n-            }\n-        }\n-        self.end()\n-    }\n-\n     pub fn print_view_path(&mut self, vp: &ast::ViewPath) -> io::Result<()> {\n         match vp.node {\n             ast::ViewPathSimple(ident, ref path) => {\n@@ -2832,181 +3047,6 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_literal(&mut self, lit: &ast::Lit) -> io::Result<()> {\n-        try!(self.maybe_print_comment(lit.span.lo));\n-        match self.next_lit(lit.span.lo) {\n-            Some(ref ltrl) => {\n-                return word(&mut self.s, &(*ltrl).lit);\n-            }\n-            _ => ()\n-        }\n-        match lit.node {\n-            ast::LitStr(ref st, style) => self.print_string(&st, style),\n-            ast::LitByte(byte) => {\n-                let mut res = String::from(\"b'\");\n-                res.extend(ascii::escape_default(byte).map(|c| c as char));\n-                res.push('\\'');\n-                word(&mut self.s, &res[..])\n-            }\n-            ast::LitChar(ch) => {\n-                let mut res = String::from(\"'\");\n-                res.extend(ch.escape_default());\n-                res.push('\\'');\n-                word(&mut self.s, &res[..])\n-            }\n-            ast::LitInt(i, t) => {\n-                match t {\n-                    ast::SignedIntLit(st, ast::Plus) => {\n-                        word(&mut self.s,\n-                             &ast_util::int_ty_to_string(st, Some(i as i64)))\n-                    }\n-                    ast::SignedIntLit(st, ast::Minus) => {\n-                        let istr = ast_util::int_ty_to_string(st, Some(-(i as i64)));\n-                        word(&mut self.s,\n-                             &format!(\"-{}\", istr))\n-                    }\n-                    ast::UnsignedIntLit(ut) => {\n-                        word(&mut self.s, &ast_util::uint_ty_to_string(ut, Some(i)))\n-                    }\n-                    ast::UnsuffixedIntLit(ast::Plus) => {\n-                        word(&mut self.s, &format!(\"{}\", i))\n-                    }\n-                    ast::UnsuffixedIntLit(ast::Minus) => {\n-                        word(&mut self.s, &format!(\"-{}\", i))\n-                    }\n-                }\n-            }\n-            ast::LitFloat(ref f, t) => {\n-                word(&mut self.s,\n-                     &format!(\n-                         \"{}{}\",\n-                         &f,\n-                         &ast_util::float_ty_to_string(t)))\n-            }\n-            ast::LitFloatUnsuffixed(ref f) => word(&mut self.s, &f[..]),\n-            ast::LitBool(val) => {\n-                if val { word(&mut self.s, \"true\") } else { word(&mut self.s, \"false\") }\n-            }\n-            ast::LitByteStr(ref v) => {\n-                let mut escaped: String = String::new();\n-                for &ch in v.iter() {\n-                    escaped.extend(ascii::escape_default(ch)\n-                                         .map(|c| c as char));\n-                }\n-                word(&mut self.s, &format!(\"b\\\"{}\\\"\", escaped))\n-            }\n-        }\n-    }\n-\n-    pub fn next_lit(&mut self, pos: BytePos) -> Option<comments::Literal> {\n-        match self.literals {\n-            Some(ref lits) => {\n-                while self.cur_cmnt_and_lit.cur_lit < lits.len() {\n-                    let ltrl = (*lits)[self.cur_cmnt_and_lit.cur_lit].clone();\n-                    if ltrl.pos > pos { return None; }\n-                    self.cur_cmnt_and_lit.cur_lit += 1;\n-                    if ltrl.pos == pos { return Some(ltrl); }\n-                }\n-                None\n-            }\n-            _ => None\n-        }\n-    }\n-\n-    pub fn maybe_print_comment(&mut self, pos: BytePos) -> io::Result<()> {\n-        loop {\n-            match self.next_comment() {\n-                Some(ref cmnt) => {\n-                    if (*cmnt).pos < pos {\n-                        try!(self.print_comment(cmnt));\n-                        self.cur_cmnt_and_lit.cur_cmnt += 1;\n-                    } else { break; }\n-                }\n-                _ => break\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn print_comment(&mut self,\n-                         cmnt: &comments::Comment) -> io::Result<()> {\n-        match cmnt.style {\n-            comments::Mixed => {\n-                assert_eq!(cmnt.lines.len(), 1);\n-                try!(zerobreak(&mut self.s));\n-                try!(word(&mut self.s, &cmnt.lines[0]));\n-                zerobreak(&mut self.s)\n-            }\n-            comments::Isolated => {\n-                try!(self.hardbreak_if_not_bol());\n-                for line in &cmnt.lines {\n-                    // Don't print empty lines because they will end up as trailing\n-                    // whitespace\n-                    if !line.is_empty() {\n-                        try!(word(&mut self.s, &line[..]));\n-                    }\n-                    try!(hardbreak(&mut self.s));\n-                }\n-                Ok(())\n-            }\n-            comments::Trailing => {\n-                try!(word(&mut self.s, \" \"));\n-                if cmnt.lines.len() == 1 {\n-                    try!(word(&mut self.s, &cmnt.lines[0]));\n-                    hardbreak(&mut self.s)\n-                } else {\n-                    try!(self.ibox(0));\n-                    for line in &cmnt.lines {\n-                        if !line.is_empty() {\n-                            try!(word(&mut self.s, &line[..]));\n-                        }\n-                        try!(hardbreak(&mut self.s));\n-                    }\n-                    self.end()\n-                }\n-            }\n-            comments::BlankLine => {\n-                // We need to do at least one, possibly two hardbreaks.\n-                let is_semi = match self.s.last_token() {\n-                    pp::Token::String(s, _) => \";\" == s,\n-                    _ => false\n-                };\n-                if is_semi || self.is_begin() || self.is_end() {\n-                    try!(hardbreak(&mut self.s));\n-                }\n-                hardbreak(&mut self.s)\n-            }\n-        }\n-    }\n-\n-    pub fn print_string(&mut self, st: &str,\n-                        style: ast::StrStyle) -> io::Result<()> {\n-        let st = match style {\n-            ast::CookedStr => {\n-                (format!(\"\\\"{}\\\"\", st.escape_default()))\n-            }\n-            ast::RawStr(n) => {\n-                (format!(\"r{delim}\\\"{string}\\\"{delim}\",\n-                         delim=repeat(\"#\", n),\n-                         string=st))\n-            }\n-        };\n-        word(&mut self.s, &st[..])\n-    }\n-\n-    pub fn next_comment(&mut self) -> Option<comments::Comment> {\n-        match self.comments {\n-            Some(ref cmnts) => {\n-                if self.cur_cmnt_and_lit.cur_cmnt < cmnts.len() {\n-                    Some(cmnts[self.cur_cmnt_and_lit.cur_cmnt].clone())\n-                } else {\n-                    None\n-                }\n-            }\n-            _ => None\n-        }\n-    }\n-\n     pub fn print_opt_abi_and_extern_if_nondefault(&mut self,\n                                                   opt_abi: Option<abi::Abi>)\n         -> io::Result<()> {"}, {"sha": "4c9c7f443c29005226a682edabce0094e3111017", "filename": "src/test/auxiliary/lint_for_crate.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Ftest%2Fauxiliary%2Flint_for_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f1b063295c48c97e239ce479b08f192a3eece4/src%2Ftest%2Fauxiliary%2Flint_for_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_for_crate.rs?ref=e9f1b063295c48c97e239ce479b08f192a3eece4", "patch": "@@ -15,10 +15,12 @@\n \n #[macro_use] extern crate rustc;\n extern crate rustc_front;\n+extern crate syntax;\n \n use rustc::lint::{Context, LintPass, LintPassObject, LintArray};\n use rustc::plugin::Registry;\n-use rustc_front::{hir, attr};\n+use rustc_front::hir;\n+use syntax::attr;\n \n declare_lint!(CRATE_NOT_OKAY, Warn, \"crate not marked with #![crate_okay]\");\n "}]}