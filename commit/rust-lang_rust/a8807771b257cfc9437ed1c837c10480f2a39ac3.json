{"sha": "a8807771b257cfc9437ed1c837c10480f2a39ac3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4ODA3NzcxYjI1N2NmYzk0MzdlZDFjODM3YzEwNDgwZjJhMzlhYzM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-19T09:35:31Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-21T17:23:56Z"}, "message": "Purge borrowck from libstd\n\nThis hasn't been in use since `@mut` was removed", "tree": {"sha": "c1ec8870c783cdb4a38e6d79a3240ce65a90a30d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1ec8870c783cdb4a38e6d79a3240ce65a90a30d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8807771b257cfc9437ed1c837c10480f2a39ac3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8807771b257cfc9437ed1c837c10480f2a39ac3", "html_url": "https://github.com/rust-lang/rust/commit/a8807771b257cfc9437ed1c837c10480f2a39ac3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8807771b257cfc9437ed1c837c10480f2a39ac3/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57f8073b5eef51e7af031be081786161dea53cb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/57f8073b5eef51e7af031be081786161dea53cb6", "html_url": "https://github.com/rust-lang/rust/commit/57f8073b5eef51e7af031be081786161dea53cb6"}], "stats": {"total": 271, "additions": 0, "deletions": 271}, "files": [{"sha": "7dcbae995ed7b2be3a278e3d8ed8b13fefde5b4d", "filename": "src/libstd/rt/borrowck.rs", "status": "removed", "additions": 0, "deletions": 220, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/57f8073b5eef51e7af031be081786161dea53cb6/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f8073b5eef51e7af031be081786161dea53cb6/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=57f8073b5eef51e7af031be081786161dea53cb6", "patch": "@@ -1,220 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use c_str::{ToCStr, CString};\n-use container::Container;\n-use iter::Iterator;\n-use libc::{c_char, size_t};\n-use option::{Option, None, Some};\n-use ptr::RawPtr;\n-use rt;\n-use rt::local::Local;\n-use rt::task::Task;\n-use str::OwnedStr;\n-use str;\n-use uint;\n-use unstable::raw;\n-use vec::{ImmutableVector, OwnedVector};\n-\n-pub static FROZEN_BIT: uint = 1 << (uint::bits - 1);\n-pub static MUT_BIT: uint = 1 << (uint::bits - 2);\n-static ALL_BITS: uint = FROZEN_BIT | MUT_BIT;\n-\n-#[deriving(Eq)]\n-pub struct BorrowRecord {\n-    priv alloc: *mut raw::Box<()>,\n-    file: *c_char,\n-    priv line: size_t\n-}\n-\n-fn try_take_task_borrow_list() -> Option<~[BorrowRecord]> {\n-    let mut task = Local::borrow(None::<Task>);\n-    task.get().borrow_list.take()\n-}\n-\n-fn swap_task_borrow_list(f: |~[BorrowRecord]| -> ~[BorrowRecord]) {\n-    let borrows = match try_take_task_borrow_list() {\n-        Some(l) => l,\n-        None => ~[]\n-    };\n-    let borrows = f(borrows);\n-\n-    let mut task = Local::borrow(None::<Task>);\n-    task.get().borrow_list = Some(borrows)\n-}\n-\n-pub fn clear_task_borrow_list() {\n-    // pub because it is used by the box annihilator.\n-    let _ = try_take_task_borrow_list();\n-}\n-\n-#[cold]\n-unsafe fn fail_borrowed(alloc: *mut raw::Box<()>, file: *c_char, line: size_t)\n-                        -> ! {\n-    debug_borrow(\"fail_borrowed: \", alloc, 0, 0, file, line);\n-\n-    match try_take_task_borrow_list() {\n-        None => { // not recording borrows\n-            let msg = \"borrowed\";\n-            msg.with_c_str(|msg_p| rt::begin_unwind_raw(msg_p, file, line))\n-        }\n-        Some(borrow_list) => { // recording borrows\n-            let mut msg = ~\"borrowed\";\n-            let mut sep = \" at \";\n-            for entry in borrow_list.rev_iter() {\n-                if entry.alloc == alloc {\n-                    msg.push_str(sep);\n-                    let filename = str::raw::from_c_str(entry.file);\n-                    msg.push_str(filename);\n-                    msg.push_str(format!(\":{}\", entry.line));\n-                    sep = \" and at \";\n-                }\n-            }\n-            msg.with_c_str(|msg_p| rt::begin_unwind_raw(msg_p, file, line))\n-        }\n-    }\n-}\n-\n-/// Because this code is so perf. sensitive, use a static constant so that\n-/// debug printouts are compiled out most of the time.\n-static ENABLE_DEBUG: bool = false;\n-\n-#[inline]\n-unsafe fn debug_borrow<T,P:RawPtr<T>>(tag: &'static str,\n-                                      p: P,\n-                                      old_bits: uint,\n-                                      new_bits: uint,\n-                                      filename: *c_char,\n-                                      line: size_t) {\n-    //! A useful debugging function that prints a pointer + tag + newline\n-    //! without allocating memory.\n-\n-    if ENABLE_DEBUG && rt::env::debug_borrow() {\n-        debug_borrow_slow(tag, p, old_bits, new_bits, filename, line);\n-    }\n-\n-    unsafe fn debug_borrow_slow<T,P:RawPtr<T>>(tag: &'static str,\n-                                               p: P,\n-                                               old_bits: uint,\n-                                               new_bits: uint,\n-                                               filename: *c_char,\n-                                               line: size_t) {\n-        let filename = CString::new(filename, false);\n-        rterrln!(\"{}{:#x} {:x} {:x} {}:{}\",\n-                 tag, p.to_uint(), old_bits, new_bits,\n-                 filename.as_str().unwrap(), line);\n-    }\n-}\n-\n-#[inline]\n-pub unsafe fn borrow_as_imm(a: *u8, file: *c_char, line: size_t) -> uint {\n-    let a = a as *mut raw::Box<()>;\n-    let old_ref_count = (*a).ref_count;\n-    let new_ref_count = old_ref_count | FROZEN_BIT;\n-\n-    debug_borrow(\"borrow_as_imm:\", a, old_ref_count, new_ref_count, file, line);\n-\n-    if (old_ref_count & MUT_BIT) != 0 {\n-        fail_borrowed(a, file, line);\n-    }\n-\n-    (*a).ref_count = new_ref_count;\n-\n-    old_ref_count\n-}\n-\n-#[inline]\n-pub unsafe fn borrow_as_mut(a: *u8, file: *c_char, line: size_t) -> uint {\n-    let a = a as *mut raw::Box<()>;\n-    let old_ref_count = (*a).ref_count;\n-    let new_ref_count = old_ref_count | MUT_BIT | FROZEN_BIT;\n-\n-    debug_borrow(\"borrow_as_mut:\", a, old_ref_count, new_ref_count, file, line);\n-\n-    if (old_ref_count & (MUT_BIT|FROZEN_BIT)) != 0 {\n-        fail_borrowed(a, file, line);\n-    }\n-\n-    (*a).ref_count = new_ref_count;\n-\n-    old_ref_count\n-}\n-\n-pub unsafe fn record_borrow(a: *u8, old_ref_count: uint,\n-                            file: *c_char, line: size_t) {\n-    if (old_ref_count & ALL_BITS) == 0 {\n-        // was not borrowed before\n-        let a = a as *mut raw::Box<()>;\n-        debug_borrow(\"record_borrow:\", a, old_ref_count, 0, file, line);\n-        swap_task_borrow_list(|borrow_list| {\n-            let mut borrow_list = borrow_list;\n-            borrow_list.push(BorrowRecord {\n-                alloc: a,\n-                file: file,\n-                line: line,\n-            });\n-            borrow_list\n-        })\n-    }\n-}\n-\n-pub unsafe fn unrecord_borrow(a: *u8,\n-                              old_ref_count: uint,\n-                              file: *c_char,\n-                              line: size_t) {\n-    if (old_ref_count & ALL_BITS) == 0 {\n-        // was not borrowed before, so we should find the record at\n-        // the end of the list\n-        let a = a as *mut raw::Box<()>;\n-        debug_borrow(\"unrecord_borrow:\", a, old_ref_count, 0, file, line);\n-        swap_task_borrow_list(|borrow_list| {\n-            let mut borrow_list = borrow_list;\n-            assert!(!borrow_list.is_empty());\n-            let br = borrow_list.pop();\n-            if br.alloc != a || br.file != file || br.line != line {\n-                let err = format!(\"wrong borrow found, br={:?}\", br);\n-                err.with_c_str(|msg_p| {\n-                    rt::begin_unwind_raw(msg_p, file, line)\n-                })\n-            }\n-            borrow_list\n-        })\n-    }\n-}\n-\n-#[inline]\n-pub unsafe fn return_to_mut(a: *u8, orig_ref_count: uint,\n-                            file: *c_char, line: size_t) {\n-    // Sometimes the box is null, if it is conditionally frozen.\n-    // See e.g. #4904.\n-    if !a.is_null() {\n-        let a = a as *mut raw::Box<()>;\n-        let old_ref_count = (*a).ref_count;\n-        let new_ref_count =\n-            (old_ref_count & !ALL_BITS) | (orig_ref_count & ALL_BITS);\n-\n-        debug_borrow(\"return_to_mut:\",\n-                     a, old_ref_count, new_ref_count, file, line);\n-\n-        (*a).ref_count = new_ref_count;\n-    }\n-}\n-\n-#[inline]\n-pub unsafe fn check_not_borrowed(a: *u8,\n-                                 file: *c_char,\n-                                 line: size_t) {\n-    let a = a as *mut raw::Box<()>;\n-    let ref_count = (*a).ref_count;\n-    debug_borrow(\"check_not_borrowed:\", a, ref_count, 0, file, line);\n-    if (ref_count & FROZEN_BIT) != 0 {\n-        fail_borrowed(a, file, line);\n-    }\n-}"}, {"sha": "40e9a3ec5b2f31a4530b5bf3717094b65081410a", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8807771b257cfc9437ed1c837c10480f2a39ac3/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8807771b257cfc9437ed1c837c10480f2a39ac3/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=a8807771b257cfc9437ed1c837c10480f2a39ac3", "patch": "@@ -127,9 +127,6 @@ mod util;\n // Global command line argument storage\n pub mod args;\n \n-// Support for dynamic borrowck\n-pub mod borrowck;\n-\n /// The default error code of the rust runtime if the main task fails instead\n /// of exiting cleanly.\n pub static DEFAULT_ERROR_CODE: int = 101;"}, {"sha": "e63208bcaec6fb0c9266e20714002ab3c2a1b4c4", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8807771b257cfc9437ed1c837c10480f2a39ac3/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8807771b257cfc9437ed1c837c10480f2a39ac3/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=a8807771b257cfc9437ed1c837c10480f2a39ac3", "patch": "@@ -27,8 +27,6 @@ use option::{Option, Some, None};\n use prelude::drop;\n use result::{Result, Ok, Err};\n use rt::Runtime;\n-use rt::borrowck::BorrowRecord;\n-use rt::borrowck;\n use rt::local::Local;\n use rt::local_heap::LocalHeap;\n use rt::rtio::LocalIo;\n@@ -52,8 +50,6 @@ pub struct Task {\n     death: Death,\n     destroyed: bool,\n     name: Option<SendStr>,\n-    // Dynamic borrowck debugging info\n-    borrow_list: Option<~[BorrowRecord]>,\n \n     logger: Option<~Logger>,\n     stdout: Option<~Writer>,\n@@ -93,7 +89,6 @@ impl Task {\n             death: Death::new(),\n             destroyed: false,\n             name: None,\n-            borrow_list: None,\n             logger: None,\n             stdout: None,\n             stderr: None,\n@@ -182,9 +177,6 @@ impl Task {\n \n         unsafe { (*handle).unwinder.try(try_block); }\n \n-        // Cleanup the dynamic borrowck debugging info\n-        borrowck::clear_task_borrow_list();\n-\n         // Here we must unsafely borrow the task in order to not remove it from\n         // TLS. When collecting failure, we may attempt to send on a channel (or\n         // just run aribitrary code), so we must be sure to still have a local"}, {"sha": "8460152ff7bae2f8984367d9e93df730f7927eca", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a8807771b257cfc9437ed1c837c10480f2a39ac3/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8807771b257cfc9437ed1c837c10480f2a39ac3/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=a8807771b257cfc9437ed1c837c10480f2a39ac3", "patch": "@@ -12,7 +12,6 @@\n \n use c_str::ToCStr;\n use libc::{c_char, size_t, uintptr_t};\n-use rt::borrowck;\n \n #[cold]\n #[lang=\"fail_\"]\n@@ -42,42 +41,3 @@ pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n pub unsafe fn local_free(ptr: *c_char) {\n     ::rt::local_heap::local_free(ptr);\n }\n-\n-#[lang=\"borrow_as_imm\"]\n-#[inline]\n-pub unsafe fn borrow_as_imm(a: *u8, file: *c_char, line: size_t) -> uint {\n-    borrowck::borrow_as_imm(a, file, line)\n-}\n-\n-#[lang=\"borrow_as_mut\"]\n-#[inline]\n-pub unsafe fn borrow_as_mut(a: *u8, file: *c_char, line: size_t) -> uint {\n-    borrowck::borrow_as_mut(a, file, line)\n-}\n-\n-#[lang=\"record_borrow\"]\n-pub unsafe fn record_borrow(a: *u8, old_ref_count: uint,\n-                            file: *c_char, line: size_t) {\n-    borrowck::record_borrow(a, old_ref_count, file, line)\n-}\n-\n-#[lang=\"unrecord_borrow\"]\n-pub unsafe fn unrecord_borrow(a: *u8, old_ref_count: uint,\n-                              file: *c_char, line: size_t) {\n-    borrowck::unrecord_borrow(a, old_ref_count, file, line)\n-}\n-\n-#[lang=\"return_to_mut\"]\n-#[inline]\n-pub unsafe fn return_to_mut(a: *u8, orig_ref_count: uint,\n-                            file: *c_char, line: size_t) {\n-    borrowck::return_to_mut(a, orig_ref_count, file, line)\n-}\n-\n-#[lang=\"check_not_borrowed\"]\n-#[inline]\n-pub unsafe fn check_not_borrowed(a: *u8,\n-                                 file: *c_char,\n-                                 line: size_t) {\n-    borrowck::check_not_borrowed(a, file, line)\n-}"}]}