{"sha": "f03cf9916a1932f47b788a9de9256269cc172fe9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwM2NmOTkxNmExOTMyZjQ3Yjc4OGE5ZGU5MjU2MjY5Y2MxNzJmZTk=", "commit": {"author": {"name": "Eduardo S\u00e1nchez Mu\u00f1oz", "email": "esm@eduardosm.net", "date": "2020-05-26T15:38:22Z"}, "committer": {"name": "Eduardo S\u00e1nchez Mu\u00f1oz", "email": "esm@eduardosm.net", "date": "2020-05-26T15:46:10Z"}, "message": "Add a fast path for `std::thread::panicking`.\n\nThis is done by adding a global atomic variable (non-TLS) that counts how many threads are panicking. In order to check if the current thread is panicking, this variable is read and, if it is zero, no thread (including the one where `panicking` is being called) is panicking and `panicking` can return `false` immediately without needing to access TLS. If the global counter is not zero, the local counter is accessed from TLS to check if the current thread is panicking.", "tree": {"sha": "6ae5e84172fdf68053b59f8b8f1f641af50d3bf7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ae5e84172fdf68053b59f8b8f1f641af50d3bf7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f03cf9916a1932f47b788a9de9256269cc172fe9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f03cf9916a1932f47b788a9de9256269cc172fe9", "html_url": "https://github.com/rust-lang/rust/commit/f03cf9916a1932f47b788a9de9256269cc172fe9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f03cf9916a1932f47b788a9de9256269cc172fe9/comments", "author": {"login": "eduardosm", "id": 761151, "node_id": "MDQ6VXNlcjc2MTE1MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/761151?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eduardosm", "html_url": "https://github.com/eduardosm", "followers_url": "https://api.github.com/users/eduardosm/followers", "following_url": "https://api.github.com/users/eduardosm/following{/other_user}", "gists_url": "https://api.github.com/users/eduardosm/gists{/gist_id}", "starred_url": "https://api.github.com/users/eduardosm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eduardosm/subscriptions", "organizations_url": "https://api.github.com/users/eduardosm/orgs", "repos_url": "https://api.github.com/users/eduardosm/repos", "events_url": "https://api.github.com/users/eduardosm/events{/privacy}", "received_events_url": "https://api.github.com/users/eduardosm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eduardosm", "id": 761151, "node_id": "MDQ6VXNlcjc2MTE1MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/761151?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eduardosm", "html_url": "https://github.com/eduardosm", "followers_url": "https://api.github.com/users/eduardosm/followers", "following_url": "https://api.github.com/users/eduardosm/following{/other_user}", "gists_url": "https://api.github.com/users/eduardosm/gists{/gist_id}", "starred_url": "https://api.github.com/users/eduardosm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eduardosm/subscriptions", "organizations_url": "https://api.github.com/users/eduardosm/orgs", "repos_url": "https://api.github.com/users/eduardosm/repos", "events_url": "https://api.github.com/users/eduardosm/events{/privacy}", "received_events_url": "https://api.github.com/users/eduardosm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb272d5d21c94f9a460d68d76817227a5913fbf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb272d5d21c94f9a460d68d76817227a5913fbf7", "html_url": "https://github.com/rust-lang/rust/commit/cb272d5d21c94f9a460d68d76817227a5913fbf7"}], "stats": {"total": 65, "additions": 51, "deletions": 14}, "files": [{"sha": "46196960e718b9f66c651ed457d810d98cb07599", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f03cf9916a1932f47b788a9de9256269cc172fe9/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03cf9916a1932f47b788a9de9256269cc172fe9/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=f03cf9916a1932f47b788a9de9256269cc172fe9", "patch": "@@ -170,7 +170,7 @@ pub fn take_hook() -> Box<dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send> {\n fn default_hook(info: &PanicInfo<'_>) {\n     // If this is a double panic, make sure that we print a backtrace\n     // for this panic. Otherwise only print it if logging is enabled.\n-    let backtrace_env = if update_panic_count(0) >= 2 {\n+    let backtrace_env = if panic_count::get() >= 2 {\n         RustBacktrace::Print(backtrace_rs::PrintFmt::Full)\n     } else {\n         backtrace::rust_backtrace_env()\n@@ -222,19 +222,56 @@ fn default_hook(info: &PanicInfo<'_>) {\n #[cfg(not(test))]\n #[doc(hidden)]\n #[unstable(feature = \"update_panic_count\", issue = \"none\")]\n-pub fn update_panic_count(amt: isize) -> usize {\n+pub mod panic_count {\n     use crate::cell::Cell;\n-    thread_local! { static PANIC_COUNT: Cell<usize> = Cell::new(0) }\n+    use crate::sync::atomic::{AtomicUsize, Ordering};\n+\n+    // Panic count for the current thread.\n+    thread_local! { static LOCAL_PANIC_COUNT: Cell<usize> = Cell::new(0) }\n+\n+    // Sum of panic counts from all threads. The purpose of this is to have\n+    // a fast path in `is_zero` (which is used by `panicking`). Access to\n+    // this variable can be always be done with relaxed ordering because\n+    // it is always guaranteed that, if `GLOBAL_PANIC_COUNT` is zero,\n+    // `LOCAL_PANIC_COUNT` will be zero.\n+    static GLOBAL_PANIC_COUNT: AtomicUsize = AtomicUsize::new(0);\n+\n+    pub fn increase() -> usize {\n+        GLOBAL_PANIC_COUNT.fetch_add(1, Ordering::Relaxed);\n+        LOCAL_PANIC_COUNT.with(|c| {\n+            let next = c.get() + 1;\n+            c.set(next);\n+            next\n+        })\n+    }\n+\n+    pub fn decrease() -> usize {\n+        GLOBAL_PANIC_COUNT.fetch_sub(1, Ordering::Relaxed);\n+        LOCAL_PANIC_COUNT.with(|c| {\n+            let next = c.get() - 1;\n+            c.set(next);\n+            next\n+        })\n+    }\n \n-    PANIC_COUNT.with(|c| {\n-        let next = (c.get() as isize + amt) as usize;\n-        c.set(next);\n-        next\n-    })\n+    pub fn get() -> usize {\n+        LOCAL_PANIC_COUNT.with(|c| c.get())\n+    }\n+\n+    pub fn is_zero() -> bool {\n+        if GLOBAL_PANIC_COUNT.load(Ordering::Relaxed) == 0 {\n+            // Fast path: if `GLOBAL_PANIC_COUNT` is zero, all threads\n+            // (including the current one) will have `LOCAL_PANIC_COUNT`\n+            // equal to zero, so TLS access can be avoided.\n+            true\n+        } else {\n+            LOCAL_PANIC_COUNT.with(|c| c.get() == 0)\n+        }\n+    }\n }\n \n #[cfg(test)]\n-pub use realstd::rt::update_panic_count;\n+pub use realstd::rt::panic_count;\n \n /// Invoke a closure, capturing the cause of an unwinding panic if one occurs.\n pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>> {\n@@ -284,7 +321,7 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     #[cold]\n     unsafe fn cleanup(payload: *mut u8) -> Box<dyn Any + Send + 'static> {\n         let obj = Box::from_raw(__rust_panic_cleanup(payload));\n-        update_panic_count(-1);\n+        panic_count::decrease();\n         obj\n     }\n \n@@ -314,7 +351,7 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n \n /// Determines whether the current thread is unwinding because of panic.\n pub fn panicking() -> bool {\n-    update_panic_count(0) != 0\n+    !panic_count::is_zero()\n }\n \n /// The entry point for panicking with a formatted message.\n@@ -452,7 +489,7 @@ fn rust_panic_with_hook(\n     message: Option<&fmt::Arguments<'_>>,\n     location: &Location<'_>,\n ) -> ! {\n-    let panics = update_panic_count(1);\n+    let panics = panic_count::increase();\n \n     // If this is the third nested call (e.g., panics == 2, this is 0-indexed),\n     // the panic hook probably triggered the last panic, otherwise the\n@@ -514,7 +551,7 @@ fn rust_panic_with_hook(\n /// This is the entry point for `resume_unwind`.\n /// It just forwards the payload to the panic runtime.\n pub fn rust_panic_without_hook(payload: Box<dyn Any + Send>) -> ! {\n-    update_panic_count(1);\n+    panic_count::increase();\n \n     struct RewrapBox(Box<dyn Any + Send>);\n "}, {"sha": "fb825ab16ebd7ef8d1dc114bd8d0a36b86a461fe", "filename": "src/libstd/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f03cf9916a1932f47b788a9de9256269cc172fe9/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03cf9916a1932f47b788a9de9256269cc172fe9/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=f03cf9916a1932f47b788a9de9256269cc172fe9", "patch": "@@ -15,7 +15,7 @@\n #![doc(hidden)]\n \n // Re-export some of our utilities which are expected by other crates.\n-pub use crate::panicking::{begin_panic, begin_panic_fmt, update_panic_count};\n+pub use crate::panicking::{begin_panic, begin_panic_fmt, panic_count};\n \n // To reduce the generated code of the new `lang_start`, this function is doing\n // the real work."}]}