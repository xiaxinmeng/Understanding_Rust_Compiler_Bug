{"sha": "c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1YmVmZGM2MzA4Zjg2MjRiNGI1ZmE4ODA4YmEwYWY3MGQyZmJjZjE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-24T15:17:06Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-28T00:56:46Z"}, "message": "rustc: always keep an explicit lifetime in trait objects.", "tree": {"sha": "d51c98b176554154537932b44426cfdc02c3d7f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d51c98b176554154537932b44426cfdc02c3d7f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1", "html_url": "https://github.com/rust-lang/rust/commit/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41553d6fbc36ee05364dcdccf43e8b8141a5cfe3", "url": "https://api.github.com/repos/rust-lang/rust/commits/41553d6fbc36ee05364dcdccf43e8b8141a5cfe3", "html_url": "https://github.com/rust-lang/rust/commit/41553d6fbc36ee05364dcdccf43e8b8141a5cfe3"}], "stats": {"total": 303, "additions": 137, "deletions": 166}, "files": [{"sha": "4b3e0d29101e4c33c42f57adee5a5fa339a50412", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1", "patch": "@@ -301,7 +301,7 @@ pub trait Visitor<'v> : Sized {\n     fn visit_ty_param_bound(&mut self, bounds: &'v TyParamBound) {\n         walk_ty_param_bound(self, bounds)\n     }\n-    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef, m: &'v TraitBoundModifier) {\n+    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef, m: TraitBoundModifier) {\n         walk_poly_trait_ref(self, t, m)\n     }\n     fn visit_variant_data(&mut self,\n@@ -421,7 +421,7 @@ pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V, lifetime_def: &'v\n \n pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n                                   trait_ref: &'v PolyTraitRef,\n-                                  _modifier: &'v TraitBoundModifier)\n+                                  _modifier: TraitBoundModifier)\n     where V: Visitor<'v>\n {\n     walk_list!(visitor, visit_lifetime_def, &trait_ref.bound_lifetimes);\n@@ -566,8 +566,11 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             visitor.visit_ty(ty);\n             visitor.visit_nested_body(length)\n         }\n-        TyTraitObject(ref bounds) => {\n-            walk_list!(visitor, visit_ty_param_bound, bounds);\n+        TyTraitObject(ref bounds, ref lifetime) => {\n+            for bound in bounds {\n+                visitor.visit_poly_trait_ref(bound, TraitBoundModifier::None);\n+            }\n+            visitor.visit_lifetime(lifetime);\n         }\n         TyImplTrait(ref bounds) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n@@ -695,7 +698,7 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v\n \n pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v TyParamBound) {\n     match *bound {\n-        TraitTyParamBound(ref typ, ref modifier) => {\n+        TraitTyParamBound(ref typ, modifier) => {\n             visitor.visit_poly_trait_ref(typ, modifier);\n         }\n         RegionTyParamBound(ref lifetime) => {"}, {"sha": "8a4acb3d03880b57acd47ec2c2885892f71afe89", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1", "patch": "@@ -360,7 +360,23 @@ impl<'a> LoweringContext<'a> {\n                     hir::TyTypeof(self.record_body(expr, None))\n                 }\n                 TyKind::TraitObject(ref bounds) => {\n-                    hir::TyTraitObject(self.lower_bounds(bounds))\n+                    let mut lifetime_bound = None;\n+                    let bounds = bounds.iter().filter_map(|bound| {\n+                        match *bound {\n+                            TraitTyParamBound(ref ty, TraitBoundModifier::None) => {\n+                                Some(self.lower_poly_trait_ref(ty))\n+                            }\n+                            TraitTyParamBound(_, TraitBoundModifier::Maybe) => None,\n+                            RegionTyParamBound(ref lifetime) => {\n+                                lifetime_bound = Some(self.lower_lifetime(lifetime));\n+                                None\n+                            }\n+                        }\n+                    }).collect();\n+                    let lifetime_bound = lifetime_bound.unwrap_or_else(|| {\n+                        self.elided_lifetime(t.span)\n+                    });\n+                    hir::TyTraitObject(bounds, lifetime_bound)\n                 }\n                 TyKind::ImplTrait(ref bounds) => {\n                     hir::TyImplTrait(self.lower_bounds(bounds))\n@@ -2361,20 +2377,20 @@ impl<'a> LoweringContext<'a> {\n             hir::QPath::Resolved(None, path) => {\n                 // Turn trait object paths into `TyTraitObject` instead.\n                 if let Def::Trait(_) = path.def {\n-                    let principal = hir::TraitTyParamBound(hir::PolyTraitRef {\n+                    let principal = hir::PolyTraitRef {\n                         bound_lifetimes: hir_vec![],\n                         trait_ref: hir::TraitRef {\n                             path: path.and_then(|path| path),\n                             ref_id: id,\n                         },\n                         span,\n-                    }, hir::TraitBoundModifier::None);\n+                    };\n \n                     // The original ID is taken by the `PolyTraitRef`,\n                     // so the `Ty` itself needs a different one.\n                     id = self.next_id();\n \n-                    hir::TyTraitObject(hir_vec![principal])\n+                    hir::TyTraitObject(hir_vec![principal], self.elided_lifetime(span))\n                 } else {\n                     hir::TyPath(hir::QPath::Resolved(None, path))\n                 }"}, {"sha": "4ebe416e1bfe67c12300b0b9b7d6a62cf3b55019", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1", "patch": "@@ -1205,7 +1205,7 @@ pub enum Ty_ {\n     TyPath(QPath),\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n-    TyTraitObject(TyParamBounds),\n+    TyTraitObject(HirVec<PolyTraitRef>, Lifetime),\n     /// An `impl Bound1 + Bound2 + Bound3` type\n     /// where `Bound` is a trait or a lifetime.\n     TyImplTrait(TyParamBounds),"}, {"sha": "e058c48c59149b2995a5d8393e0887423d504e35", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1", "patch": "@@ -416,8 +416,21 @@ impl<'a> State<'a> {\n             hir::TyPath(ref qpath) => {\n                 self.print_qpath(qpath, false)?\n             }\n-            hir::TyTraitObject(ref bounds) => {\n-                self.print_bounds(\"\", &bounds[..])?;\n+            hir::TyTraitObject(ref bounds, ref lifetime) => {\n+                let mut first = true;\n+                for bound in bounds {\n+                    self.nbsp()?;\n+                    if first {\n+                        first = false;\n+                    } else {\n+                        self.word_space(\"+\")?;\n+                    }\n+                    self.print_poly_trait_ref(bound)?;\n+                }\n+                if !lifetime.is_elided() {\n+                    self.word_space(\"+\")?;\n+                    self.print_lifetime(lifetime)?;\n+                }\n             }\n             hir::TyImplTrait(ref bounds) => {\n                 self.print_bounds(\"impl \", &bounds[..])?;"}, {"sha": "88da47c2f0c449873b07a424ce68a17f511c20d5", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1", "patch": "@@ -322,6 +322,14 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     intravisit::walk_ty(this, ty);\n                 });\n             }\n+            hir::TyTraitObject(ref bounds, ref lifetime) => {\n+                for bound in bounds {\n+                    self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n+                }\n+                if !lifetime.is_elided() {\n+                    self.visit_lifetime(lifetime);\n+                }\n+            }\n             _ => {\n                 intravisit::walk_ty(self, ty)\n             }\n@@ -441,7 +449,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_poly_trait_ref(&mut self,\n                             trait_ref: &'tcx hir::PolyTraitRef,\n-                            _modifier: &'tcx hir::TraitBoundModifier) {\n+                            _modifier: hir::TraitBoundModifier) {\n         debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n \n         if !self.trait_ref_hack || !trait_ref.bound_lifetimes.is_empty() {\n@@ -962,7 +970,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             fn visit_poly_trait_ref(&mut self,\n                                     trait_ref: &hir::PolyTraitRef,\n-                                    modifier: &hir::TraitBoundModifier) {\n+                                    modifier: hir::TraitBoundModifier) {\n                 self.binder_depth += 1;\n                 intravisit::walk_poly_trait_ref(self, trait_ref, modifier);\n                 self.binder_depth -= 1;"}, {"sha": "c7512f2971b33990269ddf68a317f637b6b45eb4", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1", "patch": "@@ -828,7 +828,7 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         visit::walk_ty_param_bound(self, bounds)\n     }\n \n-    fn visit_poly_trait_ref(&mut self, t: &'tcx PolyTraitRef, m: &'tcx TraitBoundModifier) {\n+    fn visit_poly_trait_ref(&mut self, t: &'tcx PolyTraitRef, m: TraitBoundModifier) {\n         debug!(\"visit_poly_trait_ref: st={:?}\", self.st);\n         SawPolyTraitRef.hash(self.st);\n         m.hash(self.st);"}, {"sha": "0933fdfd357cd7e82cccce429b23f57b39a2a7a4", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1", "patch": "@@ -144,6 +144,17 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 });\n             }\n             TyKind::TraitObject(ref bounds) => {\n+                let mut any_lifetime_bounds = false;\n+                for bound in bounds {\n+                    if let RegionTyParamBound(ref lifetime) = *bound {\n+                        if any_lifetime_bounds {\n+                            span_err!(self.session, lifetime.span, E0226,\n+                                      \"only a single explicit lifetime bound is permitted\");\n+                            break;\n+                        }\n+                        any_lifetime_bounds = true;\n+                    }\n+                }\n                 self.no_questions_in_bounds(bounds, \"trait object types\", false);\n             }\n             TyKind::ImplTrait(ref bounds) => {"}, {"sha": "ef871959176af088e534eda9b70c54b451c30392", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1", "patch": "@@ -244,6 +244,7 @@ match 5u32 {\n }\n \n register_diagnostics! {\n+    E0226, // only a single explicit lifetime bound is permitted\n     E0472, // asm! is unsupported on this target\n     E0561, // patterns aren't allowed in function pointer types\n     E0571, // `break` with a value in a non-`loop`-loop"}, {"sha": "5c71947c2077edb113648d0988b57138e15aca58", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 38, "deletions": 129, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1", "patch": "@@ -453,24 +453,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         (self.tcx().mk_ty(ty::TyTuple(inputs)), output_binding)\n     }\n \n-    pub fn instantiate_poly_trait_ref(&self,\n-        rscope: &RegionScope,\n-        ast_trait_ref: &hir::PolyTraitRef,\n-        self_ty: Ty<'tcx>,\n-        poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n-        -> ty::PolyTraitRef<'tcx>\n-    {\n-        let trait_ref = &ast_trait_ref.trait_ref;\n-        let trait_def_id = self.trait_def_id(trait_ref);\n-        self.ast_path_to_poly_trait_ref(rscope,\n-                                        trait_ref.path.span,\n-                                        trait_def_id,\n-                                        self_ty,\n-                                        trait_ref.ref_id,\n-                                        trait_ref.path.segments.last().unwrap(),\n-                                        poly_projections)\n-    }\n-\n     /// Instantiates the path for the given trait reference, assuming that it's\n     /// bound to a valid trait type. Returns the def_id for the defining trait.\n     /// Fails if the type is a type other than a trait type.\n@@ -505,17 +487,17 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    fn ast_path_to_poly_trait_ref(&self,\n+    pub fn instantiate_poly_trait_ref(&self,\n         rscope: &RegionScope,\n-        span: Span,\n-        trait_def_id: DefId,\n+        ast_trait_ref: &hir::PolyTraitRef,\n         self_ty: Ty<'tcx>,\n-        path_id: ast::NodeId,\n-        trait_segment: &hir::PathSegment,\n         poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n         -> ty::PolyTraitRef<'tcx>\n     {\n-        debug!(\"ast_path_to_poly_trait_ref(trait_segment={:?})\", trait_segment);\n+        let trait_ref = &ast_trait_ref.trait_ref;\n+        let trait_def_id = self.trait_def_id(trait_ref);\n+\n+        debug!(\"ast_path_to_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n         // The trait reference introduces a binding level here, so\n         // we need to shift the `rscope`. It'd be nice if we could\n         // do away with this rscope stuff and work this knowledge\n@@ -525,23 +507,23 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let (substs, assoc_bindings) =\n             self.create_substs_for_ast_trait_ref(shifted_rscope,\n-                                                 span,\n+                                                 trait_ref.path.span,\n                                                  trait_def_id,\n                                                  self_ty,\n-                                                 trait_segment);\n+                                                 trait_ref.path.segments.last().unwrap());\n         let poly_trait_ref = ty::Binder(ty::TraitRef::new(trait_def_id, substs));\n \n         poly_projections.extend(assoc_bindings.iter().filter_map(|binding| {\n             // specify type to assert that error was already reported in Err case:\n             let predicate: Result<_, ErrorReported> =\n-                self.ast_type_binding_to_poly_projection_predicate(path_id,\n+                self.ast_type_binding_to_poly_projection_predicate(trait_ref.ref_id,\n                                                                    poly_trait_ref,\n                                                                    binding);\n             predicate.ok() // ok to ignore Err() because ErrorReported (see above)\n         }));\n \n-        debug!(\"ast_path_to_poly_trait_ref(trait_segment={:?}, projections={:?}) -> {:?}\",\n-               trait_segment, poly_projections, poly_trait_ref);\n+        debug!(\"ast_path_to_poly_trait_ref({:?}, projections={:?}) -> {:?}\",\n+               trait_ref, poly_projections, poly_trait_ref);\n         poly_trait_ref\n     }\n \n@@ -754,32 +736,29 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         ty::ExistentialTraitRef::erase_self_ty(self.tcx(), trait_ref)\n     }\n \n-    fn trait_path_to_object_type(&self,\n-                                 rscope: &RegionScope,\n-                                 path_span: Span,\n-                                 trait_def_id: DefId,\n-                                 trait_path_ref_id: ast::NodeId,\n-                                 trait_segment: &hir::PathSegment,\n-                                 span: Span,\n-                                 partitioned_bounds: PartitionedBounds)\n-                                 -> Ty<'tcx> {\n+    fn conv_object_ty_poly_trait_ref(&self,\n+        rscope: &RegionScope,\n+        span: Span,\n+        trait_bounds: &[hir::PolyTraitRef],\n+        lifetime: &hir::Lifetime)\n+        -> Ty<'tcx>\n+    {\n         let tcx = self.tcx();\n \n+        if trait_bounds.is_empty() {\n+            span_err!(tcx.sess, span, E0224,\n+                      \"at least one non-builtin trait is required for an object type\");\n+            return tcx.types.err;\n+        }\n+\n         let mut projection_bounds = vec![];\n         let dummy_self = tcx.mk_ty(TRAIT_OBJECT_DUMMY_SELF);\n-        let principal = self.ast_path_to_poly_trait_ref(rscope,\n-                                                        path_span,\n-                                                        trait_def_id,\n+        let principal = self.instantiate_poly_trait_ref(rscope,\n+                                                        &trait_bounds[0],\n                                                         dummy_self,\n-                                                        trait_path_ref_id,\n-                                                        trait_segment,\n                                                         &mut projection_bounds);\n \n-        let PartitionedBounds { trait_bounds,\n-                                region_bounds } =\n-            partitioned_bounds;\n-\n-        let (auto_traits, trait_bounds) = split_auto_traits(tcx, trait_bounds);\n+        let (auto_traits, trait_bounds) = split_auto_traits(tcx, &trait_bounds[1..]);\n \n         if !trait_bounds.is_empty() {\n             let b = &trait_bounds[0];\n@@ -854,13 +833,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         v.sort_by(|a, b| a.cmp(tcx, b));\n         let existential_predicates = ty::Binder(tcx.mk_existential_predicates(v.into_iter()));\n \n-        let region_bound = self.compute_object_lifetime_bound(span,\n-                                                              &region_bounds,\n-                                                              existential_predicates);\n \n-        let region_bound = match region_bound {\n-            Some(r) => r,\n-            None => {\n+        // Explicitly specified region bound. Use that.\n+        let region_bound = if !lifetime.is_elided() {\n+            self.ast_region_to_region(lifetime, None)\n+        } else {\n+            self.compute_object_lifetime_bound(span, existential_predicates).unwrap_or_else(|| {\n                 tcx.mk_region(match rscope.object_lifetime_default(span) {\n                     Some(r) => r,\n                     None => {\n@@ -870,7 +848,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         ty::ReStatic\n                     }\n                 })\n-            }\n+            })\n         };\n \n         debug!(\"region_bound: {:?}\", region_bound);\n@@ -1330,8 +1308,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 }\n                 tcx.mk_fn_ptr(bare_fn_ty)\n             }\n-            hir::TyTraitObject(ref bounds) => {\n-                self.conv_object_ty_poly_trait_ref(rscope, ast_ty.span, bounds)\n+            hir::TyTraitObject(ref bounds, ref lifetime) => {\n+                self.conv_object_ty_poly_trait_ref(rscope, ast_ty.span, bounds, lifetime)\n             }\n             hir::TyImplTrait(ref bounds) => {\n                 use collect::{compute_bounds, SizedByDefault};\n@@ -1537,61 +1515,21 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    fn conv_object_ty_poly_trait_ref(&self,\n-        rscope: &RegionScope,\n-        span: Span,\n-        ast_bounds: &[hir::TyParamBound])\n-        -> Ty<'tcx>\n-    {\n-        let mut partitioned_bounds = partition_bounds(ast_bounds);\n-\n-        let trait_bound = if !partitioned_bounds.trait_bounds.is_empty() {\n-            partitioned_bounds.trait_bounds.remove(0)\n-        } else {\n-            span_err!(self.tcx().sess, span, E0224,\n-                      \"at least one non-builtin trait is required for an object type\");\n-            return self.tcx().types.err;\n-        };\n-\n-        let trait_ref = &trait_bound.trait_ref;\n-        let trait_def_id = self.trait_def_id(trait_ref);\n-        self.trait_path_to_object_type(rscope,\n-                                       trait_ref.path.span,\n-                                       trait_def_id,\n-                                       trait_ref.ref_id,\n-                                       trait_ref.path.segments.last().unwrap(),\n-                                       span,\n-                                       partitioned_bounds)\n-    }\n-\n     /// Given the bounds on an object, determines what single region bound (if any) we can\n     /// use to summarize this type. The basic idea is that we will use the bound the user\n     /// provided, if they provided one, and otherwise search the supertypes of trait bounds\n     /// for region bounds. It may be that we can derive no bound at all, in which case\n     /// we return `None`.\n     fn compute_object_lifetime_bound(&self,\n         span: Span,\n-        explicit_region_bounds: &[&hir::Lifetime],\n         existential_predicates: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>)\n         -> Option<&'tcx ty::Region> // if None, use the default\n     {\n         let tcx = self.tcx();\n \n-        debug!(\"compute_opt_region_bound(explicit_region_bounds={:?}, \\\n-               existential_predicates={:?})\",\n-               explicit_region_bounds,\n+        debug!(\"compute_opt_region_bound(existential_predicates={:?})\",\n                existential_predicates);\n \n-        if explicit_region_bounds.len() > 1 {\n-            span_err!(tcx.sess, explicit_region_bounds[1].span, E0226,\n-                \"only a single explicit lifetime bound is permitted\");\n-        }\n-\n-        if let Some(&r) = explicit_region_bounds.get(0) {\n-            // Explicitly specified region bound. Use that.\n-            return Some(self.ast_region_to_region(r, None));\n-        }\n-\n         if let Some(principal) = existential_predicates.principal() {\n             if let Err(ErrorReported) = self.ensure_super_predicates(span, principal.def_id()) {\n                 return Some(tcx.mk_region(ty::ReStatic));\n@@ -1627,18 +1565,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n }\n \n-pub struct PartitionedBounds<'a> {\n-    pub trait_bounds: Vec<&'a hir::PolyTraitRef>,\n-    pub region_bounds: Vec<&'a hir::Lifetime>,\n-}\n-\n /// Divides a list of general trait bounds into two groups: builtin bounds (Sync/Send) and the\n /// remaining general trait bounds.\n fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                         trait_bounds: Vec<&'b hir::PolyTraitRef>)\n+                                         trait_bounds: &'b [hir::PolyTraitRef])\n     -> (Vec<DefId>, Vec<&'b hir::PolyTraitRef>)\n {\n-    let (auto_traits, trait_bounds): (Vec<_>, _) = trait_bounds.into_iter().partition(|bound| {\n+    let (auto_traits, trait_bounds): (Vec<_>, _) = trait_bounds.iter().partition(|bound| {\n         match bound.trait_ref.path.def {\n             Def::Trait(trait_did) => {\n                 // Checks whether `trait_did` refers to one of the builtin\n@@ -1675,30 +1608,6 @@ fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     (auto_traits, trait_bounds)\n }\n \n-/// Divides a list of bounds from the AST into two groups: general trait bounds and region bounds\n-pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(ast_bounds: &'b [hir::TyParamBound])\n-    -> PartitionedBounds<'b>\n-{\n-    let mut region_bounds = Vec::new();\n-    let mut trait_bounds = Vec::new();\n-    for ast_bound in ast_bounds {\n-        match *ast_bound {\n-            hir::TraitTyParamBound(ref b, hir::TraitBoundModifier::None) => {\n-                trait_bounds.push(b);\n-            }\n-            hir::TraitTyParamBound(_, hir::TraitBoundModifier::Maybe) => {}\n-            hir::RegionTyParamBound(ref l) => {\n-                region_bounds.push(l);\n-            }\n-        }\n-    }\n-\n-    PartitionedBounds {\n-        trait_bounds: trait_bounds,\n-        region_bounds: region_bounds,\n-    }\n-}\n-\n fn check_type_argument_count(tcx: TyCtxt, span: Span, supplied: usize,\n                              ty_param_defs: &[ty::TypeParameterDef]) {\n     let accepted = ty_param_defs.len();"}, {"sha": "90e2f821b10b5fec78011a0b1fc3b51bd4599663", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1", "patch": "@@ -57,7 +57,7 @@ There are some shortcomings in this design:\n \n */\n \n-use astconv::{AstConv, Bounds, PartitionedBounds, partition_bounds};\n+use astconv::{AstConv, Bounds};\n use lint;\n use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n@@ -1961,10 +1961,19 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n                                         span: Span)\n                                         -> Bounds<'tcx>\n {\n-    let PartitionedBounds {\n-        trait_bounds,\n-        region_bounds\n-    } = partition_bounds(&ast_bounds);\n+    let mut region_bounds = vec![];\n+    let mut trait_bounds = vec![];\n+    for ast_bound in ast_bounds {\n+        match *ast_bound {\n+            hir::TraitTyParamBound(ref b, hir::TraitBoundModifier::None) => {\n+                trait_bounds.push(b);\n+            }\n+            hir::TraitTyParamBound(_, hir::TraitBoundModifier::Maybe) => {}\n+            hir::RegionTyParamBound(ref l) => {\n+                region_bounds.push(l);\n+            }\n+        }\n+    }\n \n     let mut projection_bounds = vec![];\n "}, {"sha": "c41d40b41e42ab53c8a9ca53a780e1766a8bfc82", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1", "patch": "@@ -4096,7 +4096,6 @@ register_diagnostics! {\n //  E0222, // Error code E0045 (variadic function must have C calling\n            // convention) duplicate\n     E0224, // at least one non-builtin train is required for an object type\n-    E0226, // only a single explicit lifetime bound is permitted\n     E0227, // ambiguous lifetime bound, explicit lifetime bound required\n     E0228, // explicit lifetime bound required\n     E0231, // only named substitution parameters are allowed"}, {"sha": "f1ced233dde7b5de27c4539744c6b3db92c7feef", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1", "patch": "@@ -1776,20 +1776,20 @@ impl Clean<Type> for hir::Ty {\n                     trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n                 }\n             }\n-            TyTraitObject(ref bounds) => {\n-                let lhs_ty = bounds[0].clean(cx);\n-                match lhs_ty {\n-                    TraitBound(poly_trait, ..) => {\n-                        match poly_trait.trait_ {\n-                            ResolvedPath { path, typarams: None, did, is_generic } => {\n-                                ResolvedPath {\n-                                    path: path,\n-                                    typarams: Some(bounds[1..].clean(cx)),\n-                                    did: did,\n-                                    is_generic: is_generic,\n-                                }\n-                            }\n-                            _ => Infer // shouldn't happen\n+            TyTraitObject(ref bounds, ref lifetime) => {\n+                match bounds[0].clean(cx).trait_ {\n+                    ResolvedPath { path, typarams: None, did, is_generic } => {\n+                        let mut bounds: Vec<_> = bounds[1..].iter().map(|bound| {\n+                            TraitBound(bound.clean(cx), hir::TraitBoundModifier::None)\n+                        }).collect();\n+                        if !lifetime.is_elided() {\n+                            bounds.push(RegionBound(lifetime.clean(cx)));\n+                        }\n+                        ResolvedPath {\n+                            path: path,\n+                            typarams: Some(bounds),\n+                            did: did,\n+                            is_generic: is_generic,\n                         }\n                     }\n                     _ => Infer // shouldn't happen"}, {"sha": "503b577b1f1b4f3530392c3a714a14d800d69a31", "filename": "src/test/compile-fail/region-bounds-on-objects-and-type-parameters.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs?ref=c5befdc6308f8624b4b5fa8808ba0af70d2fbcf1", "patch": "@@ -18,7 +18,7 @@ trait SomeTrait { }\n \n // Bounds on object types:\n \n-struct Foo<'a,'b,'c> {\n+struct Foo<'a,'b,'c> { //~ ERROR parameter `'b` is never used\n     // All of these are ok, because we can derive exactly one bound:\n     a: Box<IsStatic>,\n     b: Box<Is<'static>>,\n@@ -28,7 +28,9 @@ struct Foo<'a,'b,'c> {\n     f: Box<SomeTrait>,   // OK, defaults to 'static due to RFC 599.\n     g: Box<SomeTrait+'a>,\n \n-    z: Box<Is<'a>+'b+'c>, //~ ERROR only a single explicit lifetime bound is permitted\n+    z: Box<Is<'a>+'b+'c>,\n+    //~^ ERROR only a single explicit lifetime bound is permitted\n+    //~| ERROR lifetime bound not satisfied\n }\n \n fn test<"}]}