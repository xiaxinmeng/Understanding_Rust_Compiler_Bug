{"sha": "bc234ae1307f6c1ff72782a82b8222691bf67525", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMjM0YWUxMzA3ZjZjMWZmNzI3ODJhODJiODIyMjY5MWJmNjc1MjU=", "commit": {"author": {"name": "Tobba", "email": "tobias.haegermarck@gmail.com", "date": "2014-04-07T23:08:49Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-08T07:03:11Z"}, "message": "Made libflate functions return Options instead of outright failing", "tree": {"sha": "f215e6ba4bbd031c468a620ba5eb64a9e6a70cf2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f215e6ba4bbd031c468a620ba5eb64a9e6a70cf2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc234ae1307f6c1ff72782a82b8222691bf67525", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc234ae1307f6c1ff72782a82b8222691bf67525", "html_url": "https://github.com/rust-lang/rust/commit/bc234ae1307f6c1ff72782a82b8222691bf67525", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc234ae1307f6c1ff72782a82b8222691bf67525/comments", "author": {"login": "Tobba", "id": 1667853, "node_id": "MDQ6VXNlcjE2Njc4NTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1667853?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Tobba", "html_url": "https://github.com/Tobba", "followers_url": "https://api.github.com/users/Tobba/followers", "following_url": "https://api.github.com/users/Tobba/following{/other_user}", "gists_url": "https://api.github.com/users/Tobba/gists{/gist_id}", "starred_url": "https://api.github.com/users/Tobba/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Tobba/subscriptions", "organizations_url": "https://api.github.com/users/Tobba/orgs", "repos_url": "https://api.github.com/users/Tobba/repos", "events_url": "https://api.github.com/users/Tobba/events{/privacy}", "received_events_url": "https://api.github.com/users/Tobba/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc49018679e75e8641c8a8bb295075ec5f247d99", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc49018679e75e8641c8a8bb295075ec5f247d99", "html_url": "https://github.com/rust-lang/rust/commit/dc49018679e75e8641c8a8bb295075ec5f247d99"}], "stats": {"total": 60, "additions": 39, "deletions": 21}, "files": [{"sha": "753a3120c21575ac2773b47c4c18cb463c913925", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bc234ae1307f6c1ff72782a82b8222691bf67525/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc234ae1307f6c1ff72782a82b8222691bf67525/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=bc234ae1307f6c1ff72782a82b8222691bf67525", "patch": "@@ -54,43 +54,49 @@ static LZ_NORM : c_int = 0x80;  // LZ with 128 probes, \"normal\"\n static TINFL_FLAG_PARSE_ZLIB_HEADER : c_int = 0x1; // parse zlib header and adler32 checksum\n static TDEFL_WRITE_ZLIB_HEADER : c_int = 0x01000; // write zlib header and adler32 checksum\n \n-fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> CVec<u8> {\n+fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n     unsafe {\n         let mut outsz : size_t = 0;\n         let res = rustrt::tdefl_compress_mem_to_heap(bytes.as_ptr() as *c_void,\n                                                      bytes.len() as size_t,\n                                                      &mut outsz,\n                                                      flags);\n-        assert!(!res.is_null());\n-        CVec::new_with_dtor(res as *mut u8, outsz as uint, proc() libc::free(res))\n+        if !res.is_null() {\n+            Some(CVec::new_with_dtor(res as *mut u8, outsz as uint, proc() libc::free(res)))\n+        } else {\n+            None\n+        }\n     }\n }\n \n-pub fn deflate_bytes(bytes: &[u8]) -> CVec<u8> {\n+pub fn deflate_bytes(bytes: &[u8]) -> Option<CVec<u8>> {\n     deflate_bytes_internal(bytes, LZ_NORM)\n }\n \n-pub fn deflate_bytes_zlib(bytes: &[u8]) -> CVec<u8> {\n+pub fn deflate_bytes_zlib(bytes: &[u8]) -> Option<CVec<u8>> {\n     deflate_bytes_internal(bytes, LZ_NORM | TDEFL_WRITE_ZLIB_HEADER)\n }\n \n-fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> CVec<u8> {\n+fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n     unsafe {\n         let mut outsz : size_t = 0;\n         let res = rustrt::tinfl_decompress_mem_to_heap(bytes.as_ptr() as *c_void,\n                                                        bytes.len() as size_t,\n                                                        &mut outsz,\n                                                        flags);\n-        assert!(!res.is_null());\n-        CVec::new_with_dtor(res as *mut u8, outsz as uint, proc() libc::free(res))\n+        if !res.is_null() {\n+            Some(CVec::new_with_dtor(res as *mut u8, outsz as uint, proc() libc::free(res)))\n+        } else {\n+            None\n+        }\n     }\n }\n \n-pub fn inflate_bytes(bytes: &[u8]) -> CVec<u8> {\n+pub fn inflate_bytes(bytes: &[u8]) -> Option<CVec<u8>> {\n     inflate_bytes_internal(bytes, 0)\n }\n \n-pub fn inflate_bytes_zlib(bytes: &[u8]) -> CVec<u8> {\n+pub fn inflate_bytes_zlib(bytes: &[u8]) -> Option<CVec<u8>> {\n     inflate_bytes_internal(bytes, TINFL_FLAG_PARSE_ZLIB_HEADER)\n }\n \n@@ -117,8 +123,8 @@ mod tests {\n             }\n             debug!(\"de/inflate of {} bytes of random word-sequences\",\n                    input.len());\n-            let cmp = deflate_bytes(input);\n-            let out = inflate_bytes(cmp.as_slice());\n+            let cmp = deflate_bytes(input).expect(\"deflation failed\");\n+            let out = inflate_bytes(cmp.as_slice()).expect(\"inflation failed\");\n             debug!(\"{} bytes deflated to {} ({:.1f}% size)\",\n                    input.len(), cmp.len(),\n                    100.0 * ((cmp.len() as f64) / (input.len() as f64)));\n@@ -129,8 +135,8 @@ mod tests {\n     #[test]\n     fn test_zlib_flate() {\n         let bytes = vec!(1, 2, 3, 4, 5);\n-        let deflated = deflate_bytes(bytes.as_slice());\n-        let inflated = inflate_bytes(deflated.as_slice());\n+        let deflated = deflate_bytes(bytes.as_slice()).expect(\"deflation failed\");\n+        let inflated = inflate_bytes(deflated.as_slice()).expect(\"inflation failed\");\n         assert_eq!(inflated.as_slice(), bytes.as_slice());\n     }\n }"}, {"sha": "0946e375e4f7fc527232b1385b2469f5023e015a", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bc234ae1307f6c1ff72782a82b8222691bf67525/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc234ae1307f6c1ff72782a82b8222691bf67525/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=bc234ae1307f6c1ff72782a82b8222691bf67525", "patch": "@@ -945,11 +945,14 @@ fn link_rlib<'a>(sess: &'a Session,\n             let bc_deflated = obj_filename.with_extension(\"bc.deflate\");\n             match fs::File::open(&bc).read_to_end().and_then(|data| {\n                 fs::File::create(&bc_deflated)\n-                    .write(flate::deflate_bytes(data.as_slice()).as_slice())\n+                    .write(match flate::deflate_bytes(data.as_slice()) {\n+                        Some(compressed) => compressed,\n+                        None => sess.fatal(\"failed to compress bytecode\")\n+                     }.as_slice())\n             }) {\n                 Ok(()) => {}\n                 Err(e) => {\n-                    sess.err(format!(\"failed to compress bytecode: {}\", e));\n+                    sess.err(format!(\"failed to write compressed bytecode: {}\", e));\n                     sess.abort_if_errors()\n                 }\n             }"}, {"sha": "8319be02bdbc301705f2ea27564861e38be78715", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc234ae1307f6c1ff72782a82b8222691bf67525/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc234ae1307f6c1ff72782a82b8222691bf67525/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=bc234ae1307f6c1ff72782a82b8222691bf67525", "patch": "@@ -56,7 +56,10 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                       archive.read(format!(\"{}.bc.deflate\", name)));\n         let bc = bc.expect(\"missing compressed bytecode in archive!\");\n         let bc = time(sess.time_passes(), format!(\"inflate {}.bc\", name), (), |_|\n-                      flate::inflate_bytes(bc));\n+                      match flate::inflate_bytes(bc) {\n+                          Some(bc) => bc,\n+                          None => sess.fatal(format!(\"failed to decompress bc of `{}`\", name))\n+                      });\n         let ptr = bc.as_slice().as_ptr();\n         debug!(\"linking {}\", name);\n         time(sess.time_passes(), format!(\"ll link {}\", name), (), |()| unsafe {"}, {"sha": "8dea36d8152a26bbb122d147cf9a394c0f1bef1f", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bc234ae1307f6c1ff72782a82b8222691bf67525/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc234ae1307f6c1ff72782a82b8222691bf67525/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=bc234ae1307f6c1ff72782a82b8222691bf67525", "patch": "@@ -494,14 +494,17 @@ fn get_metadata_section_imp(os: Os, filename: &Path) -> Result<MetadataBlob, ~st\n                 let version_ok = slice::raw::buf_as_slice(cvbuf, minsz,\n                     |buf0| buf0 == encoder::metadata_encoding_version);\n                 if !version_ok { return Err(format!(\"incompatible metadata version found: '{}'\",\n-                                                    filename.display()));}\n+                                                    filename.display())); }\n \n                 let cvbuf1 = cvbuf.offset(vlen as int);\n                 debug!(\"inflating {} bytes of compressed metadata\",\n                        csz - vlen);\n                 slice::raw::buf_as_slice(cvbuf1, csz-vlen, |bytes| {\n-                    let inflated = flate::inflate_bytes(bytes);\n-                    found = Ok(MetadataVec(inflated));\n+                    match flate::inflate_bytes(bytes) {\n+                        Some(inflated) => found = Ok(MetadataVec(inflated)),\n+                        None => found = Err(format!(\"failed to decompress metadata for: '{}'\",\n+                                                    filename.display()))\n+                    }\n                 });\n                 if found.is_ok() {\n                     return found;"}, {"sha": "58edb717bf0bda87f0440616028e0685a88bdfb3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc234ae1307f6c1ff72782a82b8222691bf67525/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc234ae1307f6c1ff72782a82b8222691bf67525/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=bc234ae1307f6c1ff72782a82b8222691bf67525", "patch": "@@ -2236,7 +2236,10 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let metadata = encoder::encode_metadata(encode_parms, krate);\n     let compressed = encoder::metadata_encoding_version +\n-                        flate::deflate_bytes(metadata.as_slice()).as_slice();\n+                        match flate::deflate_bytes(metadata.as_slice()) {\n+                            Some(compressed) => compressed,\n+                            None => cx.sess().fatal(format!(\"failed to compress metadata\", ))\n+                        }.as_slice();\n     let llmeta = C_bytes(cx, compressed);\n     let llconst = C_struct(cx, [llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}_{}\", cx.link_meta.crateid.name,"}]}