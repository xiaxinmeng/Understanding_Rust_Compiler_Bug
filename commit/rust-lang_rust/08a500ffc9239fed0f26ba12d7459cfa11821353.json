{"sha": "08a500ffc9239fed0f26ba12d7459cfa11821353", "node_id": "C_kwDOAAsO6NoAKDA4YTUwMGZmYzkyMzlmZWQwZjI2YmExMmQ3NDU5Y2ZhMTE4MjEzNTM", "commit": {"author": {"name": "name1e5s", "email": "name1e5s@qq.com", "date": "2021-11-23T05:40:19Z"}, "committer": {"name": "name1e5s", "email": "name1e5s@qq.com", "date": "2021-11-23T05:57:22Z"}, "message": "fix test in std::process on android", "tree": {"sha": "898a095772ee2a5591ed0ce862b5953ed3aa8bb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/898a095772ee2a5591ed0ce862b5953ed3aa8bb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08a500ffc9239fed0f26ba12d7459cfa11821353", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08a500ffc9239fed0f26ba12d7459cfa11821353", "html_url": "https://github.com/rust-lang/rust/commit/08a500ffc9239fed0f26ba12d7459cfa11821353", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08a500ffc9239fed0f26ba12d7459cfa11821353/comments", "author": {"login": "name1e5s", "id": 15176913, "node_id": "MDQ6VXNlcjE1MTc2OTEz", "avatar_url": "https://avatars.githubusercontent.com/u/15176913?v=4", "gravatar_id": "", "url": "https://api.github.com/users/name1e5s", "html_url": "https://github.com/name1e5s", "followers_url": "https://api.github.com/users/name1e5s/followers", "following_url": "https://api.github.com/users/name1e5s/following{/other_user}", "gists_url": "https://api.github.com/users/name1e5s/gists{/gist_id}", "starred_url": "https://api.github.com/users/name1e5s/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/name1e5s/subscriptions", "organizations_url": "https://api.github.com/users/name1e5s/orgs", "repos_url": "https://api.github.com/users/name1e5s/repos", "events_url": "https://api.github.com/users/name1e5s/events{/privacy}", "received_events_url": "https://api.github.com/users/name1e5s/received_events", "type": "User", "site_admin": false}, "committer": {"login": "name1e5s", "id": 15176913, "node_id": "MDQ6VXNlcjE1MTc2OTEz", "avatar_url": "https://avatars.githubusercontent.com/u/15176913?v=4", "gravatar_id": "", "url": "https://api.github.com/users/name1e5s", "html_url": "https://github.com/name1e5s", "followers_url": "https://api.github.com/users/name1e5s/followers", "following_url": "https://api.github.com/users/name1e5s/following{/other_user}", "gists_url": "https://api.github.com/users/name1e5s/gists{/gist_id}", "starred_url": "https://api.github.com/users/name1e5s/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/name1e5s/subscriptions", "organizations_url": "https://api.github.com/users/name1e5s/orgs", "repos_url": "https://api.github.com/users/name1e5s/repos", "events_url": "https://api.github.com/users/name1e5s/events{/privacy}", "received_events_url": "https://api.github.com/users/name1e5s/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d0c79d26995a973c6f33c32ffb0c827d78bb213", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d0c79d26995a973c6f33c32ffb0c827d78bb213", "html_url": "https://github.com/rust-lang/rust/commit/8d0c79d26995a973c6f33c32ffb0c827d78bb213"}], "stats": {"total": 64, "additions": 36, "deletions": 28}, "files": [{"sha": "67b747e410732952bb333e1f6ed0a4b39385d963", "filename": "library/std/src/process/tests.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/08a500ffc9239fed0f26ba12d7459cfa11821353/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a500ffc9239fed0f26ba12d7459cfa11821353/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs?ref=08a500ffc9239fed0f26ba12d7459cfa11821353", "patch": "@@ -4,15 +4,23 @@ use super::{Command, Output, Stdio};\n use crate::io::ErrorKind;\n use crate::str;\n \n-// FIXME(#10380) these tests should not all be ignored on android.\n+#[cfg(target_os = \"android\")]\n+fn shell_cmd() -> Command {\n+    Command::new(\"/system/bin/sh\")\n+}\n+\n+#[cfg(not(target_os = \"android\"))]\n+fn shell_cmd() -> Command {\n+    Command::new(\"/bin/sh\")\n+}\n \n #[test]\n-#[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n+#[cfg_attr(any(target_os = \"vxworks\"), ignore)]\n fn smoke() {\n     let p = if cfg!(target_os = \"windows\") {\n         Command::new(\"cmd\").args(&[\"/C\", \"exit 0\"]).spawn()\n     } else {\n-        Command::new(\"true\").spawn()\n+        shell_cmd().arg(\"-c\").arg(\"true\").spawn()\n     };\n     assert!(p.is_ok());\n     let mut p = p.unwrap();\n@@ -29,12 +37,12 @@ fn smoke_failure() {\n }\n \n #[test]\n-#[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n+#[cfg_attr(any(target_os = \"vxworks\"), ignore)]\n fn exit_reported_right() {\n     let p = if cfg!(target_os = \"windows\") {\n         Command::new(\"cmd\").args(&[\"/C\", \"exit 1\"]).spawn()\n     } else {\n-        Command::new(\"false\").spawn()\n+        shell_cmd().arg(\"-c\").arg(\"false\").spawn()\n     };\n     assert!(p.is_ok());\n     let mut p = p.unwrap();\n@@ -44,12 +52,11 @@ fn exit_reported_right() {\n \n #[test]\n #[cfg(unix)]\n-#[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n+#[cfg_attr(any(target_os = \"vxworks\"), ignore)]\n fn signal_reported_right() {\n     use crate::os::unix::process::ExitStatusExt;\n \n-    let mut p =\n-        Command::new(\"/bin/sh\").arg(\"-c\").arg(\"read a\").stdin(Stdio::piped()).spawn().unwrap();\n+    let mut p = shell_cmd().arg(\"-c\").arg(\"read a\").stdin(Stdio::piped()).spawn().unwrap();\n     p.kill().unwrap();\n     match p.wait().unwrap().signal() {\n         Some(9) => {}\n@@ -69,31 +76,31 @@ pub fn run_output(mut cmd: Command) -> String {\n }\n \n #[test]\n-#[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n+#[cfg_attr(any(target_os = \"vxworks\"), ignore)]\n fn stdout_works() {\n     if cfg!(target_os = \"windows\") {\n         let mut cmd = Command::new(\"cmd\");\n         cmd.args(&[\"/C\", \"echo foobar\"]).stdout(Stdio::piped());\n         assert_eq!(run_output(cmd), \"foobar\\r\\n\");\n     } else {\n-        let mut cmd = Command::new(\"echo\");\n-        cmd.arg(\"foobar\").stdout(Stdio::piped());\n+        let mut cmd = shell_cmd();\n+        cmd.arg(\"-c\").arg(\"echo foobar\").stdout(Stdio::piped());\n         assert_eq!(run_output(cmd), \"foobar\\n\");\n     }\n }\n \n #[test]\n-#[cfg_attr(any(windows, target_os = \"android\", target_os = \"vxworks\"), ignore)]\n+#[cfg_attr(any(windows, target_os = \"vxworks\"), ignore)]\n fn set_current_dir_works() {\n-    let mut cmd = Command::new(\"/bin/sh\");\n+    let mut cmd = shell_cmd();\n     cmd.arg(\"-c\").arg(\"pwd\").current_dir(\"/\").stdout(Stdio::piped());\n     assert_eq!(run_output(cmd), \"/\\n\");\n }\n \n #[test]\n-#[cfg_attr(any(windows, target_os = \"android\", target_os = \"vxworks\"), ignore)]\n+#[cfg_attr(any(windows, target_os = \"vxworks\"), ignore)]\n fn stdin_works() {\n-    let mut p = Command::new(\"/bin/sh\")\n+    let mut p = shell_cmd()\n         .arg(\"-c\")\n         .arg(\"read line; echo $line\")\n         .stdin(Stdio::piped())\n@@ -109,19 +116,19 @@ fn stdin_works() {\n }\n \n #[test]\n-#[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n+#[cfg_attr(any(target_os = \"vxworks\"), ignore)]\n fn test_process_status() {\n     let mut status = if cfg!(target_os = \"windows\") {\n         Command::new(\"cmd\").args(&[\"/C\", \"exit 1\"]).status().unwrap()\n     } else {\n-        Command::new(\"false\").status().unwrap()\n+        shell_cmd().arg(\"-c\").arg(\"false\").status().unwrap()\n     };\n     assert!(status.code() == Some(1));\n \n     status = if cfg!(target_os = \"windows\") {\n         Command::new(\"cmd\").args(&[\"/C\", \"exit 0\"]).status().unwrap()\n     } else {\n-        Command::new(\"true\").status().unwrap()\n+        shell_cmd().arg(\"-c\").arg(\"true\").status().unwrap()\n     };\n     assert!(status.success());\n }\n@@ -135,12 +142,12 @@ fn test_process_output_fail_to_start() {\n }\n \n #[test]\n-#[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n+#[cfg_attr(any(target_os = \"vxworks\"), ignore)]\n fn test_process_output_output() {\n     let Output { status, stdout, stderr } = if cfg!(target_os = \"windows\") {\n         Command::new(\"cmd\").args(&[\"/C\", \"echo hello\"]).output().unwrap()\n     } else {\n-        Command::new(\"echo\").arg(\"hello\").output().unwrap()\n+        shell_cmd().arg(\"-c\").arg(\"echo hello\").output().unwrap()\n     };\n     let output_str = str::from_utf8(&stdout).unwrap();\n \n@@ -150,49 +157,50 @@ fn test_process_output_output() {\n }\n \n #[test]\n-#[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n+#[cfg_attr(any(target_os = \"vxworks\"), ignore)]\n fn test_process_output_error() {\n     let Output { status, stdout, stderr } = if cfg!(target_os = \"windows\") {\n         Command::new(\"cmd\").args(&[\"/C\", \"mkdir .\"]).output().unwrap()\n     } else {\n         Command::new(\"mkdir\").arg(\"./\").output().unwrap()\n     };\n \n-    assert!(status.code() == Some(1));\n+    assert!(status.code().is_some());\n+    assert!(status.code() != Some(0));\n     assert_eq!(stdout, Vec::new());\n     assert!(!stderr.is_empty());\n }\n \n #[test]\n-#[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n+#[cfg_attr(any(target_os = \"vxworks\"), ignore)]\n fn test_finish_once() {\n     let mut prog = if cfg!(target_os = \"windows\") {\n         Command::new(\"cmd\").args(&[\"/C\", \"exit 1\"]).spawn().unwrap()\n     } else {\n-        Command::new(\"false\").spawn().unwrap()\n+        shell_cmd().arg(\"-c\").arg(\"false\").spawn().unwrap()\n     };\n     assert!(prog.wait().unwrap().code() == Some(1));\n }\n \n #[test]\n-#[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n+#[cfg_attr(any(target_os = \"vxworks\"), ignore)]\n fn test_finish_twice() {\n     let mut prog = if cfg!(target_os = \"windows\") {\n         Command::new(\"cmd\").args(&[\"/C\", \"exit 1\"]).spawn().unwrap()\n     } else {\n-        Command::new(\"false\").spawn().unwrap()\n+        shell_cmd().arg(\"-c\").arg(\"false\").spawn().unwrap()\n     };\n     assert!(prog.wait().unwrap().code() == Some(1));\n     assert!(prog.wait().unwrap().code() == Some(1));\n }\n \n #[test]\n-#[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n+#[cfg_attr(any(target_os = \"vxworks\"), ignore)]\n fn test_wait_with_output_once() {\n     let prog = if cfg!(target_os = \"windows\") {\n         Command::new(\"cmd\").args(&[\"/C\", \"echo hello\"]).stdout(Stdio::piped()).spawn().unwrap()\n     } else {\n-        Command::new(\"echo\").arg(\"hello\").stdout(Stdio::piped()).spawn().unwrap()\n+        shell_cmd().arg(\"-c\").arg(\"echo hello\").stdout(Stdio::piped()).spawn().unwrap()\n     };\n \n     let Output { status, stdout, stderr } = prog.wait_with_output().unwrap();"}]}