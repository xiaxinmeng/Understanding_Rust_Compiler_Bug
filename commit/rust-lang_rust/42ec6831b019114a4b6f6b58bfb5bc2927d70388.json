{"sha": "42ec6831b019114a4b6f6b58bfb5bc2927d70388", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyZWM2ODMxYjAxOTExNGE0YjZmNmI1OGJmYjViYzI5MjdkNzAzODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-01T02:31:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-01T02:31:48Z"}, "message": "Auto merge of #64932 - tmandry:rollup-7t8x1nz, r=tmandry\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #64377 (Add long error explanation for E0493)\n - #64786 (Use https for curl when building for linux)\n - #64828 (Graphviz debug output for generic dataflow analysis)\n - #64838 (Add long error explanation for E0550)\n - #64891 (Fix `vec![x; n]` with null raw fat pointer zeroing the pointer metadata)\n - #64893 (Zero-initialize `vec![None; n]` for `Option<&T>`, `Option<&mut T>` and `Option<Box<T>>`)\n - #64911 (Fixed a misleading documentation issue #64844)\n - #64921 (Add test for issue-64662)\n - #64923 (Add missing links for mem::needs_drop)\n\nFailed merges:\n\n - #64918 (Add long error explanation for E0551)\n\nr? @ghost", "tree": {"sha": "be392b01361811cd2585d4e763fd671fce9ac991", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be392b01361811cd2585d4e763fd671fce9ac991"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42ec6831b019114a4b6f6b58bfb5bc2927d70388", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42ec6831b019114a4b6f6b58bfb5bc2927d70388", "html_url": "https://github.com/rust-lang/rust/commit/42ec6831b019114a4b6f6b58bfb5bc2927d70388", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42ec6831b019114a4b6f6b58bfb5bc2927d70388/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22bc9e1d9ca49ee4f5cd953088ab09c238a6dd26", "url": "https://api.github.com/repos/rust-lang/rust/commits/22bc9e1d9ca49ee4f5cd953088ab09c238a6dd26", "html_url": "https://github.com/rust-lang/rust/commit/22bc9e1d9ca49ee4f5cd953088ab09c238a6dd26"}, {"sha": "913c095bcf97177d030e4bde9a45a0bb68873eaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/913c095bcf97177d030e4bde9a45a0bb68873eaf", "html_url": "https://github.com/rust-lang/rust/commit/913c095bcf97177d030e4bde9a45a0bb68873eaf"}], "stats": {"total": 755, "additions": 719, "deletions": 36}, "files": [{"sha": "8200bbe2fdce5d84576795f2ecde89322ca5849e", "filename": "src/ci/docker/dist-x86_64-linux/build-curl.sh", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-curl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-curl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-curl.sh?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -3,9 +3,11 @@\n set -ex\n source shared.sh\n \n-VERSION=7.51.0\n+VERSION=7.66.0\n \n-curl http://cool.haxx.se/download/curl-$VERSION.tar.bz2 | tar xjf -\n+curl https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/curl-$VERSION.tar.xz \\\n+  | xz --decompress \\\n+  | tar xf -\n \n mkdir curl-build\n cd curl-build"}, {"sha": "98d013dfa2b57616889bb8b3150111077fe90fcf", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -1281,3 +1281,51 @@ fn test_stable_push_pop() {\n     v.pop().unwrap();\n     assert_eq!(*v0, 13);\n }\n+\n+// https://github.com/rust-lang/rust/pull/49496 introduced specialization based on:\n+//\n+// ```\n+// unsafe impl<T: ?Sized> IsZero for *mut T {\n+//     fn is_zero(&self) -> bool {\n+//         (*self).is_null()\n+//     }\n+// }\n+// ```\n+//\n+// \u2026 to call `RawVec::with_capacity_zeroed` for creating `Vec<*mut T>`,\n+// which is incorrect for fat pointers since `<*mut T>::is_null` only looks at the data component.\n+// That is, a fat pointer can be \u201cnull\u201d without being made entirely of zero bits.\n+#[test]\n+fn vec_macro_repeating_null_raw_fat_pointer() {\n+    let raw_dyn = &mut (|| ()) as &mut dyn Fn() as *mut dyn Fn();\n+    let vtable = dbg!(ptr_metadata(raw_dyn));\n+    let null_raw_dyn = ptr_from_raw_parts(std::ptr::null_mut(), vtable);\n+    assert!(null_raw_dyn.is_null());\n+\n+    let vec = vec![null_raw_dyn; 1];\n+    dbg!(ptr_metadata(vec[0]));\n+    assert!(vec[0] == null_raw_dyn);\n+\n+    // Polyfill for https://github.com/rust-lang/rfcs/pull/2580\n+\n+    fn ptr_metadata(ptr: *mut dyn Fn()) -> *mut () {\n+        unsafe {\n+            std::mem::transmute::<*mut dyn Fn(), DynRepr>(ptr).vtable\n+        }\n+    }\n+\n+    fn ptr_from_raw_parts(data: *mut (), vtable: *mut()) -> *mut dyn Fn() {\n+        unsafe {\n+            std::mem::transmute::<DynRepr, *mut dyn Fn()>(DynRepr {\n+                data,\n+                vtable\n+            })\n+        }\n+    }\n+\n+    #[repr(C)]\n+    struct DynRepr {\n+        data: *mut (),\n+        vtable: *mut (),\n+    }\n+}"}, {"sha": "7c6ded08bbae9964fb44ce672775826b1fc9c72d", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -1734,20 +1734,45 @@ impl_is_zero!(char, |x| x == '\\0');\n impl_is_zero!(f32, |x: f32| x.to_bits() == 0);\n impl_is_zero!(f64, |x: f64| x.to_bits() == 0);\n \n-unsafe impl<T: ?Sized> IsZero for *const T {\n+unsafe impl<T> IsZero for *const T {\n     #[inline]\n     fn is_zero(&self) -> bool {\n         (*self).is_null()\n     }\n }\n \n-unsafe impl<T: ?Sized> IsZero for *mut T {\n+unsafe impl<T> IsZero for *mut T {\n     #[inline]\n     fn is_zero(&self) -> bool {\n         (*self).is_null()\n     }\n }\n \n+// `Option<&T>`, `Option<&mut T>` and `Option<Box<T>>` are guaranteed to represent `None` as null.\n+// For fat pointers, the bytes that would be the pointer metadata in the `Some` variant\n+// are padding in the `None` variant, so ignoring them and zero-initializing instead is ok.\n+\n+unsafe impl<T: ?Sized> IsZero for Option<&T> {\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        self.is_none()\n+    }\n+}\n+\n+unsafe impl<T: ?Sized> IsZero for Option<&mut T> {\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        self.is_none()\n+    }\n+}\n+\n+unsafe impl<T: ?Sized> IsZero for Option<Box<T>> {\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        self.is_none()\n+    }\n+}\n+\n \n ////////////////////////////////////////////////////////////////////////////////\n // Common trait implementations for Vec"}, {"sha": "95ad4272cedd0568a953edb9d0434cc6490a47dd", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -368,15 +368,17 @@ pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n /// make a difference in release builds (where a loop that has no side-effects\n /// is easily detected and eliminated), but is often a big win for debug builds.\n ///\n-/// Note that `ptr::drop_in_place` already performs this check, so if your workload\n-/// can be reduced to some small number of drop_in_place calls, using this is\n-/// unnecessary. In particular note that you can drop_in_place a slice, and that\n+/// Note that [`drop_in_place`] already performs this check, so if your workload\n+/// can be reduced to some small number of [`drop_in_place`] calls, using this is\n+/// unnecessary. In particular note that you can [`drop_in_place`] a slice, and that\n /// will do a single needs_drop check for all the values.\n ///\n /// Types like Vec therefore just `drop_in_place(&mut self[..])` without using\n-/// needs_drop explicitly. Types like `HashMap`, on the other hand, have to drop\n+/// `needs_drop` explicitly. Types like [`HashMap`], on the other hand, have to drop\n /// values one at a time and should use this API.\n ///\n+/// [`drop_in_place`]: ../ptr/fn.drop_in_place.html\n+/// [`HashMap`]: ../../std/collections/struct.HashMap.html\n ///\n /// # Examples\n ///"}, {"sha": "301e432c98dfc4a3af707cf9e2e87475090803c2", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -46,7 +46,7 @@\n //! # Options and pointers (\"nullable\" pointers)\n //!\n //! Rust's pointer types must always point to a valid location; there are\n-//! no \"null\" pointers. Instead, Rust has *optional* pointers, like\n+//! no \"null\" references. Instead, Rust has *optional* pointers, like\n //! the optional owned box, [`Option`]`<`[`Box<T>`]`>`.\n //!\n //! The following example uses [`Option`] to create an optional box of"}, {"sha": "dd6238b80d1744115ea4615de706806a728afa48", "filename": "src/librustc_mir/dataflow/generic.rs", "status": "modified", "additions": 115, "deletions": 14, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -16,16 +16,24 @@\n //! [gk]: https://en.wikipedia.org/wiki/Data-flow_analysis#Bit_vector_problems\n //! [#64566]: https://github.com/rust-lang/rust/pull/64566\n \n+use std::borrow::Borrow;\n use std::cmp::Ordering;\n-use std::ops;\n+use std::ffi::OsString;\n+use std::path::{Path, PathBuf};\n+use std::{fs, io, ops};\n \n+use rustc::hir::def_id::DefId;\n use rustc::mir::{self, traversal, BasicBlock, Location};\n+use rustc::ty::{self, TyCtxt};\n+use rustc_data_structures::work_queue::WorkQueue;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_data_structures::work_queue::WorkQueue;\n+use syntax::symbol::sym;\n \n use crate::dataflow::BottomValue;\n \n+mod graphviz;\n+\n /// A specific kind of dataflow analysis.\n ///\n /// To run a dataflow analysis, one must set the initial state of the `START_BLOCK` via\n@@ -62,6 +70,13 @@ pub trait Analysis<'tcx>: BottomValue {\n     /// and try to keep it short.\n     const NAME: &'static str;\n \n+    /// How each element of your dataflow state will be displayed during debugging.\n+    ///\n+    /// By default, this is the `fmt::Debug` representation of `Self::Idx`.\n+    fn pretty_print_idx(&self, w: &mut impl io::Write, idx: Self::Idx) -> io::Result<()> {\n+        write!(w, \"{:?}\", idx)\n+    }\n+\n     /// The size of each bitvector allocated for each block.\n     fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize;\n \n@@ -77,7 +92,7 @@ pub trait Analysis<'tcx>: BottomValue {\n         location: Location,\n     );\n \n-    /// Updates the current dataflow state with the effect of evaluating a statement.\n+    /// Updates the current dataflow state with the effect of evaluating a terminator.\n     ///\n     /// Note that the effect of a successful return from a `Call` terminator should **not** be\n     /// acounted for in this function. That should go in `apply_call_return_effect`. For example,\n@@ -180,17 +195,20 @@ impl CursorPosition {\n     }\n }\n \n+type ResultsRefCursor<'a, 'mir, 'tcx, A> =\n+    ResultsCursor<'mir, 'tcx, A, &'a Results<'tcx, A>>;\n+\n /// Inspect the results of dataflow analysis.\n ///\n /// This cursor has linear performance when visiting statements in a block in order. Visiting\n /// statements within a block in reverse order is `O(n^2)`, where `n` is the number of statements\n /// in that block.\n-pub struct ResultsCursor<'mir, 'tcx, A>\n+pub struct ResultsCursor<'mir, 'tcx, A, R = Results<'tcx, A>>\n where\n     A: Analysis<'tcx>,\n {\n     body: &'mir mir::Body<'tcx>,\n-    results: Results<'tcx, A>,\n+    results: R,\n     state: BitSet<A::Idx>,\n \n     pos: CursorPosition,\n@@ -202,24 +220,29 @@ where\n     is_call_return_effect_applied: bool,\n }\n \n-impl<'mir, 'tcx, A> ResultsCursor<'mir, 'tcx, A>\n+impl<'mir, 'tcx, A, R> ResultsCursor<'mir, 'tcx, A, R>\n where\n     A: Analysis<'tcx>,\n+    R: Borrow<Results<'tcx, A>>,\n {\n     /// Returns a new cursor for `results` that points to the start of the `START_BLOCK`.\n-    pub fn new(body: &'mir mir::Body<'tcx>, results: Results<'tcx, A>) -> Self {\n+    pub fn new(body: &'mir mir::Body<'tcx>, results: R) -> Self {\n         ResultsCursor {\n             body,\n             pos: CursorPosition::AtBlockStart(mir::START_BLOCK),\n             is_call_return_effect_applied: false,\n-            state: results.entry_sets[mir::START_BLOCK].clone(),\n+            state: results.borrow().entry_sets[mir::START_BLOCK].clone(),\n             results,\n         }\n     }\n \n+    pub fn analysis(&self) -> &A {\n+        &self.results.borrow().analysis\n+    }\n+\n     /// Resets the cursor to the start of the given `block`.\n     pub fn seek_to_block_start(&mut self, block: BasicBlock) {\n-        self.state.overwrite(&self.results.entry_sets[block]);\n+        self.state.overwrite(&self.results.borrow().entry_sets[block]);\n         self.pos = CursorPosition::AtBlockStart(block);\n         self.is_call_return_effect_applied = false;\n     }\n@@ -275,7 +298,7 @@ where\n         } = &term.kind {\n             if !self.is_call_return_effect_applied {\n                 self.is_call_return_effect_applied = true;\n-                self.results.analysis.apply_call_return_effect(\n+                self.results.borrow().analysis.apply_call_return_effect(\n                     &mut self.state,\n                     target.block,\n                     func,\n@@ -316,7 +339,7 @@ where\n         };\n \n         let block_data = &self.body.basic_blocks()[target_block];\n-        self.results.analysis.apply_partial_block_effect(\n+        self.results.borrow().analysis.apply_partial_block_effect(\n             &mut self.state,\n             target_block,\n             block_data,\n@@ -349,7 +372,9 @@ where\n {\n     analysis: A,\n     bits_per_block: usize,\n+    tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n+    def_id: DefId,\n     dead_unwinds: &'a BitSet<BasicBlock>,\n     entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n }\n@@ -359,7 +384,9 @@ where\n     A: Analysis<'tcx>,\n {\n     pub fn new(\n+        tcx: TyCtxt<'tcx>,\n         body: &'a mir::Body<'tcx>,\n+        def_id: DefId,\n         dead_unwinds: &'a BitSet<BasicBlock>,\n         analysis: A,\n     ) -> Self {\n@@ -377,7 +404,9 @@ where\n         Engine {\n             analysis,\n             bits_per_block,\n+            tcx,\n             body,\n+            def_id,\n             dead_unwinds,\n             entry_sets,\n         }\n@@ -413,10 +442,26 @@ where\n             );\n         }\n \n-        Results {\n-            analysis: self.analysis,\n-            entry_sets: self.entry_sets,\n+        let Engine {\n+            tcx,\n+            body,\n+            def_id,\n+            analysis,\n+            entry_sets,\n+            ..\n+        } = self;\n+\n+        let results = Results { analysis, entry_sets };\n+\n+        let attrs = tcx.get_attrs(def_id);\n+        if let Some(path) = get_dataflow_graphviz_output_path(tcx, attrs, A::NAME) {\n+            let result = write_dataflow_graphviz_results(body, def_id, &path, &results);\n+            if let Err(e) = result {\n+                warn!(\"Failed to write dataflow results to {}: {}\", path.display(), e);\n+            }\n         }\n+\n+        results\n     }\n \n     fn propagate_bits_into_graph_successors_of(\n@@ -510,3 +555,59 @@ where\n         }\n     }\n }\n+\n+/// Looks for attributes like `#[rustc_mir(borrowck_graphviz_postflow=\"./path/to/suffix.dot\")]` and\n+/// extracts the path with the given analysis name prepended to the suffix.\n+///\n+/// Returns `None` if no such attribute exists.\n+fn get_dataflow_graphviz_output_path(\n+    tcx: TyCtxt<'tcx>,\n+    attrs: ty::Attributes<'tcx>,\n+    analysis: &str,\n+) -> Option<PathBuf> {\n+    let mut rustc_mir_attrs = attrs\n+        .into_iter()\n+        .filter(|attr| attr.check_name(sym::rustc_mir))\n+        .flat_map(|attr| attr.meta_item_list().into_iter().flat_map(|v| v.into_iter()));\n+\n+    let borrowck_graphviz_postflow = rustc_mir_attrs\n+        .find(|attr| attr.check_name(sym::borrowck_graphviz_postflow))?;\n+\n+    let path_and_suffix = match borrowck_graphviz_postflow.value_str() {\n+        Some(p) => p,\n+        None => {\n+            tcx.sess.span_err(\n+                borrowck_graphviz_postflow.span(),\n+                \"borrowck_graphviz_postflow requires a path\",\n+            );\n+\n+            return None;\n+        }\n+    };\n+\n+    // Change \"path/suffix.dot\" to \"path/analysis_name_suffix.dot\"\n+    let mut ret = PathBuf::from(path_and_suffix.to_string());\n+    let suffix = ret.file_name().unwrap();\n+\n+    let mut file_name: OsString = analysis.into();\n+    file_name.push(\"_\");\n+    file_name.push(suffix);\n+    ret.set_file_name(file_name);\n+\n+    Some(ret)\n+}\n+\n+fn write_dataflow_graphviz_results<A: Analysis<'tcx>>(\n+    body: &mir::Body<'tcx>,\n+    def_id: DefId,\n+    path: &Path,\n+    results: &Results<'tcx, A>\n+) -> io::Result<()> {\n+    debug!(\"printing dataflow results for {:?} to {}\", def_id, path.display());\n+\n+    let mut buf = Vec::new();\n+    let graphviz = graphviz::Formatter::new(body, def_id, results);\n+\n+    dot::render(&graphviz, &mut buf)?;\n+    fs::write(path, buf)\n+}"}, {"sha": "2a08feff9e77ab1bcb3a7708fbfe1a9086184d41", "filename": "src/librustc_mir/dataflow/generic/graphviz.rs", "status": "added", "additions": 412, "deletions": 0, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -0,0 +1,412 @@\n+use std::cell::RefCell;\n+use std::io::{self, Write};\n+use std::{ops, str};\n+\n+use rustc::hir::def_id::DefId;\n+use rustc::mir::{self, BasicBlock, Body, Location};\n+use rustc_index::bit_set::{BitSet, HybridBitSet};\n+use rustc_index::vec::Idx;\n+\n+use crate::util::graphviz_safe_def_name;\n+use super::{Analysis, Results, ResultsRefCursor};\n+\n+pub struct Formatter<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    body: &'a Body<'tcx>,\n+    def_id: DefId,\n+\n+    // This must be behind a `RefCell` because `dot::Labeller` takes `&self`.\n+    block_formatter: RefCell<BlockFormatter<'a, 'tcx, A>>,\n+}\n+\n+impl<A> Formatter<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    pub fn new(\n+        body: &'a Body<'tcx>,\n+        def_id: DefId,\n+        results: &'a Results<'tcx, A>,\n+    ) -> Self {\n+        let block_formatter = BlockFormatter {\n+            bg: Background::Light,\n+            prev_state: BitSet::new_empty(results.analysis.bits_per_block(body)),\n+            results: ResultsRefCursor::new(body, results),\n+        };\n+\n+        Formatter {\n+            body,\n+            def_id,\n+            block_formatter: RefCell::new(block_formatter),\n+        }\n+    }\n+}\n+\n+/// A pair of a basic block and an index into that basic blocks `successors`.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct CfgEdge {\n+    source: BasicBlock,\n+    index: usize,\n+}\n+\n+fn outgoing_edges(body: &Body<'_>, bb: BasicBlock) -> Vec<CfgEdge> {\n+    body[bb]\n+        .terminator()\n+        .successors()\n+        .enumerate()\n+        .map(|(index, _)| CfgEdge { source: bb, index })\n+        .collect()\n+}\n+\n+impl<A> dot::Labeller<'_> for Formatter<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    type Node = BasicBlock;\n+    type Edge = CfgEdge;\n+\n+    fn graph_id(&self) -> dot::Id<'_> {\n+        let name = graphviz_safe_def_name(self.def_id);\n+        dot::Id::new(format!(\"graph_for_def_id_{}\", name)).unwrap()\n+    }\n+\n+    fn node_id(&self, n: &Self::Node) -> dot::Id<'_> {\n+        dot::Id::new(format!(\"bb_{}\", n.index())).unwrap()\n+    }\n+\n+    fn node_label(&self, block: &Self::Node) -> dot::LabelText<'_> {\n+        let mut label = Vec::new();\n+        self.block_formatter\n+            .borrow_mut()\n+            .write_node_label(&mut label, self.body, *block)\n+            .unwrap();\n+        dot::LabelText::html(String::from_utf8(label).unwrap())\n+    }\n+\n+    fn node_shape(&self, _n: &Self::Node) -> Option<dot::LabelText<'_>> {\n+        Some(dot::LabelText::label(\"none\"))\n+    }\n+\n+    fn edge_label(&self, e: &Self::Edge) -> dot::LabelText<'_> {\n+        let label = &self.body\n+            [e.source]\n+            .terminator()\n+            .kind\n+            .fmt_successor_labels()\n+            [e.index];\n+        dot::LabelText::label(label.clone())\n+    }\n+}\n+\n+impl<A> dot::GraphWalk<'a> for Formatter<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    type Node = BasicBlock;\n+    type Edge = CfgEdge;\n+\n+    fn nodes(&self) -> dot::Nodes<'_, Self::Node> {\n+        self.body\n+            .basic_blocks()\n+            .indices()\n+            .collect::<Vec<_>>()\n+            .into()\n+    }\n+\n+    fn edges(&self) -> dot::Edges<'_, Self::Edge> {\n+        self.body\n+            .basic_blocks()\n+            .indices()\n+            .flat_map(|bb| outgoing_edges(self.body, bb))\n+            .collect::<Vec<_>>()\n+            .into()\n+    }\n+\n+    fn source(&self, edge: &Self::Edge) -> Self::Node {\n+        edge.source\n+    }\n+\n+    fn target(&self, edge: &Self::Edge) -> Self::Node {\n+        self.body\n+            [edge.source]\n+            .terminator()\n+            .successors()\n+            .nth(edge.index)\n+            .copied()\n+            .unwrap()\n+    }\n+}\n+\n+struct BlockFormatter<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    prev_state: BitSet<A::Idx>,\n+    results: ResultsRefCursor<'a, 'a, 'tcx, A>,\n+    bg: Background,\n+}\n+\n+impl<A> BlockFormatter<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    fn toggle_background(&mut self) -> Background {\n+        let bg = self.bg;\n+        self.bg = !bg;\n+        bg\n+    }\n+\n+    fn write_node_label(\n+        &mut self,\n+        w: &mut impl io::Write,\n+        body: &'a Body<'tcx>,\n+        block: BasicBlock,\n+    ) -> io::Result<()> {\n+        //   Sample output:\n+        //   +-+--------------------------------------------------+\n+        // A |                         bb4                        |\n+        //   +-+----------------------------------+---------------+\n+        // B |               MIR                  |     STATE     |\n+        //   +-+----------------------------------+---------------+\n+        // C | | (on entry)                       | {_0,_2,_3}    |\n+        //   +-+----------------------------------+---------------+\n+        // D |0|  0: StorageLive(_7)              |               |\n+        //   +-+----------------------------------+---------------+\n+        //   |1|  1: StorageLive(_8)              |               |\n+        //   +-+----------------------------------+---------------+\n+        //   |2|  2: _8 = &mut _1                 | +_8           |\n+        //   +-+----------------------------------+---------------+\n+        // E |T| _7 = const Foo::twiddle(move _8) | -_8           |\n+        //   +-+----------------------------------+---------------+\n+        // F | | (on unwind)                      | {_0,_2,_3,_7} |\n+        //   +-+----------------------------------+---------------+\n+        //   | | (on successful return)           | +_7           |\n+        //   +-+----------------------------------+---------------+\n+\n+        write!(\n+            w,\n+            r#\"<table border=\"1\" cellborder=\"1\" cellspacing=\"0\" cellpadding=\"3\" sides=\"rb\">\"#,\n+        )?;\n+\n+        // A: Block info\n+        write!(\n+            w,\n+            r#\"<tr>\n+                 <td colspan=\"{num_headers}\" sides=\"tl\">bb{block_id}</td>\n+               </tr>\"#,\n+            num_headers = 3,\n+            block_id = block.index(),\n+        )?;\n+\n+        // B: Column headings\n+        write!(\n+            w,\n+            r#\"<tr>\n+                 <td colspan=\"2\" {fmt}>MIR</td>\n+                 <td {fmt}>STATE</td>\n+               </tr>\"#,\n+            fmt = r##\"bgcolor=\"#a0a0a0\" sides=\"tl\"\"##,\n+        )?;\n+\n+        // C: Entry state\n+        self.results.seek_to_block_start(block);\n+        self.write_row_with_curr_state(w, \"\", \"(on entry)\")?;\n+        self.prev_state.overwrite(self.results.get());\n+\n+        // D: Statement transfer functions\n+        for (i, statement) in body[block].statements.iter().enumerate() {\n+            let location = Location { block, statement_index: i };\n+\n+            let mir_col = format!(\"{:?}\", statement);\n+            let i_col = i.to_string();\n+\n+            self.results.seek_after(location);\n+            self.write_row_with_curr_diff(w, &i_col, &mir_col)?;\n+            self.prev_state.overwrite(self.results.get());\n+        }\n+\n+        // E: Terminator transfer function\n+        let terminator = body[block].terminator();\n+        let location = body.terminator_loc(block);\n+\n+        let mut mir_col = String::new();\n+        terminator.kind.fmt_head(&mut mir_col).unwrap();\n+\n+        self.results.seek_after(location);\n+        self.write_row_with_curr_diff(w, \"T\", &mir_col)?;\n+        self.prev_state.overwrite(self.results.get());\n+\n+        // F: Exit state\n+        if let mir::TerminatorKind::Call { destination: Some(_), ..  } = &terminator.kind {\n+            self.write_row_with_curr_state(w, \"\", \"(on unwind)\")?;\n+\n+            self.results.seek_after_assume_call_returns(location);\n+            self.write_row_with_curr_diff(w, \"\", \"(on successful return)\")?;\n+        } else {\n+            self.write_row_with_curr_state(w, \"\", \"(on exit)\")?;\n+        }\n+\n+        write!(w, \"</table>\")\n+    }\n+\n+    fn write_row_with_curr_state(\n+        &mut self,\n+        w: &mut impl io::Write,\n+        i: &str,\n+        mir: &str,\n+    ) -> io::Result<()> {\n+        let bg = self.toggle_background();\n+\n+        let mut out = Vec::new();\n+        write!(&mut out, \"{{\")?;\n+        pretty_print_state_elems(&mut out, self.results.analysis(), self.results.get().iter())?;\n+        write!(&mut out, \"}}\")?;\n+\n+        write!(\n+            w,\n+            r#\"<tr>\n+                 <td {fmt} align=\"right\">{i}</td>\n+                 <td {fmt} align=\"left\">{mir}</td>\n+                 <td {fmt} align=\"left\">{state}</td>\n+               </tr>\"#,\n+            fmt = &[\"sides=\\\"tl\\\"\", bg.attr()].join(\" \"),\n+            i = i,\n+            mir = dot::escape_html(mir),\n+            state = dot::escape_html(str::from_utf8(&out).unwrap()),\n+        )\n+    }\n+\n+    fn write_row_with_curr_diff(\n+        &mut self,\n+        w: &mut impl io::Write,\n+        i: &str,\n+        mir: &str,\n+    ) -> io::Result<()> {\n+        let bg = self.toggle_background();\n+        let analysis = self.results.analysis();\n+\n+        let diff = BitSetDiff::compute(&self.prev_state, self.results.get());\n+\n+        let mut set = Vec::new();\n+        pretty_print_state_elems(&mut set, analysis, diff.set.iter())?;\n+\n+        let mut clear = Vec::new();\n+        pretty_print_state_elems(&mut clear, analysis, diff.clear.iter())?;\n+\n+        write!(\n+            w,\n+            r#\"<tr>\n+                 <td {fmt} align=\"right\">{i}</td>\n+                 <td {fmt} align=\"left\">{mir}</td>\n+                 <td {fmt} align=\"left\">\"#,\n+            i = i,\n+            fmt = &[\"sides=\\\"tl\\\"\", bg.attr()].join(\" \"),\n+            mir = dot::escape_html(mir),\n+        )?;\n+\n+        if !set.is_empty() {\n+            write!(\n+                w,\n+                r#\"<font color=\"darkgreen\">+{}</font>\"#,\n+                dot::escape_html(str::from_utf8(&set).unwrap()),\n+            )?;\n+        }\n+\n+        if !set.is_empty() && !clear.is_empty() {\n+            write!(w, \"  \")?;\n+        }\n+\n+        if !clear.is_empty() {\n+            write!(\n+                w,\n+                r#\"<font color=\"red\">-{}</font>\"#,\n+                dot::escape_html(str::from_utf8(&clear).unwrap()),\n+            )?;\n+        }\n+\n+        write!(w, \"</td></tr>\")\n+    }\n+}\n+\n+/// The operations required to transform one `BitSet` into another.\n+struct BitSetDiff<T: Idx> {\n+    set: HybridBitSet<T>,\n+    clear: HybridBitSet<T>,\n+}\n+\n+impl<T: Idx> BitSetDiff<T> {\n+    fn compute(from: &BitSet<T>, to: &BitSet<T>) -> Self {\n+        assert_eq!(from.domain_size(), to.domain_size());\n+        let len = from.domain_size();\n+\n+        let mut set = HybridBitSet::new_empty(len);\n+        let mut clear = HybridBitSet::new_empty(len);\n+\n+        // FIXME: This could be made faster if `BitSet::xor` were implemented.\n+        for i in (0..len).map(|i| T::new(i)) {\n+            match (from.contains(i), to.contains(i)) {\n+                (false, true) => set.insert(i),\n+                (true, false) => clear.insert(i),\n+                _ => continue,\n+            };\n+        }\n+\n+        BitSetDiff {\n+            set,\n+            clear,\n+        }\n+    }\n+}\n+\n+/// Formats each `elem` using the pretty printer provided by `analysis` into a comma-separated\n+/// list.\n+fn pretty_print_state_elems<A>(\n+    w: &mut impl io::Write,\n+    analysis: &A,\n+    elems: impl Iterator<Item = A::Idx>,\n+) -> io::Result<()>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    let mut first = true;\n+    for idx in elems {\n+        if first {\n+            first = false;\n+        } else {\n+            write!(w, \",\")?;\n+        }\n+\n+        analysis.pretty_print_idx(w, idx)?;\n+    }\n+\n+    Ok(())\n+}\n+\n+/// The background color used for zebra-striping the table.\n+#[derive(Clone, Copy)]\n+enum Background {\n+    Light,\n+    Dark,\n+}\n+\n+impl Background {\n+    fn attr(self) -> &'static str {\n+        match self {\n+            Self::Dark => \"bgcolor=\\\"#f0f0f0\\\"\",\n+            Self::Light => \"\",\n+        }\n+    }\n+}\n+\n+impl ops::Not for Background {\n+    type Output = Self;\n+\n+    fn not(self) -> Self {\n+        match self {\n+            Self::Light => Self::Dark,\n+            Self::Dark => Self::Light,\n+        }\n+    }\n+}"}, {"sha": "fb1311de9a70659bf14855cfc9fa9f1bc302e176", "filename": "src/librustc_mir/error_codes.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Flibrustc_mir%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Flibrustc_mir%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ferror_codes.rs?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -1128,6 +1128,51 @@ Remember this solution is unsafe! You will have to ensure that accesses to the\n cell are synchronized.\n \"##,\n \n+E0493: r##\"\n+A type with a `Drop` implementation was destructured when trying to initialize\n+a static item.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0493\n+enum DropType {\n+    A,\n+}\n+\n+impl Drop for DropType {\n+    fn drop(&mut self) {}\n+}\n+\n+struct Foo {\n+    field1: DropType,\n+}\n+\n+static FOO: Foo = Foo { ..Foo { field1: DropType::A } }; // error!\n+```\n+\n+The problem here is that if the given type or one of its fields implements the\n+`Drop` trait, this `Drop` implementation cannot be called during the static\n+type initialization which might cause a memory leak. To prevent this issue,\n+you need to instantiate all the static type's fields by hand.\n+\n+```\n+enum DropType {\n+    A,\n+}\n+\n+impl Drop for DropType {\n+    fn drop(&mut self) {}\n+}\n+\n+struct Foo {\n+    field1: DropType,\n+}\n+\n+static FOO: Foo = Foo { field1: DropType::A }; // We initialize all fields\n+                                               // by hand.\n+```\n+\"##,\n+\n E0499: r##\"\n A variable was borrowed as mutable more than once. Erroneous code example:\n \n@@ -2454,7 +2499,6 @@ There are some known bugs that trigger this message.\n //  E0299, // mismatched types between arms\n //  E0471, // constant evaluation error (in pattern)\n //  E0385, // {} in an aliasable location\n-    E0493, // destructors cannot be evaluated at compile-time\n     E0521, // borrowed data escapes outside of closure\n     E0526, // shuffle indices are not constant\n     E0594, // cannot assign to {}"}, {"sha": "40007eb3c4a3ef71d4543c827a028b630ca8dcf8", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -27,6 +27,9 @@ impl QualifSet {\n pub trait Qualif {\n     const IDX: usize;\n \n+    /// The name of the file used to debug the dataflow analysis that computes this qualif.\n+    const ANALYSIS_NAME: &'static str;\n+\n     /// Whether this `Qualif` is cleared when a local is moved from.\n     const IS_CLEARED_ON_MOVE: bool = false;\n \n@@ -207,6 +210,7 @@ pub struct HasMutInterior;\n \n impl Qualif for HasMutInterior {\n     const IDX: usize = 0;\n+    const ANALYSIS_NAME: &'static str = \"flow_has_mut_interior\";\n \n     fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n         !ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP)\n@@ -264,6 +268,7 @@ pub struct NeedsDrop;\n \n impl Qualif for NeedsDrop {\n     const IDX: usize = 1;\n+    const ANALYSIS_NAME: &'static str = \"flow_needs_drop\";\n     const IS_CLEARED_ON_MOVE: bool = true;\n \n     fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {"}, {"sha": "4fa4eba4c23b6ebca2ffdc5047ea95e4b0ba1e08", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -208,7 +208,8 @@ where\n             _qualif: PhantomData,\n         };\n         let results =\n-            dataflow::Engine::new(item.body, dead_unwinds, analysis).iterate_to_fixpoint();\n+            dataflow::Engine::new(item.tcx, item.body, item.def_id, dead_unwinds, analysis)\n+                .iterate_to_fixpoint();\n         let cursor = dataflow::ResultsCursor::new(item.body, results);\n \n         let mut qualifs_in_any_value_of_ty = BitSet::new_empty(item.body.local_decls.len());\n@@ -308,7 +309,7 @@ where\n {\n     type Idx = Local;\n \n-    const NAME: &'static str = \"flow_sensitive_qualif\";\n+    const NAME: &'static str = Q::ANALYSIS_NAME;\n \n     fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n         body.local_decls.len()"}, {"sha": "3045239d7a7701ba9cdf5370961211085585d298", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -467,8 +467,6 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         self.qualifs.needs_drop.visit_statement(statement, location);\n         self.qualifs.has_mut_interior.visit_statement(statement, location);\n-        debug!(\"needs_drop: {:?}\", self.qualifs.needs_drop.get());\n-        debug!(\"has_mut_interior: {:?}\", self.qualifs.has_mut_interior.get());\n \n         match statement.kind {\n             StatementKind::Assign(..) => {\n@@ -494,8 +492,6 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         self.qualifs.needs_drop.visit_terminator(terminator, location);\n         self.qualifs.has_mut_interior.visit_terminator(terminator, location);\n-        debug!(\"needs_drop: {:?}\", self.qualifs.needs_drop.get());\n-        debug!(\"has_mut_interior: {:?}\", self.qualifs.has_mut_interior.get());\n \n         self.super_terminator(terminator, location);\n     }"}, {"sha": "8a78daee6e49b0a4c5a3bb83080387021e288071", "filename": "src/libsyntax/error_codes.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Flibsyntax%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Flibsyntax%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferror_codes.rs?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -144,6 +144,25 @@ fn deprecated_function() {}\n ```\n \"##,\n \n+E0550: r##\"\n+More than one `deprecated` attribute has been put on an item.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0550\n+#[deprecated(note = \"because why not?\")]\n+#[deprecated(note = \"right?\")] // error!\n+fn the_banished() {}\n+```\n+\n+The `deprecated` attribute can only be present **once** on an item.\n+\n+```\n+#[deprecated(note = \"because why not, right?\")]\n+fn the_banished() {} // ok!\n+```\n+\"##,\n+\n E0552: r##\"\n A unrecognized representation attribute was used.\n \n@@ -435,7 +454,6 @@ features in the `-Z allow_features` flag.\n     // rustc_deprecated attribute must be paired with either stable or unstable\n     // attribute\n     E0549,\n-    E0550, // multiple deprecated attributes\n     E0551, // incorrect meta item\n     E0553, // multiple rustc_const_unstable attributes\n //  E0555, // replaced with a generic attribute input check"}, {"sha": "7d7ecbd1a26a579eaeb289f7a994f2bedcdc0b6d", "filename": "src/test/ui/check-static-values-constraints.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fcheck-static-values-constraints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fcheck-static-values-constraints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-static-values-constraints.stderr?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -108,5 +108,5 @@ LL |     let y = { static x: Box<isize> = box 3; x };\n \n error: aborting due to 17 previous errors\n \n-Some errors have detailed explanations: E0010, E0015, E0019, E0507.\n+Some errors have detailed explanations: E0010, E0015, E0019, E0493, E0507.\n For more information about an error, try `rustc --explain E0010`."}, {"sha": "4753222a7c07d816fb5f49190e58dcdb891b02fb", "filename": "src/test/ui/consts/const-eval/const_let.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_let.stderr?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -24,3 +24,4 @@ LL | const Z2: () = { let mut x; x = None; x = Some(FakeNeedsDrop); };\n \n error: aborting due to 4 previous errors\n \n+For more information about this error, try `rustc --explain E0493`."}, {"sha": "e3a8c85830f73fb2c7db62f91f36bef789fccb4f", "filename": "src/test/ui/consts/issue-64662.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fconsts%2Fissue-64662.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fconsts%2Fissue-64662.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-64662.rs?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -0,0 +1,10 @@\n+enum Foo {\n+    A = foo(), //~ ERROR: type annotations needed\n+    B = foo(), //~ ERROR: type annotations needed\n+}\n+\n+const fn foo<T>() -> isize {\n+    0\n+}\n+\n+fn main() {}"}, {"sha": "b81daae330bfaa21c850314304a76ddda4d8681c", "filename": "src/test/ui/consts/issue-64662.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fconsts%2Fissue-64662.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fconsts%2Fissue-64662.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-64662.stderr?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -0,0 +1,15 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-64662.rs:2:9\n+   |\n+LL |     A = foo(),\n+   |         ^^^ cannot infer type for `T`\n+\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-64662.rs:3:9\n+   |\n+LL |     B = foo(),\n+   |         ^^^ cannot infer type for `T`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "3158b6284db94761732509b56d93137268249d9f", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -324,5 +324,5 @@ LL | const fn no_fn_ptrs2() -> fn() { fn foo() {} foo }\n \n error: aborting due to 37 previous errors\n \n-Some errors have detailed explanations: E0515, E0723.\n-For more information about an error, try `rustc --explain E0515`.\n+Some errors have detailed explanations: E0493, E0515, E0723.\n+For more information about an error, try `rustc --explain E0493`."}, {"sha": "37016664ac58f38c913b3d1dbd36cf8ddd243c99", "filename": "src/test/ui/consts/miri_unleashed/feature-gate-unleash_the_miri_inside_of_you.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.stderr?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -6,3 +6,4 @@ LL |     const F: u32 = (U::X, 42).1;\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0493`."}, {"sha": "15afa78b140d5eb2aa09e7f660fe2fd3304392a3", "filename": "src/test/ui/deprecation/deprecation-sanity.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-sanity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-sanity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-sanity.stderr?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -54,5 +54,5 @@ LL | #[deprecated(since = \"a\", since = \"b\", note = \"c\")]\n \n error: aborting due to 9 previous errors\n \n-Some errors have detailed explanations: E0538, E0541, E0565.\n+Some errors have detailed explanations: E0538, E0541, E0550, E0565.\n For more information about an error, try `rustc --explain E0538`."}, {"sha": "d05e89e257f459fc293a73ba9b6d536e97c56240", "filename": "src/test/ui/span/E0493.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fspan%2FE0493.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fspan%2FE0493.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0493.stderr?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -6,3 +6,4 @@ LL | const F : Foo = (Foo { a : 0 }, Foo { a : 1 }).1;\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0493`."}, {"sha": "bc08f33f8209371b7cf1af73fe34a199e5ef4fe0", "filename": "src/test/ui/static/static-drop-scope.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fstatic%2Fstatic-drop-scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42ec6831b019114a4b6f6b58bfb5bc2927d70388/src%2Ftest%2Fui%2Fstatic%2Fstatic-drop-scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatic%2Fstatic-drop-scope.stderr?ref=42ec6831b019114a4b6f6b58bfb5bc2927d70388", "patch": "@@ -68,4 +68,5 @@ LL | const EARLY_DROP_C_OPTION_CONSTANT: i32 = (HELPER, 0).1;\n \n error: aborting due to 10 previous errors\n \n-For more information about this error, try `rustc --explain E0716`.\n+Some errors have detailed explanations: E0493, E0716.\n+For more information about an error, try `rustc --explain E0493`."}]}