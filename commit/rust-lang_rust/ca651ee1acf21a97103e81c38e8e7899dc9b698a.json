{"sha": "ca651ee1acf21a97103e81c38e8e7899dc9b698a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhNjUxZWUxYWNmMjFhOTcxMDNlODFjMzhlOGU3ODk5ZGM5YjY5OGE=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-08-19T16:43:53Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-08-19T16:43:53Z"}, "message": "Merge pull request #188 from marcusklaas/refactor-itemize-list\n\nRefactor itemize list so that it produces an iterator", "tree": {"sha": "34a10b0485922bc29298abb61162b16c7ed2acf1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34a10b0485922bc29298abb61162b16c7ed2acf1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca651ee1acf21a97103e81c38e8e7899dc9b698a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca651ee1acf21a97103e81c38e8e7899dc9b698a", "html_url": "https://github.com/rust-lang/rust/commit/ca651ee1acf21a97103e81c38e8e7899dc9b698a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca651ee1acf21a97103e81c38e8e7899dc9b698a/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "229415bca226ea0ba23c77c92e0e1b6310213f5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/229415bca226ea0ba23c77c92e0e1b6310213f5b", "html_url": "https://github.com/rust-lang/rust/commit/229415bca226ea0ba23c77c92e0e1b6310213f5b"}, {"sha": "4e0a8da447e57c1b9bc045828b77dd787b1e449e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e0a8da447e57c1b9bc045828b77dd787b1e449e", "html_url": "https://github.com/rust-lang/rust/commit/4e0a8da447e57c1b9bc045828b77dd787b1e449e"}], "stats": {"total": 302, "additions": 158, "deletions": 144}, "files": [{"sha": "1dfff001475e9661cc2a8e8fe16803e74ab9d0d9", "filename": "src/expr.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ca651ee1acf21a97103e81c38e8e7899dc9b698a/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca651ee1acf21a97103e81c38e8e7899dc9b698a/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=ca651ee1acf21a97103e81c38e8e7899dc9b698a", "patch": "@@ -407,9 +407,7 @@ fn rewrite_call(context: &RewriteContext,\n     let inner_context = &RewriteContext { block_indent: block_indent, ..*context };\n \n     let items = itemize_list(context.codemap,\n-                             Vec::new(),\n                              args.iter(),\n-                             \",\",\n                              \")\",\n                              |item| item.span.lo,\n                              |item| item.span.hi,\n@@ -430,7 +428,7 @@ fn rewrite_call(context: &RewriteContext,\n         ends_with_newline: false,\n     };\n \n-    Some(format!(\"{}({})\", callee_str, write_list(&items, &fmt)))\n+    Some(format!(\"{}({})\", callee_str, write_list(&items.collect::<Vec<_>>(), &fmt)))\n }\n \n fn expr_block_indent(context: &RewriteContext, offset: usize) -> usize {\n@@ -494,9 +492,7 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n     let inner_context = &RewriteContext { block_indent: indent, ..*context };\n \n     let items = itemize_list(context.codemap,\n-                             Vec::new(),\n                              field_iter,\n-                             \",\",\n                              \"}\",\n                              |item| {\n                                  match *item {\n@@ -543,7 +539,7 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n         v_width: v_budget,\n         ends_with_newline: false,\n     };\n-    let fields_str = write_list(&items, &fmt);\n+    let fields_str = write_list(&items.collect::<Vec<_>>(), &fmt);\n \n     match context.config.struct_lit_style {\n         StructLitStyle::BlockIndent if fields_str.contains('\\n') => {\n@@ -584,9 +580,7 @@ fn rewrite_tuple_lit(context: &RewriteContext,\n     }\n \n     let items = itemize_list(context.codemap,\n-                             Vec::new(),\n-                             items.into_iter(),\n-                             \",\",\n+                             items.iter(),\n                              \")\",\n                              |item| item.span.lo,\n                              |item| item.span.hi,\n@@ -608,7 +602,7 @@ fn rewrite_tuple_lit(context: &RewriteContext,\n         ends_with_newline: false,\n     };\n \n-    Some(format!(\"({})\", write_list(&items, &fmt)))\n+    Some(format!(\"({})\", write_list(&items.collect::<Vec<_>>(), &fmt)))\n }\n \n fn rewrite_binary_op(context: &RewriteContext,"}, {"sha": "392e6fb838a74badc4288f16fd9ff0fa9a4ba88b", "filename": "src/imports.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ca651ee1acf21a97103e81c38e8e7899dc9b698a/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca651ee1acf21a97103e81c38e8e7899dc9b698a/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=ca651ee1acf21a97103e81c38e8e7899dc9b698a", "patch": "@@ -108,30 +108,33 @@ pub fn rewrite_use_list(width: usize,\n         ends_with_newline: false,\n     };\n \n-    let mut items = itemize_list(context.codemap,\n-                                 vec![ListItem::from_str(\"\")], /* Dummy value, explanation\n-                                                                * below */\n-                                 path_list.iter(),\n-                                 \",\",\n-                                 \"}\",\n-                                 |vpi| vpi.span.lo,\n-                                 |vpi| vpi.span.hi,\n-                                 |vpi| match vpi.node {\n+    let mut items = {\n+        // Dummy value, see explanation below.\n+        let mut items = vec![ListItem::from_str(\"\")];\n+        let iter = itemize_list(context.codemap,\n+                                path_list.iter(),\n+                                \"}\",\n+                                |vpi| vpi.span.lo,\n+                                |vpi| vpi.span.hi,\n+                                |vpi| match vpi.node {\n                                      ast::PathListItem_::PathListIdent{ name, .. } => {\n                                          name.to_string()\n                                      }\n                                      ast::PathListItem_::PathListMod{ .. } => {\n                                          \"self\".to_owned()\n                                      }\n-                                 },\n-                                 span_after(span, \"{\", context.codemap),\n-                                 span.hi);\n+                                },\n+                                span_after(span, \"{\", context.codemap),\n+                                span.hi);\n+        items.extend(iter);\n+        items\n+    };\n \n     // We prefixed the item list with a dummy value so that we can\n     // potentially move \"self\" to the front of the vector without touching\n     // the rest of the items.\n-    // FIXME: Make more efficient by using a linked list? That would\n-    // require changes to the signatures of itemize_list and write_list.\n+    // FIXME: Make more efficient by using a linked list? That would require\n+    // changes to the signatures of write_list.\n     let has_self = move_self_to_front(&mut items);\n     let first_index = if has_self {\n         0"}, {"sha": "458a7b0b3363719edc33620a40057589edaba663", "filename": "src/items.rs", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ca651ee1acf21a97103e81c38e8e7899dc9b698a/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca651ee1acf21a97103e81c38e8e7899dc9b698a/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=ca651ee1acf21a97103e81c38e8e7899dc9b698a", "patch": "@@ -259,16 +259,16 @@ impl<'a> FmtVisitor<'a> {\n                 span.lo\n             };\n \n-            arg_items = itemize_list(self.codemap,\n-                                     arg_items,\n-                                     args[min_args-1..].iter().cloned(),\n-                                     \",\",\n-                                     \")\",\n-                                     span_lo_for_arg,\n-                                     |arg| arg.ty.span.hi,\n-                                     |_| String::new(),\n-                                     comment_span_start,\n-                                     span.hi);\n+            let more_items = itemize_list(self.codemap,\n+                                          args[min_args-1..].iter(),\n+                                          \")\",\n+                                          |arg| span_lo_for_arg(arg),\n+                                          |arg| arg.ty.span.hi,\n+                                          |_| String::new(),\n+                                          comment_span_start,\n+                                          span.hi);\n+\n+            arg_items.extend(more_items);\n         }\n \n         assert_eq!(arg_item_strs.len(), arg_items.len());\n@@ -401,9 +401,7 @@ impl<'a> FmtVisitor<'a> {\n \n                 if types.len() > 0 {\n                     let items = itemize_list(self.codemap,\n-                                             Vec::new(),\n                                              types.iter(),\n-                                             \",\",\n                                              \")\",\n                                              |arg| arg.ty.span.lo,\n                                              |arg| arg.ty.span.hi,\n@@ -434,7 +432,7 @@ impl<'a> FmtVisitor<'a> {\n                         v_width: budget,\n                         ends_with_newline: true,\n                     };\n-                    result.push_str(&write_list(&items, &fmt));\n+                    result.push_str(&write_list(&items.collect::<Vec<_>>(), &fmt));\n                     result.push(')');\n                 }\n \n@@ -513,9 +511,7 @@ impl<'a> FmtVisitor<'a> {\n         result.push_str(&generics_str);\n \n         let items = itemize_list(self.codemap,\n-                                 Vec::new(),\n                                  struct_def.fields.iter(),\n-                                 \",\",\n                                  terminator,\n                                  |field| {\n                                       // Include attributes and doc comments,\n@@ -563,7 +559,7 @@ impl<'a> FmtVisitor<'a> {\n             ends_with_newline: true,\n         };\n \n-        result.push_str(&write_list(&items, &fmt));\n+        result.push_str(&write_list(&items.collect::<Vec<_>>(), &fmt));\n \n         if break_line {\n             result.push('\\n');\n@@ -689,16 +685,15 @@ impl<'a> FmtVisitor<'a> {\n         });\n         let ty_spans = tys.iter().map(span_for_ty_param);\n \n-        let mut items = itemize_list(self.codemap,\n-                                     Vec::new(),\n-                                     lt_spans.chain(ty_spans),\n-                                     \",\",\n-                                     \">\",\n-                                     |sp| sp.lo,\n-                                     |sp| sp.hi,\n-                                     |_| String::new(),\n-                                     span_after(span, \"<\", self.codemap),\n-                                     span.hi);\n+        let items = itemize_list(self.codemap,\n+                                 lt_spans.chain(ty_spans),\n+                                 \">\",\n+                                 |sp| sp.lo,\n+                                 |sp| sp.hi,\n+                                 |_| String::new(),\n+                                 span_after(span, \"<\", self.codemap),\n+                                 span.hi);\n+        let mut items = items.collect::<Vec<_>>();\n \n         for (item, ty) in items.iter_mut().zip(lt_strs.chain(ty_strs)) {\n             item.item = ty;\n@@ -741,9 +736,7 @@ impl<'a> FmtVisitor<'a> {\n         let budget = self.config.ideal_width + self.config.leeway - offset;\n         let span_start = span_for_where_pred(&where_clause.predicates[0]).lo;\n         let items = itemize_list(self.codemap,\n-                                 Vec::new(),\n                                  where_clause.predicates.iter(),\n-                                 \",\",\n                                  \"{\",\n                                  |pred| span_for_where_pred(pred).lo,\n                                  |pred| span_for_where_pred(pred).hi,\n@@ -763,7 +756,7 @@ impl<'a> FmtVisitor<'a> {\n             v_width: budget,\n             ends_with_newline: false,\n         };\n-        result.push_str(&write_list(&items, &fmt));\n+        result.push_str(&write_list(&items.collect::<Vec<_>>(), &fmt));\n \n         result\n     }"}, {"sha": "8f1d8a743c22f39665a4173002dfe194c038d8ba", "filename": "src/lists.rs", "status": "modified", "additions": 113, "deletions": 85, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/ca651ee1acf21a97103e81c38e8e7899dc9b698a/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca651ee1acf21a97103e81c38e8e7899dc9b698a/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=ca651ee1acf21a97103e81c38e8e7899dc9b698a", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::cmp;\n+use std::iter::Peekable;\n \n use syntax::codemap::{self, CodeMap, BytePos};\n \n@@ -224,107 +225,134 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> St\n     result\n }\n \n-// Turns a list into a vector of items with associated comments.\n-// TODO: we probably do not want to take a terminator any more. Instead, we\n-// should demand a proper span end.\n-pub fn itemize_list<T, I, F1, F2, F3>(codemap: &CodeMap,\n-                                      prefix: Vec<ListItem>,\n-                                      it: I,\n-                                      separator: &str,\n-                                      terminator: &str,\n-                                      get_lo: F1,\n-                                      get_hi: F2,\n-                                      get_item_string: F3,\n-                                      mut prev_span_end: BytePos,\n-                                      next_span_start: BytePos)\n-                                      -> Vec<ListItem>\n+pub struct ListItems<'a, I, F1, F2, F3>\n+    where I: Iterator\n+{\n+    codemap: &'a CodeMap,\n+    inner: Peekable<I>,\n+    get_lo: F1,\n+    get_hi: F2,\n+    get_item_string: F3,\n+    prev_span_end: BytePos,\n+    next_span_start: BytePos,\n+    terminator: &'a str,\n+}\n+\n+impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n     where I: Iterator<Item = T>,\n           F1: Fn(&T) -> BytePos,\n           F2: Fn(&T) -> BytePos,\n           F3: Fn(&T) -> String\n {\n-    let mut result = prefix;\n-    result.reserve(it.size_hint().0);\n-\n-    let mut new_it = it.peekable();\n-    let white_space: &[_] = &[' ', '\\t'];\n-\n-    while let Some(item) = new_it.next() {\n-        // Pre-comment\n-        let pre_snippet = codemap.span_to_snippet(codemap::mk_sp(prev_span_end,\n-                                                                get_lo(&item)))\n-                                 .unwrap();\n-        let pre_snippet = pre_snippet.trim();\n-        let pre_comment = if pre_snippet.len() > 0 {\n-            Some(pre_snippet.to_owned())\n-        } else {\n-            None\n-        };\n-\n-        // Post-comment\n-        let next_start = match new_it.peek() {\n-            Some(ref next_item) => get_lo(next_item),\n-            None => next_span_start\n-        };\n-        let post_snippet = codemap.span_to_snippet(codemap::mk_sp(get_hi(&item),\n-                                                                  next_start))\n-                                  .unwrap();\n-\n-        let comment_end = match new_it.peek() {\n-            Some(..) => {\n-                let block_open_index = post_snippet.find(\"/*\");\n-                let newline_index = post_snippet.find('\\n');\n-                let separator_index = post_snippet.find_uncommented(separator).unwrap();\n-\n-                match (block_open_index, newline_index) {\n-                    // Separator before comment, with the next item on same line.\n-                    // Comment belongs to next item.\n-                    (Some(i), None) if i > separator_index => { separator_index + separator.len() }\n-                    // Block-style post-comment before the separator.\n-                    (Some(i), None) => {\n-                        cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                                 separator_index + separator.len())\n-                    }\n-                    // Block-style post-comment. Either before or after the separator.\n-                    (Some(i), Some(j)) if i < j => {\n-                        cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                                 separator_index + separator.len())\n+    type Item = ListItem;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let white_space: &[_] = &[' ', '\\t'];\n+\n+        self.inner.next().map(|item| {\n+            // Pre-comment\n+            let pre_snippet = self.codemap.span_to_snippet(codemap::mk_sp(self.prev_span_end,\n+                                                                          (self.get_lo)(&item)))\n+                                          .unwrap();\n+            let pre_snippet = pre_snippet.trim();\n+            let pre_comment = if pre_snippet.len() > 0 {\n+                Some(pre_snippet.to_owned())\n+            } else {\n+                None\n+            };\n+\n+            // Post-comment\n+            let next_start = match self.inner.peek() {\n+                Some(ref next_item) => (self.get_lo)(next_item),\n+                None => self.next_span_start\n+            };\n+            let post_snippet = self.codemap.span_to_snippet(codemap::mk_sp((self.get_hi)(&item),\n+                                                                           next_start))\n+                                           .unwrap();\n+\n+            let comment_end = match self.inner.peek() {\n+                Some(..) => {\n+                    let block_open_index = post_snippet.find(\"/*\");\n+                    let newline_index = post_snippet.find('\\n');\n+                    let separator_index = post_snippet.find_uncommented(\",\").unwrap();\n+\n+                    match (block_open_index, newline_index) {\n+                        // Separator before comment, with the next item on same line.\n+                        // Comment belongs to next item.\n+                        (Some(i), None) if i > separator_index => {\n+                            separator_index + 1\n+                        }\n+                        // Block-style post-comment before the separator.\n+                        (Some(i), None) => {\n+                            cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                                     separator_index + 1)\n+                        }\n+                        // Block-style post-comment. Either before or after the separator.\n+                        (Some(i), Some(j)) if i < j => {\n+                            cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                                     separator_index + 1)\n+                        }\n+                        // Potential *single* line comment.\n+                        (_, Some(j)) => { j + 1 }\n+                        _ => post_snippet.len()\n                     }\n-                    // Potential *single* line comment.\n-                    (_, Some(j)) => { j + 1 }\n-                    _ => post_snippet.len()\n+                },\n+                None => {\n+                    post_snippet.find_uncommented(self.terminator)\n+                                .unwrap_or(post_snippet.len())\n                 }\n-            },\n-            None => {\n-                post_snippet.find_uncommented(terminator)\n-                            .unwrap_or(post_snippet.len())\n-            }\n-        };\n+            };\n \n-        // Cleanup post-comment: strip separators and whitespace.\n-        prev_span_end = get_hi(&item) + BytePos(comment_end as u32);\n-        let mut post_snippet = post_snippet[..comment_end].trim();\n+            // Cleanup post-comment: strip separators and whitespace.\n+            self.prev_span_end = (self.get_hi)(&item) + BytePos(comment_end as u32);\n+            let mut post_snippet = post_snippet[..comment_end].trim();\n \n-        if post_snippet.starts_with(separator) {\n-            post_snippet = post_snippet[separator.len()..]\n-                .trim_matches(white_space);\n-        } else if post_snippet.ends_with(separator) {\n-            post_snippet = post_snippet[..post_snippet.len()-separator.len()]\n-                .trim_matches(white_space);\n-        }\n+            if post_snippet.starts_with(',') {\n+                post_snippet = post_snippet[1..].trim_matches(white_space);\n+            } else if post_snippet.ends_with(\",\") {\n+                post_snippet = post_snippet[..(post_snippet.len() - 1)].trim_matches(white_space);\n+            }\n \n-        result.push(ListItem {\n-            pre_comment: pre_comment,\n-            item: get_item_string(&item),\n-            post_comment: if post_snippet.len() > 0 {\n+            let post_comment = if post_snippet.len() > 0 {\n                 Some(post_snippet.to_owned())\n             } else {\n                 None\n+            };\n+\n+            ListItem {\n+                pre_comment: pre_comment,\n+                item: (self.get_item_string)(&item),\n+                post_comment: post_comment,\n             }\n-        });\n+        })\n     }\n+}\n \n-    result\n+// Creates an iterator over a list's items with associated comments.\n+pub fn itemize_list<'a, T, I, F1, F2, F3>(codemap: &'a CodeMap,\n+                                          inner: I,\n+                                          terminator: &'a str,\n+                                          get_lo: F1,\n+                                          get_hi: F2,\n+                                          get_item_string: F3,\n+                                          prev_span_end: BytePos,\n+                                          next_span_start: BytePos)\n+                                          -> ListItems<'a, I, F1, F2, F3>\n+    where I: Iterator<Item = T>,\n+          F1: Fn(&T) -> BytePos,\n+          F2: Fn(&T) -> BytePos,\n+          F3: Fn(&T) -> String\n+{\n+    ListItems {\n+        codemap: codemap,\n+        inner: inner.peekable(),\n+        get_lo: get_lo,\n+        get_hi: get_hi,\n+        get_item_string: get_item_string,\n+        prev_span_end: prev_span_end,\n+        next_span_start: next_span_start,\n+        terminator: terminator,\n+    }\n }\n \n fn needs_trailing_separator(separator_tactic: SeparatorTactic, list_tactic: ListTactic) -> bool {"}, {"sha": "ea8787bd846787b3eb2d775880d6e56bde9b440c", "filename": "src/types.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca651ee1acf21a97103e81c38e8e7899dc9b698a/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca651ee1acf21a97103e81c38e8e7899dc9b698a/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=ca651ee1acf21a97103e81c38e8e7899dc9b698a", "patch": "@@ -204,9 +204,7 @@ fn rewrite_segment(segment: &ast::PathSegment,\n             let separator = get_path_separator(context.codemap, *span_lo, list_lo);\n \n             let items = itemize_list(context.codemap,\n-                                     Vec::new(),\n                                      param_list.into_iter(),\n-                                     \",\",\n                                      \">\",\n                                      |param| param.get_span().lo,\n                                      |param| param.get_span().hi,\n@@ -232,7 +230,7 @@ fn rewrite_segment(segment: &ast::PathSegment,\n             // update pos\n             *span_lo = next_span_lo;\n \n-            format!(\"{}<{}>\", separator, write_list(&items, &fmt))\n+            format!(\"{}<{}>\", separator, write_list(&items.collect::<Vec<_>>(), &fmt))\n         }\n         ast::PathParameters::ParenthesizedParameters(ref data) => {\n             let output = match data.output {\n@@ -242,9 +240,7 @@ fn rewrite_segment(segment: &ast::PathSegment,\n \n             let list_lo = span_after(codemap::mk_sp(*span_lo, span_hi), \"(\", context.codemap);\n             let items = itemize_list(context.codemap,\n-                                     Vec::new(),\n                                      data.inputs.iter(),\n-                                     \",\",\n                                      \")\",\n                                      |ty| ty.span.lo,\n                                      |ty| ty.span.hi,\n@@ -269,7 +265,7 @@ fn rewrite_segment(segment: &ast::PathSegment,\n             // update pos\n             *span_lo = data.inputs.last().unwrap().span.hi + BytePos(1);\n \n-            format!(\"({}){}\", write_list(&items, &fmt), output)\n+            format!(\"({}){}\", write_list(&items.collect::<Vec<_>>(), &fmt), output)\n         }\n         _ => String::new()\n     };"}]}