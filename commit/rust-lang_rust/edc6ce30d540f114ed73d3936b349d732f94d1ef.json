{"sha": "edc6ce30d540f114ed73d3936b349d732f94d1ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkYzZjZTMwZDU0MGYxMTRlZDczZDM5MzZiMzQ5ZDczMmY5NGQxZWY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-19T21:56:05Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-25T08:19:27Z"}, "message": "implement acquiring and releasing locks", "tree": {"sha": "7efad26ebaf4ca4b0a4b779d1833fca917cff595", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7efad26ebaf4ca4b0a4b779d1833fca917cff595"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edc6ce30d540f114ed73d3936b349d732f94d1ef", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAll2/w8ACgkQpp+NIls6\n19kamw//VoDI0+vuxxPkzUrrDPDwTO6U1MGPA4+A8GW7thxcGZQ1XqvTa1ytA7IU\nQTV1pVdQSytfpGRNwkFTs5oZ6rpgBgy9Kedl71zZukF3fwO86N7/o1cncoJshdT0\nqxjmAHk4X1WnjQW5IgDKaijvwp4MpLiNKhlkvyhhXp/j+IFpiSnpxkGA4DLByUCb\nW07wMw7Iy/ekSMuNazHjecSwQYb60SzNevX2u4r9GHDL2hPT4IKYfbHYa1tOpWmU\nxACkiLUrWJ7eKdkiujRx9PAmAV3gg6pqbpbQoioHV6ntPwR7TtNdjuB5VoUzmxjS\nF7sj0u/6Qo8HmD+Sv3h3Xs0hcGCwT+zXi3voMpuYCvDV5KDCCsX5vGheSy/7xM91\n72Q3ouuxOSCpPFjf05MNUo+oDmnpREUjBeXnLramacwq1jHHWdp7d703lNlJnQPV\ntTJDNeorY/qqbzc68yB+WfmZyq6Fu6OG9+Ul4z+77NTFWgSh2qEzh8sp39ZEU0aW\n+7lgq2kf33oZWn0HTbIfvTXFxA6RqRG886wP7iGS7XZWk/6hqAQE9O5+zOknUiPG\nDPgFvrpHyrxahC+QMiWxTOECPo0xqshfP7bVH6Zi43Ly2PLE9x2GqRtThzGrbi2A\nOvEfKMYqHo+ayp38CZCv2MPdjpDYBT+zSofaK6ILqkNO56o/pV0=\n=yIay\n-----END PGP SIGNATURE-----", "payload": "tree 7efad26ebaf4ca4b0a4b779d1833fca917cff595\nparent 4372f1145f0f745d974842a785ee9dc1fe99a366\nauthor Ralf Jung <post@ralfj.de> 1497909365 -0700\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1500970767 +0200\n\nimplement acquiring and releasing locks\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edc6ce30d540f114ed73d3936b349d732f94d1ef", "html_url": "https://github.com/rust-lang/rust/commit/edc6ce30d540f114ed73d3936b349d732f94d1ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edc6ce30d540f114ed73d3936b349d732f94d1ef/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4372f1145f0f745d974842a785ee9dc1fe99a366", "url": "https://api.github.com/repos/rust-lang/rust/commits/4372f1145f0f745d974842a785ee9dc1fe99a366", "html_url": "https://github.com/rust-lang/rust/commit/4372f1145f0f745d974842a785ee9dc1fe99a366"}], "stats": {"total": 129, "additions": 109, "deletions": 20}, "files": [{"sha": "dde64a46ff0781bddddd6c4e5d7a439c0a0d1416", "filename": "src/librustc_mir/interpret/error.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/edc6ce30d540f114ed73d3936b349d732f94d1ef/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc6ce30d540f114ed73d3936b349d732f94d1ef/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ferror.rs?ref=edc6ce30d540f114ed73d3936b349d732f94d1ef", "patch": "@@ -57,6 +57,10 @@ pub enum EvalError<'tcx> {\n         access: AccessKind,\n         lock: LockInfo,\n     },\n+    InvalidMemoryLockRelease {\n+        ptr: MemoryPointer,\n+        len: u64,\n+    },\n     CalledClosureAsFunction,\n     VtableForArgumentlessMethod,\n     ModifiedConstantMemory,\n@@ -108,6 +112,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"memory access conflicts with lock\",\n             DeallocatedLockedMemory =>\n                 \"deallocated memory while a lock was held\",\n+            InvalidMemoryLockRelease { .. } =>\n+                \"memory lock released that was never acquired\",\n             ReadPointerAsBytes =>\n                 \"a raw memory access tried to access part of a pointer value as raw bytes\",\n             ReadBytesAsPointer =>\n@@ -211,6 +217,10 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                 write!(f, \"{:?} access at {:?}, size {}, is in conflict with lock {:?}\",\n                        access, ptr, len, lock)\n             }\n+            InvalidMemoryLockRelease { ptr, len } => {\n+                write!(f, \"tried to release memory write lock at {:?}, size {}, which was not acquired by this function\",\n+                       ptr, len)\n+            }\n             NoMirFor(ref func) => write!(f, \"no mir for `{}`\", func),\n             FunctionPointerTyMismatch(sig, got) =>\n                 write!(f, \"tried to call a function with sig {} through a function pointer of type {}\", sig, got),"}, {"sha": "0fc9ec6b308a49d4304be4dea139c4873f61ef5d", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/edc6ce30d540f114ed73d3936b349d732f94d1ef/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc6ce30d540f114ed73d3936b349d732f94d1ef/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=edc6ce30d540f114ed73d3936b349d732f94d1ef", "patch": "@@ -342,6 +342,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             stmt: 0,\n         });\n \n+        let cur_frame = self.cur_frame();\n+        self.memory.set_cur_frame(cur_frame);\n+\n         if self.stack.len() > self.stack_limit {\n             Err(EvalError::StackFrameLimitReached)\n         } else {\n@@ -351,7 +354,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     pub(super) fn pop_stack_frame(&mut self) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation -= 1;\n+        self.memory.locks_lifetime_ended(None);\n         let frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n+        if !self.stack.is_empty() {\n+            // TODO: IS this the correct time to start considering these accesses as originating from the returned-to stack frame?\n+            let cur_frame = self.cur_frame();\n+            self.memory.set_cur_frame(cur_frame);\n+        }\n         match frame.return_to_block {\n             StackPopCleanup::MarkStatic(mutable) => if let Lvalue::Global(id) = frame.return_lvalue {\n                 let global_value = self.globals.get_mut(&id)"}, {"sha": "7a87ef8c2a552920a8d11fd93c6385c67fc2a0d8", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 90, "deletions": 20, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/edc6ce30d540f114ed73d3936b349d732f94d1ef/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc6ce30d540f114ed73d3936b349d732f94d1ef/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=edc6ce30d540f114ed73d3936b349d732f94d1ef", "patch": "@@ -18,7 +18,7 @@ use eval_context::EvalContext;\n mod range {\n     use super::*;\n \n-    // The derived `Ord` impl sorts first by the first field, then, if the fields are the same\n+    // The derived `Ord` impl sorts first by the first field, then, if the fields are the same,\n     // by the second field.\n     // This is exactly what we need for our purposes, since a range query on a BTReeSet/BTreeMap will give us all\n     // `MemoryRange`s whose `start` is <= than the one we're looking for, but not > the end of the range we're checking.\n@@ -75,16 +75,16 @@ pub enum AccessKind {\n     Write,\n }\n \n-#[derive(Copy, Clone, Debug)]\n-struct DynamicLifetime {\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct DynamicLifetime {\n     frame: usize,\n-    region: CodeExtent,\n+    region: Option<CodeExtent>, // \"None\" indicates \"until the function ends\"\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum LockStatus {\n     Held,\n-    RecoverAfter(DynamicLifetime),\n+    RecoverAfter(CodeExtent), // the frame is given by the surrounding LockInfo's lifetime.\n }\n \n /// Information about a lock that is or will be held.\n@@ -138,7 +138,7 @@ pub struct Allocation {\n     /// Helps guarantee that stack allocations aren't deallocated via `rust_deallocate`\n     pub kind: Kind,\n     /// Memory regions that are locked by some function\n-    locks: BTreeMap<MemoryRange, LockInfo>,\n+    locks: BTreeMap<MemoryRange, Vec<LockInfo>>,\n }\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n@@ -427,19 +427,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub(crate) fn check_locks(&self, ptr: MemoryPointer, len: u64, access: AccessKind) -> EvalResult<'tcx> {\n-        let alloc = self.get(ptr.alloc_id)?;\n-        for (range, lock) in alloc.locks.range(MemoryRange::range(ptr.offset, len)) {\n-            // Check if the lock is active, overlaps this access, and is in conflict with the access.\n-            if let LockStatus::Held = lock.status {\n-                if range.overlaps(ptr.offset, len) && !lock.access_permitted(self.cur_frame, access) {\n-                    return Err(EvalError::MemoryLockViolation { ptr, len, access, lock: *lock });\n-                }\n-            }\n-        }\n-        Ok(())\n-    }\n-\n     pub(crate) fn set_cur_frame(&mut self, cur_frame: usize) {\n         self.cur_frame = cur_frame;\n     }\n@@ -520,6 +507,89 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n }\n \n+/// Locking\n+impl<'a, 'tcx> Memory<'a, 'tcx> {\n+    pub(crate) fn check_locks(&self, ptr: MemoryPointer, len: u64, access: AccessKind) -> EvalResult<'tcx> {\n+        let alloc = self.get(ptr.alloc_id)?;\n+        for (range, locks) in alloc.locks.range(MemoryRange::range(ptr.offset, len)) {\n+            for lock in locks {\n+                // Check if the lock is active, overlaps this access, and is in conflict with the access.\n+                if lock.status == LockStatus::Held  && range.overlaps(ptr.offset, len) && !lock.access_permitted(self.cur_frame, access) {\n+                    return Err(EvalError::MemoryLockViolation { ptr, len, access, lock: *lock });\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Acquire the lock for the given lifetime\n+    pub(crate) fn acquire_lock(&mut self, ptr: MemoryPointer, len: u64, region: Option<CodeExtent>, kind: AccessKind) -> EvalResult<'tcx> {\n+        self.check_bounds(ptr.offset(len, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n+        self.check_locks(ptr, len, kind)?; // make sure we have the access we are acquiring\n+        let lifetime = DynamicLifetime { frame: self.cur_frame, region };\n+        let alloc = self.get_mut(ptr.alloc_id)?;\n+        alloc.locks.entry(MemoryRange::new(ptr.offset, len)).or_insert_with(|| Vec::new()).push(LockInfo { lifetime, kind, status: LockStatus::Held });\n+        Ok(())\n+    }\n+\n+    /// Release a lock prematurely\n+    pub(crate) fn release_lock_until(&mut self, ptr: MemoryPointer, len: u64, release_until: Option<CodeExtent>) -> EvalResult<'tcx> {\n+        // Make sure there are no read locks and no *other* write locks here\n+        if let Err(_) = self.check_locks(ptr, len, AccessKind::Write) {\n+            return Err(EvalError::InvalidMemoryLockRelease { ptr, len });\n+        }\n+        let cur_frame = self.cur_frame;\n+        let alloc = self.get_mut(ptr.alloc_id)?;\n+        {\n+            let lock_infos = alloc.locks.get_mut(&MemoryRange::new(ptr.offset, len)).ok_or(EvalError::InvalidMemoryLockRelease { ptr, len })?;\n+            let lock_info = match lock_infos.len() {\n+                0 => return Err(EvalError::InvalidMemoryLockRelease { ptr, len }),\n+                1 => &mut lock_infos[0],\n+                _ => bug!(\"There can not be overlapping locks when write access is possible.\"),\n+            };\n+            assert_eq!(lock_info.lifetime.frame, cur_frame);\n+            if let Some(ce) = release_until {\n+                lock_info.status = LockStatus::RecoverAfter(ce);\n+                return Ok(());\n+            }\n+        }\n+        // Falling through to here means we want to entirely remove the lock.  The control-flow is somewhat weird because of lexical lifetimes.\n+        alloc.locks.remove(&MemoryRange::new(ptr.offset, len));\n+        Ok(())\n+    }\n+\n+    pub(crate) fn locks_lifetime_ended(&mut self, ending_region: Option<CodeExtent>) {\n+        let cur_frame = self.cur_frame;\n+        let has_ended =  |lock: &LockInfo| -> bool {\n+            if lock.lifetime.frame != cur_frame {\n+                return false;\n+            }\n+            match ending_region {\n+                None => true, // When a function ends, we end *all* its locks. It's okay for a function to still have lifetime-related locks\n+                              // when it returns, that can happen e.g. with NLL when a lifetime can, but does not have to, extend beyond the\n+                              // end of a function.\n+                Some(ending_region) => lock.lifetime.region == Some(ending_region),\n+            }\n+        };\n+\n+        for alloc in self.alloc_map.values_mut() {\n+            for (_range, locks) in alloc.locks.iter_mut() {\n+                // Delete everything that ends now -- i.e., keep only all the other lifeimes.\n+                locks.retain(|lock| !has_ended(lock));\n+                // Activate locks that get recovered now\n+                if let Some(ending_region) = ending_region {\n+                    for lock in locks.iter_mut() {\n+                        if lock.lifetime.frame == cur_frame && lock.status == LockStatus::RecoverAfter(ending_region) {\n+                            lock.status = LockStatus::Held;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        // TODO: It may happen now that we leave empty vectors in the map.  Is it worth getting rid of them?\n+    }\n+}\n+\n /// Allocation accessors\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation> {"}]}