{"sha": "397b940225d71a90b77438e56d6b1ccc6a29e890", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5N2I5NDAyMjVkNzFhOTBiNzc0MzhlNTZkNmIxY2NjNmEyOWU4OTA=", "commit": {"author": {"name": "Martin Carton", "email": "cartonmartin+github@gmail.com", "date": "2016-05-02T12:52:43Z"}, "committer": {"name": "Martin Carton", "email": "cartonmartin+github@gmail.com", "date": "2016-05-02T12:52:43Z"}, "message": "Merge pull request #891 from oli-obk/doc_precise_spans\n\nmarkdown doc lints use exact span", "tree": {"sha": "b66cd553e3d97b7d22e77f69c0a8e07f4ac2bfe8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b66cd553e3d97b7d22e77f69c0a8e07f4ac2bfe8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/397b940225d71a90b77438e56d6b1ccc6a29e890", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/397b940225d71a90b77438e56d6b1ccc6a29e890", "html_url": "https://github.com/rust-lang/rust/commit/397b940225d71a90b77438e56d6b1ccc6a29e890", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/397b940225d71a90b77438e56d6b1ccc6a29e890/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6290b622ca18ca2561f638f6b0ad4cb59d63611", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6290b622ca18ca2561f638f6b0ad4cb59d63611", "html_url": "https://github.com/rust-lang/rust/commit/f6290b622ca18ca2561f638f6b0ad4cb59d63611"}, {"sha": "3a32c2c596d1aaef4ea2c6da4656828869564ff8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a32c2c596d1aaef4ea2c6da4656828869564ff8", "html_url": "https://github.com/rust-lang/rust/commit/3a32c2c596d1aaef4ea2c6da4656828869564ff8"}], "stats": {"total": 99, "additions": 48, "deletions": 51}, "files": [{"sha": "6212a025c2565acc947c4a3558ffc7015bee8487", "filename": "src/doc.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/397b940225d71a90b77438e56d6b1ccc6a29e890/src%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397b940225d71a90b77438e56d6b1ccc6a29e890/src%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc.rs?ref=397b940225d71a90b77438e56d6b1ccc6a29e890", "patch": "@@ -1,7 +1,6 @@\n use rustc::lint::*;\n-use std::borrow::Cow;\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, BytePos};\n use utils::span_lint;\n \n /// **What it does:** This lint checks for the presence of `_`, `::` or camel-case words outside\n@@ -43,48 +42,36 @@ impl LintPass for Doc {\n \n impl EarlyLintPass for Doc {\n     fn check_crate(&mut self, cx: &EarlyContext, krate: &ast::Crate) {\n-        check_attrs(cx, &self.valid_idents, &krate.attrs, krate.span);\n+        check_attrs(cx, &self.valid_idents, &krate.attrs);\n     }\n \n     fn check_item(&mut self, cx: &EarlyContext, item: &ast::Item) {\n-        check_attrs(cx, &self.valid_idents, &item.attrs, item.span);\n+        check_attrs(cx, &self.valid_idents, &item.attrs);\n     }\n }\n \n-/// Collect all doc attributes. Multiple `///` are represented in different attributes. `rustdoc`\n-/// has a pass to merge them, but we probably don\u2019t want to invoke that here.\n-fn collect_doc(attrs: &[ast::Attribute]) -> (Cow<str>, Option<Span>) {\n-    fn doc_and_span(attr: &ast::Attribute) -> Option<(&str, Span)> {\n+pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [ast::Attribute]) {\n+    let mut in_multiline = false;\n+    for attr in attrs {\n         if attr.node.is_sugared_doc {\n             if let ast::MetaItemKind::NameValue(_, ref doc) = attr.node.value.node {\n                 if let ast::LitKind::Str(ref doc, _) = doc.node {\n-                    return Some((&doc[..], attr.span));\n+                    // doc comments start with `///` or `//!`\n+                    let real_doc = &doc[3..];\n+                    let mut span = attr.span;\n+                    span.lo = span.lo + BytePos(3);\n+\n+                    // check for multiline code blocks\n+                    if real_doc.trim_left().starts_with(\"```\") {\n+                        in_multiline = !in_multiline;\n+                    }\n+                    if !in_multiline {\n+                        check_doc(cx, valid_idents, real_doc, span);\n+                    }\n                 }\n             }\n         }\n-\n-        None\n     }\n-    let doc_and_span: fn(_) -> _ = doc_and_span;\n-\n-    let mut doc_attrs = attrs.iter().filter_map(doc_and_span);\n-\n-    let count = doc_attrs.clone().take(2).count();\n-\n-    match count {\n-        0 => (\"\".into(), None),\n-        1 => {\n-            let (doc, span) = doc_attrs.next().unwrap_or_else(|| unreachable!());\n-            (doc.into(), Some(span))\n-        }\n-        _ => (doc_attrs.map(|s| format!(\"{}\\n\", s.0)).collect::<String>().into(), None),\n-    }\n-}\n-\n-pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [ast::Attribute], default_span: Span) {\n-    let (doc, span) = collect_doc(attrs);\n-    let span = span.unwrap_or(default_span);\n-    check_doc(cx, valid_idents, &doc, span);\n }\n \n macro_rules! jump_to {\n@@ -130,6 +117,15 @@ pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], doc: &str, span: Sp\n         }\n     }\n \n+    #[allow(cast_possible_truncation)]\n+    fn word_span(mut span: Span, begin: usize, end: usize) -> Span {\n+        debug_assert_eq!(end as u32 as usize, end);\n+        debug_assert_eq!(begin as u32 as usize, begin);\n+        span.hi = span.lo + BytePos(end as u32);\n+        span.lo = span.lo + BytePos(begin as u32);\n+        span\n+    }\n+\n     let len = doc.len();\n     let mut chars = doc.char_indices().peekable();\n     let mut current_word_begin = 0;\n@@ -146,6 +142,7 @@ pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], doc: &str, span: Sp\n                     '[' => {\n                         let end = jump_to!(chars, ']', len);\n                         let link_text = &doc[current_word_begin + 1..end];\n+                        let word_span = word_span(span, current_word_begin + 1, end + 1);\n \n                         match chars.peek() {\n                             Some(&(_, c)) => {\n@@ -156,18 +153,18 @@ pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], doc: &str, span: Sp\n                                 match c {\n                                     '(' => { // inline link\n                                         current_word_begin = jump_to!(chars, ')', len);\n-                                        check_doc(cx, valid_idents, link_text, span);\n+                                        check_doc(cx, valid_idents, link_text, word_span);\n                                     }\n                                     '[' => { // reference link\n                                         current_word_begin = jump_to!(chars, ']', len);\n-                                        check_doc(cx, valid_idents, link_text, span);\n+                                        check_doc(cx, valid_idents, link_text, word_span);\n                                     }\n                                     ':' => { // reference link\n                                         current_word_begin = jump_to!(chars, '\\n', len);\n                                     }\n                                     _ => { // automatic reference link\n                                         current_word_begin = jump_to!(@next_char, chars, len);\n-                                        check_doc(cx, valid_idents, link_text, span);\n+                                        check_doc(cx, valid_idents, link_text, word_span);\n                                     }\n                                 }\n                             }\n@@ -179,8 +176,8 @@ pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], doc: &str, span: Sp\n                             Some((end, _)) => end,\n                             None => len,\n                         };\n-\n-                        check_word(cx, valid_idents, &doc[current_word_begin..end], span);\n+                        let word_span = word_span(span, current_word_begin, end);\n+                        check_word(cx, valid_idents, &doc[current_word_begin..end], word_span);\n                         current_word_begin = jump_to!(@next_char, chars, len);\n                     }\n                 }"}, {"sha": "7a150ba378dc16f11a682618aaba4d014e81c564", "filename": "tests/compile-fail/doc.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/397b940225d71a90b77438e56d6b1ccc6a29e890/tests%2Fcompile-fail%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397b940225d71a90b77438e56d6b1ccc6a29e890/tests%2Fcompile-fail%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdoc.rs?ref=397b940225d71a90b77438e56d6b1ccc6a29e890", "patch": "@@ -7,14 +7,14 @@\n #![deny(doc_markdown)]\n \n /// The foo_bar function does _nothing_. See also foo::bar. (note the dot there)\n+//~^ ERROR: you should put `foo_bar` between ticks\n+//~| ERROR: you should put `foo::bar` between ticks\n /// Markdown is _weird_. I mean _really weird_.  This \\_ is ok. So is `_`. But not Foo::some_fun\n+//~^ ERROR: you should put `Foo::some_fun` between ticks\n /// which should be reported only once despite being __doubly bad__.\n /// be_sure_we_got_to_the_end_of_it\n+//~^ ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n fn foo_bar() {\n-//~^ ERROR: you should put `foo_bar` between ticks\n-//~| ERROR: you should put `foo::bar` between ticks\n-//~| ERROR: you should put `Foo::some_fun` between ticks\n-//~| ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n }\n \n /// That one tests multiline ticks.\n@@ -23,16 +23,16 @@ fn foo_bar() {\n /// _foo bar_\n /// ```\n /// be_sure_we_got_to_the_end_of_it\n-fn multiline_ticks() {\n //~^ ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n+fn multiline_ticks() {\n }\n \n /// This _is a test for\n /// multiline\n /// emphasis_.\n /// be_sure_we_got_to_the_end_of_it\n-fn test_emphasis() {\n //~^ ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n+fn test_emphasis() {\n }\n \n /// This tests units. See also #835.\n@@ -45,8 +45,8 @@ fn test_emphasis() {\n /// 32kB 32MB 32GB 32TB 32PB 32EB\n /// 32kb 32Mb 32Gb 32Tb 32Pb 32Eb\n /// be_sure_we_got_to_the_end_of_it\n-fn test_units() {\n //~^ ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n+fn test_units() {\n }\n \n /// This one checks we don\u2019t try to split unicode codepoints\n@@ -55,11 +55,15 @@ fn test_units() {\n /// `\ud83d\udca3`\n /// `\u2764\ufe0f`\n /// \u00df_foo\n+//~^ ERROR: you should put `\u00df_foo` between ticks\n /// \u211d_foo\n+//~^ ERROR: you should put `\u211d_foo` between ticks\n /// \ud83d\udca3_foo\n /// \u2764\ufe0f_foo\n /// foo_\u00df\n+//~^ ERROR: you should put `foo_\u00df` between ticks\n /// foo_\u211d\n+//~^ ERROR: you should put `foo_\u211d` between ticks\n /// foo_\ud83d\udca3\n /// foo_\u2764\ufe0f\n /// [\u00dfdummy text\u00df][foo_\u00df]\n@@ -75,18 +79,16 @@ fn test_units() {\n /// [foo_\ud83d\udca3]: dummy text\n /// [foo_\u2764\ufe0f]: dummy text\n /// be_sure_we_got_to_the_end_of_it\n+//~^ ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n fn test_unicode() {\n-//~^ ERROR: you should put `\u00df_foo` between ticks\n-//~| ERROR: you should put `\u211d_foo` between ticks\n-//~| ERROR: you should put `foo_\u00df` between ticks\n-//~| ERROR: you should put `foo_\u211d` between ticks\n-//~| ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n }\n \n /// This test has [a link_with_underscores][chunked-example] inside it. See #823.\n+//~^ ERROR: you should put `link_with_underscores` between ticks\n /// See also [the issue tracker](https://github.com/Manishearth/rust-clippy/search?q=doc_markdown&type=Issues)\n /// on GitHub (which is a camel-cased word, but is OK). And here is another [inline link][inline_link].\n /// It can also be [inline_link2].\n+//~^ ERROR: you should put `inline_link2` between ticks\n ///\n /// [chunked-example]: https://en.wikipedia.org/wiki/Chunked_transfer_encoding#Example\n /// [inline_link]: https://foobar\n@@ -98,10 +100,8 @@ fn test_unicode() {\n /// expression of the type  `_ <bit_op> m <cmp_op> c` (where `<bit_op>`\n /// is one of {`&`, '|'} and `<cmp_op>` is one of {`!=`, `>=`, `>` ,\n /// be_sure_we_got_to_the_end_of_it\n+//~^ ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n fn main() {\n-//~^ ERROR: you should put `inline_link2` between ticks\n-//~| ERROR: you should put `link_with_underscores` between ticks\n-//~| ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n     foo_bar();\n     multiline_ticks();\n     test_emphasis();"}]}