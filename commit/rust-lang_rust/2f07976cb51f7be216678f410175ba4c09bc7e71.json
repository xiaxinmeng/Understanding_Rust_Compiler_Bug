{"sha": "2f07976cb51f7be216678f410175ba4c09bc7e71", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMDc5NzZjYjUxZjdiZTIxNjY3OGY0MTAxNzViYTRjMDliYzdlNzE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-08T14:17:18Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-08T14:17:18Z"}, "message": "Merge #460\n\n460: Name resolution fixes r=flodiebold a=flodiebold\n\nFound two problems:\r\n - use tree desugaring lost the prefix if the path had just one segment (e.g. in `use foo::{bar, baz}`)\r\n - when resolving imports across source roots, it actually used the name of the segment from the other source root... so e.g. in `use ra_syntax::foo` it'd map `ra_syntax` to the import instead of `foo` :smile: \r\n\r\nBoth of these are one-line fixes, most of this is making it possible to write tests with multiple source roots.\r\n\r\nI also left in debug logs for the name resolution, in case it turns out there's still more to fix ;)\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "c1f4896435ecfa48470e08787a24a5e3b73cc4fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1f4896435ecfa48470e08787a24a5e3b73cc4fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f07976cb51f7be216678f410175ba4c09bc7e71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f07976cb51f7be216678f410175ba4c09bc7e71", "html_url": "https://github.com/rust-lang/rust/commit/2f07976cb51f7be216678f410175ba4c09bc7e71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f07976cb51f7be216678f410175ba4c09bc7e71/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "562b448f9e49235fd47dabca1a0ce53da65dec6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/562b448f9e49235fd47dabca1a0ce53da65dec6f", "html_url": "https://github.com/rust-lang/rust/commit/562b448f9e49235fd47dabca1a0ce53da65dec6f"}, {"sha": "946b0ba02c2ab126b1b1d29027e60f21915d631e", "url": "https://api.github.com/repos/rust-lang/rust/commits/946b0ba02c2ab126b1b1d29027e60f21915d631e", "html_url": "https://github.com/rust-lang/rust/commit/946b0ba02c2ab126b1b1d29027e60f21915d631e"}], "stats": {"total": 223, "additions": 203, "deletions": 20}, "files": [{"sha": "c9af38009d7f1b61b1029d2f25f43529e3b87b2e", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2f07976cb51f7be216678f410175ba4c09bc7e71/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f07976cb51f7be216678f410175ba4c09bc7e71/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=2f07976cb51f7be216678f410175ba4c09bc7e71", "patch": "@@ -15,6 +15,7 @@ pub(crate) struct MockDatabase {\n     events: Mutex<Option<Vec<salsa::Event<MockDatabase>>>>,\n     runtime: salsa::Runtime<MockDatabase>,\n     id_maps: Arc<IdMaps>,\n+    file_counter: u32,\n }\n \n impl MockDatabase {\n@@ -27,7 +28,7 @@ impl MockDatabase {\n     pub(crate) fn with_single_file(text: &str) -> (MockDatabase, SourceRoot, FileId) {\n         let mut db = MockDatabase::default();\n         let mut source_root = SourceRoot::default();\n-        let file_id = db.add_file(&mut source_root, \"/main.rs\", text);\n+        let file_id = db.add_file(WORKSPACE, &mut source_root, \"/main.rs\", text);\n         db.query_mut(ra_db::SourceRootQuery)\n             .set(WORKSPACE, Arc::new(source_root.clone()));\n \n@@ -51,6 +52,16 @@ impl MockDatabase {\n     fn from_fixture(fixture: &str) -> (MockDatabase, SourceRoot, Option<FilePosition>) {\n         let mut db = MockDatabase::default();\n \n+        let (source_root, pos) = db.add_fixture(WORKSPACE, fixture);\n+\n+        (db, source_root, pos)\n+    }\n+\n+    pub fn add_fixture(\n+        &mut self,\n+        source_root_id: SourceRootId,\n+        fixture: &str,\n+    ) -> (SourceRoot, Option<FilePosition>) {\n         let mut position = None;\n         let mut source_root = SourceRoot::default();\n         for entry in parse_fixture(fixture) {\n@@ -59,39 +70,51 @@ impl MockDatabase {\n                     position.is_none(),\n                     \"only one marker (<|>) per fixture is allowed\"\n                 );\n-                position =\n-                    Some(db.add_file_with_position(&mut source_root, &entry.meta, &entry.text));\n+                position = Some(self.add_file_with_position(\n+                    source_root_id,\n+                    &mut source_root,\n+                    &entry.meta,\n+                    &entry.text,\n+                ));\n             } else {\n-                db.add_file(&mut source_root, &entry.meta, &entry.text);\n+                self.add_file(source_root_id, &mut source_root, &entry.meta, &entry.text);\n             }\n         }\n-        db.query_mut(ra_db::SourceRootQuery)\n-            .set(WORKSPACE, Arc::new(source_root.clone()));\n-        (db, source_root, position)\n+        self.query_mut(ra_db::SourceRootQuery)\n+            .set(source_root_id, Arc::new(source_root.clone()));\n+        (source_root, position)\n     }\n \n-    fn add_file(&mut self, source_root: &mut SourceRoot, path: &str, text: &str) -> FileId {\n+    fn add_file(\n+        &mut self,\n+        source_root_id: SourceRootId,\n+        source_root: &mut SourceRoot,\n+        path: &str,\n+        text: &str,\n+    ) -> FileId {\n         assert!(path.starts_with('/'));\n         let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n-        let file_id = FileId(source_root.files.len() as u32);\n+        let file_id = FileId(self.file_counter);\n+        self.file_counter += 1;\n         let text = Arc::new(text.to_string());\n         self.query_mut(ra_db::FileTextQuery).set(file_id, text);\n         self.query_mut(ra_db::FileRelativePathQuery)\n             .set(file_id, path.clone());\n         self.query_mut(ra_db::FileSourceRootQuery)\n-            .set(file_id, WORKSPACE);\n+            .set(file_id, source_root_id);\n         source_root.files.insert(path, file_id);\n         file_id\n     }\n \n     fn add_file_with_position(\n         &mut self,\n+        source_root_id: SourceRootId,\n         source_root: &mut SourceRoot,\n         path: &str,\n         text: &str,\n     ) -> FilePosition {\n         let (offset, text) = extract_offset(text);\n-        let file_id = self.add_file(source_root, path, &text);\n+        let file_id = self.add_file(source_root_id, source_root, path, &text);\n         FilePosition { file_id, offset }\n     }\n }\n@@ -121,6 +144,7 @@ impl Default for MockDatabase {\n             events: Default::default(),\n             runtime: salsa::Runtime::default(),\n             id_maps: Default::default(),\n+            file_counter: 0,\n         };\n         db.query_mut(ra_db::CrateGraphQuery)\n             .set((), Default::default());\n@@ -138,6 +162,7 @@ impl salsa::ParallelDatabase for MockDatabase {\n             events: Default::default(),\n             runtime: self.runtime.snapshot(self),\n             id_maps: self.id_maps.clone(),\n+            file_counter: self.file_counter,\n         })\n     }\n }"}, {"sha": "20adc9ec48814dde717225da433a7d64d955e1c4", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2f07976cb51f7be216678f410175ba4c09bc7e71/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f07976cb51f7be216678f410175ba4c09bc7e71/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=2f07976cb51f7be216678f410175ba4c09bc7e71", "patch": "@@ -433,13 +433,15 @@ where\n                 continue;\n             }\n             if self.resolve_import(module_id, import)? {\n+                log::debug!(\"import {:?} resolved (or definite error)\", import);\n                 self.processed_imports.insert((module_id, i));\n             }\n         }\n         Ok(())\n     }\n \n     fn resolve_import(&mut self, module_id: ModuleId, import: &Import) -> Cancelable<bool> {\n+        log::debug!(\"resolving import: {:?}\", import);\n         let ptr = match import.kind {\n             ImportKind::Glob => return Ok(false),\n             ImportKind::Named(ptr) => ptr,\n@@ -450,8 +452,11 @@ where\n             PathKind::Super => {\n                 match module_id.parent(&self.module_tree) {\n                     Some(it) => it,\n-                    // TODO: error\n-                    None => return Ok(true), // this can't suddenly resolve if we just resolve some other imports\n+                    None => {\n+                        // TODO: error\n+                        log::debug!(\"super path in root module\");\n+                        return Ok(true); // this can't suddenly resolve if we just resolve some other imports\n+                    }\n                 }\n             }\n             PathKind::Crate => module_id.crate_root(&self.module_tree),\n@@ -462,13 +467,20 @@ where\n \n             let def_id = match self.result.per_module[&curr].items.get(name) {\n                 Some(res) if !res.def_id.is_none() => res.def_id,\n-                _ => return Ok(false),\n+                _ => {\n+                    log::debug!(\"path segment {:?} not found\", name);\n+                    return Ok(false);\n+                }\n             };\n \n             if !is_last {\n                 let type_def_id = if let Some(d) = def_id.take(Namespace::Types) {\n                     d\n                 } else {\n+                    log::debug!(\n+                        \"path segment {:?} resolved to value only, but is not last\",\n+                        name\n+                    );\n                     return Ok(false);\n                 };\n                 curr = match type_def_id.loc(self.db) {\n@@ -486,27 +498,49 @@ where\n                                 segments: import.path.segments[i + 1..].iter().cloned().collect(),\n                                 kind: PathKind::Crate,\n                             };\n+                            log::debug!(\"resolving {:?} in other source root\", path);\n                             let def_id = module.resolve_path(self.db, &path)?;\n                             if !def_id.is_none() {\n+                                let name = path.segments.last().unwrap();\n                                 self.update(module_id, |items| {\n                                     let res = Resolution {\n-                                        def_id: def_id,\n+                                        def_id,\n                                         import: Some(ptr),\n                                     };\n                                     items.items.insert(name.clone(), res);\n                                 });\n+                                log::debug!(\n+                                    \"resolved import {:?} ({:?}) cross-source root to {:?}\",\n+                                    name,\n+                                    import,\n+                                    def_id.map(|did| did.loc(self.db))\n+                                );\n                                 return Ok(true);\n                             } else {\n-                                return Ok(false);\n+                                log::debug!(\"rest of path did not resolve in other source root\");\n+                                return Ok(true);\n                             }\n                         }\n                     }\n-                    _ => return Ok(true), // this resolved to a non-module, so the path won't ever resolve\n+                    _ => {\n+                        log::debug!(\n+                            \"path segment {:?} resolved to non-module {:?}, but is not last\",\n+                            name,\n+                            type_def_id.loc(self.db)\n+                        );\n+                        return Ok(true); // this resolved to a non-module, so the path won't ever resolve\n+                    }\n                 }\n             } else {\n+                log::debug!(\n+                    \"resolved import {:?} ({:?}) within source root to {:?}\",\n+                    name,\n+                    import,\n+                    def_id.map(|did| did.loc(self.db))\n+                );\n                 self.update(module_id, |items| {\n                     let res = Resolution {\n-                        def_id: def_id,\n+                        def_id,\n                         import: Some(ptr),\n                     };\n                     items.items.insert(name.clone(), res);"}, {"sha": "c511c40b25e83b2ff73bb736b23e36ae42f46660", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 125, "deletions": 1, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/2f07976cb51f7be216678f410175ba4c09bc7e71/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f07976cb51f7be216678f410175ba4c09bc7e71/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=2f07976cb51f7be216678f410175ba4c09bc7e71", "patch": "@@ -1,7 +1,7 @@\n use std::sync::Arc;\n \n use salsa::Database;\n-use ra_db::{FilesDatabase, CrateGraph};\n+use ra_db::{FilesDatabase, CrateGraph, SourceRootId};\n use relative_path::RelativePath;\n use test_utils::assert_eq_text;\n \n@@ -78,6 +78,35 @@ fn item_map_smoke_test() {\n     );\n }\n \n+#[test]\n+fn use_trees() {\n+    let (item_map, module_id) = item_map(\n+        \"\n+        //- /lib.rs\n+        mod foo;\n+\n+        use crate::foo::bar::{Baz, Quux};\n+        <|>\n+\n+        //- /foo/mod.rs\n+        pub mod bar;\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+        pub enum Quux {};\n+    \",\n+    );\n+    check_module_item_map(\n+        &item_map,\n+        module_id,\n+        \"\n+            Baz: t v\n+            Quux: t\n+            foo: t\n+        \",\n+    );\n+}\n+\n #[test]\n fn re_exports() {\n     let (item_map, module_id) = item_map(\n@@ -198,6 +227,101 @@ fn item_map_across_crates() {\n     );\n }\n \n+#[test]\n+fn import_across_source_roots() {\n+    let (mut db, sr) = MockDatabase::with_files(\n+        \"\n+        //- /lib.rs\n+        pub mod a {\n+            pub mod b {\n+                pub struct C;\n+            }\n+        }\n+    \",\n+    );\n+    let lib_id = sr.files[RelativePath::new(\"/lib.rs\")];\n+\n+    let source_root = SourceRootId(1);\n+\n+    let (sr2, pos) = db.add_fixture(\n+        source_root,\n+        \"\n+        //- /main.rs\n+        use test_crate::a::b::C;\n+    \",\n+    );\n+    assert!(pos.is_none());\n+\n+    let main_id = sr2.files[RelativePath::new(\"/main.rs\")];\n+\n+    eprintln!(\"lib = {:?}, main = {:?}\", lib_id, main_id);\n+\n+    let mut crate_graph = CrateGraph::default();\n+    let main_crate = crate_graph.add_crate_root(main_id);\n+    let lib_crate = crate_graph.add_crate_root(lib_id);\n+    crate_graph.add_dep(main_crate, \"test_crate\".into(), lib_crate);\n+\n+    db.set_crate_graph(crate_graph);\n+\n+    let module = crate::source_binder::module_from_file_id(&db, main_id)\n+        .unwrap()\n+        .unwrap();\n+    let module_id = module.def_id.loc(&db).module_id;\n+    let item_map = db.item_map(source_root).unwrap();\n+\n+    check_module_item_map(\n+        &item_map,\n+        module_id,\n+        \"\n+            C: t v\n+            test_crate: t\n+        \",\n+    );\n+}\n+\n+#[test]\n+fn reexport_across_crates() {\n+    let (mut db, sr) = MockDatabase::with_files(\n+        \"\n+        //- /main.rs\n+        use test_crate::Baz;\n+\n+        //- /lib.rs\n+        pub use foo::Baz;\n+\n+        mod foo;\n+\n+        //- /foo.rs\n+        pub struct Baz;\n+    \",\n+    );\n+    let main_id = sr.files[RelativePath::new(\"/main.rs\")];\n+    let lib_id = sr.files[RelativePath::new(\"/lib.rs\")];\n+\n+    let mut crate_graph = CrateGraph::default();\n+    let main_crate = crate_graph.add_crate_root(main_id);\n+    let lib_crate = crate_graph.add_crate_root(lib_id);\n+    crate_graph.add_dep(main_crate, \"test_crate\".into(), lib_crate);\n+\n+    db.set_crate_graph(crate_graph);\n+\n+    let source_root = db.file_source_root(main_id);\n+    let module = crate::source_binder::module_from_file_id(&db, main_id)\n+        .unwrap()\n+        .unwrap();\n+    let module_id = module.def_id.loc(&db).module_id;\n+    let item_map = db.item_map(source_root).unwrap();\n+\n+    check_module_item_map(\n+        &item_map,\n+        module_id,\n+        \"\n+            Baz: t v\n+            test_crate: t\n+        \",\n+    );\n+}\n+\n #[test]\n fn typing_inside_a_function_should_not_invalidate_item_map() {\n     let (mut db, pos) = MockDatabase::with_position("}, {"sha": "370e10bb8e7ad5b38da296212bb28d4ec8f79766", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f07976cb51f7be216678f410175ba4c09bc7e71/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f07976cb51f7be216678f410175ba4c09bc7e71/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=2f07976cb51f7be216678f410175ba4c09bc7e71", "patch": "@@ -150,7 +150,7 @@ fn convert_path(prefix: Option<Path>, path: &ast::Path) -> Option<Path> {\n     let prefix = if let Some(qual) = path.qualifier() {\n         Some(convert_path(prefix, qual)?)\n     } else {\n-        None\n+        prefix\n     };\n     let segment = path.segment()?;\n     let res = match segment.kind()? {"}]}