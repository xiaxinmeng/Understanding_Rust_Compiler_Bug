{"sha": "bdcf6f56589f8367c8cc82f3f4f045dcaf53748d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkY2Y2ZjU2NTg5ZjgzNjdjOGNjODJmM2Y0ZjA0NWRjYWY1Mzc0OGQ=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-04-30T10:20:13Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-05-01T12:01:17Z"}, "message": "Introduce LowerCtx for path lowering", "tree": {"sha": "805a0387fa06a0dd73b800cfd52a36a509a08bc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/805a0387fa06a0dd73b800cfd52a36a509a08bc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d", "html_url": "https://github.com/rust-lang/rust/commit/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1635d22a355b08309661e3d54d22c6bc2b53e5e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1635d22a355b08309661e3d54d22c6bc2b53e5e1", "html_url": "https://github.com/rust-lang/rust/commit/1635d22a355b08309661e3d54d22c6bc2b53e5e1"}], "stats": {"total": 252, "additions": 172, "deletions": 80}, "files": [{"sha": "3155a469ba91ccf6b55b93974106e744c53d98a9", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=bdcf6f56589f8367c8cc82f3f4f045dcaf53748d", "patch": "@@ -1,12 +1,12 @@\n //! This module defines `AssistCtx` -- the API surface that is exposed to assists.\n use hir::Semantics;\n-use ra_db::FileRange;\n+use ra_db::{FileRange, Upcast};\n use ra_fmt::{leading_indent, reindent};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo::{self, find_covering_element, find_node_at_offset},\n-    AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, TextSize,\n-    TokenAtOffset,\n+    ast, AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange,\n+    TextSize, TokenAtOffset,\n };\n use ra_text_edit::TextEditBuilder;\n \n@@ -136,6 +136,9 @@ impl<'a> AssistCtx<'a> {\n     pub(crate) fn covering_node_for_range(&self, range: TextRange) -> SyntaxElement {\n         find_covering_element(self.source_file.syntax(), range)\n     }\n+    pub(crate) fn lower_path(&self, path: ast::Path) -> Option<hir::Path> {\n+        hir::Path::from_src(path, &hir::Hygiene::new(self.db.upcast(), self.frange.file_id.into()))\n+    }\n }\n \n pub(crate) struct AssistGroup<'a> {"}, {"sha": "9ac65ab397fa0eb005bcdb855228d081e0c060d1", "filename": "crates/ra_assists/src/ast_transform.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_assists%2Fsrc%2Fast_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_assists%2Fsrc%2Fast_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_transform.rs?ref=bdcf6f56589f8367c8cc82f3f4f045dcaf53748d", "patch": "@@ -85,6 +85,7 @@ impl<'a> SubstituteTypeParams<'a> {\n             ast::TypeRef::PathType(path_type) => path_type.path()?,\n             _ => return None,\n         };\n+        // FIXME: use `hir::Path::from_src` instead.\n         let path = hir::Path::from_ast(path)?;\n         let resolution = self.source_scope.resolve_hir_path(&path)?;\n         match resolution {\n@@ -128,6 +129,7 @@ impl<'a> QualifyPaths<'a> {\n             // don't try to qualify `Fn(Foo) -> Bar` paths, they are in prelude anyway\n             return None;\n         }\n+        // FIXME: use `hir::Path::from_src` instead.\n         let hir_path = hir::Path::from_ast(p.clone());\n         let resolution = self.source_scope.resolve_hir_path(&hir_path?)?;\n         match resolution {"}, {"sha": "ad59db392a2984eab55682f777856877c62fe9aa", "filename": "crates/ra_assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=bdcf6f56589f8367c8cc82f3f4f045dcaf53748d", "patch": "@@ -27,7 +27,7 @@ pub(crate) fn replace_qualified_name_with_use(ctx: AssistCtx) -> Option<Assist>\n         return None;\n     }\n \n-    let hir_path = hir::Path::from_ast(path.clone())?;\n+    let hir_path = ctx.lower_path(path.clone())?;\n     let segments = collect_hir_path_segments(&hir_path)?;\n     if segments.len() < 2 {\n         return None;"}, {"sha": "c5df4ac24da474e969eac53c332326164a49b214", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=bdcf6f56589f8367c8cc82f3f4f045dcaf53748d", "patch": "@@ -70,6 +70,7 @@ pub use hir_def::{\n     type_ref::Mutability,\n };\n pub use hir_expand::{\n-    name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc, MacroDefId, MacroFile, Origin,\n+    hygiene::Hygiene, name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc, MacroDefId,\n+    MacroFile, Origin,\n };\n pub use hir_ty::{display::HirDisplay, CallableDef};"}, {"sha": "c63d1b8473ef7dd931c05eafdb82f0f812446284", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=bdcf6f56589f8367c8cc82f3f4f045dcaf53748d", "patch": "@@ -224,7 +224,8 @@ impl SourceAnalyzer {\n             }\n         }\n         // This must be a normal source file rather than macro file.\n-        let hir_path = crate::Path::from_ast(path.clone())?;\n+        let hir_path =\n+            crate::Path::from_src(path.clone(), &Hygiene::new(db.upcast(), self.file_id))?;\n         resolve_hir_path(db, &self.resolver, &hir_path)\n     }\n "}, {"sha": "8eef518283536b4a65d21bf1b78dfa7677bf57ad", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=bdcf6f56589f8367c8cc82f3f4f045dcaf53748d", "patch": "@@ -12,9 +12,15 @@ use ra_prof::profile;\n use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner, VisibilityOwner};\n \n use crate::{\n-    body::CfgExpander, db::DefDatabase, src::HasChildSource, src::HasSource, trace::Trace,\n-    type_ref::TypeRef, visibility::RawVisibility, EnumId, HasModule, LocalEnumVariantId,\n-    LocalFieldId, Lookup, ModuleId, StructId, UnionId, VariantId,\n+    body::{CfgExpander, LowerCtx},\n+    db::DefDatabase,\n+    src::HasChildSource,\n+    src::HasSource,\n+    trace::Trace,\n+    type_ref::TypeRef,\n+    visibility::RawVisibility,\n+    EnumId, HasModule, LocalEnumVariantId, LocalFieldId, Lookup, ModuleId, StructId, UnionId,\n+    VariantId,\n };\n \n /// Note that we use `StructData` for unions as well!\n@@ -198,6 +204,8 @@ fn lower_struct(\n     trace: &mut Trace<FieldData, Either<ast::TupleFieldDef, ast::RecordFieldDef>>,\n     ast: &InFile<ast::StructKind>,\n ) -> StructKind {\n+    let ctx = LowerCtx::new(db, ast.file_id);\n+\n     match &ast.value {\n         ast::StructKind::Tuple(fl) => {\n             for (i, fd) in fl.fields().enumerate() {\n@@ -210,7 +218,7 @@ fn lower_struct(\n                     || Either::Left(fd.clone()),\n                     || FieldData {\n                         name: Name::new_tuple_field(i),\n-                        type_ref: TypeRef::from_ast_opt(fd.type_ref()),\n+                        type_ref: TypeRef::from_ast_opt(&ctx, fd.type_ref()),\n                         visibility: RawVisibility::from_ast(db, ast.with_value(fd.visibility())),\n                     },\n                 );\n@@ -228,7 +236,7 @@ fn lower_struct(\n                     || Either::Right(fd.clone()),\n                     || FieldData {\n                         name: fd.name().map(|n| n.as_name()).unwrap_or_else(Name::missing),\n-                        type_ref: TypeRef::from_ast_opt(fd.ascribed_type()),\n+                        type_ref: TypeRef::from_ast_opt(&ctx, fd.ascribed_type()),\n                         visibility: RawVisibility::from_ast(db, ast.with_value(fd.visibility())),\n                     },\n                 );"}, {"sha": "4edaad9600afce6223a2f6b2eb42a227325d5d94", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=bdcf6f56589f8367c8cc82f3f4f045dcaf53748d", "patch": "@@ -15,6 +15,8 @@ use ra_prof::profile;\n use ra_syntax::{ast, AstNode, AstPtr};\n use rustc_hash::FxHashMap;\n \n+pub(crate) use lower::LowerCtx;\n+\n use crate::{\n     attr::Attrs,\n     db::DefDatabase,"}, {"sha": "e9dd65b0a436894f5b74b16c794ed102b32abafc", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=bdcf6f56589f8367c8cc82f3f4f045dcaf53748d", "patch": "@@ -3,8 +3,9 @@\n \n use either::Either;\n use hir_expand::{\n+    hygiene::Hygiene,\n     name::{name, AsName, Name},\n-    MacroDefId, MacroDefKind,\n+    HirFileId, MacroDefId, MacroDefKind,\n };\n use ra_arena::Arena;\n use ra_syntax::{\n@@ -26,7 +27,7 @@ use crate::{\n         LogicOp, MatchArm, Ordering, Pat, PatId, RecordFieldPat, RecordLitField, Statement,\n     },\n     item_scope::BuiltinShadowMode,\n-    path::GenericArgs,\n+    path::{GenericArgs, Path},\n     type_ref::{Mutability, TypeRef},\n     AdtId, ConstLoc, ContainerId, DefWithBodyId, EnumLoc, FunctionLoc, Intern, ModuleDefId,\n     StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n@@ -35,17 +36,37 @@ use crate::{\n use super::{ExprSource, PatSource};\n use ast::AstChildren;\n \n+pub(crate) struct LowerCtx {\n+    hygiene: Hygiene,\n+}\n+\n+impl LowerCtx {\n+    pub fn new(db: &dyn DefDatabase, file_id: HirFileId) -> Self {\n+        LowerCtx { hygiene: Hygiene::new(db.upcast(), file_id) }\n+    }\n+    pub fn with_hygiene(hygiene: &Hygiene) -> Self {\n+        LowerCtx { hygiene: hygiene.clone() }\n+    }\n+\n+    pub fn lower_path(&self, ast: ast::Path) -> Option<Path> {\n+        Path::from_src(ast, &self.hygiene)\n+    }\n+}\n+\n pub(super) fn lower(\n     db: &dyn DefDatabase,\n     def: DefWithBodyId,\n     expander: Expander,\n     params: Option<ast::ParamList>,\n     body: Option<ast::Expr>,\n ) -> (Body, BodySourceMap) {\n+    let ctx = LowerCtx::new(db, expander.current_file_id.clone());\n+\n     ExprCollector {\n         db,\n         def,\n         expander,\n+        ctx,\n         source_map: BodySourceMap::default(),\n         body: Body {\n             exprs: Arena::default(),\n@@ -62,7 +83,7 @@ struct ExprCollector<'a> {\n     db: &'a dyn DefDatabase,\n     def: DefWithBodyId,\n     expander: Expander,\n-\n+    ctx: LowerCtx,\n     body: Body,\n     source_map: BodySourceMap,\n }\n@@ -237,7 +258,8 @@ impl ExprCollector<'_> {\n                     Vec::new()\n                 };\n                 let method_name = e.name_ref().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n-                let generic_args = e.type_arg_list().and_then(GenericArgs::from_ast);\n+                let generic_args =\n+                    e.type_arg_list().and_then(|it| GenericArgs::from_ast(&self.ctx, it));\n                 self.alloc_expr(\n                     Expr::MethodCall { receiver, method_name, args, generic_args },\n                     syntax_ptr,\n@@ -343,7 +365,7 @@ impl ExprCollector<'_> {\n             }\n             ast::Expr::CastExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n-                let type_ref = TypeRef::from_ast_opt(e.type_ref());\n+                let type_ref = TypeRef::from_ast_opt(&self.ctx, e.type_ref());\n                 self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n             }\n             ast::Expr::RefExpr(e) => {\n@@ -365,12 +387,16 @@ impl ExprCollector<'_> {\n                 if let Some(pl) = e.param_list() {\n                     for param in pl.params() {\n                         let pat = self.collect_pat_opt(param.pat());\n-                        let type_ref = param.ascribed_type().map(TypeRef::from_ast);\n+                        let type_ref =\n+                            param.ascribed_type().map(|it| TypeRef::from_ast(&self.ctx, it));\n                         args.push(pat);\n                         arg_types.push(type_ref);\n                     }\n                 }\n-                let ret_type = e.ret_type().and_then(|r| r.type_ref()).map(TypeRef::from_ast);\n+                let ret_type = e\n+                    .ret_type()\n+                    .and_then(|r| r.type_ref())\n+                    .map(|it| TypeRef::from_ast(&self.ctx, it));\n                 let body = self.collect_expr_opt(e.body());\n                 self.alloc_expr(Expr::Lambda { args, arg_types, ret_type, body }, syntax_ptr)\n             }\n@@ -476,7 +502,7 @@ impl ExprCollector<'_> {\n             .map(|s| match s {\n                 ast::Stmt::LetStmt(stmt) => {\n                     let pat = self.collect_pat_opt(stmt.pat());\n-                    let type_ref = stmt.ascribed_type().map(TypeRef::from_ast);\n+                    let type_ref = stmt.ascribed_type().map(|it| TypeRef::from_ast(&self.ctx, it));\n                     let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n                     Statement::Let { pat, type_ref, initializer }\n                 }"}, {"sha": "7a2067e49cb7fef0f783d6e3c1ce4c6245c27722", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=bdcf6f56589f8367c8cc82f3f4f045dcaf53748d", "patch": "@@ -15,6 +15,7 @@ use ra_syntax::ast::{\n \n use crate::{\n     attr::Attrs,\n+    body::LowerCtx,\n     db::DefDatabase,\n     path::{path, AssociatedTypeBinding, GenericArgs, Path},\n     src::HasSource,\n@@ -40,13 +41,14 @@ impl FunctionData {\n     pub(crate) fn fn_data_query(db: &impl DefDatabase, func: FunctionId) -> Arc<FunctionData> {\n         let loc = func.lookup(db);\n         let src = loc.source(db);\n+        let ctx = LowerCtx::new(db, src.file_id);\n         let name = src.value.name().map(|n| n.as_name()).unwrap_or_else(Name::missing);\n         let mut params = Vec::new();\n         let mut has_self_param = false;\n         if let Some(param_list) = src.value.param_list() {\n             if let Some(self_param) = param_list.self_param() {\n                 let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n-                    TypeRef::from_ast(type_ref)\n+                    TypeRef::from_ast(&ctx, type_ref)\n                 } else {\n                     let self_type = TypeRef::Path(name![Self].into());\n                     match self_param.kind() {\n@@ -63,14 +65,14 @@ impl FunctionData {\n                 has_self_param = true;\n             }\n             for param in param_list.params() {\n-                let type_ref = TypeRef::from_ast_opt(param.ascribed_type());\n+                let type_ref = TypeRef::from_ast_opt(&ctx, param.ascribed_type());\n                 params.push(type_ref);\n             }\n         }\n         let attrs = Attrs::new(&src.value, &Hygiene::new(db.upcast(), src.file_id));\n \n         let ret_type = if let Some(type_ref) = src.value.ret_type().and_then(|rt| rt.type_ref()) {\n-            TypeRef::from_ast(type_ref)\n+            TypeRef::from_ast(&ctx, type_ref)\n         } else {\n             TypeRef::unit()\n         };\n@@ -122,15 +124,16 @@ impl TypeAliasData {\n         let loc = typ.lookup(db);\n         let node = loc.source(db);\n         let name = node.value.name().map_or_else(Name::missing, |n| n.as_name());\n-        let type_ref = node.value.type_ref().map(TypeRef::from_ast);\n+        let lower_ctx = LowerCtx::new(db, node.file_id);\n+        let type_ref = node.value.type_ref().map(|it| TypeRef::from_ast(&lower_ctx, it));\n         let vis_default = RawVisibility::default_for_container(loc.container);\n         let visibility = RawVisibility::from_ast_with_default(\n             db,\n             vis_default,\n             node.as_ref().map(|n| n.visibility()),\n         );\n         let bounds = if let Some(bound_list) = node.value.type_bound_list() {\n-            bound_list.bounds().map(TypeBound::from_ast).collect()\n+            bound_list.bounds().map(|it| TypeBound::from_ast(&lower_ctx, it)).collect()\n         } else {\n             Vec::new()\n         };\n@@ -223,9 +226,10 @@ impl ImplData {\n         let _p = profile(\"impl_data_query\");\n         let impl_loc = id.lookup(db);\n         let src = impl_loc.source(db);\n+        let lower_ctx = LowerCtx::new(db, src.file_id);\n \n-        let target_trait = src.value.target_trait().map(TypeRef::from_ast);\n-        let target_type = TypeRef::from_ast_opt(src.value.target_type());\n+        let target_trait = src.value.target_trait().map(|it| TypeRef::from_ast(&lower_ctx, it));\n+        let target_type = TypeRef::from_ast_opt(&lower_ctx, src.value.target_type());\n         let is_negative = src.value.excl_token().is_some();\n         let module_id = impl_loc.container.module(db);\n \n@@ -279,8 +283,9 @@ impl ConstData {\n         vis_default: RawVisibility,\n         node: InFile<N>,\n     ) -> ConstData {\n+        let ctx = LowerCtx::new(db, node.file_id);\n         let name = node.value.name().map(|n| n.as_name());\n-        let type_ref = TypeRef::from_ast_opt(node.value.ascribed_type());\n+        let type_ref = TypeRef::from_ast_opt(&ctx, node.value.ascribed_type());\n         let visibility =\n             RawVisibility::from_ast_with_default(db, vis_default, node.map(|n| n.visibility()));\n         ConstData { name, type_ref, visibility }"}, {"sha": "09a5241f7812b533f0e63c9509f2747a3eddd8c6", "filename": "crates/ra_hir_def/src/generics.rs", "status": "modified", "additions": 47, "deletions": 21, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=bdcf6f56589f8367c8cc82f3f4f045dcaf53748d", "patch": "@@ -15,6 +15,7 @@ use ra_prof::profile;\n use ra_syntax::ast::{self, NameOwner, TypeBoundsOwner, TypeParamsOwner};\n \n use crate::{\n+    body::LowerCtx,\n     child_by_source::ChildBySource,\n     db::DefDatabase,\n     dyn_map::DynMap,\n@@ -80,11 +81,13 @@ impl GenericParams {\n     fn new(db: &dyn DefDatabase, def: GenericDefId) -> (GenericParams, InFile<SourceMap>) {\n         let mut generics = GenericParams { types: Arena::default(), where_predicates: Vec::new() };\n         let mut sm = ArenaMap::default();\n+\n         // FIXME: add `: Sized` bound for everything except for `Self` in traits\n         let file_id = match def {\n             GenericDefId::FunctionId(it) => {\n                 let src = it.lookup(db).source(db);\n-                generics.fill(&mut sm, &src.value);\n+                let lower_ctx = LowerCtx::new(db, src.file_id);\n+                generics.fill(&lower_ctx, &mut sm, &src.value);\n                 // lower `impl Trait` in arguments\n                 let data = db.function_data(it);\n                 for param in &data.params {\n@@ -94,21 +97,25 @@ impl GenericParams {\n             }\n             GenericDefId::AdtId(AdtId::StructId(it)) => {\n                 let src = it.lookup(db).source(db);\n-                generics.fill(&mut sm, &src.value);\n+                let lower_ctx = LowerCtx::new(db, src.file_id);\n+                generics.fill(&lower_ctx, &mut sm, &src.value);\n                 src.file_id\n             }\n             GenericDefId::AdtId(AdtId::UnionId(it)) => {\n                 let src = it.lookup(db).source(db);\n-                generics.fill(&mut sm, &src.value);\n+                let lower_ctx = LowerCtx::new(db, src.file_id);\n+                generics.fill(&lower_ctx, &mut sm, &src.value);\n                 src.file_id\n             }\n             GenericDefId::AdtId(AdtId::EnumId(it)) => {\n                 let src = it.lookup(db).source(db);\n-                generics.fill(&mut sm, &src.value);\n+                let lower_ctx = LowerCtx::new(db, src.file_id);\n+                generics.fill(&lower_ctx, &mut sm, &src.value);\n                 src.file_id\n             }\n             GenericDefId::TraitId(it) => {\n                 let src = it.lookup(db).source(db);\n+                let lower_ctx = LowerCtx::new(db, src.file_id);\n \n                 // traits get the Self type as an implicit first type parameter\n                 let self_param_id = generics.types.alloc(TypeParamData {\n@@ -120,22 +127,26 @@ impl GenericParams {\n                 // add super traits as bounds on Self\n                 // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n                 let self_param = TypeRef::Path(name![Self].into());\n-                generics.fill_bounds(&src.value, self_param);\n+                generics.fill_bounds(&lower_ctx, &src.value, self_param);\n \n-                generics.fill(&mut sm, &src.value);\n+                generics.fill(&lower_ctx, &mut sm, &src.value);\n                 src.file_id\n             }\n             GenericDefId::TypeAliasId(it) => {\n                 let src = it.lookup(db).source(db);\n-                generics.fill(&mut sm, &src.value);\n+                let lower_ctx = LowerCtx::new(db, src.file_id);\n+\n+                generics.fill(&lower_ctx, &mut sm, &src.value);\n                 src.file_id\n             }\n             // Note that we don't add `Self` here: in `impl`s, `Self` is not a\n             // type-parameter, but rather is a type-alias for impl's target\n             // type, so this is handled by the resolver.\n             GenericDefId::ImplId(it) => {\n                 let src = it.lookup(db).source(db);\n-                generics.fill(&mut sm, &src.value);\n+                let lower_ctx = LowerCtx::new(db, src.file_id);\n+\n+                generics.fill(&lower_ctx, &mut sm, &src.value);\n                 src.file_id\n             }\n             // We won't be using this ID anyway\n@@ -145,28 +156,38 @@ impl GenericParams {\n         (generics, InFile::new(file_id, sm))\n     }\n \n-    fn fill(&mut self, sm: &mut SourceMap, node: &dyn TypeParamsOwner) {\n+    fn fill(&mut self, lower_ctx: &LowerCtx, sm: &mut SourceMap, node: &dyn TypeParamsOwner) {\n         if let Some(params) = node.type_param_list() {\n-            self.fill_params(sm, params)\n+            self.fill_params(lower_ctx, sm, params)\n         }\n         if let Some(where_clause) = node.where_clause() {\n-            self.fill_where_predicates(where_clause);\n+            self.fill_where_predicates(lower_ctx, where_clause);\n         }\n     }\n \n-    fn fill_bounds(&mut self, node: &dyn ast::TypeBoundsOwner, type_ref: TypeRef) {\n+    fn fill_bounds(\n+        &mut self,\n+        lower_ctx: &LowerCtx,\n+        node: &dyn ast::TypeBoundsOwner,\n+        type_ref: TypeRef,\n+    ) {\n         for bound in\n             node.type_bound_list().iter().flat_map(|type_bound_list| type_bound_list.bounds())\n         {\n-            self.add_where_predicate_from_bound(bound, type_ref.clone());\n+            self.add_where_predicate_from_bound(lower_ctx, bound, type_ref.clone());\n         }\n     }\n \n-    fn fill_params(&mut self, sm: &mut SourceMap, params: ast::TypeParamList) {\n+    fn fill_params(\n+        &mut self,\n+        lower_ctx: &LowerCtx,\n+        sm: &mut SourceMap,\n+        params: ast::TypeParamList,\n+    ) {\n         for type_param in params.type_params() {\n             let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n             // FIXME: Use `Path::from_src`\n-            let default = type_param.default_type().map(TypeRef::from_ast);\n+            let default = type_param.default_type().map(|it| TypeRef::from_ast(lower_ctx, it));\n             let param = TypeParamData {\n                 name: Some(name.clone()),\n                 default,\n@@ -176,29 +197,34 @@ impl GenericParams {\n             sm.insert(param_id, Either::Right(type_param.clone()));\n \n             let type_ref = TypeRef::Path(name.into());\n-            self.fill_bounds(&type_param, type_ref);\n+            self.fill_bounds(&lower_ctx, &type_param, type_ref);\n         }\n     }\n \n-    fn fill_where_predicates(&mut self, where_clause: ast::WhereClause) {\n+    fn fill_where_predicates(&mut self, lower_ctx: &LowerCtx, where_clause: ast::WhereClause) {\n         for pred in where_clause.predicates() {\n             let type_ref = match pred.type_ref() {\n                 Some(type_ref) => type_ref,\n                 None => continue,\n             };\n-            let type_ref = TypeRef::from_ast(type_ref);\n+            let type_ref = TypeRef::from_ast(lower_ctx, type_ref);\n             for bound in pred.type_bound_list().iter().flat_map(|l| l.bounds()) {\n-                self.add_where_predicate_from_bound(bound, type_ref.clone());\n+                self.add_where_predicate_from_bound(lower_ctx, bound, type_ref.clone());\n             }\n         }\n     }\n \n-    fn add_where_predicate_from_bound(&mut self, bound: ast::TypeBound, type_ref: TypeRef) {\n+    fn add_where_predicate_from_bound(\n+        &mut self,\n+        lower_ctx: &LowerCtx,\n+        bound: ast::TypeBound,\n+        type_ref: TypeRef,\n+    ) {\n         if bound.question_token().is_some() {\n             // FIXME: remove this bound\n             return;\n         }\n-        let bound = TypeBound::from_ast(bound);\n+        let bound = TypeBound::from_ast(lower_ctx, bound);\n         self.where_predicates\n             .push(WherePredicate { target: WherePredicateTarget::TypeRef(type_ref), bound });\n     }"}, {"sha": "e84efe2abd04e6edbfbd7f9f264a0b9c4611d945", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=bdcf6f56589f8367c8cc82f3f4f045dcaf53748d", "patch": "@@ -7,6 +7,7 @@ use std::{\n     sync::Arc,\n };\n \n+use crate::body::LowerCtx;\n use hir_expand::{\n     hygiene::Hygiene,\n     name::{AsName, Name},\n@@ -244,8 +245,8 @@ impl<'a> PathSegments<'a> {\n }\n \n impl GenericArgs {\n-    pub(crate) fn from_ast(node: ast::TypeArgList) -> Option<GenericArgs> {\n-        lower::lower_generic_args(node)\n+    pub(crate) fn from_ast(lower_ctx: &LowerCtx, node: ast::TypeArgList) -> Option<GenericArgs> {\n+        lower::lower_generic_args(lower_ctx, node)\n     }\n \n     pub(crate) fn empty() -> GenericArgs {"}, {"sha": "e3d237a0acb967b2ca06377b94a688e84863780b", "filename": "crates/ra_hir_def/src/path/lower.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs?ref=bdcf6f56589f8367c8cc82f3f4f045dcaf53748d", "patch": "@@ -13,6 +13,7 @@ use ra_syntax::ast::{self, AstNode, TypeAscriptionOwner, TypeBoundsOwner};\n \n use super::AssociatedTypeBinding;\n use crate::{\n+    body::LowerCtx,\n     path::{GenericArg, GenericArgs, ModPath, Path, PathKind},\n     type_ref::{TypeBound, TypeRef},\n };\n@@ -26,6 +27,7 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n     let mut type_anchor = None;\n     let mut segments = Vec::new();\n     let mut generic_args = Vec::new();\n+    let ctx = LowerCtx::with_hygiene(hygiene);\n     loop {\n         let segment = path.segment()?;\n \n@@ -40,9 +42,10 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n                     Either::Left(name) => {\n                         let args = segment\n                             .type_arg_list()\n-                            .and_then(lower_generic_args)\n+                            .and_then(|it| lower_generic_args(&ctx, it))\n                             .or_else(|| {\n                                 lower_generic_args_from_fn_path(\n+                                    &ctx,\n                                     segment.param_list(),\n                                     segment.ret_type(),\n                                 )\n@@ -60,7 +63,7 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n             ast::PathSegmentKind::Type { type_ref, trait_ref } => {\n                 assert!(path.qualifier().is_none()); // this can only occur at the first segment\n \n-                let self_type = TypeRef::from_ast(type_ref?);\n+                let self_type = TypeRef::from_ast(&ctx, type_ref?);\n \n                 match trait_ref {\n                     // <T>::foo\n@@ -128,10 +131,13 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n     }\n }\n \n-pub(super) fn lower_generic_args(node: ast::TypeArgList) -> Option<GenericArgs> {\n+pub(super) fn lower_generic_args(\n+    lower_ctx: &LowerCtx,\n+    node: ast::TypeArgList,\n+) -> Option<GenericArgs> {\n     let mut args = Vec::new();\n     for type_arg in node.type_args() {\n-        let type_ref = TypeRef::from_ast_opt(type_arg.type_ref());\n+        let type_ref = TypeRef::from_ast_opt(lower_ctx, type_arg.type_ref());\n         args.push(GenericArg::Type(type_ref));\n     }\n     // lifetimes ignored for now\n@@ -140,9 +146,9 @@ pub(super) fn lower_generic_args(node: ast::TypeArgList) -> Option<GenericArgs>\n         let assoc_type_arg: ast::AssocTypeArg = assoc_type_arg;\n         if let Some(name_ref) = assoc_type_arg.name_ref() {\n             let name = name_ref.as_name();\n-            let type_ref = assoc_type_arg.type_ref().map(TypeRef::from_ast);\n+            let type_ref = assoc_type_arg.type_ref().map(|it| TypeRef::from_ast(lower_ctx, it));\n             let bounds = if let Some(l) = assoc_type_arg.type_bound_list() {\n-                l.bounds().map(TypeBound::from_ast).collect()\n+                l.bounds().map(|it| TypeBound::from_ast(lower_ctx, it)).collect()\n             } else {\n                 Vec::new()\n             };\n@@ -159,6 +165,7 @@ pub(super) fn lower_generic_args(node: ast::TypeArgList) -> Option<GenericArgs>\n /// Collect `GenericArgs` from the parts of a fn-like path, i.e. `Fn(X, Y)\n /// -> Z` (which desugars to `Fn<(X, Y), Output=Z>`).\n fn lower_generic_args_from_fn_path(\n+    ctx: &LowerCtx,\n     params: Option<ast::ParamList>,\n     ret_type: Option<ast::RetType>,\n ) -> Option<GenericArgs> {\n@@ -167,14 +174,14 @@ fn lower_generic_args_from_fn_path(\n     if let Some(params) = params {\n         let mut param_types = Vec::new();\n         for param in params.params() {\n-            let type_ref = TypeRef::from_ast_opt(param.ascribed_type());\n+            let type_ref = TypeRef::from_ast_opt(&ctx, param.ascribed_type());\n             param_types.push(type_ref);\n         }\n         let arg = GenericArg::Type(TypeRef::Tuple(param_types));\n         args.push(arg);\n     }\n     if let Some(ret_type) = ret_type {\n-        let type_ref = TypeRef::from_ast_opt(ret_type.type_ref());\n+        let type_ref = TypeRef::from_ast_opt(&ctx, ret_type.type_ref());\n         bindings.push(AssociatedTypeBinding {\n             name: name![Output],\n             type_ref: Some(type_ref),"}, {"sha": "5bdad9efdef3276a61202853552bdac2b9907909", "filename": "crates/ra_hir_def/src/type_ref.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs?ref=bdcf6f56589f8367c8cc82f3f4f045dcaf53748d", "patch": "@@ -3,7 +3,7 @@\n \n use ra_syntax::ast::{self, TypeAscriptionOwner, TypeBoundsOwner};\n \n-use crate::path::Path;\n+use crate::{body::LowerCtx, path::Path};\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Mutability {\n@@ -64,30 +64,34 @@ pub enum TypeBound {\n \n impl TypeRef {\n     /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n-    pub(crate) fn from_ast(node: ast::TypeRef) -> Self {\n+    pub(crate) fn from_ast(ctx: &LowerCtx, node: ast::TypeRef) -> Self {\n         match node {\n-            ast::TypeRef::ParenType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n+            ast::TypeRef::ParenType(inner) => TypeRef::from_ast_opt(&ctx, inner.type_ref()),\n             ast::TypeRef::TupleType(inner) => {\n-                TypeRef::Tuple(inner.fields().map(TypeRef::from_ast).collect())\n+                TypeRef::Tuple(inner.fields().map(|it| TypeRef::from_ast(ctx, it)).collect())\n             }\n             ast::TypeRef::NeverType(..) => TypeRef::Never,\n             ast::TypeRef::PathType(inner) => {\n                 // FIXME: Use `Path::from_src`\n-                inner.path().and_then(Path::from_ast).map(TypeRef::Path).unwrap_or(TypeRef::Error)\n+                inner\n+                    .path()\n+                    .and_then(|it| ctx.lower_path(it))\n+                    .map(TypeRef::Path)\n+                    .unwrap_or(TypeRef::Error)\n             }\n             ast::TypeRef::PointerType(inner) => {\n-                let inner_ty = TypeRef::from_ast_opt(inner.type_ref());\n+                let inner_ty = TypeRef::from_ast_opt(&ctx, inner.type_ref());\n                 let mutability = Mutability::from_mutable(inner.mut_token().is_some());\n                 TypeRef::RawPtr(Box::new(inner_ty), mutability)\n             }\n             ast::TypeRef::ArrayType(inner) => {\n-                TypeRef::Array(Box::new(TypeRef::from_ast_opt(inner.type_ref())))\n+                TypeRef::Array(Box::new(TypeRef::from_ast_opt(&ctx, inner.type_ref())))\n             }\n             ast::TypeRef::SliceType(inner) => {\n-                TypeRef::Slice(Box::new(TypeRef::from_ast_opt(inner.type_ref())))\n+                TypeRef::Slice(Box::new(TypeRef::from_ast_opt(&ctx, inner.type_ref())))\n             }\n             ast::TypeRef::ReferenceType(inner) => {\n-                let inner_ty = TypeRef::from_ast_opt(inner.type_ref());\n+                let inner_ty = TypeRef::from_ast_opt(&ctx, inner.type_ref());\n                 let mutability = Mutability::from_mutable(inner.mut_token().is_some());\n                 TypeRef::Reference(Box::new(inner_ty), mutability)\n             }\n@@ -96,30 +100,33 @@ impl TypeRef {\n                 let ret_ty = inner\n                     .ret_type()\n                     .and_then(|rt| rt.type_ref())\n-                    .map(TypeRef::from_ast)\n+                    .map(|it| TypeRef::from_ast(ctx, it))\n                     .unwrap_or_else(|| TypeRef::Tuple(Vec::new()));\n                 let mut params = if let Some(pl) = inner.param_list() {\n-                    pl.params().map(|p| p.ascribed_type()).map(TypeRef::from_ast_opt).collect()\n+                    pl.params()\n+                        .map(|p| p.ascribed_type())\n+                        .map(|it| TypeRef::from_ast_opt(&ctx, it))\n+                        .collect()\n                 } else {\n                     Vec::new()\n                 };\n                 params.push(ret_ty);\n                 TypeRef::Fn(params)\n             }\n             // for types are close enough for our purposes to the inner type for now...\n-            ast::TypeRef::ForType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n+            ast::TypeRef::ForType(inner) => TypeRef::from_ast_opt(&ctx, inner.type_ref()),\n             ast::TypeRef::ImplTraitType(inner) => {\n-                TypeRef::ImplTrait(type_bounds_from_ast(inner.type_bound_list()))\n+                TypeRef::ImplTrait(type_bounds_from_ast(ctx, inner.type_bound_list()))\n             }\n             ast::TypeRef::DynTraitType(inner) => {\n-                TypeRef::DynTrait(type_bounds_from_ast(inner.type_bound_list()))\n+                TypeRef::DynTrait(type_bounds_from_ast(ctx, inner.type_bound_list()))\n             }\n         }\n     }\n \n-    pub(crate) fn from_ast_opt(node: Option<ast::TypeRef>) -> Self {\n+    pub(crate) fn from_ast_opt(ctx: &LowerCtx, node: Option<ast::TypeRef>) -> Self {\n         if let Some(node) = node {\n-            TypeRef::from_ast(node)\n+            TypeRef::from_ast(ctx, node)\n         } else {\n             TypeRef::Error\n         }\n@@ -180,24 +187,27 @@ impl TypeRef {\n     }\n }\n \n-pub(crate) fn type_bounds_from_ast(type_bounds_opt: Option<ast::TypeBoundList>) -> Vec<TypeBound> {\n+pub(crate) fn type_bounds_from_ast(\n+    lower_ctx: &LowerCtx,\n+    type_bounds_opt: Option<ast::TypeBoundList>,\n+) -> Vec<TypeBound> {\n     if let Some(type_bounds) = type_bounds_opt {\n-        type_bounds.bounds().map(TypeBound::from_ast).collect()\n+        type_bounds.bounds().map(|it| TypeBound::from_ast(lower_ctx, it)).collect()\n     } else {\n         vec![]\n     }\n }\n \n impl TypeBound {\n-    pub(crate) fn from_ast(node: ast::TypeBound) -> Self {\n+    pub(crate) fn from_ast(ctx: &LowerCtx, node: ast::TypeBound) -> Self {\n         match node.kind() {\n             ast::TypeBoundKind::PathType(path_type) => {\n                 let path = match path_type.path() {\n                     Some(p) => p,\n                     None => return TypeBound::Error,\n                 };\n-                // FIXME: Use `Path::from_src`\n-                let path = match Path::from_ast(path) {\n+\n+                let path = match ctx.lower_path(path) {\n                     Some(p) => p,\n                     None => return TypeBound::Error,\n                 };"}, {"sha": "53866bbcb7c1f287e4457d6253bd53d09c608a15", "filename": "crates/ra_hir_expand/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdcf6f56589f8367c8cc82f3f4f045dcaf53748d/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs?ref=bdcf6f56589f8367c8cc82f3f4f045dcaf53748d", "patch": "@@ -12,7 +12,7 @@ use crate::{\n     HirFileId, HirFileIdRepr, MacroCallId, MacroDefKind,\n };\n \n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n pub struct Hygiene {\n     // This is what `$crate` expands to\n     def_crate: Option<CrateId>,"}]}