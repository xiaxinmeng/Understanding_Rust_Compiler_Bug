{"sha": "c8fe232836f7ecf1b1d76d82a91c8d0022be2786", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4ZmUyMzI4MzZmN2VjZjFiMWQ3NmQ4MmE5MWM4ZDAwMjJiZTI3ODY=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-08-15T23:12:27Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-08-19T19:08:35Z"}, "message": "Add tagged pointer impl to data structures", "tree": {"sha": "dcb1de5186ab2fd1705632e07b6a1d580b742388", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcb1de5186ab2fd1705632e07b6a1d580b742388"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8fe232836f7ecf1b1d76d82a91c8d0022be2786", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8fe232836f7ecf1b1d76d82a91c8d0022be2786", "html_url": "https://github.com/rust-lang/rust/commit/c8fe232836f7ecf1b1d76d82a91c8d0022be2786", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8fe232836f7ecf1b1d76d82a91c8d0022be2786/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b287b56f97288cc4605329f76e31cb7604474aef", "url": "https://api.github.com/repos/rust-lang/rust/commits/b287b56f97288cc4605329f76e31cb7604474aef", "html_url": "https://github.com/rust-lang/rust/commit/b287b56f97288cc4605329f76e31cb7604474aef"}], "stats": {"total": 486, "additions": 486, "deletions": 0}, "files": [{"sha": "af4a7bd18813e28b3c774946e5ae3126825b3874", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8fe232836f7ecf1b1d76d82a91c8d0022be2786/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8fe232836f7ecf1b1d76d82a91c8d0022be2786/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=c8fe232836f7ecf1b1d76d82a91c8d0022be2786", "patch": "@@ -7,6 +7,7 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![allow(incomplete_features)]\n #![feature(in_band_lifetimes)]\n #![feature(unboxed_closures)]\n #![feature(generators)]\n@@ -23,6 +24,8 @@\n #![feature(associated_type_bounds)]\n #![feature(thread_id_value)]\n #![feature(extend_one)]\n+#![feature(const_panic)]\n+#![feature(const_generics)]\n #![allow(rustc::default_hash_types)]\n \n #[macro_use]\n@@ -97,6 +100,7 @@ pub mod vec_linked_list;\n pub mod work_queue;\n pub use atomic_ref::AtomicRef;\n pub mod frozen;\n+pub mod tagged_ptr;\n pub mod temp_dir;\n \n pub struct OnDrop<F: Fn()>(pub F);"}, {"sha": "e3839d193651d8c03e29cf409440cf91a3c8937b", "filename": "src/librustc_data_structures/tagged_ptr.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/c8fe232836f7ecf1b1d76d82a91c8d0022be2786/src%2Flibrustc_data_structures%2Ftagged_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8fe232836f7ecf1b1d76d82a91c8d0022be2786/src%2Flibrustc_data_structures%2Ftagged_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftagged_ptr.rs?ref=c8fe232836f7ecf1b1d76d82a91c8d0022be2786", "patch": "@@ -0,0 +1,157 @@\n+//! This module implements tagged pointers.\n+//!\n+//! In order to utilize the pointer packing, you must have two types: a pointer,\n+//! and a tag.\n+//!\n+//! The pointer must implement the `Pointer` trait, with the primary requirement\n+//! being conversion to and from a usize. Note that the pointer must be\n+//! dereferenceable, so raw pointers generally cannot implement the `Pointer`\n+//! trait. This implies that the pointer must also be nonzero.\n+//!\n+//! Many common pointer types already implement the `Pointer` trait.\n+//!\n+//! The tag must implement the `Tag` trait. We assert that the tag and `Pointer`\n+//! are compatible at compile time.\n+\n+use std::mem::ManuallyDrop;\n+use std::ops::Deref;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+mod copy;\n+mod drop;\n+\n+pub use copy::CopyTaggedPtr;\n+pub use drop::TaggedPtr;\n+\n+/// This describes the pointer type encaspulated by TaggedPtr.\n+///\n+/// # Safety\n+///\n+/// The usize returned from `into_usize` must be a valid, dereferenceable,\n+/// pointer to `<Self as Deref>::Target`. Note that pointers to `Pointee` must\n+/// be thin, even though `Pointee` may not be sized.\n+///\n+/// Note that the returned pointer from `into_usize` should be castable to `&mut\n+/// <Self as Deref>::Target` if `Pointer: DerefMut`.\n+///\n+/// The BITS constant must be correct. At least `BITS` bits, least-significant,\n+/// must be zero on all returned pointers from `into_usize`.\n+///\n+/// For example, if the alignment of `Pointee` is 2, then `BITS` should be 1.\n+pub unsafe trait Pointer: Deref {\n+    /// Most likely the value you want to use here is the following, unless\n+    /// your Pointee type is unsized (e.g., `ty::List<T>` in rustc) in which\n+    /// case you'll need to manually figure out what the right type to pass to\n+    /// align_of is.\n+    ///\n+    /// ```rust\n+    /// std::mem::align_of::<<Self as Deref>::Target>().trailing_zeros() as usize;\n+    /// ```\n+    const BITS: usize;\n+    fn into_usize(self) -> usize;\n+\n+    /// # Safety\n+    ///\n+    /// The passed `ptr` must be returned from `into_usize`.\n+    ///\n+    /// This acts as `ptr::read` semantically, it should not be called more than\n+    /// once on non-`Copy` `Pointer`s.\n+    unsafe fn from_usize(ptr: usize) -> Self;\n+\n+    /// This provides a reference to the `Pointer` itself, rather than the\n+    /// `Deref::Target`. It is used for cases where we want to call methods that\n+    /// may be implement differently for the Pointer than the Pointee (e.g.,\n+    /// `Rc::clone` vs cloning the inner value).\n+    ///\n+    /// # Safety\n+    ///\n+    /// The passed `ptr` must be returned from `into_usize`.\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R;\n+}\n+\n+/// This describes tags that the `TaggedPtr` struct can hold.\n+///\n+/// # Safety\n+///\n+/// The BITS constant must be correct.\n+///\n+/// No more than `BITS` least significant bits may be set in the returned usize.\n+pub unsafe trait Tag: Copy {\n+    const BITS: usize;\n+\n+    fn into_usize(self) -> usize;\n+\n+    /// # Safety\n+    ///\n+    /// The passed `tag` must be returned from `into_usize`.\n+    unsafe fn from_usize(tag: usize) -> Self;\n+}\n+\n+unsafe impl<T> Pointer for Box<T> {\n+    const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+    fn into_usize(self) -> usize {\n+        Box::into_raw(self) as usize\n+    }\n+    unsafe fn from_usize(ptr: usize) -> Self {\n+        Box::from_raw(ptr as *mut T)\n+    }\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n+        let raw = ManuallyDrop::new(Self::from_usize(ptr));\n+        f(&raw)\n+    }\n+}\n+\n+unsafe impl<T> Pointer for Rc<T> {\n+    const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+    fn into_usize(self) -> usize {\n+        Rc::into_raw(self) as usize\n+    }\n+    unsafe fn from_usize(ptr: usize) -> Self {\n+        Rc::from_raw(ptr as *const T)\n+    }\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n+        let raw = ManuallyDrop::new(Self::from_usize(ptr));\n+        f(&raw)\n+    }\n+}\n+\n+unsafe impl<T> Pointer for Arc<T> {\n+    const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+    fn into_usize(self) -> usize {\n+        Arc::into_raw(self) as usize\n+    }\n+    unsafe fn from_usize(ptr: usize) -> Self {\n+        Arc::from_raw(ptr as *const T)\n+    }\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n+        let raw = ManuallyDrop::new(Self::from_usize(ptr));\n+        f(&raw)\n+    }\n+}\n+\n+unsafe impl<'a, T: 'a> Pointer for &'a T {\n+    const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+    fn into_usize(self) -> usize {\n+        self as *const T as usize\n+    }\n+    unsafe fn from_usize(ptr: usize) -> Self {\n+        &*(ptr as *const T)\n+    }\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n+        f(&*(&ptr as *const usize as *const Self))\n+    }\n+}\n+\n+unsafe impl<'a, T: 'a> Pointer for &'a mut T {\n+    const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+    fn into_usize(self) -> usize {\n+        self as *mut T as usize\n+    }\n+    unsafe fn from_usize(ptr: usize) -> Self {\n+        &mut *(ptr as *mut T)\n+    }\n+    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n+        f(&*(&ptr as *const usize as *const Self))\n+    }\n+}"}, {"sha": "d39d146db318f230f11e8ff1ae909c14e2e47175", "filename": "src/librustc_data_structures/tagged_ptr/copy.rs", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/c8fe232836f7ecf1b1d76d82a91c8d0022be2786/src%2Flibrustc_data_structures%2Ftagged_ptr%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8fe232836f7ecf1b1d76d82a91c8d0022be2786/src%2Flibrustc_data_structures%2Ftagged_ptr%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftagged_ptr%2Fcopy.rs?ref=c8fe232836f7ecf1b1d76d82a91c8d0022be2786", "patch": "@@ -0,0 +1,183 @@\n+use super::{Pointer, Tag};\n+use crate::stable_hasher::{HashStable, StableHasher};\n+use std::fmt;\n+use std::marker::PhantomData;\n+use std::num::NonZeroUsize;\n+\n+/// A `Copy` TaggedPtr.\n+///\n+/// You should use this instead of the `TaggedPtr` type in all cases where\n+/// `P: Copy`.\n+///\n+/// If `COMPARE_PACKED` is true, then the pointers will be compared and hashed without\n+/// unpacking. Otherwise we don't implement PartialEq/Eq/Hash; if you want that,\n+/// wrap the TaggedPtr.\n+pub struct CopyTaggedPtr<P, T, const COMPARE_PACKED: bool>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    packed: NonZeroUsize,\n+    data: PhantomData<(P, T)>,\n+}\n+\n+impl<P, T, const COMPARE_PACKED: bool> Copy for CopyTaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer,\n+    T: Tag,\n+    P: Copy,\n+{\n+}\n+\n+impl<P, T, const COMPARE_PACKED: bool> Clone for CopyTaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer,\n+    T: Tag,\n+    P: Copy,\n+{\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+// We pack the tag into the *upper* bits of the pointer to ease retrieval of the\n+// value; a left shift is a multiplication and those are embeddable in\n+// instruction encoding.\n+impl<P, T, const COMPARE_PACKED: bool> CopyTaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    const TAG_BIT_SHIFT: usize = (8 * std::mem::size_of::<usize>()) - T::BITS;\n+    const ASSERTION: () = {\n+        assert!(T::BITS <= P::BITS);\n+        // Used for the transmute_copy's below\n+        assert!(std::mem::size_of::<&P::Target>() == std::mem::size_of::<usize>());\n+    };\n+\n+    pub fn new(pointer: P, tag: T) -> Self {\n+        // Trigger assert!\n+        let () = Self::ASSERTION;\n+        let packed_tag = tag.into_usize() << Self::TAG_BIT_SHIFT;\n+\n+        Self {\n+            // SAFETY: We know that the pointer is non-null, as it must be\n+            // dereferenceable per `Pointer` safety contract.\n+            packed: unsafe {\n+                NonZeroUsize::new_unchecked((P::into_usize(pointer) >> T::BITS) | packed_tag)\n+            },\n+            data: PhantomData,\n+        }\n+    }\n+\n+    pub(super) fn pointer_raw(&self) -> usize {\n+        self.packed.get() << T::BITS\n+    }\n+    pub fn pointer(self) -> P\n+    where\n+        P: Copy,\n+    {\n+        // SAFETY: pointer_raw returns the original pointer\n+        //\n+        // Note that this isn't going to double-drop or anything because we have\n+        // P: Copy\n+        unsafe { P::from_usize(self.pointer_raw()) }\n+    }\n+    pub fn pointer_ref(&self) -> &P::Target {\n+        // SAFETY: pointer_raw returns the original pointer\n+        unsafe { std::mem::transmute_copy(&self.pointer_raw()) }\n+    }\n+    pub fn pointer_mut(&mut self) -> &mut P::Target\n+    where\n+        P: std::ops::DerefMut,\n+    {\n+        // SAFETY: pointer_raw returns the original pointer\n+        unsafe { std::mem::transmute_copy(&self.pointer_raw()) }\n+    }\n+    pub fn tag(&self) -> T {\n+        unsafe { T::from_usize(self.packed.get() >> Self::TAG_BIT_SHIFT) }\n+    }\n+    pub fn set_tag(&mut self, tag: T) {\n+        let mut packed = self.packed.get();\n+        let new_tag = T::into_usize(tag) << Self::TAG_BIT_SHIFT;\n+        let tag_mask = (1 << T::BITS) - 1;\n+        packed &= !(tag_mask << Self::TAG_BIT_SHIFT);\n+        packed |= new_tag;\n+        self.packed = unsafe { NonZeroUsize::new_unchecked(packed) };\n+    }\n+}\n+\n+impl<P, T, const COMPARE_PACKED: bool> std::ops::Deref for CopyTaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    type Target = P::Target;\n+    fn deref(&self) -> &Self::Target {\n+        self.pointer_ref()\n+    }\n+}\n+\n+impl<P, T, const COMPARE_PACKED: bool> std::ops::DerefMut for CopyTaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer + std::ops::DerefMut,\n+    T: Tag,\n+{\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        self.pointer_mut()\n+    }\n+}\n+\n+impl<P, T, const COMPARE_PACKED: bool> fmt::Debug for CopyTaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer,\n+    P::Target: fmt::Debug,\n+    T: Tag + fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"CopyTaggedPtr\")\n+            .field(\"pointer\", &self.pointer_ref())\n+            .field(\"tag\", &self.tag())\n+            .finish()\n+    }\n+}\n+\n+impl<P, T> PartialEq for CopyTaggedPtr<P, T, true>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    fn eq(&self, other: &Self) -> bool {\n+        self.packed == other.packed\n+    }\n+}\n+\n+impl<P, T> Eq for CopyTaggedPtr<P, T, true>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+}\n+\n+impl<P, T> std::hash::Hash for CopyTaggedPtr<P, T, true>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+        self.packed.hash(state);\n+    }\n+}\n+\n+impl<P, T, HCX, const COMPARE_PACKED: bool> HashStable<HCX> for CopyTaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer + HashStable<HCX>,\n+    T: Tag + HashStable<HCX>,\n+{\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n+        unsafe {\n+            Pointer::with_ref(self.pointer_raw(), |p: &P| p.hash_stable(hcx, hasher));\n+        }\n+        self.tag().hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "63f64beae5a07089e24bebecb2b35f8d882361e2", "filename": "src/librustc_data_structures/tagged_ptr/drop.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/c8fe232836f7ecf1b1d76d82a91c8d0022be2786/src%2Flibrustc_data_structures%2Ftagged_ptr%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8fe232836f7ecf1b1d76d82a91c8d0022be2786/src%2Flibrustc_data_structures%2Ftagged_ptr%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftagged_ptr%2Fdrop.rs?ref=c8fe232836f7ecf1b1d76d82a91c8d0022be2786", "patch": "@@ -0,0 +1,142 @@\n+use super::{Pointer, Tag};\n+use crate::stable_hasher::{HashStable, StableHasher};\n+use std::fmt;\n+\n+use super::CopyTaggedPtr;\n+\n+/// A TaggedPtr implementing `Drop`.\n+///\n+/// If `COMPARE_PACKED` is true, then the pointers will be compared and hashed without\n+/// unpacking. Otherwise we don't implement PartialEq/Eq/Hash; if you want that,\n+/// wrap the TaggedPtr.\n+pub struct TaggedPtr<P, T, const COMPARE_PACKED: bool>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    raw: CopyTaggedPtr<P, T, COMPARE_PACKED>,\n+}\n+\n+impl<P, T, const COMPARE_PACKED: bool> Clone for TaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer + Clone,\n+    T: Tag,\n+{\n+    fn clone(&self) -> Self {\n+        unsafe { Self::new(P::with_ref(self.raw.pointer_raw(), |p| p.clone()), self.raw.tag()) }\n+    }\n+}\n+\n+// We pack the tag into the *upper* bits of the pointer to ease retrieval of the\n+// value; a right shift is a multiplication and those are embeddable in\n+// instruction encoding.\n+impl<P, T, const COMPARE_PACKED: bool> TaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    pub fn new(pointer: P, tag: T) -> Self {\n+        TaggedPtr { raw: CopyTaggedPtr::new(pointer, tag) }\n+    }\n+\n+    pub fn pointer_ref(&self) -> &P::Target {\n+        self.raw.pointer_ref()\n+    }\n+    pub fn pointer_mut(&mut self) -> &mut P::Target\n+    where\n+        P: std::ops::DerefMut,\n+    {\n+        self.raw.pointer_mut()\n+    }\n+    pub fn tag(&self) -> T {\n+        self.raw.tag()\n+    }\n+    pub fn set_tag(&mut self, tag: T) {\n+        self.raw.set_tag(tag);\n+    }\n+}\n+\n+impl<P, T, const COMPARE_PACKED: bool> std::ops::Deref for TaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    type Target = P::Target;\n+    fn deref(&self) -> &Self::Target {\n+        self.raw.pointer_ref()\n+    }\n+}\n+\n+impl<P, T, const COMPARE_PACKED: bool> std::ops::DerefMut for TaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer + std::ops::DerefMut,\n+    T: Tag,\n+{\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        self.raw.pointer_mut()\n+    }\n+}\n+\n+impl<P, T, const COMPARE_PACKED: bool> Drop for TaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    fn drop(&mut self) {\n+        // No need to drop the tag, as it's Copy\n+        unsafe {\n+            std::mem::drop(P::from_usize(self.raw.pointer_raw()));\n+        }\n+    }\n+}\n+\n+impl<P, T, const COMPARE_PACKED: bool> fmt::Debug for TaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer,\n+    P::Target: fmt::Debug,\n+    T: Tag + fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"TaggedPtr\")\n+            .field(\"pointer\", &self.pointer_ref())\n+            .field(\"tag\", &self.tag())\n+            .finish()\n+    }\n+}\n+\n+impl<P, T> PartialEq for TaggedPtr<P, T, true>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    fn eq(&self, other: &Self) -> bool {\n+        self.raw.eq(&other.raw)\n+    }\n+}\n+\n+impl<P, T> Eq for TaggedPtr<P, T, true>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+}\n+\n+impl<P, T> std::hash::Hash for TaggedPtr<P, T, true>\n+where\n+    P: Pointer,\n+    T: Tag,\n+{\n+    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+        self.raw.hash(state);\n+    }\n+}\n+\n+impl<P, T, HCX, const COMPARE_PACKED: bool> HashStable<HCX> for TaggedPtr<P, T, COMPARE_PACKED>\n+where\n+    P: Pointer + HashStable<HCX>,\n+    T: Tag + HashStable<HCX>,\n+{\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n+        self.raw.hash_stable(hcx, hasher);\n+    }\n+}"}]}