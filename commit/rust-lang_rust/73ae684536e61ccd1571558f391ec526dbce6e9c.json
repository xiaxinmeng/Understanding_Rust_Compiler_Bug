{"sha": "73ae684536e61ccd1571558f391ec526dbce6e9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczYWU2ODQ1MzZlNjFjY2QxNTcxNTU4ZjM5MWVjNTI2ZGJjZTZlOWM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-09T17:51:19Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-09T17:51:51Z"}, "message": "rustc: Don't resolve all type variables eagerly for paths", "tree": {"sha": "dff29a027bae0dfeec6cca4fe7058adec959a1e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dff29a027bae0dfeec6cca4fe7058adec959a1e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73ae684536e61ccd1571558f391ec526dbce6e9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73ae684536e61ccd1571558f391ec526dbce6e9c", "html_url": "https://github.com/rust-lang/rust/commit/73ae684536e61ccd1571558f391ec526dbce6e9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73ae684536e61ccd1571558f391ec526dbce6e9c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80f86d1e9b09b52d4c785c79843e76b5a9187e12", "url": "https://api.github.com/repos/rust-lang/rust/commits/80f86d1e9b09b52d4c785c79843e76b5a9187e12", "html_url": "https://github.com/rust-lang/rust/commit/80f86d1e9b09b52d4c785c79843e76b5a9187e12"}], "stats": {"total": 43, "additions": 25, "deletions": 18}, "files": [{"sha": "23caeb2456b9920d0d7cb9aedd6baf446557a6e4", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/73ae684536e61ccd1571558f391ec526dbce6e9c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73ae684536e61ccd1571558f391ec526dbce6e9c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=73ae684536e61ccd1571558f391ec526dbce6e9c", "patch": "@@ -23,8 +23,6 @@ import middle::ty::pat_ty;\n import middle::ty::path_to_str;\n import middle::ty::ty_param_substs_opt_and_ty;\n import middle::ty::ty_to_str;\n-import middle::ty::type_is_integral;\n-import middle::ty::type_is_scalar;\n import middle::ty::ty_param_count_and_ty;\n import middle::ty::ty_nil;\n import middle::ty::unify::ures_ok;\n@@ -76,22 +74,16 @@ fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &span sp, &ast::def defn)\n         case (ast::def_arg(?id)) {\n             assert (fcx.locals.contains_key(id));\n             auto typ = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(id));\n-            typ = ty::unify::resolve_all_vars(fcx.ccx.tcx, fcx.var_bindings,\n-                                              typ);\n             ret tup(0u, typ);\n         }\n         case (ast::def_local(?id)) {\n             assert (fcx.locals.contains_key(id));\n             auto typ = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(id));\n-            typ = ty::unify::resolve_all_vars(fcx.ccx.tcx, fcx.var_bindings,\n-                                              typ);\n             ret tup(0u, typ);\n         }\n         case (ast::def_obj_field(?id)) {\n             assert (fcx.locals.contains_key(id));\n             auto typ = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(id));\n-            typ = ty::unify::resolve_all_vars(fcx.ccx.tcx, fcx.var_bindings,\n-                                              typ);\n             ret tup(0u, typ);\n         }\n         case (ast::def_fn(?id)) {\n@@ -109,8 +101,6 @@ fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &span sp, &ast::def defn)\n         case (ast::def_binding(?id)) {\n             assert (fcx.locals.contains_key(id));\n             auto typ = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(id));\n-            typ = ty::unify::resolve_all_vars(fcx.ccx.tcx, fcx.var_bindings,\n-                                              typ);\n             ret tup(0u, typ);\n         }\n         case (ast::def_obj(?id)) {\n@@ -194,19 +184,37 @@ fn ast_mode_to_mode(ast::mode mode) -> ty::mode {\n     ret ty_mode;\n }\n \n-// Returns the one-level-deep structure of the given type.\n-fn structure_of(&@fn_ctxt fcx, &span sp, ty::t typ) -> ty::sty {\n+\n+// Type tests\n+\n+fn structurally_resolved_type(&@fn_ctxt fcx, &span sp, ty::t typ) -> ty::t {\n     auto r = ty::unify::resolve_type_structure(fcx.ccx.tcx, fcx.var_bindings,\n                                                typ);\n     alt (r) {\n-        case (fix_ok(?typ_s)) { ret ty::struct(fcx.ccx.tcx, typ_s); }\n+        case (fix_ok(?typ_s)) { ret typ_s; }\n         case (fix_err(_)) {\n             fcx.ccx.tcx.sess.span_err(sp, \"the type of this value must be \" +\n                 \"known in this context\");\n         }\n     }\n }\n \n+// Returns the one-level-deep structure of the given type.\n+fn structure_of(&@fn_ctxt fcx, &span sp, ty::t typ) -> ty::sty {\n+    ret ty::struct(fcx.ccx.tcx, structurally_resolved_type(fcx, sp, typ));\n+}\n+\n+fn type_is_integral(&@fn_ctxt fcx, &span sp, ty::t typ) -> bool {\n+    auto typ_s = structurally_resolved_type(fcx, sp, typ);\n+    ret ty::type_is_integral(fcx.ccx.tcx, typ_s);\n+}\n+\n+fn type_is_scalar(&@fn_ctxt fcx, &span sp, ty::t typ) -> bool {\n+    auto typ_s = structurally_resolved_type(fcx, sp, typ);\n+    ret ty::type_is_scalar(fcx.ccx.tcx, typ_s);\n+}\n+\n+\n // Parses the programmer's textual representation of a type into our internal\n // notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n@@ -1984,9 +1992,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             check_expr(fcx, e);\n             auto t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n             // FIXME: there are more forms of cast to support, eventually.\n-            if (! (type_is_scalar(fcx.ccx.tcx,\n-                    expr_ty(fcx.ccx.tcx, e)) &&\n-                    type_is_scalar(fcx.ccx.tcx, t_1))) {\n+            if (! (type_is_scalar(fcx, expr.span, expr_ty(fcx.ccx.tcx, e)) &&\n+                   type_is_scalar(fcx, expr.span, t_1))) {\n                 fcx.ccx.tcx.sess.span_err(expr.span,\n                     \"non-scalar cast: \" +\n                     ty_to_str(fcx.ccx.tcx,\n@@ -2148,7 +2155,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             auto idx_t = expr_ty(fcx.ccx.tcx, idx);\n             alt (structure_of(fcx, expr.span, base_t)) {\n                 case (ty::ty_vec(?mt)) {\n-                    if (! type_is_integral(fcx.ccx.tcx, idx_t)) {\n+                    if (! type_is_integral(fcx, idx.span, idx_t)) {\n                         fcx.ccx.tcx.sess.span_err\n                             (idx.span,\n                              \"non-integral type of vec index: \"\n@@ -2157,7 +2164,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     write::ty_only_fixup(fcx, a.id, mt.ty);\n                 }\n                 case (ty::ty_str) {\n-                    if (! type_is_integral(fcx.ccx.tcx, idx_t)) {\n+                    if (! type_is_integral(fcx, idx.span, idx_t)) {\n                         fcx.ccx.tcx.sess.span_err\n                             (idx.span,\n                              \"non-integral type of str index: \""}]}