{"sha": "3760bfab87498d71f9341ffac1aa027f26028656", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3NjBiZmFiODc0OThkNzFmOTM0MWZmYWMxYWEwMjdmMjYwMjg2NTY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-16T18:45:00Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-16T18:45:00Z"}, "message": "rustc: Don't rebuild AST patterns during typechecking", "tree": {"sha": "82e4fb4e60d955a498108cfb96ae10a0916efcf2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82e4fb4e60d955a498108cfb96ae10a0916efcf2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3760bfab87498d71f9341ffac1aa027f26028656", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3760bfab87498d71f9341ffac1aa027f26028656", "html_url": "https://github.com/rust-lang/rust/commit/3760bfab87498d71f9341ffac1aa027f26028656", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3760bfab87498d71f9341ffac1aa027f26028656/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca51b49c0a0122b2efd827fa96a656a8b1641efa", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca51b49c0a0122b2efd827fa96a656a8b1641efa", "html_url": "https://github.com/rust-lang/rust/commit/ca51b49c0a0122b2efd827fa96a656a8b1641efa"}], "stats": {"total": 57, "additions": 13, "deletions": 44}, "files": [{"sha": "4b1eea9e2fd4735f20abcb243c32a03711e8796a", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 13, "deletions": 44, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3760bfab87498d71f9341ffac1aa027f26028656/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3760bfab87498d71f9341ffac1aa027f26028656/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=3760bfab87498d71f9341ffac1aa027f26028656", "patch": "@@ -1086,37 +1086,24 @@ mod Pushdown {\n     //\n     // TODO: enforce this via a predicate.\n \n-    fn pushdown_pat(&@fn_ctxt fcx, &ty::t expected,\n-                    &@ast::pat pat) -> @ast::pat {\n-        auto p_1;\n-\n+    fn pushdown_pat(&@fn_ctxt fcx, &ty::t expected, &@ast::pat pat) {\n         alt (pat.node) {\n             case (ast::pat_wild(?ann)) {\n                 auto t = Demand::simple(fcx, pat.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n-                p_1 = ast::pat_wild(ast::ann_type(ast::ann_tag(ann), t,\n-                                                none[vec[ty::t]],\n-                                                none[@ts_ann]));\n                 write_type(fcx.ccx.node_types, ast::ann_tag(ann),\n                            tup(none[vec[ty::t]], t));\n             }\n             case (ast::pat_lit(?lit, ?ann)) {\n                 auto t = Demand::simple(fcx, pat.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n-                p_1 = ast::pat_lit(lit, ast::ann_type(ast::ann_tag(ann), t,\n-                                                    none[vec[ty::t]],\n-                                                    none[@ts_ann]));\n                 write_type(fcx.ccx.node_types, ast::ann_tag(ann),\n                            tup(none[vec[ty::t]], t));\n             }\n             case (ast::pat_bind(?id, ?did, ?ann)) {\n                 auto t = Demand::simple(fcx, pat.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n                 fcx.locals.insert(did, t);\n-                p_1 = ast::pat_bind(id, did, ast::ann_type(ast::ann_tag(ann),\n-                                                           t,\n-                                                           none[vec[ty::t]],\n-                                                           none[@ts_ann]));\n                 write_type(fcx.ccx.node_types, ast::ann_tag(ann),\n                            tup(none[vec[ty::t]], t));\n             }\n@@ -1141,22 +1128,18 @@ mod Pushdown {\n                     }\n                 }\n \n-                let vec[@ast::pat] subpats_1 = vec();\n                 auto i = 0u;\n                 for (@ast::pat subpat in subpats) {\n-                    subpats_1 += vec(pushdown_pat(fcx, arg_tys.(i), subpat));\n+                    pushdown_pat(fcx, arg_tys.(i), subpat);\n                     i += 1u;\n                 }\n \n                 // TODO: push down type from \"expected\".\n-                p_1 = ast::pat_tag(id, subpats_1, ann);\n                 write_type(fcx.ccx.node_types, ast::ann_tag(ann),\n                     ty::ann_to_ty_param_substs_opt_and_ty(fcx.ccx.node_types,\n                                                           ann));\n             }\n         }\n-\n-        ret @fold::respan[ast::pat_](pat.span, p_1);\n     }\n \n     // Push-down over typed expressions. Note that the expression that you\n@@ -1714,24 +1697,20 @@ fn check_lit(@crate_ctxt ccx, &@ast::lit lit) -> ty::t {\n     fail; // not reached\n }\n \n-fn check_pat(&@fn_ctxt fcx, &@ast::pat pat) -> @ast::pat {\n-    auto new_pat;\n+fn check_pat(&@fn_ctxt fcx, &@ast::pat pat) {\n     alt (pat.node) {\n         case (ast::pat_wild(?ann)) {\n             auto typ = next_ty_var(fcx.ccx);\n             write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), typ);\n-            new_pat = ast::pat_wild(triv_ann(ast::ann_tag(ann), typ));\n         }\n         case (ast::pat_lit(?lt, ?ann)) {\n             auto typ = check_lit(fcx.ccx, lt);\n             write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), typ);\n-            new_pat = ast::pat_lit(lt, triv_ann(ast::ann_tag(ann), typ));\n         }\n         case (ast::pat_bind(?id, ?def_id, ?a)) {\n             auto typ = next_ty_var(fcx.ccx);\n             auto ann = triv_ann(ast::ann_tag(a), typ);\n             write_type_only(fcx.ccx.node_types, ast::ann_tag(ann), typ);\n-            new_pat = ast::pat_bind(id, def_id, ann);\n         }\n         case (ast::pat_tag(?p, ?subpats, ?old_ann)) {\n             auto vdef = ast::variant_def_ids\n@@ -1763,14 +1742,10 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat) -> @ast::pat {\n                         fail;   // TODO: recover\n                     }\n \n-                    let vec[@ast::pat] new_subpats = vec();\n                     for (@ast::pat subpat in subpats) {\n-                        new_subpats += vec(check_pat(fcx, subpat));\n+                        check_pat(fcx, subpat);\n                     }\n \n-                    new_pat = ast::pat_tag(p, new_subpats,\n-                        ast::ann_type(ast::ann_tag(old_ann), path_tpot._1,\n-                                      path_tpot._0, none[@ts_ann]));\n                     write_type(fcx.ccx.node_types, ast::ann_tag(old_ann),\n                                path_tpot);\n                 }\n@@ -1790,17 +1765,12 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat) -> @ast::pat {\n                         fail;   // TODO: recover\n                     }\n \n-                    new_pat = ast::pat_tag(p, subpats,\n-                        ast::ann_type(ast::ann_tag(old_ann), path_tpot._1,\n-                                      path_tpot._0, none[@ts_ann]));\n                     write_type(fcx.ccx.node_types, ast::ann_tag(old_ann),\n                                path_tpot);\n                 }\n             }\n         }\n     }\n-\n-    ret @fold::respan[ast::pat_](pat.span, new_pat);\n }\n \n fn require_impure(&session::session sess,\n@@ -2427,17 +2397,16 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             auto pattern_ty = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n                                       expr_0);\n \n-            let vec[@ast::pat] pats_0 = vec();\n+            let vec[@ast::pat] pats = vec();\n             for (ast::arm arm in arms) {\n-                auto pat_0 = check_pat(fcx, arm.pat);\n-                pattern_ty = Demand::simple(fcx, pat_0.span, pattern_ty,\n-                    pat_ty(fcx.ccx.tcx, fcx.ccx.node_types, pat_0));\n-                pats_0 += vec(pat_0);\n+                check_pat(fcx, arm.pat);\n+                pattern_ty = Demand::simple(fcx, arm.pat.span, pattern_ty,\n+                    pat_ty(fcx.ccx.tcx, fcx.ccx.node_types, arm.pat));\n+                pats += vec(arm.pat);\n             }\n \n-            let vec[@ast::pat] pats_1 = vec();\n-            for (@ast::pat pat_0 in pats_0) {\n-                pats_1 += vec(Pushdown::pushdown_pat(fcx, pattern_ty, pat_0));\n+            for (@ast::pat pat in pats) {\n+                Pushdown::pushdown_pat(fcx, pattern_ty, pat);\n             }\n \n             // Now typecheck the blocks.\n@@ -2456,9 +2425,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             for (ast::block block_0 in blocks_0) {\n                 auto block_1 = Pushdown::pushdown_block(fcx, result_ty,\n                                                        block_0);\n-                auto pat_1 = pats_1.(i);\n+                auto pat = pats.(i);\n                 auto arm = arms.(i);\n-                auto arm_1 = rec(pat=pat_1, block=block_1);\n+                auto arm_1 = rec(pat=pat, block=block_1);\n                 arms_1 += vec(arm_1);\n                 i += 1u;\n             }"}]}