{"sha": "6808e414c7b29bfb066c1bbabff684bde1190a4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4MDhlNDE0YzdiMjliZmIwNjZjMWJiYWJmZjY4NGJkZTExOTBhNGU=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-03-27T13:25:48Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-01T00:56:07Z"}, "message": "rustc_trans::trans::consts add overflow checking", "tree": {"sha": "82a4d9f1f234b7294e7763e30b1dc727db4ee198", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82a4d9f1f234b7294e7763e30b1dc727db4ee198"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6808e414c7b29bfb066c1bbabff684bde1190a4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6808e414c7b29bfb066c1bbabff684bde1190a4e", "html_url": "https://github.com/rust-lang/rust/commit/6808e414c7b29bfb066c1bbabff684bde1190a4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6808e414c7b29bfb066c1bbabff684bde1190a4e/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b02f7d2faceac576760f9cd1bd49153b37172479", "url": "https://api.github.com/repos/rust-lang/rust/commits/b02f7d2faceac576760f9cd1bd49153b37172479", "html_url": "https://github.com/rust-lang/rust/commit/b02f7d2faceac576760f9cd1bd49153b37172479"}], "stats": {"total": 129, "additions": 124, "deletions": 5}, "files": [{"sha": "cf4675cbe46ac413b7a6ee1ec0dc4be1c4a10806", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 124, "deletions": 5, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/6808e414c7b29bfb066c1bbabff684bde1190a4e/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6808e414c7b29bfb066c1bbabff684bde1190a4e/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=6808e414c7b29bfb066c1bbabff684bde1190a4e", "patch": "@@ -14,6 +14,14 @@ use llvm;\n use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n use llvm::{InternalLinkage, ValueRef, Bool, True};\n use middle::{check_const, const_eval, def};\n+use middle::const_eval::{const_int_checked_neg, const_uint_checked_neg};\n+use middle::const_eval::{const_int_checked_add, const_uint_checked_add};\n+use middle::const_eval::{const_int_checked_sub, const_uint_checked_sub};\n+use middle::const_eval::{const_int_checked_mul, const_uint_checked_mul};\n+use middle::const_eval::{const_int_checked_div, const_uint_checked_div};\n+use middle::const_eval::{const_int_checked_rem, const_uint_checked_rem};\n+use middle::const_eval::{const_int_checked_shl, const_uint_checked_shl};\n+use middle::const_eval::{const_int_checked_shr, const_uint_checked_shr};\n use trans::{adt, closure, debuginfo, expr, inline, machine};\n use trans::base::{self, push_ctxt};\n use trans::common::*;\n@@ -336,6 +344,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let csize = machine::llsize_of_alloc(cx, val_ty(llconst));\n     let tsize = machine::llsize_of_alloc(cx, llty);\n     if csize != tsize {\n+        cx.sess().abort_if_errors();\n         unsafe {\n             // FIXME these values could use some context\n             llvm::LLVMDumpValue(llconst);\n@@ -348,6 +357,100 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     (llconst, ety_adjusted)\n }\n \n+fn check_unary_expr_validity(cx: &CrateContext, e: &ast::Expr, t: Ty,\n+                             te: ValueRef) {\n+    // The only kind of unary expression that we check for validity\n+    // here is `-expr`, to check if it \"overflows\" (e.g. `-i32::MIN`).\n+    if let ast::ExprUnary(ast::UnNeg, ref inner_e) = e.node {\n+\n+        // An unfortunate special case: we parse e.g. -128 as a\n+        // negation of the literal 128, which means if we're expecting\n+        // a i8 (or if it was already suffixed, e.g. `-128_i8`), then\n+        // 128 will have already overflowed to -128, and so then the\n+        // constant evaluator thinks we're trying to negate -128.\n+        //\n+        // Catch this up front by looking for ExprLit directly,\n+        // and just accepting it.\n+        if let ast::ExprLit(_) = inner_e.node { return; }\n+\n+        let result = match t.sty {\n+            ty::ty_int(int_type) => {\n+                let input = match const_to_opt_int(te) {\n+                    Some(v) => v,\n+                    None => return,\n+                };\n+                const_int_checked_neg(\n+                    input, e, Some(const_eval::IntTy::from(cx.tcx(), int_type)))\n+            }\n+            ty::ty_uint(uint_type) => {\n+                let input = match const_to_opt_uint(te) {\n+                    Some(v) => v,\n+                    None => return,\n+                };\n+                const_uint_checked_neg(\n+                    input, e, Some(const_eval::UintTy::from(cx.tcx(), uint_type)))\n+            }\n+            _ => return,\n+        };\n+\n+        // We do not actually care about a successful result.\n+        if let Err(err) = result {\n+            cx.tcx().sess.span_err(e.span, &err.description());\n+        }\n+    }\n+}\n+\n+fn check_binary_expr_validity(cx: &CrateContext, e: &ast::Expr, t: Ty,\n+                              te1: ValueRef, te2: ValueRef) {\n+    let b = if let ast::ExprBinary(b, _, _) = e.node { b } else { return };\n+\n+    let result = match t.sty {\n+        ty::ty_int(int_type) => {\n+            let (lhs, rhs) = match (const_to_opt_int(te1),\n+                                    const_to_opt_int(te2)) {\n+                (Some(v1), Some(v2)) => (v1, v2),\n+                _ => return,\n+            };\n+\n+            let opt_ety = Some(const_eval::IntTy::from(cx.tcx(), int_type));\n+            match b.node {\n+                ast::BiAdd => const_int_checked_add(lhs, rhs, e, opt_ety),\n+                ast::BiSub => const_int_checked_sub(lhs, rhs, e, opt_ety),\n+                ast::BiMul => const_int_checked_mul(lhs, rhs, e, opt_ety),\n+                ast::BiDiv => const_int_checked_div(lhs, rhs, e, opt_ety),\n+                ast::BiRem => const_int_checked_rem(lhs, rhs, e, opt_ety),\n+                ast::BiShl => const_int_checked_shl(lhs, rhs, e, opt_ety),\n+                ast::BiShr => const_int_checked_shr(lhs, rhs, e, opt_ety),\n+                _ => return,\n+            }\n+        }\n+        ty::ty_uint(uint_type) => {\n+            let (lhs, rhs) = match (const_to_opt_uint(te1),\n+                                    const_to_opt_uint(te2)) {\n+                (Some(v1), Some(v2)) => (v1, v2),\n+                _ => return,\n+            };\n+\n+            let opt_ety = Some(const_eval::UintTy::from(cx.tcx(), uint_type));\n+            match b.node {\n+                ast::BiAdd => const_uint_checked_add(lhs, rhs, e, opt_ety),\n+                ast::BiSub => const_uint_checked_sub(lhs, rhs, e, opt_ety),\n+                ast::BiMul => const_uint_checked_mul(lhs, rhs, e, opt_ety),\n+                ast::BiDiv => const_uint_checked_div(lhs, rhs, e, opt_ety),\n+                ast::BiRem => const_uint_checked_rem(lhs, rhs, e, opt_ety),\n+                ast::BiShl => const_uint_checked_shl(lhs, rhs, e, opt_ety),\n+                ast::BiShr => const_uint_checked_shr(lhs, rhs, e, opt_ety),\n+                _ => return,\n+            }\n+        }\n+        _ => return,\n+    };\n+    // We do not actually care about a successful result.\n+    if let Err(err) = result {\n+        cx.tcx().sess.span_err(e.span, &err.description());\n+    }\n+}\n+\n fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    e: &ast::Expr,\n                                    ety: Ty<'tcx>,\n@@ -386,7 +489,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let signed = ty::type_is_signed(intype);\n \n             let (te2, _) = const_expr(cx, &**e2, param_substs);\n-            let te2 = base::cast_shift_const_rhs(b.node, te1, te2);\n+\n+            check_binary_expr_validity(cx, e, ty, te1, te2);\n \n             match b.node {\n               ast::BiAdd   => {\n@@ -416,8 +520,12 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n               ast::BiBitXor => llvm::LLVMConstXor(te1, te2),\n               ast::BiBitAnd => llvm::LLVMConstAnd(te1, te2),\n               ast::BiBitOr  => llvm::LLVMConstOr(te1, te2),\n-              ast::BiShl    => llvm::LLVMConstShl(te1, te2),\n+              ast::BiShl    => {\n+                let te2 = base::cast_shift_const_rhs(b.node, te1, te2);\n+                llvm::LLVMConstShl(te1, te2)\n+              }\n               ast::BiShr    => {\n+                let te2 = base::cast_shift_const_rhs(b.node, te1, te2);\n                 if signed { llvm::LLVMConstAShr(te1, te2) }\n                 else      { llvm::LLVMConstLShr(te1, te2) }\n               }\n@@ -439,8 +547,11 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n               }\n             }\n           },\n-          ast::ExprUnary(u, ref e) => {\n-            let (te, ty) = const_expr(cx, &**e, param_substs);\n+          ast::ExprUnary(u, ref inner_e) => {\n+            let (te, ty) = const_expr(cx, &**inner_e, param_substs);\n+\n+            check_unary_expr_validity(cx, e, ty, te);\n+\n             let is_float = ty::type_is_fp(ty);\n             match u {\n               ast::UnUniq | ast::UnDeref => {\n@@ -664,7 +775,15 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let n = match const_eval::eval_const_expr_partial(cx.tcx(), &**count, None) {\n                 Ok(const_eval::const_int(i))  => i as usize,\n                 Ok(const_eval::const_uint(i)) => i as usize,\n-                _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n+                Ok(_) => {\n+                    cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n+                }\n+                Err(err) => {\n+                    cx.sess().span_err(count.span, &format!(\"error evaluating count: {}\",\n+                                                            err.description()));\n+                    // return 1 to allow compilation to proceed\n+                    1 as usize\n+                }\n             };\n             let unit_val = const_expr(cx, &**elem, param_substs).0;\n             let vs: Vec<_> = repeat(unit_val).take(n).collect();"}]}