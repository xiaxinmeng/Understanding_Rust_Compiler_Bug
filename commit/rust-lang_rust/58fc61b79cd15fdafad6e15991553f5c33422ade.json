{"sha": "58fc61b79cd15fdafad6e15991553f5c33422ade", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4ZmM2MWI3OWNkMTVmZGFmYWQ2ZTE1OTkxNTUzZjVjMzM0MjJhZGU=", "commit": {"author": {"name": "Dan Gohman", "email": "sunfish@mozilla.com", "date": "2020-07-07T22:56:07Z"}, "committer": {"name": "Dan Gohman", "email": "sunfish@mozilla.com", "date": "2020-07-07T23:04:52Z"}, "message": "Make WASI's FileExt's read_at/write_at consistent with other targets.\n\nRename the existing read_at/write_at to read_vectored_at/write_vectored_at,\nfor consistency with libstd's read_vectored/write_vectored. And,\nintroduce new read_at/write_at functions which take a single buffer,\nsimilar to all other targets which provide these functions, so this will\nmake it easier for applications to share code between WASI and other\ntargets.\n\nNote that WASI's FileExt is currently unstable.", "tree": {"sha": "7fa7e0535b0003ce049de6dd1bf35af1cf3bb863", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fa7e0535b0003ce049de6dd1bf35af1cf3bb863"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58fc61b79cd15fdafad6e15991553f5c33422ade", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58fc61b79cd15fdafad6e15991553f5c33422ade", "html_url": "https://github.com/rust-lang/rust/commit/58fc61b79cd15fdafad6e15991553f5c33422ade", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58fc61b79cd15fdafad6e15991553f5c33422ade/comments", "author": {"login": "sunfishcode", "id": 4503403, "node_id": "MDQ6VXNlcjQ1MDM0MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/4503403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunfishcode", "html_url": "https://github.com/sunfishcode", "followers_url": "https://api.github.com/users/sunfishcode/followers", "following_url": "https://api.github.com/users/sunfishcode/following{/other_user}", "gists_url": "https://api.github.com/users/sunfishcode/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunfishcode/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunfishcode/subscriptions", "organizations_url": "https://api.github.com/users/sunfishcode/orgs", "repos_url": "https://api.github.com/users/sunfishcode/repos", "events_url": "https://api.github.com/users/sunfishcode/events{/privacy}", "received_events_url": "https://api.github.com/users/sunfishcode/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sunfishcode", "id": 4503403, "node_id": "MDQ6VXNlcjQ1MDM0MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/4503403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunfishcode", "html_url": "https://github.com/sunfishcode", "followers_url": "https://api.github.com/users/sunfishcode/followers", "following_url": "https://api.github.com/users/sunfishcode/following{/other_user}", "gists_url": "https://api.github.com/users/sunfishcode/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunfishcode/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunfishcode/subscriptions", "organizations_url": "https://api.github.com/users/sunfishcode/orgs", "repos_url": "https://api.github.com/users/sunfishcode/repos", "events_url": "https://api.github.com/users/sunfishcode/events{/privacy}", "received_events_url": "https://api.github.com/users/sunfishcode/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "653c0912628382388ceb8a3cf29e88dad35b98ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/653c0912628382388ceb8a3cf29e88dad35b98ac", "html_url": "https://github.com/rust-lang/rust/commit/653c0912628382388ceb8a3cf29e88dad35b98ac"}], "stats": {"total": 47, "additions": 43, "deletions": 4}, "files": [{"sha": "f41c6626ccf120824fb683d8a5d850d471886a9d", "filename": "src/libstd/sys/wasi/ext/fs.rs", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/58fc61b79cd15fdafad6e15991553f5c33422ade/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58fc61b79cd15fdafad6e15991553f5c33422ade/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs?ref=58fc61b79cd15fdafad6e15991553f5c33422ade", "patch": "@@ -12,6 +12,24 @@ use crate::sys_common::{AsInner, AsInnerMut, FromInner};\n ///\n /// [`File`]: ../../../../std/fs/struct.File.html\n pub trait FileExt {\n+    /// Reads a number of bytes starting from a given offset.\n+    ///\n+    /// Returns the number of bytes read.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// Note that similar to [`File::read`], it is not an error to return with a\n+    /// short read.\n+    ///\n+    /// [`File::read`]: ../../../../std/fs/struct.File.html#method.read\n+    fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n+        let bufs = &mut [IoSliceMut::new(buf)];\n+        self.read_vectored_at(bufs, offset)\n+    }\n+\n     /// Reads a number of bytes starting from a given offset.\n     ///\n     /// Returns the number of bytes read.\n@@ -25,7 +43,7 @@ pub trait FileExt {\n     /// return with a short read.\n     ///\n     /// [`File::read`]: ../../../../std/fs/struct.File.html#method.read_vectored\n-    fn read_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize>;\n+    fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize>;\n \n     /// Reads the exact number of byte required to fill `buf` from the given offset.\n     ///\n@@ -79,6 +97,27 @@ pub trait FileExt {\n         }\n     }\n \n+    /// Writes a number of bytes starting from a given offset.\n+    ///\n+    /// Returns the number of bytes written.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// When writing beyond the end of the file, the file is appropriately\n+    /// extended and the intermediate bytes are initialized with the value 0.\n+    ///\n+    /// Note that similar to [`File::write`], it is not an error to return a\n+    /// short write.\n+    ///\n+    /// [`File::write`]: ../../../../std/fs/struct.File.html#write.v\n+    fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n+        let bufs = &[IoSlice::new(buf)];\n+        self.write_vectored_at(bufs, offset)\n+    }\n+\n     /// Writes a number of bytes starting from a given offset.\n     ///\n     /// Returns the number of bytes written.\n@@ -95,7 +134,7 @@ pub trait FileExt {\n     /// short write.\n     ///\n     /// [`File::write`]: ../../../../std/fs/struct.File.html#method.write_vectored\n-    fn write_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize>;\n+    fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize>;\n \n     /// Attempts to write an entire buffer starting from a given offset.\n     ///\n@@ -199,11 +238,11 @@ pub trait FileExt {\n // FIXME: bind random_get maybe? - on crates.io for unix\n \n impl FileExt for fs::File {\n-    fn read_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n+    fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n         self.as_inner().fd().pread(bufs, offset)\n     }\n \n-    fn write_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n+    fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n         self.as_inner().fd().pwrite(bufs, offset)\n     }\n "}]}