{"sha": "ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjNGRkOWVmZWU5MjQ4ZjRjMzIzNTQ2MGYzYzkzYWNjOTkzMmViNWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-11T00:51:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-11T00:51:20Z"}, "message": "auto merge of #10593 : metajack/rust/pkgid-hash, r=brson\n\nThis replaces the link meta attributes with a pkgid attribute and uses a hash\r\nof this as the crate hash. This makes the crate hash computable by things\r\nother than the Rust compiler. It also switches the hash function ot SHA1 since\r\nthat is much more likely to be available in shell, Python, etc than SipHash.\r\n\r\nFixes #10188, #8523.", "tree": {"sha": "cfd0eb4a1919cf127b1621e630f5ea8b0a802315", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfd0eb4a1919cf127b1621e630f5ea8b0a802315"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "html_url": "https://github.com/rust-lang/rust/commit/ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5aad292fb99f7e9a2730b35ed535bda0ab9c6117", "url": "https://api.github.com/repos/rust-lang/rust/commits/5aad292fb99f7e9a2730b35ed535bda0ab9c6117", "html_url": "https://github.com/rust-lang/rust/commit/5aad292fb99f7e9a2730b35ed535bda0ab9c6117"}, {"sha": "a16753c18844ad37d63ee00fe0292303afc990ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/a16753c18844ad37d63ee00fe0292303afc990ac", "html_url": "https://github.com/rust-lang/rust/commit/a16753c18844ad37d63ee00fe0292303afc990ac"}], "stats": {"total": 1868, "additions": 1263, "deletions": 605}, "files": [{"sha": "97c47178feb91dc4df7d351f7e550c5d91e49685", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -394,7 +394,8 @@ $(3)/stage$(1)/test/rustdoctest-$(2)$$(X_$(2)):\t\t\t\t\t\\\n \t\t$$(RUSTDOC_LIB) $$(RUSTDOC_INPUTS)\t\t\\\n \t\t$$(SREQ$(1)_T_$(2)_H_$(3)) \\\n \t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBSYNTAX_$(2)) \\\n-\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTC_$(2))\n+\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTC_$(2)) \\\n+\t\t$$(SUNDOWN_LIB_$(2))\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test \\\n \t\t-L $$(SUNDOWN_DIR_$(2))"}, {"sha": "9402578d5525a525c52f44176e3a4690c76a5ae5", "filename": "src/driver/driver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n #[cfg(rustpkg)]\n-extern mod this(name = \"rustpkg\");\n+extern mod this = \"rustpkg\";\n \n #[cfg(rustdoc)]\n-extern mod this(name = \"rustdoc\");\n+extern mod this = \"rustdoc\";\n \n #[cfg(rustc)]\n-extern mod this(name = \"rustc\");\n+extern mod this = \"rustc\";\n \n #[cfg(rustdoc_ng)]\n-extern mod this(name = \"rustdoc_ng\");\n+extern mod this = \"rustdoc_ng\";\n \n fn main() { this::main() }"}, {"sha": "afecf0875c05369d0b26cdd4f87eaca7238f70d8", "filename": "src/etc/combine-tests.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Fetc%2Fcombine-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Fetc%2Fcombine-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcombine-tests.py?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -42,6 +42,7 @@ def scrub(b):\n c = open(\"tmp/run_pass_stage2.rc\", \"w\")\n i = 0\n c.write(\"// AUTO-GENERATED FILE: DO NOT EDIT\\n\")\n+c.write(\"#[pkgid=\\\"run_pass_stage2#0.1\\\"];\\n\")\n c.write(\"#[link(name=\\\"run_pass_stage2\\\", vers=\\\"0.1\\\")];\\n\")\n c.write(\"#[feature(globs, macro_rules, struct_variant, managed_boxes)];\\n\")\n c.write(\"#[allow(attribute_usage)];\\n\")"}, {"sha": "6532ae3dc5cb02b6d20c6ff25b9c44ec85a8e14f", "filename": "src/libextra/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibextra%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibextra%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flib.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -20,6 +20,8 @@ Rust extras are part of the standard Rust distribution.\n \n */\n \n+#[pkgid=\"extra#0.9-pre\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"extra\",\n        package_id = \"extra\",\n        vers = \"0.9-pre\","}, {"sha": "786b463c37ec294c150587e70c6b36b41cfc665d", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 55, "deletions": 182, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -24,11 +24,10 @@ use middle::trans::common::gensym_name;\n use middle::ty;\n use util::common::time;\n use util::ppaux;\n+use util::sha2::{Digest, Sha256};\n \n use std::c_str::ToCStr;\n use std::char;\n-use std::hash::Streaming;\n-use std::hash;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n use std::ptr;\n use std::run;\n@@ -39,8 +38,8 @@ use syntax::abi;\n use syntax::ast;\n use syntax::ast_map::{path, path_mod, path_name, path_pretty_name};\n use syntax::attr;\n-use syntax::attr::{AttrMetaMethods};\n-use syntax::print::pprust;\n+use syntax::attr::AttrMetaMethods;\n+use syntax::pkgid::PkgId;\n \n #[deriving(Clone, Eq)]\n pub enum output_type {\n@@ -52,10 +51,6 @@ pub enum output_type {\n     output_type_exe,\n }\n \n-fn write_string<W:Writer>(writer: &mut W, string: &str) {\n-    writer.write(string.as_bytes());\n-}\n-\n pub fn llvm_err(sess: Session, msg: ~str) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n@@ -413,217 +408,90 @@ pub mod write {\n  *  - Symbols with the same name but different types need to get different\n  *    linkage-names. We do this by hashing a string-encoding of the type into\n  *    a fixed-size (currently 16-byte hex) cryptographic hash function (CHF:\n- *    we use SHA1) to \"prevent collisions\". This is not airtight but 16 hex\n+ *    we use SHA256) to \"prevent collisions\". This is not airtight but 16 hex\n  *    digits on uniform probability means you're going to need 2**32 same-name\n  *    symbols in the same process before you're even hitting birthday-paradox\n  *    collision probability.\n  *\n  *  - Symbols in different crates but with same names \"within\" the crate need\n  *    to get different linkage-names.\n  *\n- * So here is what we do:\n+ *  - The hash shown in the filename needs to be predictable and stable for\n+ *    build tooling integration. It also needs to be using a hash function\n+ *    which is easy to use from Python, make, etc.\n  *\n- *  - Separate the meta tags into two sets: exported and local. Only work with\n- *    the exported ones when considering linkage.\n+ * So here is what we do:\n  *\n- *  - Consider two exported tags as special (and mandatory): name and vers.\n- *    Every crate gets them; if it doesn't name them explicitly we infer them\n- *    as basename(crate) and \"0.1\", respectively. Call these CNAME, CVERS.\n+ *  - Consider the package id; every crate has one (specified with pkgid\n+ *    attribute).  If a package id isn't provided explicitly, we infer a\n+ *    versionless one from the output name. The version will end up being 0.0\n+ *    in this case. CNAME and CVERS are taken from this package id. For\n+ *    example, github.com/mozilla/CNAME#CVERS.\n  *\n- *  - Define CMETA as all the non-name, non-vers exported meta tags in the\n- *    crate (in sorted order).\n+ *  - Define CMH as SHA256(pkgid).\n  *\n- *  - Define CMH as hash(CMETA + hashes of dependent crates).\n+ *  - Define CMH8 as the first 8 characters of CMH.\n  *\n- *  - Compile our crate to lib CNAME-CMH-CVERS.so\n+ *  - Compile our crate to lib CNAME-CMH8-CVERS.so\n  *\n- *  - Define STH(sym) as hash(CNAME, CMH, type_str(sym))\n+ *  - Define STH(sym) as SHA256(CMH, type_str(sym))\n  *\n  *  - Suffix a mangled sym with ::STH@CVERS, so that it is unique in the\n  *    name, non-name metadata, and type sense, and versioned in the way\n  *    system linkers understand.\n- *\n  */\n \n pub fn build_link_meta(sess: Session,\n                        c: &ast::Crate,\n                        output: &Path,\n-                       symbol_hasher: &mut hash::State)\n+                       symbol_hasher: &mut Sha256)\n                        -> LinkMeta {\n-    struct ProvidedMetas {\n-        name: Option<@str>,\n-        vers: Option<@str>,\n-        pkg_id: Option<@str>,\n-        cmh_items: ~[@ast::MetaItem]\n-    }\n-\n-    fn provided_link_metas(sess: Session, c: &ast::Crate) ->\n-       ProvidedMetas {\n-        let mut name = None;\n-        let mut vers = None;\n-        let mut pkg_id = None;\n-        let mut cmh_items = ~[];\n-        let linkage_metas = attr::find_linkage_metas(c.attrs);\n-        attr::require_unique_names(sess.diagnostic(), linkage_metas);\n-        for meta in linkage_metas.iter() {\n-            match meta.name_str_pair() {\n-                Some((n, value)) if \"name\" == n => name = Some(value),\n-                Some((n, value)) if \"vers\" == n => vers = Some(value),\n-                Some((n, value)) if \"package_id\" == n => pkg_id = Some(value),\n-                _ => cmh_items.push(*meta)\n-            }\n-        }\n-\n-        ProvidedMetas {\n-            name: name,\n-            vers: vers,\n-            pkg_id: pkg_id,\n-            cmh_items: cmh_items\n-        }\n-    }\n-\n     // This calculates CMH as defined above\n-    fn crate_meta_extras_hash(symbol_hasher: &mut hash::State,\n-                              cmh_items: ~[@ast::MetaItem],\n-                              dep_hashes: ~[@str],\n-                              pkg_id: Option<@str>) -> @str {\n-        fn len_and_str(s: &str) -> ~str {\n-            format!(\"{}_{}\", s.len(), s)\n-        }\n-\n-        fn len_and_str_lit(l: ast::lit) -> ~str {\n-            len_and_str(pprust::lit_to_str(&l))\n-        }\n-\n-        let cmh_items = attr::sort_meta_items(cmh_items);\n-\n-        fn hash(symbol_hasher: &mut hash::State, m: &@ast::MetaItem) {\n-            match m.node {\n-              ast::MetaNameValue(key, value) => {\n-                write_string(symbol_hasher, len_and_str(key));\n-                write_string(symbol_hasher, len_and_str_lit(value));\n-              }\n-              ast::MetaWord(name) => {\n-                write_string(symbol_hasher, len_and_str(name));\n-              }\n-              ast::MetaList(name, ref mis) => {\n-                write_string(symbol_hasher, len_and_str(name));\n-                for m_ in mis.iter() {\n-                    hash(symbol_hasher, m_);\n-                }\n-              }\n-            }\n-        }\n-\n+    fn crate_hash(symbol_hasher: &mut Sha256, pkgid: &PkgId) -> @str {\n         symbol_hasher.reset();\n-        for m in cmh_items.iter() {\n-            hash(symbol_hasher, m);\n-        }\n-\n-        for dh in dep_hashes.iter() {\n-            write_string(symbol_hasher, len_and_str(*dh));\n-        }\n-\n-        for p in pkg_id.iter() {\n-            write_string(symbol_hasher, len_and_str(*p));\n-        }\n-\n-        return truncated_hash_result(symbol_hasher).to_managed();\n-    }\n-\n-    fn warn_missing(sess: Session, name: &str, default: &str) {\n-        if !*sess.building_library { return; }\n-        sess.warn(format!(\"missing crate link meta `{}`, using `{}` as default\",\n-                       name, default));\n-    }\n-\n-    fn crate_meta_name(sess: Session, output: &Path, opt_name: Option<@str>)\n-        -> @str {\n-        match opt_name {\n-            Some(v) if !v.is_empty() => v,\n-            _ => {\n-                // to_managed could go away if there was a version of\n-                // filestem that returned an @str\n-                // FIXME (#9639): Non-utf8 filenames will give a misleading error\n-                let name = session::expect(sess,\n-                                           output.filestem_str(),\n-                                           || format!(\"output file name `{}` doesn't\\\n-                                                    appear to have a stem\",\n-                                                   output.display())).to_managed();\n-                if name.is_empty() {\n-                    sess.fatal(\"missing crate link meta `name`, and the \\\n-                                inferred name is blank\");\n-                }\n-                warn_missing(sess, \"name\", name);\n-                name\n-            }\n-        }\n+        symbol_hasher.input_str(pkgid.to_str());\n+        truncated_hash_result(symbol_hasher).to_managed()\n     }\n \n-    fn crate_meta_vers(sess: Session, opt_vers: Option<@str>) -> @str {\n-        match opt_vers {\n-            Some(v) if !v.is_empty() => v,\n-            _ => {\n-                let vers = @\"0.0\";\n-                warn_missing(sess, \"vers\", vers);\n-                vers\n-            }\n+    let pkgid = match attr::find_pkgid(c.attrs) {\n+        None => {\n+            let stem = session::expect(\n+                sess,\n+                output.filestem_str(),\n+                || format!(\"output file name '{}' doesn't appear to have a stem\",\n+                           output.display()));\n+            from_str(stem).unwrap()\n         }\n-    }\n-\n-    fn crate_meta_pkgid(sess: Session, name: @str, opt_pkg_id: Option<@str>)\n-        -> @str {\n-        match opt_pkg_id {\n-            Some(v) if !v.is_empty() => v,\n-            _ => {\n-                let pkg_id = name.clone();\n-                warn_missing(sess, \"package_id\", pkg_id);\n-                pkg_id\n-            }\n-        }\n-    }\n+        Some(s) => s,\n+    };\n \n-    let ProvidedMetas {\n-        name: opt_name,\n-        vers: opt_vers,\n-        pkg_id: opt_pkg_id,\n-        cmh_items: cmh_items\n-    } = provided_link_metas(sess, c);\n-    let name = crate_meta_name(sess, output, opt_name);\n-    let vers = crate_meta_vers(sess, opt_vers);\n-    let pkg_id = crate_meta_pkgid(sess, name, opt_pkg_id);\n-    let dep_hashes = cstore::get_dep_hashes(sess.cstore);\n-    let extras_hash =\n-        crate_meta_extras_hash(symbol_hasher, cmh_items,\n-                               dep_hashes, Some(pkg_id));\n+    let hash = crate_hash(symbol_hasher, &pkgid);\n \n     LinkMeta {\n-        name: name,\n-        vers: vers,\n-        package_id: Some(pkg_id),\n-        extras_hash: extras_hash\n+        pkgid: pkgid,\n+        crate_hash: hash,\n     }\n }\n \n-pub fn truncated_hash_result(symbol_hasher: &mut hash::State) -> ~str {\n+pub fn truncated_hash_result(symbol_hasher: &mut Sha256) -> ~str {\n     symbol_hasher.result_str()\n }\n \n \n // This calculates STH for a symbol, as defined above\n pub fn symbol_hash(tcx: ty::ctxt,\n-                   symbol_hasher: &mut hash::State,\n+                   symbol_hasher: &mut Sha256,\n                    t: ty::t,\n-                   link_meta: LinkMeta) -> @str {\n+                   link_meta: &LinkMeta) -> @str {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n \n     symbol_hasher.reset();\n-    write_string(symbol_hasher, link_meta.name);\n-    write_string(symbol_hasher, \"-\");\n-    write_string(symbol_hasher, link_meta.extras_hash);\n-    write_string(symbol_hasher, \"-\");\n-    write_string(symbol_hasher, encoder::encoded_ty(tcx, t));\n+    symbol_hasher.input_str(link_meta.pkgid.name);\n+    symbol_hasher.input_str(\"-\");\n+    symbol_hasher.input_str(link_meta.crate_hash);\n+    symbol_hasher.input_str(\"-\");\n+    symbol_hasher.input_str(encoder::encoded_ty(tcx, t));\n     let mut hash = truncated_hash_result(symbol_hasher);\n     // Prefix with 'h' so that it never blends into adjacent digits\n     hash.unshift_char('h');\n@@ -635,7 +503,7 @@ pub fn get_symbol_hash(ccx: &mut CrateContext, t: ty::t) -> @str {\n     match ccx.type_hashcodes.find(&t) {\n       Some(&h) => h,\n       None => {\n-        let hash = symbol_hash(ccx.tcx, &mut ccx.symbol_hasher, t, ccx.link_meta);\n+        let hash = symbol_hash(ccx.tcx, &mut ccx.symbol_hasher, t, &ccx.link_meta);\n         ccx.type_hashcodes.insert(t, hash);\n         hash\n       }\n@@ -774,7 +642,7 @@ pub fn mangle_exported_name(ccx: &mut CrateContext,\n     let hash = get_symbol_hash(ccx, t);\n     return exported_name(ccx.sess, path,\n                          hash,\n-                         ccx.link_meta.vers);\n+                         ccx.link_meta.pkgid.version_or_default());\n }\n \n pub fn mangle_internal_name_by_type_only(ccx: &mut CrateContext,\n@@ -813,8 +681,11 @@ pub fn mangle_internal_name_by_path(ccx: &mut CrateContext, path: path) -> ~str\n     mangle(ccx.sess, path, None, None)\n }\n \n-pub fn output_lib_filename(lm: LinkMeta) -> ~str {\n-    format!(\"{}-{}-{}\", lm.name, lm.extras_hash, lm.vers)\n+pub fn output_lib_filename(lm: &LinkMeta) -> ~str {\n+    format!(\"{}-{}-{}\",\n+            lm.pkgid.name,\n+            lm.crate_hash.slice_chars(0, 8),\n+            lm.pkgid.version_or_default())\n }\n \n pub fn get_cc_prog(sess: Session) -> ~str {\n@@ -848,7 +719,8 @@ pub fn get_cc_prog(sess: Session) -> ~str {\n pub fn link_binary(sess: Session,\n                    trans: &CrateTranslation,\n                    obj_filename: &Path,\n-                   out_filename: &Path) {\n+                   out_filename: &Path,\n+                   lm: &LinkMeta) {\n     // If we're generating a test executable, then ignore all other output\n     // styles at all other locations\n     let outputs = if sess.opts.test {\n@@ -858,7 +730,7 @@ pub fn link_binary(sess: Session,\n     };\n \n     for output in outputs.move_iter() {\n-        link_binary_output(sess, trans, output, obj_filename, out_filename);\n+        link_binary_output(sess, trans, output, obj_filename, out_filename, lm);\n     }\n \n     // Remove the temporary object file and metadata if we aren't saving temps\n@@ -881,8 +753,9 @@ fn link_binary_output(sess: Session,\n                       trans: &CrateTranslation,\n                       output: session::OutputStyle,\n                       obj_filename: &Path,\n-                      out_filename: &Path) {\n-    let libname = output_lib_filename(trans.link);\n+                      out_filename: &Path,\n+                      lm: &LinkMeta) {\n+    let libname = output_lib_filename(lm);\n     let out_filename = match output {\n         session::OutputRlib => {\n             out_filename.with_filename(format!(\"lib{}.rlib\", libname))"}, {"sha": "ec0424994075d73aa3047e3351f1ae4c9598b4f1", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -389,7 +389,8 @@ pub fn phase_6_link_output(sess: Session,\n          link::link_binary(sess,\n                            trans,\n                            &outputs.obj_filename,\n-                           &outputs.out_filename));\n+                           &outputs.out_filename,\n+                           &trans.link));\n }\n \n pub fn stop_after_phase_3(sess: Session) -> bool {\n@@ -977,17 +978,13 @@ pub fn build_output_filenames(input: &input,\n               str_input(_) => @\"rust_out\"\n           };\n \n-          // If a linkage name meta is present, we use it as the link name\n-          let linkage_metas = attr::find_linkage_metas(attrs);\n-          if !linkage_metas.is_empty() {\n-              // But if a linkage meta is present, that overrides\n-              let maybe_name = linkage_metas.iter().find(|m| \"name\" == m.name());\n-              match maybe_name.and_then(|m| m.value_str()) {\n-                  Some(s) => stem = s,\n-                  _ => ()\n+          // If a pkgid is present, we use it as the link name\n+          let pkgid = attr::find_pkgid(attrs);\n+          match pkgid {\n+              None => {}\n+              Some(pkgid) => {\n+                  stem = pkgid.name.to_managed()\n               }\n-              // If the name is missing, we just default to the filename\n-              // version\n           }\n \n           if *sess.building_library {"}, {"sha": "090329bc4a09b8f92957d9b0636a5dd417f3ac8d", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"rustc#0.9-pre\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"rustc\",\n        package_id = \"rustc\",\n        vers = \"0.9-pre\",\n@@ -109,6 +111,7 @@ pub mod driver;\n pub mod util {\n     pub mod common;\n     pub mod ppaux;\n+    pub mod sha2;\n }\n \n pub mod lib {"}, {"sha": "bd6794b1d9ff76c92187587fcefa397e57174914", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -7,7 +7,9 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+\n use std::cast;\n+use syntax::pkgid::PkgId;\n \n // EBML enum definitions and utils shared by the encoder and decoder\n \n@@ -202,10 +204,8 @@ pub static tag_native_libraries_lib: uint = 0x104;\n pub static tag_native_libraries_name: uint = 0x105;\n pub static tag_native_libraries_kind: uint = 0x106;\n \n+#[deriving(Clone)]\n pub struct LinkMeta {\n-    name: @str,\n-    vers: @str,\n-    // Optional package ID\n-    package_id: Option<@str>, // non-None if this was a URL-like package ID\n-    extras_hash: @str\n+    pkgid: PkgId,\n+    crate_hash: @str,\n }"}, {"sha": "955ba54a404fd93e0efc8c625ec50f8e800ada4e", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 44, "deletions": 67, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -17,14 +17,14 @@ use metadata::loader;\n \n use std::hashmap::HashMap;\n use syntax::ast;\n-use std::vec;\n use syntax::abi;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{Span, dummy_sp};\n use syntax::diagnostic::span_handler;\n use syntax::parse::token;\n use syntax::parse::token::ident_interner;\n+use syntax::pkgid::PkgId;\n use syntax::visit;\n \n // Traverses an AST, reading all the information about use'd crates and extern\n@@ -64,7 +64,7 @@ struct cache_entry {\n     cnum: ast::CrateNum,\n     span: Span,\n     hash: @str,\n-    metas: @~[@ast::MetaItem]\n+    pkgid: PkgId,\n }\n \n fn dump_crates(crate_cache: &[cache_entry]) {\n@@ -80,12 +80,10 @@ fn warn_if_multiple_versions(e: @mut Env,\n                              diag: @mut span_handler,\n                              crate_cache: &[cache_entry]) {\n     if crate_cache.len() != 0u {\n-        let name = loader::crate_name_from_metas(\n-            *crate_cache[crate_cache.len() - 1].metas\n-        );\n+        let name = crate_cache[crate_cache.len() - 1].pkgid.name.clone();\n \n         let (matches, non_matches) = crate_cache.partitioned(|entry|\n-            name == loader::crate_name_from_metas(*entry.metas));\n+            name == entry.pkgid.name);\n \n         assert!(!matches.is_empty());\n \n@@ -94,11 +92,7 @@ fn warn_if_multiple_versions(e: @mut Env,\n                 format!(\"using multiple versions of crate `{}`\", name));\n             for match_ in matches.iter() {\n                 diag.span_note(match_.span, \"used here\");\n-                let attrs = ~[\n-                    attr::mk_attr(attr::mk_list_item(@\"link\",\n-                                                     (*match_.metas).clone()))\n-                ];\n-                loader::note_linkage_attrs(e.intr, diag, attrs);\n+                loader::note_pkgid_attr(diag, &match_.pkgid);\n             }\n         }\n \n@@ -129,28 +123,30 @@ fn visit_crate(e: &Env, c: &ast::Crate) {\n \n fn visit_view_item(e: @mut Env, i: &ast::view_item) {\n     match i.node {\n-      ast::view_item_extern_mod(ident, path_opt, ref meta_items, id) => {\n+      ast::view_item_extern_mod(ident, path_opt, _, id) => {\n           let ident = token::ident_to_str(&ident);\n-          let meta_items = match path_opt {\n-              None => meta_items.clone(),\n-              Some((p, _path_str_style)) => {\n-                  let p_path = Path::new(p);\n-                  match p_path.filestem_str() {\n-                      None|Some(\"\") =>\n-                          e.sess.span_bug(i.span, \"Bad package path in `extern mod` item\"),\n-                      Some(s) =>\n-                          vec::append(\n-                              ~[attr::mk_name_value_item_str(@\"package_id\", p),\n-                               attr::mk_name_value_item_str(@\"name\", s.to_managed())],\n-                              *meta_items)\n+          debug!(\"resolving extern mod stmt. ident: {:?} path_opt: {:?}\",\n+                 ident, path_opt);\n+          let (name, version) = match path_opt {\n+              Some((path_str, _)) => {\n+                  let pkgid: Option<PkgId> = from_str(path_str);\n+                  match pkgid {\n+                      None => (@\"\", @\"\"),\n+                      Some(pkgid) => {\n+                          let version = match pkgid.version {\n+                              None => @\"\",\n+                              Some(ref ver) => ver.to_managed(),\n+                          };\n+                          (pkgid.name.to_managed(), version)\n+                      }\n                   }\n-            }\n+              }\n+              None => (ident, @\"\"),\n           };\n-          debug!(\"resolving extern mod stmt. ident: {:?}, meta: {:?}\",\n-                 ident, meta_items);\n           let cnum = resolve_crate(e,\n                                    ident,\n-                                   meta_items,\n+                                   name,\n+                                   version,\n                                    @\"\",\n                                    i.span);\n           cstore::add_extern_mod_stmt_cnum(e.sess.cstore, id, cnum);\n@@ -233,46 +229,36 @@ fn visit_item(e: &Env, i: @ast::item) {\n     }\n }\n \n-fn metas_with(ident: @str, key: @str, mut metas: ~[@ast::MetaItem])\n-    -> ~[@ast::MetaItem] {\n-    // Check if key isn't there yet.\n-    if !attr::contains_name(metas, key) {\n-        metas.push(attr::mk_name_value_item_str(key, ident));\n-    }\n-    metas\n-}\n-\n-fn metas_with_ident(ident: @str, metas: ~[@ast::MetaItem])\n-    -> ~[@ast::MetaItem] {\n-    metas_with(ident, @\"name\", metas)\n-}\n-\n-fn existing_match(e: &Env, metas: &[@ast::MetaItem], hash: &str)\n-               -> Option<ast::CrateNum> {\n+fn existing_match(e: &Env, name: @str, version: @str, hash: &str) -> Option<ast::CrateNum> {\n     for c in e.crate_cache.iter() {\n-        if loader::metadata_matches(*c.metas, metas)\n-            && (hash.is_empty() || c.hash.as_slice() == hash) {\n+        let pkgid_version = match c.pkgid.version {\n+            None => @\"0.0\",\n+            Some(ref ver) => ver.to_managed(),\n+        };\n+        if (name.is_empty() || c.pkgid.name.to_managed() == name) &&\n+            (version.is_empty() || pkgid_version == version) &&\n+            (hash.is_empty() || c.hash.as_slice() == hash) {\n             return Some(c.cnum);\n         }\n     }\n-    return None;\n+    None\n }\n \n fn resolve_crate(e: @mut Env,\n                  ident: @str,\n-                 metas: ~[@ast::MetaItem],\n+                 name: @str,\n+                 version: @str,\n                  hash: @str,\n                  span: Span)\n               -> ast::CrateNum {\n-    let metas = metas_with_ident(ident, metas);\n-\n-    match existing_match(e, metas, hash) {\n+    match existing_match(e, name, version, hash) {\n       None => {\n         let load_ctxt = loader::Context {\n             sess: e.sess,\n             span: span,\n             ident: ident,\n-            metas: metas,\n+            name: name,\n+            version: version,\n             hash: hash,\n             os: e.os,\n             intr: e.intr\n@@ -282,7 +268,7 @@ fn resolve_crate(e: @mut Env,\n         } = load_ctxt.load_library_crate();\n \n         let attrs = decoder::get_crate_attributes(metadata);\n-        let linkage_metas = attr::find_linkage_metas(attrs);\n+        let pkgid = attr::find_pkgid(attrs).unwrap();\n         let hash = decoder::get_crate_hash(metadata);\n \n         // Claim this crate number and cache it\n@@ -291,21 +277,15 @@ fn resolve_crate(e: @mut Env,\n             cnum: cnum,\n             span: span,\n             hash: hash,\n-            metas: @linkage_metas\n+            pkgid: pkgid,\n         });\n         e.next_crate_num += 1;\n \n         // Now resolve the crates referenced by this crate\n         let cnum_map = resolve_crate_deps(e, metadata);\n \n-        let cname =\n-            match attr::last_meta_item_value_str_by_name(load_ctxt.metas,\n-                                                         \"name\") {\n-                Some(v) => v,\n-                None => ident\n-            };\n         let cmeta = @cstore::crate_metadata {\n-            name: cname,\n+            name: name,\n             data: metadata,\n             cnum_map: cnum_map,\n             cnum: cnum\n@@ -336,12 +316,9 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n     for dep in r.iter() {\n         let extrn_cnum = dep.cnum;\n         let cname_str = token::ident_to_str(&dep.name);\n-        let cmetas = metas_with(dep.vers, @\"vers\", ~[]);\n         debug!(\"resolving dep crate {} ver: {} hash: {}\",\n                cname_str, dep.vers, dep.hash);\n-        match existing_match(e,\n-                             metas_with_ident(cname_str, cmetas.clone()),\n-                             dep.hash) {\n+        match existing_match(e, cname_str, dep.vers, dep.hash) {\n           Some(local_cnum) => {\n             debug!(\"already have it\");\n             // We've already seen this crate\n@@ -353,8 +330,8 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n             // FIXME (#2404): Need better error reporting than just a bogus\n             // span.\n             let fake_span = dummy_sp();\n-            let local_cnum = resolve_crate(e, cname_str, cmetas, dep.hash,\n-                                           fake_span);\n+            let local_cnum = resolve_crate(e, cname_str, cname_str, dep.vers,\n+                                           dep.hash, fake_span);\n             cnum_map.insert(extrn_cnum, local_cnum);\n           }\n         }"}, {"sha": "dd4df7481d43ab5baece6180fd236f361e3d563a", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -1171,11 +1171,9 @@ pub fn get_crate_hash(data: @~[u8]) -> @str {\n \n pub fn get_crate_vers(data: @~[u8]) -> @str {\n     let attrs = decoder::get_crate_attributes(data);\n-    let linkage_attrs = attr::find_linkage_metas(attrs);\n-\n-    match attr::last_meta_item_value_str_by_name(linkage_attrs, \"vers\") {\n-        Some(ver) => ver,\n-        None => @\"0.0\"\n+    match attr::find_pkgid(attrs) {\n+        None => @\"0.0\",\n+        Some(pkgid) => pkgid.version_or_default().to_managed(),\n     }\n }\n "}, {"sha": "209ed5e2d1858ac89bd026ad5fa9d28902d60ffe", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 15, "deletions": 52, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -1482,67 +1482,30 @@ fn encode_attributes(ebml_w: &mut writer::Encoder, attrs: &[Attribute]) {\n     ebml_w.end_tag();\n }\n \n-// So there's a special crate attribute called 'link' which defines the\n-// metadata that Rust cares about for linking crates. This attribute requires\n-// 'name', 'vers' and 'package_id' items, so if the user didn't provide them we\n-// will throw them in anyway with default values.\n+// So there's a special crate attribute called 'pkgid' which defines the\n+// metadata that Rust cares about for linking crates. If the user didn't\n+// provide it we will throw it in anyway with a default value.\n fn synthesize_crate_attrs(ecx: &EncodeContext,\n                           crate: &Crate) -> ~[Attribute] {\n \n-    fn synthesize_link_attr(ecx: &EncodeContext, items: ~[@MetaItem]) ->\n-       Attribute {\n-\n-        assert!(!ecx.link_meta.name.is_empty());\n-        assert!(!ecx.link_meta.vers.is_empty());\n-\n-        let name_item =\n-            attr::mk_name_value_item_str(@\"name\",\n-                                         ecx.link_meta.name);\n-        let vers_item =\n-            attr::mk_name_value_item_str(@\"vers\",\n-                                         ecx.link_meta.vers);\n-\n-        let pkgid_item = match ecx.link_meta.package_id {\n-                Some(pkg_id) =>  attr::mk_name_value_item_str(@\"package_id\",\n-                                                              pkg_id),\n-                // uses package_id equal to name;\n-                // this should never happen here but package_id is an Option\n-                // FIXME (#10370): change package_id in LinkMeta to @str instead of Option<@str>\n-                _ => attr::mk_name_value_item_str(@\"package_id\",\n-                                                  ecx.link_meta.name)\n-        };\n-\n-        let mut meta_items = ~[name_item, vers_item, pkgid_item];\n-\n-        for &mi in items.iter().filter(|mi| \"name\" != mi.name() && \"vers\" != mi.name() &&\n-                                            \"package_id\" != mi.name()) {\n-            meta_items.push(mi);\n-        }\n-        let link_item = attr::mk_list_item(@\"link\", meta_items);\n+    fn synthesize_pkgid_attr(ecx: &EncodeContext) -> Attribute {\n+        assert!(!ecx.link_meta.pkgid.name.is_empty());\n \n-        return attr::mk_attr(link_item);\n+        attr::mk_attr(\n+            attr::mk_name_value_item_str(\n+                @\"pkgid\",\n+                ecx.link_meta.pkgid.to_str().to_managed()))\n     }\n \n     let mut attrs = ~[];\n-    let mut found_link_attr = false;\n     for attr in crate.attrs.iter() {\n-        attrs.push(\n-            if \"link\" != attr.name()  {\n-                *attr\n-            } else {\n-                match attr.meta_item_list() {\n-                  Some(l) => {\n-                    found_link_attr = true;;\n-                    synthesize_link_attr(ecx, l.to_owned())\n-                  }\n-                  _ => *attr\n-                }\n-            });\n+        if \"pkgid\" != attr.name()  {\n+            attrs.push(*attr);\n+        }\n     }\n+    attrs.push(synthesize_pkgid_attr(ecx));\n \n-    if !found_link_attr { attrs.push(synthesize_link_attr(ecx, ~[])); }\n-\n-    return attrs;\n+    attrs\n }\n \n fn encode_crate_deps(ecx: &EncodeContext,\n@@ -1800,7 +1763,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n \n     let mut ebml_w = writer::Encoder(wr);\n \n-    encode_hash(&mut ebml_w, ecx.link_meta.extras_hash);\n+    encode_hash(&mut ebml_w, ecx.link_meta.crate_hash);\n \n     let mut i = wr.tell();\n     let crate_attrs = synthesize_crate_attrs(&ecx, crate);"}, {"sha": "dd5d082ddb7c8941d7f489e2187deadeaaba9efb", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 29, "deletions": 54, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -20,8 +20,8 @@ use metadata::filesearch;\n use syntax::codemap::Span;\n use syntax::diagnostic::span_handler;\n use syntax::parse::token::ident_interner;\n-use syntax::print::pprust;\n-use syntax::{ast, attr};\n+use syntax::pkgid::PkgId;\n+use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n \n use std::c_str::ToCStr;\n@@ -47,7 +47,8 @@ pub struct Context {\n     sess: Session,\n     span: Span,\n     ident: @str,\n-    metas: ~[@ast::MetaItem],\n+    name: @str,\n+    version: @str,\n     hash: @str,\n     os: Os,\n     intr: @ident_interner\n@@ -72,9 +73,8 @@ impl Context {\n     }\n \n     fn find_library_crate(&self) -> Option<Library> {\n-        attr::require_unique_names(self.sess.diagnostic(), self.metas);\n         let filesearch = self.sess.filesearch;\n-        let crate_name = crate_name_from_metas(self.metas);\n+        let crate_name = self.name;\n         let (dyprefix, dysuffix) = self.dylibname();\n \n         // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n@@ -103,9 +103,8 @@ impl Context {\n                     } else if candidate {\n                         match get_metadata_section(self.sess, self.os, path) {\n                             Some(cvec) =>\n-                                if crate_matches(cvec, self.metas, self.hash) {\n-                                    debug!(\"found {} with matching metadata\",\n-                                           path.display());\n+                                if crate_matches(cvec, self.name, self.version, self.hash) {\n+                                    debug!(\"found {} with matching pkgid\", path.display());\n                                     let (rlib, dylib) = if file.ends_with(\".rlib\") {\n                                         (Some(path.clone()), None)\n                                     } else {\n@@ -118,7 +117,7 @@ impl Context {\n                                     });\n                                     FileMatches\n                                 } else {\n-                                    debug!(\"skipping {}, metadata doesn't match\",\n+                                    debug!(\"skipping {}, pkgid doesn't match\",\n                                            path.display());\n                                     FileDoesntMatch\n                                 },\n@@ -156,7 +155,12 @@ impl Context {\n                         None => {}\n                     }\n                     let attrs = decoder::get_crate_attributes(lib.metadata);\n-                    note_linkage_attrs(self.intr, self.sess.diagnostic(), attrs);\n+                    match attr::find_pkgid(attrs) {\n+                        None => {}\n+                        Some(pkgid) => {\n+                            note_pkgid_attr(self.sess.diagnostic(), &pkgid);\n+                        }\n+                    }\n                 }\n                 self.sess.abort_if_errors();\n                 None\n@@ -217,56 +221,27 @@ impl Context {\n     }\n }\n \n-pub fn crate_name_from_metas(metas: &[@ast::MetaItem]) -> @str {\n-    for m in metas.iter() {\n-        match m.name_str_pair() {\n-            Some((name, s)) if \"name\" == name => { return s; }\n-            _ => {}\n-        }\n-    }\n-    fail!(\"expected to find the crate name\")\n-}\n-\n-pub fn package_id_from_metas(metas: &[@ast::MetaItem]) -> Option<@str> {\n-    for m in metas.iter() {\n-        match m.name_str_pair() {\n-            Some((name, s)) if \"package_id\" == name => { return Some(s); }\n-            _ => {}\n-        }\n-    }\n-    None\n-}\n-\n-pub fn note_linkage_attrs(intr: @ident_interner,\n-                          diag: @mut span_handler,\n-                          attrs: ~[ast::Attribute]) {\n-    let r = attr::find_linkage_metas(attrs);\n-    for mi in r.iter() {\n-        diag.handler().note(format!(\"meta: {}\", pprust::meta_item_to_str(*mi,intr)));\n-    }\n+pub fn note_pkgid_attr(diag: @mut span_handler,\n+                       pkgid: &PkgId) {\n+    diag.handler().note(format!(\"pkgid: {}\", pkgid.to_str()));\n }\n \n fn crate_matches(crate_data: @~[u8],\n-                 metas: &[@ast::MetaItem],\n+                 name: @str,\n+                 version: @str,\n                  hash: @str) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n-    let linkage_metas = attr::find_linkage_metas(attrs);\n-    if !hash.is_empty() {\n-        let chash = decoder::get_crate_hash(crate_data);\n-        if chash != hash { return false; }\n+    match attr::find_pkgid(attrs) {\n+        None => false,\n+        Some(pkgid) => {\n+            if !hash.is_empty() {\n+                let chash = decoder::get_crate_hash(crate_data);\n+                if chash != hash { return false; }\n+            }\n+            name == pkgid.name.to_managed() &&\n+                (version.is_empty() || version == pkgid.version_or_default().to_managed())\n+        }\n     }\n-    metadata_matches(linkage_metas, metas)\n-}\n-\n-pub fn metadata_matches(extern_metas: &[@ast::MetaItem],\n-                        local_metas: &[@ast::MetaItem]) -> bool {\n-\n-// extern_metas: metas we read from the crate\n-// local_metas: metas we're looking for\n-    debug!(\"matching {} metadata requirements against {} items\",\n-           local_metas.len(), extern_metas.len());\n-\n-    local_metas.iter().all(|needed| attr::contains(extern_metas, *needed))\n }\n \n fn get_metadata_section(sess: Session, os: Os, filename: &Path) -> Option<@~[u8]> {"}, {"sha": "4c32f7159cad6fbebf21fe61d36af67f015bce4e", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -816,7 +816,7 @@ fn check_heap_item(cx: &Context, it: &ast::item) {\n }\n \n static crate_attrs: &'static [&'static str] = &[\n-    \"crate_type\", \"feature\", \"no_uv\", \"no_main\", \"no_std\",\n+    \"crate_type\", \"feature\", \"no_uv\", \"no_main\", \"no_std\", \"pkgid\",\n     \"desc\", \"comment\", \"license\", \"copyright\", // not used in rustc now\n ];\n "}, {"sha": "b95f4affc847e7536147c4ee588504c909757119", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -64,11 +64,10 @@ use middle::trans::value::Value;\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::{Repr, ty_to_str};\n-\n+use util::sha2::Sha256;\n use middle::trans::type_::Type;\n \n use std::c_str::ToCStr;\n-use std::hash;\n use std::hashmap::HashMap;\n use std::libc::c_uint;\n use std::vec;\n@@ -2939,8 +2938,8 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     let sym_name = if is_top {\n         ~\"_rust_crate_map_toplevel\"\n     } else {\n-        symname(sess, \"_rust_crate_map_\" + mapmeta.name, mapmeta.extras_hash,\n-                mapmeta.vers)\n+        symname(sess, \"_rust_crate_map_\" + mapmeta.pkgid.name, mapmeta.crate_hash,\n+                mapmeta.pkgid.version_or_default())\n     };\n \n     let slicetype = Type::struct_([int_type, int_type], false);\n@@ -3059,8 +3058,8 @@ pub fn write_metadata(cx: &CrateContext, crate: &ast::Crate) -> ~[u8] {\n                         flate::deflate_bytes(metadata);\n     let llmeta = C_bytes(compressed);\n     let llconst = C_struct([llmeta], false);\n-    let name = format!(\"rust_metadata_{}_{}_{}\", cx.link_meta.name,\n-                       cx.link_meta.vers, cx.link_meta.extras_hash);\n+    let name = format!(\"rust_metadata_{}_{}_{}\", cx.link_meta.pkgid.name,\n+                       cx.link_meta.pkgid.version_or_default(), cx.link_meta.crate_hash);\n     let llglobal = name.with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(cx.metadata_llmod, val_ty(llconst).to_ref(), buf)\n@@ -3084,7 +3083,7 @@ pub fn trans_crate(sess: session::Session,\n         sess.bug(\"couldn't enable multi-threaded LLVM\");\n     }\n \n-    let mut symbol_hasher = hash::default_state();\n+    let mut symbol_hasher = Sha256::new();\n     let link_meta = link::build_link_meta(sess, &crate, output,\n                                           &mut symbol_hasher);\n \n@@ -3096,7 +3095,7 @@ pub fn trans_crate(sess: session::Session,\n     // crashes if the module identifer is same as other symbols\n     // such as a function name in the module.\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-    let llmod_id = link_meta.name.to_owned() + \".rc\";\n+    let llmod_id = link_meta.pkgid.name.clone() + \".rc\";\n \n     let ccx = @mut CrateContext::new(sess,\n                                      llmod_id,\n@@ -3171,7 +3170,7 @@ pub fn trans_crate(sess: session::Session,\n     }\n \n     let llcx = ccx.llcx;\n-    let link_meta = ccx.link_meta;\n+    let link_meta = ccx.link_meta.clone();\n     let llmod = ccx.llmod;\n     let mut reachable = ccx.reachable.iter().filter_map(|id| {\n         ccx.item_symbols.find(id).map(|s| s.to_owned())"}, {"sha": "3dbe70ecf690d0f95d1c055cabd24d1031d92cea", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -26,8 +26,9 @@ use middle::ty;\n \n use middle::trans::type_::Type;\n \n+use util::sha2::Sha256;\n+\n use std::c_str::ToCStr;\n-use std::hash;\n use std::hashmap::{HashMap, HashSet};\n use std::local_data;\n use std::vec;\n@@ -98,7 +99,7 @@ pub struct CrateContext {\n      lltypes: HashMap<ty::t, Type>,\n      llsizingtypes: HashMap<ty::t, Type>,\n      adt_reprs: HashMap<ty::t, @adt::Repr>,\n-     symbol_hasher: hash::State,\n+     symbol_hasher: Sha256,\n      type_hashcodes: HashMap<ty::t, @str>,\n      type_short_names: HashMap<ty::t, ~str>,\n      all_llvm_symbols: HashSet<@str>,\n@@ -126,7 +127,7 @@ impl CrateContext {\n                tcx: ty::ctxt,\n                emap2: resolve::ExportMap2,\n                maps: astencode::Maps,\n-               symbol_hasher: hash::State,\n+               symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n                reachable: @mut HashSet<ast::NodeId>)\n                -> CrateContext {\n@@ -168,8 +169,7 @@ impl CrateContext {\n             tn.associate_type(\"tydesc\", &tydesc_type);\n             tn.associate_type(\"str_slice\", &str_slice_ty);\n \n-            let (crate_map_name, crate_map) = decl_crate_map(sess, link_meta,\n-                                                             llmod);\n+            let (crate_map_name, crate_map) = decl_crate_map(sess, link_meta.clone(), llmod);\n             let dbg_cx = if sess.opts.debuginfo {\n                 Some(debuginfo::CrateDebugContext::new(llmod, name.to_owned()))\n             } else {"}, {"sha": "8346228e8818737ba83ba2131cd0e5d892115be9", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -2728,7 +2728,7 @@ fn namespace_for_item(cx: &mut CrateContext,\n \n         if def_id.crate == ast::LOCAL_CRATE {\n             // prepend crate name if not already present\n-            let crate_namespace_ident = token::str_to_ident(cx.link_meta.name);\n+            let crate_namespace_ident = token::str_to_ident(cx.link_meta.pkgid.name);\n             item_path.insert(0, ast_map::path_mod(crate_namespace_ident));\n         }\n "}, {"sha": "d5b70284f1117cc2f3f60f37cb2c18a5f27f3417", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -1795,7 +1795,7 @@ pub fn trans_log_level(bcx: @mut Block) -> DatumBlock {\n             Some(&src) => {\n                 cstore::get_crate_data(ccx.sess.cstore, src.crate).name\n             }\n-            None => ccx.link_meta.name,\n+            None => ccx.link_meta.pkgid.name.to_managed(),\n         };\n         let mut modpath = ~[path_mod(ccx.sess.ident_of(srccrate))];\n         for e in bcx.fcx.path.iter() {"}, {"sha": "f83bdd799598e8a641f6340de334ba7318c47a54", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -286,7 +286,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         }\n         \"type_id\" => {\n             let hash = ty::hash_crate_independent(ccx.tcx, substs.tys[0],\n-                                                  ccx.link_meta.extras_hash);\n+                                                  ccx.link_meta.crate_hash);\n             // NB: This needs to be kept in lockstep with the TypeId struct in\n             //     libstd/unstable/intrinsics.rs\n             let val = C_named_struct(type_of::type_of(ccx, output_type), [C_u64(hash)]);"}, {"sha": "1ac5b73192164a9b15126b17e9fb9fe88151ca98", "filename": "src/librustc/util/sha2.rs", "status": "added", "additions": 670, "deletions": 0, "changes": 670, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -0,0 +1,670 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module implements only the Sha256 function since that is all that is needed for internal\n+//! use. This implementation is not intended for external use or for any use where security is\n+//! important.\n+\n+use std::iter::range_step;\n+use std::num::Zero;\n+use std::vec;\n+use std::vec::bytes::{MutableByteVector, copy_memory};\n+use extra::hex::ToHex;\n+\n+/// Write a u32 into a vector, which must be 4 bytes long. The value is written in big-endian\n+/// format.\n+fn write_u32_be(dst: &mut[u8], input: u32) {\n+    use std::cast::transmute;\n+    use std::unstable::intrinsics::to_be32;\n+    assert!(dst.len() == 4);\n+    unsafe {\n+        let x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n+        *x = to_be32(input as i32);\n+    }\n+}\n+\n+/// Read a vector of bytes into a vector of u32s. The values are read in big-endian format.\n+fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n+    use std::cast::transmute;\n+    use std::unstable::intrinsics::to_be32;\n+    assert!(dst.len() * 4 == input.len());\n+    unsafe {\n+        let mut x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n+        let mut y: *i32 = transmute(input.unsafe_ref(0));\n+        dst.len().times(|| {\n+            *x = to_be32(*y);\n+            x = x.offset(1);\n+            y = y.offset(1);\n+        });\n+    }\n+}\n+\n+trait ToBits {\n+    /// Convert the value in bytes to the number of bits, a tuple where the 1st item is the\n+    /// high-order value and the 2nd item is the low order value.\n+    fn to_bits(self) -> (Self, Self);\n+}\n+\n+impl ToBits for u64 {\n+    fn to_bits(self) -> (u64, u64) {\n+        return (self >> 61, self << 3);\n+    }\n+}\n+\n+/// Adds the specified number of bytes to the bit count. fail!() if this would cause numeric\n+/// overflow.\n+fn add_bytes_to_bits<T: Int + CheckedAdd + ToBits>(bits: T, bytes: T) -> T {\n+    let (new_high_bits, new_low_bits) = bytes.to_bits();\n+\n+    if new_high_bits > Zero::zero() {\n+        fail!(\"Numeric overflow occured.\")\n+    }\n+\n+    match bits.checked_add(&new_low_bits) {\n+        Some(x) => return x,\n+        None => fail!(\"Numeric overflow occured.\")\n+    }\n+}\n+\n+/// A FixedBuffer, likes its name implies, is a fixed size buffer. When the buffer becomes full, it\n+/// must be processed. The input() method takes care of processing and then clearing the buffer\n+/// automatically. However, other methods do not and require the caller to process the buffer. Any\n+/// method that modifies the buffer directory or provides the caller with bytes that can be modified\n+/// results in those bytes being marked as used by the buffer.\n+trait FixedBuffer {\n+    /// Input a vector of bytes. If the buffer becomes full, process it with the provided\n+    /// function and then clear the buffer.\n+    fn input(&mut self, input: &[u8], func: |&[u8]|);\n+\n+    /// Reset the buffer.\n+    fn reset(&mut self);\n+\n+    /// Zero the buffer up until the specified index. The buffer position currently must not be\n+    /// greater than that index.\n+    fn zero_until(&mut self, idx: uint);\n+\n+    /// Get a slice of the buffer of the specified size. There must be at least that many bytes\n+    /// remaining in the buffer.\n+    fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8];\n+\n+    /// Get the current buffer. The buffer must already be full. This clears the buffer as well.\n+    fn full_buffer<'s>(&'s mut self) -> &'s [u8];\n+\n+    /// Get the current position of the buffer.\n+    fn position(&self) -> uint;\n+\n+    /// Get the number of bytes remaining in the buffer until it is full.\n+    fn remaining(&self) -> uint;\n+\n+    /// Get the size of the buffer\n+    fn size(&self) -> uint;\n+}\n+\n+/// A FixedBuffer of 64 bytes useful for implementing Sha256 which has a 64 byte blocksize.\n+struct FixedBuffer64 {\n+    priv buffer: [u8, ..64],\n+    priv buffer_idx: uint,\n+}\n+\n+impl FixedBuffer64 {\n+    /// Create a new FixedBuffer64\n+    fn new() -> FixedBuffer64 {\n+        return FixedBuffer64 {\n+            buffer: [0u8, ..64],\n+            buffer_idx: 0\n+        };\n+    }\n+}\n+\n+impl FixedBuffer for FixedBuffer64 {\n+    fn input(&mut self, input: &[u8], func: |&[u8]|) {\n+        let mut i = 0;\n+\n+        let size = self.size();\n+\n+        // If there is already data in the buffer, copy as much as we can into it and process\n+        // the data if the buffer becomes full.\n+        if self.buffer_idx != 0 {\n+            let buffer_remaining = size - self.buffer_idx;\n+            if input.len() >= buffer_remaining {\n+                    copy_memory(\n+                        self.buffer.mut_slice(self.buffer_idx, size),\n+                        input.slice_to(buffer_remaining),\n+                        buffer_remaining);\n+                self.buffer_idx = 0;\n+                func(self.buffer);\n+                i += buffer_remaining;\n+            } else {\n+                copy_memory(\n+                    self.buffer.mut_slice(self.buffer_idx, self.buffer_idx + input.len()),\n+                    input,\n+                    input.len());\n+                self.buffer_idx += input.len();\n+                return;\n+            }\n+        }\n+\n+        // While we have at least a full buffer size chunks's worth of data, process that data\n+        // without copying it into the buffer\n+        while input.len() - i >= size {\n+            func(input.slice(i, i + size));\n+            i += size;\n+        }\n+\n+        // Copy any input data into the buffer. At this point in the method, the ammount of\n+        // data left in the input vector will be less than the buffer size and the buffer will\n+        // be empty.\n+        let input_remaining = input.len() - i;\n+        copy_memory(\n+            self.buffer.mut_slice(0, input_remaining),\n+            input.slice_from(i),\n+            input.len() - i);\n+        self.buffer_idx += input_remaining;\n+    }\n+\n+    fn reset(&mut self) {\n+        self.buffer_idx = 0;\n+    }\n+\n+    fn zero_until(&mut self, idx: uint) {\n+        assert!(idx >= self.buffer_idx);\n+        self.buffer.mut_slice(self.buffer_idx, idx).set_memory(0);\n+        self.buffer_idx = idx;\n+    }\n+\n+    fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8] {\n+        self.buffer_idx += len;\n+        return self.buffer.mut_slice(self.buffer_idx - len, self.buffer_idx);\n+    }\n+\n+    fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n+        assert!(self.buffer_idx == 64);\n+        self.buffer_idx = 0;\n+        return self.buffer.slice_to(64);\n+    }\n+\n+    fn position(&self) -> uint { self.buffer_idx }\n+\n+    fn remaining(&self) -> uint { 64 - self.buffer_idx }\n+\n+    fn size(&self) -> uint { 64 }\n+}\n+\n+/// The StandardPadding trait adds a method useful for Sha256 to a FixedBuffer struct.\n+trait StandardPadding {\n+    /// Add padding to the buffer. The buffer must not be full when this method is called and is\n+    /// guaranteed to have exactly rem remaining bytes when it returns. If there are not at least\n+    /// rem bytes available, the buffer will be zero padded, processed, cleared, and then filled\n+    /// with zeros again until only rem bytes are remaining.\n+    fn standard_padding(&mut self, rem: uint, func: |&[u8]|);\n+}\n+\n+impl <T: FixedBuffer> StandardPadding for T {\n+    fn standard_padding(&mut self, rem: uint, func: |&[u8]|) {\n+        let size = self.size();\n+\n+        self.next(1)[0] = 128;\n+\n+        if self.remaining() < rem {\n+            self.zero_until(size);\n+            func(self.full_buffer());\n+        }\n+\n+        self.zero_until(size - rem);\n+    }\n+}\n+\n+/// The Digest trait specifies an interface common to digest functions, such as SHA-1 and the SHA-2\n+/// family of digest functions.\n+pub trait Digest {\n+    /// Provide message data.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * input - A vector of message data\n+    fn input(&mut self, input: &[u8]);\n+\n+    /// Retrieve the digest result. This method may be called multiple times.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * out - the vector to hold the result. Must be large enough to contain output_bits().\n+    fn result(&mut self, out: &mut [u8]);\n+\n+    /// Reset the digest. This method must be called after result() and before supplying more\n+    /// data.\n+    fn reset(&mut self);\n+\n+    /// Get the output size in bits.\n+    fn output_bits(&self) -> uint;\n+\n+    /// Convenience function that feeds a string into a digest.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * `input` The string to feed into the digest\n+    fn input_str(&mut self, input: &str) {\n+        self.input(input.as_bytes());\n+    }\n+\n+    /// Convenience function that retrieves the result of a digest as a\n+    /// newly allocated vec of bytes.\n+    fn result_bytes(&mut self) -> ~[u8] {\n+        let mut buf = vec::from_elem((self.output_bits()+7)/8, 0u8);\n+        self.result(buf);\n+        buf\n+    }\n+\n+    /// Convenience function that retrieves the result of a digest as a\n+    /// ~str in hexadecimal format.\n+    fn result_str(&mut self) -> ~str {\n+        self.result_bytes().to_hex()\n+    }\n+}\n+\n+// A structure that represents that state of a digest computation for the SHA-2 512 family of digest\n+// functions\n+struct Engine256State {\n+    H0: u32,\n+    H1: u32,\n+    H2: u32,\n+    H3: u32,\n+    H4: u32,\n+    H5: u32,\n+    H6: u32,\n+    H7: u32,\n+}\n+\n+impl Engine256State {\n+    fn new(h: &[u32, ..8]) -> Engine256State {\n+        return Engine256State {\n+            H0: h[0],\n+            H1: h[1],\n+            H2: h[2],\n+            H3: h[3],\n+            H4: h[4],\n+            H5: h[5],\n+            H6: h[6],\n+            H7: h[7]\n+        };\n+    }\n+\n+    fn reset(&mut self, h: &[u32, ..8]) {\n+        self.H0 = h[0];\n+        self.H1 = h[1];\n+        self.H2 = h[2];\n+        self.H3 = h[3];\n+        self.H4 = h[4];\n+        self.H5 = h[5];\n+        self.H6 = h[6];\n+        self.H7 = h[7];\n+    }\n+\n+    fn process_block(&mut self, data: &[u8]) {\n+        fn ch(x: u32, y: u32, z: u32) -> u32 {\n+            ((x & y) ^ ((!x) & z))\n+        }\n+\n+        fn maj(x: u32, y: u32, z: u32) -> u32 {\n+            ((x & y) ^ (x & z) ^ (y & z))\n+        }\n+\n+        fn sum0(x: u32) -> u32 {\n+            ((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10))\n+        }\n+\n+        fn sum1(x: u32) -> u32 {\n+            ((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7))\n+        }\n+\n+        fn sigma0(x: u32) -> u32 {\n+            ((x >> 7) | (x << 25)) ^ ((x >> 18) | (x << 14)) ^ (x >> 3)\n+        }\n+\n+        fn sigma1(x: u32) -> u32 {\n+            ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10)\n+        }\n+\n+        let mut a = self.H0;\n+        let mut b = self.H1;\n+        let mut c = self.H2;\n+        let mut d = self.H3;\n+        let mut e = self.H4;\n+        let mut f = self.H5;\n+        let mut g = self.H6;\n+        let mut h = self.H7;\n+\n+        let mut W = [0u32, ..64];\n+\n+        // Sha-512 and Sha-256 use basically the same calculations which are implemented\n+        // by these macros. Inlining the calculations seems to result in better generated code.\n+        macro_rules! schedule_round( ($t:expr) => (\n+                W[$t] = sigma1(W[$t - 2]) + W[$t - 7] + sigma0(W[$t - 15]) + W[$t - 16];\n+                )\n+        )\n+\n+        macro_rules! sha2_round(\n+            ($A:ident, $B:ident, $C:ident, $D:ident,\n+             $E:ident, $F:ident, $G:ident, $H:ident, $K:ident, $t:expr) => (\n+                {\n+                    $H += sum1($E) + ch($E, $F, $G) + $K[$t] + W[$t];\n+                    $D += $H;\n+                    $H += sum0($A) + maj($A, $B, $C);\n+                }\n+             )\n+        )\n+\n+        read_u32v_be(W.mut_slice(0, 16), data);\n+\n+        // Putting the message schedule inside the same loop as the round calculations allows for\n+        // the compiler to generate better code.\n+        for t in range_step(0u, 48, 8) {\n+            schedule_round!(t + 16);\n+            schedule_round!(t + 17);\n+            schedule_round!(t + 18);\n+            schedule_round!(t + 19);\n+            schedule_round!(t + 20);\n+            schedule_round!(t + 21);\n+            schedule_round!(t + 22);\n+            schedule_round!(t + 23);\n+\n+            sha2_round!(a, b, c, d, e, f, g, h, K32, t);\n+            sha2_round!(h, a, b, c, d, e, f, g, K32, t + 1);\n+            sha2_round!(g, h, a, b, c, d, e, f, K32, t + 2);\n+            sha2_round!(f, g, h, a, b, c, d, e, K32, t + 3);\n+            sha2_round!(e, f, g, h, a, b, c, d, K32, t + 4);\n+            sha2_round!(d, e, f, g, h, a, b, c, K32, t + 5);\n+            sha2_round!(c, d, e, f, g, h, a, b, K32, t + 6);\n+            sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n+        }\n+\n+        for t in range_step(48u, 64, 8) {\n+            sha2_round!(a, b, c, d, e, f, g, h, K32, t);\n+            sha2_round!(h, a, b, c, d, e, f, g, K32, t + 1);\n+            sha2_round!(g, h, a, b, c, d, e, f, K32, t + 2);\n+            sha2_round!(f, g, h, a, b, c, d, e, K32, t + 3);\n+            sha2_round!(e, f, g, h, a, b, c, d, K32, t + 4);\n+            sha2_round!(d, e, f, g, h, a, b, c, K32, t + 5);\n+            sha2_round!(c, d, e, f, g, h, a, b, K32, t + 6);\n+            sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n+        }\n+\n+        self.H0 += a;\n+        self.H1 += b;\n+        self.H2 += c;\n+        self.H3 += d;\n+        self.H4 += e;\n+        self.H5 += f;\n+        self.H6 += g;\n+        self.H7 += h;\n+    }\n+}\n+\n+static K32: [u32, ..64] = [\n+    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n+    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n+    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n+    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n+    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n+    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n+    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n+    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n+    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n+    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n+    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n+    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n+    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n+    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n+    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n+    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n+];\n+\n+// A structure that keeps track of the state of the Sha-256 operation and contains the logic\n+// necessary to perform the final calculations.\n+struct Engine256 {\n+    length_bits: u64,\n+    buffer: FixedBuffer64,\n+    state: Engine256State,\n+    finished: bool,\n+}\n+\n+impl Engine256 {\n+    fn new(h: &[u32, ..8]) -> Engine256 {\n+        return Engine256 {\n+            length_bits: 0,\n+            buffer: FixedBuffer64::new(),\n+            state: Engine256State::new(h),\n+            finished: false\n+        }\n+    }\n+\n+    fn reset(&mut self, h: &[u32, ..8]) {\n+        self.length_bits = 0;\n+        self.buffer.reset();\n+        self.state.reset(h);\n+        self.finished = false;\n+    }\n+\n+    fn input(&mut self, input: &[u8]) {\n+        assert!(!self.finished)\n+        // Assumes that input.len() can be converted to u64 without overflow\n+        self.length_bits = add_bytes_to_bits(self.length_bits, input.len() as u64);\n+        self.buffer.input(input, |input: &[u8]| { self.state.process_block(input) });\n+    }\n+\n+    fn finish(&mut self) {\n+        if self.finished {\n+            return;\n+        }\n+\n+        self.buffer.standard_padding(8, |input: &[u8]| { self.state.process_block(input) });\n+        write_u32_be(self.buffer.next(4), (self.length_bits >> 32) as u32 );\n+        write_u32_be(self.buffer.next(4), self.length_bits as u32);\n+        self.state.process_block(self.buffer.full_buffer());\n+\n+        self.finished = true;\n+    }\n+}\n+\n+/// The SHA-256 hash algorithm\n+pub struct Sha256 {\n+    priv engine: Engine256\n+}\n+\n+impl Sha256 {\n+    /// Construct an new instance of a SHA-256 digest.\n+    pub fn new() -> Sha256 {\n+        Sha256 {\n+            engine: Engine256::new(&H256)\n+        }\n+    }\n+}\n+\n+impl Digest for Sha256 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input(d);\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.finish();\n+\n+        write_u32_be(out.mut_slice(0, 4), self.engine.state.H0);\n+        write_u32_be(out.mut_slice(4, 8), self.engine.state.H1);\n+        write_u32_be(out.mut_slice(8, 12), self.engine.state.H2);\n+        write_u32_be(out.mut_slice(12, 16), self.engine.state.H3);\n+        write_u32_be(out.mut_slice(16, 20), self.engine.state.H4);\n+        write_u32_be(out.mut_slice(20, 24), self.engine.state.H5);\n+        write_u32_be(out.mut_slice(24, 28), self.engine.state.H6);\n+        write_u32_be(out.mut_slice(28, 32), self.engine.state.H7);\n+    }\n+\n+    fn reset(&mut self) {\n+        self.engine.reset(&H256);\n+    }\n+\n+    fn output_bits(&self) -> uint { 256 }\n+}\n+\n+static H256: [u32, ..8] = [\n+    0x6a09e667,\n+    0xbb67ae85,\n+    0x3c6ef372,\n+    0xa54ff53a,\n+    0x510e527f,\n+    0x9b05688c,\n+    0x1f83d9ab,\n+    0x5be0cd19\n+];\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{Digest, Sha256};\n+    use std::vec;\n+    use std::rand::isaac::IsaacRng;\n+    use std::rand::Rng;\n+    use extra::hex::FromHex;\n+\n+    // A normal addition - no overflow occurs\n+    #[test]\n+    fn test_add_bytes_to_bits_ok() {\n+        assert!(super::add_bytes_to_bits::<u64>(100, 10) == 180);\n+    }\n+\n+    // A simple failure case - adding 1 to the max value\n+    #[test]\n+    #[should_fail]\n+    fn test_add_bytes_to_bits_overflow() {\n+        super::add_bytes_to_bits::<u64>(Bounded::max_value(), 1);\n+    }\n+\n+    struct Test {\n+        input: ~str,\n+        output_str: ~str,\n+    }\n+\n+    fn test_hash<D: Digest>(sh: &mut D, tests: &[Test]) {\n+        // Test that it works when accepting the message all at once\n+        for t in tests.iter() {\n+            sh.reset();\n+            sh.input_str(t.input);\n+            let out_str = sh.result_str();\n+            assert!(out_str == t.output_str);\n+        }\n+\n+        // Test that it works when accepting the message in pieces\n+        for t in tests.iter() {\n+            sh.reset();\n+            let len = t.input.len();\n+            let mut left = len;\n+            while left > 0u {\n+                let take = (left + 1u) / 2u;\n+                sh.input_str(t.input.slice(len - left, take + len - left));\n+                left = left - take;\n+            }\n+            let out_str = sh.result_str();\n+            assert!(out_str == t.output_str);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_sha256() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"ef537f25c895bfa782526529a9b63d97aa631564d5d789c2b765448c8635fb6c\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = ~Sha256::new();\n+\n+        test_hash(sh, tests);\n+    }\n+\n+    /// Feed 1,000,000 'a's into the digest with varying input sizes and check that the result is\n+    /// correct.\n+    fn test_digest_1million_random<D: Digest>(digest: &mut D, blocksize: uint, expected: &str) {\n+        let total_size = 1000000;\n+        let buffer = vec::from_elem(blocksize * 2, 'a' as u8);\n+        let mut rng = IsaacRng::new_unseeded();\n+        let mut count = 0;\n+\n+        digest.reset();\n+\n+        while count < total_size {\n+            let next: uint = rng.gen_range(0, 2 * blocksize + 1);\n+            let remaining = total_size - count;\n+            let size = if next > remaining { remaining } else { next };\n+            digest.input(buffer.slice_to(size));\n+            count += size;\n+        }\n+\n+        let result_str = digest.result_str();\n+        let result_bytes = digest.result_bytes();\n+\n+        assert_eq!(expected, result_str.as_slice());\n+        assert_eq!(expected.from_hex().unwrap(), result_bytes);\n+    }\n+\n+    #[test]\n+    fn test_1million_random_sha256() {\n+        let mut sh = Sha256::new();\n+        test_digest_1million_random(\n+            &mut sh,\n+            64,\n+            \"cdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0\");\n+    }\n+}\n+\n+#[cfg(test)]\n+mod bench {\n+    use extra::test::BenchHarness;\n+    use super::Sha256;\n+\n+    #[bench]\n+    pub fn sha256_10(bh: &mut BenchHarness) {\n+        let mut sh = Sha256::new();\n+        let bytes = [1u8, ..10];\n+        bh.iter(|| {\n+            sh.input(bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn sha256_1k(bh: &mut BenchHarness) {\n+        let mut sh = Sha256::new();\n+        let bytes = [1u8, ..1024];\n+        bh.iter(|| {\n+            sh.input(bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn sha256_64k(bh: &mut BenchHarness) {\n+        let mut sh = Sha256::new();\n+        let bytes = [1u8, ..65536];\n+        bh.iter(|| {\n+            sh.input(bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+}"}, {"sha": "f8b86da03c1f73532d6533c6b1701de68248361d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"rustdoc#0.9-pre\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"rustdoc\",\n        package_id = \"rustdoc\",\n        vers = \"0.9-pre\","}, {"sha": "0526e7dd434c4ceec4188e26f5ba915853a158d9", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -10,6 +10,8 @@\n \n // rustpkg - a package manager and build system for Rust\n \n+#[pkgid=\"rustpkg#0.9-pre\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"rustpkg\",\n        package_id = \"rustpkg\",\n        vers = \"0.9-pre\",\n@@ -36,6 +38,7 @@ use extra::workcache;\n use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;\n use rustc::metadata::filesearch::rust_path;\n+use rustc::util::sha2;\n use extra::{getopts};\n use syntax::{ast, diagnostic};\n use messages::{error, warn, note};\n@@ -52,7 +55,7 @@ use context::{Context, BuildContext,\n use package_id::PkgId;\n use package_source::PkgSrc;\n use target::{WhatToBuild, Everything, is_lib, is_main, is_test, is_bench};\n-use target::{Tests, MaybeCustom, Inferred, JustOne};\n+use target::{Main, Tests, MaybeCustom, Inferred, JustOne};\n use workcache_support::digest_only_date;\n use exit_codes::{COPY_FAILED_CODE, BAD_FLAG_CODE};\n \n@@ -66,7 +69,6 @@ mod messages;\n pub mod package_id;\n pub mod package_source;\n mod path_util;\n-mod sha1;\n mod source_control;\n mod target;\n #[cfg(not(windows), test)] // FIXME test failure on windows: #10471\n@@ -151,7 +153,8 @@ impl<'self> PkgScript<'self> {\n                                        Nothing,\n                                        &self.build_dir,\n                                        sess,\n-                                       crate);\n+                                       crate,\n+                                       Main);\n         // Discover the output\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         // Discover the output"}, {"sha": "59fdf20941ec2ee7eddfd1bf4a0908b223ed3724", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 47, "deletions": 45, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -15,8 +15,6 @@ use std::{os, run, str, task};\n use std::io;\n use std::io::fs;\n use std::io::File;\n-use std::io::process;\n-use std::io::process::ProcessExit;\n use extra::arc::Arc;\n use extra::arc::RWArc;\n use extra::tempfile::TempDir;\n@@ -739,8 +737,8 @@ fn test_package_ids_must_be_relative_path_like() {\n \n     let whatever = PkgId::new(\"foo\");\n \n-    assert_eq!(~\"foo-0.1\", whatever.to_str());\n-    assert!(\"github.com/catamorphism/test-pkg-0.1\" ==\n+    assert_eq!(~\"foo-0.0\", whatever.to_str());\n+    assert!(\"github.com/catamorphism/test-pkg-0.0\" ==\n             PkgId::new(\"github.com/catamorphism/test-pkg\").to_str());\n \n     cond.trap(|(p, e)| {\n@@ -749,7 +747,7 @@ fn test_package_ids_must_be_relative_path_like() {\n         whatever.clone()\n     }).inside(|| {\n         let x = PkgId::new(\"\");\n-        assert_eq!(~\"foo-0.1\", x.to_str());\n+        assert_eq!(~\"foo-0.0\", x.to_str());\n     });\n \n     cond.trap(|(p, e)| {\n@@ -761,9 +759,8 @@ fn test_package_ids_must_be_relative_path_like() {\n         let zp = os::make_absolute(&Path::new(\"foo/bar/quux\"));\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let z = PkgId::new(zp.as_str().unwrap());\n-        assert_eq!(~\"foo-0.1\", z.to_str());\n+        assert_eq!(~\"foo-0.0\", z.to_str());\n     })\n-\n }\n \n #[test]\n@@ -896,7 +893,7 @@ fn package_script_with_default_build() {\n     let source = Path::new(file!()).dir_path().join_many(\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"fancy-lib\", ~\"pkg.rs\"]);\n     debug!(\"package_script_with_default_build: {}\", source.display());\n-    fs::copy(&source, &dir.join_many([\"src\", \"fancy-lib-0.1\", \"pkg.rs\"]));\n+    fs::copy(&source, &dir.join_many([\"src\", \"fancy-lib-0.0\", \"pkg.rs\"]));\n     command_line_test([~\"install\", ~\"fancy-lib\"], dir);\n     assert_lib_exists(dir, &Path::new(\"fancy-lib\"), NoVersion);\n     assert!(target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]).exists());\n@@ -1349,7 +1346,7 @@ fn test_import_rustpkg() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    writeFile(&workspace.join_many([\"src\", \"foo-0.1\", \"pkg.rs\"]),\n+    writeFile(&workspace.join_many([\"src\", \"foo-0.0\", \"pkg.rs\"]),\n               \"extern mod rustpkg; fn main() {}\");\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n     debug!(\"workspace = {}\", workspace.display());\n@@ -1362,7 +1359,7 @@ fn test_macro_pkg_script() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    writeFile(&workspace.join_many([\"src\", \"foo-0.1\", \"pkg.rs\"]),\n+    writeFile(&workspace.join_many([\"src\", \"foo-0.0\", \"pkg.rs\"]),\n               \"extern mod rustpkg; fn main() { debug!(\\\"Hi\\\"); }\");\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n     debug!(\"workspace = {}\", workspace.display());\n@@ -1404,7 +1401,7 @@ fn rust_path_hack_test(hack_flag: bool) {\n    let workspace = workspace.path();\n    let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n    let dest_workspace = dest_workspace.path();\n-   let foo_path = workspace.join_many([\"src\", \"foo-0.1\"]);\n+   let foo_path = workspace.join_many([\"src\", \"foo-0.0\"]);\n    let rust_path = Some(~[(~\"RUST_PATH\",\n        format!(\"{}:{}\",\n                dest_workspace.as_str().unwrap(),\n@@ -1534,9 +1531,9 @@ fn rust_path_hack_build_with_dependency() {\n     let dep_workspace = dep_workspace.path();\n     let dest_workspace = mk_emptier_workspace(\"dep\");\n     let dest_workspace = dest_workspace.path();\n-    let source_dir = work_dir.join_many([\"src\", \"foo-0.1\"]);\n+    let source_dir = work_dir.join_many([\"src\", \"foo-0.0\"]);\n     writeFile(&source_dir.join(\"lib.rs\"), \"extern mod dep; pub fn f() { }\");\n-    let dep_dir = dep_workspace.join_many([\"src\", \"dep-0.1\"]);\n+    let dep_dir = dep_workspace.join_many([\"src\", \"dep-0.0\"]);\n     let rust_path = Some(~[(~\"RUST_PATH\",\n                           format!(\"{}:{}\",\n                                   dest_workspace.display(),\n@@ -1706,7 +1703,7 @@ fn test_cfg_build() {\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     // If the cfg flag gets messed up, this won't compile\n-    writeFile(&workspace.join_many([\"src\", \"foo-0.1\", \"main.rs\"]),\n+    writeFile(&workspace.join_many([\"src\", \"foo-0.0\", \"main.rs\"]),\n                \"#[cfg(quux)] fn main() {}\");\n     let test_sys = test_sysroot();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -1724,7 +1721,7 @@ fn test_cfg_fail() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    writeFile(&workspace.join_many([\"src\", \"foo-0.1\", \"main.rs\"]),\n+    writeFile(&workspace.join_many([\"src\", \"foo-0.0\", \"main.rs\"]),\n                \"#[cfg(quux)] fn main() {}\");\n     let test_sys = test_sysroot();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -1892,11 +1889,13 @@ fn pkgid_pointing_to_subdir() {\n                                        \"extras\", \"bar\"]);\n     fs::mkdir_recursive(&foo_dir, io::UserRWX);\n     fs::mkdir_recursive(&bar_dir, io::UserRWX);\n-    writeFile(&foo_dir.join(\"lib.rs\"), \"pub fn f() {}\");\n-    writeFile(&bar_dir.join(\"lib.rs\"), \"pub fn g() {}\");\n+    writeFile(&foo_dir.join(\"lib.rs\"),\n+              \"#[pkgid=\\\"mockgithub.com/mozilla/some_repo/extras/foo\\\"]; pub fn f() {}\");\n+    writeFile(&bar_dir.join(\"lib.rs\"),\n+              \"#[pkgid=\\\"mockgithub.com/mozilla/some_repo/extras/bar\\\"]; pub fn g() {}\");\n \n     debug!(\"Creating a file in {}\", workspace.display());\n-    let testpkg_dir = workspace.join_many([\"src\", \"testpkg-0.1\"]);\n+    let testpkg_dir = workspace.join_many([\"src\", \"testpkg-0.0\"]);\n     fs::mkdir_recursive(&testpkg_dir, io::UserRWX);\n \n     writeFile(&testpkg_dir.join(\"main.rs\"),\n@@ -1916,13 +1915,13 @@ fn test_recursive_deps() {\n     let c_id = PkgId::new(\"c\");\n     let b_workspace = create_local_package_with_dep(&b_id, &c_id);\n     let b_workspace = b_workspace.path();\n-    writeFile(&b_workspace.join_many([\"src\", \"c-0.1\", \"lib.rs\"]),\n+    writeFile(&b_workspace.join_many([\"src\", \"c-0.0\", \"lib.rs\"]),\n                \"pub fn g() {}\");\n     let a_workspace = create_local_package(&a_id);\n     let a_workspace = a_workspace.path();\n-    writeFile(&a_workspace.join_many([\"src\", \"a-0.1\", \"main.rs\"]),\n+    writeFile(&a_workspace.join_many([\"src\", \"a-0.0\", \"main.rs\"]),\n                \"extern mod b; use b::f; fn main() { f(); }\");\n-    writeFile(&b_workspace.join_many([\"src\", \"b-0.1\", \"lib.rs\"]),\n+    writeFile(&b_workspace.join_many([\"src\", \"b-0.0\", \"lib.rs\"]),\n                \"extern mod c; use c::g; pub fn f() { g(); }\");\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let environment = Some(~[(~\"RUST_PATH\", b_workspace.as_str().unwrap().to_owned())]);\n@@ -1999,7 +1998,7 @@ fn test_dependencies_terminate() {\n     let b_id = PkgId::new(\"b\");\n     let workspace = create_local_package(&b_id);\n     let workspace = workspace.path();\n-    let b_dir = workspace.join_many([\"src\", \"b-0.1\"]);\n+    let b_dir = workspace.join_many([\"src\", \"b-0.0\"]);\n     let b_subdir = b_dir.join(\"test\");\n     fs::mkdir_recursive(&b_subdir, io::UserRWX);\n     writeFile(&b_subdir.join(\"test.rs\"),\n@@ -2066,10 +2065,10 @@ fn correct_package_name_with_rust_path_hack() {\n     let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n     let dest_workspace = dest_workspace.path();\n \n-    writeFile(&dest_workspace.join_many([\"src\", \"bar-0.1\", \"main.rs\"]),\n+    writeFile(&dest_workspace.join_many([\"src\", \"bar-0.0\", \"main.rs\"]),\n               \"extern mod blat; fn main() { let _x = (); }\");\n \n-    let foo_path = foo_workspace.join_many([\"src\", \"foo-0.1\"]);\n+    let foo_path = foo_workspace.join_many([\"src\", \"foo-0.0\"]);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let rust_path = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", dest_workspace.as_str().unwrap(),\n                                                   foo_path.as_str().unwrap()))]);\n@@ -2092,7 +2091,7 @@ fn test_rustpkg_test_creates_exec() {\n     let foo_id = PkgId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n-    writeFile(&foo_workspace.join_many([\"src\", \"foo-0.1\", \"test.rs\"]),\n+    writeFile(&foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]),\n               \"#[test] fn f() { assert!('a' == 'a'); }\");\n     command_line_test([~\"test\", ~\"foo\"], foo_workspace);\n     assert!(test_executable_exists(foo_workspace, \"foo\"));\n@@ -2115,7 +2114,7 @@ fn test_rustpkg_test_failure_exit_status() {\n     let foo_id = PkgId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n-    writeFile(&foo_workspace.join_many([\"src\", \"foo-0.1\", \"test.rs\"]),\n+    writeFile(&foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]),\n               \"#[test] fn f() { assert!('a' != 'a'); }\");\n     let res = command_line_test_partial([~\"test\", ~\"foo\"], foo_workspace);\n     match res {\n@@ -2129,7 +2128,7 @@ fn test_rustpkg_test_cfg() {\n     let foo_id = PkgId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n-    writeFile(&foo_workspace.join_many([\"src\", \"foo-0.1\", \"test.rs\"]),\n+    writeFile(&foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]),\n               \"#[test] #[cfg(not(foobar))] fn f() { assert!('a' != 'a'); }\");\n     let output = command_line_test([~\"test\", ~\"--cfg\", ~\"foobar\", ~\"foo\"],\n                                    foo_workspace);\n@@ -2142,7 +2141,7 @@ fn test_rebuild_when_needed() {\n     let foo_id = PkgId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n-    let test_crate = foo_workspace.join_many([\"src\", \"foo-0.1\", \"test.rs\"]);\n+    let test_crate = foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]);\n     writeFile(&test_crate, \"#[test] fn f() { assert!('a' == 'a'); }\");\n     command_line_test([~\"test\", ~\"foo\"], foo_workspace);\n     assert!(test_executable_exists(foo_workspace, \"foo\"));\n@@ -2163,7 +2162,7 @@ fn test_no_rebuilding() {\n     let foo_id = PkgId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n-    let test_crate = foo_workspace.join_many([\"src\", \"foo-0.1\", \"test.rs\"]);\n+    let test_crate = foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]);\n     writeFile(&test_crate, \"#[test] fn f() { assert!('a' == 'a'); }\");\n     command_line_test([~\"test\", ~\"foo\"], foo_workspace);\n     assert!(test_executable_exists(foo_workspace, \"foo\"));\n@@ -2182,7 +2181,7 @@ fn test_no_rebuilding() {\n fn test_installed_read_only() {\n     // Install sources from a \"remote\" (actually a local github repo)\n     // Check that afterward, sources are read-only and installed under build/\n-    let temp_pkg_id = git_repo_pkg();\n+    let mut temp_pkg_id = git_repo_pkg();\n     let repo = init_git_repo(&temp_pkg_id.path);\n     let repo = repo.path();\n     debug!(\"repo = {}\", repo.display());\n@@ -2194,6 +2193,8 @@ fn test_installed_read_only() {\n     writeFile(&repo_subdir.join(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n     add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n+    // update pkgid to what will be auto-detected\n+    temp_pkg_id.version = ExactRevision(~\"0.1\");\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n     command_line_test([~\"install\", temp_pkg_id.path.as_str().unwrap().to_owned()], repo);\n@@ -2247,7 +2248,7 @@ fn test_installed_local_changes() {\n     let target_dir = hacking_workspace.join_many([\"src\",\n                                                   \"mockgithub.com\",\n                                                   \"catamorphism\",\n-                                                  \"test-pkg-0.1\"]);\n+                                                  \"test-pkg-0.0\"]);\n     debug!(\"---- git clone {} {}\", repo_subdir.display(), target_dir.display());\n \n     let c_res = safe_git_clone(&repo_subdir, &NoVersion, &target_dir);\n@@ -2294,7 +2295,7 @@ fn test_compile_error() {\n     let foo_id = PkgId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n-    let main_crate = foo_workspace.join_many([\"src\", \"foo-0.1\", \"main.rs\"]);\n+    let main_crate = foo_workspace.join_many([\"src\", \"foo-0.0\", \"main.rs\"]);\n     // Write something bogus\n     writeFile(&main_crate, \"pub fn main() { if 42 != ~\\\"the answer\\\" { fail!(); } }\");\n     let result = command_line_test_partial([~\"build\", ~\"foo\"], foo_workspace);\n@@ -2327,15 +2328,15 @@ fn test_c_dependency_ok() {\n \n     let dir = create_local_package(&PkgId::new(\"cdep\"));\n     let dir = dir.path();\n-    writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"main.rs\"]),\n+    writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"main.rs\"]),\n               \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n               \\nfn main() { unsafe { f(); } }\");\n-    writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"foo.c\"]), \"void f() {}\");\n+    writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"foo.c\"]), \"void f() {}\");\n \n     debug!(\"dir = {}\", dir.display());\n     let source = Path::new(file!()).dir_path().join_many(\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n-    fs::copy(&source, &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]));\n+    fs::copy(&source, &dir.join_many([~\"src\", ~\"cdep-0.0\", ~\"pkg.rs\"]));\n     command_line_test([~\"build\", ~\"cdep\"], dir);\n     assert_executable_exists(dir, \"cdep\");\n     let out_dir = target_build_dir(dir).join(\"cdep\");\n@@ -2344,20 +2345,21 @@ fn test_c_dependency_ok() {\n     assert!(c_library_path.exists());\n }\n \n+#[ignore(reason=\"rustpkg is not reentrant\")]\n #[test]\n #[ignore(reason=\"busted\")]\n fn test_c_dependency_no_rebuilding() {\n     let dir = create_local_package(&PkgId::new(\"cdep\"));\n     let dir = dir.path();\n-    writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"main.rs\"]),\n+    writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"main.rs\"]),\n               \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n               \\nfn main() { unsafe { f(); } }\");\n-    writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"foo.c\"]), \"void f() {}\");\n+    writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"foo.c\"]), \"void f() {}\");\n \n     debug!(\"dir = {}\", dir.display());\n     let source = Path::new(file!()).dir_path().join_many(\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n-    fs::copy(&source, &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]));\n+    fs::copy(&source, &dir.join_many([~\"src\", ~\"cdep-0.0\", ~\"pkg.rs\"]));\n     command_line_test([~\"build\", ~\"cdep\"], dir);\n     assert_executable_exists(dir, \"cdep\");\n     let out_dir = target_build_dir(dir).join(\"cdep\");\n@@ -2383,15 +2385,15 @@ fn test_c_dependency_no_rebuilding() {\n fn test_c_dependency_yes_rebuilding() {\n     let dir = create_local_package(&PkgId::new(\"cdep\"));\n     let dir = dir.path();\n-    writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"main.rs\"]),\n+    writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"main.rs\"]),\n               \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n               \\nfn main() { unsafe { f(); } }\");\n-    let c_file_name = dir.join_many([\"src\", \"cdep-0.1\", \"foo.c\"]);\n+    let c_file_name = dir.join_many([\"src\", \"cdep-0.0\", \"foo.c\"]);\n     writeFile(&c_file_name, \"void f() {}\");\n \n     let source = Path::new(file!()).dir_path().join_many(\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n-    let target = dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]);\n+    let target = dir.join_many([~\"src\", ~\"cdep-0.0\", ~\"pkg.rs\"]);\n     debug!(\"Copying {} -> {}\", source.display(), target.display());\n     fs::copy(&source, &target);\n     command_line_test([~\"build\", ~\"cdep\"], dir);\n@@ -2420,13 +2422,13 @@ fn test_c_dependency_yes_rebuilding() {\n fn correct_error_dependency() {\n     // Supposing a package we're trying to install via a dependency doesn't\n     // exist, we should throw a condition, and not ICE\n-    let dir = create_local_package(&PkgId::new(\"badpkg\"));\n+    let workspace_dir = create_local_package(&PkgId::new(\"badpkg\"));\n \n-    let dir = dir.path();\n-    writeFile(&dir.join_many([\"src\", \"badpkg-0.1\", \"main.rs\"]),\n+    let dir = workspace_dir.path();\n+    let main_rs = dir.join_many([\"src\", \"badpkg-0.0\", \"main.rs\"]);\n+    writeFile(&main_rs,\n               \"extern mod p = \\\"some_package_that_doesnt_exist\\\";\n                fn main() {}\");\n-\n     match command_line_test_partial([~\"build\", ~\"badpkg\"], dir) {\n         Fail(ProcessOutput{ error: error, output: output, .. }) => {\n             assert!(str::is_utf8(error));"}, {"sha": "e5386aa701bf15224b3f85265b34d8ecfa4aed30", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/pkg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -42,7 +42,7 @@ pub fn main() {\n \n     let mut context = api::default_context(sysroot, path_for_db);\n     let my_workspace = api::my_workspace(&context.context, \"cdep\");\n-    let foo_c_name = my_workspace.join_many([\"src\", \"cdep-0.1\", \"foo.c\"]);\n+    let foo_c_name = my_workspace.join_many([\"src\", \"cdep-0.0\", \"foo.c\"]);\n \n     let out_lib_path = context.workcache_context.with_prep(\"foo.c\", |prep| {\n         let sub_cx = context.context.clone();"}, {"sha": "97fba807c0e6030404e265ddeca82add141a5ec1", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -290,23 +290,17 @@ pub fn compile_input(context: &BuildContext,\n                                       addl_lib_search_paths.insert(p);\n                                   });\n \n-    // Inject the link attributes so we get the right package name and version\n-    if attr::find_linkage_metas(crate.attrs).is_empty() {\n-        let name_to_use = match what {\n-            Test  => format!(\"{}test\", pkg_id.short_name).to_managed(),\n-            Bench => format!(\"{}bench\", pkg_id.short_name).to_managed(),\n-            _     => pkg_id.short_name.to_managed()\n-        };\n-        debug!(\"Injecting link name: {}\", name_to_use);\n+    // Inject the pkgid attribute so we get the right package name and version\n+    if !attr::contains_name(crate.attrs, \"pkgid\") {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let link_options =\n-            ~[attr::mk_name_value_item_str(@\"name\", name_to_use),\n-              attr::mk_name_value_item_str(@\"vers\", pkg_id.version.to_str().to_managed())] +\n-            ~[attr::mk_name_value_item_str(@\"package_id\",\n-                                           pkg_id.path.as_str().unwrap().to_managed())];\n-\n-        debug!(\"link options: {:?}\", link_options);\n-        crate.attrs = ~[attr::mk_attr(attr::mk_list_item(@\"link\", link_options))];\n+        let pkgid_attr =\n+            attr::mk_name_value_item_str(@\"pkgid\",\n+                                         format!(\"{}\\\\#{}\",\n+                                                 pkg_id.path.as_str().unwrap(),\n+                                                 pkg_id.version.to_str()).to_managed());\n+\n+        debug!(\"pkgid attr: {:?}\", pkgid_attr);\n+        crate.attrs = ~[attr::mk_attr(pkgid_attr)];\n     }\n \n     debug!(\"calling compile_crate_from_input, workspace = {},\n@@ -316,7 +310,8 @@ pub fn compile_input(context: &BuildContext,\n                                           context.compile_upto(),\n                                           &out_dir,\n                                           sess,\n-                                          crate);\n+                                          crate,\n+                                          what);\n     // Discover the output\n     let discovered_output = if what == Lib  {\n         built_library_in_workspace(pkg_id, workspace) // Huh???\n@@ -351,15 +346,29 @@ pub fn compile_crate_from_input(input: &Path,\n                                 sess: session::Session,\n // Returns None if one of the flags that suppresses compilation output was\n // given\n-                                crate: ast::Crate) -> Option<Path> {\n+                                crate: ast::Crate,\n+                                what: OutputType) -> Option<Path> {\n     debug!(\"Calling build_output_filenames with {}, building library? {:?}\",\n            out_dir.display(), sess.building_library);\n \n     // bad copy\n     debug!(\"out_dir = {}\", out_dir.display());\n-    let outputs = driver::build_output_filenames(&driver::file_input(input.clone()),\n-                                                 &Some(out_dir.clone()), &None,\n-                                                 crate.attrs, sess);\n+    let mut outputs = driver::build_output_filenames(&driver::file_input(input.clone()),\n+                                                     &Some(out_dir.clone()), &None,\n+                                                     crate.attrs, sess);\n+    match what {\n+        Lib | Main => {}\n+        Test => {\n+            let mut ofile = outputs.out_filename.filename_str().unwrap().to_owned();\n+            ofile.push_str(\"test\");\n+            outputs.out_filename.set_filename(ofile);\n+        }\n+        Bench => {\n+            let mut ofile = outputs.out_filename.filename_str().unwrap().to_owned();\n+            ofile.push_str(\"bench\");\n+            outputs.out_filename.set_filename(ofile);\n+        }\n+    };\n \n     debug!(\"Outputs are out_filename: {} and obj_filename: {} and output type = {:?}\",\n            outputs.out_filename.display(),"}, {"sha": "ba6cf5f513b77fefd85a8a288c583ec06ad04cf5", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -24,7 +24,7 @@ pub enum Version {\n     SemanticVersion(semver::Version),\n     Tagged(~str), // String that can't be parsed as a version.\n                   // Requirements get interpreted exactly\n-    NoVersion // user didn't specify a version -- prints as 0.1\n+    NoVersion // user didn't specify a version -- prints as 0.0\n }\n \n // Equality on versions is non-symmetric: if self is NoVersion, it's equal to\n@@ -81,7 +81,7 @@ impl ToStr for Version {\n         match *self {\n             ExactRevision(ref n) | Tagged(ref n) => format!(\"{}\", n.to_str()),\n             SemanticVersion(ref v) => format!(\"{}\", v.to_str()),\n-            NoVersion => ~\"0.1\"\n+            NoVersion => ~\"0.0\"\n         }\n     }\n }"}, {"sha": "824ba5341d4f6cd6823d76662f7fce10f71168fb", "filename": "src/librustpkg/workcache_support.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustpkg%2Fworkcache_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustpkg%2Fworkcache_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkcache_support.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -11,15 +11,15 @@\n use std::io;\n use std::io::File;\n use extra::workcache;\n-use sha1::{Digest, Sha1};\n+use sha2::{Digest, Sha256};\n \n /// Hashes the file contents along with the last-modified time\n pub fn digest_file_with_date(path: &Path) -> ~str {\n     use conditions::bad_path::cond;\n \n     match io::result(|| File::open(path).read_to_end()) {\n         Ok(bytes) => {\n-            let mut sha = Sha1::new();\n+            let mut sha = Sha256::new();\n             sha.input(bytes);\n             let st = path.stat();\n             sha.input_str(st.modified.to_str());\n@@ -34,7 +34,7 @@ pub fn digest_file_with_date(path: &Path) -> ~str {\n \n /// Hashes only the last-modified time\n pub fn digest_only_date(path: &Path) -> ~str {\n-    let mut sha = Sha1::new();\n+    let mut sha = Sha256::new();\n     let st = path.stat();\n     sha.input_str(st.modified.to_str());\n     sha.result_str()"}, {"sha": "d8b7c4db69c809fa63c5b1724cc0c043a95ad922", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -34,6 +34,8 @@ via `close` and `delete` methods.\n \n */\n \n+#[pkgid=\"rustuv#0.9-pre\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"rustuv\",\n        package_id = \"rustuv\",\n        vers = \"0.9-pre\","}, {"sha": "e2674006215035c3fb833a214df4a10a1a306e7a", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -43,6 +43,8 @@\n //!\n //!     use std::prelude::*;\n \n+#[pkgid=\"std#0.9-pre\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"std\",\n        package_id = \"std\",\n        vers = \"0.9-pre\",\n@@ -69,13 +71,13 @@\n // When testing libstd, bring in libuv as the I/O backend so tests can print\n // things and all of the std::io tests have an I/O interface to run on top\n // of\n-#[cfg(test)] extern mod rustuv(vers = \"0.9-pre\");\n+#[cfg(test)] extern mod rustuv = \"rustuv#0.9-pre\";\n \n // Make extra accessible for benchmarking\n-#[cfg(test)] extern mod extra(vers = \"0.9-pre\");\n+#[cfg(test)] extern mod extra = \"extra#0.9-pre\";\n \n // Make std testable by not duplicating lang items. See #2912\n-#[cfg(test)] extern mod realstd(name = \"std\");\n+#[cfg(test)] extern mod realstd = \"std#0.9-pre\";\n #[cfg(test)] pub use kinds = realstd::kinds;\n #[cfg(test)] pub use ops = realstd::ops;\n #[cfg(test)] pub use cmp = realstd::cmp;"}, {"sha": "eb5b2df4ed967a30063e8ff83c62e0c871f40e9e", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -917,8 +917,6 @@ fn new_sched_rng() -> XorShiftRng {\n \n #[cfg(test)]\n mod test {\n-    extern mod extra;\n-\n     use prelude::*;\n     use rt::test::*;\n     use unstable::run_in_bare_thread;"}, {"sha": "ac5254f1abafc80f02dce3b0ee98ee1eb201b57b", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -18,6 +18,7 @@ use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n use diagnostic::span_handler;\n use parse::comments::{doc_comment_style, strip_doc_comment_decoration};\n+use pkgid::PkgId;\n \n use std::hashmap::HashSet;\n \n@@ -235,6 +236,13 @@ pub fn find_linkage_metas(attrs: &[Attribute]) -> ~[@MetaItem] {\n     result\n }\n \n+pub fn find_pkgid(attrs: &[Attribute]) -> Option<PkgId> {\n+    match first_attr_value_str_by_name(attrs, \"pkgid\") {\n+        None => None,\n+        Some(id) => from_str::<PkgId>(id),\n+    }\n+}\n+\n #[deriving(Eq)]\n pub enum InlineAttr {\n     InlineNone,"}, {"sha": "4382e6d67b883e92efbe5101738aa486bb91879e", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -13,6 +13,8 @@\n  *  macros.\n  */\n \n+#[pkgid=\"syntax#0.9-pre\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"syntax\",\n        package_id = \"syntax\",\n        vers = \"0.9-pre\",\n@@ -51,6 +53,7 @@ pub mod fold;\n \n \n pub mod parse;\n+pub mod pkgid;\n \n pub mod print {\n     pub mod pp;"}, {"sha": "1e840ca700bd180b5f8471bc1335d0a08e6d32e0", "filename": "src/libsyntax/pkgid.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibsyntax%2Fpkgid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Flibsyntax%2Fpkgid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fpkgid.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -0,0 +1,160 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deriving(Clone, Eq)]\n+pub struct PkgId {\n+    path: ~str,\n+    name: ~str,\n+    version: Option<~str>,\n+}\n+\n+impl ToStr for PkgId {\n+    fn to_str(&self) -> ~str {\n+        let version = match self.version {\n+            None => \"0.0\",\n+            Some(ref version) => version.as_slice(),\n+        };\n+        if self.path.is_empty() {\n+            format!(\"{}\\\\#{}\", self.name, version)\n+        } else {\n+            format!(\"{}/{}\\\\#{}\", self.path, self.name, version)\n+        }\n+    }\n+}\n+\n+impl FromStr for PkgId {\n+    fn from_str(s: &str) -> Option<PkgId> {\n+        let hash_idx = match s.find('#') {\n+            None => s.len(),\n+            Some(idx) => idx,\n+        };\n+        let prefix = s.slice_to(hash_idx);\n+        let name_idx = match prefix.rfind('/') {\n+            None => 0,\n+            Some(idx) => idx + 1,\n+        };\n+        if name_idx >= prefix.len() {\n+            return None;\n+        }\n+        let name = prefix.slice_from(name_idx);\n+        if name.len() <= 0 {\n+            return None;\n+        }\n+\n+        let path = if name_idx == 0 {\n+            \"\"\n+        } else {\n+            prefix.slice_to(name_idx - 1)\n+        };\n+        let check_path = Path::new(path);\n+        if !check_path.is_relative() {\n+            return None;\n+        }\n+\n+        let version = match s.find('#') {\n+            None => None,\n+            Some(idx) => {\n+                if idx >= s.len() {\n+                    None\n+                } else {\n+                    let v = s.slice_from(idx + 1);\n+                    if v.is_empty() {\n+                        None\n+                    } else {\n+                        Some(v.to_owned())\n+                    }\n+                }\n+            }\n+        };\n+\n+        Some(PkgId{\n+            path: path.to_owned(),\n+            name: name.to_owned(),\n+            version: version,\n+        })\n+    }\n+}\n+\n+impl PkgId {\n+    pub fn version_or_default<'a>(&'a self) -> &'a str {\n+        match self.version {\n+            None => \"0.0\",\n+            Some(ref version) => version.as_slice(),\n+        }\n+    }\n+}\n+\n+#[test]\n+fn bare_name() {\n+    let pkgid: PkgId = from_str(\"foo\").expect(\"valid pkgid\");\n+    assert_eq!(pkgid.name, ~\"foo\");\n+    assert_eq!(pkgid.version, None);\n+    assert_eq!(pkgid.path, ~\"\");\n+}\n+\n+#[test]\n+fn bare_name_single_char() {\n+    let pkgid: PkgId = from_str(\"f\").expect(\"valid pkgid\");\n+    assert_eq!(pkgid.name, ~\"f\");\n+    assert_eq!(pkgid.version, None);\n+    assert_eq!(pkgid.path, ~\"\");\n+}\n+\n+#[test]\n+fn empty_pkgid() {\n+    let pkgid: Option<PkgId> = from_str(\"\");\n+    assert!(pkgid.is_none());\n+}\n+\n+#[test]\n+fn simple_path() {\n+    let pkgid: PkgId = from_str(\"example.com/foo/bar\").expect(\"valid pkgid\");\n+    assert_eq!(pkgid.name, ~\"bar\");\n+    assert_eq!(pkgid.version, None);\n+    assert_eq!(pkgid.path, ~\"example.com/foo\");\n+}\n+\n+#[test]\n+fn simple_version() {\n+    let pkgid: PkgId = from_str(\"foo#1.0\").expect(\"valid pkgid\");\n+    assert_eq!(pkgid.name, ~\"foo\");\n+    assert_eq!(pkgid.version, Some(~\"1.0\"));\n+    assert_eq!(pkgid.path, ~\"\");\n+}\n+\n+#[test]\n+fn absolute_path() {\n+    let pkgid: Option<PkgId> = from_str(\"/foo/bar\");\n+    assert!(pkgid.is_none());\n+}\n+\n+#[test]\n+fn path_and_version() {\n+    let pkgid: PkgId = from_str(\"example.com/foo/bar#1.0\").expect(\"valid pkgid\");\n+    assert_eq!(pkgid.name, ~\"bar\");\n+    assert_eq!(pkgid.version, Some(~\"1.0\"));\n+    assert_eq!(pkgid.path, ~\"example.com/foo\");\n+}\n+\n+#[test]\n+fn single_chars() {\n+    let pkgid: PkgId = from_str(\"a/b#1\").expect(\"valid pkgid\");\n+    assert_eq!(pkgid.name, ~\"b\");\n+    assert_eq!(pkgid.version, Some(~\"1\"));\n+    assert_eq!(pkgid.path, ~\"a\");\n+}\n+\n+#[test]\n+fn missing_version() {\n+    let pkgid: PkgId = from_str(\"foo#\").expect(\"valid pkgid\");\n+    assert_eq!(pkgid.name, ~\"foo\");\n+    assert_eq!(pkgid.version, None);\n+    assert_eq!(pkgid.path, ~\"\");\n+}\n\\ No newline at end of file"}, {"sha": "0c1906500c07fc9ebb2ac1fd5a3d8d2d136a4059", "filename": "src/test/auxiliary/anon-extern-mod-cross-crate-1.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fanon-extern-mod-cross-crate-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fanon-extern-mod-cross-crate-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fanon-extern-mod-cross-crate-1.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[link(name = \"anonexternmod\", vers = \"0.1\")];\n-\n-#[crate_type = \"lib\"];\n+#[pkgid=\"anonexternmod#0.1\"];\n \n use std::libc;\n \n-#[link(name = \"rustrt\")]\n+#[link(name=\"rustrt\")]\n extern {\n     pub fn rust_get_test_int() -> libc::intptr_t;\n }"}, {"sha": "16c03fa8e3b330d5816e8ae75ab66657297c9785", "filename": "src/test/auxiliary/cci_impl_lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"cci_impl_lib\"];\n+// NOTE: remove after the next snapshot\n #[link(name=\"cci_impl_lib\", vers=\"0.0\")];\n \n trait uint_helpers {"}, {"sha": "903563055b7f1efbbeeaf5b5003735dde025c90a", "filename": "src/test/auxiliary/cci_iter_lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"cci_iter_lib\"];\n+// NOTE: remove after the next snapshot\n #[link(name=\"cci_iter_lib\", vers=\"0.0\")];\n \n #[inline]"}, {"sha": "ea06cbf793a4defe787d5c0d23486455c7eeab39", "filename": "src/test/auxiliary/cci_no_inline_lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"cci_no_inline_lib\"];\n+// NOTE: remove after the next snapshot\n #[link(name=\"cci_no_inline_lib\", vers=\"0.0\")];\n \n // same as cci_iter_lib, more-or-less, but not marked inline"}, {"sha": "921082440d86be3f043b1e1132f5ecbcd13c0044", "filename": "src/test/auxiliary/crate-method-reexport-grrrrrrr2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n #[feature(managed_boxes)];\n+#[pkgid=\"crate_method_reexport_grrrrrrr2\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"crate_method_reexport_grrrrrrr2\")];\n \n pub use name_pool::add;"}, {"sha": "d7600f95ecdb187b95dd13893f0a5dab06b2e680", "filename": "src/test/auxiliary/crateresolve1-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve1-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve1-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve1-1.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"crateresolve1#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"crateresolve1\",\n        vers = \"0.1\")];\n "}, {"sha": "239d11b19857732af853e3112a8d5247109f4caa", "filename": "src/test/auxiliary/crateresolve1-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve1-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve1-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve1-2.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"crateresolve1#0.2\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"crateresolve1\",\n        vers = \"0.2\")];\n "}, {"sha": "7acb3804fd307533a44ecd991bd3c1f682043294", "filename": "src/test/auxiliary/crateresolve1-3.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve1-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve1-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve1-3.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"crateresolve1#0.3\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"crateresolve1\",\n        vers = \"0.3\")];\n "}, {"sha": "149314e5a07442fb9415f8d1a88042677a6689f6", "filename": "src/test/auxiliary/crateresolve2-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve2-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve2-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve2-1.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"crateresolve2#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"crateresolve2\",\n        vers = \"0.1\")];\n "}, {"sha": "9286b68586a9854697319d154448b982659cd968", "filename": "src/test/auxiliary/crateresolve2-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve2-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve2-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve2-2.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"crateresolve2#0.2\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"crateresolve2\",\n        vers = \"0.2\")];\n "}, {"sha": "37ccbbd40d70e0673aa67de0515d739169cac14a", "filename": "src/test/auxiliary/crateresolve2-3.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve2-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve2-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve2-3.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"crateresolve2#0.3\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"crateresolve2\",\n        vers = \"0.3\")];\n "}, {"sha": "e2c46a9a88d2f7c974868afb95704625e2cac6fa", "filename": "src/test/auxiliary/crateresolve3-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve3-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve3-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve3-1.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"crateresolve3#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"crateresolve3\",\n        vers = \"0.1\")];\n "}, {"sha": "cda986f21cbf6ea246f4b14d49cd886a5e5be610", "filename": "src/test/auxiliary/crateresolve3-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve3-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve3-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve3-2.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"crateresolve3#0.2\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"crateresolve3\",\n        vers = \"0.2\")];\n "}, {"sha": "eeb946b1da7715c1d17e9f42a075e216642a0c9f", "filename": "src/test/auxiliary/crateresolve4a-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-1.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"crateresolve4a#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"crateresolve4a\", vers = \"0.1\")];\n #[crate_type = \"lib\"];\n "}, {"sha": "9c089fd214139ee9f094c838214ca6ce8a340a8e", "filename": "src/test/auxiliary/crateresolve4a-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-2.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"crateresolve4a#0.2\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"crateresolve4a\", vers= \"0.2\")];\n #[crate_type = \"lib\"];\n "}, {"sha": "9fbfdcf1687d1702cb3a9d567c6a16c97a5628e8", "filename": "src/test/auxiliary/crateresolve4b-1.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-1.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -10,9 +10,11 @@\n \n // aux-build:crateresolve4a-1.rs\n // aux-build:crateresolve4a-2.rs\n+#[pkgid=\"crateresolve4b#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"crateresolve4b\", vers = \"0.1\")];\n #[crate_type = \"lib\"];\n \n-extern mod crateresolve4a(vers=\"0.2\");\n+extern mod crateresolve4a = \"crateresolve4a#0.2\";\n \n pub fn f() -> int { crateresolve4a::g() }"}, {"sha": "73484ab22320158ee2dff07d6a0ed99b80ee86a1", "filename": "src/test/auxiliary/crateresolve4b-2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-2.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -10,9 +10,11 @@\n \n // aux-build:crateresolve4a-1.rs\n // aux-build:crateresolve4a-2.rs\n+#[pkgid=\"crateresolve4b#0.2\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"crateresolve4b\", vers = \"0.2\")];\n #[crate_type = \"lib\"];\n \n-extern mod crateresolve4a(vers=\"0.1\");\n+extern mod crateresolve4a = \"crateresolve4a#0.1\";\n \n pub fn g() -> int { crateresolve4a::f() }"}, {"sha": "726b3919f7ff33e5d04248eddcb5576e1d7469ac", "filename": "src/test/auxiliary/crateresolve5-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"crateresolve5#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"crateresolve5\",\n        vers = \"0.1\")];\n "}, {"sha": "05a760dea7384ab03878fa41d640fd1d5dd02420", "filename": "src/test/auxiliary/crateresolve5-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"crateresolve5#0.2\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"crateresolve5\",\n        vers = \"0.2\")];\n "}, {"sha": "b0990d2e3036dfd8b31a7b36767d889ab05868b9", "filename": "src/test/auxiliary/crateresolve8-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve8-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve8-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve8-1.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n // default link meta for 'package_id' will be equal to filestem\n+#[pkgid=\"crateresolve8#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"crateresolve8\",\n        vers = \"0.1\")];\n "}, {"sha": "0f000716e4de04bd2818bde7109ea591abbcd8a6", "filename": "src/test/auxiliary/crateresolve_calories-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-1.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"crateresolve_calories#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"crateresolve_calories\",\n        vers = \"0.1\",\n        calories = \"100\")];"}, {"sha": "4d3ff1e2071aba4ce35cf1e0f8c6e922738514c0", "filename": "src/test/auxiliary/crateresolve_calories-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-2.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"crateresolve_calories#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"crateresolve_calories\",\n        vers = \"0.1\",\n        calories = \"200\")];"}, {"sha": "d6bf2dda9cedf8d91eabd8bbae5ec3288533f95e", "filename": "src/test/auxiliary/extern-crosscrate-source.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"externcallback#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"externcallback\",\n        vers = \"0.1\")];\n "}, {"sha": "4a92a8dd5666c60bf58be86d5b42b38aef0911ce", "filename": "src/test/auxiliary/foreign_lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"foreign_lib\"];\n+// NOTE: remove after the next snapshot\n #[link(name=\"foreign_lib\", vers=\"0.0\")];\n \n pub mod rustrt {"}, {"sha": "67db37234cf003cd5ae1edcabdbb46c5fb9c7885", "filename": "src/test/auxiliary/inline_dtor.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Finline_dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Finline_dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Finline_dtor.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"inline_dtor#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name=\"inline_dtor\", vers=\"0.1\")];\n \n pub struct Foo;"}, {"sha": "83574fb218ad6d37e9e8c262dbcb19277ae02ff0", "filename": "src/test/auxiliary/iss.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fiss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fiss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fiss.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"issue6919_3#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name=\"iss6919_3\", vers=\"0.1\")];\n \n // part of issue-6919.rs"}, {"sha": "a1534aa25e44ee693ff1c6c220c2b8e106ab1052", "filename": "src/test/auxiliary/issue-2380.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fissue-2380.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fissue-2380.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2380.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n #[feature(managed_boxes)];\n+#[pkgid=\"a\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"a\", vers = \"0.0\")];\n #[crate_type = \"lib\"];\n "}, {"sha": "9caf89deb492692ee0436e6a53d218168f01925d", "filename": "src/test/auxiliary/issue-2414-a.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"a#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"a\", vers = \"0.1\")];\n #[crate_type = \"lib\"];\n "}, {"sha": "726f8cc29ab3073cc4826884b4225ee8afc39d51", "filename": "src/test/auxiliary/issue-2414-b.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fissue-2414-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fissue-2414-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2414-b.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -10,6 +10,8 @@\n \n // xfail-fast\n \n+#[pkgid=\"b#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"b\", vers = \"0.1\")];\n #[crate_type = \"lib\"];\n "}, {"sha": "cdbb081f9022eae9a1c56571cd4f153363b6624b", "filename": "src/test/auxiliary/issue-2526.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2526.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"issue_2526#0.2\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"issue_2526\",\n        vers = \"0.2\",\n        uuid = \"54cc1bc9-02b8-447c-a227-75ebc923bc29\")];"}, {"sha": "451fde61ce7ef75ad534335133ba688045a0716d", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n #[feature(managed_boxes)];\n+#[pkgid=\"req\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"req\")];\n #[crate_type = \"lib\"];\n "}, {"sha": "f206911a7c06f1320a55f970ad30a8ee85bfa778", "filename": "src/test/auxiliary/issue-3012-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fissue-3012-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fissue-3012-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-3012-1.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"socketlib\"];\n+// NOTE: remove after the next snapshot\n #[link(name=\"socketlib\", vers=\"0.0\")];\n #[crate_type = \"lib\"];\n "}, {"sha": "35b19c6558c467b061cf86047625f1f7cd42c197", "filename": "src/test/auxiliary/issue-4208-cc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fissue-4208-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fissue-4208-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-4208-cc.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"numeric#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"numeric\",\n        vers = \"0.1\")];\n #[crate_type = \"lib\"];"}, {"sha": "cfa75be5b0eb283c96a70948e458cbc96ad6cc8f", "filename": "src/test/auxiliary/issue_2242_a.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"a#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"a\", vers = \"0.1\")];\n #[crate_type = \"lib\"];\n "}, {"sha": "331d25358931447f852b003b6456fe67a285ea3f", "filename": "src/test/auxiliary/issue_2242_c.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"c#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"c\", vers = \"0.1\")];\n #[crate_type = \"lib\"];\n "}, {"sha": "e800e59b9978237f419330c2d022010de2440fd6", "filename": "src/test/auxiliary/issue_3979_traits.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fissue_3979_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fissue_3979_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_3979_traits.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"issue_3979_traits#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"issue_3979_traits\",\n        vers = \"0.1\")];\n "}, {"sha": "398d0268bc57efed9a9cf8cb368fff01cd5ccfec", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -7,6 +7,8 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+#[pkgid=\"lint_stability#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"lint_stability\",\n        vers = \"0.1\")];\n #[crate_type = \"lib\"];"}, {"sha": "b80ac427dc21d635407c30de0acb37a27ae4a871", "filename": "src/test/auxiliary/static-function-pointer-aux.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fstatic-function-pointer-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fstatic-function-pointer-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-function-pointer-aux.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"static-function-pointer-aux\"];\n+\n pub fn f(x: int) -> int { -x }\n \n pub static F: extern fn(int) -> int = f;"}, {"sha": "c6f27ebb97189a7803435b5b55bdd5ee1414d9bb", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"static_methods_crate#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"static_methods_crate\",\n        vers = \"0.1\")];\n "}, {"sha": "a090b052016fc712b87f9b5c2a733a06590e0b3f", "filename": "src/test/auxiliary/struct_variant_xc_aux.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fstruct_variant_xc_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Fstruct_variant_xc_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstruct_variant_xc_aux.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"struct_variant_xc_aux#0.1\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"struct_variant_xc_aux\",\n        vers = \"0.1\")];\n #[crate_type = \"lib\"];"}, {"sha": "a0b50f860ddc166ad16d0599221096fef385b561", "filename": "src/test/auxiliary/trait_default_method_xc_aux.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -1,3 +1,4 @@\n+#[pkgid=\"trait_default_method_xc_aux\"];\n \n pub struct Something { x: int }\n "}, {"sha": "849709dfd2210fddfd3e4eedf00ae1e3b7b4ef36", "filename": "src/test/auxiliary/trait_default_method_xc_aux_2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux_2.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -1,6 +1,6 @@\n // aux-build:trait_default_method_xc_aux.rs\n \n-extern mod aux(name = \"trait_default_method_xc_aux\");\n+extern mod aux = \"trait_default_method_xc_aux\";\n use aux::A;\n \n pub struct a_struct { x: int }"}, {"sha": "b1565d4b3a1503d399cf195d99ca85d0f41c4aa2", "filename": "src/test/compile-fail/crateresolve2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fcompile-fail%2Fcrateresolve2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fcompile-fail%2Fcrateresolve2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcrateresolve2.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -13,10 +13,10 @@\n // aux-build:crateresolve2-3.rs\n // error-pattern:using multiple versions of crate `crateresolve2`\n \n-extern mod crateresolve2(vers = \"0.1\");\n+extern mod crateresolve2 = \"crateresolve2#0.1\";\n \n mod m {\n-    pub extern mod crateresolve2(vers = \"0.2\");\n+    pub extern mod crateresolve2 = \"crateresolve2#0.2\";\n }\n \n fn main() {"}, {"sha": "8bf47d664ed9750ceb4a373492ae4597db574ce3", "filename": "src/test/compile-fail/crateresolve5.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fcompile-fail%2Fcrateresolve5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fcompile-fail%2Fcrateresolve5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcrateresolve5.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -12,8 +12,8 @@\n // aux-build:crateresolve5-1.rs\n // aux-build:crateresolve5-2.rs\n \n-extern mod cr5_1 (name = \"crateresolve5\", vers = \"0.1\");\n-extern mod cr5_2 (name = \"crateresolve5\", vers = \"0.2\");\n+extern mod cr5_1 = \"crateresolve5#0.1\";\n+extern mod cr5_2 = \"crateresolve5#0.2\";\n \n \n fn main() {"}, {"sha": "f8ccdf118bbae3ba01033f5c0f8ed10c428c7996", "filename": "src/test/compile-fail/dup-link-name.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5aad292fb99f7e9a2730b35ed535bda0ab9c6117/src%2Ftest%2Fcompile-fail%2Fdup-link-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aad292fb99f7e9a2730b35ed535bda0ab9c6117/src%2Ftest%2Fcompile-fail%2Fdup-link-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdup-link-name.rs?ref=5aad292fb99f7e9a2730b35ed535bda0ab9c6117", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:duplicate meta item `name`\n-\n-#[link(name = \"test\", name)];\n-\n-fn main() { }"}, {"sha": "dd57382afbbb7ccefd74dddbd998666165bfc58c", "filename": "src/test/compile-fail/use-meta-dup.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5aad292fb99f7e9a2730b35ed535bda0ab9c6117/src%2Ftest%2Fcompile-fail%2Fuse-meta-dup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aad292fb99f7e9a2730b35ed535bda0ab9c6117/src%2Ftest%2Fcompile-fail%2Fuse-meta-dup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-meta-dup.rs?ref=5aad292fb99f7e9a2730b35ed535bda0ab9c6117", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:duplicate meta item `name`\n-\n-extern mod extra(name = \"extra\", name = \"nonstd\");\n-\n-fn main() { }"}, {"sha": "dc8250d4134fe532a13a6d7ca0dab5cf0ca2b60d", "filename": "src/test/compile-fail/use-meta-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fcompile-fail%2Fuse-meta-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fcompile-fail%2Fuse-meta-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-meta-mismatch.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -10,6 +10,6 @@\n \n // error-pattern:can't find crate for `extra`\n \n-extern mod extra(complex(meta(item)));\n+extern mod extra = \"fake-crate\";\n \n fn main() { }"}, {"sha": "61d18a4a2f7e584b9d335f3d00910a182b326e22", "filename": "src/test/compile-fail/use-meta.rc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fcompile-fail%2Fuse-meta.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Fcompile-fail%2Fuse-meta.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-meta.rc?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -10,5 +10,4 @@\n \n // error-pattern:can't find crate for `std`\n \n-extern mod std (name = \"std\",\n-         vers = \"bogus\");\n\\ No newline at end of file\n+extern mod std = \"std#bogus\";"}, {"sha": "e42382fa84c2a2f782cfbf4b9f4d9996ea19fd54", "filename": "src/test/run-make/bootstrap-from-c-with-uvio/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-uvio%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-uvio%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-uvio%2Flib.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[link(package_id = \"boot\", name = \"boot\", vers = \"0.1\")];\n-#[crate_type = \"lib\"];\n+#[pkgid=\"boot#0.1\"];\n+#[crate_type=\"lib\"];\n \n extern mod rustuv; // pull in uvio\n "}, {"sha": "563a036fecdbd75d821b17843cc3618b4db03e37", "filename": "src/test/run-pass/crateresolve1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fcrateresolve1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fcrateresolve1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrateresolve1.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -13,7 +13,7 @@\n // aux-build:crateresolve1-2.rs\n // aux-build:crateresolve1-3.rs\n \n-extern mod crateresolve1(vers = \"0.2\");\n+extern mod crateresolve1 = \"crateresolve1#0.2\";\n \n pub fn main() {\n     assert_eq!(crateresolve1::f(), 20);"}, {"sha": "d78f8cf66baf6ce6a35bbb11bc1cea02b64b3554", "filename": "src/test/run-pass/crateresolve2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fcrateresolve2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fcrateresolve2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrateresolve2.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -14,17 +14,17 @@\n // aux-build:crateresolve2-3.rs\n \n mod a {\n-    extern mod crateresolve2(vers = \"0.1\");\n+    extern mod crateresolve2 = \"crateresolve2#0.1\";\n     pub fn f() { assert!(crateresolve2::f() == 10); }\n }\n \n mod b {\n-    extern mod crateresolve2(vers = \"0.2\");\n+    extern mod crateresolve2 = \"crateresolve2#0.2\";\n     pub fn f() { assert!(crateresolve2::f() == 20); }\n }\n \n mod c {\n-    extern mod crateresolve2(vers = \"0.3\");\n+    extern mod crateresolve2 = \"crateresolve2#0.3\";\n     pub fn f() { assert!(crateresolve2::f() == 30); }\n }\n "}, {"sha": "3114ee0fae06dd0f77a54b9d07fb67587379becc", "filename": "src/test/run-pass/crateresolve3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fcrateresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fcrateresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrateresolve3.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -16,12 +16,12 @@\n // as long as no name collision on invoked functions.\n \n mod a {\n-    extern mod crateresolve3(vers = \"0.1\");\n+    extern mod crateresolve3 = \"crateresolve3#0.1\";\n     pub fn f() { assert!(crateresolve3::f() == 10); }\n }\n \n mod b {\n-    extern mod crateresolve3(vers = \"0.2\");\n+    extern mod crateresolve3 = \"crateresolve3#0.2\";\n     pub fn f() { assert!(crateresolve3::g() == 20); }\n }\n "}, {"sha": "d913d487c0fb6c414e16f64deb4b12efdae03eaa", "filename": "src/test/run-pass/crateresolve4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fcrateresolve4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fcrateresolve4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrateresolve4.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -15,12 +15,12 @@\n // aux-build:crateresolve4b-2.rs\n \n pub mod a {\n-    extern mod crateresolve4b(vers = \"0.1\");\n+    extern mod crateresolve4b = \"crateresolve4b#0.1\";\n     pub fn f() { assert!(crateresolve4b::f() == 20); }\n }\n \n pub mod b {\n-    extern mod crateresolve4b(vers = \"0.2\");\n+    extern mod crateresolve4b = \"crateresolve4b#0.2\";\n     pub fn f() { assert!(crateresolve4b::g() == 10); }\n }\n "}, {"sha": "00c8cd90f84fc7afc6a6d54a25543a6d3e151775", "filename": "src/test/run-pass/crateresolve5.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fcrateresolve5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fcrateresolve5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrateresolve5.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -12,8 +12,8 @@\n // aux-build:crateresolve5-1.rs\n // aux-build:crateresolve5-2.rs\n \n-extern mod cr5_1 (name = \"crateresolve5\", vers = \"0.1\");\n-extern mod cr5_2 (name = \"crateresolve5\", vers = \"0.2\");\n+extern mod cr5_1 = \"crateresolve5#0.1\";\n+extern mod cr5_2 = \"crateresolve5#0.2\";\n \n pub fn main() {\n     // Structural types can be used between two versions of the same crate"}, {"sha": "883f48656bcf6344d0994f1da403baf2ed82012f", "filename": "src/test/run-pass/crateresolve6.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5aad292fb99f7e9a2730b35ed535bda0ab9c6117/src%2Ftest%2Frun-pass%2Fcrateresolve6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aad292fb99f7e9a2730b35ed535bda0ab9c6117/src%2Ftest%2Frun-pass%2Fcrateresolve6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrateresolve6.rs?ref=5aad292fb99f7e9a2730b35ed535bda0ab9c6117", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-fast\n-// aux-build:crateresolve_calories-1.rs\n-// aux-build:crateresolve_calories-2.rs\n-// error-pattern:mismatched types\n-\n-// These both have the same version but differ in other metadata\n-extern mod cr6_1 (name = \"crateresolve_calories\", vers = \"0.1\", calories=\"100\");\n-extern mod cr6_2 (name = \"crateresolve_calories\", vers = \"0.1\", calories=\"200\");\n-\n-pub fn main() {\n-    assert_eq!(cr6_1::f(), 100);\n-    assert_eq!(cr6_2::f(), 200);\n-}"}, {"sha": "86fc72aa489c65b0e9da476d29c8cbfeda24619c", "filename": "src/test/run-pass/crateresolve7.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5aad292fb99f7e9a2730b35ed535bda0ab9c6117/src%2Ftest%2Frun-pass%2Fcrateresolve7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aad292fb99f7e9a2730b35ed535bda0ab9c6117/src%2Ftest%2Frun-pass%2Fcrateresolve7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrateresolve7.rs?ref=5aad292fb99f7e9a2730b35ed535bda0ab9c6117", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-fast\n-// aux-build:crateresolve_calories-1.rs\n-// aux-build:crateresolve_calories-2.rs\n-// aux-build:crateresolve7x.rs\n-\n-extern mod crateresolve7x;\n-\n-pub fn main() {\n-    assert_eq!(crateresolve7x::a::f(), 100);\n-    assert_eq!(crateresolve7x::b::f(), 200);\n-}"}, {"sha": "ad716edd5ef05a4ca4eb6f237b74a7a9b8d9cb30", "filename": "src/test/run-pass/crateresolve8.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fcrateresolve8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fcrateresolve8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrateresolve8.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -11,7 +11,9 @@\n // xfail-fast\n // aux-build:crateresolve8-1.rs\n \n-extern mod crateresolve8(vers = \"0.1\", package_id=\"crateresolve8\");\n+#[pkgid=\"crateresolve8#0.1\"];\n+\n+extern mod crateresolve8(vers = \"0.1\", package_id=\"crateresolve8#0.1\");\n //extern mod crateresolve8(vers = \"0.1\");\n \n pub fn main() {"}, {"sha": "7fb897f9f202001ad0f00798386b62017c050e3f", "filename": "src/test/run-pass/issue-1251.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fissue-1251.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fissue-1251.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1251.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[pkgid=\"rust_get_test_int\"];\n+// NOTE: remove after the next snapshot\n #[link(name = \"rust_get_test_int\")];\n \n mod rustrt {"}, {"sha": "dfee437ba35e6dd6521cac91b384f07633e4cb2b", "filename": "src/test/run-pass/issue-4545.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fissue-4545.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fissue-4545.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4545.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -11,5 +11,5 @@\n // xfail-fast check-fast doesn't like aux-build\n // aux-build:issue-4545.rs\n \n-extern mod somelib(name = \"issue-4545\");\n+extern mod somelib = \"issue-4545\";\n fn main() { somelib::mk::<int>(); }"}, {"sha": "041c0609dcd9e619a99aae01d3d83cc8cf1b2473", "filename": "src/test/run-pass/issue-6919.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fissue-6919.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fissue-6919.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6919.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -11,9 +11,11 @@\n // aux-build:iss.rs\n // xfail-fast\n \n-extern mod iss ( name = \"iss6919_3\" );\n+#[pkgid=\"issue-6919\"];\n+\n+extern mod issue6919_3;\n \n pub fn main() {\n-    iss::D.k;\n+    issue6919_3::D.k;\n }\n "}, {"sha": "15d490e98d64fe74b2438fbcb7ad26f97ccaacd7", "filename": "src/test/run-pass/issue-8044.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fissue-8044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fissue-8044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8044.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast check-fast doesn't like aux-build\n // aux-build:issue-8044.rs\n \n-extern mod minimal(name= \"issue-8044\");\n+extern mod minimal = \"issue-8044\";\n use minimal::{BTree, leaf};\n \n fn main() {"}, {"sha": "e44374cb23a35af058c3ddbfb8aa2aa151a9a3c5", "filename": "src/test/run-pass/issue-9906.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fissue-9906.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fissue-9906.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9906.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast check-fast doesn't like extern mod\n // aux-build:issue-9906.rs\n \n-extern mod testmod(name = \"issue-9906\");\n+extern mod testmod = \"issue-9906\";\n \n fn main() {\n     testmod::foo();"}, {"sha": "4ea5aba91dac4b6fb930e996a897dd93229f0920", "filename": "src/test/run-pass/issue-9968.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fissue-9968.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fissue-9968.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9968.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast check-fast doesn't like extern mod\n // aux-build:issue-9968.rs\n \n-extern mod lib(name = \"issue-9968\");\n+extern mod lib = \"issue-9968\";\n \n use lib::{Trait, Struct};\n "}, {"sha": "99ada9cc650d577760b988a596aa8817101d0192", "filename": "src/test/run-pass/item-attributes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fitem-attributes.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -16,6 +16,8 @@\n #[attr3];\n #[attr4(attr5)];\n \n+#[pkgid=\"extra#0.1\"];\n+// NOTE: remove after the next snapshot\n // Special linkage attributes for the crate\n #[link(name = \"extra\",\n        vers = \"0.1\","}, {"sha": "438fd21e81040639e33ee8a9c09fe4c0aa32ea52", "filename": "src/test/run-pass/linkage-visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -13,7 +13,7 @@\n // xfail-android: FIXME(#10379)\n // xfail-win32: std::unstable::dynamic_lib does not work on win32 well\n \n-extern mod foo(name = \"linkage-visibility\");\n+extern mod foo = \"linkage-visibility\";\n \n fn main() {\n     foo::test();"}, {"sha": "0c722e1ede5912121e048996de5d560b5bae060b", "filename": "src/test/run-pass/priv-impl-prim-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fpriv-impl-prim-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fpriv-impl-prim-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpriv-impl-prim-ty.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast\n // aux-build:priv-impl-prim-ty.rs\n \n-extern mod bar(name = \"priv-impl-prim-ty\");\n+extern mod bar = \"priv-impl-prim-ty\";\n \n fn main() {\n     bar::frob(1i);"}, {"sha": "fcfcc30c98898de36dd52ad35bb1a4f2fc5aee58", "filename": "src/test/run-pass/reexport-should-still-link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Freexport-should-still-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Freexport-should-still-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freexport-should-still-link.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -11,7 +11,7 @@\n // aux-build:reexport-should-still-link.rs\n // xfail-fast check-fast doesn't like extern mod\n \n-extern mod foo(name = \"reexport-should-still-link\");\n+extern mod foo = \"reexport-should-still-link\";\n \n fn main() {\n     foo::bar();"}, {"sha": "e772488c8727bc232ba1d12bde2e13efdc068d19", "filename": "src/test/run-pass/static-fn-inline-xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fstatic-fn-inline-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fstatic-fn-inline-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-fn-inline-xc.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast\n // aux-build:static_fn_inline_xc_aux.rs\n \n-extern mod mycore(name =\"static_fn_inline_xc_aux\");\n+extern mod mycore = \"static_fn_inline_xc_aux\";\n \n use mycore::num;\n "}, {"sha": "ef40d2789e46afeff356bd8a6bb6ee20cab83222", "filename": "src/test/run-pass/static-fn-trait-xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fstatic-fn-trait-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fstatic-fn-trait-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-fn-trait-xc.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -1,7 +1,7 @@\n // aux-build:static_fn_trait_xc_aux.rs\n // xfail-fast\n \n-extern mod mycore(name =\"static_fn_trait_xc_aux\");\n+extern mod mycore = \"static_fn_trait_xc_aux\";\n \n use mycore::num;\n "}, {"sha": "61790e93584118cb227d6eec004e478842126728", "filename": "src/test/run-pass/static-function-pointer-xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fstatic-function-pointer-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fstatic-function-pointer-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-function-pointer-xc.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-fast\n // aux-build:static-function-pointer-aux.rs\n-extern mod aux(name = \"static-function-pointer-aux\");\n+extern mod aux = \"static-function-pointer-aux\";\n \n fn f(x: int) -> int { x }\n "}, {"sha": "171971e73e02e3e349beafbdb9e095109c62682d", "filename": "src/test/run-pass/trait-default-method-xc-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc-2.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -3,8 +3,8 @@\n // aux-build:trait_default_method_xc_aux_2.rs\n \n \n-extern mod aux(name = \"trait_default_method_xc_aux\");\n-extern mod aux2(name = \"trait_default_method_xc_aux_2\");\n+extern mod aux = \"trait_default_method_xc_aux\";\n+extern mod aux2 = \"trait_default_method_xc_aux_2\";\n use aux::A;\n use aux2::{a_struct, welp};\n "}, {"sha": "9813864724c2bda3b0c8e7e90f5dcb0bf0fb11d2", "filename": "src/test/run-pass/trait-default-method-xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -4,7 +4,7 @@\n // aux-build:trait_default_method_xc_aux.rs\n \n \n-extern mod aux(name = \"trait_default_method_xc_aux\");\n+extern mod aux = \"trait_default_method_xc_aux\";\n use aux::{A, TestEquality, Something};\n use aux::B;\n "}, {"sha": "6793db96509a1a8310777e5f15eb5cc9c6badb76", "filename": "src/test/run-pass/trait-inheritance-auto-xc-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto-xc-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto-xc-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto-xc-2.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast\n // aux-build:trait_inheritance_auto_xc_2_aux.rs\n \n-extern mod aux(name = \"trait_inheritance_auto_xc_2_aux\");\n+extern mod aux = \"trait_inheritance_auto_xc_2_aux\";\n \n // aux defines impls of Foo, Bar and Baz for A\n use aux::{Foo, Bar, Baz, A};"}, {"sha": "d4f718608a968600379dd1fffe35a6c77b005d34", "filename": "src/test/run-pass/trait-inheritance-auto-xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto-xc.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast\n // aux-build:trait_inheritance_auto_xc_aux.rs\n \n-extern mod aux(name = \"trait_inheritance_auto_xc_aux\");\n+extern mod aux = \"trait_inheritance_auto_xc_aux\";\n \n use aux::{Foo, Bar, Baz, Quux};\n "}, {"sha": "0cdc1d0e27fec3f6142e0c1b122704395f8a744e", "filename": "src/test/run-pass/trait-inheritance-cross-trait-call-xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cross-trait-call-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cross-trait-call-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cross-trait-call-xc.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast\n // aux-build:trait_inheritance_cross_trait_call_xc_aux.rs\n \n-extern mod aux(name = \"trait_inheritance_cross_trait_call_xc_aux\");\n+extern mod aux = \"trait_inheritance_cross_trait_call_xc_aux\";\n \n use aux::Foo;\n "}, {"sha": "a500e167a8b5f8807988299a6de2f292a7549ec8", "filename": "src/test/run-pass/typeid-intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -12,8 +12,8 @@\n // aux-build:typeid-intrinsic.rs\n // aux-build:typeid-intrinsic2.rs\n \n-extern mod other1(name = \"typeid-intrinsic\");\n-extern mod other2(name = \"typeid-intrinsic2\");\n+extern mod other1 = \"typeid-intrinsic\";\n+extern mod other2 = \"typeid-intrinsic2\";\n \n use std::unstable::intrinsics;\n use std::unstable::intrinsics::TypeId;"}, {"sha": "d9f40e5f1f3d8c9a482b0c2c5e5920b82dbc938c", "filename": "src/test/run-pass/use-crate-name-alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fuse-crate-name-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fuse-crate-name-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuse-crate-name-alias.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n // Issue #1706\n-extern mod stdlib(name=\"extra\");\n+extern mod stdlib = \"extra\";\n \n pub fn main() {}"}, {"sha": "ddd4b10fd5c956b564bb83243f504a506d7e19a1", "filename": "src/test/run-pass/use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuse.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -14,8 +14,8 @@\n \n #[no_std];\n extern mod std;\n-extern mod zed(name = \"std\");\n-extern mod bar(name = \"std\", vers = \"0.9-pre\");\n+extern mod zed = \"std\";\n+extern mod bar = \"std#0.9-pre\";\n \n \n use std::str;"}, {"sha": "8a5a4a0cfe5175db82e5212eba51ff36d9d23cbe", "filename": "src/test/run-pass/xcrate-address-insignificant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fxcrate-address-insignificant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fxcrate-address-insignificant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fxcrate-address-insignificant.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast check-fast doesn't like aux-build\n // aux-build:xcrate_address_insignificant.rs\n \n-extern mod foo(name = \"xcrate_address_insignificant\");\n+extern mod foo = \"xcrate_address_insignificant\";\n \n fn main() {\n     assert_eq!(foo::foo::<f64>(), foo::bar());"}, {"sha": "941efdb24a8a6298aa9230d4665de6948326ffdb", "filename": "src/test/run-pass/xcrate-trait-lifetime-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fxcrate-trait-lifetime-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4dd9efee9248f4c3235460f3c93acc9932eb5a/src%2Ftest%2Frun-pass%2Fxcrate-trait-lifetime-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fxcrate-trait-lifetime-param.rs?ref=ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast\n // aux-build:xcrate-trait-lifetime-param.rs\n \n-extern mod other(name = \"xcrate-trait-lifetime-param\");\n+extern mod other = \"xcrate-trait-lifetime-param\";\n \n struct Reader<'a> {\n     b : &'a [u8]"}]}