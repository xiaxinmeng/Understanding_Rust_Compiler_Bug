{"sha": "b03bde9c2af8b004b5c8eba5a797b079190718c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwM2JkZTljMmFmOGIwMDRiNWM4ZWJhNWE3OTdiMDc5MTkwNzE4YzM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-24T22:45:25Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-24T22:45:25Z"}, "message": "trans: move the linker support to compute symbols on-demand.", "tree": {"sha": "a88be3d38a4795abf715eb37a2da697f851a8830", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a88be3d38a4795abf715eb37a2da697f851a8830"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b03bde9c2af8b004b5c8eba5a797b079190718c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b03bde9c2af8b004b5c8eba5a797b079190718c3", "html_url": "https://github.com/rust-lang/rust/commit/b03bde9c2af8b004b5c8eba5a797b079190718c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b03bde9c2af8b004b5c8eba5a797b079190718c3/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba", "html_url": "https://github.com/rust-lang/rust/commit/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba"}], "stats": {"total": 133, "additions": 88, "deletions": 45}, "files": [{"sha": "0a7c3b6fc8f499de14a44835e6e955e6538eb593", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b03bde9c2af8b004b5c8eba5a797b079190718c3/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03bde9c2af8b004b5c8eba5a797b079190718c3/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=b03bde9c2af8b004b5c8eba5a797b079190718c3", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use super::archive::{ArchiveBuilder, ArchiveConfig};\n-use super::linker::{Linker, GnuLinker, MsvcLinker};\n+use super::linker::Linker;\n use super::rpath::RPathConfig;\n use super::rpath;\n use super::msvc;\n@@ -637,13 +637,9 @@ fn link_natively(sess: &Session,\n     }\n \n     {\n-        let mut linker = if sess.target.target.options.is_like_msvc {\n-            Box::new(MsvcLinker { cmd: &mut cmd, sess: &sess }) as Box<Linker>\n-        } else {\n-            Box::new(GnuLinker { cmd: &mut cmd, sess: &sess }) as Box<Linker>\n-        };\n+        let mut linker = trans.linker_info.to_linker(&mut cmd, &sess);\n         link_args(&mut *linker, sess, crate_type, tmpdir,\n-                  objects, out_filename, trans, outputs);\n+                  objects, out_filename, outputs);\n         if !sess.target.target.options.no_compiler_rt {\n             linker.link_staticlib(\"compiler-rt\");\n         }\n@@ -712,7 +708,6 @@ fn link_args(cmd: &mut Linker,\n              tmpdir: &Path,\n              objects: &[PathBuf],\n              out_filename: &Path,\n-             trans: &CrateTranslation,\n              outputs: &OutputFilenames) {\n \n     // The default library location, we need this to find the runtime.\n@@ -731,7 +726,7 @@ fn link_args(cmd: &mut Linker,\n     // If we're building a dynamic library then some platforms need to make sure\n     // that all symbols are exported correctly from the dynamic library.\n     if crate_type != config::CrateTypeExecutable {\n-        cmd.export_symbols(sess, trans, tmpdir, crate_type);\n+        cmd.export_symbols(tmpdir, crate_type);\n     }\n \n     // When linking a dynamic library, we put the metadata into a section of the"}, {"sha": "cb990ead8e81e94ae0de9f5982d8817517e2e9d6", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 80, "deletions": 36, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/b03bde9c2af8b004b5c8eba5a797b079190718c3/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03bde9c2af8b004b5c8eba5a797b079190718c3/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=b03bde9c2af8b004b5c8eba5a797b079190718c3", "patch": "@@ -15,13 +15,50 @@ use std::io::prelude::*;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n+use context::SharedCrateContext;\n+use monomorphize::Instance;\n+\n use back::archive;\n use middle::dependency_format::Linkage;\n use session::Session;\n use session::config::CrateType;\n use session::config;\n use syntax::ast;\n-use CrateTranslation;\n+\n+/// For all the linkers we support, and information they might\n+/// need out of the shared crate context before we get rid of it.\n+pub struct LinkerInfo {\n+    dylib_exports: Vec<String>,\n+    cdylib_exports: Vec<String>\n+}\n+\n+impl<'a, 'tcx> LinkerInfo {\n+    pub fn new(scx: &SharedCrateContext<'a, 'tcx>,\n+               reachable: &[String]) -> LinkerInfo {\n+        LinkerInfo {\n+            dylib_exports: exported_symbols(scx, reachable, CrateType::CrateTypeDylib),\n+            cdylib_exports: exported_symbols(scx, reachable, CrateType::CrateTypeCdylib)\n+        }\n+    }\n+\n+    pub fn to_linker(&'a self,\n+                     cmd: &'a mut Command,\n+                     sess: &'a Session) -> Box<Linker+'a> {\n+        if sess.target.target.options.is_like_msvc {\n+            Box::new(MsvcLinker {\n+                cmd: cmd,\n+                sess: sess,\n+                info: self\n+            }) as Box<Linker>\n+        } else {\n+            Box::new(GnuLinker {\n+                cmd: cmd,\n+                sess: sess,\n+                info: self\n+            }) as Box<Linker>\n+        }\n+    }\n+}\n \n /// Linker abstraction used by back::link to build up the command to invoke a\n /// linker.\n@@ -53,16 +90,13 @@ pub trait Linker {\n     fn hint_dynamic(&mut self);\n     fn whole_archives(&mut self);\n     fn no_whole_archives(&mut self);\n-    fn export_symbols(&mut self,\n-                      sess: &Session,\n-                      trans: &CrateTranslation,\n-                      tmpdir: &Path,\n-                      crate_type: CrateType);\n+    fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType);\n }\n \n pub struct GnuLinker<'a> {\n-    pub cmd: &'a mut Command,\n-    pub sess: &'a Session,\n+    cmd: &'a mut Command,\n+    sess: &'a Session,\n+    info: &'a LinkerInfo\n }\n \n impl<'a> GnuLinker<'a> {\n@@ -201,11 +235,7 @@ impl<'a> Linker for GnuLinker<'a> {\n         self.cmd.arg(\"-Wl,-Bdynamic\");\n     }\n \n-    fn export_symbols(&mut self,\n-                      sess: &Session,\n-                      trans: &CrateTranslation,\n-                      tmpdir: &Path,\n-                      crate_type: CrateType) {\n+    fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType) {\n         // If we're compiling a dylib, then we let symbol visibility in object\n         // files to take care of whether they're exported or not.\n         //\n@@ -225,13 +255,13 @@ impl<'a> Linker for GnuLinker<'a> {\n         };\n         let res = (|| -> io::Result<()> {\n             let mut f = BufWriter::new(File::create(&path)?);\n-            for sym in exported_symbols(sess, trans, crate_type) {\n+            for sym in &self.info.cdylib_exports {\n                 writeln!(f, \"{}{}\", prefix, sym)?;\n             }\n             Ok(())\n         })();\n         if let Err(e) = res {\n-            sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n+            self.sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n         }\n         let mut arg = OsString::new();\n         if self.sess.target.target.options.is_like_osx {\n@@ -245,8 +275,9 @@ impl<'a> Linker for GnuLinker<'a> {\n }\n \n pub struct MsvcLinker<'a> {\n-    pub cmd: &'a mut Command,\n-    pub sess: &'a Session,\n+    cmd: &'a mut Command,\n+    sess: &'a Session,\n+    info: &'a LinkerInfo\n }\n \n impl<'a> Linker for MsvcLinker<'a> {\n@@ -366,8 +397,6 @@ impl<'a> Linker for MsvcLinker<'a> {\n     // in which case they may continue to transitively be used and hence need\n     // their symbols exported.\n     fn export_symbols(&mut self,\n-                      sess: &Session,\n-                      trans: &CrateTranslation,\n                       tmpdir: &Path,\n                       crate_type: CrateType) {\n         let path = tmpdir.join(\"lib.def\");\n@@ -378,26 +407,42 @@ impl<'a> Linker for MsvcLinker<'a> {\n             // straight to exports.\n             writeln!(f, \"LIBRARY\")?;\n             writeln!(f, \"EXPORTS\")?;\n-\n-            for sym in exported_symbols(sess, trans, crate_type) {\n-                writeln!(f, \"  {}\", sym)?;\n+            let symbols = if crate_type == CrateType::CrateTypeCdylib {\n+                &self.info.cdylib_exports\n+            } else {\n+                &self.info.dylib_exports\n+            };\n+            for symbol in symbols {\n+                writeln!(f, \"  {}\", symbol)?;\n             }\n-\n             Ok(())\n         })();\n         if let Err(e) = res {\n-            sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n+            self.sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n         }\n         let mut arg = OsString::from(\"/DEF:\");\n         arg.push(path);\n         self.cmd.arg(&arg);\n     }\n }\n \n-fn exported_symbols(sess: &Session,\n-                    trans: &CrateTranslation,\n-                    crate_type: CrateType) -> Vec<String> {\n-    let mut symbols = trans.reachable.iter().cloned().collect::<Vec<_>>();\n+fn exported_symbols(scx: &SharedCrateContext,\n+                    reachable: &[String],\n+                    crate_type: CrateType)\n+                    -> Vec<String> {\n+    if !scx.sess().crate_types.borrow().contains(&crate_type) {\n+        return vec![];\n+    }\n+\n+    // See explanation in GnuLinker::export_symbols, for\n+    // why we don't ever need dylib symbols on non-MSVC.\n+    if crate_type == CrateType::CrateTypeDylib {\n+        if !scx.sess().target.target.options.is_like_msvc {\n+            return vec![];\n+        }\n+    }\n+\n+    let mut symbols = reachable.to_vec();\n \n     // If we're producing anything other than a dylib then the `reachable` array\n     // above is the exhaustive set of symbols we should be exporting.\n@@ -409,20 +454,19 @@ fn exported_symbols(sess: &Session,\n         return symbols\n     }\n \n-    let cstore = &sess.cstore;\n-    let formats = sess.dependency_formats.borrow();\n-    let upstream_symbols = formats[&crate_type].iter();\n-    symbols.extend(upstream_symbols.enumerate().filter_map(|(i, f)| {\n+    let cstore = &scx.sess().cstore;\n+    let formats = scx.sess().dependency_formats.borrow();\n+    let deps = formats[&crate_type].iter();\n+    symbols.extend(deps.enumerate().filter_map(|(i, f)| {\n         if *f == Linkage::Static {\n             Some((i + 1) as ast::CrateNum)\n         } else {\n             None\n         }\n     }).flat_map(|cnum| {\n         cstore.reachable_ids(cnum)\n-    }).map(|did| {\n-        cstore.item_symbol(did)\n+    }).map(|did| -> String {\n+        Instance::mono(scx, did).symbol_name(scx)\n     }));\n-\n-    return symbols\n+    symbols\n }"}, {"sha": "84dd633a45265300f814bd32286f0a633b9d6d20", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b03bde9c2af8b004b5c8eba5a797b079190718c3/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03bde9c2af8b004b5c8eba5a797b079190718c3/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=b03bde9c2af8b004b5c8eba5a797b079190718c3", "patch": "@@ -31,6 +31,7 @@ use super::CrateTranslation;\n use super::ModuleTranslation;\n \n use back::link;\n+use back::linker::LinkerInfo;\n use lint;\n use llvm::{BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n use llvm;\n@@ -2828,13 +2829,15 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n \n+    let linker_info = LinkerInfo::new(&shared_ccx, &reachable_symbols);\n     CrateTranslation {\n         modules: modules,\n         metadata_module: metadata_module,\n         link: link_meta,\n         metadata: metadata,\n         reachable: reachable_symbols,\n         no_builtins: no_builtins,\n+        linker_info: linker_info\n     }\n }\n "}, {"sha": "0188a6d54de2dc88ea0e71515d5f850b6fb3d774", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b03bde9c2af8b004b5c8eba5a797b079190718c3/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03bde9c2af8b004b5c8eba5a797b079190718c3/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=b03bde9c2af8b004b5c8eba5a797b079190718c3", "patch": "@@ -145,6 +145,7 @@ pub struct CrateTranslation {\n     pub metadata: Vec<u8>,\n     pub reachable: Vec<String>,\n     pub no_builtins: bool,\n+    pub linker_info: back::linker::LinkerInfo\n }\n \n __build_diagnostic_array! { librustc_trans, DIAGNOSTICS }"}]}