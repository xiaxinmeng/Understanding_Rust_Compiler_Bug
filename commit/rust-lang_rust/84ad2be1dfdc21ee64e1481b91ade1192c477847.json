{"sha": "84ad2be1dfdc21ee64e1481b91ade1192c477847", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0YWQyYmUxZGZkYzIxZWU2NGUxNDgxYjkxYWRlMTE5MmM0Nzc4NDc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-11-22T16:28:13Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-11-22T16:28:13Z"}, "message": "Merge branch 'pr-462'\n\nConflicts:\n\tREADME.md", "tree": {"sha": "2f8cd8e9f105e6d7a5fdac86f55fed9f6c8aa5ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f8cd8e9f105e6d7a5fdac86f55fed9f6c8aa5ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84ad2be1dfdc21ee64e1481b91ade1192c477847", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84ad2be1dfdc21ee64e1481b91ade1192c477847", "html_url": "https://github.com/rust-lang/rust/commit/84ad2be1dfdc21ee64e1481b91ade1192c477847", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84ad2be1dfdc21ee64e1481b91ade1192c477847/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4cf288b385b9c58cfa0d4c97b3b548bc21b4923", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4cf288b385b9c58cfa0d4c97b3b548bc21b4923", "html_url": "https://github.com/rust-lang/rust/commit/d4cf288b385b9c58cfa0d4c97b3b548bc21b4923"}, {"sha": "a36707bffd41d5197cf7b081c7594b5663106586", "url": "https://api.github.com/repos/rust-lang/rust/commits/a36707bffd41d5197cf7b081c7594b5663106586", "html_url": "https://github.com/rust-lang/rust/commit/a36707bffd41d5197cf7b081c7594b5663106586"}], "stats": {"total": 94, "additions": 89, "deletions": 5}, "files": [{"sha": "ae19f6ff9d7ad3ec4fa78ec6b553739a9d86c4dd", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84ad2be1dfdc21ee64e1481b91ade1192c477847/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/84ad2be1dfdc21ee64e1481b91ade1192c477847/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=84ad2be1dfdc21ee64e1481b91ade1192c477847", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 76 lints included in this crate:\n+There are 77 lints included in this crate:\n \n name                                                                                                     | default | meaning\n ---------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -52,6 +52,7 @@ name\n [no_effect](https://github.com/Manishearth/rust-clippy/wiki#no_effect)                                   | warn    | statements with no effect\n [non_ascii_literal](https://github.com/Manishearth/rust-clippy/wiki#non_ascii_literal)                   | allow   | using any literal non-ASCII chars in a string literal; suggests using the \\\\u escape instead\n [nonsensical_open_options](https://github.com/Manishearth/rust-clippy/wiki#nonsensical_open_options)     | warn    | nonsensical combination of options for opening a file\n+[ok_expect](https://github.com/Manishearth/rust-clippy/wiki#ok_expect)                                   | warn    | using `ok().expect()`, which gives worse error messages than calling `expect` directly on the Result\n [option_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#option_unwrap_used)                 | allow   | using `Option.unwrap()`, which should at least get a better message using `expect()`\n [precedence](https://github.com/Manishearth/rust-clippy/wiki#precedence)                                 | warn    | catches operations where precedence may be unclear. See the wiki for a list of cases caught\n [ptr_arg](https://github.com/Manishearth/rust-clippy/wiki#ptr_arg)                                       | warn    | fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively"}, {"sha": "3664803d02238797ccb6389149c8d9a43bd43caa", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84ad2be1dfdc21ee64e1481b91ade1192c477847/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ad2be1dfdc21ee64e1481b91ade1192c477847/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=84ad2be1dfdc21ee64e1481b91ade1192c477847", "patch": "@@ -155,6 +155,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         matches::MATCH_BOOL,\n         matches::MATCH_REF_PATS,\n         matches::SINGLE_MATCH,\n+        methods::OK_EXPECT,\n         methods::SHOULD_IMPLEMENT_TRAIT,\n         methods::STR_TO_STRING,\n         methods::STRING_TO_STRING,"}, {"sha": "b8c6402544d696d28d8526b8675757ac5ec9b27d", "filename": "src/methods.rs", "status": "modified", "additions": 61, "deletions": 4, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/84ad2be1dfdc21ee64e1481b91ade1192c477847/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ad2be1dfdc21ee64e1481b91ade1192c477847/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=84ad2be1dfdc21ee64e1481b91ade1192c477847", "patch": "@@ -1,17 +1,18 @@\n use rustc_front::hir::*;\n use rustc::lint::*;\n use rustc::middle::ty;\n-use rustc::middle::subst::Subst;\n+use rustc::middle::subst::{Subst, TypeSpace};\n use std::iter;\n use std::borrow::Cow;\n \n-use utils::{snippet, span_lint, match_path, match_type, walk_ptrs_ty_depth};\n+use utils::{snippet, span_lint, match_path, match_type, walk_ptrs_ty_depth,\n+    walk_ptrs_ty};\n use utils::{OPTION_PATH, RESULT_PATH, STRING_PATH};\n \n use self::SelfKind::*;\n use self::OutType::*;\n \n-#[derive(Copy,Clone)]\n+#[derive(Clone)]\n pub struct MethodsPass;\n \n declare_lint!(pub OPTION_UNWRAP_USED, Allow,\n@@ -30,16 +31,21 @@ declare_lint!(pub WRONG_SELF_CONVENTION, Warn,\n declare_lint!(pub WRONG_PUB_SELF_CONVENTION, Allow,\n               \"defining a public method named with an established prefix (like \\\"into_\\\") that takes \\\n                `self` with the wrong convention\");\n+declare_lint!(pub OK_EXPECT, Warn,\n+              \"using `ok().expect()`, which gives worse error messages than \\\n+               calling `expect` directly on the Result\");\n+\n \n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(OPTION_UNWRAP_USED, RESULT_UNWRAP_USED, STR_TO_STRING, STRING_TO_STRING,\n-                    SHOULD_IMPLEMENT_TRAIT, WRONG_SELF_CONVENTION)\n+                    SHOULD_IMPLEMENT_TRAIT, WRONG_SELF_CONVENTION, OK_EXPECT)\n     }\n }\n \n impl LateLintPass for MethodsPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+\n         if let ExprMethodCall(ref name, _, ref args) = expr.node {\n             let (obj_ty, ptr_depth) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&args[0]));\n             if name.node.as_str() == \"unwrap\" {\n@@ -70,6 +76,22 @@ impl LateLintPass for MethodsPass {\n                                                                 `clone()` to make a copy\");\n                 }\n             }\n+            else if name.node.as_str() == \"expect\" {\n+                if let ExprMethodCall(ref inner_name, _, ref inner_args) = args[0].node {\n+                    if inner_name.node.as_str() == \"ok\"\n+                            && match_type(cx, cx.tcx.expr_ty(&inner_args[0]), &RESULT_PATH) {\n+                        let result_type = cx.tcx.expr_ty(&inner_args[0]);\n+                        if let Some(error_type) = get_error_type(cx, result_type) {\n+                            if has_debug_impl(error_type, cx) {\n+                                span_lint(cx, OK_EXPECT, expr.span,\n+                                         \"called `ok().expect()` on a Result \\\n+                                          value. You can call `expect` directly\n+                                          on the `Result`\");\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n         }\n     }\n \n@@ -115,6 +137,41 @@ impl LateLintPass for MethodsPass {\n     }\n }\n \n+// Given a `Result<T, E>` type, return its error type (`E`)\n+fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n+    if !match_type(cx, ty, &RESULT_PATH) {\n+        return None;\n+    }\n+    if let ty::TyEnum(_, substs) = ty.sty {\n+        if let Some(err_ty) = substs.types.opt_get(TypeSpace, 1) {\n+            return Some(err_ty);\n+        }\n+    }\n+    None\n+}\n+\n+// This checks whether a given type is known to implement Debug. It's\n+// conservative, i.e. it should not return false positives, but will return\n+// false negatives.\n+fn has_debug_impl<'a, 'b>(ty: ty::Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n+    let no_ref_ty = walk_ptrs_ty(ty);\n+    let debug = match cx.tcx.lang_items.debug_trait() {\n+        Some(debug) => debug,\n+        None => return false\n+    };\n+    let debug_def = cx.tcx.lookup_trait_def(debug);\n+    let mut debug_impl_exists = false;\n+    debug_def.for_each_relevant_impl(cx.tcx, no_ref_ty, |d| {\n+        let self_ty = &cx.tcx.impl_trait_ref(d).and_then(|im| im.substs.self_ty());\n+        if let Some(self_ty) = *self_ty {\n+            if !self_ty.flags.get().contains(ty::TypeFlags::HAS_PARAMS) {\n+                debug_impl_exists = true;\n+            }\n+        }\n+    });\n+    debug_impl_exists\n+}\n+\n const CONVENTIONS: [(&'static str, &'static [SelfKind]); 5] = [\n     (\"into_\", &[ValueSelf]),\n     (\"to_\",   &[RefSelf]),"}, {"sha": "6d543596cf5c4e5136ddf8d234f99c68cadcd0db", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/84ad2be1dfdc21ee64e1481b91ade1192c477847/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ad2be1dfdc21ee64e1481b91ade1192c477847/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=84ad2be1dfdc21ee64e1481b91ade1192c477847", "patch": "@@ -35,6 +35,8 @@ impl Mul<T> for T {\n }\n \n fn main() {\n+    use std::io;\n+\n     let opt = Some(0);\n     let _ = opt.unwrap();  //~ERROR used unwrap() on an Option\n \n@@ -46,4 +48,27 @@ fn main() {\n     let v = &\"str\";\n     let string = v.to_string();  //~ERROR `(*v).to_owned()` is faster\n     let _again = string.to_string();  //~ERROR `String.to_string()` is a no-op\n+\n+    res.ok().expect(\"disaster!\"); //~ERROR called `ok().expect()`\n+    // the following should not warn, since `expect` isn't implemented unless\n+    // the error type implements `Debug`\n+    let res2: Result<i32, MyError> = Ok(0);\n+    res2.ok().expect(\"oh noes!\");\n+    // we currently don't warn if the error type has a type parameter\n+    // (but it would be nice if we did)\n+    let res3: Result<u32, MyErrorWithParam<u8>>= Ok(0);\n+    res3.ok().expect(\"whoof\");\n+    let res4: Result<u32, io::Error> = Ok(0);\n+    res4.ok().expect(\"argh\"); //~ERROR called `ok().expect()`\n+    let res5: io::Result<u32> = Ok(0);\n+    res5.ok().expect(\"oops\"); //~ERROR called `ok().expect()`\n+    let res6: Result<u32, &str> = Ok(0);\n+    res6.ok().expect(\"meh\"); //~ERROR called `ok().expect()`\n+}\n+\n+struct MyError(()); // doesn't implement Debug\n+\n+#[derive(Debug)]\n+struct MyErrorWithParam<T> {\n+    x: T\n }"}]}