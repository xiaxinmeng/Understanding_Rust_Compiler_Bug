{"sha": "0b4ede39e50aab5f8f262ddd5a821ae699cbd179", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNGVkZTM5ZTUwYWFiNWY4ZjI2MmRkZDVhODIxYWU2OTljYmQxNzk=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-12-22T16:42:38Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-12-22T17:21:30Z"}, "message": "Add pretty param and local info comments to clif", "tree": {"sha": "d46f8bc6b14b22bffbf30decd587a43a0afdac59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d46f8bc6b14b22bffbf30decd587a43a0afdac59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b4ede39e50aab5f8f262ddd5a821ae699cbd179", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b4ede39e50aab5f8f262ddd5a821ae699cbd179", "html_url": "https://github.com/rust-lang/rust/commit/0b4ede39e50aab5f8f262ddd5a821ae699cbd179", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b4ede39e50aab5f8f262ddd5a821ae699cbd179/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "988257649752a4b41a819ca415df363893f300be", "url": "https://api.github.com/repos/rust-lang/rust/commits/988257649752a4b41a819ca415df363893f300be", "html_url": "https://github.com/rust-lang/rust/commit/988257649752a4b41a819ca415df363893f300be"}], "stats": {"total": 105, "additions": 77, "deletions": 28}, "files": [{"sha": "220554550f1794794815833181031bd36796682d", "filename": "example/example.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0b4ede39e50aab5f8f262ddd5a821ae699cbd179/example%2Fexample.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4ede39e50aab5f8f262ddd5a821ae699cbd179/example%2Fexample.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fexample.rs?ref=0b4ede39e50aab5f8f262ddd5a821ae699cbd179", "patch": "@@ -18,7 +18,6 @@ fn bcd(b: bool, a: u8) -> u8 {\n     }\n }\n \n-// FIXME make calls work\n fn call() {\n     abc(42);\n }\n@@ -33,14 +32,12 @@ enum BoolOption {\n     None,\n }\n \n-/*\n fn option_unwrap_or(o: BoolOption, d: bool) -> bool {\n     match o {\n         BoolOption::Some(b) => b,\n         BoolOption::None => d,\n     }\n }\n-*/\n \n fn ret_42() -> u8 {\n     42\n@@ -62,18 +59,18 @@ fn cmp_raw_ptr(a: *const u8, b: *const u8) -> bool {\n     a == b\n }\n \n-/*fn int_cast(a: u16, b: i16) -> (u8, u16, u32, usize, i8, i16, i32, isize, u8, u32) {\n+fn int_cast(a: u16, b: i16) -> (u8, u16, u32, usize, i8, i16, i32, isize, u8, u32) {\n     (\n         a as u8, a as u16, a as u32, a as usize, a as i8, a as i16, a as i32, a as isize, b as u8,\n         b as u32,\n     )\n-}*/\n+}\n \n fn char_cast(c: char) -> u8 {\n     c as u8\n }\n \n-struct DebugTuple(());\n+pub struct DebugTuple(());\n \n fn debug_tuple() -> DebugTuple {\n     DebugTuple(())\n@@ -87,47 +84,51 @@ fn use_size_of() -> usize {\n     size_of::<u64>()\n }\n \n-/*unsafe fn use_copy_intrinsic(src: *const u8, dst: *mut u8) {\n+unsafe fn use_copy_intrinsic(src: *const u8, dst: *mut u8) {\n     intrinsics::copy::<u8>(src, dst, 1);\n-}*/\n+}\n \n-/*unsafe fn use_copy_intrinsic_ref(src: *const u8, dst: *mut u8) {\n-    let copy2 = &copy::<u8>;\n+unsafe fn use_copy_intrinsic_ref(src: *const u8, dst: *mut u8) {\n+    let copy2 = &intrinsics::copy::<u8>;\n     copy2(src, dst, 1);\n-}*/\n+}\n \n const Abc: u8 = 6 * 7;\n \n fn use_const() -> u8 {\n     Abc\n }\n \n-fn call_closure_3arg() {\n+pub fn call_closure_3arg() {\n     (|_, _, _| {})(0u8, 42u16, 0u8)\n }\n \n-fn call_closure_2arg() {\n+pub fn call_closure_2arg() {\n     (|_, _| {})(0u8, 42u16)\n }\n \n struct IsNotEmpty;\n \n impl<'a, 'b> FnOnce<(&'a &'b [u16],)> for IsNotEmpty {\n-    type Output = bool;\n+    type Output = (u8, u8);\n \n     #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&'a &'b [u16],)) -> bool {\n+    extern \"rust-call\" fn call_once(mut self, arg: (&'a &'b [u16],)) -> (u8, u8) {\n         self.call_mut(arg)\n     }\n }\n \n impl<'a, 'b> FnMut<(&'a &'b [u16],)> for IsNotEmpty {\n     #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a &'b [u16],)) -> bool {\n-        true\n+    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a &'b [u16],)) -> (u8, u8) {\n+        (0, 42)\n     }\n }\n \n+pub fn call_is_not_empty() {\n+    IsNotEmpty.call_once((&(&[0u16] as &[_]),));\n+}\n+\n fn eq_char(a: char, b: char) -> bool {\n     a == b\n }\n@@ -140,7 +141,6 @@ unsafe fn call_uninit() -> u8 {\n     intrinsics::uninit()\n }\n \n-// TODO: enable when fat pointers are supported\n unsafe fn deref_str_ptr(s: *const str) -> &'static str {\n     &*s\n }\n@@ -157,9 +157,9 @@ fn array_as_slice(arr: &[u8; 3]) -> &[u8] {\n     arr\n }\n \n-/*unsafe fn use_ctlz_nonzero(a: u16) -> u16 {\n+unsafe fn use_ctlz_nonzero(a: u16) -> u16 {\n     intrinsics::ctlz_nonzero(a)\n-}*/\n+}\n \n fn ptr_as_usize(ptr: *const u8) -> usize {\n     ptr as usize\n@@ -169,9 +169,9 @@ fn float_cast(a: f32, b: f64) -> (f64, f32) {\n     (a as f64, b as f32)\n }\n \n-/*fn int_to_float(a: u8, b: i32) -> (f64, f32) {\n+fn int_to_float(a: u8, b: i32) -> (f64, f32) {\n     (a as f64, b as f32)\n-}*/\n+}\n \n fn make_array() -> [u8; 3] {\n     [42, 0, 5]"}, {"sha": "ae4eb7b1c98793bebaabbf34e629dbdfb54fe320", "filename": "src/abi.rs", "status": "modified", "additions": 55, "deletions": 6, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0b4ede39e50aab5f8f262ddd5a821ae699cbd179/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4ede39e50aab5f8f262ddd5a821ae699cbd179/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=0b4ede39e50aab5f8f262ddd5a821ae699cbd179", "patch": "@@ -1,3 +1,4 @@\n+use std::borrow::Cow;\n use std::iter;\n \n use rustc::hir;\n@@ -270,6 +271,41 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n     }\n }\n \n+fn add_local_comment<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    msg: &str,\n+    local: mir::Local,\n+    local_field: Option<usize>,\n+    param: Option<Value>,\n+    pass_mode: Option<PassMode>,\n+    ssa: crate::analyze::Flags,\n+    ty: Ty<'tcx>,\n+) {\n+    let local_field = if let Some(local_field) = local_field {\n+        Cow::Owned(format!(\".{}\", local_field))\n+    } else {\n+        Cow::Borrowed(\"\")\n+    };\n+    let param = if let Some(param) = param {\n+        Cow::Owned(format!(\"= {:?}\", param))\n+    } else {\n+        Cow::Borrowed(\"-\")\n+    };\n+    let pass_mode = if let Some(pass_mode) = pass_mode {\n+        Cow::Owned(format!(\"{:?}\", pass_mode))\n+    } else {\n+        Cow::Borrowed(\"-\")\n+    };\n+    fx.add_global_comment(format!(\n+        \"{msg:5} {local:>3}{local_field:<5} {param:10} {pass_mode:20} {ssa:10} {ty:?}\",\n+        msg=msg, local=format!(\"{:?}\", local), local_field=local_field, param=param, pass_mode=pass_mode, ssa=format!(\"{:?}\", ssa), ty=ty,\n+    ));\n+}\n+\n+fn add_local_header_comment(fx: &mut FunctionCx<impl Backend>) {\n+    fx.add_global_comment(format!(\"msg   loc.idx    param    pass mode            ssa flags  ty\"));\n+}\n+\n pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     start_ebb: Ebb,\n@@ -331,12 +367,6 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n \n     fx.add_global_comment(format!(\"ssa {:?}\", ssa_analyzed));\n \n-    for local in fx.mir.args_iter() {\n-        let arg_ty = fx.monomorphize(&fx.mir.local_decls[local].ty);\n-        let pass_mode = get_pass_mode(fx.tcx, fx.self_sig().abi, arg_ty, false);\n-        fx.add_global_comment(format!(\"pass {:?}: {:?} {:?}\", local, arg_ty, pass_mode));\n-    }\n-\n     match output_pass_mode {\n         PassMode::NoPass => {\n             let null = fx.bcx.ins().iconst(fx.pointer_type, 0);\n@@ -359,9 +389,26 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n         }\n     }\n \n+    add_local_header_comment(fx);\n+    add_local_comment(fx, \"ret\", RETURN_PLACE, None, ret_param, Some(output_pass_mode), ssa_analyzed[&RETURN_PLACE], ret_layout.ty);\n+\n     for (local, arg_kind, ty) in func_params {\n         let layout = fx.layout_of(ty);\n \n+        match arg_kind {\n+            ArgKind::Normal(ebb_param) => {\n+                let pass_mode = get_pass_mode(fx.tcx, fx.self_sig().abi, ty, false);\n+                add_local_comment(fx, \"arg\", local, None, Some(ebb_param), Some(pass_mode), ssa_analyzed[&local], ty);\n+            }\n+            ArgKind::Spread(ref ebb_params) => {\n+                for (i, &ebb_param) in ebb_params.iter().enumerate() {\n+                    let sub_layout = layout.field(fx, i);\n+                    let pass_mode = get_pass_mode(fx.tcx, fx.self_sig().abi, sub_layout.ty, false);\n+                    add_local_comment(fx, \"arg\", local, Some(i), Some(ebb_param), Some(pass_mode), ssa_analyzed[&local], sub_layout.ty);\n+                }\n+            }\n+        }\n+\n         if let ArgKind::Normal(ebb_param) = arg_kind {\n             if !ssa_analyzed\n                 .get(&local)\n@@ -422,6 +469,8 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n         let ty = fx.mir.local_decls[local].ty;\n         let layout = fx.layout_of(ty);\n \n+        add_local_comment(fx, \"local\", local, None, None, None, ssa_analyzed[&local], ty);\n+\n         let place = if ssa_analyzed\n             .get(&local)\n             .unwrap()"}]}