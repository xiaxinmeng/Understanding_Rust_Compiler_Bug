{"sha": "d14dd9f763c9d0126cb40fd816eb25b4a1b1e8c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxNGRkOWY3NjNjOWQwMTI2Y2I0MGZkODE2ZWIyNWI0YTFiMWU4YzQ=", "commit": {"author": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2021-05-16T10:34:42Z"}, "committer": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2021-05-25T16:39:50Z"}, "message": "emit diagnostic after post-monomorphization errors\n\nEmit a diagnostic when the monomorphized item collector\nencounters errors during a step of the recursive item collection.\n\nThese post-monomorphization errors otherwise only show the\nerroneous expression without a trace, making them very obscure\nand hard to pinpoint whenever they happen in dependencies.", "tree": {"sha": "c325486b5d9c69ac4a9f3c8f7a251ddabdd21394", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c325486b5d9c69ac4a9f3c8f7a251ddabdd21394"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d14dd9f763c9d0126cb40fd816eb25b4a1b1e8c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d14dd9f763c9d0126cb40fd816eb25b4a1b1e8c4", "html_url": "https://github.com/rust-lang/rust/commit/d14dd9f763c9d0126cb40fd816eb25b4a1b1e8c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d14dd9f763c9d0126cb40fd816eb25b4a1b1e8c4/comments", "author": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68424e2f01ef6884af440114f7cf2ed01faf86e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/68424e2f01ef6884af440114f7cf2ed01faf86e3", "html_url": "https://github.com/rust-lang/rust/commit/68424e2f01ef6884af440114f7cf2ed01faf86e3"}], "stats": {"total": 55, "additions": 53, "deletions": 2}, "files": [{"sha": "0109580a0bba90062c773206f1b31e4f703686cb", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d14dd9f763c9d0126cb40fd816eb25b4a1b1e8c4/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d14dd9f763c9d0126cb40fd816eb25b4a1b1e8c4/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=d14dd9f763c9d0126cb40fd816eb25b4a1b1e8c4", "patch": "@@ -186,6 +186,15 @@ impl<'tcx> MonoItem<'tcx> {\n     pub fn codegen_dep_node(&self, tcx: TyCtxt<'tcx>) -> DepNode {\n         crate::dep_graph::make_compile_mono_item(tcx, self)\n     }\n+\n+    /// Returns the item's `CrateNum`\n+    pub fn krate(&self) -> CrateNum {\n+        match self {\n+            MonoItem::Fn(ref instance) => instance.def_id().krate,\n+            MonoItem::Static(def_id) => def_id.krate,\n+            MonoItem::GlobalAsm(..) => LOCAL_CRATE,\n+        }\n+    }\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for MonoItem<'tcx> {"}, {"sha": "afe4457bf433d5f772ea7708dfcccedeeb2e265a", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d14dd9f763c9d0126cb40fd816eb25b4a1b1e8c4/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d14dd9f763c9d0126cb40fd816eb25b4a1b1e8c4/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=d14dd9f763c9d0126cb40fd816eb25b4a1b1e8c4", "patch": "@@ -184,7 +184,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{par_iter, MTLock, MTRef, ParallelIterator};\n use rustc_errors::{ErrorReported, FatalError};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n+use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::bit_set::GrowableBitSet;\n@@ -342,7 +342,8 @@ fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<\n         .collect()\n }\n \n-// Collect all monomorphized items reachable from `starting_point`\n+/// Collect all monomorphized items reachable from `starting_point`, and emit a note diagnostic if a\n+/// post-monorphization error is encountered during a collection step.\n fn collect_items_rec<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     starting_point: Spanned<MonoItem<'tcx>>,\n@@ -359,6 +360,31 @@ fn collect_items_rec<'tcx>(\n     let mut neighbors = Vec::new();\n     let recursion_depth_reset;\n \n+    //\n+    // Post-monomorphization errors MVP\n+    //\n+    // We can encounter errors while monomorphizing an item, but we don't have a good way of\n+    // showing a complete stack of spans ultimately leading to collecting the erroneous one yet.\n+    // (It's also currently unclear exactly which diagnostics and information would be interesting\n+    // to report in such cases)\n+    //\n+    // This leads to suboptimal error reporting: a post-monomorphization error (PME) will be\n+    // shown with just a spanned piece of code causing the error, without information on where\n+    // it was called from. This is especially obscure if the erroneous mono item is in a\n+    // dependency. See for example issue #85155, where, before minimization, a PME happened two\n+    // crates downstream from libcore's stdarch, without a way to know which dependency was the\n+    // cause.\n+    //\n+    // If such an error occurs in the current crate, its span will be enough to locate the\n+    // source. If the cause is in another crate, the goal here is to quickly locate which mono\n+    // item in the current crate is ultimately responsible for causing the error.\n+    //\n+    // To give at least _some_ context to the user: while collecting mono items, we check the\n+    // error count. If it has changed, a PME occurred, and we trigger some diagnostics about the\n+    // current step of mono items collection.\n+    //\n+    let error_count = tcx.sess.diagnostic().err_count();\n+\n     match starting_point.node {\n         MonoItem::Static(def_id) => {\n             let instance = Instance::mono(tcx, def_id);\n@@ -411,6 +437,22 @@ fn collect_items_rec<'tcx>(\n         }\n     }\n \n+    // Check for PMEs and emit a diagnostic if one happened. To try to show relevant edges of the\n+    // mono item graph where the PME diagnostics are currently the most problematic (e.g. ones\n+    // involving a dependency, and the lack of context is confusing) in this MVP, we focus on\n+    // diagnostics on edges crossing a crate boundary: the collected mono items which are not\n+    // defined in the local crate.\n+    if tcx.sess.diagnostic().err_count() > error_count && starting_point.node.krate() != LOCAL_CRATE\n+    {\n+        tcx.sess.span_note_without_error(\n+            starting_point.span,\n+            &format!(\n+                \"the above error was encountered while instantiating `{}`\",\n+                starting_point.node\n+            ),\n+        );\n+    }\n+\n     record_accesses(tcx, starting_point.node, neighbors.iter().map(|i| &i.node), inlining_map);\n \n     for neighbour in neighbors {"}]}