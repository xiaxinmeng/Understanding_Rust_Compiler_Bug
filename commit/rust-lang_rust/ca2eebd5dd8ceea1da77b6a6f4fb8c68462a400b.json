{"sha": "ca2eebd5dd8ceea1da77b6a6f4fb8c68462a400b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhMmVlYmQ1ZGQ4Y2VlYTFkYTc3YjZhNmY0ZmI4YzY4NDYyYTQwMGI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-30T04:03:21Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-30T04:03:21Z"}, "message": "core::rt: Add some notes about optimizations", "tree": {"sha": "ce0525da63ffaaad34f754109c477746ab68dddb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce0525da63ffaaad34f754109c477746ab68dddb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca2eebd5dd8ceea1da77b6a6f4fb8c68462a400b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca2eebd5dd8ceea1da77b6a6f4fb8c68462a400b", "html_url": "https://github.com/rust-lang/rust/commit/ca2eebd5dd8ceea1da77b6a6f4fb8c68462a400b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca2eebd5dd8ceea1da77b6a6f4fb8c68462a400b/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4ed554ddbd2dacfaa5dcc1dda99a3121f8cf2a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4ed554ddbd2dacfaa5dcc1dda99a3121f8cf2a4", "html_url": "https://github.com/rust-lang/rust/commit/f4ed554ddbd2dacfaa5dcc1dda99a3121f8cf2a4"}], "stats": {"total": 14, "additions": 14, "deletions": 0}, "files": [{"sha": "75b5306644116d04bb1396aed03b1bc9ba332769", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ca2eebd5dd8ceea1da77b6a6f4fb8c68462a400b/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca2eebd5dd8ceea1da77b6a6f4fb8c68462a400b/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=ca2eebd5dd8ceea1da77b6a6f4fb8c68462a400b", "patch": "@@ -29,6 +29,9 @@ use rt::rtio::{IoFactoryObject, RemoteCallback};\n /// on a single thread. When the scheduler is running it is owned by\n /// thread local storage and the running task is owned by the\n /// scheduler.\n+///\n+/// XXX: This creates too many callbacks to run_sched_once, resulting\n+/// in too much allocation and too many events.\n pub struct Scheduler {\n     /// A queue of available work. Under a work-stealing policy there\n     /// is one per Scheduler.\n@@ -143,6 +146,10 @@ pub impl Scheduler {\n \n     fn run_sched_once() {\n \n+        // First, check the message queue for instructions.\n+        // XXX: perf. Check for messages without atomics.\n+        // It's ok if we miss messages occasionally, as long as\n+        // we sync and check again before sleeping.\n         let sched = Local::take::<Scheduler>();\n         if sched.interpret_message_queue() {\n             // We performed a scheduling action. There may be other work\n@@ -153,6 +160,7 @@ pub impl Scheduler {\n             return;\n         }\n \n+        // Now, look in the work queue for tasks to run\n         let sched = Local::take::<Scheduler>();\n         if sched.resume_task_from_queue() {\n             // We performed a scheduling action. There may be other work\n@@ -198,6 +206,12 @@ pub impl Scheduler {\n         self.event_loop.callback(Scheduler::run_sched_once);\n \n         // We've made work available. Notify a sleeping scheduler.\n+        // XXX: perf. Check for a sleeper without synchronizing memory.\n+        // It's not critical that we always find it.\n+        // XXX: perf. If there's a sleeper then we might as well just send\n+        // it the task directly instead of pushing it to the\n+        // queue. That is essentially the intent here and it is less\n+        // work.\n         match self.sleeper_list.pop() {\n             Some(handle) => {\n                 let mut handle = handle;"}]}