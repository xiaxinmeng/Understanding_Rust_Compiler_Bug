{"sha": "00ce7ae5248b41d5944abe6075407236cde1b075", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwY2U3YWU1MjQ4YjQxZDU5NDRhYmU2MDc1NDA3MjM2Y2RlMWIwNzU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-02T11:25:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-02T11:25:40Z"}, "message": "Merge #8285\n\n8285: Don't recheck obligations if we have learned nothing new r=matklad a=flodiebold\n\nThis is just the most trivial check: If no inference variables have been updated, and there are no new obligations, we can just skip trying to solve them again. We could be smarter about it, but this already helps quite a bit, and I don't want to touch this too much before we replace the inference table by Chalk's.\r\n\r\nFixes #8263 (well, improves it quite a bit).\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "a7d300232f331eb2d4e854e884c8d8c0d60404c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7d300232f331eb2d4e854e884c8d8c0d60404c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00ce7ae5248b41d5944abe6075407236cde1b075", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgZv80CRBK7hj4Ov3rIwAAdHIIAIkhb9RFU7kvi+xERmHsDQxD\nK+ooiB4jMB9G3si95ALUe+1utwMjNb8yA+DWPRMnKNZEqC07yIzel2LvIjj/9RkZ\nvDVIPVrpq71qN4w9ekoQg88lK2miwv356Ddcmc8IOPmhK9YLhzPX7WyyBL1eeAEa\nk5gYTs2YRxEn2vqHRtzBKPn25EZt6LeXiKFvSZiBW/kUdyAQcHmM4ce3Nh8kMIiY\nsU/hwSCi5Dg/dq4v8FInc9Cx6o5JdLYnRtO9baF7KMhSL8zq+PTlhpk54sDOQ+3U\nk/4PCJkpCYwR/cVttBSHTBuYljS7o/vO8HLs5WunEvuq8L53VdsiBMnPojVHCn0=\n=DHEy\n-----END PGP SIGNATURE-----\n", "payload": "tree a7d300232f331eb2d4e854e884c8d8c0d60404c6\nparent a0b3eb7135361315ed953613a1a8c7a038b1562d\nparent 0e8c4503bf4754f4437d8bd45a110b9d0ec671e0\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1617362740 +0000\ncommitter GitHub <noreply@github.com> 1617362740 +0000\n\nMerge #8285\n\n8285: Don't recheck obligations if we have learned nothing new r=matklad a=flodiebold\n\nThis is just the most trivial check: If no inference variables have been updated, and there are no new obligations, we can just skip trying to solve them again. We could be smarter about it, but this already helps quite a bit, and I don't want to touch this too much before we replace the inference table by Chalk's.\r\n\r\nFixes #8263 (well, improves it quite a bit).\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00ce7ae5248b41d5944abe6075407236cde1b075", "html_url": "https://github.com/rust-lang/rust/commit/00ce7ae5248b41d5944abe6075407236cde1b075", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00ce7ae5248b41d5944abe6075407236cde1b075/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0b3eb7135361315ed953613a1a8c7a038b1562d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0b3eb7135361315ed953613a1a8c7a038b1562d", "html_url": "https://github.com/rust-lang/rust/commit/a0b3eb7135361315ed953613a1a8c7a038b1562d"}, {"sha": "0e8c4503bf4754f4437d8bd45a110b9d0ec671e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e8c4503bf4754f4437d8bd45a110b9d0ec671e0", "html_url": "https://github.com/rust-lang/rust/commit/0e8c4503bf4754f4437d8bd45a110b9d0ec671e0"}], "stats": {"total": 34, "additions": 26, "deletions": 8}, "files": [{"sha": "497a1beb7dc795082555a253eb9aeb917c75186b", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/00ce7ae5248b41d5944abe6075407236cde1b075/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ce7ae5248b41d5944abe6075407236cde1b075/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=00ce7ae5248b41d5944abe6075407236cde1b075", "patch": "@@ -210,6 +210,7 @@ struct InferenceContext<'a> {\n     table: unify::InferenceTable,\n     trait_env: Arc<TraitEnvironment>,\n     obligations: Vec<DomainGoal>,\n+    last_obligations_check: Option<u32>,\n     result: InferenceResult,\n     /// The return type of the function being inferred, or the closure if we're\n     /// currently within one.\n@@ -245,6 +246,7 @@ impl<'a> InferenceContext<'a> {\n             result: InferenceResult::default(),\n             table: unify::InferenceTable::new(),\n             obligations: Vec::default(),\n+            last_obligations_check: None,\n             return_ty: TyKind::Unknown.intern(&Interner), // set in collect_fn_signature\n             trait_env: owner\n                 .as_generic_def_id()\n@@ -334,6 +336,11 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn resolve_obligations_as_possible(&mut self) {\n+        if self.last_obligations_check == Some(self.table.revision) {\n+            // no change\n+            return;\n+        }\n+        self.last_obligations_check = Some(self.table.revision);\n         let obligations = mem::replace(&mut self.obligations, Vec::new());\n         for obligation in obligations {\n             let in_env = InEnvironment::new(self.trait_env.env.clone(), obligation.clone());\n@@ -360,6 +367,11 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n+    fn push_obligation(&mut self, o: DomainGoal) {\n+        self.obligations.push(o);\n+        self.last_obligations_check = None;\n+    }\n+\n     fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n         self.table.unify(ty1, ty2)\n     }\n@@ -408,8 +420,8 @@ impl<'a> InferenceContext<'a> {\n                     }),\n                     ty: ty.clone(),\n                 };\n-                self.obligations.push(trait_ref.cast(&Interner));\n-                self.obligations.push(alias_eq.cast(&Interner));\n+                self.push_obligation(trait_ref.cast(&Interner));\n+                self.push_obligation(alias_eq.cast(&Interner));\n                 self.resolve_ty_as_possible(ty)\n             }\n             None => self.err_ty(),\n@@ -436,7 +448,7 @@ impl<'a> InferenceContext<'a> {\n         let var = self.table.new_type_var();\n         let alias_eq = AliasEq { alias: AliasTy::Projection(proj_ty), ty: var.clone() };\n         let obligation = alias_eq.cast(&Interner);\n-        self.obligations.push(obligation);\n+        self.push_obligation(obligation);\n         var\n     }\n "}, {"sha": "25ab3ea4c1a623242c216615527b5b7b3993e1ca", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00ce7ae5248b41d5944abe6075407236cde1b075/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ce7ae5248b41d5944abe6075407236cde1b075/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=00ce7ae5248b41d5944abe6075407236cde1b075", "patch": "@@ -99,7 +99,7 @@ impl<'a> InferenceContext<'a> {\n             environment: trait_env,\n         });\n         if self.db.trait_solve(krate, goal.value).is_some() {\n-            self.obligations.push(implements_fn_trait);\n+            self.push_obligation(implements_fn_trait);\n             let output_proj_ty = crate::ProjectionTy {\n                 associated_ty_id: to_assoc_type_id(output_assoc_type),\n                 substitution: substs,\n@@ -964,7 +964,7 @@ impl<'a> InferenceContext<'a> {\n                 let (predicate, binders) =\n                     predicate.clone().subst(parameters).into_value_and_skipped_binders();\n                 always!(binders == 0); // quantified where clauses not yet handled\n-                self.obligations.push(predicate.cast(&Interner));\n+                self.push_obligation(predicate.cast(&Interner));\n             }\n             // add obligation for trait implementation, if this is a trait method\n             match def {\n@@ -974,7 +974,7 @@ impl<'a> InferenceContext<'a> {\n                         // construct a TraitRef\n                         let substs =\n                             parameters.prefix(generics(self.db.upcast(), trait_.into()).len());\n-                        self.obligations.push(\n+                        self.push_obligation(\n                             TraitRef { trait_id: to_chalk_trait_id(trait_), substitution: substs }\n                                 .cast(&Interner),\n                         );"}, {"sha": "717738789b9612f5c54c5de95417a06e3524088b", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ce7ae5248b41d5944abe6075407236cde1b075/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ce7ae5248b41d5944abe6075407236cde1b075/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=00ce7ae5248b41d5944abe6075407236cde1b075", "patch": "@@ -258,7 +258,7 @@ impl<'a> InferenceContext<'a> {\n                             .push(ty.clone())\n                             .fill(std::iter::repeat_with(|| self.table.new_type_var()))\n                             .build();\n-                        self.obligations.push(\n+                        self.push_obligation(\n                             TraitRef {\n                                 trait_id: to_chalk_trait_id(trait_),\n                                 substitution: trait_substs.clone(),"}, {"sha": "5ea4b7481ecfe645eb9b38dd100b041cc8a64d33", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00ce7ae5248b41d5944abe6075407236cde1b075/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ce7ae5248b41d5944abe6075407236cde1b075/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=00ce7ae5248b41d5944abe6075407236cde1b075", "patch": "@@ -231,13 +231,15 @@ pub(crate) struct TypeVariableData {\n pub(crate) struct InferenceTable {\n     pub(super) var_unification_table: InPlaceUnificationTable<TypeVarId>,\n     pub(super) type_variable_table: TypeVariableTable,\n+    pub(super) revision: u32,\n }\n \n impl InferenceTable {\n     pub(crate) fn new() -> Self {\n         InferenceTable {\n             var_unification_table: InPlaceUnificationTable::new(),\n             type_variable_table: TypeVariableTable { inner: Vec::new() },\n+            revision: 0,\n         }\n     }\n \n@@ -360,7 +362,10 @@ impl InferenceTable {\n                 == self.type_variable_table.is_diverging(*tv2) =>\n             {\n                 // both type vars are unknown since we tried to resolve them\n-                self.var_unification_table.union(tv1.to_inner(), tv2.to_inner());\n+                if !self.var_unification_table.unioned(tv1.to_inner(), tv2.to_inner()) {\n+                    self.var_unification_table.union(tv1.to_inner(), tv2.to_inner());\n+                    self.revision += 1;\n+                }\n                 true\n             }\n \n@@ -398,6 +403,7 @@ impl InferenceTable {\n                     tv.to_inner(),\n                     TypeVarValue::Known(other.clone().intern(&Interner)),\n                 );\n+                self.revision += 1;\n                 true\n             }\n "}]}