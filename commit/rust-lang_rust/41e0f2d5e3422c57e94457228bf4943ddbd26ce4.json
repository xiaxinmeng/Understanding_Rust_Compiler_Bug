{"sha": "41e0f2d5e3422c57e94457228bf4943ddbd26ce4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxZTBmMmQ1ZTM0MjJjNTdlOTQ0NTcyMjhiZjQ5NDNkZGJkMjZjZTQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-14T17:29:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-14T17:29:48Z"}, "message": "Rollup merge of #35444 - alexcrichton:optimize-catch-unwind, r=brson\n\nstd: Optimize panic::catch_unwind slightly\n\nThe previous implementation of this function was overly conservative with\nliberal usage of `Option` and `.unwrap()` which in theory never triggers. This\ncommit essentially removes the `Option`s in favor of unsafe implementations,\nimproving the code generation of the fast path for LLVM to see through what's\nhappening more clearly.\n\ncc #34727", "tree": {"sha": "b9784ffe226c4d64a0fc200ba3fe438d1c3bc62a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9784ffe226c4d64a0fc200ba3fe438d1c3bc62a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41e0f2d5e3422c57e94457228bf4943ddbd26ce4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41e0f2d5e3422c57e94457228bf4943ddbd26ce4", "html_url": "https://github.com/rust-lang/rust/commit/41e0f2d5e3422c57e94457228bf4943ddbd26ce4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41e0f2d5e3422c57e94457228bf4943ddbd26ce4/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa57f358a326af04eb354fb37c9afd38e8bb87bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa57f358a326af04eb354fb37c9afd38e8bb87bd", "html_url": "https://github.com/rust-lang/rust/commit/fa57f358a326af04eb354fb37c9afd38e8bb87bd"}, {"sha": "045c8c86244aa69843c7f55ec91f2330a3aaec4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/045c8c86244aa69843c7f55ec91f2330a3aaec4e", "html_url": "https://github.com/rust-lang/rust/commit/045c8c86244aa69843c7f55ec91f2330a3aaec4e"}], "stats": {"total": 104, "additions": 68, "deletions": 36}, "files": [{"sha": "5961fd59699c1b8d0a92341e6c78f69729f0b648", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 68, "deletions": 36, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/41e0f2d5e3422c57e94457228bf4943ddbd26ce4/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e0f2d5e3422c57e94457228bf4943ddbd26ce4/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=41e0f2d5e3422c57e94457228bf4943ddbd26ce4", "patch": "@@ -25,9 +25,10 @@ use cell::RefCell;\n use fmt;\n use intrinsics;\n use mem;\n+use ptr;\n use raw;\n-use sys_common::rwlock::RWLock;\n use sys::stdio::Stderr;\n+use sys_common::rwlock::RWLock;\n use sys_common::thread_info;\n use sys_common::util;\n use thread;\n@@ -255,45 +256,76 @@ pub use realstd::rt::update_panic_count;\n \n /// Invoke a closure, capturing the cause of an unwinding panic if one occurs.\n pub unsafe fn try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<Any + Send>> {\n-    let mut slot = None;\n-    let mut f = Some(f);\n-    let ret;\n-\n-    {\n-        let mut to_run = || {\n-            slot = Some(f.take().unwrap()());\n-        };\n-        let fnptr = get_call(&mut to_run);\n-        let dataptr = &mut to_run as *mut _ as *mut u8;\n-        let mut any_data = 0;\n-        let mut any_vtable = 0;\n-        let fnptr = mem::transmute::<fn(&mut _), fn(*mut u8)>(fnptr);\n-        let r = __rust_maybe_catch_panic(fnptr,\n-                                         dataptr,\n-                                         &mut any_data,\n-                                         &mut any_vtable);\n-        if r == 0 {\n-            ret = Ok(());\n-        } else {\n-            update_panic_count(-1);\n-            ret = Err(mem::transmute(raw::TraitObject {\n-                data: any_data as *mut _,\n-                vtable: any_vtable as *mut _,\n-            }));\n-        }\n+    struct Data<F, R> {\n+        f: F,\n+        r: R,\n     }\n \n-    debug_assert!(update_panic_count(0) == 0);\n-    return ret.map(|()| {\n-        slot.take().unwrap()\n-    });\n+    // We do some sketchy operations with ownership here for the sake of\n+    // performance. The `Data` structure is never actually fully valid, but\n+    // instead it always contains at least one uninitialized field. We can only\n+    // pass pointers down to `__rust_maybe_catch_panic` (can't pass objects by\n+    // value), so we do all the ownership tracking here manully.\n+    //\n+    // Note that this is all invalid if any of these functions unwind, but the\n+    // whole point of this function is to prevent that! As a result we go\n+    // through a transition where:\n+    //\n+    // * First, only the closure we're going to call is initialized. The return\n+    //   value is uninitialized.\n+    // * When we make the function call, the `do_call` function below, we take\n+    //   ownership of the function pointer, replacing it with uninitialized\n+    //   data. At this point the `Data` structure is entirely uninitialized, but\n+    //   it won't drop due to an unwind because it's owned on the other side of\n+    //   the catch panic.\n+    // * If the closure successfully returns, we write the return value into the\n+    //   data's return slot. Note that `ptr::write` is used as it's overwriting\n+    //   uninitialized data.\n+    // * Finally, when we come back out of the `__rust_maybe_catch_panic` we're\n+    //   in one of two states:\n+    //\n+    //      1. The closure didn't panic, in which case the return value was\n+    //         filled in. We have to be careful to `forget` the closure,\n+    //         however, as ownership was passed to the `do_call` function.\n+    //      2. The closure panicked, in which case the return value wasn't\n+    //         filled in. In this case the entire `data` structure is invalid,\n+    //         so we forget the entire thing.\n+    //\n+    // Once we stack all that together we should have the \"most efficient'\n+    // method of calling a catch panic whilst juggling ownership.\n+    let mut any_data = 0;\n+    let mut any_vtable = 0;\n+    let mut data = Data {\n+        f: f,\n+        r: mem::uninitialized(),\n+    };\n \n-    fn get_call<F: FnMut()>(_: &mut F) -> fn(&mut F) {\n-        call\n-    }\n+    let r = __rust_maybe_catch_panic(do_call::<F, R>,\n+                                     &mut data as *mut _ as *mut u8,\n+                                     &mut any_data,\n+                                     &mut any_vtable);\n+\n+    return if r == 0 {\n+        let Data { f, r } = data;\n+        mem::forget(f);\n+        debug_assert!(update_panic_count(0) == 0);\n+        Ok(r)\n+    } else {\n+        mem::forget(data);\n+        update_panic_count(-1);\n+        debug_assert!(update_panic_count(0) == 0);\n+        Err(mem::transmute(raw::TraitObject {\n+            data: any_data as *mut _,\n+            vtable: any_vtable as *mut _,\n+        }))\n+    };\n \n-    fn call<F: FnMut()>(f: &mut F) {\n-        f()\n+    fn do_call<F: FnOnce() -> R, R>(data: *mut u8) {\n+        unsafe {\n+            let data = data as *mut Data<F, R>;\n+            let f = ptr::read(&mut (*data).f);\n+            ptr::write(&mut (*data).r, f());\n+        }\n     }\n }\n "}]}