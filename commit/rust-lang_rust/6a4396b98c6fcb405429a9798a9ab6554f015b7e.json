{"sha": "6a4396b98c6fcb405429a9798a9ab6554f015b7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhNDM5NmI5OGM2ZmNiNDA1NDI5YTk3OThhOWFiNjU1NGYwMTViN2U=", "commit": {"author": {"name": "Joseph Ryan", "email": "josephryan3.14@gmail.com", "date": "2020-06-24T13:16:21Z"}, "committer": {"name": "Joseph Ryan", "email": "josephryan3.14@gmail.com", "date": "2020-07-27T21:00:38Z"}, "message": "Extract `Cache` and other types from `html` module", "tree": {"sha": "8e900f16fd378deb9ad937878b7cd90e1d541af6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e900f16fd378deb9ad937878b7cd90e1d541af6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a4396b98c6fcb405429a9798a9ab6554f015b7e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEEtei29J14PIgXYsIlGom1QEO7zL0FAl8fQHYACgkQGom1QEO7\nzL1Ghwf9EhA4VBuzK3/Z7kHSLHiC5mCszXusqqFvpjElbkmsWhesSMsgJR6KK3ID\nx3XfAXepjb3hwkRSfn6xBDcvmmGxF2Uw1zI+Z7o6erv1aiwRp+ca7QzqMxU8noEj\nbWuFlMSns1Oe9KA86j3U1wzDCQ96nFxs1cL5RVJ6NeOEzTQsPxyP63P6YrF4/eJt\nGNvlYeQiZuk+JgckoOlKsgdq/UqrKDWP0+U4ksMeoOOcSYo7d5pSMwRse+v/ed9K\nCZKP/qGPkRVnslvB94QHxTqKrM4dOv4WUaJ67yGC+VgKvJf92nFTy9NySdj92+vo\njxWvZHx9r5Up7wNpl20IWVZSL2bZLQ==\n=KoOa\n-----END PGP SIGNATURE-----", "payload": "tree 8e900f16fd378deb9ad937878b7cd90e1d541af6\nparent 5bc97946ca35a789b690668bb6b27ca41bfeb5b2\nauthor Joseph Ryan <josephryan3.14@gmail.com> 1593004581 -0500\ncommitter Joseph Ryan <josephryan3.14@gmail.com> 1595883638 -0500\n\nExtract `Cache` and other types from `html` module\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a4396b98c6fcb405429a9798a9ab6554f015b7e", "html_url": "https://github.com/rust-lang/rust/commit/6a4396b98c6fcb405429a9798a9ab6554f015b7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a4396b98c6fcb405429a9798a9ab6554f015b7e/comments", "author": {"login": "P1n3appl3", "id": 9326885, "node_id": "MDQ6VXNlcjkzMjY4ODU=", "avatar_url": "https://avatars.githubusercontent.com/u/9326885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P1n3appl3", "html_url": "https://github.com/P1n3appl3", "followers_url": "https://api.github.com/users/P1n3appl3/followers", "following_url": "https://api.github.com/users/P1n3appl3/following{/other_user}", "gists_url": "https://api.github.com/users/P1n3appl3/gists{/gist_id}", "starred_url": "https://api.github.com/users/P1n3appl3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P1n3appl3/subscriptions", "organizations_url": "https://api.github.com/users/P1n3appl3/orgs", "repos_url": "https://api.github.com/users/P1n3appl3/repos", "events_url": "https://api.github.com/users/P1n3appl3/events{/privacy}", "received_events_url": "https://api.github.com/users/P1n3appl3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "P1n3appl3", "id": 9326885, "node_id": "MDQ6VXNlcjkzMjY4ODU=", "avatar_url": "https://avatars.githubusercontent.com/u/9326885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P1n3appl3", "html_url": "https://github.com/P1n3appl3", "followers_url": "https://api.github.com/users/P1n3appl3/followers", "following_url": "https://api.github.com/users/P1n3appl3/following{/other_user}", "gists_url": "https://api.github.com/users/P1n3appl3/gists{/gist_id}", "starred_url": "https://api.github.com/users/P1n3appl3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P1n3appl3/subscriptions", "organizations_url": "https://api.github.com/users/P1n3appl3/orgs", "repos_url": "https://api.github.com/users/P1n3appl3/repos", "events_url": "https://api.github.com/users/P1n3appl3/events{/privacy}", "received_events_url": "https://api.github.com/users/P1n3appl3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bc97946ca35a789b690668bb6b27ca41bfeb5b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bc97946ca35a789b690668bb6b27ca41bfeb5b2", "html_url": "https://github.com/rust-lang/rust/commit/5bc97946ca35a789b690668bb6b27ca41bfeb5b2"}], "stats": {"total": 1560, "additions": 808, "deletions": 752}, "files": [{"sha": "89549eae2cb0e7bfdb6a18eb84efb8cffeae155a", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=6a4396b98c6fcb405429a9798a9ab6554f015b7e", "patch": "@@ -32,8 +32,9 @@ use crate::clean::inline;\n use crate::clean::types::Type::{QPath, ResolvedPath};\n use crate::core::DocContext;\n use crate::doctree;\n-use crate::html::item_type::ItemType;\n-use crate::html::render::{cache, ExternalLocation};\n+use crate::formats::cache::cache;\n+use crate::formats::item_type::ItemType;\n+use crate::html::render::cache::ExternalLocation;\n \n use self::FnRetTy::*;\n use self::ItemEnum::*;\n@@ -1172,7 +1173,7 @@ impl GetDefId for Type {\n     fn def_id(&self) -> Option<DefId> {\n         match *self {\n             ResolvedPath { did, .. } => Some(did),\n-            Primitive(p) => crate::html::render::cache().primitive_locations.get(&p).cloned(),\n+            Primitive(p) => cache().primitive_locations.get(&p).cloned(),\n             BorrowedRef { type_: box Generic(..), .. } => {\n                 Primitive(PrimitiveType::Reference).def_id()\n             }"}, {"sha": "3547b45dfa71f95b095723e2ef6c03749f00d871", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=6a4396b98c6fcb405429a9798a9ab6554f015b7e", "patch": "@@ -254,7 +254,7 @@ pub struct RenderOptions {\n \n /// Temporary storage for data obtained during `RustdocVisitor::clean()`.\n /// Later on moved into `CACHE_KEY`.\n-#[derive(Default)]\n+#[derive(Default, Clone)]\n pub struct RenderInfo {\n     pub inlined: FxHashSet<DefId>,\n     pub external_paths: crate::core::ExternalPaths,"}, {"sha": "7635453d56fd6331a4c63206ef0a9e856b606247", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6a4396b98c6fcb405429a9798a9ab6554f015b7e", "patch": "@@ -44,9 +44,9 @@ pub type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n pub struct DocContext<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n     pub resolver: Rc<RefCell<interface::BoxedResolver>>,\n-    /// Later on moved into `html::render::CACHE_KEY`\n+    /// Later on moved into `formats::cache::CACHE_KEY`\n     pub renderinfo: RefCell<RenderInfo>,\n-    /// Later on moved through `clean::Crate` into `html::render::CACHE_KEY`\n+    /// Later on moved through `clean::Crate` into `formats::cache::CACHE_KEY`\n     pub external_traits: Rc<RefCell<FxHashMap<DefId, clean::Trait>>>,\n     /// Used while populating `external_traits` to ensure we don't process the same trait twice at\n     /// the same time."}, {"sha": "4bdeafa1ec7c03d8e7c59babdcc22c984805a6a3", "filename": "src/librustdoc/formats/cache.rs", "status": "added", "additions": 498, "deletions": 0, "changes": 498, "blob_url": "https://github.com/rust-lang/rust/blob/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=6a4396b98c6fcb405429a9798a9ab6554f015b7e", "patch": "@@ -0,0 +1,498 @@\n+use std::cell::RefCell;\n+use std::collections::BTreeMap;\n+use std::mem;\n+use std::path::{Path, PathBuf};\n+use std::sync::Arc;\n+\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n+use rustc_middle::middle::privacy::AccessLevels;\n+use rustc_span::source_map::FileName;\n+\n+use crate::clean::{self, GetDefId};\n+use crate::config::RenderInfo;\n+use crate::fold::DocFolder;\n+use crate::formats::item_type::ItemType;\n+use crate::formats::Impl;\n+use crate::html::render::cache::{extern_location, get_index_search_type, ExternalLocation};\n+use crate::html::render::IndexItem;\n+use crate::html::render::{plain_summary_line, shorten};\n+\n+thread_local!(crate static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n+\n+/// This cache is used to store information about the `clean::Crate` being\n+/// rendered in order to provide more useful documentation. This contains\n+/// information like all implementors of a trait, all traits a type implements,\n+/// documentation for all known traits, etc.\n+///\n+/// This structure purposefully does not implement `Clone` because it's intended\n+/// to be a fairly large and expensive structure to clone. Instead this adheres\n+/// to `Send` so it may be stored in a `Arc` instance and shared among the various\n+/// rendering threads.\n+#[derive(Default)]\n+pub struct Cache {\n+    /// Maps a type ID to all known implementations for that type. This is only\n+    /// recognized for intra-crate `ResolvedPath` types, and is used to print\n+    /// out extra documentation on the page of an enum/struct.\n+    ///\n+    /// The values of the map are a list of implementations and documentation\n+    /// found on that implementation.\n+    pub impls: FxHashMap<DefId, Vec<Impl>>,\n+\n+    /// Maintains a mapping of local crate `DefId`s to the fully qualified name\n+    /// and \"short type description\" of that node. This is used when generating\n+    /// URLs when a type is being linked to. External paths are not located in\n+    /// this map because the `External` type itself has all the information\n+    /// necessary.\n+    pub paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n+\n+    /// Similar to `paths`, but only holds external paths. This is only used for\n+    /// generating explicit hyperlinks to other crates.\n+    pub external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n+\n+    /// Maps local `DefId`s of exported types to fully qualified paths.\n+    /// Unlike 'paths', this mapping ignores any renames that occur\n+    /// due to 'use' statements.\n+    ///\n+    /// This map is used when writing out the special 'implementors'\n+    /// javascript file. By using the exact path that the type\n+    /// is declared with, we ensure that each path will be identical\n+    /// to the path used if the corresponding type is inlined. By\n+    /// doing this, we can detect duplicate impls on a trait page, and only display\n+    /// the impl for the inlined type.\n+    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n+\n+    /// This map contains information about all known traits of this crate.\n+    /// Implementations of a crate should inherit the documentation of the\n+    /// parent trait if no extra documentation is specified, and default methods\n+    /// should show up in documentation about trait implementations.\n+    pub traits: FxHashMap<DefId, clean::Trait>,\n+\n+    /// When rendering traits, it's often useful to be able to list all\n+    /// implementors of the trait, and this mapping is exactly, that: a mapping\n+    /// of trait ids to the list of known implementors of the trait\n+    pub implementors: FxHashMap<DefId, Vec<Impl>>,\n+\n+    /// Cache of where external crate documentation can be found.\n+    pub extern_locations: FxHashMap<CrateNum, (String, PathBuf, ExternalLocation)>,\n+\n+    /// Cache of where documentation for primitives can be found.\n+    pub primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n+\n+    // Note that external items for which `doc(hidden)` applies to are shown as\n+    // non-reachable while local items aren't. This is because we're reusing\n+    // the access levels from the privacy check pass.\n+    pub access_levels: AccessLevels<DefId>,\n+\n+    /// The version of the crate being documented, if given from the `--crate-version` flag.\n+    pub crate_version: Option<String>,\n+\n+    /// Whether to document private items.\n+    /// This is stored in `Cache` so it doesn't need to be passed through all rustdoc functions.\n+    pub document_private: bool,\n+\n+    // Private fields only used when initially crawling a crate to build a cache\n+    stack: Vec<String>,\n+    parent_stack: Vec<DefId>,\n+    parent_is_trait_impl: bool,\n+    stripped_mod: bool,\n+    masked_crates: FxHashSet<CrateNum>,\n+\n+    pub search_index: Vec<IndexItem>,\n+    pub deref_trait_did: Option<DefId>,\n+    pub deref_mut_trait_did: Option<DefId>,\n+    pub owned_box_did: Option<DefId>,\n+\n+    // In rare case where a structure is defined in one module but implemented\n+    // in another, if the implementing module is parsed before defining module,\n+    // then the fully qualified name of the structure isn't presented in `paths`\n+    // yet when its implementation methods are being indexed. Caches such methods\n+    // and their parent id here and indexes them at the end of crate parsing.\n+    pub orphan_impl_items: Vec<(DefId, clean::Item)>,\n+\n+    // Similarly to `orphan_impl_items`, sometimes trait impls are picked up\n+    // even though the trait itself is not exported. This can happen if a trait\n+    // was defined in function/expression scope, since the impl will be picked\n+    // up by `collect-trait-impls` but the trait won't be scraped out in the HIR\n+    // crawl. In order to prevent crashes when looking for spotlight traits or\n+    // when gathering trait documentation on a type, hold impls here while\n+    // folding and add them to the cache later on if we find the trait.\n+    orphan_trait_impls: Vec<(DefId, FxHashSet<DefId>, Impl)>,\n+\n+    /// Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n+    /// we need the alias element to have an array of items.\n+    pub aliases: BTreeMap<String, Vec<usize>>,\n+}\n+\n+impl Cache {\n+    pub fn from_krate(\n+        renderinfo: RenderInfo,\n+        document_private: bool,\n+        extern_html_root_urls: &BTreeMap<String, String>,\n+        dst: &Path,\n+        mut krate: clean::Crate,\n+    ) -> (clean::Crate, Cache) {\n+        // Crawl the crate to build various caches used for the output\n+        let RenderInfo {\n+            inlined: _,\n+            external_paths,\n+            exact_paths,\n+            access_levels,\n+            deref_trait_did,\n+            deref_mut_trait_did,\n+            owned_box_did,\n+            ..\n+        } = renderinfo;\n+\n+        let external_paths =\n+            external_paths.into_iter().map(|(k, (v, t))| (k, (v, ItemType::from(t)))).collect();\n+\n+        let mut cache = Cache {\n+            impls: Default::default(),\n+            external_paths,\n+            exact_paths,\n+            paths: Default::default(),\n+            implementors: Default::default(),\n+            stack: Vec::new(),\n+            parent_stack: Vec::new(),\n+            search_index: Vec::new(),\n+            parent_is_trait_impl: false,\n+            extern_locations: Default::default(),\n+            primitive_locations: Default::default(),\n+            stripped_mod: false,\n+            access_levels,\n+            crate_version: krate.version.take(),\n+            document_private,\n+            orphan_impl_items: Vec::new(),\n+            orphan_trait_impls: Vec::new(),\n+            traits: krate.external_traits.replace(Default::default()),\n+            deref_trait_did,\n+            deref_mut_trait_did,\n+            owned_box_did,\n+            masked_crates: mem::take(&mut krate.masked_crates),\n+            aliases: Default::default(),\n+        };\n+\n+        // Cache where all our extern crates are located\n+        // TODO: this part is specific to HTML so it'd be nice to remove it from the common code\n+        for &(n, ref e) in &krate.externs {\n+            let src_root = match e.src {\n+                FileName::Real(ref p) => match p.local_path().parent() {\n+                    Some(p) => p.to_path_buf(),\n+                    None => PathBuf::new(),\n+                },\n+                _ => PathBuf::new(),\n+            };\n+            let extern_url = extern_html_root_urls.get(&e.name).map(|u| &**u);\n+            cache\n+                .extern_locations\n+                .insert(n, (e.name.clone(), src_root, extern_location(e, extern_url, &dst)));\n+\n+            let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n+            cache.external_paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n+        }\n+\n+        // Cache where all known primitives have their documentation located.\n+        //\n+        // Favor linking to as local extern as possible, so iterate all crates in\n+        // reverse topological order.\n+        for &(_, ref e) in krate.externs.iter().rev() {\n+            for &(def_id, prim, _) in &e.primitives {\n+                cache.primitive_locations.insert(prim, def_id);\n+            }\n+        }\n+        for &(def_id, prim, _) in &krate.primitives {\n+            cache.primitive_locations.insert(prim, def_id);\n+        }\n+\n+        cache.stack.push(krate.name.clone());\n+        krate = cache.fold_crate(krate);\n+\n+        for (trait_did, dids, impl_) in cache.orphan_trait_impls.drain(..) {\n+            if cache.traits.contains_key(&trait_did) {\n+                for did in dids {\n+                    cache.impls.entry(did).or_insert(vec![]).push(impl_.clone());\n+                }\n+            }\n+        }\n+\n+        (krate, cache)\n+    }\n+}\n+\n+impl DocFolder for Cache {\n+    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        if item.def_id.is_local() {\n+            debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.def_id);\n+        }\n+\n+        // If this is a stripped module,\n+        // we don't want it or its children in the search index.\n+        let orig_stripped_mod = match item.inner {\n+            clean::StrippedItem(box clean::ModuleItem(..)) => {\n+                mem::replace(&mut self.stripped_mod, true)\n+            }\n+            _ => self.stripped_mod,\n+        };\n+\n+        // If the impl is from a masked crate or references something from a\n+        // masked crate then remove it completely.\n+        if let clean::ImplItem(ref i) = item.inner {\n+            if self.masked_crates.contains(&item.def_id.krate)\n+                || i.trait_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n+                || i.for_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n+            {\n+                return None;\n+            }\n+        }\n+\n+        // Propagate a trait method's documentation to all implementors of the\n+        // trait.\n+        if let clean::TraitItem(ref t) = item.inner {\n+            self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n+        }\n+\n+        // Collect all the implementors of traits.\n+        if let clean::ImplItem(ref i) = item.inner {\n+            if let Some(did) = i.trait_.def_id() {\n+                if i.blanket_impl.is_none() {\n+                    self.implementors\n+                        .entry(did)\n+                        .or_default()\n+                        .push(Impl { impl_item: item.clone() });\n+                }\n+            }\n+        }\n+\n+        // Index this method for searching later on.\n+        if let Some(ref s) = item.name {\n+            let (parent, is_inherent_impl_item) = match item.inner {\n+                clean::StrippedItem(..) => ((None, None), false),\n+                clean::AssocConstItem(..) | clean::TypedefItem(_, true)\n+                    if self.parent_is_trait_impl =>\n+                {\n+                    // skip associated items in trait impls\n+                    ((None, None), false)\n+                }\n+                clean::AssocTypeItem(..)\n+                | clean::TyMethodItem(..)\n+                | clean::StructFieldItem(..)\n+                | clean::VariantItem(..) => (\n+                    (\n+                        Some(*self.parent_stack.last().expect(\"parent_stack is empty\")),\n+                        Some(&self.stack[..self.stack.len() - 1]),\n+                    ),\n+                    false,\n+                ),\n+                clean::MethodItem(..) | clean::AssocConstItem(..) => {\n+                    if self.parent_stack.is_empty() {\n+                        ((None, None), false)\n+                    } else {\n+                        let last = self.parent_stack.last().expect(\"parent_stack is empty 2\");\n+                        let did = *last;\n+                        let path = match self.paths.get(&did) {\n+                            // The current stack not necessarily has correlation\n+                            // for where the type was defined. On the other\n+                            // hand, `paths` always has the right\n+                            // information if present.\n+                            Some(&(\n+                                ref fqp,\n+                                ItemType::Trait\n+                                | ItemType::Struct\n+                                | ItemType::Union\n+                                | ItemType::Enum,\n+                            )) => Some(&fqp[..fqp.len() - 1]),\n+                            Some(..) => Some(&*self.stack),\n+                            None => None,\n+                        };\n+                        ((Some(*last), path), true)\n+                    }\n+                }\n+                _ => ((None, Some(&*self.stack)), false),\n+            };\n+\n+            match parent {\n+                (parent, Some(path)) if is_inherent_impl_item || !self.stripped_mod => {\n+                    debug_assert!(!item.is_stripped());\n+\n+                    // A crate has a module at its root, containing all items,\n+                    // which should not be indexed. The crate-item itself is\n+                    // inserted later on when serializing the search-index.\n+                    if item.def_id.index != CRATE_DEF_INDEX {\n+                        self.search_index.push(IndexItem {\n+                            ty: item.type_(),\n+                            name: s.to_string(),\n+                            path: path.join(\"::\"),\n+                            desc: shorten(plain_summary_line(item.doc_value())),\n+                            parent,\n+                            parent_idx: None,\n+                            search_type: get_index_search_type(&item),\n+                        });\n+\n+                        for alias in item.attrs.get_doc_aliases() {\n+                            self.aliases\n+                                .entry(alias.to_lowercase())\n+                                .or_insert(Vec::new())\n+                                .push(self.search_index.len() - 1);\n+                        }\n+                    }\n+                }\n+                (Some(parent), None) if is_inherent_impl_item => {\n+                    // We have a parent, but we don't know where they're\n+                    // defined yet. Wait for later to index this item.\n+                    self.orphan_impl_items.push((parent, item.clone()));\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        // Keep track of the fully qualified path for this item.\n+        let pushed = match item.name {\n+            Some(ref n) if !n.is_empty() => {\n+                self.stack.push(n.to_string());\n+                true\n+            }\n+            _ => false,\n+        };\n+\n+        match item.inner {\n+            clean::StructItem(..)\n+            | clean::EnumItem(..)\n+            | clean::TypedefItem(..)\n+            | clean::TraitItem(..)\n+            | clean::FunctionItem(..)\n+            | clean::ModuleItem(..)\n+            | clean::ForeignFunctionItem(..)\n+            | clean::ForeignStaticItem(..)\n+            | clean::ConstantItem(..)\n+            | clean::StaticItem(..)\n+            | clean::UnionItem(..)\n+            | clean::ForeignTypeItem\n+            | clean::MacroItem(..)\n+            | clean::ProcMacroItem(..)\n+            | clean::VariantItem(..)\n+                if !self.stripped_mod =>\n+            {\n+                // Re-exported items mean that the same id can show up twice\n+                // in the rustdoc ast that we're looking at. We know,\n+                // however, that a re-exported item doesn't show up in the\n+                // `public_items` map, so we can skip inserting into the\n+                // paths map if there was already an entry present and we're\n+                // not a public item.\n+                if !self.paths.contains_key(&item.def_id)\n+                    || self.access_levels.is_public(item.def_id)\n+                {\n+                    self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n+                }\n+            }\n+            clean::PrimitiveItem(..) => {\n+                self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n+            }\n+\n+            _ => {}\n+        }\n+\n+        // Maintain the parent stack\n+        let orig_parent_is_trait_impl = self.parent_is_trait_impl;\n+        let parent_pushed = match item.inner {\n+            clean::TraitItem(..)\n+            | clean::EnumItem(..)\n+            | clean::ForeignTypeItem\n+            | clean::StructItem(..)\n+            | clean::UnionItem(..)\n+            | clean::VariantItem(..) => {\n+                self.parent_stack.push(item.def_id);\n+                self.parent_is_trait_impl = false;\n+                true\n+            }\n+            clean::ImplItem(ref i) => {\n+                self.parent_is_trait_impl = i.trait_.is_some();\n+                match i.for_ {\n+                    clean::ResolvedPath { did, .. } => {\n+                        self.parent_stack.push(did);\n+                        true\n+                    }\n+                    ref t => {\n+                        let prim_did = t\n+                            .primitive_type()\n+                            .and_then(|t| self.primitive_locations.get(&t).cloned());\n+                        match prim_did {\n+                            Some(did) => {\n+                                self.parent_stack.push(did);\n+                                true\n+                            }\n+                            None => false,\n+                        }\n+                    }\n+                }\n+            }\n+            _ => false,\n+        };\n+\n+        // Once we've recursively found all the generics, hoard off all the\n+        // implementations elsewhere.\n+        let ret = self.fold_item_recur(item).and_then(|item| {\n+            if let clean::Item { inner: clean::ImplItem(_), .. } = item {\n+                // Figure out the id of this impl. This may map to a\n+                // primitive rather than always to a struct/enum.\n+                // Note: matching twice to restrict the lifetime of the `i` borrow.\n+                let mut dids = FxHashSet::default();\n+                if let clean::Item { inner: clean::ImplItem(ref i), .. } = item {\n+                    match i.for_ {\n+                        clean::ResolvedPath { did, .. }\n+                        | clean::BorrowedRef {\n+                            type_: box clean::ResolvedPath { did, .. }, ..\n+                        } => {\n+                            dids.insert(did);\n+                        }\n+                        ref t => {\n+                            let did = t\n+                                .primitive_type()\n+                                .and_then(|t| self.primitive_locations.get(&t).cloned());\n+\n+                            if let Some(did) = did {\n+                                dids.insert(did);\n+                            }\n+                        }\n+                    }\n+\n+                    if let Some(generics) = i.trait_.as_ref().and_then(|t| t.generics()) {\n+                        for bound in generics {\n+                            if let Some(did) = bound.def_id() {\n+                                dids.insert(did);\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    unreachable!()\n+                };\n+                let impl_item = Impl { impl_item: item };\n+                if impl_item.trait_did().map_or(true, |d| self.traits.contains_key(&d)) {\n+                    for did in dids {\n+                        self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n+                    }\n+                } else {\n+                    let trait_did = impl_item.trait_did().expect(\"no trait did\");\n+                    self.orphan_trait_impls.push((trait_did, dids, impl_item));\n+                }\n+                None\n+            } else {\n+                Some(item)\n+            }\n+        });\n+\n+        if pushed {\n+            self.stack.pop().expect(\"stack already empty\");\n+        }\n+        if parent_pushed {\n+            self.parent_stack.pop().expect(\"parent stack already empty\");\n+        }\n+        self.stripped_mod = orig_stripped_mod;\n+        self.parent_is_trait_impl = orig_parent_is_trait_impl;\n+        ret\n+    }\n+}\n+\n+crate fn cache() -> Arc<Cache> {\n+    CACHE_KEY.with(|c| c.borrow().clone())\n+}"}, {"sha": "696bdae94fc88b89170999b60258b2d196781c04", "filename": "src/librustdoc/formats/item_type.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fitem_type.rs?ref=6a4396b98c6fcb405429a9798a9ab6554f015b7e", "patch": "@@ -13,7 +13,7 @@ use crate::clean;\n /// The search index uses item types encoded as smaller numbers which equal to\n /// discriminants. JavaScript then is used to decode them into the original value.\n /// Consequently, every change to this type should be synchronized to\n-/// the `itemTypes` mapping table in `static/main.js`.\n+/// the `itemTypes` mapping table in `html/static/main.js`.\n ///\n /// In addition, code in `html::render` uses this enum to generate CSS classes, page prefixes, and\n /// module headings. If you are adding to this enum and want to ensure that the sidebar also prints", "previous_filename": "src/librustdoc/html/item_type.rs"}, {"sha": "2473f7758d2a82e456d774f03d8de83bdd600ffe", "filename": "src/librustdoc/formats/mod.rs", "status": "modified", "additions": 19, "deletions": 97, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fformats%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fformats%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fmod.rs?ref=6a4396b98c6fcb405429a9798a9ab6554f015b7e", "patch": "@@ -1,107 +1,29 @@\n-use std::cell::RefCell;\n-use std::rc::Rc;\n+pub mod cache;\n+pub mod item_type;\n+pub mod renderer;\n \n-use rustc_span::edition::Edition;\n+pub use renderer::{FormatRenderer, Renderer};\n \n-use crate::clean;\n-use crate::config::{RenderInfo, RenderOptions};\n-use crate::error::Error;\n-\n-pub trait FormatRenderer: Clone {\n-    type Output: FormatRenderer;\n-\n-    fn init(\n-        krate: clean::Crate,\n-        options: RenderOptions,\n-        renderinfo: RenderInfo,\n-        diag: &rustc_errors::Handler,\n-        edition: Edition,\n-        parent: Rc<RefCell<Renderer>>,\n-    ) -> Result<(Self::Output, clean::Crate), Error>;\n-\n-    /// Renders a single non-module item. This means no recursive sub-item rendering is required.\n-    fn item(&mut self, item: clean::Item) -> Result<(), Error>;\n+use rustc_span::def_id::DefId;\n \n-    /// Renders a module. Doesn't need to handle recursing into children, the driver does that\n-    /// automatically.\n-    fn mod_item_in(\n-        &mut self,\n-        item: &clean::Item,\n-        item_name: &str,\n-        module: &clean::Module,\n-    ) -> Result<(), Error>;\n-\n-    /// Runs after recursively rendering all sub-items of a module.\n-    fn mod_item_out(&mut self) -> Result<(), Error>;\n-\n-    /// Post processing hook for cleanup and dumping output to files.\n-    fn after_krate(&mut self, krate: &clean::Crate) -> Result<(), Error>;\n+use crate::clean;\n+use crate::clean::types::GetDefId;\n \n-    /// Called after everything else to write out errors.\n-    fn after_run(&mut self, diag: &rustc_errors::Handler) -> Result<(), Error>;\n+/// Metadata about implementations for a type or trait.\n+#[derive(Clone, Debug)]\n+pub struct Impl {\n+    pub impl_item: clean::Item,\n }\n \n-#[derive(Clone)]\n-pub struct Renderer;\n-\n-impl Renderer {\n-    pub fn new() -> Renderer {\n-        Renderer\n-    }\n-\n-    /// Main method for rendering a crate.\n-    pub fn run<T: FormatRenderer + Clone>(\n-        self,\n-        krate: clean::Crate,\n-        options: RenderOptions,\n-        renderinfo: RenderInfo,\n-        diag: &rustc_errors::Handler,\n-        edition: Edition,\n-    ) -> Result<(), Error> {\n-        let rself = Rc::new(RefCell::new(self));\n-        let (mut renderer, mut krate) =\n-            T::init(krate, options, renderinfo, diag, edition, rself.clone())?;\n-        let mut item = match krate.module.take() {\n-            Some(i) => i,\n-            None => return Ok(()),\n-        };\n-\n-        item.name = Some(krate.name.clone());\n-\n-        // Render the crate documentation\n-        let mut work = vec![(renderer.clone(), item)];\n-\n-        while let Some((mut cx, item)) = work.pop() {\n-            if item.is_mod() {\n-                // modules are special because they add a namespace. We also need to\n-                // recurse into the items of the module as well.\n-                let name = item.name.as_ref().unwrap().to_string();\n-                if name.is_empty() {\n-                    panic!(\"Unexpected module with empty name\");\n-                }\n-\n-                let module = match item.inner {\n-                    clean::StrippedItem(box clean::ModuleItem(ref m))\n-                    | clean::ModuleItem(ref m) => m,\n-                    _ => unreachable!(),\n-                };\n-                cx.mod_item_in(&item, &name, module)?;\n-                let module = match item.inner {\n-                    clean::StrippedItem(box clean::ModuleItem(m)) | clean::ModuleItem(m) => m,\n-                    _ => unreachable!(),\n-                };\n-                for it in module.items {\n-                    info!(\"Adding {:?} to worklist\", it.name);\n-                    work.push((cx.clone(), it));\n-                }\n-\n-                cx.mod_item_out()?;\n-            } else if item.name.is_some() {\n-                cx.item(item)?;\n-            }\n+impl Impl {\n+    pub fn inner_impl(&self) -> &clean::Impl {\n+        match self.impl_item.inner {\n+            clean::ImplItem(ref impl_) => impl_,\n+            _ => panic!(\"non-impl item found in impl\"),\n         }\n+    }\n \n-        renderer.after_krate(&krate)?;\n-        renderer.after_run(diag)\n+    pub fn trait_did(&self) -> Option<DefId> {\n+        self.inner_impl().trait_.def_id()\n     }\n }"}, {"sha": "f1862337ba1a5b08180fc36c4067b2ca3449457b", "filename": "src/librustdoc/formats/renderer.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Frenderer.rs?ref=6a4396b98c6fcb405429a9798a9ab6554f015b7e", "patch": "@@ -0,0 +1,112 @@\n+use std::sync::Arc;\n+\n+use rustc_span::edition::Edition;\n+\n+use crate::clean;\n+use crate::config::{RenderInfo, RenderOptions};\n+use crate::error::Error;\n+use crate::formats::cache::{Cache, CACHE_KEY};\n+\n+pub trait FormatRenderer: Clone {\n+    type Output: FormatRenderer;\n+\n+    fn init(\n+        krate: clean::Crate,\n+        options: RenderOptions,\n+        renderinfo: RenderInfo,\n+        edition: Edition,\n+        cache: &mut Cache,\n+    ) -> Result<(Self::Output, clean::Crate), Error>;\n+\n+    /// Renders a single non-module item. This means no recursive sub-item rendering is required.\n+    fn item(&mut self, item: clean::Item, cache: &Cache) -> Result<(), Error>;\n+\n+    /// Renders a module (doesn't need to handle recursing into children).\n+    fn mod_item_in(\n+        &mut self,\n+        item: &clean::Item,\n+        item_name: &str,\n+        cache: &Cache,\n+    ) -> Result<(), Error>;\n+\n+    /// Runs after recursively rendering all sub-items of a module.\n+    fn mod_item_out(&mut self, name: &str) -> Result<(), Error>;\n+\n+    /// Post processing hook for cleanup and dumping output to files.\n+    fn after_krate(&mut self, krate: &clean::Crate, cache: &Cache) -> Result<(), Error>;\n+\n+    /// Called after everything else to write out errors.\n+    fn after_run(&mut self, diag: &rustc_errors::Handler) -> Result<(), Error>;\n+}\n+\n+#[derive(Clone)]\n+pub struct Renderer;\n+\n+impl Renderer {\n+    pub fn new() -> Renderer {\n+        Renderer\n+    }\n+\n+    /// Main method for rendering a crate.\n+    pub fn run<T: FormatRenderer + Clone>(\n+        self,\n+        krate: clean::Crate,\n+        options: RenderOptions,\n+        renderinfo: RenderInfo,\n+        diag: &rustc_errors::Handler,\n+        edition: Edition,\n+    ) -> Result<(), Error> {\n+        let (krate, mut cache) = Cache::from_krate(\n+            renderinfo.clone(),\n+            options.document_private,\n+            &options.extern_html_root_urls,\n+            &options.output,\n+            krate,\n+        );\n+\n+        let (mut renderer, mut krate) = T::init(krate, options, renderinfo, edition, &mut cache)?;\n+\n+        let cache = Arc::new(cache);\n+        // Freeze the cache now that the index has been built. Put an Arc into TLS for future\n+        // parallelization opportunities\n+        CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n+\n+        let mut item = match krate.module.take() {\n+            Some(i) => i,\n+            None => return Ok(()),\n+        };\n+\n+        item.name = Some(krate.name.clone());\n+\n+        // Render the crate documentation\n+        let mut work = vec![(renderer.clone(), item)];\n+\n+        while let Some((mut cx, item)) = work.pop() {\n+            if item.is_mod() {\n+                // modules are special because they add a namespace. We also need to\n+                // recurse into the items of the module as well.\n+                let name = item.name.as_ref().unwrap().to_string();\n+                if name.is_empty() {\n+                    panic!(\"Unexpected module with empty name\");\n+                }\n+\n+                cx.mod_item_in(&item, &name, &cache)?;\n+                let module = match item.inner {\n+                    clean::StrippedItem(box clean::ModuleItem(m)) | clean::ModuleItem(m) => m,\n+                    _ => unreachable!(),\n+                };\n+                for it in module.items {\n+                    info!(\"Adding {:?} to worklist\", it.name);\n+                    work.push((cx.clone(), it));\n+                }\n+\n+                cx.mod_item_out(&name)?;\n+            } else if item.name.is_some() {\n+                cx.item(item, &cache)?;\n+            }\n+        }\n+\n+        renderer.after_krate(&krate, &cache)?;\n+        renderer.after_run(diag)\n+    }\n+}"}, {"sha": "699f8c36cba6a43cbdd9a2a198fdf899275713dd", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=6a4396b98c6fcb405429a9798a9ab6554f015b7e", "patch": "@@ -11,13 +11,15 @@ use std::fmt;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_span::def_id::DefId;\n use rustc_target::spec::abi::Abi;\n \n use crate::clean::{self, PrimitiveType};\n+use crate::formats::cache::cache;\n+use crate::formats::item_type::ItemType;\n use crate::html::escape::Escape;\n-use crate::html::item_type::ItemType;\n-use crate::html::render::{self, cache, CURRENT_DEPTH};\n+use crate::html::render::cache::ExternalLocation;\n+use crate::html::render::CURRENT_DEPTH;\n \n pub trait Print {\n     fn print(self, buffer: &mut Buffer);\n@@ -493,9 +495,9 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n                 fqp,\n                 shortty,\n                 match cache.extern_locations[&did.krate] {\n-                    (.., render::Remote(ref s)) => s.to_string(),\n-                    (.., render::Local) => \"../\".repeat(depth),\n-                    (.., render::Unknown) => return None,\n+                    (.., ExternalLocation::Remote(ref s)) => s.to_string(),\n+                    (.., ExternalLocation::Local) => \"../\".repeat(depth),\n+                    (.., ExternalLocation::Unknown) => return None,\n                 },\n             )\n         }\n@@ -574,12 +576,12 @@ fn primitive_link(\n             }\n             Some(&def_id) => {\n                 let loc = match m.extern_locations[&def_id.krate] {\n-                    (ref cname, _, render::Remote(ref s)) => Some((cname, s.to_string())),\n-                    (ref cname, _, render::Local) => {\n+                    (ref cname, _, ExternalLocation::Remote(ref s)) => Some((cname, s.to_string())),\n+                    (ref cname, _, ExternalLocation::Local) => {\n                         let len = CURRENT_DEPTH.with(|s| s.get());\n                         Some((cname, \"../\".repeat(len)))\n                     }\n-                    (.., render::Unknown) => None,\n+                    (.., ExternalLocation::Unknown) => None,\n                 };\n                 if let Some((cname, root)) = loc {\n                     write!("}, {"sha": "367538d440ea113c839e3de90f6c195c616b56a0", "filename": "src/librustdoc/html/mod.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmod.rs?ref=6a4396b98c6fcb405429a9798a9ab6554f015b7e", "patch": "@@ -0,0 +1,9 @@\n+crate mod escape;\n+crate mod format;\n+crate mod highlight;\n+crate mod layout;\n+pub mod markdown;\n+pub mod render;\n+crate mod sources;\n+crate mod static_files;\n+crate mod toc;"}, {"sha": "378efa1a1bed7c0aaad67a5a2aab26a8af8ed225", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 12, "deletions": 489, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=6a4396b98c6fcb405429a9798a9ab6554f015b7e", "patch": "@@ -1,19 +1,16 @@\n-use crate::clean::{self, AttributesExt, GetDefId};\n-use crate::fold::DocFolder;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n-use rustc_middle::middle::privacy::AccessLevels;\n-use rustc_span::source_map::FileName;\n-use rustc_span::symbol::sym;\n use std::collections::BTreeMap;\n-use std::mem;\n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n \n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_span::symbol::sym;\n use serde::Serialize;\n \n-use super::{plain_summary_line, shorten, Impl, IndexItem, IndexItemFunctionType, ItemType};\n-use super::{Generic, RenderType, TypeWithKind};\n-use crate::config::RenderInfo;\n+use crate::clean::types::GetDefId;\n+use crate::clean::{self, AttributesExt};\n+use crate::formats::cache::Cache;\n+use crate::formats::item_type::ItemType;\n+use crate::html::render::{plain_summary_line, shorten};\n+use crate::html::render::{Generic, IndexItem, IndexItemFunctionType, RenderType, TypeWithKind};\n \n /// Indicates where an external crate can be found.\n pub enum ExternalLocation {\n@@ -25,483 +22,9 @@ pub enum ExternalLocation {\n     Unknown,\n }\n \n-/// This cache is used to store information about the `clean::Crate` being\n-/// rendered in order to provide more useful documentation. This contains\n-/// information like all implementors of a trait, all traits a type implements,\n-/// documentation for all known traits, etc.\n-///\n-/// This structure purposefully does not implement `Clone` because it's intended\n-/// to be a fairly large and expensive structure to clone. Instead this adheres\n-/// to `Send` so it may be stored in a `Arc` instance and shared among the various\n-/// rendering threads.\n-#[derive(Default)]\n-crate struct Cache {\n-    /// Maps a type ID to all known implementations for that type. This is only\n-    /// recognized for intra-crate `ResolvedPath` types, and is used to print\n-    /// out extra documentation on the page of an enum/struct.\n-    ///\n-    /// The values of the map are a list of implementations and documentation\n-    /// found on that implementation.\n-    pub impls: FxHashMap<DefId, Vec<Impl>>,\n-\n-    /// Maintains a mapping of local crate `DefId`s to the fully qualified name\n-    /// and \"short type description\" of that node. This is used when generating\n-    /// URLs when a type is being linked to. External paths are not located in\n-    /// this map because the `External` type itself has all the information\n-    /// necessary.\n-    pub paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n-\n-    /// Similar to `paths`, but only holds external paths. This is only used for\n-    /// generating explicit hyperlinks to other crates.\n-    pub external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n-\n-    /// Maps local `DefId`s of exported types to fully qualified paths.\n-    /// Unlike 'paths', this mapping ignores any renames that occur\n-    /// due to 'use' statements.\n-    ///\n-    /// This map is used when writing out the special 'implementors'\n-    /// javascript file. By using the exact path that the type\n-    /// is declared with, we ensure that each path will be identical\n-    /// to the path used if the corresponding type is inlined. By\n-    /// doing this, we can detect duplicate impls on a trait page, and only display\n-    /// the impl for the inlined type.\n-    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n-\n-    /// This map contains information about all known traits of this crate.\n-    /// Implementations of a crate should inherit the documentation of the\n-    /// parent trait if no extra documentation is specified, and default methods\n-    /// should show up in documentation about trait implementations.\n-    pub traits: FxHashMap<DefId, clean::Trait>,\n-\n-    /// When rendering traits, it's often useful to be able to list all\n-    /// implementors of the trait, and this mapping is exactly, that: a mapping\n-    /// of trait ids to the list of known implementors of the trait\n-    pub implementors: FxHashMap<DefId, Vec<Impl>>,\n-\n-    /// Cache of where external crate documentation can be found.\n-    pub extern_locations: FxHashMap<CrateNum, (String, PathBuf, ExternalLocation)>,\n-\n-    /// Cache of where documentation for primitives can be found.\n-    pub primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n-\n-    // Note that external items for which `doc(hidden)` applies to are shown as\n-    // non-reachable while local items aren't. This is because we're reusing\n-    // the access levels from the privacy check pass.\n-    pub access_levels: AccessLevels<DefId>,\n-\n-    /// The version of the crate being documented, if given from the `--crate-version` flag.\n-    pub crate_version: Option<String>,\n-\n-    /// Whether to document private items.\n-    /// This is stored in `Cache` so it doesn't need to be passed through all rustdoc functions.\n-    pub document_private: bool,\n-\n-    // Private fields only used when initially crawling a crate to build a cache\n-    stack: Vec<String>,\n-    parent_stack: Vec<DefId>,\n-    parent_is_trait_impl: bool,\n-    search_index: Vec<IndexItem>,\n-    stripped_mod: bool,\n-    pub deref_trait_did: Option<DefId>,\n-    pub deref_mut_trait_did: Option<DefId>,\n-    pub owned_box_did: Option<DefId>,\n-    masked_crates: FxHashSet<CrateNum>,\n-\n-    // In rare case where a structure is defined in one module but implemented\n-    // in another, if the implementing module is parsed before defining module,\n-    // then the fully qualified name of the structure isn't presented in `paths`\n-    // yet when its implementation methods are being indexed. Caches such methods\n-    // and their parent id here and indexes them at the end of crate parsing.\n-    orphan_impl_items: Vec<(DefId, clean::Item)>,\n-\n-    // Similarly to `orphan_impl_items`, sometimes trait impls are picked up\n-    // even though the trait itself is not exported. This can happen if a trait\n-    // was defined in function/expression scope, since the impl will be picked\n-    // up by `collect-trait-impls` but the trait won't be scraped out in the HIR\n-    // crawl. In order to prevent crashes when looking for spotlight traits or\n-    // when gathering trait documentation on a type, hold impls here while\n-    // folding and add them to the cache later on if we find the trait.\n-    orphan_trait_impls: Vec<(DefId, FxHashSet<DefId>, Impl)>,\n-\n-    /// Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n-    /// we need the alias element to have an array of items.\n-    pub(super) aliases: BTreeMap<String, Vec<usize>>,\n-}\n-\n-impl Cache {\n-    pub fn from_krate(\n-        renderinfo: RenderInfo,\n-        document_private: bool,\n-        extern_html_root_urls: &BTreeMap<String, String>,\n-        dst: &Path,\n-        mut krate: clean::Crate,\n-    ) -> (clean::Crate, String, Cache) {\n-        // Crawl the crate to build various caches used for the output\n-        let RenderInfo {\n-            inlined: _,\n-            external_paths,\n-            exact_paths,\n-            access_levels,\n-            deref_trait_did,\n-            deref_mut_trait_did,\n-            owned_box_did,\n-            ..\n-        } = renderinfo;\n-\n-        let external_paths =\n-            external_paths.into_iter().map(|(k, (v, t))| (k, (v, ItemType::from(t)))).collect();\n-\n-        let mut cache = Cache {\n-            impls: Default::default(),\n-            external_paths,\n-            exact_paths,\n-            paths: Default::default(),\n-            implementors: Default::default(),\n-            stack: Vec::new(),\n-            parent_stack: Vec::new(),\n-            search_index: Vec::new(),\n-            parent_is_trait_impl: false,\n-            extern_locations: Default::default(),\n-            primitive_locations: Default::default(),\n-            stripped_mod: false,\n-            access_levels,\n-            crate_version: krate.version.take(),\n-            document_private,\n-            orphan_impl_items: Vec::new(),\n-            orphan_trait_impls: Vec::new(),\n-            traits: krate.external_traits.replace(Default::default()),\n-            deref_trait_did,\n-            deref_mut_trait_did,\n-            owned_box_did,\n-            masked_crates: mem::take(&mut krate.masked_crates),\n-            aliases: Default::default(),\n-        };\n-\n-        // Cache where all our extern crates are located\n-        for &(n, ref e) in &krate.externs {\n-            let src_root = match e.src {\n-                FileName::Real(ref p) => match p.local_path().parent() {\n-                    Some(p) => p.to_path_buf(),\n-                    None => PathBuf::new(),\n-                },\n-                _ => PathBuf::new(),\n-            };\n-            let extern_url = extern_html_root_urls.get(&e.name).map(|u| &**u);\n-            cache\n-                .extern_locations\n-                .insert(n, (e.name.clone(), src_root, extern_location(e, extern_url, &dst)));\n-\n-            let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n-            cache.external_paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n-        }\n-\n-        // Cache where all known primitives have their documentation located.\n-        //\n-        // Favor linking to as local extern as possible, so iterate all crates in\n-        // reverse topological order.\n-        for &(_, ref e) in krate.externs.iter().rev() {\n-            for &(def_id, prim, _) in &e.primitives {\n-                cache.primitive_locations.insert(prim, def_id);\n-            }\n-        }\n-        for &(def_id, prim, _) in &krate.primitives {\n-            cache.primitive_locations.insert(prim, def_id);\n-        }\n-\n-        cache.stack.push(krate.name.clone());\n-        krate = cache.fold_crate(krate);\n-\n-        for (trait_did, dids, impl_) in cache.orphan_trait_impls.drain(..) {\n-            if cache.traits.contains_key(&trait_did) {\n-                for did in dids {\n-                    cache.impls.entry(did).or_insert(vec![]).push(impl_.clone());\n-                }\n-            }\n-        }\n-\n-        // Build our search index\n-        let index = build_index(&krate, &mut cache);\n-\n-        (krate, index, cache)\n-    }\n-}\n-\n-impl DocFolder for Cache {\n-    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        if item.def_id.is_local() {\n-            debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.def_id);\n-        }\n-\n-        // If this is a stripped module,\n-        // we don't want it or its children in the search index.\n-        let orig_stripped_mod = match item.inner {\n-            clean::StrippedItem(box clean::ModuleItem(..)) => {\n-                mem::replace(&mut self.stripped_mod, true)\n-            }\n-            _ => self.stripped_mod,\n-        };\n-\n-        // If the impl is from a masked crate or references something from a\n-        // masked crate then remove it completely.\n-        if let clean::ImplItem(ref i) = item.inner {\n-            if self.masked_crates.contains(&item.def_id.krate)\n-                || i.trait_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n-                || i.for_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n-            {\n-                return None;\n-            }\n-        }\n-\n-        // Propagate a trait method's documentation to all implementors of the\n-        // trait.\n-        if let clean::TraitItem(ref t) = item.inner {\n-            self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n-        }\n-\n-        // Collect all the implementors of traits.\n-        if let clean::ImplItem(ref i) = item.inner {\n-            if let Some(did) = i.trait_.def_id() {\n-                if i.blanket_impl.is_none() {\n-                    self.implementors\n-                        .entry(did)\n-                        .or_default()\n-                        .push(Impl { impl_item: item.clone() });\n-                }\n-            }\n-        }\n-\n-        // Index this method for searching later on.\n-        if let Some(ref s) = item.name {\n-            let (parent, is_inherent_impl_item) = match item.inner {\n-                clean::StrippedItem(..) => ((None, None), false),\n-                clean::AssocConstItem(..) | clean::TypedefItem(_, true)\n-                    if self.parent_is_trait_impl =>\n-                {\n-                    // skip associated items in trait impls\n-                    ((None, None), false)\n-                }\n-                clean::AssocTypeItem(..)\n-                | clean::TyMethodItem(..)\n-                | clean::StructFieldItem(..)\n-                | clean::VariantItem(..) => (\n-                    (\n-                        Some(*self.parent_stack.last().expect(\"parent_stack is empty\")),\n-                        Some(&self.stack[..self.stack.len() - 1]),\n-                    ),\n-                    false,\n-                ),\n-                clean::MethodItem(..) | clean::AssocConstItem(..) => {\n-                    if self.parent_stack.is_empty() {\n-                        ((None, None), false)\n-                    } else {\n-                        let last = self.parent_stack.last().expect(\"parent_stack is empty 2\");\n-                        let did = *last;\n-                        let path = match self.paths.get(&did) {\n-                            // The current stack not necessarily has correlation\n-                            // for where the type was defined. On the other\n-                            // hand, `paths` always has the right\n-                            // information if present.\n-                            Some(&(\n-                                ref fqp,\n-                                ItemType::Trait\n-                                | ItemType::Struct\n-                                | ItemType::Union\n-                                | ItemType::Enum,\n-                            )) => Some(&fqp[..fqp.len() - 1]),\n-                            Some(..) => Some(&*self.stack),\n-                            None => None,\n-                        };\n-                        ((Some(*last), path), true)\n-                    }\n-                }\n-                _ => ((None, Some(&*self.stack)), false),\n-            };\n-\n-            match parent {\n-                (parent, Some(path)) if is_inherent_impl_item || !self.stripped_mod => {\n-                    debug_assert!(!item.is_stripped());\n-\n-                    // A crate has a module at its root, containing all items,\n-                    // which should not be indexed. The crate-item itself is\n-                    // inserted later on when serializing the search-index.\n-                    if item.def_id.index != CRATE_DEF_INDEX {\n-                        self.search_index.push(IndexItem {\n-                            ty: item.type_(),\n-                            name: s.to_string(),\n-                            path: path.join(\"::\"),\n-                            desc: shorten(plain_summary_line(item.doc_value())),\n-                            parent,\n-                            parent_idx: None,\n-                            search_type: get_index_search_type(&item),\n-                        });\n-\n-                        for alias in item.attrs.get_doc_aliases() {\n-                            self.aliases\n-                                .entry(alias.to_lowercase())\n-                                .or_insert(Vec::new())\n-                                .push(self.search_index.len() - 1);\n-                        }\n-                    }\n-                }\n-                (Some(parent), None) if is_inherent_impl_item => {\n-                    // We have a parent, but we don't know where they're\n-                    // defined yet. Wait for later to index this item.\n-                    self.orphan_impl_items.push((parent, item.clone()));\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        // Keep track of the fully qualified path for this item.\n-        let pushed = match item.name {\n-            Some(ref n) if !n.is_empty() => {\n-                self.stack.push(n.to_string());\n-                true\n-            }\n-            _ => false,\n-        };\n-\n-        match item.inner {\n-            clean::StructItem(..)\n-            | clean::EnumItem(..)\n-            | clean::TypedefItem(..)\n-            | clean::TraitItem(..)\n-            | clean::FunctionItem(..)\n-            | clean::ModuleItem(..)\n-            | clean::ForeignFunctionItem(..)\n-            | clean::ForeignStaticItem(..)\n-            | clean::ConstantItem(..)\n-            | clean::StaticItem(..)\n-            | clean::UnionItem(..)\n-            | clean::ForeignTypeItem\n-            | clean::MacroItem(..)\n-            | clean::ProcMacroItem(..)\n-            | clean::VariantItem(..)\n-                if !self.stripped_mod =>\n-            {\n-                // Re-exported items mean that the same id can show up twice\n-                // in the rustdoc ast that we're looking at. We know,\n-                // however, that a re-exported item doesn't show up in the\n-                // `public_items` map, so we can skip inserting into the\n-                // paths map if there was already an entry present and we're\n-                // not a public item.\n-                if !self.paths.contains_key(&item.def_id)\n-                    || self.access_levels.is_public(item.def_id)\n-                {\n-                    self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n-                }\n-            }\n-            clean::PrimitiveItem(..) => {\n-                self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n-            }\n-\n-            _ => {}\n-        }\n-\n-        // Maintain the parent stack\n-        let orig_parent_is_trait_impl = self.parent_is_trait_impl;\n-        let parent_pushed = match item.inner {\n-            clean::TraitItem(..)\n-            | clean::EnumItem(..)\n-            | clean::ForeignTypeItem\n-            | clean::StructItem(..)\n-            | clean::UnionItem(..)\n-            | clean::VariantItem(..) => {\n-                self.parent_stack.push(item.def_id);\n-                self.parent_is_trait_impl = false;\n-                true\n-            }\n-            clean::ImplItem(ref i) => {\n-                self.parent_is_trait_impl = i.trait_.is_some();\n-                match i.for_ {\n-                    clean::ResolvedPath { did, .. } => {\n-                        self.parent_stack.push(did);\n-                        true\n-                    }\n-                    ref t => {\n-                        let prim_did = t\n-                            .primitive_type()\n-                            .and_then(|t| self.primitive_locations.get(&t).cloned());\n-                        match prim_did {\n-                            Some(did) => {\n-                                self.parent_stack.push(did);\n-                                true\n-                            }\n-                            None => false,\n-                        }\n-                    }\n-                }\n-            }\n-            _ => false,\n-        };\n-\n-        // Once we've recursively found all the generics, hoard off all the\n-        // implementations elsewhere.\n-        let ret = self.fold_item_recur(item).and_then(|item| {\n-            if let clean::Item { inner: clean::ImplItem(_), .. } = item {\n-                // Figure out the id of this impl. This may map to a\n-                // primitive rather than always to a struct/enum.\n-                // Note: matching twice to restrict the lifetime of the `i` borrow.\n-                let mut dids = FxHashSet::default();\n-                if let clean::Item { inner: clean::ImplItem(ref i), .. } = item {\n-                    match i.for_ {\n-                        clean::ResolvedPath { did, .. }\n-                        | clean::BorrowedRef {\n-                            type_: box clean::ResolvedPath { did, .. }, ..\n-                        } => {\n-                            dids.insert(did);\n-                        }\n-                        ref t => {\n-                            let did = t\n-                                .primitive_type()\n-                                .and_then(|t| self.primitive_locations.get(&t).cloned());\n-\n-                            if let Some(did) = did {\n-                                dids.insert(did);\n-                            }\n-                        }\n-                    }\n-\n-                    if let Some(generics) = i.trait_.as_ref().and_then(|t| t.generics()) {\n-                        for bound in generics {\n-                            if let Some(did) = bound.def_id() {\n-                                dids.insert(did);\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    unreachable!()\n-                };\n-                let impl_item = Impl { impl_item: item };\n-                if impl_item.trait_did().map_or(true, |d| self.traits.contains_key(&d)) {\n-                    for did in dids {\n-                        self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n-                    }\n-                } else {\n-                    let trait_did = impl_item.trait_did().expect(\"no trait did\");\n-                    self.orphan_trait_impls.push((trait_did, dids, impl_item));\n-                }\n-                None\n-            } else {\n-                Some(item)\n-            }\n-        });\n-\n-        if pushed {\n-            self.stack.pop().expect(\"stack already empty\");\n-        }\n-        if parent_pushed {\n-            self.parent_stack.pop().expect(\"parent stack already empty\");\n-        }\n-        self.stripped_mod = orig_stripped_mod;\n-        self.parent_is_trait_impl = orig_parent_is_trait_impl;\n-        ret\n-    }\n-}\n-\n /// Attempts to find where an external crate is located, given that we're\n /// rendering in to the specified source destination.\n-fn extern_location(\n+pub fn extern_location(\n     e: &clean::ExternalCrate,\n     extern_url: Option<&str>,\n     dst: &Path,\n@@ -539,7 +62,7 @@ fn extern_location(\n }\n \n /// Builds the search index from the collected metadata\n-fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n+pub fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     let mut defid_to_pathid = FxHashMap::default();\n     let mut crate_items = Vec::with_capacity(cache.search_index.len());\n     let mut crate_paths = vec![];\n@@ -641,7 +164,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     )\n }\n \n-fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n+crate fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n     let (all_types, ret_types) = match item.inner {\n         clean::FunctionItem(ref f) => (&f.all_types, &f.ret_types),\n         clean::MethodItem(ref m) => (&m.all_types, &m.ret_types),"}, {"sha": "1678cff16a96ef93e2f2a6c303294c5c2d2029e2", "filename": "src/librustdoc/html/render/mod.rs", "status": "renamed", "additions": 137, "deletions": 137, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=6a4396b98c6fcb405429a9798a9ab6554f015b7e", "patch": "@@ -25,6 +25,11 @@\n //! These threads are not parallelized (they haven't been a bottleneck yet), and\n //! both occur before the crate is rendered.\n \n+pub mod cache;\n+\n+#[cfg(test)]\n+mod tests;\n+\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering;\n@@ -63,24 +68,18 @@ use crate::config::RenderOptions;\n use crate::docfs::{DocFS, ErrorStorage, PathError};\n use crate::doctree;\n use crate::error::Error;\n-use crate::formats::{FormatRenderer, Renderer};\n+use crate::formats::cache::{cache, Cache};\n+use crate::formats::item_type::ItemType;\n+use crate::formats::{FormatRenderer, Impl};\n use crate::html::escape::Escape;\n use crate::html::format::fmt_impl_for_trait_page;\n use crate::html::format::Function;\n use crate::html::format::{href, print_default_space, print_generic_bounds, WhereClause};\n use crate::html::format::{print_abi_with_space, Buffer, PrintWithSpace};\n-use crate::html::item_type::ItemType;\n use crate::html::markdown::{self, ErrorCodes, IdMap, Markdown, MarkdownHtml, MarkdownSummaryLine};\n use crate::html::sources;\n use crate::html::{highlight, layout, static_files};\n-\n-#[cfg(test)]\n-mod tests;\n-\n-mod cache;\n-\n-use cache::Cache;\n-crate use cache::ExternalLocation::{self, *};\n+use cache::{build_index, ExternalLocation};\n \n /// A pair of name and its optional document.\n pub type NameDoc = (String, Option<String>);\n@@ -113,8 +112,6 @@ crate struct Context {\n     /// The map used to ensure all generated 'id=' attributes are unique.\n     id_map: Rc<RefCell<IdMap>>,\n     pub shared: Arc<SharedContext>,\n-    pub cache: Arc<Cache>,\n-    pub parent: Rc<RefCell<Renderer>>,\n     all: Rc<RefCell<AllTypes>>,\n     pub errors: Arc<ErrorStorage>,\n }\n@@ -196,39 +193,20 @@ impl SharedContext {\n     }\n }\n \n-/// Metadata about implementations for a type or trait.\n-#[derive(Clone, Debug)]\n-pub struct Impl {\n-    pub impl_item: clean::Item,\n-}\n-\n-impl Impl {\n-    fn inner_impl(&self) -> &clean::Impl {\n-        match self.impl_item.inner {\n-            clean::ImplItem(ref impl_) => impl_,\n-            _ => panic!(\"non-impl item found in impl\"),\n-        }\n-    }\n-\n-    fn trait_did(&self) -> Option<DefId> {\n-        self.inner_impl().trait_.def_id()\n-    }\n-}\n-\n // Helper structs for rendering items/sidebars and carrying along contextual\n // information\n \n /// Struct representing one entry in the JS search index. These are all emitted\n /// by hand to a large JS file at the end of cache-creation.\n #[derive(Debug)]\n-struct IndexItem {\n-    ty: ItemType,\n-    name: String,\n-    path: String,\n-    desc: String,\n-    parent: Option<DefId>,\n-    parent_idx: Option<usize>,\n-    search_type: Option<IndexItemFunctionType>,\n+pub struct IndexItem {\n+    pub ty: ItemType,\n+    pub name: String,\n+    pub path: String,\n+    pub desc: String,\n+    pub parent: Option<DefId>,\n+    pub parent_idx: Option<usize>,\n+    pub search_type: Option<IndexItemFunctionType>,\n }\n \n impl Serialize for IndexItem {\n@@ -250,7 +228,7 @@ impl Serialize for IndexItem {\n \n /// A type used for the search index.\n #[derive(Debug)]\n-struct RenderType {\n+pub struct RenderType {\n     ty: Option<DefId>,\n     idx: Option<usize>,\n     name: Option<String>,\n@@ -281,7 +259,7 @@ impl Serialize for RenderType {\n \n /// A type used for the search index.\n #[derive(Debug)]\n-struct Generic {\n+pub struct Generic {\n     name: String,\n     defid: Option<DefId>,\n     idx: Option<usize>,\n@@ -302,7 +280,7 @@ impl Serialize for Generic {\n \n /// Full type of functions/methods in the search index.\n #[derive(Debug)]\n-struct IndexItemFunctionType {\n+pub struct IndexItemFunctionType {\n     inputs: Vec<TypeWithKind>,\n     output: Option<Vec<TypeWithKind>>,\n }\n@@ -367,7 +345,6 @@ pub struct StylePath {\n     pub disabled: bool,\n }\n \n-thread_local!(static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n thread_local!(pub static CURRENT_DEPTH: Cell<usize> = Cell::new(0));\n \n pub fn initial_ids() -> Vec<String> {\n@@ -401,10 +378,9 @@ impl FormatRenderer for Context {\n     fn init(\n         mut krate: clean::Crate,\n         options: RenderOptions,\n-        renderinfo: RenderInfo,\n-        _diag: &rustc_errors::Handler,\n+        _renderinfo: RenderInfo,\n         edition: Edition,\n-        parent: Rc<RefCell<Renderer>>,\n+        cache: &mut Cache,\n     ) -> Result<(Context, clean::Crate), Error> {\n         // need to save a copy of the options for rendering the index page\n         let md_opts = options.clone();\n@@ -416,11 +392,9 @@ impl FormatRenderer for Context {\n             sort_modules_alphabetically,\n             themes: style_files,\n             extension_css,\n-            extern_html_root_urls,\n             resource_suffix,\n             static_root_path,\n             generate_search_filter,\n-            document_private,\n             ..\n         } = options;\n \n@@ -509,30 +483,26 @@ impl FormatRenderer for Context {\n         let dst = output;\n         scx.ensure_dir(&dst)?;\n         krate = sources::render(&dst, &mut scx, krate)?;\n-        let (new_crate, index, cache) =\n-            Cache::from_krate(renderinfo, document_private, &extern_html_root_urls, &dst, krate);\n-        krate = new_crate;\n+\n+        // Build our search index\n+        let index = build_index(&krate, cache);\n+\n         let cache = Arc::new(cache);\n         let mut cx = Context {\n             current: Vec::new(),\n             dst,\n             render_redirect_pages: false,\n             id_map: Rc::new(RefCell::new(id_map)),\n             shared: Arc::new(scx),\n-            cache: cache.clone(),\n-            parent,\n             all: Rc::new(RefCell::new(AllTypes::new())),\n             errors,\n         };\n \n-        // Freeze the cache now that the index has been built. Put an Arc into TLS\n-        // for future parallelization opportunities\n-        CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n         CURRENT_DEPTH.with(|s| s.set(0));\n \n         // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n         Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n-        write_shared(&cx, &krate, index, &md_opts)?;\n+        write_shared(&cx, &krate, index, &md_opts, &cache)?;\n         Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(false);\n         Ok((cx, krate))\n     }\n@@ -547,7 +517,7 @@ impl FormatRenderer for Context {\n         }\n     }\n \n-    fn after_krate(&mut self, krate: &clean::Crate) -> Result<(), Error> {\n+    fn after_krate(&mut self, krate: &clean::Crate, cache: &Cache) -> Result<(), Error> {\n         let final_file = self.dst.join(&krate.name).join(\"all.html\");\n         let settings_file = self.dst.join(\"settings.html\");\n         let crate_name = krate.name.clone();\n@@ -567,7 +537,7 @@ impl FormatRenderer for Context {\n             extra_scripts: &[],\n             static_extra_scripts: &[],\n         };\n-        let sidebar = if let Some(ref version) = self.cache.crate_version {\n+        let sidebar = if let Some(ref version) = cache.crate_version {\n             format!(\n                 \"<p class='location'>Crate {}</p>\\\n                      <div class='block version'>\\\n@@ -616,7 +586,7 @@ impl FormatRenderer for Context {\n         &mut self,\n         item: &clean::Item,\n         item_name: &str,\n-        module: &clean::Module,\n+        cache: &Cache,\n     ) -> Result<(), Error> {\n         // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n         // if they contain impls for public types. These modules can also\n@@ -634,7 +604,7 @@ impl FormatRenderer for Context {\n \n         info!(\"Recursing into {}\", self.dst.display());\n \n-        let buf = self.render_item(item, false);\n+        let buf = self.render_item(item, false, cache);\n         // buf will be empty if the module is stripped and there is no redirect for it\n         if !buf.is_empty() {\n             self.shared.ensure_dir(&self.dst)?;\n@@ -644,6 +614,10 @@ impl FormatRenderer for Context {\n \n         // Render sidebar-items.js used throughout this module.\n         if !self.render_redirect_pages {\n+            let module = match item.inner {\n+                clean::StrippedItem(box clean::ModuleItem(ref m)) | clean::ModuleItem(ref m) => m,\n+                _ => unreachable!(),\n+            };\n             let items = self.build_sidebar_items(module);\n             let js_dst = self.dst.join(\"sidebar-items.js\");\n             let v = format!(\"initSidebarItems({});\", serde_json::to_string(&items).unwrap());\n@@ -652,7 +626,7 @@ impl FormatRenderer for Context {\n         Ok(())\n     }\n \n-    fn mod_item_out(&mut self) -> Result<(), Error> {\n+    fn mod_item_out(&mut self, _name: &str) -> Result<(), Error> {\n         info!(\"Recursed; leaving {}\", self.dst.display());\n \n         // Go back to where we were at\n@@ -661,7 +635,7 @@ impl FormatRenderer for Context {\n         Ok(())\n     }\n \n-    fn item(&mut self, item: clean::Item) -> Result<(), Error> {\n+    fn item(&mut self, item: clean::Item, cache: &Cache) -> Result<(), Error> {\n         // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n         // if they contain impls for public types. These modules can also\n         // contain items such as publicly re-exported structures.\n@@ -673,7 +647,7 @@ impl FormatRenderer for Context {\n             self.render_redirect_pages = item.is_stripped();\n         }\n \n-        let buf = self.render_item(&item, true);\n+        let buf = self.render_item(&item, true, cache);\n         // buf will be empty if the item is stripped and there is no redirect for it\n         if !buf.is_empty() {\n             let name = item.name.as_ref().unwrap();\n@@ -704,6 +678,7 @@ fn write_shared(\n     krate: &clean::Crate,\n     search_index: String,\n     options: &RenderOptions,\n+    cache: &Cache,\n ) -> Result<(), Error> {\n     // Write out the shared files. Note that these are shared among all rustdoc\n     // docs placed in the output directory, so this needs to be a synchronized\n@@ -1101,17 +1076,17 @@ themePicker.onblur = handleThemeButtonsBlur;\n \n     // Update the list of all implementors for traits\n     let dst = cx.dst.join(\"implementors\");\n-    for (&did, imps) in &cx.cache.implementors {\n+    for (&did, imps) in &cache.implementors {\n         // Private modules can leak through to this phase of rustdoc, which\n         // could contain implementations for otherwise private types. In some\n         // rare cases we could find an implementation for an item which wasn't\n         // indexed, so we just skip this step in that case.\n         //\n         // FIXME: this is a vague explanation for why this can't be a `get`, in\n         //        theory it should be...\n-        let &(ref remote_path, remote_item_type) = match cx.cache.paths.get(&did) {\n+        let &(ref remote_path, remote_item_type) = match cache.paths.get(&did) {\n             Some(p) => p,\n-            None => match cx.cache.external_paths.get(&did) {\n+            None => match cache.external_paths.get(&did) {\n                 Some(p) => p,\n                 None => continue,\n             },\n@@ -1149,7 +1124,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n         // Only create a js file if we have impls to add to it. If the trait is\n         // documented locally though we always create the file to avoid dead\n         // links.\n-        if implementors.is_empty() && !cx.cache.paths.contains_key(&did) {\n+        if implementors.is_empty() && !cache.paths.contains_key(&did) {\n             continue;\n         }\n \n@@ -1454,7 +1429,7 @@ impl Context {\n         \"../\".repeat(self.current.len())\n     }\n \n-    fn render_item(&self, it: &clean::Item, pushname: bool) -> String {\n+    fn render_item(&self, it: &clean::Item, pushname: bool, cache: &Cache) -> String {\n         // A little unfortunate that this is done like this, but it sure\n         // does make formatting *a lot* nicer.\n         CURRENT_DEPTH.with(|slot| {\n@@ -1507,13 +1482,13 @@ impl Context {\n             layout::render(\n                 &self.shared.layout,\n                 &page,\n-                |buf: &mut _| print_sidebar(self, it, buf),\n-                |buf: &mut _| print_item(self, it, buf),\n+                |buf: &mut _| print_sidebar(self, it, buf, cache),\n+                |buf: &mut _| print_item(self, it, buf, cache),\n                 &self.shared.style_files,\n             )\n         } else {\n             let mut url = self.root_path();\n-            if let Some(&(ref names, ty)) = self.cache.paths.get(&it.def_id) {\n+            if let Some(&(ref names, ty)) = cache.paths.get(&it.def_id) {\n                 for name in &names[..names.len() - 1] {\n                     url.push_str(name);\n                     url.push_str(\"/\");\n@@ -1552,9 +1527,7 @@ impl Context {\n         }\n         map\n     }\n-}\n \n-impl Context {\n     /// Generates a url appropriate for an `href` attribute back to the source of\n     /// this item.\n     ///\n@@ -1564,7 +1537,7 @@ impl Context {\n     /// If `None` is returned, then a source link couldn't be generated. This\n     /// may happen, for example, with externally inlined items where the source\n     /// of their crate documentation isn't known.\n-    fn src_href(&self, item: &clean::Item) -> Option<String> {\n+    fn src_href(&self, item: &clean::Item, cache: &Cache) -> Option<String> {\n         let mut root = self.root_path();\n \n         let mut path = String::new();\n@@ -1583,13 +1556,13 @@ impl Context {\n                 return None;\n             }\n         } else {\n-            let (krate, src_root) = match *self.cache.extern_locations.get(&item.source.cnum)? {\n-                (ref name, ref src, Local) => (name, src),\n-                (ref name, ref src, Remote(ref s)) => {\n+            let (krate, src_root) = match *cache.extern_locations.get(&item.source.cnum)? {\n+                (ref name, ref src, ExternalLocation::Local) => (name, src),\n+                (ref name, ref src, ExternalLocation::Remote(ref s)) => {\n                     root = s.to_string();\n                     (name, src)\n                 }\n-                (_, _, Unknown) => return None,\n+                (_, _, ExternalLocation::Unknown) => return None,\n             };\n \n             sources::clean_path(&src_root, file, false, |component| {\n@@ -1626,7 +1599,7 @@ where\n     write!(w, \"</div>\")\n }\n \n-fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer) {\n+fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer, cache: &Cache) {\n     debug_assert!(!item.is_stripped());\n     // Write the breadcrumb trail header for the top\n     write!(buf, \"<h1 class='fqn'><span class='out-of-band'>\");\n@@ -1654,7 +1627,7 @@ fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer) {\n     // this page, and this link will be auto-clicked. The `id` attribute is\n     // used to find the link to auto-click.\n     if cx.shared.include_sources && !item.is_primitive() {\n-        if let Some(l) = cx.src_href(item) {\n+        if let Some(l) = cx.src_href(item, cache) {\n             write!(buf, \"<a class='srclink' href='{}' title='{}'>[src]</a>\", l, \"goto source code\");\n         }\n     }\n@@ -1715,20 +1688,20 @@ fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer) {\n         clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) => {\n             item_function(buf, cx, item, f)\n         }\n-        clean::TraitItem(ref t) => item_trait(buf, cx, item, t),\n-        clean::StructItem(ref s) => item_struct(buf, cx, item, s),\n-        clean::UnionItem(ref s) => item_union(buf, cx, item, s),\n-        clean::EnumItem(ref e) => item_enum(buf, cx, item, e),\n-        clean::TypedefItem(ref t, _) => item_typedef(buf, cx, item, t),\n+        clean::TraitItem(ref t) => item_trait(buf, cx, item, t, cache),\n+        clean::StructItem(ref s) => item_struct(buf, cx, item, s, cache),\n+        clean::UnionItem(ref s) => item_union(buf, cx, item, s, cache),\n+        clean::EnumItem(ref e) => item_enum(buf, cx, item, e, cache),\n+        clean::TypedefItem(ref t, _) => item_typedef(buf, cx, item, t, cache),\n         clean::MacroItem(ref m) => item_macro(buf, cx, item, m),\n         clean::ProcMacroItem(ref m) => item_proc_macro(buf, cx, item, m),\n-        clean::PrimitiveItem(_) => item_primitive(buf, cx, item),\n+        clean::PrimitiveItem(_) => item_primitive(buf, cx, item, cache),\n         clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) => item_static(buf, cx, item, i),\n         clean::ConstantItem(ref c) => item_constant(buf, cx, item, c),\n-        clean::ForeignTypeItem => item_foreign_type(buf, cx, item),\n+        clean::ForeignTypeItem => item_foreign_type(buf, cx, item, cache),\n         clean::KeywordItem(_) => item_keyword(buf, cx, item),\n-        clean::OpaqueTyItem(ref e, _) => item_opaque_ty(buf, cx, item, e),\n-        clean::TraitAliasItem(ref ta) => item_trait_alias(buf, cx, item, ta),\n+        clean::OpaqueTyItem(ref e, _) => item_opaque_ty(buf, cx, item, e, cache),\n+        clean::TraitAliasItem(ref ta) => item_trait_alias(buf, cx, item, ta, cache),\n         _ => {\n             // We don't generate pages for any other type.\n             unreachable!();\n@@ -1751,7 +1724,7 @@ fn full_path(cx: &Context, item: &clean::Item) -> String {\n }\n \n #[inline]\n-fn plain_summary_line(s: Option<&str>) -> String {\n+crate fn plain_summary_line(s: Option<&str>) -> String {\n     let s = s.unwrap_or(\"\");\n     // This essentially gets the first paragraph of text in one line.\n     let mut line = s\n@@ -1768,7 +1741,7 @@ fn plain_summary_line(s: Option<&str>) -> String {\n     markdown::plain_summary_line(&line[..])\n }\n \n-fn shorten(s: String) -> String {\n+crate fn shorten(s: String) -> String {\n     if s.chars().count() > 60 {\n         let mut len = 0;\n         let mut ret = s\n@@ -2338,6 +2311,7 @@ fn render_implementor(\n     w: &mut Buffer,\n     implementor_dups: &FxHashMap<&str, (DefId, bool)>,\n     aliases: &[String],\n+    cache: &Cache,\n ) {\n     // If there's already another implementor that has the same abbridged name, use the\n     // full path, for example in `std::iter::ExactSizeIterator`\n@@ -2361,10 +2335,17 @@ fn render_implementor(\n         false,\n         false,\n         aliases,\n+        cache,\n     );\n }\n \n-fn render_impls(cx: &Context, w: &mut Buffer, traits: &[&&Impl], containing_item: &clean::Item) {\n+fn render_impls(\n+    cx: &Context,\n+    w: &mut Buffer,\n+    traits: &[&&Impl],\n+    containing_item: &clean::Item,\n+    cache: &Cache,\n+) {\n     let mut impls = traits\n         .iter()\n         .map(|i| {\n@@ -2383,6 +2364,7 @@ fn render_impls(cx: &Context, w: &mut Buffer, traits: &[&&Impl], containing_item\n                 false,\n                 true,\n                 &[],\n+                cache,\n             );\n             buffer.into_inner()\n         })\n@@ -2415,7 +2397,7 @@ fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl) -> Ordering {\n     name_key(&lhs).cmp(&name_key(&rhs))\n }\n \n-fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait) {\n+fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait, cache: &Cache) {\n     let bounds = bounds(&t.bounds, false);\n     let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n     let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n@@ -2575,9 +2557,9 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All);\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache);\n \n-    if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n+    if let Some(implementors) = cache.implementors.get(&it.def_id) {\n         // The DefId is for the first Type found with that name. The bool is\n         // if any Types with the same name but different DefId have been found.\n         let mut implementor_dups: FxHashMap<&str, (DefId, bool)> = FxHashMap::default();\n@@ -2599,7 +2581,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n         }\n \n         let (local, foreign) = implementors.iter().partition::<Vec<_>, _>(|i| {\n-            i.inner_impl().for_.def_id().map_or(true, |d| cx.cache.paths.contains_key(&d))\n+            i.inner_impl().for_.def_id().map_or(true, |d| cache.paths.contains_key(&d))\n         });\n \n         let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n@@ -2628,6 +2610,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n                     true,\n                     false,\n                     &[],\n+                    cache,\n                 );\n             }\n             write_loading_content(w, \"\");\n@@ -2640,7 +2623,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n             \"<div class='item-list' id='implementors-list'>\",\n         );\n         for implementor in concrete {\n-            render_implementor(cx, implementor, w, &implementor_dups, &[]);\n+            render_implementor(cx, implementor, w, &implementor_dups, &[], cache);\n         }\n         write_loading_content(w, \"</div>\");\n \n@@ -2658,6 +2641,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n                     w,\n                     &implementor_dups,\n                     &collect_paths_for_type(implementor.inner_impl().for_.clone()),\n+                    cache,\n                 );\n             }\n             write_loading_content(w, \"</div>\");\n@@ -2693,7 +2677,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n         path = if it.def_id.is_local() {\n             cx.current.join(\"/\")\n         } else {\n-            let (ref path, _) = cx.cache.external_paths[&it.def_id];\n+            let (ref path, _) = cache.external_paths[&it.def_id];\n             path[..path.len() - 1].join(\"/\")\n         },\n         ty = it.type_(),\n@@ -2702,7 +2686,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n }\n \n fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>) -> String {\n-    use crate::html::item_type::ItemType::*;\n+    use crate::formats::item_type::ItemType::*;\n \n     let name = it.name.as_ref().unwrap();\n     let ty = match it.type_() {\n@@ -2868,7 +2852,7 @@ fn render_assoc_item(\n     }\n }\n \n-fn item_struct(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Struct) {\n+fn item_struct(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Struct, cache: &Cache) {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class='rust struct'>\");\n         render_attributes(w, it, true);\n@@ -2915,10 +2899,10 @@ fn item_struct(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Struct\n             }\n         }\n     }\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union) {\n+fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union, cache: &Cache) {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class='rust union'>\");\n         render_attributes(w, it, true);\n@@ -2961,10 +2945,10 @@ fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union)\n             document(w, cx, field);\n         }\n     }\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n+fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum, cache: &Cache) {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class='rust enum'>\");\n         render_attributes(w, it, true);\n@@ -3089,7 +3073,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n             render_stability_since(w, variant, it);\n         }\n     }\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n const ALLOWED_ATTRIBUTES: &[Symbol] = &[\n@@ -3288,9 +3272,9 @@ fn render_assoc_items(\n     containing_item: &clean::Item,\n     it: DefId,\n     what: AssocItemRender<'_>,\n+    cache: &Cache,\n ) {\n-    let c = &cx.cache;\n-    let v = match c.impls.get(&it) {\n+    let v = match cache.impls.get(&it) {\n         Some(v) => v,\n         None => return,\n     };\n@@ -3336,6 +3320,7 @@ fn render_assoc_items(\n                 false,\n                 true,\n                 &[],\n+                cache,\n             );\n         }\n     }\n@@ -3344,11 +3329,11 @@ fn render_assoc_items(\n     }\n     if !traits.is_empty() {\n         let deref_impl =\n-            traits.iter().find(|t| t.inner_impl().trait_.def_id() == c.deref_trait_did);\n+            traits.iter().find(|t| t.inner_impl().trait_.def_id() == cache.deref_trait_did);\n         if let Some(impl_) = deref_impl {\n             let has_deref_mut =\n-                traits.iter().any(|t| t.inner_impl().trait_.def_id() == c.deref_mut_trait_did);\n-            render_deref_methods(w, cx, impl_, containing_item, has_deref_mut);\n+                traits.iter().any(|t| t.inner_impl().trait_.def_id() == cache.deref_mut_trait_did);\n+            render_deref_methods(w, cx, impl_, containing_item, has_deref_mut, cache);\n         }\n \n         let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n@@ -3357,7 +3342,7 @@ fn render_assoc_items(\n             concrete.into_iter().partition(|t| t.inner_impl().blanket_impl.is_some());\n \n         let mut impls = Buffer::empty_from(&w);\n-        render_impls(cx, &mut impls, &concrete, containing_item);\n+        render_impls(cx, &mut impls, &concrete, containing_item, cache);\n         let impls = impls.into_inner();\n         if !impls.is_empty() {\n             write!(\n@@ -3382,7 +3367,7 @@ fn render_assoc_items(\n                 <div id='synthetic-implementations-list'>\\\n             \"\n             );\n-            render_impls(cx, w, &synthetic, containing_item);\n+            render_impls(cx, w, &synthetic, containing_item, cache);\n             write!(w, \"</div>\");\n         }\n \n@@ -3397,7 +3382,7 @@ fn render_assoc_items(\n                 <div id='blanket-implementations-list'>\\\n             \"\n             );\n-            render_impls(cx, w, &blanket_impl, containing_item);\n+            render_impls(cx, w, &blanket_impl, containing_item, cache);\n             write!(w, \"</div>\");\n         }\n     }\n@@ -3409,6 +3394,7 @@ fn render_deref_methods(\n     impl_: &Impl,\n     container_item: &clean::Item,\n     deref_mut: bool,\n+    cache: &Cache,\n ) {\n     let deref_type = impl_.inner_impl().trait_.as_ref().unwrap();\n     let (target, real_target) = impl_\n@@ -3426,11 +3412,11 @@ fn render_deref_methods(\n     let what =\n         AssocItemRender::DerefFor { trait_: deref_type, type_: real_target, deref_mut_: deref_mut };\n     if let Some(did) = target.def_id() {\n-        render_assoc_items(w, cx, container_item, did, what);\n+        render_assoc_items(w, cx, container_item, did, what, cache);\n     } else {\n         if let Some(prim) = target.primitive_type() {\n-            if let Some(&did) = cx.cache.primitive_locations.get(&prim) {\n-                render_assoc_items(w, cx, container_item, did, what);\n+            if let Some(&did) = cache.primitive_locations.get(&prim) {\n+                render_assoc_items(w, cx, container_item, did, what, cache);\n             }\n         }\n     }\n@@ -3532,6 +3518,7 @@ fn render_impl(\n     // This argument is used to reference same type with different paths to avoid duplication\n     // in documentation pages for trait with automatic implementations like \"Send\" and \"Sync\".\n     aliases: &[String],\n+    cache: &Cache,\n ) {\n     if render_mode == RenderMode::Normal {\n         let id = cx.derive_id(match i.inner_impl().trait_ {\n@@ -3574,7 +3561,7 @@ fn render_impl(\n         write!(w, \"<a href='#{}' class='anchor'></a>\", id);\n         let since = i.impl_item.stability.as_ref().map(|s| &s.since[..]);\n         render_stability_since_raw(w, since, outer_version);\n-        if let Some(l) = cx.src_href(&i.impl_item) {\n+        if let Some(l) = cx.src_href(&i.impl_item, cache) {\n             write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a>\", l, \"goto source code\");\n         }\n         write!(w, \"</h3>\");\n@@ -3606,6 +3593,7 @@ fn render_impl(\n         outer_version: Option<&str>,\n         trait_: Option<&clean::Trait>,\n         show_def_docs: bool,\n+        cache: &Cache,\n     ) {\n         let item_type = item.type_();\n         let name = item.name.as_ref().unwrap();\n@@ -3634,7 +3622,7 @@ fn render_impl(\n                     render_assoc_item(w, item, link.anchor(&id), ItemType::Impl);\n                     write!(w, \"</code>\");\n                     render_stability_since_raw(w, item.stable_since(), outer_version);\n-                    if let Some(l) = cx.src_href(item) {\n+                    if let Some(l) = cx.src_href(item, cache) {\n                         write!(\n                             w,\n                             \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n@@ -3656,7 +3644,7 @@ fn render_impl(\n                 assoc_const(w, item, ty, default.as_ref(), link.anchor(&id), \"\");\n                 write!(w, \"</code>\");\n                 render_stability_since_raw(w, item.stable_since(), outer_version);\n-                if let Some(l) = cx.src_href(item) {\n+                if let Some(l) = cx.src_href(item, cache) {\n                     write!(\n                         w,\n                         \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n@@ -3707,7 +3695,7 @@ fn render_impl(\n         }\n     }\n \n-    let traits = &cx.cache.traits;\n+    let traits = &cache.traits;\n     let trait_ = i.trait_did().map(|did| &traits[&did]);\n \n     write!(w, \"<div class='impl-items'>\");\n@@ -3722,6 +3710,7 @@ fn render_impl(\n             outer_version,\n             trait_,\n             show_def_docs,\n+            cache,\n         );\n     }\n \n@@ -3733,6 +3722,7 @@ fn render_impl(\n         render_mode: RenderMode,\n         outer_version: Option<&str>,\n         show_def_docs: bool,\n+        cache: &Cache,\n     ) {\n         for trait_item in &t.items {\n             let n = trait_item.name.clone();\n@@ -3752,6 +3742,7 @@ fn render_impl(\n                 outer_version,\n                 None,\n                 show_def_docs,\n+                cache,\n             );\n         }\n     }\n@@ -3770,13 +3761,20 @@ fn render_impl(\n                 render_mode,\n                 outer_version,\n                 show_def_docs,\n+                cache,\n             );\n         }\n     }\n     write!(w, \"</div>\");\n }\n \n-fn item_opaque_ty(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::OpaqueTy) {\n+fn item_opaque_ty(\n+    w: &mut Buffer,\n+    cx: &Context,\n+    it: &clean::Item,\n+    t: &clean::OpaqueTy,\n+    cache: &Cache,\n+) {\n     write!(w, \"<pre class='rust opaque'>\");\n     render_attributes(w, it, false);\n     write!(\n@@ -3794,10 +3792,16 @@ fn item_opaque_ty(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Opa\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn item_trait_alias(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::TraitAlias) {\n+fn item_trait_alias(\n+    w: &mut Buffer,\n+    cx: &Context,\n+    it: &clean::Item,\n+    t: &clean::TraitAlias,\n+    cache: &Cache,\n+) {\n     write!(w, \"<pre class='rust trait-alias'>\");\n     render_attributes(w, it, false);\n     write!(\n@@ -3815,10 +3819,10 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::T\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn item_typedef(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Typedef) {\n+fn item_typedef(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Typedef, cache: &Cache) {\n     write!(w, \"<pre class='rust typedef'>\");\n     render_attributes(w, it, false);\n     write!(\n@@ -3836,10 +3840,10 @@ fn item_typedef(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Typed\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn item_foreign_type(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n+fn item_foreign_type(w: &mut Buffer, cx: &Context, it: &clean::Item, cache: &Cache) {\n     writeln!(w, \"<pre class='rust foreigntype'>extern {{\");\n     render_attributes(w, it, false);\n     write!(\n@@ -3851,10 +3855,10 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n \n     document(w, cx, it);\n \n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer) {\n+fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer, cache: &Cache) {\n     let parentlen = cx.current.len() - if it.is_mod() { 1 } else { 0 };\n \n     if it.is_struct()\n@@ -3889,7 +3893,7 @@ fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer) {\n     }\n \n     if it.is_crate() {\n-        if let Some(ref version) = cx.cache.crate_version {\n+        if let Some(ref version) = cache.crate_version {\n             write!(\n                 buffer,\n                 \"<div class='block version'>\\\n@@ -4526,9 +4530,9 @@ fn item_proc_macro(w: &mut Buffer, cx: &Context, it: &clean::Item, m: &clean::Pr\n     document(w, cx, it)\n }\n \n-fn item_primitive(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n+fn item_primitive(w: &mut Buffer, cx: &Context, it: &clean::Item, cache: &Cache) {\n     document(w, cx, it);\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n fn item_keyword(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n@@ -4593,7 +4597,3 @@ fn collect_paths_for_type(first_ty: clean::Type) -> Vec<String> {\n     }\n     out\n }\n-\n-crate fn cache() -> Arc<Cache> {\n-    CACHE_KEY.with(|c| c.borrow().clone())\n-}", "previous_filename": "src/librustdoc/html/render.rs"}, {"sha": "0de9c6336bbd854312f730d42c3a2509ed473b24", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a4396b98c6fcb405429a9798a9ab6554f015b7e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=6a4396b98c6fcb405429a9798a9ab6554f015b7e", "patch": "@@ -66,19 +66,8 @@ mod doctree;\n #[macro_use]\n mod error;\n mod fold;\n-mod formats;\n-pub mod html {\n-    crate mod escape;\n-    crate mod format;\n-    crate mod highlight;\n-    crate mod item_type;\n-    crate mod layout;\n-    pub mod markdown;\n-    crate mod render;\n-    crate mod sources;\n-    crate mod static_files;\n-    crate mod toc;\n-}\n+crate mod formats;\n+crate mod html;\n mod markdown;\n mod passes;\n mod test;"}]}