{"sha": "17c8f8bd0cc1bd58f6adbf0ca954ec326f8ef8c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3YzhmOGJkMGNjMWJkNThmNmFkYmYwY2E5NTRlYzMyNmY4ZWY4YzY=", "commit": {"author": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2013-08-25T13:47:24Z"}, "committer": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2013-08-25T13:47:24Z"}, "message": "bigint: inlining small functions", "tree": {"sha": "8d781aefc9a03e73797091966386557448d24362", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d781aefc9a03e73797091966386557448d24362"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17c8f8bd0cc1bd58f6adbf0ca954ec326f8ef8c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17c8f8bd0cc1bd58f6adbf0ca954ec326f8ef8c6", "html_url": "https://github.com/rust-lang/rust/commit/17c8f8bd0cc1bd58f6adbf0ca954ec326f8ef8c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17c8f8bd0cc1bd58f6adbf0ca954ec326f8ef8c6/comments", "author": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b247d176297f85c01e89c64d6058dbdd539cb95a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b247d176297f85c01e89c64d6058dbdd539cb95a", "html_url": "https://github.com/rust-lang/rust/commit/b247d176297f85c01e89c64d6058dbdd539cb95a"}], "stats": {"total": 189, "additions": 92, "deletions": 97}, "files": [{"sha": "00eec3e9ac448312d288e935819a87dbdb94b4d7", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 92, "deletions": 97, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/17c8f8bd0cc1bd58f6adbf0ca954ec326f8ef8c6/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17c8f8bd0cc1bd58f6adbf0ca954ec326f8ef8c6/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=17c8f8bd0cc1bd58f6adbf0ca954ec326f8ef8c6", "patch": "@@ -58,19 +58,19 @@ pub mod BigDigit {\n     static hi_mask: uint = (-1 as uint) << bits;\n     static lo_mask: uint = (-1 as uint) >> bits;\n \n-\n+    #[inline]\n     fn get_hi(n: uint) -> BigDigit { (n >> bits) as BigDigit }\n-\n+    #[inline]\n     fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n \n     /// Split one machine sized unsigned integer into two BigDigits.\n-\n+    #[inline]\n     pub fn from_uint(n: uint) -> (BigDigit, BigDigit) {\n         (get_hi(n), get_lo(n))\n     }\n \n     /// Join two BigDigits into one machine sized unsigned integer\n-\n+    #[inline]\n     pub fn to_uint(hi: BigDigit, lo: BigDigit) -> uint {\n         (lo as uint) | ((hi as uint) << bits)\n     }\n@@ -88,24 +88,26 @@ pub struct BigUint {\n }\n \n impl Eq for BigUint {\n+    #[inline]\n     fn eq(&self, other: &BigUint) -> bool { self.equals(other) }\n }\n \n impl TotalEq for BigUint {\n+    #[inline]\n     fn equals(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Equal => true, _ => false }\n     }\n }\n \n impl Ord for BigUint {\n-\n+    #[inline]\n     fn lt(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Less => true, _ => false}\n     }\n }\n \n impl TotalOrd for BigUint {\n-\n+    #[inline]\n     fn cmp(&self, other: &BigUint) -> Ordering {\n         let (s_len, o_len) = (self.data.len(), other.data.len());\n         if s_len < o_len { return Less; }\n@@ -120,12 +122,12 @@ impl TotalOrd for BigUint {\n }\n \n impl ToStr for BigUint {\n-\n+    #[inline]\n     fn to_str(&self) -> ~str { self.to_str_radix(10) }\n }\n \n impl FromStr for BigUint {\n-\n+    #[inline]\n     fn from_str(s: &str) -> Option<BigUint> {\n         FromStrRadix::from_str_radix(s, 10)\n     }\n@@ -134,25 +136,25 @@ impl FromStr for BigUint {\n impl Num for BigUint {}\n \n impl Orderable for BigUint {\n-\n+    #[inline]\n     fn min(&self, other: &BigUint) -> BigUint {\n         if self < other { self.clone() } else { other.clone() }\n     }\n \n-\n+    #[inline]\n     fn max(&self, other: &BigUint) -> BigUint {\n         if self > other { self.clone() } else { other.clone() }\n     }\n \n-\n+    #[inline]\n     fn clamp(&self, mn: &BigUint, mx: &BigUint) -> BigUint {\n         if self > mx { mx.clone() } else\n         if self < mn { mn.clone() } else { self.clone() }\n     }\n }\n \n impl Shl<uint, BigUint> for BigUint {\n-\n+    #[inline]\n     fn shl(&self, rhs: &uint) -> BigUint {\n         let n_unit = *rhs / BigDigit::bits;\n         let n_bits = *rhs % BigDigit::bits;\n@@ -161,7 +163,7 @@ impl Shl<uint, BigUint> for BigUint {\n }\n \n impl Shr<uint, BigUint> for BigUint {\n-\n+    #[inline]\n     fn shr(&self, rhs: &uint) -> BigUint {\n         let n_unit = *rhs / BigDigit::bits;\n         let n_bits = *rhs % BigDigit::bits;\n@@ -170,22 +172,21 @@ impl Shr<uint, BigUint> for BigUint {\n }\n \n impl Zero for BigUint {\n-\n+    #[inline]\n     fn zero() -> BigUint { BigUint::new(~[]) }\n \n-\n+    #[inline]\n     fn is_zero(&self) -> bool { self.data.is_empty() }\n }\n \n impl One for BigUint {\n-\n+    #[inline]\n     fn one() -> BigUint { BigUint::new(~[1]) }\n }\n \n impl Unsigned for BigUint {}\n \n impl Add<BigUint, BigUint> for BigUint {\n-\n     fn add(&self, other: &BigUint) -> BigUint {\n         let new_len = num::max(self.data.len(), other.data.len());\n \n@@ -205,7 +206,6 @@ impl Add<BigUint, BigUint> for BigUint {\n }\n \n impl Sub<BigUint, BigUint> for BigUint {\n-\n     fn sub(&self, other: &BigUint) -> BigUint {\n         let new_len = num::max(self.data.len(), other.data.len());\n \n@@ -278,14 +278,14 @@ impl Mul<BigUint, BigUint> for BigUint {\n             return BigUint::new(prod);\n         }\n \n-\n+        #[inline]\n         fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n             let mid = num::min(a.data.len(), n);\n             return (BigUint::from_slice(a.data.slice(mid, a.data.len())),\n                     BigUint::from_slice(a.data.slice(0, mid)));\n         }\n \n-\n+        #[inline]\n         fn sub_sign(a: BigUint, b: BigUint) -> (Ordering, BigUint) {\n             match a.cmp(&b) {\n                 Less    => (Less,    b - a),\n@@ -297,45 +297,44 @@ impl Mul<BigUint, BigUint> for BigUint {\n }\n \n impl Div<BigUint, BigUint> for BigUint {\n-\n+    #[inline]\n     fn div(&self, other: &BigUint) -> BigUint {\n         let (q, _) = self.div_rem(other);\n         return q;\n     }\n }\n \n impl Rem<BigUint, BigUint> for BigUint {\n-\n+    #[inline]\n     fn rem(&self, other: &BigUint) -> BigUint {\n         let (_, r) = self.div_rem(other);\n         return r;\n     }\n }\n \n impl Neg<BigUint> for BigUint {\n-\n+    #[inline]\n     fn neg(&self) -> BigUint { fail!() }\n }\n \n impl Integer for BigUint {\n-\n+    #[inline]\n     fn div_rem(&self, other: &BigUint) -> (BigUint, BigUint) {\n         self.div_mod_floor(other)\n     }\n \n-\n+    #[inline]\n     fn div_floor(&self, other: &BigUint) -> BigUint {\n         let (d, _) = self.div_mod_floor(other);\n         return d;\n     }\n \n-\n+    #[inline]\n     fn mod_floor(&self, other: &BigUint) -> BigUint {\n         let (_, m) = self.div_mod_floor(other);\n         return m;\n     }\n \n-\n     fn div_mod_floor(&self, other: &BigUint) -> (BigUint, BigUint) {\n         if other.is_zero() { fail!() }\n         if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n@@ -423,7 +422,7 @@ impl Integer for BigUint {\n      *\n      * The result is always positive\n      */\n-\n+    #[inline]\n     fn gcd(&self, other: &BigUint) -> BigUint {\n         // Use Euclid's algorithm\n         let mut m = (*self).clone();\n@@ -439,15 +438,15 @@ impl Integer for BigUint {\n     /**\n      * Calculates the Lowest Common Multiple (LCM) of the number and `other`\n      */\n-\n+    #[inline]\n     fn lcm(&self, other: &BigUint) -> BigUint { ((*self * *other) / self.gcd(other)) }\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n-\n+    #[inline]\n     fn is_multiple_of(&self, other: &BigUint) -> bool { (*self % *other).is_zero() }\n \n     /// Returns `true` if the number is divisible by `2`\n-\n+    #[inline]\n     fn is_even(&self) -> bool {\n         // Considering only the last digit.\n         if self.data.is_empty() {\n@@ -458,24 +457,23 @@ impl Integer for BigUint {\n     }\n \n     /// Returns `true` if the number is not divisible by `2`\n-\n+    #[inline]\n     fn is_odd(&self) -> bool { !self.is_even() }\n }\n \n impl IntConvertible for BigUint {\n-\n+    #[inline]\n     fn to_int(&self) -> int {\n         num::min(self.to_uint(), int::max_value as uint) as int\n     }\n \n-\n+    #[inline]\n     fn from_int(n: int) -> BigUint {\n         if (n < 0) { Zero::zero() } else { BigUint::from_uint(n as uint) }\n     }\n }\n \n impl ToStrRadix for BigUint {\n-\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         assert!(1 < radix && radix <= 16);\n         let (base, max_len) = get_radix_base(radix);\n@@ -484,7 +482,6 @@ impl ToStrRadix for BigUint {\n         }\n         return fill_concat(convert_base((*self).clone(), base), radix, max_len);\n \n-\n         fn convert_base(n: BigUint, base: uint) -> ~[BigDigit] {\n             let divider    = BigUint::from_uint(base);\n             let mut result = ~[];\n@@ -500,7 +497,6 @@ impl ToStrRadix for BigUint {\n             return result;\n         }\n \n-\n         fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n             if v.is_empty() { return ~\"0\" }\n             let mut s = str::with_capacity(v.len() * l);\n@@ -516,7 +512,7 @@ impl ToStrRadix for BigUint {\n \n impl FromStrRadix for BigUint {\n     /// Creates and initializes an BigUint.\n-\n+    #[inline]\n     fn from_str_radix(s: &str, radix: uint)\n         -> Option<BigUint> {\n         BigUint::parse_bytes(s.as_bytes(), radix)\n@@ -525,7 +521,7 @@ impl FromStrRadix for BigUint {\n \n impl BigUint {\n     /// Creates and initializes an BigUint.\n-\n+    #[inline]\n     pub fn new(v: ~[BigDigit]) -> BigUint {\n         // omit trailing zeros\n         let new_len = v.rposition(|n| *n != 0).map_move_default(0, |p| p + 1);\n@@ -537,7 +533,7 @@ impl BigUint {\n     }\n \n     /// Creates and initializes an BigUint.\n-\n+    #[inline]\n     pub fn from_uint(n: uint) -> BigUint {\n         match BigDigit::from_uint(n) {\n             (0,  0)  => Zero::zero(),\n@@ -547,13 +543,12 @@ impl BigUint {\n     }\n \n     /// Creates and initializes an BigUint.\n-\n+    #[inline]\n     pub fn from_slice(slice: &[BigDigit]) -> BigUint {\n         return BigUint::new(slice.to_owned());\n     }\n \n     /// Creates and initializes an BigUint.\n-\n     pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigUint> {\n         let (base, unit_len) = get_radix_base(radix);\n@@ -583,6 +578,7 @@ impl BigUint {\n \n     /// Converts this big integer into a uint, returning the uint::max_value if\n     /// it's too large to fit in a uint.\n+    #[inline]\n     pub fn to_uint(&self) -> uint {\n         match self.data.len() {\n             0 => 0,\n@@ -592,15 +588,15 @@ impl BigUint {\n         }\n     }\n \n-\n+    #[inline]\n     fn shl_unit(&self, n_unit: uint) -> BigUint {\n         if n_unit == 0 || self.is_zero() { return (*self).clone(); }\n \n         return BigUint::new(vec::from_elem(n_unit, ZERO_BIG_DIGIT)\n                             + self.data);\n     }\n \n-\n+    #[inline]\n     fn shl_bits(&self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.is_zero() { return (*self).clone(); }\n \n@@ -616,7 +612,7 @@ impl BigUint {\n         return BigUint::new(shifted);\n     }\n \n-\n+    #[inline]\n     fn shr_unit(&self, n_unit: uint) -> BigUint {\n         if n_unit == 0 { return (*self).clone(); }\n         if self.data.len() < n_unit { return Zero::zero(); }\n@@ -625,7 +621,7 @@ impl BigUint {\n         );\n     }\n \n-\n+    #[inline]\n     fn shr_bits(&self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.data.is_empty() { return (*self).clone(); }\n \n@@ -640,6 +636,7 @@ impl BigUint {\n }\n \n #[cfg(target_word_size = \"64\")]\n+#[inline]\n fn get_radix_base(radix: uint) -> (uint, uint) {\n     assert!(1 < radix && radix <= 16);\n     match radix {\n@@ -663,6 +660,7 @@ fn get_radix_base(radix: uint) -> (uint, uint) {\n }\n \n #[cfg(target_word_size = \"32\")]\n+#[inline]\n fn get_radix_base(radix: uint) -> (uint, uint) {\n     assert!(1 < radix && radix <= 16);\n     match radix {\n@@ -690,19 +688,18 @@ fn get_radix_base(radix: uint) -> (uint, uint) {\n pub enum Sign { Minus, Zero, Plus }\n \n impl Ord for Sign {\n-\n+    #[inline]\n     fn lt(&self, other: &Sign) -> bool {\n         match self.cmp(other) { Less => true, _ => false}\n     }\n }\n \n impl TotalEq for Sign {\n-    fn equals(&self, other: &Sign) -> bool {\n-        *self == *other\n-    }\n+    #[inline]\n+    fn equals(&self, other: &Sign) -> bool { *self == *other }\n }\n impl TotalOrd for Sign {\n-\n+    #[inline]\n     fn cmp(&self, other: &Sign) -> Ordering {\n         match (*self, *other) {\n           (Minus, Minus) | (Zero,  Zero) | (Plus, Plus) => Equal,\n@@ -714,7 +711,7 @@ impl TotalOrd for Sign {\n \n impl Neg<Sign> for Sign {\n     /// Negate Sign value.\n-\n+    #[inline]\n     fn neg(&self) -> Sign {\n         match *self {\n           Minus => Plus,\n@@ -732,26 +729,26 @@ pub struct BigInt {\n }\n \n impl Eq for BigInt {\n-\n+    #[inline]\n     fn eq(&self, other: &BigInt) -> bool { self.equals(other) }\n }\n \n impl TotalEq for BigInt {\n-\n+    #[inline]\n     fn equals(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Equal => true, _ => false }\n     }\n }\n \n impl Ord for BigInt {\n-\n+    #[inline]\n     fn lt(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Less => true, _ => false}\n     }\n }\n \n impl TotalOrd for BigInt {\n-\n+    #[inline]\n     fn cmp(&self, other: &BigInt) -> Ordering {\n         let scmp = self.sign.cmp(&other.sign);\n         if scmp != Equal { return scmp; }\n@@ -765,12 +762,12 @@ impl TotalOrd for BigInt {\n }\n \n impl ToStr for BigInt {\n-\n+    #[inline]\n     fn to_str(&self) -> ~str { self.to_str_radix(10) }\n }\n \n impl FromStr for BigInt {\n-\n+    #[inline]\n     fn from_str(s: &str) -> Option<BigInt> {\n         FromStrRadix::from_str_radix(s, 10)\n     }\n@@ -779,69 +776,69 @@ impl FromStr for BigInt {\n impl Num for BigInt {}\n \n impl Orderable for BigInt {\n-\n+    #[inline]\n     fn min(&self, other: &BigInt) -> BigInt {\n         if self < other { self.clone() } else { other.clone() }\n     }\n \n-\n+    #[inline]\n     fn max(&self, other: &BigInt) -> BigInt {\n         if self > other { self.clone() } else { other.clone() }\n     }\n \n-\n+    #[inline]\n     fn clamp(&self, mn: &BigInt, mx: &BigInt) -> BigInt {\n         if self > mx { mx.clone() } else\n         if self < mn { mn.clone() } else { self.clone() }\n     }\n }\n \n impl Shl<uint, BigInt> for BigInt {\n-\n+    #[inline]\n     fn shl(&self, rhs: &uint) -> BigInt {\n         BigInt::from_biguint(self.sign, self.data << *rhs)\n     }\n }\n \n impl Shr<uint, BigInt> for BigInt {\n-\n+    #[inline]\n     fn shr(&self, rhs: &uint) -> BigInt {\n         BigInt::from_biguint(self.sign, self.data >> *rhs)\n     }\n }\n \n impl Zero for BigInt {\n-\n+    #[inline]\n     fn zero() -> BigInt {\n         BigInt::from_biguint(Zero, Zero::zero())\n     }\n \n-\n+    #[inline]\n     fn is_zero(&self) -> bool { self.sign == Zero }\n }\n \n impl One for BigInt {\n-\n+    #[inline]\n     fn one() -> BigInt {\n         BigInt::from_biguint(Plus, One::one())\n     }\n }\n \n impl Signed for BigInt {\n-\n+    #[inline]\n     fn abs(&self) -> BigInt {\n         match self.sign {\n             Plus | Zero => self.clone(),\n             Minus => BigInt::from_biguint(Plus, self.data.clone())\n         }\n     }\n \n-\n+    #[inline]\n     fn abs_sub(&self, other: &BigInt) -> BigInt {\n         if *self <= *other { Zero::zero() } else { *self - *other }\n     }\n \n-\n+    #[inline]\n     fn signum(&self) -> BigInt {\n         match self.sign {\n             Plus  => BigInt::from_biguint(Plus, One::one()),\n@@ -850,15 +847,15 @@ impl Signed for BigInt {\n         }\n     }\n \n-\n+    #[inline]\n     fn is_positive(&self) -> bool { self.sign == Plus }\n \n-\n+    #[inline]\n     fn is_negative(&self) -> bool { self.sign == Minus }\n }\n \n impl Add<BigInt, BigInt> for BigInt {\n-\n+    #[inline]\n     fn add(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)      => other.clone(),\n@@ -873,7 +870,7 @@ impl Add<BigInt, BigInt> for BigInt {\n }\n \n impl Sub<BigInt, BigInt> for BigInt {\n-\n+    #[inline]\n     fn sub(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)    => -other,\n@@ -891,7 +888,7 @@ impl Sub<BigInt, BigInt> for BigInt {\n }\n \n impl Mul<BigInt, BigInt> for BigInt {\n-\n+    #[inline]\n     fn mul(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)     | (_,     Zero)  => Zero::zero(),\n@@ -906,30 +903,30 @@ impl Mul<BigInt, BigInt> for BigInt {\n }\n \n impl Div<BigInt, BigInt> for BigInt {\n-\n+    #[inline]\n     fn div(&self, other: &BigInt) -> BigInt {\n         let (q, _) = self.div_rem(other);\n         return q;\n     }\n }\n \n impl Rem<BigInt, BigInt> for BigInt {\n-\n+    #[inline]\n     fn rem(&self, other: &BigInt) -> BigInt {\n         let (_, r) = self.div_rem(other);\n         return r;\n     }\n }\n \n impl Neg<BigInt> for BigInt {\n-\n+    #[inline]\n     fn neg(&self) -> BigInt {\n         BigInt::from_biguint(self.sign.neg(), self.data.clone())\n     }\n }\n \n impl Integer for BigInt {\n-\n+    #[inline]\n     fn div_rem(&self, other: &BigInt) -> (BigInt, BigInt) {\n         // r.sign == self.sign\n         let (d_ui, r_ui) = self.data.div_mod_floor(&other.data);\n@@ -944,19 +941,18 @@ impl Integer for BigInt {\n         }\n     }\n \n-\n+    #[inline]\n     fn div_floor(&self, other: &BigInt) -> BigInt {\n         let (d, _) = self.div_mod_floor(other);\n         return d;\n     }\n \n-\n+    #[inline]\n     fn mod_floor(&self, other: &BigInt) -> BigInt {\n         let (_, m) = self.div_mod_floor(other);\n         return m;\n     }\n \n-\n     fn div_mod_floor(&self, other: &BigInt) -> (BigInt, BigInt) {\n         // m.sign == other.sign\n         let (d_ui, m_ui) = self.data.div_rem(&other.data);\n@@ -984,34 +980,34 @@ impl Integer for BigInt {\n      *\n      * The result is always positive\n      */\n-\n+    #[inline]\n     fn gcd(&self, other: &BigInt) -> BigInt {\n         BigInt::from_biguint(Plus, self.data.gcd(&other.data))\n     }\n \n     /**\n      * Calculates the Lowest Common Multiple (LCM) of the number and `other`\n      */\n-\n+    #[inline]\n     fn lcm(&self, other: &BigInt) -> BigInt {\n         BigInt::from_biguint(Plus, self.data.lcm(&other.data))\n     }\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n-\n+    #[inline]\n     fn is_multiple_of(&self, other: &BigInt) -> bool { self.data.is_multiple_of(&other.data) }\n \n     /// Returns `true` if the number is divisible by `2`\n-\n+    #[inline]\n     fn is_even(&self) -> bool { self.data.is_even() }\n \n     /// Returns `true` if the number is not divisible by `2`\n-\n+    #[inline]\n     fn is_odd(&self) -> bool { self.data.is_odd() }\n }\n \n impl IntConvertible for BigInt {\n-\n+    #[inline]\n     fn to_int(&self) -> int {\n         match self.sign {\n             Plus  => num::min(self.to_uint(), int::max_value as uint) as int,\n@@ -1021,7 +1017,7 @@ impl IntConvertible for BigInt {\n         }\n     }\n \n-\n+    #[inline]\n     fn from_int(n: int) -> BigInt {\n         if n > 0 {\n            return BigInt::from_biguint(Plus,  BigUint::from_uint(n as uint));\n@@ -1036,7 +1032,7 @@ impl IntConvertible for BigInt {\n }\n \n impl ToStrRadix for BigInt {\n-\n+    #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         match self.sign {\n             Plus  => self.data.to_str_radix(radix),\n@@ -1048,21 +1044,21 @@ impl ToStrRadix for BigInt {\n \n impl FromStrRadix for BigInt {\n     /// Creates and initializes an BigInt.\n-\n-    fn from_str_radix(s: &str, radix: uint)\n-        -> Option<BigInt> {\n+    #[inline]\n+    fn from_str_radix(s: &str, radix: uint) -> Option<BigInt> {\n         BigInt::parse_bytes(s.as_bytes(), radix)\n     }\n }\n \n impl BigInt {\n     /// Creates and initializes an BigInt.\n+    #[inline]\n     pub fn new(sign: Sign, v: ~[BigDigit]) -> BigInt {\n         BigInt::from_biguint(sign, BigUint::new(v))\n     }\n \n     /// Creates and initializes an BigInt.\n-\n+    #[inline]\n     pub fn from_biguint(sign: Sign, data: BigUint) -> BigInt {\n         if sign == Zero || data.is_zero() {\n             return BigInt { sign: Zero, data: Zero::zero() };\n@@ -1071,20 +1067,19 @@ impl BigInt {\n     }\n \n     /// Creates and initializes an BigInt.\n-\n+    #[inline]\n     pub fn from_uint(n: uint) -> BigInt {\n         if n == 0 { return Zero::zero(); }\n         return BigInt::from_biguint(Plus, BigUint::from_uint(n));\n     }\n \n     /// Creates and initializes an BigInt.\n-\n+    #[inline]\n     pub fn from_slice(sign: Sign, slice: &[BigDigit]) -> BigInt {\n         BigInt::from_biguint(sign, BigUint::from_slice(slice))\n     }\n \n     /// Creates and initializes an BigInt.\n-\n     pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigInt> {\n         if buf.is_empty() { return None; }\n@@ -1098,6 +1093,7 @@ impl BigInt {\n             .map_move(|bu| BigInt::from_biguint(sign, bu));\n     }\n \n+    #[inline]\n     pub fn to_uint(&self) -> uint {\n         match self.sign {\n             Plus  => self.data.to_uint(),\n@@ -1577,7 +1573,6 @@ mod biguint_tests {\n \n #[cfg(test)]\n mod bigint_tests {\n-\n     use super::*;\n \n     use std::cmp::{Less, Equal, Greater};"}]}