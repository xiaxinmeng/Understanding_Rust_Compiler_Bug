{"sha": "018525ea7028ccff96fca6949cfc9a666d2f3229", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxODUyNWVhNzAyOGNjZmY5NmZjYTY5NDljZmM5YTY2NmQyZjMyMjk=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-09-20T13:36:20Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-09-20T13:49:21Z"}, "message": "address review comments", "tree": {"sha": "ff982e377b939c903d15cde29bfac0d0460aa153", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff982e377b939c903d15cde29bfac0d0460aa153"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/018525ea7028ccff96fca6949cfc9a666d2f3229", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/018525ea7028ccff96fca6949cfc9a666d2f3229", "html_url": "https://github.com/rust-lang/rust/commit/018525ea7028ccff96fca6949cfc9a666d2f3229", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/018525ea7028ccff96fca6949cfc9a666d2f3229/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c0feb86b9d51e1ac80321b10dde43d1dbc3c042", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c0feb86b9d51e1ac80321b10dde43d1dbc3c042", "html_url": "https://github.com/rust-lang/rust/commit/5c0feb86b9d51e1ac80321b10dde43d1dbc3c042"}], "stats": {"total": 111, "additions": 95, "deletions": 16}, "files": [{"sha": "9d8075de2eb2f985b03c72137519e816e5b7ca82", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/018525ea7028ccff96fca6949cfc9a666d2f3229/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018525ea7028ccff96fca6949cfc9a666d2f3229/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=018525ea7028ccff96fca6949cfc9a666d2f3229", "patch": "@@ -411,10 +411,13 @@ pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body) {\n }\n \n pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n+    // Intentionally visiting the expr first - the initialization expr\n+    // dominates the local's definition.\n+    walk_list!(visitor, visit_expr, &local.init);\n+\n     visitor.visit_id(local.id);\n     visitor.visit_pat(&local.pat);\n     walk_list!(visitor, visit_ty, &local.ty);\n-    walk_list!(visitor, visit_expr, &local.init);\n }\n \n pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {"}, {"sha": "8b73bc5c840a9f275b51f703af215ea6cea1da1d", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 53, "deletions": 13, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/018525ea7028ccff96fca6949cfc9a666d2f3229/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018525ea7028ccff96fca6949cfc9a666d2f3229/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=018525ea7028ccff96fca6949cfc9a666d2f3229", "patch": "@@ -259,8 +259,37 @@ pub struct ScopeTree {\n     /// lower than theirs, and therefore don't need to be suspended\n     /// at yield-points at these indexes.\n     ///\n-    /// Let's show that: let `D` be our binding/temporary and `U` be our\n-    /// other HIR node, with `HIR-postorder(U) < HIR-postorder(D)`.\n+    /// For an example, suppose we have some code such as:\n+    /// ```rust,ignore (example)\n+    ///     foo(f(), yield y, bar(g()))\n+    /// ```\n+    ///\n+    /// With the HIR tree (calls numbered for expository purposes)\n+    /// ```\n+    ///     Call#0(foo, [Call#1(f), Yield(y), Call#2(bar, Call#3(g))])\n+    /// ```\n+    ///\n+    /// Obviously, the result of `f()` was created before the yield\n+    /// (and therefore needs to be kept valid over the yield) while\n+    /// the result of `g()` occurs after the yield (and therefore\n+    /// doesn't). If we want to infer that, we can look at the\n+    /// postorder traversal:\n+    /// ```\n+    /// `foo` `f` Call#1 `y` Yield `bar` `g` Call#3 Call#2 Call#0\n+    /// ```\n+    ///\n+    /// In which we can easily see that `Call#1` occurs before the yield,\n+    /// and `Call#3` after it.\n+    ///\n+    /// To see that this method works, consider:\n+    ///\n+    /// Let `D` be our binding/temporary and `U` be our other HIR node, with\n+    /// `HIR-postorder(U) < HIR-postorder(D)` (in our example, U would be\n+    /// the yield and D would be one of the calls). Let's show that\n+    /// `D` is storage-dead at `U`.\n+    ///\n+    /// Remember that storage-live/storage-dead refers to the state of\n+    /// the *storage*, and does not consider moves/drop flags.\n     ///\n     /// Then:\n     ///     1. From the ordering guarantee of HIR visitors (see\n@@ -272,17 +301,26 @@ pub struct ScopeTree {\n     ///     or always storage-dead. This is what is being guaranteed\n     ///     by `terminating_scopes` including all blocks where the\n     ///     count of executions is not guaranteed.\n-    ///     4. By `2.` and `3.`, `D` is *statically* dead at `U`,\n+    ///     4. By `2.` and `3.`, `D` is *statically* storage-dead at `U`,\n     ///     QED.\n     ///\n     /// I don't think this property relies on `3.` in an essential way - it\n     /// is probably still correct even if we have \"unrestricted\" terminating\n     /// scopes. However, why use the complicated proof when a simple one\n     /// works?\n+    ///\n+    /// A subtle thing: `box` expressions, such as `box (&x, yield 2, &y)`. It\n+    /// might seem that a `box` expression creates a `Box<T>` temporary\n+    /// when it *starts* executing, at `HIR-preorder(BOX-EXPR)`. That might\n+    /// be true in the MIR desugaring, but it is not important in the semantics.\n+    ///\n+    /// The reason is that semantically, until the `box` expression returns,\n+    /// the values are still owned by their containing expressions. So\n+    /// we'll see that `&x`.\n     yield_in_scope: FxHashMap<Scope, (Span, usize)>,\n \n-    /// The number of visit_expr calls done in the body.\n-    /// Used to sanity check visit_expr call count when\n+    /// The number of visit_expr and visit_pat calls done in the body.\n+    /// Used to sanity check visit_expr/visit_pat call count when\n     /// calculating geneartor interiors.\n     body_expr_count: FxHashMap<hir::BodyId, usize>,\n }\n@@ -307,8 +345,8 @@ pub struct Context {\n struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n-    // The number of expressions visited in the current body\n-    expr_count: usize,\n+    // The number of expressions and patterns visited in the current body\n+    expr_and_pat_count: usize,\n \n     // Generated scope tree:\n     scope_tree: ScopeTree,\n@@ -758,6 +796,8 @@ fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &\n     }\n \n     intravisit::walk_pat(visitor, pat);\n+\n+    visitor.expr_and_pat_count += 1;\n }\n \n fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n@@ -863,14 +903,14 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n         _ => intravisit::walk_expr(visitor, expr)\n     }\n \n-    visitor.expr_count += 1;\n+    visitor.expr_and_pat_count += 1;\n \n     if let hir::ExprYield(..) = expr.node {\n         // Mark this expr's scope and all parent scopes as containing `yield`.\n         let mut scope = Scope::Node(expr.hir_id.local_id);\n         loop {\n             visitor.scope_tree.yield_in_scope.insert(scope,\n-                (expr.span, visitor.expr_count));\n+                (expr.span, visitor.expr_and_pat_count));\n \n             // Keep traversing up while we can.\n             match visitor.scope_tree.parent_map.get(&scope) {\n@@ -1160,7 +1200,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n                body_id,\n                self.cx.parent);\n \n-        let outer_ec = mem::replace(&mut self.expr_count, 0);\n+        let outer_ec = mem::replace(&mut self.expr_and_pat_count, 0);\n         let outer_cx = self.cx;\n         let outer_ts = mem::replace(&mut self.terminating_scopes, FxHashSet());\n         self.terminating_scopes.insert(body.value.hir_id.local_id);\n@@ -1207,11 +1247,11 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n         }\n \n         if body.is_generator {\n-            self.scope_tree.body_expr_count.insert(body_id, self.expr_count);\n+            self.scope_tree.body_expr_count.insert(body_id, self.expr_and_pat_count);\n         }\n \n         // Restore context we had at the start.\n-        self.expr_count = outer_ec;\n+        self.expr_and_pat_count = outer_ec;\n         self.cx = outer_cx;\n         self.terminating_scopes = outer_ts;\n     }\n@@ -1246,7 +1286,7 @@ fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n         let mut visitor = RegionResolutionVisitor {\n             tcx,\n             scope_tree: ScopeTree::default(),\n-            expr_count: 0,\n+            expr_and_pat_count: 0,\n             cx: Context {\n                 root_id: None,\n                 parent: None,"}, {"sha": "f2607b164de26346f63179b872d1fb31f2aeea6f", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/018525ea7028ccff96fca6949cfc9a666d2f3229/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018525ea7028ccff96fca6949cfc9a666d2f3229/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=018525ea7028ccff96fca6949cfc9a666d2f3229", "patch": "@@ -96,7 +96,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             ExprKind::Box { value } => {\n                 let value = this.hir.mirror(value);\n-                let result = this.local_decls.push(LocalDecl::new_temp(expr.ty, expr_span));\n+                // The `Box<T>` temporary created here is not a part of the HIR,\n+                // and therefore is not considered during generator OIBIT\n+                // determination. See the comment about `box` at `yield_in_scope`.\n+                let result = this.local_decls.push(\n+                    LocalDecl::new_internal(expr.ty, expr_span));\n                 this.cfg.push(block, Statement {\n                     source_info,\n                     kind: StatementKind::StorageLive(result)"}, {"sha": "af1297697c24188b04e5426e2188e4c4458c1526", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/018525ea7028ccff96fca6949cfc9a666d2f3229/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018525ea7028ccff96fca6949cfc9a666d2f3229/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=018525ea7028ccff96fca6949cfc9a666d2f3229", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n                 // be storage-live (and therefore live) at any of the yields.\n                 //\n                 // See the mega-comment at `yield_in_scope` for a proof.\n-                if expr.is_none() || expr_count >= self.expr_count {\n+                if expr_count >= self.expr_count {\n                     Some(span)\n                 } else {\n                     None\n@@ -115,6 +115,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'gcx, 'tcx> {\n             self.record(ty, Some(scope), None);\n         }\n \n+        self.expr_count += 1;\n+\n         intravisit::walk_pat(self, pat);\n     }\n "}, {"sha": "df00329799e96e68aae4a2adc4318202c18e94a2", "filename": "src/test/run-pass/generator/yield-in-args-rev.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/018525ea7028ccff96fca6949cfc9a666d2f3229/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-in-args-rev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018525ea7028ccff96fca6949cfc9a666d2f3229/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-in-args-rev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-in-args-rev.rs?ref=018525ea7028ccff96fca6949cfc9a666d2f3229", "patch": "@@ -8,6 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test that a borrow that occurs after a yield in the same\n+// argument list is not treated as live across the yield by\n+// type-checking.\n+\n #![feature(generators)]\n \n fn foo(_a: (), _b: &bool) {}"}, {"sha": "d68007be05c881844ad46a737c965c2f80e02943", "filename": "src/test/run-pass/generator/yield-in-box.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/018525ea7028ccff96fca6949cfc9a666d2f3229/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-in-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018525ea7028ccff96fca6949cfc9a666d2f3229/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-in-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-in-box.rs?ref=018525ea7028ccff96fca6949cfc9a666d2f3229", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that box-statements with yields in them work.\n+\n+#![feature(generators, box_syntax)]\n+\n+fn main() {\n+    let x = 0i32;\n+    || {\n+        let y = 2u32;\n+        {\n+            let _t = box (&x, yield 0, &y);\n+        }\n+        match box (&x, yield 0, &y) {\n+            _t => {}\n+        }\n+    };\n+}"}]}