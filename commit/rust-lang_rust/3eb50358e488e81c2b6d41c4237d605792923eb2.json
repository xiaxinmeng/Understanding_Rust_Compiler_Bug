{"sha": "3eb50358e488e81c2b6d41c4237d605792923eb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlYjUwMzU4ZTQ4OGU4MWMyYjZkNDFjNDIzN2Q2MDU3OTI5MjNlYjI=", "commit": {"author": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-07-10T11:34:34Z"}, "committer": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-07-30T16:49:20Z"}, "message": "rustc_codegen_llvm: use safe references for BasicBlock.", "tree": {"sha": "c6b7cad26c29f55f64b1a61695b1172c6e16fa37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6b7cad26c29f55f64b1a61695b1172c6e16fa37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3eb50358e488e81c2b6d41c4237d605792923eb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3eb50358e488e81c2b6d41c4237d605792923eb2", "html_url": "https://github.com/rust-lang/rust/commit/3eb50358e488e81c2b6d41c4237d605792923eb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3eb50358e488e81c2b6d41c4237d605792923eb2/comments", "author": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f375185314e94a266f76ad7ffdd61b2d4608e97d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f375185314e94a266f76ad7ffdd61b2d4608e97d", "html_url": "https://github.com/rust-lang/rust/commit/f375185314e94a266f76ad7ffdd61b2d4608e97d"}], "stats": {"total": 109, "additions": 54, "deletions": 55}, "files": [{"sha": "dbc16cbbf0ded651f4e08ffc04f5e03ec558f294", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3eb50358e488e81c2b6d41c4237d605792923eb2/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb50358e488e81c2b6d41c4237d605792923eb2/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=3eb50358e488e81c2b6d41c4237d605792923eb2", "patch": "@@ -12,7 +12,7 @@\n \n use llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n use llvm::{Opcode, IntPredicate, RealPredicate, False, OperandBundleDef};\n-use llvm::{self, BasicBlockRef};\n+use llvm::{self, BasicBlock};\n use common::*;\n use type_::Type;\n use value::Value;\n@@ -102,7 +102,7 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn llbb(&self) -> BasicBlockRef {\n+    pub fn llbb(&self) -> &'ll BasicBlock {\n         unsafe {\n             llvm::LLVMGetInsertBlock(self.llbuilder)\n         }\n@@ -134,13 +134,13 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn position_at_end(&self, llbb: BasicBlockRef) {\n+    pub fn position_at_end(&self, llbb: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(self.llbuilder, llbb);\n         }\n     }\n \n-    pub fn position_at_start(&self, llbb: BasicBlockRef) {\n+    pub fn position_at_start(&self, llbb: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMRustPositionBuilderAtStart(self.llbuilder, llbb);\n         }\n@@ -168,21 +168,21 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn br(&self, dest: BasicBlockRef) {\n+    pub fn br(&self, dest: &'ll BasicBlock) {\n         self.count_insn(\"br\");\n         unsafe {\n             llvm::LLVMBuildBr(self.llbuilder, dest);\n         }\n     }\n \n-    pub fn cond_br(&self, cond: &'ll Value, then_llbb: BasicBlockRef, else_llbb: BasicBlockRef) {\n+    pub fn cond_br(&self, cond: &'ll Value, then_llbb: &'ll BasicBlock, else_llbb: &'ll BasicBlock) {\n         self.count_insn(\"condbr\");\n         unsafe {\n             llvm::LLVMBuildCondBr(self.llbuilder, cond, then_llbb, else_llbb);\n         }\n     }\n \n-    pub fn switch(&self, v: &'ll Value, else_llbb: BasicBlockRef, num_cases: usize) -> &'ll Value {\n+    pub fn switch(&self, v: &'ll Value, else_llbb: &'ll BasicBlock, num_cases: usize) -> &'ll Value {\n         unsafe {\n             llvm::LLVMBuildSwitch(self.llbuilder, v, else_llbb, num_cases as c_uint)\n         }\n@@ -198,8 +198,8 @@ impl Builder<'a, 'll, 'tcx> {\n     pub fn invoke(&self,\n                   llfn: &'ll Value,\n                   args: &[&'ll Value],\n-                  then: BasicBlockRef,\n-                  catch: BasicBlockRef,\n+                  then: &'ll BasicBlock,\n+                  catch: &'ll BasicBlock,\n                   bundle: Option<&OperandBundleDef>) -> &'ll Value {\n         self.count_insn(\"invoke\");\n \n@@ -830,7 +830,7 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn phi(&self, ty: &'ll Type, vals: &[&'ll Value], bbs: &[BasicBlockRef]) -> &'ll Value {\n+    pub fn phi(&self, ty: &'ll Type, vals: &[&'ll Value], bbs: &[&'ll BasicBlock]) -> &'ll Value {\n         assert_eq!(vals.len(), bbs.len());\n         let phi = self.empty_phi(ty);\n         self.count_insn(\"addincoming\");\n@@ -1167,10 +1167,11 @@ impl Builder<'a, 'll, 'tcx> {\n         ret.expect(\"LLVM does not have support for cleanuppad\")\n     }\n \n-    pub fn cleanup_ret(&self, cleanup: &'ll Value,\n-                       unwind: Option<BasicBlockRef>) -> &'ll Value {\n+    pub fn cleanup_ret(\n+        &self, cleanup: &'ll Value,\n+        unwind: Option<&'ll BasicBlock>,\n+    ) -> &'ll Value {\n         self.count_insn(\"cleanupret\");\n-        let unwind = unwind.and_then(NonNull::new);\n         let ret = unsafe {\n             llvm::LLVMRustBuildCleanupRet(self.llbuilder, cleanup, unwind)\n         };\n@@ -1190,7 +1191,7 @@ impl Builder<'a, 'll, 'tcx> {\n         ret.expect(\"LLVM does not have support for catchpad\")\n     }\n \n-    pub fn catch_ret(&self, pad: &'ll Value, unwind: BasicBlockRef) -> &'ll Value {\n+    pub fn catch_ret(&self, pad: &'ll Value, unwind: &'ll BasicBlock) -> &'ll Value {\n         self.count_insn(\"catchret\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchRet(self.llbuilder, pad, unwind)\n@@ -1201,11 +1202,10 @@ impl Builder<'a, 'll, 'tcx> {\n     pub fn catch_switch(\n         &self,\n         parent: Option<&'ll Value>,\n-        unwind: Option<BasicBlockRef>,\n+        unwind: Option<&'ll BasicBlock>,\n         num_handlers: usize,\n     ) -> &'ll Value {\n         self.count_insn(\"catchswitch\");\n-        let unwind = unwind.and_then(NonNull::new);\n         let name = CString::new(\"catchswitch\").unwrap();\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchSwitch(self.llbuilder, parent, unwind,\n@@ -1215,7 +1215,7 @@ impl Builder<'a, 'll, 'tcx> {\n         ret.expect(\"LLVM does not have support for catchswitch\")\n     }\n \n-    pub fn add_handler(&self, catch_switch: &'ll Value, handler: BasicBlockRef) {\n+    pub fn add_handler(&self, catch_switch: &'ll Value, handler: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMRustAddHandler(catch_switch, handler);\n         }\n@@ -1260,13 +1260,13 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn add_case(&self, s: &'ll Value, on_val: &'ll Value, dest: BasicBlockRef) {\n+    pub fn add_case(&self, s: &'ll Value, on_val: &'ll Value, dest: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMAddCase(s, on_val, dest)\n         }\n     }\n \n-    pub fn add_incoming_to_phi(&self, phi: &'ll Value, val: &'ll Value, bb: BasicBlockRef) {\n+    pub fn add_incoming_to_phi(&self, phi: &'ll Value, val: &'ll Value, bb: &'ll BasicBlock) {\n         self.count_insn(\"addincoming\");\n         unsafe {\n             llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);"}, {"sha": "1b6014b495246fc2f3ed502a11396ff835eb949e", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3eb50358e488e81c2b6d41c4237d605792923eb2/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb50358e488e81c2b6d41c4237d605792923eb2/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=3eb50358e488e81c2b6d41c4237d605792923eb2", "patch": "@@ -381,7 +381,6 @@ extern { pub type Type; }\n extern { pub type Value; }\n extern { pub type Metadata; }\n extern { pub type BasicBlock; }\n-pub type BasicBlockRef = *mut BasicBlock;\n extern { pub type Builder; }\n extern { pub type MemoryBuffer; }\n pub type MemoryBufferRef = *mut MemoryBuffer;\n@@ -716,18 +715,18 @@ extern \"C\" {\n     pub fn LLVMGetParam(Fn: &Value, Index: c_uint) -> &Value;\n \n     // Operations on basic blocks\n-    pub fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> &'a Value;\n-    pub fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> &'a Value;\n+    pub fn LLVMBasicBlockAsValue(BB: &BasicBlock) -> &Value;\n+    pub fn LLVMGetBasicBlockParent(BB: &BasicBlock) -> &Value;\n     pub fn LLVMAppendBasicBlockInContext(C: &'a Context,\n                                          Fn: &'a Value,\n                                          Name: *const c_char)\n-                                         -> BasicBlockRef;\n-    pub fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n+                                         -> &'a BasicBlock;\n+    pub fn LLVMDeleteBasicBlock(BB: &BasicBlock);\n \n     // Operations on instructions\n-    pub fn LLVMGetInstructionParent(Inst: &Value) -> BasicBlockRef;\n-    pub fn LLVMGetFirstBasicBlock(Fn: &Value) -> BasicBlockRef;\n-    pub fn LLVMGetFirstInstruction(BB: BasicBlockRef) -> &'a Value;\n+    pub fn LLVMGetInstructionParent(Inst: &Value) -> &BasicBlock;\n+    pub fn LLVMGetFirstBasicBlock(Fn: &Value) -> &BasicBlock;\n+    pub fn LLVMGetFirstInstruction(BB: &BasicBlock) -> &'a Value;\n     pub fn LLVMInstructionEraseFromParent(Inst: &Value);\n \n     // Operations on call sites\n@@ -745,15 +744,15 @@ extern \"C\" {\n     // Operations on phi nodes\n     pub fn LLVMAddIncoming(PhiNode: &'a Value,\n                            IncomingValues: *const &'a Value,\n-                           IncomingBlocks: *const BasicBlockRef,\n+                           IncomingBlocks: *const &'a BasicBlock,\n                            Count: c_uint);\n \n     // Instruction builders\n     pub fn LLVMCreateBuilderInContext(C: &Context) -> &Builder;\n-    pub fn LLVMPositionBuilder(Builder: &'a Builder, Block: BasicBlockRef, Instr: &'a Value);\n+    pub fn LLVMPositionBuilder(Builder: &'a Builder, Block: &'a BasicBlock, Instr: &'a Value);\n     pub fn LLVMPositionBuilderBefore(Builder: &'a Builder, Instr: &'a Value);\n-    pub fn LLVMPositionBuilderAtEnd(Builder: &Builder, Block: BasicBlockRef);\n-    pub fn LLVMGetInsertBlock(Builder: &Builder) -> BasicBlockRef;\n+    pub fn LLVMPositionBuilderAtEnd(Builder: &'a Builder, Block: &'a BasicBlock);\n+    pub fn LLVMGetInsertBlock(Builder: &Builder) -> &BasicBlock;\n     pub fn LLVMDisposeBuilder(Builder: &Builder);\n \n     // Metadata\n@@ -765,24 +764,24 @@ extern \"C\" {\n     pub fn LLVMBuildRetVoid(B: &Builder) -> &Value;\n     pub fn LLVMBuildRet(B: &'a Builder, V: &'a Value) -> &'a Value;\n     pub fn LLVMBuildAggregateRet(B: &'a Builder, RetVals: *const &'a Value, N: c_uint) -> &'a Value;\n-    pub fn LLVMBuildBr(B: &Builder, Dest: BasicBlockRef) -> &Value;\n+    pub fn LLVMBuildBr(B: &'a Builder, Dest: &'a BasicBlock) -> &'a Value;\n     pub fn LLVMBuildCondBr(B: &'a Builder,\n                            If: &'a Value,\n-                           Then: BasicBlockRef,\n-                           Else: BasicBlockRef)\n+                           Then: &'a BasicBlock,\n+                           Else: &'a BasicBlock)\n                            -> &'a Value;\n     pub fn LLVMBuildSwitch(B: &'a Builder,\n                            V: &'a Value,\n-                           Else: BasicBlockRef,\n+                           Else: &'a BasicBlock,\n                            NumCases: c_uint)\n                            -> &'a Value;\n     pub fn LLVMBuildIndirectBr(B: &'a Builder, Addr: &'a Value, NumDests: c_uint) -> &'a Value;\n     pub fn LLVMRustBuildInvoke(B: &'a Builder,\n                                Fn: &'a Value,\n                                Args: *const &'a Value,\n                                NumArgs: c_uint,\n-                               Then: BasicBlockRef,\n-                               Catch: BasicBlockRef,\n+                               Then: &'a BasicBlock,\n+                               Catch: &'a BasicBlock,\n                                Bundle: Option<NonNull<OperandBundleDef>>,\n                                Name: *const c_char)\n                                -> &'a Value;\n@@ -803,26 +802,26 @@ extern \"C\" {\n                                    -> Option<&'a Value>;\n     pub fn LLVMRustBuildCleanupRet(B: &'a Builder,\n                                    CleanupPad: &'a Value,\n-                                   UnwindBB: Option<NonNull<BasicBlock>>)\n+                                   UnwindBB: Option<&'a BasicBlock>)\n                                    -> Option<&'a Value>;\n     pub fn LLVMRustBuildCatchPad(B: &'a Builder,\n                                  ParentPad: &'a Value,\n                                  ArgCnt: c_uint,\n                                  Args: *const &'a Value,\n                                  Name: *const c_char)\n                                  -> Option<&'a Value>;\n-    pub fn LLVMRustBuildCatchRet(B: &'a Builder, Pad: &'a Value, BB: BasicBlockRef) -> Option<&'a Value>;\n+    pub fn LLVMRustBuildCatchRet(B: &'a Builder, Pad: &'a Value, BB: &'a BasicBlock) -> Option<&'a Value>;\n     pub fn LLVMRustBuildCatchSwitch(Builder: &'a Builder,\n                                     ParentPad: Option<&'a Value>,\n-                                    BB: Option<NonNull<BasicBlock>>,\n+                                    BB: Option<&'a BasicBlock>,\n                                     NumHandlers: c_uint,\n                                     Name: *const c_char)\n                                     -> Option<&'a Value>;\n-    pub fn LLVMRustAddHandler(CatchSwitch: &Value, Handler: BasicBlockRef);\n+    pub fn LLVMRustAddHandler(CatchSwitch: &'a Value, Handler: &'a BasicBlock);\n     pub fn LLVMSetPersonalityFn(Func: &'a Value, Pers: &'a Value);\n \n     // Add a case to the switch instruction\n-    pub fn LLVMAddCase(Switch: &'a Value, OnVal: &'a Value, Dest: BasicBlockRef);\n+    pub fn LLVMAddCase(Switch: &'a Value, OnVal: &'a Value, Dest: &'a BasicBlock);\n \n     // Add a clause to the landing pad instruction\n     pub fn LLVMAddClause(LandingPad: &'a Value, ClauseVal: &'a Value);\n@@ -1503,7 +1502,7 @@ extern \"C\" {\n                                                AddrOps: *const i64,\n                                                AddrOpsCount: c_uint,\n                                                DL: &'a Value,\n-                                               InsertAtEnd: BasicBlockRef)\n+                                               InsertAtEnd: &'a BasicBlock)\n                                                -> &'a Value;\n \n     pub fn LLVMRustDIBuilderCreateEnumerator(Builder: &DIBuilder,\n@@ -1691,7 +1690,7 @@ extern \"C\" {\n                                          -> OperandBundleDefRef;\n     pub fn LLVMRustFreeOperandBundleDef(Bundle: OperandBundleDefRef);\n \n-    pub fn LLVMRustPositionBuilderAtStart(B: &Builder, BB: BasicBlockRef);\n+    pub fn LLVMRustPositionBuilderAtStart(B: &'a Builder, BB: &'a BasicBlock);\n \n     pub fn LLVMRustSetComdat(M: &'a Module, V: &'a Value, Name: *const c_char);\n     pub fn LLVMRustUnsetComdat(V: &Value);"}, {"sha": "684ecfaeec8f159d858f736e22b2d45b6a6699cd", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3eb50358e488e81c2b6d41c4237d605792923eb2/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb50358e488e81c2b6d41c4237d605792923eb2/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=3eb50358e488e81c2b6d41c4237d605792923eb2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, BasicBlockRef};\n+use llvm::{self, BasicBlock};\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf};\n@@ -754,7 +754,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     /// Return the landingpad wrapper around the given basic block\n     ///\n     /// No-op in MSVC SEH scheme.\n-    fn landing_pad_to(&mut self, target_bb: mir::BasicBlock) -> BasicBlockRef {\n+    fn landing_pad_to(&mut self, target_bb: mir::BasicBlock) -> &'ll BasicBlock {\n         if let Some(block) = self.landing_pads[target_bb] {\n             return block;\n         }\n@@ -765,7 +765,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         landing_pad\n     }\n \n-    fn landing_pad_uncached(&mut self, target_bb: BasicBlockRef) -> BasicBlockRef {\n+    fn landing_pad_uncached(&mut self, target_bb: &'ll BasicBlock) -> &'ll BasicBlock {\n         if base::wants_msvc_seh(self.cx.sess()) {\n             span_bug!(self.mir.span, \"landing pad was not inserted?\")\n         }\n@@ -790,7 +790,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         Type::struct_(cx, &[Type::i8p(cx), Type::i32(cx)], false)\n     }\n \n-    fn unreachable_block(&mut self) -> BasicBlockRef {\n+    fn unreachable_block(&mut self) -> &'ll BasicBlock {\n         self.unreachable_block.unwrap_or_else(|| {\n             let bl = self.new_block(\"unreachable\");\n             bl.unreachable();"}, {"sha": "8cdd0398eff96d02e28dfea807c8523429dc968b", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3eb50358e488e81c2b6d41c4237d605792923eb2/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb50358e488e81c2b6d41c4237d605792923eb2/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=3eb50358e488e81c2b6d41c4237d605792923eb2", "patch": "@@ -10,7 +10,7 @@\n \n use common::{C_i32, C_null};\n use libc::c_uint;\n-use llvm::{self, BasicBlockRef};\n+use llvm::{self, BasicBlock};\n use llvm::debuginfo::DIScope;\n use rustc::ty::{self, Ty, TypeFoldable, UpvarSubsts};\n use rustc::ty::layout::{LayoutOf, TyLayout};\n@@ -66,7 +66,7 @@ pub struct FunctionCx<'a, 'll: 'a, 'tcx: 'll> {\n     personality_slot: Option<PlaceRef<'ll, 'tcx>>,\n \n     /// A `Block` for each MIR `BasicBlock`\n-    blocks: IndexVec<mir::BasicBlock, BasicBlockRef>,\n+    blocks: IndexVec<mir::BasicBlock, &'ll BasicBlock>,\n \n     /// The funclet status of each basic block\n     cleanup_kinds: IndexVec<mir::BasicBlock, analyze::CleanupKind>,\n@@ -77,10 +77,10 @@ pub struct FunctionCx<'a, 'll: 'a, 'tcx: 'll> {\n \n     /// This stores the landing-pad block for a given BB, computed lazily on GNU\n     /// and eagerly on MSVC.\n-    landing_pads: IndexVec<mir::BasicBlock, Option<BasicBlockRef>>,\n+    landing_pads: IndexVec<mir::BasicBlock, Option<&'ll BasicBlock>>,\n \n     /// Cached unreachable block\n-    unreachable_block: Option<BasicBlockRef>,\n+    unreachable_block: Option<&'ll BasicBlock>,\n \n     /// The location where each MIR arg/var/tmp/ret is stored. This is\n     /// usually an `PlaceRef` representing an alloca, but not always:\n@@ -219,7 +219,7 @@ pub fn codegen_mir(\n     // Allocate a `Block` for every basic block, except\n     // the start block, if nothing loops back to it.\n     let reentrant_start_block = !mir.predecessors_for(mir::START_BLOCK).is_empty();\n-    let block_bxs: IndexVec<mir::BasicBlock, BasicBlockRef> =\n+    let block_bxs: IndexVec<mir::BasicBlock, &'ll BasicBlock> =\n         mir.basic_blocks().indices().map(|bb| {\n             if bb == mir::START_BLOCK && !reentrant_start_block {\n                 bx.llbb()\n@@ -348,8 +348,8 @@ fn create_funclets(\n     mir: &'a Mir<'tcx>,\n     bx: &Builder<'a, 'll, 'tcx>,\n     cleanup_kinds: &IndexVec<mir::BasicBlock, CleanupKind>,\n-    block_bxs: &IndexVec<mir::BasicBlock, BasicBlockRef>)\n-    -> (IndexVec<mir::BasicBlock, Option<BasicBlockRef>>,\n+    block_bxs: &IndexVec<mir::BasicBlock, &'ll BasicBlock>)\n+    -> (IndexVec<mir::BasicBlock, Option<&'ll BasicBlock>>,\n         IndexVec<mir::BasicBlock, Option<Funclet<'ll>>>)\n {\n     block_bxs.iter_enumerated().zip(cleanup_kinds).map(|((bb, &llbb), cleanup_kind)| {"}]}