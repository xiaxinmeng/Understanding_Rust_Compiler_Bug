{"sha": "5c1fd5f8b7351085765217b198c6d5a8c0026b74", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjMWZkNWY4YjczNTEwODU3NjUyMTdiMTk4YzZkNWE4YzAwMjZiNzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-05T18:01:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-05T18:01:53Z"}, "message": "auto merge of #18462 : netvl/rust/to-socket-addr, r=alexcrichton\n\nThis is a follow-up to [RFC PR #173](https://github.com/rust-lang/rfcs/pull/173). I was told there that changes like this don't need to go through the RFC process, so I'm submitting this directly.\r\n\r\nThis PR introduces `ToSocketAddr` trait as defined in said RFC. This trait defines a conversion from different types like `&str`, `(&str, u16)` or even `SocketAddr` to `SocketAddr`. Then this trait is used in all constructor methods for `TcpStream`, `TcpListener` and `UdpSocket`.\r\n\r\nThis unifies these constructor methods - previously they were using different types of input parameters (TCP ones used `(&str, u16)` pair while UDP ones used `SocketAddr`), which is not consistent by itself and sometimes inconvenient - for example, when the address initially is available as `SocketAddr`, you still need to convert it to string to pass it to e.g. `TcpStream`. This is very prominently demonstrated by the unit tests for TCP functionality. This PR makes working with network objects much like with `Path`, which also uses similar trait to be able to be constructed from `&[u8]`, `Vec<u8>` and other `Path`s.\r\n\r\nThis is a breaking change. If constant literals were used before, like this:\r\n```rust\r\nTcpStream::connect(\"localhost\", 12345)\r\n```\r\nthen the nicest fix is to change it to this:\r\n```rust\r\nTcpStream::connect(\"localhost:12345\")\r\n```\r\n\r\nIf variables were used before, like this:\r\n```rust\r\nTcpStream::connect(some_address, some_port)\r\n```\r\nthen the arguments should be wrapped in another set of parentheses:\r\n```rust\r\nTcpStream::connect((some_address, some_port))\r\n```\r\n\r\n`UdpSocket` usages won't break because its constructor method accepted `SocketAddr` which implements `ToSocketAddr`, so `bind()` calls:\r\n```rust\r\nUdpSocket::bind(some_socket_addr)\r\n```\r\nwill continue working as before.\r\n\r\nI haven't changed `UdpStream` constructor because it is deprecated anyway.", "tree": {"sha": "9cff896e8595a6e8a0089cb72c1a326e7019c3dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cff896e8595a6e8a0089cb72c1a326e7019c3dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c1fd5f8b7351085765217b198c6d5a8c0026b74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c1fd5f8b7351085765217b198c6d5a8c0026b74", "html_url": "https://github.com/rust-lang/rust/commit/5c1fd5f8b7351085765217b198c6d5a8c0026b74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c1fd5f8b7351085765217b198c6d5a8c0026b74/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14cd5c590e2157f153ed38625011e7fc3c83659c", "url": "https://api.github.com/repos/rust-lang/rust/commits/14cd5c590e2157f153ed38625011e7fc3c83659c", "html_url": "https://github.com/rust-lang/rust/commit/14cd5c590e2157f153ed38625011e7fc3c83659c"}, {"sha": "0f610f3c14f25bb51a865d04a42a4cbb62b8815f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f610f3c14f25bb51a865d04a42a4cbb62b8815f", "html_url": "https://github.com/rust-lang/rust/commit/0f610f3c14f25bb51a865d04a42a4cbb62b8815f"}], "stats": {"total": 675, "additions": 411, "deletions": 264}, "files": [{"sha": "b082cffd668182646546ccfc52b1863bc3e6579f", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c1fd5f8b7351085765217b198c6d5a8c0026b74/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c1fd5f8b7351085765217b198c6d5a8c0026b74/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=5c1fd5f8b7351085765217b198c6d5a8c0026b74", "patch": "@@ -444,7 +444,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                 //waiting 1 second for gdbserver start\n                 timer::sleep(Duration::milliseconds(1000));\n                 let result = task::try(proc() {\n-                    tcp::TcpStream::connect(\"127.0.0.1\", 5039).unwrap();\n+                    tcp::TcpStream::connect(\"127.0.0.1:5039\").unwrap();\n                 });\n                 if result.is_err() {\n                     continue;"}, {"sha": "ebf541a63dafaa1d0d347712cf5fd878e83a29ff", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c1fd5f8b7351085765217b198c6d5a8c0026b74/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c1fd5f8b7351085765217b198c6d5a8c0026b74/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=5c1fd5f8b7351085765217b198c6d5a8c0026b74", "patch": "@@ -91,7 +91,7 @@ Some examples of obvious things you might want to do\n     # // locally, we still want to be type checking this code, so lets\n     # // just stop it running (#11576)\n     # if false {\n-    let mut socket = TcpStream::connect(\"127.0.0.1\", 8080).unwrap();\n+    let mut socket = TcpStream::connect(\"127.0.0.1:8080\").unwrap();\n     socket.write(b\"GET / HTTP/1.0\\n\\n\");\n     let response = socket.read_to_end();\n     # }\n@@ -106,7 +106,7 @@ Some examples of obvious things you might want to do\n     use std::io::{TcpListener, TcpStream};\n     use std::io::{Acceptor, Listener};\n \n-    let listener = TcpListener::bind(\"127.0.0.1\", 80);\n+    let listener = TcpListener::bind(\"127.0.0.1:80\");\n \n     // bind the listener to the specified address\n     let mut acceptor = listener.listen();"}, {"sha": "b4e9f7502e47c9e259b1eca81c3bd60f9006ca57", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/5c1fd5f8b7351085765217b198c6d5a8c0026b74/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c1fd5f8b7351085765217b198c6d5a8c0026b74/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=5c1fd5f8b7351085765217b198c6d5a8c0026b74", "patch": "@@ -17,10 +17,14 @@\n \n use fmt;\n use from_str::FromStr;\n+use io::{mod, IoResult, IoError};\n+use io::net;\n use iter::Iterator;\n use option::{Option, None, Some};\n+use result::{Ok, Err};\n use str::StrSlice;\n use slice::{MutableCloneableSlice, MutableSlice, ImmutableSlice};\n+use vec::Vec;\n \n pub type Port = u16;\n \n@@ -348,6 +352,189 @@ impl FromStr for SocketAddr {\n     }\n }\n \n+/// A trait for objects which can be converted or resolved to one or more `SocketAddr` values.\n+///\n+/// Implementing types minimally have to implement either `to_socket_addr` or `to_socket_addr_all`\n+/// method, and its trivial counterpart will be available automatically.\n+///\n+/// This trait is used for generic address resolution when constructing network objects.\n+/// By default it is implemented for the following types:\n+///\n+///  * `SocketAddr` - `to_socket_addr` is identity function.\n+///\n+///  * `(IpAddr, u16)` - `to_socket_addr` constructs `SocketAddr` trivially.\n+///\n+///  * `(&str, u16)` - the string should be either a string representation of an IP address\n+///    expected by `FromStr` implementation for `IpAddr` or a host name.\n+///\n+///    For the former, `to_socket_addr_all` returns a vector with a single element corresponding\n+///    to that IP address joined with the given port.\n+///\n+///    For the latter, it tries to resolve the host name and returns a vector of all IP addresses\n+///    for the host name, each joined with the given port.\n+///\n+///  * `&str` - the string should be either a string representation of a `SocketAddr` as\n+///    expected by its `FromStr` implementation or a string like `<host_name>:<port>` pair\n+///    where `<port>` is a `u16` value.\n+///\n+///    For the former, `to_socker_addr_all` returns a vector with a single element corresponding\n+///    to that socker address.\n+///\n+///    For the latter, it tries to resolve the host name and returns a vector of all IP addresses\n+///    for the host name, each joined with the port.\n+///\n+///\n+/// This trait allows constructing network objects like `TcpStream` or `UdpSocket` easily with\n+/// values of various types for the bind/connection address. It is needed because sometimes\n+/// one type is more appropriate than the other: for simple uses a string like `\"localhost:12345\"`\n+/// is much nicer than manual construction of the corresponding `SocketAddr`, but sometimes\n+/// `SocketAddr` value is *the* main source of the address, and converting it to some other type\n+/// (e.g. a string) just for it to be converted back to `SocketAddr` in constructor methods\n+/// is pointless.\n+///\n+/// Some examples:\n+///\n+/// ```rust,no_run\n+/// # #![allow(unused_must_use)]\n+///\n+/// use std::io::{TcpStream, TcpListener};\n+/// use std::io::net::udp::UdpSocket;\n+/// use std::io::net::ip::{Ipv4Addr, SocketAddr};\n+///\n+/// fn main() {\n+///     // The following lines are equivalent modulo possible \"localhost\" name resolution\n+///     // differences\n+///     let tcp_s = TcpStream::connect(SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 12345 });\n+///     let tcp_s = TcpStream::connect((Ipv4Addr(127, 0, 0, 1), 12345u16));\n+///     let tcp_s = TcpStream::connect((\"127.0.0.1\", 12345u16));\n+///     let tcp_s = TcpStream::connect((\"localhost\", 12345u16));\n+///     let tcp_s = TcpStream::connect(\"127.0.0.1:12345\");\n+///     let tcp_s = TcpStream::connect(\"localhost:12345\");\n+///\n+///     // TcpListener::bind(), UdpSocket::bind() and UdpSocket::send_to() behave similarly\n+///     let tcp_l = TcpListener::bind(\"localhost:12345\");\n+///\n+///     let mut udp_s = UdpSocket::bind((\"127.0.0.1\", 23451u16)).unwrap();\n+///     udp_s.send_to([7u8, 7u8, 7u8].as_slice(), (Ipv4Addr(127, 0, 0, 1), 23451u16));\n+/// }\n+/// ```\n+pub trait ToSocketAddr {\n+    /// Converts this object to single socket address value.\n+    ///\n+    /// If more than one value is available, this method returns the first one. If no\n+    /// values are available, this method returns an `IoError`.\n+    ///\n+    /// By default this method delegates to `to_socket_addr_all` method, taking the first\n+    /// item from its result.\n+    fn to_socket_addr(&self) -> IoResult<SocketAddr> {\n+        self.to_socket_addr_all()\n+            .and_then(|v| v.into_iter().next().ok_or_else(|| IoError {\n+                kind: io::InvalidInput,\n+                desc: \"no address available\",\n+                detail: None\n+            }))\n+    }\n+\n+    /// Converts this object to all available socket address values.\n+    ///\n+    /// Some values like host name string naturally corrrespond to multiple IP addresses.\n+    /// This method tries to return all available addresses corresponding to this object.\n+    ///\n+    /// By default this method delegates to `to_socket_addr` method, creating a singleton\n+    /// vector from its result.\n+    #[inline]\n+    fn to_socket_addr_all(&self) -> IoResult<Vec<SocketAddr>> {\n+        self.to_socket_addr().map(|a| vec![a])\n+    }\n+}\n+\n+impl ToSocketAddr for SocketAddr {\n+    #[inline]\n+    fn to_socket_addr(&self) -> IoResult<SocketAddr> { Ok(*self) }\n+}\n+\n+impl ToSocketAddr for (IpAddr, u16) {\n+    #[inline]\n+    fn to_socket_addr(&self) -> IoResult<SocketAddr> {\n+        let (ip, port) = *self;\n+        Ok(SocketAddr { ip: ip, port: port })\n+    }\n+}\n+\n+fn resolve_socket_addr(s: &str, p: u16) -> IoResult<Vec<SocketAddr>> {\n+    net::get_host_addresses(s)\n+        .map(|v| v.into_iter().map(|a| SocketAddr { ip: a, port: p }).collect())\n+}\n+\n+fn parse_and_resolve_socket_addr(s: &str) -> IoResult<Vec<SocketAddr>> {\n+    macro_rules! try_opt(\n+        ($e:expr, $msg:expr) => (\n+            match $e {\n+                Some(r) => r,\n+                None => return Err(IoError {\n+                    kind: io::InvalidInput,\n+                    desc: $msg,\n+                    detail: None\n+                })\n+            }\n+        )\n+    )\n+\n+    // split the string by ':' and convert the second part to u16\n+    let mut parts_iter = s.rsplitn(2, ':');\n+    let port_str = try_opt!(parts_iter.next(), \"invalid socket address\");\n+    let host = try_opt!(parts_iter.next(), \"invalid socket address\");\n+    let port: u16 = try_opt!(FromStr::from_str(port_str), \"invalid port value\");\n+    resolve_socket_addr(host, port)\n+}\n+\n+impl<'a> ToSocketAddr for (&'a str, u16) {\n+    fn to_socket_addr_all(&self) -> IoResult<Vec<SocketAddr>> {\n+        let (host, port) = *self;\n+\n+        // try to parse the host as a regular IpAddr first\n+        match FromStr::from_str(host) {\n+            Some(addr) => return Ok(vec![SocketAddr {\n+                ip: addr,\n+                port: port\n+            }]),\n+            None => {}\n+        }\n+\n+        resolve_socket_addr(host, port)\n+    }\n+}\n+\n+// accepts strings like 'localhost:12345'\n+impl<'a> ToSocketAddr for &'a str {\n+    fn to_socket_addr(&self) -> IoResult<SocketAddr> {\n+        // try to parse as a regular SocketAddr first\n+        match FromStr::from_str(*self) {\n+            Some(addr) => return Ok(addr),\n+            None => {}\n+        }\n+\n+        parse_and_resolve_socket_addr(*self)\n+            .and_then(|v| v.into_iter().next()\n+                .ok_or_else(|| IoError {\n+                    kind: io::InvalidInput,\n+                    desc: \"no address available\",\n+                    detail: None\n+                })\n+            )\n+    }\n+\n+    fn to_socket_addr_all(&self) -> IoResult<Vec<SocketAddr>> {\n+        // try to parse as a regular SocketAddr first\n+        match FromStr::from_str(*self) {\n+            Some(addr) => return Ok(vec![addr]),\n+            None => {}\n+        }\n+\n+        parse_and_resolve_socket_addr(*self)\n+    }\n+}\n+\n \n #[cfg(test)]\n mod test {\n@@ -457,4 +644,48 @@ mod test {\n         assert_eq!(Ipv6Addr(8, 9, 10, 11, 12, 13, 14, 15).to_string(),\n                    \"8:9:a:b:c:d:e:f\".to_string());\n     }\n+\n+    #[test]\n+    fn to_socket_addr_socketaddr() {\n+        let a = SocketAddr { ip: Ipv4Addr(77, 88, 21, 11), port: 12345 };\n+        assert_eq!(Ok(a), a.to_socket_addr());\n+        assert_eq!(Ok(vec![a]), a.to_socket_addr_all());\n+    }\n+\n+    #[test]\n+    fn to_socket_addr_ipaddr_u16() {\n+        let a = Ipv4Addr(77, 88, 21, 11);\n+        let p = 12345u16;\n+        let e = SocketAddr { ip: a, port: p };\n+        assert_eq!(Ok(e), (a, p).to_socket_addr());\n+        assert_eq!(Ok(vec![e]), (a, p).to_socket_addr_all());\n+    }\n+\n+    #[test]\n+    fn to_socket_addr_str_u16() {\n+        let a = SocketAddr { ip: Ipv4Addr(77, 88, 21, 11), port: 24352 };\n+        assert_eq!(Ok(a), (\"77.88.21.11\", 24352u16).to_socket_addr());\n+        assert_eq!(Ok(vec![a]), (\"77.88.21.11\", 24352u16).to_socket_addr_all());\n+\n+        let a = SocketAddr { ip: Ipv6Addr(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), port: 53 };\n+        assert_eq!(Ok(a), (\"2a02:6b8:0:1::1\", 53).to_socket_addr());\n+        assert_eq!(Ok(vec![a]), (\"2a02:6b8:0:1::1\", 53).to_socket_addr_all());\n+\n+        let a = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 23924 };\n+        assert!((\"localhost\", 23924u16).to_socket_addr_all().unwrap().contains(&a));\n+    }\n+\n+    #[test]\n+    fn to_socket_addr_str() {\n+        let a = SocketAddr { ip: Ipv4Addr(77, 88, 21, 11), port: 24352 };\n+        assert_eq!(Ok(a), \"77.88.21.11:24352\".to_socket_addr());\n+        assert_eq!(Ok(vec![a]), \"77.88.21.11:24352\".to_socket_addr_all());\n+\n+        let a = SocketAddr { ip: Ipv6Addr(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), port: 53 };\n+        assert_eq!(Ok(a), \"[2a02:6b8:0:1::1]:53\".to_socket_addr());\n+        assert_eq!(Ok(vec![a]), \"[2a02:6b8:0:1::1]:53\".to_socket_addr_all());\n+\n+        let a = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 23924 };\n+        assert!(\"localhost:23924\".to_socket_addr_all().unwrap().contains(&a));\n+    }\n }"}, {"sha": "b9b50a55a10f25e160828c88eadbf57b42df3270", "filename": "src/libstd/io/net/mod.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5c1fd5f8b7351085765217b198c6d5a8c0026b74/src%2Flibstd%2Fio%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c1fd5f8b7351085765217b198c6d5a8c0026b74/src%2Flibstd%2Fio%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fmod.rs?ref=5c1fd5f8b7351085765217b198c6d5a8c0026b74", "patch": "@@ -10,8 +10,11 @@\n \n //! Networking I/O\n \n+use io::{IoError, IoResult, InvalidInput};\n+use option::None;\n+use result::{Result, Ok, Err};\n use rt::rtio;\n-use self::ip::{Ipv4Addr, Ipv6Addr, IpAddr};\n+use self::ip::{Ipv4Addr, Ipv6Addr, IpAddr, SocketAddr, ToSocketAddr};\n \n pub use self::addrinfo::get_host_addresses;\n \n@@ -38,3 +41,44 @@ fn from_rtio(ip: rtio::IpAddr) -> IpAddr {\n         }\n     }\n }\n+\n+fn with_addresses_io<A: ToSocketAddr, T>(\n+    addr: A,\n+    action: |&mut rtio::IoFactory, rtio::SocketAddr| -> Result<T, rtio::IoError>\n+) -> Result<T, IoError> {\n+    const DEFAULT_ERROR: IoError = IoError {\n+        kind: InvalidInput,\n+        desc: \"no addresses found for hostname\",\n+        detail: None\n+    };\n+\n+    let addresses = try!(addr.to_socket_addr_all());\n+    let mut err = DEFAULT_ERROR;\n+    for addr in addresses.into_iter() {\n+        let addr = rtio::SocketAddr { ip: to_rtio(addr.ip), port: addr.port };\n+        match rtio::LocalIo::maybe_raise(|io| action(io, addr)) {\n+            Ok(r) => return Ok(r),\n+            Err(e) => err = IoError::from_rtio_error(e)\n+        }\n+    }\n+    Err(err)\n+}\n+\n+fn with_addresses<A: ToSocketAddr, T>(addr: A, action: |SocketAddr| -> IoResult<T>)\n+    -> IoResult<T> {\n+    const DEFAULT_ERROR: IoError = IoError {\n+        kind: InvalidInput,\n+        desc: \"no addresses found for hostname\",\n+        detail: None\n+    };\n+\n+    let addresses = try!(addr.to_socket_addr_all());\n+    let mut err = DEFAULT_ERROR;\n+    for addr in addresses.into_iter() {\n+        match action(addr) {\n+            Ok(r) => return Ok(r),\n+            Err(e) => err = e\n+        }\n+    }\n+    Err(err)\n+}"}, {"sha": "928c858673963773ee02d9d5cc5f1475125ce867", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 109, "deletions": 231, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/5c1fd5f8b7351085765217b198c6d5a8c0026b74/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c1fd5f8b7351085765217b198c6d5a8c0026b74/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=5c1fd5f8b7351085765217b198c6d5a8c0026b74", "patch": "@@ -20,18 +20,15 @@\n use clone::Clone;\n use io::IoResult;\n use iter::Iterator;\n-use slice::ImmutableSlice;\n use result::{Ok,Err};\n-use io::net::addrinfo::get_host_addresses;\n-use io::net::ip::SocketAddr;\n-use io::{IoError, ConnectionFailed, InvalidInput};\n+use io::net::ip::{SocketAddr, ToSocketAddr};\n+use io::IoError;\n use io::{Reader, Writer, Listener, Acceptor};\n use io::{standard_error, TimedOut};\n-use from_str::FromStr;\n use kinds::Send;\n use option::{None, Some, Option};\n use boxed::Box;\n-use rt::rtio::{IoFactory, LocalIo, RtioSocket, RtioTcpListener};\n+use rt::rtio::{IoFactory, RtioSocket, RtioTcpListener};\n use rt::rtio::{RtioTcpAcceptor, RtioTcpStream};\n use rt::rtio;\n use time::Duration;\n@@ -45,7 +42,7 @@ use time::Duration;\n /// # #![allow(unused_must_use)]\n /// use std::io::TcpStream;\n ///\n-/// let mut stream = TcpStream::connect(\"127.0.0.1\", 34254);\n+/// let mut stream = TcpStream::connect(\"127.0.0.1:34254\");\n ///\n /// stream.write([1]);\n /// let mut buf = [0];\n@@ -61,35 +58,13 @@ impl TcpStream {\n         TcpStream { obj: s }\n     }\n \n-    /// Open a TCP connection to a remote host by hostname or IP address.\n+    /// Open a TCP connection to a remote host.\n     ///\n-    /// `host` can be a hostname or IP address string. If no error is\n-    /// encountered, then `Ok(stream)` is returned.\n-    pub fn connect(host: &str, port: u16) -> IoResult<TcpStream> {\n-        let addresses = match FromStr::from_str(host) {\n-            Some(addr) => vec!(addr),\n-            None => try!(get_host_addresses(host))\n-        };\n-        let mut err = IoError {\n-            kind: ConnectionFailed,\n-            desc: \"no addresses found for hostname\",\n-            detail: None\n-        };\n-        for addr in addresses.iter() {\n-            let addr = rtio::SocketAddr{ ip: super::to_rtio(*addr), port: port };\n-            let result = LocalIo::maybe_raise(|io| {\n-                io.tcp_connect(addr, None).map(TcpStream::new)\n-            });\n-            match result {\n-                Ok(stream) => {\n-                    return Ok(stream)\n-                }\n-                Err(connect_err) => {\n-                    err = IoError::from_rtio_error(connect_err)\n-                }\n-            }\n-        }\n-        Err(err)\n+    /// `addr` is an address of the remote host. Anything which implements `ToSocketAddr`\n+    /// trait can be supplied for the address; see this trait documentation for\n+    /// concrete examples.\n+    pub fn connect<A: ToSocketAddr>(addr: A) -> IoResult<TcpStream> {\n+        super::with_addresses_io(addr, |io, addr| io.tcp_connect(addr, None).map(TcpStream::new))\n     }\n \n     /// Creates a TCP connection to a remote socket address, timing out after\n@@ -99,23 +74,21 @@ impl TcpStream {\n     /// specified elapses before a connection is made an error will be\n     /// returned. The error's kind will be `TimedOut`.\n     ///\n-    /// Note that the `addr` argument may one day be split into a separate host\n-    /// and port, similar to the API seen in `connect`.\n+    /// Same as the `connect` method, `addr` argument type can be anything which\n+    /// implements `ToSocketAddr` trait.\n     ///\n     /// If a `timeout` with zero or negative duration is specified then\n     /// the function returns `Err`, with the error kind set to `TimedOut`.\n     #[experimental = \"the timeout argument may eventually change types\"]\n-    pub fn connect_timeout(addr: SocketAddr,\n-                           timeout: Duration) -> IoResult<TcpStream> {\n+    pub fn connect_timeout<A: ToSocketAddr>(addr: A,\n+                                            timeout: Duration) -> IoResult<TcpStream> {\n         if timeout <= Duration::milliseconds(0) {\n             return Err(standard_error(TimedOut));\n         }\n \n-        let SocketAddr { ip, port } = addr;\n-        let addr = rtio::SocketAddr { ip: super::to_rtio(ip), port: port };\n-        LocalIo::maybe_raise(|io| {\n+        super::with_addresses_io(addr, |io, addr|\n             io.tcp_connect(addr, Some(timeout.num_milliseconds() as u64)).map(TcpStream::new)\n-        }).map_err(IoError::from_rtio_error)\n+        )\n     }\n \n     /// Returns the socket address of the remote peer of this TCP connection.\n@@ -174,7 +147,7 @@ impl TcpStream {\n     /// use std::io::TcpStream;\n     /// use std::time::Duration;\n     ///\n-    /// let mut stream = TcpStream::connect(\"127.0.0.1\", 34254).unwrap();\n+    /// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n     /// let stream2 = stream.clone();\n     ///\n     /// spawn(proc() {\n@@ -311,7 +284,7 @@ impl Writer for TcpStream {\n /// use std::io::{TcpListener, TcpStream};\n /// use std::io::{Acceptor, Listener};\n ///\n-/// let listener = TcpListener::bind(\"127.0.0.1\", 80);\n+/// let listener = TcpListener::bind(\"127.0.0.1:80\");\n ///\n /// // bind the listener to the specified address\n /// let mut acceptor = listener.listen();\n@@ -340,32 +313,18 @@ pub struct TcpListener {\n }\n \n impl TcpListener {\n-    /// Creates a new `TcpListener` which will be bound to the specified IP\n-    /// and port. This listener is not ready for accepting connections,\n-    /// `listen` must be called on it before that's possible.\n+    /// Creates a new `TcpListener` which will be bound to the specified address.\n+    /// This listener is not ready for accepting connections, `listen` must be called\n+    /// on it before that's possible.\n     ///\n     /// Binding with a port number of 0 will request that the OS assigns a port\n     /// to this listener. The port allocated can be queried via the\n     /// `socket_name` function.\n-    pub fn bind(addr: &str, port: u16) -> IoResult<TcpListener> {\n-        match FromStr::from_str(addr) {\n-            Some(ip) => {\n-                let addr = rtio::SocketAddr{\n-                    ip: super::to_rtio(ip),\n-                    port: port,\n-                };\n-                LocalIo::maybe_raise(|io| {\n-                    io.tcp_bind(addr).map(|l| TcpListener { obj: l })\n-                }).map_err(IoError::from_rtio_error)\n-            }\n-            None => {\n-                Err(IoError{\n-                    kind: InvalidInput,\n-                    desc: \"invalid IP address specified\",\n-                    detail: None\n-                })\n-            }\n-        }\n+    ///\n+    /// The address type can be any implementor of `ToSocketAddr` trait. See its\n+    /// documentation for concrete examples.\n+    pub fn bind<A: ToSocketAddr>(addr: A) -> IoResult<TcpListener> {\n+        super::with_addresses_io(addr, |io, addr| io.tcp_bind(addr).map(|l| TcpListener { obj: l }))\n     }\n \n     /// Returns the local socket address of this listener.\n@@ -419,7 +378,7 @@ impl TcpAcceptor {\n     /// use std::io::TcpListener;\n     /// use std::io::{Listener, Acceptor, TimedOut};\n     ///\n-    /// let mut a = TcpListener::bind(\"127.0.0.1\", 8482).listen().unwrap();\n+    /// let mut a = TcpListener::bind(\"127.0.0.1:8482\").listen().unwrap();\n     ///\n     /// // After 100ms have passed, all accepts will fail\n     /// a.set_timeout(Some(100));\n@@ -462,7 +421,7 @@ impl TcpAcceptor {\n     /// # #![allow(experimental)]\n     /// use std::io::{TcpListener, Listener, Acceptor, EndOfFile};\n     ///\n-    /// let mut a = TcpListener::bind(\"127.0.0.1\", 8482).listen().unwrap();\n+    /// let mut a = TcpListener::bind(\"127.0.0.1:8482\").listen().unwrap();\n     /// let a2 = a.clone();\n     ///\n     /// spawn(proc() {\n@@ -531,15 +490,15 @@ mod test {\n     #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n     #[test]\n     fn bind_error() {\n-        match TcpListener::bind(\"0.0.0.0\", 1) {\n+        match TcpListener::bind(\"0.0.0.0:1\") {\n             Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, PermissionDenied),\n         }\n     }\n \n     #[test]\n     fn connect_error() {\n-        match TcpStream::connect(\"0.0.0.0\", 1) {\n+        match TcpStream::connect(\"0.0.0.0:1\") {\n             Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, ConnectionRefused),\n         }\n@@ -548,13 +507,11 @@ mod test {\n     #[test]\n     fn listen_ip4_localhost() {\n         let socket_addr = next_test_ip4();\n-        let ip_str = socket_addr.ip.to_string();\n-        let port = socket_addr.port;\n-        let listener = TcpListener::bind(ip_str.as_slice(), port);\n+        let listener = TcpListener::bind(socket_addr);\n         let mut acceptor = listener.listen();\n \n         spawn(proc() {\n-            let mut stream = TcpStream::connect(\"localhost\", port);\n+            let mut stream = TcpStream::connect((\"localhost\", socket_addr.port));\n             stream.write([144]).unwrap();\n         });\n \n@@ -567,12 +524,10 @@ mod test {\n     #[test]\n     fn connect_localhost() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let mut stream = TcpStream::connect(\"localhost\", addr.port);\n+            let mut stream = TcpStream::connect((\"localhost\", addr.port));\n             stream.write([64]).unwrap();\n         });\n \n@@ -585,12 +540,10 @@ mod test {\n     #[test]\n     fn connect_ip4_loopback() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let mut stream = TcpStream::connect(\"127.0.0.1\", addr.port);\n+            let mut stream = TcpStream::connect((\"127.0.0.1\", addr.port));\n             stream.write([44]).unwrap();\n         });\n \n@@ -603,12 +556,10 @@ mod test {\n     #[test]\n     fn connect_ip6_loopback() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let mut stream = TcpStream::connect(\"::1\", addr.port);\n+            let mut stream = TcpStream::connect((\"::1\", addr.port));\n             stream.write([66]).unwrap();\n         });\n \n@@ -621,12 +572,10 @@ mod test {\n     #[test]\n     fn smoke_test_ip4() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n+            let mut stream = TcpStream::connect(addr);\n             stream.write([99]).unwrap();\n         });\n \n@@ -639,12 +588,10 @@ mod test {\n     #[test]\n     fn smoke_test_ip6() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n+            let mut stream = TcpStream::connect(addr);\n             stream.write([99]).unwrap();\n         });\n \n@@ -657,12 +604,10 @@ mod test {\n     #[test]\n     fn read_eof_ip4() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(ip_str.as_slice(), port);\n+            let _stream = TcpStream::connect(addr);\n             // Close\n         });\n \n@@ -675,12 +620,10 @@ mod test {\n     #[test]\n     fn read_eof_ip6() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(ip_str.as_slice(), port);\n+            let _stream = TcpStream::connect(addr);\n             // Close\n         });\n \n@@ -693,12 +636,10 @@ mod test {\n     #[test]\n     fn read_eof_twice_ip4() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(ip_str.as_slice(), port);\n+            let _stream = TcpStream::connect(addr);\n             // Close\n         });\n \n@@ -719,12 +660,10 @@ mod test {\n     #[test]\n     fn read_eof_twice_ip6() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(ip_str.as_slice(), port);\n+            let _stream = TcpStream::connect(addr);\n             // Close\n         });\n \n@@ -745,12 +684,10 @@ mod test {\n     #[test]\n     fn write_close_ip4() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(ip_str.as_slice(), port);\n+            let _stream = TcpStream::connect(addr);\n             // Close\n         });\n \n@@ -773,12 +710,10 @@ mod test {\n     #[test]\n     fn write_close_ip6() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(ip_str.as_slice(), port);\n+            let _stream = TcpStream::connect(addr);\n             // Close\n         });\n \n@@ -801,14 +736,12 @@ mod test {\n     #[test]\n     fn multiple_connect_serial_ip4() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n         let max = 10u;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n             for _ in range(0, max) {\n-                let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n+                let mut stream = TcpStream::connect(addr);\n                 stream.write([99]).unwrap();\n             }\n         });\n@@ -823,14 +756,12 @@ mod test {\n     #[test]\n     fn multiple_connect_serial_ip6() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n         let max = 10u;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n             for _ in range(0, max) {\n-                let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n+                let mut stream = TcpStream::connect(addr);\n                 stream.write([99]).unwrap();\n             }\n         });\n@@ -845,10 +776,8 @@ mod test {\n     #[test]\n     fn multiple_connect_interleaved_greedy_schedule_ip4() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n         static MAX: int = 10;\n-        let acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n             let mut acceptor = acceptor;\n@@ -867,13 +796,11 @@ mod test {\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n-            let ip_str = addr.ip.to_string();\n-            let port = addr.port;\n             if i == MAX { return }\n \n             spawn(proc() {\n                 debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n+                let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n@@ -885,10 +812,8 @@ mod test {\n     #[test]\n     fn multiple_connect_interleaved_greedy_schedule_ip6() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n         static MAX: int = 10;\n-        let acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n             let mut acceptor = acceptor;\n@@ -907,13 +832,11 @@ mod test {\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n-            let ip_str = addr.ip.to_string();\n-            let port = addr.port;\n             if i == MAX { return }\n \n             spawn(proc() {\n                 debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n+                let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n@@ -926,9 +849,7 @@ mod test {\n     fn multiple_connect_interleaved_lazy_schedule_ip4() {\n         static MAX: int = 10;\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n             let mut acceptor = acceptor;\n@@ -947,13 +868,11 @@ mod test {\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n-            let ip_str = addr.ip.to_string();\n-            let port = addr.port;\n             if i == MAX { return }\n \n             spawn(proc() {\n                 debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n+                let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n@@ -966,9 +885,7 @@ mod test {\n     fn multiple_connect_interleaved_lazy_schedule_ip6() {\n         static MAX: int = 10;\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n             let mut acceptor = acceptor;\n@@ -987,13 +904,11 @@ mod test {\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n-            let ip_str = addr.ip.to_string();\n-            let port = addr.port;\n             if i == MAX { return }\n \n             spawn(proc() {\n                 debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n+                let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n@@ -1003,9 +918,7 @@ mod test {\n     }\n \n     pub fn socket_name(addr: SocketAddr) {\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut listener = TcpListener::bind(ip_str.as_slice(), port).unwrap();\n+        let mut listener = TcpListener::bind(addr).unwrap();\n \n         // Make sure socket_name gives\n         // us the socket we binded to.\n@@ -1015,15 +928,13 @@ mod test {\n     }\n \n     pub fn peer_name(addr: SocketAddr) {\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let acceptor = TcpListener::bind(addr).listen();\n         spawn(proc() {\n             let mut acceptor = acceptor;\n             acceptor.accept().unwrap();\n         });\n \n-        let stream = TcpStream::connect(ip_str.as_slice(), port);\n+        let stream = TcpStream::connect(addr);\n \n         assert!(stream.is_ok());\n         let mut stream = stream.unwrap();\n@@ -1052,11 +963,9 @@ mod test {\n     #[test]\n     fn partial_read() {\n         let addr = next_test_ip4();\n-        let port = addr.port;\n         let (tx, rx) = channel();\n         spawn(proc() {\n-            let ip_str = addr.ip.to_string();\n-            let mut srv = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n+            let mut srv = TcpListener::bind(addr).listen().unwrap();\n             tx.send(());\n             let mut cl = srv.accept().unwrap();\n             cl.write([10]).unwrap();\n@@ -1066,8 +975,7 @@ mod test {\n         });\n \n         rx.recv();\n-        let ip_str = addr.ip.to_string();\n-        let mut c = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n+        let mut c = TcpStream::connect(addr).unwrap();\n         let mut b = [0, ..10];\n         assert_eq!(c.read(b), Ok(1));\n         c.write([1]).unwrap();\n@@ -1077,11 +985,9 @@ mod test {\n     #[test]\n     fn double_bind() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let listener = TcpListener::bind(ip_str.as_slice(), port).unwrap().listen();\n+        let listener = TcpListener::bind(addr).unwrap().listen();\n         assert!(listener.is_ok());\n-        match TcpListener::bind(ip_str.as_slice(), port).listen() {\n+        match TcpListener::bind(addr).listen() {\n             Ok(..) => panic!(),\n             Err(e) => {\n                 assert!(e.kind == ConnectionRefused || e.kind == OtherIoError,\n@@ -1093,20 +999,17 @@ mod test {\n     #[test]\n     fn fast_rebind() {\n         let addr = next_test_ip4();\n-        let port = addr.port;\n         let (tx, rx) = channel();\n \n         spawn(proc() {\n-            let ip_str = addr.ip.to_string();\n             rx.recv();\n-            let _stream = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n+            let _stream = TcpStream::connect(addr).unwrap();\n             // Close\n             rx.recv();\n         });\n \n         {\n-            let ip_str = addr.ip.to_string();\n-            let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+            let mut acceptor = TcpListener::bind(addr).listen();\n             tx.send(());\n             {\n                 let _stream = acceptor.accept().unwrap();\n@@ -1115,18 +1018,16 @@ mod test {\n             }\n             // Close listener\n         }\n-        let _listener = TcpListener::bind(addr.ip.to_string().as_slice(), port);\n+        let _listener = TcpListener::bind(addr);\n     }\n \n     #[test]\n     fn tcp_clone_smoke() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str.as_slice(), port);\n+            let mut s = TcpStream::connect(addr);\n             let mut buf = [0, 0];\n             assert_eq!(s.read(buf), Ok(1));\n             assert_eq!(buf[0], 1);\n@@ -1153,14 +1054,12 @@ mod test {\n     #[test]\n     fn tcp_clone_two_read() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n         let (tx1, rx) = channel();\n         let tx2 = tx1.clone();\n \n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str.as_slice(), port);\n+            let mut s = TcpStream::connect(addr);\n             s.write([1]).unwrap();\n             rx.recv();\n             s.write([2]).unwrap();\n@@ -1188,12 +1087,10 @@ mod test {\n     #[test]\n     fn tcp_clone_two_write() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str.as_slice(), port);\n+            let mut s = TcpStream::connect(addr);\n             let mut buf = [0, 1];\n             s.read(buf).unwrap();\n             s.read(buf).unwrap();\n@@ -1218,17 +1115,15 @@ mod test {\n         use rt::rtio::RtioTcpStream;\n \n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let a = TcpListener::bind(ip_str.as_slice(), port).unwrap().listen();\n+        let a = TcpListener::bind(addr).unwrap().listen();\n         spawn(proc() {\n             let mut a = a;\n             let mut c = a.accept().unwrap();\n             assert_eq!(c.read_to_end(), Ok(vec!()));\n             c.write([1]).unwrap();\n         });\n \n-        let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n+        let mut s = TcpStream::connect(addr).unwrap();\n         assert!(s.obj.close_write().is_ok());\n         assert!(s.write([1]).is_err());\n         assert_eq!(s.read_to_end(), Ok(vec!(1)));\n@@ -1237,9 +1132,7 @@ mod test {\n     #[test]\n     fn accept_timeout() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut a = TcpListener::bind(ip_str.as_slice(), port).unwrap().listen().unwrap();\n+        let mut a = TcpListener::bind(addr).unwrap().listen().unwrap();\n \n         a.set_timeout(Some(10));\n \n@@ -1258,8 +1151,7 @@ mod test {\n         if !cfg!(target_os = \"freebsd\") {\n             let (tx, rx) = channel();\n             spawn(proc() {\n-                tx.send(TcpStream::connect(addr.ip.to_string().as_slice(),\n-                                           port).unwrap());\n+                tx.send(TcpStream::connect(addr).unwrap());\n             });\n             let _l = rx.recv();\n             for i in range(0i, 1001) {\n@@ -1276,18 +1168,15 @@ mod test {\n         // Unset the timeout and make sure that this always blocks.\n         a.set_timeout(None);\n         spawn(proc() {\n-            drop(TcpStream::connect(addr.ip.to_string().as_slice(),\n-                                    port).unwrap());\n+            drop(TcpStream::connect(addr).unwrap());\n         });\n         a.accept().unwrap();\n     }\n \n     #[test]\n     fn close_readwrite_smoke() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n+        let a = TcpListener::bind(addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n         spawn(proc() {\n             let mut a = a;\n@@ -1296,7 +1185,7 @@ mod test {\n         });\n \n         let mut b = [0];\n-        let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n+        let mut s = TcpStream::connect(addr).unwrap();\n         let mut s2 = s.clone();\n \n         // closing should prevent reads/writes\n@@ -1324,17 +1213,15 @@ mod test {\n     #[test]\n     fn close_read_wakes_up() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n+        let a = TcpListener::bind(addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n         spawn(proc() {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n             let _ = rx.recv_opt();\n         });\n \n-        let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n+        let mut s = TcpStream::connect(addr).unwrap();\n         let s2 = s.clone();\n         let (tx, rx) = channel();\n         spawn(proc() {\n@@ -1352,12 +1239,10 @@ mod test {\n     #[test]\n     fn readwrite_timeouts() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n+        let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n+            let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv();\n             assert!(s.write([0]).is_ok());\n             let _ = rx.recv_opt();\n@@ -1387,12 +1272,10 @@ mod test {\n     #[test]\n     fn read_timeouts() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n+        let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n+            let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv();\n             let mut amt = 0;\n             while amt < 100 * 128 * 1024 {\n@@ -1418,12 +1301,10 @@ mod test {\n     #[test]\n     fn write_timeouts() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n+        let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n+            let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv();\n             assert!(s.write([0]).is_ok());\n             let _ = rx.recv_opt();\n@@ -1448,12 +1329,10 @@ mod test {\n     #[test]\n     fn timeout_concurrent_read() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n+        let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n+            let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv();\n             assert_eq!(s.write([0]), Ok(()));\n             let _ = rx.recv_opt();\n@@ -1478,16 +1357,15 @@ mod test {\n     #[test]\n     fn clone_while_reading() {\n         let addr = next_test_ip6();\n-        let listen = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n+        let listen = TcpListener::bind(addr);\n         let mut accept = listen.listen().unwrap();\n \n         // Enqueue a task to write to a socket\n         let (tx, rx) = channel();\n         let (txdone, rxdone) = channel();\n         let txdone2 = txdone.clone();\n         spawn(proc() {\n-            let mut tcp = TcpStream::connect(addr.ip.to_string().as_slice(),\n-                                             addr.port).unwrap();\n+            let mut tcp = TcpStream::connect(addr).unwrap();\n             rx.recv();\n             tcp.write_u8(0).unwrap();\n             txdone2.send(());\n@@ -1519,15 +1397,15 @@ mod test {\n     #[test]\n     fn clone_accept_smoke() {\n         let addr = next_test_ip4();\n-        let l = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n+        let l = TcpListener::bind(addr);\n         let mut a = l.listen().unwrap();\n         let mut a2 = a.clone();\n \n         spawn(proc() {\n-            let _ = TcpStream::connect(addr.ip.to_string().as_slice(), addr.port);\n+            let _ = TcpStream::connect(addr);\n         });\n         spawn(proc() {\n-            let _ = TcpStream::connect(addr.ip.to_string().as_slice(), addr.port);\n+            let _ = TcpStream::connect(addr);\n         });\n \n         assert!(a.accept().is_ok());\n@@ -1537,7 +1415,7 @@ mod test {\n     #[test]\n     fn clone_accept_concurrent() {\n         let addr = next_test_ip4();\n-        let l = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n+        let l = TcpListener::bind(addr);\n         let a = l.listen().unwrap();\n         let a2 = a.clone();\n \n@@ -1548,10 +1426,10 @@ mod test {\n         spawn(proc() { let mut a = a2; tx2.send(a.accept()) });\n \n         spawn(proc() {\n-            let _ = TcpStream::connect(addr.ip.to_string().as_slice(), addr.port);\n+            let _ = TcpStream::connect(addr);\n         });\n         spawn(proc() {\n-            let _ = TcpStream::connect(addr.ip.to_string().as_slice(), addr.port);\n+            let _ = TcpStream::connect(addr);\n         });\n \n         assert!(rx.recv().is_ok());\n@@ -1561,7 +1439,7 @@ mod test {\n     #[test]\n     fn close_accept_smoke() {\n         let addr = next_test_ip4();\n-        let l = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n+        let l = TcpListener::bind(addr);\n         let mut a = l.listen().unwrap();\n \n         a.close_accept().unwrap();\n@@ -1571,7 +1449,7 @@ mod test {\n     #[test]\n     fn close_accept_concurrent() {\n         let addr = next_test_ip4();\n-        let l = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n+        let l = TcpListener::bind(addr);\n         let a = l.listen().unwrap();\n         let mut a2 = a.clone();\n "}, {"sha": "4ae054beadb966415d36590ce9eb6c8915db8c13", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5c1fd5f8b7351085765217b198c6d5a8c0026b74/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c1fd5f8b7351085765217b198c6d5a8c0026b74/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=5c1fd5f8b7351085765217b198c6d5a8c0026b74", "patch": "@@ -16,13 +16,13 @@\n //! datagram protocol.\n \n use clone::Clone;\n-use io::net::ip::{SocketAddr, IpAddr};\n+use io::net::ip::{SocketAddr, IpAddr, ToSocketAddr};\n use io::{Reader, Writer, IoResult, IoError};\n use kinds::Send;\n use boxed::Box;\n use option::Option;\n use result::{Ok, Err};\n-use rt::rtio::{RtioSocket, RtioUdpSocket, IoFactory, LocalIo};\n+use rt::rtio::{RtioSocket, RtioUdpSocket, IoFactory};\n use rt::rtio;\n \n /// A User Datagram Protocol socket.\n@@ -64,19 +64,17 @@ pub struct UdpSocket {\n }\n \n impl UdpSocket {\n-    /// Creates a UDP socket from the given socket address.\n-    pub fn bind(addr: SocketAddr) -> IoResult<UdpSocket> {\n-        let SocketAddr { ip, port } = addr;\n-        LocalIo::maybe_raise(|io| {\n-            let addr = rtio::SocketAddr { ip: super::to_rtio(ip), port: port };\n-            io.udp_bind(addr).map(|s| UdpSocket { obj: s })\n-        }).map_err(IoError::from_rtio_error)\n+    /// Creates a UDP socket from the given address.\n+    ///\n+    /// Address type can be any implementor of `ToSocketAddr` trait. See its\n+    /// documentation for concrete examples.\n+    pub fn bind<A: ToSocketAddr>(addr: A) -> IoResult<UdpSocket> {\n+        super::with_addresses_io(addr, |io, addr| io.udp_bind(addr).map(|s| UdpSocket { obj: s }))\n     }\n \n     /// Receives data from the socket. On success, returns the number of bytes\n     /// read and the address from whence the data came.\n-    pub fn recv_from(&mut self, buf: &mut [u8])\n-                    -> IoResult<(uint, SocketAddr)> {\n+    pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)> {\n         match self.obj.recv_from(buf) {\n             Ok((amt, rtio::SocketAddr { ip, port })) => {\n                 Ok((amt, SocketAddr { ip: super::from_rtio(ip), port: port }))\n@@ -87,11 +85,14 @@ impl UdpSocket {\n \n     /// Sends data on the socket to the given address. Returns nothing on\n     /// success.\n-    pub fn send_to(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> {\n-        self.obj.send_to(buf, rtio::SocketAddr {\n-            ip: super::to_rtio(dst.ip),\n-            port: dst.port,\n-        }).map_err(IoError::from_rtio_error)\n+    ///\n+    /// Address type can be any implementor of `ToSocketAddr` trait. See its\n+    /// documentation for concrete examples.\n+    pub fn send_to<A: ToSocketAddr>(&mut self, buf: &[u8], addr: A) -> IoResult<()> {\n+        super::with_addresses(addr, |addr| self.obj.send_to(buf, rtio::SocketAddr {\n+            ip: super::to_rtio(addr.ip),\n+            port: addr.port,\n+        }).map_err(IoError::from_rtio_error))\n     }\n \n     /// Creates a `UdpStream`, which allows use of the `Reader` and `Writer`"}, {"sha": "1ed2efa4b320372b94448b4d8a3be9bab5a3438c", "filename": "src/test/run-pass/tcp-accept-stress.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c1fd5f8b7351085765217b198c6d5a8c0026b74/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c1fd5f8b7351085765217b198c6d5a8c0026b74/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs?ref=5c1fd5f8b7351085765217b198c6d5a8c0026b74", "patch": "@@ -24,7 +24,7 @@ fn main() {\n }\n \n fn test() {\n-    let mut l = TcpListener::bind(\"127.0.0.1\", 0).unwrap();\n+    let mut l = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n     let addr = l.socket_name().unwrap();\n     let mut a = l.listen().unwrap();\n     let cnt = Arc::new(atomic::AtomicUint::new(0));\n@@ -56,8 +56,7 @@ fn test() {\n         let cli_tx = cli_tx.clone();\n         spawn(proc() {\n             for _ in range(0, M) {\n-                let _s = TcpStream::connect(addr.ip.to_string().as_slice(),\n-                                            addr.port).unwrap();\n+                let _s = TcpStream::connect(addr).unwrap();\n             }\n             cli_tx.send(());\n         });"}, {"sha": "7dcbccdb17af0bd8b7bc5506e38ed4b52bfe727f", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c1fd5f8b7351085765217b198c6d5a8c0026b74/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c1fd5f8b7351085765217b198c6d5a8c0026b74/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=5c1fd5f8b7351085765217b198c6d5a8c0026b74", "patch": "@@ -31,13 +31,11 @@ use std::time::Duration;\n #[cfg_attr(target_os = \"freebsd\", ignore)]\n fn eventual_timeout() {\n     let addr = next_test_ip4();\n-    let host = addr.ip.to_string();\n-    let port = addr.port;\n \n     let (tx1, rx1) = channel();\n     let (_tx2, rx2) = channel::<()>();\n     std::task::spawn(proc() {\n-        let _l = TcpListener::bind(host.as_slice(), port).unwrap().listen();\n+        let _l = TcpListener::bind(addr).unwrap().listen();\n         tx1.send(());\n         let _ = rx2.recv_opt();\n     });\n@@ -56,9 +54,7 @@ fn eventual_timeout() {\n \n fn timeout_success() {\n     let addr = next_test_ip4();\n-    let host = addr.ip.to_string();\n-    let port = addr.port;\n-    let _l = TcpListener::bind(host.as_slice(), port).unwrap().listen();\n+    let _l = TcpListener::bind(addr).unwrap().listen();\n \n     assert!(TcpStream::connect_timeout(addr, Duration::milliseconds(1000)).is_ok());\n }"}, {"sha": "676f7e91857f00fd87fb8d3046ad866cb4095c5d", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c1fd5f8b7351085765217b198c6d5a8c0026b74/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c1fd5f8b7351085765217b198c6d5a8c0026b74/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=5c1fd5f8b7351085765217b198c6d5a8c0026b74", "patch": "@@ -33,7 +33,7 @@ fn main() {\n \n     let (tx, rx) = channel();\n     spawn(proc() {\n-        let mut listener = TcpListener::bind(\"127.0.0.1\", 0).unwrap();\n+        let mut listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n         tx.send(listener.socket_name().unwrap());\n         let mut acceptor = listener.listen();\n         loop {\n@@ -54,9 +54,7 @@ fn main() {\n     for _ in range(0u, 1000) {\n         let tx = tx.clone();\n         TaskBuilder::new().stack_size(64 * 1024).spawn(proc() {\n-            let host = addr.ip.to_string();\n-            let port = addr.port;\n-            match TcpStream::connect(host.as_slice(), port) {\n+            match TcpStream::connect(addr) {\n                 Ok(stream) => {\n                     let mut stream = stream;\n                     stream.write([1]);"}]}