{"sha": "64c69aa7b88b3ef66167f26cf681aaeeed33180e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0YzY5YWE3Yjg4YjNlZjY2MTY3ZjI2Y2Y2ODFhYWVlZWQzMzE4MGU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-23T19:13:50Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-23T20:49:37Z"}, "message": "Start on a piecemeal conversion to DPS\n\nIssue #667\n\nWires in a basic framework for destination-passing style, with\nbackwards-compatibility to the old approach, so that expression types\ncan be moved over to it one at a time (by moving them from trans_expr\nto trans_expr_dps).", "tree": {"sha": "e0b1c2cd96552e013037d9b89fc135a592169678", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0b1c2cd96552e013037d9b89fc135a592169678"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64c69aa7b88b3ef66167f26cf681aaeeed33180e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64c69aa7b88b3ef66167f26cf681aaeeed33180e", "html_url": "https://github.com/rust-lang/rust/commit/64c69aa7b88b3ef66167f26cf681aaeeed33180e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64c69aa7b88b3ef66167f26cf681aaeeed33180e/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d114dedf9a892b53977adcbe5eb69e831c7d0e64", "url": "https://api.github.com/repos/rust-lang/rust/commits/d114dedf9a892b53977adcbe5eb69e831c7d0e64", "html_url": "https://github.com/rust-lang/rust/commit/d114dedf9a892b53977adcbe5eb69e831c7d0e64"}], "stats": {"total": 303, "additions": 177, "deletions": 126}, "files": [{"sha": "7de5ea7c6d75b964f48280b0ffb22f0f86b59f75", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 162, "deletions": 115, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/64c69aa7b88b3ef66167f26cf681aaeeed33180e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c69aa7b88b3ef66167f26cf681aaeeed33180e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=64c69aa7b88b3ef66167f26cf681aaeeed33180e", "patch": "@@ -2412,6 +2412,7 @@ fn join_results(parent_cx: @block_ctxt, t: TypeRef, ins: [result]) -> result {\n     ret rslt(join_cx, phi);\n }\n \n+// FIXME remove once all uses have been converted to join_returns\n fn join_branches(parent_cx: @block_ctxt, ins: [result]) -> @block_ctxt {\n     let out = new_sub_block_ctxt(parent_cx, \"join\");\n     let branched = false;\n@@ -2422,38 +2423,107 @@ fn join_branches(parent_cx: @block_ctxt, ins: [result]) -> @block_ctxt {\n     ret out;\n }\n \n-tag out_method { return; save_in(ValueRef); }\n+tag dest {\n+    by_val(@mutable ValueRef);\n+    by_ref(@mutable ValueRef);\n+    save_in(ValueRef);\n+    ignore;\n+}\n+\n+fn empty_dest_cell() -> @mutable ValueRef {\n+    ret @mutable llvm::LLVMGetUndef(T_nil());\n+}\n+\n+fn dup_for_join(dest: dest) -> dest {\n+    alt dest {\n+      by_val(_) { by_val(empty_dest_cell()) }\n+      by_ref(_) { by_ref(empty_dest_cell()) }\n+      _ { dest }\n+    }\n+}\n+\n+fn join_returns(parent_cx: @block_ctxt, in_cxs: [@block_ctxt],\n+                in_ds: [dest], out_dest: dest) -> @block_ctxt {\n+    let out = new_sub_block_ctxt(parent_cx, \"join\");\n+    let reachable = false, i = 0u, phi = none;\n+    for cx in in_cxs {\n+        if !cx.unreachable {\n+            Br(cx, out.llbb);\n+            reachable = true;\n+            alt in_ds[i] {\n+              by_val(cell) | by_ref(cell) {\n+                if option::is_none(phi) {\n+                    phi = some(EmptyPhi(out, val_ty(*cell)));\n+                }\n+                AddIncomingToPhi(option::get(phi), [*cell], [cx.llbb]);\n+              }\n+              _ {}\n+            }\n+        }\n+        i += 1u;\n+    }\n+    if !reachable {\n+        Unreachable(out);\n+    } else {\n+        alt out_dest {\n+          by_val(cell) | by_ref(cell) { *cell = option::get(phi); }\n+          _ {}\n+        }\n+    }\n+    ret out;\n+}\n+\n+// Wrapper through which legacy non-DPS code can use DPS functions\n+fn dps_to_result(bcx: @block_ctxt,\n+                 work: block(@block_ctxt, dest) -> @block_ctxt,\n+                 ty: ty::t) -> result {\n+    let tcx = bcx_tcx(bcx);\n+    if ty::type_is_nil(tcx, ty) || ty::type_is_bot(tcx, ty) {\n+        ret rslt(work(bcx, ignore), C_nil());\n+    } else if type_is_immediate(bcx_ccx(bcx), ty) {\n+        let cell = empty_dest_cell();\n+        bcx = work(bcx, by_val(cell));\n+        add_clean_temp(bcx, *cell, ty);\n+        ret rslt(bcx, *cell);\n+    } else {\n+        let {bcx, val: alloca} = alloc_ty(bcx, ty);\n+        bcx = zero_alloca(bcx, alloca, ty);\n+        bcx = work(bcx, save_in(alloca));\n+        add_clean_temp(bcx, alloca, ty);\n+        ret rslt(bcx, alloca);\n+    }\n+}\n \n fn trans_if(cx: @block_ctxt, cond: @ast::expr, thn: ast::blk,\n-            els: option::t<@ast::expr>, output: out_method) -> result {\n+            els: option::t<@ast::expr>, dest: dest)\n+    -> @block_ctxt {\n     let {bcx, val: cond_val} = trans_expr(cx, cond);\n \n+    let then_dest = dup_for_join(dest);\n+    let else_dest = dup_for_join(dest);\n     let then_cx = new_scope_block_ctxt(bcx, \"then\");\n-    let then_res = trans_block(then_cx, thn, output);\n     let else_cx = new_scope_block_ctxt(bcx, \"else\");\n-    // Synthesize a block here to act as the else block\n-    // containing an if expression. Needed in order for the\n-    // else scope to behave like a normal block scope. A tad\n-    // ugly.\n+    CondBr(bcx, cond_val, then_cx.llbb, else_cx.llbb);\n+    then_cx = trans_block_dps(then_cx, thn, then_dest);\n     // Calling trans_block directly instead of trans_expr\n     // because trans_expr will create another scope block\n     // context for the block, but we've already got the\n     // 'else' context\n-    let else_res =\n-        alt els {\n-          some(elexpr) {\n-            alt elexpr.node {\n-              ast::expr_if(_, _, _) {\n-                let elseif_blk = ast_util::block_from_expr(elexpr);\n-                trans_block(else_cx, elseif_blk, output)\n-              }\n-              ast::expr_block(blk) { trans_block(else_cx, blk, output) }\n-            }\n+    alt els {\n+      some(elexpr) {\n+        alt elexpr.node {\n+          ast::expr_if(_, _, _) {\n+            let elseif_blk = ast_util::block_from_expr(elexpr);\n+            else_cx = trans_block_dps(else_cx, elseif_blk, else_dest);\n           }\n-          _ { rslt(else_cx, C_nil()) }\n-        };\n-    CondBr(bcx, cond_val, then_cx.llbb, else_cx.llbb);\n-    ret rslt(join_branches(cx, [then_res, else_res]), C_nil());\n+          ast::expr_block(blk) {\n+            else_cx = trans_block_dps(else_cx, blk, else_dest);\n+          }\n+        }\n+      }\n+      _ {}\n+    }\n+    ret join_returns(cx, [then_cx, else_cx], [then_dest, else_dest], dest);\n }\n \n fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n@@ -2468,7 +2538,7 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n         curr = PointerCast(bcx, curr, T_ptr(type_of_or_i8(bcx, t)));\n         bcx = trans_alt::bind_irrefutable_pat(scope_cx, local.node.pat, curr,\n                                               bcx.fcx.lllocals, false);\n-        bcx = trans_block(bcx, body, return).bcx;\n+        bcx = trans_block_dps(bcx, body, ignore);\n         Br(bcx, next_cx.llbb);\n         ret next_cx;\n     }\n@@ -2771,7 +2841,7 @@ fn trans_for_each(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n                                         llvm::LLVMGetParam(fcx.llfn, 3u),\n                                         bcx.fcx.lllocals, false);\n     let lltop = bcx.llbb;\n-    let r = trans_block(bcx, body, return);\n+    let r = trans_block(bcx, body);\n     finish_fn(fcx, lltop);\n \n     build_return(r.bcx);\n@@ -2793,7 +2863,7 @@ fn trans_while(cx: @block_ctxt, cond: @ast::expr, body: ast::blk) -> result {\n         new_loop_scope_block_ctxt(cx, option::none::<@block_ctxt>, next_cx,\n                                   \"while cond\");\n     let body_cx = new_scope_block_ctxt(cond_cx, \"while loop body\");\n-    let body_res = trans_block(body_cx, body, return);\n+    let body_res = trans_block(body_cx, body);\n     let cond_res = trans_expr(cond_cx, cond);\n     Br(body_res.bcx, cond_cx.llbb);\n     let cond_bcx = trans_block_cleanups(cond_res.bcx, cond_cx);\n@@ -2808,7 +2878,7 @@ fn trans_do_while(cx: @block_ctxt, body: ast::blk, cond: @ast::expr) ->\n     let body_cx =\n         new_loop_scope_block_ctxt(cx, option::none::<@block_ctxt>, next_cx,\n                                   \"do-while loop body\");\n-    let body_res = trans_block(body_cx, body, return);\n+    let body_res = trans_block(body_cx, body);\n     let cond_res = trans_expr(body_res.bcx, cond);\n     CondBr(cond_res.bcx, cond_res.val, body_cx.llbb, next_cx.llbb);\n     Br(cx, body_cx.llbb);\n@@ -4034,36 +4104,16 @@ fn trans_rec(cx: @block_ctxt, fields: [ast::field],\n }\n \n fn trans_expr(cx: @block_ctxt, e: @ast::expr) -> result {\n-    trans_expr_out(cx, e, return)\n-}\n-\n-fn trans_expr_out(cx: @block_ctxt, e: @ast::expr, output: out_method) ->\n-   result {\n     // Fixme Fill in cx.sp\n     alt e.node {\n       ast::expr_lit(lit) { ret trans_lit(cx, *lit); }\n       ast::expr_binary(op, x, y) { ret trans_binary(cx, op, x, y); }\n-      ast::expr_if(cond, thn, els) {\n-        ret with_out_method(bind trans_if(cx, cond, thn, els, _), cx, e.id,\n-                            output);\n-      }\n-      ast::expr_if_check(cond, thn, els) {\n-        ret with_out_method(bind trans_if(cx, cond, thn, els, _), cx, e.id,\n-                            output);\n-      }\n-      ast::expr_ternary(_, _, _) {\n-        ret trans_expr_out(cx, ast_util::ternary_to_if(e), output);\n-      }\n       ast::expr_for(decl, seq, body) { ret trans_for(cx, decl, seq, body); }\n       ast::expr_for_each(decl, seq, body) {\n         ret trans_for_each(cx, decl, seq, body);\n       }\n       ast::expr_while(cond, body) { ret trans_while(cx, cond, body); }\n       ast::expr_do_while(body, cond) { ret trans_do_while(cx, body, cond); }\n-      ast::expr_alt(expr, arms) {\n-        ret with_out_method(bind trans_alt::trans_alt(cx, expr, arms, _), cx,\n-                            e.id, output);\n-      }\n       ast::expr_fn(f) {\n         let ccx = bcx_ccx(cx);\n         let fty = node_id_type(ccx, e.id);\n@@ -4088,17 +4138,6 @@ fn trans_expr_out(cx: @block_ctxt, e: @ast::expr, output: out_method) ->\n             };\n         ret rslt(fn_pair.bcx, fn_pair.fn_pair);\n       }\n-      ast::expr_block(blk) {\n-        let sub_cx = new_scope_block_ctxt(cx, \"block-expr body\");\n-        let next_cx = new_sub_block_ctxt(cx, \"next\");\n-        let sub =\n-            with_out_method(bind trans_block(sub_cx, blk, _), cx, e.id,\n-                            output);\n-        Br(cx, sub_cx.llbb);\n-        Br(sub.bcx, next_cx.llbb);\n-        if sub.bcx.unreachable { Unreachable(next_cx); }\n-        ret rslt(next_cx, sub.val);\n-      }\n       ast::expr_copy(a) {\n         let e_ty = ty::expr_ty(bcx_tcx(cx), a);\n         let lv = trans_lval(cx, a);\n@@ -4256,27 +4295,62 @@ fn trans_expr_out(cx: @block_ctxt, e: @ast::expr, output: out_method) ->\n       ast::expr_unary(op, x) {\n         ret trans_unary(cx, op, x, e.id);\n       }\n+      // Fall through to DPS-style\n+      _ {\n+        ret dps_to_result(cx, {|bcx, dest| trans_expr_dps(bcx, e, dest)},\n+                          ty::expr_ty(bcx_tcx(cx), e));\n+      }\n     }\n }\n \n-fn with_out_method(work: fn(out_method) -> result, cx: @block_ctxt,\n-                   id: ast::node_id, outer_output: out_method) -> result {\n-    let ccx = bcx_ccx(cx);\n-    if outer_output != return {\n-        ret work(outer_output);\n-    } else {\n-        let tp = node_id_type(ccx, id);\n-        if ty::type_is_nil(ccx.tcx, tp) { ret work(return); }\n-        let res_alloca = alloc_ty(cx, tp);\n-        cx = zero_alloca(res_alloca.bcx, res_alloca.val, tp);\n-        let done = work(save_in(res_alloca.val));\n-        let loaded = load_if_immediate(done.bcx, res_alloca.val, tp);\n-        add_clean_temp(cx, loaded, tp);\n-        ret rslt(done.bcx, loaded);\n+fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n+    -> @block_ctxt {\n+    alt e.node {\n+      ast::expr_if(cond, thn, els) | ast::expr_if_check(cond, thn, els) {\n+        ret trans_if(bcx, cond, thn, els, dest);\n+      }\n+      ast::expr_ternary(_, _, _) {\n+        ret trans_expr_dps(bcx, ast_util::ternary_to_if(e), dest);\n+      }\n+      ast::expr_alt(expr, arms) {\n+        ret trans_alt::trans_alt(bcx, expr, arms, dest);\n+      }\n+      ast::expr_block(blk) {\n+        let sub_cx = new_scope_block_ctxt(bcx, \"block-expr body\");\n+        Br(bcx, sub_cx.llbb);\n+        sub_cx = trans_block_dps(sub_cx, blk, dest);\n+        let next_cx = new_sub_block_ctxt(bcx, \"next\");\n+        Br(sub_cx, next_cx.llbb);\n+        if sub_cx.unreachable { Unreachable(next_cx); }\n+        ret next_cx;\n+      }\n+      // Convert back from result to DPS\n+      _ {\n+        let lv = trans_lval(bcx, e);\n+        let {bcx, val, is_mem} = lv;\n+        let ty = ty::expr_ty(bcx_tcx(bcx), e);\n+        alt dest {\n+          by_val(cell) {\n+            if is_mem {\n+                bcx = take_ty(bcx, val, ty);\n+                *cell = Load(bcx, val);\n+            } else {\n+                revoke_clean(bcx, val);\n+                *cell = val;\n+            }\n+          }\n+          by_ref(cell) {\n+            assert is_mem;\n+            *cell = val;\n+          }\n+          save_in(loc) { bcx = move_val_if_temp(bcx, INIT, loc, lv, ty); }\n+          ignore. {}\n+        }\n+        ret bcx;\n+      }\n     }\n }\n \n-\n // We pass structural values around the compiler \"by pointer\" and\n // non-structural values (scalars, boxes, pointers) \"by value\". We call the\n // latter group \"immediates\" and, in some circumstances when we know we have a\n@@ -4900,54 +4974,27 @@ fn alloc_local(cx: @block_ctxt, local: @ast::local) -> result {\n     ret r;\n }\n \n-fn trans_block(cx: @block_ctxt, b: ast::blk, output: out_method) -> result {\n-    let bcx = cx;\n+fn trans_block(bcx: @block_ctxt, b: ast::blk) -> result {\n+    dps_to_result(bcx, {|bcx, dest| trans_block_dps(bcx, b, dest)},\n+                  ty::node_id_to_type(bcx_tcx(bcx), b.node.id))\n+}\n+\n+fn trans_block_dps(bcx: @block_ctxt, b: ast::blk, dest: dest)\n+    -> @block_ctxt {\n     for each local: @ast::local in block_locals(b) {\n         // FIXME Update bcx.sp\n         let r = alloc_local(bcx, local);\n         bcx = r.bcx;\n         bcx.fcx.lllocals.insert(local.node.id, r.val);\n     }\n-    let r = rslt(bcx, C_nil());\n     for s: @ast::stmt in b.node.stmts {\n         bcx = trans_stmt(bcx, *s);\n     }\n-    fn accept_out_method(expr: @ast::expr) -> bool {\n-        ret alt expr.node {\n-              ast::expr_if(_, _, _) { true }\n-              ast::expr_alt(_, _) { true }\n-              ast::expr_block(_) { true }\n-              _ { false }\n-            };\n-    }\n     alt b.node.expr {\n-      some(e) {\n-        let ccx = bcx_ccx(cx);\n-        let r_ty = ty::expr_ty(ccx.tcx, e);\n-        let pass = output != return && accept_out_method(e);\n-        if pass {\n-            r = trans_expr_out(bcx, e, output);\n-            bcx = r.bcx;\n-        } else {\n-            let lv = trans_lval(bcx, e);\n-            r = {bcx: lv.bcx, val: lv.val};\n-            bcx = r.bcx;\n-            alt output {\n-              save_in(target) {\n-                // The output method is to save the value at target,\n-                // and we didn't pass it to the recursive trans_expr\n-                // call.\n-                bcx = move_val_if_temp(bcx, INIT, target, lv, r_ty);\n-                r = rslt(bcx, C_nil());\n-              }\n-              return. { }\n-            }\n-        }\n-      }\n-      none. { r = rslt(bcx, C_nil()); }\n+      some(e) { bcx = trans_expr_dps(bcx, e, dest); }\n+      _ { assert dest == ignore || bcx.unreachable; }\n     }\n-    bcx = trans_block_cleanups(bcx, find_scope_cx(bcx));\n-    ret rslt(bcx, r.val);\n+    ret trans_block_cleanups(bcx, find_scope_cx(bcx));\n }\n \n fn new_local_ctxt(ccx: @crate_ctxt) -> @local_ctxt {\n@@ -5238,13 +5285,13 @@ fn trans_closure(bcx_maybe: option::t<@block_ctxt>,\n     // translation calls that don't have a return value (trans_crate,\n     // trans_mod, trans_item, trans_obj, et cetera) and those that do\n     // (trans_block, trans_expr, et cetera).\n-    let rslt =\n-        if !ty::type_is_bot(cx.ccx.tcx, block_ty) &&\n-           !ty::type_is_nil(cx.ccx.tcx, block_ty) &&\n-           f.proto != ast::proto_iter {\n-            trans_block(bcx, f.body, save_in(fcx.llretptr))\n-        } else { trans_block(bcx, f.body, return) };\n-    bcx = rslt.bcx;\n+    let dest = if !ty::type_is_bot(cx.ccx.tcx, block_ty) &&\n+                  !ty::type_is_nil(cx.ccx.tcx, block_ty) &&\n+                  f.proto != ast::proto_iter &&\n+                  option::is_some(f.body.node.expr) {\n+        save_in(fcx.llretptr)\n+    } else { ignore };\n+    bcx = trans_block_dps(bcx, f.body, dest);\n \n     if !bcx.unreachable {\n         // FIXME: until LLVM has a unit type, we are moving around"}, {"sha": "89ae84a5e8457c8edba15a63910c4a9f0c787d7a", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/64c69aa7b88b3ef66167f26cf681aaeeed33180e/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c69aa7b88b3ef66167f26cf681aaeeed33180e/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=64c69aa7b88b3ef66167f26cf681aaeeed33180e", "patch": "@@ -517,11 +517,11 @@ fn make_phi_bindings(bcx: @block_ctxt, map: [exit_node],\n }\n \n fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms: [ast::arm],\n-             output: trans::out_method) -> result {\n+             dest: trans::dest) -> @block_ctxt {\n     let bodies = [];\n     let match: match = [];\n     let er = trans::trans_expr(cx, expr);\n-    if er.bcx.unreachable { ret er; }\n+    if er.bcx.unreachable { ret er.bcx; }\n \n     for a: ast::arm in arms {\n         let body = new_scope_block_ctxt(er.bcx, \"case_body\");\n@@ -552,20 +552,18 @@ fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms: [ast::arm],\n     compile_submatch(vr.bcx, match, [vr.val],\n                      bind mk_fail(cx, expr.span, fail_cx), exit_map);\n \n-    let i = 0u;\n-    let arm_results = [];\n+    let arm_cxs = [], arm_dests = [], i = 0u;\n     for a: ast::arm in arms {\n         let body_cx = bodies[i];\n         if make_phi_bindings(body_cx, exit_map,\n                              ast_util::pat_id_map(a.pats[0])) {\n-            let block_res = trans::trans_block(body_cx, a.body, output);\n-            arm_results += [block_res];\n-        } else { // Unreachable\n-            arm_results += [rslt(body_cx, C_nil())];\n+            let arm_dest = trans::dup_for_join(dest);\n+            arm_dests += [arm_dest];\n+            arm_cxs += [trans::trans_block_dps(body_cx, a.body, arm_dest)];\n         }\n         i += 1u;\n     }\n-    ret rslt(trans::join_branches(cx, arm_results), C_nil());\n+    ret trans::join_returns(cx, arm_cxs, arm_dests, dest);\n }\n \n // Not alt-related, but similar to the pattern-munging code above"}, {"sha": "7e92d7826dbe01dde28af0d8bdbf91375f958683", "filename": "src/comp/middle/trans_build.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/64c69aa7b88b3ef66167f26cf681aaeeed33180e/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c69aa7b88b3ef66167f26cf681aaeeed33180e/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_build.rs?ref=64c69aa7b88b3ef66167f26cf681aaeeed33180e", "patch": "@@ -449,18 +449,24 @@ fn FCmp(cx: @block_ctxt, Op: uint, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret llvm::LLVMBuildFCmp(B(cx), Op, LHS, RHS, noname());\n }\n \n-\n /* Miscellaneous instructions */\n+fn EmptyPhi(cx: @block_ctxt, Ty: TypeRef) -> ValueRef {\n+    if cx.unreachable { ret llvm::LLVMGetUndef(Ty); }\n+    ret llvm::LLVMBuildPhi(B(cx), Ty, noname());\n+}\n+\n fn Phi(cx: @block_ctxt, Ty: TypeRef, vals: [ValueRef], bbs: [BasicBlockRef])\n    -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(Ty); }\n-    let phi = llvm::LLVMBuildPhi(B(cx), Ty, noname());\n     assert (vec::len::<ValueRef>(vals) == vec::len::<BasicBlockRef>(bbs));\n+    let phi = EmptyPhi(cx, Ty);\n     llvm::LLVMAddIncoming(phi, vec::to_ptr(vals), vec::to_ptr(bbs),\n                           vec::len(vals));\n     ret phi;\n }\n \n+// FIXME we typically need only a single val and bb. With std::ptr::addr_of\n+// and a count of 1, we should be able to avoid the overhead of creating vecs.\n fn AddIncomingToPhi(phi: ValueRef, vals: [ValueRef], bbs: [BasicBlockRef]) {\n     if llvm::LLVMIsUndef(phi) == lib::llvm::True { ret; }\n     assert (vec::len::<ValueRef>(vals) == vec::len::<BasicBlockRef>(bbs));"}]}