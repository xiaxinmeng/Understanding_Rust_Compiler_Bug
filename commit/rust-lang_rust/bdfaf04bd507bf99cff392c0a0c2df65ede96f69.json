{"sha": "bdfaf04bd507bf99cff392c0a0c2df65ede96f69", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkZmFmMDRiZDUwN2JmOTljZmYzOTJjMGEwYzJkZjY1ZWRlOTZmNjk=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-11-22T05:30:34Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-11-23T21:45:05Z"}, "message": "Move mutable::Mut to cell::RefCell", "tree": {"sha": "b946434aee84cc2a9d7bb8fbb0ff92bec5d3d6b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b946434aee84cc2a9d7bb8fbb0ff92bec5d3d6b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdfaf04bd507bf99cff392c0a0c2df65ede96f69", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdfaf04bd507bf99cff392c0a0c2df65ede96f69", "html_url": "https://github.com/rust-lang/rust/commit/bdfaf04bd507bf99cff392c0a0c2df65ede96f69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6ca9abcc651423fe85f522cbd20f1e64463c36f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6ca9abcc651423fe85f522cbd20f1e64463c36f", "html_url": "https://github.com/rust-lang/rust/commit/c6ca9abcc651423fe85f522cbd20f1e64463c36f"}], "stats": {"total": 685, "additions": 335, "deletions": 350}, "files": [{"sha": "019cd53be55bccc960c8d4cc62a8cb2e23bf851a", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 298, "deletions": 4, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=bdfaf04bd507bf99cff392c0a0c2df65ede96f69", "patch": "@@ -8,12 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Runtime move semantics\n+//! Types dealing with dynamic mutability\n \n #[missing_doc];\n \n-use cast::transmute_mut;\n use prelude::*;\n+use cast;\n+use util::NonCopyable;\n+\n \n /*\n A dynamic, mutable location.\n@@ -36,7 +38,7 @@ impl<T> Cell<T> {\n \n     /// Yields the value, failing if the cell is empty.\n     pub fn take(&self) -> T {\n-        let this = unsafe { transmute_mut(self) };\n+        let this = unsafe { cast::transmute_mut(self) };\n         if this.is_empty() {\n             fail!(\"attempt to take an empty cell\");\n         }\n@@ -46,7 +48,7 @@ impl<T> Cell<T> {\n \n     /// Yields the value if the cell is full, or `None` if it is empty.\n     pub fn take_opt(&self) -> Option<T> {\n-        let this = unsafe { transmute_mut(self) };\n+        let this = unsafe { cast::transmute_mut(self) };\n         this.value.take()\n     }\n \n@@ -72,3 +74,295 @@ fn test_take_empty() {\n     value_cell.take();\n     value_cell.take();\n }\n+\n+\n+/// A mutable memory location with dynamically checked borrow rules\n+#[no_freeze]\n+pub struct RefCell<T> {\n+    priv value: T,\n+    priv borrow: BorrowFlag,\n+    priv nc: NonCopyable\n+}\n+\n+// Values [1, MAX-1] represent the number of `Ref` active\n+// (will not outgrow its range since `uint` is the size of the address space)\n+type BorrowFlag = uint;\n+static UNUSED: BorrowFlag = 0;\n+static WRITING: BorrowFlag = -1;\n+\n+impl<T> RefCell<T> {\n+    /// Create a new `RefCell` containing `value`\n+    pub fn new(value: T) -> RefCell<T> {\n+        RefCell {\n+            value: value,\n+            borrow: UNUSED,\n+            nc: NonCopyable\n+        }\n+    }\n+\n+    /// Consumes the `RefCell`, returning the wrapped value.\n+    pub fn unwrap(self) -> T {\n+        assert!(self.borrow == UNUSED);\n+        self.value\n+    }\n+\n+    unsafe fn as_mut<'a>(&'a self) -> &'a mut RefCell<T> {\n+        cast::transmute_mut(self)\n+    }\n+\n+    /// Attempts to immutably borrow the wrapped value.\n+    ///\n+    /// The borrow lasts until the returned `Ref` exits scope. Multiple\n+    /// immutable borrows can be taken out at the same time.\n+    ///\n+    /// Returns `None` if the value is currently mutably borrowed.\n+    pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> {\n+        match self.borrow {\n+            WRITING => None,\n+            _ => {\n+                unsafe { self.as_mut().borrow += 1; }\n+                Some(Ref { parent: self })\n+            }\n+        }\n+    }\n+\n+    /// Immutably borrows the wrapped value.\n+    ///\n+    /// The borrow lasts until the returned `Ref` exits scope. Multiple\n+    /// immutable borrows can be taken out at the same time.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value is currently mutably borrowed.\n+    pub fn borrow<'a>(&'a self) -> Ref<'a, T> {\n+        match self.try_borrow() {\n+            Some(ptr) => ptr,\n+            None => fail!(\"RefCell<T> already mutably borrowed\")\n+        }\n+    }\n+\n+    /// Mutably borrows the wrapped value.\n+    ///\n+    /// The borrow lasts untile the returned `RefMut` exits scope. The value\n+    /// cannot be borrowed while this borrow is active.\n+    ///\n+    /// Returns `None` if the value is currently borrowed.\n+    pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> {\n+        match self.borrow {\n+            UNUSED => unsafe {\n+                let mut_self = self.as_mut();\n+                mut_self.borrow = WRITING;\n+                Some(RefMut { parent: mut_self })\n+            },\n+            _ => None\n+        }\n+    }\n+\n+    /// Mutably borrows the wrapped value.\n+    ///\n+    /// The borrow lasts untile the returned `RefMut` exits scope. The value\n+    /// cannot be borrowed while this borrow is active.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value is currently borrowed.\n+    pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> {\n+        match self.try_borrow_mut() {\n+            Some(ptr) => ptr,\n+            None => fail!(\"RefCell<T> already borrowed\")\n+        }\n+    }\n+\n+    /// Immutably borrows the wrapped value and applies `blk` to it.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value is currently mutably borrowed.\n+    #[inline]\n+    pub fn with<U>(&self, blk: |&T| -> U) -> U {\n+        let ptr = self.borrow();\n+        blk(ptr.get())\n+    }\n+\n+    /// Mutably borrows the wrapped value and applies `blk` to it.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value is currently borrowed.\n+    #[inline]\n+    pub fn with_mut<U>(&self, blk: |&mut T| -> U) -> U {\n+        let mut ptr = self.borrow_mut();\n+        blk(ptr.get())\n+    }\n+}\n+\n+impl<T: Clone> Clone for RefCell<T> {\n+    fn clone(&self) -> RefCell<T> {\n+        let x = self.borrow();\n+        RefCell::new(x.get().clone())\n+    }\n+}\n+\n+impl<T: DeepClone> DeepClone for RefCell<T> {\n+    fn deep_clone(&self) -> RefCell<T> {\n+        let x = self.borrow();\n+        RefCell::new(x.get().deep_clone())\n+    }\n+}\n+\n+impl<T: Eq> Eq for RefCell<T> {\n+    fn eq(&self, other: &RefCell<T>) -> bool {\n+        let a = self.borrow();\n+        let b = other.borrow();\n+        a.get() == b.get()\n+    }\n+}\n+\n+/// Wraps a borrowed reference to a value in a `RefCell` box.\n+pub struct Ref<'box, T> {\n+    priv parent: &'box RefCell<T>\n+}\n+\n+#[unsafe_destructor]\n+impl<'box, T> Drop for Ref<'box, T> {\n+    fn drop(&mut self) {\n+        assert!(self.parent.borrow != WRITING && self.parent.borrow != UNUSED);\n+        unsafe { self.parent.as_mut().borrow -= 1; }\n+    }\n+}\n+\n+impl<'box, T> Ref<'box, T> {\n+    /// Retrieve an immutable reference to the stored value.\n+    #[inline]\n+    pub fn get<'a>(&'a self) -> &'a T {\n+        &self.parent.value\n+    }\n+}\n+\n+/// Wraps a mutable borrowed reference to a value in a `RefCell` box.\n+pub struct RefMut<'box, T> {\n+    priv parent: &'box mut RefCell<T>\n+}\n+\n+#[unsafe_destructor]\n+impl<'box, T> Drop for RefMut<'box, T> {\n+    fn drop(&mut self) {\n+        assert!(self.parent.borrow == WRITING);\n+        self.parent.borrow = UNUSED;\n+    }\n+}\n+\n+impl<'box, T> RefMut<'box, T> {\n+    /// Retrieve a mutable reference to the stored value.\n+    #[inline]\n+    pub fn get<'a>(&'a mut self) -> &'a mut T {\n+        &mut self.parent.value\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test]\n+    fn double_imm_borrow() {\n+        let x = RefCell::new(0);\n+        let _b1 = x.borrow();\n+        x.borrow();\n+    }\n+\n+    #[test]\n+    fn no_mut_then_imm_borrow() {\n+        let x = RefCell::new(0);\n+        let _b1 = x.borrow_mut();\n+        assert!(x.try_borrow().is_none());\n+    }\n+\n+    #[test]\n+    fn no_imm_then_borrow_mut() {\n+        let x = RefCell::new(0);\n+        let _b1 = x.borrow();\n+        assert!(x.try_borrow_mut().is_none());\n+    }\n+\n+    #[test]\n+    fn no_double_borrow_mut() {\n+        let x = RefCell::new(0);\n+        let _b1 = x.borrow_mut();\n+        assert!(x.try_borrow_mut().is_none());\n+    }\n+\n+    #[test]\n+    fn imm_release_borrow_mut() {\n+        let x = RefCell::new(0);\n+        {\n+            let _b1 = x.borrow();\n+        }\n+        x.borrow_mut();\n+    }\n+\n+    #[test]\n+    fn mut_release_borrow_mut() {\n+        let x = RefCell::new(0);\n+        {\n+            let _b1 = x.borrow_mut();\n+        }\n+        x.borrow();\n+    }\n+\n+    #[test]\n+    fn double_borrow_single_release_no_borrow_mut() {\n+        let x = RefCell::new(0);\n+        let _b1 = x.borrow();\n+        {\n+            let _b2 = x.borrow();\n+        }\n+        assert!(x.try_borrow_mut().is_none());\n+    }\n+\n+    #[test]\n+    fn with_ok() {\n+        let x = RefCell::new(0);\n+        assert_eq!(1, x.with(|x| *x+1));\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn mut_borrow_with() {\n+        let x = RefCell::new(0);\n+        let _b1 = x.borrow_mut();\n+        x.with(|x| *x+1);\n+    }\n+\n+    #[test]\n+    fn borrow_with() {\n+        let x = RefCell::new(0);\n+        let _b1 = x.borrow();\n+        assert_eq!(1, x.with(|x| *x+1));\n+    }\n+\n+    #[test]\n+    fn with_mut_ok() {\n+        let x = RefCell::new(0);\n+        x.with_mut(|x| *x += 1);\n+        let b = x.borrow();\n+        assert_eq!(1, *b.get());\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn borrow_with_mut() {\n+        let x = RefCell::new(0);\n+        let _b = x.borrow();\n+        x.with_mut(|x| *x += 1);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn discard_doesnt_unborrow() {\n+        let x = RefCell::new(0);\n+        let _b = x.borrow();\n+        let _ = _b;\n+        let _b = x.borrow_mut();\n+    }\n+}"}, {"sha": "5fe11d310d4675f8b1130f7c2b4a15ca8d4d3803", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=bdfaf04bd507bf99cff392c0a0c2df65ede96f69", "patch": "@@ -55,26 +55,26 @@ impl<T: DeepClone + Send + 'static> DeepClone for Gc<T> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use cell::Cell;\n+    use cell::RefCell;\n \n     #[test]\n     fn test_clone() {\n-        let x = Gc::new(Cell::new(5));\n+        let x = Gc::new(RefCell::new(5));\n         let y = x.clone();\n-        do x.borrow().with_mut_ref |inner| {\n+        do x.borrow().with_mut |inner| {\n             *inner = 20;\n         }\n-        assert_eq!(y.borrow().take(), 20);\n+        assert_eq!(y.borrow().with(|x| *x), 20);\n     }\n \n     #[test]\n     fn test_deep_clone() {\n-        let x = Gc::new(Cell::new(5));\n+        let x = Gc::new(RefCell::new(5));\n         let y = x.deep_clone();\n-        do x.borrow().with_mut_ref |inner| {\n+        do x.borrow().with_mut |inner| {\n             *inner = 20;\n         }\n-        assert_eq!(y.borrow().take(), 5);\n+        assert_eq!(y.borrow().with(|x| *x), 5);\n     }\n \n     #[test]"}, {"sha": "ffa91df4e8a86e2114b10d7378aa8a97f4ac8186", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=bdfaf04bd507bf99cff392c0a0c2df65ede96f69", "patch": "@@ -164,7 +164,6 @@ pub mod result;\n pub mod either;\n pub mod hashmap;\n pub mod cell;\n-pub mod mutable;\n pub mod trie;\n \n "}, {"sha": "44efbc149c173a4bd7913895e28484b580408ea0", "filename": "src/libstd/mutable.rs", "status": "removed", "additions": 0, "deletions": 307, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/c6ca9abcc651423fe85f522cbd20f1e64463c36f/src%2Flibstd%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ca9abcc651423fe85f522cbd20f1e64463c36f/src%2Flibstd%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmutable.rs?ref=c6ca9abcc651423fe85f522cbd20f1e64463c36f", "patch": "@@ -1,307 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A mutable memory location with dynamically checked borrow rules\n-\n-use prelude::*;\n-\n-use cast;\n-use util::NonCopyable;\n-\n-/// A mutable memory location with dynamically checked borrow rules\n-#[no_freeze]\n-pub struct Mut<T> {\n-    priv value: T,\n-    priv borrow: BorrowFlag,\n-    priv nc: NonCopyable\n-}\n-\n-// Values [1, MAX-1] represent the number of `Ref` active\n-// (will not outgrow its range since `uint` is the size of the address space)\n-type BorrowFlag = uint;\n-static UNUSED: BorrowFlag = 0;\n-static WRITING: BorrowFlag = -1;\n-\n-impl<T> Mut<T> {\n-    /// Create a new `Mut` containing `value`\n-    pub fn new(value: T) -> Mut<T> {\n-        Mut {\n-            value: value,\n-            borrow: UNUSED,\n-            nc: NonCopyable\n-        }\n-    }\n-\n-    /// Consumes the `Mut`, returning the wrapped value.\n-    pub fn unwrap(self) -> T {\n-        assert!(self.borrow == UNUSED);\n-        self.value\n-    }\n-\n-    unsafe fn as_mut<'a>(&'a self) -> &'a mut Mut<T> {\n-        cast::transmute_mut(self)\n-    }\n-\n-    /// Attempts to immutably borrow the wrapped value.\n-    ///\n-    /// The borrow lasts until the returned `Ref` exits scope. Multiple\n-    /// immutable borrows can be taken out at the same time.\n-    ///\n-    /// Returns `None` if the value is currently mutably borrowed.\n-    pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> {\n-        match self.borrow {\n-            WRITING => None,\n-            _ => {\n-                unsafe { self.as_mut().borrow += 1; }\n-                Some(Ref { parent: self })\n-            }\n-        }\n-    }\n-\n-    /// Immutably borrows the wrapped value.\n-    ///\n-    /// The borrow lasts until the returned `Ref` exits scope. Multiple\n-    /// immutable borrows can be taken out at the same time.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value is currently mutably borrowed.\n-    pub fn borrow<'a>(&'a self) -> Ref<'a, T> {\n-        match self.try_borrow() {\n-            Some(ptr) => ptr,\n-            None => fail!(\"Mut<T> already mutably borrowed\")\n-        }\n-    }\n-\n-    /// Mutably borrows the wrapped value.\n-    ///\n-    /// The borrow lasts untile the returned `RefMut` exits scope. The value\n-    /// cannot be borrowed while this borrow is active.\n-    ///\n-    /// Returns `None` if the value is currently borrowed.\n-    pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> {\n-        match self.borrow {\n-            UNUSED => unsafe {\n-                let mut_self = self.as_mut();\n-                mut_self.borrow = WRITING;\n-                Some(RefMut { parent: mut_self })\n-            },\n-            _ => None\n-        }\n-    }\n-\n-    /// Mutably borrows the wrapped value.\n-    ///\n-    /// The borrow lasts untile the returned `RefMut` exits scope. The value\n-    /// cannot be borrowed while this borrow is active.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value is currently borrowed.\n-    pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> {\n-        match self.try_borrow_mut() {\n-            Some(ptr) => ptr,\n-            None => fail!(\"Mut<T> already borrowed\")\n-        }\n-    }\n-\n-    /// Immutably borrows the wrapped value and applies `blk` to it.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value is currently mutably borrowed.\n-    #[inline]\n-    pub fn with<U>(&self, blk: |&T| -> U) -> U {\n-        let ptr = self.borrow();\n-        blk(ptr.get())\n-    }\n-\n-    /// Mutably borrows the wrapped value and applies `blk` to it.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value is currently borrowed.\n-    #[inline]\n-    pub fn with_mut<U>(&self, blk: |&mut T| -> U) -> U {\n-        let mut ptr = self.borrow_mut();\n-        blk(ptr.get())\n-    }\n-}\n-\n-impl<T: Clone> Clone for Mut<T> {\n-    fn clone(&self) -> Mut<T> {\n-        let x = self.borrow();\n-        Mut::new(x.get().clone())\n-    }\n-}\n-\n-impl<T: DeepClone> DeepClone for Mut<T> {\n-    fn deep_clone(&self) -> Mut<T> {\n-        let x = self.borrow();\n-        Mut::new(x.get().deep_clone())\n-    }\n-}\n-\n-impl<T: Eq> Eq for Mut<T> {\n-    fn eq(&self, other: &Mut<T>) -> bool {\n-        let a = self.borrow();\n-        let b = other.borrow();\n-        a.get() == b.get()\n-    }\n-}\n-\n-/// Wraps a borrowed reference to a value in a `Mut` box.\n-pub struct Ref<'box, T> {\n-    priv parent: &'box Mut<T>\n-}\n-\n-#[unsafe_destructor]\n-impl<'box, T> Drop for Ref<'box, T> {\n-    fn drop(&mut self) {\n-        assert!(self.parent.borrow != WRITING && self.parent.borrow != UNUSED);\n-        unsafe { self.parent.as_mut().borrow -= 1; }\n-    }\n-}\n-\n-impl<'box, T> Ref<'box, T> {\n-    /// Retrieve an immutable reference to the stored value.\n-    #[inline]\n-    pub fn get<'a>(&'a self) -> &'a T {\n-        &self.parent.value\n-    }\n-}\n-\n-/// Wraps a mutable borrowed reference to a value in a `Mut` box.\n-pub struct RefMut<'box, T> {\n-    priv parent: &'box mut Mut<T>\n-}\n-\n-#[unsafe_destructor]\n-impl<'box, T> Drop for RefMut<'box, T> {\n-    fn drop(&mut self) {\n-        assert!(self.parent.borrow == WRITING);\n-        self.parent.borrow = UNUSED;\n-    }\n-}\n-\n-impl<'box, T> RefMut<'box, T> {\n-    /// Retrieve a mutable reference to the stored value.\n-    #[inline]\n-    pub fn get<'a>(&'a mut self) -> &'a mut T {\n-        &mut self.parent.value\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-\n-    #[test]\n-    fn double_imm_borrow() {\n-        let x = Mut::new(0);\n-        let _b1 = x.borrow();\n-        x.borrow();\n-    }\n-\n-    #[test]\n-    fn no_mut_then_imm_borrow() {\n-        let x = Mut::new(0);\n-        let _b1 = x.borrow_mut();\n-        assert!(x.try_borrow().is_none());\n-    }\n-\n-    #[test]\n-    fn no_imm_then_borrow_mut() {\n-        let x = Mut::new(0);\n-        let _b1 = x.borrow();\n-        assert!(x.try_borrow_mut().is_none());\n-    }\n-\n-    #[test]\n-    fn no_double_borrow_mut() {\n-        let x = Mut::new(0);\n-        let _b1 = x.borrow_mut();\n-        assert!(x.try_borrow_mut().is_none());\n-    }\n-\n-    #[test]\n-    fn imm_release_borrow_mut() {\n-        let x = Mut::new(0);\n-        {\n-            let _b1 = x.borrow();\n-        }\n-        x.borrow_mut();\n-    }\n-\n-    #[test]\n-    fn mut_release_borrow_mut() {\n-        let x = Mut::new(0);\n-        {\n-            let _b1 = x.borrow_mut();\n-        }\n-        x.borrow();\n-    }\n-\n-    #[test]\n-    fn double_borrow_single_release_no_borrow_mut() {\n-        let x = Mut::new(0);\n-        let _b1 = x.borrow();\n-        {\n-            let _b2 = x.borrow();\n-        }\n-        assert!(x.try_borrow_mut().is_none());\n-    }\n-\n-    #[test]\n-    fn with_ok() {\n-        let x = Mut::new(0);\n-        assert_eq!(1, x.with(|x| *x+1));\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn mut_borrow_with() {\n-        let x = Mut::new(0);\n-        let _b1 = x.borrow_mut();\n-        x.with(|x| *x+1);\n-    }\n-\n-    #[test]\n-    fn borrow_with() {\n-        let x = Mut::new(0);\n-        let _b1 = x.borrow();\n-        assert_eq!(1, x.with(|x| *x+1));\n-    }\n-\n-    #[test]\n-    fn with_mut_ok() {\n-        let x = Mut::new(0);\n-        x.with_mut(|x| *x += 1);\n-        let b = x.borrow();\n-        assert_eq!(1, *b.get());\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn borrow_with_mut() {\n-        let x = Mut::new(0);\n-        let _b = x.borrow();\n-        x.with_mut(|x| *x += 1);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn discard_doesnt_unborrow() {\n-        let x = Mut::new(0);\n-        let _b = x.borrow();\n-        let _ = _b;\n-        let _b = x.borrow_mut();\n-    }\n-}"}, {"sha": "242533773d7cec59cddae60049a8797078c11dd9", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=bdfaf04bd507bf99cff392c0a0c2df65ede96f69", "patch": "@@ -21,7 +21,7 @@ use unstable::intrinsics::transmute;\n use ops::Drop;\n use kinds::{Freeze, Send};\n use clone::{Clone, DeepClone};\n-use mutable::Mut;\n+use cell::RefCell;\n \n struct RcBox<T> {\n     value: T,\n@@ -55,10 +55,10 @@ impl<T: Send> Rc<T> {\n     }\n }\n \n-impl<T: Freeze> Rc<Mut<T>> {\n-    /// Construct a new reference-counted box from a `Mut`-wrapped `Freeze` value\n+impl<T: Freeze> Rc<RefCell<T>> {\n+    /// Construct a new reference-counted box from a `RefCell`-wrapped `Freeze` value\n     #[inline]\n-    pub fn from_mut(value: Mut<T>) -> Rc<Mut<T>> {\n+    pub fn from_mut(value: RefCell<T>) -> Rc<RefCell<T>> {\n         unsafe {\n             Rc::new_unchecked(value)\n         }\n@@ -116,11 +116,11 @@ impl<T> Drop for Rc<T> {\n #[cfg(test)]\n mod test_rc {\n     use super::*;\n-    use mutable::Mut;\n+    use cell::RefCell;\n \n     #[test]\n     fn test_clone() {\n-        let x = Rc::from_send(Mut::new(5));\n+        let x = Rc::from_send(RefCell::new(5));\n         let y = x.clone();\n         do x.borrow().with_mut |inner| {\n             *inner = 20;\n@@ -130,7 +130,7 @@ mod test_rc {\n \n     #[test]\n     fn test_deep_clone() {\n-        let x = Rc::from_send(Mut::new(5));\n+        let x = Rc::from_send(RefCell::new(5));\n         let y = x.deep_clone();\n         do x.borrow().with_mut |inner| {\n             *inner = 20;\n@@ -161,6 +161,6 @@ mod test_rc {\n     #[test]\n     fn test_from_mut() {\n         let a = 10;\n-        let _x = Rc::from_mut(Mut::new(&a));\n+        let _x = Rc::from_mut(RefCell::new(&a));\n     }\n }"}, {"sha": "8635f9372c472c9b2d21bf6692d5b32b80d79e79", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=bdfaf04bd507bf99cff392c0a0c2df65ede96f69", "patch": "@@ -25,10 +25,9 @@ use unstable::sync::UnsafeArc;\n use util;\n use util::Void;\n use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable, SendDeferred};\n-use cell::Cell;\n+use cell::{Cell, RefCell};\n use clone::Clone;\n use tuple::ImmutableTuple;\n-use mutable::Mut;\n \n /// A combined refcount / BlockedTask-as-uint pointer.\n ///\n@@ -433,20 +432,20 @@ type StreamPortOne<T> = PortOne<StreamPayload<T>>;\n \n /// A channel with unbounded size.\n pub struct Chan<T> {\n-    // FIXME #5372. Using Mut because we don't take &mut self\n-    next: Mut<StreamChanOne<T>>\n+    // FIXME #5372. Using RefCell because we don't take &mut self\n+    next: RefCell<StreamChanOne<T>>\n }\n \n /// An port with unbounded size.\n pub struct Port<T> {\n-    // FIXME #5372. Using Mut because we don't take &mut self\n-    next: Mut<Option<StreamPortOne<T>>>\n+    // FIXME #5372. Using RefCell because we don't take &mut self\n+    next: RefCell<Option<StreamPortOne<T>>>\n }\n \n pub fn stream<T: Send>() -> (Port<T>, Chan<T>) {\n     let (pone, cone) = oneshot();\n-    let port = Port { next: Mut::new(Some(pone)) };\n-    let chan = Chan { next: Mut::new(cone) };\n+    let port = Port { next: RefCell::new(Some(pone)) };\n+    let chan = Chan { next: RefCell::new(cone) };\n     return (port, chan);\n }\n "}, {"sha": "9276a2f0d41941e5f0ac0cb5ca95c3228c67420a", "filename": "src/test/compile-fail/issue-7013.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs?ref=bdfaf04bd507bf99cff392c0a0c2df65ede96f69", "patch": "@@ -9,21 +9,21 @@\n // except according to those terms.\n \n use std::rc::Rc;\n-use std::mutable::Mut;\n+use std::cell::RefCell;\n \n trait Foo\n {\n-    fn set(&mut self, v: Rc<Mut<A>>);\n+    fn set(&mut self, v: Rc<RefCell<A>>);\n }\n \n struct B\n {\n-    v: Option<Rc<Mut<A>>>\n+    v: Option<Rc<RefCell<A>>>\n }\n \n impl Foo for B\n {\n-    fn set(&mut self, v: Rc<Mut<A>>)\n+    fn set(&mut self, v: Rc<RefCell<A>>)\n     {\n         self.v = Some(v);\n     }\n@@ -37,7 +37,7 @@ struct A\n fn main()\n {\n     let a = A {v: ~B{v: None} as ~Foo}; //~ ERROR cannot pack type `~B`, which does not fulfill `Send`\n-    let v = Rc::from_send(Mut::new(a));\n+    let v = Rc::from_send(RefCell::new(a));\n     let w = v.clone();\n     let b = v.borrow();\n     let mut b = b.borrow_mut();"}, {"sha": "f031467328f0b712b8fc0d4dc37b4860c38627b3", "filename": "src/test/compile-fail/mut-cant-alias.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/src%2Ftest%2Fcompile-fail%2Fmut-cant-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/src%2Ftest%2Fcompile-fail%2Fmut-cant-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-cant-alias.rs?ref=bdfaf04bd507bf99cff392c0a0c2df65ede96f69", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::mutable::Mut;\n+use std::cell::RefCell;\n \n fn main() {\n-    let m = Mut::new(0);\n+    let m = RefCell::new(0);\n     let mut b = m.borrow_mut();\n     let b1 = b.get();\n     let b2 = b.get(); //~ ERROR cannot borrow `b` as mutable more than once at a time"}, {"sha": "97fe49ca087f544e52f89607f3bcd6b72833f169", "filename": "src/test/compile-fail/mut-not-freeze.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs?ref=bdfaf04bd507bf99cff392c0a0c2df65ede96f69", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::mutable::Mut;\n+use std::cell::RefCell;\n \n fn f<T: Freeze>(_: T) {}\n \n fn main() {\n-    let x = Mut::new(0);\n+    let x = RefCell::new(0);\n     f(x); //~ ERROR: which does not fulfill `Freeze`\n }"}, {"sha": "ca276700e8b61d1a26f5ca7d1ec4b4f8f20cae44", "filename": "src/test/compile-fail/mut-ptr-cant-outlive-ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/src%2Ftest%2Fcompile-fail%2Fmut-ptr-cant-outlive-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/src%2Ftest%2Fcompile-fail%2Fmut-ptr-cant-outlive-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-ptr-cant-outlive-ref.rs?ref=bdfaf04bd507bf99cff392c0a0c2df65ede96f69", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::mutable::Mut;\n+use std::cell::RefCell;\n \n fn main() {\n-    let m = Mut::new(0);\n+    let m = RefCell::new(0);\n     let p;\n     {\n         let b = m.borrow();"}, {"sha": "7e0c8319356e47f8ca7110978bfac4ea91d1258d", "filename": "src/test/compile-fail/rcmut-not-const-and-not-owned.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdfaf04bd507bf99cff392c0a0c2df65ede96f69/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs?ref=bdfaf04bd507bf99cff392c0a0c2df65ede96f69", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::mutable::Mut;\n+use std::cell::RefCell;\n use std::rc::Rc;\n \n fn o<T: Send>(_: &T) {}\n fn c<T: Freeze>(_: &T) {}\n \n fn main() {\n-    let x = Rc::from_send(Mut::new(0));\n-    o(&x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::Rc<std::mutable::Mut<int>>`, which does not fulfill `Send`\n-    c(&x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::Rc<std::mutable::Mut<int>>`, which does not fulfill `Freeze`\n+    let x = Rc::from_send(RefCell::new(0));\n+    o(&x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::Rc<std::cell::RefCell<int>>`, which does not fulfill `Send`\n+    c(&x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::Rc<std::cell::RefCell<int>>`, which does not fulfill `Freeze`\n }"}]}