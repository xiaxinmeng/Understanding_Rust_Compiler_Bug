{"sha": "aea57aee5fd6debadb91dd30cd4bb4ccb92411f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlYTU3YWVlNWZkNmRlYmFkYjkxZGQzMGNkNGJiNGNjYjkyNDExZjY=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-02-10T13:29:21Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-03-14T21:52:30Z"}, "message": "Don't hash HIR with bodies thrice", "tree": {"sha": "e1fc376367a1dbb41b2f2e43c3f03b5aadb19b43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1fc376367a1dbb41b2f2e43c3f03b5aadb19b43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aea57aee5fd6debadb91dd30cd4bb4ccb92411f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aea57aee5fd6debadb91dd30cd4bb4ccb92411f6", "html_url": "https://github.com/rust-lang/rust/commit/aea57aee5fd6debadb91dd30cd4bb4ccb92411f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aea57aee5fd6debadb91dd30cd4bb4ccb92411f6/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e316e29e6f7166989cb3e8342b145f16dc48cca", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e316e29e6f7166989cb3e8342b145f16dc48cca", "html_url": "https://github.com/rust-lang/rust/commit/0e316e29e6f7166989cb3e8342b145f16dc48cca"}], "stats": {"total": 80, "additions": 43, "deletions": 37}, "files": [{"sha": "58f755693f7a8fbd923f917c621c49b2bc054cd3", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/aea57aee5fd6debadb91dd30cd4bb4ccb92411f6/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea57aee5fd6debadb91dd30cd4bb4ccb92411f6/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=aea57aee5fd6debadb91dd30cd4bb4ccb92411f6", "patch": "@@ -63,9 +63,10 @@ fn hash_body(\n     def_path_hash: DefPathHash,\n     item_like: impl for<'a> HashStable<StableHashingContext<'a>>,\n     hir_body_nodes: &mut Vec<(DefPathHash, Fingerprint)>,\n-) {\n+) -> Fingerprint {\n     let hash = hash(hcx, HirItemLike { item_like: &item_like });\n     hir_body_nodes.push((def_path_hash, hash));\n+    hash\n }\n \n fn upstream_crates(cstore: &dyn CrateStore) -> Vec<(Symbol, Fingerprint, Svh)> {\n@@ -96,7 +97,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n         let mut hir_body_nodes = Vec::new();\n \n-        {\n+        let hash = {\n             let Crate {\n                 ref item,\n                 // These fields are handled separately:\n@@ -137,6 +138,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         collector.insert_entry(\n             hir::CRATE_HIR_ID,\n             Entry { parent: hir::CRATE_HIR_ID, node: Node::Crate(&krate.item) },\n+            hash,\n         );\n \n         collector\n@@ -197,27 +199,24 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         (self.owner_map, self.owner_items_map, svh)\n     }\n \n-    fn insert_entry(&mut self, id: HirId, entry: Entry<'hir>) {\n+    fn insert_entry(&mut self, id: HirId, entry: Entry<'hir>, hash: Fingerprint) {\n         let i = id.local_id.as_u32() as usize;\n \n         let owner = HirOwner { parent: entry.parent, node: entry.node };\n \n         let arena = self.arena;\n-        let krate = self.krate;\n \n         let items = self.owner_items_map.entry(id.owner).or_insert_with(|| {\n             arena.alloc(HirOwnerItems {\n-                // Insert a dummy node which will be overwritten\n-                // when we call `insert_entry` on the HIR owner.\n-                owner: Node::Crate(&krate.item),\n+                hash,\n                 items: IndexVec::new(),\n                 bodies: FxHashMap::default(),\n             })\n         });\n \n         if i == 0 {\n-            // Overwrite the dummy node with the real HIR owner.\n-            items.owner = entry.node;\n+            // Overwrite the dummy hash with the real HIR owner hash.\n+            items.hash = hash;\n \n             self.owner_map.insert(id.owner, self.arena.alloc(owner));\n         // FIXME: feature(impl_trait_in_bindings) broken and trigger this assert\n@@ -234,6 +233,10 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     }\n \n     fn insert(&mut self, span: Span, hir_id: HirId, node: Node<'hir>) {\n+        self.insert_with_hash(span, hir_id, node, Fingerprint::ZERO)\n+    }\n+\n+    fn insert_with_hash(&mut self, span: Span, hir_id: HirId, node: Node<'hir>, hash: Fingerprint) {\n         let entry = Entry { parent: self.parent_node, node };\n \n         // Make sure that the DepNode of some node coincides with the HirId\n@@ -269,7 +272,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             }\n         }\n \n-        self.insert_entry(hir_id, entry);\n+        self.insert_entry(hir_id, entry, hash);\n     }\n \n     fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_node_id: HirId, f: F) {\n@@ -281,7 +284,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n     fn with_dep_node_owner<\n         T: for<'b> HashStable<StableHashingContext<'b>>,\n-        F: FnOnce(&mut Self),\n+        F: FnOnce(&mut Self, Fingerprint),\n     >(\n         &mut self,\n         dep_node_owner: DefIndex,\n@@ -292,10 +295,10 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n         let def_path_hash = self.definitions.def_path_hash(dep_node_owner);\n \n-        hash_body(&mut self.hcx, def_path_hash, item_like, &mut self.hir_body_nodes);\n+        let hash = hash_body(&mut self.hcx, def_path_hash, item_like, &mut self.hir_body_nodes);\n \n         self.current_dep_node_owner = dep_node_owner;\n-        f(self);\n+        f(self, hash);\n         self.current_dep_node_owner = prev_owner;\n     }\n }\n@@ -342,8 +345,8 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n             i.hir_id.owner,\n             self.definitions.opt_def_index(self.hir_to_node_id[&i.hir_id]).unwrap()\n         );\n-        self.with_dep_node_owner(i.hir_id.owner, i, |this| {\n-            this.insert(i.span, i.hir_id, Node::Item(i));\n+        self.with_dep_node_owner(i.hir_id.owner, i, |this, hash| {\n+            this.insert_with_hash(i.span, i.hir_id, Node::Item(i), hash);\n             this.with_parent(i.hir_id, |this| {\n                 if let ItemKind::Struct(ref struct_def, _) = i.kind {\n                     // If this is a tuple or unit-like struct, register the constructor.\n@@ -374,8 +377,8 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n             ti.hir_id.owner,\n             self.definitions.opt_def_index(self.hir_to_node_id[&ti.hir_id]).unwrap()\n         );\n-        self.with_dep_node_owner(ti.hir_id.owner, ti, |this| {\n-            this.insert(ti.span, ti.hir_id, Node::TraitItem(ti));\n+        self.with_dep_node_owner(ti.hir_id.owner, ti, |this, hash| {\n+            this.insert_with_hash(ti.span, ti.hir_id, Node::TraitItem(ti), hash);\n \n             this.with_parent(ti.hir_id, |this| {\n                 intravisit::walk_trait_item(this, ti);\n@@ -388,8 +391,8 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n             ii.hir_id.owner,\n             self.definitions.opt_def_index(self.hir_to_node_id[&ii.hir_id]).unwrap()\n         );\n-        self.with_dep_node_owner(ii.hir_id.owner, ii, |this| {\n-            this.insert(ii.span, ii.hir_id, Node::ImplItem(ii));\n+        self.with_dep_node_owner(ii.hir_id.owner, ii, |this, hash| {\n+            this.insert_with_hash(ii.span, ii.hir_id, Node::ImplItem(ii), hash);\n \n             this.with_parent(ii.hir_id, |this| {\n                 intravisit::walk_impl_item(this, ii);\n@@ -508,8 +511,13 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         let node_id = self.hir_to_node_id[&macro_def.hir_id];\n         let def_index = self.definitions.opt_def_index(node_id).unwrap();\n \n-        self.with_dep_node_owner(def_index, macro_def, |this| {\n-            this.insert(macro_def.span, macro_def.hir_id, Node::MacroDef(macro_def));\n+        self.with_dep_node_owner(def_index, macro_def, |this, hash| {\n+            this.insert_with_hash(\n+                macro_def.span,\n+                macro_def.hir_id,\n+                Node::MacroDef(macro_def),\n+                hash,\n+            );\n         });\n     }\n "}, {"sha": "c5e2c847b0dd5080801d109f328e0b39b75e8b00", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/aea57aee5fd6debadb91dd30cd4bb4ccb92411f6/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea57aee5fd6debadb91dd30cd4bb4ccb92411f6/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=aea57aee5fd6debadb91dd30cd4bb4ccb92411f6", "patch": "@@ -8,6 +8,7 @@ pub mod map;\n use crate::ich::StableHashingContext;\n use crate::ty::query::Providers;\n use crate::ty::TyCtxt;\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n@@ -17,42 +18,39 @@ use rustc_hir::ItemLocalId;\n use rustc_hir::Node;\n use rustc_index::vec::IndexVec;\n \n-#[derive(HashStable)]\n pub struct HirOwner<'tcx> {\n     parent: HirId,\n     node: Node<'tcx>,\n }\n \n-#[derive(Clone)]\n-pub struct HirItem<'tcx> {\n-    parent: ItemLocalId,\n-    node: Node<'tcx>,\n-}\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for HirItem<'tcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for HirOwner<'tcx> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let HirItem { parent, node } = self;\n+        let HirOwner { parent, node } = self;\n         hcx.while_hashing_hir_bodies(false, |hcx| {\n             parent.hash_stable(hcx, hasher);\n             node.hash_stable(hcx, hasher);\n         });\n     }\n }\n \n+#[derive(Clone)]\n+pub struct HirItem<'tcx> {\n+    parent: ItemLocalId,\n+    node: Node<'tcx>,\n+}\n+\n pub struct HirOwnerItems<'tcx> {\n-    owner: Node<'tcx>,\n+    hash: Fingerprint,\n     items: IndexVec<ItemLocalId, Option<HirItem<'tcx>>>,\n     bodies: FxHashMap<ItemLocalId, &'tcx Body<'tcx>>,\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for HirOwnerItems<'tcx> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        // We ignore the `items` and `bodies` fields since these refer to information reachable\n-        // when hashing `owner` with its bodies.\n-        let HirOwnerItems { owner, items: _, bodies: _ } = *self;\n-        hcx.while_hashing_hir_bodies(true, |hcx| {\n-            owner.hash_stable(hcx, hasher);\n-        });\n+        // We ignore the `items` and `bodies` fields since these refer to information included in\n+        // `hash` which is hashed in the collector and used for the crate hash.\n+        let HirOwnerItems { hash, items: _, bodies: _ } = *self;\n+        hash.hash_stable(hcx, hasher);\n     }\n }\n "}]}