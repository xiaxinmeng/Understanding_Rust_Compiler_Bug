{"sha": "14e3d038c002956fe07d8862e420ed37d7c194fc", "node_id": "C_kwDOAAsO6NoAKDE0ZTNkMDM4YzAwMjk1NmZlMDdkODg2MmU0MjBlZDM3ZDdjMTk0ZmM", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-04-02T10:17:07Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-04-02T10:47:06Z"}, "message": "rebase and remove dead code", "tree": {"sha": "b675c581c43776ff56d5f13c47562e90d89e7ca4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b675c581c43776ff56d5f13c47562e90d89e7ca4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14e3d038c002956fe07d8862e420ed37d7c194fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14e3d038c002956fe07d8862e420ed37d7c194fc", "html_url": "https://github.com/rust-lang/rust/commit/14e3d038c002956fe07d8862e420ed37d7c194fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14e3d038c002956fe07d8862e420ed37d7c194fc/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b28d3b494f5507b13b04f383bb4ea2bf23294fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b28d3b494f5507b13b04f383bb4ea2bf23294fc", "html_url": "https://github.com/rust-lang/rust/commit/9b28d3b494f5507b13b04f383bb4ea2bf23294fc"}], "stats": {"total": 238, "additions": 4, "deletions": 234}, "files": [{"sha": "6fd7f707e7e5d4813805e892f394e16a33cc73be", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/14e3d038c002956fe07d8862e420ed37d7c194fc/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e3d038c002956fe07d8862e420ed37d7c194fc/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=14e3d038c002956fe07d8862e420ed37d7c194fc", "patch": "@@ -172,40 +172,6 @@ pub(crate) fn try_destructure_const<'tcx>(\n     Ok(mir::DestructuredConst { variant, fields })\n }\n \n-pub(crate) fn destructure_mir_constant<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    val: mir::ConstantKind<'tcx>,\n-) -> mir::DestructuredMirConstant<'tcx> {\n-    trace!(\"destructure_const: {:?}\", val);\n-    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n-    let op = ecx.mir_const_to_op(&val, None).unwrap();\n-\n-    // We go to `usize` as we cannot allocate anything bigger anyway.\n-    let (field_count, variant, down) = match val.ty().kind() {\n-        ty::Array(_, len) => (usize::try_from(len.eval_usize(tcx, param_env)).unwrap(), None, op),\n-        ty::Adt(def, _) if def.variants().is_empty() => {\n-            return mir::DestructuredMirConstant { variant: None, fields: &[] };\n-        }\n-        ty::Adt(def, _) => {\n-            let variant = ecx.read_discriminant(&op).unwrap().1;\n-            let down = ecx.operand_downcast(&op, variant).unwrap();\n-            (def.variants()[variant].fields.len(), Some(variant), down)\n-        }\n-        ty::Tuple(substs) => (substs.len(), None, op),\n-        _ => bug!(\"cannot destructure constant {:?}\", val),\n-    };\n-\n-    let fields_iter = (0..field_count).map(|i| {\n-        let field_op = ecx.operand_field(&down, i).unwrap();\n-        let val = op_to_const(&ecx, &field_op);\n-        mir::ConstantKind::Val(val, field_op.layout.ty)\n-    });\n-    let fields = tcx.arena.alloc_from_iter(fields_iter);\n-\n-    mir::DestructuredMirConstant { variant, fields }\n-}\n-\n pub(crate) fn deref_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -241,39 +207,3 @@ pub(crate) fn deref_const<'tcx>(\n \n     tcx.mk_const(ty::ConstS { val: ty::ConstKind::Value(op_to_const(&ecx, &mplace.into())), ty })\n }\n-\n-#[instrument(skip(tcx), level = \"debug\")]\n-pub(crate) fn deref_mir_constant<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    val: mir::ConstantKind<'tcx>,\n-) -> mir::ConstantKind<'tcx> {\n-    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n-    let op = ecx.mir_const_to_op(&val, None).unwrap();\n-    let mplace = ecx.deref_operand(&op).unwrap();\n-    if let Some(alloc_id) = mplace.ptr.provenance {\n-        assert_eq!(\n-            tcx.get_global_alloc(alloc_id).unwrap().unwrap_memory().0.0.mutability,\n-            Mutability::Not,\n-            \"deref_const cannot be used with mutable allocations as \\\n-            that could allow pattern matching to observe mutable statics\",\n-        );\n-    }\n-\n-    let ty = match mplace.meta {\n-        MemPlaceMeta::None => mplace.layout.ty,\n-        MemPlaceMeta::Poison => bug!(\"poison metadata in `deref_const`: {:#?}\", mplace),\n-        // In case of unsized types, figure out the real type behind.\n-        MemPlaceMeta::Meta(scalar) => match mplace.layout.ty.kind() {\n-            ty::Str => bug!(\"there's no sized equivalent of a `str`\"),\n-            ty::Slice(elem_ty) => tcx.mk_array(*elem_ty, scalar.to_machine_usize(&tcx).unwrap()),\n-            _ => bug!(\n-                \"type {} should not have metadata, but had {:?}\",\n-                mplace.layout.ty,\n-                mplace.meta\n-            ),\n-        },\n-    };\n-\n-    mir::ConstantKind::Val(op_to_const(&ecx, &mplace.into()), ty)\n-}"}, {"sha": "d688331ae0a56f569fac57467846e593a02164b6", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14e3d038c002956fe07d8862e420ed37d7c194fc/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e3d038c002956fe07d8862e420ed37d7c194fc/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=14e3d038c002956fe07d8862e420ed37d7c194fc", "patch": "@@ -45,10 +45,6 @@ pub fn provide(providers: &mut Providers) {\n         let (param_env, value) = param_env_and_value.into_parts();\n         const_eval::try_destructure_const(tcx, param_env, value).ok()\n     };\n-    providers.destructure_mir_constant = |tcx, param_env_and_value| {\n-        let (param_env, value) = param_env_and_value.into_parts();\n-        const_eval::destructure_mir_constant(tcx, param_env, value)\n-    };\n     providers.const_to_valtree = |tcx, param_env_and_value| {\n         let (param_env, raw) = param_env_and_value.into_parts();\n         const_eval::const_to_valtree(tcx, param_env, raw)\n@@ -57,8 +53,4 @@ pub fn provide(providers: &mut Providers) {\n         let (param_env, value) = param_env_and_value.into_parts();\n         const_eval::deref_const(tcx, param_env, value)\n     };\n-    providers.deref_mir_constant = |tcx, param_env_and_value| {\n-        let (param_env, value) = param_env_and_value.into_parts();\n-        const_eval::deref_mir_constant(tcx, param_env, value)\n-    }\n }"}, {"sha": "9c2a6f205e0529a59470dd2ee50473bf5cae5fb4", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 107, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/14e3d038c002956fe07d8862e420ed37d7c194fc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e3d038c002956fe07d8862e420ed37d7c194fc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=14e3d038c002956fe07d8862e420ed37d7c194fc", "patch": "@@ -2721,8 +2721,8 @@ impl<'tcx> ConstantKind<'tcx> {\n         }\n     }\n \n-    #[inline]\n     /// Panics if the value cannot be evaluated or doesn't contain a valid integer of the given type.\n+    #[inline]\n     pub fn eval_bits(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> u128 {\n         self.try_eval_bits(tcx, param_env, ty)\n             .unwrap_or_else(|| bug!(\"expected bits of {:#?}, got {:#?}\", ty, self))\n@@ -2793,112 +2793,6 @@ impl<'tcx> ConstantKind<'tcx> {\n         Self::from_bits(tcx, n as u128, ty::ParamEnv::empty().and(ty))\n     }\n \n-    #[instrument(skip(tcx), level = \"debug\")]\n-    pub fn try_eval_lit_or_param(\n-        tcx: TyCtxt<'tcx>,\n-        ty: Ty<'tcx>,\n-        expr: &'tcx hir::Expr<'tcx>,\n-    ) -> Option<Self> {\n-        // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n-        // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n-        let expr = match &expr.kind {\n-            hir::ExprKind::Block(block, _) if block.stmts.is_empty() && block.expr.is_some() => {\n-                block.expr.as_ref().unwrap()\n-            }\n-            _ => expr,\n-        };\n-\n-        let lit_input = match expr.kind {\n-            hir::ExprKind::Lit(ref lit) => {\n-                Some(interpret::LitToConstInput { lit: &lit.node, ty, neg: false })\n-            }\n-            hir::ExprKind::Unary(hir::UnOp::Neg, ref expr) => match expr.kind {\n-                hir::ExprKind::Lit(ref lit) => {\n-                    Some(interpret::LitToConstInput { lit: &lit.node, ty, neg: true })\n-                }\n-                _ => None,\n-            },\n-            _ => None,\n-        };\n-\n-        if let Some(lit_input) = lit_input {\n-            // If an error occurred, ignore that it's a literal and leave reporting the error up to\n-            // mir.\n-            match tcx.at(expr.span).lit_to_mir_constant(lit_input) {\n-                Ok(c) => return Some(c),\n-                Err(e) => {\n-                    tcx.sess.delay_span_bug(\n-                        expr.span,\n-                        &format!(\"Const::from_anon_const: couldn't lit_to_const {:?}\", e),\n-                    );\n-                }\n-            }\n-        }\n-        use hir::{def::DefKind::ConstParam, def::Res, ExprKind, Path, QPath};\n-        match expr.kind {\n-            ExprKind::Path(QPath::Resolved(_, &Path { res: Res::Def(ConstParam, def_id), .. })) => {\n-                // Find the name and index of the const parameter by indexing the generics of\n-                // the parent item and construct a `ParamConst`.\n-                let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-                let item_id = tcx.hir().get_parent_node(hir_id);\n-                let item_def_id = tcx.hir().local_def_id(item_id);\n-                let generics = tcx.generics_of(item_def_id.to_def_id());\n-                let index = generics.param_def_id_to_index[&def_id];\n-                let name = tcx.hir().name(hir_id);\n-                let ty_const = tcx.mk_const(ty::ConstS {\n-                    val: ty::ConstKind::Param(ty::ParamConst::new(index, name)),\n-                    ty,\n-                });\n-\n-                Some(Self::Ty(ty_const))\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    #[instrument(skip(tcx), level = \"debug\")]\n-    pub fn from_inline_const(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Self {\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-\n-        let body_id = match tcx.hir().get(hir_id) {\n-            hir::Node::AnonConst(ac) => ac.body,\n-            _ => span_bug!(\n-                tcx.def_span(def_id.to_def_id()),\n-                \"from_inline_const can only process anonymous constants\"\n-            ),\n-        };\n-\n-        let expr = &tcx.hir().body(body_id).value;\n-\n-        let ty = tcx.typeck(def_id).node_type(hir_id);\n-\n-        let ret = match Self::try_eval_lit_or_param(tcx, ty, expr) {\n-            Some(v) => v,\n-            None => {\n-                let typeck_root_def_id = tcx.typeck_root_def_id(def_id.to_def_id());\n-                let parent_substs =\n-                    tcx.erase_regions(InternalSubsts::identity_for_item(tcx, typeck_root_def_id));\n-                let substs = ty::InlineConstSubsts::new(\n-                    tcx,\n-                    ty::InlineConstSubstsParts { parent_substs, ty },\n-                )\n-                .substs;\n-                let ty_const = tcx.mk_const(ty::ConstS {\n-                    val: ty::ConstKind::Unevaluated(ty::Unevaluated {\n-                        def: ty::WithOptConstParam::unknown(def_id).to_global(),\n-                        substs,\n-                        promoted: None,\n-                    }),\n-                    ty,\n-                });\n-\n-                Self::Ty(ty_const)\n-            }\n-        };\n-        debug_assert!(!ret.has_free_regions());\n-        ret\n-    }\n-\n     /// Literals are converted to `ConstantKindVal`, const generic parameters are eagerly\n     /// converted to a constant, everything else becomes `Unevaluated`.\n     pub fn from_anon_const("}, {"sha": "cee510a42413abbf63457fc6cce2452201deb8f7", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/14e3d038c002956fe07d8862e420ed37d7c194fc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e3d038c002956fe07d8862e420ed37d7c194fc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=14e3d038c002956fe07d8862e420ed37d7c194fc", "patch": "@@ -1,6 +1,6 @@\n //! Values computed by queries that use MIR.\n \n-use crate::mir::{self, Body, Promoted};\n+use crate::mir::{Body, Promoted};\n use crate::ty::{self, OpaqueHiddenType, Ty, TyCtxt};\n use rustc_data_structures::stable_map::FxHashMap;\n use rustc_data_structures::vec_map::VecMap;\n@@ -421,13 +421,6 @@ pub struct DestructuredConst<'tcx> {\n     pub fields: &'tcx [ty::Const<'tcx>],\n }\n \n-/// The constituent parts of an ADT or array.\n-#[derive(Copy, Clone, Debug, HashStable)]\n-pub struct DestructuredMirConstant<'tcx> {\n-    pub variant: Option<VariantIdx>,\n-    pub fields: &'tcx [mir::ConstantKind<'tcx>],\n-}\n-\n /// Coverage information summarized from a MIR if instrumented for source code coverage (see\n /// compiler option `-Cinstrument-coverage`). This information is generated by the\n /// `InstrumentCoverage` MIR pass and can be retrieved via the `coverageinfo` query."}, {"sha": "d382b9c58a27b8a7e01f332b674f14feed1cbf73", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/14e3d038c002956fe07d8862e420ed37d7c194fc/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e3d038c002956fe07d8862e420ed37d7c194fc/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=14e3d038c002956fe07d8862e420ed37d7c194fc", "patch": "@@ -940,13 +940,6 @@ rustc_queries! {\n         remap_env_constness\n     }\n \n-    /// Destructure an `mir::ConstantKind` ADT or array into its variant index\n-    /// and its field values.\n-    query destructure_mir_constant(key: ty::ParamEnvAnd<'tcx, mir::ConstantKind<'tcx>>) -> mir::DestructuredMirConstant<'tcx> {\n-        desc { \"destructure mir constant\"}\n-        remap_env_constness\n-    }\n-\n     /// Dereference a constant reference or raw pointer and turn the result into a constant\n     /// again.\n     query deref_const(\n@@ -956,15 +949,6 @@ rustc_queries! {\n         remap_env_constness\n     }\n \n-    /// Dereference a constant reference or raw pointer and turn the result into a constant\n-    /// again.\n-    query deref_mir_constant(\n-        key: ty::ParamEnvAnd<'tcx, mir::ConstantKind<'tcx>>\n-    ) -> mir::ConstantKind<'tcx> {\n-        desc { \"deref constant\" }\n-        remap_env_constness\n-    }\n-\n     query const_caller_location(key: (rustc_span::Symbol, u32, u32)) -> ConstValue<'tcx> {\n         desc { \"get a &core::panic::Location referring to a span\" }\n     }"}, {"sha": "f17fe38b292cbca5b6234856f23d40f293f68f17", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/14e3d038c002956fe07d8862e420ed37d7c194fc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e3d038c002956fe07d8862e420ed37d7c194fc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=14e3d038c002956fe07d8862e420ed37d7c194fc", "patch": "@@ -5,18 +5,15 @@\n use crate::thir::pattern::pat_from_hir;\n use crate::thir::util::UserAnnotatedTyHelpers;\n \n-use rustc_ast::ast;\n use rustc_data_structures::steal::Steal;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::HirId;\n use rustc_hir::Node;\n use rustc_middle::middle::region;\n-use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n-use rustc_middle::mir::ConstantKind;\n use rustc_middle::thir::*;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::Span;\n \n crate fn thir_body<'tcx>(\n@@ -78,24 +75,6 @@ impl<'tcx> Cx<'tcx> {\n         }\n     }\n \n-    #[instrument(skip(self), level = \"debug\")]\n-    crate fn const_eval_literal(\n-        &mut self,\n-        lit: &'tcx ast::LitKind,\n-        ty: Ty<'tcx>,\n-        sp: Span,\n-        neg: bool,\n-    ) -> ConstantKind<'tcx> {\n-        match self.tcx.at(sp).lit_to_mir_constant(LitToConstInput { lit, ty, neg }) {\n-            Ok(c) => c,\n-            Err(LitToConstError::Reported) => {\n-                // create a dummy value and continue compiling\n-                ConstantKind::Ty(self.tcx.const_error(ty))\n-            }\n-            Err(LitToConstError::TypeError) => bug!(\"const_eval_literal: had type error\"),\n-        }\n-    }\n-\n     crate fn pattern_from_hir(&mut self, p: &hir::Pat<'_>) -> Pat<'tcx> {\n         let p = match self.tcx.hir().get(p.hir_id) {\n             Node::Pat(p) | Node::Binding(p) => p,"}, {"sha": "59b9d2c92792917143dfd6698cabb5788e1bc1fb", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e3d038c002956fe07d8862e420ed37d7c194fc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e3d038c002956fe07d8862e420ed37d7c194fc/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=14e3d038c002956fe07d8862e420ed37d7c194fc", "patch": "@@ -739,7 +739,6 @@ impl<'tcx> PatternFoldable<'tcx> for PatKind<'tcx> {\n     }\n }\n \n-// FIXME: Get rid of this function once valtrees land\n #[instrument(skip(tcx), level = \"debug\")]\n crate fn compare_const_vals<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -759,8 +758,7 @@ crate fn compare_const_vals<'tcx>(\n \n     // Early return for equal constants (so e.g. references to ZSTs can be compared, even if they\n     // are just integer addresses).\n-    // FIXME This might be wrong\n-    if a == b {\n+    if a.val() == b.val() {\n         return from_bool(true);\n     }\n "}]}