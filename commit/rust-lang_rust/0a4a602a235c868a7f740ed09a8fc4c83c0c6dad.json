{"sha": "0a4a602a235c868a7f740ed09a8fc4c83c0c6dad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhNGE2MDJhMjM1Yzg2OGE3Zjc0MGVkMDlhOGZjNGM4M2MwYzZkYWQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-06-20T01:35:56Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-07-10T22:16:48Z"}, "message": "Modify reflect interface to pass tydescs back to client, stop on false return.\n\nThese changes are required to prune type-recursion and admit early\nreturns in the visitor code. Changes to visitors in subsequent csets.", "tree": {"sha": "658f07f41c582049ade16430ada19b735837e58e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/658f07f41c582049ade16430ada19b735837e58e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad", "html_url": "https://github.com/rust-lang/rust/commit/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef9a64709efafbcf692a80413ba71fd37733ceb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef9a64709efafbcf692a80413ba71fd37733ceb5", "html_url": "https://github.com/rust-lang/rust/commit/ef9a64709efafbcf692a80413ba71fd37733ceb5"}], "stats": {"total": 759, "additions": 356, "deletions": 403}, "files": [{"sha": "21d8777e22df0511e5584715ceb299c79748461b", "filename": "src/rustc/front/intrinsic.rs", "status": "modified", "additions": 39, "deletions": 44, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/src%2Frustc%2Ffront%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/src%2Frustc%2Ffront%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fintrinsic.rs?ref=0a4a602a235c868a7f740ed09a8fc4c83c0c6dad", "patch": "@@ -3,8 +3,21 @@\n \n mod intrinsic {\n \n-    import rusti::visit_ty;\n-    export ty_visitor, visit_ty;\n+    import rusti::visit_tydesc;\n+    export ty_visitor, get_tydesc, visit_tydesc, tydesc;\n+\n+    // FIXME (#2712): remove this when the interface has settled and the\n+    // version in sys is no longer present.\n+    fn get_tydesc<T>() -> *tydesc {\n+        rusti::get_tydesc::<T>() as *tydesc\n+    }\n+\n+    enum tydesc = {\n+        first_param: **u8,\n+        size: uint,\n+        align: uint\n+        // Remaining fields not listed\n+    };\n \n     iface ty_visitor {\n         fn visit_bot() -> bool;\n@@ -35,50 +48,37 @@ mod intrinsic {\n         fn visit_estr_slice() -> bool;\n         fn visit_estr_fixed(sz: uint) -> bool;\n \n-        fn visit_enter_box(mtbl: uint) -> bool;\n-        fn visit_leave_box(mtbl: uint) -> bool;\n-        fn visit_enter_uniq(mtbl: uint) -> bool;\n-        fn visit_leave_uniq(mtbl: uint) -> bool;\n-        fn visit_enter_ptr(mtbl: uint) -> bool;\n-        fn visit_leave_ptr(mtbl: uint) -> bool;\n-        fn visit_enter_rptr(mtbl: uint) -> bool;\n-        fn visit_leave_rptr(mtbl: uint) -> bool;\n-\n-        fn visit_enter_vec(mtbl: uint) -> bool;\n-        fn visit_leave_vec(mtbl: uint) -> bool;\n-        fn visit_enter_evec_box(mtbl: uint) -> bool;\n-        fn visit_leave_evec_box(mtbl: uint) -> bool;\n-        fn visit_enter_evec_uniq(mtbl: uint) -> bool;\n-        fn visit_leave_evec_uniq(mtbl: uint) -> bool;\n-        fn visit_enter_evec_slice(mtbl: uint) -> bool;\n-        fn visit_leave_evec_slice(mtbl: uint) -> bool;\n-        fn visit_enter_evec_fixed(mtbl: uint, n: uint,\n-                                  sz: uint, align: uint) -> bool;\n-        fn visit_leave_evec_fixed(mtbl: uint, n: uint,\n-                                  sz: uint, align: uint) -> bool;\n+        fn visit_box(mtbl: uint, inner: *tydesc) -> bool;\n+        fn visit_uniq(mtbl: uint, inner: *tydesc) -> bool;\n+        fn visit_ptr(mtbl: uint, inner: *tydesc) -> bool;\n+        fn visit_rptr(mtbl: uint, inner: *tydesc) -> bool;\n+\n+        fn visit_vec(mtbl: uint, inner: *tydesc) -> bool;\n+        fn visit_unboxed_vec(mtbl: uint, inner: *tydesc) -> bool;\n+        fn visit_evec_box(mtbl: uint, inner: *tydesc) -> bool;\n+        fn visit_evec_uniq(mtbl: uint, inner: *tydesc) -> bool;\n+        fn visit_evec_slice(mtbl: uint, inner: *tydesc) -> bool;\n+        fn visit_evec_fixed(n: uint, mtbl: uint,\n+                            sz: uint, align: uint,\n+                            inner: *tydesc) -> bool;\n \n         fn visit_enter_rec(n_fields: uint,\n                            sz: uint, align: uint) -> bool;\n-        fn visit_enter_rec_field(mtbl: uint, i: uint,\n-                                 name: str/&) -> bool;\n-        fn visit_leave_rec_field(mtbl: uint, i: uint,\n-                                 name: str/&) -> bool;\n+        fn visit_rec_field(i: uint, name: str/&,\n+                           mtbl: uint, inner: *tydesc) -> bool;\n         fn visit_leave_rec(n_fields: uint,\n                            sz: uint, align: uint) -> bool;\n \n         fn visit_enter_class(n_fields: uint,\n                              sz: uint, align: uint) -> bool;\n-        fn visit_enter_class_field(mtbl: uint, i: uint,\n-                                   name: str/&) -> bool;\n-        fn visit_leave_class_field(mtbl: uint, i: uint,\n-                                   name: str/&) -> bool;\n+        fn visit_class_field(i: uint, name: str/&,\n+                             mtbl: uint, inner: *tydesc) -> bool;\n         fn visit_leave_class(n_fields: uint,\n                              sz: uint, align: uint) -> bool;\n \n         fn visit_enter_tup(n_fields: uint,\n                            sz: uint, align: uint) -> bool;\n-        fn visit_enter_tup_field(i: uint) -> bool;\n-        fn visit_leave_tup_field(i: uint) -> bool;\n+        fn visit_tup_field(i: uint, inner: *tydesc) -> bool;\n         fn visit_leave_tup(n_fields: uint,\n                            sz: uint, align: uint) -> bool;\n \n@@ -88,8 +88,7 @@ mod intrinsic {\n                                     disr_val: int,\n                                     n_fields: uint,\n                                     name: str/&) -> bool;\n-        fn visit_enter_enum_variant_field(i: uint) -> bool;\n-        fn visit_leave_enum_variant_field(i: uint) -> bool;\n+        fn visit_enum_variant_field(i: uint, inner: *tydesc) -> bool;\n         fn visit_leave_enum_variant(variant: uint,\n                                     disr_val: int,\n                                     n_fields: uint,\n@@ -99,29 +98,25 @@ mod intrinsic {\n \n         fn visit_enter_fn(purity: uint, proto: uint,\n                           n_inputs: uint, retstyle: uint) -> bool;\n-        fn visit_enter_fn_input(i: uint, mode: uint) -> bool;\n-        fn visit_leave_fn_input(i: uint, mode: uint) -> bool;\n-        fn visit_enter_fn_output(retstyle: uint) -> bool;\n-        fn visit_leave_fn_output(retstyle: uint) -> bool;\n+        fn visit_fn_input(i: uint, mode: uint, inner: *tydesc) -> bool;\n+        fn visit_fn_output(retstyle: uint, inner: *tydesc) -> bool;\n         fn visit_leave_fn(purity: uint, proto: uint,\n                           n_inputs: uint, retstyle: uint) -> bool;\n \n         fn visit_trait() -> bool;\n-        fn visit_enter_res() -> bool;\n-        fn visit_leave_res() -> bool;\n         fn visit_var() -> bool;\n         fn visit_var_integral() -> bool;\n         fn visit_param(i: uint) -> bool;\n         fn visit_self() -> bool;\n         fn visit_type() -> bool;\n         fn visit_opaque_box() -> bool;\n-        fn visit_enter_constr() -> bool;\n-        fn visit_leave_constr() -> bool;\n+        fn visit_constr(inner: *tydesc) -> bool;\n         fn visit_closure_ptr(ck: uint) -> bool;\n     }\n \n     #[abi = \"rust-intrinsic\"]\n     extern mod rusti {\n-        fn visit_ty<T>(&&tv: ty_visitor);\n+        fn get_tydesc<T>() -> *();\n+        fn visit_tydesc(td: *tydesc, &&tv: ty_visitor);\n     }\n }"}, {"sha": "d17c4ba2ca2c19d11fc3d341b824ddabe04b2c2f", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0a4a602a235c868a7f740ed09a8fc4c83c0c6dad", "patch": "@@ -671,8 +671,8 @@ fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"make_visit_glue\");\n     let mut bcx = bcx;\n-    assert bcx.ccx().tcx.intrinsic_traits.contains_key(@\"ty_visitor\");\n-    let (iid, ty) = bcx.ccx().tcx.intrinsic_traits.get(@\"ty_visitor\");\n+    assert bcx.ccx().tcx.intrinsic_defs.contains_key(@\"ty_visitor\");\n+    let (iid, ty) = bcx.ccx().tcx.intrinsic_defs.get(@\"ty_visitor\");\n     let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), ty)));\n     bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, iid);\n     build_return(bcx);"}, {"sha": "d46779d4fe767b7f321a78b15db45f1390e5183f", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=0a4a602a235c868a7f740ed09a8fc4c83c0c6dad", "patch": "@@ -910,8 +910,13 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n       }\n       \"get_tydesc\" {\n         let tp_ty = substs.tys[0];\n-        let td = get_tydesc_simple(ccx, tp_ty);\n-        Store(bcx, PointerCast(bcx, td, T_ptr(T_nil())), fcx.llretptr);\n+        let mut static_ti = none;\n+        let lltydesc = get_tydesc(ccx, tp_ty, static_ti);\n+        lazily_emit_all_tydesc_glue(ccx, copy static_ti);\n+        // FIXME (#2712): change this to T_ptr(ccx.tydesc_ty) when the\n+        // core::sys copy of the get_tydesc interface dies off.\n+        let td = PointerCast(bcx, lltydesc, T_ptr(T_nil()));\n+        Store(bcx, td, fcx.llretptr);\n       }\n       \"init\" {\n         let tp_ty = substs.tys[0];\n@@ -951,10 +956,12 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n         Store(bcx, C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)),\n               fcx.llretptr);\n       }\n-      \"visit_ty\" {\n-        let tp_ty = substs.tys[0];\n-        let visitor = get_param(decl, first_real_arg);\n-        call_tydesc_glue(bcx, visitor, tp_ty, abi::tydesc_field_visit_glue);\n+      \"visit_tydesc\" {\n+        let td = get_param(decl, first_real_arg);\n+        let visitor = get_param(decl, first_real_arg + 1u);\n+        let td = PointerCast(bcx, td, T_ptr(ccx.tydesc_type));\n+        call_tydesc_glue_full(bcx, visitor, td,\n+                              abi::tydesc_field_visit_glue, none);\n       }\n       \"frame_address\" {\n         let frameaddress = ccx.intrinsics.get(\"llvm.frameaddress\");"}, {"sha": "e77b60db39c317cab13bb65b988d5fc8c3fe7dae", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 88, "deletions": 67, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=0a4a602a235c868a7f740ed09a8fc4c83c0c6dad", "patch": "@@ -13,6 +13,8 @@ import util::ppaux::ty_to_str;\n enum reflector = {\n     visitor_val: ValueRef,\n     visitor_methods: @~[ty::method],\n+    final_bcx: block,\n+    tydesc_ty: TypeRef,\n     mut bcx: block\n };\n \n@@ -39,6 +41,19 @@ impl methods for reflector {\n              self.c_uint(a)];\n     }\n \n+    fn c_tydesc(t: ty::t) -> ValueRef {\n+        let bcx = self.bcx;\n+        let mut static_ti = none;\n+        let lltydesc = get_tydesc(bcx.ccx(), t, static_ti);\n+        lazily_emit_all_tydesc_glue(bcx.ccx(), copy static_ti);\n+        PointerCast(bcx, lltydesc, T_ptr(self.tydesc_ty))\n+    }\n+\n+    fn c_mt(mt: ty::mt) -> ~[ValueRef] {\n+        ~[self.c_uint(mt.mutbl as uint),\n+          self.c_tydesc(mt.ty)]\n+    }\n+\n     fn visit(ty_name: str, args: ~[ValueRef]) {\n         let tcx = self.bcx.tcx();\n         let mth_idx = option::get(ty::method_idx(@(\"visit_\" + ty_name),\n@@ -58,29 +73,22 @@ impl methods for reflector {\n         for args.eachi |i, a| {\n             #debug(\"arg %u: %s\", i, val_str(bcx.ccx().tn, a));\n         }\n-        self.bcx =\n+        let d = empty_dest_cell();\n+        let bcx =\n             trans_call_inner(self.bcx, none, mth_ty, ty::mk_bool(tcx),\n-                             get_lval, arg_vals(args), ignore);\n-    }\n-\n-    fn visit_tydesc(t: ty::t) {\n-        self.bcx =\n-            call_tydesc_glue(self.bcx, self.visitor_val, t,\n-                             abi::tydesc_field_visit_glue);\n+                             get_lval, arg_vals(args), by_val(d));\n+        let next_bcx = sub_block(bcx, \"next\");\n+        CondBr(bcx, *d, next_bcx.llbb, self.final_bcx.llbb);\n+        self.bcx = next_bcx\n     }\n \n-    fn bracketed_t(bracket_name: str, t: ty::t, extra: ~[ValueRef]) {\n+    fn bracketed(bracket_name: str, extra: ~[ValueRef],\n+                 inner: fn()) {\n         self.visit(\"enter_\" + bracket_name, extra);\n-        self.visit_tydesc(t);\n+        inner();\n         self.visit(\"leave_\" + bracket_name, extra);\n     }\n \n-    fn bracketed_mt(bracket_name: str, mt: ty::mt, extra: ~[ValueRef]) {\n-        self.bracketed_t(bracket_name, mt.ty,\n-                         vec::append(~[self.c_uint(mt.mutbl as uint)],\n-                                     extra));\n-    }\n-\n     fn vstore_name_and_extra(t: ty::t,\n                              vstore: ty::vstore,\n                              f: fn(str,~[ValueRef])) {\n@@ -127,42 +135,47 @@ impl methods for reflector {\n           ty::ty_float(ast::ty_f64) { self.leaf(\"f64\") }\n           ty::ty_str { self.leaf(\"str\") }\n \n-          ty::ty_vec(mt) { self.bracketed_mt(\"vec\", mt, ~[]) }\n+          ty::ty_vec(mt) { self.visit(\"vec\", self.c_mt(mt)) }\n+          ty::ty_unboxed_vec(mt) { self.visit(\"vec\", self.c_mt(mt)) }\n           ty::ty_estr(vst) {\n             do self.vstore_name_and_extra(t, vst) |name, extra| {\n                 self.visit(\"estr_\" + name, extra)\n             }\n           }\n           ty::ty_evec(mt, vst) {\n             do self.vstore_name_and_extra(t, vst) |name, extra| {\n-                self.bracketed_mt(\"evec_\" + name, mt, extra)\n+                self.visit(\"evec_\" + name, extra +\n+                           self.c_mt(mt))\n             }\n           }\n-          ty::ty_box(mt) { self.bracketed_mt(\"box\", mt, ~[]) }\n-          ty::ty_uniq(mt) { self.bracketed_mt(\"uniq\", mt, ~[]) }\n-          ty::ty_ptr(mt) { self.bracketed_mt(\"ptr\", mt, ~[]) }\n-          ty::ty_rptr(_, mt) { self.bracketed_mt(\"rptr\", mt, ~[]) }\n+          ty::ty_box(mt) { self.visit(\"box\", self.c_mt(mt)) }\n+          ty::ty_uniq(mt) { self.visit(\"uniq\", self.c_mt(mt)) }\n+          ty::ty_ptr(mt) { self.visit(\"ptr\", self.c_mt(mt)) }\n+          ty::ty_rptr(_, mt) { self.visit(\"rptr\", self.c_mt(mt)) }\n \n           ty::ty_rec(fields) {\n-            let extra = (vec::append(~[self.c_uint(vec::len(fields))],\n-                                     self.c_size_and_align(t)));\n-            self.visit(\"enter_rec\", extra);\n-            for fields.eachi |i, field| {\n-                self.bracketed_mt(\"rec_field\", field.mt,\n-                                  ~[self.c_uint(i),\n-                                   self.c_slice(*field.ident)]);\n+            do self.bracketed(\"rec\",\n+                              ~[self.c_uint(vec::len(fields))]\n+                              + self.c_size_and_align(t)) {\n+                for fields.eachi |i, field| {\n+                    self.visit(\"rec_field\",\n+                               ~[self.c_uint(i),\n+                                 self.c_slice(*field.ident)]\n+                               + self.c_mt(field.mt));\n+                }\n             }\n-            self.visit(\"leave_rec\", extra);\n           }\n \n           ty::ty_tup(tys) {\n-            let extra = (vec::append(~[self.c_uint(vec::len(tys))],\n-                                     self.c_size_and_align(t)));\n-            self.visit(\"enter_tup\", extra);\n-            for tys.eachi |i, t| {\n-                self.bracketed_t(\"tup_field\", t, ~[self.c_uint(i)]);\n+            do self.bracketed(\"tup\",\n+                              ~[self.c_uint(vec::len(tys))]\n+                              + self.c_size_and_align(t)) {\n+                for tys.eachi |i, t| {\n+                    self.visit(\"tup_field\",\n+                               ~[self.c_uint(i),\n+                                 self.c_tydesc(t)]);\n+                }\n             }\n-            self.visit(\"leave_tup\", extra);\n           }\n \n           // FIXME (#2594): fetch constants out of intrinsic:: for the\n@@ -203,29 +216,31 @@ impl methods for reflector {\n                     }\n                   }\n                 };\n-                self.bracketed_t(\"fn_input\", arg.ty,\n-                                 ~[self.c_uint(i),\n-                                  self.c_uint(modeval)]);\n+                self.visit(\"fn_input\",\n+                           ~[self.c_uint(i),\n+                             self.c_uint(modeval),\n+                             self.c_tydesc(arg.ty)]);\n             }\n-            self.bracketed_t(\"fn_output\", fty.output,\n-                             ~[self.c_uint(retval)]);\n+            self.visit(\"fn_output\",\n+                       ~[self.c_uint(retval),\n+                         self.c_tydesc(fty.output)]);\n             self.visit(\"leave_fn\", extra);\n           }\n \n           ty::ty_class(did, substs) {\n             let bcx = self.bcx;\n             let tcx = bcx.ccx().tcx;\n             let fields = ty::class_items_as_fields(tcx, did, substs);\n-            let extra = vec::append(~[self.c_uint(vec::len(fields))],\n-                                    self.c_size_and_align(t));\n \n-            self.visit(\"enter_class\", extra);\n-            for fields.eachi |i, field| {\n-                self.bracketed_mt(\"class_field\", field.mt,\n-                                  ~[self.c_uint(i),\n-                                   self.c_slice(*field.ident)]);\n+            do self.bracketed(\"class\", ~[self.c_uint(vec::len(fields))]\n+                              + self.c_size_and_align(t)) {\n+                for fields.eachi |i, field| {\n+                    self.visit(\"class_field\",\n+                               ~[self.c_uint(i),\n+                                self.c_slice(*field.ident)]\n+                               + self.c_mt(field.mt));\n+                }\n             }\n-            self.visit(\"leave_class\", extra);\n           }\n \n           // FIXME (#2595): visiting all the variants in turn is probably\n@@ -236,23 +251,24 @@ impl methods for reflector {\n             let bcx = self.bcx;\n             let tcx = bcx.ccx().tcx;\n             let variants = ty::substd_enum_variants(tcx, did, substs);\n-            let extra = vec::append(~[self.c_uint(vec::len(variants))],\n-                                    self.c_size_and_align(t));\n \n-            self.visit(\"enter_enum\", extra);\n-            for variants.eachi |i, v| {\n-                let extra = ~[self.c_uint(i),\n-                             self.c_int(v.disr_val),\n-                             self.c_uint(vec::len(v.args)),\n-                             self.c_slice(*v.name)];\n-                self.visit(\"enter_enum_variant\", extra);\n-                for v.args.eachi |j, a| {\n-                    self.bracketed_t(\"enum_variant_field\", a,\n-                                     ~[self.c_uint(j)]);\n+            do self.bracketed(\"enum\",\n+                              ~[self.c_uint(vec::len(variants))]\n+                              + self.c_size_and_align(t)) {\n+                for variants.eachi |i, v| {\n+                    do self.bracketed(\"enum_variant\",\n+                                      ~[self.c_uint(i),\n+                                        self.c_int(v.disr_val),\n+                                        self.c_uint(vec::len(v.args)),\n+                                        self.c_slice(*v.name)]) {\n+                        for v.args.eachi |j, a| {\n+                            self.visit(\"enum_variant_field\",\n+                                       ~[self.c_uint(j),\n+                                         self.c_tydesc(a)]);\n+                        }\n+                    }\n                 }\n-                self.visit(\"leave_enum_variant\", extra);\n             }\n-            self.visit(\"leave_enum\", extra);\n           }\n \n           // Miscallaneous extra types\n@@ -263,7 +279,7 @@ impl methods for reflector {\n           ty::ty_self { self.leaf(\"self\") }\n           ty::ty_type { self.leaf(\"type\") }\n           ty::ty_opaque_box { self.leaf(\"opaque_box\") }\n-          ty::ty_constr(t, _) { self.bracketed_t(\"constr\", t, ~[]) }\n+          ty::ty_constr(t, _) { self.visit(\"constr\", ~[self.c_tydesc(t)]) }\n           ty::ty_opaque_closure_ptr(ck) {\n             let ckval = alt ck {\n               ty::ck_block { 0u }\n@@ -272,7 +288,6 @@ impl methods for reflector {\n             };\n             self.visit(\"closure_ptr\", ~[self.c_uint(ckval)])\n           }\n-          ty::ty_unboxed_vec(mt) { self.bracketed_mt(\"vec\", mt, ~[]) }\n         }\n     }\n }\n@@ -282,12 +297,18 @@ fn emit_calls_to_trait_visit_ty(bcx: block, t: ty::t,\n                                 visitor_val: ValueRef,\n                                 visitor_iid: def_id) -> block {\n \n+    let final = sub_block(bcx, \"final\");\n+    assert bcx.ccx().tcx.intrinsic_defs.contains_key(@\"tydesc\");\n+    let (_, tydesc_ty) = bcx.ccx().tcx.intrinsic_defs.get(@\"tydesc\");\n+    let tydesc_ty = type_of::type_of(bcx.ccx(), tydesc_ty);\n     let r = reflector({\n         visitor_val: visitor_val,\n         visitor_methods: ty::trait_methods(bcx.tcx(), visitor_iid),\n+        final_bcx: final,\n+        tydesc_ty: tydesc_ty,\n         mut bcx: bcx\n     });\n-\n     r.visit_ty(t);\n-    ret r.bcx;\n+    Br(r.bcx, final.llbb);\n+    ret final;\n }"}, {"sha": "ef2a95005da78d634b82ea09ce33738a80377504", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=0a4a602a235c868a7f740ed09a8fc4c83c0c6dad", "patch": "@@ -76,7 +76,6 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n                                  abi, _) {\n         if abi == foreign_abi_rust_intrinsic {\n             let flags = alt check *i.ident {\n-              \"visit_ty\" { use_repr | use_tydesc }\n               \"size_of\" |  \"pref_align_of\" | \"min_align_of\" |\n               \"init\" |  \"reinterpret_cast\" | \"move_val\" | \"move_val_init\" {\n                 use_repr\n@@ -87,7 +86,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n               \"atomic_xchng_rel\" | \"atomic_add_rel\" | \"atomic_sub_rel\" {\n                 0u\n               }\n-              \"forget\" | \"addr_of\" { 0u }\n+              \"visit_tydesc\" | \"forget\" | \"addr_of\" { 0u }\n             };\n             for uint::range(0u, n_tps) |n| { cx.uses[n] |= flags;}\n         }"}, {"sha": "f4febfa051209a9a06b1462021b7883f9eedfac7", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=0a4a602a235c868a7f740ed09a8fc4c83c0c6dad", "patch": "@@ -247,7 +247,7 @@ type ctxt =\n       node_type_substs: hashmap<node_id, ~[t]>,\n \n       items: ast_map::map,\n-      intrinsic_traits: hashmap<ast::ident, (ast::def_id, t)>,\n+      intrinsic_defs: hashmap<ast::ident, (ast::def_id, t)>,\n       freevars: freevars::freevar_map,\n       tcache: type_cache,\n       rcache: creader_cache,\n@@ -526,7 +526,7 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n       node_types: @smallintmap::mk(),\n       node_type_substs: map::int_hash(),\n       items: amap,\n-      intrinsic_traits: map::box_str_hash(),\n+      intrinsic_defs: map::box_str_hash(),\n       freevars: freevars,\n       tcache: ast_util::new_def_hash(),\n       rcache: mk_rcache(),"}, {"sha": "bd9230613d31a4ac78c6c22e3b242a62a15ba262", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=0a4a602a235c868a7f740ed09a8fc4c83c0c6dad", "patch": "@@ -2254,7 +2254,6 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n     let (n_tps, inputs, output) = alt *it.ident {\n       \"size_of\" |\n       \"pref_align_of\" | \"min_align_of\" { (1u, ~[], ty::mk_uint(ccx.tcx)) }\n-      \"get_tydesc\" { (1u, ~[], ty::mk_nil_ptr(tcx)) }\n       \"init\" { (1u, ~[], param(ccx, 0u)) }\n       \"forget\" { (1u, ~[arg(ast::by_move, param(ccx, 0u))],\n                   ty::mk_nil(tcx)) }\n@@ -2277,10 +2276,19 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n          ty::mk_int(tcx))\n       }\n \n-      \"visit_ty\" {\n-        assert ccx.tcx.intrinsic_traits.contains_key(@\"ty_visitor\");\n-        let (_, visitor_trait) = ccx.tcx.intrinsic_traits.get(@\"ty_visitor\");\n-        (1u, ~[arg(ast::by_ref, visitor_trait)], ty::mk_nil(tcx))\n+      \"get_tydesc\" {\n+        // FIXME (#2712): return *intrinsic::tydesc, not *()\n+        (1u, ~[], ty::mk_nil_ptr(tcx))\n+      }\n+      \"visit_tydesc\" {\n+        assert ccx.tcx.intrinsic_defs.contains_key(@\"tydesc\");\n+        assert ccx.tcx.intrinsic_defs.contains_key(@\"ty_visitor\");\n+        let (_, tydesc_ty) = ccx.tcx.intrinsic_defs.get(@\"tydesc\");\n+        let (_, visitor_trait) = ccx.tcx.intrinsic_defs.get(@\"ty_visitor\");\n+        let td_ptr = ty::mk_ptr(ccx.tcx, {ty: tydesc_ty,\n+                                          mutbl: ast::m_imm});\n+        (0u, ~[arg(ast::by_val, td_ptr),\n+               arg(ast::by_ref, visitor_trait)], ty::mk_nil(tcx))\n       }\n       \"frame_address\" {\n         let fty = ty::mk_fn(ccx.tcx, {"}, {"sha": "b1d0f02695750f0c022eee200ef901e17bb2aee6", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=0a4a602a235c868a7f740ed09a8fc4c83c0c6dad", "patch": "@@ -33,16 +33,25 @@ fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n             alt crate_item.node {\n               ast::item_mod(m) {\n                 for m.items.each |intrinsic_item| {\n+                    let def_id = { crate: ast::local_crate,\n+                                  node: intrinsic_item.id };\n+                    let substs = {self_r: none, self_ty: none, tps: ~[]};\n+\n                     alt intrinsic_item.node {\n+\n                       ast::item_trait(_, _, _) {\n-                        let def_id = { crate: ast::local_crate,\n-                                      node: intrinsic_item.id };\n-                        let substs = {self_r: none, self_ty: none, tps: ~[]};\n                         let ty = ty::mk_trait(ccx.tcx, def_id, substs);\n-                        ccx.tcx.intrinsic_traits.insert\n+                        ccx.tcx.intrinsic_defs.insert\n+                            (intrinsic_item.ident, (def_id, ty));\n+                      }\n+\n+                      ast::item_enum(_, _, _) {\n+                        let ty = ty::mk_enum(ccx.tcx, def_id, substs);\n+                        ccx.tcx.intrinsic_defs.insert\n                             (intrinsic_item.ident, (def_id, ty));\n                       }\n-                      _ { }\n+\n+                     _ { }\n                     }\n                 }\n               }"}, {"sha": "51cbba6f63e31d35e9409e472a04bba72ff9b901", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 123, "deletions": 203, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=0a4a602a235c868a7f740ed09a8fc4c83c0c6dad", "patch": "@@ -1,10 +1,17 @@\n // FIXME: un-xfail after snapshot\n // xfail-test\n \n-import intrinsic::ty_visitor;\n+import intrinsic::{tydesc, get_tydesc, visit_tydesc, ty_visitor};\n import libc::c_void;\n \n-/// High-level interfaces to `intrinsic::visit_ty` reflection system.\n+// FIXME: this is a near-duplicate of code in core::vec.\n+type unboxed_vec_repr = {\n+    mut fill: uint,\n+    mut alloc: uint,\n+    data: u8\n+};\n+\n+#[doc = \"High-level interfaces to `intrinsic::visit_ty` reflection system.\"]\n \n /// Iface for visitor that wishes to reflect on data.\n iface movable_ptr {\n@@ -201,114 +208,77 @@ impl ptr_visitor<V: ty_visitor movable_ptr>\n         true\n     }\n \n-    fn visit_enter_box(mtbl: uint) -> bool {\n+    fn visit_box(mtbl: uint, inner: *tydesc) -> bool {\n         self.align_to::<@u8>();\n-        if ! self.inner.visit_enter_box(mtbl) { ret false; }\n-        true\n-    }\n-\n-    fn visit_leave_box(mtbl: uint) -> bool {\n-        if ! self.inner.visit_leave_box(mtbl) { ret false; }\n+        if ! self.inner.visit_box(mtbl, inner) { ret false; }\n         self.bump_past::<@u8>();\n         true\n     }\n \n-    fn visit_enter_uniq(mtbl: uint) -> bool {\n+    fn visit_uniq(mtbl: uint, inner: *tydesc) -> bool {\n         self.align_to::<~u8>();\n-        if ! self.inner.visit_enter_uniq(mtbl) { ret false; }\n-        true\n-    }\n-\n-    fn visit_leave_uniq(mtbl: uint) -> bool {\n-        if ! self.inner.visit_leave_uniq(mtbl) { ret false; }\n+        if ! self.inner.visit_uniq(mtbl, inner) { ret false; }\n         self.bump_past::<~u8>();\n         true\n     }\n \n-    fn visit_enter_ptr(mtbl: uint) -> bool {\n+    fn visit_ptr(mtbl: uint, inner: *tydesc) -> bool {\n         self.align_to::<*u8>();\n-        if ! self.inner.visit_enter_ptr(mtbl) { ret false; }\n-        true\n-    }\n-\n-    fn visit_leave_ptr(mtbl: uint) -> bool {\n-        if ! self.inner.visit_leave_ptr(mtbl) { ret false; }\n+        if ! self.inner.visit_ptr(mtbl, inner) { ret false; }\n         self.bump_past::<*u8>();\n         true\n     }\n \n-    fn visit_enter_rptr(mtbl: uint) -> bool {\n+    fn visit_rptr(mtbl: uint, inner: *tydesc) -> bool {\n         self.align_to::<&static.u8>();\n-        if ! self.inner.visit_enter_rptr(mtbl) { ret false; }\n-        true\n-    }\n-\n-    fn visit_leave_rptr(mtbl: uint) -> bool {\n-        if ! self.inner.visit_leave_rptr(mtbl) { ret false; }\n+        if ! self.inner.visit_rptr(mtbl, inner) { ret false; }\n         self.bump_past::<&static.u8>();\n         true\n     }\n \n-    fn visit_enter_vec(mtbl: uint) -> bool {\n-        self.align_to::<~[u8]>();\n-        if ! self.inner.visit_enter_vec(mtbl) { ret false; }\n-        true\n-    }\n-\n-    fn visit_leave_vec(mtbl: uint) -> bool {\n-        if ! self.inner.visit_leave_vec(mtbl) { ret false; }\n-        self.bump_past::<~[u8]>();\n+    fn visit_unboxed_vec(mtbl: uint, inner: *tydesc) -> bool {\n+        self.align_to::<unboxed_vec_repr>();\n+        // FIXME: Inner really has to move its own pointers on this one.\n+        // or else possibly we could have some weird interface wherein we\n+        // read-off a word from inner's pointers, but the read-word has to\n+        // always be the same in all sub-pointers? Dubious.\n+        if ! self.inner.visit_vec(mtbl, inner) { ret false; }\n         true\n     }\n \n-    fn visit_enter_evec_box(mtbl: uint) -> bool {\n-        self.align_to::<@[u8]>();\n-        if ! self.inner.visit_enter_evec_box(mtbl) { ret false; }\n+    fn visit_vec(mtbl: uint, inner: *tydesc) -> bool {\n+        self.align_to::<[u8]>();\n+        if ! self.inner.visit_vec(mtbl, inner) { ret false; }\n+        self.bump_past::<[u8]>();\n         true\n     }\n \n-    fn visit_leave_evec_box(mtbl: uint) -> bool {\n-        if ! self.inner.visit_leave_evec_box(mtbl) { ret false; }\n-        self.bump_past::<@[u8]>();\n+    fn visit_evec_box(mtbl: uint, inner: *tydesc) -> bool {\n+        self.align_to::<[u8]/@>();\n+        if ! self.inner.visit_evec_box(mtbl, inner) { ret false; }\n+        self.bump_past::<[u8]/@>();\n         true\n     }\n \n-    fn visit_enter_evec_uniq(mtbl: uint) -> bool {\n-        self.align_to::<~[u8]>();\n-        if ! self.inner.visit_enter_evec_uniq(mtbl) { ret false; }\n+    fn visit_evec_uniq(mtbl: uint, inner: *tydesc) -> bool {\n+        self.align_to::<[u8]/~>();\n+        if ! self.inner.visit_evec_uniq(mtbl, inner) { ret false; }\n+        self.bump_past::<[u8]/~>();\n         true\n     }\n \n-    fn visit_leave_evec_uniq(mtbl: uint) -> bool {\n-        if ! self.inner.visit_leave_evec_uniq(mtbl) { ret false; }\n-        self.bump_past::<~[u8]>();\n+    fn visit_evec_slice(mtbl: uint, inner: *tydesc) -> bool {\n+        self.align_to::<[u8]/&static>();\n+        if ! self.inner.visit_evec_slice(mtbl, inner) { ret false; }\n+        self.bump_past::<[u8]/&static>();\n         true\n     }\n \n-    fn visit_enter_evec_slice(mtbl: uint) -> bool {\n-        self.align_to::<&[u8]static>();\n-        if ! self.inner.visit_enter_evec_slice(mtbl) { ret false; }\n-        true\n-    }\n-\n-    fn visit_leave_evec_slice(mtbl: uint) -> bool {\n-        if ! self.inner.visit_leave_evec_slice(mtbl) { ret false; }\n-        self.bump_past::<&[u8]static>();\n-        true\n-    }\n-\n-    fn visit_enter_evec_fixed(mtbl: uint, n: uint,\n-                              sz: uint, align: uint) -> bool {\n+    fn visit_evec_fixed(mtbl: uint, n: uint,\n+                        sz: uint, align: uint,\n+                        inner: *tydesc) -> bool {\n         self.align(align);\n-        if ! self.inner.visit_enter_evec_fixed(mtbl, n, sz, align) {\n-            ret false;\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_evec_fixed(mtbl: uint, n: uint,\n-                              sz: uint, align: uint) -> bool {\n-        if ! self.inner.visit_leave_evec_fixed(mtbl, n, sz, align) {\n+        if ! self.inner.visit_evec_fixed(mtbl, n, sz, align, inner) {\n             ret false;\n         }\n         self.bump(sz);\n@@ -321,21 +291,14 @@ impl ptr_visitor<V: ty_visitor movable_ptr>\n         true\n     }\n \n-    fn visit_enter_rec_field(mtbl: uint, i: uint,\n-                             name: str/&) -> bool {\n-        if ! self.inner.visit_enter_rec_field(mtbl, i, name) { ret false; }\n-        true\n-    }\n-\n-    fn visit_leave_rec_field(mtbl: uint, i: uint,\n-                             name: str/&) -> bool {\n-        if ! self.inner.visit_leave_rec_field(mtbl, i, name) { ret false; }\n+    fn visit_rec_field(i: uint, name: str/&,\n+                       mtbl: uint, inner: *tydesc) -> bool {\n+        if ! self.inner.visit_rec_field(i, name, mtbl, inner) { ret false; }\n         true\n     }\n \n     fn visit_leave_rec(n_fields: uint, sz: uint, align: uint) -> bool {\n         if ! self.inner.visit_leave_rec(n_fields, sz, align) { ret false; }\n-        self.bump(sz);\n         true\n     }\n \n@@ -347,17 +310,9 @@ impl ptr_visitor<V: ty_visitor movable_ptr>\n         true\n     }\n \n-    fn visit_enter_class_field(mtbl: uint, i: uint,\n-                               name: str/&) -> bool {\n-        if ! self.inner.visit_enter_class_field(mtbl, i, name) {\n-            ret false;\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_class_field(mtbl: uint, i: uint,\n-                               name: str/&) -> bool {\n-        if ! self.inner.visit_leave_class_field(mtbl, i, name) {\n+    fn visit_class_field(i: uint, name: str/&,\n+                         mtbl: uint, inner: *tydesc) -> bool {\n+        if ! self.inner.visit_class_field(i, name, mtbl, inner) {\n             ret false;\n         }\n         true\n@@ -367,7 +322,6 @@ impl ptr_visitor<V: ty_visitor movable_ptr>\n         if ! self.inner.visit_leave_class(n_fields, sz, align) {\n             ret false;\n         }\n-        self.bump(sz);\n         true\n     }\n \n@@ -377,47 +331,31 @@ impl ptr_visitor<V: ty_visitor movable_ptr>\n         true\n     }\n \n-    fn visit_enter_tup_field(i: uint) -> bool {\n-        if ! self.inner.visit_enter_tup_field(i) { ret false; }\n-        true\n-    }\n-\n-    fn visit_leave_tup_field(i: uint) -> bool {\n-        if ! self.inner.visit_leave_tup_field(i) { ret false; }\n+    fn visit_tup_field(i: uint, inner: *tydesc) -> bool {\n+        if ! self.inner.visit_tup_field(i, inner) { ret false; }\n         true\n     }\n \n     fn visit_leave_tup(n_fields: uint, sz: uint, align: uint) -> bool {\n         if ! self.inner.visit_leave_tup(n_fields, sz, align) { ret false; }\n-        self.bump(sz);\n         true\n     }\n \n     fn visit_enter_fn(purity: uint, proto: uint,\n                       n_inputs: uint, retstyle: uint) -> bool {\n         if ! self.inner.visit_enter_fn(purity, proto, n_inputs, retstyle) {\n-            ret false;\n+            ret false\n         }\n         true\n     }\n \n-    fn visit_enter_fn_input(i: uint, mode: uint) -> bool {\n-        if ! self.inner.visit_enter_fn_input(i, mode) { ret false; }\n+    fn visit_fn_input(i: uint, mode: uint, inner: *tydesc) -> bool {\n+        if ! self.inner.visit_fn_input(i, mode, inner) { ret false; }\n         true\n     }\n \n-    fn visit_leave_fn_input(i: uint, mode: uint) -> bool {\n-        if ! self.inner.visit_leave_fn_input(i, mode) { ret false; }\n-        true\n-    }\n-\n-    fn visit_enter_fn_output(retstyle: uint) -> bool {\n-        if ! self.inner.visit_enter_fn_output(retstyle) { ret false; }\n-        true\n-    }\n-\n-    fn visit_leave_fn_output(retstyle: uint) -> bool {\n-        if ! self.inner.visit_leave_fn_output(retstyle) { ret false; }\n+    fn visit_fn_output(retstyle: uint, inner: *tydesc) -> bool {\n+        if ! self.inner.visit_fn_output(retstyle, inner) { ret false; }\n         true\n     }\n \n@@ -446,13 +384,8 @@ impl ptr_visitor<V: ty_visitor movable_ptr>\n         true\n     }\n \n-    fn visit_enter_enum_variant_field(i: uint) -> bool {\n-        if ! self.inner.visit_enter_enum_variant_field(i) { ret false; }\n-        true\n-    }\n-\n-    fn visit_leave_enum_variant_field(i: uint) -> bool {\n-        if ! self.inner.visit_leave_enum_variant_field(i) { ret false; }\n+    fn visit_enum_variant_field(i: uint, inner: *tydesc) -> bool {\n+        if ! self.inner.visit_enum_variant_field(i, inner) { ret false; }\n         true\n     }\n \n@@ -469,29 +402,16 @@ impl ptr_visitor<V: ty_visitor movable_ptr>\n \n     fn visit_leave_enum(n_variants: uint, sz: uint, align: uint) -> bool {\n         if ! self.inner.visit_leave_enum(n_variants, sz, align) { ret false; }\n-        self.bump(sz);\n         true\n     }\n \n-    fn visit_iface() -> bool {\n+    fn visit_trait() -> bool {\n         self.align_to::<ty_visitor>();\n         if ! self.inner.visit_iface() { ret false; }\n         self.bump_past::<ty_visitor>();\n         true\n     }\n \n-    fn visit_enter_res() -> bool {\n-        // FIXME: I _think_ a resource takes no space,\n-        // but I might be wrong.\n-        if ! self.inner.visit_enter_res() { ret false; }\n-        true\n-    }\n-\n-    fn visit_leave_res() -> bool {\n-        if ! self.inner.visit_leave_res() { ret false; }\n-        true\n-    }\n-\n     fn visit_var() -> bool {\n         if ! self.inner.visit_var() { ret false; }\n         true\n@@ -526,13 +446,8 @@ impl ptr_visitor<V: ty_visitor movable_ptr>\n         true\n     }\n \n-    fn visit_enter_constr() -> bool {\n-        if ! self.inner.visit_enter_constr() { ret false; }\n-        true\n-    }\n-\n-    fn visit_leave_constr() -> bool {\n-        if ! self.inner.visit_leave_constr() { ret false; }\n+    fn visit_constr(inner: *tydesc) -> bool {\n+        if ! self.inner.visit_constr(inner) { ret false; }\n         true\n     }\n \n@@ -556,6 +471,13 @@ impl extra_methods for my_visitor {\n             f(*(self.ptr1 as *T));\n         }\n     }\n+\n+    fn visit_inner(inner: *tydesc) -> bool {\n+        let u = my_visitor(*self);\n+        let v = ptr_visit_adaptor({inner: u});\n+        visit_tydesc(inner, v as ty_visitor);\n+        true\n+    }\n }\n \n impl of movable_ptr for my_visitor {\n@@ -570,19 +492,15 @@ impl of ty_visitor for my_visitor {\n     fn visit_bot() -> bool { true }\n     fn visit_nil() -> bool { true }\n     fn visit_bool() -> bool {\n-/*\n         self.get::<bool>() {|b|\n             self.vals += ~[bool::to_str(b)];\n         }\n-*/\n         true\n     }\n     fn visit_int() -> bool {\n-/*\n         self.get::<int>() {|i|\n             self.vals += ~[int::to_str(i, 10u)];\n         }\n-*/\n         true\n     }\n     fn visit_i8() -> bool { true }\n@@ -608,104 +526,106 @@ impl of ty_visitor for my_visitor {\n     fn visit_estr_slice() -> bool { true }\n     fn visit_estr_fixed(_sz: uint) -> bool { true }\n \n-    fn visit_enter_box(_mtbl: uint) -> bool { true }\n-    fn visit_leave_box(_mtbl: uint) -> bool { true }\n-    fn visit_enter_uniq(_mtbl: uint) -> bool { true }\n-    fn visit_leave_uniq(_mtbl: uint) -> bool { true }\n-    fn visit_enter_ptr(_mtbl: uint) -> bool { true }\n-    fn visit_leave_ptr(_mtbl: uint) -> bool { true }\n-    fn visit_enter_rptr(_mtbl: uint) -> bool { true }\n-    fn visit_leave_rptr(_mtbl: uint) -> bool { true }\n-\n-    fn visit_enter_vec(_mtbl: uint) -> bool { true }\n-    fn visit_leave_vec(_mtbl: uint) -> bool { true }\n-    fn visit_enter_evec_box(_mtbl: uint) -> bool { true }\n-    fn visit_leave_evec_box(_mtbl: uint) -> bool { true }\n-    fn visit_enter_evec_uniq(_mtbl: uint) -> bool { true }\n-    fn visit_leave_evec_uniq(_mtbl: uint) -> bool { true }\n-    fn visit_enter_evec_slice(_mtbl: uint) -> bool { true }\n-    fn visit_leave_evec_slice(_mtbl: uint) -> bool { true }\n-    fn visit_enter_evec_fixed(_mtbl: uint, _n: uint,\n-                              _sz: uint, _align: uint) -> bool { true }\n-    fn visit_leave_evec_fixed(_mtbl: uint, _n: uint,\n-                              _sz: uint, _align: uint) -> bool { true }\n+    fn visit_box(_mtbl: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_uniq(_mtbl: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_ptr(_mtbl: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_rptr(_mtbl: uint, _inner: *tydesc) -> bool { true }\n+\n+    fn visit_vec(_mtbl: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_unboxed_vec(_mtbl: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_evec_box(_mtbl: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_evec_uniq(_mtbl: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_evec_slice(_mtbl: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_evec_fixed(_n: uint, _mtbl: uint,\n+                        _sz: uint, _align: uint,\n+                        _inner: *tydesc) -> bool { true }\n \n     fn visit_enter_rec(_n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n-    fn visit_enter_rec_field(_mtbl: uint, _i: uint,\n-                             _name: str/&) -> bool { true }\n-    fn visit_leave_rec_field(_mtbl: uint, _i: uint,\n-                             _name: str/&) -> bool { true }\n+    fn visit_rec_field(_i: uint, _name: str/&,\n+                       _mtbl: uint, inner: *tydesc) -> bool {\n+        #error(\"rec field!\");\n+        self.visit_inner(inner)\n+    }\n     fn visit_leave_rec(_n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n \n     fn visit_enter_class(_n_fields: uint,\n                          _sz: uint, _align: uint) -> bool { true }\n-    fn visit_enter_class_field(_mtbl: uint, _i: uint,\n-                               _name: str/&) -> bool { true }\n-    fn visit_leave_class_field(_mtbl: uint, _i: uint,\n-                               _name: str/&) -> bool { true }\n+    fn visit_class_field(_i: uint, _name: str/&,\n+                         _mtbl: uint, inner: *tydesc) -> bool {\n+        self.visit_inner(inner)\n+    }\n     fn visit_leave_class(_n_fields: uint,\n                          _sz: uint, _align: uint) -> bool { true }\n \n     fn visit_enter_tup(_n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n-    fn visit_enter_tup_field(_i: uint) -> bool { true }\n-    fn visit_leave_tup_field(_i: uint) -> bool { true }\n+    fn visit_tup_field(_i: uint, inner: *tydesc) -> bool {\n+        #error(\"tup field!\");\n+        self.visit_inner(inner)\n+    }\n     fn visit_leave_tup(_n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_enter_fn(_purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-    fn visit_enter_fn_input(_i: uint, _mode: uint) -> bool { true }\n-    fn visit_leave_fn_input(_i: uint, _mode: uint) -> bool { true }\n-    fn visit_enter_fn_output(_retstyle: uint) -> bool { true }\n-    fn visit_leave_fn_output(_retstyle: uint) -> bool { true }\n-    fn visit_leave_fn(_purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-\n     fn visit_enter_enum(_n_variants: uint,\n-                        _sz: uint, _align: uint) -> bool { true }\n+                        _sz: uint, _align: uint) -> bool {\n+        // FIXME: this needs to rewind between enum variants, or something.\n+        true\n+    }\n     fn visit_enter_enum_variant(_variant: uint,\n                                 _disr_val: int,\n                                 _n_fields: uint,\n                                 _name: str/&) -> bool { true }\n-    fn visit_enter_enum_variant_field(_i: uint) -> bool { true }\n-    fn visit_leave_enum_variant_field(_i: uint) -> bool { true }\n+    fn visit_enum_variant_field(_i: uint, inner: *tydesc) -> bool {\n+        self.visit_inner(inner)\n+    }\n     fn visit_leave_enum_variant(_variant: uint,\n                                 _disr_val: int,\n                                 _n_fields: uint,\n                                 _name: str/&) -> bool { true }\n     fn visit_leave_enum(_n_variants: uint,\n                         _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_iface() -> bool { true }\n-    fn visit_enter_res() -> bool { true }\n-    fn visit_leave_res() -> bool { true }\n+    fn visit_enter_fn(_purity: uint, _proto: uint,\n+                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n+    fn visit_fn_input(_i: uint, _mode: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_fn_output(_retstyle: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_leave_fn(_purity: uint, _proto: uint,\n+                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n+\n+\n+    fn visit_trait() -> bool { true }\n     fn visit_var() -> bool { true }\n     fn visit_var_integral() -> bool { true }\n     fn visit_param(_i: uint) -> bool { true }\n     fn visit_self() -> bool { true }\n     fn visit_type() -> bool { true }\n     fn visit_opaque_box() -> bool { true }\n-    fn visit_enter_constr() -> bool { true }\n-    fn visit_leave_constr() -> bool { true }\n+    fn visit_constr(_inner: *tydesc) -> bool { true }\n     fn visit_closure_ptr(_ck: uint) -> bool { true }\n }\n \n+fn get_tydesc_for<T>(&&_t: T) -> *tydesc {\n+    get_tydesc::<T>()\n+}\n \n fn main() {\n-    let r = (1,2,3,true,false);\n+    let r = (1,2,3,true,false,{x:5,y:4,z:3});\n     let p = ptr::addr_of(r) as *c_void;\n     let u = my_visitor(@{mut ptr1: p,\n                          mut ptr2: p,\n                          mut vals: ~[]});\n     let v = ptr_visit_adaptor({inner: u});\n-    let vv = v as intrinsic::ty_visitor;\n-    intrinsic::visit_ty::<(int,int,int,bool,bool)>(vv);\n+    let td = get_tydesc_for(r);\n+    unsafe { #error(\"tydesc sz: %u, align: %u\",\n+                    (*td).size, (*td).align); }\n+    let v = v as ty_visitor;\n+    visit_tydesc(td, v);\n \n     for (copy u.vals).each {|s|\n         io::println(#fmt(\"val: %s\", s));\n     }\n-    assert u.vals == [\"1\", \"2\", \"3\", \"true\", \"false\"];\n+    #error(\"%?\", copy u.vals);\n+    assert u.vals == [\"1\", \"2\", \"3\", \"true\", \"false\", \"5\", \"4\", \"3\"];\n  }"}, {"sha": "0ba4bf0730c279a56cebc88459aff365b518945a", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 61, "deletions": 67, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4a602a235c868a7f740ed09a8fc4c83c0c6dad/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=0a4a602a235c868a7f740ed09a8fc4c83c0c6dad", "patch": "@@ -1,9 +1,10 @@\n // FIXME: un-xfail after snapshot\n // xfail-test\n \n+import intrinsic::{tydesc, get_tydesc, visit_tydesc, ty_visitor};\n enum my_visitor = @{ mut types: ~[str] };\n \n-impl of intrinsic::ty_visitor for my_visitor {\n+impl of ty_visitor for my_visitor {\n     fn visit_bot() -> bool {\n         self.types += [\"bot\"];\n         #error(\"visited bot type\");\n@@ -55,98 +56,91 @@ impl of intrinsic::ty_visitor for my_visitor {\n     fn visit_estr_slice() -> bool { true }\n     fn visit_estr_fixed(_sz: uint) -> bool { true }\n \n-    fn visit_enter_box(_mtbl: uint) -> bool { true }\n-    fn visit_leave_box(_mtbl: uint) -> bool { true }\n-    fn visit_enter_uniq(_mtbl: uint) -> bool { true }\n-    fn visit_leave_uniq(_mtbl: uint) -> bool { true }\n-    fn visit_enter_ptr(_mtbl: uint) -> bool { true }\n-    fn visit_leave_ptr(_mtbl: uint) -> bool { true }\n-    fn visit_enter_rptr(_mtbl: uint) -> bool { true }\n-    fn visit_leave_rptr(_mtbl: uint) -> bool { true }\n+    fn visit_box(_mtbl: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_uniq(_mtbl: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_ptr(_mtbl: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_rptr(_mtbl: uint, _inner: *tydesc) -> bool { true }\n \n-    fn visit_enter_vec(_mtbl: uint) -> bool {\n+    fn visit_vec(_mtbl: uint, inner: *tydesc) -> bool {\n         self.types += [\"[\"];\n-        #error(\"visited enter-vec\");\n-        true\n-    }\n-    fn visit_leave_vec(_mtbl: uint) -> bool {\n+        visit_tydesc(inner, my_visitor(*self) as ty_visitor);\n         self.types += [\"]\"];\n-        #error(\"visited leave-vec\");\n         true\n     }\n-    fn visit_enter_evec_box(_mtbl: uint) -> bool { true }\n-    fn visit_leave_evec_box(_mtbl: uint) -> bool { true }\n-    fn visit_enter_evec_uniq(_mtbl: uint) -> bool { true }\n-    fn visit_leave_evec_uniq(_mtbl: uint) -> bool { true }\n-    fn visit_enter_evec_slice(_mtbl: uint) -> bool { true }\n-    fn visit_leave_evec_slice(_mtbl: uint) -> bool { true }\n-    fn visit_enter_evec_fixed(_mtbl: uint, _sz: uint) -> bool { true }\n-    fn visit_leave_evec_fixed(_mtbl: uint, _sz: uint) -> bool { true }\n-\n-    fn visit_enter_rec(_n_fields: uint) -> bool { true }\n-    fn visit_enter_rec_field(_mtbl: uint, _i: uint,\n-                             _name: str/&) -> bool { true }\n-    fn visit_leave_rec_field(_mtbl: uint, _i: uint,\n-                             _name: str/&) -> bool { true }\n-    fn visit_leave_rec(_n_fields: uint) -> bool { true }\n-\n-    fn visit_enter_class(_n_fields: uint) -> bool { true }\n-    fn visit_enter_class_field(_mtbl: uint, _i: uint,\n-                               _name: str/&) -> bool { true }\n-    fn visit_leave_class_field(_mtbl: uint, _i: uint,\n-                               _name: str/&) -> bool { true }\n-    fn visit_leave_class(_n_fields: uint) -> bool { true }\n-\n-    fn visit_enter_tup(_n_fields: uint) -> bool { true }\n-    fn visit_enter_tup_field(_i: uint) -> bool { true }\n-    fn visit_leave_tup_field(_i: uint) -> bool { true }\n-    fn visit_leave_tup(_n_fields: uint) -> bool { true }\n-\n-    fn visit_enter_fn(_purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-    fn visit_enter_fn_input(_i: uint, _mode: uint) -> bool { true }\n-    fn visit_leave_fn_input(_i: uint, _mode: uint) -> bool { true }\n-    fn visit_enter_fn_output(_retstyle: uint) -> bool { true }\n-    fn visit_leave_fn_output(_retstyle: uint) -> bool { true }\n-    fn visit_leave_fn(_purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-\n-    fn visit_enter_enum(_n_variants: uint) -> bool { true }\n+    fn visit_unboxed_vec(_mtbl: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_evec_box(_mtbl: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_evec_uniq(_mtbl: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_evec_slice(_mtbl: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_evec_fixed(_n: uint, _mtbl: uint,\n+                        _sz: uint, _align: uint,\n+                        _inner: *tydesc) -> bool { true }\n+\n+    fn visit_enter_rec(_n_fields: uint,\n+                       _sz: uint, _align: uint) -> bool { true }\n+    fn visit_rec_field(_i: uint, _name: str/&,\n+                       _mtbl: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_leave_rec(_n_fields: uint,\n+                       _sz: uint, _align: uint) -> bool { true }\n+\n+    fn visit_enter_class(_n_fields: uint,\n+                         _sz: uint, _align: uint) -> bool { true }\n+    fn visit_class_field(_i: uint, _name: str/&,\n+                         _mtbl: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_leave_class(_n_fields: uint,\n+                         _sz: uint, _align: uint) -> bool { true }\n+\n+    fn visit_enter_tup(_n_fields: uint,\n+                       _sz: uint, _align: uint) -> bool { true }\n+    fn visit_tup_field(_i: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_leave_tup(_n_fields: uint,\n+                       _sz: uint, _align: uint) -> bool { true }\n+\n+    fn visit_enter_enum(_n_variants: uint,\n+                        _sz: uint, _align: uint) -> bool { true }\n     fn visit_enter_enum_variant(_variant: uint,\n                                 _disr_val: int,\n                                 _n_fields: uint,\n                                 _name: str/&) -> bool { true }\n-    fn visit_enter_enum_variant_field(_i: uint) -> bool { true }\n-    fn visit_leave_enum_variant_field(_i: uint) -> bool { true }\n+    fn visit_enum_variant_field(_i: uint, _inner: *tydesc) -> bool { true }\n     fn visit_leave_enum_variant(_variant: uint,\n                                 _disr_val: int,\n                                 _n_fields: uint,\n                                 _name: str/&) -> bool { true }\n-    fn visit_leave_enum(_n_variants: uint) -> bool { true }\n+    fn visit_leave_enum(_n_variants: uint,\n+                        _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_iface() -> bool { true }\n-    fn visit_enter_res() -> bool { true }\n-    fn visit_leave_res() -> bool { true }\n+    fn visit_enter_fn(_purity: uint, _proto: uint,\n+                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n+    fn visit_fn_input(_i: uint, _mode: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_fn_output(_retstyle: uint, _inner: *tydesc) -> bool { true }\n+    fn visit_leave_fn(_purity: uint, _proto: uint,\n+                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n+\n+\n+    fn visit_trait() -> bool { true }\n     fn visit_var() -> bool { true }\n     fn visit_var_integral() -> bool { true }\n     fn visit_param(_i: uint) -> bool { true }\n     fn visit_self() -> bool { true }\n     fn visit_type() -> bool { true }\n     fn visit_opaque_box() -> bool { true }\n-    fn visit_enter_constr() -> bool { true }\n-    fn visit_leave_constr() -> bool { true }\n+    fn visit_constr(_inner: *tydesc) -> bool { true }\n     fn visit_closure_ptr(_ck: uint) -> bool { true }\n }\n \n+fn visit_ty<T>(v: ty_visitor) {\n+    visit_tydesc(get_tydesc::<T>(), v);\n+}\n+\n fn main() {\n     let v = my_visitor(@{mut types: ~[]});\n-    let vv = v as intrinsic::ty_visitor;\n+    let vv = v as ty_visitor;\n \n-    intrinsic::visit_ty::<bool>(vv);\n-    intrinsic::visit_ty::<int>(vv);\n-    intrinsic::visit_ty::<i8>(vv);\n-    intrinsic::visit_ty::<i16>(vv);\n-    intrinsic::visit_ty::<~[int]>(vv);\n+    visit_ty::<bool>(vv);\n+    visit_ty::<int>(vv);\n+    visit_ty::<i8>(vv);\n+    visit_ty::<i16>(vv);\n+    visit_ty::<~[int]>(vv);\n \n     for (copy v.types).each {|s|\n         io::println(#fmt(\"type: %s\", s));"}]}