{"sha": "2f0dd63bbe83938b9eda5b6076543d420bae2f2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMGRkNjNiYmU4MzkzOGI5ZWRhNWI2MDc2NTQzZDQyMGJhZTJmMmI=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2017-03-22T16:36:43Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2017-03-22T16:43:01Z"}, "message": "Checked (and unchecked) slicing for strings?\n\nWhat is this magic\u203d", "tree": {"sha": "ce388c50e55d43df1aeb1e4198145367814d11c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce388c50e55d43df1aeb1e4198145367814d11c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f0dd63bbe83938b9eda5b6076543d420bae2f2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f0dd63bbe83938b9eda5b6076543d420bae2f2b", "html_url": "https://github.com/rust-lang/rust/commit/2f0dd63bbe83938b9eda5b6076543d420bae2f2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f0dd63bbe83938b9eda5b6076543d420bae2f2b/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c4f2c64c6759a82f143e23964a46a65c67509c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c4f2c64c6759a82f143e23964a46a65c67509c9", "html_url": "https://github.com/rust-lang/rust/commit/8c4f2c64c6759a82f143e23964a46a65c67509c9"}], "stats": {"total": 497, "additions": 441, "deletions": 56}, "files": [{"sha": "00448b6abb2cf3937ab36f2c8416bea36f1e31ca", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f0dd63bbe83938b9eda5b6076543d420bae2f2b/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0dd63bbe83938b9eda5b6076543d420bae2f2b/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=2f0dd63bbe83938b9eda5b6076543d420bae2f2b", "patch": "@@ -60,6 +60,7 @@\n #![feature(unicode)]\n #![feature(unique)]\n #![feature(untagged_unions)]\n+#![cfg_attr(not(test), feature(str_checked_slicing))]\n #![cfg_attr(test, feature(rand, test))]\n \n #![no_std]"}, {"sha": "424e175996ec86fd003b53cb722d8578bceaaf17", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f0dd63bbe83938b9eda5b6076543d420bae2f2b/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0dd63bbe83938b9eda5b6076543d420bae2f2b/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=2f0dd63bbe83938b9eda5b6076543d420bae2f2b", "patch": "@@ -362,7 +362,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn get<I>(&self, index: I) -> Option<&I::Output>\n-        where I: SliceIndex<T>\n+        where I: SliceIndex<Self>\n     {\n         core_slice::SliceExt::get(self, index)\n     }\n@@ -385,7 +385,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n-        where I: SliceIndex<T>\n+        where I: SliceIndex<Self>\n     {\n         core_slice::SliceExt::get_mut(self, index)\n     }\n@@ -405,7 +405,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n-        where I: SliceIndex<T>\n+        where I: SliceIndex<Self>\n     {\n         core_slice::SliceExt::get_unchecked(self, index)\n     }\n@@ -427,7 +427,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n-        where I: SliceIndex<T>\n+        where I: SliceIndex<Self>\n     {\n         core_slice::SliceExt::get_unchecked_mut(self, index)\n     }"}, {"sha": "84b73090817d25182f9335cccb3544f403d54f95", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 109, "deletions": 1, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/2f0dd63bbe83938b9eda5b6076543d420bae2f2b/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0dd63bbe83938b9eda5b6076543d420bae2f2b/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=2f0dd63bbe83938b9eda5b6076543d420bae2f2b", "patch": "@@ -32,7 +32,7 @@ use borrow::{Borrow, ToOwned};\n use string::String;\n use std_unicode;\n use vec::Vec;\n-use slice::SliceConcatExt;\n+use slice::{SliceConcatExt, SliceIndex};\n use boxed::Box;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -291,6 +291,114 @@ impl str {\n         core_str::StrExt::as_ptr(self)\n     }\n \n+    /// Returns a subslice of `str`.\n+    ///\n+    /// This is the non-panicking alternative to indexing the `str`. Returns `None` whenever\n+    /// equivalent indexing operation would panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(str_checked_slicing)]\n+    /// let v = \"\ud83d\uddfb\u2208\ud83c\udf0f\";\n+    /// assert_eq!(Some(\"\ud83d\uddfb\"), v.get(0..4));\n+    /// assert!(v.get(1..).is_none());\n+    /// assert!(v.get(..8).is_none());\n+    /// assert!(v.get(..42).is_none());\n+    /// ```\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"0\")]\n+    #[inline]\n+    pub fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n+        core_str::StrExt::get(self, i)\n+    }\n+\n+    /// Returns a mutable subslice of `str`.\n+    ///\n+    /// This is the non-panicking alternative to indexing the `str`. Returns `None` whenever\n+    /// equivalent indexing operation would panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(str_checked_slicing)]\n+    /// let mut v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n+    /// assert_eq!(Some(\"\ud83d\uddfb\"), v.get_mut(0..4).map(|v| &*v));\n+    /// assert!(v.get_mut(1..).is_none());\n+    /// assert!(v.get_mut(..8).is_none());\n+    /// assert!(v.get_mut(..42).is_none());\n+    /// ```\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"0\")]\n+    #[inline]\n+    pub fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n+        core_str::StrExt::get_mut(self, i)\n+    }\n+\n+    /// Returns a unchecked subslice of `str`.\n+    ///\n+    /// This is the unchecked alternative to indexing the `str`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that these preconditions are\n+    /// satisfied:\n+    ///\n+    /// * The starting index must come before the ending index;\n+    /// * Indexes must be within bounds of the original slice;\n+    /// * Indexes must lie on UTF-8 sequence boundaries.\n+    ///\n+    /// Failing that, the returned string slice may reference invalid memory or\n+    /// violate the invariants communicated by the `str` type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(str_checked_slicing)]\n+    /// let v = \"\ud83d\uddfb\u2208\ud83c\udf0f\";\n+    /// unsafe {\n+    ///     assert_eq!(\"\ud83d\uddfb\", v.get_unchecked(0..4));\n+    ///     assert_eq!(\"\u2208\", v.get_unchecked(4..7));\n+    ///     assert_eq!(\"\ud83c\udf0f\", v.get_unchecked(7..11));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"0\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n+        core_str::StrExt::get_unchecked(self, i)\n+    }\n+\n+    /// Returns a mutable, unchecked subslice of `str`.\n+    ///\n+    /// This is the unchecked alternative to indexing the `str`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that these preconditions are\n+    /// satisfied:\n+    ///\n+    /// * The starting index must come before the ending index;\n+    /// * Indexes must be within bounds of the original slice;\n+    /// * Indexes must lie on UTF-8 sequence boundaries.\n+    ///\n+    /// Failing that, the returned string slice may reference invalid memory or\n+    /// violate the invariants communicated by the `str` type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(str_checked_slicing)]\n+    /// let mut v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n+    /// unsafe {\n+    ///     assert_eq!(\"\ud83d\uddfb\", v.get_unchecked_mut(0..4));\n+    ///     assert_eq!(\"\u2208\", v.get_unchecked_mut(4..7));\n+    ///     assert_eq!(\"\ud83c\udf0f\", v.get_unchecked_mut(7..11));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"0\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n+        core_str::StrExt::get_unchecked_mut(self, i)\n+    }\n+\n     /// Creates a string slice from another string slice, bypassing safety\n     /// checks.\n     ///"}, {"sha": "4e56fa80cd9ca8e6d67d5709ccb9df31e559bf9a", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2f0dd63bbe83938b9eda5b6076543d420bae2f2b/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0dd63bbe83938b9eda5b6076543d420bae2f2b/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=2f0dd63bbe83938b9eda5b6076543d420bae2f2b", "patch": "@@ -97,8 +97,7 @@ pub trait SliceExt {\n \n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn get<I>(&self, index: I) -> Option<&I::Output>\n-        where I: SliceIndex<Self::Item>;\n-\n+        where I: SliceIndex<Self>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn first(&self) -> Option<&Self::Item>;\n \n@@ -113,8 +112,7 @@ pub trait SliceExt {\n \n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n-        where I: SliceIndex<Self::Item>;\n-\n+        where I: SliceIndex<Self>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn as_ptr(&self) -> *const Self::Item;\n \n@@ -141,8 +139,7 @@ pub trait SliceExt {\n \n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n-        where I: SliceIndex<Self::Item>;\n-\n+        where I: SliceIndex<Self>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn iter_mut(&mut self) -> IterMut<Self::Item>;\n \n@@ -184,8 +181,7 @@ pub trait SliceExt {\n \n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n-        where I: SliceIndex<Self::Item>;\n-\n+        where I: SliceIndex<Self>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn as_mut_ptr(&mut self) -> *mut Self::Item;\n \n@@ -337,7 +333,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn get<I>(&self, index: I) -> Option<&I::Output>\n-        where I: SliceIndex<T>\n+        where I: SliceIndex<[T]>\n     {\n         index.get(self)\n     }\n@@ -365,7 +361,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n-        where I: SliceIndex<T>\n+        where I: SliceIndex<[T]>\n     {\n         index.get_unchecked(self)\n     }\n@@ -406,7 +402,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n-        where I: SliceIndex<T>\n+        where I: SliceIndex<[T]>\n     {\n         index.get_mut(self)\n     }\n@@ -538,7 +534,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n-        where I: SliceIndex<T>\n+        where I: SliceIndex<[T]>\n     {\n         index.get_unchecked_mut(self)\n     }\n@@ -631,7 +627,7 @@ impl<T> SliceExt for [T] {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n impl<T, I> ops::Index<I> for [T]\n-    where I: SliceIndex<T>\n+    where I: SliceIndex<[T]>\n {\n     type Output = I::Output;\n \n@@ -644,7 +640,7 @@ impl<T, I> ops::Index<I> for [T]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n impl<T, I> ops::IndexMut<I> for [T]\n-    where I: SliceIndex<T>\n+    where I: SliceIndex<[T]>\n {\n     #[inline]\n     fn index_mut(&mut self, index: I) -> &mut I::Output {\n@@ -667,37 +663,37 @@ fn slice_index_order_fail(index: usize, end: usize) -> ! {\n /// A helper trait used for indexing operations.\n #[unstable(feature = \"slice_get_slice\", issue = \"35729\")]\n #[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n-pub trait SliceIndex<T> {\n+pub trait SliceIndex<T: ?Sized> {\n     /// The output type returned by methods.\n     type Output: ?Sized;\n \n     /// Returns a shared reference to the output at this location, if in\n     /// bounds.\n-    fn get(self, slice: &[T]) -> Option<&Self::Output>;\n+    fn get(self, slice: &T) -> Option<&Self::Output>;\n \n     /// Returns a mutable reference to the output at this location, if in\n     /// bounds.\n-    fn get_mut(self, slice: &mut [T]) -> Option<&mut Self::Output>;\n+    fn get_mut(self, slice: &mut T) -> Option<&mut Self::Output>;\n \n     /// Returns a shared reference to the output at this location, without\n     /// performing any bounds checking.\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &Self::Output;\n+    unsafe fn get_unchecked(self, slice: &T) -> &Self::Output;\n \n     /// Returns a mutable reference to the output at this location, without\n     /// performing any bounds checking.\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut Self::Output;\n+    unsafe fn get_unchecked_mut(self, slice: &mut T) -> &mut Self::Output;\n \n     /// Returns a shared reference to the output at this location, panicking\n     /// if out of bounds.\n-    fn index(self, slice: &[T]) -> &Self::Output;\n+    fn index(self, slice: &T) -> &Self::Output;\n \n     /// Returns a mutable reference to the output at this location, panicking\n     /// if out of bounds.\n-    fn index_mut(self, slice: &mut [T]) -> &mut Self::Output;\n+    fn index_mut(self, slice: &mut T) -> &mut Self::Output;\n }\n \n #[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<T> for usize {\n+impl<T> SliceIndex<[T]> for usize {\n     type Output = T;\n \n     #[inline]\n@@ -746,7 +742,7 @@ impl<T> SliceIndex<T> for usize {\n }\n \n #[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<T> for  ops::Range<usize> {\n+impl<T> SliceIndex<[T]> for  ops::Range<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -807,7 +803,7 @@ impl<T> SliceIndex<T> for  ops::Range<usize> {\n }\n \n #[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<T> for ops::RangeTo<usize> {\n+impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -842,7 +838,7 @@ impl<T> SliceIndex<T> for ops::RangeTo<usize> {\n }\n \n #[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<T> for ops::RangeFrom<usize> {\n+impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -877,7 +873,7 @@ impl<T> SliceIndex<T> for ops::RangeFrom<usize> {\n }\n \n #[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<T> for ops::RangeFull {\n+impl<T> SliceIndex<[T]> for ops::RangeFull {\n     type Output = [T];\n \n     #[inline]\n@@ -913,7 +909,7 @@ impl<T> SliceIndex<T> for ops::RangeFull {\n \n \n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-impl<T> SliceIndex<T> for ops::RangeInclusive<usize> {\n+impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -976,7 +972,7 @@ impl<T> SliceIndex<T> for ops::RangeInclusive<usize> {\n }\n \n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-impl<T> SliceIndex<T> for ops::RangeToInclusive<usize> {\n+impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n     type Output = [T];\n \n     #[inline]"}, {"sha": "aecfaa7ee023bac317796964bde82bae7fe1bd0f", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 303, "deletions": 23, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/2f0dd63bbe83938b9eda5b6076543d420bae2f2b/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0dd63bbe83938b9eda5b6076543d420bae2f2b/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=2f0dd63bbe83938b9eda5b6076543d420bae2f2b", "patch": "@@ -22,7 +22,7 @@ use convert::TryFrom;\n use fmt;\n use iter::{Map, Cloned, FusedIterator};\n use mem;\n-use slice;\n+use slice::{self, SliceIndex};\n \n pub mod pattern;\n \n@@ -1408,6 +1408,8 @@ Section: Trait implementations\n mod traits {\n     use cmp::Ordering;\n     use ops;\n+    use mem;\n+    use slice::{self, SliceIndex};\n     use str::eq_slice;\n \n     /// Implements ordering of strings.\n@@ -1490,14 +1492,7 @@ mod traits {\n         type Output = str;\n         #[inline]\n         fn index(&self, index: ops::Range<usize>) -> &str {\n-            // is_char_boundary checks that the index is in [0, .len()]\n-            if index.start <= index.end &&\n-               self.is_char_boundary(index.start) &&\n-               self.is_char_boundary(index.end) {\n-                unsafe { self.slice_unchecked(index.start, index.end) }\n-            } else {\n-                super::slice_error_fail(self, index.start, index.end)\n-            }\n+            index.index(self)\n         }\n     }\n \n@@ -1519,14 +1514,7 @@ mod traits {\n     impl ops::IndexMut<ops::Range<usize>> for str {\n         #[inline]\n         fn index_mut(&mut self, index: ops::Range<usize>) -> &mut str {\n-            // is_char_boundary checks that the index is in [0, .len()]\n-            if index.start <= index.end &&\n-               self.is_char_boundary(index.start) &&\n-               self.is_char_boundary(index.end) {\n-                unsafe { self.slice_mut_unchecked(index.start, index.end) }\n-            } else {\n-                super::slice_error_fail(self, index.start, index.end)\n-            }\n+            index.index_mut(self)\n         }\n     }\n \n@@ -1694,8 +1682,276 @@ mod traits {\n             self.index_mut(0...index.end)\n         }\n     }\n+\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"0\")]\n+    impl SliceIndex<str> for ops::RangeFull {\n+        type Output = str;\n+        #[inline]\n+        fn get(self, slice: &str) -> Option<&Self::Output> {\n+            Some(slice)\n+        }\n+        #[inline]\n+        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+            Some(slice)\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+            slice\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+            slice\n+        }\n+        #[inline]\n+        fn index(self, slice: &str) -> &Self::Output {\n+            slice\n+        }\n+        #[inline]\n+        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+            slice\n+        }\n+    }\n+\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"0\")]\n+    impl SliceIndex<str> for ops::Range<usize> {\n+        type Output = str;\n+        #[inline]\n+        fn get(self, slice: &str) -> Option<&Self::Output> {\n+            if self.start <= self.end &&\n+               slice.is_char_boundary(self.start) &&\n+               slice.is_char_boundary(self.end) {\n+                Some(unsafe { self.get_unchecked(slice) })\n+            } else {\n+                None\n+            }\n+        }\n+        #[inline]\n+        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+            if self.start <= self.end &&\n+               slice.is_char_boundary(self.start) &&\n+               slice.is_char_boundary(self.end) {\n+                Some(unsafe { self.get_unchecked_mut(slice) })\n+            } else {\n+                None\n+            }\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+            let ptr = slice.as_ptr().offset(self.start as isize);\n+            let len = self.end - self.start;\n+            super::from_utf8_unchecked(slice::from_raw_parts(ptr, len))\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+            let ptr = slice.as_ptr().offset(self.start as isize);\n+            let len = self.end - self.start;\n+            mem::transmute(slice::from_raw_parts_mut(ptr as *mut u8, len))\n+        }\n+        #[inline]\n+        fn index(self, slice: &str) -> &Self::Output {\n+            let (start, end) = (self.start, self.end);\n+            self.get(slice).unwrap_or_else(|| super::slice_error_fail(slice, start, end))\n+        }\n+        #[inline]\n+        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            // canot reuse `get` as above, because of NLL trouble\n+            if self.start <= self.end &&\n+               slice.is_char_boundary(self.start) &&\n+               slice.is_char_boundary(self.end) {\n+                unsafe { self.get_unchecked_mut(slice) }\n+            } else {\n+                super::slice_error_fail(slice, self.start, self.end)\n+            }\n+        }\n+    }\n+\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"0\")]\n+    impl SliceIndex<str> for ops::RangeTo<usize> {\n+        type Output = str;\n+        #[inline]\n+        fn get(self, slice: &str) -> Option<&Self::Output> {\n+            if slice.is_char_boundary(self.end) {\n+                Some(unsafe { self.get_unchecked(slice) })\n+            } else {\n+                None\n+            }\n+        }\n+        #[inline]\n+        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+            if slice.is_char_boundary(self.end) {\n+                Some(unsafe { self.get_unchecked_mut(slice) })\n+            } else {\n+                None\n+            }\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+            let ptr = slice.as_ptr();\n+            super::from_utf8_unchecked(slice::from_raw_parts(ptr, self.end))\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+            let ptr = slice.as_ptr();\n+            mem::transmute(slice::from_raw_parts_mut(ptr as *mut u8, self.end))\n+        }\n+        #[inline]\n+        fn index(self, slice: &str) -> &Self::Output {\n+            let end = self.end;\n+            self.get(slice).unwrap_or_else(|| super::slice_error_fail(slice, 0, end))\n+        }\n+        #[inline]\n+        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+            if slice.is_char_boundary(self.end) {\n+                unsafe { self.get_unchecked_mut(slice) }\n+            } else {\n+                super::slice_error_fail(slice, 0, self.end)\n+            }\n+        }\n+    }\n+\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"0\")]\n+    impl SliceIndex<str> for ops::RangeFrom<usize> {\n+        type Output = str;\n+        #[inline]\n+        fn get(self, slice: &str) -> Option<&Self::Output> {\n+            if slice.is_char_boundary(self.start) {\n+                Some(unsafe { self.get_unchecked(slice) })\n+            } else {\n+                None\n+            }\n+        }\n+        #[inline]\n+        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+            if slice.is_char_boundary(self.start) {\n+                Some(unsafe { self.get_unchecked_mut(slice) })\n+            } else {\n+                None\n+            }\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+            let ptr = slice.as_ptr().offset(self.start as isize);\n+            let len = slice.len() - self.start;\n+            super::from_utf8_unchecked(slice::from_raw_parts(ptr, len))\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+            let ptr = slice.as_ptr().offset(self.start as isize);\n+            let len = slice.len() - self.start;\n+            mem::transmute(slice::from_raw_parts_mut(ptr as *mut u8, len))\n+        }\n+        #[inline]\n+        fn index(self, slice: &str) -> &Self::Output {\n+            let (start, end) = (self.start, slice.len());\n+            self.get(slice).unwrap_or_else(|| super::slice_error_fail(slice, start, end))\n+        }\n+        #[inline]\n+        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+            if slice.is_char_boundary(self.start) {\n+                unsafe { self.get_unchecked_mut(slice) }\n+            } else {\n+                super::slice_error_fail(slice, self.start, slice.len())\n+            }\n+        }\n+    }\n+\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"0\")]\n+    impl SliceIndex<str> for ops::RangeInclusive<usize> {\n+        type Output = str;\n+        #[inline]\n+        fn get(self, slice: &str) -> Option<&Self::Output> {\n+            match self {\n+                ops::RangeInclusive::Empty { .. } => 0..0,\n+                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n+            }.get(slice)\n+        }\n+        #[inline]\n+        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+            match self {\n+                ops::RangeInclusive::Empty { .. } => 0..0,\n+                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n+            }.get_mut(slice)\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+            match self {\n+                ops::RangeInclusive::Empty { .. } => 0..0,\n+                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n+            }.get_unchecked(slice)\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+            match self {\n+                ops::RangeInclusive::Empty { .. } => 0..0,\n+                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n+            }.get_unchecked_mut(slice)\n+        }\n+        #[inline]\n+        fn index(self, slice: &str) -> &Self::Output {\n+            match self {\n+                ops::RangeInclusive::Empty { .. } => 0..0,\n+                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n+            }.index(slice)\n+        }\n+        #[inline]\n+        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+            match self {\n+                ops::RangeInclusive::Empty { .. } => 0..0,\n+                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n+            }.index_mut(slice)\n+        }\n+    }\n+\n+\n+\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"0\")]\n+    impl SliceIndex<str> for ops::RangeToInclusive<usize> {\n+        type Output = str;\n+        #[inline]\n+        fn get(self, slice: &str) -> Option<&Self::Output> {\n+            if slice.is_char_boundary(self.end + 1) {\n+                Some(unsafe { self.get_unchecked(slice) })\n+            } else {\n+                None\n+            }\n+        }\n+        #[inline]\n+        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+            if slice.is_char_boundary(self.end + 1) {\n+                Some(unsafe { self.get_unchecked_mut(slice) })\n+            } else {\n+                None\n+            }\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+            let ptr = slice.as_ptr();\n+            super::from_utf8_unchecked(slice::from_raw_parts(ptr, self.end + 1))\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+            let ptr = slice.as_ptr();\n+            mem::transmute(slice::from_raw_parts_mut(ptr as *mut u8, self.end + 1))\n+        }\n+        #[inline]\n+        fn index(self, slice: &str) -> &Self::Output {\n+            let end = self.end + 1;\n+            self.get(slice).unwrap_or_else(|| super::slice_error_fail(slice, 0, end))\n+        }\n+        #[inline]\n+        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+            if slice.is_char_boundary(self.end) {\n+                unsafe { self.get_unchecked_mut(slice) }\n+            } else {\n+                super::slice_error_fail(slice, 0, self.end + 1)\n+            }\n+        }\n+    }\n+\n }\n \n+\n /// Methods for string slices\n #[allow(missing_docs)]\n #[doc(hidden)]\n@@ -1745,6 +2001,14 @@ pub trait StrExt {\n     #[rustc_deprecated(since = \"1.6.0\", reason = \"use lines() instead now\")]\n     #[allow(deprecated)]\n     fn lines_any(&self) -> LinesAny;\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"0\")]\n+    fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output>;\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"0\")]\n+    fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output>;\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"0\")]\n+    unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output;\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"0\")]\n+    unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -1934,18 +2198,34 @@ impl StrExt for str {\n         LinesAny(self.lines())\n     }\n \n+    #[inline]\n+    fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n+        i.get(self)\n+    }\n+\n+    #[inline]\n+    fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n+        i.get_mut(self)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n+        i.get_unchecked(self)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n+        i.get_unchecked_mut(self)\n+    }\n+\n     #[inline]\n     unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n-        let ptr = self.as_ptr().offset(begin as isize);\n-        let len = end - begin;\n-        from_utf8_unchecked(slice::from_raw_parts(ptr, len))\n+        (begin..end).get_unchecked(self)\n     }\n \n     #[inline]\n     unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n-        let ptr = self.as_ptr().offset(begin as isize);\n-        let len = end - begin;\n-        mem::transmute(slice::from_raw_parts_mut(ptr as *mut u8, len))\n+        (begin..end).get_unchecked_mut(self)\n     }\n \n     #[inline]"}]}