{"sha": "1082a292eafef01a24376b82be4dc875e595691e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwODJhMjkyZWFmZWYwMWEyNDM3NmI4MmJlNGRjODc1ZTU5NTY5MWU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-02-24T04:56:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-02-24T04:56:01Z"}, "message": "Rollup merge of #58511 - oli-obk:const_to_op, r=RalfJung\n\nConst to op simplification\n\nr? @RalfJung\n\nalternative to https://github.com/rust-lang/rust/pull/58486", "tree": {"sha": "ea3bd28ec33ac99a8eef9a88489ae589d56e149e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea3bd28ec33ac99a8eef9a88489ae589d56e149e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1082a292eafef01a24376b82be4dc875e595691e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcciPhCRBK7hj4Ov3rIwAAdHIIAALzpUdVmEF7Go5sjlZXDx8K\npuy/xUGK0HyWRU7vEedEpziZvpA3dAdX7eKIle5fAEb2r5IjpnFsPK54li9kE4UQ\nDWvaWpv8i93NXq4Tx5MxQd8TePJzXIft1wKMnCNAkcxbIworr3ypWP35cSaoa2x+\nGG7zGNOtjswPuaCNCX34AxapZHWTIhkfjG4Jls1R0gidw0jU2qVg9vDuyuQFGGWB\n3doaUYNtiRkMvtFCbFknJjnKPVFTWnbbpk47ru567WfJOBIzPTr+q+RK33znEgjj\nvNRNQisG49CRw4+Rs9tMjJ63D4qgIfTl8WVUZcdn61pn4zaqNDLUVVk39XS5kXI=\n=BTVJ\n-----END PGP SIGNATURE-----\n", "payload": "tree ea3bd28ec33ac99a8eef9a88489ae589d56e149e\nparent 4dcb7af0e71ea7c6790f225371a055ef707cf0cb\nparent 1fe7eb00944c3c41059e16daa7b401bc8b04447c\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1550984161 +0100\ncommitter GitHub <noreply@github.com> 1550984161 +0100\n\nRollup merge of #58511 - oli-obk:const_to_op, r=RalfJung\n\nConst to op simplification\n\nr? @RalfJung\n\nalternative to https://github.com/rust-lang/rust/pull/58486\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1082a292eafef01a24376b82be4dc875e595691e", "html_url": "https://github.com/rust-lang/rust/commit/1082a292eafef01a24376b82be4dc875e595691e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1082a292eafef01a24376b82be4dc875e595691e/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4dcb7af0e71ea7c6790f225371a055ef707cf0cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4dcb7af0e71ea7c6790f225371a055ef707cf0cb", "html_url": "https://github.com/rust-lang/rust/commit/4dcb7af0e71ea7c6790f225371a055ef707cf0cb"}, {"sha": "1fe7eb00944c3c41059e16daa7b401bc8b04447c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fe7eb00944c3c41059e16daa7b401bc8b04447c", "html_url": "https://github.com/rust-lang/rust/commit/1fe7eb00944c3c41059e16daa7b401bc8b04447c"}], "stats": {"total": 243, "additions": 117, "deletions": 126}, "files": [{"sha": "cce1273b7f025d0743b29c355061f141e7752960", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=1082a292eafef01a24376b82be4dc875e595691e", "patch": "@@ -312,7 +312,7 @@ impl_stable_hash_for!(\n     impl<'tcx> for enum mir::interpret::ConstValue<'tcx> [ mir::interpret::ConstValue ] {\n         Scalar(val),\n         Slice(a, b),\n-        ByRef(id, alloc, offset),\n+        ByRef(ptr, alloc),\n     }\n );\n impl_stable_hash_for!(struct crate::mir::interpret::RawConst<'tcx> {"}, {"sha": "956182fc8b275bd680e06f2ac85287deb3cc61ef", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=1082a292eafef01a24376b82be4dc875e595691e", "patch": "@@ -31,9 +31,9 @@ pub enum ConstValue<'tcx> {\n     /// it.\n     Slice(Scalar, u64),\n \n-    /// An allocation together with an offset into the allocation.\n-    /// Invariant: the `AllocId` matches the allocation.\n-    ByRef(AllocId, &'tcx Allocation, Size),\n+    /// An allocation together with a pointer into the allocation.\n+    /// Invariant: the pointer's `AllocId` resolves to the allocation.\n+    ByRef(Pointer, &'tcx Allocation),\n }\n \n #[cfg(target_arch = \"x86_64\")]"}, {"sha": "a81d5c9d86edd1ae17bbe81fcdf52a26a1dfc25e", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=1082a292eafef01a24376b82be4dc875e595691e", "patch": "@@ -505,8 +505,8 @@ impl<'a, 'tcx> Lift<'tcx> for ConstValue<'a> {\n         match *self {\n             ConstValue::Scalar(x) => Some(ConstValue::Scalar(x)),\n             ConstValue::Slice(x, y) => Some(ConstValue::Slice(x, y)),\n-            ConstValue::ByRef(x, alloc, z) => Some(ConstValue::ByRef(\n-                x, alloc.lift_to_tcx(tcx)?, z,\n+            ConstValue::ByRef(ptr, alloc) => Some(ConstValue::ByRef(\n+                ptr, alloc.lift_to_tcx(tcx)?,\n             )),\n         }\n     }"}, {"sha": "4c88d4f0e63ca0aefd03303ec2184999ce3e474c", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=1082a292eafef01a24376b82be4dc875e595691e", "patch": "@@ -71,7 +71,7 @@ pub fn codegen_static_initializer(\n     let static_ = cx.tcx.const_eval(param_env.and(cid))?;\n \n     let alloc = match static_.val {\n-        ConstValue::ByRef(_, alloc, n) if n.bytes() == 0 => alloc,\n+        ConstValue::ByRef(ptr, alloc) if ptr.offset.bytes() == 0 => alloc,\n         _ => bug!(\"static const eval returned {:#?}\", static_),\n     };\n     Ok((const_alloc_to_llvm(cx, alloc), alloc))"}, {"sha": "3cac1befaf4ef13b83cf918d2ec3a2ad69ed617f", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=1082a292eafef01a24376b82be4dc875e595691e", "patch": "@@ -101,8 +101,8 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n                 let b_llval = bx.cx().const_usize(b);\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n-            ConstValue::ByRef(_, alloc, offset) => {\n-                return Ok(bx.load_operand(bx.cx().from_const_alloc(layout, alloc, offset)));\n+            ConstValue::ByRef(ptr, alloc) => {\n+                return Ok(bx.load_operand(bx.cx().from_const_alloc(layout, alloc, ptr.offset)));\n             },\n         };\n "}, {"sha": "1edcbfead2c94424ca509af15fb458825214bd5d", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=1082a292eafef01a24376b82be4dc875e595691e", "patch": "@@ -417,8 +417,8 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n                 match bx.tcx().const_eval(param_env.and(cid)) {\n                     Ok(val) => match val.val {\n-                        mir::interpret::ConstValue::ByRef(_, alloc, offset) => {\n-                            bx.cx().from_const_alloc(layout, alloc, offset)\n+                        mir::interpret::ConstValue::ByRef(ptr, alloc) => {\n+                            bx.cx().from_const_alloc(layout, alloc, ptr.offset)\n                         }\n                         _ => bug!(\"promoteds should have an allocation: {:?}\", val),\n                     },"}, {"sha": "2f8e3189d12e969f5394031128f4a2def3fe2b90", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=1082a292eafef01a24376b82be4dc875e595691e", "patch": "@@ -21,7 +21,7 @@ use syntax::ast::Mutability;\n use syntax::source_map::{Span, DUMMY_SP};\n \n use crate::interpret::{self,\n-    PlaceTy, MPlaceTy, MemPlace, OpTy, ImmTy, Operand, Immediate, Scalar, Pointer,\n+    PlaceTy, MPlaceTy, MemPlace, OpTy, ImmTy, Immediate, Scalar, Pointer,\n     RawConst, ConstValue,\n     EvalResult, EvalError, EvalErrorKind, GlobalId, EvalContext, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n@@ -62,45 +62,46 @@ pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n     eval_body_using_ecx(&mut ecx, cid, Some(mir), param_env)\n }\n \n-// FIXME: These two conversion functions are bad hacks.  We should just always use allocations.\n-pub fn op_to_const<'tcx>(\n+fn mplace_to_const<'tcx>(\n+    ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n+    mplace: MPlaceTy<'tcx>,\n+) -> EvalResult<'tcx, ty::Const<'tcx>> {\n+    let MemPlace { ptr, align, meta } = *mplace;\n+    // extract alloc-offset pair\n+    assert!(meta.is_none());\n+    let ptr = ptr.to_ptr()?;\n+    let alloc = ecx.memory.get(ptr.alloc_id)?;\n+    assert!(alloc.align >= align);\n+    assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= mplace.layout.size.bytes());\n+    let mut alloc = alloc.clone();\n+    alloc.align = align;\n+    // FIXME shouldn't it be the case that `mark_static_initialized` has already\n+    // interned this?  I thought that is the entire point of that `FinishStatic` stuff?\n+    let alloc = ecx.tcx.intern_const_alloc(alloc);\n+    let val = ConstValue::ByRef(ptr, alloc);\n+    Ok(ty::Const { val, ty: mplace.layout.ty })\n+}\n+\n+fn op_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n     op: OpTy<'tcx>,\n-    may_normalize: bool,\n ) -> EvalResult<'tcx, ty::Const<'tcx>> {\n     // We do not normalize just any data.  Only scalar layout and slices.\n-    let normalize = may_normalize\n-        && match op.layout.abi {\n-            layout::Abi::Scalar(..) => true,\n-            layout::Abi::ScalarPair(..) => op.layout.ty.is_slice(),\n-            _ => false,\n-        };\n+    let normalize = match op.layout.abi {\n+        layout::Abi::Scalar(..) => true,\n+        layout::Abi::ScalarPair(..) => op.layout.ty.is_slice(),\n+        _ => false,\n+    };\n     let normalized_op = if normalize {\n-        ecx.try_read_immediate(op)?\n+        Err(*ecx.read_immediate(op).expect(\"normalization works on validated constants\"))\n     } else {\n-        match *op {\n-            Operand::Indirect(mplace) => Err(mplace),\n-            Operand::Immediate(val) => Ok(val)\n-        }\n+        op.try_as_mplace()\n     };\n     let val = match normalized_op {\n-        Err(MemPlace { ptr, align, meta }) => {\n-            // extract alloc-offset pair\n-            assert!(meta.is_none());\n-            let ptr = ptr.to_ptr()?;\n-            let alloc = ecx.memory.get(ptr.alloc_id)?;\n-            assert!(alloc.align >= align);\n-            assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= op.layout.size.bytes());\n-            let mut alloc = alloc.clone();\n-            alloc.align = align;\n-            // FIXME shouldn't it be the case that `mark_static_initialized` has already\n-            // interned this?  I thought that is the entire point of that `FinishStatic` stuff?\n-            let alloc = ecx.tcx.intern_const_alloc(alloc);\n-            ConstValue::ByRef(ptr.alloc_id, alloc, ptr.offset)\n-        },\n-        Ok(Immediate::Scalar(x)) =>\n+        Ok(mplace) => return mplace_to_const(ecx, mplace),\n+        Err(Immediate::Scalar(x)) =>\n             ConstValue::Scalar(x.not_undef()?),\n-        Ok(Immediate::ScalarPair(a, b)) =>\n+        Err(Immediate::ScalarPair(a, b)) =>\n             ConstValue::Slice(a.not_undef()?, b.to_usize(ecx)?),\n     };\n     Ok(ty::Const { val, ty: op.layout.ty })\n@@ -476,7 +477,7 @@ pub fn const_field<'a, 'tcx>(\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n     let result = (|| {\n         // get the operand again\n-        let op = ecx.lazy_const_to_op(ty::LazyConst::Evaluated(value), value.ty)?;\n+        let op = ecx.const_to_op(value, None)?;\n         // downcast\n         let down = match variant {\n             None => op,\n@@ -486,7 +487,7 @@ pub fn const_field<'a, 'tcx>(\n         let field = ecx.operand_field(down, field.index() as u64)?;\n         // and finally move back to the const world, always normalizing because\n         // this is not called for statics.\n-        op_to_const(&ecx, field, true)\n+        op_to_const(&ecx, field)\n     })();\n     result.map_err(|error| {\n         let err = error_to_const_error(&ecx, error);\n@@ -502,7 +503,7 @@ pub fn const_variant_index<'a, 'tcx>(\n ) -> EvalResult<'tcx, VariantIdx> {\n     trace!(\"const_variant_index: {:?}\", val);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n-    let op = ecx.lazy_const_to_op(ty::LazyConst::Evaluated(val), val.ty)?;\n+    let op = ecx.const_to_op(val, None)?;\n     Ok(ecx.read_discriminant(op)?.1)\n }\n \n@@ -523,22 +524,23 @@ fn validate_and_turn_into_const<'a, 'tcx>(\n     let cid = key.value;\n     let ecx = mk_eval_cx(tcx, tcx.def_span(key.value.instance.def_id()), key.param_env);\n     let val = (|| {\n-        let op = ecx.raw_const_to_mplace(constant)?.into();\n-        // FIXME: Once the visitor infrastructure landed, change validation to\n-        // work directly on `MPlaceTy`.\n-        let mut ref_tracking = RefTracking::new(op);\n-        while let Some((op, path)) = ref_tracking.todo.pop() {\n+        let mplace = ecx.raw_const_to_mplace(constant)?;\n+        let mut ref_tracking = RefTracking::new(mplace);\n+        while let Some((mplace, path)) = ref_tracking.todo.pop() {\n             ecx.validate_operand(\n-                op,\n+                mplace.into(),\n                 path,\n                 Some(&mut ref_tracking),\n                 true, // const mode\n             )?;\n         }\n         // Now that we validated, turn this into a proper constant.\n         let def_id = cid.instance.def.def_id();\n-        let normalize = tcx.is_static(def_id).is_none() && cid.promoted.is_none();\n-        op_to_const(&ecx, op, normalize)\n+        if tcx.is_static(def_id).is_some() || cid.promoted.is_some() {\n+            mplace_to_const(&ecx, mplace)\n+        } else {\n+            op_to_const(&ecx, mplace.into())\n+        }\n     })();\n \n     val.map_err(|error| {"}, {"sha": "10bef53e249c4430993e3581013d81d776b1d11a", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=1082a292eafef01a24376b82be4dc875e595691e", "patch": "@@ -172,7 +172,7 @@ use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Const};\n use rustc::ty::layout::{Integer, IntegerExt, VariantIdx, Size};\n \n use rustc::mir::Field;\n-use rustc::mir::interpret::{ConstValue, Pointer, Scalar};\n+use rustc::mir::interpret::{ConstValue, Scalar};\n use rustc::util::common::ErrorReported;\n \n use syntax::attr::{SignedInt, UnsignedInt};\n@@ -214,9 +214,8 @@ impl<'a, 'tcx> LiteralExpander<'a, 'tcx> {\n         match (val, &crty.sty, &rty.sty) {\n             // the easy case, deref a reference\n             (ConstValue::Scalar(Scalar::Ptr(p)), x, y) if x == y => ConstValue::ByRef(\n-                p.alloc_id,\n+                p,\n                 self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id),\n-                p.offset,\n             ),\n             // unsize array to slice if pattern is array but match value or other patterns are slice\n             (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n@@ -1428,15 +1427,14 @@ fn slice_pat_covered_by_const<'tcx>(\n     suffix: &[Pattern<'tcx>]\n ) -> Result<bool, ErrorReported> {\n     let data: &[u8] = match (const_val.val, &const_val.ty.sty) {\n-        (ConstValue::ByRef(id, alloc, offset), ty::Array(t, n)) => {\n+        (ConstValue::ByRef(ptr, alloc), ty::Array(t, n)) => {\n             if *t != tcx.types.u8 {\n                 // FIXME(oli-obk): can't mix const patterns with slice patterns and get\n                 // any sort of exhaustiveness/unreachable check yet\n                 // This solely means that we don't lint about unreachable patterns, even if some\n                 // are definitely unreachable.\n                 return Ok(false);\n             }\n-            let ptr = Pointer::new(id, offset);\n             let n = n.assert_usize(tcx).unwrap();\n             alloc.get_bytes(&tcx, ptr, Size::from_bytes(n)).unwrap()\n         },\n@@ -1778,8 +1776,8 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                     let (opt_ptr, n, ty) = match value.ty.sty {\n                         ty::TyKind::Array(t, n) => {\n                             match value.val {\n-                                ConstValue::ByRef(id, alloc, offset) => (\n-                                    Some((Pointer::new(id, offset), alloc)),\n+                                ConstValue::ByRef(ptr, alloc) => (\n+                                    Some((ptr, alloc)),\n                                     n.unwrap_usize(cx.tcx),\n                                     t,\n                                 ),"}, {"sha": "474df457f61a2826a9c799599b4835ab932b2aff", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 40, "deletions": 48, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=1082a292eafef01a24376b82be4dc875e595691e", "patch": "@@ -13,7 +13,7 @@ use rustc::mir::interpret::{\n     sign_extend, truncate,\n };\n use super::{\n-    EvalContext, Machine, AllocMap, Allocation, AllocationExtra,\n+    EvalContext, Machine,\n     MemPlace, MPlaceTy, PlaceTy, Place, MemoryKind,\n };\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n@@ -270,7 +270,7 @@ pub(super) fn from_known_layout<'tcx>(\n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Try reading an immediate in memory; this is interesting particularly for ScalarPair.\n     /// Returns `None` if the layout does not permit loading this as a value.\n-    pub(super) fn try_read_immediate_from_mplace(\n+    fn try_read_immediate_from_mplace(\n         &self,\n         mplace: MPlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, Option<Immediate<M::PointerTag>>> {\n@@ -324,7 +324,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     /// Note that for a given layout, this operation will either always fail or always\n     /// succeed!  Whether it succeeds depends on whether the layout can be represented\n     /// in a `Immediate`, not on which data is stored there currently.\n-    pub(crate) fn try_read_immediate(\n+    pub(super) fn try_read_immediate(\n         &self,\n         src: OpTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, Result<Immediate<M::PointerTag>, MemPlace<M::PointerTag>>> {\n@@ -509,7 +509,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n     // Evaluate a place with the goal of reading from it.  This lets us sometimes\n     // avoid allocations.\n-    fn eval_place_to_op(\n+    pub(super) fn eval_place_to_op(\n         &self,\n         mir_place: &mir::Place<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n@@ -546,14 +546,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             Move(ref place) =>\n                 self.eval_place_to_op(place, layout)?,\n \n-            Constant(ref constant) => {\n-                let layout = from_known_layout(layout, || {\n-                    let ty = self.monomorphize(mir_op.ty(self.mir(), *self.tcx))?;\n-                    self.layout_of(ty)\n-                })?;\n-                let op = self.const_value_to_op(*constant.literal)?;\n-                OpTy { op, layout }\n-            }\n+            Constant(ref constant) => self.eval_lazy_const_to_op(*constant.literal, layout)?,\n         };\n         trace!(\"{:?}: {:?}\", mir_op, *op);\n         Ok(op)\n@@ -569,38 +562,56 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             .collect()\n     }\n \n-    // Used when Miri runs into a constant, and (indirectly through lazy_const_to_op) by CTFE.\n-    fn const_value_to_op(\n+    // Used when Miri runs into a constant, and by const propagation.\n+    crate fn eval_lazy_const_to_op(\n         &self,\n         val: ty::LazyConst<'tcx>,\n-    ) -> EvalResult<'tcx, Operand<M::PointerTag>> {\n-        trace!(\"const_value_to_op: {:?}\", val);\n-        let val = match val {\n+        layout: Option<TyLayout<'tcx>>,\n+    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        trace!(\"const_to_op: {:?}\", val);\n+        match val {\n             ty::LazyConst::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n-                return Ok(*OpTy::from(self.const_eval_raw(GlobalId {\n+                return Ok(OpTy::from(self.const_eval_raw(GlobalId {\n                     instance,\n                     promoted: None,\n                 })?));\n             },\n-            ty::LazyConst::Evaluated(c) => c,\n-        };\n-        match val.val {\n-            ConstValue::ByRef(id, alloc, offset) => {\n+            ty::LazyConst::Evaluated(c) => self.const_to_op(c, layout),\n+        }\n+    }\n+\n+    // Used when the miri-engine runs into a constant and for extracting information from constants\n+    // in patterns via the `const_eval` module\n+    crate fn const_to_op(\n+        &self,\n+        val: ty::Const<'tcx>,\n+        layout: Option<TyLayout<'tcx>>,\n+    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        let layout = from_known_layout(layout, || {\n+            let ty = self.monomorphize(val.ty)?;\n+            self.layout_of(ty)\n+        })?;\n+        let op = match val.val {\n+            ConstValue::ByRef(ptr, alloc) => {\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen -- and for `static mut`, we copy on demand anyway.\n-                Ok(Operand::Indirect(\n-                    MemPlace::from_ptr(Pointer::new(id, offset), alloc.align)\n-                ).with_default_tag())\n+                Operand::Indirect(\n+                    MemPlace::from_ptr(ptr, alloc.align)\n+                ).with_default_tag()\n             },\n             ConstValue::Slice(a, b) =>\n-                Ok(Operand::Immediate(Immediate::ScalarPair(\n+                Operand::Immediate(Immediate::ScalarPair(\n                     a.into(),\n                     Scalar::from_uint(b, self.tcx.data_layout.pointer_size).into(),\n-                )).with_default_tag()),\n+                )).with_default_tag(),\n             ConstValue::Scalar(x) =>\n-                Ok(Operand::Immediate(Immediate::Scalar(x.into())).with_default_tag()),\n-        }\n+                Operand::Immediate(Immediate::Scalar(x.into())).with_default_tag(),\n+        };\n+        Ok(OpTy {\n+            op,\n+            layout,\n+        })\n     }\n \n     /// Read discriminant, return the runtime value as well as the variant index.\n@@ -697,23 +708,4 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             }\n         })\n     }\n-\n-}\n-\n-impl<'a, 'mir, 'tcx, M> EvalContext<'a, 'mir, 'tcx, M>\n-where\n-    M: Machine<'a, 'mir, 'tcx, PointerTag=()>,\n-    // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n-    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<(), M::AllocExtra>)>,\n-    M::AllocExtra: AllocationExtra<(), M::MemoryExtra>,\n-{\n-    // FIXME: CTFE should use allocations, then we can remove this.\n-    pub(crate) fn lazy_const_to_op(\n-        &self,\n-        cnst: ty::LazyConst<'tcx>,\n-        ty: ty::Ty<'tcx>,\n-    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n-        let op = self.const_value_to_op(cnst)?;\n-        Ok(OpTy { op, layout: self.layout_of(ty)? })\n-    }\n }"}, {"sha": "7b66d11131c13fdd09ae365fd491f78ca7533ca2", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=1082a292eafef01a24376b82be4dc875e595691e", "patch": "@@ -59,7 +59,7 @@ impl<'tcx, Tag> ::std::ops::Deref for PlaceTy<'tcx, Tag> {\n }\n \n /// A MemPlace with its layout. Constructing it is only possible in this module.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]\n pub struct MPlaceTy<'tcx, Tag=()> {\n     mplace: MemPlace<Tag>,\n     pub layout: TyLayout<'tcx>,"}, {"sha": "656c13c16d9edac1ff96f0bec5933adba795c04d", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=1082a292eafef01a24376b82be4dc875e595691e", "patch": "@@ -266,8 +266,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             }\n \n             Discriminant(ref place) => {\n-                let place = self.eval_place(place)?;\n-                let discr_val = self.read_discriminant(self.place_to_op(place)?)?.0;\n+                let op = self.eval_place_to_op(place, None)?;\n+                let discr_val = self.read_discriminant(op)?.0;\n                 let size = dest.layout.size;\n                 self.write_scalar(Scalar::from_uint(discr_val, size), dest)?;\n             }"}, {"sha": "252e8bac2a3f8c1c5c9a79ff1037de488f1b9020", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=1082a292eafef01a24376b82be4dc875e595691e", "patch": "@@ -11,7 +11,7 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    OpTy, Machine, EvalContext, ValueVisitor,\n+    OpTy, Machine, EvalContext, ValueVisitor, MPlaceTy,\n };\n \n macro_rules! validation_failure {\n@@ -74,13 +74,13 @@ pub enum PathElem {\n }\n \n /// State for tracking recursive validation of references\n-pub struct RefTracking<'tcx, Tag> {\n-    pub seen: FxHashSet<(OpTy<'tcx, Tag>)>,\n-    pub todo: Vec<(OpTy<'tcx, Tag>, Vec<PathElem>)>,\n+pub struct RefTracking<T> {\n+    pub seen: FxHashSet<T>,\n+    pub todo: Vec<(T, Vec<PathElem>)>,\n }\n \n-impl<'tcx, Tag: Copy+Eq+Hash> RefTracking<'tcx, Tag> {\n-    pub fn new(op: OpTy<'tcx, Tag>) -> Self {\n+impl<'tcx, T: Copy + Eq + Hash> RefTracking<T> {\n+    pub fn new(op: T) -> Self {\n         let mut ref_tracking = RefTracking {\n             seen: FxHashSet::default(),\n             todo: vec![(op, Vec::new())],\n@@ -151,7 +151,7 @@ struct ValidityVisitor<'rt, 'a: 'rt, 'mir: 'rt, 'tcx: 'a+'rt+'mir, M: Machine<'a\n     /// starts must not be changed!  `visit_fields` and `visit_array` rely on\n     /// this stack discipline.\n     path: Vec<PathElem>,\n-    ref_tracking: Option<&'rt mut RefTracking<'tcx, M::PointerTag>>,\n+    ref_tracking: Option<&'rt mut RefTracking<MPlaceTy<'tcx, M::PointerTag>>>,\n     const_mode: bool,\n     ecx: &'rt EvalContext<'a, 'mir, 'tcx, M>,\n }\n@@ -401,16 +401,15 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     // before.  Proceed recursively even for integer pointers, no\n                     // reason to skip them! They are (recursively) valid for some ZST,\n                     // but not for others (e.g., `!` is a ZST).\n-                    let op = place.into();\n-                    if ref_tracking.seen.insert(op) {\n-                        trace!(\"Recursing below ptr {:#?}\", *op);\n+                    if ref_tracking.seen.insert(place) {\n+                        trace!(\"Recursing below ptr {:#?}\", *place);\n                         // We need to clone the path anyway, make sure it gets created\n                         // with enough space for the additional `Deref`.\n                         let mut new_path = Vec::with_capacity(self.path.len()+1);\n                         new_path.clone_from(&self.path);\n                         new_path.push(PathElem::Deref);\n                         // Remember to come back to this later.\n-                        ref_tracking.todo.push((op, new_path));\n+                        ref_tracking.todo.push((place, new_path));\n                     }\n                 }\n             }\n@@ -600,7 +599,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n         path: Vec<PathElem>,\n-        ref_tracking: Option<&mut RefTracking<'tcx, M::PointerTag>>,\n+        ref_tracking: Option<&mut RefTracking<MPlaceTy<'tcx, M::PointerTag>>>,\n         const_mode: bool,\n     ) -> EvalResult<'tcx> {\n         trace!(\"validate_operand: {:?}, {:?}\", *op, op.layout.ty);"}, {"sha": "dd7158897b889fb037739645410e0cfb645c8626", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=1082a292eafef01a24376b82be4dc875e595691e", "patch": "@@ -1260,7 +1260,7 @@ fn collect_const<'a, 'tcx>(\n         ConstValue::Slice(Scalar::Ptr(ptr), _) |\n         ConstValue::Scalar(Scalar::Ptr(ptr)) =>\n             collect_miri(tcx, ptr.alloc_id, output),\n-        ConstValue::ByRef(_id, alloc, _offset) => {\n+        ConstValue::ByRef(_ptr, alloc) => {\n             for &((), id) in alloc.relocations.values() {\n                 collect_miri(tcx, id, output);\n             }"}, {"sha": "1acc7b6e0c57fe2cc295a4a908473a767968c512", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=1082a292eafef01a24376b82be4dc875e595691e", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n         source_info: SourceInfo,\n     ) -> Option<Const<'tcx>> {\n         self.ecx.tcx.span = source_info.span;\n-        match self.ecx.lazy_const_to_op(*c.literal, c.ty) {\n+        match self.ecx.eval_lazy_const_to_op(*c.literal, None) {\n             Ok(op) => {\n                 Some((op, c.span))\n             },"}, {"sha": "3fe73e78bba836472aee89357a0577356b9e2249", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1082a292eafef01a24376b82be4dc875e595691e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1082a292eafef01a24376b82be4dc875e595691e", "patch": "@@ -1461,7 +1461,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt, id: DefId, span: Span) {\n     };\n     let param_env = ty::ParamEnv::reveal_all();\n     if let Ok(static_) = tcx.const_eval(param_env.and(cid)) {\n-        let alloc = if let ConstValue::ByRef(_, allocation, _) = static_.val {\n+        let alloc = if let ConstValue::ByRef(_, allocation) = static_.val {\n             allocation\n         } else {\n             bug!(\"Matching on non-ByRef static\")"}]}