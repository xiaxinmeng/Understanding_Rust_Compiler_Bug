{"sha": "38491c65790e393915616ccc3822a752272a4a92", "node_id": "C_kwDOAAsO6NoAKDM4NDkxYzY1NzkwZTM5MzkxNTYxNmNjYzM4MjJhNzUyMjcyYTRhOTI", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-08T22:31:47Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-09T17:48:22Z"}, "message": "Consider method return type for various method suggestions", "tree": {"sha": "9397233882ca6c9259282dbf70fdbc9d0d07fb65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9397233882ca6c9259282dbf70fdbc9d0d07fb65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38491c65790e393915616ccc3822a752272a4a92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38491c65790e393915616ccc3822a752272a4a92", "html_url": "https://github.com/rust-lang/rust/commit/38491c65790e393915616ccc3822a752272a4a92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38491c65790e393915616ccc3822a752272a4a92/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ee6cebd8afbb7f6085e5980121ba53f9304885e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ee6cebd8afbb7f6085e5980121ba53f9304885e", "html_url": "https://github.com/rust-lang/rust/commit/7ee6cebd8afbb7f6085e5980121ba53f9304885e"}], "stats": {"total": 262, "additions": 224, "deletions": 38}, "files": [{"sha": "e299a65ba6fc238c9dba589295dcc592b2bfc87c", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38491c65790e393915616ccc3822a752272a4a92/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38491c65790e393915616ccc3822a752272a4a92/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=38491c65790e393915616ccc3822a752272a4a92", "patch": "@@ -499,6 +499,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .probe_for_name(\n                 Mode::MethodCall,\n                 segment.ident,\n+                expected.only_has_type(self),\n                 IsSuggestion(true),\n                 callee_ty,\n                 call_expr.hir_id,"}, {"sha": "1f31a45cfec0a713e6da2374dadac00a5859fb07", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38491c65790e393915616ccc3822a752272a4a92/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38491c65790e393915616ccc3822a752272a4a92/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=38491c65790e393915616ccc3822a752272a4a92", "patch": "@@ -560,6 +560,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .probe_for_name(\n                 probe::Mode::MethodCall,\n                 path.ident,\n+                None,\n                 probe::IsSuggestion(true),\n                 self_ty,\n                 deref.hir_id,\n@@ -570,6 +571,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let in_scope_methods = self.probe_for_name_many(\n             probe::Mode::MethodCall,\n             path.ident,\n+            Some(expected),\n             probe::IsSuggestion(true),\n             self_ty,\n             deref.hir_id,\n@@ -581,6 +583,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let all_methods = self.probe_for_name_many(\n             probe::Mode::MethodCall,\n             path.ident,\n+            Some(expected),\n             probe::IsSuggestion(true),\n             self_ty,\n             deref.hir_id,\n@@ -1850,10 +1853,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n         let mut expr = end.expr;\n+        let mut expectation = Some(expected_ty);\n         while let hir::ExprKind::MethodCall(_, rcvr, ..) = expr.kind {\n             // Getting to the root receiver and asserting it is a fn call let's us ignore cases in\n             // `src/test/ui/methods/issues/issue-90315.stderr`.\n             expr = rcvr;\n+            // If we have more than one layer of calls, then the expected ty\n+            // cannot guide the method probe.\n+            expectation = None;\n         }\n         let hir::ExprKind::Call(method_name, _) = expr.kind else { return; };\n         let ty::Adt(adt, _) = checked_ty.kind() else { return; };\n@@ -1872,6 +1879,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let Ok(_pick) = self.probe_for_name(\n             probe::Mode::MethodCall,\n             *ident,\n+            expectation,\n             probe::IsSuggestion(true),\n             self_ty,\n             expr.hir_id,"}, {"sha": "46aabe7d5c3b0c1339be2c375a21f58200ece91c", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/38491c65790e393915616ccc3822a752272a4a92/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38491c65790e393915616ccc3822a752272a4a92/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=38491c65790e393915616ccc3822a752272a4a92", "patch": "@@ -351,7 +351,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Struct(qpath, fields, ref base_expr) => {\n                 self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n             }\n-            ExprKind::Field(base, field) => self.check_field(expr, &base, field),\n+            ExprKind::Field(base, field) => self.check_field(expr, &base, field, expected),\n             ExprKind::Index(base, idx) => self.check_expr_index(base, idx, expr),\n             ExprKind::Yield(value, ref src) => self.check_expr_yield(value, expr, src),\n             hir::ExprKind::Err => tcx.ty_error(),\n@@ -1244,6 +1244,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         SelfSource::MethodCall(rcvr),\n                         error,\n                         Some((rcvr, args)),\n+                        expected,\n                     ) {\n                         err.emit();\n                     }\n@@ -2186,6 +2187,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &'tcx hir::Expr<'tcx>,\n         base: &'tcx hir::Expr<'tcx>,\n         field: Ident,\n+        expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         debug!(\"check_field(expr: {:?}, base: {:?}, field: {:?})\", expr, base, field);\n         let base_ty = self.check_expr(base);\n@@ -2244,12 +2246,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // (#90483) apply adjustments to avoid ExprUseVisitor from\n             // creating erroneous projection.\n             self.apply_adjustments(base, adjustments);\n-            self.ban_private_field_access(expr, base_ty, field, did);\n+            self.ban_private_field_access(expr, base_ty, field, did, expected.only_has_type(self));\n             return self.tcx().ty_error();\n         }\n \n         if field.name == kw::Empty {\n-        } else if self.method_exists(field, base_ty, expr.hir_id, true) {\n+        } else if self.method_exists(\n+            field,\n+            base_ty,\n+            expr.hir_id,\n+            true,\n+            expected.only_has_type(self),\n+        ) {\n             self.ban_take_value_of_method(expr, base_ty, field);\n         } else if !base_ty.is_primitive_ty() {\n             self.ban_nonexisting_field(field, base, expr, base_ty);\n@@ -2427,6 +2435,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr_t: Ty<'tcx>,\n         field: Ident,\n         base_did: DefId,\n+        return_ty: Option<Ty<'tcx>>,\n     ) {\n         let struct_path = self.tcx().def_path_str(base_did);\n         let kind_name = self.tcx().def_kind(base_did).descr(base_did);\n@@ -2438,7 +2447,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n         err.span_label(field.span, \"private field\");\n         // Also check if an accessible method exists, which is often what is meant.\n-        if self.method_exists(field, expr_t, expr.hir_id, false) && !self.expr_in_place(expr.hir_id)\n+        if self.method_exists(field, expr_t, expr.hir_id, false, return_ty)\n+            && !self.expr_in_place(expr.hir_id)\n         {\n             self.suggest_method_call(\n                 &mut err,"}, {"sha": "ebbd64eba37b70d1b9f94ab8877552bd80735293", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38491c65790e393915616ccc3822a752272a4a92/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38491c65790e393915616ccc3822a752272a4a92/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=38491c65790e393915616ccc3822a752272a4a92", "patch": "@@ -841,6 +841,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         SelfSource::QPath(qself),\n                         error,\n                         None,\n+                        Expectation::NoExpectation,\n                     ) {\n                         e.emit();\n                     }"}, {"sha": "91498265259dee557456da28c7d319a86594360f", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38491c65790e393915616ccc3822a752272a4a92/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38491c65790e393915616ccc3822a752272a4a92/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=38491c65790e393915616ccc3822a752272a4a92", "patch": "@@ -1343,6 +1343,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let Ok(pick) = self.probe_for_name(\n                     Mode::Path,\n                     Ident::new(capitalized_name, segment.ident.span),\n+                    Some(expected_ty),\n                     IsSuggestion(true),\n                     self_ty,\n                     expr.hir_id,"}, {"sha": "76c62d6fdc49ab4620f1b3488578342114edc99f", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/38491c65790e393915616ccc3822a752272a4a92/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38491c65790e393915616ccc3822a752272a4a92/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=38491c65790e393915616ccc3822a752272a4a92", "patch": "@@ -97,10 +97,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self_ty: Ty<'tcx>,\n         call_expr_id: hir::HirId,\n         allow_private: bool,\n+        return_type: Option<Ty<'tcx>>,\n     ) -> bool {\n         match self.probe_for_name(\n             probe::Mode::MethodCall,\n             method_name,\n+            return_type,\n             IsSuggestion(false),\n             self_ty,\n             call_expr_id,\n@@ -118,7 +120,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Err(Ambiguity(..)) => true,\n             Err(PrivateMatch(..)) => allow_private,\n             Err(IllegalSizedBound { .. }) => true,\n-            Err(BadReturnType) => bug!(\"no return type expectations but got BadReturnType\"),\n+            Err(BadReturnType) => false,\n         }\n     }\n \n@@ -137,6 +139,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .probe_for_name(\n                 probe::Mode::MethodCall,\n                 method_name,\n+                None,\n                 IsSuggestion(true),\n                 self_ty,\n                 call_expr.hir_id,\n@@ -258,6 +261,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let pick = self.probe_for_name(\n             probe::Mode::MethodCall,\n             method_name,\n+            None,\n             IsSuggestion(false),\n             self_ty,\n             call_expr.hir_id,\n@@ -484,6 +488,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let pick = self.probe_for_name(\n             probe::Mode::Path,\n             method_name,\n+            None,\n             IsSuggestion(false),\n             self_ty,\n             expr_id,"}, {"sha": "47c072831e3a6b8d29488eee91b05beddac3c22f", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38491c65790e393915616ccc3822a752272a4a92/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38491c65790e393915616ccc3822a752272a4a92/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=38491c65790e393915616ccc3822a752272a4a92", "patch": "@@ -304,6 +304,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         mode: Mode,\n         item_name: Ident,\n+        return_type: Option<Ty<'tcx>>,\n         is_suggestion: IsSuggestion,\n         self_ty: Ty<'tcx>,\n         scope_expr_id: hir::HirId,\n@@ -313,7 +314,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             item_name.span,\n             mode,\n             Some(item_name),\n-            None,\n+            return_type,\n             is_suggestion,\n             self_ty,\n             scope_expr_id,\n@@ -327,6 +328,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         mode: Mode,\n         item_name: Ident,\n+        return_type: Option<Ty<'tcx>>,\n         is_suggestion: IsSuggestion,\n         self_ty: Ty<'tcx>,\n         scope_expr_id: hir::HirId,\n@@ -336,7 +338,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             item_name.span,\n             mode,\n             Some(item_name),\n-            None,\n+            return_type,\n             is_suggestion,\n             self_ty,\n             scope_expr_id,"}, {"sha": "bd2b66a72d508e2dbc56159518a0b8aa96b9a10b", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 42, "deletions": 9, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/38491c65790e393915616ccc3822a752272a4a92/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38491c65790e393915616ccc3822a752272a4a92/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=38491c65790e393915616ccc3822a752272a4a92", "patch": "@@ -2,6 +2,7 @@\n //! found or is otherwise invalid.\n \n use crate::errors;\n+use crate::Expectation;\n use crate::FnCtxt;\n use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -108,6 +109,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         source: SelfSource<'tcx>,\n         error: MethodError<'tcx>,\n         args: Option<(&'tcx hir::Expr<'tcx>, &'tcx [hir::Expr<'tcx>])>,\n+        expected: Expectation<'tcx>,\n     ) -> Option<DiagnosticBuilder<'_, ErrorGuaranteed>> {\n         // Avoid suggestions when we don't know what's going on.\n         if rcvr_ty.references_error() {\n@@ -131,6 +133,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     args,\n                     sugg_span,\n                     &mut no_match_data,\n+                    expected,\n                 );\n             }\n \n@@ -250,6 +253,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         args: Option<(&'tcx hir::Expr<'tcx>, &'tcx [hir::Expr<'tcx>])>,\n         sugg_span: Span,\n         no_match_data: &mut NoMatchData<'tcx>,\n+        expected: Expectation<'tcx>,\n     ) -> Option<DiagnosticBuilder<'_, ErrorGuaranteed>> {\n         let mode = no_match_data.mode;\n         let tcx = self.tcx;\n@@ -320,7 +324,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if let Mode::MethodCall = mode && let SelfSource::MethodCall(cal) = source {\n             self.suggest_await_before_method(\n-                &mut err, item_name, rcvr_ty, cal, span,\n+                &mut err, item_name, rcvr_ty, cal, span, expected.only_has_type(self),\n             );\n         }\n         if let Some(span) =\n@@ -898,7 +902,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Don't suggest (for example) `expr.field.clone()` if `expr.clone()`\n         // can't be called due to `typeof(expr): Clone` not holding.\n         if unsatisfied_predicates.is_empty() {\n-            self.suggest_calling_method_on_field(&mut err, source, span, rcvr_ty, item_name);\n+            self.suggest_calling_method_on_field(\n+                &mut err,\n+                source,\n+                span,\n+                rcvr_ty,\n+                item_name,\n+                expected.only_has_type(self),\n+            );\n         }\n \n         self.check_for_inner_self(&mut err, source, rcvr_ty, item_name);\n@@ -922,6 +933,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 &unsatisfied_predicates,\n                 &static_candidates,\n                 unsatisfied_bounds,\n+                expected.only_has_type(self),\n             );\n         }\n \n@@ -987,7 +999,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        self.check_for_deref_method(&mut err, source, rcvr_ty, item_name);\n+        self.check_for_deref_method(&mut err, source, rcvr_ty, item_name, expected);\n         return Some(err);\n     }\n \n@@ -1377,6 +1389,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let pick = self.probe_for_name(\n                         Mode::MethodCall,\n                         item_name,\n+                        None,\n                         IsSuggestion(true),\n                         range_ty,\n                         expr.hir_id,\n@@ -1587,6 +1600,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         actual: Ty<'tcx>,\n         item_name: Ident,\n+        return_type: Option<Ty<'tcx>>,\n     ) {\n         if let SelfSource::MethodCall(expr) = source\n         && let mod_id = self.tcx.parent_module(expr.hir_id).to_def_id()\n@@ -1610,10 +1624,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.check_for_nested_field_satisfying(\n                         span,\n                         &|_, field_ty| {\n-                            self.lookup_probe(\n+                            self.probe_for_name(\n+                                Mode::MethodCall,\n                                 item_name,\n+                                return_type,\n+                                IsSuggestion(true),\n                                 field_ty,\n-                                call_expr,\n+                                call_expr.hir_id,\n                                 ProbeScope::TraitsInScope,\n                             )\n                             .map_or(false, |pick| {\n@@ -2010,12 +2027,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self_source: SelfSource<'tcx>,\n         rcvr_ty: Ty<'tcx>,\n         item_name: Ident,\n+        expected: Expectation<'tcx>,\n     ) {\n         let SelfSource::QPath(ty) = self_source else { return; };\n         for (deref_ty, _) in self.autoderef(rustc_span::DUMMY_SP, rcvr_ty).skip(1) {\n             if let Ok(pick) = self.probe_for_name(\n                 Mode::Path,\n                 item_name,\n+                expected.only_has_type(self),\n                 IsSuggestion(true),\n                 deref_ty,\n                 ty.hir_id,\n@@ -2080,12 +2099,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         call: &hir::Expr<'_>,\n         span: Span,\n+        return_type: Option<Ty<'tcx>>,\n     ) {\n         let output_ty = match self.get_impl_future_output_ty(ty) {\n             Some(output_ty) => self.resolve_vars_if_possible(output_ty),\n             _ => return,\n         };\n-        let method_exists = self.method_exists(item_name, output_ty, call.hir_id, true);\n+        let method_exists =\n+            self.method_exists(item_name, output_ty, call.hir_id, true, return_type);\n         debug!(\"suggest_await_before_method: is_method_exist={}\", method_exists);\n         if method_exists {\n             err.span_suggestion_verbose(\n@@ -2199,6 +2220,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )],\n         static_candidates: &[CandidateSource],\n         unsatisfied_bounds: bool,\n+        return_type: Option<Ty<'tcx>>,\n     ) {\n         let mut alt_rcvr_sugg = false;\n         if let (SelfSource::MethodCall(rcvr), false) = (source, unsatisfied_bounds) {\n@@ -2221,7 +2243,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (self.tcx.mk_mut_ref(self.tcx.lifetimes.re_erased, rcvr_ty), \"&mut \"),\n                 (self.tcx.mk_imm_ref(self.tcx.lifetimes.re_erased, rcvr_ty), \"&\"),\n             ] {\n-                match self.lookup_probe(item_name, *rcvr_ty, rcvr, ProbeScope::AllTraits) {\n+                match self.probe_for_name(\n+                    Mode::MethodCall,\n+                    item_name,\n+                    return_type,\n+                    IsSuggestion(true),\n+                    *rcvr_ty,\n+                    rcvr.hir_id,\n+                    ProbeScope::AllTraits,\n+                ) {\n                     Ok(pick) => {\n                         // If the method is defined for the receiver we have, it likely wasn't `use`d.\n                         // We point at the method, but we just skip the rest of the check for arbitrary\n@@ -2254,10 +2284,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     (self.tcx.mk_diagnostic_item(*rcvr_ty, sym::Rc), \"Rc::new\"),\n                 ] {\n                     if let Some(new_rcvr_t) = *rcvr_ty\n-                        && let Ok(pick) = self.lookup_probe(\n+                        && let Ok(pick) = self.probe_for_name(\n+                            Mode::MethodCall,\n                             item_name,\n+                            return_type,\n+                            IsSuggestion(true),\n                             new_rcvr_t,\n-                            rcvr,\n+                            rcvr.hir_id,\n                             ProbeScope::AllTraits,\n                         )\n                     {"}, {"sha": "f2f87a908178c19719a06638161c5c4b58207333", "filename": "src/test/ui/async-await/dont-suggest-await-on-method-return-mismatch.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/38491c65790e393915616ccc3822a752272a4a92/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-await-on-method-return-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38491c65790e393915616ccc3822a752272a4a92/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-await-on-method-return-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-await-on-method-return-mismatch.rs?ref=38491c65790e393915616ccc3822a752272a4a92", "patch": "@@ -0,0 +1,24 @@\n+// edition:2021\n+\n+// Test that we do not suggest `.await` when it doesn't make sense.\n+\n+struct A;\n+\n+impl A {\n+    fn test(&self) -> i32 {\n+        1\n+    }\n+}\n+\n+async fn foo() -> A {\n+    A\n+}\n+\n+async fn async_main() {\n+    let x: u32 = foo().test();\n+    //~^ ERROR no method named `test` found for opaque type `impl Future<Output = A>` in the current scope\n+}\n+\n+fn main() {\n+    let _ = async_main();\n+}"}, {"sha": "e65d9d0e5d35ff60dc6d0a2b7d8fb252e923416c", "filename": "src/test/ui/async-await/dont-suggest-await-on-method-return-mismatch.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/38491c65790e393915616ccc3822a752272a4a92/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-await-on-method-return-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38491c65790e393915616ccc3822a752272a4a92/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-await-on-method-return-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-await-on-method-return-mismatch.stderr?ref=38491c65790e393915616ccc3822a752272a4a92", "patch": "@@ -0,0 +1,9 @@\n+error[E0599]: no method named `test` found for opaque type `impl Future<Output = A>` in the current scope\n+  --> $DIR/dont-suggest-await-on-method-return-mismatch.rs:18:24\n+   |\n+LL |     let x: u32 = foo().test();\n+   |                        ^^^^ method not found in `impl Future<Output = A>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "07b975c44c905ab2c1bd8bad6f3b56c1bf7f1472", "filename": "src/test/ui/methods/field-method-suggestion-using-return-ty.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/38491c65790e393915616ccc3822a752272a4a92/src%2Ftest%2Fui%2Fmethods%2Ffield-method-suggestion-using-return-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38491c65790e393915616ccc3822a752272a4a92/src%2Ftest%2Fui%2Fmethods%2Ffield-method-suggestion-using-return-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Ffield-method-suggestion-using-return-ty.rs?ref=38491c65790e393915616ccc3822a752272a4a92", "patch": "@@ -0,0 +1,18 @@\n+struct Wrapper<T>(T);\n+\n+impl Wrapper<Option<i32>> {\n+    fn inner_mut(&self) -> Option<&mut i32> {\n+        self.as_mut()\n+        //~^ ERROR no method named `as_mut` found for reference `&Wrapper<Option<i32>>` in the current scope\n+        //~| HELP one of the expressions' fields has a method of the same name\n+        //~| HELP items from traits can only be used if\n+    }\n+\n+    fn inner_mut_bad(&self) -> Option<&mut u32> {\n+        self.as_mut()\n+        //~^ ERROR no method named `as_mut` found for reference `&Wrapper<Option<i32>>` in the current scope\n+        //~| HELP items from traits can only be used if\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "51c52a07e10f6d075217b3d9f23ab87f82217027", "filename": "src/test/ui/methods/field-method-suggestion-using-return-ty.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/38491c65790e393915616ccc3822a752272a4a92/src%2Ftest%2Fui%2Fmethods%2Ffield-method-suggestion-using-return-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38491c65790e393915616ccc3822a752272a4a92/src%2Ftest%2Fui%2Fmethods%2Ffield-method-suggestion-using-return-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Ffield-method-suggestion-using-return-ty.stderr?ref=38491c65790e393915616ccc3822a752272a4a92", "patch": "@@ -0,0 +1,27 @@\n+error[E0599]: no method named `as_mut` found for reference `&Wrapper<Option<i32>>` in the current scope\n+  --> $DIR/field-method-suggestion-using-return-ty.rs:5:14\n+   |\n+LL |         self.as_mut()\n+   |              ^^^^^^ method not found in `&Wrapper<Option<i32>>`\n+   |\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+   = note: the following trait defines an item `as_mut`, perhaps you need to implement it:\n+           candidate #1: `AsMut`\n+help: one of the expressions' fields has a method of the same name\n+   |\n+LL |         self.0.as_mut()\n+   |              ++\n+\n+error[E0599]: no method named `as_mut` found for reference `&Wrapper<Option<i32>>` in the current scope\n+  --> $DIR/field-method-suggestion-using-return-ty.rs:12:14\n+   |\n+LL |         self.as_mut()\n+   |              ^^^^^^ method not found in `&Wrapper<Option<i32>>`\n+   |\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+   = note: the following trait defines an item `as_mut`, perhaps you need to implement it:\n+           candidate #1: `AsMut`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "98ba7856e57e3c9c6babdc2b294fccce8239e18e", "filename": "src/test/ui/privacy/private-field-ty-err.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/38491c65790e393915616ccc3822a752272a4a92/src%2Ftest%2Fui%2Fprivacy%2Fprivate-field-ty-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38491c65790e393915616ccc3822a752272a4a92/src%2Ftest%2Fui%2Fprivacy%2Fprivate-field-ty-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-field-ty-err.stderr?ref=38491c65790e393915616ccc3822a752272a4a92", "patch": "@@ -3,11 +3,6 @@ error[E0616]: field `len` of struct `Foo` is private\n    |\n LL |     if x.len {\n    |          ^^^ private field\n-   |\n-help: a method `len` also exists, call it with parentheses\n-   |\n-LL |     if x.len() {\n-   |             ++\n \n error: aborting due to previous error\n "}, {"sha": "13601eef6c25b9944cb86969eb5de1c3ded7d407", "filename": "src/test/ui/suggestions/method-access-to-range-literal-typo.fixed", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/38491c65790e393915616ccc3822a752272a4a92/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/38491c65790e393915616ccc3822a752272a4a92/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.fixed?ref=38491c65790e393915616ccc3822a752272a4a92", "patch": "@@ -0,0 +1,34 @@\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+fn as_ref() -> Option<Vec<u8>> {\n+    None\n+}\n+struct Type {\n+    option: Option<Vec<u8>>\n+}\n+trait Trait {\n+    fn foo(&self) -> &Vec<u8>;\n+}\n+impl Trait for Option<Vec<u8>> {\n+    fn foo(&self) -> &Vec<u8> {\n+        self.as_ref().unwrap()\n+    }\n+}\n+\n+impl Type {\n+    fn method(&self) -> Option<&Vec<u8>> {\n+        self.option.as_ref().map(|x| x)\n+        //~^ ERROR E0308\n+    }\n+    fn method2(&self) -> Option<&u8> {\n+        self.option.foo().get(0)\n+        //~^ ERROR E0425\n+        //~| ERROR E0308\n+    }\n+}\n+\n+fn main() {\n+    let _ = Type { option: None }.method();\n+}"}, {"sha": "fdcd6425d32de88d50f81194f9836631447f68c2", "filename": "src/test/ui/suggestions/method-access-to-range-literal-typo.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/38491c65790e393915616ccc3822a752272a4a92/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38491c65790e393915616ccc3822a752272a4a92/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.rs?ref=38491c65790e393915616ccc3822a752272a4a92", "patch": "@@ -1,24 +1,28 @@\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n fn as_ref() -> Option<Vec<u8>> {\n     None\n }\n struct Type {\n     option: Option<Vec<u8>>\n }\n trait Trait {\n-    fn foo(&self) -> Vec<u8>;\n+    fn foo(&self) -> &Vec<u8>;\n }\n impl Trait for Option<Vec<u8>> {\n-    fn foo(&self) -> Vec<u8> {\n-        vec![1, 2, 3]\n+    fn foo(&self) -> &Vec<u8> {\n+        self.as_ref().unwrap()\n     }\n }\n \n impl Type {\n-    fn method(&self) -> Option<Vec<u8>> {\n+    fn method(&self) -> Option<&Vec<u8>> {\n         self.option..as_ref().map(|x| x)\n         //~^ ERROR E0308\n     }\n-    fn method2(&self) -> &u8 {\n+    fn method2(&self) -> Option<&u8> {\n         self.option..foo().get(0)\n         //~^ ERROR E0425\n         //~| ERROR E0308"}, {"sha": "f421408944bb3b3d7656a64f7ccbbe64429395b7", "filename": "src/test/ui/suggestions/method-access-to-range-literal-typo.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/38491c65790e393915616ccc3822a752272a4a92/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38491c65790e393915616ccc3822a752272a4a92/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-access-to-range-literal-typo.stderr?ref=38491c65790e393915616ccc3822a752272a4a92", "patch": "@@ -1,5 +1,5 @@\n error[E0425]: cannot find function `foo` in this scope\n-  --> $DIR/method-access-to-range-literal-typo.rs:22:22\n+  --> $DIR/method-access-to-range-literal-typo.rs:26:22\n    |\n LL |         self.option..foo().get(0)\n    |                      ^^^ not found in this scope\n@@ -11,31 +11,31 @@ LL +         self.option.foo().get(0)\n    |\n \n error[E0308]: mismatched types\n-  --> $DIR/method-access-to-range-literal-typo.rs:18:9\n+  --> $DIR/method-access-to-range-literal-typo.rs:22:9\n    |\n-LL |     fn method(&self) -> Option<Vec<u8>> {\n-   |                         --------------- expected `Option<Vec<u8>>` because of return type\n+LL |     fn method(&self) -> Option<&Vec<u8>> {\n+   |                         ---------------- expected `Option<&Vec<u8>>` because of return type\n LL |         self.option..as_ref().map(|x| x)\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found struct `Range`\n    |\n-   = note: expected enum `Option<_>`\n-            found struct `std::ops::Range<Option<_>>`\n+   = note: expected enum `Option<&Vec<u8>>`\n+            found struct `std::ops::Range<Option<Vec<u8>>>`\n help: you likely meant to write a method call instead of a range\n    |\n LL -         self.option..as_ref().map(|x| x)\n LL +         self.option.as_ref().map(|x| x)\n    |\n \n error[E0308]: mismatched types\n-  --> $DIR/method-access-to-range-literal-typo.rs:22:9\n+  --> $DIR/method-access-to-range-literal-typo.rs:26:9\n    |\n-LL |     fn method2(&self) -> &u8 {\n-   |                          --- expected `&u8` because of return type\n+LL |     fn method2(&self) -> Option<&u8> {\n+   |                          ----------- expected `Option<&u8>` because of return type\n LL |         self.option..foo().get(0)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&u8`, found struct `Range`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found struct `Range`\n    |\n-   = note: expected reference `&u8`\n-                 found struct `std::ops::Range<Option<Vec<u8>>>`\n+   = note: expected enum `Option<&u8>`\n+            found struct `std::ops::Range<Option<Vec<u8>>>`\n help: you likely meant to write a method call instead of a range\n    |\n LL -         self.option..foo().get(0)"}, {"sha": "7cd9788a7d348ad8622a7069a3bea4a193afa7d5", "filename": "src/test/ui/trait-bounds/impl-derived-implicit-sized-bound-2.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/38491c65790e393915616ccc3822a752272a4a92/src%2Ftest%2Fui%2Ftrait-bounds%2Fimpl-derived-implicit-sized-bound-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38491c65790e393915616ccc3822a752272a4a92/src%2Ftest%2Fui%2Ftrait-bounds%2Fimpl-derived-implicit-sized-bound-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrait-bounds%2Fimpl-derived-implicit-sized-bound-2.stderr?ref=38491c65790e393915616ccc3822a752272a4a92", "patch": "@@ -17,6 +17,13 @@ LL | impl<'a, T: Perpetrator /*+ ?Sized*/> VictimTrait for Victim<'a, T> {\n    |          ^                            -----------     -------------\n    |          |\n    |          unsatisfied trait bound introduced here\n+   = note: the following trait bounds were not satisfied:\n+           `&Victim<'_, Self>: VictimTrait`\n+           `&mut Victim<'_, Self>: VictimTrait`\n+help: consider relaxing the type parameter's implicit `Sized` bound\n+   |\n+LL | impl<'a, T: ?Sized + Perpetrator /*+ ?Sized*/> VictimTrait for Victim<'a, T> {\n+   |             ++++++++\n help: consider relaxing the type parameter's implicit `Sized` bound\n    |\n LL | impl<'a, T: ?Sized + Perpetrator /*+ ?Sized*/> VictimTrait for Victim<'a, T> {"}, {"sha": "96345df73b4b3f500b78d313a02bfc6b0dd8ea03", "filename": "src/test/ui/trait-bounds/impl-derived-implicit-sized-bound.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/38491c65790e393915616ccc3822a752272a4a92/src%2Ftest%2Fui%2Ftrait-bounds%2Fimpl-derived-implicit-sized-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38491c65790e393915616ccc3822a752272a4a92/src%2Ftest%2Fui%2Ftrait-bounds%2Fimpl-derived-implicit-sized-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrait-bounds%2Fimpl-derived-implicit-sized-bound.stderr?ref=38491c65790e393915616ccc3822a752272a4a92", "patch": "@@ -17,6 +17,13 @@ LL | impl<'a, T: Perpetrator /*+ ?Sized*/> VictimTrait for Victim<'a, T> {\n    |          ^                            -----------     -------------\n    |          |\n    |          unsatisfied trait bound introduced here\n+   = note: the following trait bounds were not satisfied:\n+           `&Victim<'_, Self>: VictimTrait`\n+           `&mut Victim<'_, Self>: VictimTrait`\n+help: consider relaxing the type parameter's implicit `Sized` bound\n+   |\n+LL | impl<'a, T: ?Sized + Perpetrator /*+ ?Sized*/> VictimTrait for Victim<'a, T> {\n+   |             ++++++++\n help: consider relaxing the type parameter's implicit `Sized` bound\n    |\n LL | impl<'a, T: ?Sized + Perpetrator /*+ ?Sized*/> VictimTrait for Victim<'a, T> {"}]}