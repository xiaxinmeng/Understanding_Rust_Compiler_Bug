{"sha": "fc15e9f8382353176f53d9837f3d619474759ee1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjMTVlOWY4MzgyMzUzMTc2ZjUzZDk4MzdmM2Q2MTk0NzQ3NTllZTE=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-10-13T14:00:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-10-13T14:00:10Z"}, "message": "Merge pull request #2042 from topecongiro/refactoring\n\nRefactorings", "tree": {"sha": "46271ffa95b92c90f76fdb3cfb59143fa3ab3fb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46271ffa95b92c90f76fdb3cfb59143fa3ab3fb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc15e9f8382353176f53d9837f3d619474759ee1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc15e9f8382353176f53d9837f3d619474759ee1", "html_url": "https://github.com/rust-lang/rust/commit/fc15e9f8382353176f53d9837f3d619474759ee1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc15e9f8382353176f53d9837f3d619474759ee1/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5798fe6e130226cfe0b737bbc5ac8036e759887f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5798fe6e130226cfe0b737bbc5ac8036e759887f", "html_url": "https://github.com/rust-lang/rust/commit/5798fe6e130226cfe0b737bbc5ac8036e759887f"}, {"sha": "c7250d18b1bf4a91cb95535135b3eacf096d8906", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7250d18b1bf4a91cb95535135b3eacf096d8906", "html_url": "https://github.com/rust-lang/rust/commit/c7250d18b1bf4a91cb95535135b3eacf096d8906"}], "stats": {"total": 246, "additions": 107, "deletions": 139}, "files": [{"sha": "38d015322ce68b0d00a43b647f0c90f464c38a21", "filename": "src/chains.rs", "status": "modified", "additions": 47, "deletions": 84, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/fc15e9f8382353176f53d9837f3d619474759ee1/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc15e9f8382353176f53d9837f3d619474759ee1/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=fc15e9f8382353176f53d9837f3d619474759ee1", "patch": "@@ -24,6 +24,15 @@\n /// alignment).\n /// E.g., `let foo = { aaaa; bbb; ccc }.bar.baz();`, we would layout for the\n /// following values of `chain_indent`:\n+/// Block:\n+/// ```\n+/// let foo = {\n+///     aaaa;\n+///     bbb;\n+///     ccc\n+/// }.bar\n+///     .baz();\n+/// ```\n /// Visual:\n /// ```\n /// let foo = {\n@@ -34,46 +43,20 @@\n ///           .bar\n ///           .baz();\n /// ```\n-/// Inherit:\n-/// ```\n-/// let foo = {\n-///     aaaa;\n-///     bbb;\n-///     ccc\n-/// }\n-/// .bar\n-/// .baz();\n-/// ```\n-/// Tabbed:\n-/// ```\n-/// let foo = {\n-///         aaaa;\n-///         bbb;\n-///         ccc\n-///     }\n-///     .bar\n-///     .baz();\n-/// ```\n ///\n /// If the first item in the chain is a block expression, we align the dots with\n /// the braces.\n-/// Visual:\n-/// ```\n-/// let a = foo.bar\n-///            .baz()\n-///            .qux\n-/// ```\n-/// Inherit:\n+/// Block:\n /// ```\n /// let a = foo.bar\n-/// .baz()\n-/// .qux\n+///     .baz()\n+///     .qux\n /// ```\n-/// Tabbed:\n+/// Visual:\n /// ```\n /// let a = foo.bar\n-///     .baz()\n-///     .qux\n+///            .baz()\n+///            .qux\n /// ```\n \n use shape::Shape;\n@@ -182,13 +165,23 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     let all_in_one_line = !parent_rewrite_contains_newline\n         && rewrites.iter().all(|s| !s.contains('\\n'))\n         && almost_total < one_line_budget;\n-    let rewrite_last = || rewrite_chain_subexpr(last_subexpr, total_span, context, nested_shape);\n+    let last_shape = if rewrites.is_empty() {\n+        // We only have a single child.\n+        first_child_shape\n+    } else {\n+        match context.config.chain_indent() {\n+            IndentStyle::Visual => other_child_shape.sub_width(shape.rhs_overhead(context.config))?,\n+            IndentStyle::Block => other_child_shape,\n+        }\n+    };\n+    let last_shape = last_shape.sub_width(suffix_try_num)?;\n+    let rewrite_last = || rewrite_chain_subexpr(last_subexpr, total_span, context, last_shape);\n     let (last_subexpr_str, fits_single_line) = if all_in_one_line || extend_last_subexr {\n         parent_shape.offset_left(almost_total).map(|shape| {\n             if let Some(rw) = rewrite_chain_subexpr(last_subexpr, total_span, context, shape) {\n                 let line_count = rw.lines().count();\n                 let fits_single_line = almost_total + first_line_width(&rw) <= one_line_budget;\n-                if (line_count >= 5 && fits_single_line) || extend_last_subexr {\n+                if fits_single_line && (line_count >= 5 || extend_last_subexr) {\n                     (Some(rw), true)\n                 } else {\n                     match rewrite_last() {\n@@ -229,38 +222,37 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         connector.as_str()\n     };\n \n-    let subexpr_num = subexpr_list.len();\n     let result = if is_small_parent && rewrites.len() > 1 {\n-        let second_connector = choose_first_connector(\n-            context,\n-            &rewrites[0],\n-            &rewrites[1],\n-            &connector,\n-            &subexpr_list[..subexpr_num - 1],\n-            false,\n-        );\n+        let second_connector = if fits_single_line || rewrites[1] == \"?\"\n+            || last_line_extendable(&rewrites[0])\n+            || context.config.chain_indent() == IndentStyle::Visual\n+        {\n+            \"\"\n+        } else {\n+            &connector\n+        };\n         format!(\n             \"{}{}{}{}{}\",\n             parent_rewrite,\n             first_connector,\n             rewrites[0],\n             second_connector,\n-            join_rewrites(&rewrites[1..], &subexpr_list[..subexpr_num - 1], &connector)\n+            join_rewrites(&rewrites[1..], &connector)\n         )\n     } else {\n         format!(\n             \"{}{}{}\",\n             parent_rewrite,\n             first_connector,\n-            join_rewrites(&rewrites, subexpr_list, &connector)\n+            join_rewrites(&rewrites, &connector)\n         )\n     };\n     let result = format!(\"{}{}\", result, repeat_try(suffix_try_num));\n-    wrap_str(result, context.config.max_width(), shape)\n-}\n-\n-fn is_extendable_parent(context: &RewriteContext, parent_str: &str) -> bool {\n-    context.config.chain_indent() == IndentStyle::Block && last_line_extendable(parent_str)\n+    if context.config.chain_indent() == IndentStyle::Visual {\n+        wrap_str(result, context.config.max_width(), shape)\n+    } else {\n+        Some(result)\n+    }\n }\n \n // True if the chain is only `?`s.\n@@ -288,17 +280,14 @@ fn rewrite_try(\n     Some(format!(\"{}{}\", sub_expr, repeat_try(try_count)))\n }\n \n-fn join_rewrites(rewrites: &[String], subexps: &[ast::Expr], connector: &str) -> String {\n+fn join_rewrites(rewrites: &[String], connector: &str) -> String {\n     let mut rewrite_iter = rewrites.iter();\n     let mut result = rewrite_iter.next().unwrap().clone();\n-    let mut subexpr_iter = subexps.iter().rev();\n-    subexpr_iter.next();\n \n-    for (rewrite, expr) in rewrite_iter.zip(subexpr_iter) {\n-        match expr.node {\n-            ast::ExprKind::Try(_) => (),\n-            _ => result.push_str(connector),\n-        };\n+    for rewrite in rewrite_iter {\n+        if rewrite != \"?\" {\n+            result.push_str(connector);\n+        }\n         result.push_str(&rewrite[..]);\n     }\n \n@@ -431,32 +420,6 @@ fn is_try(expr: &ast::Expr) -> bool {\n     }\n }\n \n-fn choose_first_connector<'a>(\n-    context: &RewriteContext,\n-    parent_str: &str,\n-    first_child_str: &str,\n-    connector: &'a str,\n-    subexpr_list: &[ast::Expr],\n-    extend: bool,\n-) -> &'a str {\n-    if subexpr_list.is_empty() {\n-        \"\"\n-    } else if extend || subexpr_list.last().map_or(false, is_try)\n-        || is_extendable_parent(context, parent_str)\n-    {\n-        // 1 = \";\", being conservative here.\n-        if last_line_width(parent_str) + first_line_width(first_child_str) + 1\n-            <= context.config.max_width()\n-        {\n-            \"\"\n-        } else {\n-            connector\n-        }\n-    } else {\n-        connector\n-    }\n-}\n-\n fn rewrite_method_call(\n     method_name: ast::Ident,\n     types: &[ptr::P<ast::Ty>],"}, {"sha": "dbaf1cceefc6f5515e199b5dc9e2941b683b69c1", "filename": "src/expr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc15e9f8382353176f53d9837f3d619474759ee1/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc15e9f8382353176f53d9837f3d619474759ee1/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=fc15e9f8382353176f53d9837f3d619474759ee1", "patch": "@@ -718,9 +718,7 @@ fn rewrite_closure_block(\n             if block_str.matches('\\n').count() <= block_threshold as usize\n                 && !need_block_indent(&block_str, shape)\n             {\n-                if let Some(block_str) = block_str.rewrite(context, shape) {\n-                    return Some(format!(\"{} {}\", prefix, block_str));\n-                }\n+                return Some(format!(\"{} {}\", prefix, block_str));\n             }\n         }\n     }"}, {"sha": "fffbe2b9913ea5a392c81813e1e2eff0b21557ed", "filename": "src/shape.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fc15e9f8382353176f53d9837f3d619474759ee1/src%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc15e9f8382353176f53d9837f3d619474759ee1/src%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshape.rs?ref=fc15e9f8382353176f53d9837f3d619474759ee1", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::borrow::Cow;\n use std::ops::{Add, Sub};\n \n use Config;\n@@ -21,6 +22,10 @@ pub struct Indent {\n     pub alignment: usize,\n }\n \n+// INDENT_BUFFER.len() = 80\n+const INDENT_BUFFER_LEN: usize = 80;\n+const INDENT_BUFFER: &str =\n+    \"                                                                                \";\n impl Indent {\n     pub fn new(block_indent: usize, alignment: usize) -> Indent {\n         Indent {\n@@ -68,21 +73,25 @@ impl Indent {\n         self.block_indent + self.alignment\n     }\n \n-    pub fn to_string(&self, config: &Config) -> String {\n+    pub fn to_string(&self, config: &Config) -> Cow<'static, str> {\n         let (num_tabs, num_spaces) = if config.hard_tabs() {\n             (self.block_indent / config.tab_spaces(), self.alignment)\n         } else {\n             (0, self.width())\n         };\n         let num_chars = num_tabs + num_spaces;\n-        let mut indent = String::with_capacity(num_chars);\n-        for _ in 0..num_tabs {\n-            indent.push('\\t')\n-        }\n-        for _ in 0..num_spaces {\n-            indent.push(' ')\n+        if num_tabs == 0 && num_chars <= INDENT_BUFFER_LEN {\n+            Cow::from(&INDENT_BUFFER[0..num_chars])\n+        } else {\n+            let mut indent = String::with_capacity(num_chars);\n+            for _ in 0..num_tabs {\n+                indent.push('\\t')\n+            }\n+            for _ in 0..num_spaces {\n+                indent.push(' ')\n+            }\n+            Cow::from(indent)\n         }\n-        indent\n     }\n }\n "}, {"sha": "8475b82d69330db7ae0a23d3a1d8065118c72216", "filename": "src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc15e9f8382353176f53d9837f3d619474759ee1/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc15e9f8382353176f53d9837f3d619474759ee1/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=fc15e9f8382353176f53d9837f3d619474759ee1", "patch": "@@ -550,7 +550,7 @@ impl Rewrite for ast::TyParamBounds {\n         let strs = self.iter()\n             .map(|b| b.rewrite(context, shape))\n             .collect::<Option<Vec<_>>>()?;\n-        join_bounds(context, shape, &strs).rewrite(context, shape)\n+        Some(join_bounds(context, shape, &strs))\n     }\n }\n \n@@ -660,7 +660,7 @@ impl Rewrite for ast::Ty {\n                             mut_str,\n                             mt.ty.rewrite(\n                                 context,\n-                                Shape::legacy(budget, shape.indent + 1 + mut_len),\n+                                Shape::legacy(budget, shape.indent + 1 + mut_len)\n                             )?\n                         )\n                     }"}, {"sha": "3106df9ed8b2ff8f703085b491c5ed2fba7f4d0d", "filename": "src/utils.rs", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/fc15e9f8382353176f53d9837f3d619474759ee1/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc15e9f8382353176f53d9837f3d619474759ee1/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=fc15e9f8382353176f53d9837f3d619474759ee1", "patch": "@@ -15,7 +15,7 @@ use syntax::ast::{self, Attribute, MetaItem, MetaItemKind, NestedMetaItem, Neste\n                   Path, Visibility};\n use syntax::codemap::{BytePos, Span, NO_EXPANSION};\n \n-use rewrite::{Rewrite, RewriteContext};\n+use rewrite::RewriteContext;\n use shape::Shape;\n \n // When we get scoped annotations, we should have rustfmt::skip.\n@@ -171,12 +171,18 @@ pub fn trimmed_last_line_width(s: &str) -> usize {\n \n #[inline]\n pub fn last_line_extendable(s: &str) -> bool {\n-    s.lines().last().map_or(false, |s| {\n-        s.ends_with(\"\\\"#\")\n-            || s.trim()\n-                .chars()\n-                .all(|c| c == ')' || c == ']' || c == '}' || c == '?')\n-    })\n+    if s.ends_with(\"\\\"#\") {\n+        return true;\n+    }\n+    for c in s.chars().rev() {\n+        match c {\n+            ')' | ']' | '}' | '?' => continue,\n+            '\\n' => break,\n+            _ if c.is_whitespace() => continue,\n+            _ => return false,\n+        }\n+    }\n+    true\n }\n \n #[inline]\n@@ -390,45 +396,37 @@ macro_rules! skip_out_of_file_lines_range_visitor {\n     }\n }\n \n-// Wraps string-like values in an Option. Returns Some when the string adheres\n-// to the Rewrite constraints defined for the Rewrite trait and else otherwise.\n-pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, shape: Shape) -> Option<S> {\n-    {\n-        let snippet = s.as_ref();\n-\n-        if !snippet.is_empty() {\n-            if !snippet.contains('\\n') && snippet.len() > shape.width {\n-                return None;\n-            } else {\n-                let mut lines = snippet.lines();\n-\n-                if lines.next().unwrap().len() > shape.width {\n-                    return None;\n-                }\n-\n-                // The other lines must fit within the maximum width.\n-                if lines.any(|line| line.len() > max_width) {\n-                    return None;\n-                }\n-\n-                // `width` is the maximum length of the last line, excluding\n-                // indentation.\n-                // A special check for the last line, since the caller may\n-                // place trailing characters on this line.\n-                if snippet.lines().rev().next().unwrap().len() > shape.used_width() + shape.width {\n-                    return None;\n-                }\n-            }\n-        }\n+// Wraps String in an Option. Returns Some when the string adheres to the\n+// Rewrite constraints defined for the Rewrite trait and else otherwise.\n+pub fn wrap_str(s: String, max_width: usize, shape: Shape) -> Option<String> {\n+    if is_valid_str(&s, max_width, shape) {\n+        Some(s)\n+    } else {\n+        None\n     }\n-\n-    Some(s)\n }\n \n-impl Rewrite for String {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        wrap_str(self, context.config.max_width(), shape).map(ToOwned::to_owned)\n+fn is_valid_str(snippet: &str, max_width: usize, shape: Shape) -> bool {\n+    if !snippet.is_empty() {\n+        // First line must fits with `shape.width`.\n+        if first_line_width(snippet) > shape.width {\n+            return false;\n+        }\n+        // If the snippet does not include newline, we are done.\n+        if first_line_width(snippet) == snippet.len() {\n+            return true;\n+        }\n+        // The other lines must fit within the maximum width.\n+        if snippet.lines().skip(1).any(|line| line.len() > max_width) {\n+            return false;\n+        }\n+        // A special check for the last line, since the caller may\n+        // place trailing characters on this line.\n+        if last_line_width(snippet) > shape.used_width() + shape.width {\n+            return false;\n+        }\n     }\n+    true\n }\n \n #[inline]"}]}