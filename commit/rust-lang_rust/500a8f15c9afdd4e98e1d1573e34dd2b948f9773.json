{"sha": "500a8f15c9afdd4e98e1d1573e34dd2b948f9773", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwMGE4ZjE1YzlhZmRkNGU5OGUxZDE1NzNlMzRkZDJiOTQ4Zjk3NzM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-11-18T21:25:09Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-11-19T02:27:30Z"}, "message": "libstd: Change all `~fn()`s to `proc`s in the standard library.\n\nThis makes `Cell`s no longer necessary in most cases.", "tree": {"sha": "37d9a289e563155bfd15c3dc79af525cf7a88d7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37d9a289e563155bfd15c3dc79af525cf7a88d7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/500a8f15c9afdd4e98e1d1573e34dd2b948f9773", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/500a8f15c9afdd4e98e1d1573e34dd2b948f9773", "html_url": "https://github.com/rust-lang/rust/commit/500a8f15c9afdd4e98e1d1573e34dd2b948f9773", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fc3e82aaeb15c067a1eed914032ba21a7763557", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fc3e82aaeb15c067a1eed914032ba21a7763557", "html_url": "https://github.com/rust-lang/rust/commit/7fc3e82aaeb15c067a1eed914032ba21a7763557"}], "stats": {"total": 174, "additions": 92, "deletions": 82}, "files": [{"sha": "438261ba8a0a3fc40951806dabe28a9bc242b9ec", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=500a8f15c9afdd4e98e1d1573e34dd2b948f9773", "patch": "@@ -157,7 +157,7 @@ mod tests {\n     use io::*;\n     use rt::comm::oneshot;\n \n-    fn smalltest(server: ~fn(UnixStream), client: ~fn(UnixStream)) {\n+    fn smalltest(server: proc(UnixStream), client: proc(UnixStream)) {\n         let server = Cell::new(server);\n         let client = Cell::new(client);\n         do run_in_mt_newsched_task {"}, {"sha": "9769739b966b15ce60a335d3930af517ff3e69a1", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=500a8f15c9afdd4e98e1d1573e34dd2b948f9773", "patch": "@@ -478,11 +478,11 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_closure_ptr(&mut self, ck: uint) -> bool {\n-        self.align_to::<~fn()>();\n+        self.align_to::<proc()>();\n         if ! self.inner.visit_closure_ptr(ck) {\n             return false\n         }\n-        self.bump_past::<~fn()>();\n+        self.bump_past::<proc()>();\n         true\n     }\n }"}, {"sha": "39a3e4d57abb3ad2ad13e0edfbeee4fa08e35efa", "filename": "src/libstd/rt/context.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcontext.rs?ref=500a8f15c9afdd4e98e1d1573e34dd2b948f9773", "patch": "@@ -25,7 +25,7 @@ pub static RED_ZONE: uint = 20 * 1024;\n // then misalign the regs again.\n pub struct Context {\n     /// The context entry point, saved here for later destruction\n-    priv start: Option<~~fn()>,\n+    priv start: Option<~proc()>,\n     /// Hold the registers while the task or scheduler is suspended\n     priv regs: ~Registers,\n     /// Lower bound and upper bound for the stack\n@@ -41,18 +41,24 @@ impl Context {\n         }\n     }\n \n-    /// Create a new context that will resume execution by running ~fn()\n-    pub fn new(start: ~fn(), stack: &mut StackSegment) -> Context {\n+    /// Create a new context that will resume execution by running proc()\n+    pub fn new(start: proc(), stack: &mut StackSegment) -> Context {\n         // FIXME #7767: Putting main into a ~ so it's a thin pointer and can\n         // be passed to the spawn function.  Another unfortunate\n         // allocation\n         let start = ~start;\n \n         // The C-ABI function that is the task entry point\n-        extern fn task_start_wrapper(f: &~fn()) { (*f)() }\n+        extern fn task_start_wrapper(f: &proc()) {\n+            // XXX(pcwalton): This may be sketchy.\n+            unsafe {\n+                let f: &|| = transmute(f);\n+                (*f)()\n+            }\n+        }\n \n         let fp: *c_void = task_start_wrapper as *c_void;\n-        let argp: *c_void = unsafe { transmute::<&~fn(), *c_void>(&*start) };\n+        let argp: *c_void = unsafe { transmute::<&proc(), *c_void>(&*start) };\n         let sp: *uint = stack.end();\n         let sp: *mut uint = unsafe { transmute_mut_unsafe(sp) };\n         // Save and then immediately load the current context,"}, {"sha": "f7abc33ce142d5c650aba7083137c856f0e960f2", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=500a8f15c9afdd4e98e1d1573e34dd2b948f9773", "patch": "@@ -110,7 +110,7 @@ see a failure from the grandchild task. While we could achieve this by having\n each intermediate task block on its handle, this keeps around the other resources\n the task was using. To be more efficient, this is accomplished via \"tombstones\".\n \n-A tombstone is a closure, ~fn() -> bool, which will perform any waiting necessary\n+A tombstone is a closure, proc() -> bool, which will perform any waiting necessary\n to collect the exit code of descendant tasks. In its environment is captured\n the KillHandle of whichever task created the tombstone, and perhaps also any\n tombstones that that task itself had, and finally also another tombstone,\n@@ -205,7 +205,7 @@ struct KillHandleInner {\n     // Locklessly accessed; protected by the enclosing refcount's barriers.\n     any_child_failed: bool,\n     // A lazy list, consuming which may unwrap() many child tombstones.\n-    child_tombstones: Option<~fn() -> bool>,\n+    child_tombstones: Option<proc() -> bool>,\n     // Protects multiple children simultaneously creating tombstones.\n     graveyard_lock: LittleLock,\n }\n@@ -223,7 +223,7 @@ pub struct Death {\n     priv watching_parent: Option<KillHandle>,\n     // Action to be done with the exit code. If set, also makes the task wait\n     // until all its watched children exit before collecting the status.\n-    on_exit:         Option<~fn(UnwindResult)>,\n+    on_exit:         Option<proc(UnwindResult)>,\n     // nesting level counter for task::unkillable calls (0 == killable).\n     priv unkillable:      int,\n     // nesting level counter for unstable::atomically calls (0 == can deschedule).\n@@ -525,7 +525,8 @@ impl KillHandle {\n         // NB: Takes a pthread mutex -- 'blk' not allowed to reschedule.\n         #[inline]\n         fn add_lazy_tombstone(parent: &mut KillHandle,\n-                              blk: &fn(Option<~fn() -> bool>) -> ~fn() -> bool) {\n+                              blk: &fn(Option<proc() -> bool>)\n+                              -> proc() -> bool) {\n \n             let inner: &mut KillHandleInner = unsafe { &mut *parent.get() };\n             unsafe {"}, {"sha": "72e1f6a6e8faca825aff3dbb84a580580216d0e5", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=500a8f15c9afdd4e98e1d1573e34dd2b948f9773", "patch": "@@ -207,7 +207,7 @@ pub mod borrowck;\n /// # Return value\n ///\n /// The return value is used as the process return code. 0 on success, 101 on error.\n-pub fn start(argc: int, argv: **u8, main: ~fn()) -> int {\n+pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n \n     init(argc, argv);\n     let exit_code = run(main);\n@@ -221,7 +221,7 @@ pub fn start(argc: int, argv: **u8, main: ~fn()) -> int {\n ///\n /// This is appropriate for running code that must execute on the main thread,\n /// such as the platform event loop and GUI.\n-pub fn start_on_main_thread(argc: int, argv: **u8, main: ~fn()) -> int {\n+pub fn start_on_main_thread(argc: int, argv: **u8, main: proc()) -> int {\n     init(argc, argv);\n     let exit_code = run_on_main_thread(main);\n     cleanup();\n@@ -254,15 +254,15 @@ pub fn cleanup() {\n /// Configures the runtime according to the environment, by default\n /// using a task scheduler with the same number of threads as cores.\n /// Returns a process exit code.\n-pub fn run(main: ~fn()) -> int {\n+pub fn run(main: proc()) -> int {\n     run_(main, false)\n }\n \n-pub fn run_on_main_thread(main: ~fn()) -> int {\n+pub fn run_on_main_thread(main: proc()) -> int {\n     run_(main, true)\n }\n \n-fn run_(main: ~fn(), use_main_sched: bool) -> int {\n+fn run_(main: proc(), use_main_sched: bool) -> int {\n     static DEFAULT_ERROR_CODE: int = 101;\n \n     let nscheds = util::default_sched_threads();\n@@ -341,7 +341,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n     // When the main task exits, after all the tasks in the main\n     // task tree, shut down the schedulers and set the exit code.\n     let handles = Cell::new(handles);\n-    let on_exit: ~fn(UnwindResult) = |exit_success| {\n+    let on_exit: proc(UnwindResult) = |exit_success| {\n         unsafe {\n             assert!(!(*exited_already.get()).swap(true, SeqCst),\n                     \"the runtime already exited\");"}, {"sha": "00895289b6a9896d258e14c65ef1a15b982af2b8", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=500a8f15c9afdd4e98e1d1573e34dd2b948f9773", "patch": "@@ -990,7 +990,9 @@ mod test {\n                 assert!(Task::on_appropriate_sched());\n             };\n \n-            let on_exit: ~fn(UnwindResult) = |exit_status| rtassert!(exit_status.is_success());\n+            let on_exit: proc(UnwindResult) = |exit_status| {\n+                rtassert!(exit_status.is_success())\n+            };\n             task.death.on_exit = Some(on_exit);\n \n             sched.bootstrap(task);"}, {"sha": "6d3eec9a9213b0be3d96dece27f50ad8af963841", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=500a8f15c9afdd4e98e1d1573e34dd2b948f9773", "patch": "@@ -139,7 +139,10 @@ impl Task {\n \n     // A helper to build a new task using the dynamically found\n     // scheduler and task. Only works in GreenTask context.\n-    pub fn build_homed_child(stack_size: Option<uint>, f: ~fn(), home: SchedHome) -> ~Task {\n+    pub fn build_homed_child(stack_size: Option<uint>,\n+                             f: proc(),\n+                             home: SchedHome)\n+                             -> ~Task {\n         let f = Cell::new(f);\n         let home = Cell::new(home);\n         do Local::borrow |running_task: &mut Task| {\n@@ -153,11 +156,14 @@ impl Task {\n         }\n     }\n \n-    pub fn build_child(stack_size: Option<uint>, f: ~fn()) -> ~Task {\n+    pub fn build_child(stack_size: Option<uint>, f: proc()) -> ~Task {\n         Task::build_homed_child(stack_size, f, AnySched)\n     }\n \n-    pub fn build_homed_root(stack_size: Option<uint>, f: ~fn(), home: SchedHome) -> ~Task {\n+    pub fn build_homed_root(stack_size: Option<uint>,\n+                            f: proc(),\n+                            home: SchedHome)\n+                            -> ~Task {\n         let f = Cell::new(f);\n         let home = Cell::new(home);\n         do Local::borrow |running_task: &mut Task| {\n@@ -171,7 +177,7 @@ impl Task {\n         }\n     }\n \n-    pub fn build_root(stack_size: Option<uint>, f: ~fn()) -> ~Task {\n+    pub fn build_root(stack_size: Option<uint>, f: proc()) -> ~Task {\n         Task::build_homed_root(stack_size, f, AnySched)\n     }\n \n@@ -196,21 +202,21 @@ impl Task {\n \n     pub fn new_root(stack_pool: &mut StackPool,\n                     stack_size: Option<uint>,\n-                    start: ~fn()) -> Task {\n+                    start: proc()) -> Task {\n         Task::new_root_homed(stack_pool, stack_size, AnySched, start)\n     }\n \n     pub fn new_child(&mut self,\n                      stack_pool: &mut StackPool,\n                      stack_size: Option<uint>,\n-                     start: ~fn()) -> Task {\n+                     start: proc()) -> Task {\n         self.new_child_homed(stack_pool, stack_size, AnySched, start)\n     }\n \n     pub fn new_root_homed(stack_pool: &mut StackPool,\n                           stack_size: Option<uint>,\n                           home: SchedHome,\n-                          start: ~fn()) -> Task {\n+                          start: proc()) -> Task {\n         Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n@@ -233,7 +239,7 @@ impl Task {\n                            stack_pool: &mut StackPool,\n                            stack_size: Option<uint>,\n                            home: SchedHome,\n-                           start: ~fn()) -> Task {\n+                           start: proc()) -> Task {\n         Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n@@ -404,7 +410,10 @@ impl Drop for Task {\n \n impl Coroutine {\n \n-    pub fn new(stack_pool: &mut StackPool, stack_size: Option<uint>, start: ~fn()) -> Coroutine {\n+    pub fn new(stack_pool: &mut StackPool,\n+               stack_size: Option<uint>,\n+               start: proc())\n+               -> Coroutine {\n         let stack_size = match stack_size {\n             Some(size) => size,\n             None => env::min_stack()\n@@ -425,9 +434,9 @@ impl Coroutine {\n         }\n     }\n \n-    fn build_start_wrapper(start: ~fn()) -> ~fn() {\n+    fn build_start_wrapper(start: proc()) -> proc() {\n         let start_cell = Cell::new(start);\n-        let wrapper: ~fn() = || {\n+        let wrapper: proc() = || {\n             // First code after swap to this new context. Run our\n             // cleanup job.\n             unsafe {"}, {"sha": "53e504fe8fb8d5bcab29687a1d767f769a1aa683", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=500a8f15c9afdd4e98e1d1573e34dd2b948f9773", "patch": "@@ -65,28 +65,28 @@ pub fn new_test_sched() -> Scheduler {\n     return sched;\n }\n \n-pub fn run_in_uv_task(f: ~fn()) {\n+pub fn run_in_uv_task(f: proc()) {\n     let f = Cell::new(f);\n     do run_in_bare_thread {\n         run_in_uv_task_core(f.take());\n     }\n }\n \n-pub fn run_in_newsched_task(f: ~fn()) {\n+pub fn run_in_newsched_task(f: proc()) {\n     let f = Cell::new(f);\n     do run_in_bare_thread {\n         run_in_newsched_task_core(f.take());\n     }\n }\n \n-pub fn run_in_uv_task_core(f: ~fn()) {\n+pub fn run_in_uv_task_core(f: proc()) {\n \n     use rt::sched::Shutdown;\n \n     let mut sched = ~new_test_uv_sched();\n     let exit_handle = Cell::new(sched.make_handle());\n \n-    let on_exit: ~fn(UnwindResult) = |exit_status| {\n+    let on_exit: proc(UnwindResult) = |exit_status| {\n         exit_handle.take().send(Shutdown);\n         rtassert!(exit_status.is_success());\n     };\n@@ -96,13 +96,13 @@ pub fn run_in_uv_task_core(f: ~fn()) {\n     sched.bootstrap(task);\n }\n \n-pub fn run_in_newsched_task_core(f: ~fn()) {\n+pub fn run_in_newsched_task_core(f: proc()) {\n     use rt::sched::Shutdown;\n \n     let mut sched = ~new_test_sched();\n     let exit_handle = Cell::new(sched.make_handle());\n \n-    let on_exit: ~fn(UnwindResult) = |exit_status| {\n+    let on_exit: proc(UnwindResult) = |exit_status| {\n         exit_handle.take().send(Shutdown);\n         rtassert!(exit_status.is_success());\n     };\n@@ -196,7 +196,7 @@ pub fn prepare_for_lots_of_tests() {\n /// Create more than one scheduler and run a function in a task\n /// in one of the schedulers. The schedulers will stay alive\n /// until the function `f` returns.\n-pub fn run_in_mt_newsched_task(f: ~fn()) {\n+pub fn run_in_mt_newsched_task(f: proc()) {\n     use os;\n     use from_str::FromStr;\n     use rt::sched::Shutdown;\n@@ -246,7 +246,7 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n         }\n \n         let handles = Cell::new(handles);\n-        let on_exit: ~fn(UnwindResult) = |exit_status| {\n+        let on_exit: proc(UnwindResult) = |exit_status| {\n             let mut handles = handles.take();\n             // Tell schedulers to exit\n             for handle in handles.mut_iter() {\n@@ -295,16 +295,16 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n }\n \n /// Test tasks will abort on failure instead of unwinding\n-pub fn spawntask(f: ~fn()) {\n+pub fn spawntask(f: proc()) {\n     Scheduler::run_task(Task::build_child(None, f));\n }\n \n /// Create a new task and run it right now. Aborts on failure\n-pub fn spawntask_later(f: ~fn()) {\n+pub fn spawntask_later(f: proc()) {\n     Scheduler::run_task_later(Task::build_child(None, f));\n }\n \n-pub fn spawntask_random(f: ~fn()) {\n+pub fn spawntask_random(f: proc()) {\n     use rand::{Rand, rng};\n \n     let mut rng = rng();\n@@ -317,11 +317,11 @@ pub fn spawntask_random(f: ~fn()) {\n     }\n }\n \n-pub fn spawntask_try(f: ~fn()) -> Result<(),()> {\n+pub fn spawntask_try(f: proc()) -> Result<(),()> {\n \n     let (port, chan) = oneshot();\n     let chan = Cell::new(chan);\n-    let on_exit: ~fn(UnwindResult) = |exit_status| chan.take().send(exit_status);\n+    let on_exit: proc(UnwindResult) = |exit_status| chan.take().send(exit_status);\n \n     let mut new_task = Task::build_root(None, f);\n     new_task.death.on_exit = Some(on_exit);\n@@ -334,7 +334,7 @@ pub fn spawntask_try(f: ~fn()) -> Result<(),()> {\n }\n \n /// Spawn a new task in a new scheduler and return a thread handle.\n-pub fn spawntask_thread(f: ~fn()) -> Thread {\n+pub fn spawntask_thread(f: proc()) -> Thread {\n \n     let f = Cell::new(f);\n \n@@ -346,7 +346,7 @@ pub fn spawntask_thread(f: ~fn()) -> Thread {\n }\n \n /// Get a ~Task for testing purposes other than actually scheduling it.\n-pub fn with_test_task(blk: ~fn(~Task) -> ~Task) {\n+pub fn with_test_task(blk: proc(~Task) -> ~Task) {\n     do run_in_bare_thread {\n         let mut sched = ~new_test_sched();\n         let task = blk(~Task::new_root(&mut sched.stack_pool, None, ||{}));"}, {"sha": "e364e5a6603f455361cee52833b92662a036ae41", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=500a8f15c9afdd4e98e1d1573e34dd2b948f9773", "patch": "@@ -35,7 +35,7 @@ static DEFAULT_STACK_SIZE: libc::size_t = 1024*1024;\n \n impl Thread {\n \n-    pub fn start(main: ~fn()) -> Thread {\n+    pub fn start(main: proc()) -> Thread {\n         // This is the starting point of rust os threads. The first thing we do\n         // is make sure that we don't trigger __morestack (also why this has a\n         // no_split_stack annotation), and then we extract the main function\n@@ -45,7 +45,7 @@ impl Thread {\n             use rt::context;\n             unsafe {\n                 context::record_stack_bounds(0, uint::max_value);\n-                let f: ~~fn() = cast::transmute(trampoline);\n+                let f: ~proc() = cast::transmute(trampoline);\n                 (*f)();\n             }\n             unsafe { cast::transmute(0) }\n@@ -67,7 +67,7 @@ impl Thread {\n \n #[cfg(windows)]\n fn native_thread_create(thread_start: extern \"C\" fn(*libc::c_void) -> rust_thread_return,\n-                        tramp: ~~fn()) -> rust_thread {\n+                        tramp: ~proc()) -> rust_thread {\n     unsafe {\n         let ptr: *mut libc::c_void = cast::transmute(tramp);\n         CreateThread(ptr::mut_null(), DEFAULT_STACK_SIZE, thread_start, ptr, 0, ptr::mut_null())\n@@ -82,7 +82,7 @@ fn native_thread_join(native: rust_thread) {\n \n #[cfg(unix)]\n fn native_thread_create(thread_start: extern \"C\" fn(*libc::c_void) -> rust_thread_return,\n-                        tramp: ~~fn()) -> rust_thread {\n+                        tramp: ~proc()) -> rust_thread {\n     use unstable::intrinsics;\n     let mut native: libc::pthread_t = unsafe { intrinsics::uninit() };\n "}, {"sha": "a81f30c9a90211701d5aee0c706eafd87017b895", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=500a8f15c9afdd4e98e1d1573e34dd2b948f9773", "patch": "@@ -195,7 +195,7 @@ pub struct TaskOpts {\n // FIXME (#3724): Replace the 'consumed' bit with move mode on self\n pub struct TaskBuilder {\n     opts: TaskOpts,\n-    priv gen_body: Option<~fn(v: ~fn()) -> ~fn()>,\n+    priv gen_body: Option<proc(v: proc()) -> proc()>,\n     priv can_not_copy: Option<util::NonCopyable>,\n     priv consumed: bool,\n }\n@@ -340,18 +340,18 @@ impl TaskBuilder {\n      * generator by applying the task body which results from the\n      * existing body generator to the new body generator.\n      */\n-    pub fn add_wrapper(&mut self, wrapper: ~fn(v: ~fn()) -> ~fn()) {\n+    pub fn add_wrapper(&mut self, wrapper: proc(v: proc()) -> proc()) {\n         let prev_gen_body = self.gen_body.take();\n         let prev_gen_body = match prev_gen_body {\n             Some(gen) => gen,\n             None => {\n-                let f: ~fn(~fn()) -> ~fn() = |body| body;\n+                let f: proc(proc()) -> proc() = |body| body;\n                 f\n             }\n         };\n         let prev_gen_body = Cell::new(prev_gen_body);\n         let next_gen_body = {\n-            let f: ~fn(~fn()) -> ~fn() = |body| {\n+            let f: proc(proc()) -> proc() = |body| {\n                 let prev_gen_body = prev_gen_body.take();\n                 wrapper(prev_gen_body(body))\n             };\n@@ -372,7 +372,7 @@ impl TaskBuilder {\n      * When spawning into a new scheduler, the number of threads requested\n      * must be greater than zero.\n      */\n-    pub fn spawn(&mut self, f: ~fn()) {\n+    pub fn spawn(&mut self, f: proc()) {\n         let gen_body = self.gen_body.take();\n         let notify_chan = self.opts.notify_chan.take();\n         let name = self.opts.name.take();\n@@ -399,7 +399,7 @@ impl TaskBuilder {\n     }\n \n     /// Runs a task, while transferring ownership of one argument to the child.\n-    pub fn spawn_with<A:Send>(&mut self, arg: A, f: ~fn(v: A)) {\n+    pub fn spawn_with<A:Send>(&mut self, arg: A, f: proc(v: A)) {\n         let arg = Cell::new(arg);\n         do self.spawn {\n             f(arg.take());\n@@ -419,7 +419,7 @@ impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    pub fn try<T:Send>(&mut self, f: ~fn() -> T) -> Result<T, ~Any> {\n+    pub fn try<T:Send>(&mut self, f: proc() -> T) -> Result<T, ~Any> {\n         let (po, ch) = stream::<T>();\n \n         let result = self.future_result();\n@@ -468,20 +468,20 @@ pub fn default_task_opts() -> TaskOpts {\n /// the provided unique closure.\n ///\n /// This function is equivalent to `task().spawn(f)`.\n-pub fn spawn(f: ~fn()) {\n+pub fn spawn(f: proc()) {\n     let mut task = task();\n     task.spawn(f)\n }\n \n /// Creates a child task unlinked from the current one. If either this\n /// task or the child task fails, the other will not be killed.\n-pub fn spawn_unlinked(f: ~fn()) {\n+pub fn spawn_unlinked(f: proc()) {\n     let mut task = task();\n     task.unlinked();\n     task.spawn(f)\n }\n \n-pub fn spawn_supervised(f: ~fn()) {\n+pub fn spawn_supervised(f: proc()) {\n     /*!\n      * Creates a child task supervised by the current one. If the child\n      * task fails, the parent will not be killed, but if the parent fails,\n@@ -498,13 +498,13 @@ pub fn spawn_supervised(f: ~fn()) {\n /// (Note that this convenience wrapper still uses linked-failure, so the\n /// child's children will still be killable by the parent. For the fastest\n /// possible spawn mode, use task::task().unlinked().indestructible().spawn.)\n-pub fn spawn_indestructible(f: ~fn()) {\n+pub fn spawn_indestructible(f: proc()) {\n     let mut task = task();\n     task.indestructible();\n     task.spawn(f)\n }\n \n-pub fn spawn_with<A:Send>(arg: A, f: ~fn(v: A)) {\n+pub fn spawn_with<A:Send>(arg: A, f: proc(v: A)) {\n     /*!\n      * Runs a task, while transferring ownership of one argument to the\n      * child.\n@@ -519,7 +519,7 @@ pub fn spawn_with<A:Send>(arg: A, f: ~fn(v: A)) {\n     task.spawn_with(arg, f)\n }\n \n-pub fn spawn_sched(mode: SchedMode, f: ~fn()) {\n+pub fn spawn_sched(mode: SchedMode, f: proc()) {\n     /*!\n      * Creates a new task on a new or existing scheduler.\n      *\n@@ -537,7 +537,7 @@ pub fn spawn_sched(mode: SchedMode, f: ~fn()) {\n     task.spawn(f)\n }\n \n-pub fn try<T:Send>(f: ~fn() -> T) -> Result<T, ~Any> {\n+pub fn try<T:Send>(f: proc() -> T) -> Result<T, ~Any> {\n     /*!\n      * Execute a function in another task and return either the return value\n      * of the function or result::err.\n@@ -1033,7 +1033,7 @@ fn test_add_wrapper() {\n     let ch = Cell::new(ch);\n     do b0.add_wrapper |body| {\n         let ch = Cell::new(ch.take());\n-        let result: ~fn() = || {\n+        let result: proc() = || {\n             let ch = ch.take();\n             body();\n             ch.send(());\n@@ -1211,7 +1211,7 @@ fn test_spawn_sched_blocking() {\n }\n \n #[cfg(test)]\n-fn avoid_copying_the_body(spawnfn: &fn(v: ~fn())) {\n+fn avoid_copying_the_body(spawnfn: &fn(v: proc())) {\n     let (p, ch) = stream::<uint>();\n \n     let x = ~1;\n@@ -1337,7 +1337,7 @@ fn test_child_doesnt_ref_parent() {\n     // (well, it would if the constant were 8000+ - I lowered it to be more\n     // valgrind-friendly. try this at home, instead..!)\n     static generations: uint = 16;\n-    fn child_no(x: uint) -> ~fn() {\n+    fn child_no(x: uint) -> proc() {\n         return || {\n             if x < generations {\n                 let mut t = task();"}, {"sha": "d7d3e715ef9cab219cb67efdf198816a20afe94a", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=500a8f15c9afdd4e98e1d1573e34dd2b948f9773", "patch": "@@ -562,13 +562,13 @@ fn enlist_many(child: &KillHandle, child_arc: &TaskGroupArc,\n     result\n }\n \n-pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n+pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n     assert!(in_green_task_context());\n \n     let child_data = Cell::new(gen_child_taskgroup(opts.linked, opts.supervised));\n     let indestructible = opts.indestructible;\n \n-    let child_wrapper: ~fn() = || {\n+    let child_wrapper: proc() = || {\n         // Child task runs this code.\n \n         // If child data is 'None', the enlist is vacuously successful.\n@@ -589,12 +589,14 @@ pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n                 }\n             }\n         };\n+\n         // Should be run after the local-borrowed task is returned.\n+        let f_cell = Cell::new(f);\n         if enlist_success {\n             if indestructible {\n-                do unkillable { f() }\n+                do unkillable { f_cell.take()() }\n             } else {\n-                f()\n+                f_cell.take()()\n             }\n         }\n     };\n@@ -683,7 +685,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n     if opts.notify_chan.is_some() {\n         let notify_chan = opts.notify_chan.take_unwrap();\n         let notify_chan = Cell::new(notify_chan);\n-        let on_exit: ~fn(UnwindResult) = |task_result| {\n+        let on_exit: proc(UnwindResult) = |task_result| {\n             notify_chan.take().send(task_result)\n         };\n         task.death.on_exit = Some(on_exit);"}, {"sha": "266a619c710371138d6df0a93ad9495d01328b97", "filename": "src/libstd/unstable/finally.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Ffinally.rs?ref=500a8f15c9afdd4e98e1d1573e34dd2b948f9773", "patch": "@@ -54,7 +54,6 @@ impl<'self,T> Finally<T> for &'self fn() -> T {\n     }\n }\n \n-finally_fn!(~fn() -> T)\n finally_fn!(extern \"Rust\" fn() -> T)\n \n struct Finallyalizer<'self> {\n@@ -109,12 +108,3 @@ fn test_compact() {\n         but_always_run_this_function);\n }\n \n-#[test]\n-fn test_owned() {\n-    fn spawn_with_finalizer(f: ~fn()) {\n-        do spawn { do f.finally { } }\n-    }\n-    let owned: ~fn() = || { };\n-    spawn_with_finalizer(owned);\n-}\n-"}, {"sha": "d1ac5611e6ecb7eb5a8fbd9328eb8840ee4279b6", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500a8f15c9afdd4e98e1d1573e34dd2b948f9773/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=500a8f15c9afdd4e98e1d1573e34dd2b948f9773", "patch": "@@ -35,7 +35,7 @@ for it to terminate.\n The executing thread has no access to a task pointer and will be using\n a normal large stack.\n */\n-pub fn run_in_bare_thread(f: ~fn()) {\n+pub fn run_in_bare_thread(f: proc()) {\n     use cell::Cell;\n     use rt::thread::Thread;\n "}]}