{"sha": "30bf20a692df794c9c639ef7153115b7db5aade5", "node_id": "C_kwDOAAsO6NoAKDMwYmYyMGE2OTJkZjc5NGM5YzYzOWVmNzE1MzExNWI3ZGI1YWFkZTU", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-05-19T13:03:43Z"}, "committer": {"name": "Alan Egerton", "email": "eggyal@gmail.com", "date": "2021-11-26T07:38:25Z"}, "message": "Unwrap the results of type folders\n\nCo-authored-by: Alan Egerton <eggyal@gmail.com>", "tree": {"sha": "d8b2dc8a6b9140b287866f074ace120015e6348d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8b2dc8a6b9140b287866f074ace120015e6348d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30bf20a692df794c9c639ef7153115b7db5aade5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEm/Nz5g9hEBdpmKVOB8rDzKfgZD8FAmGgjwoACgkQB8rDzKfg\nZD+lLQ//TONYYcX59FPQ6Z8fsIhFoYO0PEci/oghvTlaDBx200BMUHWNaJJLGDQI\nDeKNPv/hJyuaaJsRFrslxef+KMr/X790iYOgt05OtMrC/HssargKK4pRzRr7gEJ1\nFPnVVwEsoPhlLkQjdnjYrGdoUfbeClAy0+M0Y7m8A2XBh2IBhcHo4JyDlssK4Op6\nI7n/y3/INCiC8pvbDVSUh80GP6cRoTef5432faxnVP3mue2u33Kr9c5HwDcVPclI\njAwUEcesVIIPsICMVjLASgT6tRdBWY3qK0FBTtLuoaCCIsEB1G6DqmsWon5aWECh\nrV5J6on4dDNZDZSxTltik7g03360/B2J3pLCSRkT5wfP/79XwylhvdcgKS1fQCy/\nuVTjSoFfqs1B41A5RuJ3cQhs6edn5BcxK5H14NTf9gsLJ2Bva32x37jzyBf1nEr+\nkYcglEujX4+mwsaTWvGsJW4wiP1xU3VIEgWfjCjQSMewHeV/9eusXnnIE3bSZENv\nMiCxN2ibttX9d2OLz7KFgpTwmJqvVI7SQn2alBzqSHZ1IRyPkmDYegoE0oIe+ZNX\nS1n9kWM3F6lazqPep35tu5Ziy+GEUzCzUqidloh3mfR9729TNBZlVWO8p74tGdLs\nctXjEqVZqIWBLz8OYfhvZ/z6zhdc/TPlB6zmltCApStfpcvdwkk=\n=zPSQ\n-----END PGP SIGNATURE-----", "payload": "tree d8b2dc8a6b9140b287866f074ace120015e6348d\nparent 6dc3dae46f600efe75627a7ad386e7462066e34d\nauthor LeSeulArtichaut <leseulartichaut@gmail.com> 1621429423 +0200\ncommitter Alan Egerton <eggyal@gmail.com> 1637912305 +0000\n\nUnwrap the results of type folders\n\nCo-authored-by: Alan Egerton <eggyal@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30bf20a692df794c9c639ef7153115b7db5aade5", "html_url": "https://github.com/rust-lang/rust/commit/30bf20a692df794c9c639ef7153115b7db5aade5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30bf20a692df794c9c639ef7153115b7db5aade5/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eggyal", "id": 3089613, "node_id": "MDQ6VXNlcjMwODk2MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3089613?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eggyal", "html_url": "https://github.com/eggyal", "followers_url": "https://api.github.com/users/eggyal/followers", "following_url": "https://api.github.com/users/eggyal/following{/other_user}", "gists_url": "https://api.github.com/users/eggyal/gists{/gist_id}", "starred_url": "https://api.github.com/users/eggyal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eggyal/subscriptions", "organizations_url": "https://api.github.com/users/eggyal/orgs", "repos_url": "https://api.github.com/users/eggyal/repos", "events_url": "https://api.github.com/users/eggyal/events{/privacy}", "received_events_url": "https://api.github.com/users/eggyal/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6dc3dae46f600efe75627a7ad386e7462066e34d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dc3dae46f600efe75627a7ad386e7462066e34d", "html_url": "https://github.com/rust-lang/rust/commit/6dc3dae46f600efe75627a7ad386e7462066e34d"}], "stats": {"total": 360, "additions": 192, "deletions": 168}, "files": [{"sha": "0d36466f6e3e73153e2498e393c608614cc367da", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -23,6 +23,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(trusted_len)]\n #![feature(trusted_step)]\n #![feature(try_blocks)]\n+#![feature(unwrap_infallible)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "0ab077cf2bf404335d81a5488792adf8e2d25065", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -95,7 +95,8 @@ pub fn equal_up_to_regions(\n                 // Leave consts and types unchanged.\n                 ct_op: |ct| ct,\n                 ty_op: |ty| ty,\n-            }),\n+            })\n+            .into_ok(),\n         )\n     };\n     tcx.infer_ctxt().enter(|infcx| infcx.can_eq(param_env, normalize(src), normalize(dest)).is_ok())"}, {"sha": "27e73738b7f351bf07bd4bd56298cd90477ecaee", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -503,7 +503,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n             indices: FxHashMap::default(),\n             binder_index: ty::INNERMOST,\n         };\n-        let out_value = value.fold_with(&mut canonicalizer);\n+        let out_value = value.fold_with(&mut canonicalizer).into_ok();\n \n         // Once we have canonicalized `out_value`, it should not\n         // contain anything that ties it to this inference context\n@@ -621,7 +621,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         let infcx = self.infcx;\n         let bound_to = infcx.shallow_resolve(ty_var);\n         if bound_to != ty_var {\n-            self.fold_ty(bound_to)\n+            self.fold_ty(bound_to).into_ok()\n         } else {\n             let var = self.canonical_var(info, ty_var.into());\n             self.tcx().mk_ty(ty::Bound(self.binder_index, var.into()))\n@@ -640,12 +640,12 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         let infcx = self.infcx;\n         let bound_to = infcx.shallow_resolve(const_var);\n         if bound_to != const_var {\n-            self.fold_const(bound_to)\n+            self.fold_const(bound_to).into_ok()\n         } else {\n             let var = self.canonical_var(info, const_var.into());\n             self.tcx().mk_const(ty::Const {\n                 val: ty::ConstKind::Bound(self.binder_index, var),\n-                ty: self.fold_ty(const_var.ty),\n+                ty: self.fold_ty(const_var.ty).into_ok(),\n             })\n         }\n     }"}, {"sha": "7599e98167fb5c04e6c8e2839ae394a4f3761c68", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n         F: FnOnce(u32) -> ty::InferTy,\n     {\n         if let Some(ty) = opt_ty {\n-            return ty.fold_with(self);\n+            return ty.fold_with(self).into_ok();\n         }\n \n         match self.ty_freshen_map.entry(key) {\n@@ -98,7 +98,7 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n         F: FnOnce(u32) -> ty::InferConst<'tcx>,\n     {\n         if let Some(ct) = opt_ct {\n-            return ct.fold_with(self);\n+            return ct.fold_with(self).into_ok();\n         }\n \n         match self.const_freshen_map.entry(key) {"}, {"sha": "4e6f1315d102437ecf565992403cf0548181c6a4", "filename": "compiler/rustc_infer/src/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -161,7 +161,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         {\n             Ok(value)\n         } else {\n-            Ok(value.fold_with(&mut fudger))\n+            Ok(value.fold_with(&mut fudger).into_ok())\n         }\n     }\n }"}, {"sha": "4a9a63e1c76029357a4f14f033ff386c4560c6f6", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -681,7 +681,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn freshen<T: TypeFoldable<'tcx>>(&self, t: T) -> T {\n-        t.fold_with(&mut self.freshener())\n+        t.fold_with(&mut self.freshener()).into_ok()\n     }\n \n     /// Returns the origin of the type variable identified by `vid`, or `None`\n@@ -1381,7 +1381,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        value.fold_with(&mut ShallowResolver { infcx: self })\n+        value.fold_with(&mut ShallowResolver { infcx: self }).into_ok()\n     }\n \n     pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {\n@@ -1402,7 +1402,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             return value; // Avoid duplicated subst-folding.\n         }\n         let mut r = resolve::OpportunisticVarResolver::new(self);\n-        value.fold_with(&mut r)\n+        value.fold_with(&mut r).into_ok()\n     }\n \n     /// Returns the first unresolved variable contained in `T`. In the"}, {"sha": "932f26d5550108df9dcc679cd84ddf5bb547cc2a", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 100, "deletions": 96, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -418,92 +418,94 @@ struct Instantiator<'a, 'tcx> {\n impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n     fn instantiate_opaque_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n         let tcx = self.infcx.tcx;\n-        value.fold_with(&mut BottomUpFolder {\n-            tcx,\n-            ty_op: |ty| {\n-                if ty.references_error() {\n-                    return tcx.ty_error();\n-                } else if let ty::Opaque(def_id, substs) = ty.kind() {\n-                    // Check that this is `impl Trait` type is\n-                    // declared by `parent_def_id` -- i.e., one whose\n-                    // value we are inferring.  At present, this is\n-                    // always true during the first phase of\n-                    // type-check, but not always true later on during\n-                    // NLL. Once we support named opaque types more fully,\n-                    // this same scenario will be able to arise during all phases.\n-                    //\n-                    // Here is an example using type alias `impl Trait`\n-                    // that indicates the distinction we are checking for:\n-                    //\n-                    // ```rust\n-                    // mod a {\n-                    //   pub type Foo = impl Iterator;\n-                    //   pub fn make_foo() -> Foo { .. }\n-                    // }\n-                    //\n-                    // mod b {\n-                    //   fn foo() -> a::Foo { a::make_foo() }\n-                    // }\n-                    // ```\n-                    //\n-                    // Here, the return type of `foo` references an\n-                    // `Opaque` indeed, but not one whose value is\n-                    // presently being inferred. You can get into a\n-                    // similar situation with closure return types\n-                    // today:\n-                    //\n-                    // ```rust\n-                    // fn foo() -> impl Iterator { .. }\n-                    // fn bar() {\n-                    //     let x = || foo(); // returns the Opaque assoc with `foo`\n-                    // }\n-                    // ```\n-                    if let Some(def_id) = def_id.as_local() {\n-                        let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-                        let parent_def_id = self.infcx.defining_use_anchor;\n-                        let def_scope_default = || {\n-                            let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n-                            parent_def_id == tcx.hir().local_def_id(opaque_parent_hir_id)\n-                        };\n-                        let (in_definition_scope, origin) =\n-                            match tcx.hir().expect_item(opaque_hir_id).kind {\n-                                // Anonymous `impl Trait`\n-                                hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                                    impl_trait_fn: Some(parent),\n-                                    origin,\n-                                    ..\n-                                }) => (parent == parent_def_id.to_def_id(), origin),\n-                                // Named `type Foo = impl Bar;`\n-                                hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                                    impl_trait_fn: None,\n-                                    origin,\n-                                    ..\n-                                }) => (\n-                                    may_define_opaque_type(tcx, parent_def_id, opaque_hir_id),\n-                                    origin,\n-                                ),\n-                                _ => (def_scope_default(), hir::OpaqueTyOrigin::TyAlias),\n+        value\n+            .fold_with(&mut BottomUpFolder {\n+                tcx,\n+                ty_op: |ty| {\n+                    if ty.references_error() {\n+                        return tcx.ty_error();\n+                    } else if let ty::Opaque(def_id, substs) = ty.kind() {\n+                        // Check that this is `impl Trait` type is\n+                        // declared by `parent_def_id` -- i.e., one whose\n+                        // value we are inferring.  At present, this is\n+                        // always true during the first phase of\n+                        // type-check, but not always true later on during\n+                        // NLL. Once we support named opaque types more fully,\n+                        // this same scenario will be able to arise during all phases.\n+                        //\n+                        // Here is an example using type alias `impl Trait`\n+                        // that indicates the distinction we are checking for:\n+                        //\n+                        // ```rust\n+                        // mod a {\n+                        //   pub type Foo = impl Iterator;\n+                        //   pub fn make_foo() -> Foo { .. }\n+                        // }\n+                        //\n+                        // mod b {\n+                        //   fn foo() -> a::Foo { a::make_foo() }\n+                        // }\n+                        // ```\n+                        //\n+                        // Here, the return type of `foo` references an\n+                        // `Opaque` indeed, but not one whose value is\n+                        // presently being inferred. You can get into a\n+                        // similar situation with closure return types\n+                        // today:\n+                        //\n+                        // ```rust\n+                        // fn foo() -> impl Iterator { .. }\n+                        // fn bar() {\n+                        //     let x = || foo(); // returns the Opaque assoc with `foo`\n+                        // }\n+                        // ```\n+                        if let Some(def_id) = def_id.as_local() {\n+                            let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+                            let parent_def_id = self.infcx.defining_use_anchor;\n+                            let def_scope_default = || {\n+                                let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n+                                parent_def_id == tcx.hir().local_def_id(opaque_parent_hir_id)\n                             };\n-                        if in_definition_scope {\n-                            let opaque_type_key =\n-                                OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n-                            return self.fold_opaque_ty(ty, opaque_type_key, origin);\n-                        }\n-\n-                        debug!(\n-                            \"instantiate_opaque_types_in_map: \\\n+                            let (in_definition_scope, origin) =\n+                                match tcx.hir().expect_item(opaque_hir_id).kind {\n+                                    // Anonymous `impl Trait`\n+                                    hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                                        impl_trait_fn: Some(parent),\n+                                        origin,\n+                                        ..\n+                                    }) => (parent == parent_def_id.to_def_id(), origin),\n+                                    // Named `type Foo = impl Bar;`\n+                                    hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                                        impl_trait_fn: None,\n+                                        origin,\n+                                        ..\n+                                    }) => (\n+                                        may_define_opaque_type(tcx, parent_def_id, opaque_hir_id),\n+                                        origin,\n+                                    ),\n+                                    _ => (def_scope_default(), hir::OpaqueTyOrigin::TyAlias),\n+                                };\n+                            if in_definition_scope {\n+                                let opaque_type_key =\n+                                    OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n+                                return self.fold_opaque_ty(ty, opaque_type_key, origin);\n+                            }\n+\n+                            debug!(\n+                                \"instantiate_opaque_types_in_map: \\\n                              encountered opaque outside its definition scope \\\n                              def_id={:?}\",\n-                            def_id,\n-                        );\n+                                def_id,\n+                            );\n+                        }\n                     }\n-                }\n \n-                ty\n-            },\n-            lt_op: |lt| lt,\n-            ct_op: |ct| ct,\n-        })\n+                    ty\n+                },\n+                lt_op: |lt| lt,\n+                ct_op: |ct| ct,\n+            })\n+            .into_ok()\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n@@ -556,21 +558,23 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n             debug!(?predicate);\n \n             // We can't normalize associated types from `rustc_infer`, but we can eagerly register inference variables for them.\n-            let predicate = predicate.fold_with(&mut BottomUpFolder {\n-                tcx,\n-                ty_op: |ty| match ty.kind() {\n-                    ty::Projection(projection_ty) => infcx.infer_projection(\n-                        self.param_env,\n-                        *projection_ty,\n-                        traits::ObligationCause::misc(self.value_span, self.body_id),\n-                        0,\n-                        &mut self.obligations,\n-                    ),\n-                    _ => ty,\n-                },\n-                lt_op: |lt| lt,\n-                ct_op: |ct| ct,\n-            });\n+            let predicate = predicate\n+                .fold_with(&mut BottomUpFolder {\n+                    tcx,\n+                    ty_op: |ty| match ty.kind() {\n+                        ty::Projection(projection_ty) => infcx.infer_projection(\n+                            self.param_env,\n+                            *projection_ty,\n+                            traits::ObligationCause::misc(self.value_span, self.body_id),\n+                            0,\n+                            &mut self.obligations,\n+                        ),\n+                        _ => ty,\n+                    },\n+                    lt_op: |lt| lt,\n+                    ct_op: |ct| ct,\n+                })\n+                .into_ok();\n             debug!(?predicate);\n \n             if let ty::PredicateKind::Projection(projection) = predicate.kind().skip_binder() {"}, {"sha": "554c5b162f755b6a1f677528f062607a48a77f72", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -182,7 +182,7 @@ where\n     T: TypeFoldable<'tcx>,\n {\n     let mut full_resolver = FullTypeResolver { infcx, err: None };\n-    let result = value.fold_with(&mut full_resolver);\n+    let result = value.fold_with(&mut full_resolver).into_ok();\n     match full_resolver.err {\n         None => Ok(result),\n         Some(e) => Err(e),"}, {"sha": "5153427954ccc723f761dbf1f79ab274146b8f1f", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -24,6 +24,7 @@\n #![feature(control_flow_enum)]\n #![feature(min_specialization)]\n #![feature(label_break_value)]\n+#![feature(unwrap_infallible)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "b67ad8b770ea1537ca2e8264d2a36a5eeb50cb30", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -56,6 +56,7 @@\n #![feature(try_blocks)]\n #![feature(try_reserve_kind)]\n #![feature(nonzero_ops)]\n+#![feature(unwrap_infallible)]\n #![recursion_limit = \"512\"]\n \n #[macro_use]"}, {"sha": "25b460cf16d3c7f5cfddbb7775fc1e566a306ed0", "filename": "compiler/rustc_middle/src/ty/erase_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -9,7 +9,7 @@ pub(super) fn provide(providers: &mut ty::query::Providers) {\n fn erase_regions_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     // N.B., use `super_fold_with` here. If we used `fold_with`, it\n     // could invoke the `erase_regions_ty` query recursively.\n-    ty.super_fold_with(&mut RegionEraserVisitor { tcx })\n+    ty.super_fold_with(&mut RegionEraserVisitor { tcx }).into_ok()\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -27,7 +27,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             return value;\n         }\n         debug!(\"erase_regions({:?})\", value);\n-        let value1 = value.fold_with(&mut RegionEraserVisitor { tcx: self });\n+        let value1 = value.fold_with(&mut RegionEraserVisitor { tcx: self }).into_ok();\n         debug!(\"erase_regions = {:?}\", value1);\n         value1\n     }"}, {"sha": "31055c03a5d36c73e551ddbf76377ef6699f081d", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -336,7 +336,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        value.fold_with(&mut RegionFolder::new(self, skipped_regions, &mut f))\n+        value.fold_with(&mut RegionFolder::new(self, skipped_regions, &mut f)).into_ok()\n     }\n \n     /// Invoke `callback` on every region appearing free in `value`.\n@@ -638,7 +638,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             value\n         } else {\n             let mut replacer = BoundVarReplacer::new(self, Some(&mut real_fld_r), None, None);\n-            value.fold_with(&mut replacer)\n+            value.fold_with(&mut replacer).into_ok()\n         };\n         (value, region_map)\n     }\n@@ -664,7 +664,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         } else {\n             let mut replacer =\n                 BoundVarReplacer::new(self, Some(&mut fld_r), Some(&mut fld_t), Some(&mut fld_c));\n-            value.fold_with(&mut replacer)\n+            value.fold_with(&mut replacer).into_ok()\n         }\n     }\n \n@@ -1030,7 +1030,7 @@ where\n {\n     debug!(\"shift_vars(value={:?}, amount={})\", value, amount);\n \n-    value.fold_with(&mut Shifter::new(tcx, amount))\n+    value.fold_with(&mut Shifter::new(tcx, amount)).into_ok()\n }\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n@@ -1293,7 +1293,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     ///\n     /// FIXME(@lcnr): explain this function a bit more\n     pub fn expose_default_const_substs<T: TypeFoldable<'tcx>>(self, v: T) -> T {\n-        v.fold_with(&mut ExposeDefaultConstSubstsFolder { tcx: self })\n+        v.fold_with(&mut ExposeDefaultConstSubstsFolder { tcx: self }).into_ok()\n     }\n }\n "}, {"sha": "15931b8d2c86a85d0129437e207e9255cf26b0e9", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -669,7 +669,7 @@ fn polymorphize<'tcx>(\n                     // ..and polymorphize any closures/generators captured as upvars.\n                     let upvars_ty = upvars_ty.unwrap();\n                     let polymorphized_upvars_ty = upvars_ty.fold_with(\n-                        &mut PolymorphizationFolder { tcx });\n+                        &mut PolymorphizationFolder { tcx }).into_ok();\n                     debug!(\"polymorphize: polymorphized_upvars_ty={:?}\", polymorphized_upvars_ty);\n                     ty::GenericArg::from(polymorphized_upvars_ty)\n                 },"}, {"sha": "e6f67adae93daadd92bbce9674bddfe3f5fc844a", "filename": "compiler/rustc_middle/src/ty/normalize_erasing_regions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -35,7 +35,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         if !value.has_projections() {\n             value\n         } else {\n-            value.fold_with(&mut NormalizeAfterErasingRegionsFolder { tcx: self, param_env })\n+            value\n+                .fold_with(&mut NormalizeAfterErasingRegionsFolder { tcx: self, param_env })\n+                .into_ok()\n         }\n     }\n "}, {"sha": "f454b95862bab57b319630ac74d2115c083f3abb", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -2193,7 +2193,7 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n                 name: &mut name,\n                 region_map: BTreeMap::new(),\n             };\n-            let new_value = value.clone().skip_binder().fold_with(&mut folder);\n+            let new_value = value.clone().skip_binder().fold_with(&mut folder).into_ok();\n             let region_map = folder.region_map;\n             start_or_continue(&mut self, \"\", \"> \");\n             (new_value, region_map)"}, {"sha": "0767224ad9288e72109faa38fb93a2e5320b12f9", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -439,7 +439,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> Subst<'tcx> for T {\n         span: Option<Span>,\n     ) -> T {\n         let mut folder = SubstFolder { tcx, substs, span, binders_passed: 0 };\n-        self.fold_with(&mut folder)\n+        self.fold_with(&mut folder).into_ok()\n     }\n }\n "}, {"sha": "5137f9650633a38dcdfc09009a359ee1fcdc98c7", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -574,14 +574,14 @@ impl<'tcx> OpaqueTypeExpander<'tcx> {\n         if self.found_any_recursion {\n             return None;\n         }\n-        let substs = substs.fold_with(self);\n+        let substs = substs.fold_with(self).into_ok();\n         if !self.check_recursion || self.seen_opaque_tys.insert(def_id) {\n             let expanded_ty = match self.expanded_cache.get(&(def_id, substs)) {\n                 Some(expanded_ty) => expanded_ty,\n                 None => {\n                     let generic_ty = self.tcx.type_of(def_id);\n                     let concrete_ty = generic_ty.subst(self.tcx, substs);\n-                    let expanded_ty = self.fold_ty(concrete_ty);\n+                    let expanded_ty = self.fold_ty(concrete_ty).into_ok();\n                     self.expanded_cache.insert((def_id, substs), expanded_ty);\n                     expanded_ty\n                 }\n@@ -1092,7 +1092,7 @@ pub fn normalize_opaque_types(\n         check_recursion: false,\n         tcx,\n     };\n-    val.fold_with(&mut visitor)\n+    val.fold_with(&mut visitor).into_ok()\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {"}, {"sha": "ecc352c1a49b5bc5f1de2d98b30ed34212a9ac4b", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -22,6 +22,7 @@\n #![feature(never_type)]\n #![feature(crate_visibility_modifier)]\n #![feature(control_flow_enum)]\n+#![feature(unwrap_infallible)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "9052dff0aaa837514b2eadfe507eb6184c079b4e", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -65,14 +65,16 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // Convert the type from the function into a type valid outside\n         // the function, by replacing invalid regions with 'static,\n         // after producing an error for each of them.\n-        let definition_ty = instantiated_ty.fold_with(&mut ReverseMapper::new(\n-            self.tcx,\n-            self.is_tainted_by_errors(),\n-            def_id,\n-            map,\n-            instantiated_ty,\n-            span,\n-        ));\n+        let definition_ty = instantiated_ty\n+            .fold_with(&mut ReverseMapper::new(\n+                self.tcx,\n+                self.is_tainted_by_errors(),\n+                def_id,\n+                map,\n+                instantiated_ty,\n+                span,\n+            ))\n+            .into_ok();\n         debug!(?definition_ty);\n \n         definition_ty\n@@ -123,14 +125,14 @@ impl ReverseMapper<'tcx> {\n     ) -> GenericArg<'tcx> {\n         assert!(!self.map_missing_regions_to_empty);\n         self.map_missing_regions_to_empty = true;\n-        let kind = kind.fold_with(self);\n+        let kind = kind.fold_with(self).into_ok();\n         self.map_missing_regions_to_empty = false;\n         kind\n     }\n \n     fn fold_kind_normally(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n         assert!(!self.map_missing_regions_to_empty);\n-        kind.fold_with(self)\n+        kind.fold_with(self).into_ok()\n     }\n }\n "}, {"sha": "866bcde1bfd4f11a4f1c76369cba0f4e779ad2a2", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -1916,8 +1916,9 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         self.probe(|_| {\n             let mut selcx = SelectionContext::new(self);\n \n-            let cleaned_pred =\n-                pred.fold_with(&mut ParamToVarFolder { infcx: self, var_map: Default::default() });\n+            let cleaned_pred = pred\n+                .fold_with(&mut ParamToVarFolder { infcx: self, var_map: Default::default() })\n+                .into_ok();\n \n             let cleaned_pred = super::project::normalize(\n                 &mut selcx,"}, {"sha": "0911b2c529ab25b00bc520c58cf4f1fdad1c4864", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -339,7 +339,7 @@ impl<'a, 'b, 'tcx> AssocTypeNormalizer<'a, 'b, 'tcx> {\n         if !needs_normalization(&value, self.param_env.reveal()) {\n             value\n         } else {\n-            value.fold_with(self)\n+            value.fold_with(self).into_ok()\n         }\n     }\n }\n@@ -555,7 +555,7 @@ impl<'me, 'tcx> BoundVarReplacer<'me, 'tcx> {\n             universe_indices,\n         };\n \n-        let value = value.super_fold_with(&mut replacer);\n+        let value = value.super_fold_with(&mut replacer).into_ok();\n \n         (value, replacer.mapped_regions, replacer.mapped_types, replacer.mapped_consts)\n     }\n@@ -681,7 +681,7 @@ impl<'me, 'tcx> PlaceholderReplacer<'me, 'tcx> {\n             universe_indices,\n             current_index: ty::INNERMOST,\n         };\n-        value.super_fold_with(&mut replacer)\n+        value.super_fold_with(&mut replacer).into_ok()\n     }\n }\n \n@@ -1546,7 +1546,8 @@ fn confirm_candidate<'cx, 'tcx>(\n     // when possible for this to work. See `auto-trait-projection-recursion.rs`\n     // for a case where this matters.\n     if progress.ty.has_infer_regions() {\n-        progress.ty = OpportunisticRegionResolver::new(selcx.infcx()).fold_ty(progress.ty);\n+        progress.ty =\n+            OpportunisticRegionResolver::new(selcx.infcx()).fold_ty(progress.ty).into_ok();\n     }\n     progress\n }"}, {"sha": "dd9cd51936ec3cb80871b8f98ec3ebc6df8d937f", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -88,7 +88,7 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n                 normalizer.universes.extend((0..max_visitor.escaping).map(|_| None));\n             }\n         }\n-        let result = value.fold_with(&mut normalizer);\n+        let result = value.fold_with(&mut normalizer).into_ok();\n         info!(\n             \"normalize::<{}>: result={:?} with {} obligations\",\n             std::any::type_name::<T>(),"}, {"sha": "767cb1618bb67d35239db630af41e98e8bad37e3", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -2222,6 +2222,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .predicate\n             .to_poly_trait_ref()\n             .fold_with(&mut self.freshener)\n+            .into_ok()\n             .with_constness(obligation.predicate.skip_binder().constness);\n \n         let dfn = previous_stack.cache.next_dfn();"}, {"sha": "fdff07302c2407fbe7e8c72c5844870e5f1b715d", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -45,7 +45,7 @@ impl<'tcx> RustIrDatabase<'tcx> {\n         predicates\n             .iter()\n             .map(|(wc, _)| wc.subst(self.interner.tcx, bound_vars))\n-            .map(|wc| wc.fold_with(&mut regions_substitutor))\n+            .map(|wc| wc.fold_with(&mut regions_substitutor).into_ok())\n             .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect()\n     }\n \n@@ -287,7 +287,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         let trait_ref = trait_ref.subst(self.interner.tcx, bound_vars);\n         let mut regions_substitutor =\n             lowering::RegionsSubstitutor::new(self.interner.tcx, self.reempty_placeholder);\n-        let trait_ref = trait_ref.fold_with(&mut regions_substitutor);\n+        let trait_ref = trait_ref.fold_with(&mut regions_substitutor).into_ok();\n \n         let where_clauses = self.where_clauses_for(def_id, bound_vars);\n \n@@ -335,7 +335,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             let self_ty = self_ty.subst(self.interner.tcx, bound_vars);\n             let mut regions_substitutor =\n                 lowering::RegionsSubstitutor::new(self.interner.tcx, self.reempty_placeholder);\n-            let self_ty = self_ty.fold_with(&mut regions_substitutor);\n+            let self_ty = self_ty.fold_with(&mut regions_substitutor).into_ok();\n             let lowered_ty = self_ty.lower_into(&self.interner);\n \n             parameters[0].assert_ty_ref(&self.interner).could_match(\n@@ -501,22 +501,24 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                 .iter()\n                 .map(|(bound, _)| bound.subst(self.interner.tcx, &bound_vars))\n                 .map(|bound| {\n-                    bound.fold_with(&mut ty::fold::BottomUpFolder {\n-                        tcx: self.interner.tcx,\n-                        ty_op: |ty| {\n-                            if let ty::Opaque(def_id, substs) = *ty.kind() {\n-                                if def_id == opaque_ty_id.0 && substs == identity_substs {\n-                                    return self.interner.tcx.mk_ty(ty::Bound(\n-                                        ty::INNERMOST,\n-                                        ty::BoundTy::from(ty::BoundVar::from_u32(0)),\n-                                    ));\n+                    bound\n+                        .fold_with(&mut ty::fold::BottomUpFolder {\n+                            tcx: self.interner.tcx,\n+                            ty_op: |ty| {\n+                                if let ty::Opaque(def_id, substs) = *ty.kind() {\n+                                    if def_id == opaque_ty_id.0 && substs == identity_substs {\n+                                        return self.interner.tcx.mk_ty(ty::Bound(\n+                                            ty::INNERMOST,\n+                                            ty::BoundTy::from(ty::BoundVar::from_u32(0)),\n+                                        ));\n+                                    }\n                                 }\n-                            }\n-                            ty\n-                        },\n-                        lt_op: |lt| lt,\n-                        ct_op: |ct| ct,\n-                    })\n+                                ty\n+                            },\n+                            lt_op: |lt| lt,\n+                            ct_op: |ct| ct,\n+                        })\n+                        .into_ok()\n                 })\n                 .filter_map(|bound| {\n                     LowerInto::<"}, {"sha": "66073facf4b0c1f10bfa59e3ed2ea39ac1053c25", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -817,7 +817,7 @@ crate fn collect_bound_vars<'tcx, T: TypeFoldable<'tcx>>(\n         .collect();\n \n     let mut bound_var_substitutor = NamedBoundVarSubstitutor::new(tcx, &named_parameters);\n-    let new_ty = ty.skip_binder().fold_with(&mut bound_var_substitutor);\n+    let new_ty = ty.skip_binder().fold_with(&mut bound_var_substitutor).into_ok();\n \n     for var in named_parameters.values() {\n         parameters.insert(*var, chalk_ir::VariableKind::Lifetime);"}, {"sha": "a6f7c4d7988f697ed0fb37dd39c5cdcd5d04b20e", "filename": "compiler/rustc_traits/src/chalk/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -49,12 +49,12 @@ crate fn evaluate_goal<'tcx>(\n \n     let mut params_substitutor =\n         ParamsSubstitutor::new(tcx, placeholders_collector.next_ty_placeholder);\n-    let obligation = obligation.fold_with(&mut params_substitutor);\n+    let obligation = obligation.fold_with(&mut params_substitutor).into_ok();\n     // FIXME(chalk): we really should be substituting these back in the solution\n     let _params: FxHashMap<usize, ParamTy> = params_substitutor.params;\n \n     let mut regions_substitutor = RegionsSubstitutor::new(tcx, reempty_placeholder);\n-    let obligation = obligation.fold_with(&mut regions_substitutor);\n+    let obligation = obligation.fold_with(&mut regions_substitutor).into_ok();\n \n     let max_universe = obligation.max_universe.index();\n "}, {"sha": "ea70a8d9e3a0d30fd9504f496e21b3cebee49669", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -4,6 +4,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n+#![feature(unwrap_infallible)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "1c4e0522bef8fac63307ddb78ce3355b0f507128", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -442,8 +442,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             let mut eraser = TypeParamEraser(self, expr.span);\n                             let needs_bound = self\n                                 .lookup_op_method(\n-                                    eraser.fold_ty(lhs_ty),\n-                                    &[eraser.fold_ty(rhs_ty)],\n+                                    eraser.fold_ty(lhs_ty).into_ok(),\n+                                    &[eraser.fold_ty(rhs_ty).into_ok()],\n                                     Op::Binary(op, is_assign),\n                                 )\n                                 .is_ok();"}, {"sha": "a5965411020a4a429c4dd6e865b69c2639aa7ecc", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -658,7 +658,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         let mut resolver = Resolver::new(self.fcx, span, self.body);\n-        let x = x.fold_with(&mut resolver);\n+        let x = x.fold_with(&mut resolver).into_ok();\n         if cfg!(debug_assertions) && x.needs_infer() {\n             span_bug!(span.to_span(self.fcx.tcx), \"writeback: `{:?}` has inference variables\", x);\n         }"}, {"sha": "1ea379c57389a1035052985f142ba5c71c11bf22", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -761,7 +761,7 @@ fn infer_placeholder_type<'a>(\n \n                 // Suggesting unnameable types won't help.\n                 let mut mk_nameable = MakeNameable::new(tcx);\n-                let ty = mk_nameable.fold_ty(ty);\n+                let ty = mk_nameable.fold_ty(ty).into_ok();\n                 let sugg_ty = if mk_nameable.success { Some(ty) } else { None };\n                 if let Some(sugg_ty) = sugg_ty {\n                     err.span_suggestion(\n@@ -785,7 +785,7 @@ fn infer_placeholder_type<'a>(\n \n             if !ty.references_error() {\n                 let mut mk_nameable = MakeNameable::new(tcx);\n-                let ty = mk_nameable.fold_ty(ty);\n+                let ty = mk_nameable.fold_ty(ty).into_ok();\n                 let sugg_ty = if mk_nameable.success { Some(ty) } else { None };\n                 if let Some(sugg_ty) = sugg_ty {\n                     diag.span_suggestion("}, {"sha": "f9de6376b0ff5e572964c8edc8c3b7abd6469d4e", "filename": "compiler/rustc_typeck/src/hir_wf_check.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -71,8 +71,11 @@ fn diagnostic_hir_wf_check<'tcx>(\n         fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n             self.tcx.infer_ctxt().enter(|infcx| {\n                 let mut fulfill = traits::FulfillmentContext::new();\n-                let tcx_ty =\n-                    self.icx.to_ty(ty).fold_with(&mut EraseAllBoundRegions { tcx: self.tcx });\n+                let tcx_ty = self\n+                    .icx\n+                    .to_ty(ty)\n+                    .fold_with(&mut EraseAllBoundRegions { tcx: self.tcx })\n+                    .into_ok();\n                 let cause = traits::ObligationCause::new(\n                     ty.span,\n                     self.hir_id,"}, {"sha": "c0f0b3fe7046ec2c34fe78af4dbf93b43a44b3e7", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -71,6 +71,7 @@ This API is completely unstable and subject to change.\n #![feature(slice_partition_dedup)]\n #![feature(control_flow_enum)]\n #![feature(hash_drain_filter)]\n+#![feature(unwrap_infallible)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "04fe1dccce44bfa8ce56da0cb9e4c4916f187ed8", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -449,7 +449,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                         _ => false,\n                     }\n             })\n-            .map(|p| p.fold_with(&mut replacer));\n+            .map(|p| p.fold_with(&mut replacer).into_ok());\n \n         let mut generic_params =\n             (tcx.generics_of(item_def_id), tcx.explicit_predicates_of(item_def_id))"}, {"sha": "6ba56fe01a93505a7306cf628a98c89ad27cbdb9", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30bf20a692df794c9c639ef7153115b7db5aade5/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30bf20a692df794c9c639ef7153115b7db5aade5/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=30bf20a692df794c9c639ef7153115b7db5aade5", "patch": "@@ -18,6 +18,7 @@\n #![feature(type_ascription)]\n #![feature(iter_intersperse)]\n #![recursion_limit = \"256\"]\n+#![feature(unwrap_infallible)]\n #![warn(rustc::internal)]\n \n #[macro_use]"}]}