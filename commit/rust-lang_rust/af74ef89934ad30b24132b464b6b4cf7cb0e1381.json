{"sha": "af74ef89934ad30b24132b464b6b4cf7cb0e1381", "node_id": "C_kwDOAAsO6NoAKGFmNzRlZjg5OTM0YWQzMGIyNDEzMmI0NjRiNmI0Y2Y3Y2IwZTEzODE", "commit": {"author": {"name": "Deadbeef", "email": "ent3rm4n@gmail.com", "date": "2023-03-27T13:44:06Z"}, "committer": {"name": "Deadbeef", "email": "ent3rm4n@gmail.com", "date": "2023-04-06T04:55:58Z"}, "message": "migrate rustc_macros to syn 2.0", "tree": {"sha": "60eaf705873a5d7a894449f56b090bddc751c693", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60eaf705873a5d7a894449f56b090bddc751c693"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af74ef89934ad30b24132b464b6b4cf7cb0e1381", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af74ef89934ad30b24132b464b6b4cf7cb0e1381", "html_url": "https://github.com/rust-lang/rust/commit/af74ef89934ad30b24132b464b6b4cf7cb0e1381", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af74ef89934ad30b24132b464b6b4cf7cb0e1381/comments", "author": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33289132ecc1805250f63801fded10fceb2300d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/33289132ecc1805250f63801fded10fceb2300d8", "html_url": "https://github.com/rust-lang/rust/commit/33289132ecc1805250f63801fded10fceb2300d8"}], "stats": {"total": 619, "additions": 275, "deletions": 344}, "files": [{"sha": "be8afa930c6e75f06072ce5a46e48513e3d310a4", "filename": "Cargo.lock", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/af74ef89934ad30b24132b464b6b4cf7cb0e1381/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/af74ef89934ad30b24132b464b6b4cf7cb0e1381/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=af74ef89934ad30b24132b464b6b4cf7cb0e1381", "patch": "@@ -632,7 +632,7 @@ dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"syn 1.0.102\",\n- \"synstructure\",\n+ \"synstructure 0.12.6\",\n ]\n \n [[package]]\n@@ -4994,8 +4994,8 @@ dependencies = [\n  \"fluent-syntax\",\n  \"proc-macro2\",\n  \"quote\",\n- \"syn 1.0.102\",\n- \"synstructure\",\n+ \"syn 2.0.8\",\n+ \"synstructure 0.13.0\",\n  \"unic-langid\",\n ]\n \n@@ -6131,6 +6131,18 @@ dependencies = [\n  \"unicode-xid\",\n ]\n \n+[[package]]\n+name = \"synstructure\"\n+version = \"0.13.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"285ba80e733fac80aa4270fbcdf83772a79b80aa35c97075320abfee4a915b06\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn 2.0.8\",\n+ \"unicode-xid\",\n+]\n+\n [[package]]\n name = \"tar\"\n version = \"0.4.38\"\n@@ -7154,7 +7166,7 @@ dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"syn 1.0.102\",\n- \"synstructure\",\n+ \"synstructure 0.12.6\",\n ]\n \n [[package]]\n@@ -7175,7 +7187,7 @@ dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"syn 1.0.102\",\n- \"synstructure\",\n+ \"synstructure 0.12.6\",\n ]\n \n [[package]]\n@@ -7204,5 +7216,5 @@ dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"syn 1.0.102\",\n- \"synstructure\",\n+ \"synstructure 0.12.6\",\n ]"}, {"sha": "745983e7e869aed7e1f42167b26bcc41baa7e3b3", "filename": "compiler/rustc_macros/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af74ef89934ad30b24132b464b6b4cf7cb0e1381/compiler%2Frustc_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/af74ef89934ad30b24132b464b6b4cf7cb0e1381/compiler%2Frustc_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2FCargo.toml?ref=af74ef89934ad30b24132b464b6b4cf7cb0e1381", "patch": "@@ -10,8 +10,8 @@ proc-macro = true\n annotate-snippets = \"0.9\"\n fluent-bundle = \"0.15.2\"\n fluent-syntax = \"0.11\"\n-synstructure = \"0.12.1\"\n-syn = { version = \"1\", features = [\"full\"] }\n+synstructure = \"0.13.0\"\n+syn = { version = \"2\", features = [\"full\"] }\n proc-macro2 = \"1\"\n quote = \"1\"\n unic-langid = { version = \"0.9.0\", features = [\"macros\"] }"}, {"sha": "fb75d87f8d2e4d02b10db9a9bb9e10fd396aad24", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 62, "deletions": 90, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/af74ef89934ad30b24132b464b6b4cf7cb0e1381/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af74ef89934ad30b24132b464b6b4cf7cb0e1381/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=af74ef89934ad30b24132b464b6b4cf7cb0e1381", "patch": "@@ -1,8 +1,7 @@\n #![deny(unused_must_use)]\n \n use crate::diagnostics::error::{\n-    invalid_nested_attr, span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err,\n-    DiagnosticDeriveError,\n+    span_err, throw_invalid_attr, throw_span_err, DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n     build_field_mapping, is_doc_comment, report_error_if_not_applied_to_span, report_type_error,\n@@ -11,9 +10,8 @@ use crate::diagnostics::utils::{\n };\n use proc_macro2::{Ident, Span, TokenStream};\n use quote::{format_ident, quote};\n-use syn::{\n-    parse_quote, spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta, Path, Type,\n-};\n+use syn::Token;\n+use syn::{parse_quote, spanned::Spanned, Attribute, Meta, Path, Type};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n /// What kind of diagnostic is being derived - a fatal/error/warning or a lint?\n@@ -77,7 +75,7 @@ impl DiagnosticDeriveBuilder {\n         match ast.data {\n             syn::Data::Struct(..) | syn::Data::Enum(..) => (),\n             syn::Data::Union(..) => {\n-                span_err(span, \"diagnostic derives can only be used on structs and enums\");\n+                span_err(span, \"diagnostic derives can only be used on structs and enums\").emit();\n             }\n         }\n \n@@ -160,8 +158,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n         };\n \n         if let SubdiagnosticKind::MultipartSuggestion { .. } = subdiag {\n-            let meta = attr.parse_meta()?;\n-            throw_invalid_attr!(attr, &meta, |diag| diag\n+            throw_invalid_attr!(attr, |diag| diag\n                 .help(\"consider creating a `Subdiagnostic` instead\"));\n         }\n \n@@ -191,71 +188,39 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             return Ok(quote! {});\n         }\n \n-        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let name = attr.path().segments.last().unwrap().ident.to_string();\n         let name = name.as_str();\n-        let meta = attr.parse_meta()?;\n \n-        if name == \"diag\" {\n-            let Meta::List(MetaList { ref nested, .. }) = meta else {\n-                throw_invalid_attr!(\n-                    attr,\n-                    &meta\n-                );\n-            };\n+        let mut first = true;\n \n-            let mut nested_iter = nested.into_iter().peekable();\n+        if name == \"diag\" {\n+            let mut tokens = TokenStream::new();\n+            attr.parse_nested_meta(|nested| {\n+                let path = &nested.path;\n \n-            match nested_iter.peek() {\n-                Some(NestedMeta::Meta(Meta::Path(slug))) => {\n-                    self.slug.set_once(slug.clone(), slug.span().unwrap());\n-                    nested_iter.next();\n+                if first && (nested.input.is_empty() || nested.input.peek(Token![,])) {\n+                    self.slug.set_once(path.clone(), path.span().unwrap());\n+                    first = false;\n+                    return Ok(())\n                 }\n-                Some(NestedMeta::Meta(Meta::NameValue { .. })) => {}\n-                Some(nested_attr) => throw_invalid_nested_attr!(attr, nested_attr, |diag| diag\n-                    .help(\"a diagnostic slug is required as the first argument\")),\n-                None => throw_invalid_attr!(attr, &meta, |diag| diag\n-                    .help(\"a diagnostic slug is required as the first argument\")),\n-            };\n \n-            // Remaining attributes are optional, only `code = \"..\"` at the moment.\n-            let mut tokens = TokenStream::new();\n-            for nested_attr in nested_iter {\n-                let (value, path) = match nested_attr {\n-                    NestedMeta::Meta(Meta::NameValue(MetaNameValue {\n-                        lit: syn::Lit::Str(value),\n-                        path,\n-                        ..\n-                    })) => (value, path),\n-                    NestedMeta::Meta(Meta::Path(_)) => {\n-                        invalid_nested_attr(attr, nested_attr)\n-                            .help(\"diagnostic slug must be the first argument\")\n-                            .emit();\n-                        continue;\n-                    }\n-                    _ => {\n-                        invalid_nested_attr(attr, nested_attr).emit();\n-                        continue;\n-                    }\n+                first = false;\n+\n+                let Ok(nested) = nested.value() else {\n+                    span_err(nested.input.span().unwrap(), \"diagnostic slug must be the first argument\").emit();\n+                    return Ok(())\n                 };\n \n-                let nested_name = path.segments.last().unwrap().ident.to_string();\n-                // Struct attributes are only allowed to be applied once, and the diagnostic\n-                // changes will be set in the initialisation code.\n-                let span = value.span().unwrap();\n-                match nested_name.as_str() {\n-                    \"code\" => {\n-                        self.code.set_once((), span);\n-\n-                        let code = value.value();\n-                        tokens.extend(quote! {\n-                            #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string()));\n-                        });\n-                    }\n-                    _ => invalid_nested_attr(attr, nested_attr)\n-                        .help(\"only `code` is a valid nested attributes following the slug\")\n-                        .emit(),\n+                if path.is_ident(\"code\") {\n+                    self.code.set_once((), path.span().unwrap());\n+\n+                    let code = nested.parse::<TokenStream>()?;\n+                    tokens.extend(quote! {\n+                        #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string()));\n+                    });\n                 }\n-            }\n+                Ok(())\n+            })?;\n             return Ok(tokens);\n         }\n \n@@ -270,7 +235,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 Ok(self.add_subdiagnostic(&fn_ident, slug))\n             }\n             SubdiagnosticKind::Label | SubdiagnosticKind::Suggestion { .. } => {\n-                throw_invalid_attr!(attr, &meta, |diag| diag\n+                throw_invalid_attr!(attr, |diag| diag\n                     .help(\"`#[label]` and `#[suggestion]` can only be applied to fields\"));\n             }\n             SubdiagnosticKind::MultipartSuggestion { .. } => unreachable!(),\n@@ -309,7 +274,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                     return quote! {};\n                 }\n \n-                let name = attr.path.segments.last().unwrap().ident.to_string();\n+                let name = attr.path().segments.last().unwrap().ident.to_string();\n                 let needs_clone =\n                     name == \"primary_span\" && matches!(inner_ty, FieldInnerTy::Vec(_));\n                 let (binding, needs_destructure) = if needs_clone {\n@@ -343,11 +308,10 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n         binding: TokenStream,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n         let diag = &self.parent.diag;\n-        let meta = attr.parse_meta()?;\n \n-        let ident = &attr.path.segments.last().unwrap().ident;\n+        let ident = &attr.path().segments.last().unwrap().ident;\n         let name = ident.to_string();\n-        match (&meta, name.as_str()) {\n+        match (&attr.meta, name.as_str()) {\n             // Don't need to do anything - by virtue of the attribute existing, the\n             // `set_arg` call will not be generated.\n             (Meta::Path(_), \"skip_arg\") => return Ok(quote! {}),\n@@ -361,7 +325,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                         });\n                     }\n                     DiagnosticDeriveKind::LintDiagnostic => {\n-                        throw_invalid_attr!(attr, &meta, |diag| {\n+                        throw_invalid_attr!(attr, |diag| {\n                             diag.help(\"the `primary_span` field attribute is not valid for lint diagnostics\")\n                         })\n                     }\n@@ -378,26 +342,34 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                     return Ok(quote! { #diag.subdiagnostic(#binding); });\n                 }\n             }\n-            (Meta::List(MetaList { ref nested, .. }), \"subdiagnostic\") => {\n-                if nested.len() == 1\n-                    && let Some(NestedMeta::Meta(Meta::Path(path))) = nested.first()\n-                    && path.is_ident(\"eager\") {\n-                        let handler = match &self.parent.kind {\n-                            DiagnosticDeriveKind::Diagnostic { handler } => handler,\n-                            DiagnosticDeriveKind::LintDiagnostic => {\n-                                throw_invalid_attr!(attr, &meta, |diag| {\n-                                    diag.help(\"eager subdiagnostics are not supported on lints\")\n-                                })\n-                            }\n-                        };\n-                        return Ok(quote! { #diag.eager_subdiagnostic(#handler, #binding); });\n-                } else {\n-                    throw_invalid_attr!(attr, &meta, |diag| {\n-                        diag.help(\n-                            \"`eager` is the only supported nested attribute for `subdiagnostic`\",\n-                        )\n-                    })\n+            (Meta::List(meta_list), \"subdiagnostic\") => {\n+                let err = || {\n+                    span_err(\n+                        meta_list.span().unwrap(),\n+                        \"`eager` is the only supported nested attribute for `subdiagnostic`\",\n+                    )\n+                    .emit();\n+                };\n+\n+                let Ok(p): Result<Path, _> = meta_list.parse_args() else {\n+                    err();\n+                    return Ok(quote! {});\n+                };\n+\n+                if !p.is_ident(\"eager\") {\n+                    err();\n+                    return Ok(quote! {});\n                 }\n+\n+                let handler = match &self.parent.kind {\n+                    DiagnosticDeriveKind::Diagnostic { handler } => handler,\n+                    DiagnosticDeriveKind::LintDiagnostic => {\n+                        throw_invalid_attr!(attr, |diag| {\n+                            diag.help(\"eager subdiagnostics are not supported on lints\")\n+                        })\n+                    }\n+                };\n+                return Ok(quote! { #diag.eager_subdiagnostic(#handler, #binding); });\n             }\n             _ => (),\n         }\n@@ -432,7 +404,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 code_init,\n             } => {\n                 if let FieldInnerTy::Vec(_) = info.ty {\n-                    throw_invalid_attr!(attr, &meta, |diag| {\n+                    throw_invalid_attr!(attr, |diag| {\n                         diag\n                         .note(\"`#[suggestion(...)]` applied to `Vec` field is ambiguous\")\n                         .help(\"to show a suggestion consisting of multiple parts, use a `Subdiagnostic` annotated with `#[multipart_suggestion(...)]`\")"}, {"sha": "b37dc826d28865d5cc44e237f7499571e50ac453", "filename": "compiler/rustc_macros/src/diagnostics/error.rs", "status": "modified", "additions": 8, "deletions": 47, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/af74ef89934ad30b24132b464b6b4cf7cb0e1381/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af74ef89934ad30b24132b464b6b4cf7cb0e1381/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs?ref=af74ef89934ad30b24132b464b6b4cf7cb0e1381", "patch": "@@ -1,7 +1,7 @@\n use proc_macro::{Diagnostic, Level, MultiSpan};\n use proc_macro2::TokenStream;\n use quote::quote;\n-use syn::{spanned::Spanned, Attribute, Error as SynError, Meta, NestedMeta};\n+use syn::{spanned::Spanned, Attribute, Error as SynError, Meta};\n \n #[derive(Debug)]\n pub(crate) enum DiagnosticDeriveError {\n@@ -53,6 +53,7 @@ fn path_to_string(path: &syn::Path) -> String {\n }\n \n /// Returns an error diagnostic on span `span` with msg `msg`.\n+#[must_use]\n pub(crate) fn span_err(span: impl MultiSpan, msg: &str) -> Diagnostic {\n     Diagnostic::spanned(span, Level::Error, msg)\n }\n@@ -72,10 +73,10 @@ macro_rules! throw_span_err {\n pub(crate) use throw_span_err;\n \n /// Returns an error diagnostic for an invalid attribute.\n-pub(crate) fn invalid_attr(attr: &Attribute, meta: &Meta) -> Diagnostic {\n+pub(crate) fn invalid_attr(attr: &Attribute) -> Diagnostic {\n     let span = attr.span().unwrap();\n-    let path = path_to_string(&attr.path);\n-    match meta {\n+    let path = path_to_string(attr.path());\n+    match attr.meta {\n         Meta::Path(_) => span_err(span, &format!(\"`#[{path}]` is not a valid attribute\")),\n         Meta::NameValue(_) => {\n             span_err(span, &format!(\"`#[{path} = ...]` is not a valid attribute\"))\n@@ -89,51 +90,11 @@ pub(crate) fn invalid_attr(attr: &Attribute, meta: &Meta) -> Diagnostic {\n ///\n /// For methods that return a `Result<_, DiagnosticDeriveError>`:\n macro_rules! throw_invalid_attr {\n-    ($attr:expr, $meta:expr) => {{ throw_invalid_attr!($attr, $meta, |diag| diag) }};\n-    ($attr:expr, $meta:expr, $f:expr) => {{\n-        let diag = crate::diagnostics::error::invalid_attr($attr, $meta);\n+    ($attr:expr) => {{ throw_invalid_attr!($attr, |diag| diag) }};\n+    ($attr:expr, $f:expr) => {{\n+        let diag = crate::diagnostics::error::invalid_attr($attr);\n         return Err(crate::diagnostics::error::_throw_err(diag, $f));\n     }};\n }\n \n pub(crate) use throw_invalid_attr;\n-\n-/// Returns an error diagnostic for an invalid nested attribute.\n-pub(crate) fn invalid_nested_attr(attr: &Attribute, nested: &NestedMeta) -> Diagnostic {\n-    let name = attr.path.segments.last().unwrap().ident.to_string();\n-    let name = name.as_str();\n-\n-    let span = nested.span().unwrap();\n-    let meta = match nested {\n-        syn::NestedMeta::Meta(meta) => meta,\n-        syn::NestedMeta::Lit(_) => {\n-            return span_err(span, &format!(\"`#[{name}(\\\"...\\\")]` is not a valid attribute\"));\n-        }\n-    };\n-\n-    let span = meta.span().unwrap();\n-    let path = path_to_string(meta.path());\n-    match meta {\n-        Meta::NameValue(..) => {\n-            span_err(span, &format!(\"`#[{name}({path} = ...)]` is not a valid attribute\"))\n-        }\n-        Meta::Path(..) => span_err(span, &format!(\"`#[{name}({path})]` is not a valid attribute\")),\n-        Meta::List(..) => {\n-            span_err(span, &format!(\"`#[{name}({path}(...))]` is not a valid attribute\"))\n-        }\n-    }\n-}\n-\n-/// Emit an error diagnostic for an invalid nested attribute (optionally performing additional\n-/// decoration using the `FnOnce` passed in `diag`) and return `Err(ErrorHandled)`.\n-///\n-/// For methods that return a `Result<_, DiagnosticDeriveError>`:\n-macro_rules! throw_invalid_nested_attr {\n-    ($attr:expr, $nested_attr:expr) => {{ throw_invalid_nested_attr!($attr, $nested_attr, |diag| diag) }};\n-    ($attr:expr, $nested_attr:expr, $f:expr) => {{\n-        let diag = crate::diagnostics::error::invalid_nested_attr($attr, $nested_attr);\n-        return Err(crate::diagnostics::error::_throw_err(diag, $f));\n-    }};\n-}\n-\n-pub(crate) use throw_invalid_nested_attr;"}, {"sha": "2f42a3b0bd4819ea5a1fb55886c0ecc94a2d1e6b", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 37, "deletions": 41, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/af74ef89934ad30b24132b464b6b4cf7cb0e1381/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af74ef89934ad30b24132b464b6b4cf7cb0e1381/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=af74ef89934ad30b24132b464b6b4cf7cb0e1381", "patch": "@@ -1,8 +1,7 @@\n #![deny(unused_must_use)]\n \n use crate::diagnostics::error::{\n-    invalid_attr, span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err,\n-    DiagnosticDeriveError,\n+    invalid_attr, span_err, throw_invalid_attr, throw_span_err, DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n     build_field_mapping, is_doc_comment, new_code_ident,\n@@ -11,7 +10,7 @@ use crate::diagnostics::utils::{\n };\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote};\n-use syn::{spanned::Spanned, Attribute, Meta, MetaList, NestedMeta, Path};\n+use syn::{spanned::Spanned, Attribute, Meta, MetaList, Path};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n use super::utils::{build_suggestion_code, AllowMultipleAlternatives};\n@@ -39,7 +38,8 @@ impl SubdiagnosticDeriveBuilder {\n                     span_err(\n                         span,\n                         \"`#[derive(Subdiagnostic)]` can only be used on structs and enums\",\n-                    );\n+                    )\n+                    .emit();\n                 }\n             }\n \n@@ -192,7 +192,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n             };\n \n             let Some(slug) = slug else {\n-                let name = attr.path.segments.last().unwrap().ident.to_string();\n+                let name = attr.path().segments.last().unwrap().ident.to_string();\n                 let name = name.as_str();\n \n                 throw_span_err!(\n@@ -265,17 +265,18 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n         info: FieldInfo<'_>,\n         clone_suggestion_code: bool,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n-        let meta = attr.parse_meta()?;\n-        match meta {\n-            Meta::Path(path) => self.generate_field_code_inner_path(kind_stats, attr, info, path),\n-            Meta::List(list @ MetaList { .. }) => self.generate_field_code_inner_list(\n+        match &attr.meta {\n+            Meta::Path(path) => {\n+                self.generate_field_code_inner_path(kind_stats, attr, info, path.clone())\n+            }\n+            Meta::List(list) => self.generate_field_code_inner_list(\n                 kind_stats,\n                 attr,\n                 info,\n                 list,\n                 clone_suggestion_code,\n             ),\n-            _ => throw_invalid_attr!(attr, &meta),\n+            _ => throw_invalid_attr!(attr),\n         }\n     }\n \n@@ -296,7 +297,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n             \"skip_arg\" => Ok(quote! {}),\n             \"primary_span\" => {\n                 if kind_stats.has_multipart_suggestion {\n-                    invalid_attr(attr, &Meta::Path(path))\n+                    invalid_attr(attr)\n                         .help(\n                             \"multipart suggestions use one or more `#[suggestion_part]`s rather \\\n                             than one `#[primary_span]`\",\n@@ -309,7 +310,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                     // FIXME(#100717): support `Option<Span>` on `primary_span` like in the\n                     // diagnostic derive\n                     if !matches!(info.ty, FieldInnerTy::Plain(_)) {\n-                        throw_invalid_attr!(attr, &Meta::Path(path), |diag| {\n+                        throw_invalid_attr!(attr, |diag| {\n                             let diag = diag.note(\"there must be exactly one primary span\");\n \n                             if kind_stats.has_normal_suggestion {\n@@ -335,7 +336,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                     span_err(span, \"`#[suggestion_part(...)]` attribute without `code = \\\"...\\\"`\")\n                         .emit();\n                 } else {\n-                    invalid_attr(attr, &Meta::Path(path))\n+                    invalid_attr(attr)\n                         .help(\n                             \"`#[suggestion_part(...)]` is only valid in multipart suggestions, \\\n                              use `#[primary_span]` instead\",\n@@ -375,7 +376,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                     span_attrs.push(\"primary_span\")\n                 }\n \n-                invalid_attr(attr, &Meta::Path(path))\n+                invalid_attr(attr)\n                     .help(format!(\n                         \"only `{}`, `applicability` and `skip_arg` are valid field attributes\",\n                         span_attrs.join(\", \")\n@@ -394,7 +395,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n         kind_stats: KindsStatistics,\n         attr: &Attribute,\n         info: FieldInfo<'_>,\n-        list: MetaList,\n+        list: &MetaList,\n         clone_suggestion_code: bool,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n         let span = attr.span().unwrap();\n@@ -405,7 +406,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n         match name {\n             \"suggestion_part\" => {\n                 if !kind_stats.has_multipart_suggestion {\n-                    throw_invalid_attr!(attr, &Meta::List(list), |diag| {\n+                    throw_invalid_attr!(attr, |diag| {\n                         diag.help(\n                             \"`#[suggestion_part(...)]` is only valid in multipart suggestions\",\n                         )\n@@ -417,31 +418,26 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                 report_error_if_not_applied_to_span(attr, &info)?;\n \n                 let mut code = None;\n-                for nested_attr in list.nested.iter() {\n-                    let NestedMeta::Meta(ref meta) = nested_attr else {\n-                        throw_invalid_nested_attr!(attr, nested_attr);\n-                    };\n-\n-                    let span = meta.span().unwrap();\n-                    let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n-                    let nested_name = nested_name.as_str();\n-\n-                    match nested_name {\n-                        \"code\" => {\n-                            let code_field = new_code_ident();\n-                            let formatting_init = build_suggestion_code(\n-                                &code_field,\n-                                meta,\n-                                self,\n-                                AllowMultipleAlternatives::No,\n-                            );\n-                            code.set_once((code_field, formatting_init), span);\n-                        }\n-                        _ => throw_invalid_nested_attr!(attr, nested_attr, |diag| {\n-                            diag.help(\"`code` is the only valid nested attribute\")\n-                        }),\n+\n+                list.parse_nested_meta(|nested| {\n+                    if nested.path.is_ident(\"code\") {\n+                        let code_field = new_code_ident();\n+                        let formatting_init = build_suggestion_code(\n+                            &code_field,\n+                            nested,\n+                            self,\n+                            AllowMultipleAlternatives::No,\n+                        );\n+                        code.set_once((code_field, formatting_init), span);\n+                    } else {\n+                        span_err(\n+                            nested.path.span().unwrap(),\n+                            \"`code` is the only valid nested attribute\",\n+                        )\n+                        .emit();\n                     }\n-                }\n+                    Ok(())\n+                })?;\n \n                 let Some((code_field, formatting_init)) = code.value() else {\n                     span_err(span, \"`#[suggestion_part(...)]` attribute without `code = \\\"...\\\"`\")\n@@ -458,7 +454,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                 };\n                 Ok(quote! { suggestions.push((#binding, #code_field)); })\n             }\n-            _ => throw_invalid_attr!(attr, &Meta::List(list), |diag| {\n+            _ => throw_invalid_attr!(attr, |diag| {\n                 let mut span_attrs = vec![];\n                 if kind_stats.has_multipart_suggestion {\n                     span_attrs.push(\"suggestion_part\");"}, {"sha": "38292df6d85428f5e857a6e32c39758905dbe8ea", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 89, "deletions": 97, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/af74ef89934ad30b24132b464b6b4cf7cb0e1381/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af74ef89934ad30b24132b464b6b4cf7cb0e1381/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=af74ef89934ad30b24132b464b6b4cf7cb0e1381", "patch": "@@ -1,5 +1,5 @@\n use crate::diagnostics::error::{\n-    span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err, DiagnosticDeriveError,\n+    span_err, throw_invalid_attr, throw_span_err, DiagnosticDeriveError,\n };\n use proc_macro::Span;\n use proc_macro2::{Ident, TokenStream};\n@@ -8,11 +8,13 @@ use std::cell::RefCell;\n use std::collections::{BTreeSet, HashMap};\n use std::fmt;\n use std::str::FromStr;\n+use syn::meta::ParseNestedMeta;\n+use syn::punctuated::Punctuated;\n+use syn::{parenthesized, LitStr, Path, Token};\n use syn::{spanned::Spanned, Attribute, Field, Meta, Type, TypeTuple};\n-use syn::{MetaList, MetaNameValue, NestedMeta, Path};\n use synstructure::{BindingInfo, VariantInfo};\n \n-use super::error::{invalid_attr, invalid_nested_attr};\n+use super::error::invalid_attr;\n \n thread_local! {\n     pub static CODE_IDENT_COUNT: RefCell<u32> = RefCell::new(0);\n@@ -60,8 +62,8 @@ pub(crate) fn report_type_error(\n     attr: &Attribute,\n     ty_name: &str,\n ) -> Result<!, DiagnosticDeriveError> {\n-    let name = attr.path.segments.last().unwrap().ident.to_string();\n-    let meta = attr.parse_meta()?;\n+    let name = attr.path().segments.last().unwrap().ident.to_string();\n+    let meta = &attr.meta;\n \n     throw_span_err!(\n         attr.span().unwrap(),\n@@ -422,55 +424,53 @@ pub(super) enum AllowMultipleAlternatives {\n /// `#[suggestion*(code(\"foo\", \"bar\"))]` attribute field\n pub(super) fn build_suggestion_code(\n     code_field: &Ident,\n-    meta: &Meta,\n+    nested: ParseNestedMeta<'_>,\n     fields: &impl HasFieldMap,\n     allow_multiple: AllowMultipleAlternatives,\n ) -> TokenStream {\n-    let values = match meta {\n-        // `code = \"foo\"`\n-        Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => vec![s],\n-        // `code(\"foo\", \"bar\")`\n-        Meta::List(MetaList { nested, .. }) => {\n+    let values = match (|| {\n+        let values: Vec<LitStr> = if let Ok(val) = nested.value() {\n+            vec![val.parse()?]\n+        } else {\n+            let content;\n+            parenthesized!(content in nested.input);\n+\n             if let AllowMultipleAlternatives::No = allow_multiple {\n                 span_err(\n-                    meta.span().unwrap(),\n+                    nested.input.span().unwrap(),\n                     \"expected exactly one string literal for `code = ...`\",\n                 )\n                 .emit();\n                 vec![]\n-            } else if nested.is_empty() {\n-                span_err(\n-                    meta.span().unwrap(),\n-                    \"expected at least one string literal for `code(...)`\",\n-                )\n-                .emit();\n-                vec![]\n             } else {\n-                nested\n-                    .into_iter()\n-                    .filter_map(|item| {\n-                        if let NestedMeta::Lit(syn::Lit::Str(s)) = item {\n-                            Some(s)\n-                        } else {\n-                            span_err(\n-                                item.span().unwrap(),\n-                                \"`code(...)` must contain only string literals\",\n-                            )\n-                            .emit();\n-                            None\n-                        }\n-                    })\n-                    .collect()\n+                let literals = Punctuated::<LitStr, Token![,]>::parse_terminated(&content);\n+\n+                match literals {\n+                    Ok(p) if p.is_empty() => {\n+                        span_err(\n+                            content.span().unwrap(),\n+                            \"expected at least one string literal for `code(...)`\",\n+                        )\n+                        .emit();\n+                        vec![]\n+                    }\n+                    Ok(p) => p.into_iter().collect(),\n+                    Err(_) => {\n+                        span_err(\n+                            content.span().unwrap(),\n+                            \"`code(...)` must contain only string literals\",\n+                        )\n+                        .emit();\n+                        vec![]\n+                    }\n+                }\n             }\n-        }\n-        _ => {\n-            span_err(\n-                meta.span().unwrap(),\n-                r#\"`code = \"...\"`/`code(...)` must contain only string literals\"#,\n-            )\n-            .emit();\n-            vec![]\n-        }\n+        };\n+\n+        Ok(values)\n+    })() {\n+        Ok(x) => x,\n+        Err(e) => return e.into_compile_error(),\n     };\n \n     if let AllowMultipleAlternatives::Yes = allow_multiple {\n@@ -601,11 +601,9 @@ impl SubdiagnosticKind {\n \n         let span = attr.span().unwrap();\n \n-        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let name = attr.path().segments.last().unwrap().ident.to_string();\n         let name = name.as_str();\n \n-        let meta = attr.parse_meta()?;\n-\n         let mut kind = match name {\n             \"label\" => SubdiagnosticKind::Label,\n             \"note\" => SubdiagnosticKind::Note,\n@@ -618,7 +616,7 @@ impl SubdiagnosticKind {\n                     name.strip_prefix(\"suggestion\").and_then(SuggestionKind::from_suffix)\n                 {\n                     if suggestion_kind != SuggestionKind::Normal {\n-                        invalid_attr(attr, &meta)\n+                        invalid_attr(attr)\n                             .help(format!(\n                                 r#\"Use `#[suggestion(..., style = \"{suggestion_kind}\")]` instead\"#\n                             ))\n@@ -635,7 +633,7 @@ impl SubdiagnosticKind {\n                     name.strip_prefix(\"multipart_suggestion\").and_then(SuggestionKind::from_suffix)\n                 {\n                     if suggestion_kind != SuggestionKind::Normal {\n-                        invalid_attr(attr, &meta)\n+                        invalid_attr(attr)\n                             .help(format!(\n                                 r#\"Use `#[multipart_suggestion(..., style = \"{suggestion_kind}\")]` instead\"#\n                             ))\n@@ -647,16 +645,16 @@ impl SubdiagnosticKind {\n                         applicability: None,\n                     }\n                 } else {\n-                    throw_invalid_attr!(attr, &meta);\n+                    throw_invalid_attr!(attr);\n                 }\n             }\n         };\n \n-        let nested = match meta {\n-            Meta::List(MetaList { ref nested, .. }) => {\n+        let list = match &attr.meta {\n+            Meta::List(list) => {\n                 // An attribute with properties, such as `#[suggestion(code = \"...\")]` or\n                 // `#[error(some::slug)]`\n-                nested\n+                list\n             }\n             Meta::Path(_) => {\n                 // An attribute without a slug or other properties, such as `#[note]` - return\n@@ -678,52 +676,51 @@ impl SubdiagnosticKind {\n                 }\n             }\n             _ => {\n-                throw_invalid_attr!(attr, &meta)\n+                throw_invalid_attr!(attr)\n             }\n         };\n \n         let mut code = None;\n         let mut suggestion_kind = None;\n \n-        let mut nested_iter = nested.into_iter().peekable();\n+        let mut first = true;\n+        let mut slug = None;\n \n-        // Peek at the first nested attribute: if it's a slug path, consume it.\n-        let slug = if let Some(NestedMeta::Meta(Meta::Path(path))) = nested_iter.peek() {\n-            let path = path.clone();\n-            // Advance the iterator.\n-            nested_iter.next();\n-            Some(path)\n-        } else {\n-            None\n-        };\n-\n-        for nested_attr in nested_iter {\n-            let meta = match nested_attr {\n-                NestedMeta::Meta(ref meta) => meta,\n-                NestedMeta::Lit(_) => {\n-                    invalid_nested_attr(attr, nested_attr).emit();\n-                    continue;\n+        list.parse_nested_meta(|nested| {\n+            if nested.input.is_empty() || nested.input.peek(Token![,]) {\n+                if first {\n+                    slug = Some(nested.path);\n+                } else {\n+                    span_err(nested.input.span().unwrap(), \"a diagnostic slug must be the first argument to the attribute\").emit();\n                 }\n-            };\n \n-            let span = meta.span().unwrap();\n-            let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n+                first = false;\n+                return Ok(());\n+            }\n+\n+            first = false;\n+\n+            let nested_name = nested.path.segments.last().unwrap().ident.to_string();\n             let nested_name = nested_name.as_str();\n \n-            let string_value = match meta {\n-                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) => Some(value),\n+            let path_span = nested.path.span().unwrap();\n+            let val_span = nested.input.span().unwrap();\n \n-                Meta::Path(_) => throw_invalid_nested_attr!(attr, nested_attr, |diag| {\n-                    diag.help(\"a diagnostic slug must be the first argument to the attribute\")\n-                }),\n-                _ => None,\n-            };\n+            macro get_string() {\n+                {\n+                    let Ok(value) = nested.value().and_then(|x| x.parse::<LitStr>()) else {\n+                        span_err(val_span, \"expected `= \\\"xxx\\\"`\").emit();\n+                        return Ok(());\n+                    };\n+                    value\n+                }\n+            }\n \n             match (nested_name, &mut kind) {\n                 (\"code\", SubdiagnosticKind::Suggestion { code_field, .. }) => {\n                     let code_init = build_suggestion_code(\n                         code_field,\n-                        meta,\n+                        nested,\n                         fields,\n                         AllowMultipleAlternatives::Yes,\n                     );\n@@ -734,13 +731,9 @@ impl SubdiagnosticKind {\n                     SubdiagnosticKind::Suggestion { ref mut applicability, .. }\n                     | SubdiagnosticKind::MultipartSuggestion { ref mut applicability, .. },\n                 ) => {\n-                    let Some(value) = string_value else {\n-                        invalid_nested_attr(attr, nested_attr).emit();\n-                        continue;\n-                    };\n-\n+                    let value = get_string!();\n                     let value = Applicability::from_str(&value.value()).unwrap_or_else(|()| {\n-                        span_err(span, \"invalid applicability\").emit();\n+                        span_err(value.span().unwrap(), \"invalid applicability\").emit();\n                         Applicability::Unspecified\n                     });\n                     applicability.set_once(value, span);\n@@ -750,10 +743,7 @@ impl SubdiagnosticKind {\n                     SubdiagnosticKind::Suggestion { .. }\n                     | SubdiagnosticKind::MultipartSuggestion { .. },\n                 ) => {\n-                    let Some(value) = string_value else {\n-                        invalid_nested_attr(attr, nested_attr).emit();\n-                        continue;\n-                    };\n+                    let value = get_string!();\n \n                     let value = value.value().parse().unwrap_or_else(|()| {\n                         span_err(value.span().unwrap(), \"invalid suggestion style\")\n@@ -767,22 +757,24 @@ impl SubdiagnosticKind {\n \n                 // Invalid nested attribute\n                 (_, SubdiagnosticKind::Suggestion { .. }) => {\n-                    invalid_nested_attr(attr, nested_attr)\n+                    span_err(path_span, \"invalid nested attribute\")\n                         .help(\n                             \"only `style`, `code` and `applicability` are valid nested attributes\",\n                         )\n                         .emit();\n                 }\n                 (_, SubdiagnosticKind::MultipartSuggestion { .. }) => {\n-                    invalid_nested_attr(attr, nested_attr)\n+                    span_err(path_span, \"invalid nested attribute\")\n                         .help(\"only `style` and `applicability` are valid nested attributes\")\n-                        .emit()\n+                        .emit();\n                 }\n                 _ => {\n-                    invalid_nested_attr(attr, nested_attr).emit();\n+                    span_err(path_span, \"invalid nested attribute\").emit();\n                 }\n             }\n-        }\n+\n+            Ok(())\n+        })?;\n \n         match kind {\n             SubdiagnosticKind::Suggestion {\n@@ -845,5 +837,5 @@ pub(super) fn should_generate_set_arg(field: &Field) -> bool {\n }\n \n pub(super) fn is_doc_comment(attr: &Attribute) -> bool {\n-    attr.path.segments.last().unwrap().ident == \"doc\"\n+    attr.path().segments.last().unwrap().ident == \"doc\"\n }"}, {"sha": "75a2f7009c2589d7e684a4b1f74ca6c2cdcd5b2e", "filename": "compiler/rustc_macros/src/hash_stable.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/af74ef89934ad30b24132b464b6b4cf7cb0e1381/compiler%2Frustc_macros%2Fsrc%2Fhash_stable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af74ef89934ad30b24132b464b6b4cf7cb0e1381/compiler%2Frustc_macros%2Fsrc%2Fhash_stable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fhash_stable.rs?ref=af74ef89934ad30b24132b464b6b4cf7cb0e1381", "patch": "@@ -1,6 +1,6 @@\n use proc_macro2::{self, Ident};\n use quote::quote;\n-use syn::{self, parse_quote, Meta, NestedMeta};\n+use syn::{self, parse_quote};\n \n struct Attributes {\n     ignore: bool,\n@@ -10,32 +10,29 @@ struct Attributes {\n fn parse_attributes(field: &syn::Field) -> Attributes {\n     let mut attrs = Attributes { ignore: false, project: None };\n     for attr in &field.attrs {\n-        if let Ok(meta) = attr.parse_meta() {\n-            if !meta.path().is_ident(\"stable_hasher\") {\n-                continue;\n+        let meta = &attr.meta;\n+        if !meta.path().is_ident(\"stable_hasher\") {\n+            continue;\n+        }\n+        let mut any_attr = false;\n+        let _ = attr.parse_nested_meta(|nested| {\n+            if nested.path.is_ident(\"ignore\") {\n+                attrs.ignore = true;\n+                any_attr = true;\n             }\n-            let mut any_attr = false;\n-            if let Meta::List(list) = meta {\n-                for nested in list.nested.iter() {\n-                    if let NestedMeta::Meta(meta) = nested {\n-                        if meta.path().is_ident(\"ignore\") {\n-                            attrs.ignore = true;\n-                            any_attr = true;\n-                        }\n-                        if meta.path().is_ident(\"project\") {\n-                            if let Meta::List(list) = meta {\n-                                if let Some(NestedMeta::Meta(meta)) = list.nested.iter().next() {\n-                                    attrs.project = meta.path().get_ident().cloned();\n-                                    any_attr = true;\n-                                }\n-                            }\n-                        }\n+            if nested.path.is_ident(\"project\") {\n+                let _ = nested.parse_nested_meta(|meta| {\n+                    if attrs.project.is_none() {\n+                        attrs.project = meta.path.get_ident().cloned();\n                     }\n-                }\n-            }\n-            if !any_attr {\n-                panic!(\"error parsing stable_hasher\");\n+                    any_attr = true;\n+                    Ok(())\n+                });\n             }\n+            Ok(())\n+        });\n+        if !any_attr {\n+            panic!(\"error parsing stable_hasher\");\n         }\n     }\n     attrs"}, {"sha": "04e762e91de34c355108e20c46fee450b5aa6ee2", "filename": "compiler/rustc_macros/src/newtype.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af74ef89934ad30b24132b464b6b4cf7cb0e1381/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af74ef89934ad30b24132b464b6b4cf7cb0e1381/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs?ref=af74ef89934ad30b24132b464b6b4cf7cb0e1381", "patch": "@@ -25,7 +25,7 @@ impl Parse for Newtype {\n         let mut encodable = true;\n         let mut ord = true;\n \n-        attrs.retain(|attr| match attr.path.get_ident() {\n+        attrs.retain(|attr| match attr.path().get_ident() {\n             Some(ident) => match &*ident.to_string() {\n                 \"custom_encodable\" => {\n                     encodable = false;\n@@ -36,22 +36,22 @@ impl Parse for Newtype {\n                     false\n                 }\n                 \"max\" => {\n-                    let Ok(Meta::NameValue(literal) )= attr.parse_meta() else {\n+                    let Meta::NameValue(MetaNameValue { value: Expr::Lit(lit), .. }) = &attr.meta else {\n                         panic!(\"#[max = NUMBER] attribute requires max value\");\n                     };\n \n-                    if let Some(old) = max.replace(literal.lit) {\n+                    if let Some(old) = max.replace(lit.lit.clone()) {\n                         panic!(\"Specified multiple max: {old:?}\");\n                     }\n \n                     false\n                 }\n                 \"debug_format\" => {\n-                    let Ok(Meta::NameValue(literal) )= attr.parse_meta() else {\n+                    let Meta::NameValue(MetaNameValue { value: Expr::Lit(lit), .. } ) = &attr.meta else {\n                         panic!(\"#[debug_format = FMT] attribute requires a format\");\n                     };\n \n-                    if let Some(old) = debug_format.replace(literal.lit) {\n+                    if let Some(old) = debug_format.replace(lit.lit.clone()) {\n                         panic!(\"Specified multiple debug format options: {old:?}\");\n                     }\n "}, {"sha": "f85ba38003c13a39599c31959e049d8ef3a7b32b", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af74ef89934ad30b24132b464b6b4cf7cb0e1381/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af74ef89934ad30b24132b464b6b4cf7cb0e1381/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=af74ef89934ad30b24132b464b6b4cf7cb0e1381", "patch": "@@ -15,7 +15,7 @@ mod kw {\n /// Ensures only doc comment attributes are used\n fn check_attributes(attrs: Vec<Attribute>) -> Result<Vec<Attribute>> {\n     let inner = |attr: Attribute| {\n-        if !attr.path.is_ident(\"doc\") {\n+        if !attr.path().is_ident(\"doc\") {\n             Err(Error::new(attr.span(), \"attributes not supported on queries\"))\n         } else if attr.style != AttrStyle::Outer {\n             Err(Error::new(\n@@ -48,7 +48,7 @@ impl Parse for Query {\n         let name: Ident = input.parse()?;\n         let arg_content;\n         parenthesized!(arg_content in input);\n-        let key = arg_content.parse()?;\n+        let key = Pat::parse_single(&arg_content)?;\n         arg_content.parse::<Token![:]>()?;\n         let arg = arg_content.parse()?;\n         let result = input.parse()?;\n@@ -158,15 +158,15 @@ fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n             } else {\n                 None\n             };\n-            let list = attr_content.parse_terminated(Expr::parse)?;\n+            let list = attr_content.parse_terminated(Expr::parse, Token![,])?;\n             try_insert!(desc = (tcx, list));\n         } else if modifier == \"cache_on_disk_if\" {\n             // Parse a cache modifier like:\n             // `cache(tcx) { |tcx| key.is_local() }`\n             let args = if input.peek(token::Paren) {\n                 let args;\n                 parenthesized!(args in input);\n-                let tcx = args.parse()?;\n+                let tcx = Pat::parse_single(&args)?;\n                 Some(tcx)\n             } else {\n                 None"}, {"sha": "5ee4d8793135ca8865982460f621012f015edd27", "filename": "compiler/rustc_macros/src/type_foldable.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/af74ef89934ad30b24132b464b6b4cf7cb0e1381/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af74ef89934ad30b24132b464b6b4cf7cb0e1381/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs?ref=af74ef89934ad30b24132b464b6b4cf7cb0e1381", "patch": "@@ -1,5 +1,5 @@\n use quote::{quote, ToTokens};\n-use syn::{parse_quote, Attribute, Meta, NestedMeta};\n+use syn::parse_quote;\n \n pub fn type_foldable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n     if let syn::Data::Union(_) = s.ast().data {\n@@ -17,21 +17,20 @@ pub fn type_foldable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::\n         vi.construct(|_, index| {\n             let bind = &bindings[index];\n \n+            let mut fixed = false;\n+\n             // retain value of fields with #[type_foldable(identity)]\n-            let fixed = bind\n-                .ast()\n-                .attrs\n-                .iter()\n-                .map(Attribute::parse_meta)\n-                .filter_map(Result::ok)\n-                .flat_map(|attr| match attr {\n-                    Meta::List(list) if list.path.is_ident(\"type_foldable\") => list.nested,\n-                    _ => Default::default(),\n-                })\n-                .any(|nested| match nested {\n-                    NestedMeta::Meta(Meta::Path(path)) => path.is_ident(\"identity\"),\n-                    _ => false,\n+            bind.ast().attrs.iter().for_each(|x| {\n+                if !x.path().is_ident(\"type_foldable\") {\n+                    return;\n+                }\n+                let _ = x.parse_nested_meta(|nested| {\n+                    if nested.path.is_ident(\"identity\") {\n+                        fixed = true;\n+                    }\n+                    Ok(())\n                 });\n+            });\n \n             if fixed {\n                 bind.to_token_stream()"}, {"sha": "dcd505a105e579c8387f696b82b70b94e8d0655f", "filename": "compiler/rustc_macros/src/type_visitable.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/af74ef89934ad30b24132b464b6b4cf7cb0e1381/compiler%2Frustc_macros%2Fsrc%2Ftype_visitable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af74ef89934ad30b24132b464b6b4cf7cb0e1381/compiler%2Frustc_macros%2Fsrc%2Ftype_visitable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Ftype_visitable.rs?ref=af74ef89934ad30b24132b464b6b4cf7cb0e1381", "patch": "@@ -1,5 +1,5 @@\n use quote::quote;\n-use syn::{parse_quote, Attribute, Meta, NestedMeta};\n+use syn::parse_quote;\n \n pub fn type_visitable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n     if let syn::Data::Union(_) = s.ast().data {\n@@ -8,19 +8,21 @@ pub fn type_visitable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2:\n \n     // ignore fields with #[type_visitable(ignore)]\n     s.filter(|bi| {\n-        !bi.ast()\n-            .attrs\n-            .iter()\n-            .map(Attribute::parse_meta)\n-            .filter_map(Result::ok)\n-            .flat_map(|attr| match attr {\n-                Meta::List(list) if list.path.is_ident(\"type_visitable\") => list.nested,\n-                _ => Default::default(),\n-            })\n-            .any(|nested| match nested {\n-                NestedMeta::Meta(Meta::Path(path)) => path.is_ident(\"ignore\"),\n-                _ => false,\n-            })\n+        let mut ignored = false;\n+\n+        bi.ast().attrs.iter().for_each(|attr| {\n+            if !attr.path().is_ident(\"type_visitable\") {\n+                return;\n+            }\n+            let _ = attr.parse_nested_meta(|nested| {\n+                if nested.path.is_ident(\"ignore\") {\n+                    ignored = true;\n+                }\n+                Ok(())\n+            });\n+        });\n+\n+        !ignored\n     });\n \n     if !s.ast().generics.lifetimes().any(|lt| lt.lifetime.ident == \"tcx\") {"}]}