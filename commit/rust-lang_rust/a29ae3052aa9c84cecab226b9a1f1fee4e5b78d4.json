{"sha": "a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyOWFlMzA1MmFhOWM4NGNlY2FiMjI2YjlhMWYxZmVlNGU1Yjc4ZDQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-20T22:35:16Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-23T17:27:28Z"}, "message": "convert inherent-impl-related things to on-demand queries\n\nThere are now 3 queries:\n\n- inherent_impls(def-id): for a given type, get a `Rc<Vec<DefId>>` with\n  all its inherent impls. This internally uses `crate_inherent_impls`,\n  doing some hacks to keep the current deps (which, btw, are not clearly\n  correct).\n- crate_inherent_impls(crate): gathers up a map from types\n  to `Rc<Vec<DefId>>`, touching the entire krate, possibly generating\n  errors.\n- crate_inherent_impls_overlap_check(crate): performs overlap checks\n  between the inherent impls for a given type, generating errors.", "tree": {"sha": "9ac6761d75e9d4f7f1454cd4605c6eff6fca4322", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ac6761d75e9d4f7f1454cd4605c6eff6fca4322"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4", "html_url": "https://github.com/rust-lang/rust/commit/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e6b10a6cb349deab30fa0fb507a8c73cae6ec68", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e6b10a6cb349deab30fa0fb507a8c73cae6ec68", "html_url": "https://github.com/rust-lang/rust/commit/8e6b10a6cb349deab30fa0fb507a8c73cae6ec68"}], "stats": {"total": 413, "additions": 227, "deletions": 186}, "files": [{"sha": "c4cbbc17d51df7c7fd328e60d092e7735229e155", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4", "patch": "@@ -74,7 +74,6 @@ pub enum DepNode<D: Clone + Debug> {\n     CoherenceCheckImpl(D),\n     CoherenceOverlapCheck(D),\n     CoherenceOverlapCheckSpecial(D),\n-    CoherenceOverlapInherentCheck(D),\n     CoherenceOrphanCheck(D),\n     Variance,\n     WfCheck(D),\n@@ -251,7 +250,6 @@ impl<D: Clone + Debug> DepNode<D> {\n             CoherenceCheckImpl(ref d) => op(d).map(CoherenceCheckImpl),\n             CoherenceOverlapCheck(ref d) => op(d).map(CoherenceOverlapCheck),\n             CoherenceOverlapCheckSpecial(ref d) => op(d).map(CoherenceOverlapCheckSpecial),\n-            CoherenceOverlapInherentCheck(ref d) => op(d).map(CoherenceOverlapInherentCheck),\n             CoherenceOrphanCheck(ref d) => op(d).map(CoherenceOrphanCheck),\n             WfCheck(ref d) => op(d).map(WfCheck),\n             TypeckItemType(ref d) => op(d).map(TypeckItemType),"}, {"sha": "b6a2360211cac92610410d081de314d4c45a2148", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4", "patch": "@@ -81,21 +81,6 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n     pub fn keys(&self) -> Vec<M::Key> {\n         self.map.keys().cloned().collect()\n     }\n-\n-    /// Append `elem` to the vector stored for `k`, creating a new vector if needed.\n-    /// This is considered a write to `k`.\n-    ///\n-    /// NOTE: Caution is required when using this method. You should\n-    /// be sure that nobody is **reading from the vector** while you\n-    /// are writing to it. Eventually, it'd be nice to remove this.\n-    pub fn push<E: Clone>(&mut self, k: M::Key, elem: E)\n-        where M: DepTrackingMapConfig<Value=Vec<E>>\n-    {\n-        self.write(&k);\n-        self.map.entry(k)\n-                .or_insert(Vec::new())\n-                .push(elem);\n-    }\n }\n \n impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {"}, {"sha": "50ec6f26d4b82839cf84964bb4f1b2fb40284758", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4", "patch": "@@ -176,7 +176,6 @@ pub trait CrateStore {\n     fn item_generics_cloned(&self, def: DefId) -> ty::Generics;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>;\n-    fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n \n     // trait info\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>;\n@@ -310,7 +309,6 @@ impl CrateStore for DummyCrateStore {\n         { bug!(\"item_generics_cloned\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name> { bug!(\"fn_arg_names\") }\n-    fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n \n     // trait info\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId> { vec![] }"}, {"sha": "87fe27d92fca6d15b2349a13c4ee48b0278729a2", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4", "patch": "@@ -12,7 +12,7 @@ use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use middle::const_val::ConstVal;\n use mir;\n-use ty::{self, Ty, TyCtxt};\n+use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use std::cell::{RefCell, RefMut};\n@@ -176,9 +176,15 @@ impl<'tcx> QueryDescription for queries::coherent_trait<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::coherent_inherent_impls<'tcx> {\n+impl<'tcx> QueryDescription for queries::crate_inherent_impls<'tcx> {\n+    fn describe(_: TyCtxt, k: CrateNum) -> String {\n+        format!(\"all inherent impls defined in crate `{:?}`\", k)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_inherent_impls_overlap_check<'tcx> {\n     fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        format!(\"coherence checking all inherent impls\")\n+        format!(\"check for overlap between inherent impls defined in this crate\")\n     }\n }\n \n@@ -368,7 +374,7 @@ define_maps! { <'tcx>\n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n     /// Methods in these implementations don't need to be exported.\n-    pub inherent_impls: InherentImpls(DefId) -> Vec<DefId>,\n+    pub inherent_impls: InherentImpls(DefId) -> Rc<Vec<DefId>>,\n \n     /// Maps from the def-id of a function/method or const/static\n     /// to its MIR. Mutation is done at an item granularity to\n@@ -400,7 +406,15 @@ define_maps! { <'tcx>\n \n     pub coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n \n-    pub coherent_inherent_impls: coherent_inherent_impls_dep_node(CrateNum) -> (),\n+    /// Gets a complete map from all types to their inherent impls.\n+    /// Not meant to be used directly outside of coherence.\n+    /// (Defined only for LOCAL_CRATE)\n+    pub crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum) -> CrateInherentImpls,\n+\n+    /// Checks all types in the krate for overlap in their inherent impls. Reports errors.\n+    /// Not meant to be used directly outside of coherence.\n+    /// (Defined only for LOCAL_CRATE)\n+    pub crate_inherent_impls_overlap_check: crate_inherent_impls_dep_node(CrateNum) -> (),\n \n     /// Results of evaluating monomorphic constants embedded in\n     /// other items, such as enum variant explicit discriminants.\n@@ -413,7 +427,7 @@ fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n     DepNode::CoherenceCheckTrait(def_id)\n }\n \n-fn coherent_inherent_impls_dep_node(_: CrateNum) -> DepNode<DefId> {\n+fn crate_inherent_impls_dep_node(_: CrateNum) -> DepNode<DefId> {\n     DepNode::Coherence\n }\n "}, {"sha": "d19f2ba2fadb19be2d25c646f9dc97d93681efab", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 14, "deletions": 29, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4", "patch": "@@ -31,7 +31,7 @@ use ty::subst::{Subst, Substs};\n use ty::util::IntTypeExt;\n use ty::walk::TypeWalker;\n use util::common::MemoizationMap;\n-use util::nodemap::{NodeSet, FxHashMap};\n+use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n \n use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n@@ -2345,34 +2345,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         def.flags.get().intersects(TraitFlags::HAS_DEFAULT_IMPL)\n     }\n \n-    /// Populates the type context with all the inherent implementations for\n-    /// the given type if necessary.\n-    pub fn populate_inherent_implementations_for_type_if_necessary(self,\n-                                                                   span: Span,\n-                                                                   type_id: DefId) {\n-        if type_id.is_local() {\n-            // Make sure coherence of inherent impls ran already.\n-            ty::queries::coherent_inherent_impls::force(self, span, LOCAL_CRATE);\n-            return\n-        }\n-\n-        // The type is not local, hence we are reading this out of\n-        // metadata and don't need to track edges.\n-        let _ignore = self.dep_graph.in_ignore();\n-\n-        if self.populated_external_types.borrow().contains(&type_id) {\n-            return\n-        }\n-\n-        debug!(\"populate_inherent_implementations_for_type_if_necessary: searching for {:?}\",\n-               type_id);\n-\n-        let inherent_impls = self.sess.cstore.inherent_implementations_for_type(type_id);\n-\n-        self.maps.inherent_impls.borrow_mut().insert(type_id, inherent_impls);\n-        self.populated_external_types.borrow_mut().insert(type_id);\n-    }\n-\n     /// Populates the type context with all the implementations for the given\n     /// trait if necessary.\n     pub fn populate_implementations_for_trait_if_necessary(self, trait_id: DefId) {\n@@ -2637,3 +2609,16 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         ..*providers\n     };\n }\n+\n+\n+/// A map for the local crate mapping each type to a vector of its\n+/// inherent impls. This is not meant to be used outside of coherence;\n+/// rather, you should request the vector for a specific type via\n+/// `ty::queries::inherent_impls::get(def_id)` so as to minimize your\n+/// dependencies (constructing this map requires touching the entire\n+/// crate).\n+#[derive(Clone, Debug)]\n+pub struct CrateInherentImpls {\n+    pub inherent_impls: DefIdMap<Rc<Vec<DefId>>>,\n+}\n+"}, {"sha": "9b781d28f88dc1ebf90ea17be4460b79b3fe79c5", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4", "patch": "@@ -109,6 +109,7 @@ provide! { <'tcx> tcx, def_id, cdata\n     typeck_tables => { cdata.item_body_tables(def_id.index, tcx) }\n     closure_kind => { cdata.closure_kind(def_id.index) }\n     closure_type => { cdata.closure_ty(def_id.index, tcx) }\n+    inherent_impls => { Rc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }\n }\n \n impl CrateStore for cstore::CStore {\n@@ -162,12 +163,6 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(did.krate).get_fn_arg_names(did.index)\n     }\n \n-    fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def_id));\n-        self.get_crate_data(def_id.krate).get_inherent_implementations_for_type(def_id.index)\n-    }\n-\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>\n     {\n         if let Some(def_id) = filter {"}, {"sha": "5b0418921563a2dea56b4fa4bbf47897b57f3fc8", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4", "patch": "@@ -479,14 +479,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn assemble_inherent_impl_candidates_for_type(&mut self, def_id: DefId) {\n-        // Read the inherent implementation candidates for this type from the\n-        // metadata if necessary.\n-        self.tcx.populate_inherent_implementations_for_type_if_necessary(self.span, def_id);\n-\n-        if let Some(impl_infos) = self.tcx.maps.inherent_impls.borrow().get(&def_id) {\n-            for &impl_def_id in impl_infos.iter() {\n-                self.assemble_inherent_impl_probe(impl_def_id);\n-            }\n+        let impl_def_ids = ty::queries::inherent_impls::get(self.tcx, self.span, def_id);\n+        for &impl_def_id in impl_def_ids.iter() {\n+            self.assemble_inherent_impl_probe(impl_def_id);\n         }\n     }\n "}, {"sha": "3a39df505eb07863ae2314bff3f2174dd419abe3", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "renamed", "additions": 74, "deletions": 106, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4", "patch": "@@ -8,26 +8,82 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! The code in this module gathers up all of the inherent impls in\n+//! the current crate and organizes them in a map. It winds up\n+//! touching the whole crate and thus must be recomputed completely\n+//! for any change, but it is very cheap to compute. In practice, most\n+//! code in the compiler never *directly* requests this map. Instead,\n+//! it requests the inherent impls specific to some type (via\n+//! `ty::queries::inherent_impls::get(def_id)`). That value, however,\n+//! is computed by selecting an idea from this table.\n+\n use rustc::dep_graph::DepNode;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::lint;\n-use rustc::traits::{self, Reveal};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, CrateInherentImpls, TyCtxt};\n+use rustc::util::nodemap::DefIdMap;\n \n+use std::rc::Rc;\n use syntax::ast;\n-use syntax_pos::Span;\n+use syntax_pos::{DUMMY_SP, Span};\n+\n+/// On-demand query: yields a map containing all types mapped to their inherent impls.\n+pub fn crate_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      crate_num: CrateNum)\n+                                      -> CrateInherentImpls {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n+\n+    let krate = tcx.hir.krate();\n+    let mut collect = InherentCollect {\n+        tcx,\n+        impls_map: CrateInherentImpls {\n+            inherent_impls: DefIdMap()\n+        }\n+    };\n+    krate.visit_all_item_likes(&mut collect);\n+    collect.impls_map\n+}\n+\n+/// On-demand query: yields a vector of the inherent impls for a specific type.\n+pub fn inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                ty_def_id: DefId)\n+                                -> Rc<Vec<DefId>> {\n+    assert!(ty_def_id.is_local());\n+\n+    // NB. Until we adopt the red-green dep-tracking algorithm (see\n+    // [the plan] for details on that), we do some hackery here to get\n+    // the dependencies correct.  Basically, we use a `with_ignore` to\n+    // read the result we want. If we didn't have the `with_ignore`,\n+    // we would wind up with a dependency on the entire crate, which\n+    // we don't want. Then we go and add dependencies on all the impls\n+    // in the result (which is what we wanted).\n+    //\n+    // The result is a graph with an edge from `Hir(I)` for every impl\n+    // `I` defined on some type `T` to `CoherentInherentImpls(T)`,\n+    // thus ensuring that if any of those impls change, the set of\n+    // inherent impls is considered dirty.\n+    //\n+    // [the plan]: https://github.com/rust-lang/rust-roadmap/issues/4\n+\n+    let result = tcx.dep_graph.with_ignore(|| {\n+        let crate_map = ty::queries::crate_inherent_impls::get(tcx, DUMMY_SP, ty_def_id.krate);\n+        match crate_map.inherent_impls.get(&ty_def_id) {\n+            Some(v) => v.clone(),\n+            None => Rc::new(vec![]),\n+        }\n+    });\n+\n+    for &impl_def_id in &result[..] {\n+        tcx.dep_graph.read(DepNode::Hir(impl_def_id));\n+    }\n \n-pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.visit_all_item_likes_in_krate(DepNode::CoherenceCheckImpl,\n-                                      &mut InherentCollect { tcx });\n-    tcx.visit_all_item_likes_in_krate(DepNode::CoherenceOverlapCheckSpecial,\n-                                      &mut InherentOverlapChecker { tcx });\n+    result\n }\n \n struct InherentCollect<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    impls_map: CrateInherentImpls,\n }\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n@@ -216,25 +272,19 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n-    fn check_def_id(&self, item: &hir::Item, def_id: DefId) {\n+    fn check_def_id(&mut self, item: &hir::Item, def_id: DefId) {\n         if def_id.is_local() {\n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and\n             // the implementation does not have any associated traits.\n             let impl_def_id = self.tcx.hir.local_def_id(item.id);\n+            let mut rc_vec = self.impls_map.inherent_impls\n+                                           .entry(def_id)\n+                                           .or_insert_with(|| Rc::new(vec![]));\n \n-            // Subtle: it'd be better to collect these into a local map\n-            // and then write the vector only once all items are known,\n-            // but that leads to degenerate dep-graphs. The problem is\n-            // that the write of that big vector winds up having reads\n-            // from *all* impls in the krate, since we've lost the\n-            // precision basically.  This would be ok in the firewall\n-            // model so once we've made progess towards that we can modify\n-            // the strategy here. In the meantime, using `push` is ok\n-            // because we are doing this as a pre-pass before anyone\n-            // actually reads from `inherent_impls` -- and we know this is\n-            // true beacuse we hold the refcell lock.\n-            self.tcx.maps.inherent_impls.borrow_mut().push(def_id, impl_def_id);\n+            // At this point, there should not be any clones of the\n+            // `Rc`, so we can still safely push into it in place:\n+            Rc::get_mut(&mut rc_vec).unwrap().push(impl_def_id);\n         } else {\n             struct_span_err!(self.tcx.sess,\n                              item.span,\n@@ -273,85 +323,3 @@ impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n     }\n }\n \n-struct InherentOverlapChecker<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>\n-}\n-\n-impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n-    fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId) {\n-        #[derive(Copy, Clone, PartialEq)]\n-        enum Namespace {\n-            Type,\n-            Value,\n-        }\n-\n-        let name_and_namespace = |def_id| {\n-            let item = self.tcx.associated_item(def_id);\n-            (item.name, match item.kind {\n-                ty::AssociatedKind::Type => Namespace::Type,\n-                ty::AssociatedKind::Const |\n-                ty::AssociatedKind::Method => Namespace::Value,\n-            })\n-        };\n-\n-        let impl_items1 = self.tcx.associated_item_def_ids(impl1);\n-        let impl_items2 = self.tcx.associated_item_def_ids(impl2);\n-\n-        for &item1 in &impl_items1[..] {\n-            let (name, namespace) = name_and_namespace(item1);\n-\n-            for &item2 in &impl_items2[..] {\n-                if (name, namespace) == name_and_namespace(item2) {\n-                    let msg = format!(\"duplicate definitions with name `{}`\", name);\n-                    let node_id = self.tcx.hir.as_local_node_id(item1).unwrap();\n-                    self.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,\n-                                           node_id,\n-                                           self.tcx.span_of_impl(item1).unwrap(),\n-                                           msg);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn check_for_overlapping_inherent_impls(&self, ty_def_id: DefId) {\n-        let _task = self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapInherentCheck(ty_def_id));\n-\n-        let inherent_impls = self.tcx.maps.inherent_impls.borrow();\n-        let impls = match inherent_impls.get(&ty_def_id) {\n-            Some(impls) => impls,\n-            None => return,\n-        };\n-\n-        for (i, &impl1_def_id) in impls.iter().enumerate() {\n-            for &impl2_def_id in &impls[(i + 1)..] {\n-                self.tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n-                    if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n-                        self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n-                    }\n-                });\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentOverlapChecker<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &'v hir::Item) {\n-        match item.node {\n-            hir::ItemEnum(..) |\n-            hir::ItemStruct(..) |\n-            hir::ItemTrait(..) |\n-            hir::ItemUnion(..) => {\n-                let type_def_id = self.tcx.hir.local_def_id(item.id);\n-                self.check_for_overlapping_inherent_impls(type_def_id);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n-    }\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n-    }\n-}\n-", "previous_filename": "src/librustc_typeck/coherence/inherent.rs"}, {"sha": "4b36072243c810ae1f9b110faa3f8fc69580e784", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4", "patch": "@@ -0,0 +1,102 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc::hir;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::lint;\n+use rustc::traits::{self, Reveal};\n+use rustc::ty::{self, TyCtxt};\n+\n+use syntax_pos::DUMMY_SP;\n+\n+pub fn crate_inherent_impls_overlap_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                    crate_num: CrateNum) {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n+    let krate = tcx.hir.krate();\n+    krate.visit_all_item_likes(&mut InherentOverlapChecker { tcx });\n+}\n+\n+struct InherentOverlapChecker<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+}\n+\n+impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n+    fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId) {\n+        #[derive(Copy, Clone, PartialEq)]\n+        enum Namespace {\n+            Type,\n+            Value,\n+        }\n+\n+        let name_and_namespace = |def_id| {\n+            let item = self.tcx.associated_item(def_id);\n+            (item.name, match item.kind {\n+                ty::AssociatedKind::Type => Namespace::Type,\n+                ty::AssociatedKind::Const |\n+                ty::AssociatedKind::Method => Namespace::Value,\n+            })\n+        };\n+\n+        let impl_items1 = self.tcx.associated_item_def_ids(impl1);\n+        let impl_items2 = self.tcx.associated_item_def_ids(impl2);\n+\n+        for &item1 in &impl_items1[..] {\n+            let (name, namespace) = name_and_namespace(item1);\n+\n+            for &item2 in &impl_items2[..] {\n+                if (name, namespace) == name_and_namespace(item2) {\n+                    let msg = format!(\"duplicate definitions with name `{}`\", name);\n+                    let node_id = self.tcx.hir.as_local_node_id(item1).unwrap();\n+                    self.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,\n+                                           node_id,\n+                                           self.tcx.span_of_impl(item1).unwrap(),\n+                                           msg);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_for_overlapping_inherent_impls(&self, ty_def_id: DefId) {\n+        let impls = ty::queries::inherent_impls::get(self.tcx, DUMMY_SP, ty_def_id);\n+\n+        for (i, &impl1_def_id) in impls.iter().enumerate() {\n+            for &impl2_def_id in &impls[(i + 1)..] {\n+                self.tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n+                    if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n+                        self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n+                    }\n+                });\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentOverlapChecker<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'v hir::Item) {\n+        match item.node {\n+            hir::ItemEnum(..) |\n+            hir::ItemStruct(..) |\n+            hir::ItemTrait(..) |\n+            hir::ItemUnion(..) => {\n+                let type_def_id = self.tcx.hir.local_def_id(item.id);\n+                self.check_for_overlapping_inherent_impls(type_def_id);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n+}\n+"}, {"sha": "b3a7b612dd5b8532af75ac7aee58742cbfb29953", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4", "patch": "@@ -24,7 +24,8 @@ use syntax::ast;\n use syntax_pos::DUMMY_SP;\n \n mod builtin;\n-mod inherent;\n+mod inherent_impls;\n+mod inherent_impls_overlap;\n mod orphan;\n mod overlap;\n mod unsafety;\n@@ -103,10 +104,14 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, impl_def_id: DefId, trait_d\n \n pub fn provide(providers: &mut Providers) {\n     use self::builtin::coerce_unsized_info;\n+    use self::inherent_impls::{crate_inherent_impls, inherent_impls};\n+    use self::inherent_impls_overlap::crate_inherent_impls_overlap_check;\n \n     *providers = Providers {\n         coherent_trait,\n-        coherent_inherent_impls,\n+        crate_inherent_impls,\n+        inherent_impls,\n+        crate_inherent_impls_overlap_check,\n         coerce_unsized_info,\n         ..*providers\n     };\n@@ -126,10 +131,6 @@ fn coherent_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     builtin::check_trait(tcx, def_id);\n }\n \n-fn coherent_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, _: CrateNum) {\n-    inherent::check(tcx);\n-}\n-\n pub fn check_coherence<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::Coherence);\n     for &trait_def_id in tcx.hir.krate().trait_impls.keys() {\n@@ -140,5 +141,7 @@ pub fn check_coherence<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     orphan::check(tcx);\n     overlap::check_default_impls(tcx);\n \n-    ty::queries::coherent_inherent_impls::get(tcx, DUMMY_SP, LOCAL_CRATE);\n+    // these queries are executed for side-effects (error reporting):\n+    ty::queries::crate_inherent_impls::get(tcx, DUMMY_SP, LOCAL_CRATE);\n+    ty::queries::crate_inherent_impls_overlap_check::get(tcx, DUMMY_SP, LOCAL_CRATE);\n }"}, {"sha": "cc30fdf56fc346c08b411d8b027a6400cfbb33f1", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=a29ae3052aa9c84cecab226b9a1f1fee4e5b78d4", "patch": "@@ -232,14 +232,12 @@ fn build_type_alias(cx: &DocContext, did: DefId) -> clean::Typedef {\n \n pub fn build_impls(cx: &DocContext, did: DefId) -> Vec<clean::Item> {\n     let tcx = cx.tcx;\n-    tcx.populate_inherent_implementations_for_type_if_necessary(DUMMY_SP, did);\n     let mut impls = Vec::new();\n \n-    if let Some(i) = tcx.maps.inherent_impls.borrow().get(&did) {\n-        for &did in i.iter() {\n-            build_impl(cx, did, &mut impls);\n-        }\n+    for &did in ty::queries::inherent_impls::get(tcx, DUMMY_SP, did).iter() {\n+        build_impl(cx, did, &mut impls);\n     }\n+\n     // If this is the first time we've inlined something from another crate, then\n     // we inline *all* impls from all the crates into this crate. Note that there's\n     // currently no way for us to filter this based on type, and we likely need"}]}