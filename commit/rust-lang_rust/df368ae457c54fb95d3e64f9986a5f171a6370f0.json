{"sha": "df368ae457c54fb95d3e64f9986a5f171a6370f0", "node_id": "C_kwDOAAsO6NoAKGRmMzY4YWU0NTdjNTRmYjk1ZDNlNjRmOTk4NmE1ZjE3MWE2MzcwZjA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-25T05:15:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-25T05:15:21Z"}, "message": "Auto merge of #93288 - matthiaskrgr:rollup-uu4uwd1, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #88794 (Add a `try_clone()` function to `OwnedFd`.)\n - #93064 (Properly track `DepNode`s in trait evaluation provisional cache)\n - #93118 (Move param count error emission to end of `check_argument_types`)\n - #93144 (Work around missing code coverage data causing llvm-cov failures)\n - #93169 (Fix inconsistency of local blanket impls)\n - #93175 (Implement stable overlap check considering negative traits)\n - #93251 (rustdoc settings: use radio buttons for theme)\n - #93269 (Use error-on-mismatch policy for PAuth module flags.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "937d7106779ef49d1997a2178f187af99809a09a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/937d7106779ef49d1997a2178f187af99809a09a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df368ae457c54fb95d3e64f9986a5f171a6370f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df368ae457c54fb95d3e64f9986a5f171a6370f0", "html_url": "https://github.com/rust-lang/rust/commit/df368ae457c54fb95d3e64f9986a5f171a6370f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df368ae457c54fb95d3e64f9986a5f171a6370f0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7825f2b690c9a0d21b6f6d84c404bb53b151b38", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7825f2b690c9a0d21b6f6d84c404bb53b151b38", "html_url": "https://github.com/rust-lang/rust/commit/e7825f2b690c9a0d21b6f6d84c404bb53b151b38"}, {"sha": "13b87d8cc73b8ac9cab1fa99b2b61820d4d483a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/13b87d8cc73b8ac9cab1fa99b2b61820d4d483a6", "html_url": "https://github.com/rust-lang/rust/commit/13b87d8cc73b8ac9cab1fa99b2b61820d4d483a6"}], "stats": {"total": 1242, "additions": 855, "deletions": 387}, "files": [{"sha": "8672459b5da3aae9191938309ca7e29808314256", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -215,16 +215,19 @@ pub unsafe fn create_module<'ll>(\n     // to ensure intrinsic calls don't use it.\n     if !sess.needs_plt() {\n         let avoid_plt = \"RtLibUseGOT\\0\".as_ptr().cast();\n-        llvm::LLVMRustAddModuleFlag(llmod, avoid_plt, 1);\n+        llvm::LLVMRustAddModuleFlag(llmod, llvm::LLVMModFlagBehavior::Warning, avoid_plt, 1);\n     }\n \n     if sess.is_sanitizer_cfi_enabled() {\n         // FIXME(rcvalle): Add support for non canonical jump tables.\n         let canonical_jump_tables = \"CFI Canonical Jump Tables\\0\".as_ptr().cast();\n-        // FIXME(rcvalle): Add it with Override behavior flag--LLVMRustAddModuleFlag adds it with\n-        // Warning behavior flag. Add support for specifying the behavior flag to\n-        // LLVMRustAddModuleFlag.\n-        llvm::LLVMRustAddModuleFlag(llmod, canonical_jump_tables, 1);\n+        // FIXME(rcvalle): Add it with Override behavior flag.\n+        llvm::LLVMRustAddModuleFlag(\n+            llmod,\n+            llvm::LLVMModFlagBehavior::Warning,\n+            canonical_jump_tables,\n+            1,\n+        );\n     }\n \n     // Control Flow Guard is currently only supported by the MSVC linker on Windows.\n@@ -233,11 +236,21 @@ pub unsafe fn create_module<'ll>(\n             CFGuard::Disabled => {}\n             CFGuard::NoChecks => {\n                 // Set `cfguard=1` module flag to emit metadata only.\n-                llvm::LLVMRustAddModuleFlag(llmod, \"cfguard\\0\".as_ptr() as *const _, 1)\n+                llvm::LLVMRustAddModuleFlag(\n+                    llmod,\n+                    llvm::LLVMModFlagBehavior::Warning,\n+                    \"cfguard\\0\".as_ptr() as *const _,\n+                    1,\n+                )\n             }\n             CFGuard::Checks => {\n                 // Set `cfguard=2` module flag to emit metadata and checks.\n-                llvm::LLVMRustAddModuleFlag(llmod, \"cfguard\\0\".as_ptr() as *const _, 2)\n+                llvm::LLVMRustAddModuleFlag(\n+                    llmod,\n+                    llvm::LLVMModFlagBehavior::Warning,\n+                    \"cfguard\\0\".as_ptr() as *const _,\n+                    2,\n+                )\n             }\n         }\n     }\n@@ -247,24 +260,28 @@ pub unsafe fn create_module<'ll>(\n \n         llvm::LLVMRustAddModuleFlag(\n             llmod,\n+            llvm::LLVMModFlagBehavior::Error,\n             \"branch-target-enforcement\\0\".as_ptr().cast(),\n             bti.into(),\n         );\n \n         llvm::LLVMRustAddModuleFlag(\n             llmod,\n+            llvm::LLVMModFlagBehavior::Error,\n             \"sign-return-address\\0\".as_ptr().cast(),\n             pac.is_some().into(),\n         );\n         let pac_opts = pac.unwrap_or(PacRet { leaf: false, key: PAuthKey::A });\n         llvm::LLVMRustAddModuleFlag(\n             llmod,\n+            llvm::LLVMModFlagBehavior::Error,\n             \"sign-return-address-all\\0\".as_ptr().cast(),\n             pac_opts.leaf.into(),\n         );\n         let is_bkey = if pac_opts.key == PAuthKey::A { false } else { true };\n         llvm::LLVMRustAddModuleFlag(\n             llmod,\n+            llvm::LLVMModFlagBehavior::Error,\n             \"sign-return-address-with-bkey\\0\".as_ptr().cast(),\n             is_bkey.into(),\n         );"}, {"sha": "3014d2f1930eef5210cf4d4f9e0ccf1c4ea270cb", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -9,6 +9,7 @@ use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefIdSet;\n use rustc_llvm::RustString;\n+use rustc_middle::bug;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::coverage::CodeRegion;\n use rustc_middle::ty::TyCtxt;\n@@ -76,10 +77,18 @@ pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n         let coverage_mapping_buffer = llvm::build_byte_buffer(|coverage_mapping_buffer| {\n             mapgen.write_coverage_mapping(expressions, counter_regions, coverage_mapping_buffer);\n         });\n-        debug_assert!(\n-            !coverage_mapping_buffer.is_empty(),\n-            \"Every `FunctionCoverage` should have at least one counter\"\n-        );\n+\n+        if coverage_mapping_buffer.is_empty() {\n+            if function_coverage.is_used() {\n+                bug!(\n+                    \"A used function should have had coverage mapping data but did not: {}\",\n+                    mangled_function_name\n+                );\n+            } else {\n+                debug!(\"unused function had no coverage mapping data: {}\", mangled_function_name);\n+                continue;\n+            }\n+        }\n \n         function_data.push((mangled_function_name, source_hash, is_used, coverage_mapping_buffer));\n     }"}, {"sha": "28eb8e2a0a462de1e22b3fcb803d73cdc3cddf80", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -108,18 +108,29 @@ impl<'a, 'tcx> CrateDebugContext<'a, 'tcx> {\n             // This can be overridden using --llvm-opts -dwarf-version,N.\n             // Android has the same issue (#22398)\n             if let Some(version) = sess.target.dwarf_version {\n-                llvm::LLVMRustAddModuleFlag(self.llmod, \"Dwarf Version\\0\".as_ptr().cast(), version)\n+                llvm::LLVMRustAddModuleFlag(\n+                    self.llmod,\n+                    llvm::LLVMModFlagBehavior::Warning,\n+                    \"Dwarf Version\\0\".as_ptr().cast(),\n+                    version,\n+                )\n             }\n \n             // Indicate that we want CodeView debug information on MSVC\n             if sess.target.is_like_msvc {\n-                llvm::LLVMRustAddModuleFlag(self.llmod, \"CodeView\\0\".as_ptr().cast(), 1)\n+                llvm::LLVMRustAddModuleFlag(\n+                    self.llmod,\n+                    llvm::LLVMModFlagBehavior::Warning,\n+                    \"CodeView\\0\".as_ptr().cast(),\n+                    1,\n+                )\n             }\n \n             // Prevent bitcode readers from deleting the debug info.\n             let ptr = \"Debug Info Version\\0\".as_ptr();\n             llvm::LLVMRustAddModuleFlag(\n                 self.llmod,\n+                llvm::LLVMModFlagBehavior::Warning,\n                 ptr.cast(),\n                 llvm::LLVMRustDebugMetadataVersion(),\n             );"}, {"sha": "2b102188790389dc86445e6be4393ca049f62350", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -61,6 +61,26 @@ pub enum LLVMMachineType {\n     ARM = 0x01c0,\n }\n \n+/// LLVM's Module::ModFlagBehavior, defined in llvm/include/llvm/IR/Module.h.\n+///\n+/// When merging modules (e.g. during LTO), their metadata flags are combined. Conflicts are\n+/// resolved according to the merge behaviors specified here. Flags differing only in merge\n+/// behavior are still considered to be in conflict.\n+///\n+/// In order for Rust-C LTO to work, we must specify behaviors compatible with Clang. Notably,\n+/// 'Error' and 'Warning' cannot be mixed for a given flag.\n+#[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n+pub enum LLVMModFlagBehavior {\n+    Error = 1,\n+    Warning = 2,\n+    Require = 3,\n+    Override = 4,\n+    Append = 5,\n+    AppendUnique = 6,\n+    Max = 7,\n+}\n+\n // Consts for the LLVM CallConv type, pre-cast to usize.\n \n /// LLVM CallingConv::ID. Should we wrap this?\n@@ -1895,7 +1915,16 @@ extern \"C\" {\n \n     pub fn LLVMRustIsRustLLVM() -> bool;\n \n-    pub fn LLVMRustAddModuleFlag(M: &Module, name: *const c_char, value: u32);\n+    /// Add LLVM module flags.\n+    ///\n+    /// In order for Rust-C LTO to work, module flags must be compatible with Clang. What\n+    /// \"compatible\" means depends on the merge behaviors involved.\n+    pub fn LLVMRustAddModuleFlag(\n+        M: &Module,\n+        merge_behavior: LLVMModFlagBehavior,\n+        name: *const c_char,\n+        value: u32,\n+    );\n \n     pub fn LLVMRustMetadataAsValue<'a>(C: &'a Context, MD: &'a Metadata) -> &'a Value;\n "}, {"sha": "0e643ff59983497d18f48db28dc9d12ca0cdc72d", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -697,6 +697,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     rustc_attr!(TEST, rustc_capture_analysis, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_insignificant_dtor, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_strict_coherence, Normal, template!(Word), WarnFollowing),\n+    rustc_attr!(TEST, rustc_with_negative_coherence, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_variance, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_layout, Normal, template!(List: \"field1, field2, ...\"), WarnFollowing),\n     rustc_attr!(TEST, rustc_regions, Normal, template!(Word), WarnFollowing),"}, {"sha": "dcd6327c92f6a38789a747473ac8ca6d11bc1b55", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -722,9 +722,12 @@ extern \"C\" bool LLVMRustIsRustLLVM() {\n #endif\n }\n \n-extern \"C\" void LLVMRustAddModuleFlag(LLVMModuleRef M, const char *Name,\n-                                      uint32_t Value) {\n-  unwrap(M)->addModuleFlag(Module::Warning, Name, Value);\n+extern \"C\" void LLVMRustAddModuleFlag(\n+    LLVMModuleRef M,\n+    Module::ModFlagBehavior MergeBehavior,\n+    const char *Name,\n+    uint32_t Value) {\n+  unwrap(M)->addModuleFlag(MergeBehavior, Name, Value);\n }\n \n extern \"C\" LLVMValueRef LLVMRustMetadataAsValue(LLVMContextRef C, LLVMMetadataRef MD) {"}, {"sha": "52d52752b158326e5501701076e11e54fde27ab0", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -1204,6 +1204,7 @@ symbols! {\n         rustc_trivial_field_reads,\n         rustc_unsafe_specialization_marker,\n         rustc_variance,\n+        rustc_with_negative_coherence,\n         rustdoc,\n         rustdoc_internals,\n         rustfmt,"}, {"sha": "80ed9023d9694ca0a01847bcf5e6a236c4249c2e", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 201, "deletions": 61, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -7,9 +7,11 @@\n use crate::infer::{CombinedSnapshot, InferOk, TyCtxtInferExt};\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::select::IntercrateAmbiguityCause;\n+use crate::traits::util::impl_trait_ref_and_oblig;\n use crate::traits::SkipLeakCheck;\n use crate::traits::{\n-    self, Normalized, Obligation, ObligationCause, PredicateObligation, SelectionContext,\n+    self, FulfillmentContext, Normalized, Obligation, ObligationCause, PredicateObligation,\n+    PredicateObligations, SelectionContext,\n };\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::ty::fast_reject::{self, SimplifyParams, StripReferences};\n@@ -135,45 +137,83 @@ fn with_fresh_ty_vars<'cx, 'tcx>(\n     header\n }\n \n+/// What kind of overlap check are we doing -- this exists just for testing and feature-gating\n+/// purposes.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+enum OverlapMode {\n+    /// The 1.0 rules (either types fail to unify, or where clauses are not implemented for crate-local types)\n+    Stable,\n+    /// Feature-gated test: Stable, *or* there is an explicit negative impl that rules out one of the where-clauses.\n+    WithNegative,\n+    /// Just check for negative impls, not for \"where clause not implemented\": used for testing.\n+    Strict,\n+}\n+\n+impl OverlapMode {\n+    fn use_negative_impl(&self) -> bool {\n+        *self == OverlapMode::Strict || *self == OverlapMode::WithNegative\n+    }\n+\n+    fn use_implicit_negative(&self) -> bool {\n+        *self == OverlapMode::Stable || *self == OverlapMode::WithNegative\n+    }\n+}\n+\n+fn overlap_mode<'tcx>(tcx: TyCtxt<'tcx>, impl1_def_id: DefId, impl2_def_id: DefId) -> OverlapMode {\n+    if tcx.has_attr(impl1_def_id, sym::rustc_strict_coherence)\n+        != tcx.has_attr(impl2_def_id, sym::rustc_strict_coherence)\n+    {\n+        bug!(\"Use strict coherence on both impls\",);\n+    }\n+\n+    if tcx.has_attr(impl1_def_id, sym::rustc_with_negative_coherence)\n+        != tcx.has_attr(impl2_def_id, sym::rustc_with_negative_coherence)\n+    {\n+        bug!(\"Use with negative coherence on both impls\",);\n+    }\n+\n+    if tcx.has_attr(impl1_def_id, sym::rustc_strict_coherence) {\n+        OverlapMode::Strict\n+    } else if tcx.has_attr(impl1_def_id, sym::rustc_with_negative_coherence) {\n+        OverlapMode::WithNegative\n+    } else {\n+        OverlapMode::Stable\n+    }\n+}\n+\n /// Can both impl `a` and impl `b` be satisfied by a common type (including\n /// where-clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n fn overlap<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     skip_leak_check: SkipLeakCheck,\n-    a_def_id: DefId,\n-    b_def_id: DefId,\n+    impl1_def_id: DefId,\n+    impl2_def_id: DefId,\n ) -> Option<OverlapResult<'tcx>> {\n-    debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\", a_def_id, b_def_id);\n+    debug!(\"overlap(impl1_def_id={:?}, impl2_def_id={:?})\", impl1_def_id, impl2_def_id);\n \n     selcx.infcx().probe_maybe_skip_leak_check(skip_leak_check.is_yes(), |snapshot| {\n-        overlap_within_probe(selcx, skip_leak_check, a_def_id, b_def_id, snapshot)\n+        overlap_within_probe(selcx, skip_leak_check, impl1_def_id, impl2_def_id, snapshot)\n     })\n }\n \n fn overlap_within_probe<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     skip_leak_check: SkipLeakCheck,\n-    a_def_id: DefId,\n-    b_def_id: DefId,\n+    impl1_def_id: DefId,\n+    impl2_def_id: DefId,\n     snapshot: &CombinedSnapshot<'_, 'tcx>,\n ) -> Option<OverlapResult<'tcx>> {\n-    fn loose_check<'cx, 'tcx>(\n-        selcx: &mut SelectionContext<'cx, 'tcx>,\n-        o: &PredicateObligation<'tcx>,\n-    ) -> bool {\n-        !selcx.predicate_may_hold_fatal(o)\n-    }\n+    let infcx = selcx.infcx();\n+    let tcx = infcx.tcx;\n \n-    fn strict_check<'cx, 'tcx>(\n-        selcx: &SelectionContext<'cx, 'tcx>,\n-        o: &PredicateObligation<'tcx>,\n-    ) -> bool {\n-        let infcx = selcx.infcx();\n-        let tcx = infcx.tcx;\n-        o.flip_polarity(tcx)\n-            .as_ref()\n-            .map(|o| selcx.infcx().predicate_must_hold_modulo_regions(o))\n-            .unwrap_or(false)\n+    let overlap_mode = overlap_mode(tcx, impl1_def_id, impl2_def_id);\n+\n+    if overlap_mode.use_negative_impl() {\n+        if negative_impl(selcx, impl1_def_id, impl2_def_id)\n+            || negative_impl(selcx, impl2_def_id, impl1_def_id)\n+        {\n+            return None;\n+        }\n     }\n \n     // For the purposes of this check, we don't bring any placeholder\n@@ -182,26 +222,61 @@ fn overlap_within_probe<'cx, 'tcx>(\n     // empty environment.\n     let param_env = ty::ParamEnv::empty();\n \n-    let a_impl_header = with_fresh_ty_vars(selcx, param_env, a_def_id);\n-    let b_impl_header = with_fresh_ty_vars(selcx, param_env, b_def_id);\n+    let impl1_header = with_fresh_ty_vars(selcx, param_env, impl1_def_id);\n+    let impl2_header = with_fresh_ty_vars(selcx, param_env, impl2_def_id);\n \n-    debug!(\"overlap: a_impl_header={:?}\", a_impl_header);\n-    debug!(\"overlap: b_impl_header={:?}\", b_impl_header);\n+    debug!(\"overlap: impl1_header={:?}\", impl1_header);\n+    debug!(\"overlap: impl2_header={:?}\", impl2_header);\n \n-    // Do `a` and `b` unify? If not, no overlap.\n-    let obligations = match selcx\n-        .infcx()\n-        .at(&ObligationCause::dummy(), param_env)\n-        .eq_impl_headers(&a_impl_header, &b_impl_header)\n-    {\n-        Ok(InferOk { obligations, value: () }) => obligations,\n-        Err(_) => {\n+    let obligations = equate_impl_headers(selcx, &impl1_header, &impl2_header)?;\n+    debug!(\"overlap: unification check succeeded\");\n+\n+    if overlap_mode.use_implicit_negative() {\n+        if implicit_negative(selcx, param_env, &impl1_header, impl2_header, obligations) {\n             return None;\n         }\n-    };\n+    }\n \n-    debug!(\"overlap: unification check succeeded\");\n+    if !skip_leak_check.is_yes() {\n+        if infcx.leak_check(true, snapshot).is_err() {\n+            debug!(\"overlap: leak check failed\");\n+            return None;\n+        }\n+    }\n+\n+    let intercrate_ambiguity_causes = selcx.take_intercrate_ambiguity_causes();\n+    debug!(\"overlap: intercrate_ambiguity_causes={:#?}\", intercrate_ambiguity_causes);\n+\n+    let involves_placeholder =\n+        matches!(selcx.infcx().region_constraints_added_in_snapshot(snapshot), Some(true));\n+\n+    let impl_header = selcx.infcx().resolve_vars_if_possible(impl1_header);\n+    Some(OverlapResult { impl_header, intercrate_ambiguity_causes, involves_placeholder })\n+}\n+\n+fn equate_impl_headers<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    impl1_header: &ty::ImplHeader<'tcx>,\n+    impl2_header: &ty::ImplHeader<'tcx>,\n+) -> Option<PredicateObligations<'tcx>> {\n+    // Do `a` and `b` unify? If not, no overlap.\n+    selcx\n+        .infcx()\n+        .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n+        .eq_impl_headers(impl1_header, impl2_header)\n+        .map(|infer_ok| infer_ok.obligations)\n+        .ok()\n+}\n \n+/// Given impl1 and impl2 check if both impls can be satisfied by a common type (including\n+/// where-clauses) If so, return false, otherwise return true, they are disjoint.\n+fn implicit_negative<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    impl1_header: &ty::ImplHeader<'tcx>,\n+    impl2_header: ty::ImplHeader<'tcx>,\n+    obligations: PredicateObligations<'tcx>,\n+) -> bool {\n     // There's no overlap if obligations are unsatisfiable or if the obligation negated is\n     // satisfied.\n     //\n@@ -225,11 +300,11 @@ fn overlap_within_probe<'cx, 'tcx>(\n     // at some point an impl for `&'?a str: Error` could be added.\n     let infcx = selcx.infcx();\n     let tcx = infcx.tcx;\n-    let opt_failing_obligation = a_impl_header\n+    let opt_failing_obligation = impl1_header\n         .predicates\n         .iter()\n         .copied()\n-        .chain(b_impl_header.predicates)\n+        .chain(impl2_header.predicates)\n         .map(|p| infcx.resolve_vars_if_possible(p))\n         .map(|p| Obligation {\n             cause: ObligationCause::dummy(),\n@@ -239,40 +314,105 @@ fn overlap_within_probe<'cx, 'tcx>(\n         })\n         .chain(obligations)\n         .find(|o| {\n-            // if both impl headers are set to strict coherence it means that this will be accepted\n-            // only if it's stated that T: !Trait. So only prove that the negated obligation holds.\n-            if tcx.has_attr(a_def_id, sym::rustc_strict_coherence)\n-                && tcx.has_attr(b_def_id, sym::rustc_strict_coherence)\n-            {\n-                strict_check(selcx, o)\n-            } else {\n-                loose_check(selcx, o) || tcx.features().negative_impls && strict_check(selcx, o)\n-            }\n+            loose_check(selcx, o) || tcx.features().negative_impls && negative_impl_exists(selcx, o)\n         });\n     // FIXME: the call to `selcx.predicate_may_hold_fatal` above should be ported\n     // to the canonical trait query form, `infcx.predicate_may_hold`, once\n     // the new system supports intercrate mode (which coherence needs).\n \n     if let Some(failing_obligation) = opt_failing_obligation {\n         debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);\n-        return None;\n+        true\n+    } else {\n+        false\n     }\n+}\n \n-    if !skip_leak_check.is_yes() {\n-        if infcx.leak_check(true, snapshot).is_err() {\n-            debug!(\"overlap: leak check failed\");\n-            return None;\n-        }\n-    }\n+/// Given impl1 and impl2 check if both impls are never satisfied by a common type (including\n+/// where-clauses) If so, return true, they are disjoint and false otherwise.\n+fn negative_impl<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    impl1_def_id: DefId,\n+    impl2_def_id: DefId,\n+) -> bool {\n+    let tcx = selcx.infcx().tcx;\n \n-    let impl_header = selcx.infcx().resolve_vars_if_possible(a_impl_header);\n-    let intercrate_ambiguity_causes = selcx.take_intercrate_ambiguity_causes();\n-    debug!(\"overlap: intercrate_ambiguity_causes={:#?}\", intercrate_ambiguity_causes);\n+    // create a parameter environment corresponding to a (placeholder) instantiation of impl1\n+    let impl1_env = tcx.param_env(impl1_def_id);\n+    let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n \n-    let involves_placeholder =\n-        matches!(selcx.infcx().region_constraints_added_in_snapshot(snapshot), Some(true));\n+    // Create an infcx, taking the predicates of impl1 as assumptions:\n+    tcx.infer_ctxt().enter(|infcx| {\n+        // Normalize the trait reference. The WF rules ought to ensure\n+        // that this always succeeds.\n+        let impl1_trait_ref = match traits::fully_normalize(\n+            &infcx,\n+            FulfillmentContext::new(),\n+            ObligationCause::dummy(),\n+            impl1_env,\n+            impl1_trait_ref,\n+        ) {\n+            Ok(impl1_trait_ref) => impl1_trait_ref,\n+            Err(err) => {\n+                bug!(\"failed to fully normalize {:?}: {:?}\", impl1_trait_ref, err);\n+            }\n+        };\n+\n+        // Attempt to prove that impl2 applies, given all of the above.\n+        let selcx = &mut SelectionContext::new(&infcx);\n+        let impl2_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl2_def_id);\n+        let (impl2_trait_ref, obligations) =\n+            impl_trait_ref_and_oblig(selcx, impl1_env, impl2_def_id, impl2_substs);\n+\n+        // do the impls unify? If not, not disjoint.\n+        let more_obligations = match infcx\n+            .at(&ObligationCause::dummy(), impl1_env)\n+            .eq(impl1_trait_ref, impl2_trait_ref)\n+        {\n+            Ok(InferOk { obligations, .. }) => obligations,\n+            Err(_) => {\n+                debug!(\n+                    \"explicit_disjoint: {:?} does not unify with {:?}\",\n+                    impl1_trait_ref, impl2_trait_ref\n+                );\n+                return false;\n+            }\n+        };\n \n-    Some(OverlapResult { impl_header, intercrate_ambiguity_causes, involves_placeholder })\n+        let opt_failing_obligation = obligations\n+            .into_iter()\n+            .chain(more_obligations)\n+            .find(|o| negative_impl_exists(selcx, o));\n+\n+        if let Some(failing_obligation) = opt_failing_obligation {\n+            debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);\n+            true\n+        } else {\n+            false\n+        }\n+    })\n+}\n+\n+fn loose_check<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    o: &PredicateObligation<'tcx>,\n+) -> bool {\n+    !selcx.predicate_may_hold_fatal(o)\n+}\n+\n+fn negative_impl_exists<'cx, 'tcx>(\n+    selcx: &SelectionContext<'cx, 'tcx>,\n+    o: &PredicateObligation<'tcx>,\n+) -> bool {\n+    let infcx = selcx.infcx();\n+    let tcx = infcx.tcx;\n+    o.flip_polarity(tcx)\n+        .as_ref()\n+        .map(|o| {\n+            // FIXME This isn't quite correct, regions should be included\n+            selcx.infcx().predicate_must_hold_modulo_regions(o)\n+        })\n+        .unwrap_or(false)\n }\n \n pub fn trait_ref_is_knowable<'tcx>("}, {"sha": "ab4fb9607ca002b4024d49d3ccf84558797c37ff", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 51, "deletions": 12, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -765,14 +765,38 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             debug!(?result, \"CACHE MISS\");\n             self.insert_evaluation_cache(param_env, fresh_trait_pred, dep_node, result);\n \n-            stack.cache().on_completion(stack.dfn, |fresh_trait_pred, provisional_result| {\n-                self.insert_evaluation_cache(\n-                    param_env,\n-                    fresh_trait_pred,\n-                    dep_node,\n-                    provisional_result.max(result),\n-                );\n-            });\n+            stack.cache().on_completion(\n+                stack.dfn,\n+                |fresh_trait_pred, provisional_result, provisional_dep_node| {\n+                    // Create a new `DepNode` that has dependencies on:\n+                    // * The `DepNode` for the original evaluation that resulted in a provisional cache\n+                    // entry being crated\n+                    // * The `DepNode` for the *current* evaluation, which resulted in us completing\n+                    // provisional caches entries and inserting them into the evaluation cache\n+                    //\n+                    // This ensures that when a query reads this entry from the evaluation cache,\n+                    // it will end up (transitively) dependening on all of the incr-comp dependencies\n+                    // created during the evaluation of this trait. For example, evaluating a trait\n+                    // will usually require us to invoke `type_of(field_def_id)` to determine the\n+                    // constituent types, and we want any queries reading from this evaluation\n+                    // cache entry to end up with a transitive `type_of(field_def_id`)` dependency.\n+                    //\n+                    // By using `in_task`, we're also creating an edge from the *current* query\n+                    // to the newly-created `combined_dep_node`. This is probably redundant,\n+                    // but it's better to add too many dep graph edges than to add too few\n+                    // dep graph edges.\n+                    let ((), combined_dep_node) = self.in_task(|this| {\n+                        this.tcx().dep_graph.read_index(provisional_dep_node);\n+                        this.tcx().dep_graph.read_index(dep_node);\n+                    });\n+                    self.insert_evaluation_cache(\n+                        param_env,\n+                        fresh_trait_pred,\n+                        combined_dep_node,\n+                        provisional_result.max(result),\n+                    );\n+                },\n+            );\n         } else {\n             debug!(?result, \"PROVISIONAL\");\n             debug!(\n@@ -781,7 +805,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 fresh_trait_pred, stack.depth, reached_depth,\n             );\n \n-            stack.cache().insert_provisional(stack.dfn, reached_depth, fresh_trait_pred, result);\n+            stack.cache().insert_provisional(\n+                stack.dfn,\n+                reached_depth,\n+                fresh_trait_pred,\n+                result,\n+                dep_node,\n+            );\n         }\n \n         Ok(result)\n@@ -2506,6 +2536,11 @@ struct ProvisionalEvaluation {\n     from_dfn: usize,\n     reached_depth: usize,\n     result: EvaluationResult,\n+    /// The `DepNodeIndex` created for the `evaluate_stack` call for this provisional\n+    /// evaluation. When we create an entry in the evaluation cache using this provisional\n+    /// cache entry (see `on_completion`), we use this `dep_node` to ensure that future reads from\n+    /// the cache will have all of the necessary incr comp dependencies tracked.\n+    dep_node: DepNodeIndex,\n }\n \n impl<'tcx> Default for ProvisionalEvaluationCache<'tcx> {\n@@ -2548,6 +2583,7 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n         reached_depth: usize,\n         fresh_trait_pred: ty::PolyTraitPredicate<'tcx>,\n         result: EvaluationResult,\n+        dep_node: DepNodeIndex,\n     ) {\n         debug!(?from_dfn, ?fresh_trait_pred, ?result, \"insert_provisional\");\n \n@@ -2573,7 +2609,10 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n             }\n         }\n \n-        map.insert(fresh_trait_pred, ProvisionalEvaluation { from_dfn, reached_depth, result });\n+        map.insert(\n+            fresh_trait_pred,\n+            ProvisionalEvaluation { from_dfn, reached_depth, result, dep_node },\n+        );\n     }\n \n     /// Invoked when the node with dfn `dfn` does not get a successful\n@@ -2624,7 +2663,7 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n     fn on_completion(\n         &self,\n         dfn: usize,\n-        mut op: impl FnMut(ty::PolyTraitPredicate<'tcx>, EvaluationResult),\n+        mut op: impl FnMut(ty::PolyTraitPredicate<'tcx>, EvaluationResult, DepNodeIndex),\n     ) {\n         debug!(?dfn, \"on_completion\");\n \n@@ -2633,7 +2672,7 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n         {\n             debug!(?fresh_trait_pred, ?eval, \"on_completion\");\n \n-            op(fresh_trait_pred, eval.result);\n+            op(fresh_trait_pred, eval.result, eval.dep_node);\n         }\n     }\n }"}, {"sha": "c39199f84b527d210dc90de342cabbe9ba4ed1ab", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 144, "deletions": 135, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -127,136 +127,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let expected_arg_count = formal_input_tys.len();\n \n-        let param_count_error = |expected_count: usize,\n-                                 arg_count: usize,\n-                                 error_code: &str,\n-                                 c_variadic: bool,\n-                                 sugg_unit: bool| {\n-            let (span, start_span, args, ctor_of) = match &call_expr.kind {\n-                hir::ExprKind::Call(\n-                    hir::Expr {\n-                        span,\n-                        kind:\n-                            hir::ExprKind::Path(hir::QPath::Resolved(\n-                                _,\n-                                hir::Path { res: Res::Def(DefKind::Ctor(of, _), _), .. },\n-                            )),\n-                        ..\n-                    },\n-                    args,\n-                ) => (*span, *span, &args[..], Some(of)),\n-                hir::ExprKind::Call(hir::Expr { span, .. }, args) => {\n-                    (*span, *span, &args[..], None)\n-                }\n-                hir::ExprKind::MethodCall(path_segment, args, _) => (\n-                    path_segment.ident.span,\n-                    // `sp` doesn't point at the whole `foo.bar()`, only at `bar`.\n-                    path_segment\n-                        .args\n-                        .and_then(|args| args.args.iter().last())\n-                        // Account for `foo.bar::<T>()`.\n-                        .map(|arg| {\n-                            // Skip the closing `>`.\n-                            tcx.sess\n-                                .source_map()\n-                                .next_point(tcx.sess.source_map().next_point(arg.span()))\n-                        })\n-                        .unwrap_or(path_segment.ident.span),\n-                    &args[1..], // Skip the receiver.\n-                    None,       // methods are never ctors\n-                ),\n-                k => span_bug!(call_span, \"checking argument types on a non-call: `{:?}`\", k),\n-            };\n-            let arg_spans = if provided_args.is_empty() {\n-                // foo()\n-                // ^^^-- supplied 0 arguments\n-                // |\n-                // expected 2 arguments\n-                vec![tcx.sess.source_map().next_point(start_span).with_hi(call_span.hi())]\n-            } else {\n-                // foo(1, 2, 3)\n-                // ^^^ -  -  - supplied 3 arguments\n-                // |\n-                // expected 2 arguments\n-                args.iter().map(|arg| arg.span).collect::<Vec<Span>>()\n-            };\n-\n-            let mut err = tcx.sess.struct_span_err_with_code(\n-                span,\n-                &format!(\n-                    \"this {} takes {}{} but {} {} supplied\",\n-                    match ctor_of {\n-                        Some(CtorOf::Struct) => \"struct\",\n-                        Some(CtorOf::Variant) => \"enum variant\",\n-                        None => \"function\",\n-                    },\n-                    if c_variadic { \"at least \" } else { \"\" },\n-                    potentially_plural_count(expected_count, \"argument\"),\n-                    potentially_plural_count(arg_count, \"argument\"),\n-                    if arg_count == 1 { \"was\" } else { \"were\" }\n-                ),\n-                DiagnosticId::Error(error_code.to_owned()),\n-            );\n-            let label = format!(\"supplied {}\", potentially_plural_count(arg_count, \"argument\"));\n-            for (i, span) in arg_spans.into_iter().enumerate() {\n-                err.span_label(\n-                    span,\n-                    if arg_count == 0 || i + 1 == arg_count { &label } else { \"\" },\n-                );\n-            }\n-\n-            if let Some(def_id) = fn_def_id {\n-                if let Some(def_span) = tcx.def_ident_span(def_id) {\n-                    let mut spans: MultiSpan = def_span.into();\n-\n-                    let params = tcx\n-                        .hir()\n-                        .get_if_local(def_id)\n-                        .and_then(|node| node.body_id())\n-                        .into_iter()\n-                        .map(|id| tcx.hir().body(id).params)\n-                        .flatten();\n-\n-                    for param in params {\n-                        spans.push_span_label(param.span, String::new());\n-                    }\n-\n-                    let def_kind = tcx.def_kind(def_id);\n-                    err.span_note(spans, &format!(\"{} defined here\", def_kind.descr(def_id)));\n-                }\n-            }\n-\n-            if sugg_unit {\n-                let sugg_span = tcx.sess.source_map().end_point(call_expr.span);\n-                // remove closing `)` from the span\n-                let sugg_span = sugg_span.shrink_to_lo();\n-                err.span_suggestion(\n-                    sugg_span,\n-                    \"expected the unit value `()`; create it with empty parentheses\",\n-                    String::from(\"()\"),\n-                    Applicability::MachineApplicable,\n-                );\n-            } else {\n-                err.span_label(\n-                    span,\n-                    format!(\n-                        \"expected {}{}\",\n-                        if c_variadic { \"at least \" } else { \"\" },\n-                        potentially_plural_count(expected_count, \"argument\")\n-                    ),\n-                );\n-            }\n-            err.emit();\n-        };\n+        // expected_count, arg_count, error_code, sugg_unit\n+        let mut error: Option<(usize, usize, &str, bool)> = None;\n \n+        // If the arguments should be wrapped in a tuple (ex: closures), unwrap them here\n         let (formal_input_tys, expected_input_tys) = if tuple_arguments == TupleArguments {\n             let tuple_type = self.structurally_resolved_type(call_span, formal_input_tys[0]);\n             match tuple_type.kind() {\n-                ty::Tuple(arg_types) if arg_types.len() != provided_args.len() => {\n-                    param_count_error(arg_types.len(), provided_args.len(), \"E0057\", false, false);\n-                    (self.err_args(provided_args.len()), vec![])\n-                }\n+                // We expected a tuple and got a tuple\n                 ty::Tuple(arg_types) => {\n+                    // Argument length differs\n+                    if arg_types.len() != provided_args.len() {\n+                        error = Some((arg_types.len(), provided_args.len(), \"E0057\", false));\n+                    }\n                     let expected_input_tys = match expected_input_tys.get(0) {\n                         Some(&ty) => match ty.kind() {\n                             ty::Tuple(ref tys) => tys.iter().map(|k| k.expect_ty()).collect(),\n@@ -267,6 +150,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     (arg_types.iter().map(|k| k.expect_ty()).collect(), expected_input_tys)\n                 }\n                 _ => {\n+                    // Otherwise, there's a mismatch, so clear out what we're expecting, and set\n+                    // our input typs to err_args so we don't blow up the error messages\n                     struct_span_err!(\n                         tcx.sess,\n                         call_span,\n@@ -284,7 +169,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if supplied_arg_count >= expected_arg_count {\n                 (formal_input_tys.to_vec(), expected_input_tys)\n             } else {\n-                param_count_error(expected_arg_count, supplied_arg_count, \"E0060\", true, false);\n+                error = Some((expected_arg_count, supplied_arg_count, \"E0060\", false));\n                 (self.err_args(supplied_arg_count), vec![])\n             }\n         } else {\n@@ -296,8 +181,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             } else {\n                 false\n             };\n-            param_count_error(expected_arg_count, supplied_arg_count, \"E0061\", false, sugg_unit);\n-\n+            error = Some((expected_arg_count, supplied_arg_count, \"E0061\", sugg_unit));\n             (self.err_args(supplied_arg_count), vec![])\n         };\n \n@@ -315,13 +199,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         assert_eq!(expected_input_tys.len(), formal_input_tys.len());\n \n+        let provided_arg_count: usize = provided_args.len();\n+\n         // Keep track of the fully coerced argument types\n-        let mut final_arg_types: Vec<(usize, Ty<'_>, Ty<'_>)> = vec![];\n+        let mut final_arg_types: Vec<Option<(Ty<'_>, Ty<'_>)>> = vec![None; provided_arg_count];\n \n         // We introduce a helper function to demand that a given argument satisfy a given input\n         // This is more complicated than just checking type equality, as arguments could be coerced\n         // This version writes those types back so further type checking uses the narrowed types\n-        let demand_compatible = |idx, final_arg_types: &mut Vec<(usize, Ty<'tcx>, Ty<'tcx>)>| {\n+        let demand_compatible = |idx, final_arg_types: &mut Vec<Option<(Ty<'tcx>, Ty<'tcx>)>>| {\n             let formal_input_ty: Ty<'tcx> = formal_input_tys[idx];\n             let expected_input_ty: Ty<'tcx> = expected_input_tys[idx];\n             let provided_arg = &provided_args[idx];\n@@ -340,13 +226,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let coerced_ty = expectation.only_has_type(self).unwrap_or(formal_input_ty);\n \n             // Keep track of these for below\n-            final_arg_types.push((idx, checked_ty, coerced_ty));\n+            final_arg_types[idx] = Some((checked_ty, coerced_ty));\n \n             // Cause selection errors caused by resolving a single argument to point at the\n             // argument and not the call. This is otherwise redundant with the `demand_coerce`\n             // call immediately after, but it lets us customize the span pointed to in the\n             // fulfillment error to be more accurate.\n-            let _ =\n+            let coerced_ty =\n                 self.resolve_vars_with_obligations_and_mutate_fulfillment(coerced_ty, |errors| {\n                     self.point_at_type_arg_instead_of_call_if_possible(errors, call_expr);\n                     self.point_at_arg_instead_of_call_if_possible(\n@@ -358,6 +244,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     );\n                 });\n \n+            final_arg_types[idx] = Some((checked_ty, coerced_ty));\n+\n             // We're processing function arguments so we definitely want to use\n             // two-phase borrows.\n             self.demand_coerce(&provided_arg, checked_ty, coerced_ty, None, AllowTwoPhase::Yes);\n@@ -416,6 +304,123 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n+        // If there was an error in parameter count, emit that here\n+        if let Some((expected_count, arg_count, err_code, sugg_unit)) = error {\n+            let (span, start_span, args, ctor_of) = match &call_expr.kind {\n+                hir::ExprKind::Call(\n+                    hir::Expr {\n+                        span,\n+                        kind:\n+                            hir::ExprKind::Path(hir::QPath::Resolved(\n+                                _,\n+                                hir::Path { res: Res::Def(DefKind::Ctor(of, _), _), .. },\n+                            )),\n+                        ..\n+                    },\n+                    args,\n+                ) => (*span, *span, &args[..], Some(of)),\n+                hir::ExprKind::Call(hir::Expr { span, .. }, args) => {\n+                    (*span, *span, &args[..], None)\n+                }\n+                hir::ExprKind::MethodCall(path_segment, args, _) => (\n+                    path_segment.ident.span,\n+                    // `sp` doesn't point at the whole `foo.bar()`, only at `bar`.\n+                    path_segment\n+                        .args\n+                        .and_then(|args| args.args.iter().last())\n+                        // Account for `foo.bar::<T>()`.\n+                        .map(|arg| {\n+                            // Skip the closing `>`.\n+                            tcx.sess\n+                                .source_map()\n+                                .next_point(tcx.sess.source_map().next_point(arg.span()))\n+                        })\n+                        .unwrap_or(path_segment.ident.span),\n+                    &args[1..], // Skip the receiver.\n+                    None,       // methods are never ctors\n+                ),\n+                k => span_bug!(call_span, \"checking argument types on a non-call: `{:?}`\", k),\n+            };\n+            let arg_spans = if provided_args.is_empty() {\n+                // foo()\n+                // ^^^-- supplied 0 arguments\n+                // |\n+                // expected 2 arguments\n+                vec![tcx.sess.source_map().next_point(start_span).with_hi(call_span.hi())]\n+            } else {\n+                // foo(1, 2, 3)\n+                // ^^^ -  -  - supplied 3 arguments\n+                // |\n+                // expected 2 arguments\n+                args.iter().map(|arg| arg.span).collect::<Vec<Span>>()\n+            };\n+            let call_name = match ctor_of {\n+                Some(CtorOf::Struct) => \"struct\",\n+                Some(CtorOf::Variant) => \"enum variant\",\n+                None => \"function\",\n+            };\n+            let mut err = tcx.sess.struct_span_err_with_code(\n+                span,\n+                &format!(\n+                    \"this {} takes {}{} but {} {} supplied\",\n+                    call_name,\n+                    if c_variadic { \"at least \" } else { \"\" },\n+                    potentially_plural_count(expected_count, \"argument\"),\n+                    potentially_plural_count(arg_count, \"argument\"),\n+                    if arg_count == 1 { \"was\" } else { \"were\" }\n+                ),\n+                DiagnosticId::Error(err_code.to_owned()),\n+            );\n+            let label = format!(\"supplied {}\", potentially_plural_count(arg_count, \"argument\"));\n+            for (i, span) in arg_spans.into_iter().enumerate() {\n+                err.span_label(\n+                    span,\n+                    if arg_count == 0 || i + 1 == arg_count { &label } else { \"\" },\n+                );\n+            }\n+            if let Some(def_id) = fn_def_id {\n+                if let Some(def_span) = tcx.def_ident_span(def_id) {\n+                    let mut spans: MultiSpan = def_span.into();\n+\n+                    let params = tcx\n+                        .hir()\n+                        .get_if_local(def_id)\n+                        .and_then(|node| node.body_id())\n+                        .into_iter()\n+                        .map(|id| tcx.hir().body(id).params)\n+                        .flatten();\n+\n+                    for param in params {\n+                        spans.push_span_label(param.span, String::new());\n+                    }\n+\n+                    let def_kind = tcx.def_kind(def_id);\n+                    err.span_note(spans, &format!(\"{} defined here\", def_kind.descr(def_id)));\n+                }\n+            }\n+            if sugg_unit {\n+                let sugg_span = tcx.sess.source_map().end_point(call_expr.span);\n+                // remove closing `)` from the span\n+                let sugg_span = sugg_span.shrink_to_lo();\n+                err.span_suggestion(\n+                    sugg_span,\n+                    \"expected the unit value `()`; create it with empty parentheses\",\n+                    String::from(\"()\"),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                err.span_label(\n+                    span,\n+                    format!(\n+                        \"expected {}{}\",\n+                        if c_variadic { \"at least \" } else { \"\" },\n+                        potentially_plural_count(expected_count, \"argument\")\n+                    ),\n+                );\n+            }\n+            err.emit();\n+        }\n+\n         // We also need to make sure we at least write the ty of the other\n         // arguments which we skipped above.\n         if c_variadic {\n@@ -975,7 +980,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn point_at_arg_instead_of_call_if_possible(\n         &self,\n         errors: &mut Vec<traits::FulfillmentError<'tcx>>,\n-        final_arg_types: &[(usize, Ty<'tcx>, Ty<'tcx>)],\n+        final_arg_types: &[Option<(Ty<'tcx>, Ty<'tcx>)>],\n         expr: &'tcx hir::Expr<'tcx>,\n         call_sp: Span,\n         args: &'tcx [hir::Expr<'tcx>],\n@@ -1030,8 +1035,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // `FulfillmentError`.\n             let mut referenced_in = final_arg_types\n                 .iter()\n-                .map(|&(i, checked_ty, _)| (i, checked_ty))\n-                .chain(final_arg_types.iter().map(|&(i, _, coerced_ty)| (i, coerced_ty)))\n+                .enumerate()\n+                .filter_map(|(i, arg)| match arg {\n+                    Some((checked_ty, coerce_ty)) => Some([(i, *checked_ty), (i, *coerce_ty)]),\n+                    _ => None,\n+                })\n+                .flatten()\n                 .flat_map(|(i, ty)| {\n                     let ty = self.resolve_vars_if_possible(ty);\n                     // We walk the argument type because the argument's type could have"}, {"sha": "0b6588db92c83102b30fb5fe7a17de01c82a4acf", "filename": "library/std/src/os/fd/owned.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -8,6 +8,8 @@ use crate::fmt;\n use crate::fs;\n use crate::marker::PhantomData;\n use crate::mem::forget;\n+#[cfg(not(target_os = \"wasi\"))]\n+use crate::sys::cvt;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n /// A borrowed file descriptor.\n@@ -67,6 +69,37 @@ impl BorrowedFd<'_> {\n     }\n }\n \n+impl OwnedFd {\n+    /// Creates a new `OwnedFd` instance that shares the same underlying file handle\n+    /// as the existing `OwnedFd` instance.\n+    #[cfg(not(target_os = \"wasi\"))]\n+    pub fn try_clone(&self) -> crate::io::Result<Self> {\n+        // We want to atomically duplicate this file descriptor and set the\n+        // CLOEXEC flag, and currently that's done via F_DUPFD_CLOEXEC. This\n+        // is a POSIX flag that was added to Linux in 2.6.24.\n+        #[cfg(not(target_os = \"espidf\"))]\n+        let cmd = libc::F_DUPFD_CLOEXEC;\n+\n+        // For ESP-IDF, F_DUPFD is used instead, because the CLOEXEC semantics\n+        // will never be supported, as this is a bare metal framework with\n+        // no capabilities for multi-process execution.  While F_DUPFD is also\n+        // not supported yet, it might be (currently it returns ENOSYS).\n+        #[cfg(target_os = \"espidf\")]\n+        let cmd = libc::F_DUPFD;\n+\n+        let fd = cvt(unsafe { libc::fcntl(self.as_raw_fd(), cmd, 0) })?;\n+        Ok(unsafe { Self::from_raw_fd(fd) })\n+    }\n+\n+    #[cfg(target_os = \"wasi\")]\n+    pub fn try_clone(&self) -> crate::io::Result<Self> {\n+        Err(crate::io::Error::new_const(\n+            crate::io::ErrorKind::Unsupported,\n+            &\"operation not supported on WASI yet\",\n+        ))\n+    }\n+}\n+\n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n impl AsRawFd for BorrowedFd<'_> {\n     #[inline]"}, {"sha": "e37ce633a129a77f231af65ffff172824d358adc", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -6,9 +6,11 @@ use super::raw::{AsRawHandle, FromRawHandle, IntoRawHandle, RawHandle};\n use crate::convert::TryFrom;\n use crate::fmt;\n use crate::fs;\n+use crate::io;\n use crate::marker::PhantomData;\n use crate::mem::forget;\n use crate::sys::c;\n+use crate::sys::cvt;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n /// A borrowed handle.\n@@ -144,6 +146,36 @@ impl TryFrom<HandleOrNull> for OwnedHandle {\n     }\n }\n \n+impl OwnedHandle {\n+    /// Creates a new `OwnedHandle` instance that shares the same underlying file handle\n+    /// as the existing `OwnedHandle` instance.\n+    pub fn try_clone(&self) -> crate::io::Result<Self> {\n+        self.duplicate(0, false, c::DUPLICATE_SAME_ACCESS)\n+    }\n+\n+    pub(crate) fn duplicate(\n+        &self,\n+        access: c::DWORD,\n+        inherit: bool,\n+        options: c::DWORD,\n+    ) -> io::Result<Self> {\n+        let mut ret = 0 as c::HANDLE;\n+        cvt(unsafe {\n+            let cur_proc = c::GetCurrentProcess();\n+            c::DuplicateHandle(\n+                cur_proc,\n+                self.as_raw_handle(),\n+                cur_proc,\n+                &mut ret,\n+                access,\n+                inherit as c::BOOL,\n+                options,\n+            )\n+        })?;\n+        unsafe { Ok(Self::from_raw_handle(ret)) }\n+    }\n+}\n+\n impl TryFrom<HandleOrInvalid> for OwnedHandle {\n     type Error = ();\n "}, {"sha": "26b569bcdd3625f3f1c0ecaa75eb6c183113e6d3", "filename": "library/std/src/os/windows/io/socket.rs", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -4,9 +4,13 @@\n \n use super::raw::{AsRawSocket, FromRawSocket, IntoRawSocket, RawSocket};\n use crate::fmt;\n+use crate::io;\n use crate::marker::PhantomData;\n+use crate::mem;\n use crate::mem::forget;\n+use crate::sys;\n use crate::sys::c;\n+use crate::sys::cvt;\n \n /// A borrowed socket.\n ///\n@@ -69,6 +73,77 @@ impl BorrowedSocket<'_> {\n     }\n }\n \n+impl OwnedSocket {\n+    /// Creates a new `OwnedSocket` instance that shares the same underlying socket\n+    /// as the existing `OwnedSocket` instance.\n+    pub fn try_clone(&self) -> io::Result<Self> {\n+        let mut info = unsafe { mem::zeroed::<c::WSAPROTOCOL_INFO>() };\n+        let result = unsafe {\n+            c::WSADuplicateSocketW(self.as_raw_socket(), c::GetCurrentProcessId(), &mut info)\n+        };\n+        sys::net::cvt(result)?;\n+        let socket = unsafe {\n+            c::WSASocketW(\n+                info.iAddressFamily,\n+                info.iSocketType,\n+                info.iProtocol,\n+                &mut info,\n+                0,\n+                c::WSA_FLAG_OVERLAPPED | c::WSA_FLAG_NO_HANDLE_INHERIT,\n+            )\n+        };\n+\n+        if socket != c::INVALID_SOCKET {\n+            unsafe { Ok(OwnedSocket::from_raw_socket(socket)) }\n+        } else {\n+            let error = unsafe { c::WSAGetLastError() };\n+\n+            if error != c::WSAEPROTOTYPE && error != c::WSAEINVAL {\n+                return Err(io::Error::from_raw_os_error(error));\n+            }\n+\n+            let socket = unsafe {\n+                c::WSASocketW(\n+                    info.iAddressFamily,\n+                    info.iSocketType,\n+                    info.iProtocol,\n+                    &mut info,\n+                    0,\n+                    c::WSA_FLAG_OVERLAPPED,\n+                )\n+            };\n+\n+            if socket == c::INVALID_SOCKET {\n+                return Err(last_error());\n+            }\n+\n+            unsafe {\n+                let socket = OwnedSocket::from_raw_socket(socket);\n+                socket.set_no_inherit()?;\n+                Ok(socket)\n+            }\n+        }\n+    }\n+\n+    #[cfg(not(target_vendor = \"uwp\"))]\n+    pub(crate) fn set_no_inherit(&self) -> io::Result<()> {\n+        cvt(unsafe {\n+            c::SetHandleInformation(self.as_raw_socket() as c::HANDLE, c::HANDLE_FLAG_INHERIT, 0)\n+        })\n+        .map(drop)\n+    }\n+\n+    #[cfg(target_vendor = \"uwp\")]\n+    pub(crate) fn set_no_inherit(&self) -> io::Result<()> {\n+        Err(io::Error::new_const(io::ErrorKind::Unsupported, &\"Unavailable on UWP\"))\n+    }\n+}\n+\n+/// Returns the last error from the Windows socket interface.\n+fn last_error() -> io::Error {\n+    io::Error::from_raw_os_error(unsafe { c::WSAGetLastError() })\n+}\n+\n impl AsRawSocket for BorrowedSocket<'_> {\n     #[inline]\n     fn as_raw_socket(&self) -> RawSocket {"}, {"sha": "3de7c68a6866dbde7bb55aa2f749e621a164f30b", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -259,22 +259,9 @@ impl FileDesc {\n         }\n     }\n \n+    #[inline]\n     pub fn duplicate(&self) -> io::Result<FileDesc> {\n-        // We want to atomically duplicate this file descriptor and set the\n-        // CLOEXEC flag, and currently that's done via F_DUPFD_CLOEXEC. This\n-        // is a POSIX flag that was added to Linux in 2.6.24.\n-        #[cfg(not(target_os = \"espidf\"))]\n-        let cmd = libc::F_DUPFD_CLOEXEC;\n-\n-        // For ESP-IDF, F_DUPFD is used instead, because the CLOEXEC semantics\n-        // will never be supported, as this is a bare metal framework with\n-        // no capabilities for multi-process execution.  While F_DUPFD is also\n-        // not supported yet, it might be (currently it returns ENOSYS).\n-        #[cfg(target_os = \"espidf\")]\n-        let cmd = libc::F_DUPFD;\n-\n-        let fd = cvt(unsafe { libc::fcntl(self.as_raw_fd(), cmd, 0) })?;\n-        Ok(unsafe { FileDesc::from_raw_fd(fd) })\n+        Ok(Self(self.0.try_clone()?))\n     }\n }\n "}, {"sha": "028b6b30099dd7a7146b694b5c2ca1cbd32afd6e", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -460,7 +460,7 @@ impl File {\n     }\n \n     pub fn duplicate(&self) -> io::Result<File> {\n-        Ok(File { handle: self.handle.duplicate(0, false, c::DUPLICATE_SAME_ACCESS)? })\n+        Ok(Self { handle: self.handle.try_clone()? })\n     }\n \n     fn reparse_point<'a>("}, {"sha": "daab39bb00cbcd9a0c556d935bbfc66b7b697953", "filename": "library/std/src/sys/windows/handle.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -262,26 +262,17 @@ impl Handle {\n         Ok(written as usize)\n     }\n \n+    pub fn try_clone(&self) -> io::Result<Self> {\n+        Ok(Self(self.0.try_clone()?))\n+    }\n+\n     pub fn duplicate(\n         &self,\n         access: c::DWORD,\n         inherit: bool,\n         options: c::DWORD,\n-    ) -> io::Result<Handle> {\n-        let mut ret = 0 as c::HANDLE;\n-        cvt(unsafe {\n-            let cur_proc = c::GetCurrentProcess();\n-            c::DuplicateHandle(\n-                cur_proc,\n-                self.as_raw_handle(),\n-                cur_proc,\n-                &mut ret,\n-                access,\n-                inherit as c::BOOL,\n-                options,\n-            )\n-        })?;\n-        unsafe { Ok(Handle::from_raw_handle(ret)) }\n+    ) -> io::Result<Self> {\n+        Ok(Self(self.0.duplicate(access, inherit, options)?))\n     }\n }\n "}, {"sha": "14d5f15d2024822585ad8b3c6cf3e6c4f9d0076a", "filename": "library/std/src/sys/windows/net.rs", "status": "modified", "additions": 2, "deletions": 60, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -134,7 +134,7 @@ impl Socket {\n \n             unsafe {\n                 let socket = Self::from_raw_socket(socket);\n-                socket.set_no_inherit()?;\n+                socket.0.set_no_inherit()?;\n                 Ok(socket)\n             }\n         }\n@@ -213,52 +213,7 @@ impl Socket {\n     }\n \n     pub fn duplicate(&self) -> io::Result<Socket> {\n-        let mut info = unsafe { mem::zeroed::<c::WSAPROTOCOL_INFO>() };\n-        let result = unsafe {\n-            c::WSADuplicateSocketW(self.as_raw_socket(), c::GetCurrentProcessId(), &mut info)\n-        };\n-        cvt(result)?;\n-        let socket = unsafe {\n-            c::WSASocketW(\n-                info.iAddressFamily,\n-                info.iSocketType,\n-                info.iProtocol,\n-                &mut info,\n-                0,\n-                c::WSA_FLAG_OVERLAPPED | c::WSA_FLAG_NO_HANDLE_INHERIT,\n-            )\n-        };\n-\n-        if socket != c::INVALID_SOCKET {\n-            unsafe { Ok(Self::from_inner(OwnedSocket::from_raw_socket(socket))) }\n-        } else {\n-            let error = unsafe { c::WSAGetLastError() };\n-\n-            if error != c::WSAEPROTOTYPE && error != c::WSAEINVAL {\n-                return Err(io::Error::from_raw_os_error(error));\n-            }\n-\n-            let socket = unsafe {\n-                c::WSASocketW(\n-                    info.iAddressFamily,\n-                    info.iSocketType,\n-                    info.iProtocol,\n-                    &mut info,\n-                    0,\n-                    c::WSA_FLAG_OVERLAPPED,\n-                )\n-            };\n-\n-            if socket == c::INVALID_SOCKET {\n-                return Err(last_error());\n-            }\n-\n-            unsafe {\n-                let socket = Self::from_inner(OwnedSocket::from_raw_socket(socket));\n-                socket.set_no_inherit()?;\n-                Ok(socket)\n-            }\n-        }\n+        Ok(Self(self.0.try_clone()?))\n     }\n \n     fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n@@ -421,19 +376,6 @@ impl Socket {\n         }\n     }\n \n-    #[cfg(not(target_vendor = \"uwp\"))]\n-    fn set_no_inherit(&self) -> io::Result<()> {\n-        sys::cvt(unsafe {\n-            c::SetHandleInformation(self.as_raw_socket() as c::HANDLE, c::HANDLE_FLAG_INHERIT, 0)\n-        })\n-        .map(drop)\n-    }\n-\n-    #[cfg(target_vendor = \"uwp\")]\n-    fn set_no_inherit(&self) -> io::Result<()> {\n-        Err(io::Error::new_const(io::ErrorKind::Unsupported, &\"Unavailable on UWP\"))\n-    }\n-\n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n         let how = match how {\n             Shutdown::Write => c::SD_SEND,"}, {"sha": "75ee663b926c49378b437cdc98b7059d6261dde9", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -101,6 +101,27 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n \n                     cx.generated_synthetics.insert((ty, trait_def_id));\n \n+                    let hir_imp = impl_def_id.as_local()\n+                        .map(|local| cx.tcx.hir().expect_item(local))\n+                        .and_then(|item| if let hir::ItemKind::Impl(i) = &item.kind {\n+                            Some(i)\n+                        } else {\n+                            None\n+                        });\n+\n+                    let items = match hir_imp {\n+                        Some(imp) => imp\n+                            .items\n+                            .iter()\n+                            .map(|ii| cx.tcx.hir().impl_item(ii.id).clean(cx))\n+                            .collect::<Vec<_>>(),\n+                        None => cx.tcx\n+                            .associated_items(impl_def_id)\n+                            .in_definition_order()\n+                            .map(|x| x.clean(cx))\n+                            .collect::<Vec<_>>(),\n+                    };\n+\n                     impls.push(Item {\n                         name: None,\n                         attrs: Default::default(),\n@@ -117,12 +138,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                             // the post-inference `trait_ref`, as it's more accurate.\n                             trait_: Some(trait_ref.clean(cx)),\n                             for_: ty.clean(cx),\n-                            items: cx\n-                                .tcx\n-                                .associated_items(impl_def_id)\n-                                .in_definition_order()\n-                                .map(|x| x.clean(cx))\n-                                .collect::<Vec<_>>(),\n+                            items,\n                             polarity: ty::ImplPolarity::Positive,\n                             kind: ImplKind::Blanket(box trait_ref.self_ty().clean(cx)),\n                         }),"}, {"sha": "32e4a82918421cb83d34d43dd0c497ab50f7cf6e", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 35, "deletions": 40, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -376,25 +376,21 @@ impl Setting {\n                 description,\n             ),\n             Setting::Select { js_data_name, description, default_value, ref options } => format!(\n-                \"<div class=\\\"setting-line\\\">\\\n-                     <div>{}</div>\\\n-                     <label class=\\\"select-wrapper\\\">\\\n-                         <select id=\\\"{}\\\" autocomplete=\\\"off\\\">{}</select>\\\n-                         <img src=\\\"{}down-arrow{}.svg\\\" alt=\\\"Select item\\\">\\\n-                     </label>\\\n-                 </div>\",\n-                description,\n+                \"<div class=\\\"setting-line\\\"><div class=\\\"radio-line\\\" id=\\\"{}\\\"><span class=\\\"setting-name\\\">{}</span>{}</div></div>\",\n                 js_data_name,\n+                description,\n                 options\n                     .iter()\n                     .map(|opt| format!(\n-                        \"<option value=\\\"{name}\\\" {}>{name}</option>\",\n-                        if opt == default_value { \"selected\" } else { \"\" },\n+                        \"<label for=\\\"{js_data_name}-{name}\\\" class=\\\"choice\\\">\n+                           <input type=\\\"radio\\\" name=\\\"{js_data_name}\\\" id=\\\"{js_data_name}-{name}\\\" value=\\\"{name}\\\" {checked}>\\\n+                           {name}\\\n+                         </label>\",\n+                        js_data_name = js_data_name,\n                         name = opt,\n+                        checked = if opt == default_value { \"checked\" } else { \"\" },\n                     ))\n                     .collect::<String>(),\n-                root_path,\n-                suffix,\n             ),\n         }\n     }\n@@ -418,31 +414,25 @@ impl<T: Into<Setting>> From<(&'static str, Vec<T>)> for Setting {\n fn settings(root_path: &str, suffix: &str, theme_names: Vec<String>) -> Result<String, Error> {\n     // (id, explanation, default value)\n     let settings: &[Setting] = &[\n-        (\n-            \"Theme preferences\",\n-            vec![\n-                Setting::from((\"use-system-theme\", \"Use system theme\", true)),\n-                Setting::Select {\n-                    js_data_name: \"theme\",\n-                    description: \"Theme\",\n-                    default_value: \"light\",\n-                    options: theme_names.clone(),\n-                },\n-                Setting::Select {\n-                    js_data_name: \"preferred-dark-theme\",\n-                    description: \"Preferred dark theme\",\n-                    default_value: \"dark\",\n-                    options: theme_names.clone(),\n-                },\n-                Setting::Select {\n-                    js_data_name: \"preferred-light-theme\",\n-                    description: \"Preferred light theme\",\n-                    default_value: \"light\",\n-                    options: theme_names,\n-                },\n-            ],\n-        )\n-            .into(),\n+        Setting::from((\"use-system-theme\", \"Use system theme\", true)),\n+        Setting::Select {\n+            js_data_name: \"theme\",\n+            description: \"Theme\",\n+            default_value: \"light\",\n+            options: theme_names.clone(),\n+        },\n+        Setting::Select {\n+            js_data_name: \"preferred-light-theme\",\n+            description: \"Preferred light theme\",\n+            default_value: \"light\",\n+            options: theme_names.clone(),\n+        },\n+        Setting::Select {\n+            js_data_name: \"preferred-dark-theme\",\n+            description: \"Preferred dark theme\",\n+            default_value: \"dark\",\n+            options: theme_names,\n+        },\n         (\"auto-hide-large-items\", \"Auto-hide item contents for large items.\", true).into(),\n         (\"auto-hide-method-docs\", \"Auto-hide item methods' documentation\", false).into(),\n         (\"auto-hide-trait-implementations\", \"Auto-hide trait implementation documentation\", false)\n@@ -454,9 +444,14 @@ fn settings(root_path: &str, suffix: &str, theme_names: Vec<String>) -> Result<S\n     ];\n \n     Ok(format!(\n-        \"<h1 class=\\\"fqn\\\">\\\n-            <span class=\\\"in-band\\\">Rustdoc settings</span>\\\n-        </h1>\\\n+        \"<div class=\\\"main-heading\\\">\n+            <h1 class=\\\"fqn\\\">\\\n+                <span class=\\\"in-band\\\">Rustdoc settings</span>\\\n+            </h1>\\\n+            <span class=\\\"out-of-band\\\">\\\n+            <a id=\\\"back\\\" href=\\\"javascript:void(0)\\\">Back</a>\\\n+            </span>\\\n+        </div>\\\n         <div class=\\\"settings\\\">{}</div>\\\n         <link rel=\\\"stylesheet\\\" href=\\\"{root_path}settings{suffix}.css\\\">\\\n         <script src=\\\"{root_path}settings{suffix}.js\\\"></script>\","}, {"sha": "932000487b0a8098ffc24003f6f706b7a3fe254c", "filename": "src/librustdoc/html/static/css/settings.css", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -17,6 +17,30 @@\n \tborder-bottom: 1px solid;\n }\n \n+.setting-line .radio-line {\n+\tdisplay: flex;\n+\tflex-wrap: wrap;\n+}\n+\n+.setting-line .radio-line > * {\n+\tpadding: 0.3em;\n+}\n+\n+.setting-line .radio-line .setting-name {\n+\tflex-grow: 1;\n+}\n+\n+.setting-line .radio-line input {\n+\tmargin-right: 0.3em;\n+}\n+\n+.radio-line .choice {\n+\tborder-radius: 0.1em;\n+\tborder: 1px solid;\n+\tmargin-left: 0.5em;\n+\tmin-width: 3.5em;\n+}\n+\n .toggle {\n \tposition: relative;\n \tdisplay: inline-block;"}, {"sha": "47a8fcdfd5ecf29c5f7f6223a8691debc0b7928a", "filename": "src/librustdoc/html/static/js/settings.js", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -33,19 +33,15 @@\n     }\n \n     function showLightAndDark() {\n-        addClass(document.getElementById(\"theme\").parentElement.parentElement, \"hidden\");\n-        removeClass(document.getElementById(\"preferred-light-theme\").parentElement.parentElement,\n-            \"hidden\");\n-        removeClass(document.getElementById(\"preferred-dark-theme\").parentElement.parentElement,\n-            \"hidden\");\n+        addClass(document.getElementById(\"theme\").parentElement, \"hidden\");\n+        removeClass(document.getElementById(\"preferred-light-theme\").parentElement, \"hidden\");\n+        removeClass(document.getElementById(\"preferred-dark-theme\").parentElement, \"hidden\");\n     }\n \n     function hideLightAndDark() {\n-        addClass(document.getElementById(\"preferred-light-theme\").parentElement.parentElement,\n-            \"hidden\");\n-        addClass(document.getElementById(\"preferred-dark-theme\").parentElement.parentElement,\n-            \"hidden\");\n-        removeClass(document.getElementById(\"theme\").parentElement.parentElement, \"hidden\");\n+        addClass(document.getElementById(\"preferred-light-theme\").parentElement, \"hidden\");\n+        addClass(document.getElementById(\"preferred-dark-theme\").parentElement, \"hidden\");\n+        removeClass(document.getElementById(\"theme\").parentElement, \"hidden\");\n     }\n \n     function updateLightAndDark() {\n@@ -82,6 +78,19 @@\n                 changeSetting(this.id, this.value);\n             };\n         });\n+        onEachLazy(document.querySelectorAll(\"input[type=\\\"radio\\\"]\"), function(elem) {\n+            const settingId = elem.name;\n+            const settingValue = getSettingValue(settingId);\n+            if (settingValue !== null && settingValue !== \"null\") {\n+                elem.checked = settingValue === elem.value;\n+            }\n+            elem.addEventListener(\"change\", function(ev) {\n+                changeSetting(ev.target.name, ev.target.value);\n+            });\n+        });\n+        document.getElementById(\"back\").addEventListener(\"click\", function() {\n+            history.back();\n+        });\n     }\n \n     window.addEventListener(\"DOMContentLoaded\", setEvents);"}, {"sha": "f9e9fe0d3cf201d7aaae3937650af957ff6c54ed", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -172,21 +172,8 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n     /// the hashmap because certain items (traits and types) need to have their mappings for trait\n     /// implementations filled out before they're inserted.\n     fn item(&mut self, item: clean::Item) -> Result<(), Error> {\n-        let local_blanket_impl = match item.def_id {\n-            clean::ItemId::Blanket { impl_id, .. } => impl_id.is_local(),\n-            clean::ItemId::Auto { .. }\n-            | clean::ItemId::DefId(_)\n-            | clean::ItemId::Primitive(_, _) => false,\n-        };\n-\n         // Flatten items that recursively store other items\n-        // FIXME(CraftSpider): We skip children of local blanket implementations, as we'll have\n-        //     already seen the actual generic impl, and the generated ones don't need documenting.\n-        //     This is necessary due to the visibility, return type, and self arg of the generated\n-        //     impls not quite matching, and will no longer be necessary when the mismatch is fixed.\n-        if !local_blanket_impl {\n-            item.kind.inner_items().for_each(|i| self.item(i.clone()).unwrap());\n-        }\n+        item.kind.inner_items().for_each(|i| self.item(i.clone()).unwrap());\n \n         let id = item.def_id;\n         if let Some(mut new_item) = self.convert_item(item) {"}, {"sha": "a48a8373c2b593053cdec0146942e9aa21c0cf1e", "filename": "src/test/incremental/issue-92987-provisional-dep-node.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Ftest%2Fincremental%2Fissue-92987-provisional-dep-node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Ftest%2Fincremental%2Fissue-92987-provisional-dep-node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-92987-provisional-dep-node.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -0,0 +1,24 @@\n+// revisions: rpass1 rpass2\n+\n+// Regression test for issue #92987\n+// Tests that we properly manage `DepNode`s during trait evaluation\n+// involing an auto-trait cycle.\n+\n+#[cfg(rpass1)]\n+struct CycleOne(Box<CycleTwo>);\n+\n+#[cfg(rpass2)]\n+enum CycleOne {\n+    Variant(Box<CycleTwo>)\n+}\n+\n+struct CycleTwo(CycleOne);\n+\n+fn assert_send<T: Send>() {}\n+\n+fn bar() {\n+    assert_send::<CycleOne>();\n+    assert_send::<CycleTwo>();\n+}\n+\n+fn main() {}"}, {"sha": "a1655adedd44705fd962eb6b3cd5fee940a8ffe3", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.issue-93054.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-93054.txt", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-93054.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-93054.txt?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -0,0 +1,29 @@\n+    1|       |// Regression test for #93054: Functions using uninhabited types often only have a single,\n+    2|       |// unreachable basic block which doesn't get instrumented. This should not cause llvm-cov to fail.\n+    3|       |// Since these kinds functions can't be invoked anyway, it's ok to not have coverage data for them.\n+    4|       |\n+    5|       |// compile-flags: --edition=2021\n+    6|       |\n+    7|       |enum Never { }\n+    8|       |\n+    9|       |impl Never {\n+   10|       |    fn foo(self) {\n+   11|       |        match self { }\n+   12|       |        make().map(|never| match never { });\n+   13|       |    }\n+   14|       |\n+   15|       |    fn bar(&self) {\n+   16|       |        match *self { }\n+   17|       |    }\n+   18|       |}\n+   19|       |\n+   20|      0|async fn foo2(never: Never) {\n+   21|       |    match never { }\n+   22|       |}\n+   23|       |\n+   24|      0|fn make() -> Option<Never> {\n+   25|      0|    None\n+   26|      0|}\n+   27|       |\n+   28|      1|fn main() { }\n+"}, {"sha": "c160b3db03f8e49e35dd704fd247ca90b53c766c", "filename": "src/test/run-make-fulldeps/coverage/issue-93054.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fissue-93054.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fissue-93054.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fissue-93054.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -0,0 +1,28 @@\n+// Regression test for #93054: Functions using uninhabited types often only have a single,\n+// unreachable basic block which doesn't get instrumented. This should not cause llvm-cov to fail.\n+// Since these kinds functions can't be invoked anyway, it's ok to not have coverage data for them.\n+\n+// compile-flags: --edition=2021\n+\n+enum Never { }\n+\n+impl Never {\n+    fn foo(self) {\n+        match self { }\n+        make().map(|never| match never { });\n+    }\n+\n+    fn bar(&self) {\n+        match *self { }\n+    }\n+}\n+\n+async fn foo2(never: Never) {\n+    match never { }\n+}\n+\n+fn make() -> Option<Never> {\n+    None\n+}\n+\n+fn main() { }"}, {"sha": "a3d55b35f0018ad7fb412746efcfb21ca152ab25", "filename": "src/test/rustdoc-json/impls/blanket_with_local.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Ftest%2Frustdoc-json%2Fimpls%2Fblanket_with_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Ftest%2Frustdoc-json%2Fimpls%2Fblanket_with_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fimpls%2Fblanket_with_local.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -3,11 +3,15 @@\n \n // @has blanket_with_local.json \"$.index[*][?(@.name=='Load')]\"\n pub trait Load {\n+    // @has - \"$.index[*][?(@.name=='load')]\"\n     fn load() {}\n+    // @has - \"$.index[*][?(@.name=='write')]\"\n+    fn write(self) {}\n }\n \n impl<P> Load for P {\n     fn load() {}\n+    fn write(self) {}\n }\n \n // @has - \"$.index[*][?(@.name=='Wrapper')]\""}, {"sha": "f71df1b87fcda367ca59e71e60106e48cb6d9a0f", "filename": "src/test/ui/coherence/auxiliary/option_future.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Ftest%2Fui%2Fcoherence%2Fauxiliary%2Foption_future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Ftest%2Fui%2Fcoherence%2Fauxiliary%2Foption_future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fauxiliary%2Foption_future.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -0,0 +1,8 @@\n+#![crate_type = \"lib\"]\n+#![feature(negative_impls)]\n+#![feature(rustc_attrs)]\n+\n+pub trait Future {}\n+\n+#[rustc_with_negative_coherence]\n+impl<E> !Future for Option<E> where E: Sized {}"}, {"sha": "1f47b5ba46e411158d39814bf710cf03b55d1f32", "filename": "src/test/ui/coherence/coherence-overlap-negative-trait2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negative-trait2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negative-trait2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negative-trait2.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+// aux-build:option_future.rs\n+//\n+// Check that if we promise to not impl what would overlap it doesn't actually overlap\n+\n+#![feature(rustc_attrs)]\n+\n+extern crate option_future as lib;\n+use lib::Future;\n+\n+trait Termination {}\n+\n+#[rustc_with_negative_coherence]\n+impl<E> Termination for Option<E> where E: Sized {}\n+#[rustc_with_negative_coherence]\n+impl<F> Termination for F where F: Future + Sized {}\n+\n+fn main() {}"}, {"sha": "d62625faaaa083b1bf6a907ecfb645c72768c263", "filename": "src/test/ui/mismatched_types/overloaded-calls-bad.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.rs?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -30,4 +30,5 @@ fn main() {\n     //~^ ERROR this function takes 1 argument but 0 arguments were supplied\n     let ans = s(\"burma\", \"shave\");\n     //~^ ERROR this function takes 1 argument but 2 arguments were supplied\n+    //~| ERROR mismatched types\n }"}, {"sha": "9ae9c474162d94c4c221b4b312260253a781af40", "filename": "src/test/ui/mismatched_types/overloaded-calls-bad.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df368ae457c54fb95d3e64f9986a5f171a6370f0/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr?ref=df368ae457c54fb95d3e64f9986a5f171a6370f0", "patch": "@@ -18,6 +18,12 @@ note: associated function defined here\n LL |     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n    |                           ^^^^^^^^\n \n+error[E0308]: mismatched types\n+  --> $DIR/overloaded-calls-bad.rs:31:17\n+   |\n+LL |     let ans = s(\"burma\", \"shave\");\n+   |                 ^^^^^^^ expected `isize`, found `&str`\n+\n error[E0057]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/overloaded-calls-bad.rs:31:15\n    |\n@@ -32,7 +38,7 @@ note: associated function defined here\n LL |     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n    |                           ^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n Some errors have detailed explanations: E0057, E0308.\n For more information about an error, try `rustc --explain E0057`."}]}