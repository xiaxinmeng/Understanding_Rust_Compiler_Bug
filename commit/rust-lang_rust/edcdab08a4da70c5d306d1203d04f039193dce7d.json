{"sha": "edcdab08a4da70c5d306d1203d04f039193dce7d", "node_id": "C_kwDOAAsO6NoAKGVkY2RhYjA4YTRkYTcwYzVkMzA2ZDEyMDNkMDRmMDM5MTkzZGNlN2Q", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-14T17:24:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-14T17:24:42Z"}, "message": "Rollup merge of #108033 - lcnr:coinductive-attr, r=compiler-errors\n\nadd an unstable `#[rustc_coinductive]` attribute\n\nuseful to test coinduction, especially in the new solver.\n\nas this attribute should remain permanently unstable I don't think this needs any official approval. cc ``@rust-lang/types``\n\nhad to weaken the check for stable query results in the solver to prevent an ICE if there's a coinductive cycle with constraints.\n\nr? ``@compiler-errors``", "tree": {"sha": "06f08ea292b71b5c25fe2d711d11cf5b30216b0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06f08ea292b71b5c25fe2d711d11cf5b30216b0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edcdab08a4da70c5d306d1203d04f039193dce7d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj68PaCRBK7hj4Ov3rIwAAjzgIAE56y3O+2THw9M3/UzI+GGPF\n7/ojuXuUE8JeF4/N//d6+wdfCaoWKkewyjkIQNYiKj/F8hrgjj3J6sAMQhX1JdY3\nLnpuIgpmASaod6nQbEk5XU8XfzXrXcZHqnmLdWUrrF/L1GuHYM8sguCzfHYNQJ1E\n5Zf+QQpOFRIjWuhpLpOhmrDVBtGJaRuYWiGUhSRuTkC8QoPUKqAzn5BZtS7LhEHL\nYui4eBEZlg48DjVPFg2r2dBydi8/mXF98MwGaFWxNIAWc9dE0ClBzu7Gda6VtzIO\ncX1NHWmNV3F/q2nv8TzlVxdou0x+mhko0aoVZfSNpXhAVPbY+lbLf17Fj+KQzEI=\n=7f7O\n-----END PGP SIGNATURE-----\n", "payload": "tree 06f08ea292b71b5c25fe2d711d11cf5b30216b0b\nparent 7e0127b2aee220222c044aa55039e45a6be7be87\nparent a2f03037b40c9c20a46020f7760ebab9e0736900\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1676395482 +0100\ncommitter GitHub <noreply@github.com> 1676395482 +0100\n\nRollup merge of #108033 - lcnr:coinductive-attr, r=compiler-errors\n\nadd an unstable `#[rustc_coinductive]` attribute\n\nuseful to test coinduction, especially in the new solver.\n\nas this attribute should remain permanently unstable I don't think this needs any official approval. cc ``@rust-lang/types``\n\nhad to weaken the check for stable query results in the solver to prevent an ICE if there's a coinductive cycle with constraints.\n\nr? ``@compiler-errors``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edcdab08a4da70c5d306d1203d04f039193dce7d", "html_url": "https://github.com/rust-lang/rust/commit/edcdab08a4da70c5d306d1203d04f039193dce7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edcdab08a4da70c5d306d1203d04f039193dce7d/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e0127b2aee220222c044aa55039e45a6be7be87", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e0127b2aee220222c044aa55039e45a6be7be87", "html_url": "https://github.com/rust-lang/rust/commit/7e0127b2aee220222c044aa55039e45a6be7be87"}, {"sha": "a2f03037b40c9c20a46020f7760ebab9e0736900", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2f03037b40c9c20a46020f7760ebab9e0736900", "html_url": "https://github.com/rust-lang/rust/commit/a2f03037b40c9c20a46020f7760ebab9e0736900"}], "stats": {"total": 167, "additions": 130, "deletions": 37}, "files": [{"sha": "493a9cd89e3b63fa98af2b59130e331a52e6ef3f", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/edcdab08a4da70c5d306d1203d04f039193dce7d/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edcdab08a4da70c5d306d1203d04f039193dce7d/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=edcdab08a4da70c5d306d1203d04f039193dce7d", "patch": "@@ -414,7 +414,10 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n \n     // Linking:\n-    gated!(naked, Normal, template!(Word), WarnFollowing, @only_local: true, naked_functions, experimental!(naked)),\n+    gated!(\n+        naked, Normal, template!(Word), WarnFollowing, @only_local: true,\n+        naked_functions, experimental!(naked)\n+    ),\n \n     // Plugins:\n     BuiltinAttribute {\n@@ -441,7 +444,8 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n     // RFC #1268\n     gated!(\n-        marker, Normal, template!(Word), WarnFollowing, marker_trait_attr, experimental!(marker)\n+        marker, Normal, template!(Word), WarnFollowing, @only_local: true,\n+        marker_trait_attr, experimental!(marker)\n     ),\n     gated!(\n         thread_local, Normal, template!(Word), WarnFollowing,\n@@ -682,14 +686,17 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         \"language items are subject to change\",\n     ),\n     rustc_attr!(\n-        rustc_pass_by_value, Normal,\n-        template!(Word), ErrorFollowing,\n+        rustc_pass_by_value, Normal, template!(Word), ErrorFollowing,\n         \"#[rustc_pass_by_value] is used to mark types that must be passed by value instead of reference.\"\n     ),\n     rustc_attr!(\n         rustc_coherence_is_core, AttributeType::CrateLevel, template!(Word), ErrorFollowing, @only_local: true,\n         \"#![rustc_coherence_is_core] allows inherent methods on builtin types, only intended to be used in `core`.\"\n     ),\n+    rustc_attr!(\n+        rustc_coinductive, AttributeType::Normal, template!(Word), WarnFollowing, @only_local: true,\n+        \"#![rustc_coinductive] changes a trait to be coinductive, allowing cycles in the trait solver.\"\n+    ),\n     rustc_attr!(\n         rustc_allow_incoherent_impl, AttributeType::Normal, template!(Word), ErrorFollowing, @only_local: true,\n         \"#[rustc_allow_incoherent_impl] has to be added to all impl items of an incoherent inherent impl.\""}, {"sha": "9f33d84ab52067e176b92f8f3d6d5b7b610b92cc", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/edcdab08a4da70c5d306d1203d04f039193dce7d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edcdab08a4da70c5d306d1203d04f039193dce7d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=edcdab08a4da70c5d306d1203d04f039193dce7d", "patch": "@@ -934,9 +934,10 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n     }\n \n     let is_marker = tcx.has_attr(def_id, sym::marker);\n+    let rustc_coinductive = tcx.has_attr(def_id, sym::rustc_coinductive);\n     let skip_array_during_method_dispatch =\n         tcx.has_attr(def_id, sym::rustc_skip_array_during_method_dispatch);\n-    let spec_kind = if tcx.has_attr(def_id, sym::rustc_unsafe_specialization_marker) {\n+    let specialization_kind = if tcx.has_attr(def_id, sym::rustc_unsafe_specialization_marker) {\n         ty::trait_def::TraitSpecializationKind::Marker\n     } else if tcx.has_attr(def_id, sym::rustc_specialization_trait) {\n         ty::trait_def::TraitSpecializationKind::AlwaysApplicable\n@@ -1036,16 +1037,17 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n             no_dups.then_some(list)\n         });\n \n-    ty::TraitDef::new(\n+    ty::TraitDef {\n         def_id,\n         unsafety,\n         paren_sugar,\n-        is_auto,\n+        has_auto_impl: is_auto,\n         is_marker,\n+        is_coinductive: rustc_coinductive || is_auto,\n         skip_array_during_method_dispatch,\n-        spec_kind,\n+        specialization_kind,\n         must_implement_one_of,\n-    )\n+    }\n }\n \n fn are_suggestable_generic_args(generic_args: &[hir::GenericArg<'_>]) -> bool {"}, {"sha": "5b7ca750f78fb52cb7ee57beeab8ac66371544c2", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/edcdab08a4da70c5d306d1203d04f039193dce7d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edcdab08a4da70c5d306d1203d04f039193dce7d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=edcdab08a4da70c5d306d1203d04f039193dce7d", "patch": "@@ -2388,15 +2388,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.trait_def(trait_def_id).has_auto_impl\n     }\n \n+    /// Returns `true` if this is coinductive, either because it is\n+    /// an auto trait or because it has the `#[rustc_coinductive]` attribute.\n+    pub fn trait_is_coinductive(self, trait_def_id: DefId) -> bool {\n+        self.trait_def(trait_def_id).is_coinductive\n+    }\n+\n     /// Returns `true` if this is a trait alias.\n     pub fn trait_is_alias(self, trait_def_id: DefId) -> bool {\n         self.def_kind(trait_def_id) == DefKind::TraitAlias\n     }\n \n-    pub fn trait_is_coinductive(self, trait_def_id: DefId) -> bool {\n-        self.trait_is_auto(trait_def_id) || self.lang_items().sized_trait() == Some(trait_def_id)\n-    }\n-\n     /// Returns layout of a generator. Layout might be unavailable if the\n     /// generator is tainted by errors.\n     pub fn generator_layout(self, def_id: DefId) -> Option<&'tcx GeneratorLayout<'tcx>> {"}, {"sha": "71353acaaa7c45f844bc1bf47dfa042f3c7510e4", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/edcdab08a4da70c5d306d1203d04f039193dce7d/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edcdab08a4da70c5d306d1203d04f039193dce7d/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=edcdab08a4da70c5d306d1203d04f039193dce7d", "patch": "@@ -31,6 +31,15 @@ pub struct TraitDef {\n     /// and thus `impl`s of it are allowed to overlap.\n     pub is_marker: bool,\n \n+    /// If `true`, then this trait has to `#[rustc_coinductive]` attribute or\n+    /// is an auto trait. This indicates that trait solver cycles involving an\n+    /// `X: ThisTrait` goal are accepted.\n+    ///\n+    /// In the future all traits should be coinductive, but we need a better\n+    /// formal understanding of what exactly that means and should probably\n+    /// also have already switched to the new trait solver.\n+    pub is_coinductive: bool,\n+\n     /// If `true`, then this trait has the `#[rustc_skip_array_during_method_dispatch]`\n     /// attribute, indicating that editions before 2021 should not consider this trait\n     /// during method dispatch if the receiver is an array.\n@@ -81,28 +90,6 @@ impl TraitImpls {\n }\n \n impl<'tcx> TraitDef {\n-    pub fn new(\n-        def_id: DefId,\n-        unsafety: hir::Unsafety,\n-        paren_sugar: bool,\n-        has_auto_impl: bool,\n-        is_marker: bool,\n-        skip_array_during_method_dispatch: bool,\n-        specialization_kind: TraitSpecializationKind,\n-        must_implement_one_of: Option<Box<[Ident]>>,\n-    ) -> TraitDef {\n-        TraitDef {\n-            def_id,\n-            unsafety,\n-            paren_sugar,\n-            has_auto_impl,\n-            is_marker,\n-            skip_array_during_method_dispatch,\n-            specialization_kind,\n-            must_implement_one_of,\n-        }\n-    }\n-\n     pub fn ancestors(\n         &self,\n         tcx: TyCtxt<'tcx>,"}, {"sha": "225095948af883512ce5b49c2283121a992e8718", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/edcdab08a4da70c5d306d1203d04f039193dce7d/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edcdab08a4da70c5d306d1203d04f039193dce7d/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=edcdab08a4da70c5d306d1203d04f039193dce7d", "patch": "@@ -156,6 +156,7 @@ impl CheckAttrVisitor<'_> {\n                 | sym::rustc_dirty\n                 | sym::rustc_if_this_changed\n                 | sym::rustc_then_this_would_need => self.check_rustc_dirty_clean(&attr),\n+                sym::rustc_coinductive => self.check_rustc_coinductive(&attr, span, target),\n                 sym::cmse_nonsecure_entry => {\n                     self.check_cmse_nonsecure_entry(hir_id, attr, span, target)\n                 }\n@@ -1608,6 +1609,20 @@ impl CheckAttrVisitor<'_> {\n         }\n     }\n \n+    /// Checks if the `#[rustc_coinductive]` attribute is applied to a trait.\n+    fn check_rustc_coinductive(&self, attr: &Attribute, span: Span, target: Target) -> bool {\n+        match target {\n+            Target::Trait => true,\n+            _ => {\n+                self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToTrait {\n+                    attr_span: attr.span,\n+                    defn_span: span,\n+                });\n+                false\n+            }\n+        }\n+    }\n+\n     /// Checks if `#[link_section]` is applied to a function or static.\n     fn check_link_section(&self, hir_id: HirId, attr: &Attribute, span: Span, target: Target) {\n         match target {"}, {"sha": "56835a2466a5222c0ff91b9267fb260e06a42023", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/edcdab08a4da70c5d306d1203d04f039193dce7d/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edcdab08a4da70c5d306d1203d04f039193dce7d/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=edcdab08a4da70c5d306d1203d04f039193dce7d", "patch": "@@ -1224,6 +1224,7 @@ symbols! {\n         rustc_capture_analysis,\n         rustc_clean,\n         rustc_coherence_is_core,\n+        rustc_coinductive,\n         rustc_const_stable,\n         rustc_const_unstable,\n         rustc_conversion_suggestion,"}, {"sha": "38a86d55a2cc4706077d9f29afe4111589fa4d47", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/edcdab08a4da70c5d306d1203d04f039193dce7d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edcdab08a4da70c5d306d1203d04f039193dce7d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=edcdab08a4da70c5d306d1203d04f039193dce7d", "patch": "@@ -265,12 +265,18 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         // call `exists<U> <T as Trait>::Assoc == U` to enable better caching. This goal\n         // could constrain `U` to `u32` which would cause this check to result in a\n         // solver cycle.\n-        if cfg!(debug_assertions) && has_changed && !self.in_projection_eq_hack {\n+        if cfg!(debug_assertions)\n+            && has_changed\n+            && !self.in_projection_eq_hack\n+            && !self.search_graph.in_cycle()\n+        {\n             let mut orig_values = OriginalQueryValues::default();\n             let canonical_goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n             let canonical_response =\n                 EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n-            assert!(canonical_response.value.var_values.is_identity());\n+            if !canonical_response.value.var_values.is_identity() {\n+                bug!(\"unstable result: {goal:?} {canonical_goal:?} {canonical_response:?}\");\n+            }\n             assert_eq!(certainty, canonical_response.value.certainty);\n         }\n "}, {"sha": "e989c9145d1e047af1ee8618b4196e45775d2237", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/edcdab08a4da70c5d306d1203d04f039193dce7d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edcdab08a4da70c5d306d1203d04f039193dce7d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=edcdab08a4da70c5d306d1203d04f039193dce7d", "patch": "@@ -42,6 +42,24 @@ impl<'tcx> SearchGraph<'tcx> {\n             && !self.overflow_data.did_overflow()\n     }\n \n+    /// Whether we're currently in a cycle. This should only be used\n+    /// for debug assertions.\n+    pub(super) fn in_cycle(&self) -> bool {\n+        if let Some(stack_depth) = self.stack.last() {\n+            // Either the current goal on the stack is the root of a cycle...\n+            if self.stack[stack_depth].has_been_used {\n+                return true;\n+            }\n+\n+            // ...or it depends on a goal with a lower depth.\n+            let current_goal = self.stack[stack_depth].goal;\n+            let entry_index = self.provisional_cache.lookup_table[&current_goal];\n+            self.provisional_cache.entries[entry_index].depth != stack_depth\n+        } else {\n+            false\n+        }\n+    }\n+\n     /// Tries putting the new goal on the stack, returning an error if it is already cached.\n     ///\n     /// This correctly updates the provisional cache if there is a cycle."}, {"sha": "520ae0edb09c29aedb5956e7100ccc655f77ca16", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/edcdab08a4da70c5d306d1203d04f039193dce7d/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edcdab08a4da70c5d306d1203d04f039193dce7d/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=edcdab08a4da70c5d306d1203d04f039193dce7d", "patch": "@@ -97,6 +97,7 @@ unsafe impl<T: Sync + ?Sized> Send for &T {}\n #[fundamental] // for Default, for example, which requires that `[T]: !Default` be evaluatable\n #[rustc_specialization_trait]\n #[rustc_deny_explicit_impl]\n+#[cfg_attr(not(bootstrap), rustc_coinductive)]\n pub trait Sized {\n     // Empty.\n }"}, {"sha": "b10ba3a810fd974defec21b10ca3e3249693b83c", "filename": "tests/ui/coinduction/canonicalization-rerun.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/edcdab08a4da70c5d306d1203d04f039193dce7d/tests%2Fui%2Fcoinduction%2Fcanonicalization-rerun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edcdab08a4da70c5d306d1203d04f039193dce7d/tests%2Fui%2Fcoinduction%2Fcanonicalization-rerun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoinduction%2Fcanonicalization-rerun.rs?ref=edcdab08a4da70c5d306d1203d04f039193dce7d", "patch": "@@ -0,0 +1,54 @@\n+// check-pass\n+// revisions: old new\n+//[new] compile-flags: -Ztrait-solver=next\n+\n+// If we use canonical goals during trait solving we have to reevaluate\n+// the root goal of a cycle until we hit a fixpoint.\n+//\n+// Here `main` has a goal `(?0, ?1): Trait` which is canonicalized to\n+// `exists<^0, ^1> (^0, ^1): Trait`.\n+//\n+// - `exists<^0, ^1> (^0, ^1): Trait` -instantiate-> `(?0, ?1): Trait`\n+//   -`(?1, ?0): Trait` -canonicalize-> `exists<^0, ^1> (^0, ^1): Trait`\n+//     - COINDUCTIVE CYCLE OK (no constraints)\n+//   - `(): ConstrainToU32<?0>` -canonicalize-> `exists<^0> (): ConstrainToU32<^0>`\n+//     - OK (^0 = u32 -apply-> ?0 = u32)\n+//   - OK (?0 = u32 -canonicalize-> ^0 = u32)\n+//   - coinductive cycle with provisional result != final result, rerun\n+//\n+// - `exists<^0, ^1> (^0, ^1): Trait` -instantiate-> `(?0, ?1): Trait`\n+//   -`(?1, ?0): Trait` -canonicalize-> `exists<^0, ^1> (^0, ^1): Trait`\n+//     - COINDUCTIVE CYCLE OK (^0 = u32 -apply-> ?1 = u32)\n+//   - `(): ConstrainToU32<?0>` -canonicalize-> `exists<^0> (): ConstrainToU32<^0>`\n+//     - OK (^0 = u32 -apply-> ?1 = u32)\n+//   - OK (?0 = u32, ?1 = u32 -canonicalize-> ^0 = u32, ^1 = u32)\n+//   - coinductive cycle with provisional result != final result, rerun\n+//\n+// - `exists<^0, ^1> (^0, ^1): Trait` -instantiate-> `(?0, ?1): Trait`\n+//   -`(?1, ?0): Trait` -canonicalize-> `exists<^0, ^1> (^0, ^1): Trait`\n+//     - COINDUCTIVE CYCLE OK (^0 = u32, ^1 = u32 -apply-> ?1 = u32, ?0 = u32)\n+//   - `(): ConstrainToU32<?0>` -canonicalize-> `exists<^0> (): ConstrainToU32<^0>`\n+//     - OK (^0 = u32 -apply-> ?1 = u32)\n+//   - OK (?0 = u32, ?1 = u32 -canonicalize-> ^0 = u32, ^1 = u32)\n+//   - coinductive cycle with provisional result == final result, DONE\n+#![feature(rustc_attrs)]\n+#[rustc_coinductive]\n+trait Trait {}\n+\n+impl<T, U> Trait for (T, U)\n+where\n+    (U, T): Trait,\n+    (): ConstrainToU32<T>,\n+{}\n+\n+trait ConstrainToU32<T> {}\n+impl ConstrainToU32<u32> for () {}\n+\n+fn impls_trait<T, U>()\n+where\n+    (T, U): Trait,\n+{}\n+\n+fn main() {\n+    impls_trait::<_, _>();\n+}"}]}