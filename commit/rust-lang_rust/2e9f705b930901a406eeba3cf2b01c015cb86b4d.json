{"sha": "2e9f705b930901a406eeba3cf2b01c015cb86b4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlOWY3MDViOTMwOTAxYTQwNmVlYmEzY2YyYjAxYzAxNWNiODZiNGQ=", "commit": {"author": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-11-19T21:41:39Z"}, "committer": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-11-19T21:41:39Z"}, "message": "rollup merge of #19108: steveklabnik/doc_atomic_bool\n\nI don't know enough about the free functions to give them better docs right now.", "tree": {"sha": "6e0b9fcc48011968358186ec41fe7beff56bae8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e0b9fcc48011968358186ec41fe7beff56bae8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e9f705b930901a406eeba3cf2b01c015cb86b4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e9f705b930901a406eeba3cf2b01c015cb86b4d", "html_url": "https://github.com/rust-lang/rust/commit/2e9f705b930901a406eeba3cf2b01c015cb86b4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e9f705b930901a406eeba3cf2b01c015cb86b4d/comments", "author": null, "committer": null, "parents": [{"sha": "1b8ee82b5433f3e53dac7186b74439e1b4bbc786", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b8ee82b5433f3e53dac7186b74439e1b4bbc786", "html_url": "https://github.com/rust-lang/rust/commit/1b8ee82b5433f3e53dac7186b74439e1b4bbc786"}, {"sha": "40aa833fa3f31c0d9e657263f22d870566801e9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/40aa833fa3f31c0d9e657263f22d870566801e9a", "html_url": "https://github.com/rust-lang/rust/commit/40aa833fa3f31c0d9e657263f22d870566801e9a"}], "stats": {"total": 394, "additions": 296, "deletions": 98}, "files": [{"sha": "e930f353b52258b14a3c7b4ca5fa170644275f7c", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 296, "deletions": 98, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/2e9f705b930901a406eeba3cf2b01c015cb86b4d/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e9f705b930901a406eeba3cf2b01c015cb86b4d/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=2e9f705b930901a406eeba3cf2b01c015cb86b4d", "patch": "@@ -18,28 +18,28 @@ use intrinsics;\n use std::kinds::marker;\n use cell::UnsafeCell;\n \n-/// An atomic boolean type.\n+/// A boolean type which can be safely shared between threads.\n #[stable]\n pub struct AtomicBool {\n     v: UnsafeCell<uint>,\n     nocopy: marker::NoCopy\n }\n \n-/// A signed atomic integer type, supporting basic atomic arithmetic operations\n+/// A signed integer type which can be safely shared between threads.\n #[stable]\n pub struct AtomicInt {\n     v: UnsafeCell<int>,\n     nocopy: marker::NoCopy\n }\n \n-/// An unsigned atomic integer type, supporting basic atomic arithmetic operations\n+/// An unsigned integer type which can be safely shared between threads.\n #[stable]\n pub struct AtomicUint {\n     v: UnsafeCell<uint>,\n     nocopy: marker::NoCopy\n }\n \n-/// An unsafe atomic pointer. Only supports basic atomic operations\n+/// A raw pointer type which can be safely shared between threads.\n #[stable]\n pub struct AtomicPtr<T> {\n     p: UnsafeCell<uint>,\n@@ -54,43 +54,42 @@ pub struct AtomicPtr<T> {\n /// to be moved either before or after the atomic operation; on the other end\n /// \"relaxed\" atomics allow all reorderings.\n ///\n-/// Rust's memory orderings are the same as in C++[1].\n-///\n-/// 1: http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync\n+/// Rust's memory orderings are [the same as\n+/// C++'s](http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync).\n #[stable]\n pub enum Ordering {\n-    /// No ordering constraints, only atomic operations\n+    /// No ordering constraints, only atomic operations.\n     #[stable]\n     Relaxed,\n     /// When coupled with a store, all previous writes become visible\n     /// to another thread that performs a load with `Acquire` ordering\n-    /// on the same value\n+    /// on the same value.\n     #[stable]\n     Release,\n     /// When coupled with a load, all subsequent loads will see data\n     /// written before a store with `Release` ordering on the same value\n-    /// in another thread\n+    /// in another thread.\n     #[stable]\n     Acquire,\n     /// When coupled with a load, uses `Acquire` ordering, and with a store\n-    /// `Release` ordering\n+    /// `Release` ordering.\n     #[stable]\n     AcqRel,\n     /// Like `AcqRel` with the additional guarantee that all threads see all\n     /// sequentially consistent operations in the same order.\n     #[stable]\n-    SeqCst\n+    SeqCst,\n }\n \n-/// An `AtomicBool` initialized to `false`\n+/// An `AtomicBool` initialized to `false`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n pub const INIT_ATOMIC_BOOL: AtomicBool =\n         AtomicBool { v: UnsafeCell { value: 0 }, nocopy: marker::NoCopy };\n-/// An `AtomicInt` initialized to `0`\n+/// An `AtomicInt` initialized to `0`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n pub const INIT_ATOMIC_INT: AtomicInt =\n         AtomicInt { v: UnsafeCell { value: 0 }, nocopy: marker::NoCopy };\n-/// An `AtomicUint` initialized to `0`\n+/// An `AtomicUint` initialized to `0`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n pub const INIT_ATOMIC_UINT: AtomicUint =\n         AtomicUint { v: UnsafeCell { value: 0, }, nocopy: marker::NoCopy };\n@@ -99,26 +98,59 @@ pub const INIT_ATOMIC_UINT: AtomicUint =\n const UINT_TRUE: uint = -1;\n \n impl AtomicBool {\n-    /// Create a new `AtomicBool`\n+    /// Creates a new `AtomicBool`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::AtomicBool;\n+    ///\n+    /// let atomic_true  = AtomicBool::new(true);\n+    /// let atomic_false = AtomicBool::new(false);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn new(v: bool) -> AtomicBool {\n         let val = if v { UINT_TRUE } else { 0 };\n         AtomicBool { v: UnsafeCell::new(val), nocopy: marker::NoCopy }\n     }\n \n-    /// Load the value\n+    /// Loads a value from the bool.\n+    ///\n+    /// `load` takes an `Ordering` argument which describes the memory ordering of this operation.\n     ///\n     /// # Panics\n     ///\n     /// Panics if `order` is `Release` or `AcqRel`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n+    ///\n+    /// let some_bool = AtomicBool::new(true);\n+    ///\n+    /// let value = some_bool.load(Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn load(&self, order: Ordering) -> bool {\n         unsafe { atomic_load(self.v.get() as *const uint, order) > 0 }\n     }\n \n-    /// Store the value\n+    /// Stores a value into the bool.\n+    ///\n+    /// `store` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n+    ///\n+    /// let some_bool = AtomicBool::new(true);\n+    ///\n+    /// some_bool.store(false, Ordering::Relaxed);\n+    /// ```\n     ///\n     /// # Panics\n     ///\n@@ -131,7 +163,19 @@ impl AtomicBool {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n-    /// Store a value, returning the old value\n+    /// Stores a value into the bool, returning the old value.\n+    ///\n+    /// `swap` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n+    ///\n+    /// let some_bool = AtomicBool::new(true);\n+    ///\n+    /// let value = some_bool.swap(false, Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n@@ -140,48 +184,21 @@ impl AtomicBool {\n         unsafe { atomic_swap(self.v.get(), val, order) > 0 }\n     }\n \n-    /// If the current value is the same as expected, store a new value\n+    /// Stores a value into the bool if the current value is the same as the expected value.\n     ///\n-    /// Compare the current value with `old`; if they are the same then\n-    /// replace the current value with `new`. Return the previous value.\n     /// If the return value is equal to `old` then the value was updated.\n     ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// use std::sync::Arc;\n-    /// use std::sync::atomic::{AtomicBool, SeqCst};\n-    /// use std::task::deschedule;\n-    ///\n-    /// fn main() {\n-    ///     let spinlock = Arc::new(AtomicBool::new(false));\n-    ///     let spinlock_clone = spinlock.clone();\n+    /// `swap` also takes an `Ordering` argument which describes the memory ordering of this\n+    /// operation.\n     ///\n-    ///     spawn(proc() {\n-    ///         with_lock(&spinlock, || println!(\"task 1 in lock\"));\n-    ///     });\n-    ///\n-    ///     spawn(proc() {\n-    ///         with_lock(&spinlock_clone, || println!(\"task 2 in lock\"));\n-    ///     });\n-    /// }\n+    /// # Examples\n     ///\n-    /// fn with_lock(spinlock: &Arc<AtomicBool>, f: || -> ()) {\n-    ///     // CAS loop until we are able to replace `false` with `true`\n-    ///     while spinlock.compare_and_swap(false, true, SeqCst) != false {\n-    ///         // Since tasks may not be preemptive (if they are green threads)\n-    ///         // yield to the scheduler to let the other task run. Low level\n-    ///         // concurrent code needs to take into account Rust's two threading\n-    ///         // models.\n-    ///         deschedule();\n-    ///     }\n+    /// ```\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n     ///\n-    ///     // Now we have the spinlock\n-    ///     f();\n+    /// let some_bool = AtomicBool::new(true);\n     ///\n-    ///     // Release the lock\n-    ///     spinlock.store(false, SeqCst);\n-    /// }\n+    /// let value = some_bool.store(false, Ordering::Relaxed);\n     /// ```\n     #[inline]\n     #[stable]\n@@ -192,10 +209,11 @@ impl AtomicBool {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) > 0 }\n     }\n \n-    /// A logical \"and\" operation\n+    /// Logical \"and\" with a boolean value.\n+    ///\n+    /// Performs a logical \"and\" operation on the current value and the argument `val`, and sets\n+    /// the new value to the result.\n     ///\n-    /// Performs a logical \"and\" operation on the current value and the\n-    /// argument `val`, and sets the new value to the result.\n     /// Returns the previous value.\n     ///\n     /// # Examples\n@@ -223,10 +241,11 @@ impl AtomicBool {\n         unsafe { atomic_and(self.v.get(), val, order) > 0 }\n     }\n \n-    /// A logical \"nand\" operation\n+    /// Logical \"nand\" with a boolean value.\n+    ///\n+    /// Performs a logical \"nand\" operation on the current value and the argument `val`, and sets\n+    /// the new value to the result.\n     ///\n-    /// Performs a logical \"nand\" operation on the current value and the\n-    /// argument `val`, and sets the new value to the result.\n     /// Returns the previous value.\n     ///\n     /// # Examples\n@@ -255,10 +274,11 @@ impl AtomicBool {\n         unsafe { atomic_nand(self.v.get(), val, order) > 0 }\n     }\n \n-    /// A logical \"or\" operation\n+    /// Logical \"or\" with a boolean value.\n+    ///\n+    /// Performs a logical \"or\" operation on the current value and the argument `val`, and sets the\n+    /// new value to the result.\n     ///\n-    /// Performs a logical \"or\" operation on the current value and the\n-    /// argument `val`, and sets the new value to the result.\n     /// Returns the previous value.\n     ///\n     /// # Examples\n@@ -286,10 +306,11 @@ impl AtomicBool {\n         unsafe { atomic_or(self.v.get(), val, order) > 0 }\n     }\n \n-    /// A logical \"xor\" operation\n+    /// Logical \"xor\" with a boolean value.\n+    ///\n+    /// Performs a logical \"xor\" operation on the current value and the argument `val`, and sets\n+    /// the new value to the result.\n     ///\n-    /// Performs a logical \"xor\" operation on the current value and the\n-    /// argument `val`, and sets the new value to the result.\n     /// Returns the previous value.\n     ///\n     /// # Examples\n@@ -319,25 +340,57 @@ impl AtomicBool {\n }\n \n impl AtomicInt {\n-    /// Create a new `AtomicInt`\n+    /// Creates a new `AtomicInt`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::AtomicInt;\n+    ///\n+    /// let atomic_forty_two  = AtomicInt::new(42);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn new(v: int) -> AtomicInt {\n         AtomicInt {v: UnsafeCell::new(v), nocopy: marker::NoCopy}\n     }\n \n-    /// Load the value\n+    /// Loads a value from the int.\n+    ///\n+    /// `load` takes an `Ordering` argument which describes the memory ordering of this operation.\n     ///\n     /// # Panics\n     ///\n     /// Panics if `order` is `Release` or `AcqRel`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicInt, Ordering};\n+    ///\n+    /// let some_int = AtomicInt::new(5);\n+    ///\n+    /// let value = some_int.load(Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn load(&self, order: Ordering) -> int {\n         unsafe { atomic_load(self.v.get() as *const int, order) }\n     }\n \n-    /// Store the value\n+    /// Stores a value into the int.\n+    ///\n+    /// `store` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicInt, Ordering};\n+    ///\n+    /// let some_int = AtomicInt::new(5);\n+    ///\n+    /// some_int.store(10, Ordering::Relaxed);\n+    /// ```\n     ///\n     /// # Panics\n     ///\n@@ -348,25 +401,48 @@ impl AtomicInt {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n-    /// Store a value, returning the old value\n+    /// Stores a value into the int, returning the old value.\n+    ///\n+    /// `swap` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicInt, Ordering};\n+    ///\n+    /// let some_int = AtomicInt::new(5);\n+    ///\n+    /// let value = some_int.swap(10, Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn swap(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n \n-    /// If the current value is the same as expected, store a new value\n+    /// Stores a value into the int if the current value is the same as the expected value.\n     ///\n-    /// Compare the current value with `old`; if they are the same then\n-    /// replace the current value with `new`. Return the previous value.\n     /// If the return value is equal to `old` then the value was updated.\n+    ///\n+    /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n+    /// this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicInt, Ordering};\n+    ///\n+    /// let some_int = AtomicInt::new(5);\n+    ///\n+    /// let value = some_int.compare_and_swap(5, 10, Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn compare_and_swap(&self, old: int, new: int, order: Ordering) -> int {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n \n-    /// Add to the current value, returning the previous\n+    /// Add an int to the current value, returning the previous value.\n     ///\n     /// # Examples\n     ///\n@@ -383,7 +459,7 @@ impl AtomicInt {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n \n-    /// Subtract from the current value, returning the previous\n+    /// Subtract an int from the current value, returning the previous value.\n     ///\n     /// # Examples\n     ///\n@@ -400,7 +476,7 @@ impl AtomicInt {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n \n-    /// Bitwise and with the current value, returning the previous\n+    /// Bitwise and with the current int, returning the previous value.\n     ///\n     /// # Examples\n     ///\n@@ -416,7 +492,7 @@ impl AtomicInt {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n \n-    /// Bitwise or with the current value, returning the previous\n+    /// Bitwise or with the current int, returning the previous value.\n     ///\n     /// # Examples\n     ///\n@@ -432,7 +508,7 @@ impl AtomicInt {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n \n-    /// Bitwise xor with the current value, returning the previous\n+    /// Bitwise xor with the current int, returning the previous value.\n     ///\n     /// # Examples\n     ///\n@@ -450,25 +526,57 @@ impl AtomicInt {\n }\n \n impl AtomicUint {\n-    /// Create a new `AtomicUint`\n+    /// Creates a new `AtomicUint`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::AtomicUint;\n+    ///\n+    /// let atomic_forty_two = AtomicUint::new(42u);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn new(v: uint) -> AtomicUint {\n         AtomicUint { v: UnsafeCell::new(v), nocopy: marker::NoCopy }\n     }\n \n-    /// Load the value\n+    /// Loads a value from the uint.\n+    ///\n+    /// `load` takes an `Ordering` argument which describes the memory ordering of this operation.\n     ///\n     /// # Panics\n     ///\n     /// Panics if `order` is `Release` or `AcqRel`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicUint, Ordering};\n+    ///\n+    /// let some_uint = AtomicUint::new(5);\n+    ///\n+    /// let value = some_uint.load(Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn load(&self, order: Ordering) -> uint {\n         unsafe { atomic_load(self.v.get() as *const uint, order) }\n     }\n \n-    /// Store the value\n+    /// Stores a value into the uint.\n+    ///\n+    /// `store` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicUint, Ordering};\n+    ///\n+    /// let some_uint = AtomicUint::new(5);\n+    ///\n+    /// some_uint.store(10, Ordering::Relaxed);\n+    /// ```\n     ///\n     /// # Panics\n     ///\n@@ -479,25 +587,48 @@ impl AtomicUint {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n-    /// Store a value, returning the old value\n+    /// Stores a value into the uint, returning the old value.\n+    ///\n+    /// `swap` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicUint, Ordering};\n+    ///\n+    /// let some_uint = AtomicUint::new(5);\n+    ///\n+    /// let value = some_uint.swap(10, Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn swap(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n \n-    /// If the current value is the same as expected, store a new value\n+    /// Stores a value into the uint if the current value is the same as the expected value.\n     ///\n-    /// Compare the current value with `old`; if they are the same then\n-    /// replace the current value with `new`. Return the previous value.\n     /// If the return value is equal to `old` then the value was updated.\n+    ///\n+    /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n+    /// this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicUint, Ordering};\n+    ///\n+    /// let some_uint = AtomicUint::new(5);\n+    ///\n+    /// let value = some_uint.compare_and_swap(5, 10, Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn compare_and_swap(&self, old: uint, new: uint, order: Ordering) -> uint {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n \n-    /// Add to the current value, returning the previous\n+    /// Add to the current uint, returning the previous value.\n     ///\n     /// # Examples\n     ///\n@@ -514,7 +645,7 @@ impl AtomicUint {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n \n-    /// Subtract from the current value, returning the previous\n+    /// Subtract from the current uint, returning the previous value.\n     ///\n     /// # Examples\n     ///\n@@ -531,7 +662,7 @@ impl AtomicUint {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n \n-    /// Bitwise and with the current value, returning the previous\n+    /// Bitwise and with the current uint, returning the previous value.\n     ///\n     /// # Examples\n     ///\n@@ -547,7 +678,7 @@ impl AtomicUint {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n \n-    /// Bitwise or with the current value, returning the previous\n+    /// Bitwise or with the current uint, returning the previous value.\n     ///\n     /// # Examples\n     ///\n@@ -563,7 +694,7 @@ impl AtomicUint {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n \n-    /// Bitwise xor with the current value, returning the previous\n+    /// Bitwise xor with the current uint, returning the previous value.\n     ///\n     /// # Examples\n     ///\n@@ -581,18 +712,40 @@ impl AtomicUint {\n }\n \n impl<T> AtomicPtr<T> {\n-    /// Create a new `AtomicPtr`\n+    /// Creates a new `AtomicPtr`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::AtomicPtr;\n+    ///\n+    /// let ptr = &mut 5i;\n+    /// let atomic_ptr  = AtomicPtr::new(ptr);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn new(p: *mut T) -> AtomicPtr<T> {\n         AtomicPtr { p: UnsafeCell::new(p as uint), nocopy: marker::NoCopy }\n     }\n \n-    /// Load the value\n+    /// Loads a value from the pointer.\n+    ///\n+    /// `load` takes an `Ordering` argument which describes the memory ordering of this operation.\n     ///\n     /// # Panics\n     ///\n     /// Panics if `order` is `Release` or `AcqRel`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let ptr = &mut 5i;\n+    /// let some_ptr  = AtomicPtr::new(ptr);\n+    ///\n+    /// let value = some_ptr.load(Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn load(&self, order: Ordering) -> *mut T {\n@@ -601,7 +754,22 @@ impl<T> AtomicPtr<T> {\n         }\n     }\n \n-    /// Store the value\n+    /// Stores a value into the pointer.\n+    ///\n+    /// `store` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let ptr = &mut 5i;\n+    /// let some_ptr  = AtomicPtr::new(ptr);\n+    ///\n+    /// let other_ptr = &mut 10i;\n+    ///\n+    /// some_ptr.store(other_ptr, Ordering::Relaxed);\n+    /// ```\n     ///\n     /// # Panics\n     ///\n@@ -612,18 +780,48 @@ impl<T> AtomicPtr<T> {\n         unsafe { atomic_store(self.p.get(), ptr as uint, order); }\n     }\n \n-    /// Store a value, returning the old value\n+    /// Stores a value into the pointer, returning the old value.\n+    ///\n+    /// `swap` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let ptr = &mut 5i;\n+    /// let some_ptr  = AtomicPtr::new(ptr);\n+    ///\n+    /// let other_ptr = &mut 10i;\n+    ///\n+    /// let value = some_ptr.swap(other_ptr, Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_swap(self.p.get(), ptr as uint, order) as *mut T }\n     }\n \n-    /// If the current value is the same as expected, store a new value\n+    /// Stores a value into the pointer if the current value is the same as the expected value.\n     ///\n-    /// Compare the current value with `old`; if they are the same then\n-    /// replace the current value with `new`. Return the previous value.\n     /// If the return value is equal to `old` then the value was updated.\n+    ///\n+    /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n+    /// this operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let ptr = &mut 5i;\n+    /// let some_ptr  = AtomicPtr::new(ptr);\n+    ///\n+    /// let other_ptr   = &mut 10i;\n+    /// let another_ptr = &mut 10i;\n+    ///\n+    /// let value = some_ptr.compare_and_swap(other_ptr, another_ptr, Ordering::Relaxed);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n@@ -777,7 +975,7 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n ///\n /// # Panics\n ///\n-/// Panics if `order` is `Relaxed`\n+/// Panics if `order` is `Relaxed`.\n #[inline]\n #[stable]\n pub fn fence(order: Ordering) {"}]}