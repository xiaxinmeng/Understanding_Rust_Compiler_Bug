{"sha": "ad43613346a5702b84e3a32b39395258e32b1037", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkNDM2MTMzNDZhNTcwMmI4NGUzYTMyYjM5Mzk1MjU4ZTMyYjEwMzc=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-09-10T18:41:05Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-09-10T23:42:41Z"}, "message": "rustpkg: Pass command-line arguments to rustc\n\nrustpkg now accepts most of rustc's command-line arguments and passes\nthem along to rustc when building or installing.\n\nA few rarely-used arguments aren't implemented yet.\n\nrustpkg doesn't support flags that don't make sense with rustpkg\n(for example, --bin and --lib, which get inferred from crate file names).\n\nCloses #8522", "tree": {"sha": "6eafa1b1967045284a5cf7c952bfa64c91d1e343", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6eafa1b1967045284a5cf7c952bfa64c91d1e343"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad43613346a5702b84e3a32b39395258e32b1037", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad43613346a5702b84e3a32b39395258e32b1037", "html_url": "https://github.com/rust-lang/rust/commit/ad43613346a5702b84e3a32b39395258e32b1037", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad43613346a5702b84e3a32b39395258e32b1037/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9ac27270f9ce20aaf6424f6de5128351c70659e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9ac27270f9ce20aaf6424f6de5128351c70659e", "html_url": "https://github.com/rust-lang/rust/commit/a9ac27270f9ce20aaf6424f6de5128351c70659e"}], "stats": {"total": 769, "additions": 704, "deletions": 65}, "files": [{"sha": "727bbcb30b4c51f6bf5a07430df1d5db126b311a", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad43613346a5702b84e3a32b39395258e32b1037/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad43613346a5702b84e3a32b39395258e32b1037/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=ad43613346a5702b84e3a32b39395258e32b1037", "patch": "@@ -29,6 +29,8 @@ pub fn default_context(p: Path) -> BuildContext {\n pub fn new_default_context(c: workcache::Context, p: Path) -> BuildContext {\n     BuildContext {\n         context: Context {\n+            cfgs: ~[],\n+            rustc_flags: RustcFlags::default(),\n             use_rust_path_hack: false,\n             sysroot: p\n         },\n@@ -44,7 +46,6 @@ fn binary_is_fresh(path: &str, in_hash: &str) -> bool {\n     in_hash == digest_only_date(&Path(path))\n }\n \n-\n pub fn new_workcache_context(p: &Path) -> workcache::Context {\n     let db_file = p.push(\"rustpkg_db.json\"); // ??? probably wrong\n     debug!(\"Workcache database file: %s\", db_file.to_str());"}, {"sha": "1b1f3f14214fdc69567c114cd8d56873176d3eb1", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 222, "deletions": 3, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/ad43613346a5702b84e3a32b39395258e32b1037/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad43613346a5702b84e3a32b39395258e32b1037/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=ad43613346a5702b84e3a32b39395258e32b1037", "patch": "@@ -10,11 +10,16 @@\n \n // Context data structure used by rustpkg\n \n-use std::os;\n+use std::{io, os};\n use extra::workcache;\n+use rustc::driver::session::{OptLevel, No};\n \n #[deriving(Clone)]\n pub struct Context {\n+    // Config strings that the user passed in with --cfg\n+    cfgs: ~[~str],\n+    // Flags to pass to rustc\n+    rustc_flags: RustcFlags,\n     // If use_rust_path_hack is true, rustpkg searches for sources\n     // in *package* directories that are in the RUST_PATH (for example,\n     // FOO/src/bar-0.1 instead of FOO). The flag doesn't affect where\n@@ -40,15 +45,82 @@ impl BuildContext {\n     pub fn sysroot_to_use(&self) -> Path {\n         self.context.sysroot_to_use()\n     }\n+\n+    /// Returns the flags to pass to rustc, as a vector of strings\n+    pub fn flag_strs(&self) -> ~[~str] {\n+        self.context.flag_strs()\n+    }\n+\n+    pub fn compile_upto(&self) -> StopBefore {\n+        self.context.compile_upto()\n+    }\n+}\n+\n+/*\n+Deliberately unsupported rustc flags:\n+   --bin, --lib           inferred from crate file names\n+   -L                     inferred from extern mods\n+   --out-dir              inferred from RUST_PATH\n+   --test                 use `rustpkg test`\n+   -v -h --ls             don't make sense with rustpkg\n+   -W -A -D -F -          use pragmas instead\n+\n+rustc flags that aren't implemented yet:\n+   --passes\n+   --llvm-arg\n+   --target-feature\n+   --android-cross-path\n+*/\n+pub struct RustcFlags {\n+    compile_upto: StopBefore,\n+    // Linker to use with the --linker flag\n+    linker: Option<~str>,\n+    // Extra arguments to pass to rustc with the --link-args flag\n+    link_args: Option<~str>,\n+    // Optimization level. 0 = default. -O = 2.\n+    optimization_level: OptLevel,\n+    // True if the user passed in --save-temps\n+    save_temps: bool,\n+    // Target (defaults to rustc's default target)\n+    target: Option<~str>,\n+    // Target CPU (defaults to rustc's default target CPU)\n+    target_cpu: Option<~str>,\n+    // Any -Z features\n+    experimental_features: Option<~[~str]>\n+}\n+\n+impl Clone for RustcFlags {\n+    fn clone(&self) -> RustcFlags {\n+        RustcFlags {\n+            compile_upto: self.compile_upto,\n+            linker: self.linker.clone(),\n+            link_args: self.link_args.clone(),\n+            optimization_level: self.optimization_level,\n+            save_temps: self.save_temps,\n+            target: self.target.clone(),\n+            target_cpu: self.target_cpu.clone(),\n+            experimental_features: self.experimental_features.clone()\n+        }\n+    }\n+}\n+\n+#[deriving(Eq)]\n+pub enum StopBefore {\n+    Nothing,  // compile everything\n+    Link,     // --no-link\n+    LLVMCompileBitcode, // --emit-llvm without -S\n+    LLVMAssemble, // -S --emit-llvm\n+    Assemble, // -S without --emit-llvm\n+    Trans,    // --no-trans\n+    Pretty,   // --pretty\n+    Analysis, // --parse-only\n }\n \n impl Context {\n     pub fn sysroot(&self) -> Path {\n         self.sysroot.clone()\n     }\n-}\n \n-impl Context {\n     /// Debugging\n     pub fn sysroot_str(&self) -> ~str {\n         self.sysroot.to_str()\n@@ -63,6 +135,15 @@ impl Context {\n             self.sysroot.pop().pop().pop()\n         }\n     }\n+\n+    /// Returns the flags to pass to rustc, as a vector of strings\n+    pub fn flag_strs(&self) -> ~[~str] {\n+        self.rustc_flags.flag_strs()\n+    }\n+\n+    pub fn compile_upto(&self) -> StopBefore {\n+        self.rustc_flags.compile_upto\n+    }\n }\n \n /// We assume that if ../../rustc exists, then we're running\n@@ -72,3 +153,141 @@ pub fn in_target(sysroot: &Path) -> bool {\n     debug!(\"Checking whether %s is in target\", sysroot.to_str());\n     os::path_is_dir(&sysroot.pop().pop().push(\"rustc\"))\n }\n+\n+impl RustcFlags {\n+    fn flag_strs(&self) -> ~[~str] {\n+        let linker_flag = match self.linker {\n+            Some(ref l) => ~[~\"--linker\", l.clone()],\n+            None    => ~[]\n+        };\n+        let link_args_flag = match self.link_args {\n+            Some(ref l) => ~[~\"--link-args\", l.clone()],\n+            None        => ~[]\n+        };\n+        let save_temps_flag = if self.save_temps { ~[~\"--save-temps\"] } else { ~[] };\n+        let target_flag = match self.target {\n+            Some(ref l) => ~[~\"--target\", l.clone()],\n+            None        => ~[]\n+        };\n+        let target_cpu_flag = match self.target_cpu {\n+            Some(ref l) => ~[~\"--target-cpu\", l.clone()],\n+            None        => ~[]\n+        };\n+        let z_flags = match self.experimental_features {\n+            Some(ref ls)    => ls.flat_map(|s| ~[~\"-Z\", s.clone()]),\n+            None            => ~[]\n+        };\n+        linker_flag\n+            + link_args_flag\n+            + save_temps_flag\n+            + target_flag\n+            + target_cpu_flag\n+            + z_flags + (match self.compile_upto {\n+            LLVMCompileBitcode => ~[~\"--emit-llvm\"],\n+            LLVMAssemble => ~[~\"--emit-llvm\", ~\"-S\"],\n+            Link => ~[~\"-c\"],\n+            Trans => ~[~\"--no-trans\"],\n+            Assemble => ~[~\"-S\"],\n+            // n.b. Doesn't support all flavors of --pretty (yet)\n+            Pretty => ~[~\"--pretty\"],\n+            Analysis => ~[~\"--parse-only\"],\n+            Nothing => ~[]\n+        })\n+    }\n+\n+    pub fn default() -> RustcFlags {\n+        RustcFlags {\n+            linker: None,\n+            link_args: None,\n+            compile_upto: Nothing,\n+            optimization_level: No,\n+            save_temps: false,\n+            target: None,\n+            target_cpu: None,\n+            experimental_features: None\n+        }\n+    }\n+}\n+\n+/// Returns true if any of the flags given are incompatible with the cmd\n+pub fn flags_ok_for_cmd(flags: &RustcFlags,\n+                        cfgs: &[~str],\n+                        cmd: &str, user_supplied_opt_level: bool) -> bool {\n+    let complain = |s| {\n+        io::println(fmt!(\"The %s option can only be used with the build command:\n+                         rustpkg [options..] build %s [package-ID]\", s, s));\n+    };\n+\n+    if flags.linker.is_some() && cmd != \"build\" && cmd != \"install\" {\n+        io::println(\"The --linker option can only be used with the build or install commands.\");\n+        return true;\n+    }\n+    if flags.link_args.is_some() && cmd != \"build\" && cmd != \"install\" {\n+        io::println(\"The --link-args option can only be used with the build or install commands.\");\n+        return true;\n+    }\n+\n+    if !cfgs.is_empty() && cmd != \"build\" && cmd != \"install\" {\n+        io::println(\"The --cfg option can only be used with the build or install commands.\");\n+        return true;\n+    }\n+\n+    if user_supplied_opt_level && cmd != \"build\" && cmd != \"install\" {\n+        io::println(\"The -O and --opt-level options can only be used with the build \\\n+                    or install commands.\");\n+        return true;\n+    }\n+\n+    if flags.save_temps  && cmd != \"build\" && cmd != \"install\" {\n+        io::println(\"The --save-temps option can only be used with the build \\\n+                    or install commands.\");\n+        return true;\n+    }\n+\n+    if flags.target.is_some()  && cmd != \"build\" && cmd != \"install\" {\n+        io::println(\"The --target option can only be used with the build \\\n+                    or install commands.\");\n+        return true;\n+    }\n+    if flags.target_cpu.is_some()  && cmd != \"build\" && cmd != \"install\" {\n+        io::println(\"The --target-cpu option can only be used with the build \\\n+                    or install commands.\");\n+        return true;\n+    }\n+    if flags.experimental_features.is_some() && cmd != \"build\" && cmd != \"install\" {\n+        io::println(\"The -Z option can only be used with the build or install commands.\");\n+        return true;\n+    }\n+\n+    match flags.compile_upto {\n+        Link if cmd != \"build\" => {\n+            complain(\"--no-link\");\n+            true\n+        }\n+        Trans if cmd != \"build\" => {\n+            complain(\"--no-trans\");\n+            true\n+        }\n+        Assemble if cmd != \"build\" => {\n+            complain(\"-S\");\n+            true\n+        }\n+        Pretty if cmd != \"build\" => {\n+            complain(\"--pretty\");\n+            true\n+        }\n+        Analysis if cmd != \"build\" => {\n+            complain(\"--parse-only\");\n+            true\n+        }\n+        LLVMCompileBitcode if cmd != \"build\" => {\n+            complain(\"--emit-llvm\");\n+            true\n+        }\n+        LLVMAssemble if cmd != \"build\" => {\n+            complain(\"--emit-llvm\");\n+            true\n+        }\n+        _ => false\n+    }\n+}"}, {"sha": "03eb4e938424ee3c10bbef3421b1f0549ca3bffa", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 117, "deletions": 26, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/ad43613346a5702b84e3a32b39395258e32b1037/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad43613346a5702b84e3a32b39395258e32b1037/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=ad43613346a5702b84e3a32b39395258e32b1037", "patch": "@@ -40,7 +40,9 @@ use path_util::{built_executable_in_workspace, built_library_in_workspace, defau\n use path_util::{target_executable_in_workspace, target_library_in_workspace};\n use source_control::is_git_dir;\n use workspace::{each_pkg_parent_workspace, pkg_parent_workspaces, cwd_to_workspace};\n-use context::{BuildContext, Context};\n+use context::{Context, BuildContext,\n+                       RustcFlags, Trans, Link, Nothing, Pretty, Analysis, Assemble,\n+                       LLVMAssemble, LLVMCompileBitcode};\n use package_id::PkgId;\n use package_source::PkgSrc;\n use workcache_support::{discover_outputs, digest_only_date};\n@@ -138,6 +140,7 @@ impl<'self> PkgScript<'self> {\n         let exe = self.build_dir.push(~\"pkg\" + util::exe_suffix());\n         util::compile_crate_from_input(&self.input,\n                                        exec,\n+                                       Nothing,\n                                        &self.build_dir,\n                                        sess,\n                                        crate);\n@@ -400,7 +403,7 @@ impl CtxMethods for BuildContext {\n                 debug!(\"No package script, continuing\");\n                 ~[]\n             }\n-        };\n+        } + self.context.cfgs;\n \n         // If there was a package script, it should have finished\n         // the build already. Otherwise...\n@@ -539,9 +542,25 @@ pub fn main() {\n \n pub fn main_args(args: &[~str]) {\n     let opts = ~[getopts::optflag(\"h\"), getopts::optflag(\"help\"),\n+                                        getopts::optflag(\"no-link\"),\n+                                        getopts::optflag(\"no-trans\"),\n+                 // n.b. Ignores different --pretty options for now\n+                                        getopts::optflag(\"pretty\"),\n+                                        getopts::optflag(\"parse-only\"),\n+                 getopts::optflag(\"S\"), getopts::optflag(\"assembly\"),\n                  getopts::optmulti(\"c\"), getopts::optmulti(\"cfg\"),\n                  getopts::optflag(\"v\"), getopts::optflag(\"version\"),\n-                 getopts::optflag(\"r\"), getopts::optflag(\"rust-path-hack\")];\n+                 getopts::optflag(\"r\"), getopts::optflag(\"rust-path-hack\"),\n+                                        getopts::optopt(\"sysroot\"),\n+                                        getopts::optflag(\"emit-llvm\"),\n+                                        getopts::optopt(\"linker\"),\n+                                        getopts::optopt(\"link-args\"),\n+                                        getopts::optopt(\"opt-level\"),\n+                 getopts::optflag(\"O\"),\n+                                        getopts::optflag(\"save-temps\"),\n+                                        getopts::optopt(\"target\"),\n+                                        getopts::optopt(\"target-cpu\"),\n+                 getopts::optmulti(\"Z\")                                   ];\n     let matches = &match getopts::getopts(args, opts) {\n         result::Ok(m) => m,\n         result::Err(f) => {\n@@ -550,8 +569,16 @@ pub fn main_args(args: &[~str]) {\n             return;\n         }\n     };\n-    let help = getopts::opt_present(matches, \"h\") ||\n-               getopts::opt_present(matches, \"help\");\n+    let mut help = getopts::opt_present(matches, \"h\") ||\n+                   getopts::opt_present(matches, \"help\");\n+    let no_link = getopts::opt_present(matches, \"no-link\");\n+    let no_trans = getopts::opt_present(matches, \"no-trans\");\n+    let supplied_sysroot = getopts::opt_val(matches, \"sysroot\");\n+    let generate_asm = getopts::opt_present(matches, \"S\") ||\n+        getopts::opt_present(matches, \"assembly\");\n+    let parse_only = getopts::opt_present(matches, \"parse-only\");\n+    let pretty = getopts::opt_present(matches, \"pretty\");\n+    let emit_llvm = getopts::opt_present(matches, \"emit-llvm\");\n \n     if getopts::opt_present(matches, \"v\") ||\n        getopts::opt_present(matches, \"version\") {\n@@ -562,13 +589,69 @@ pub fn main_args(args: &[~str]) {\n     let use_rust_path_hack = getopts::opt_present(matches, \"r\") ||\n                              getopts::opt_present(matches, \"rust-path-hack\");\n \n+    let linker = getopts::opt_maybe_str(matches, \"linker\");\n+    let link_args = getopts::opt_maybe_str(matches, \"link-args\");\n+    let cfgs = getopts::opt_strs(matches, \"cfg\") + getopts::opt_strs(matches, \"c\");\n+    let mut user_supplied_opt_level = true;\n+    let opt_level = match getopts::opt_maybe_str(matches, \"opt-level\") {\n+        Some(~\"0\") => session::No,\n+        Some(~\"1\") => session::Less,\n+        Some(~\"2\") => session::Default,\n+        Some(~\"3\") => session::Aggressive,\n+        _ if getopts::opt_present(matches, \"O\") => session::Default,\n+        _ => {\n+            user_supplied_opt_level = false;\n+            session::No\n+        }\n+    };\n+\n+    let save_temps = getopts::opt_present(matches, \"save-temps\");\n+    let target     = getopts::opt_maybe_str(matches, \"target\");\n+    let target_cpu = getopts::opt_maybe_str(matches, \"target-cpu\");\n+    let experimental_features = {\n+        let strs = getopts::opt_strs(matches, \"Z\");\n+        if getopts::opt_present(matches, \"Z\") {\n+            Some(strs)\n+        }\n+        else {\n+            None\n+        }\n+    };\n+\n     let mut args = matches.free.clone();\n     args.shift();\n \n     if (args.len() < 1) {\n         return usage::general();\n     }\n \n+    let rustc_flags = RustcFlags {\n+        linker: linker,\n+        link_args: link_args,\n+        optimization_level: opt_level,\n+        compile_upto: if no_trans {\n+            Trans\n+        } else if no_link {\n+            Link\n+        } else if pretty {\n+            Pretty\n+        } else if parse_only {\n+            Analysis\n+        } else if emit_llvm && generate_asm {\n+            LLVMAssemble\n+        } else if generate_asm {\n+            Assemble\n+        } else if emit_llvm {\n+            LLVMCompileBitcode\n+        } else {\n+            Nothing\n+        },\n+        save_temps: save_temps,\n+        target: target,\n+        target_cpu: target_cpu,\n+        experimental_features: experimental_features\n+    };\n+\n     let mut cmd_opt = None;\n     for a in args.iter() {\n         if util::is_cmd(*a) {\n@@ -578,23 +661,25 @@ pub fn main_args(args: &[~str]) {\n     }\n     let cmd = match cmd_opt {\n         None => return usage::general(),\n-        Some(cmd) => if help {\n-            return match *cmd {\n-                ~\"build\" => usage::build(),\n-                ~\"clean\" => usage::clean(),\n-                ~\"do\" => usage::do_cmd(),\n-                ~\"info\" => usage::info(),\n-                ~\"install\" => usage::install(),\n-                ~\"list\"    => usage::list(),\n-                ~\"prefer\" => usage::prefer(),\n-                ~\"test\" => usage::test(),\n-                ~\"uninstall\" => usage::uninstall(),\n-                ~\"unprefer\" => usage::unprefer(),\n-                _ => usage::general()\n-            };\n-        }\n-        else {\n-            cmd\n+        Some(cmd) => {\n+            help |= context::flags_ok_for_cmd(&rustc_flags, cfgs, *cmd, user_supplied_opt_level);\n+            if help {\n+                return match *cmd {\n+                    ~\"build\" => usage::build(),\n+                    ~\"clean\" => usage::clean(),\n+                    ~\"do\" => usage::do_cmd(),\n+                    ~\"info\" => usage::info(),\n+                    ~\"install\" => usage::install(),\n+                    ~\"list\"    => usage::list(),\n+                    ~\"prefer\" => usage::prefer(),\n+                    ~\"test\" => usage::test(),\n+                    ~\"uninstall\" => usage::uninstall(),\n+                    ~\"unprefer\" => usage::unprefer(),\n+                    _ => usage::general()\n+                };\n+            } else {\n+                cmd\n+            }\n         }\n     };\n \n@@ -603,14 +688,20 @@ pub fn main_args(args: &[~str]) {\n     // I had to add this type annotation to get the code to typecheck\n     let mut remaining_args: ~[~str] = remaining_args.map(|s| (*s).clone()).collect();\n     remaining_args.shift();\n-    let sroot = filesearch::get_or_default_sysroot();\n+    let sroot = match supplied_sysroot {\n+        Some(getopts::Val(s)) => Path(s),\n+        _ => filesearch::get_or_default_sysroot()\n+    };\n+\n     debug!(\"Using sysroot: %s\", sroot.to_str());\n     debug!(\"Will store workcache in %s\", default_workspace().to_str());\n     BuildContext {\n         context: Context {\n-            use_rust_path_hack: use_rust_path_hack,\n-            sysroot: sroot, // Currently, only tests override this\n-         },\n+        cfgs: cfgs,\n+        rustc_flags: rustc_flags,\n+        use_rust_path_hack: use_rust_path_hack,\n+        sysroot: sroot, // Currently, only tests override this\n+    },\n         workcache_context: api::default_context(default_workspace()).workcache_context\n     }.run(*cmd, remaining_args)\n }"}, {"sha": "21a45dd8ef6d211d1148d6b48d1435b17a438e85", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 291, "deletions": 6, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/ad43613346a5702b84e3a32b39395258e32b1037/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad43613346a5702b84e3a32b39395258e32b1037/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=ad43613346a5702b84e3a32b39395258e32b1037", "patch": "@@ -10,14 +10,15 @@\n \n // rustpkg unit tests\n \n-use context::{BuildContext, Context};\n+use context::{BuildContext, Context, RustcFlags};\n use std::{io, libc, os, run, str, task};\n use extra::arc::Arc;\n use extra::arc::RWArc;\n use extra::tempfile::mkdtemp;\n use extra::workcache;\n use extra::workcache::{Database, Logger};\n use extra::treemap::TreeMap;\n+use extra::getopts::groups::getopts;\n use std::run::ProcessOutput;\n use installed_packages::list_installed_packages;\n use package_id::{PkgId};\n@@ -27,8 +28,10 @@ use path_util::{target_executable_in_workspace, target_test_in_workspace,\n                library_in_workspace, installed_library_in_workspace,\n                built_bench_in_workspace, built_test_in_workspace,\n                built_library_in_workspace, built_executable_in_workspace};\n+use rustc::back::link::get_cc_prog;\n use rustc::metadata::filesearch::rust_path;\n-use rustc::driver::driver::host_triple;\n+use rustc::driver::driver::{build_session, build_session_options, host_triple, optgroups};\n+use syntax::diagnostic;\n use target::*;\n use package_source::PkgSrc;\n \n@@ -45,6 +48,9 @@ fn fake_ctxt(sysroot: Path, workspace: &Path) -> BuildContext {\n     BuildContext {\n         workcache_context: context,\n         context: Context {\n+            cfgs: ~[],\n+            rustc_flags: RustcFlags::default(),\n+\n             use_rust_path_hack: false,\n             sysroot: sysroot\n         }\n@@ -218,14 +224,18 @@ fn rustpkg_exec() -> Path {\n }\n \n fn command_line_test(args: &[~str], cwd: &Path) -> ProcessOutput {\n+    command_line_test_with_env(args, cwd, None).expect(\"Command line test failed\")\n+}\n+\n+fn command_line_test_partial(args: &[~str], cwd: &Path) -> Option<ProcessOutput> {\n     command_line_test_with_env(args, cwd, None)\n }\n \n /// Runs `rustpkg` (based on the directory that this executable was\n /// invoked from) with the given arguments, in the given working directory.\n /// Returns the process's output.\n fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~str)]>)\n-    -> ProcessOutput {\n+    -> Option<ProcessOutput> {\n     let cmd = rustpkg_exec().to_str();\n     debug!(\"cd %s; %s %s\",\n            cwd.to_str(), cmd, args.connect(\" \"));\n@@ -250,11 +260,14 @@ So tests that use this need to check the existence of a file\n to make sure the command succeeded\n */\n     if output.status != 0 {\n-        fail!(\"Command %s %? failed with exit code %?; its output was {{{ %s }}}\",\n+        debug!(\"Command %s %? failed with exit code %?; its output was {{{ %s }}}\",\n               cmd, args, output.status,\n               str::from_utf8(output.output) + str::from_utf8(output.error));\n+        None\n+    }\n+    else {\n+        Some(output)\n     }\n-    output\n }\n \n fn create_local_package(pkgid: &PkgId) -> Path {\n@@ -352,6 +365,27 @@ fn built_executable_exists(repo: &Path, short_name: &str) -> bool {\n     }\n }\n \n+fn object_file_exists(repo: &Path, short_name: &str) -> bool {\n+    file_exists(repo, short_name, \"o\")\n+}\n+\n+fn assembly_file_exists(repo: &Path, short_name: &str) -> bool {\n+    file_exists(repo, short_name, \"s\")\n+}\n+\n+fn llvm_assembly_file_exists(repo: &Path, short_name: &str) -> bool {\n+    file_exists(repo, short_name, \"ll\")\n+}\n+\n+fn llvm_bitcode_file_exists(repo: &Path, short_name: &str) -> bool {\n+    file_exists(repo, short_name, \"bc\")\n+}\n+\n+fn file_exists(repo: &Path, short_name: &str, extension: &str) -> bool {\n+    os::path_exists(&repo.push_many([~\"build\", short_name.to_owned(),\n+                                     fmt!(\"%s.%s\", short_name, extension)]))\n+}\n+\n fn assert_built_library_exists(repo: &Path, short_name: &str) {\n     assert!(built_library_exists(repo, short_name));\n }\n@@ -377,7 +411,8 @@ fn command_line_test_output(args: &[~str]) -> ~[~str] {\n \n fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~str] {\n     let mut result = ~[];\n-    let p_output = command_line_test_with_env(args, &os::getcwd(), Some(env));\n+    let p_output = command_line_test_with_env(args,\n+        &os::getcwd(), Some(env)).expect(\"Command-line test failed\");\n     let test_output = str::from_utf8(p_output.output);\n     for s in test_output.split_iter('\\n') {\n         result.push(s.to_owned());\n@@ -1264,6 +1299,256 @@ fn rust_path_install_target() {\n \n }\n \n+#[test]\n+fn sysroot_flag() {\n+    let p_id = PkgId::new(\"foo\");\n+    let workspace = create_local_package(&p_id);\n+    // no-op sysroot setting; I'm not sure how else to test this\n+    command_line_test([~\"--sysroot\",\n+                       test_sysroot().to_str(),\n+                       ~\"build\",\n+                       ~\"foo\"],\n+                      &workspace);\n+    assert_built_executable_exists(&workspace, \"foo\");\n+}\n+\n+#[test]\n+fn compile_flag_build() {\n+    let p_id = PkgId::new(\"foo\");\n+    let workspace = create_local_package(&p_id);\n+    command_line_test([test_sysroot().to_str(),\n+                       ~\"build\",\n+                       ~\"--no-link\",\n+                       ~\"foo\"],\n+                      &workspace);\n+    assert!(!built_executable_exists(&workspace, \"foo\"));\n+    assert!(object_file_exists(&workspace, \"foo\"));\n+}\n+\n+#[test]\n+fn compile_flag_fail() {\n+    // --no-link shouldn't be accepted for install\n+    let p_id = PkgId::new(\"foo\");\n+    let workspace = create_local_package(&p_id);\n+    command_line_test([test_sysroot().to_str(),\n+                       ~\"install\",\n+                       ~\"--no-link\",\n+                       ~\"foo\"],\n+                      &workspace);\n+    assert!(!built_executable_exists(&workspace, \"foo\"));\n+    assert!(!object_file_exists(&workspace, \"foo\"));\n+}\n+\n+#[test]\n+fn notrans_flag_build() {\n+    let p_id = PkgId::new(\"foo\");\n+    let workspace = create_local_package(&p_id);\n+    let flags_to_test = [~\"--no-trans\", ~\"--parse-only\",\n+                         ~\"--pretty\", ~\"-S\"];\n+\n+    for flag in flags_to_test.iter() {\n+        command_line_test([test_sysroot().to_str(),\n+                           ~\"build\",\n+                           flag.clone(),\n+                           ~\"foo\"],\n+                          &workspace);\n+        // Ideally we'd test that rustpkg actually succeeds, but\n+        // since task failure doesn't set the exit code properly,\n+        // we can't tell\n+        assert!(!built_executable_exists(&workspace, \"foo\"));\n+        assert!(!object_file_exists(&workspace, \"foo\"));\n+    }\n+}\n+\n+#[test]\n+fn notrans_flag_fail() {\n+    // --no-trans shouldn't be accepted for install\n+    let p_id = PkgId::new(\"foo\");\n+    let workspace = create_local_package(&p_id);\n+    let flags_to_test = [~\"--no-trans\", ~\"--parse-only\",\n+                         ~\"--pretty\", ~\"-S\"];\n+    for flag in flags_to_test.iter() {\n+        command_line_test([test_sysroot().to_str(),\n+                           ~\"install\",\n+                           flag.clone(),\n+                           ~\"foo\"],\n+                          &workspace);\n+        // Ideally we'd test that rustpkg actually fails, but\n+        // since task failure doesn't set the exit code properly,\n+        // we can't tell\n+        assert!(!built_executable_exists(&workspace, \"foo\"));\n+        assert!(!object_file_exists(&workspace, \"foo\"));\n+        assert!(!lib_exists(&workspace, \"foo\", NoVersion));\n+    }\n+}\n+\n+#[test]\n+fn dash_S() {\n+    let p_id = PkgId::new(\"foo\");\n+    let workspace = create_local_package(&p_id);\n+    command_line_test([test_sysroot().to_str(),\n+                       ~\"build\",\n+                       ~\"-S\",\n+                       ~\"foo\"],\n+                      &workspace);\n+    assert!(!built_executable_exists(&workspace, \"foo\"));\n+    assert!(!object_file_exists(&workspace, \"foo\"));\n+    assert!(assembly_file_exists(&workspace, \"foo\"));\n+}\n+\n+#[test]\n+fn dash_S_fail() {\n+    let p_id = PkgId::new(\"foo\");\n+    let workspace = create_local_package(&p_id);\n+    command_line_test([test_sysroot().to_str(),\n+                       ~\"install\",\n+                       ~\"-S\",\n+                       ~\"foo\"],\n+                      &workspace);\n+    assert!(!built_executable_exists(&workspace, \"foo\"));\n+    assert!(!object_file_exists(&workspace, \"foo\"));\n+    assert!(!assembly_file_exists(&workspace, \"foo\"));\n+}\n+\n+#[test]\n+fn test_cfg_build() {\n+    let p_id = PkgId::new(\"foo\");\n+    let workspace = create_local_package(&p_id);\n+    // If the cfg flag gets messed up, this won't compile\n+    writeFile(&workspace.push_many([\"src\", \"foo-0.1\", \"main.rs\"]),\n+               \"#[cfg(quux)] fn main() {}\");\n+    command_line_test([test_sysroot().to_str(),\n+                       ~\"build\",\n+                       ~\"--cfg\",\n+                       ~\"quux\",\n+                       ~\"foo\"],\n+                      &workspace);\n+    assert_built_executable_exists(&workspace, \"foo\");\n+}\n+\n+#[test]\n+fn test_cfg_fail() {\n+    let p_id = PkgId::new(\"foo\");\n+    let workspace = create_local_package(&p_id);\n+    writeFile(&workspace.push_many([\"src\", \"foo-0.1\", \"main.rs\"]),\n+               \"#[cfg(quux)] fn main() {}\");\n+    assert!(command_line_test_partial([test_sysroot().to_str(),\n+                       ~\"build\",\n+                       ~\"foo\"],\n+                      &workspace).is_none());\n+}\n+\n+\n+#[test]\n+fn test_emit_llvm_S_build() {\n+    let p_id = PkgId::new(\"foo\");\n+    let workspace = create_local_package(&p_id);\n+    command_line_test([test_sysroot().to_str(),\n+                       ~\"build\",\n+                       ~\"-S\", ~\"--emit-llvm\",\n+                       ~\"foo\"],\n+                      &workspace);\n+    assert!(!built_executable_exists(&workspace, \"foo\"));\n+    assert!(!object_file_exists(&workspace, \"foo\"));\n+    assert!(llvm_assembly_file_exists(&workspace, \"foo\"));\n+    assert!(!assembly_file_exists(&workspace, \"foo\"));\n+}\n+\n+#[test]\n+fn test_emit_llvm_S_fail() {\n+    let p_id = PkgId::new(\"foo\");\n+    let workspace = create_local_package(&p_id);\n+    command_line_test([test_sysroot().to_str(),\n+                       ~\"install\",\n+                       ~\"-S\", ~\"--emit-llvm\",\n+                       ~\"foo\"],\n+                      &workspace);\n+    assert!(!built_executable_exists(&workspace, \"foo\"));\n+    assert!(!object_file_exists(&workspace, \"foo\"));\n+    assert!(!llvm_assembly_file_exists(&workspace, \"foo\"));\n+    assert!(!assembly_file_exists(&workspace, \"foo\"));\n+}\n+\n+#[test]\n+fn test_emit_llvm_build() {\n+    let p_id = PkgId::new(\"foo\");\n+    let workspace = create_local_package(&p_id);\n+    command_line_test([test_sysroot().to_str(),\n+                       ~\"build\",\n+                       ~\"--emit-llvm\",\n+                       ~\"foo\"],\n+                      &workspace);\n+    assert!(!built_executable_exists(&workspace, \"foo\"));\n+    assert!(!object_file_exists(&workspace, \"foo\"));\n+    assert!(llvm_bitcode_file_exists(&workspace, \"foo\"));\n+    assert!(!assembly_file_exists(&workspace, \"foo\"));\n+    assert!(!llvm_assembly_file_exists(&workspace, \"foo\"));\n+}\n+\n+#[test]\n+fn test_emit_llvm_fail() {\n+    let p_id = PkgId::new(\"foo\");\n+    let workspace = create_local_package(&p_id);\n+    command_line_test([test_sysroot().to_str(),\n+                       ~\"install\",\n+                       ~\"--emit-llvm\",\n+                       ~\"foo\"],\n+                      &workspace);\n+    assert!(!built_executable_exists(&workspace, \"foo\"));\n+    assert!(!object_file_exists(&workspace, \"foo\"));\n+    assert!(!llvm_bitcode_file_exists(&workspace, \"foo\"));\n+    assert!(!llvm_assembly_file_exists(&workspace, \"foo\"));\n+    assert!(!assembly_file_exists(&workspace, \"foo\"));\n+}\n+\n+#[test]\n+fn test_linker_build() {\n+    let p_id = PkgId::new(\"foo\");\n+    let workspace = create_local_package(&p_id);\n+    let matches = getopts([], optgroups());\n+    let options = build_session_options(@\"rustpkg\",\n+                                        matches.get_ref(),\n+                                        diagnostic::emit);\n+    let sess = build_session(options, diagnostic::emit);\n+    command_line_test([test_sysroot().to_str(),\n+                       ~\"install\",\n+                       ~\"--linker\",\n+                       get_cc_prog(sess),\n+                       ~\"foo\"],\n+                      &workspace);\n+    assert_executable_exists(&workspace, \"foo\");\n+}\n+\n+#[test]\n+fn test_build_install_flags_fail() {\n+    // The following flags can only be used with build or install:\n+    let forbidden = [~[~\"--linker\", ~\"ld\"],\n+                     ~[~\"--link-args\", ~\"quux\"],\n+                     ~[~\"-O\"],\n+                     ~[~\"--opt-level\", ~\"2\"],\n+                     ~[~\"--save-temps\"],\n+                     ~[~\"--target\", host_triple()],\n+                     ~[~\"--target-cpu\", ~\"generic\"],\n+                     ~[~\"-Z\", ~\"--time-passes\"]];\n+    for flag in forbidden.iter() {\n+        let output = command_line_test_output([test_sysroot().to_str(),\n+                           ~\"list\"] + *flag);\n+        assert!(output.len() > 1);\n+        assert!(output[1].find_str(\"can only be used with\").is_some());\n+    }\n+}\n+\n+#[test]\n+fn test_optimized_build() {\n+    let p_id = PkgId::new(\"foo\");\n+    let workspace = create_local_package(&p_id);\n+    command_line_test([test_sysroot().to_str(),\n+                       ~\"build\",\n+                       ~\"-O\",\n+                       ~\"foo\"],\n+                      &workspace);\n+    assert!(built_executable_exists(&workspace, \"foo\"));\n+}\n \n /// Returns true if p exists and is executable\n fn is_executable(p: &Path) -> bool {"}, {"sha": "dae949541b3a185a3272a7d9ba74db586ecafb35", "filename": "src/librustpkg/usage.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ad43613346a5702b84e3a32b39395258e32b1037/src%2Flibrustpkg%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad43613346a5702b84e3a32b39395258e32b1037/src%2Flibrustpkg%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fusage.rs?ref=ad43613346a5702b84e3a32b39395258e32b1037", "patch": "@@ -19,18 +19,34 @@ Where <cmd> is one of:\n Options:\n \n     -h, --help                  Display this message\n+    --sysroot PATH              Override the system root\n     <cmd> -h, <cmd> --help      Display help for <cmd>\");\n }\n \n pub fn build() {\n-    io::println(\"rustpkg [options..] build [package-ID]\n+    io::println(\"rustpkg build [options..] [package-ID]\n \n Build the given package ID if specified. With no package ID argument,\n build the package in the current directory. In that case, the current\n directory must be a direct child of an `src` directory in a workspace.\n \n Options:\n-    -c, --cfg      Pass a cfg flag to the package script\");\n+    -c, --cfg      Pass a cfg flag to the package script\n+    --no-link      Compile and assemble, but don't link (like -c in rustc)\n+    --no-trans     Parse and translate, but don't generate any code\n+    --pretty       Pretty-print the code, but don't generate output\n+    --parse-only   Parse the code, but don't typecheck or generate code\n+    -S             Generate assembly code, but don't assemble or link it\n+    -S --emit-llvm Generate LLVM assembly code\n+    --emit-llvm    Generate LLVM bitcode\n+    --linker PATH  Use a linker other than the system linker\n+    --link-args [ARG..] Extra arguments to pass to the linker\n+    --opt-level=n  Set the optimization level (0 <= n <= 3)\n+    -O             Equivalent to --opt-level=2\n+    --save-temps   Don't delete temporary files\n+    --target TRIPLE Set the target triple\n+    --target-cpu CPU Set the target CPU\n+    -Z FLAG        Enable an experimental rustc feature (see `rustc --help`)\");\n }\n \n pub fn clean() {\n@@ -63,7 +79,7 @@ List all installed packages.\");\n }\n \n pub fn install() {\n-    io::println(\"rustpkg [options..] install [package-ID]\n+    io::println(\"rustpkg install [options..] [package-ID]\n \n Install the given package ID if specified. With no package ID\n argument, install the package in the current directory.\n@@ -76,7 +92,16 @@ Examples:\n     rustpkg install github.com/mozilla/servo#0.1.2\n \n Options:\n-    -c, --cfg      Pass a cfg flag to the package script\");\n+    -c, --cfg      Pass a cfg flag to the package script\n+    --emit-llvm    Generate LLVM bitcode\n+    --linker PATH  Use a linker other than the system linker\n+    --link-args [ARG..] Extra arguments to pass to the linker\n+    --opt-level=n  Set the optimization level (0 <= n <= 3)\n+    -O             Equivalent to --opt-level=2\n+    --save-temps   Don't delete temporary files\n+    --target TRIPLE Set the target triple\n+    --target-cpu CPU Set the target CPU\n+    -Z FLAG        Enable an experimental rustc feature (see `rustc --help`)\");\n }\n \n pub fn uninstall() {"}, {"sha": "7413755d541e73816b96b1c2be82bd18d11530a6", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ad43613346a5702b84e3a32b39395258e32b1037/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad43613346a5702b84e3a32b39395258e32b1037/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=ad43613346a5702b84e3a32b39395258e32b1037", "patch": "@@ -17,9 +17,9 @@ use syntax::codemap::{dummy_sp, Spanned};\n use syntax::ext::base::ExtCtxt;\n use syntax::{ast, attr, codemap, diagnostic, fold};\n use syntax::attr::AttrMetaMethods;\n-use rustc::back::link::output_type_exe;\n+use rustc::back::link;\n use rustc::driver::session::{lib_crate, bin_crate};\n-use context::{in_target, BuildContext};\n+use context::{in_target, StopBefore, Link, Assemble, BuildContext};\n use package_id::PkgId;\n use package_source::PkgSrc;\n use path_util::{installed_library_in_workspace, U_RWX};\n@@ -153,15 +153,15 @@ pub fn ready_crate(sess: session::Session,\n     @fold.fold_crate(crate)\n }\n \n-pub fn compile_input(ctxt: &BuildContext,\n+pub fn compile_input(context: &BuildContext,\n                      exec: &mut workcache::Exec,\n                      pkg_id: &PkgId,\n                      in_file: &Path,\n                      workspace: &Path,\n                      flags: &[~str],\n                      cfgs: &[~str],\n                      opt: bool,\n-                     what: OutputType) -> Path {\n+                     what: OutputType) -> Option<Path> {\n     assert!(in_file.components.len() > 1);\n     let input = driver::file_input((*in_file).clone());\n     debug!(\"compile_input: %s / %?\", in_file.to_str(), what);\n@@ -174,7 +174,7 @@ pub fn compile_input(ctxt: &BuildContext,\n \n     debug!(\"flags: %s\", flags.connect(\" \"));\n     debug!(\"cfgs: %s\", cfgs.connect(\" \"));\n-    debug!(\"compile_input's sysroot = %s\", ctxt.sysroot().to_str());\n+    debug!(\"compile_input's sysroot = %s\", context.sysroot().to_str());\n \n     let crate_type = match what {\n         Lib => lib_crate,\n@@ -188,26 +188,38 @@ pub fn compile_input(ctxt: &BuildContext,\n                               Main => ~[]\n                           }\n                           + flags\n+                          + context.flag_strs()\n                           + cfgs.flat_map(|c| { ~[~\"--cfg\", (*c).clone()] }),\n                           driver::optgroups()).unwrap();\n+    debug!(\"rustc flags: %?\", matches);\n+\n     // Hack so that rustpkg can run either out of a rustc target dir,\n     // or the host dir\n-    let sysroot_to_use = @if !in_target(&ctxt.sysroot()) {\n-        ctxt.sysroot()\n+    let sysroot_to_use = @if !in_target(&context.sysroot()) {\n+        context.sysroot()\n     }\n     else {\n-        ctxt.sysroot().pop().pop().pop()\n+        context.sysroot().pop().pop().pop()\n     };\n-    debug!(\"compile_input's sysroot = %s\", ctxt.sysroot().to_str());\n+    debug!(\"compile_input's sysroot = %s\", context.sysroot().to_str());\n     debug!(\"sysroot_to_use = %s\", sysroot_to_use.to_str());\n+\n+    let output_type = match context.compile_upto() {\n+        Assemble => link::output_type_assembly,\n+        Link     => link::output_type_object,\n+        Pretty | Trans | Analysis => link::output_type_none,\n+        LLVMAssemble => link::output_type_llvm_assembly,\n+        LLVMCompileBitcode => link::output_type_bitcode,\n+        Nothing => link::output_type_exe\n+    };\n+\n     let options = @session::options {\n         crate_type: crate_type,\n         optimize: if opt { session::Aggressive } else { session::No },\n         test: what == Test || what == Bench,\n         maybe_sysroot: Some(sysroot_to_use),\n         addl_lib_search_paths: @mut (~[out_dir.clone()]),\n-        // output_type should be conditional\n-        output_type: output_type_exe, // Use this to get a library? That's weird\n+        output_type: output_type,\n         .. (*driver::build_session_options(binary, &matches, diagnostic::emit)).clone()\n     };\n \n@@ -233,7 +245,7 @@ pub fn compile_input(ctxt: &BuildContext,\n \n     // Not really right. Should search other workspaces too, and the installed\n     // database (which doesn't exist yet)\n-    find_and_install_dependencies(ctxt, sess, exec, workspace, crate,\n+    find_and_install_dependencies(context, sess, exec, workspace, crate,\n                                   |p| {\n                                       debug!(\"a dependency: %s\", p.to_str());\n                                       // Pass the directory containing a dependency\n@@ -270,7 +282,7 @@ pub fn compile_input(ctxt: &BuildContext,\n \n     debug!(\"calling compile_crate_from_input, workspace = %s,\n            building_library = %?\", out_dir.to_str(), sess.building_library);\n-    compile_crate_from_input(in_file, exec, &out_dir, sess, crate)\n+    compile_crate_from_input(in_file, exec, context.compile_upto(), &out_dir, sess, crate)\n }\n \n // Should use workcache to avoid recompiling when not necessary\n@@ -280,10 +292,13 @@ pub fn compile_input(ctxt: &BuildContext,\n // also, too many arguments\n pub fn compile_crate_from_input(input: &Path,\n                                 exec: &mut workcache::Exec,\n+                                stop_before: StopBefore,\n  // should be of the form <workspace>/build/<pkg id's path>\n                                 out_dir: &Path,\n                                 sess: session::Session,\n-                                crate: @ast::Crate) -> Path {\n+// Returns None if one of the flags that suppresses compilation output was\n+// given\n+                                crate: @ast::Crate) -> Option<Path> {\n     debug!(\"Calling build_output_filenames with %s, building library? %?\",\n            out_dir.to_str(), sess.building_library);\n \n@@ -302,17 +317,21 @@ pub fn compile_crate_from_input(input: &Path,\n         debug!(\"an additional library: %s\", lib.to_str());\n     }\n     let analysis = driver::phase_3_run_analysis_passes(sess, crate);\n+    if driver::stop_after_phase_3(sess) { return None; }\n     let translation = driver::phase_4_translate_to_llvm(sess, crate,\n                                                         &analysis,\n                                                         outputs);\n     driver::phase_5_run_llvm_passes(sess, &translation, outputs);\n-    if driver::stop_after_phase_5(sess) { return outputs.out_filename; }\n+    // The second check shouldn't be necessary, but rustc seems to ignore\n+    // -c\n+    if driver::stop_after_phase_5(sess)\n+        || stop_before == Link || stop_before == Assemble { return Some(outputs.out_filename); }\n     driver::phase_6_link_output(sess, &translation, outputs);\n \n     // Register dependency on the source file\n     exec.discover_input(\"file\", input.to_str(), digest_file_with_date(input));\n \n-    outputs.out_filename\n+    Some(outputs.out_filename)\n }\n \n #[cfg(windows)]\n@@ -330,7 +349,7 @@ pub fn compile_crate(ctxt: &BuildContext,\n                      pkg_id: &PkgId,\n                      crate: &Path, workspace: &Path,\n                      flags: &[~str], cfgs: &[~str], opt: bool,\n-                     what: OutputType) -> Path {\n+                     what: OutputType) -> Option<Path> {\n     debug!(\"compile_crate: crate=%s, workspace=%s\", crate.to_str(), workspace.to_str());\n     debug!(\"compile_crate: short_name = %s, flags =...\", pkg_id.to_str());\n     for fl in flags.iter() {\n@@ -344,14 +363,13 @@ pub fn compile_crate(ctxt: &BuildContext,\n /// try to install their targets, failing if any target\n /// can't be found.\n pub fn find_and_install_dependencies(ctxt: &BuildContext,\n-                                 sess: session::Session,\n-                                 exec: &mut workcache::Exec,\n-                                 workspace: &Path,\n-                                 c: &ast::Crate,\n-                                 save: @fn(Path)\n-                                ) {\n-    debug!(\"Finding and installing dependencies...\");\n-    do c.each_view_item |vi| {\n+                                     sess: session::Session,\n+                                     exec: &mut workcache::Exec,\n+                                     workspace: &Path,\n+                                     c: &ast::Crate,\n+                                     save: @fn(Path)\n+                                     ) {\n+    do c.each_view_item() |vi: &ast::view_item| {\n         debug!(\"A view item!\");\n         match vi.node {\n             // ignore metadata, I guess"}]}