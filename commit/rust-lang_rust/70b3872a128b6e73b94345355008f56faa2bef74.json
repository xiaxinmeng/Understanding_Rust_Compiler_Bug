{"sha": "70b3872a128b6e73b94345355008f56faa2bef74", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwYjM4NzJhMTI4YjZlNzNiOTQzNDUzNTUwMDhmNTZmYWEyYmVmNzQ=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-05-09T11:46:42Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-05-17T16:38:23Z"}, "message": "Make all field-handling go through Fields", "tree": {"sha": "759a6078099fd151d64847ee9eec40f4226e6219", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/759a6078099fd151d64847ee9eec40f4226e6219"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70b3872a128b6e73b94345355008f56faa2bef74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70b3872a128b6e73b94345355008f56faa2bef74", "html_url": "https://github.com/rust-lang/rust/commit/70b3872a128b6e73b94345355008f56faa2bef74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70b3872a128b6e73b94345355008f56faa2bef74/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3d3727046a542e23cd105984c735a2ab5a4f610", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3d3727046a542e23cd105984c735a2ab5a4f610", "html_url": "https://github.com/rust-lang/rust/commit/c3d3727046a542e23cd105984c735a2ab5a4f610"}], "stats": {"total": 284, "additions": 143, "deletions": 141}, "files": [{"sha": "921516d6b95f9b754077727def65ccb6f9110db6", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 143, "deletions": 141, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/70b3872a128b6e73b94345355008f56faa2bef74/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70b3872a128b6e73b94345355008f56faa2bef74/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=70b3872a128b6e73b94345355008f56faa2bef74", "patch": "@@ -722,6 +722,11 @@ impl Slice {\n \n /// A value can be decomposed into a constructor applied to some fields. This struct represents\n /// the constructor. See also `Fields`.\n+///\n+/// `pat_constructor` retrieves the constructor corresponding to a pattern.\n+/// `specialize_one_pattern` returns the list of fields corresponding to a pattern, given a\n+/// constructor. `Constructor::apply` reconstructs the pattern from a pair of `Constructor` and\n+/// `Fields`.\n #[derive(Clone, Debug, PartialEq)]\n enum Constructor<'tcx> {\n     /// The constructor for patterns that have a single constructor, like tuples, struct patterns\n@@ -850,96 +855,10 @@ impl<'tcx> Constructor<'tcx> {\n         }\n     }\n \n-    /// This returns one wildcard pattern for each argument to this constructor.\n-    ///\n-    /// This must be consistent with `apply`, `specialize_one_pattern`, and `arity`.\n-    fn wildcard_subpatterns<'a>(\n-        &self,\n-        cx: &MatchCheckCtxt<'a, 'tcx>,\n-        ty: Ty<'tcx>,\n-    ) -> Vec<Pat<'tcx>> {\n-        debug!(\"wildcard_subpatterns({:#?}, {:?})\", self, ty);\n-\n-        match self {\n-            Single | Variant(_) => match ty.kind {\n-                ty::Tuple(ref fs) => {\n-                    fs.into_iter().map(|t| t.expect_ty()).map(Pat::wildcard_from_ty).collect()\n-                }\n-                ty::Ref(_, rty, _) => vec![Pat::wildcard_from_ty(rty)],\n-                ty::Adt(adt, substs) => {\n-                    if adt.is_box() {\n-                        // Use T as the sub pattern type of Box<T>.\n-                        vec![Pat::wildcard_from_ty(substs.type_at(0))]\n-                    } else {\n-                        let variant = &adt.variants[self.variant_index_for_adt(cx, adt)];\n-                        let is_non_exhaustive = cx.is_foreign_non_exhaustive_variant(ty, variant);\n-                        variant\n-                            .fields\n-                            .iter()\n-                            .map(|field| {\n-                                let ty = field.ty(cx.tcx, substs);\n-                                let is_visible = adt.is_enum()\n-                                    || field.vis.is_accessible_from(cx.module, cx.tcx);\n-                                let is_inhabited = !cx.is_uninhabited(ty);\n-                                // Treat all uninhabited non-visible fields as `TyErr`. They can't\n-                                // appear in any other pattern from this match (because they are\n-                                // private), so their type does not matter - but we don't want\n-                                // to know they are uninhabited.\n-                                // Also treat all uninhabited types in non-exhaustive variants as\n-                                // `TyErr`.\n-                                let allowed_to_inspect =\n-                                    is_inhabited || (is_visible && !is_non_exhaustive);\n-\n-                                if allowed_to_inspect {\n-                                    Pat::wildcard_from_ty(ty)\n-                                } else {\n-                                    Pat::wildcard_from_ty(cx.tcx.types.err)\n-                                }\n-                            })\n-                            .collect()\n-                    }\n-                }\n-                _ => vec![],\n-            },\n-            Slice(_) => match ty.kind {\n-                ty::Slice(ty) | ty::Array(ty, _) => {\n-                    let arity = self.arity(cx, ty);\n-                    (0..arity).map(|_| Pat::wildcard_from_ty(ty)).collect()\n-                }\n-                _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n-            },\n-            ConstantValue(..) | FloatRange(..) | IntRange(..) | NonExhaustive => vec![],\n-        }\n-    }\n-\n-    /// This computes the arity of a constructor. The arity of a constructor\n-    /// is how many subpattern patterns of that constructor should be expanded to.\n-    ///\n-    /// For instance, a tuple pattern `(_, 42, Some([]))` has the arity of 3.\n-    /// A struct pattern's arity is the number of fields it contains, etc.\n-    ///\n-    /// This must be consistent with `wildcard_subpatterns`, `specialize_one_pattern`, and `apply`.\n-    fn arity<'a>(&self, cx: &MatchCheckCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> u64 {\n-        debug!(\"Constructor::arity({:#?}, {:?})\", self, ty);\n-        match self {\n-            Single | Variant(_) => match ty.kind {\n-                ty::Tuple(ref fs) => fs.len() as u64,\n-                ty::Slice(..) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n-                ty::Ref(..) => 1,\n-                ty::Adt(adt, _) => {\n-                    adt.variants[self.variant_index_for_adt(cx, adt)].fields.len() as u64\n-                }\n-                _ => 0,\n-            },\n-            Slice(slice) => slice.arity(),\n-            ConstantValue(..) | FloatRange(..) | IntRange(..) | NonExhaustive => 0,\n-        }\n-    }\n-\n     /// Apply a constructor to a list of patterns, yielding a new pattern. `pats`\n     /// must have as many elements as this constructor's arity.\n     ///\n-    /// This must be consistent with `wildcard_subpatterns`, `specialize_one_pattern`, and `arity`.\n+    /// This is roughly the inverse of `specialize_one_pattern`.\n     ///\n     /// Examples:\n     /// `self`: `Constructor::Single`\n@@ -951,13 +870,13 @@ impl<'tcx> Constructor<'tcx> {\n     /// `ty`: `Option<bool>`\n     /// `pats`: `[false]`\n     /// returns `Some(false)`\n-    fn apply<'a>(\n+    fn apply<'p>(\n         &self,\n-        cx: &MatchCheckCtxt<'a, 'tcx>,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n         ty: Ty<'tcx>,\n-        pats: impl IntoIterator<Item = Pat<'tcx>>,\n+        fields: Fields<'p, 'tcx>,\n     ) -> Pat<'tcx> {\n-        let mut subpatterns = pats.into_iter();\n+        let mut subpatterns = fields.into_iter().cloned();\n \n         let pat = match self {\n             Single | Variant(_) => match ty.kind {\n@@ -1022,8 +941,7 @@ impl<'tcx> Constructor<'tcx> {\n \n     /// Like `apply`, but where all the subpatterns are wildcards `_`.\n     fn apply_wildcards<'a>(&self, cx: &MatchCheckCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> Pat<'tcx> {\n-        let subpatterns = self.wildcard_subpatterns(cx, ty).into_iter();\n-        self.apply(cx, ty, subpatterns)\n+        self.apply(cx, ty, Fields::wildcards(cx, self, ty))\n     }\n }\n \n@@ -1050,15 +968,70 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         Fields::Vec(pats)\n     }\n \n+    /// Convenience; internal use.\n+    fn wildcards_from_tys(\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        tys: impl IntoIterator<Item = Ty<'tcx>>,\n+    ) -> Self {\n+        let wilds = tys.into_iter().map(Pat::wildcard_from_ty);\n+        let pats = cx.pattern_arena.alloc_from_iter(wilds);\n+        Fields::Slice(pats)\n+    }\n+\n     /// Creates a new list of wildcard fields for a given constructor.\n     fn wildcards(\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n         constructor: &Constructor<'tcx>,\n         ty: Ty<'tcx>,\n     ) -> Self {\n         debug!(\"Fields::wildcards({:#?}, {:?})\", constructor, ty);\n-        let pats = cx.pattern_arena.alloc_from_iter(constructor.wildcard_subpatterns(cx, ty));\n-        Fields::Slice(pats)\n+        let wildcard_from_ty = |ty| &*cx.pattern_arena.alloc(Pat::wildcard_from_ty(ty));\n+\n+        match constructor {\n+            Single | Variant(_) => match ty.kind {\n+                ty::Tuple(ref fs) => {\n+                    Fields::wildcards_from_tys(cx, fs.into_iter().map(|ty| ty.expect_ty()))\n+                }\n+                ty::Ref(_, rty, _) => Fields::from_single_pattern(wildcard_from_ty(rty)),\n+                ty::Adt(adt, substs) => {\n+                    if adt.is_box() {\n+                        // Use T as the sub pattern type of Box<T>.\n+                        Fields::from_single_pattern(wildcard_from_ty(substs.type_at(0)))\n+                    } else {\n+                        let variant = &adt.variants[constructor.variant_index_for_adt(cx, adt)];\n+                        let is_non_exhaustive = cx.is_foreign_non_exhaustive_variant(ty, variant);\n+                        Fields::wildcards_from_tys(\n+                            cx,\n+                            variant.fields.iter().map(|field| {\n+                                let ty = field.ty(cx.tcx, substs);\n+                                let is_visible = adt.is_enum()\n+                                    || field.vis.is_accessible_from(cx.module, cx.tcx);\n+                                let is_inhabited = !cx.is_uninhabited(ty);\n+                                // Treat all uninhabited non-visible fields as `TyErr`. They can't\n+                                // appear in any other pattern from this match (because they are\n+                                // private), so their type does not matter - but we don't want\n+                                // to know they are uninhabited.\n+                                // Also treat all uninhabited types in non-exhaustive variants as\n+                                // `TyErr`.\n+                                let allowed_to_inspect =\n+                                    is_inhabited || (is_visible && !is_non_exhaustive);\n+\n+                                if allowed_to_inspect { ty } else { cx.tcx.types.err }\n+                            }),\n+                        )\n+                    }\n+                }\n+                _ => Fields::empty(),\n+            },\n+            Slice(slice) => match ty.kind {\n+                ty::Slice(ty) | ty::Array(ty, _) => {\n+                    let arity = slice.arity();\n+                    Fields::wildcards_from_tys(cx, (0..arity).map(|_| ty))\n+                }\n+                _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, ty),\n+            },\n+            ConstantValue(..) | FloatRange(..) | IntRange(..) | NonExhaustive => Fields::empty(),\n+        }\n     }\n \n     fn len(&self) -> usize {\n@@ -1068,14 +1041,61 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         }\n     }\n \n-    fn iter(&self) -> impl Iterator<Item = &'p Pat<'tcx>> {\n+    fn into_iter(self) -> impl Iterator<Item = &'p Pat<'tcx>> {\n         let pats: SmallVec<_> = match self {\n             Fields::Slice(pats) => pats.iter().collect(),\n-            Fields::Vec(pats) => pats.clone(),\n+            Fields::Vec(pats) => pats,\n         };\n         pats.into_iter()\n     }\n \n+    /// Overrides some of the fields with the provided patterns.\n+    fn replace_with_fieldpats(\n+        &self,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        new_pats: impl IntoIterator<Item = &'p FieldPat<'tcx>>,\n+        is_non_exhaustive: bool,\n+    ) -> Self {\n+        self.replace_fields_indexed(\n+            new_pats\n+                .into_iter()\n+                .map(|pat| (pat.field.index(), &pat.pattern))\n+                .filter(|(_, pat)| !(is_non_exhaustive && cx.is_uninhabited(pat.ty))),\n+        )\n+    }\n+\n+    /// Overrides some of the fields with the provided patterns.\n+    fn replace_fields_indexed(\n+        &self,\n+        new_pats: impl IntoIterator<Item = (usize, &'p Pat<'tcx>)>,\n+    ) -> Self {\n+        let mut fields = self.clone();\n+        if let Fields::Slice(pats) = fields {\n+            fields = Fields::Vec(pats.iter().collect());\n+        }\n+\n+        match &mut fields {\n+            Fields::Vec(pats) => {\n+                for (i, pat) in new_pats {\n+                    pats[i] = pat\n+                }\n+            }\n+            Fields::Slice(_) => unreachable!(),\n+        }\n+        fields\n+    }\n+\n+    /// Replaces contained fields with the given filtered list of patterns, e.g. taken from the\n+    /// matrix. There must be `len()` patterns in `pats`.\n+    fn replace_fields(\n+        &self,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        pats: impl IntoIterator<Item = Pat<'tcx>>,\n+    ) -> Self {\n+        let pats: &[_] = cx.pattern_arena.alloc_from_iter(pats);\n+        Fields::Slice(pats)\n+    }\n+\n     fn push_on_patstack(self, stack: &[&'p Pat<'tcx>]) -> PatStack<'p, 'tcx> {\n         let pats: SmallVec<_> = match self {\n             Fields::Slice(pats) => pats.iter().chain(stack.iter().copied()).collect(),\n@@ -1114,15 +1134,16 @@ impl<'tcx, 'p> Usefulness<'tcx, 'p> {\n \n     fn apply_constructor(\n         self,\n-        cx: &MatchCheckCtxt<'_, 'tcx>,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n         ctor: &Constructor<'tcx>,\n         ty: Ty<'tcx>,\n+        ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Self {\n         match self {\n             UsefulWithWitness(witnesses) => UsefulWithWitness(\n                 witnesses\n                     .into_iter()\n-                    .map(|witness| witness.apply_constructor(cx, &ctor, ty))\n+                    .map(|witness| witness.apply_constructor(cx, &ctor, ty, ctor_wild_subpatterns))\n                     .collect(),\n             ),\n             x => x,\n@@ -1242,17 +1263,19 @@ impl<'tcx> Witness<'tcx> {\n     ///\n     /// left_ty: struct X { a: (bool, &'static str), b: usize}\n     /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n-    fn apply_constructor<'a>(\n+    fn apply_constructor<'p>(\n         mut self,\n-        cx: &MatchCheckCtxt<'a, 'tcx>,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n         ctor: &Constructor<'tcx>,\n         ty: Ty<'tcx>,\n+        ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Self {\n-        let arity = ctor.arity(cx, ty);\n         let pat = {\n-            let len = self.0.len() as u64;\n-            let pats = self.0.drain((len - arity) as usize..).rev();\n-            ctor.apply(cx, ty, pats)\n+            let len = self.0.len();\n+            let arity = ctor_wild_subpatterns.len();\n+            let pats = self.0.drain((len - arity)..).rev();\n+            let fields = ctor_wild_subpatterns.replace_fields(cx, pats);\n+            ctor.apply(cx, ty, fields)\n         };\n \n         self.0.push(pat);\n@@ -1877,18 +1900,19 @@ fn is_useful_specialized<'p, 'tcx>(\n     matrix: &Matrix<'p, 'tcx>,\n     v: &PatStack<'p, 'tcx>,\n     ctor: Constructor<'tcx>,\n-    lty: Ty<'tcx>,\n+    ty: Ty<'tcx>,\n     witness_preference: WitnessPreference,\n     hir_id: HirId,\n     is_under_guard: bool,\n ) -> Usefulness<'tcx, 'p> {\n-    debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n+    debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, ty);\n \n-    let ctor_wild_subpatterns = Fields::wildcards(cx, &ctor, lty);\n+    // We cache the result of `Fields::wildcards` because it is used a lot.\n+    let ctor_wild_subpatterns = Fields::wildcards(cx, &ctor, ty);\n     let matrix = matrix.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns);\n     v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns)\n         .map(|v| is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false))\n-        .map(|u| u.apply_constructor(cx, &ctor, lty))\n+        .map(|u| u.apply_constructor(cx, &ctor, ty, &ctor_wild_subpatterns))\n         .unwrap_or(NotUseful)\n }\n \n@@ -2352,27 +2376,6 @@ fn constructor_covered_by_range<'tcx>(\n     if intersects { Some(()) } else { None }\n }\n \n-fn patterns_for_variant<'p, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n-    subpatterns: &'p [FieldPat<'tcx>],\n-    ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n-    is_non_exhaustive: bool,\n-) -> Fields<'p, 'tcx> {\n-    let mut result: SmallVec<_> = ctor_wild_subpatterns.iter().collect();\n-\n-    for subpat in subpatterns {\n-        if !is_non_exhaustive || !cx.is_uninhabited(subpat.pattern.ty) {\n-            result[subpat.field.index()] = &subpat.pattern;\n-        }\n-    }\n-\n-    debug!(\n-        \"patterns_for_variant({:#?}, {:#?}) = {:#?}\",\n-        subpatterns, ctor_wild_subpatterns, result\n-    );\n-    Fields::from_vec(result)\n-}\n-\n /// This is the main specialization step. It expands the pattern\n /// into `arity` patterns based on the constructor. For most patterns, the step is trivial,\n /// for instance tuple patterns are flattened and box patterns expand into their inner pattern.\n@@ -2382,6 +2385,8 @@ fn patterns_for_variant<'p, 'tcx>(\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n+///\n+/// This is roughly the inverse of `Constructor::apply`.\n fn specialize_one_pattern<'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     pat: &'p Pat<'tcx>,\n@@ -2407,11 +2412,11 @@ fn specialize_one_pattern<'p, 'tcx>(\n                 return None;\n             }\n             let is_non_exhaustive = cx.is_foreign_non_exhaustive_variant(pat.ty, variant);\n-            Some(patterns_for_variant(cx, subpatterns, ctor_wild_subpatterns, is_non_exhaustive))\n+            Some(ctor_wild_subpatterns.replace_with_fieldpats(cx, subpatterns, is_non_exhaustive))\n         }\n \n         PatKind::Leaf { ref subpatterns } => {\n-            Some(patterns_for_variant(cx, subpatterns, ctor_wild_subpatterns, false))\n+            Some(ctor_wild_subpatterns.replace_with_fieldpats(cx, subpatterns, false))\n         }\n \n         PatKind::Deref { ref subpattern } => Some(Fields::from_single_pattern(subpattern)),\n@@ -2512,18 +2517,15 @@ fn specialize_one_pattern<'p, 'tcx>(\n                 // Number of subpatterns for this constructor\n                 let arity = ctor_wild_subpatterns.len();\n \n-                if slice.is_none() && arity != pat_len {\n+                if (slice.is_none() && arity != pat_len) || pat_len > arity {\n                     return None;\n                 }\n \n-                // Number of subpatterns matched by the `..` subslice pattern (is 0 for a slice\n-                // pattern of fixed length).\n-                let subslice_count = arity.checked_sub(pat_len)?;\n-                let subslice_pats =\n-                    ctor_wild_subpatterns.iter().skip(prefix.len()).take(subslice_count);\n-                Some(Fields::from_vec(\n-                    prefix.iter().chain(subslice_pats).chain(suffix.iter()).collect(),\n-                ))\n+                // Replace the prefix and the suffix with the given patterns, leaving wildcards in\n+                // the middle if there was a subslice pattern `..`.\n+                let prefix = prefix.iter().enumerate();\n+                let suffix = suffix.iter().enumerate().map(|(i, p)| (arity - suffix.len() + i, p));\n+                Some(ctor_wild_subpatterns.replace_fields_indexed(prefix.chain(suffix)))\n             }\n             ConstantValue(cv) => {\n                 match slice_pat_covered_by_const("}]}