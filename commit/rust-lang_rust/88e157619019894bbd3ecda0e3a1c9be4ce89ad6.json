{"sha": "88e157619019894bbd3ecda0e3a1c9be4ce89ad6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4ZTE1NzYxOTAxOTg5NGJiZDNlY2RhMGUzYTFjOWJlNGNlODlhZDY=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2014-06-16T12:28:05Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-17T01:16:10Z"}, "message": "debuginfo: Correctly handle indirectly recursive types.\n\nSo far handling some indirectly recursive types, such as pointer types, has relied on LLVM metadata uniquing in a very implicit way. This could cause some inconsistencies in the debuginfo, and sometimes to hard to trace LLVM assertions.\nWith this commit unique type IDs and the TypeMap are used to explicitly make sure that no inconsistencies exist, and, if in the future some regression re-introduces one, give a better error message instead of the hard-to-interpret LLVM error.", "tree": {"sha": "f609de8f552a3d8d666f7fb9279f9481515cb8de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f609de8f552a3d8d666f7fb9279f9481515cb8de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88e157619019894bbd3ecda0e3a1c9be4ce89ad6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88e157619019894bbd3ecda0e3a1c9be4ce89ad6", "html_url": "https://github.com/rust-lang/rust/commit/88e157619019894bbd3ecda0e3a1c9be4ce89ad6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88e157619019894bbd3ecda0e3a1c9be4ce89ad6/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5d9e941f52c67b8628f9044da7c24371335a15d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5d9e941f52c67b8628f9044da7c24371335a15d", "html_url": "https://github.com/rust-lang/rust/commit/b5d9e941f52c67b8628f9044da7c24371335a15d"}], "stats": {"total": 331, "additions": 205, "deletions": 126}, "files": [{"sha": "b934f23abb48c5f17444afe79a0529807c58b35e", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 205, "deletions": 126, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/88e157619019894bbd3ecda0e3a1c9be4ce89ad6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88e157619019894bbd3ecda0e3a1c9be4ce89ad6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=88e157619019894bbd3ecda0e3a1c9be4ce89ad6", "patch": "@@ -237,7 +237,7 @@ impl TypeMap {\n                                    metadata: DIType) {\n         if !self.type_to_metadata.insert(ty::type_id(type_), metadata) {\n             cx.sess().bug(format!(\"Type metadata for ty::t '{}' is already in the TypeMap!\",\n-                                  ppaux::ty_to_str(cx.tcx(), type_)).as_slice());\n+                                   ppaux::ty_to_str(cx.tcx(), type_)).as_slice());\n         }\n     }\n \n@@ -291,6 +291,8 @@ impl TypeMap {\n         //                             :return-type-uid: : (:bounds:)*}\n         // function             -> {<unsafe_> <abi_> fn( (:param-uid:)* <,_...> ) -> \\\n         //                             :return-type-uid:}\n+        // unique vec box (~[]) -> {HEAP_VEC_BOX<:pointee-uid:>}\n+        // gc box               -> {GC_BOX<:pointee-uid:>}\n \n         match self.type_to_unique_id.find_copy(&ty::type_id(type_)) {\n             Some(unique_type_id) => return unique_type_id,\n@@ -552,6 +554,30 @@ impl TypeMap {\n         let interner_key = self.unique_id_interner.intern(Rc::new(enum_variant_type_id));\n         UniqueTypeId(interner_key)\n     }\n+\n+    fn get_unique_type_id_of_heap_vec_box(&mut self,\n+                                          cx: &CrateContext,\n+                                          element_type: ty::t)\n+                                       -> UniqueTypeId {\n+        let element_type_id = self.get_unique_type_id_of_type(cx, element_type);\n+        let heap_vec_box_type_id = format!(\"$$HEAP_VEC_BOX<{}>$$\",\n+                                           self.get_unique_type_id_as_string(element_type_id)\n+                                               .as_slice());\n+        let interner_key = self.unique_id_interner.intern(Rc::new(heap_vec_box_type_id));\n+        UniqueTypeId(interner_key)\n+    }\n+\n+    fn get_unique_type_id_of_gc_box(&mut self,\n+                                    cx: &CrateContext,\n+                                    element_type: ty::t)\n+                                 -> UniqueTypeId {\n+        let element_type_id = self.get_unique_type_id_of_type(cx, element_type);\n+        let gc_box_type_id = format!(\"$$GC_BOX<{}>$$\",\n+                                     self.get_unique_type_id_as_string(element_type_id)\n+                                         .as_slice());\n+        let interner_key = self.unique_id_interner.intern(Rc::new(gc_box_type_id));\n+        UniqueTypeId(interner_key)\n+    }\n }\n \n \n@@ -1677,9 +1703,9 @@ fn create_and_register_recursive_type_forward_declaration(\n impl RecursiveTypeDescription {\n     // Finishes up the description of the type in question (mostly by providing descriptions of the\n     // fields of the given type) and returns the final type metadata.\n-    fn finalize(&self, cx: &CrateContext) -> DICompositeType {\n+    fn finalize(&self, cx: &CrateContext) -> MetadataCreationResult {\n         match *self {\n-            FinalMetadata(metadata) => metadata,\n+            FinalMetadata(metadata) => MetadataCreationResult::new(metadata, false),\n             UnfinishedMetadata {\n                 unfinished_type,\n                 unique_type_id,\n@@ -1713,7 +1739,7 @@ impl RecursiveTypeDescription {\n                                               member_descriptions.as_slice(),\n                                               file_metadata,\n                                               codemap::DUMMY_SP);\n-                return metadata_stub;\n+                return MetadataCreationResult::new(metadata_stub, true);\n             }\n         }\n     }\n@@ -2459,14 +2485,22 @@ fn create_struct_stub(cx: &CrateContext,\n }\n \n fn at_box_metadata(cx: &CrateContext,\n+                   at_pointer_type: ty::t,\n                    content_type: ty::t,\n-                   unique_type_id: UniqueTypeId) -> DIType {\n+                   unique_type_id: UniqueTypeId)\n+                -> MetadataCreationResult {\n+    let content_type_metadata = type_metadata(cx, content_type, codemap::DUMMY_SP);\n+\n+    match debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id) {\n+        Some(metadata) => return MetadataCreationResult::new(metadata, true),\n+        None => { /* proceed */ }\n+    };\n+\n     let content_type_name = ppaux::ty_to_str(cx.tcx(), content_type);\n     let content_type_name = content_type_name.as_slice();\n     let content_llvm_type = type_of::type_of(cx, content_type);\n-    let content_type_metadata = type_metadata(cx, content_type, codemap::DUMMY_SP);\n \n-    let box_type_name = format!(\"Boxed<{}>\", content_type_name);\n+    let box_type_name = format!(\"GcBox<{}>\", content_type_name);\n     let box_llvm_type = Type::at_box(cx, content_llvm_type);\n     let member_llvm_types = box_llvm_type.field_types();\n     assert!(box_layout_is_correct(cx,\n@@ -2513,16 +2547,24 @@ fn at_box_metadata(cx: &CrateContext,\n     let loc = span_start(cx, codemap::DUMMY_SP);\n     let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n \n-    return composite_type_metadata(\n+    let gc_box_unique_id = debug_context(cx).type_map\n+                                            .borrow_mut()\n+                                            .get_unique_type_id_of_gc_box(cx, content_type);\n+\n+    let gc_box_metadata = composite_type_metadata(\n         cx,\n         box_llvm_type,\n         box_type_name.as_slice(),\n-        unique_type_id,\n+        gc_box_unique_id,\n         member_descriptions,\n         file_metadata,\n         file_metadata,\n         codemap::DUMMY_SP);\n \n+    let gc_pointer_metadata = pointer_type_metadata(cx, at_pointer_type, gc_box_metadata);\n+\n+    return MetadataCreationResult::new(gc_pointer_metadata, false);\n+\n     // Unfortunately, we cannot assert anything but the correct types here---and not whether the\n     // 'next' and 'prev' pointers are in the correct order.\n     fn box_layout_is_correct(cx: &CrateContext,\n@@ -2540,11 +2582,18 @@ fn at_box_metadata(cx: &CrateContext,\n \n \n fn fixed_vec_metadata(cx: &CrateContext,\n+                      unique_type_id: UniqueTypeId,\n                       element_type: ty::t,\n                       len: uint,\n                       span: Span)\n-                   -> DIType {\n+                   -> MetadataCreationResult {\n     let element_type_metadata = type_metadata(cx, element_type, span);\n+\n+    match debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id) {\n+        Some(metadata) => return MetadataCreationResult::new(metadata, true),\n+        None => { /* proceed */ }\n+    };\n+\n     let element_llvm_type = type_of::type_of(cx, element_type);\n     let (element_type_size, element_type_align) = size_and_align_of(cx, element_llvm_type);\n \n@@ -2556,32 +2605,38 @@ fn fixed_vec_metadata(cx: &CrateContext,\n     };\n \n     let subscripts = create_DIArray(DIB(cx), [subrange]);\n-    return unsafe {\n+    let metadata = unsafe {\n         llvm::LLVMDIBuilderCreateArrayType(\n             DIB(cx),\n             bytes_to_bits(element_type_size * (len as u64)),\n             bytes_to_bits(element_type_align),\n             element_type_metadata,\n             subscripts)\n     };\n+\n+    return MetadataCreationResult::new(metadata, false);\n }\n \n fn heap_vec_metadata(cx: &CrateContext,\n-                     vec_type: ty::t,\n+                     vec_pointer_type: ty::t,\n                      element_type: ty::t,\n                      unique_type_id: UniqueTypeId,\n                      span: Span)\n-                  -> DICompositeType {\n-\n+                  -> MetadataCreationResult {\n     let element_type_metadata = type_metadata(cx, element_type, span);\n     let element_llvm_type = type_of::type_of(cx, element_type);\n     let (element_size, element_align) = size_and_align_of(cx, element_llvm_type);\n \n-    let vec_llvm_type = Type::vec(cx, &element_llvm_type);\n-    let vec_type_name = ppaux::ty_to_str(cx.tcx(), vec_type);\n-    let vec_type_name = vec_type_name.as_slice();\n+    match debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id) {\n+        Some(metadata) => return MetadataCreationResult::new(metadata, true),\n+        None => { /* proceed */ }\n+    };\n+\n+    let vecbox_llvm_type = Type::vec(cx, &element_llvm_type);\n+    let vec_pointer_type_name = ppaux::ty_to_str(cx.tcx(), vec_pointer_type);\n+    let vec_pointer_type_name = vec_pointer_type_name.as_slice();\n \n-    let member_llvm_types = vec_llvm_type.field_types();\n+    let member_llvm_types = vecbox_llvm_type.field_types();\n \n     let int_type_metadata = type_metadata(cx, ty::mk_int(), span);\n     let array_type_metadata = unsafe {\n@@ -2619,25 +2674,39 @@ fn heap_vec_metadata(cx: &CrateContext,\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n \n-    composite_type_metadata(\n-        cx,\n-        vec_llvm_type,\n-        vec_type_name,\n-        unique_type_id,\n-        member_descriptions,\n-        file_metadata,\n-        file_metadata,\n-        span)\n+    let vec_box_unique_id = debug_context(cx).type_map\n+                                             .borrow_mut()\n+                                             .get_unique_type_id_of_heap_vec_box(cx, element_type);\n+\n+    let vecbox_metadata = composite_type_metadata(cx,\n+                                                  vecbox_llvm_type,\n+                                                  vec_pointer_type_name,\n+                                                  vec_box_unique_id,\n+                                                  member_descriptions,\n+                                                  file_metadata,\n+                                                  file_metadata,\n+                                                  span);\n+\n+    MetadataCreationResult::new(pointer_type_metadata(cx, vec_pointer_type, vecbox_metadata), false)\n }\n \n fn vec_slice_metadata(cx: &CrateContext,\n                       vec_type: ty::t,\n                       element_type: ty::t,\n                       unique_type_id: UniqueTypeId,\n                       span: Span)\n-                   -> DICompositeType {\n+                   -> MetadataCreationResult {\n+    let data_ptr_type = ty::mk_ptr(cx.tcx(), ty::mt {\n+        ty: element_type,\n+        mutbl: ast::MutImmutable\n+    });\n+\n+    let element_type_metadata = type_metadata(cx, data_ptr_type, span);\n \n-    debug!(\"vec_slice_metadata: {:?}\", ty::get(vec_type));\n+    match debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id) {\n+        Some(metadata) => return MetadataCreationResult::new(metadata, true),\n+        None => { /* proceed */ }\n+    };\n \n     let slice_llvm_type = type_of::type_of(cx, vec_type);\n     let slice_type_name = ppaux::ty_to_str(cx.tcx(), vec_type);\n@@ -2646,17 +2715,11 @@ fn vec_slice_metadata(cx: &CrateContext,\n     assert!(slice_layout_is_correct(cx,\n                                     member_llvm_types.as_slice(),\n                                     element_type));\n-\n-    let data_ptr_type = ty::mk_ptr(cx.tcx(), ty::mt {\n-        ty: element_type,\n-        mutbl: ast::MutImmutable\n-    });\n-\n     let member_descriptions = [\n         MemberDescription {\n             name: \"data_ptr\".to_string(),\n             llvm_type: *member_llvm_types.get(0),\n-            type_metadata: type_metadata(cx, data_ptr_type, span),\n+            type_metadata: element_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n@@ -2672,15 +2735,15 @@ fn vec_slice_metadata(cx: &CrateContext,\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n \n-    return composite_type_metadata(\n-        cx,\n-        slice_llvm_type,\n-        slice_type_name.as_slice(),\n-        unique_type_id,\n-        member_descriptions,\n-        file_metadata,\n-        file_metadata,\n-        span);\n+    let metadata = composite_type_metadata(cx,\n+                                           slice_llvm_type,\n+                                           slice_type_name.as_slice(),\n+                                           unique_type_id,\n+                                           member_descriptions,\n+                                           file_metadata,\n+                                           file_metadata,\n+                                           span);\n+    return MetadataCreationResult::new(metadata, false);\n \n     fn slice_layout_is_correct(cx: &CrateContext,\n                                member_llvm_types: &[Type],\n@@ -2693,12 +2756,12 @@ fn vec_slice_metadata(cx: &CrateContext,\n }\n \n fn subroutine_type_metadata(cx: &CrateContext,\n+                            unique_type_id: UniqueTypeId,\n                             signature: &ty::FnSig,\n                             span: Span)\n-                         -> DICompositeType {\n+                         -> MetadataCreationResult {\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n-\n     let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs.len() + 1);\n \n     // return type\n@@ -2712,12 +2775,19 @@ fn subroutine_type_metadata(cx: &CrateContext,\n         signature_metadata.push(type_metadata(cx, argument_type, span));\n     }\n \n-    return unsafe {\n-        llvm::LLVMDIBuilderCreateSubroutineType(\n-            DIB(cx),\n-            file_metadata,\n-            create_DIArray(DIB(cx), signature_metadata.as_slice()))\n+    match debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id) {\n+        Some(metadata) => return MetadataCreationResult::new(metadata, true),\n+        None => { /* proceed */ }\n     };\n+\n+    return MetadataCreationResult::new(\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateSubroutineType(\n+                DIB(cx),\n+                file_metadata,\n+                create_DIArray(DIB(cx), signature_metadata.as_slice()))\n+        },\n+        false);\n }\n \n fn trait_metadata(cx: &CrateContext,\n@@ -2758,28 +2828,32 @@ fn trait_metadata(cx: &CrateContext,\n                             definition_span)\n }\n \n-\n fn type_metadata(cx: &CrateContext,\n                  t: ty::t,\n                  usage_site_span: Span)\n               -> DIType {\n     // Get the unique type id of this type.\n     let unique_type_id = {\n         let mut type_map = debug_context(cx).type_map.borrow_mut();\n+        // First, try to find the type in TypeMap. If we have seen it before, we can exit early here\n         match type_map.find_metadata_for_type(t) {\n             Some(metadata) => {\n                 return metadata;\n             },\n             None => {\n+                // The ty::t is not in the TypeMap but maybe we have already seen an equivalent type\n+                // (e.g. only differing in region arguments). In order to find out, generate the\n+                // unique type id and look that up.\n                 let unique_type_id = type_map.get_unique_type_id_of_type(cx, t);\n                 match type_map.find_metadata_for_unique_id(unique_type_id) {\n                     Some(metadata) => {\n+                        // There is already an equivalent type in the TypeMap. Register this ty::t\n+                        // as an alias in the cache and return the cached metadata\n                         type_map.register_type_with_metadata(cx, t, metadata);\n                         return metadata;\n                     },\n                     None => {\n-                        // There really is no type metadata for this type, so proceed by creating\n-                        // it\n+                        // There really is no type metadata for this type, so proceed by creating it\n                         unique_type_id\n                     }\n                 }\n@@ -2799,106 +2873,87 @@ fn type_metadata(cx: &CrateContext,\n     )\n \n     let sty = &ty::get(t).sty;\n-    let (type_metadata, should_already_be_stored_in_typemap) = match *sty {\n+    let MetadataCreationResult { metadata, already_stored_in_typemap } = match *sty {\n         ty::ty_nil      |\n         ty::ty_bot      |\n         ty::ty_bool     |\n         ty::ty_char     |\n         ty::ty_int(_)   |\n         ty::ty_uint(_)  |\n         ty::ty_float(_) => {\n-            (basic_type_metadata(cx, t), false)\n+            MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n         ty::ty_enum(def_id, _) => {\n-            let is_c_style_enum = match *adt::represent_type(cx, t) {\n-                adt::CEnum(..) => true,\n-                _ => false\n-            };\n-\n-            (prepare_enum_metadata(cx, t, def_id, unique_type_id, usage_site_span).finalize(cx),\n-             !is_c_style_enum)\n+            prepare_enum_metadata(cx, t, def_id, unique_type_id, usage_site_span).finalize(cx)\n         }\n         ty::ty_box(pointee_type) => {\n-            let box_content_metadata = at_box_metadata(cx, pointee_type, unique_type_id);\n-            return_if_created_in_meantime!();\n-            (pointer_type_metadata(cx, t, box_content_metadata), false)\n+            at_box_metadata(cx, t, pointee_type, unique_type_id)\n         }\n         ty::ty_vec(ref mt, Some(len)) => {\n-            (fixed_vec_metadata(cx, mt.ty, len, usage_site_span), false)\n+            fixed_vec_metadata(cx, unique_type_id, mt.ty, len, usage_site_span)\n         }\n         ty::ty_uniq(pointee_type) => {\n-            (match ty::get(pointee_type).sty {\n+            match ty::get(pointee_type).sty {\n                 ty::ty_vec(ref mt, None) => {\n-                    let vec_metadata = heap_vec_metadata(cx,\n-                                                         pointee_type,\n-                                                         mt.ty,\n-                                                         unique_type_id,\n-                                                         usage_site_span);\n-                    return_if_created_in_meantime!();\n-                    pointer_type_metadata(cx, t, vec_metadata)\n+                    heap_vec_metadata(cx, pointee_type, mt.ty, unique_type_id, usage_site_span)\n                 }\n                 ty::ty_str => {\n                     let i8_t = ty::mk_i8();\n-                    let vec_metadata = heap_vec_metadata(cx,\n-                                                         pointee_type,\n-                                                         i8_t,\n-                                                         unique_type_id,\n-                                                         usage_site_span);\n-                    pointer_type_metadata(cx, t, vec_metadata)\n+                    heap_vec_metadata(cx, pointee_type, i8_t, unique_type_id, usage_site_span)\n                 }\n                 _ => {\n                     let pointee_metadata = type_metadata(cx, pointee_type, usage_site_span);\n                     return_if_created_in_meantime!();\n-                    pointer_type_metadata(cx, t, pointee_metadata)\n+                    MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee_metadata),\n+                                                false)\n                 }\n-            }, false)\n+            }\n         }\n         ty::ty_ptr(ref mt) | ty::ty_rptr(_, ref mt) => {\n-            (match ty::get(mt.ty).sty {\n+            match ty::get(mt.ty).sty {\n                 ty::ty_vec(ref mt, None) => {\n                     vec_slice_metadata(cx, t, mt.ty, unique_type_id, usage_site_span)\n                 }\n                 ty::ty_str => {\n-                    let i8_t = ty::mk_i8();\n-                    vec_slice_metadata(cx, t, i8_t, unique_type_id, usage_site_span)\n+                    vec_slice_metadata(cx, t, ty::mk_i8(), unique_type_id, usage_site_span)\n                 }\n                 _ => {\n                     let pointee = type_metadata(cx, mt.ty, usage_site_span);\n                     return_if_created_in_meantime!();\n-                    pointer_type_metadata(cx, t, pointee)\n+                    MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee), false)\n                 }\n-            }, false)\n+            }\n         }\n         ty::ty_bare_fn(ref barefnty) => {\n-            (subroutine_type_metadata(cx, &barefnty.sig, usage_site_span), false)\n+            subroutine_type_metadata(cx, unique_type_id, &barefnty.sig, usage_site_span)\n         }\n         ty::ty_closure(ref closurety) => {\n-            (subroutine_type_metadata(cx, &closurety.sig, usage_site_span), false)\n+            subroutine_type_metadata(cx, unique_type_id, &closurety.sig, usage_site_span)\n         }\n         ty::ty_trait(box ty::TyTrait {\n                 def_id,\n                 ref substs,\n                 store,\n                 ref bounds\n             }) => {\n-            (trait_metadata(cx, def_id, t, substs, store, bounds, unique_type_id), false)\n+            MetadataCreationResult::new(\n+                trait_metadata(cx, def_id, t, substs, store, bounds, unique_type_id),\n+                false)\n         }\n         ty::ty_struct(def_id, ref substs) => {\n-            let struct_metadata = prepare_struct_metadata(cx,\n-                                                          t,\n-                                                          def_id,\n-                                                          substs,\n-                                                          unique_type_id,\n-                                                          usage_site_span).finalize(cx);\n-            (struct_metadata, true)\n+            prepare_struct_metadata(cx,\n+                                    t,\n+                                    def_id,\n+                                    substs,\n+                                    unique_type_id,\n+                                    usage_site_span).finalize(cx)\n         }\n         ty::ty_tup(ref elements) => {\n-            let tuple_metadata = prepare_tuple_metadata(cx,\n-                                                        t,\n-                                                        elements.as_slice(),\n-                                                        unique_type_id,\n-                                                        usage_site_span).finalize(cx);\n-            (tuple_metadata, true)\n+            prepare_tuple_metadata(cx,\n+                                   t,\n+                                   elements.as_slice(),\n+                                   unique_type_id,\n+                                   usage_site_span).finalize(cx)\n         }\n         _ => {\n             cx.sess().bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\",\n@@ -2909,33 +2964,57 @@ fn type_metadata(cx: &CrateContext,\n     {\n         let mut type_map = debug_context(cx).type_map.borrow_mut();\n \n-        if should_already_be_stored_in_typemap {\n-            // Make sure that we already have a TypeMap entry entry for the ty::t.\n-            if type_map.find_metadata_for_type(t).is_none() {\n-                let unique_type_id_str = type_map.get_unique_type_id_as_string(unique_type_id);\n-                let error_message = format!(\"Expected type metadata for ty::t '{}' to already be in\n-                                            the TypeMap but it was not (unique type id = {})\",\n-                                            ppaux::ty_to_str(cx.tcx(), t),\n-                                            unique_type_id_str.as_slice());\n-                cx.sess().span_bug(usage_site_span, error_message.as_slice());\n-            }\n-\n+        if already_stored_in_typemap {\n             // Also make sure that we already have a TypeMap entry entry for the unique type id.\n-            if type_map.find_metadata_for_unique_id(unique_type_id).is_none() {\n-                let unique_type_id_str = type_map.get_unique_type_id_as_string(unique_type_id);\n-                let error_message = format!(\"Expected type metadata for unique type id '{}' to\n-                                            already be in the TypeMap but it was not. (ty::t = {})\",\n-                                            unique_type_id_str.as_slice(),\n-                                            ppaux::ty_to_str(cx.tcx(), t));\n-                cx.sess().span_bug(usage_site_span, error_message.as_slice());\n+            let metadata_for_uid = match type_map.find_metadata_for_unique_id(unique_type_id) {\n+                Some(metadata) => metadata,\n+                None => {\n+                    let unique_type_id_str = type_map.get_unique_type_id_as_string(unique_type_id);\n+                    let error_message = format!(\"Expected type metadata for unique type id '{}' to \\\n+                        already be in the debuginfo::TypeMap but it was not. (ty::t = {})\",\n+                        unique_type_id_str.as_slice(),\n+                        ppaux::ty_to_str(cx.tcx(), t));\n+                    cx.sess().span_bug(usage_site_span, error_message.as_slice());\n+                }\n+            };\n+\n+            match type_map.find_metadata_for_type(t) {\n+                Some(metadata) => {\n+                    if metadata != metadata_for_uid {\n+                        let unique_type_id_str =\n+                            type_map.get_unique_type_id_as_string(unique_type_id);\n+                        let error_message = format!(\"Mismatch between ty::t and UniqueTypeId maps \\\n+                            in debuginfo::TypeMap. UniqueTypeId={}, ty::t={}\",\n+                            unique_type_id_str.as_slice(),\n+                            ppaux::ty_to_str(cx.tcx(), t));\n+                        cx.sess().span_bug(usage_site_span, error_message.as_slice());\n+                    }\n+                }\n+                None => {\n+                    type_map.register_type_with_metadata(cx, t, metadata);\n+                }\n             }\n         } else {\n-            type_map.register_type_with_metadata(cx, t, type_metadata);\n-            type_map.register_unique_id_with_metadata(cx, unique_type_id, type_metadata);\n+            type_map.register_type_with_metadata(cx, t, metadata);\n+            type_map.register_unique_id_with_metadata(cx, unique_type_id, metadata);\n         }\n     }\n \n-    type_metadata\n+    metadata\n+}\n+\n+struct MetadataCreationResult {\n+    metadata: DIType,\n+    already_stored_in_typemap: bool\n+}\n+\n+impl MetadataCreationResult {\n+    fn new(metadata: DIType, already_stored_in_typemap: bool) -> MetadataCreationResult {\n+        MetadataCreationResult {\n+            metadata: metadata,\n+            already_stored_in_typemap: already_stored_in_typemap\n+        }\n+    }\n }\n \n #[deriving(PartialEq)]"}]}