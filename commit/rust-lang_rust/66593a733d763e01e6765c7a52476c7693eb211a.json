{"sha": "66593a733d763e01e6765c7a52476c7693eb211a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2NTkzYTczM2Q3NjNlMDFlNjc2NWM3YTUyNDc2Yzc2OTNlYjIxMWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-01T12:30:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-01T12:30:47Z"}, "message": "auto merge of #8911 : Kimundi/rust/master, r=huonw\n\nMost notable: span -> Span", "tree": {"sha": "ab15f69ecc2e88e7e5ae5ea80cf572e336df92a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab15f69ecc2e88e7e5ae5ea80cf572e336df92a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66593a733d763e01e6765c7a52476c7693eb211a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66593a733d763e01e6765c7a52476c7693eb211a", "html_url": "https://github.com/rust-lang/rust/commit/66593a733d763e01e6765c7a52476c7693eb211a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66593a733d763e01e6765c7a52476c7693eb211a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "617850131b795312c4dd404ae7d853b54d883105", "url": "https://api.github.com/repos/rust-lang/rust/commits/617850131b795312c4dd404ae7d853b54d883105", "html_url": "https://github.com/rust-lang/rust/commit/617850131b795312c4dd404ae7d853b54d883105"}, {"sha": "539f37925c4364aa46e984df6ae2ec7e66cecc21", "url": "https://api.github.com/repos/rust-lang/rust/commits/539f37925c4364aa46e984df6ae2ec7e66cecc21", "html_url": "https://github.com/rust-lang/rust/commit/539f37925c4364aa46e984df6ae2ec7e66cecc21"}], "stats": {"total": 2625, "additions": 1315, "deletions": 1310}, "files": [{"sha": "42855b63ff86b19389270736c019eb83cbd8ff03", "filename": "src/librustc/back/arm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fback%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fback%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farm.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -13,46 +13,46 @@ use driver::session::sess_os_to_meta_os;\n use driver::session;\n use metadata::loader::meta_section_name;\n \n-pub fn get_target_strs(target_triple: ~str, target_os: session::os) -> target_strs::t {\n+pub fn get_target_strs(target_triple: ~str, target_os: session::Os) -> target_strs::t {\n     return target_strs::t {\n         module_asm: ~\"\",\n \n-        meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)),\n+        meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)).to_owned(),\n \n         data_layout: match target_os {\n-          session::os_macos => {\n+          session::OsMacos => {\n             ~\"e-p:32:32:32\" +\n                 \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n                 \"-f32:32:32-f64:64:64\" +\n                 \"-v64:64:64-v128:64:128\" +\n                 \"-a0:0:64-n32\"\n           }\n \n-          session::os_win32 => {\n+          session::OsWin32 => {\n             ~\"e-p:32:32:32\" +\n                 \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n                 \"-f32:32:32-f64:64:64\" +\n                 \"-v64:64:64-v128:64:128\" +\n                 \"-a0:0:64-n32\"\n           }\n \n-          session::os_linux => {\n+          session::OsLinux => {\n             ~\"e-p:32:32:32\" +\n                 \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n                 \"-f32:32:32-f64:64:64\" +\n                 \"-v64:64:64-v128:64:128\" +\n                 \"-a0:0:64-n32\"\n           }\n \n-          session::os_android => {\n+          session::OsAndroid => {\n             ~\"e-p:32:32:32\" +\n                 \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n                 \"-f32:32:32-f64:64:64\" +\n                 \"-v64:64:64-v128:64:128\" +\n                 \"-a0:0:64-n32\"\n           }\n \n-          session::os_freebsd => {\n+          session::OsFreebsd => {\n             ~\"e-p:32:32:32\" +\n                 \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n                 \"-f32:32:32-f64:64:64\" +"}, {"sha": "9166696694986c1e18719fec5e17ef1c617cb097", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -814,13 +814,13 @@ pub fn mangle_internal_name_by_seq(_ccx: &mut CrateContext, flav: &str) -> ~str\n }\n \n \n-pub fn output_dll_filename(os: session::os, lm: LinkMeta) -> ~str {\n+pub fn output_dll_filename(os: session::Os, lm: LinkMeta) -> ~str {\n     let (dll_prefix, dll_suffix) = match os {\n-        session::os_win32 => (win32::DLL_PREFIX, win32::DLL_SUFFIX),\n-        session::os_macos => (macos::DLL_PREFIX, macos::DLL_SUFFIX),\n-        session::os_linux => (linux::DLL_PREFIX, linux::DLL_SUFFIX),\n-        session::os_android => (android::DLL_PREFIX, android::DLL_SUFFIX),\n-        session::os_freebsd => (freebsd::DLL_PREFIX, freebsd::DLL_SUFFIX),\n+        session::OsWin32 => (win32::DLL_PREFIX, win32::DLL_SUFFIX),\n+        session::OsMacos => (macos::DLL_PREFIX, macos::DLL_SUFFIX),\n+        session::OsLinux => (linux::DLL_PREFIX, linux::DLL_SUFFIX),\n+        session::OsAndroid => (android::DLL_PREFIX, android::DLL_SUFFIX),\n+        session::OsFreebsd => (freebsd::DLL_PREFIX, freebsd::DLL_SUFFIX),\n     };\n     fmt!(\"%s%s-%s-%s%s\", dll_prefix, lm.name, lm.extras_hash, lm.vers, dll_suffix)\n }\n@@ -835,7 +835,7 @@ pub fn get_cc_prog(sess: Session) -> ~str {\n     match sess.opts.linker {\n         Some(ref linker) => linker.to_str(),\n         None => match sess.targ_cfg.os {\n-            session::os_android =>\n+            session::OsAndroid =>\n                 match &sess.opts.android_cross_path {\n                     &Some(ref path) => {\n                         fmt!(\"%s/bin/arm-linux-androideabi-gcc\", *path)\n@@ -845,7 +845,7 @@ pub fn get_cc_prog(sess: Session) -> ~str {\n                                     (--android-cross-path)\")\n                     }\n                 },\n-            session::os_win32 => ~\"g++\",\n+            session::OsWin32 => ~\"g++\",\n             _ => ~\"cc\"\n         }\n     }\n@@ -892,7 +892,7 @@ pub fn link_binary(sess: Session,\n     }\n \n     // Clean up on Darwin\n-    if sess.targ_cfg.os == session::os_macos {\n+    if sess.targ_cfg.os == session::OsMacos {\n         run::process_status(\"dsymutil\", [output.to_str()]);\n     }\n \n@@ -913,7 +913,7 @@ pub fn link_args(sess: Session,\n     // Converts a library file-stem into a cc -l argument\n     fn unlib(config: @session::config, stem: ~str) -> ~str {\n         if stem.starts_with(\"lib\") &&\n-            config.os != session::os_win32 {\n+            config.os != session::OsWin32 {\n             stem.slice(3, stem.len()).to_owned()\n         } else {\n             stem\n@@ -939,7 +939,7 @@ pub fn link_args(sess: Session,\n         obj_filename.to_str()]);\n \n     let lib_cmd = match sess.targ_cfg.os {\n-        session::os_macos => ~\"-dynamiclib\",\n+        session::OsMacos => ~\"-dynamiclib\",\n         _ => ~\"-shared\"\n     };\n \n@@ -995,28 +995,28 @@ pub fn link_args(sess: Session,\n \n         // On mac we need to tell the linker to let this library\n         // be rpathed\n-        if sess.targ_cfg.os == session::os_macos {\n+        if sess.targ_cfg.os == session::OsMacos {\n             args.push(~\"-Wl,-install_name,@rpath/\"\n                       + output.filename().unwrap());\n         }\n     }\n \n     // On linux librt and libdl are an indirect dependencies via rustrt,\n     // and binutils 2.22+ won't add them automatically\n-    if sess.targ_cfg.os == session::os_linux {\n+    if sess.targ_cfg.os == session::OsLinux {\n         args.push_all([~\"-lrt\", ~\"-ldl\"]);\n \n         // LLVM implements the `frem` instruction as a call to `fmod`,\n         // which lives in libm. Similar to above, on some linuxes we\n         // have to be explicit about linking to it. See #2510\n         args.push(~\"-lm\");\n     }\n-    else if sess.targ_cfg.os == session::os_android {\n+    else if sess.targ_cfg.os == session::OsAndroid {\n         args.push_all([~\"-ldl\", ~\"-llog\",  ~\"-lsupc++\", ~\"-lgnustl_shared\"]);\n         args.push(~\"-lm\");\n     }\n \n-    if sess.targ_cfg.os == session::os_freebsd {\n+    if sess.targ_cfg.os == session::OsFreebsd {\n         args.push_all([~\"-pthread\", ~\"-lrt\",\n                        ~\"-L/usr/local/lib\", ~\"-lexecinfo\",\n                        ~\"-L/usr/local/lib/gcc46\",\n@@ -1030,7 +1030,7 @@ pub fn link_args(sess: Session,\n     // linker from the dwarf unwind info. Unfortunately, it does not seem to\n     // understand how to unwind our __morestack frame, so we have to turn it\n     // off. This has impacted some other projects like GHC.\n-    if sess.targ_cfg.os == session::os_macos {\n+    if sess.targ_cfg.os == session::OsMacos {\n         args.push(~\"-Wl,-no_compact_unwind\");\n     }\n "}, {"sha": "52d8463adfe137bb0f603540f277f9464f782576", "filename": "src/librustc/back/mips.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fback%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fback%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fmips.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -13,46 +13,46 @@ use driver::session;\n use driver::session::sess_os_to_meta_os;\n use metadata::loader::meta_section_name;\n \n-pub fn get_target_strs(target_triple: ~str, target_os: session::os) -> target_strs::t {\n+pub fn get_target_strs(target_triple: ~str, target_os: session::Os) -> target_strs::t {\n     return target_strs::t {\n         module_asm: ~\"\",\n \n-        meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)),\n+        meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)).to_owned(),\n \n         data_layout: match target_os {\n-          session::os_macos => {\n+          session::OsMacos => {\n             ~\"e-p:32:32:32\" +\n                 \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n                 \"-f32:32:32-f64:64:64\" +\n                 \"-v64:64:64-v128:64:128\" +\n                 \"-a0:0:64-n32\"\n           }\n \n-          session::os_win32 => {\n+          session::OsWin32 => {\n             ~\"e-p:32:32:32\" +\n                 \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n                 \"-f32:32:32-f64:64:64\" +\n                 \"-v64:64:64-v128:64:128\" +\n                 \"-a0:0:64-n32\"\n           }\n \n-          session::os_linux => {\n+          session::OsLinux => {\n             ~\"e-p:32:32:32\" +\n                 \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n                 \"-f32:32:32-f64:64:64\" +\n                 \"-v64:64:64-v128:64:128\" +\n                 \"-a0:0:64-n32\"\n           }\n \n-          session::os_android => {\n+          session::OsAndroid => {\n             ~\"e-p:32:32:32\" +\n                 \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n                 \"-f32:32:32-f64:64:64\" +\n                 \"-v64:64:64-v128:64:128\" +\n                 \"-a0:0:64-n32\"\n           }\n \n-          session::os_freebsd => {\n+          session::OsFreebsd => {\n             ~\"e-p:32:32:32\" +\n                 \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\" +\n                 \"-f32:32:32-f64:64:64\" +"}, {"sha": "f937ab446f6c0be002ebb537b7705333491d9dcc", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -16,16 +16,16 @@ use metadata::filesearch;\n use std::hashmap::HashSet;\n use std::{os, util, vec};\n \n-fn not_win32(os: session::os) -> bool {\n-  os != session::os_win32\n+fn not_win32(os: session::Os) -> bool {\n+  os != session::OsWin32\n }\n \n pub fn get_rpath_flags(sess: session::Session, out_filename: &Path)\n                     -> ~[~str] {\n     let os = sess.targ_cfg.os;\n \n     // No rpath on windows\n-    if os == session::os_win32 {\n+    if os == session::OsWin32 {\n         return ~[];\n     }\n \n@@ -52,7 +52,7 @@ pub fn rpaths_to_flags(rpaths: &[Path]) -> ~[~str] {\n     rpaths.iter().map(|rpath| fmt!(\"-Wl,-rpath,%s\",rpath.to_str())).collect()\n }\n \n-fn get_rpaths(os: session::os,\n+fn get_rpaths(os: session::Os,\n               sysroot: &Path,\n               output: &Path,\n               libs: &[Path],\n@@ -97,13 +97,13 @@ fn get_rpaths(os: session::os,\n     return rpaths;\n }\n \n-fn get_rpaths_relative_to_output(os: session::os,\n+fn get_rpaths_relative_to_output(os: session::Os,\n                                  output: &Path,\n                                  libs: &[Path]) -> ~[Path] {\n     libs.iter().map(|a| get_rpath_relative_to_output(os, output, a)).collect()\n }\n \n-pub fn get_rpath_relative_to_output(os: session::os,\n+pub fn get_rpath_relative_to_output(os: session::Os,\n                                     output: &Path,\n                                     lib: &Path)\n                                  -> Path {\n@@ -113,10 +113,10 @@ pub fn get_rpath_relative_to_output(os: session::os,\n \n     // Mac doesn't appear to support $ORIGIN\n     let prefix = match os {\n-        session::os_android | session::os_linux | session::os_freebsd\n+        session::OsAndroid | session::OsLinux | session::OsFreebsd\n                           => \"$ORIGIN\",\n-        session::os_macos => \"@executable_path\",\n-        session::os_win32 => util::unreachable()\n+        session::OsMacos => \"@executable_path\",\n+        session::OsWin32 => util::unreachable()\n     };\n \n     Path(prefix).push_rel(&os::make_absolute(output).get_relative_to(&os::make_absolute(lib)))\n@@ -205,7 +205,7 @@ mod test {\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n     fn test_rpath_relative() {\n-      let o = session::os_linux;\n+      let o = session::OsLinux;\n       let res = get_rpath_relative_to_output(o,\n             &Path(\"bin/rustc\"), &Path(\"lib/libstd.so\"));\n       assert_eq!(res.to_str(), ~\"$ORIGIN/../lib\");\n@@ -214,7 +214,7 @@ mod test {\n     #[test]\n     #[cfg(target_os = \"freebsd\")]\n     fn test_rpath_relative() {\n-        let o = session::os_freebsd;\n+        let o = session::OsFreebsd;\n         let res = get_rpath_relative_to_output(o,\n             &Path(\"bin/rustc\"), &Path(\"lib/libstd.so\"));\n         assert_eq!(res.to_str(), ~\"$ORIGIN/../lib\");\n@@ -223,7 +223,7 @@ mod test {\n     #[test]\n     #[cfg(target_os = \"macos\")]\n     fn test_rpath_relative() {\n-        let o = session::os_macos;\n+        let o = session::OsMacos;\n         let res = get_rpath_relative_to_output(o,\n                                                &Path(\"bin/rustc\"),\n                                                &Path(\"lib/libstd.so\"));"}, {"sha": "4518ec0a14876b57ac0ac18ed09f3cd9664c4422", "filename": "src/librustc/back/x86.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -14,32 +14,32 @@ use driver::session::sess_os_to_meta_os;\n use driver::session;\n use metadata::loader::meta_section_name;\n \n-pub fn get_target_strs(target_triple: ~str, target_os: session::os) -> target_strs::t {\n+pub fn get_target_strs(target_triple: ~str, target_os: session::Os) -> target_strs::t {\n     return target_strs::t {\n         module_asm: ~\"\",\n \n-        meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)),\n+        meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)).to_owned(),\n \n         data_layout: match target_os {\n-          session::os_macos => {\n+          session::OsMacos => {\n             ~\"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\" +\n                 \"-i32:32:32-i64:32:64\" +\n                 \"-f32:32:32-f64:32:64-v64:64:64\" +\n                 \"-v128:128:128-a0:0:64-f80:128:128\" + \"-n8:16:32\"\n           }\n \n-          session::os_win32 => {\n+          session::OsWin32 => {\n             ~\"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\"\n           }\n \n-          session::os_linux => {\n+          session::OsLinux => {\n             ~\"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\"\n           }\n-          session::os_android => {\n+          session::OsAndroid => {\n             ~\"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\"\n           }\n \n-          session::os_freebsd => {\n+          session::OsFreebsd => {\n             ~\"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\"\n           }\n         },"}, {"sha": "3833f0d2b94b8d2b8378a1cb0cdf80e5f4017512", "filename": "src/librustc/back/x86_64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86_64.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -14,38 +14,38 @@ use driver::session::sess_os_to_meta_os;\n use driver::session;\n use metadata::loader::meta_section_name;\n \n-pub fn get_target_strs(target_triple: ~str, target_os: session::os) -> target_strs::t {\n+pub fn get_target_strs(target_triple: ~str, target_os: session::Os) -> target_strs::t {\n     return target_strs::t {\n         module_asm: ~\"\",\n \n-        meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)),\n+        meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)).to_owned(),\n \n         data_layout: match target_os {\n-          session::os_macos => {\n+          session::OsMacos => {\n             ~\"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\"+\n                 \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n                 \"s0:64:64-f80:128:128-n8:16:32:64\"\n           }\n \n-          session::os_win32 => {\n+          session::OsWin32 => {\n             // FIXME: Test this. Copied from linux (#2398)\n             ~\"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\"+\n                 \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n                 \"s0:64:64-f80:128:128-n8:16:32:64-S128\"\n           }\n \n-          session::os_linux => {\n+          session::OsLinux => {\n             ~\"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\"+\n                 \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n                 \"s0:64:64-f80:128:128-n8:16:32:64-S128\"\n           }\n-          session::os_android => {\n+          session::OsAndroid => {\n             ~\"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\"+\n                 \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n                 \"s0:64:64-f80:128:128-n8:16:32:64-S128\"\n           }\n \n-          session::os_freebsd => {\n+          session::OsFreebsd => {\n             ~\"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\"+\n                 \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n                 \"s0:64:64-f80:128:128-n8:16:32:64-S128\""}, {"sha": "e4d3ca4baefb25b74849f288f8e03f03171501fb", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -43,12 +43,12 @@ use syntax::parse::token;\n use syntax::print::{pp, pprust};\n use syntax;\n \n-pub enum pp_mode {\n-    ppm_normal,\n-    ppm_expanded,\n-    ppm_typed,\n-    ppm_identified,\n-    ppm_expanded_identified\n+pub enum PpMode {\n+    PpmNormal,\n+    PpmExpanded,\n+    PpmTyped,\n+    PpmIdentified,\n+    PpmExpandedIdentified\n }\n \n /**\n@@ -67,11 +67,11 @@ pub fn source_name(input: &input) -> @str {\n pub fn default_configuration(sess: Session) ->\n    ast::CrateConfig {\n     let tos = match sess.targ_cfg.os {\n-        session::os_win32 =>   @\"win32\",\n-        session::os_macos =>   @\"macos\",\n-        session::os_linux =>   @\"linux\",\n-        session::os_android => @\"android\",\n-        session::os_freebsd => @\"freebsd\"\n+        session::OsWin32 =>   @\"win32\",\n+        session::OsMacos =>   @\"macos\",\n+        session::OsLinux =>   @\"linux\",\n+        session::OsAndroid => @\"android\",\n+        session::OsFreebsd => @\"freebsd\"\n     };\n \n     // ARM is bi-endian, however using NDK seems to default\n@@ -338,8 +338,8 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n     // output are OK, so we generate assembly first and then run it through\n     // an external assembler.\n     // Same for Android.\n-    if (sess.targ_cfg.os == session::os_android ||\n-        sess.targ_cfg.os == session::os_win32) &&\n+    if (sess.targ_cfg.os == session::OsAndroid ||\n+        sess.targ_cfg.os == session::OsWin32) &&\n         (sess.opts.output_type == link::output_type_object ||\n          sess.opts.output_type == link::output_type_exe) {\n         let output_type = link::output_type_assembly;\n@@ -439,7 +439,7 @@ pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n }\n \n pub fn pretty_print_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n-                          ppm: pp_mode) {\n+                          ppm: PpMode) {\n \n     fn ann_paren_for_expr(node: pprust::ann_node) {\n         match node {\n@@ -485,20 +485,20 @@ pub fn pretty_print_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n     let crate = phase_1_parse_input(sess, cfg.clone(), input);\n \n     let (crate, is_expanded) = match ppm {\n-        ppm_expanded | ppm_expanded_identified | ppm_typed => {\n+        PpmExpanded | PpmExpandedIdentified | PpmTyped => {\n             (phase_2_configure_and_expand(sess, cfg, crate), true)\n         }\n         _ => (crate, false)\n     };\n \n     let annotation = match ppm {\n-        ppm_identified | ppm_expanded_identified => {\n+        PpmIdentified | PpmExpandedIdentified => {\n             pprust::pp_ann {\n                 pre: ann_paren_for_expr,\n                 post: ann_identified_post\n             }\n         }\n-        ppm_typed => {\n+        PpmTyped => {\n             let analysis = phase_3_run_analysis_passes(sess, crate);\n             pprust::pp_ann {\n                 pre: ann_paren_for_expr,\n@@ -518,19 +518,19 @@ pub fn pretty_print_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n     }\n }\n \n-pub fn get_os(triple: &str) -> Option<session::os> {\n+pub fn get_os(triple: &str) -> Option<session::Os> {\n     for &(name, os) in os_names.iter() {\n         if triple.contains(name) { return Some(os) }\n     }\n     None\n }\n-static os_names : &'static [(&'static str, session::os)] = &'static [\n-    (\"mingw32\", session::os_win32),\n-    (\"win32\",   session::os_win32),\n-    (\"darwin\",  session::os_macos),\n-    (\"android\", session::os_android),\n-    (\"linux\",   session::os_linux),\n-    (\"freebsd\", session::os_freebsd)];\n+static os_names : &'static [(&'static str, session::Os)] = &'static [\n+    (\"mingw32\", session::OsWin32),\n+    (\"win32\",   session::OsWin32),\n+    (\"darwin\",  session::OsMacos),\n+    (\"android\", session::OsAndroid),\n+    (\"linux\",   session::OsLinux),\n+    (\"freebsd\", session::OsFreebsd)];\n \n pub fn get_arch(triple: &str) -> Option<abi::Architecture> {\n     for &(arch, abi) in architecture_abis.iter() {\n@@ -817,13 +817,13 @@ pub fn build_session_(sopts: @session::options,\n     }\n }\n \n-pub fn parse_pretty(sess: Session, name: &str) -> pp_mode {\n+pub fn parse_pretty(sess: Session, name: &str) -> PpMode {\n     match name {\n-      &\"normal\" => ppm_normal,\n-      &\"expanded\" => ppm_expanded,\n-      &\"typed\" => ppm_typed,\n-      &\"expanded,identified\" => ppm_expanded_identified,\n-      &\"identified\" => ppm_identified,\n+      &\"normal\" => PpmNormal,\n+      &\"expanded\" => PpmExpanded,\n+      &\"typed\" => PpmTyped,\n+      &\"expanded,identified\" => PpmExpandedIdentified,\n+      &\"identified\" => PpmIdentified,\n       _ => {\n         sess.fatal(\"argument to `pretty` must be one of `normal`, \\\n                     `expanded`, `typed`, `identified`, \\"}, {"sha": "acc0aab659d5ae528012a5d80f29b0d7563a042e", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -20,7 +20,7 @@ use middle::lint;\n \n use syntax::ast::NodeId;\n use syntax::ast::{int_ty, uint_ty, float_ty};\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::diagnostic;\n use syntax::parse::ParseSess;\n use syntax::{ast, codemap};\n@@ -31,7 +31,7 @@ use syntax;\n use std::hashmap::HashMap;\n \n #[deriving(Eq)]\n-pub enum os { os_win32, os_macos, os_linux, os_android, os_freebsd, }\n+pub enum Os { OsWin32, OsMacos, OsLinux, OsAndroid, OsFreebsd, }\n \n #[deriving(Clone)]\n pub enum crate_type {\n@@ -41,7 +41,7 @@ pub enum crate_type {\n }\n \n pub struct config {\n-    os: os,\n+    os: Os,\n     arch: abi::Architecture,\n     target_strs: target_strs::t,\n     int_type: int_ty,\n@@ -209,25 +209,25 @@ pub struct Session_ {\n     parse_sess: @mut ParseSess,\n     codemap: @codemap::CodeMap,\n     // For a library crate, this is always none\n-    entry_fn: @mut Option<(NodeId, codemap::span)>,\n+    entry_fn: @mut Option<(NodeId, codemap::Span)>,\n     entry_type: @mut Option<EntryFnType>,\n     span_diagnostic: @mut diagnostic::span_handler,\n     filesearch: @filesearch::FileSearch,\n     building_library: @mut bool,\n     working_dir: Path,\n-    lints: @mut HashMap<ast::NodeId, ~[(lint::lint, codemap::span, ~str)]>,\n+    lints: @mut HashMap<ast::NodeId, ~[(lint::lint, codemap::Span, ~str)]>,\n }\n \n pub type Session = @Session_;\n \n impl Session_ {\n-    pub fn span_fatal(@self, sp: span, msg: &str) -> ! {\n+    pub fn span_fatal(@self, sp: Span, msg: &str) -> ! {\n         self.span_diagnostic.span_fatal(sp, msg)\n     }\n     pub fn fatal(@self, msg: &str) -> ! {\n         self.span_diagnostic.handler().fatal(msg)\n     }\n-    pub fn span_err(@self, sp: span, msg: &str) {\n+    pub fn span_err(@self, sp: Span, msg: &str) {\n         self.span_diagnostic.span_err(sp, msg)\n     }\n     pub fn err(@self, msg: &str) {\n@@ -242,25 +242,25 @@ impl Session_ {\n     pub fn abort_if_errors(@self) {\n         self.span_diagnostic.handler().abort_if_errors()\n     }\n-    pub fn span_warn(@self, sp: span, msg: &str) {\n+    pub fn span_warn(@self, sp: Span, msg: &str) {\n         self.span_diagnostic.span_warn(sp, msg)\n     }\n     pub fn warn(@self, msg: &str) {\n         self.span_diagnostic.handler().warn(msg)\n     }\n-    pub fn span_note(@self, sp: span, msg: &str) {\n+    pub fn span_note(@self, sp: Span, msg: &str) {\n         self.span_diagnostic.span_note(sp, msg)\n     }\n     pub fn note(@self, msg: &str) {\n         self.span_diagnostic.handler().note(msg)\n     }\n-    pub fn span_bug(@self, sp: span, msg: &str) -> ! {\n+    pub fn span_bug(@self, sp: Span, msg: &str) -> ! {\n         self.span_diagnostic.span_bug(sp, msg)\n     }\n     pub fn bug(@self, msg: &str) -> ! {\n         self.span_diagnostic.handler().bug(msg)\n     }\n-    pub fn span_unimpl(@self, sp: span, msg: &str) -> ! {\n+    pub fn span_unimpl(@self, sp: Span, msg: &str) -> ! {\n         self.span_diagnostic.span_unimpl(sp, msg)\n     }\n     pub fn unimpl(@self, msg: &str) -> ! {\n@@ -269,7 +269,7 @@ impl Session_ {\n     pub fn add_lint(@self,\n                     lint: lint::lint,\n                     id: ast::NodeId,\n-                    sp: span,\n+                    sp: Span,\n                     msg: ~str) {\n         match self.lints.find_mut(&id) {\n             Some(arr) => { arr.push((lint, sp, msg)); return; }\n@@ -288,7 +288,7 @@ impl Session_ {\n     }\n     // This exists to help with refactoring to eliminate impossible\n     // cases later on\n-    pub fn impossible_case(@self, sp: span, msg: &str) -> ! {\n+    pub fn impossible_case(@self, sp: Span, msg: &str) -> ! {\n         self.span_bug(sp, fmt!(\"Impossible case reached: %s\", msg));\n     }\n     pub fn verbose(@self) -> bool { self.debugging_opt(verbose) }\n@@ -411,15 +411,15 @@ pub fn building_library(req_crate_type: crate_type,\n     }\n }\n \n-pub fn sess_os_to_meta_os(os: os) -> metadata::loader::os {\n+pub fn sess_os_to_meta_os(os: Os) -> metadata::loader::Os {\n     use metadata::loader;\n \n     match os {\n-      os_win32 => loader::os_win32,\n-      os_linux => loader::os_linux,\n-      os_android => loader::os_android,\n-      os_macos => loader::os_macos,\n-      os_freebsd => loader::os_freebsd\n+        OsWin32 => loader::OsWin32,\n+        OsLinux => loader::OsLinux,\n+        OsAndroid => loader::OsAndroid,\n+        OsMacos => loader::OsMacos,\n+        OsFreebsd => loader::OsFreebsd\n     }\n }\n "}, {"sha": "5d536ba7213f9401cf273e78a51353242aad2f08", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -39,8 +39,8 @@ fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n }\n \n fn inject_libstd_ref(sess: Session, crate: &ast::Crate) -> @ast::Crate {\n-    fn spanned<T>(x: T) -> codemap::spanned<T> {\n-        codemap::spanned { node: x, span: dummy_sp() }\n+    fn spanned<T>(x: T) -> codemap::Spanned<T> {\n+        codemap::Spanned { node: x, span: dummy_sp() }\n     }\n \n     let precursor = @fold::AstFoldFns {"}, {"sha": "906aa619fa3e3e9a8940f1e996065494713c6935", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -18,7 +18,7 @@ use std::vec;\n use syntax::ast_util::*;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n-use syntax::codemap::{dummy_sp, span, ExpnInfo, NameAndSpan};\n+use syntax::codemap::{dummy_sp, Span, ExpnInfo, NameAndSpan};\n use syntax::codemap;\n use syntax::ext::base::ExtCtxt;\n use syntax::fold;\n@@ -29,7 +29,7 @@ use syntax::{ast, ast_util};\n type node_id_gen = @fn() -> ast::NodeId;\n \n struct Test {\n-    span: span,\n+    span: Span,\n     path: ~[ast::ident],\n     bench: bool,\n     ignore: bool,\n@@ -379,8 +379,8 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n     return @item;\n }\n \n-fn nospan<T>(t: T) -> codemap::spanned<T> {\n-    codemap::spanned { node: t, span: dummy_sp() }\n+fn nospan<T>(t: T) -> codemap::Spanned<T> {\n+    codemap::Spanned { node: t, span: dummy_sp() }\n }\n \n fn path_node(ids: ~[ast::ident]) -> ast::Path {"}, {"sha": "c463bd9bc033839da26dbdb77d4ffbc197bb716b", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -21,7 +21,7 @@ use syntax::ast;\n use std::vec;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::{span, dummy_sp};\n+use syntax::codemap::{Span, dummy_sp};\n use syntax::diagnostic::span_handler;\n use syntax::parse::token;\n use syntax::parse::token::ident_interner;\n@@ -33,7 +33,7 @@ pub fn read_crates(diag: @mut span_handler,\n                    crate: &ast::Crate,\n                    cstore: @mut cstore::CStore,\n                    filesearch: @FileSearch,\n-                   os: loader::os,\n+                   os: loader::Os,\n                    statik: bool,\n                    intr: @ident_interner) {\n     let e = @mut Env {\n@@ -68,7 +68,7 @@ impl visit::Visitor<()> for ReadCrateVisitor {\n #[deriving(Clone)]\n struct cache_entry {\n     cnum: int,\n-    span: span,\n+    span: Span,\n     hash: @str,\n     metas: @~[@ast::MetaItem]\n }\n@@ -116,7 +116,7 @@ struct Env {\n     diag: @mut span_handler,\n     filesearch: @FileSearch,\n     cstore: @mut cstore::CStore,\n-    os: loader::os,\n+    os: loader::Os,\n     statik: bool,\n     crate_cache: @mut ~[cache_entry],\n     next_crate_num: ast::CrateNum,\n@@ -252,7 +252,7 @@ fn resolve_crate(e: @mut Env,\n                  ident: @str,\n                  metas: ~[@ast::MetaItem],\n                  hash: @str,\n-                 span: span)\n+                 span: Span)\n               -> ast::CrateNum {\n     let metas = metas_with_ident(ident, metas);\n "}, {"sha": "198c41539cb6e9f414e73375ba546d48701069a4", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -52,7 +52,7 @@ pub fn each_lang_item(cstore: @mut cstore::CStore,\n /// Iterates over each child of the given item.\n pub fn each_child_of_item(cstore: @mut cstore::CStore,\n                           def_id: ast::def_id,\n-                          callback: &fn(decoder::def_like, ast::ident)) {\n+                          callback: &fn(decoder::DefLike, ast::ident)) {\n     let crate_data = cstore::get_crate_data(cstore, def_id.crate);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore::get_crate_data(cstore, cnum)\n@@ -67,7 +67,7 @@ pub fn each_child_of_item(cstore: @mut cstore::CStore,\n /// Iterates over each top-level crate item.\n pub fn each_top_level_item_of_crate(cstore: @mut cstore::CStore,\n                                     cnum: ast::CrateNum,\n-                                    callback: &fn(decoder::def_like,\n+                                    callback: &fn(decoder::DefLike,\n                                                   ast::ident)) {\n     let crate_data = cstore::get_crate_data(cstore, cnum);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {"}, {"sha": "592ee1b0a63380a33ee8752f44866e4a86320ecc", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -43,7 +43,7 @@ use syntax::ast;\n use syntax::codemap;\n use syntax::parse::token;\n \n-type cmd = @crate_metadata;\n+type Cmd = @crate_metadata;\n \n // A function that takes a def_id relative to the crate being searched and\n // returns a def_id relative to the compilation environment, i.e. if we hit a\n@@ -74,7 +74,7 @@ fn lookup_hash(d: ebml::Doc, eq_fn: &fn(x:&[u8]) -> bool, hash: u64) ->\n     ret\n }\n \n-pub type GetCrateDataCb<'self> = &'self fn(ast::CrateNum) -> cmd;\n+pub type GetCrateDataCb<'self> = &'self fn(ast::CrateNum) -> Cmd;\n \n pub fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n@@ -192,12 +192,12 @@ fn item_reqd_and_translated_parent_item(cnum: ast::CrateNum,\n     ast::def_id { crate: cnum, node: trait_did.node }\n }\n \n-fn item_def_id(d: ebml::Doc, cdata: cmd) -> ast::def_id {\n+fn item_def_id(d: ebml::Doc, cdata: Cmd) -> ast::def_id {\n     let tagdoc = reader::get_doc(d, tag_def_id);\n     return translate_def_id(cdata, reader::with_doc_data(tagdoc, parse_def_id));\n }\n \n-fn get_provided_source(d: ebml::Doc, cdata: cmd) -> Option<ast::def_id> {\n+fn get_provided_source(d: ebml::Doc, cdata: Cmd) -> Option<ast::def_id> {\n     do reader::maybe_get_doc(d, tag_item_method_provided_source).map_move |doc| {\n         translate_def_id(cdata, reader::with_doc_data(doc, parse_def_id))\n     }\n@@ -213,21 +213,21 @@ fn variant_disr_val(d: ebml::Doc) -> Option<ty::Disr> {\n     }\n }\n \n-fn doc_type(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n+fn doc_type(doc: ebml::Doc, tcx: ty::ctxt, cdata: Cmd) -> ty::t {\n     let tp = reader::get_doc(doc, tag_items_data_item_type);\n     parse_ty_data(*tp.data, cdata.cnum, tp.start, tcx,\n                   |_, did| translate_def_id(cdata, did))\n }\n \n-fn doc_method_fty(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::BareFnTy {\n+fn doc_method_fty(doc: ebml::Doc, tcx: ty::ctxt, cdata: Cmd) -> ty::BareFnTy {\n     let tp = reader::get_doc(doc, tag_item_method_fty);\n     parse_bare_fn_ty_data(*tp.data, cdata.cnum, tp.start, tcx,\n                           |_, did| translate_def_id(cdata, did))\n }\n \n fn doc_transformed_self_ty(doc: ebml::Doc,\n                            tcx: ty::ctxt,\n-                           cdata: cmd) -> Option<ty::t>\n+                           cdata: Cmd) -> Option<ty::t>\n {\n     do reader::maybe_get_doc(doc, tag_item_method_transformed_self_ty).map |tp| {\n         parse_ty_data(*tp.data, cdata.cnum, tp.start, tcx,\n@@ -236,21 +236,21 @@ fn doc_transformed_self_ty(doc: ebml::Doc,\n }\n \n pub fn item_type(_item_id: ast::def_id, item: ebml::Doc,\n-                 tcx: ty::ctxt, cdata: cmd) -> ty::t {\n+                 tcx: ty::ctxt, cdata: Cmd) -> ty::t {\n     doc_type(item, tcx, cdata)\n }\n \n-fn doc_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::TraitRef {\n+fn doc_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n     parse_trait_ref_data(*doc.data, cdata.cnum, doc.start, tcx,\n                          |_, did| translate_def_id(cdata, did))\n }\n \n-fn item_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::TraitRef {\n+fn item_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n     let tp = reader::get_doc(doc, tag_item_trait_ref);\n     doc_trait_ref(tp, tcx, cdata)\n }\n \n-fn item_ty_param_defs(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd,\n+fn item_ty_param_defs(item: ebml::Doc, tcx: ty::ctxt, cdata: Cmd,\n                       tag: uint)\n     -> @~[ty::TypeParameterDef] {\n     let mut bounds = ~[];\n@@ -278,7 +278,7 @@ fn item_ty_param_count(item: ebml::Doc) -> uint {\n     n\n }\n \n-fn enum_variant_ids(item: ebml::Doc, cdata: cmd) -> ~[ast::def_id] {\n+fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> ~[ast::def_id] {\n     let mut ids: ~[ast::def_id] = ~[];\n     let v = tag_items_data_item_variant;\n     do reader::tagged_docs(item, v) |p| {\n@@ -322,15 +322,15 @@ fn item_name(intr: @ident_interner, item: ebml::Doc) -> ast::ident {\n }\n \n fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::CrateNum)\n-    -> def_like {\n+    -> DefLike {\n     let fam = item_family(item);\n     match fam {\n-        ImmStatic => dl_def(ast::def_static(did, false)),\n-        MutStatic => dl_def(ast::def_static(did, true)),\n-        Struct    => dl_def(ast::def_struct(did)),\n-        UnsafeFn  => dl_def(ast::def_fn(did, ast::unsafe_fn)),\n-        Fn        => dl_def(ast::def_fn(did, ast::impure_fn)),\n-        ForeignFn => dl_def(ast::def_fn(did, ast::extern_fn)),\n+        ImmStatic => DlDef(ast::def_static(did, false)),\n+        MutStatic => DlDef(ast::def_static(did, true)),\n+        Struct    => DlDef(ast::def_struct(did)),\n+        UnsafeFn  => DlDef(ast::def_fn(did, ast::unsafe_fn)),\n+        Fn        => DlDef(ast::def_fn(did, ast::impure_fn)),\n+        ForeignFn => DlDef(ast::def_fn(did, ast::extern_fn)),\n         StaticMethod | UnsafeStaticMethod => {\n             let purity = if fam == UnsafeStaticMethod { ast::unsafe_fn } else\n                 { ast::impure_fn };\n@@ -347,19 +347,19 @@ fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::CrateNum)\n                 ast::FromImpl(item_reqd_and_translated_parent_item(cnum,\n                                                                    item))\n             };\n-            dl_def(ast::def_static_method(did, provenance, purity))\n+            DlDef(ast::def_static_method(did, provenance, purity))\n         }\n-        Type | ForeignType => dl_def(ast::def_ty(did)),\n-        Mod => dl_def(ast::def_mod(did)),\n-        ForeignMod => dl_def(ast::def_foreign_mod(did)),\n+        Type | ForeignType => DlDef(ast::def_ty(did)),\n+        Mod => DlDef(ast::def_mod(did)),\n+        ForeignMod => DlDef(ast::def_foreign_mod(did)),\n         Variant => {\n             let enum_did = item_reqd_and_translated_parent_item(cnum, item);\n-            dl_def(ast::def_variant(enum_did, did))\n+            DlDef(ast::def_variant(enum_did, did))\n         }\n-        Trait => dl_def(ast::def_trait(did)),\n-        Enum => dl_def(ast::def_ty(did)),\n-        Impl => dl_impl(did),\n-        PublicField | PrivateField | InheritedField => dl_field,\n+        Trait => DlDef(ast::def_trait(did)),\n+        Enum => DlDef(ast::def_ty(did)),\n+        Impl => DlImpl(did),\n+        PublicField | PrivateField | InheritedField => DlField,\n     }\n }\n \n@@ -371,7 +371,7 @@ pub fn lookup_def(cnum: ast::CrateNum, data: @~[u8], did_: ast::def_id) ->\n     return def_like_to_def(item_to_def_like(item, did, cnum));\n }\n \n-pub fn get_trait_def(cdata: cmd,\n+pub fn get_trait_def(cdata: Cmd,\n                      item_id: ast::NodeId,\n                      tcx: ty::ctxt) -> ty::TraitDef\n {\n@@ -398,7 +398,7 @@ pub fn get_trait_def(cdata: cmd,\n     }\n }\n \n-pub fn get_type(cdata: cmd, id: ast::NodeId, tcx: ty::ctxt)\n+pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n     -> ty::ty_param_bounds_and_ty {\n \n     let item = lookup_item(id, cdata.data);\n@@ -415,7 +415,7 @@ pub fn get_type(cdata: cmd, id: ast::NodeId, tcx: ty::ctxt)\n     }\n }\n \n-pub fn get_region_param(cdata: cmd, id: ast::NodeId)\n+pub fn get_region_param(cdata: Cmd, id: ast::NodeId)\n     -> Option<ty::region_variance> {\n \n     let item = lookup_item(id, cdata.data);\n@@ -426,7 +426,7 @@ pub fn get_type_param_count(data: @~[u8], id: ast::NodeId) -> uint {\n     item_ty_param_count(lookup_item(id, data))\n }\n \n-pub fn get_impl_trait(cdata: cmd,\n+pub fn get_impl_trait(cdata: Cmd,\n                        id: ast::NodeId,\n                        tcx: ty::ctxt) -> Option<@ty::TraitRef>\n {\n@@ -436,7 +436,7 @@ pub fn get_impl_trait(cdata: cmd,\n     }\n }\n \n-pub fn get_impl_vtables(cdata: cmd,\n+pub fn get_impl_vtables(cdata: Cmd,\n                         id: ast::NodeId,\n                         tcx: ty::ctxt) -> typeck::impl_res\n {\n@@ -451,7 +451,7 @@ pub fn get_impl_vtables(cdata: cmd,\n }\n \n \n-pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n+pub fn get_impl_method(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n                        name: ast::ident) -> Option<ast::def_id> {\n     let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n     let mut found = None;\n@@ -470,22 +470,22 @@ pub fn get_symbol(data: @~[u8], id: ast::NodeId) -> ~str {\n }\n \n // Something that a name can resolve to.\n-pub enum def_like {\n-    dl_def(ast::def),\n-    dl_impl(ast::def_id),\n-    dl_field\n+pub enum DefLike {\n+    DlDef(ast::def),\n+    DlImpl(ast::def_id),\n+    DlField\n }\n \n-fn def_like_to_def(def_like: def_like) -> ast::def {\n+fn def_like_to_def(def_like: DefLike) -> ast::def {\n     match def_like {\n-        dl_def(def) => return def,\n-        dl_impl(*) => fail!(\"found impl in def_like_to_def\"),\n-        dl_field => fail!(\"found field in def_like_to_def\")\n+        DlDef(def) => return def,\n+        DlImpl(*) => fail!(\"found impl in def_like_to_def\"),\n+        DlField => fail!(\"found field in def_like_to_def\")\n     }\n }\n \n /// Iterates over the language items in the given crate.\n-pub fn each_lang_item(cdata: cmd, f: &fn(ast::NodeId, uint) -> bool) -> bool {\n+pub fn each_lang_item(cdata: Cmd, f: &fn(ast::NodeId, uint) -> bool) -> bool {\n     let root = reader::Doc(cdata.data);\n     let lang_items = reader::get_doc(root, tag_lang_items);\n     do reader::tagged_docs(lang_items, tag_lang_items_item) |item_doc| {\n@@ -501,10 +501,10 @@ pub fn each_lang_item(cdata: cmd, f: &fn(ast::NodeId, uint) -> bool) -> bool {\n \n struct EachItemContext<'self> {\n     intr: @ident_interner,\n-    cdata: cmd,\n+    cdata: Cmd,\n     get_crate_data: GetCrateDataCb<'self>,\n     path_builder: &'self mut ~str,\n-    callback: &'self fn(&str, def_like, ast::visibility) -> bool,\n+    callback: &'self fn(&str, DefLike, ast::visibility) -> bool,\n }\n \n impl<'self> EachItemContext<'self> {\n@@ -533,7 +533,7 @@ impl<'self> EachItemContext<'self> {\n                                  -> bool {\n         let def_like = item_to_def_like(doc, def_id, self.cdata.cnum);\n         match def_like {\n-            dl_def(def) => {\n+            DlDef(def) => {\n                 debug!(\"(iterating over each item of a module) processing \\\n                         `%s` (def %?)\",\n                        *self.path_builder,\n@@ -703,10 +703,10 @@ impl<'self> EachItemContext<'self> {\n }\n \n fn each_child_of_item_or_crate(intr: @ident_interner,\n-                               cdata: cmd,\n+                               cdata: Cmd,\n                                item_doc: ebml::Doc,\n                                get_crate_data: GetCrateDataCb,\n-                               callback: &fn(def_like, ast::ident)) {\n+                               callback: &fn(DefLike, ast::ident)) {\n     // Iterate over all children.\n     let _ = do reader::tagged_docs(item_doc, tag_mod_child) |child_info_doc| {\n         let child_def_id = reader::with_doc_data(child_info_doc,\n@@ -826,10 +826,10 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n \n /// Iterates over each child of the given item.\n pub fn each_child_of_item(intr: @ident_interner,\n-                          cdata: cmd,\n+                          cdata: Cmd,\n                           id: ast::NodeId,\n                           get_crate_data: GetCrateDataCb,\n-                          callback: &fn(def_like, ast::ident)) {\n+                          callback: &fn(DefLike, ast::ident)) {\n     // Find the item.\n     let root_doc = reader::Doc(cdata.data);\n     let items = reader::get_doc(root_doc, tag_items);\n@@ -847,9 +847,9 @@ pub fn each_child_of_item(intr: @ident_interner,\n \n /// Iterates over all the top-level crate items.\n pub fn each_top_level_item_of_crate(intr: @ident_interner,\n-                                    cdata: cmd,\n+                                    cdata: Cmd,\n                                     get_crate_data: GetCrateDataCb,\n-                                    callback: &fn(def_like, ast::ident)) {\n+                                    callback: &fn(DefLike, ast::ident)) {\n     let root_doc = reader::Doc(cdata.data);\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n     let crate_items_doc = reader::get_doc(misc_info_doc,\n@@ -862,7 +862,7 @@ pub fn each_top_level_item_of_crate(intr: @ident_interner,\n                                 callback)\n }\n \n-pub fn get_item_path(cdata: cmd, id: ast::NodeId) -> ast_map::path {\n+pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> ast_map::path {\n     item_path(lookup_item(id, cdata.data))\n }\n \n@@ -872,7 +872,7 @@ pub type decode_inlined_item<'self> = &'self fn(\n     path: ast_map::path,\n     par_doc: ebml::Doc) -> Option<ast::inlined_item>;\n \n-pub fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt,\n+pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt,\n                           id: ast::NodeId,\n                           decode_inlined_item: decode_inlined_item)\n                        -> csearch::found_ast {\n@@ -900,7 +900,7 @@ pub fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt,\n     }\n }\n \n-pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n+pub fn get_enum_variants(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n                      tcx: ty::ctxt) -> ~[@ty::VariantInfo] {\n     let data = cdata.data;\n     let items = reader::get_doc(reader::Doc(data), tag_items);\n@@ -964,7 +964,7 @@ fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n     }\n }\n \n-fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml::Doc,\n+fn item_impl_methods(intr: @ident_interner, cdata: Cmd, item: ebml::Doc,\n                      tcx: ty::ctxt) -> ~[@ty::Method] {\n     let mut rslt = ~[];\n     do reader::tagged_docs(item, tag_item_impl_method) |doc| {\n@@ -977,7 +977,7 @@ fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml::Doc,\n }\n \n /// Returns information about the given implementation.\n-pub fn get_impl(intr: @ident_interner, cdata: cmd, impl_id: ast::NodeId,\n+pub fn get_impl(intr: @ident_interner, cdata: Cmd, impl_id: ast::NodeId,\n                tcx: ty::ctxt)\n                 -> ty::Impl {\n     let data = cdata.data;\n@@ -994,7 +994,7 @@ pub fn get_impl(intr: @ident_interner, cdata: cmd, impl_id: ast::NodeId,\n \n pub fn get_method_name_and_explicit_self(\n     intr: @ident_interner,\n-    cdata: cmd,\n+    cdata: Cmd,\n     id: ast::NodeId) -> (ast::ident, ast::explicit_self_)\n {\n     let method_doc = lookup_item(id, cdata.data);\n@@ -1003,7 +1003,7 @@ pub fn get_method_name_and_explicit_self(\n     (name, explicit_self)\n }\n \n-pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n+pub fn get_method(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n                   tcx: ty::ctxt) -> ty::Method\n {\n     let method_doc = lookup_item(id, cdata.data);\n@@ -1042,7 +1042,7 @@ pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n     )\n }\n \n-pub fn get_trait_method_def_ids(cdata: cmd,\n+pub fn get_trait_method_def_ids(cdata: Cmd,\n                                 id: ast::NodeId) -> ~[ast::def_id] {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n@@ -1054,7 +1054,7 @@ pub fn get_trait_method_def_ids(cdata: cmd,\n     result\n }\n \n-pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n+pub fn get_provided_trait_methods(intr: @ident_interner, cdata: Cmd,\n                                   id: ast::NodeId, tcx: ty::ctxt) ->\n         ~[@ty::Method] {\n     let data = cdata.data;\n@@ -1075,7 +1075,7 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n }\n \n /// Returns the supertraits of the given trait.\n-pub fn get_supertraits(cdata: cmd, id: ast::NodeId, tcx: ty::ctxt)\n+pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n                     -> ~[@ty::TraitRef] {\n     let mut results = ~[];\n     let item_doc = lookup_item(id, cdata.data);\n@@ -1092,7 +1092,7 @@ pub fn get_supertraits(cdata: cmd, id: ast::NodeId, tcx: ty::ctxt)\n     return results;\n }\n \n-pub fn get_type_name_if_impl(cdata: cmd,\n+pub fn get_type_name_if_impl(cdata: Cmd,\n                              node_id: ast::NodeId) -> Option<ast::ident> {\n     let item = lookup_item(node_id, cdata.data);\n     if item_family(item) != Impl {\n@@ -1109,7 +1109,7 @@ pub fn get_type_name_if_impl(cdata: cmd,\n }\n \n pub fn get_static_methods_if_impl(intr: @ident_interner,\n-                                  cdata: cmd,\n+                                  cdata: Cmd,\n                                   node_id: ast::NodeId)\n                                -> Option<~[StaticMethodInfo]> {\n     let item = lookup_item(node_id, cdata.data);\n@@ -1156,7 +1156,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n     return Some(static_impl_methods);\n }\n \n-pub fn get_item_attrs(cdata: cmd,\n+pub fn get_item_attrs(cdata: Cmd,\n                       node_id: ast::NodeId,\n                       f: &fn(~[@ast::MetaItem])) {\n \n@@ -1179,7 +1179,7 @@ fn struct_field_family_to_visibility(family: Family) -> ast::visibility {\n     }\n }\n \n-pub fn get_struct_fields(intr: @ident_interner, cdata: cmd, id: ast::NodeId)\n+pub fn get_struct_fields(intr: @ident_interner, cdata: Cmd, id: ast::NodeId)\n     -> ~[ty::field_ty] {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n@@ -1209,7 +1209,7 @@ pub fn get_struct_fields(intr: @ident_interner, cdata: cmd, id: ast::NodeId)\n     result\n }\n \n-pub fn get_item_visibility(cdata: cmd, id: ast::NodeId)\n+pub fn get_item_visibility(cdata: Cmd, id: ast::NodeId)\n                         -> ast::visibility {\n     item_visibility(lookup_item(id, cdata.data))\n }\n@@ -1308,7 +1308,7 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n             assert_eq!(meta_items.len(), 1u);\n             let meta_item = meta_items[0];\n             attrs.push(\n-                codemap::spanned {\n+                codemap::Spanned {\n                     node: ast::Attribute_ {\n                         style: ast::AttrOuter,\n                         value: meta_item,\n@@ -1350,15 +1350,15 @@ pub fn get_crate_attributes(data: @~[u8]) -> ~[ast::Attribute] {\n }\n \n #[deriving(Clone)]\n-pub struct crate_dep {\n+pub struct CrateDep {\n     cnum: ast::CrateNum,\n     name: ast::ident,\n     vers: @str,\n     hash: @str\n }\n \n-pub fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n-    let mut deps: ~[crate_dep] = ~[];\n+pub fn get_crate_deps(data: @~[u8]) -> ~[CrateDep] {\n+    let mut deps: ~[CrateDep] = ~[];\n     let cratedoc = reader::Doc(data);\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n@@ -1367,7 +1367,7 @@ pub fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n         d.as_str_slice().to_managed()\n     }\n     do reader::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n-        deps.push(crate_dep {cnum: crate_num,\n+        deps.push(CrateDep {cnum: crate_num,\n                   name: token::str_to_ident(docstr(depdoc, tag_crate_dep_name)),\n                   vers: docstr(depdoc, tag_crate_dep_vers),\n                   hash: docstr(depdoc, tag_crate_dep_hash)});\n@@ -1419,7 +1419,7 @@ pub fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n // external crates - if those types further refer to types in other crates\n // then we must translate the crate number from that encoded in the external\n // crate to the correct local crate number.\n-pub fn translate_def_id(cdata: cmd, did: ast::def_id) -> ast::def_id {\n+pub fn translate_def_id(cdata: Cmd, did: ast::def_id) -> ast::def_id {\n     if did.crate == ast::LOCAL_CRATE {\n         return ast::def_id { crate: cdata.cnum, node: did.node };\n     }\n@@ -1430,7 +1430,7 @@ pub fn translate_def_id(cdata: cmd, did: ast::def_id) -> ast::def_id {\n     }\n }\n \n-pub fn get_link_args_for_crate(cdata: cmd) -> ~[~str] {\n+pub fn get_link_args_for_crate(cdata: Cmd) -> ~[~str] {\n     let link_args = reader::get_doc(reader::Doc(cdata.data), tag_link_args);\n     let mut result = ~[];\n     do reader::tagged_docs(link_args, tag_link_args_arg) |arg_doc| {\n@@ -1440,15 +1440,15 @@ pub fn get_link_args_for_crate(cdata: cmd) -> ~[~str] {\n     result\n }\n \n-pub fn each_impl(cdata: cmd, callback: &fn(ast::def_id)) {\n+pub fn each_impl(cdata: Cmd, callback: &fn(ast::def_id)) {\n     let impls_doc = reader::get_doc(reader::Doc(cdata.data), tag_impls);\n     let _ = do reader::tagged_docs(impls_doc, tag_impls_impl) |impl_doc| {\n         callback(item_def_id(impl_doc, cdata));\n         true\n     };\n }\n \n-pub fn each_implementation_for_type(cdata: cmd,\n+pub fn each_implementation_for_type(cdata: Cmd,\n                                     id: ast::NodeId,\n                                     callback: &fn(ast::def_id)) {\n     let item_doc = lookup_item(id, cdata.data);\n@@ -1460,7 +1460,7 @@ pub fn each_implementation_for_type(cdata: cmd,\n     };\n }\n \n-pub fn each_implementation_for_trait(cdata: cmd,\n+pub fn each_implementation_for_trait(cdata: Cmd,\n                                      id: ast::NodeId,\n                                      callback: &fn(ast::def_id)) {\n     let item_doc = lookup_item(id, cdata.data);\n@@ -1474,7 +1474,7 @@ pub fn each_implementation_for_trait(cdata: cmd,\n     };\n }\n \n-pub fn get_trait_of_method(cdata: cmd, id: ast::NodeId, tcx: ty::ctxt)\n+pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n                            -> Option<ast::def_id> {\n     let item_doc = lookup_item(id, cdata.data);\n     let parent_item_id = match item_parent_item(item_doc) {"}, {"sha": "c6efeaec9b33497ad82523edb729216ef5953ec8", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -1488,13 +1488,13 @@ fn encode_crate_deps(ecx: &EncodeContext,\n                      ebml_w: &mut writer::Encoder,\n                      cstore: &cstore::CStore) {\n     fn get_ordered_deps(ecx: &EncodeContext, cstore: &cstore::CStore)\n-                     -> ~[decoder::crate_dep] {\n-        type numdep = decoder::crate_dep;\n+                     -> ~[decoder::CrateDep] {\n+        type numdep = decoder::CrateDep;\n \n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps = ~[];\n         do cstore::iter_crate_data(cstore) |key, val| {\n-            let dep = decoder::crate_dep {cnum: key,\n+            let dep = decoder::CrateDep {cnum: key,\n                        name: ecx.tcx.sess.ident_of(val.name),\n                        vers: decoder::get_crate_vers(val.data),\n                        hash: decoder::get_crate_hash(val.data)};\n@@ -1645,7 +1645,7 @@ fn encode_misc_info(ecx: &EncodeContext,\n \n fn encode_crate_dep(ecx: &EncodeContext,\n                     ebml_w: &mut writer::Encoder,\n-                    dep: decoder::crate_dep) {\n+                    dep: decoder::CrateDep) {\n     ebml_w.start_tag(tag_crate_dep);\n     ebml_w.start_tag(tag_crate_dep_name);\n     let s = ecx.tcx.sess.str_of(dep.name);"}, {"sha": "b5ba9bb5648a2ee0d2cfc7fca9b69dc7c19e126f", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -16,7 +16,7 @@ use metadata::decoder;\n use metadata::encoder;\n use metadata::filesearch::{FileSearch, FileMatch, FileMatches, FileDoesntMatch};\n use metadata::filesearch;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::diagnostic::span_handler;\n use syntax::parse::token::ident_interner;\n use syntax::print::pprust;\n@@ -34,22 +34,22 @@ use std::str;\n use std::vec;\n use extra::flate;\n \n-pub enum os {\n-    os_macos,\n-    os_win32,\n-    os_linux,\n-    os_android,\n-    os_freebsd\n+pub enum Os {\n+    OsMacos,\n+    OsWin32,\n+    OsLinux,\n+    OsAndroid,\n+    OsFreebsd\n }\n \n pub struct Context {\n     diag: @mut span_handler,\n     filesearch: @FileSearch,\n-    span: span,\n+    span: Span,\n     ident: @str,\n     metas: ~[@ast::MetaItem],\n     hash: @str,\n-    os: os,\n+    os: Os,\n     is_static: bool,\n     intr: @ident_interner\n }\n@@ -73,11 +73,11 @@ fn find_library_crate(cx: &Context) -> Option<(~str, @~[u8])> {\n fn libname(cx: &Context) -> (~str, ~str) {\n     if cx.is_static { return (~\"lib\", ~\".rlib\"); }\n     let (dll_prefix, dll_suffix) = match cx.os {\n-        os_win32 => (win32::DLL_PREFIX, win32::DLL_SUFFIX),\n-        os_macos => (macos::DLL_PREFIX, macos::DLL_SUFFIX),\n-        os_linux => (linux::DLL_PREFIX, linux::DLL_SUFFIX),\n-        os_android => (android::DLL_PREFIX, android::DLL_SUFFIX),\n-        os_freebsd => (freebsd::DLL_PREFIX, freebsd::DLL_SUFFIX),\n+        OsWin32 => (win32::DLL_PREFIX, win32::DLL_SUFFIX),\n+        OsMacos => (macos::DLL_PREFIX, macos::DLL_SUFFIX),\n+        OsLinux => (linux::DLL_PREFIX, linux::DLL_SUFFIX),\n+        OsAndroid => (android::DLL_PREFIX, android::DLL_SUFFIX),\n+        OsFreebsd => (freebsd::DLL_PREFIX, freebsd::DLL_SUFFIX),\n     };\n \n     (dll_prefix.to_owned(), dll_suffix.to_owned())\n@@ -196,7 +196,7 @@ pub fn metadata_matches(extern_metas: &[@ast::MetaItem],\n     }\n }\n \n-fn get_metadata_section(os: os,\n+fn get_metadata_section(os: Os,\n                         filename: &Path) -> Option<@~[u8]> {\n     unsafe {\n         let mb = do filename.with_c_str |buf| {\n@@ -212,7 +212,7 @@ fn get_metadata_section(os: os,\n             let name_buf = llvm::LLVMGetSectionName(si.llsi);\n             let name = str::raw::from_c_str(name_buf);\n             debug!(\"get_metadata_section: name %s\", name);\n-            if name == read_meta_section_name(os) {\n+            if read_meta_section_name(os) == name {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n                 let mut found = None;\n@@ -245,29 +245,29 @@ fn get_metadata_section(os: os,\n     }\n }\n \n-pub fn meta_section_name(os: os) -> ~str {\n+pub fn meta_section_name(os: Os) -> &'static str {\n     match os {\n-      os_macos => ~\"__DATA,__note.rustc\",\n-      os_win32 => ~\".note.rustc\",\n-      os_linux => ~\".note.rustc\",\n-      os_android => ~\".note.rustc\",\n-      os_freebsd => ~\".note.rustc\"\n+        OsMacos => \"__DATA,__note.rustc\",\n+        OsWin32 => \".note.rustc\",\n+        OsLinux => \".note.rustc\",\n+        OsAndroid => \".note.rustc\",\n+        OsFreebsd => \".note.rustc\"\n     }\n }\n \n-pub fn read_meta_section_name(os: os) -> ~str {\n+pub fn read_meta_section_name(os: Os) -> &'static str {\n     match os {\n-      os_macos => ~\"__note.rustc\",\n-      os_win32 => ~\".note.rustc\",\n-      os_linux => ~\".note.rustc\",\n-      os_android => ~\".note.rustc\",\n-      os_freebsd => ~\".note.rustc\"\n+        OsMacos => \"__note.rustc\",\n+        OsWin32 => \".note.rustc\",\n+        OsLinux => \".note.rustc\",\n+        OsAndroid => \".note.rustc\",\n+        OsFreebsd => \".note.rustc\"\n     }\n }\n \n // A diagnostic function for dumping crate metadata to an output stream\n pub fn list_file_metadata(intr: @ident_interner,\n-                          os: os,\n+                          os: Os,\n                           path: &Path,\n                           out: @io::Writer) {\n     match get_metadata_section(os, path) {"}, {"sha": "e38ac4feb9cef98938ec1e221aee155a50de7fa5", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -33,7 +33,7 @@ use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::inlined_item_utils;\n use syntax::ast_util;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::codemap;\n use syntax::fold::*;\n use syntax::fold;\n@@ -214,7 +214,7 @@ impl ExtendedDecodeContext {\n         assert_eq!(did.crate, ast::LOCAL_CRATE);\n         ast::def_id { crate: ast::LOCAL_CRATE, node: self.tr_id(did.node) }\n     }\n-    pub fn tr_span(&self, _span: span) -> span {\n+    pub fn tr_span(&self, _span: Span) -> Span {\n         codemap::dummy_sp() // FIXME (#1972): handle span properly\n     }\n }\n@@ -231,8 +231,8 @@ impl tr for ast::def_id {\n     }\n }\n \n-impl tr for span {\n-    fn tr(&self, xcx: @ExtendedDecodeContext) -> span {\n+impl tr for Span {\n+    fn tr(&self, xcx: @ExtendedDecodeContext) -> Span {\n         xcx.tr_span(*self)\n     }\n }\n@@ -302,9 +302,9 @@ fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n         let stmts_sans_items = do blk.stmts.iter().filter_map |stmt| {\n             match stmt.node {\n               ast::stmt_expr(_, _) | ast::stmt_semi(_, _) |\n-              ast::stmt_decl(@codemap::spanned { node: ast::decl_local(_), span: _}, _)\n+              ast::stmt_decl(@codemap::Spanned { node: ast::decl_local(_), span: _}, _)\n                 => Some(*stmt),\n-              ast::stmt_decl(@codemap::spanned { node: ast::decl_item(_), span: _}, _)\n+              ast::stmt_decl(@codemap::Spanned { node: ast::decl_item(_), span: _}, _)\n                 => None,\n               ast::stmt_mac(*) => fail!(\"unexpanded macro in astencode\")\n             }\n@@ -1255,7 +1255,7 @@ fn decode_item_ast(par_doc: ebml::Doc) -> @ast::item {\n trait fake_ext_ctxt {\n     fn cfg(&self) -> ast::CrateConfig;\n     fn parse_sess(&self) -> @mut parse::ParseSess;\n-    fn call_site(&self) -> span;\n+    fn call_site(&self) -> Span;\n     fn ident_of(&self, st: &str) -> ast::ident;\n }\n \n@@ -1266,8 +1266,8 @@ type fake_session = @mut parse::ParseSess;\n impl fake_ext_ctxt for fake_session {\n     fn cfg(&self) -> ast::CrateConfig { ~[] }\n     fn parse_sess(&self) -> @mut parse::ParseSess { *self }\n-    fn call_site(&self) -> span {\n-        codemap::span {\n+    fn call_site(&self) -> Span {\n+        codemap::Span {\n             lo: codemap::BytePos(0),\n             hi: codemap::BytePos(0),\n             expn_info: None"}, {"sha": "029080ed26540cf908e7279943c8fbbd039a1cda", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -26,7 +26,7 @@ use middle::ty;\n use syntax::ast::{m_imm, m_mutbl};\n use syntax::ast;\n use syntax::ast_util;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::visit::Visitor;\n use syntax::visit;\n use util::ppaux::Repr;\n@@ -56,7 +56,7 @@ impl<'self> Visitor<CheckLoanCtxt<'self>> for CheckLoanVisitor {\n         check_loans_in_pat(self, p, e);\n     }\n     fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:span, n:ast::NodeId, e:CheckLoanCtxt) {\n+                b:&ast::Block, s:Span, n:ast::NodeId, e:CheckLoanCtxt) {\n         check_loans_in_fn(self, fk, fd, b, s, n, e);\n     }\n }\n@@ -82,7 +82,7 @@ pub fn check_loans(bccx: @BorrowckCtxt,\n \n enum MoveError {\n     MoveOk,\n-    MoveWhileBorrowed(/*loan*/@LoanPath, /*loan*/span)\n+    MoveWhileBorrowed(/*loan*/@LoanPath, /*loan*/Span)\n }\n \n impl<'self> CheckLoanCtxt<'self> {\n@@ -107,7 +107,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         }\n     }\n \n-    fn check_captured_variables(&self, closure_id: ast::NodeId, span: span) {\n+    fn check_captured_variables(&self, closure_id: ast::NodeId, span: Span) {\n         let cap_vars = self.bccx.capture_map.get(&closure_id);\n         for cap_var in cap_vars.iter() {\n             let var_id = ast_util::def_id_of_def(cap_var.def).node;\n@@ -311,7 +311,7 @@ impl<'self> CheckLoanCtxt<'self> {\n \n     pub fn check_if_path_is_moved(&self,\n                                   id: ast::NodeId,\n-                                  span: span,\n+                                  span: Span,\n                                   use_kind: MovedValueUseKind,\n                                   lp: @LoanPath) {\n         /*!\n@@ -669,7 +669,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         }\n     }\n \n-    fn check_move_out_from_id(&self, id: ast::NodeId, span: span) {\n+    fn check_move_out_from_id(&self, id: ast::NodeId, span: Span) {\n         do self.move_data.each_path_moved_by(id) |_, move_path| {\n             match self.analyze_move_out_from(id, move_path) {\n                 MoveOk => {}\n@@ -713,7 +713,7 @@ impl<'self> CheckLoanCtxt<'self> {\n                       _expr: @ast::expr,\n                       _callee: Option<@ast::expr>,\n                       _callee_id: ast::NodeId,\n-                      _callee_span: span,\n+                      _callee_span: Span,\n                       _args: &[@ast::expr]) {\n         // NB: This call to check for conflicting loans is not truly\n         // necessary, because the callee_id never issues new loans.\n@@ -729,7 +729,7 @@ fn check_loans_in_fn<'a>(visitor: &mut CheckLoanVisitor,\n                          fk: &visit::fn_kind,\n                          decl: &ast::fn_decl,\n                          body: &ast::Block,\n-                         sp: span,\n+                         sp: Span,\n                          id: ast::NodeId,\n                          this: CheckLoanCtxt<'a>) {\n     match *fk {\n@@ -749,7 +749,7 @@ fn check_loans_in_fn<'a>(visitor: &mut CheckLoanVisitor,\n \n     fn check_captured_variables(this: CheckLoanCtxt,\n                                 closure_id: ast::NodeId,\n-                                span: span) {\n+                                span: Span) {\n         let cap_vars = this.bccx.capture_map.get(&closure_id);\n         for cap_var in cap_vars.iter() {\n             let var_id = ast_util::def_id_of_def(cap_var.def).node;"}, {"sha": "c25655803a48c58c3e3cab69928e4a44e393c8df", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -19,13 +19,13 @@ use middle::moves;\n use middle::ty;\n use syntax::ast;\n use syntax::ast_util;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use util::ppaux::{UserString};\n \n pub fn gather_decl(bccx: @BorrowckCtxt,\n                    move_data: &mut MoveData,\n                    decl_id: ast::NodeId,\n-                   _decl_span: span,\n+                   _decl_span: Span,\n                    var_id: ast::NodeId) {\n     let loan_path = @LpVar(var_id);\n     move_data.add_move(bccx.tcx, loan_path, decl_id, Declared);\n@@ -86,7 +86,7 @@ pub fn gather_captures(bccx: @BorrowckCtxt,\n pub fn gather_assignment(bccx: @BorrowckCtxt,\n                          move_data: &mut MoveData,\n                          assignment_id: ast::NodeId,\n-                         assignment_span: span,\n+                         assignment_span: Span,\n                          assignee_loan_path: @LoanPath,\n                          assignee_id: ast::NodeId) {\n     move_data.add_assignment(bccx.tcx,"}, {"sha": "1776e041c834f865c93d4babc8b90ecec3059e8b", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -17,13 +17,13 @@ use mc = middle::mem_categorization;\n use middle::ty;\n use syntax::ast::{m_imm, m_mutbl};\n use syntax::ast;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use util::ppaux::{note_and_explain_region};\n \n pub fn guarantee_lifetime(bccx: @BorrowckCtxt,\n                           item_scope_id: ast::NodeId,\n                           root_scope_id: ast::NodeId,\n-                          span: span,\n+                          span: Span,\n                           cmt: mc::cmt,\n                           loan_region: ty::Region,\n                           loan_mutbl: LoanMutability) {\n@@ -52,7 +52,7 @@ struct GuaranteeLifetimeContext {\n     // longest scope for which we can root managed boxes\n     root_scope_id: ast::NodeId,\n \n-    span: span,\n+    span: Span,\n     loan_region: ty::Region,\n     loan_mutbl: LoanMutability,\n     cmt_original: mc::cmt"}, {"sha": "43bb278c94900a9ee0b7590f1cc71cbd409638af", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -28,7 +28,7 @@ use util::ppaux::{Repr};\n \n use syntax::ast;\n use syntax::ast_util::id_range;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::print::pprust;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -83,7 +83,7 @@ impl visit::Visitor<@mut GatherLoanCtxt> for GatherLoanVisitor {\n         gather_loans_in_block(self, b, e);\n     }\n     fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block,\n-                s:span, n:NodeId, e:@mut GatherLoanCtxt) {\n+                s:Span, n:NodeId, e:@mut GatherLoanCtxt) {\n         gather_loans_in_fn(self, fk, fd, b, s, n, e);\n     }\n     fn visit_stmt(&mut self, s:@stmt, e:@mut GatherLoanCtxt) {\n@@ -131,7 +131,7 @@ fn gather_loans_in_fn(v: &mut GatherLoanVisitor,\n                       fk: &fn_kind,\n                       decl: &ast::fn_decl,\n                       body: &ast::Block,\n-                      sp: span,\n+                      sp: Span,\n                       id: ast::NodeId,\n                       this: @mut GatherLoanCtxt) {\n     match fk {\n@@ -413,7 +413,7 @@ impl GatherLoanCtxt {\n     // dynamically that they are not freed.\n     pub fn guarantee_valid(&mut self,\n                            borrow_id: ast::NodeId,\n-                           borrow_span: span,\n+                           borrow_span: Span,\n                            cmt: mc::cmt,\n                            req_mutbl: LoanMutability,\n                            loan_region: ty::Region) {\n@@ -538,7 +538,7 @@ impl GatherLoanCtxt {\n         // }\n \n         fn check_mutability(bccx: @BorrowckCtxt,\n-                            borrow_span: span,\n+                            borrow_span: Span,\n                             cmt: mc::cmt,\n                             req_mutbl: LoanMutability) {\n             //! Implements the M-* rules in doc.rs."}, {"sha": "33b90cbe573165d681ca41da3ad33d0b19e44e9f", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -16,15 +16,15 @@ use middle::borrowck::*;\n use mc = middle::mem_categorization;\n use middle::ty;\n use syntax::ast::{m_imm, m_mutbl};\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n \n pub enum RestrictionResult {\n     Safe,\n     SafeIf(@LoanPath, ~[Restriction])\n }\n \n pub fn compute_restrictions(bccx: @BorrowckCtxt,\n-                            span: span,\n+                            span: Span,\n                             cmt: mc::cmt,\n                             restr: RestrictionSet) -> RestrictionResult {\n     let ctxt = RestrictionsContext {\n@@ -41,7 +41,7 @@ pub fn compute_restrictions(bccx: @BorrowckCtxt,\n \n struct RestrictionsContext {\n     bccx: @BorrowckCtxt,\n-    span: span,\n+    span: Span,\n     cmt_original: mc::cmt\n }\n "}, {"sha": "0c182286b069d0bf36317d3f15bce1a79fc36d24", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -26,7 +26,7 @@ use std::ops::{BitOr, BitAnd};\n use std::result::{Result};\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::visit;\n use syntax::visit::{Visitor,fn_kind};\n@@ -65,7 +65,7 @@ struct BorrowckVisitor;\n \n impl Visitor<@BorrowckCtxt> for BorrowckVisitor {\n     fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl,\n-                b:&Block, s:span, n:NodeId, e:@BorrowckCtxt) {\n+                b:&Block, s:Span, n:NodeId, e:@BorrowckCtxt) {\n         borrowck_fn(self, fk, fd, b, s, n, e);\n     }\n }\n@@ -127,7 +127,7 @@ fn borrowck_fn(v: &mut BorrowckVisitor,\n                fk: &visit::fn_kind,\n                decl: &ast::fn_decl,\n                body: &ast::Block,\n-               sp: span,\n+               sp: Span,\n                id: ast::NodeId,\n                this: @BorrowckCtxt) {\n     match fk {\n@@ -277,7 +277,7 @@ pub struct Loan {\n     restrictions: ~[Restriction],\n     gen_scope: ast::NodeId,\n     kill_scope: ast::NodeId,\n-    span: span,\n+    span: Span,\n }\n \n #[deriving(Eq, IterBytes)]\n@@ -454,7 +454,7 @@ pub enum bckerr_code {\n // that caused it\n #[deriving(Eq)]\n pub struct BckError {\n-    span: span,\n+    span: Span,\n     cmt: mc::cmt,\n     code: bckerr_code\n }\n@@ -516,7 +516,7 @@ impl BorrowckCtxt {\n \n     pub fn cat_def(&self,\n                    id: ast::NodeId,\n-                   span: span,\n+                   span: Span,\n                    ty: ty::t,\n                    def: ast::def)\n                    -> mc::cmt {\n@@ -550,7 +550,7 @@ impl BorrowckCtxt {\n     }\n \n     pub fn report_use_of_moved_value(&self,\n-                                     use_span: span,\n+                                     use_span: Span,\n                                      use_kind: MovedValueUseKind,\n                                      lp: &LoanPath,\n                                      move: &move_data::Move,\n@@ -631,7 +631,7 @@ impl BorrowckCtxt {\n     }\n \n     pub fn report_reassigned_immutable_variable(&self,\n-                                                span: span,\n+                                                span: Span,\n                                                 lp: &LoanPath,\n                                                 assign:\n                                                 &move_data::Assignment) {\n@@ -644,11 +644,11 @@ impl BorrowckCtxt {\n             fmt!(\"prior assignment occurs here\"));\n     }\n \n-    pub fn span_err(&self, s: span, m: &str) {\n+    pub fn span_err(&self, s: Span, m: &str) {\n         self.tcx.sess.span_err(s, m);\n     }\n \n-    pub fn span_note(&self, s: span, m: &str) {\n+    pub fn span_note(&self, s: Span, m: &str) {\n         self.tcx.sess.span_note(s, m);\n     }\n \n@@ -677,7 +677,7 @@ impl BorrowckCtxt {\n     }\n \n     pub fn report_aliasability_violation(&self,\n-                                         span: span,\n+                                         span: Span,\n                                          kind: AliasableViolationKind,\n                                          cause: mc::AliasableReason) {\n         let prefix = match kind {"}, {"sha": "353a06a759e691bb2190def42f7c989469368345", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -25,7 +25,7 @@ use middle::ty;\n use middle::typeck;\n use syntax::ast;\n use syntax::ast_util;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n use util::ppaux::Repr;\n@@ -135,7 +135,7 @@ pub struct Assignment {\n     id: ast::NodeId,\n \n     /// span of node where assignment occurs\n-    span: span,\n+    span: Span,\n }\n \n pub struct MoveDataFlowOperator;\n@@ -327,7 +327,7 @@ impl MoveData {\n                           tcx: ty::ctxt,\n                           lp: @LoanPath,\n                           assign_id: ast::NodeId,\n-                          span: span,\n+                          span: Span,\n                           assignee_id: ast::NodeId) {\n         /*!\n          * Adds a new record for an assignment to `lp` that occurs at"}, {"sha": "6a4570474f0371355ef3564baa1155b7f21ab19d", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -85,7 +85,7 @@ pub fn check_pat(v: &mut CheckCrateVisitor, p: @pat, _is_const: bool) {\n     fn is_str(e: @expr) -> bool {\n         match e.node {\n             expr_vstore(\n-                @expr { node: expr_lit(@codemap::spanned {\n+                @expr { node: expr_lit(@codemap::Spanned {\n                     node: lit_str(_),\n                     _}),\n                        _ },\n@@ -120,7 +120,7 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n                           \"disallowed operator in constant expression\");\n             return;\n           }\n-          expr_lit(@codemap::spanned {node: lit_str(_), _}) => { }\n+          expr_lit(@codemap::Spanned {node: lit_str(_), _}) => { }\n           expr_binary(*) | expr_unary(*) => {\n             if method_map.contains_key(&e.id) {\n                 sess.span_err(e.span, \"user-defined operators are not \\\n@@ -200,15 +200,15 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n         }\n     }\n     match e.node {\n-      expr_lit(@codemap::spanned {node: lit_int(v, t), _}) => {\n+      expr_lit(@codemap::Spanned {node: lit_int(v, t), _}) => {\n         if t != ty_char {\n             if (v as u64) > ast_util::int_ty_max(\n                 if t == ty_i { sess.targ_cfg.int_type } else { t }) {\n                 sess.span_err(e.span, \"literal out of range for its type\");\n             }\n         }\n       }\n-      expr_lit(@codemap::spanned {node: lit_uint(v, t), _}) => {\n+      expr_lit(@codemap::Spanned {node: lit_uint(v, t), _}) => {\n         if v > ast_util::uint_ty_max(\n             if t == ty_u { sess.targ_cfg.uint_type } else { t }) {\n             sess.span_err(e.span, \"literal out of range for its type\");"}, {"sha": "1996f84591465187f8b7a6178731fc9b4fdd51de", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -24,7 +24,7 @@ use std::vec;\n use extra::sort;\n use syntax::ast::*;\n use syntax::ast_util::{unguarded_pat, walk_pat};\n-use syntax::codemap::{span, dummy_sp, spanned};\n+use syntax::codemap::{Span, dummy_sp, Spanned};\n use syntax::visit;\n use syntax::visit::{Visitor,fn_kind};\n \n@@ -45,7 +45,7 @@ impl Visitor<()> for CheckMatchVisitor {\n     fn visit_local(&mut self, l:@Local, e:()) {\n         check_local(self, self.cx, l, e);\n     }\n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:span, n:NodeId, e:()) {\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:Span, n:NodeId, e:()) {\n         check_fn(self, self.cx, fk, fd, b, s, n, e);\n     }\n }\n@@ -160,7 +160,7 @@ pub fn raw_pat(p: @pat) -> @pat {\n     }\n }\n \n-pub fn check_exhaustive(cx: &MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n+pub fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@pat]) {\n     assert!((!pats.is_empty()));\n     let ext = match is_useful(cx, &pats.map(|p| ~[*p]), [wild()]) {\n         not_useful => {\n@@ -821,7 +821,7 @@ pub fn check_fn(v: &mut CheckMatchVisitor,\n                 kind: &visit::fn_kind,\n                 decl: &fn_decl,\n                 body: &Block,\n-                sp: span,\n+                sp: Span,\n                 id: NodeId,\n                 s: ()) {\n     visit::walk_fn(v, kind, decl, body, sp, id, s);\n@@ -850,7 +850,7 @@ pub fn is_refutable(cx: &MatchCheckCtxt, pat: &pat) -> bool {\n         is_refutable(cx, sub)\n       }\n       pat_wild | pat_ident(_, _, None) => { false }\n-      pat_lit(@expr {node: expr_lit(@spanned { node: lit_nil, _}), _}) => {\n+      pat_lit(@expr {node: expr_lit(@Spanned { node: lit_nil, _}), _}) => {\n         // \"()\"\n         false\n       }"}, {"sha": "825f53c9e4287c59258d03751e3fe67b74faf456", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -19,7 +19,7 @@ use util::ppaux;\n use syntax::ast::{deref, expr_call, expr_inline_asm, expr_method_call};\n use syntax::ast::{expr_unary, unsafe_fn, expr_path};\n use syntax::ast;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::visit::{fk_item_fn, fk_method};\n use syntax::visit;\n use syntax::visit::{Visitor,fn_kind};\n@@ -53,7 +53,7 @@ struct EffectCheckVisitor {\n }\n \n impl EffectCheckVisitor {\n-    fn require_unsafe(&mut self, span: span, description: &str) {\n+    fn require_unsafe(&mut self, span: Span, description: &str) {\n         match self.context.unsafe_context {\n             SafeContext => {\n                 // Report an error.\n@@ -73,7 +73,7 @@ impl EffectCheckVisitor {\n \n impl Visitor<()> for EffectCheckVisitor {\n     fn visit_fn(&mut self, fn_kind:&fn_kind, fn_decl:&fn_decl,\n-                block:&Block, span:span, node_id:NodeId, _:()) {\n+                block:&Block, span:Span, node_id:NodeId, _:()) {\n \n             let (is_item_fn, is_unsafe_fn) = match *fn_kind {\n                 fk_item_fn(_, _, purity, _) => (true, purity == unsafe_fn),"}, {"sha": "8aa4584e0427e0354a6898b1c6e4f5069ce4eefe", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -14,7 +14,7 @@ use driver::session::Session;\n use syntax::ast::{Crate, NodeId, item, item_fn};\n use syntax::ast_map;\n use syntax::attr;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -26,17 +26,17 @@ struct EntryContext {\n     ast_map: ast_map::map,\n \n     // The top-level function called 'main'\n-    main_fn: Option<(NodeId, span)>,\n+    main_fn: Option<(NodeId, Span)>,\n \n     // The function that has attribute named 'main'\n-    attr_main_fn: Option<(NodeId, span)>,\n+    attr_main_fn: Option<(NodeId, Span)>,\n \n     // The function that has the attribute 'start' on it\n-    start_fn: Option<(NodeId, span)>,\n+    start_fn: Option<(NodeId, Span)>,\n \n     // The functions that one might think are 'main' but aren't, e.g.\n     // main functions not defined at the top level. For diagnostics.\n-    non_main_fns: ~[(NodeId, span)],\n+    non_main_fns: ~[(NodeId, Span)],\n }\n \n struct EntryVisitor;\n@@ -51,7 +51,7 @@ pub fn find_entry_point(session: Session, crate: &Crate, ast_map: ast_map::map)\n \n     // FIXME #4404 android JNI hacks\n     if *session.building_library &&\n-        session.targ_cfg.os != session::os_android {\n+        session.targ_cfg.os != session::OsAndroid {\n         // No need to find a main function\n         return;\n     }\n@@ -157,7 +157,7 @@ fn configure_main(ctxt: @mut EntryContext) {\n         } else {\n             // If we *are* building a library, then we're on android where we still might\n             // optionally want to translate main $4404\n-            assert_eq!(this.session.targ_cfg.os, session::os_android);\n+            assert_eq!(this.session.targ_cfg.os, session::OsAndroid);\n         }\n     }\n }"}, {"sha": "0968ebc22df8fd9f4611b34cac214479d89dfef3", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -16,7 +16,7 @@ use middle::resolve;\n use middle::ty;\n \n use std::hashmap::HashMap;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::{ast, ast_util};\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -27,7 +27,7 @@ use syntax::ast::{item};\n #[deriving(Encodable, Decodable)]\n pub struct freevar_entry {\n     def: ast::def, //< The variable being accessed free.\n-    span: span     //< First span where it is accessed (there can be multiple)\n+    span: Span     //< First span where it is accessed (there can be multiple)\n }\n pub type freevar_info = @~[@freevar_entry];\n pub type freevar_map = @mut HashMap<ast::NodeId, freevar_info>;\n@@ -110,7 +110,7 @@ struct AnnotateFreevarsVisitor {\n \n impl Visitor<()> for AnnotateFreevarsVisitor {\n     fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                blk:&ast::Block, s:span, nid:ast::NodeId, _:()) {\n+                blk:&ast::Block, s:Span, nid:ast::NodeId, _:()) {\n         let vars = collect_freevars(self.def_map, blk);\n         self.freevars.insert(nid, vars);\n         visit::walk_fn(self, fk, fd, blk, s, nid, ());"}, {"sha": "0beb3d25064767d12568cd91bc846f0168e78afb", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -18,7 +18,7 @@ use util::ppaux::UserString;\n \n use syntax::ast::*;\n use syntax::attr;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::opt_vec;\n use syntax::print::pprust::expr_to_str;\n use syntax::{visit,ast_util};\n@@ -65,7 +65,7 @@ impl Visitor<Context> for KindAnalysisVisitor {\n         check_expr(self, ex, e);\n     }\n \n-    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&fn_decl, b:&Block, s:span, n:NodeId, e:Context) {\n+    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&fn_decl, b:&Block, s:Span, n:NodeId, e:Context) {\n         check_fn(self, fk, fd, b, s, n, e);\n     }\n \n@@ -91,7 +91,7 @@ pub fn check_crate(tcx: ty::ctxt,\n }\n \n fn check_struct_safe_for_destructor(cx: Context,\n-                                    span: span,\n+                                    span: Span,\n                                     struct_did: def_id) {\n     let struct_tpt = ty::lookup_item_type(cx.tcx, struct_did);\n     if !struct_tpt.generics.has_type_params() {\n@@ -245,7 +245,7 @@ fn check_fn(\n     fk: &visit::fn_kind,\n     decl: &fn_decl,\n     body: &Block,\n-    sp: span,\n+    sp: Span,\n     fn_id: NodeId,\n     cx: Context) {\n \n@@ -364,7 +364,7 @@ pub fn check_builtin_bounds(cx: Context, ty: ty::t, bounds: ty::BuiltinBounds,\n \n pub fn check_typaram_bounds(cx: Context,\n                     _type_parameter_id: NodeId,\n-                    sp: span,\n+                    sp: Span,\n                     ty: ty::t,\n                     type_param_def: &ty::TypeParameterDef)\n {\n@@ -378,7 +378,7 @@ pub fn check_typaram_bounds(cx: Context,\n     }\n }\n \n-pub fn check_freevar_bounds(cx: Context, sp: span, ty: ty::t,\n+pub fn check_freevar_bounds(cx: Context, sp: Span, ty: ty::t,\n                             bounds: ty::BuiltinBounds, referenced_ty: Option<ty::t>)\n {\n     do check_builtin_bounds(cx, ty, bounds) |missing| {\n@@ -401,7 +401,7 @@ pub fn check_freevar_bounds(cx: Context, sp: span, ty: ty::t,\n     }\n }\n \n-pub fn check_trait_cast_bounds(cx: Context, sp: span, ty: ty::t,\n+pub fn check_trait_cast_bounds(cx: Context, sp: Span, ty: ty::t,\n                                bounds: ty::BuiltinBounds) {\n     do check_builtin_bounds(cx, ty, bounds) |missing| {\n         cx.tcx.sess.span_err(sp,\n@@ -426,7 +426,7 @@ fn is_nullary_variant(cx: Context, ex: @expr) -> bool {\n     }\n }\n \n-fn check_imm_free_var(cx: Context, def: def, sp: span) {\n+fn check_imm_free_var(cx: Context, def: def, sp: Span) {\n     match def {\n         def_local(_, is_mutbl) => {\n             if is_mutbl {\n@@ -446,7 +446,7 @@ fn check_imm_free_var(cx: Context, def: def, sp: span) {\n     }\n }\n \n-fn check_copy(cx: Context, ty: ty::t, sp: span, reason: &str) {\n+fn check_copy(cx: Context, ty: ty::t, sp: Span, reason: &str) {\n     debug!(\"type_contents(%s)=%s\",\n            ty_to_str(cx.tcx, ty),\n            ty::type_contents(cx.tcx, ty).to_str());\n@@ -458,7 +458,7 @@ fn check_copy(cx: Context, ty: ty::t, sp: span, reason: &str) {\n     }\n }\n \n-pub fn check_send(cx: Context, ty: ty::t, sp: span) -> bool {\n+pub fn check_send(cx: Context, ty: ty::t, sp: Span) -> bool {\n     if !ty::type_is_sendable(cx.tcx, ty) {\n         cx.tcx.sess.span_err(\n             sp, fmt!(\"value has non-sendable type `%s`\",\n@@ -470,7 +470,7 @@ pub fn check_send(cx: Context, ty: ty::t, sp: span) -> bool {\n }\n \n // note: also used from middle::typeck::regionck!\n-pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n+pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: Span) -> bool {\n     if !ty::type_is_static(tcx, ty) {\n         match ty::get(ty).sty {\n           ty::ty_param(*) => {"}, {"sha": "d60781dcc097dd0a711bece340dba425234a5169", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -28,7 +28,7 @@ use extra::smallintmap::SmallIntMap;\n use syntax::ast_map;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::codemap;\n use syntax::parse::token;\n use syntax::{ast, ast_util, visit};\n@@ -135,7 +135,7 @@ enum AttributedNode<'self> {\n \n #[deriving(Eq)]\n enum LintSource {\n-    Node(span),\n+    Node(Span),\n     Default,\n     CommandLine\n }\n@@ -304,7 +304,7 @@ pub fn get_lint_dict() -> LintDict {\n trait OuterLint {\n     fn process_item(@mut self, i:@ast::item, e:@mut Context);\n     fn process_fn(@mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                  b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context);\n+                  b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context);\n \n     // Returned inner variant will not proceed past subitems.\n     // Supports decomposition of simple lints into subitem-traversing\n@@ -319,7 +319,7 @@ trait InnerLint {\n                   function_kind: &visit::fn_kind,\n                   function_declaration: &ast::fn_decl,\n                   function_body: &ast::Block,\n-                  sp: span,\n+                  sp: Span,\n                   id: ast::NodeId,\n                   env: @mut Context);\n }\n@@ -332,7 +332,7 @@ impl<V:Visitor<@mut Context>> InnerLint for V {\n         visit::walk_crate(self, crate, env);\n     }\n     fn descend_fn(@mut self, fk: &visit::fn_kind, fd: &ast::fn_decl, fb: &ast::Block,\n-                  sp: span, id: ast::NodeId, env: @mut Context) {\n+                  sp: Span, id: ast::NodeId, env: @mut Context) {\n         visit::walk_fn(self, fk, fd, fb, sp, id, env);\n     }\n }\n@@ -409,7 +409,7 @@ impl Context {\n         fail!(\"unregistered lint %?\", lint);\n     }\n \n-    fn span_lint(&self, lint: lint, span: span, msg: &str) {\n+    fn span_lint(&self, lint: lint, span: Span, msg: &str) {\n         let (level, src) = match self.curr.find(&(lint as uint)) {\n             None => { return }\n             Some(&(warn, src)) => (self.get_level(warnings), src),\n@@ -617,7 +617,7 @@ trait SubitemStoppableVisitor : Visitor<@mut Context> {\n     }\n \n     fn visit_fn_action(&mut self, _fk:&visit::fn_kind, _fd:&ast::fn_decl,\n-                       _b:&ast::Block, _s:span, _n:ast::NodeId, _e:@mut Context) {\n+                       _b:&ast::Block, _s:Span, _n:ast::NodeId, _e:@mut Context) {\n         // fill in with particular action without recursion if desired\n     }\n \n@@ -641,7 +641,7 @@ trait SubitemStoppableVisitor : Visitor<@mut Context> {\n     }\n \n     fn OVERRIDE_visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context) {\n+                b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n         if self.is_running_on_items() {\n             self.visit_fn_action(fk, fd, b, s, n, e);\n             visit::walk_fn(self, fk, fd, b, s, n, e);\n@@ -670,7 +670,7 @@ impl Visitor<@mut Context> for WhileTrueLintVisitor {\n     }\n \n     fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context) {\n+                b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n         self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n     }\n \n@@ -679,7 +679,7 @@ impl Visitor<@mut Context> for WhileTrueLintVisitor {\n             match e.node {\n                 ast::expr_while(cond, _) => {\n                     match cond.node {\n-                        ast::expr_lit(@codemap::spanned {\n+                        ast::expr_lit(@codemap::Spanned {\n                             node: ast::lit_bool(true), _}) =>\n                         {\n                             cx.span_lint(while_true, e.span,\n@@ -703,7 +703,7 @@ macro_rules! outer_lint_boilerplate_impl(\n                 self.visit_item_action(i, e);\n             }\n             fn process_fn(@mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                          b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context) {\n+                          b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n                 self.visit_fn_action(fk, fd, b, s, n, e);\n             }\n             fn inner_variant(@mut self) -> @mut InnerLint {\n@@ -834,7 +834,7 @@ impl Visitor<@mut Context> for TypeLimitsLintVisitor {\n     }\n \n     fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context) {\n+                b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n         self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n     }\n \n@@ -905,7 +905,7 @@ fn check_item_ctypes(cx: &Context, it: &ast::item) {\n     }\n }\n \n-fn check_type_for_lint(cx: &Context, lint: lint, span: span, ty: ty::t) {\n+fn check_type_for_lint(cx: &Context, lint: lint, span: Span, ty: ty::t) {\n     if cx.get_level(lint) == allow { return }\n \n     let mut n_box = 0;\n@@ -932,7 +932,7 @@ fn check_type_for_lint(cx: &Context, lint: lint, span: span, ty: ty::t) {\n     }\n }\n \n-fn check_type(cx: &Context, span: span, ty: ty::t) {\n+fn check_type(cx: &Context, span: Span, ty: ty::t) {\n     let xs = [managed_heap_memory, owned_heap_memory, heap_memory];\n     for lint in xs.iter() {\n         check_type_for_lint(cx, *lint, span, ty);\n@@ -975,7 +975,7 @@ impl Visitor<@mut Context> for HeapLintVisitor {\n     }\n \n     fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context) {\n+                b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n         self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n     }\n \n@@ -1006,7 +1006,7 @@ impl Visitor<@mut Context> for PathStatementLintVisitor {\n     }\n \n     fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context) {\n+                b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n         self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n     }\n \n@@ -1044,7 +1044,7 @@ fn check_item_non_camel_case_types(cx: &Context, it: &ast::item) {\n             !ident.contains_char('_')\n     }\n \n-    fn check_case(cx: &Context, sort: &str, ident: ast::ident, span: span) {\n+    fn check_case(cx: &Context, sort: &str, ident: ast::ident, span: Span) {\n         if !is_camel_case(cx.tcx, ident) {\n             cx.span_lint(\n                 non_camel_case_types, span,\n@@ -1099,7 +1099,7 @@ impl Visitor<@mut Context> for UnusedUnsafeLintVisitor {\n     }\n \n     fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context) {\n+                b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n         self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n     }\n \n@@ -1157,7 +1157,7 @@ impl SubitemStoppableVisitor for UnusedMutLintVisitor {\n     fn is_running_on_items(&mut self) -> bool { !self.stopping_on_items }\n \n     fn visit_fn_action(&mut self, _a:&visit::fn_kind, fd:&ast::fn_decl,\n-                       _b:&ast::Block, _c:span, _d:ast::NodeId, cx:@mut Context) {\n+                       _b:&ast::Block, _c:Span, _d:ast::NodeId, cx:@mut Context) {\n             self.visit_fn_decl(cx, fd);\n     }\n }\n@@ -1168,7 +1168,7 @@ impl Visitor<@mut Context> for UnusedMutLintVisitor {\n     }\n \n     fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context) {\n+                b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n         self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n     }\n \n@@ -1225,7 +1225,7 @@ impl Visitor<@mut Context> for UnnecessaryAllocationLintVisitor {\n     }\n \n     fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context) {\n+                b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n         self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n     }\n \n@@ -1243,7 +1243,7 @@ impl UnnecessaryAllocationLintVisitor {\n             ast::expr_vstore(e2, ast::expr_vstore_uniq) |\n             ast::expr_vstore(e2, ast::expr_vstore_box) => {\n                 match e2.node {\n-                    ast::expr_lit(@codemap::spanned{\n+                    ast::expr_lit(@codemap::Spanned{\n                             node: ast::lit_str(*), _}) |\n                     ast::expr_vec(*) => {}\n                     _ => return\n@@ -1278,7 +1278,7 @@ impl MissingDocLintVisitor {\n     fn check_attrs(&mut self,\n                    cx: @mut Context,\n                    attrs: &[ast::Attribute],\n-                   sp: span,\n+                   sp: Span,\n                    msg: &str) {\n         // If we're building a test harness, then warning about documentation is\n         // probably not really relevant right now\n@@ -1299,7 +1299,7 @@ impl Visitor<@mut Context> for MissingDocLintVisitor {\n     }\n \n     fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:span, n:ast::NodeId, e:@mut Context) {\n+                b:&ast::Block, s:Span, n:ast::NodeId, e:@mut Context) {\n         self.OVERRIDE_visit_fn(fk, fd, b, s, n, e);\n     }\n \n@@ -1316,7 +1316,7 @@ impl SubitemStoppableVisitor for MissingDocLintVisitor {\n     fn is_running_on_items(&mut self) -> bool { !self.stopping_on_items }\n \n     fn visit_fn_action(&mut self, fk:&visit::fn_kind, _d:&ast::fn_decl,\n-                       _b:&ast::Block, sp:span, _id:ast::NodeId, cx:@mut Context) {\n+                       _b:&ast::Block, sp:Span, _id:ast::NodeId, cx:@mut Context) {\n \n             // Only warn about explicitly public methods. Soon implicit\n             // public-ness will hopefully be going away.\n@@ -1400,7 +1400,7 @@ impl Visitor<@mut Context> for LintCheckVisitor {\n     }\n \n     fn visit_fn(&mut self, fk:&visit::fn_kind, decl:&ast::fn_decl,\n-                body:&ast::Block, span:span, id:ast::NodeId, cx:@mut Context) {\n+                body:&ast::Block, span:Span, id:ast::NodeId, cx:@mut Context) {\n \n                 match *fk {\n                     visit::fk_method(_, _, m) => {"}, {"sha": "b79f6299e26cf0a8917b47fab277b8b9514e6d5d", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -116,7 +116,7 @@ use std::to_str;\n use std::uint;\n use std::vec;\n use syntax::ast::*;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust::{expr_to_str, block_to_str};\n use syntax::{visit, ast_util};\n@@ -135,9 +135,9 @@ impl Clone for LiveNode {\n \n #[deriving(Eq)]\n enum LiveNodeKind {\n-    FreeVarNode(span),\n-    ExprNode(span),\n-    VarDefNode(span),\n+    FreeVarNode(Span),\n+    ExprNode(Span),\n+    VarDefNode(Span),\n     ExitNode\n }\n \n@@ -154,7 +154,7 @@ fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n struct LivenessVisitor;\n \n impl Visitor<@mut IrMaps> for LivenessVisitor {\n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:span, n:NodeId, e:@mut IrMaps) {\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:Span, n:NodeId, e:@mut IrMaps) {\n         visit_fn(self, fk, fd, b, s, n, e);\n     }\n     fn visit_local(&mut self, l:@Local, e:@mut IrMaps) { visit_local(self, l, e); }\n@@ -308,7 +308,7 @@ impl IrMaps {\n         v\n     }\n \n-    pub fn variable(&mut self, node_id: NodeId, span: span) -> Variable {\n+    pub fn variable(&mut self, node_id: NodeId, span: Span) -> Variable {\n         match self.variable_map.find(&node_id) {\n           Some(&var) => var,\n           None => {\n@@ -348,7 +348,7 @@ impl IrMaps {\n struct ErrorCheckVisitor;\n \n impl Visitor<@Liveness> for ErrorCheckVisitor {\n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:span, n:NodeId, e:@Liveness) {\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:Span, n:NodeId, e:@Liveness) {\n         check_fn(self, fk, fd, b, s, n, e);\n     }\n     fn visit_local(&mut self, l:@Local, e:@Liveness) {\n@@ -366,7 +366,7 @@ fn visit_fn(v: &mut LivenessVisitor,\n             fk: &visit::fn_kind,\n             decl: &fn_decl,\n             body: &Block,\n-            sp: span,\n+            sp: Span,\n             id: NodeId,\n             this: @mut IrMaps) {\n     debug!(\"visit_fn: id=%d\", id);\n@@ -602,7 +602,7 @@ fn Liveness(ir: @mut IrMaps, specials: Specials) -> Liveness {\n }\n \n impl Liveness {\n-    pub fn live_node(&self, node_id: NodeId, span: span) -> LiveNode {\n+    pub fn live_node(&self, node_id: NodeId, span: Span) -> LiveNode {\n         let ir: &mut IrMaps = self.ir;\n         match ir.live_node_map.find(&node_id) {\n           Some(&ln) => ln,\n@@ -630,11 +630,11 @@ impl Liveness {\n         }\n     }\n \n-    pub fn variable(&self, node_id: NodeId, span: span) -> Variable {\n+    pub fn variable(&self, node_id: NodeId, span: Span) -> Variable {\n         self.ir.variable(node_id, span)\n     }\n \n-    pub fn variable_from_def_map(&self, node_id: NodeId, span: span)\n+    pub fn variable_from_def_map(&self, node_id: NodeId, span: Span)\n                                  -> Option<Variable> {\n         match self.tcx.def_map.find(&node_id) {\n           Some(&def) => {\n@@ -651,7 +651,7 @@ impl Liveness {\n \n     pub fn pat_bindings(&self,\n                         pat: @pat,\n-                        f: &fn(LiveNode, Variable, span, NodeId)) {\n+                        f: &fn(LiveNode, Variable, Span, NodeId)) {\n         let def_map = self.tcx.def_map;\n         do pat_util::pat_bindings(def_map, pat) |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n@@ -662,7 +662,7 @@ impl Liveness {\n \n     pub fn arm_pats_bindings(&self,\n                              pats: &[@pat],\n-                             f: &fn(LiveNode, Variable, span, NodeId)) {\n+                             f: &fn(LiveNode, Variable, Span, NodeId)) {\n         // only consider the first pattern; any later patterns must have\n         // the same bindings, and we also consider the first pattern to be\n         // the \"authoratative\" set of ids\n@@ -758,7 +758,7 @@ impl Liveness {\n     pub fn find_loop_scope(&self,\n                            opt_label: Option<ident>,\n                            id: NodeId,\n-                           sp: span)\n+                           sp: Span)\n                            -> NodeId {\n         match opt_label {\n             Some(_) => // Refers to a labeled loop. Use the results of resolve\n@@ -1512,7 +1512,7 @@ fn check_fn(_v: &mut ErrorCheckVisitor,\n             _fk: &visit::fn_kind,\n             _decl: &fn_decl,\n             _body: &Block,\n-            _sp: span,\n+            _sp: Span,\n             _id: NodeId,\n             _self: @Liveness) {\n     // do not check contents of nested fns\n@@ -1528,7 +1528,7 @@ enum ReadKind {\n impl Liveness {\n     pub fn check_ret(&self,\n                      id: NodeId,\n-                     sp: span,\n+                     sp: Span,\n                      _fk: &visit::fn_kind,\n                      entry_ln: LiveNode) {\n         if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n@@ -1584,7 +1584,7 @@ impl Liveness {\n     }\n \n     pub fn report_illegal_read(&self,\n-                               chk_span: span,\n+                               chk_span: Span,\n                                lnk: LiveNodeKind,\n                                var: Variable,\n                                rk: ReadKind) {\n@@ -1639,7 +1639,7 @@ impl Liveness {\n     }\n \n     pub fn warn_about_unused(&self,\n-                             sp: span,\n+                             sp: Span,\n                              id: NodeId,\n                              ln: LiveNode,\n                              var: Variable)\n@@ -1673,7 +1673,7 @@ impl Liveness {\n     }\n \n     pub fn warn_about_dead_assign(&self,\n-                                  sp: span,\n+                                  sp: Span,\n                                   id: NodeId,\n                                   ln: LiveNode,\n                                   var: Variable) {"}, {"sha": "21a2256b5543751217b9d73226d23ea2b6e89b85", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -54,7 +54,7 @@ use util::common::indenter;\n \n use syntax::ast::{m_imm, m_mutbl};\n use syntax::ast;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::print::pprust;\n \n #[deriving(Eq)]\n@@ -134,7 +134,7 @@ pub enum MutabilityCategory {\n #[deriving(Eq)]\n pub struct cmt_ {\n     id: ast::NodeId,          // id of expr/pat producing this value\n-    span: span,                // span of same expr/pat\n+    span: Span,                // span of same expr/pat\n     cat: categorization,       // categorization of expr\n     mutbl: MutabilityCategory, // mutability of expr as lvalue\n     ty: ty::t                  // type of the expr (*see WARNING above*)\n@@ -256,7 +256,7 @@ pub fn cat_def(\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n     expr_id: ast::NodeId,\n-    expr_span: span,\n+    expr_span: Span,\n     expr_ty: ty::t,\n     def: ast::def) -> cmt {\n \n@@ -268,17 +268,17 @@ pub fn cat_def(\n \n pub trait ast_node {\n     fn id(&self) -> ast::NodeId;\n-    fn span(&self) -> span;\n+    fn span(&self) -> Span;\n }\n \n impl ast_node for @ast::expr {\n     fn id(&self) -> ast::NodeId { self.id }\n-    fn span(&self) -> span { self.span }\n+    fn span(&self) -> Span { self.span }\n }\n \n impl ast_node for @ast::pat {\n     fn id(&self) -> ast::NodeId { self.id }\n-    fn span(&self) -> span { self.span }\n+    fn span(&self) -> Span { self.span }\n }\n \n pub struct mem_categorization_ctxt {\n@@ -442,7 +442,7 @@ impl mem_categorization_ctxt {\n \n     pub fn cat_def(&self,\n                    id: ast::NodeId,\n-                   span: span,\n+                   span: Span,\n                    expr_ty: ty::t,\n                    def: ast::def)\n                    -> cmt {\n@@ -584,7 +584,7 @@ impl mem_categorization_ctxt {\n \n     pub fn cat_rvalue(&self,\n                       cmt_id: ast::NodeId,\n-                      span: span,\n+                      span: Span,\n                       cleanup_scope_id: ast::NodeId,\n                       expr_ty: ty::t) -> cmt {\n         @cmt_ {"}, {"sha": "8ba2c38250f65294fbb1c6551874c3f8d922f20c", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -141,7 +141,7 @@ use syntax::ast::*;\n use syntax::ast_util;\n use syntax::visit;\n use syntax::visit::Visitor;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n \n #[deriving(Encodable, Decodable)]\n pub enum CaptureMode {\n@@ -153,7 +153,7 @@ pub enum CaptureMode {\n #[deriving(Encodable, Decodable)]\n pub struct CaptureVar {\n     def: def,         // Variable being accessed free\n-    span: span,       // Location of an access to this variable\n+    span: Span,       // Location of an access to this variable\n     mode: CaptureMode // How variable is being accessed\n }\n \n@@ -194,7 +194,7 @@ struct ComputeModesVisitor;\n \n impl visit::Visitor<VisitContext> for ComputeModesVisitor {\n     fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&fn_decl,\n-                b:&Block, s:span, n:NodeId, e:VisitContext) {\n+                b:&Block, s:Span, n:NodeId, e:VisitContext) {\n         compute_modes_for_fn(*self, fk, fd, b, s, n, e);\n     }\n     fn visit_expr(&mut self, ex:@expr, e:VisitContext) {\n@@ -250,7 +250,7 @@ fn compute_modes_for_fn(v: ComputeModesVisitor,\n                         fk: &visit::fn_kind,\n                         decl: &fn_decl,\n                         body: &Block,\n-                        span: span,\n+                        span: Span,\n                         id: NodeId,\n                         cx: VisitContext) {\n     let mut v = v;"}, {"sha": "253d234afcfc451006f737f38b053c90f5deee88", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -14,7 +14,7 @@ use middle::resolve;\n use std::hashmap::HashMap;\n use syntax::ast::*;\n use syntax::ast_util::{path_to_ident, walk_pat};\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n \n pub type PatIdMap = HashMap<ident, NodeId>;\n \n@@ -71,7 +71,7 @@ pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: @pat) -> bool {\n }\n \n pub fn pat_bindings(dm: resolve::DefMap, pat: @pat,\n-                    it: &fn(binding_mode, NodeId, span, &Path)) {\n+                    it: &fn(binding_mode, NodeId, Span, &Path)) {\n     do walk_pat(pat) |p| {\n         match p.node {\n           pat_ident(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {"}, {"sha": "5fa85674f9a1a48611762fe5a994c821032a50b5", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -31,7 +31,7 @@ use syntax::ast_map;\n use syntax::ast_util::{Private, Public, is_local};\n use syntax::ast_util::{variant_visibility_to_privacy, visibility_to_privacy};\n use syntax::attr;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -79,7 +79,7 @@ impl PrivacyVisitor {\n     }\n \n     // Checks that an enum variant is in scope\n-    fn check_variant(&mut self, span: span, enum_id: ast::def_id) {\n+    fn check_variant(&mut self, span: Span, enum_id: ast::def_id) {\n         let variant_info = ty::enum_variants(self.tcx, enum_id)[0];\n         let parental_privacy = if is_local(enum_id) {\n             let parent_vis = ast_map::node_item_query(self.tcx.items,\n@@ -108,7 +108,7 @@ impl PrivacyVisitor {\n     }\n \n     // Returns true if a crate-local method is private and false otherwise.\n-    fn method_is_private(&mut self, span: span, method_id: NodeId) -> bool {\n+    fn method_is_private(&mut self, span: Span, method_id: NodeId) -> bool {\n         let check = |vis: visibility, container_id: def_id| {\n             let mut is_private = false;\n             if vis == private {\n@@ -171,7 +171,7 @@ impl PrivacyVisitor {\n     }\n \n     // Returns true if the given local item is private and false otherwise.\n-    fn local_item_is_private(&mut self, span: span, item_id: NodeId) -> bool {\n+    fn local_item_is_private(&mut self, span: Span, item_id: NodeId) -> bool {\n         let mut f: &fn(NodeId) -> bool = |_| false;\n         f = |item_id| {\n             match self.tcx.items.find(&item_id) {\n@@ -203,7 +203,7 @@ impl PrivacyVisitor {\n     }\n \n     // Checks that a private field is in scope.\n-    fn check_field(&mut self, span: span, id: ast::def_id, ident: ast::ident) {\n+    fn check_field(&mut self, span: Span, id: ast::def_id, ident: ast::ident) {\n         let fields = ty::lookup_struct_fields(self.tcx, id);\n         for field in fields.iter() {\n             if field.ident != ident { loop; }\n@@ -216,7 +216,7 @@ impl PrivacyVisitor {\n     }\n \n     // Given the ID of a method, checks to ensure it's in scope.\n-    fn check_method_common(&mut self, span: span, method_id: def_id, name: &ident) {\n+    fn check_method_common(&mut self, span: Span, method_id: def_id, name: &ident) {\n         // If the method is a default method, we need to use the def_id of\n         // the default implementation.\n         // Having to do this this is really unfortunate.\n@@ -245,7 +245,7 @@ impl PrivacyVisitor {\n     }\n \n     // Checks that a private path is in scope.\n-    fn check_path(&mut self, span: span, def: def, path: &Path) {\n+    fn check_path(&mut self, span: Span, def: def, path: &Path) {\n         debug!(\"checking path\");\n         match def {\n             def_static_method(method_id, _, _) => {\n@@ -280,7 +280,7 @@ impl PrivacyVisitor {\n     }\n \n     // Checks that a private method is in scope.\n-    fn check_method(&mut self, span: span, origin: &method_origin, ident: ast::ident) {\n+    fn check_method(&mut self, span: Span, origin: &method_origin, ident: ast::ident) {\n         match *origin {\n             method_static(method_id) => {\n                 self.check_method_common(span, method_id, &ident)\n@@ -343,7 +343,7 @@ impl PrivacyVisitor {\n \n impl<'self> Visitor<&'self method_map> for PrivacyVisitor {\n \n-    fn visit_mod<'mm>(&mut self, the_module:&_mod, _:span, _:NodeId,\n+    fn visit_mod<'mm>(&mut self, the_module:&_mod, _:Span, _:NodeId,\n                       method_map:&'mm method_map) {\n \n             let n_added = self.add_privileged_items(the_module.items);"}, {"sha": "2d503029256cd361168f626b3d0aed34f63f0a89", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -30,7 +30,7 @@ use middle::ty;\n \n use std::hashmap::{HashMap, HashSet};\n use syntax::ast_map;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::print::pprust;\n use syntax::parse::token;\n use syntax::parse::token::special_idents;\n@@ -318,7 +318,7 @@ impl RegionMaps {\n }\n \n /// Records the current parent (if any) as the parent of `child_id`.\n-fn parent_to_expr(cx: Context, child_id: ast::NodeId, sp: span) {\n+fn parent_to_expr(cx: Context, child_id: ast::NodeId, sp: Span) {\n     debug!(\"region::parent_to_expr(span=%?)\",\n            cx.sess.codemap.span_to_str(sp));\n     for parent_id in cx.parent.iter() {\n@@ -431,7 +431,7 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n               fk: &visit::fn_kind,\n               decl: &ast::fn_decl,\n               body: &ast::Block,\n-              sp: span,\n+              sp: Span,\n               id: ast::NodeId,\n               cx: Context) {\n     debug!(\"region::resolve_fn(id=%?, \\\n@@ -482,7 +482,7 @@ impl Visitor<Context> for RegionResolutionVisitor {\n         resolve_item(self, i, cx);\n     }\n \n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:span, n:NodeId, cx:Context) {\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:Span, n:NodeId, cx:Context) {\n         resolve_fn(self, fk, fd, b, s, n, cx);\n     }\n     fn visit_arm(&mut self, a:&arm, cx:Context) {\n@@ -744,7 +744,7 @@ fn determine_rp_in_fn(visitor: &mut DetermineRpVisitor,\n                       fk: &visit::fn_kind,\n                       decl: &ast::fn_decl,\n                       body: &ast::Block,\n-                      _: span,\n+                      _: Span,\n                       _: ast::NodeId,\n                       cx: @mut DetermineRpCtxt) {\n     do cx.with(cx.item_id, false) {\n@@ -911,7 +911,7 @@ struct DetermineRpVisitor;\n impl Visitor<@mut DetermineRpCtxt> for DetermineRpVisitor {\n \n     fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl,\n-                b:&Block, s:span, n:NodeId, e:@mut DetermineRpCtxt) {\n+                b:&Block, s:Span, n:NodeId, e:@mut DetermineRpCtxt) {\n         determine_rp_in_fn(self, fk, fd, b, s, n, e);\n     }\n     fn visit_item(&mut self, i:@item, e:@mut DetermineRpCtxt) {"}, {"sha": "303a534974dd5017bb9a0caea9586cb55217ea1e", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 131, "deletions": 126, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -16,7 +16,7 @@ use metadata::csearch::get_static_methods_if_impl;\n use metadata::csearch::{get_type_name_if_impl, get_struct_fields};\n use metadata::csearch;\n use metadata::cstore::find_extern_mod_stmt_cnum;\n-use metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n+use metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n use middle::lang_items::LanguageItems;\n use middle::lint::{unnecessary_qualification, unused_imports};\n use middle::pat_util::pat_bindings;\n@@ -32,7 +32,7 @@ use syntax::parse::token;\n use syntax::parse::token::ident_interner;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust::path_to_str;\n-use syntax::codemap::{span, dummy_sp, BytePos};\n+use syntax::codemap::{Span, dummy_sp, BytePos};\n use syntax::opt_vec::OptVec;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -46,7 +46,7 @@ use std::util;\n pub type DefMap = @mut HashMap<NodeId,def>;\n \n pub struct binding_info {\n-    span: span,\n+    span: Span,\n     binding_mode: binding_mode,\n }\n \n@@ -311,41 +311,44 @@ pub enum DuplicateCheckingMode {\n \n /// One local scope.\n pub struct Rib {\n-    bindings: @mut HashMap<ident,def_like>,\n-    self_binding: @mut Option<def_like>,\n+    bindings: @mut HashMap<ident, DefLike>,\n+    self_binding: @mut Option<DefLike>,\n     kind: RibKind,\n }\n \n-pub fn Rib(kind: RibKind) -> Rib {\n-    Rib {\n-        bindings: @mut HashMap::new(),\n-        self_binding: @mut None,\n-        kind: kind\n+impl Rib {\n+    pub fn new(kind: RibKind) -> Rib {\n+        Rib {\n+            bindings: @mut HashMap::new(),\n+            self_binding: @mut None,\n+            kind: kind\n+        }\n     }\n }\n \n-\n /// One import directive.\n pub struct ImportDirective {\n     privacy: Privacy,\n     module_path: ~[ident],\n     subclass: @ImportDirectiveSubclass,\n-    span: span,\n+    span: Span,\n     id: NodeId,\n }\n \n-pub fn ImportDirective(privacy: Privacy,\n-                       module_path: ~[ident],\n-                       subclass: @ImportDirectiveSubclass,\n-                       span: span,\n-                       id: NodeId)\n-                    -> ImportDirective {\n-    ImportDirective {\n-        privacy: privacy,\n-        module_path: module_path,\n-        subclass: subclass,\n-        span: span,\n-        id: id\n+impl ImportDirective {\n+    pub fn new(privacy: Privacy,\n+               module_path: ~[ident],\n+               subclass: @ImportDirectiveSubclass,\n+               span: Span,\n+               id: NodeId)\n+               -> ImportDirective {\n+        ImportDirective {\n+            privacy: privacy,\n+            module_path: module_path,\n+            subclass: subclass,\n+            span: span,\n+            id: id\n+        }\n     }\n }\n \n@@ -355,12 +358,14 @@ pub struct Target {\n     bindings: @mut NameBindings,\n }\n \n-pub fn Target(target_module: @mut Module,\n-              bindings: @mut NameBindings)\n-           -> Target {\n-    Target {\n-        target_module: target_module,\n-        bindings: bindings\n+impl Target {\n+    pub fn new(target_module: @mut Module,\n+               bindings: @mut NameBindings)\n+               -> Target {\n+        Target {\n+            target_module: target_module,\n+            bindings: bindings\n+        }\n     }\n }\n \n@@ -388,19 +393,19 @@ pub struct ImportResolution {\n     type_id: NodeId,\n }\n \n-pub fn ImportResolution(privacy: Privacy,\n-                        id: NodeId) -> ImportResolution {\n-    ImportResolution {\n-        privacy: privacy,\n-        type_id: id,\n-        value_id: id,\n-        outstanding_references: 0,\n-        value_target: None,\n-        type_target: None,\n+impl ImportResolution {\n+    pub fn new(privacy: Privacy,\n+               id: NodeId) -> ImportResolution {\n+        ImportResolution {\n+            privacy: privacy,\n+            type_id: id,\n+            value_id: id,\n+            outstanding_references: 0,\n+            value_target: None,\n+            type_target: None,\n+        }\n     }\n-}\n \n-impl ImportResolution {\n     pub fn target_for_namespace(&self, namespace: Namespace)\n                                 -> Option<Target> {\n         match namespace {\n@@ -478,27 +483,27 @@ pub struct Module {\n     populated: bool,\n }\n \n-pub fn Module(parent_link: ParentLink,\n-              def_id: Option<def_id>,\n-              kind: ModuleKind,\n-              external: bool)\n-              -> Module {\n-    Module {\n-        parent_link: parent_link,\n-        def_id: def_id,\n-        kind: kind,\n-        children: @mut HashMap::new(),\n-        imports: @mut ~[],\n-        external_module_children: @mut HashMap::new(),\n-        anonymous_children: @mut HashMap::new(),\n-        import_resolutions: @mut HashMap::new(),\n-        glob_count: 0,\n-        resolved_import_count: 0,\n-        populated: !external,\n+impl Module {\n+    pub fn new(parent_link: ParentLink,\n+                def_id: Option<def_id>,\n+                kind: ModuleKind,\n+                external: bool)\n+                -> Module {\n+        Module {\n+            parent_link: parent_link,\n+            def_id: def_id,\n+            kind: kind,\n+            children: @mut HashMap::new(),\n+            imports: @mut ~[],\n+            external_module_children: @mut HashMap::new(),\n+            anonymous_children: @mut HashMap::new(),\n+            import_resolutions: @mut HashMap::new(),\n+            glob_count: 0,\n+            resolved_import_count: 0,\n+            populated: !external,\n+        }\n     }\n-}\n \n-impl Module {\n     pub fn all_imports_resolved(&self) -> bool {\n         let imports = &mut *self.imports;\n         return imports.len() == self.resolved_import_count;\n@@ -510,14 +515,14 @@ pub struct TypeNsDef {\n     privacy: Privacy,\n     module_def: Option<@mut Module>,\n     type_def: Option<def>,\n-    type_span: Option<span>\n+    type_span: Option<Span>\n }\n \n // Records a possibly-private value definition.\n pub struct ValueNsDef {\n     privacy: Privacy,\n     def: def,\n-    value_span: Option<span>,\n+    value_span: Option<Span>,\n }\n \n // Records the definitions (at most one for each namespace) that a name is\n@@ -542,9 +547,9 @@ impl NameBindings {\n                          def_id: Option<def_id>,\n                          kind: ModuleKind,\n                          external: bool,\n-                         sp: span) {\n+                         sp: Span) {\n         // Merges the module with the existing type def or creates a new one.\n-        let module_ = @mut Module(parent_link, def_id, kind, external);\n+        let module_ = @mut Module::new(parent_link, def_id, kind, external);\n         match self.type_def {\n             None => {\n                 self.type_def = Some(TypeNsDef {\n@@ -572,10 +577,10 @@ impl NameBindings {\n                            def_id: Option<def_id>,\n                            kind: ModuleKind,\n                            external: bool,\n-                           _sp: span) {\n+                           _sp: Span) {\n         match self.type_def {\n             None => {\n-                let module = @mut Module(parent_link, def_id, kind, external);\n+                let module = @mut Module::new(parent_link, def_id, kind, external);\n                 self.type_def = Some(TypeNsDef {\n                     privacy: privacy,\n                     module_def: Some(module),\n@@ -586,7 +591,7 @@ impl NameBindings {\n             Some(type_def) => {\n                 match type_def.module_def {\n                     None => {\n-                        let module = @mut Module(parent_link,\n+                        let module = @mut Module::new(parent_link,\n                                                  def_id,\n                                                  kind,\n                                                  external);\n@@ -604,7 +609,7 @@ impl NameBindings {\n     }\n \n     /// Records a type definition.\n-    pub fn define_type(@mut self, privacy: Privacy, def: def, sp: span) {\n+    pub fn define_type(@mut self, privacy: Privacy, def: def, sp: Span) {\n         // Merges the type with the existing type def or creates a new one.\n         match self.type_def {\n             None => {\n@@ -627,7 +632,7 @@ impl NameBindings {\n     }\n \n     /// Records a value definition.\n-    pub fn define_value(@mut self, privacy: Privacy, def: def, sp: span) {\n+    pub fn define_value(@mut self, privacy: Privacy, def: def, sp: Span) {\n         self.value_def = Some(ValueNsDef { privacy: privacy, def: def, value_span: Some(sp) });\n     }\n \n@@ -723,7 +728,7 @@ impl NameBindings {\n         }\n     }\n \n-    pub fn span_for_namespace(&self, namespace: Namespace) -> Option<span> {\n+    pub fn span_for_namespace(&self, namespace: Namespace) -> Option<Span> {\n         if self.defined_in_namespace(namespace) {\n             match namespace {\n                 TypeNS  => {\n@@ -1016,7 +1021,7 @@ impl Resolver {\n                      reduced_graph_parent: ReducedGraphParent,\n                      duplicate_checking_mode: DuplicateCheckingMode,\n                      // For printing errors\n-                     sp: span)\n+                     sp: Span)\n                      -> (@mut NameBindings, ReducedGraphParent) {\n         // If this is the immediate descendant of a module, then we add the\n         // child name directly. Otherwise, we create or reuse an anonymous\n@@ -1571,7 +1576,7 @@ impl Resolver {\n                         let def_id = def_id { crate: crate_id, node: 0 };\n                         let parent_link = ModuleParentLink\n                             (self.get_module_from_parent(parent), name);\n-                        let external_module = @mut Module(parent_link,\n+                        let external_module = @mut Module::new(parent_link,\n                                                           Some(def_id),\n                                                           NormalModuleKind,\n                                                           false);\n@@ -1635,7 +1640,7 @@ impl Resolver {\n                    block_id);\n \n             let parent_module = self.get_module_from_parent(parent);\n-            let new_module = @mut Module(\n+            let new_module = @mut Module::new(\n                 BlockParentLink(parent_module, block_id),\n                 None,\n                 AnonymousModuleKind,\n@@ -1777,10 +1782,10 @@ impl Resolver {\n     /// Builds the reduced graph for a single item in an external crate.\n     fn build_reduced_graph_for_external_crate_def(@mut self,\n                                                   root: @mut Module,\n-                                                  def_like: def_like,\n+                                                  def_like: DefLike,\n                                                   ident: ident) {\n         match def_like {\n-            dl_def(def) => {\n+            DlDef(def) => {\n                 // Add the new child item, if necessary.\n                 match def {\n                     def_foreign_mod(def_id) => {\n@@ -1811,7 +1816,7 @@ impl Resolver {\n                     }\n                 }\n             }\n-            dl_impl(def) => {\n+            DlImpl(def) => {\n                 // We only process static methods of impls here.\n                 match get_type_name_if_impl(self.session.cstore, def) {\n                     None => {}\n@@ -1900,7 +1905,7 @@ impl Resolver {\n                     }\n                 }\n             }\n-            dl_field => {\n+            DlField => {\n                 debug!(\"(building reduced graph for external crate) \\\n                         ignoring field\");\n             }\n@@ -1959,9 +1964,9 @@ impl Resolver {\n                                   module_: @mut Module,\n                                   module_path: ~[ident],\n                                   subclass: @ImportDirectiveSubclass,\n-                                  span: span,\n+                                  span: Span,\n                                   id: NodeId) {\n-        let directive = @ImportDirective(privacy, module_path,\n+        let directive = @ImportDirective::new(privacy, module_path,\n                                          subclass, span, id);\n         module_.imports.push(directive);\n \n@@ -1989,7 +1994,7 @@ impl Resolver {\n                     }\n                     None => {\n                         debug!(\"(building import directive) creating new\");\n-                        let resolution = @mut ImportResolution(privacy, id);\n+                        let resolution = @mut ImportResolution::new(privacy, id);\n                         resolution.outstanding_references = 1;\n                         module_.import_resolutions.insert(target, resolution);\n                     }\n@@ -2402,7 +2407,7 @@ impl Resolver {\n             BoundResult(target_module, name_bindings) => {\n                 debug!(\"(resolving single import) found value target\");\n                 import_resolution.value_target =\n-                    Some(Target(target_module, name_bindings));\n+                    Some(Target::new(target_module, name_bindings));\n                 import_resolution.value_id = directive.id;\n             }\n             UnboundResult => { /* Continue. */ }\n@@ -2415,7 +2420,7 @@ impl Resolver {\n                 debug!(\"(resolving single import) found type target: %?\",\n                         name_bindings.type_def.unwrap().type_def);\n                 import_resolution.type_target =\n-                    Some(Target(target_module, name_bindings));\n+                    Some(Target::new(target_module, name_bindings));\n                 import_resolution.type_id = directive.id;\n             }\n             UnboundResult => { /* Continue. */ }\n@@ -2522,7 +2527,7 @@ impl Resolver {\n                 None if target_import_resolution.privacy == Public => {\n                     // Simple: just copy the old import resolution.\n                     let new_import_resolution =\n-                        @mut ImportResolution(privacy, id);\n+                        @mut ImportResolution::new(privacy, id);\n                     new_import_resolution.value_target =\n                         target_import_resolution.value_target;\n                     new_import_resolution.type_target =\n@@ -2564,7 +2569,7 @@ impl Resolver {\n             match module_.import_resolutions.find(&ident) {\n                 None => {\n                     // Create a new import resolution from this child.\n-                    dest_import_resolution = @mut ImportResolution(privacy, id);\n+                    dest_import_resolution = @mut ImportResolution::new(privacy, id);\n                     module_.import_resolutions.insert\n                         (ident, dest_import_resolution);\n                 }\n@@ -2584,13 +2589,13 @@ impl Resolver {\n             if name_bindings.defined_in_public_namespace(ValueNS) {\n                 debug!(\"(resolving glob import) ... for value target\");\n                 dest_import_resolution.value_target =\n-                    Some(Target(containing_module, name_bindings));\n+                    Some(Target::new(containing_module, name_bindings));\n                 dest_import_resolution.value_id = id;\n             }\n             if name_bindings.defined_in_public_namespace(TypeNS) {\n                 debug!(\"(resolving glob import) ... for type target\");\n                 dest_import_resolution.type_target =\n-                    Some(Target(containing_module, name_bindings));\n+                    Some(Target::new(containing_module, name_bindings));\n                 dest_import_resolution.type_id = id;\n             }\n         };\n@@ -2617,7 +2622,7 @@ impl Resolver {\n                                          module_: @mut Module,\n                                          module_path: &[ident],\n                                          index: uint,\n-                                         span: span,\n+                                         span: Span,\n                                          mut name_search_type: NameSearchType)\n                                          -> ResolveResult<@mut Module> {\n         let mut search_module = module_;\n@@ -2637,7 +2642,7 @@ impl Resolver {\n                     let segment_name = self.session.str_of(name);\n                     let module_name = self.module_to_str(search_module);\n                     if \"???\" == module_name {\n-                        let span = span {\n+                        let span = Span {\n                             lo: span.lo,\n                             hi: span.lo + BytePos(segment_name.len()),\n                             expn_info: span.expn_info,\n@@ -2726,7 +2731,7 @@ impl Resolver {\n                                module_: @mut Module,\n                                module_path: &[ident],\n                                use_lexical_scope: UseLexicalScopeFlag,\n-                               span: span,\n+                               span: Span,\n                                name_search_type: NameSearchType)\n                                -> ResolveResult<@mut Module> {\n         let module_path_len = module_path.len();\n@@ -2834,7 +2839,7 @@ impl Resolver {\n         match module_.children.find(&name) {\n             Some(name_bindings)\n                     if name_bindings.defined_in_namespace(namespace) => {\n-                return Success(Target(module_, *name_bindings));\n+                return Success(Target::new(module_, *name_bindings));\n             }\n             Some(_) | None => { /* Not found; continue. */ }\n         }\n@@ -2873,7 +2878,7 @@ impl Resolver {\n                     let name_bindings =\n                         @mut Resolver::create_name_bindings_from_module(\n                             *module);\n-                    return Success(Target(module_, name_bindings));\n+                    return Success(Target::new(module_, name_bindings));\n                 }\n             }\n         }\n@@ -3090,7 +3095,7 @@ impl Resolver {\n             Some(name_bindings)\n                     if name_bindings.defined_in_namespace(namespace) => {\n                 debug!(\"(resolving name in module) found node as child\");\n-                return Success(Target(module_, *name_bindings));\n+                return Success(Target::new(module_, *name_bindings));\n             }\n             Some(_) | None => {\n                 // Continue.\n@@ -3148,7 +3153,7 @@ impl Resolver {\n                     let name_bindings =\n                         @mut Resolver::create_name_bindings_from_module(\n                             *module);\n-                    return Success(Target(module_, name_bindings));\n+                    return Success(Target::new(module_, name_bindings));\n                 }\n             }\n         }\n@@ -3382,24 +3387,24 @@ impl Resolver {\n     pub fn upvarify(@mut self,\n                     ribs: &mut ~[@Rib],\n                     rib_index: uint,\n-                    def_like: def_like,\n-                    span: span,\n+                    def_like: DefLike,\n+                    span: Span,\n                     allow_capturing_self: AllowCapturingSelfFlag)\n-                    -> Option<def_like> {\n+                    -> Option<DefLike> {\n         let mut def;\n         let is_ty_param;\n \n         match def_like {\n-            dl_def(d @ def_local(*)) | dl_def(d @ def_upvar(*)) |\n-            dl_def(d @ def_arg(*)) | dl_def(d @ def_binding(*)) => {\n+            DlDef(d @ def_local(*)) | DlDef(d @ def_upvar(*)) |\n+            DlDef(d @ def_arg(*)) | DlDef(d @ def_binding(*)) => {\n                 def = d;\n                 is_ty_param = false;\n             }\n-            dl_def(d @ def_ty_param(*)) => {\n+            DlDef(d @ def_ty_param(*)) => {\n                 def = d;\n                 is_ty_param = true;\n             }\n-            dl_def(d @ def_self(*))\n+            DlDef(d @ def_self(*))\n                     if allow_capturing_self == DontAllowCapturingSelf => {\n                 def = d;\n                 is_ty_param = false;\n@@ -3488,15 +3493,15 @@ impl Resolver {\n             rib_index += 1;\n         }\n \n-        return Some(dl_def(def));\n+        return Some(DlDef(def));\n     }\n \n     pub fn search_ribs(@mut self,\n                        ribs: &mut ~[@Rib],\n                        name: ident,\n-                       span: span,\n+                       span: Span,\n                        allow_capturing_self: AllowCapturingSelfFlag)\n-                       -> Option<def_like> {\n+                       -> Option<DefLike> {\n         // FIXME #4950: This should not use a while loop.\n         // FIXME #4950: Try caching?\n \n@@ -3584,10 +3589,10 @@ impl Resolver {\n \n             item_trait(ref generics, ref traits, ref methods) => {\n                 // Create a new rib for the self type.\n-                let self_type_rib = @Rib(NormalRibKind);\n+                let self_type_rib = @Rib::new(NormalRibKind);\n                 self.type_ribs.push(self_type_rib);\n                 self_type_rib.bindings.insert(self.type_self_ident,\n-                                              dl_def(def_self_ty(item.id)));\n+                                              DlDef(def_self_ty(item.id)));\n \n                 // Create a new rib for the trait-wide type parameters.\n                 do self.with_type_parameter_rib\n@@ -3714,14 +3719,14 @@ impl Resolver {\n             HasTypeParameters(generics, node_id, initial_index,\n                               rib_kind) => {\n \n-                let function_type_rib = @Rib(rib_kind);\n+                let function_type_rib = @Rib::new(rib_kind);\n                 self.type_ribs.push(function_type_rib);\n \n                 for (index, type_parameter) in generics.ty_params.iter().enumerate() {\n                     let name = type_parameter.ident;\n                     debug!(\"with_type_parameter_rib: %d %d\", node_id,\n                            type_parameter.id);\n-                    let def_like = dl_def(def_ty_param\n+                    let def_like = DlDef(def_ty_param\n                         (local_def(type_parameter.id),\n                          index + initial_index));\n                     // Associate this type parameter with\n@@ -3751,13 +3756,13 @@ impl Resolver {\n     }\n \n     pub fn with_label_rib(@mut self, f: &fn()) {\n-        self.label_ribs.push(@Rib(NormalRibKind));\n+        self.label_ribs.push(@Rib::new(NormalRibKind));\n         f();\n         self.label_ribs.pop();\n     }\n \n     pub fn with_constant_rib(@mut self, f: &fn()) {\n-        self.value_ribs.push(@Rib(ConstantItemRibKind));\n+        self.value_ribs.push(@Rib::new(ConstantItemRibKind));\n         f();\n         self.value_ribs.pop();\n     }\n@@ -3770,11 +3775,11 @@ impl Resolver {\n                             self_binding: SelfBinding,\n                             visitor: &mut ResolveVisitor) {\n         // Create a value rib for the function.\n-        let function_value_rib = @Rib(rib_kind);\n+        let function_value_rib = @Rib::new(rib_kind);\n         self.value_ribs.push(function_value_rib);\n \n         // Create a label rib for the function.\n-        let function_label_rib = @Rib(rib_kind);\n+        let function_label_rib = @Rib::new(rib_kind);\n         self.label_ribs.push(function_label_rib);\n \n         // If this function has type parameters, add them now.\n@@ -3796,7 +3801,7 @@ impl Resolver {\n                     // Nothing to do.\n                 }\n                 HasSelfBinding(self_node_id) => {\n-                    let def_like = dl_def(def_self(self_node_id));\n+                    let def_like = DlDef(def_self(self_node_id));\n                     *function_value_rib.self_binding = Some(def_like);\n                 }\n             }\n@@ -4029,7 +4034,7 @@ impl Resolver {\n \n     pub fn resolve_module(@mut self,\n                           module_: &_mod,\n-                          _span: span,\n+                          _span: Span,\n                           _name: ident,\n                           id: NodeId,\n                           visitor: &mut ResolveVisitor) {\n@@ -4110,7 +4115,7 @@ impl Resolver {\n     }\n \n     pub fn resolve_arm(@mut self, arm: &arm, visitor: &mut ResolveVisitor) {\n-        self.value_ribs.push(@Rib(NormalRibKind));\n+        self.value_ribs.push(@Rib::new(NormalRibKind));\n \n         let bindings_list = @mut HashMap::new();\n         for pattern in arm.pats.iter() {\n@@ -4130,7 +4135,7 @@ impl Resolver {\n \n     pub fn resolve_block(@mut self, block: &Block, visitor: &mut ResolveVisitor) {\n         debug!(\"(resolving block) entering block\");\n-        self.value_ribs.push(@Rib(NormalRibKind));\n+        self.value_ribs.push(@Rib::new(NormalRibKind));\n \n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module;\n@@ -4366,7 +4371,7 @@ impl Resolver {\n                                     let last_rib = this.value_ribs[\n                                             this.value_ribs.len() - 1];\n                                     last_rib.bindings.insert(ident,\n-                                                             dl_def(def));\n+                                                             DlDef(def));\n                                     bindings_list.insert(ident, pat_id);\n                                 }\n                                 Some(b) => {\n@@ -4387,7 +4392,7 @@ impl Resolver {\n                                     let last_rib = this.value_ribs[\n                                             this.value_ribs.len() - 1];\n                                     last_rib.bindings.insert(ident,\n-                                                             dl_def(def));\n+                                                             DlDef(def));\n                                 }\n                             }\n                         }\n@@ -4602,7 +4607,7 @@ impl Resolver {\n                               identifier: ident,\n                               namespace: Namespace,\n                               check_ribs: bool,\n-                              span: span)\n+                              span: Span)\n                               -> Option<def> {\n         if check_ribs {\n             match self.resolve_identifier_in_local_ribs(identifier,\n@@ -4826,7 +4831,7 @@ impl Resolver {\n     pub fn resolve_identifier_in_local_ribs(@mut self,\n                                             ident: ident,\n                                             namespace: Namespace,\n-                                            span: span)\n+                                            span: Span)\n                                             -> Option<def> {\n         // Check the local set of ribs.\n         let search_result;\n@@ -4843,20 +4848,20 @@ impl Resolver {\n         }\n \n         match search_result {\n-            Some(dl_def(def)) => {\n+            Some(DlDef(def)) => {\n                 debug!(\"(resolving path in local ribs) resolved `%s` to \\\n                         local: %?\",\n                        self.session.str_of(ident),\n                        def);\n                 return Some(def);\n             }\n-            Some(dl_field) | Some(dl_impl(_)) | None => {\n+            Some(DlField) | Some(DlImpl(_)) | None => {\n                 return None;\n             }\n         }\n     }\n \n-    pub fn resolve_self_value_in_local_ribs(@mut self, span: span)\n+    pub fn resolve_self_value_in_local_ribs(@mut self, span: Span)\n                                             -> Option<def> {\n         // FIXME #4950: This should not use a while loop.\n         let ribs = &mut self.value_ribs;\n@@ -4870,7 +4875,7 @@ impl Resolver {\n                                         def_like,\n                                         span,\n                                         DontAllowCapturingSelf) {\n-                        Some(dl_def(def)) => return Some(def),\n+                        Some(DlDef(def)) => return Some(def),\n                         _ => {\n                             if self.session.has_errors() {\n                                 // May happen inside a nested fn item, cf #6642.\n@@ -4929,7 +4934,7 @@ impl Resolver {\n         rs\n     }\n \n-    fn resolve_error(@mut self, span: span, s: &str) {\n+    fn resolve_error(@mut self, span: Span, s: &str) {\n         if self.emit_errors {\n             self.session.span_err(span, s);\n         }\n@@ -5135,7 +5140,7 @@ impl Resolver {\n                 do self.with_label_rib {\n                     {\n                         let this = &mut *self;\n-                        let def_like = dl_def(def_label(expr.id));\n+                        let def_like = DlDef(def_label(expr.id));\n                         let rib = this.label_ribs[this.label_ribs.len() - 1];\n                         rib.bindings.insert(label, def_like);\n                     }\n@@ -5155,7 +5160,7 @@ impl Resolver {\n                                                    `%s`\",\n                                                    self.session.str_of(\n                                                        label))),\n-                    Some(dl_def(def @ def_label(_))) => {\n+                    Some(DlDef(def @ def_label(_))) => {\n                         self.record_def(expr.id, def)\n                     }\n                     Some(_) => {"}, {"sha": "1f64038e43fdc700095bea76dc3ba67f6d13e67b", "filename": "src/librustc/middle/stack_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstack_check.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -21,7 +21,7 @@ use middle::ty;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::attr;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n use util::ppaux::Repr;\n@@ -39,7 +39,7 @@ impl Visitor<Context> for StackCheckVisitor {\n         stack_check_item(*self, i, e);\n     }\n     fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:&ast::Block, s:span, n:ast::NodeId, e:Context) {\n+                b:&ast::Block, s:Span, n:ast::NodeId, e:Context) {\n         stack_check_fn(*self, fk, fd, b, s, n, e);\n     }\n     fn visit_expr(&mut self, ex:@ast::expr, e:Context) {\n@@ -94,7 +94,7 @@ fn stack_check_fn<'a>(v: StackCheckVisitor,\n                       fk: &visit::fn_kind,\n                       decl: &ast::fn_decl,\n                       body: &ast::Block,\n-                      sp: span,\n+                      sp: Span,\n                       id: ast::NodeId,\n                       in_cx: Context) {\n     let safe_stack = match *fk {"}, {"sha": "9259b323d429bd024e74c6a437d86324ac869487", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -225,7 +225,7 @@ use syntax::ast;\n use syntax::ast::ident;\n use syntax::ast_util::path_to_ident;\n use syntax::ast_util;\n-use syntax::codemap::{span, dummy_sp};\n+use syntax::codemap::{Span, dummy_sp};\n \n // An option identifying a literal: either a unit-like struct or an\n // expression.\n@@ -386,7 +386,7 @@ struct BindingInfo {\n     llmatch: ValueRef,\n     trmode: TransBindingMode,\n     id: ast::NodeId,\n-    span: span,\n+    span: Span,\n     ty: ty::t,\n }\n \n@@ -1014,7 +1014,7 @@ fn match_datum(bcx: @mut Block, val: ValueRef, pat_id: ast::NodeId) -> Datum {\n \n \n fn extract_vec_elems(bcx: @mut Block,\n-                         pat_span: span,\n+                         pat_span: Span,\n                          pat_id: ast::NodeId,\n                          elem_count: uint,\n                          slice: Option<uint>,\n@@ -1891,7 +1891,7 @@ fn trans_match_inner(scope_cx: @mut Block,\n     bcx = controlflow::join_blocks(scope_cx, arm_cxs);\n     return bcx;\n \n-    fn mk_fail(bcx: @mut Block, sp: span, msg: @str,\n+    fn mk_fail(bcx: @mut Block, sp: Span, msg: @str,\n                finished: @mut Option<BasicBlockRef>) -> BasicBlockRef {\n         match *finished { Some(bb) => return bb, _ => () }\n         let fail_cx = sub_block(bcx, \"case_fallthrough\");"}, {"sha": "7206eb4755410b5f7d38cb3efee08328c7b10aa6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -81,7 +81,7 @@ use syntax::ast_map::{path, path_elt_to_str, path_name};\n use syntax::ast_util::{local_def};\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::parse::token::{special_idents};\n use syntax::print::pprust::stmt_to_str;\n@@ -138,7 +138,7 @@ fn fcx_has_nonzero_span(fcx: &FunctionContext) -> bool {\n     }\n }\n \n-fn span_is_empty(opt_span: &Option<span>) -> bool {\n+fn span_is_empty(opt_span: &Option<Span>) -> bool {\n     match *opt_span {\n         None => true,\n         Some(span) => *span.lo == 0 && *span.hi == 0\n@@ -791,7 +791,7 @@ pub fn cast_shift_rhs(op: ast::binop,\n     }\n }\n \n-pub fn fail_if_zero(cx: @mut Block, span: span, divrem: ast::binop,\n+pub fn fail_if_zero(cx: @mut Block, span: Span, divrem: ast::binop,\n                     rhs: ValueRef, rhs_t: ty::t) -> @mut Block {\n     let text = if divrem == ast::div {\n         @\"attempted to divide by zero\"\n@@ -1064,7 +1064,7 @@ pub fn load_if_immediate(cx: @mut Block, v: ValueRef, t: ty::t) -> ValueRef {\n     return v;\n }\n \n-pub fn trans_trace(bcx: @mut Block, sp_opt: Option<span>, trace_str: @str) {\n+pub fn trans_trace(bcx: @mut Block, sp_opt: Option<Span>, trace_str: @str) {\n     if !bcx.sess().trace() { return; }\n     let _icx = push_ctxt(\"trans_trace\");\n     add_comment(bcx, trace_str);\n@@ -1615,7 +1615,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n                         skip_retptr: bool,\n                         param_substs: Option<@param_substs>,\n                         opt_node_info: Option<NodeInfo>,\n-                        sp: Option<span>)\n+                        sp: Option<Span>)\n                      -> @mut FunctionContext {\n     for p in param_substs.iter() { p.validate(); }\n \n@@ -1690,7 +1690,7 @@ pub fn new_fn_ctxt(ccx: @mut CrateContext,\n                    path: path,\n                    llfndecl: ValueRef,\n                    output_type: ty::t,\n-                   sp: Option<span>)\n+                   sp: Option<Span>)\n                 -> @mut FunctionContext {\n     new_fn_ctxt_w_id(ccx, path, llfndecl, -1, output_type, false, None, None, sp)\n }\n@@ -2283,7 +2283,7 @@ pub fn trans_mod(ccx: @mut CrateContext, m: &ast::_mod) {\n }\n \n pub fn register_fn(ccx: @mut CrateContext,\n-                   sp: span,\n+                   sp: Span,\n                    sym: ~str,\n                    node_id: ast::NodeId,\n                    node_type: ty::t)\n@@ -2293,7 +2293,7 @@ pub fn register_fn(ccx: @mut CrateContext,\n }\n \n pub fn register_fn_llvmty(ccx: @mut CrateContext,\n-                          sp: span,\n+                          sp: Span,\n                           sym: ~str,\n                           node_id: ast::NodeId,\n                           cc: lib::llvm::CallConv,\n@@ -2309,7 +2309,7 @@ pub fn register_fn_llvmty(ccx: @mut CrateContext,\n     // FIXME #4404 android JNI hacks\n     let is_entry = is_entry_fn(&ccx.sess, node_id) && (!*ccx.sess.building_library ||\n                       (*ccx.sess.building_library &&\n-                       ccx.sess.targ_cfg.os == session::os_android));\n+                       ccx.sess.targ_cfg.os == session::OsAndroid));\n     if is_entry {\n         create_entry_wrapper(ccx, sp, llfn);\n     }\n@@ -2326,7 +2326,7 @@ pub fn is_entry_fn(sess: &Session, node_id: ast::NodeId) -> bool {\n // Create a _rust_main(args: ~[str]) function which will be called from the\n // runtime rust_start function\n pub fn create_entry_wrapper(ccx: @mut CrateContext,\n-                           _sp: span,\n+                           _sp: Span,\n                            main_llfn: ValueRef) {\n     let et = ccx.sess.entry_type.unwrap();\n     match et {"}, {"sha": "acec33f7004b3046e88f0dda6c404205e18e8e3a", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -15,7 +15,7 @@ use lib::llvm::{Opcode, IntPredicate, RealPredicate};\n use lib::llvm::{ValueRef, BasicBlockRef};\n use lib;\n use middle::trans::common::*;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n \n use middle::trans::builder::Builder;\n use middle::trans::type_::Type;\n@@ -629,7 +629,7 @@ pub fn _UndefReturn(cx: @mut Block, Fn: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn add_span_comment(cx: @mut Block, sp: span, text: &str) {\n+pub fn add_span_comment(cx: @mut Block, sp: Span, text: &str) {\n     B(cx).add_span_comment(sp, text)\n }\n "}, {"sha": "6a1acf68efa534aec0f223ae0e9401de6d7a5502", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -21,7 +21,7 @@ use std::cast;\n use std::hashmap::HashMap;\n use std::libc::{c_uint, c_ulonglong, c_char};\n use std::vec;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use std::ptr::is_not_null;\n \n pub struct Builder {\n@@ -728,7 +728,7 @@ impl Builder {\n         }\n     }\n \n-    pub fn add_span_comment(&self, sp: span, text: &str) {\n+    pub fn add_span_comment(&self, sp: Span, text: &str) {\n         if self.ccx.sess.asm_comments() {\n             let s = fmt!(\"%s (%s)\", text, self.ccx.sess.codemap.span_to_str(sp));\n             debug!(\"%s\", s);"}, {"sha": "de53d8dd3dadae71f7733b150e7090f14cbce6a9", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use driver::session::{os_win32, os_macos};\n+use driver::session::{OsWin32, OsMacos};\n use lib::llvm::*;\n use super::cabi::*;\n use super::common::*;\n@@ -42,7 +42,7 @@ pub fn compute_abi_info(ccx: &mut CrateContext,\n \n         enum Strategy { RetValue(Type), RetPointer }\n         let strategy = match ccx.sess.targ_cfg.os {\n-            os_win32 | os_macos => {\n+            OsWin32 | OsMacos => {\n                 match llsize_of_alloc(ccx, rty) {\n                     1 => RetValue(Type::i8()),\n                     2 => RetValue(Type::i16()),"}, {"sha": "6a0541f0046b40252efc81620a8c325c254552f8", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -40,7 +40,7 @@ use std::libc::{c_uint, c_longlong, c_ulonglong, c_char};\n use std::vec;\n use syntax::ast::ident;\n use syntax::ast_map::{path, path_elt};\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::{ast, ast_map};\n \n@@ -220,7 +220,7 @@ pub struct FunctionContext {\n \n     // The source span and nesting context where this function comes from, for\n     // error reporting and symbol generation.\n-    span: Option<span>,\n+    span: Option<Span>,\n     path: path,\n \n     // This function's enclosing crate context.\n@@ -509,7 +509,7 @@ impl get_node_info for Option<@ast::expr> {\n pub struct NodeInfo {\n     id: ast::NodeId,\n     callee_id: Option<ast::NodeId>,\n-    span: span\n+    span: Span\n }\n \n // Basic block context.  We create a block context for each basic block\n@@ -1110,7 +1110,7 @@ pub fn dummy_substs(tps: ~[ty::t]) -> ty::substs {\n }\n \n pub fn filename_and_line_num_from_span(bcx: @mut Block,\n-                                       span: span) -> (ValueRef, ValueRef) {\n+                                       span: Span) -> (ValueRef, ValueRef) {\n     let loc = bcx.sess().parse_sess.cm.lookup_char_pos(span.lo);\n     let filename_cstr = C_cstr(bcx.ccx(), loc.file.name);\n     let filename = build::PointerCast(bcx, filename_cstr, Type::i8p());\n@@ -1123,7 +1123,7 @@ pub fn bool_to_i1(bcx: @mut Block, llval: ValueRef) -> ValueRef {\n     build::ICmp(bcx, lib::llvm::IntNE, llval, C_bool(false))\n }\n \n-pub fn langcall(bcx: @mut Block, span: Option<span>, msg: &str,\n+pub fn langcall(bcx: @mut Block, span: Option<Span>, msg: &str,\n                 li: LangItem) -> ast::def_id {\n     match bcx.tcx().lang_items.require(li) {\n         Ok(id) => id,"}, {"sha": "feacede972545d40d95b8b53682e749593c5c76e", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -30,7 +30,7 @@ use syntax::ast;\n use syntax::ast::ident;\n use syntax::ast_map::path_mod;\n use syntax::ast_util;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n \n pub fn trans_block(bcx: @mut Block, b: &ast::Block, dest: expr::Dest) -> @mut Block {\n     let _icx = push_ctxt(\"trans_block\");\n@@ -353,7 +353,7 @@ pub fn trans_ret(bcx: @mut Block, e: Option<@ast::expr>) -> @mut Block {\n }\n \n pub fn trans_fail_expr(bcx: @mut Block,\n-                       sp_opt: Option<span>,\n+                       sp_opt: Option<Span>,\n                        fail_expr: Option<@ast::expr>)\n                     -> @mut Block {\n     let _icx = push_ctxt(\"trans_fail_expr\");\n@@ -381,7 +381,7 @@ pub fn trans_fail_expr(bcx: @mut Block,\n }\n \n pub fn trans_fail(bcx: @mut Block,\n-                  sp_opt: Option<span>,\n+                  sp_opt: Option<Span>,\n                   fail_str: @str)\n                -> @mut Block {\n     let _icx = push_ctxt(\"trans_fail\");\n@@ -390,7 +390,7 @@ pub fn trans_fail(bcx: @mut Block,\n }\n \n fn trans_fail_value(bcx: @mut Block,\n-                    sp_opt: Option<span>,\n+                    sp_opt: Option<Span>,\n                     V_fail_str: ValueRef)\n                  -> @mut Block {\n     let _icx = push_ctxt(\"trans_fail_value\");\n@@ -415,7 +415,7 @@ fn trans_fail_value(bcx: @mut Block,\n     return bcx;\n }\n \n-pub fn trans_fail_bounds_check(bcx: @mut Block, sp: span,\n+pub fn trans_fail_bounds_check(bcx: @mut Block, sp: Span,\n                                index: ValueRef, len: ValueRef) -> @mut Block {\n     let _icx = push_ctxt(\"trans_fail_bounds_check\");\n     let (filename, line) = filename_and_line_num_from_span(bcx, sp);"}, {"sha": "2fd0e38aea8c4808bb984a64d46799bdd5797f56", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -106,7 +106,7 @@ use util::ppaux::ty_to_str;\n \n use std::uint;\n use syntax::ast;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n \n #[deriving(Eq)]\n@@ -613,7 +613,7 @@ impl Datum {\n     /// is_auto: If true, only deref if auto-derefable.\n     pub fn try_deref(&self,\n                      bcx: @mut Block,\n-                     span: span,\n+                     span: Span,\n                      expr_id: ast::NodeId,\n                      derefs: uint,\n                      is_auto: bool)\n@@ -739,7 +739,7 @@ impl Datum {\n \n     pub fn autoderef(&self,\n                      bcx: @mut Block,\n-                     span: span,\n+                     span: Span,\n                      expr_id: ast::NodeId,\n                      max: uint)\n                      -> DatumBlock {\n@@ -772,7 +772,7 @@ impl Datum {\n \n     pub fn get_vec_base_and_len(&self,\n                                 mut bcx: @mut Block,\n-                                span: span,\n+                                span: Span,\n                                 expr_id: ast::NodeId,\n                                 derefs: uint)\n                                 -> (@mut Block, ValueRef, ValueRef) {\n@@ -796,7 +796,7 @@ impl Datum {\n \n     pub fn root_and_write_guard(&self,\n                                 bcx: @mut Block,\n-                                span: span,\n+                                span: Span,\n                                 expr_id: ast::NodeId,\n                                 derefs: uint)\n                                 -> @mut Block {"}, {"sha": "71269d5e61e2837568b5b3719804633c6a3bf207", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -68,7 +68,7 @@ use std::hashmap::HashMap;\n use std::libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n use std::vec;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::{ast, codemap, ast_util, ast_map, opt_vec};\n use syntax::parse::token::special_idents;\n \n@@ -158,7 +158,7 @@ pub fn create_match_binding_metadata(bcx: @mut Block,\n                                      variable_ident: ast::ident,\n                                      node_id: ast::NodeId,\n                                      variable_type: ty::t,\n-                                     span: span) {\n+                                     span: Span) {\n     declare_local(bcx, variable_ident, node_id, variable_type, span);\n }\n \n@@ -296,7 +296,7 @@ pub fn create_argument_metadata(bcx: @mut Block,\n /// reliably find the correct visibility scope for the code position.\n pub fn set_source_location(fcx: &FunctionContext,\n                            node_id: ast::NodeId,\n-                           span: span) {\n+                           span: Span) {\n     let cx: &mut CrateContext = fcx.ccx;\n \n     if !cx.sess.opts.debuginfo || (*span.lo == 0 && *span.hi == 0) {\n@@ -643,7 +643,7 @@ fn declare_local(bcx: @mut Block,\n                  variable_ident: ast::ident,\n                  node_id: ast::NodeId,\n                  variable_type: ty::t,\n-                 span: span) {\n+                 span: Span) {\n     let cx: &mut CrateContext = bcx.ccx();\n \n     let filename = span_start(cx, span).file.name;\n@@ -720,7 +720,7 @@ fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n /// Finds the scope metadata node for the given AST node.\n fn scope_metadata(fcx: &FunctionContext,\n                   node_id: ast::NodeId,\n-                  span: span) -> DIScope {\n+                  span: Span) -> DIScope {\n     if fcx.debug_context.is_none() {\n         fcx.ccx.sess.span_bug(span, \"debuginfo: FunctionDebugContext should be initialized \\\n                                      but is not!\");\n@@ -808,7 +808,7 @@ fn pointer_type_metadata(cx: &mut CrateContext,\n fn struct_metadata(cx: &mut CrateContext,\n                    struct_type: ty::t,\n                    fields: ~[ty::field],\n-                   span: span)\n+                   span: Span)\n                 -> DICompositeType {\n     let struct_name = ty_to_str(cx.tcx, struct_type);\n     debug!(\"struct_metadata: %s\", struct_name);\n@@ -840,7 +840,7 @@ fn struct_metadata(cx: &mut CrateContext,\n fn tuple_metadata(cx: &mut CrateContext,\n                   tuple_type: ty::t,\n                   component_types: &[ty::t],\n-                  span: span)\n+                  span: Span)\n                -> DICompositeType {\n \n     let tuple_name = ty_to_str(cx.tcx, tuple_type);\n@@ -865,7 +865,7 @@ fn tuple_metadata(cx: &mut CrateContext,\n fn enum_metadata(cx: &mut CrateContext,\n                  enum_type: ty::t,\n                  enum_def_id: ast::def_id,\n-                 span: span)\n+                 span: Span)\n               -> DIType {\n \n     let enum_name = ty_to_str(cx.tcx, enum_type);\n@@ -987,7 +987,7 @@ fn enum_metadata(cx: &mut CrateContext,\n                                   struct_def: &adt::Struct,\n                                   variant_info: &ty::VariantInfo,\n                                   discriminant_type_metadata: Option<DIType>,\n-                                  span: span)\n+                                  span: Span)\n                                -> DICompositeType\n     {\n         let arg_llvm_types: ~[Type] = do struct_def.fields.map |&ty| { type_of::type_of(cx, ty) };\n@@ -1031,7 +1031,7 @@ fn composite_type_metadata(cx: &mut CrateContext,\n                            member_llvm_types: &[Type],\n                            member_names: &[~str],\n                            member_type_metadata: &[DIType],\n-                           span: span)\n+                           span: Span)\n                         -> DICompositeType {\n \n     let loc = span_start(cx, span);\n@@ -1088,7 +1088,7 @@ fn boxed_type_metadata(cx: &mut CrateContext,\n                        content_type_name: Option<&str>,\n                        content_llvm_type: Type,\n                        content_type_metadata: DIType,\n-                       span: span)\n+                       span: Span)\n                     -> DICompositeType {\n \n     let box_type_name = match content_type_name {\n@@ -1140,7 +1140,7 @@ fn boxed_type_metadata(cx: &mut CrateContext,\n fn fixed_vec_metadata(cx: &mut CrateContext,\n                       element_type: ty::t,\n                       len: uint,\n-                      span: span)\n+                      span: Span)\n                    -> DIType {\n     let element_type_metadata = type_metadata(cx, element_type, span);\n     let element_llvm_type = type_of::type_of(cx, element_type);\n@@ -1166,7 +1166,7 @@ fn fixed_vec_metadata(cx: &mut CrateContext,\n \n fn vec_metadata(cx: &mut CrateContext,\n                 element_type: ty::t,\n-                span: span)\n+                span: Span)\n              -> DICompositeType {\n \n     let element_type_metadata = type_metadata(cx, element_type, span);\n@@ -1204,7 +1204,7 @@ fn vec_metadata(cx: &mut CrateContext,\n \n fn boxed_vec_metadata(cx: &mut CrateContext,\n                       element_type: ty::t,\n-                      span: span)\n+                      span: Span)\n                    -> DICompositeType {\n \n     let element_llvm_type = type_of::type_of(cx, element_type);\n@@ -1223,7 +1223,7 @@ fn boxed_vec_metadata(cx: &mut CrateContext,\n fn vec_slice_metadata(cx: &mut CrateContext,\n                       vec_type: ty::t,\n                       element_type: ty::t,\n-                      span: span)\n+                      span: Span)\n                    -> DICompositeType {\n \n     debug!(\"vec_slice_metadata: %?\", ty::get(vec_type));\n@@ -1264,7 +1264,7 @@ fn bare_fn_metadata(cx: &mut CrateContext,\n                     _fn_ty: ty::t,\n                     inputs: ~[ty::t],\n                     output: ty::t,\n-                    span: span)\n+                    span: Span)\n                  -> DICompositeType {\n \n     debug!(\"bare_fn_metadata: %?\", ty::get(_fn_ty));\n@@ -1307,7 +1307,7 @@ fn unimplemented_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n \n fn type_metadata(cx: &mut CrateContext,\n                  t: ty::t,\n-                 span: span)\n+                 span: Span)\n               -> DIType {\n     let type_id = ty::type_id(t);\n     match dbg_cx(cx).created_types.find(&type_id) {\n@@ -1493,7 +1493,7 @@ fn roundup(x: uint, a: uint) -> uint {\n }\n \n /// Return codemap::Loc corresponding to the beginning of the span\n-fn span_start(cx: &CrateContext, span: span) -> codemap::Loc {\n+fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n     cx.sess.codemap.lookup_char_pos(span.lo)\n }\n \n@@ -1561,7 +1561,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n     // local helper functions for walking the AST.\n \n     fn with_new_scope(cx: &mut CrateContext,\n-                      scope_span: span,\n+                      scope_span: Span,\n                       scope_stack: &mut ~[ScopeStackEntry],\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>,\n                       inner_walk: &fn(&mut CrateContext,\n@@ -1625,7 +1625,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n                  scope_stack: &mut ~[ScopeStackEntry],\n                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n         match *decl {\n-            codemap::spanned { node: ast::decl_local(@ref local), _ } => {\n+            codemap::Spanned { node: ast::decl_local(@ref local), _ } => {\n                 scope_map.insert(local.id, scope_stack.last().scope_metadata);\n \n                 walk_pattern(cx, local.pat, scope_stack, scope_map);"}, {"sha": "f36b20e053bf1e5c273c7afc9671fac90c6dae4d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -680,7 +680,7 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: @ast::expr,\n                 args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n             return trans_adt(bcx, repr, 0, numbered_fields, None, dest);\n         }\n-        ast::expr_lit(@codemap::spanned {node: ast::lit_str(s), _}) => {\n+        ast::expr_lit(@codemap::Spanned {node: ast::lit_str(s), _}) => {\n             return tvec::trans_lit_str(bcx, expr, s, dest);\n         }\n         ast::expr_vstore(contents, ast::expr_vstore_slice) |\n@@ -1163,7 +1163,7 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n fn trans_rec_or_struct(bcx: @mut Block,\n                        fields: &[ast::Field],\n                        base: Option<@ast::expr>,\n-                       expr_span: codemap::span,\n+                       expr_span: codemap::Span,\n                        id: ast::NodeId,\n                        dest: Dest) -> @mut Block\n {"}, {"sha": "26968ce4881725e3cc81bfd9c006d428e9ebd9fd", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -29,7 +29,7 @@ use middle::ty::FnSig;\n \n use std::uint;\n use std::vec;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::{ast};\n use syntax::{attr, ast_map};\n use syntax::parse::token::special_idents;\n@@ -350,7 +350,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n // correct code in the first place, but this is much simpler.\n \n pub fn register_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n-                                         sp: span,\n+                                         sp: Span,\n                                          sym: ~str,\n                                          node_id: ast::NodeId)\n                                          -> ValueRef {"}, {"sha": "59f5c9d0723a823fb8e58f5a9fb41d057e2364d1", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -205,7 +205,7 @@ pub fn trans_slice_vstore(bcx: @mut Block,\n \n     // Handle the &\"...\" case:\n     match content_expr.node {\n-        ast::expr_lit(@codemap::spanned {node: ast::lit_str(s), span: _}) => {\n+        ast::expr_lit(@codemap::Spanned {node: ast::lit_str(s), span: _}) => {\n             return trans_lit_str(bcx, content_expr, s, dest);\n         }\n         _ => {}\n@@ -295,7 +295,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: @a\n     match heap {\n         heap_exchange => {\n             match content_expr.node {\n-                ast::expr_lit(@codemap::spanned {\n+                ast::expr_lit(@codemap::Spanned {\n                     node: ast::lit_str(s), span\n                 }) => {\n                     let llptrval = C_cstr(bcx.ccx(), s);\n@@ -357,7 +357,7 @@ pub fn write_content(bcx: @mut Block,\n     let _indenter = indenter();\n \n     match content_expr.node {\n-        ast::expr_lit(@codemap::spanned { node: ast::lit_str(s), _ }) => {\n+        ast::expr_lit(@codemap::Spanned { node: ast::lit_str(s), _ }) => {\n             match dest {\n                 Ignore => {\n                     return bcx;\n@@ -490,7 +490,7 @@ pub fn elements_required(bcx: @mut Block, content_expr: &ast::expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n     match content_expr.node {\n-        ast::expr_lit(@codemap::spanned { node: ast::lit_str(s), _ }) => {\n+        ast::expr_lit(@codemap::Spanned { node: ast::lit_str(s), _ }) => {\n             s.len()\n         },\n         ast::expr_vec(ref es, _) => es.len(),"}, {"sha": "ad999e0c1aabc15c2f6f33312c7d44120885a222", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -28,14 +28,14 @@ use middle::trans::common::*;\n use middle::trans::datum::*;\n use middle::trans::expr;\n use middle::ty;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::ast;\n \n use middle::trans::type_::Type;\n \n pub fn root_and_write_guard(datum: &Datum,\n                             mut bcx: @mut Block,\n-                            span: span,\n+                            span: Span,\n                             expr_id: ast::NodeId,\n                             derefs: uint) -> @mut Block {\n     let key = root_map_key { id: expr_id, derefs: derefs };\n@@ -103,7 +103,7 @@ pub fn return_to_mut(mut bcx: @mut Block,\n \n fn root(datum: &Datum,\n         mut bcx: @mut Block,\n-        span: span,\n+        span: Span,\n         root_key: root_map_key,\n         root_info: RootInfo) -> @mut Block {\n     //! In some cases, borrowck will decide that an @T/@[]/@str\n@@ -183,7 +183,7 @@ fn root(datum: &Datum,\n \n fn perform_write_guard(datum: &Datum,\n                        bcx: @mut Block,\n-                       span: span) -> @mut Block {\n+                       span: Span) -> @mut Block {\n     debug!(\"perform_write_guard\");\n \n     let llval = datum.to_value_llval(bcx);"}, {"sha": "b464ce6d624e88a0d19a35422d5a652a303d9dcf", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -38,7 +38,7 @@ use syntax::ast::*;\n use syntax::ast_util::is_local;\n use syntax::ast_util;\n use syntax::attr;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::codemap;\n use syntax::parse::token;\n use syntax::{ast, ast_map};\n@@ -2898,7 +2898,7 @@ pub fn ty_vstore(ty: t) -> vstore {\n }\n \n pub fn ty_region(tcx: ctxt,\n-                 span: span,\n+                 span: Span,\n                  ty: t) -> Region {\n     match get(ty).sty {\n         ty_rptr(r, _) => r,\n@@ -2996,7 +2996,7 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: &ast::expr) -> t {\n }\n \n pub fn adjust_ty(cx: ctxt,\n-                 span: span,\n+                 span: Span,\n                  unadjusted_ty: ty::t,\n                  adjustment: Option<@AutoAdjustment>) -> ty::t\n {\n@@ -3076,7 +3076,7 @@ pub fn adjust_ty(cx: ctxt,\n         }\n     };\n \n-    fn borrow_vec(cx: ctxt, span: span,\n+    fn borrow_vec(cx: ctxt, span: Span,\n                   r: Region, m: ast::mutability,\n                   ty: ty::t) -> ty::t {\n         match get(ty).sty {\n@@ -3097,7 +3097,7 @@ pub fn adjust_ty(cx: ctxt,\n         }\n     }\n \n-    fn borrow_fn(cx: ctxt, span: span, r: Region, ty: ty::t) -> ty::t {\n+    fn borrow_fn(cx: ctxt, span: Span, r: Region, ty: ty::t) -> ty::t {\n         match get(ty).sty {\n             ty_closure(ref fty) => {\n                 ty::mk_closure(cx, ClosureTy {\n@@ -3116,7 +3116,7 @@ pub fn adjust_ty(cx: ctxt,\n         }\n     }\n \n-    fn borrow_obj(cx: ctxt, span: span, r: Region,\n+    fn borrow_obj(cx: ctxt, span: Span, r: Region,\n                   m: ast::mutability, ty: ty::t) -> ty::t {\n         match get(ty).sty {\n             ty_trait(trt_did, ref trt_substs, _, _, b) => {\n@@ -3283,7 +3283,7 @@ pub fn expr_kind(tcx: ctxt,\n         ast::expr_do_body(*) |\n         ast::expr_block(*) |\n         ast::expr_repeat(*) |\n-        ast::expr_lit(@codemap::spanned {node: lit_str(_), _}) |\n+        ast::expr_lit(@codemap::Spanned {node: lit_str(_), _}) |\n         ast::expr_vstore(_, ast::expr_vstore_slice) |\n         ast::expr_vstore(_, ast::expr_vstore_mut_slice) |\n         ast::expr_vec(*) => {\n@@ -3395,7 +3395,7 @@ pub fn param_tys_in_type(ty: t) -> ~[param_ty] {\n     rslt\n }\n \n-pub fn occurs_check(tcx: ctxt, sp: span, vid: TyVid, rt: t) {\n+pub fn occurs_check(tcx: ctxt, sp: Span, vid: TyVid, rt: t) {\n     // Returns a vec of all the type variables occurring in `ty`. It may\n     // contain duplicates.  (Integral type vars aren't counted.)\n     fn vars_in_type(ty: t) -> ~[TyVid] {"}, {"sha": "419bc999e033ac2e9381d82975be3d641a56bc72", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -65,7 +65,7 @@ use middle::typeck::lookup_def_tcx;\n use std::result;\n use syntax::abi::AbiSet;\n use syntax::{ast, ast_util};\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n use syntax::print::pprust::{lifetime_to_str, path_to_str};\n@@ -78,12 +78,12 @@ pub trait AstConv {\n     fn get_trait_def(&self, id: ast::def_id) -> @ty::TraitDef;\n \n     // what type should we use when a type is omitted?\n-    fn ty_infer(&self, span: span) -> ty::t;\n+    fn ty_infer(&self, span: Span) -> ty::t;\n }\n \n pub fn get_region_reporting_err(\n     tcx: ty::ctxt,\n-    span: span,\n+    span: Span,\n     a_r: &Option<ast::Lifetime>,\n     res: Result<ty::Region, RegionError>) -> ty::Region\n {\n@@ -107,7 +107,7 @@ pub fn get_region_reporting_err(\n pub fn ast_region_to_region<AC:AstConv,RS:RegionScope + Clone + 'static>(\n     this: &AC,\n     rscope: &RS,\n-    default_span: span,\n+    default_span: Span,\n     opt_lifetime: &Option<ast::Lifetime>) -> ty::Region\n {\n     let (span, res) = match opt_lifetime {\n@@ -701,7 +701,7 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope + Clone + 'static>(\n     decl: &ast::fn_decl,\n     expected_sig: Option<ty::FnSig>,\n     lifetimes: &OptVec<ast::Lifetime>,\n-    span: span)\n+    span: Span)\n     -> ty::ClosureTy\n {\n     // The caller should not both provide explicit bound lifetime"}, {"sha": "b2cec19963df97cd2f8d50b49b006e32a3be4d69", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -21,7 +21,7 @@ use middle::typeck::require_same_types;\n use std::hashmap::{HashMap, HashSet};\n use syntax::ast;\n use syntax::ast_util;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::print::pprust;\n \n pub fn check_match(fcx: @mut FnCtxt,\n@@ -284,7 +284,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n /// (e.g. K,V in HashMap<K,V>).\n /// `etc` is true if the pattern said '...' and false otherwise.\n pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n-                               span: span,\n+                               span: Span,\n                                path: &ast::Path,\n                                fields: &[ast::field_pat],\n                                class_fields: ~[ty::field_ty],\n@@ -338,7 +338,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n     }\n }\n \n-pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::NodeId, span: span,\n+pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::NodeId, span: Span,\n                         expected: ty::t, path: &ast::Path,\n                         fields: &[ast::field_pat], etc: bool,\n                         struct_id: ast::def_id,\n@@ -372,7 +372,7 @@ pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::NodeId, span: span,\n \n pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n                                           pat_id: ast::NodeId,\n-                                          span: span,\n+                                          span: Span,\n                                           expected: ty::t,\n                                           path: &ast::Path,\n                                           fields: &[ast::field_pat],\n@@ -651,7 +651,7 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n                          pointer_kind: PointerKind,\n                          inner: @ast::pat,\n                          pat_id: ast::NodeId,\n-                         span: span,\n+                         span: Span,\n                          expected: ty::t) {\n     let fcx = pcx.fcx;\n     let check_inner: &fn(ty::mt) = |e_inner| {"}, {"sha": "6b755510e8d15134642c2fbda0c8ca0aecd01e22", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -16,24 +16,24 @@ use middle::typeck::infer;\n use std::result::{Err, Ok};\n use std::result;\n use syntax::ast;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n \n // Requires that the two types unify, and prints an error message if they\n // don't.\n-pub fn suptype(fcx: @mut FnCtxt, sp: span, expected: ty::t, actual: ty::t) {\n+pub fn suptype(fcx: @mut FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n     suptype_with_fn(fcx, sp, false, expected, actual,\n         |sp, e, a, s| { fcx.report_mismatched_types(sp, e, a, s) })\n }\n \n-pub fn subtype(fcx: @mut FnCtxt, sp: span, expected: ty::t, actual: ty::t) {\n+pub fn subtype(fcx: @mut FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n     suptype_with_fn(fcx, sp, true, actual, expected,\n         |sp, a, e, s| { fcx.report_mismatched_types(sp, e, a, s) })\n }\n \n pub fn suptype_with_fn(fcx: @mut FnCtxt,\n-                       sp: span, b_is_expected: bool,\n+                       sp: Span, b_is_expected: bool,\n                        ty_a: ty::t, ty_b: ty::t,\n-                       handle_err: &fn(span, ty::t, ty::t, &ty::type_err)) {\n+                       handle_err: &fn(Span, ty::t, ty::t, &ty::type_err)) {\n     // n.b.: order of actual, expected is reversed\n     match infer::mk_subty(fcx.infcx(), b_is_expected, infer::Misc(sp),\n                           ty_b, ty_a) {\n@@ -44,7 +44,7 @@ pub fn suptype_with_fn(fcx: @mut FnCtxt,\n     }\n }\n \n-pub fn eqtype(fcx: @mut FnCtxt, sp: span, expected: ty::t, actual: ty::t) {\n+pub fn eqtype(fcx: @mut FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n     match infer::mk_eqty(fcx.infcx(), false, infer::Misc(sp), actual, expected) {\n         Ok(()) => { /* ok */ }\n         Err(ref err) => {\n@@ -55,7 +55,7 @@ pub fn eqtype(fcx: @mut FnCtxt, sp: span, expected: ty::t, actual: ty::t) {\n \n // Checks that the type `actual` can be coerced to `expected`.\n pub fn coerce(fcx: @mut FnCtxt,\n-              sp: span,\n+              sp: Span,\n               expected: ty::t,\n               expr: @ast::expr) {\n     let expr_ty = fcx.expr_ty(expr);"}, {"sha": "0d4185470b7dce288eabae88ecece6061a15fbb5", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -122,7 +122,7 @@ use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::local_def;\n use syntax::ast_util;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::codemap;\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n@@ -144,7 +144,7 @@ pub mod method;\n pub struct SelfInfo {\n     self_ty: ty::t,\n     self_id: ast::NodeId,\n-    span: span\n+    span: Span\n }\n \n /// Fields that are part of a `FnCtxt` which are inherited by\n@@ -398,7 +398,7 @@ impl Visitor<()> for GatherLocalsVisitor {\n \n         // Don't descend into fns and items\n     fn visit_fn(&mut self, _:&visit::fn_kind, _:&ast::fn_decl,\n-                _:&ast::Block, _:span, _:ast::NodeId, _:()) { }\n+                _:&ast::Block, _:Span, _:ast::NodeId, _:()) { }\n     fn visit_item(&mut self, _:@ast::item, _:()) { }\n \n }\n@@ -557,7 +557,7 @@ pub fn check_method(ccx: @mut CrateCtxt,\n }\n \n pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n-                                 fields: ~[(ast::ident, span)]) {\n+                                 fields: ~[(ast::ident, Span)]) {\n     let mut field_names = HashMap::new();\n \n     for p in fields.iter() {\n@@ -577,7 +577,7 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n     }\n }\n \n-pub fn check_struct(ccx: @mut CrateCtxt, id: ast::NodeId, span: span) {\n+pub fn check_struct(ccx: @mut CrateCtxt, id: ast::NodeId, span: Span) {\n     let tcx = ccx.tcx;\n \n     // Check that the class is instantiable\n@@ -665,7 +665,7 @@ impl AstConv for FnCtxt {\n         ty::lookup_trait_def(self.tcx(), id)\n     }\n \n-    fn ty_infer(&self, _span: span) -> ty::t {\n+    fn ty_infer(&self, _span: Span) -> ty::t {\n         self.infcx().next_ty_var()\n     }\n }\n@@ -678,7 +678,7 @@ impl FnCtxt {\n         self.ccx.tcx.sess.err_count() - self.err_count_on_creation\n     }\n     pub fn search_in_scope_regions(&self,\n-                                   span: span,\n+                                   span: Span,\n                                    br: ty::bound_region)\n                                    -> Result<ty::Region, RegionError> {\n         let in_scope_regions = self.in_scope_regions;\n@@ -706,14 +706,14 @@ impl FnCtxt {\n }\n \n impl RegionScope for FnCtxt {\n-    fn anon_region(&self, span: span) -> Result<ty::Region, RegionError> {\n+    fn anon_region(&self, span: Span) -> Result<ty::Region, RegionError> {\n         result::Ok(self.infcx().next_region_var(infer::MiscVariable(span)))\n     }\n-    fn self_region(&self, span: span) -> Result<ty::Region, RegionError> {\n+    fn self_region(&self, span: Span) -> Result<ty::Region, RegionError> {\n         self.search_in_scope_regions(span, ty::br_self)\n     }\n     fn named_region(&self,\n-                    span: span,\n+                    span: Span,\n                     id: ast::ident) -> Result<ty::Region, RegionError> {\n         self.search_in_scope_regions(span, ty::br_named(id))\n     }\n@@ -726,7 +726,7 @@ impl FnCtxt {\n         }\n     }\n \n-    pub fn local_ty(&self, span: span, nid: ast::NodeId) -> ty::t {\n+    pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> ty::t {\n         match self.inh.locals.find(&nid) {\n             Some(&t) => t,\n             None => {\n@@ -918,7 +918,7 @@ impl FnCtxt {\n \n     pub fn region_var_if_parameterized(&self,\n                                        rp: Option<ty::region_variance>,\n-                                       span: span)\n+                                       span: Span)\n                                        -> OptVec<ty::Region> {\n         match rp {\n             None => opt_vec::Empty,\n@@ -931,15 +931,15 @@ impl FnCtxt {\n     }\n \n     pub fn type_error_message(&self,\n-                              sp: span,\n+                              sp: Span,\n                               mk_msg: &fn(~str) -> ~str,\n                               actual_ty: ty::t,\n                               err: Option<&ty::type_err>) {\n         self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n     }\n \n     pub fn report_mismatched_return_types(&self,\n-                                          sp: span,\n+                                          sp: Span,\n                                           e: ty::t,\n                                           a: ty::t,\n                                           err: &ty::type_err) {\n@@ -951,15 +951,15 @@ impl FnCtxt {\n     }\n \n     pub fn report_mismatched_types(&self,\n-                                   sp: span,\n+                                   sp: Span,\n                                    e: ty::t,\n                                    a: ty::t,\n                                    err: &ty::type_err) {\n         self.infcx().report_mismatched_types(sp, e, a, err)\n     }\n }\n \n-pub fn do_autoderef(fcx: @mut FnCtxt, sp: span, t: ty::t) -> (ty::t, uint) {\n+pub fn do_autoderef(fcx: @mut FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n     /*!\n      *\n      * Autoderefs the type `t` as many times as possible, returning\n@@ -1306,7 +1306,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     fn check_method_argument_types(\n         fcx: @mut FnCtxt,\n-        sp: span,\n+        sp: Span,\n         method_fn_ty: ty::t,\n         callee_expr: @ast::expr,\n         args: &[@ast::expr],\n@@ -1336,7 +1336,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     fn check_argument_types(\n         fcx: @mut FnCtxt,\n-        sp: span,\n+        sp: Span,\n         fn_inputs: &[ty::t],\n         callee_expr: @ast::expr,\n         args: &[@ast::expr],\n@@ -1597,7 +1597,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                        then_blk: &ast::Block,\n                        opt_else_expr: Option<@ast::expr>,\n                        id: ast::NodeId,\n-                       sp: span,\n+                       sp: Span,\n                        expected: Option<ty::t>) {\n         check_expr_has_type(fcx, cond_expr, ty::mk_bool());\n \n@@ -2005,7 +2005,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     fn check_struct_or_variant_fields(fcx: @mut FnCtxt,\n-                                      span: span,\n+                                      span: Span,\n                                       class_id: ast::def_id,\n                                       node_id: ast::NodeId,\n                                       substitutions: ty::substs,\n@@ -2096,7 +2096,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     fn check_struct_constructor(fcx: @mut FnCtxt,\n                                 id: ast::NodeId,\n-                                span: codemap::span,\n+                                span: codemap::Span,\n                                 class_id: ast::def_id,\n                                 fields: &[ast::Field],\n                                 base_expr: Option<@ast::expr>) {\n@@ -2185,7 +2185,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     fn check_struct_enum_variant(fcx: @mut FnCtxt,\n                                  id: ast::NodeId,\n-                                 span: codemap::span,\n+                                 span: codemap::Span,\n                                  enum_id: ast::def_id,\n                                  variant_id: ast::def_id,\n                                  fields: &[ast::Field]) {\n@@ -2259,7 +2259,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     match expr.node {\n       ast::expr_vstore(ev, vst) => {\n         let typ = match ev.node {\n-          ast::expr_lit(@codemap::spanned { node: ast::lit_str(_), _ }) => {\n+          ast::expr_lit(@codemap::Spanned { node: ast::lit_str(_), _ }) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             ty::mk_estr(tcx, tt)\n           }\n@@ -2708,7 +2708,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                 _ => false\n                             }\n                         }\n-                        fn types_compatible(fcx: @mut FnCtxt, sp: span,\n+                        fn types_compatible(fcx: @mut FnCtxt, sp: Span,\n                                             t1: ty::t, t2: ty::t) -> bool {\n                             if !is_vec(t1) {\n                                 false\n@@ -2897,7 +2897,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     unifier();\n }\n \n-pub fn require_integral(fcx: @mut FnCtxt, sp: span, t: ty::t) {\n+pub fn require_integral(fcx: @mut FnCtxt, sp: Span, t: ty::t) {\n     if !type_is_integral(fcx, sp, t) {\n         fcx.type_error_message(sp, |actual| {\n             fmt!(\"mismatched types: expected integral type but found `%s`\",\n@@ -3022,7 +3022,7 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n             let s_id = ast_util::stmt_id(*s);\n             let s_ty = fcx.node_ty(s_id);\n             if last_was_bot && !warned && match s.node {\n-                  ast::stmt_decl(@codemap::spanned { node: ast::decl_local(_),\n+                  ast::stmt_decl(@codemap::Spanned { node: ast::decl_local(_),\n                                                  _}, _) |\n                   ast::stmt_expr(_, _) | ast::stmt_semi(_, _) => {\n                     true\n@@ -3070,7 +3070,7 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n }\n \n pub fn check_const(ccx: @mut CrateCtxt,\n-                   sp: span,\n+                   sp: Span,\n                    e: @ast::expr,\n                    id: ast::NodeId) {\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n@@ -3080,7 +3080,7 @@ pub fn check_const(ccx: @mut CrateCtxt,\n }\n \n pub fn check_const_with_ty(fcx: @mut FnCtxt,\n-                           _: span,\n+                           _: Span,\n                            e: @ast::expr,\n                            declty: ty::t) {\n     check_expr(fcx, e);\n@@ -3102,7 +3102,7 @@ pub fn check_const_with_ty(fcx: @mut FnCtxt,\n ///\n /// is representable, but not instantiable.\n pub fn check_instantiable(tcx: ty::ctxt,\n-                          sp: span,\n+                          sp: Span,\n                           item_id: ast::NodeId) {\n     let item_ty = ty::node_id_to_type(tcx, item_id);\n     if !ty::is_instantiable(tcx, item_ty) {\n@@ -3113,7 +3113,7 @@ pub fn check_instantiable(tcx: ty::ctxt,\n     }\n }\n \n-pub fn check_simd(tcx: ty::ctxt, sp: span, id: ast::NodeId) {\n+pub fn check_simd(tcx: ty::ctxt, sp: Span, id: ast::NodeId) {\n     let t = ty::node_id_to_type(tcx, id);\n     if ty::type_needs_subst(t) {\n         tcx.sess.span_err(sp, \"SIMD vector cannot be generic\");\n@@ -3143,7 +3143,7 @@ pub fn check_simd(tcx: ty::ctxt, sp: span, id: ast::NodeId) {\n }\n \n pub fn check_enum_variants(ccx: @mut CrateCtxt,\n-                           sp: span,\n+                           sp: Span,\n                            vs: &[ast::variant],\n                            id: ast::NodeId) {\n     fn do_check(ccx: @mut CrateCtxt,\n@@ -3236,13 +3236,13 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n     check_instantiable(ccx.tcx, sp, id);\n }\n \n-pub fn lookup_def(fcx: @mut FnCtxt, sp: span, id: ast::NodeId) -> ast::def {\n+pub fn lookup_def(fcx: @mut FnCtxt, sp: Span, id: ast::NodeId) -> ast::def {\n     lookup_def_ccx(fcx.ccx, sp, id)\n }\n \n // Returns the type parameter count and the type for the given definition.\n pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n-                                      sp: span,\n+                                      sp: Span,\n                                       defn: ast::def)\n                                    -> ty_param_bounds_and_ty {\n     match defn {\n@@ -3295,7 +3295,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n                         pth: &ast::Path,\n                         tpt: ty_param_bounds_and_ty,\n                         def: ast::def,\n-                        span: span,\n+                        span: Span,\n                         node_id: ast::NodeId) {\n     debug!(\">>> instantiate_path\");\n \n@@ -3409,7 +3409,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n \n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n // resolution is possible, then an error is reported.\n-pub fn structurally_resolved_type(fcx: @mut FnCtxt, sp: span, tp: ty::t)\n+pub fn structurally_resolved_type(fcx: @mut FnCtxt, sp: Span, tp: ty::t)\n                                -> ty::t {\n     match infer::resolve_type(fcx.infcx(), tp, force_tvar) {\n         Ok(t_s) if !ty::type_is_ty_var(t_s) => t_s,\n@@ -3424,32 +3424,32 @@ pub fn structurally_resolved_type(fcx: @mut FnCtxt, sp: span, tp: ty::t)\n }\n \n // Returns the one-level-deep structure of the given type.\n-pub fn structure_of<'a>(fcx: @mut FnCtxt, sp: span, typ: ty::t)\n+pub fn structure_of<'a>(fcx: @mut FnCtxt, sp: Span, typ: ty::t)\n                         -> &'a ty::sty {\n     &ty::get(structurally_resolved_type(fcx, sp, typ)).sty\n }\n \n-pub fn type_is_integral(fcx: @mut FnCtxt, sp: span, typ: ty::t) -> bool {\n+pub fn type_is_integral(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_integral(typ_s);\n }\n \n-pub fn type_is_scalar(fcx: @mut FnCtxt, sp: span, typ: ty::t) -> bool {\n+pub fn type_is_scalar(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_scalar(typ_s);\n }\n \n-pub fn type_is_unsafe_ptr(fcx: @mut FnCtxt, sp: span, typ: ty::t) -> bool {\n+pub fn type_is_unsafe_ptr(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_unsafe_ptr(typ_s);\n }\n \n-pub fn type_is_region_ptr(fcx: @mut FnCtxt, sp: span, typ: ty::t) -> bool {\n+pub fn type_is_region_ptr(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_region_ptr(typ_s);\n }\n \n-pub fn type_is_c_like_enum(fcx: @mut FnCtxt, sp: span, typ: ty::t) -> bool {\n+pub fn type_is_c_like_enum(fcx: @mut FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_c_like_enum(fcx.ccx.tcx, typ_s);\n }\n@@ -3492,7 +3492,7 @@ pub fn may_break(cx: ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n }\n \n pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n-                             span: span,\n+                             span: Span,\n                              tps: &OptVec<ast::TyParam>,\n                              ty: ty::t) {\n     debug!(\"check_bounds_are_used(n_tps=%u, ty=%s)\","}, {"sha": "dc5a60876a45e341552d199da35ae03323746bf2", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -42,7 +42,7 @@ use middle::pat_util;\n use syntax::ast::{ManagedSigil, OwnedSigil, BorrowedSigil};\n use syntax::ast::{def_arg, def_binding, def_local, def_self, def_upvar};\n use syntax::ast;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -626,7 +626,7 @@ fn constrain_derefs(rcx: @mut Rcx,\n }\n \n pub fn mk_subregion_due_to_derefence(rcx: @mut Rcx,\n-                                     deref_span: span,\n+                                     deref_span: Span,\n                                      minimum_lifetime: ty::Region,\n                                      maximum_lifetime: ty::Region) {\n     rcx.fcx.mk_subr(true, infer::DerefPointer(deref_span),\n@@ -809,7 +809,7 @@ pub mod guarantor {\n     use middle::typeck::infer;\n     use middle::ty;\n     use syntax::ast;\n-    use syntax::codemap::span;\n+    use syntax::codemap::Span;\n     use util::ppaux::{ty_to_str};\n \n     pub fn for_addr_of(rcx: @mut Rcx, expr: @ast::expr, base: @ast::expr) {\n@@ -918,7 +918,7 @@ pub mod guarantor {\n \n     fn link(\n         rcx: @mut Rcx,\n-        span: span,\n+        span: Span,\n         id: ast::NodeId,\n         guarantor: Option<ty::Region>) {\n         /*!"}, {"sha": "abea685eaf89709c0c870a11e28d94e67eacb979", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -27,7 +27,7 @@ use std::hashmap::HashSet;\n use std::result;\n use syntax::ast;\n use syntax::ast_util;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::print::pprust::expr_to_str;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -62,7 +62,7 @@ use syntax::visit::Visitor;\n /// responsible for this vtable instantiation. (This may not be an expression\n /// if the vtable instantiation is being performed as part of \"deriving\".)\n pub struct LocationInfo {\n-    span: span,\n+    span: Span,\n     id: ast::NodeId\n }\n "}, {"sha": "6878cbcbb7b21dd408c697078c27885fe6c58259", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -27,11 +27,11 @@ use middle::typeck::write_ty_to_tcx;\n use util::ppaux;\n \n use syntax::ast;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::print::pprust::pat_to_str;\n use syntax::oldvisit;\n \n-fn resolve_type_vars_in_type(fcx: @mut FnCtxt, sp: span, typ: ty::t)\n+fn resolve_type_vars_in_type(fcx: @mut FnCtxt, sp: Span, typ: ty::t)\n                           -> Option<ty::t> {\n     if !ty::type_needs_infer(typ) { return Some(typ); }\n     match resolve_type(fcx.infcx(), typ, resolve_all | force_all) {\n@@ -49,7 +49,7 @@ fn resolve_type_vars_in_type(fcx: @mut FnCtxt, sp: span, typ: ty::t)\n     }\n }\n \n-fn resolve_type_vars_in_types(fcx: @mut FnCtxt, sp: span, tys: &[ty::t])\n+fn resolve_type_vars_in_types(fcx: @mut FnCtxt, sp: Span, tys: &[ty::t])\n                           -> ~[ty::t] {\n     tys.map(|t| {\n         match resolve_type_vars_in_type(fcx, sp, *t) {\n@@ -59,7 +59,7 @@ fn resolve_type_vars_in_types(fcx: @mut FnCtxt, sp: span, tys: &[ty::t])\n     })\n }\n \n-fn resolve_method_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::NodeId) {\n+fn resolve_method_map_entry(fcx: @mut FnCtxt, sp: Span, id: ast::NodeId) {\n     // Resolve any method map entry\n     match fcx.inh.method_map.find(&id) {\n         None => {}\n@@ -79,7 +79,7 @@ fn resolve_method_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::NodeId) {\n     }\n }\n \n-fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::NodeId) {\n+fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: Span, id: ast::NodeId) {\n     // Resolve any method map entry\n     match fcx.inh.vtable_map.find(&id) {\n         None => {}\n@@ -92,13 +92,13 @@ fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::NodeId) {\n         }\n     }\n \n-    fn resolve_origins(fcx: @mut FnCtxt, sp: span,\n+    fn resolve_origins(fcx: @mut FnCtxt, sp: Span,\n                        vtbls: vtable_res) -> vtable_res {\n         @vtbls.map(|os| @os.map(|o| resolve_origin(fcx, sp, o)))\n     }\n \n     fn resolve_origin(fcx: @mut FnCtxt,\n-                      sp: span,\n+                      sp: Span,\n                       origin: &vtable_origin) -> vtable_origin {\n         match origin {\n             &vtable_static(def_id, ref tys, origins) => {\n@@ -113,7 +113,7 @@ fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::NodeId) {\n     }\n }\n \n-fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: span, id: ast::NodeId)\n+fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: Span, id: ast::NodeId)\n                            -> Option<ty::t> {\n     let fcx = wbcx.fcx;\n     let tcx = fcx.ccx.tcx;\n@@ -196,7 +196,7 @@ fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: span, id: ast::NodeId)\n }\n \n fn maybe_resolve_type_vars_for_node(wbcx: @mut WbCtxt,\n-                                    sp: span,\n+                                    sp: Span,\n                                     id: ast::NodeId)\n                                  -> Option<ty::t> {\n     if wbcx.fcx.inh.node_types.contains_key(&id) {"}, {"sha": "91ebbbd17ba00aa78f9b709eb0f1dfa8d455c951", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -42,7 +42,7 @@ use syntax::ast;\n use syntax::ast_map::node_item;\n use syntax::ast_map;\n use syntax::ast_util::{def_id_of_def, local_def};\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::opt_vec;\n use syntax::visit;\n use syntax::parse;\n@@ -58,7 +58,7 @@ pub struct UniversalQuantificationResult {\n }\n \n pub fn get_base_type(inference_context: @mut InferCtxt,\n-                     span: span,\n+                     span: Span,\n                      original_type: t)\n                   -> Option<t> {\n     let resolved_type;\n@@ -121,7 +121,7 @@ pub fn type_is_defined_in_local_crate(original_type: t) -> bool {\n \n // Returns the def ID of the base type, if there is one.\n pub fn get_base_type_def_id(inference_context: @mut InferCtxt,\n-                            span: span,\n+                            span: Span,\n                             original_type: t)\n                          -> Option<def_id> {\n     match get_base_type(inference_context, span, original_type) {\n@@ -546,7 +546,7 @@ impl CoherenceChecker {\n         &self,\n         all_methods: &mut ~[@Method],\n         trait_did: def_id,\n-        trait_ref_span: span) {\n+        trait_ref_span: Span) {\n \n         let tcx = self.crate_context.tcx;\n \n@@ -647,7 +647,7 @@ impl CoherenceChecker {\n         }\n     }\n \n-    pub fn span_of_impl(&self, implementation: @Impl) -> span {\n+    pub fn span_of_impl(&self, implementation: @Impl) -> Span {\n         assert_eq!(implementation.did.crate, LOCAL_CRATE);\n         match self.crate_context.tcx.items.find(&implementation.did.node) {\n             Some(&node_item(item, _)) => {"}, {"sha": "4707af5ca6c8cc31f35c12555f830a405e2cc0f0", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -54,7 +54,7 @@ use syntax::ast::{RegionTyParamBound, TraitTyParamBound};\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::{local_def, split_trait_methods};\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::codemap;\n use syntax::print::pprust::{path_to_str, explicit_self_to_str};\n use syntax::visit;\n@@ -140,7 +140,7 @@ impl AstConv for CrateCtxt {\n         get_trait_def(self, id)\n     }\n \n-    fn ty_infer(&self, span: span) -> ty::t {\n+    fn ty_infer(&self, span: Span) -> ty::t {\n         self.tcx.sess.span_bug(span,\n                                \"found `ty_infer` in unexpected place\");\n     }\n@@ -397,7 +397,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n \n pub fn ensure_supertraits(ccx: &CrateCtxt,\n                           id: ast::NodeId,\n-                          sp: codemap::span,\n+                          sp: codemap::Span,\n                           rp: Option<ty::region_variance>,\n                           ast_trait_refs: &[ast::trait_ref],\n                           generics: &ast::Generics) -> ty::BuiltinBounds\n@@ -740,7 +740,7 @@ pub fn convert_field(ccx: &CrateCtxt,\n pub struct ConvertedMethod {\n     mty: @ty::Method,\n     id: ast::NodeId,\n-    span: span,\n+    span: Span,\n     body_id: ast::NodeId\n }\n \n@@ -828,7 +828,7 @@ pub fn convert_methods(ccx: &CrateCtxt,\n }\n \n pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n-                                 span: span,\n+                                 span: Span,\n                                  generics: &ast::Generics,\n                                  thing: &'static str) {\n     for ty_param in generics.ty_params.iter() {"}, {"sha": "da3471168ddc49ceec517429343fa3d2e46464ca", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -44,7 +44,7 @@ use extra::smallintmap::SmallIntMap;\n use syntax::ast::{m_imm, m_mutbl};\n use syntax::ast;\n use syntax::codemap;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n \n pub mod doc;\n pub mod macros;\n@@ -100,25 +100,25 @@ pub struct InferCtxt {\n #[deriving(Clone)]\n pub enum TypeOrigin {\n     // Not yet categorized in a better way\n-    Misc(span),\n+    Misc(Span),\n \n     // Checking that method of impl is compatible with trait\n-    MethodCompatCheck(span),\n+    MethodCompatCheck(Span),\n \n     // Checking that this expression can be assigned where it needs to be\n     ExprAssignable(@ast::expr),\n \n     // Relating trait refs when resolving vtables\n-    RelateTraitRefs(span),\n+    RelateTraitRefs(Span),\n \n     // Relating trait refs when resolving vtables\n-    RelateSelfType(span),\n+    RelateSelfType(Span),\n \n     // Computing common supertype in a match expression\n-    MatchExpression(span),\n+    MatchExpression(Span),\n \n     // Computing common supertype in an if expression\n-    IfExpression(span),\n+    IfExpression(Span),\n }\n \n /// See `error_reporting.rs` for more details\n@@ -148,47 +148,47 @@ pub enum SubregionOrigin {\n \n     // Stack-allocated closures cannot outlive innermost loop\n     // or function so as to ensure we only require finite stack\n-    InfStackClosure(span),\n+    InfStackClosure(Span),\n \n     // Invocation of closure must be within its lifetime\n-    InvokeClosure(span),\n+    InvokeClosure(Span),\n \n     // Dereference of borrowed pointer must be within its lifetime\n-    DerefPointer(span),\n+    DerefPointer(Span),\n \n     // Closure bound must not outlive captured free variables\n-    FreeVariable(span),\n+    FreeVariable(Span),\n \n     // Index into slice must be within its lifetime\n-    IndexSlice(span),\n+    IndexSlice(Span),\n \n     // When casting `&'a T` to an `&'b Trait` object,\n     // relating `'a` to `'b`\n-    RelateObjectBound(span),\n+    RelateObjectBound(Span),\n \n     // Creating a pointer `b` to contents of another borrowed pointer\n-    Reborrow(span),\n+    Reborrow(Span),\n \n     // (&'a &'b T) where a >= b\n-    ReferenceOutlivesReferent(ty::t, span),\n+    ReferenceOutlivesReferent(ty::t, Span),\n \n     // A `ref b` whose region does not enclose the decl site\n-    BindingTypeIsNotValidAtDecl(span),\n+    BindingTypeIsNotValidAtDecl(Span),\n \n     // Regions appearing in a method receiver must outlive method call\n-    CallRcvr(span),\n+    CallRcvr(Span),\n \n     // Regions appearing in a function argument must outlive func call\n-    CallArg(span),\n+    CallArg(Span),\n \n     // Region in return type of invoked fn must enclose call\n-    CallReturn(span),\n+    CallReturn(Span),\n \n     // Region resulting from a `&` expr must enclose the `&` expr\n-    AddrOf(span),\n+    AddrOf(Span),\n \n     // An auto-borrow that does not enclose the expr where it occurs\n-    AutoBorrow(span),\n+    AutoBorrow(Span),\n }\n \n /// Reasons to create a region inference variable\n@@ -197,36 +197,36 @@ pub enum SubregionOrigin {\n pub enum RegionVariableOrigin {\n     // Region variables created for ill-categorized reasons,\n     // mostly indicates places in need of refactoring\n-    MiscVariable(span),\n+    MiscVariable(Span),\n \n     // Regions created by a `&P` or `[...]` pattern\n-    PatternRegion(span),\n+    PatternRegion(Span),\n \n     // Regions created by `&` operator\n-    AddrOfRegion(span),\n+    AddrOfRegion(Span),\n \n     // Regions created by `&[...]` literal\n-    AddrOfSlice(span),\n+    AddrOfSlice(Span),\n \n     // Regions created as part of an autoref of a method receiver\n-    Autoref(span),\n+    Autoref(Span),\n \n     // Regions created as part of an automatic coercion\n     Coercion(TypeTrace),\n \n     // Region variables created for bound regions\n     // in a function or method that is called\n-    BoundRegionInFnCall(span, ty::bound_region),\n+    BoundRegionInFnCall(Span, ty::bound_region),\n \n     // Region variables created for bound regions\n     // when doing subtyping/lub/glb computations\n-    BoundRegionInFnType(span, ty::bound_region),\n+    BoundRegionInFnType(Span, ty::bound_region),\n \n-    BoundRegionInTypeOrImpl(span),\n+    BoundRegionInTypeOrImpl(Span),\n \n     BoundRegionInCoherence,\n \n-    BoundRegionError(span),\n+    BoundRegionError(Span),\n }\n \n pub enum fixup_err {\n@@ -710,15 +710,15 @@ impl InferCtxt {\n     // types using one of these four methods, and should not call span_err directly for such\n     // errors.\n     pub fn type_error_message_str(@mut self,\n-                                  sp: span,\n+                                  sp: Span,\n                                   mk_msg: &fn(Option<~str>, ~str) -> ~str,\n                                   actual_ty: ~str,\n                                   err: Option<&ty::type_err>) {\n         self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n     }\n \n     pub fn type_error_message_str_with_expected(@mut self,\n-                                                sp: span,\n+                                                sp: Span,\n                                                 mk_msg:\n                                                 &fn(Option<~str>, ~str) ->\n                                                 ~str,\n@@ -749,7 +749,7 @@ impl InferCtxt {\n     }\n \n     pub fn type_error_message(@mut self,\n-                              sp: span,\n+                              sp: Span,\n                               mk_msg: &fn(~str) -> ~str,\n                               actual_ty: ty::t,\n                               err: Option<&ty::type_err>) {\n@@ -764,7 +764,7 @@ impl InferCtxt {\n     }\n \n     pub fn report_mismatched_types(@mut self,\n-                                   sp: span,\n+                                   sp: Span,\n                                    e: ty::t,\n                                    a: ty::t,\n                                    err: &ty::type_err) {\n@@ -812,7 +812,7 @@ pub fn fold_regions_in_sig(\n }\n \n impl TypeTrace {\n-    pub fn span(&self) -> span {\n+    pub fn span(&self) -> Span {\n         self.origin.span()\n     }\n }\n@@ -824,7 +824,7 @@ impl Repr for TypeTrace {\n }\n \n impl TypeOrigin {\n-    pub fn span(&self) -> span {\n+    pub fn span(&self) -> Span {\n         match *self {\n             MethodCompatCheck(span) => span,\n             ExprAssignable(expr) => expr.span,\n@@ -852,7 +852,7 @@ impl Repr for TypeOrigin {\n }\n \n impl SubregionOrigin {\n-    pub fn span(&self) -> span {\n+    pub fn span(&self) -> Span {\n         match *self {\n             Subtype(a) => a.span(),\n             InfStackClosure(a) => a,\n@@ -896,7 +896,7 @@ impl Repr for SubregionOrigin {\n }\n \n impl RegionVariableOrigin {\n-    pub fn span(&self) -> span {\n+    pub fn span(&self) -> Span {\n         match *self {\n             MiscVariable(a) => a,\n             PatternRegion(a) => a,"}, {"sha": "4d88df06480bc9f726d938e7bbc2a4349b3cdc47", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -61,7 +61,7 @@ use std::hashmap::HashMap;\n use std::result;\n use extra::list::List;\n use extra::list;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::print::pprust::*;\n use syntax::{ast, ast_map, abi};\n use syntax::opt_vec;\n@@ -249,7 +249,7 @@ pub fn write_tpt_to_tcx(tcx: ty::ctxt,\n     }\n }\n \n-pub fn lookup_def_tcx(tcx: ty::ctxt, sp: span, id: ast::NodeId) -> ast::def {\n+pub fn lookup_def_tcx(tcx: ty::ctxt, sp: Span, id: ast::NodeId) -> ast::def {\n     match tcx.def_map.find(&id) {\n       Some(&x) => x,\n       _ => {\n@@ -258,7 +258,7 @@ pub fn lookup_def_tcx(tcx: ty::ctxt, sp: span, id: ast::NodeId) -> ast::def {\n     }\n }\n \n-pub fn lookup_def_ccx(ccx: &CrateCtxt, sp: span, id: ast::NodeId)\n+pub fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n                    -> ast::def {\n     lookup_def_tcx(ccx.tcx, sp, id)\n }\n@@ -275,7 +275,7 @@ pub fn require_same_types(\n     tcx: ty::ctxt,\n     maybe_infcx: Option<@mut infer::InferCtxt>,\n     t1_is_expected: bool,\n-    span: span,\n+    span: Span,\n     t1: ty::t,\n     t2: ty::t,\n     msg: &fn() -> ~str) -> bool {\n@@ -330,7 +330,7 @@ impl get_and_find_region for isr_alist {\n \n fn check_main_fn_ty(ccx: &CrateCtxt,\n                     main_id: ast::NodeId,\n-                    main_span: span) {\n+                    main_span: Span) {\n     let tcx = ccx.tcx;\n     let main_t = ty::node_id_to_type(tcx, main_id);\n     match ty::get(main_t).sty {\n@@ -374,7 +374,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n \n fn check_start_fn_ty(ccx: &CrateCtxt,\n                      start_id: ast::NodeId,\n-                     start_span: span) {\n+                     start_span: Span) {\n     let tcx = ccx.tcx;\n     let start_t = ty::node_id_to_type(tcx, start_id);\n     match ty::get(start_t).sty {"}, {"sha": "b1342de067cd486f83e379613450b67bae1ac7dd", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -13,7 +13,7 @@ use middle::ty;\n \n use std::result;\n use syntax::ast;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n use syntax::parse::token::special_idents;\n@@ -25,25 +25,25 @@ pub struct RegionError {\n }\n \n pub trait RegionScope {\n-    fn anon_region(&self, span: span) -> Result<ty::Region, RegionError>;\n-    fn self_region(&self, span: span) -> Result<ty::Region, RegionError>;\n-    fn named_region(&self, span: span, id: ast::ident)\n+    fn anon_region(&self, span: Span) -> Result<ty::Region, RegionError>;\n+    fn self_region(&self, span: Span) -> Result<ty::Region, RegionError>;\n+    fn named_region(&self, span: Span, id: ast::ident)\n                       -> Result<ty::Region, RegionError>;\n }\n \n #[deriving(Clone)]\n pub struct EmptyRscope;\n impl RegionScope for EmptyRscope {\n-    fn anon_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n+    fn anon_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n         result::Err(RegionError {\n             msg: ~\"only 'static is allowed here\",\n             replacement: ty::re_static\n         })\n     }\n-    fn self_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n+    fn self_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n         self.anon_region(_span)\n     }\n-    fn named_region(&self, _span: span, _id: ast::ident)\n+    fn named_region(&self, _span: Span, _id: ast::ident)\n         -> Result<ty::Region, RegionError>\n     {\n         self.anon_region(_span)\n@@ -176,13 +176,13 @@ impl MethodRscope {\n }\n \n impl RegionScope for MethodRscope {\n-    fn anon_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n+    fn anon_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n         result::Err(RegionError {\n             msg: ~\"anonymous lifetimes are not permitted here\",\n             replacement: ty::re_bound(ty::br_self)\n         })\n     }\n-    fn self_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n+    fn self_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n         assert!(self.variance.is_some());\n         match self.variance {\n             None => {}  // must be borrowed self, so this is OK\n@@ -197,7 +197,7 @@ impl RegionScope for MethodRscope {\n         }\n         result::Ok(ty::re_bound(ty::br_self))\n     }\n-    fn named_region(&self, span: span, id: ast::ident)\n+    fn named_region(&self, span: Span, id: ast::ident)\n                       -> Result<ty::Region, RegionError> {\n         if !self.region_param_names.has_ident(id) {\n             return RegionParamNames::undeclared_name(None);\n@@ -224,13 +224,13 @@ impl TypeRscope {\n     }\n }\n impl RegionScope for TypeRscope {\n-    fn anon_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n+    fn anon_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n         result::Err(RegionError {\n             msg: ~\"anonymous lifetimes are not permitted here\",\n             replacement: self.replacement()\n         })\n     }\n-    fn self_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n+    fn self_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n         match **self {\n             None => {\n                 // if the self region is used, region parameterization should\n@@ -249,7 +249,7 @@ impl RegionScope for TypeRscope {\n         }\n         result::Ok(ty::re_bound(ty::br_self))\n     }\n-    fn named_region(&self, span: span, id: ast::ident)\n+    fn named_region(&self, span: Span, id: ast::ident)\n                       -> Result<ty::Region, RegionError> {\n         do EmptyRscope.named_region(span, id).chain_err |_e| {\n             result::Err(RegionError {\n@@ -298,16 +298,16 @@ pub fn in_binding_rscope<RS:RegionScope + Clone + 'static>(\n }\n \n impl RegionScope for BindingRscope {\n-    fn anon_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n+    fn anon_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n         let idx = *self.anon_bindings;\n         *self.anon_bindings += 1;\n         result::Ok(ty::re_bound(ty::br_anon(idx)))\n     }\n-    fn self_region(&self, span: span) -> Result<ty::Region, RegionError> {\n+    fn self_region(&self, span: Span) -> Result<ty::Region, RegionError> {\n         self.base.self_region(span)\n     }\n     fn named_region(&self,\n-                    span: span,\n+                    span: Span,\n                     id: ast::ident) -> Result<ty::Region, RegionError>\n     {\n         do self.base.named_region(span, id).chain_err |_e| {"}, {"sha": "72cd3fa7b4f310cb5a35279c4b5a960207442b6c", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -28,7 +28,7 @@ extern mod syntax;\n use driver::driver::{host_triple, optgroups, early_error};\n use driver::driver::{str_input, file_input, build_session_options};\n use driver::driver::{build_session, build_configuration, parse_pretty};\n-use driver::driver::{pp_mode, pretty_print_input, list_metadata};\n+use driver::driver::{PpMode, pretty_print_input, list_metadata};\n use driver::driver::{compile_input};\n use driver::session;\n use middle::lint;\n@@ -262,11 +262,11 @@ pub fn run_compiler(args: &[~str], demitter: diagnostic::Emitter) {\n         parse_pretty(sess, a)\n     };\n     match pretty {\n-      Some::<pp_mode>(ppm) => {\n+      Some::<PpMode>(ppm) => {\n         pretty_print_input(sess, cfg, &input, ppm);\n         return;\n       }\n-      None::<pp_mode> => {/* continue */ }\n+      None::<PpMode> => {/* continue */ }\n     }\n     let ls = opt_present(matches, \"ls\");\n     if ls {\n@@ -326,7 +326,7 @@ pub fn monitor(f: ~fn(diagnostic::Emitter)) {\n         let ch_capture = ch.clone();\n         // The 'diagnostics emitter'. Every error, warning, etc. should\n         // go through this function.\n-        let demitter: @fn(Option<(@codemap::CodeMap, codemap::span)>,\n+        let demitter: @fn(Option<(@codemap::CodeMap, codemap::Span)>,\n                           &str,\n                           diagnostic::level) =\n                           |cmsp, msg, lvl| {"}, {"sha": "e2475efa40b8ba3a28bf23ff65f10aceba3d6a59", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -10,7 +10,7 @@\n \n \n use syntax::ast;\n-use syntax::codemap::{span};\n+use syntax::codemap::{Span};\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -105,7 +105,7 @@ pub fn block_query(b: &ast::Block, p: @fn(@ast::expr) -> bool) -> bool {\n     return *rs;\n }\n \n-pub fn local_rhs_span(l: @ast::Local, def: span) -> span {\n+pub fn local_rhs_span(l: @ast::Local, def: Span) -> Span {\n     match l.init {\n       Some(i) => return i.span,\n       _ => return def"}, {"sha": "de839239e728222cc8547d5494c570df092398af", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -26,7 +26,7 @@ use middle::ty;\n use middle::typeck;\n use syntax::abi::AbiSet;\n use syntax::ast_map;\n-use syntax::codemap::span;\n+use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n@@ -69,7 +69,7 @@ pub fn explain_region(cx: ctxt, region: ty::Region) -> ~str {\n \n \n pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n-                            -> (~str, Option<span>) {\n+                            -> (~str, Option<Span>) {\n     return match region {\n       re_scope(node_id) => {\n         match cx.items.find(&node_id) {\n@@ -136,8 +136,8 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n       }\n     };\n \n-    fn explain_span(cx: ctxt, heading: &str, span: span)\n-        -> (~str, Option<span>)\n+    fn explain_span(cx: ctxt, heading: &str, span: Span)\n+        -> (~str, Option<Span>)\n     {\n         let lo = cx.sess.codemap.lookup_char_pos_adj(span.lo);\n         (fmt!(\"the %s at %u:%u\", heading,\n@@ -827,7 +827,7 @@ impl Repr for ty::BuiltinBounds {\n     }\n }\n \n-impl Repr for span {\n+impl Repr for Span {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         tcx.sess.codemap.span_to_str(*self)\n     }"}, {"sha": "98c499900a20c0ecde26af2ec2e248daff3efe05", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -12,7 +12,7 @@ use std::os;\n use rustc::driver::{driver, session};\n use extra::getopts::groups::getopts;\n use syntax::ast_util::*;\n-use syntax::codemap::{dummy_sp, spanned};\n+use syntax::codemap::{dummy_sp, Spanned};\n use syntax::ext::base::ExtCtxt;\n use syntax::{ast, attr, codemap, diagnostic, fold};\n use syntax::attr::AttrMetaMethods;\n@@ -53,7 +53,7 @@ pub fn is_cmd(cmd: &str) -> bool {\n \n struct ListenerFn {\n     cmds: ~[~str],\n-    span: codemap::span,\n+    span: codemap::Span,\n     path: ~[ast::ident]\n }\n \n@@ -427,7 +427,7 @@ pub fn link_exe(src: &Path, dest: &Path) -> bool {\n }\n \n pub fn mk_string_lit(s: @str) -> ast::lit {\n-    spanned {\n+    Spanned {\n         node: ast::lit_str(s),\n         span: dummy_sp()\n     }"}, {"sha": "a7fad7def186fc8ce8b48c6247441e77a7895c25", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -10,7 +10,7 @@\n \n // The Rust abstract syntax tree.\n \n-use codemap::{span, spanned};\n+use codemap::{Span, Spanned};\n use abi::AbiSet;\n use opt_vec::OptVec;\n use parse::token::{interner_get, str_to_ident};\n@@ -95,7 +95,7 @@ pub type fn_ident = Option<ident>;\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct Lifetime {\n     id: NodeId,\n-    span: span,\n+    span: Span,\n     ident: ident\n }\n \n@@ -105,7 +105,7 @@ pub struct Lifetime {\n // of supporting information.\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct Path {\n-    span: span,\n+    span: Span,\n     /// A `::foo` path, is relative to the crate root rather than current\n     /// module (like paths in an import).\n     global: bool,\n@@ -219,10 +219,10 @@ pub struct Crate {\n     module: _mod,\n     attrs: ~[Attribute],\n     config: CrateConfig,\n-    span: span,\n+    span: Span,\n }\n \n-pub type MetaItem = spanned<MetaItem_>;\n+pub type MetaItem = Spanned<MetaItem_>;\n \n #[deriving(Clone, Encodable, Decodable, IterBytes)]\n pub enum MetaItem_ {\n@@ -263,14 +263,14 @@ pub struct Block {\n     expr: Option<@expr>,\n     id: NodeId,\n     rules: BlockCheckMode,\n-    span: span,\n+    span: Span,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct pat {\n     id: NodeId,\n     node: pat_,\n-    span: span,\n+    span: Span,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n@@ -333,7 +333,7 @@ impl ToStr for Sigil {\n     }\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Eq, Encodable, Decodable, IterBytes)]\n pub enum vstore {\n     // FIXME (#3469): Change uint to @expr (actually only constant exprs)\n     vstore_fixed(Option<uint>),     // [1,2,3,4]\n@@ -382,7 +382,7 @@ pub enum unop {\n     neg\n }\n \n-pub type stmt = spanned<stmt_>;\n+pub type stmt = Spanned<stmt_>;\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum stmt_ {\n@@ -408,10 +408,10 @@ pub struct Local {\n     pat: @pat,\n     init: Option<@expr>,\n     id: NodeId,\n-    span: span,\n+    span: Span,\n }\n \n-pub type decl = spanned<decl_>;\n+pub type decl = Spanned<decl_>;\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum decl_ {\n@@ -432,7 +432,7 @@ pub struct arm {\n pub struct Field {\n     ident: ident,\n     expr: @expr,\n-    span: span,\n+    span: Span,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n@@ -445,7 +445,7 @@ pub enum BlockCheckMode {\n pub struct expr {\n     id: NodeId,\n     node: expr_,\n-    span: span,\n+    span: Span,\n }\n \n impl expr {\n@@ -538,7 +538,7 @@ pub enum expr_ {\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n pub enum token_tree {\n     // a single token\n-    tt_tok(span, ::parse::token::Token),\n+    tt_tok(Span, ::parse::token::Token),\n     // a delimited sequence (the delimiters appear as the first\n     // and last elements of the vector)\n     tt_delim(@mut ~[token_tree]),\n@@ -547,10 +547,10 @@ pub enum token_tree {\n     // a kleene-style repetition sequence with a span, a tt_forest,\n     // an optional separator (?), and a boolean where true indicates\n     // zero or more (*), and false indicates one or more (+).\n-    tt_seq(span, @mut ~[token_tree], Option<::parse::token::Token>, bool),\n+    tt_seq(Span, @mut ~[token_tree], Option<::parse::token::Token>, bool),\n \n     // a syntactic variable that will be filled in by macro expansion.\n-    tt_nonterminal(span, ident)\n+    tt_nonterminal(Span, ident)\n }\n \n //\n@@ -605,7 +605,7 @@ pub enum token_tree {\n // If you understand that, you have closed to loop and understand the whole\n // macro system. Congratulations.\n //\n-pub type matcher = spanned<matcher_>;\n+pub type matcher = Spanned<matcher_>;\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum matcher_ {\n@@ -618,14 +618,14 @@ pub enum matcher_ {\n     match_nonterminal(ident, ident, uint)\n }\n \n-pub type mac = spanned<mac_>;\n+pub type mac = Spanned<mac_>;\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum mac_ {\n     mac_invoc_tt(Path,~[token_tree]),   // new macro-invocation\n }\n \n-pub type lit = spanned<lit_>;\n+pub type lit = Spanned<lit_>;\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum lit_ {\n@@ -651,7 +651,7 @@ pub struct mt {\n pub struct TypeField {\n     ident: ident,\n     mt: mt,\n-    span: span,\n+    span: Span,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n@@ -663,7 +663,7 @@ pub struct TypeMethod {\n     generics: Generics,\n     explicit_self: explicit_self,\n     id: NodeId,\n-    span: span,\n+    span: Span,\n }\n \n // A trait method is either required (meaning it doesn't have an\n@@ -724,7 +724,7 @@ impl ToStr for float_ty {\n pub struct Ty {\n     id: NodeId,\n     node: ty_,\n-    span: span,\n+    span: Span,\n }\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n@@ -864,7 +864,7 @@ pub enum explicit_self_ {\n     sty_uniq                                   // `~self`\n }\n \n-pub type explicit_self = spanned<explicit_self_>;\n+pub type explicit_self = Spanned<explicit_self_>;\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct method {\n@@ -876,7 +876,7 @@ pub struct method {\n     decl: fn_decl,\n     body: Block,\n     id: NodeId,\n-    span: span,\n+    span: Span,\n     self_id: NodeId,\n     vis: visibility,\n }\n@@ -929,17 +929,17 @@ pub struct variant_ {\n     vis: visibility,\n }\n \n-pub type variant = spanned<variant_>;\n+pub type variant = Spanned<variant_>;\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct path_list_ident_ {\n     name: ident,\n     id: NodeId,\n }\n \n-pub type path_list_ident = spanned<path_list_ident_>;\n+pub type path_list_ident = Spanned<path_list_ident_>;\n \n-pub type view_path = spanned<view_path_>;\n+pub type view_path = Spanned<view_path_>;\n \n #[deriving(Eq, Encodable, Decodable, IterBytes)]\n pub enum view_path_ {\n@@ -963,7 +963,7 @@ pub struct view_item {\n     node: view_item_,\n     attrs: ~[Attribute],\n     vis: visibility,\n-    span: span,\n+    span: Span,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n@@ -977,7 +977,7 @@ pub enum view_item_ {\n }\n \n // Meta-data associated with an item\n-pub type Attribute = spanned<Attribute_>;\n+pub type Attribute = Spanned<Attribute_>;\n \n // Distinguishes between Attributes that decorate items and Attributes that\n // are contained as statements within items. These two cases need to be\n@@ -1033,7 +1033,7 @@ pub struct struct_field_ {\n     attrs: ~[Attribute],\n }\n \n-pub type struct_field = spanned<struct_field_>;\n+pub type struct_field = Spanned<struct_field_>;\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum struct_field_kind {\n@@ -1060,7 +1060,7 @@ pub struct item {\n     id: NodeId,\n     node: item_,\n     vis: visibility,\n-    span: span,\n+    span: Span,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n@@ -1087,7 +1087,7 @@ pub struct foreign_item {\n     attrs: ~[Attribute],\n     node: foreign_item_,\n     id: NodeId,\n-    span: span,\n+    span: Span,\n     vis: visibility,\n }\n "}, {"sha": "c900bf2c15d0c3cdf040d759c695edf1ec59fb64", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -13,7 +13,7 @@ use ast::*;\n use ast;\n use ast_util::{inlined_item_utils, stmt_id};\n use ast_util;\n-use codemap::span;\n+use codemap::Span;\n use codemap;\n use diagnostic::span_handler;\n use parse::token::ident_interner;\n@@ -148,7 +148,7 @@ impl Ctx {\n               fk: &visit::fn_kind,\n               decl: &fn_decl,\n               body: &Block,\n-              sp: codemap::span,\n+              sp: codemap::Span,\n               id: NodeId) {\n         for a in decl.inputs.iter() {\n             self.map.insert(a.id, node_arg);\n@@ -282,7 +282,7 @@ impl Visitor<()> for Ctx {\n                 function_kind: &fn_kind,\n                 function_declaration: &fn_decl,\n                 block: &Block,\n-                span: span,\n+                span: Span,\n                 node_id: NodeId,\n                 _: ()) {\n         self.map_fn(function_kind, function_declaration, block, span, node_id)\n@@ -294,7 +294,7 @@ impl Visitor<()> for Ctx {\n \n     // XXX: Methods below can become default methods.\n \n-    fn visit_mod(&mut self, module: &_mod, _: span, _: NodeId, _: ()) {\n+    fn visit_mod(&mut self, module: &_mod, _: Span, _: NodeId, _: ()) {\n         visit::walk_mod(self, module, ())\n     }\n \n@@ -334,7 +334,7 @@ impl Visitor<()> for Ctx {\n                 function_kind: &fn_kind,\n                 function_declaration: &fn_decl,\n                 block: &Block,\n-                span: span,\n+                span: Span,\n                 node_id: NodeId,\n                 _: ()) {\n         visit::walk_fn(self,"}, {"sha": "62c2e9af938fdb1dd0253e4033e3e58e8ea89efe", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -11,7 +11,7 @@\n use ast::*;\n use ast;\n use ast_util;\n-use codemap::{span, dummy_sp};\n+use codemap::{Span, dummy_sp};\n use opt_vec;\n use parse::token;\n use visit::{SimpleVisitor, SimpleVisitorVisitor, Visitor};\n@@ -217,7 +217,7 @@ pub fn default_block(\n     }\n }\n \n-pub fn ident_to_path(s: span, identifier: ident) -> Path {\n+pub fn ident_to_path(s: Span, identifier: ident) -> Path {\n     ast::Path {\n         span: s,\n         global: false,\n@@ -231,7 +231,7 @@ pub fn ident_to_path(s: span, identifier: ident) -> Path {\n     }\n }\n \n-pub fn ident_to_pat(id: NodeId, s: span, i: ident) -> @pat {\n+pub fn ident_to_pat(id: NodeId, s: Span, i: ident) -> @pat {\n     @ast::pat { id: id,\n                 node: pat_ident(bind_infer, ident_to_path(s, i), None),\n                 span: s }\n@@ -426,7 +426,7 @@ impl IdVisitor {\n impl Visitor<()> for IdVisitor {\n     fn visit_mod(&mut self,\n                  module: &_mod,\n-                 _: span,\n+                 _: Span,\n                  node_id: NodeId,\n                  env: ()) {\n         (self.visit_callback)(node_id);\n@@ -551,7 +551,7 @@ impl Visitor<()> for IdVisitor {\n                 function_kind: &visit::fn_kind,\n                 function_declaration: &fn_decl,\n                 block: &Block,\n-                span: span,\n+                span: Span,\n                 node_id: NodeId,\n                 env: ()) {\n         if !self.pass_through_items {\n@@ -691,7 +691,7 @@ struct EachViewItemData {\n }\n \n impl SimpleVisitor for EachViewItemData {\n-    fn visit_mod(&mut self, _: &_mod, _: span, _: NodeId) {\n+    fn visit_mod(&mut self, _: &_mod, _: Span, _: NodeId) {\n         // XXX: Default method.\n     }\n     fn visit_view_item(&mut self, view_item: &view_item) {\n@@ -737,7 +737,7 @@ impl SimpleVisitor for EachViewItemData {\n                 _: &visit::fn_kind,\n                 _: &fn_decl,\n                 _: &Block,\n-                _: span,\n+                _: Span,\n                 _: NodeId) {\n         // XXX: Default method.\n     }"}, {"sha": "d365c89eee73a5ad8d51d5707216b12a90d49c5d", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -14,7 +14,7 @@ use extra;\n \n use ast;\n use ast::{Attribute, Attribute_, MetaItem, MetaWord, MetaNameValue, MetaList};\n-use codemap::{spanned, dummy_spanned};\n+use codemap::{Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n use diagnostic::span_handler;\n use parse::comments::{doc_comment_style, strip_doc_comment_decoration};\n@@ -212,7 +212,7 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> ~[@MetaItem] {\n     do v.move_iter().map |(_, m)| {\n         match m.node {\n             MetaList(n, ref mis) => {\n-                @spanned {\n+                @Spanned {\n                     node: MetaList(n, sort_meta_items(*mis)),\n                     .. /*bad*/ (*m).clone()\n                 }"}, {"sha": "1c3a8e81e5527f0453b6e54f5ed3af61a7cebe67", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -96,57 +96,57 @@ relative to FileMaps. Methods on the CodeMap can be used to relate spans back\n to the original source.\n */\n #[deriving(Clone, IterBytes)]\n-pub struct span {\n+pub struct Span {\n     lo: BytePos,\n     hi: BytePos,\n     expn_info: Option<@ExpnInfo>\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub struct spanned<T> {\n+pub struct Spanned<T> {\n     node: T,\n-    span: span,\n+    span: Span,\n }\n \n-impl cmp::Eq for span {\n-    fn eq(&self, other: &span) -> bool {\n+impl cmp::Eq for Span {\n+    fn eq(&self, other: &Span) -> bool {\n         return (*self).lo == (*other).lo && (*self).hi == (*other).hi;\n     }\n-    fn ne(&self, other: &span) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &Span) -> bool { !(*self).eq(other) }\n }\n \n-impl<S:Encoder> Encodable<S> for span {\n+impl<S:Encoder> Encodable<S> for Span {\n     /* Note #1972 -- spans are encoded but not decoded */\n     fn encode(&self, s: &mut S) {\n         s.emit_nil()\n     }\n }\n \n-impl<D:Decoder> Decodable<D> for span {\n-    fn decode(_d: &mut D) -> span {\n+impl<D:Decoder> Decodable<D> for Span {\n+    fn decode(_d: &mut D) -> Span {\n         dummy_sp()\n     }\n }\n \n-pub fn spanned<T>(lo: BytePos, hi: BytePos, t: T) -> spanned<T> {\n+pub fn spanned<T>(lo: BytePos, hi: BytePos, t: T) -> Spanned<T> {\n     respan(mk_sp(lo, hi), t)\n }\n \n-pub fn respan<T>(sp: span, t: T) -> spanned<T> {\n-    spanned {node: t, span: sp}\n+pub fn respan<T>(sp: Span, t: T) -> Spanned<T> {\n+    Spanned {node: t, span: sp}\n }\n \n-pub fn dummy_spanned<T>(t: T) -> spanned<T> {\n+pub fn dummy_spanned<T>(t: T) -> Spanned<T> {\n     respan(dummy_sp(), t)\n }\n \n /* assuming that we're not in macro expansion */\n-pub fn mk_sp(lo: BytePos, hi: BytePos) -> span {\n-    span {lo: lo, hi: hi, expn_info: None}\n+pub fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n+    Span {lo: lo, hi: hi, expn_info: None}\n }\n \n // make this a const, once the compiler supports it\n-pub fn dummy_sp() -> span { return mk_sp(BytePos(0), BytePos(0)); }\n+pub fn dummy_sp() -> Span { return mk_sp(BytePos(0), BytePos(0)); }\n \n \n \n@@ -174,12 +174,12 @@ pub struct LocWithOpt {\n pub struct FileMapAndLine {fm: @FileMap, line: uint}\n pub struct FileMapAndBytePos {fm: @FileMap, pos: BytePos}\n #[deriving(IterBytes)]\n-pub struct NameAndSpan {name: @str, span: Option<span>}\n+pub struct NameAndSpan {name: @str, span: Option<Span>}\n \n /// Extra information for tracking macro expansion of spans\n #[deriving(IterBytes)]\n pub struct ExpnInfo {\n-    call_site: span,\n+    call_site: Span,\n     callee: NameAndSpan\n }\n \n@@ -197,7 +197,7 @@ pub enum FileSubstr {\n     FssNone,\n     // indicates that this \"file\" is actually a substring\n     // of another file that appears earlier in the codemap\n-    FssInternal(span),\n+    FssInternal(Span),\n }\n \n /// Identifies an offset of a multi-byte character in a FileMap\n@@ -302,7 +302,7 @@ impl CodeMap {\n         return filemap;\n     }\n \n-    pub fn mk_substr_filename(&self, sp: span) -> ~str {\n+    pub fn mk_substr_filename(&self, sp: Span) -> ~str {\n         let pos = self.lookup_char_pos(sp.lo);\n         return fmt!(\"<%s:%u:%u>\", pos.file.name,\n                     pos.line, pos.col.to_uint());\n@@ -328,12 +328,12 @@ impl CodeMap {\n         }\n     }\n \n-    pub fn adjust_span(&self, sp: span) -> span {\n+    pub fn adjust_span(&self, sp: Span) -> Span {\n         let line = self.lookup_line(sp.lo);\n         match (line.fm.substr) {\n             FssNone => sp,\n             FssInternal(s) => {\n-                self.adjust_span(span {\n+                self.adjust_span(Span {\n                     lo: s.lo + (sp.lo - line.fm.start_pos),\n                     hi: s.lo + (sp.hi - line.fm.start_pos),\n                     expn_info: sp.expn_info\n@@ -342,7 +342,7 @@ impl CodeMap {\n         }\n     }\n \n-    pub fn span_to_str(&self, sp: span) -> ~str {\n+    pub fn span_to_str(&self, sp: Span) -> ~str {\n         let files = &*self.files;\n         if files.len() == 0 && sp == dummy_sp() {\n             return ~\"no-location\";\n@@ -354,12 +354,12 @@ impl CodeMap {\n                     lo.line, lo.col.to_uint(), hi.line, hi.col.to_uint())\n     }\n \n-    pub fn span_to_filename(&self, sp: span) -> FileName {\n+    pub fn span_to_filename(&self, sp: Span) -> FileName {\n         let lo = self.lookup_char_pos(sp.lo);\n         lo.file.name\n     }\n \n-    pub fn span_to_lines(&self, sp: span) -> @FileLines {\n+    pub fn span_to_lines(&self, sp: Span) -> @FileLines {\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n         let mut lines = ~[];\n@@ -369,7 +369,7 @@ impl CodeMap {\n         return @FileLines {file: lo.file, lines: lines};\n     }\n \n-    pub fn span_to_snippet(&self, sp: span) -> Option<~str> {\n+    pub fn span_to_snippet(&self, sp: Span) -> Option<~str> {\n         let begin = self.lookup_byte_offset(sp.lo);\n         let end = self.lookup_byte_offset(sp.hi);\n \n@@ -446,7 +446,7 @@ impl CodeMap {\n         };\n     }\n \n-    fn span_to_str_no_adj(&self, sp: span) -> ~str {\n+    fn span_to_str_no_adj(&self, sp: Span) -> ~str {\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n         return fmt!(\"%s:%u:%u: %u:%u\", lo.file.name,"}, {"sha": "536267a2235c050e0ea37e5c1733bae697277b61", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use codemap::{Pos, span};\n+use codemap::{Pos, Span};\n use codemap;\n \n use std::io;\n use std::local_data;\n use extra::term;\n \n-pub type Emitter = @fn(cmsp: Option<(@codemap::CodeMap, span)>,\n+pub type Emitter = @fn(cmsp: Option<(@codemap::CodeMap, Span)>,\n                        msg: &str,\n                        lvl: level);\n \n@@ -35,7 +35,7 @@ pub trait handler {\n     fn bug(@mut self, msg: &str) -> !;\n     fn unimpl(@mut self, msg: &str) -> !;\n     fn emit(@mut self,\n-            cmsp: Option<(@codemap::CodeMap, span)>,\n+            cmsp: Option<(@codemap::CodeMap, Span)>,\n             msg: &str,\n             lvl: level);\n }\n@@ -44,12 +44,12 @@ pub trait handler {\n // accepts span information for source-location\n // reporting.\n pub trait span_handler {\n-    fn span_fatal(@mut self, sp: span, msg: &str) -> !;\n-    fn span_err(@mut self, sp: span, msg: &str);\n-    fn span_warn(@mut self, sp: span, msg: &str);\n-    fn span_note(@mut self, sp: span, msg: &str);\n-    fn span_bug(@mut self, sp: span, msg: &str) -> !;\n-    fn span_unimpl(@mut self, sp: span, msg: &str) -> !;\n+    fn span_fatal(@mut self, sp: Span, msg: &str) -> !;\n+    fn span_err(@mut self, sp: Span, msg: &str);\n+    fn span_warn(@mut self, sp: Span, msg: &str);\n+    fn span_note(@mut self, sp: Span, msg: &str);\n+    fn span_bug(@mut self, sp: Span, msg: &str) -> !;\n+    fn span_unimpl(@mut self, sp: Span, msg: &str) -> !;\n     fn handler(@mut self) -> @mut handler;\n }\n \n@@ -64,24 +64,24 @@ struct CodemapT {\n }\n \n impl span_handler for CodemapT {\n-    fn span_fatal(@mut self, sp: span, msg: &str) -> ! {\n+    fn span_fatal(@mut self, sp: Span, msg: &str) -> ! {\n         self.handler.emit(Some((self.cm, sp)), msg, fatal);\n         fail!();\n     }\n-    fn span_err(@mut self, sp: span, msg: &str) {\n+    fn span_err(@mut self, sp: Span, msg: &str) {\n         self.handler.emit(Some((self.cm, sp)), msg, error);\n         self.handler.bump_err_count();\n     }\n-    fn span_warn(@mut self, sp: span, msg: &str) {\n+    fn span_warn(@mut self, sp: Span, msg: &str) {\n         self.handler.emit(Some((self.cm, sp)), msg, warning);\n     }\n-    fn span_note(@mut self, sp: span, msg: &str) {\n+    fn span_note(@mut self, sp: Span, msg: &str) {\n         self.handler.emit(Some((self.cm, sp)), msg, note);\n     }\n-    fn span_bug(@mut self, sp: span, msg: &str) -> ! {\n+    fn span_bug(@mut self, sp: Span, msg: &str) -> ! {\n         self.span_fatal(sp, ice_msg(msg));\n     }\n-    fn span_unimpl(@mut self, sp: span, msg: &str) -> ! {\n+    fn span_unimpl(@mut self, sp: Span, msg: &str) -> ! {\n         self.span_bug(sp, ~\"unimplemented \" + msg);\n     }\n     fn handler(@mut self) -> @mut handler {\n@@ -132,7 +132,7 @@ impl handler for HandlerT {\n         self.bug(~\"unimplemented \" + msg);\n     }\n     fn emit(@mut self,\n-            cmsp: Option<(@codemap::CodeMap, span)>,\n+            cmsp: Option<(@codemap::CodeMap, Span)>,\n             msg: &str,\n             lvl: level) {\n         (self.emit)(cmsp, msg, lvl);\n@@ -231,13 +231,13 @@ fn print_diagnostic(topic: &str, lvl: level, msg: &str) {\n }\n \n pub fn collect(messages: @mut ~[~str])\n-            -> @fn(Option<(@codemap::CodeMap, span)>, &str, level) {\n-    let f: @fn(Option<(@codemap::CodeMap, span)>, &str, level) =\n+            -> @fn(Option<(@codemap::CodeMap, Span)>, &str, level) {\n+    let f: @fn(Option<(@codemap::CodeMap, Span)>, &str, level) =\n         |_o, msg: &str, _l| { messages.push(msg.to_str()); };\n     f\n }\n \n-pub fn emit(cmsp: Option<(@codemap::CodeMap, span)>, msg: &str, lvl: level) {\n+pub fn emit(cmsp: Option<(@codemap::CodeMap, Span)>, msg: &str, lvl: level) {\n     match cmsp {\n       Some((cm, sp)) => {\n         let sp = cm.adjust_span(sp);\n@@ -254,7 +254,7 @@ pub fn emit(cmsp: Option<(@codemap::CodeMap, span)>, msg: &str, lvl: level) {\n }\n \n fn highlight_lines(cm: @codemap::CodeMap,\n-                   sp: span, lvl: level,\n+                   sp: Span, lvl: level,\n                    lines: @codemap::FileLines) {\n     let fm = lines.file;\n \n@@ -330,7 +330,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n     }\n }\n \n-fn print_macro_backtrace(cm: @codemap::CodeMap, sp: span) {\n+fn print_macro_backtrace(cm: @codemap::CodeMap, sp: Span) {\n     for ei in sp.expn_info.iter() {\n         let ss = ei.callee.span.map_default(~\"\", |span| cm.span_to_str(*span));\n         print_diagnostic(ss, note,"}, {"sha": "e023c0c67edfa5357771a0b3afc56bca66dbdb26", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -13,7 +13,7 @@\n  */\n \n use ast;\n-use codemap::span;\n+use codemap::Span;\n use ext::base;\n use ext::base::*;\n use parse;\n@@ -37,7 +37,7 @@ fn next_state(s: State) -> Option<State> {\n     }\n }\n \n-pub fn expand_asm(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_asm(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                -> base::MacResult {\n     let p = parse::new_parser_from_tts(cx.parse_sess(),\n                                        cx.cfg(),"}, {"sha": "c1e7ba60fade4e1d55ccae928583cc3835e49621", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -11,12 +11,12 @@\n /// Deprecated #[auto_encode] and #[auto_decode] syntax extensions\n \n use ast;\n-use codemap::span;\n+use codemap::Span;\n use ext::base::*;\n \n pub fn expand_auto_encode(\n     cx: @ExtCtxt,\n-    span: span,\n+    span: Span,\n     _mitem: @ast::MetaItem,\n     in_items: ~[@ast::item]\n ) -> ~[@ast::item] {\n@@ -26,7 +26,7 @@ pub fn expand_auto_encode(\n \n pub fn expand_auto_decode(\n     cx: @ExtCtxt,\n-    span: span,\n+    span: Span,\n     _mitem: @ast::MetaItem,\n     in_items: ~[@ast::item]\n ) -> ~[@ast::item] {"}, {"sha": "83a19bb4634e2a02b8b609162b98d61fba078578", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -11,7 +11,7 @@\n use ast;\n use ast::Name;\n use codemap;\n-use codemap::{CodeMap, span, ExpnInfo};\n+use codemap::{CodeMap, Span, ExpnInfo};\n use diagnostic::span_handler;\n use ext;\n use parse;\n@@ -35,28 +35,28 @@ pub struct MacroDef {\n }\n \n pub type ItemDecorator = @fn(@ExtCtxt,\n-                             span,\n+                             Span,\n                              @ast::MetaItem,\n                              ~[@ast::item])\n                           -> ~[@ast::item];\n \n pub struct SyntaxExpanderTT {\n     expander: SyntaxExpanderTTFun,\n-    span: Option<span>\n+    span: Option<Span>\n }\n \n pub type SyntaxExpanderTTFun = @fn(@ExtCtxt,\n-                                   span,\n+                                   Span,\n                                    &[ast::token_tree])\n                                 -> MacResult;\n \n pub struct SyntaxExpanderTTItem {\n     expander: SyntaxExpanderTTItemFun,\n-    span: Option<span>\n+    span: Option<Span>\n }\n \n pub type SyntaxExpanderTTItemFun = @fn(@ExtCtxt,\n-                                       span,\n+                                       Span,\n                                        ast::ident,\n                                        ~[ast::token_tree])\n                                     -> MacResult;\n@@ -247,7 +247,7 @@ impl ExtCtxt {\n     pub fn codemap(&self) -> @CodeMap { self.parse_sess.cm }\n     pub fn parse_sess(&self) -> @mut parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> ast::CrateConfig { self.cfg.clone() }\n-    pub fn call_site(&self) -> span {\n+    pub fn call_site(&self) -> Span {\n         match *self.backtrace {\n             Some(@ExpnInfo {call_site: cs, _}) => cs,\n             None => self.bug(\"missing top span\")\n@@ -263,7 +263,7 @@ impl ExtCtxt {\n             ExpnInfo {call_site: cs, callee: ref callee} => {\n                 *self.backtrace =\n                     Some(@ExpnInfo {\n-                        call_site: span {lo: cs.lo, hi: cs.hi,\n+                        call_site: Span {lo: cs.lo, hi: cs.hi,\n                                          expn_info: *self.backtrace},\n                         callee: *callee});\n             }\n@@ -272,29 +272,29 @@ impl ExtCtxt {\n     pub fn bt_pop(&self) {\n         match *self.backtrace {\n             Some(@ExpnInfo {\n-                call_site: span {expn_info: prev, _}, _}) => {\n+                call_site: Span {expn_info: prev, _}, _}) => {\n                 *self.backtrace = prev\n             }\n             _ => self.bug(\"tried to pop without a push\")\n         }\n     }\n-    pub fn span_fatal(&self, sp: span, msg: &str) -> ! {\n+    pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n         self.print_backtrace();\n         self.parse_sess.span_diagnostic.span_fatal(sp, msg);\n     }\n-    pub fn span_err(&self, sp: span, msg: &str) {\n+    pub fn span_err(&self, sp: Span, msg: &str) {\n         self.print_backtrace();\n         self.parse_sess.span_diagnostic.span_err(sp, msg);\n     }\n-    pub fn span_warn(&self, sp: span, msg: &str) {\n+    pub fn span_warn(&self, sp: Span, msg: &str) {\n         self.print_backtrace();\n         self.parse_sess.span_diagnostic.span_warn(sp, msg);\n     }\n-    pub fn span_unimpl(&self, sp: span, msg: &str) -> ! {\n+    pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n         self.print_backtrace();\n         self.parse_sess.span_diagnostic.span_unimpl(sp, msg);\n     }\n-    pub fn span_bug(&self, sp: span, msg: &str) -> ! {\n+    pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n         self.print_backtrace();\n         self.parse_sess.span_diagnostic.span_bug(sp, msg);\n     }\n@@ -329,15 +329,15 @@ pub fn expr_to_str(cx: @ExtCtxt, expr: @ast::expr, err_msg: &str) -> @str {\n     }\n }\n \n-pub fn check_zero_tts(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree],\n+pub fn check_zero_tts(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree],\n                       name: &str) {\n     if tts.len() != 0 {\n         cx.span_fatal(sp, fmt!(\"%s takes no arguments\", name));\n     }\n }\n \n pub fn get_single_str_from_tts(cx: @ExtCtxt,\n-                               sp: span,\n+                               sp: Span,\n                                tts: &[ast::token_tree],\n                                name: &str)\n                                -> @str {\n@@ -352,7 +352,7 @@ pub fn get_single_str_from_tts(cx: @ExtCtxt,\n }\n \n pub fn get_exprs_from_tts(cx: @ExtCtxt,\n-                          sp: span,\n+                          sp: Span,\n                           tts: &[ast::token_tree]) -> ~[@ast::expr] {\n     let p = parse::new_parser_from_tts(cx.parse_sess(),\n                                        cx.cfg(),"}, {"sha": "194b4ab83f92e36089b22b73859b4905688afb25", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 174, "deletions": 174, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -12,7 +12,7 @@ use abi::AbiSet;\n use ast::ident;\n use ast;\n use ast_util;\n-use codemap::{span, respan, dummy_sp};\n+use codemap::{Span, respan, dummy_sp};\n use fold;\n use ext::base::ExtCtxt;\n use ext::quote::rt::*;\n@@ -32,10 +32,10 @@ mod syntax {\n \n pub trait AstBuilder {\n     // paths\n-    fn path(&self, span: span, strs: ~[ast::ident]) -> ast::Path;\n-    fn path_ident(&self, span: span, id: ast::ident) -> ast::Path;\n-    fn path_global(&self, span: span, strs: ~[ast::ident]) -> ast::Path;\n-    fn path_all(&self, sp: span,\n+    fn path(&self, span: Span, strs: ~[ast::ident]) -> ast::Path;\n+    fn path_ident(&self, span: Span, id: ast::ident) -> ast::Path;\n+    fn path_global(&self, span: Span, strs: ~[ast::ident]) -> ast::Path;\n+    fn path_all(&self, sp: Span,\n                 global: bool,\n                 idents: ~[ast::ident],\n                 rp: Option<ast::Lifetime>,\n@@ -45,203 +45,203 @@ pub trait AstBuilder {\n     // types\n     fn ty_mt(&self, ty: ast::Ty, mutbl: ast::mutability) -> ast::mt;\n \n-    fn ty(&self, span: span, ty: ast::ty_) -> ast::Ty;\n+    fn ty(&self, span: Span, ty: ast::ty_) -> ast::Ty;\n     fn ty_path(&self, ast::Path, Option<OptVec<ast::TyParamBound>>) -> ast::Ty;\n-    fn ty_ident(&self, span: span, idents: ast::ident) -> ast::Ty;\n+    fn ty_ident(&self, span: Span, idents: ast::ident) -> ast::Ty;\n \n-    fn ty_rptr(&self, span: span,\n+    fn ty_rptr(&self, span: Span,\n                ty: ast::Ty,\n                lifetime: Option<ast::Lifetime>,\n                mutbl: ast::mutability) -> ast::Ty;\n-    fn ty_uniq(&self, span: span, ty: ast::Ty) -> ast::Ty;\n-    fn ty_box(&self, span: span, ty: ast::Ty, mutbl: ast::mutability) -> ast::Ty;\n+    fn ty_uniq(&self, span: Span, ty: ast::Ty) -> ast::Ty;\n+    fn ty_box(&self, span: Span, ty: ast::Ty, mutbl: ast::mutability) -> ast::Ty;\n \n     fn ty_option(&self, ty: ast::Ty) -> ast::Ty;\n-    fn ty_infer(&self, sp: span) -> ast::Ty;\n+    fn ty_infer(&self, sp: Span) -> ast::Ty;\n     fn ty_nil(&self) -> ast::Ty;\n \n     fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty];\n     fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty];\n-    fn ty_field_imm(&self, span: span, name: ident, ty: ast::Ty) -> ast::TypeField;\n+    fn ty_field_imm(&self, span: Span, name: ident, ty: ast::Ty) -> ast::TypeField;\n     fn strip_bounds(&self, bounds: &Generics) -> Generics;\n \n     fn typaram(&self, id: ast::ident, bounds: OptVec<ast::TyParamBound>) -> ast::TyParam;\n \n     fn trait_ref(&self, path: ast::Path) -> ast::trait_ref;\n     fn typarambound(&self, path: ast::Path) -> ast::TyParamBound;\n-    fn lifetime(&self, span: span, ident: ast::ident) -> ast::Lifetime;\n+    fn lifetime(&self, span: Span, ident: ast::ident) -> ast::Lifetime;\n \n     // statements\n     fn stmt_expr(&self, expr: @ast::expr) -> @ast::stmt;\n-    fn stmt_let(&self, sp: span, mutbl: bool, ident: ast::ident, ex: @ast::expr) -> @ast::stmt;\n+    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::ident, ex: @ast::expr) -> @ast::stmt;\n     fn stmt_let_typed(&self,\n-                      sp: span,\n+                      sp: Span,\n                       mutbl: bool,\n                       ident: ast::ident,\n                       typ: ast::Ty,\n                       ex: @ast::expr)\n                       -> @ast::stmt;\n \n     // blocks\n-    fn block(&self, span: span, stmts: ~[@ast::stmt], expr: Option<@ast::expr>) -> ast::Block;\n+    fn block(&self, span: Span, stmts: ~[@ast::stmt], expr: Option<@ast::expr>) -> ast::Block;\n     fn block_expr(&self, expr: @ast::expr) -> ast::Block;\n-    fn block_all(&self, span: span,\n+    fn block_all(&self, span: Span,\n                  view_items: ~[ast::view_item],\n                  stmts: ~[@ast::stmt],\n                  expr: Option<@ast::expr>) -> ast::Block;\n \n     // expressions\n-    fn expr(&self, span: span, node: ast::expr_) -> @ast::expr;\n+    fn expr(&self, span: Span, node: ast::expr_) -> @ast::expr;\n     fn expr_path(&self, path: ast::Path) -> @ast::expr;\n-    fn expr_ident(&self, span: span, id: ast::ident) -> @ast::expr;\n+    fn expr_ident(&self, span: Span, id: ast::ident) -> @ast::expr;\n \n-    fn expr_self(&self, span: span) -> @ast::expr;\n-    fn expr_binary(&self, sp: span, op: ast::binop,\n+    fn expr_self(&self, span: Span) -> @ast::expr;\n+    fn expr_binary(&self, sp: Span, op: ast::binop,\n                    lhs: @ast::expr, rhs: @ast::expr) -> @ast::expr;\n-    fn expr_deref(&self, sp: span, e: @ast::expr) -> @ast::expr;\n-    fn expr_unary(&self, sp: span, op: ast::unop, e: @ast::expr) -> @ast::expr;\n-\n-    fn expr_managed(&self, sp: span, e: @ast::expr) -> @ast::expr;\n-    fn expr_addr_of(&self, sp: span, e: @ast::expr) -> @ast::expr;\n-    fn expr_mut_addr_of(&self, sp: span, e: @ast::expr) -> @ast::expr;\n-    fn expr_field_access(&self, span: span, expr: @ast::expr, ident: ast::ident) -> @ast::expr;\n-    fn expr_call(&self, span: span, expr: @ast::expr, args: ~[@ast::expr]) -> @ast::expr;\n-    fn expr_call_ident(&self, span: span, id: ast::ident, args: ~[@ast::expr]) -> @ast::expr;\n-    fn expr_call_global(&self, sp: span, fn_path: ~[ast::ident],\n+    fn expr_deref(&self, sp: Span, e: @ast::expr) -> @ast::expr;\n+    fn expr_unary(&self, sp: Span, op: ast::unop, e: @ast::expr) -> @ast::expr;\n+\n+    fn expr_managed(&self, sp: Span, e: @ast::expr) -> @ast::expr;\n+    fn expr_addr_of(&self, sp: Span, e: @ast::expr) -> @ast::expr;\n+    fn expr_mut_addr_of(&self, sp: Span, e: @ast::expr) -> @ast::expr;\n+    fn expr_field_access(&self, span: Span, expr: @ast::expr, ident: ast::ident) -> @ast::expr;\n+    fn expr_call(&self, span: Span, expr: @ast::expr, args: ~[@ast::expr]) -> @ast::expr;\n+    fn expr_call_ident(&self, span: Span, id: ast::ident, args: ~[@ast::expr]) -> @ast::expr;\n+    fn expr_call_global(&self, sp: Span, fn_path: ~[ast::ident],\n                         args: ~[@ast::expr]) -> @ast::expr;\n-    fn expr_method_call(&self, span: span,\n+    fn expr_method_call(&self, span: Span,\n                         expr: @ast::expr, ident: ast::ident,\n                         args: ~[@ast::expr]) -> @ast::expr;\n     fn expr_block(&self, b: ast::Block) -> @ast::expr;\n \n-    fn field_imm(&self, span: span, name: ident, e: @ast::expr) -> ast::Field;\n-    fn expr_struct(&self, span: span, path: ast::Path, fields: ~[ast::Field]) -> @ast::expr;\n-    fn expr_struct_ident(&self, span: span, id: ast::ident, fields: ~[ast::Field]) -> @ast::expr;\n+    fn field_imm(&self, span: Span, name: ident, e: @ast::expr) -> ast::Field;\n+    fn expr_struct(&self, span: Span, path: ast::Path, fields: ~[ast::Field]) -> @ast::expr;\n+    fn expr_struct_ident(&self, span: Span, id: ast::ident, fields: ~[ast::Field]) -> @ast::expr;\n \n-    fn expr_lit(&self, sp: span, lit: ast::lit_) -> @ast::expr;\n+    fn expr_lit(&self, sp: Span, lit: ast::lit_) -> @ast::expr;\n \n-    fn expr_uint(&self, span: span, i: uint) -> @ast::expr;\n-    fn expr_int(&self, sp: span, i: int) -> @ast::expr;\n-    fn expr_u8(&self, sp: span, u: u8) -> @ast::expr;\n-    fn expr_bool(&self, sp: span, value: bool) -> @ast::expr;\n+    fn expr_uint(&self, span: Span, i: uint) -> @ast::expr;\n+    fn expr_int(&self, sp: Span, i: int) -> @ast::expr;\n+    fn expr_u8(&self, sp: Span, u: u8) -> @ast::expr;\n+    fn expr_bool(&self, sp: Span, value: bool) -> @ast::expr;\n \n-    fn expr_vstore(&self, sp: span, expr: @ast::expr, vst: ast::expr_vstore) -> @ast::expr;\n-    fn expr_vec(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr;\n-    fn expr_vec_uniq(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr;\n-    fn expr_vec_slice(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr;\n-    fn expr_str(&self, sp: span, s: @str) -> @ast::expr;\n-    fn expr_str_uniq(&self, sp: span, s: @str) -> @ast::expr;\n+    fn expr_vstore(&self, sp: Span, expr: @ast::expr, vst: ast::expr_vstore) -> @ast::expr;\n+    fn expr_vec(&self, sp: Span, exprs: ~[@ast::expr]) -> @ast::expr;\n+    fn expr_vec_uniq(&self, sp: Span, exprs: ~[@ast::expr]) -> @ast::expr;\n+    fn expr_vec_slice(&self, sp: Span, exprs: ~[@ast::expr]) -> @ast::expr;\n+    fn expr_str(&self, sp: Span, s: @str) -> @ast::expr;\n+    fn expr_str_uniq(&self, sp: Span, s: @str) -> @ast::expr;\n \n-    fn expr_unreachable(&self, span: span) -> @ast::expr;\n+    fn expr_unreachable(&self, span: Span) -> @ast::expr;\n \n-    fn pat(&self, span: span, pat: ast::pat_) -> @ast::pat;\n-    fn pat_wild(&self, span: span) -> @ast::pat;\n-    fn pat_lit(&self, span: span, expr: @ast::expr) -> @ast::pat;\n-    fn pat_ident(&self, span: span, ident: ast::ident) -> @ast::pat;\n+    fn pat(&self, span: Span, pat: ast::pat_) -> @ast::pat;\n+    fn pat_wild(&self, span: Span) -> @ast::pat;\n+    fn pat_lit(&self, span: Span, expr: @ast::expr) -> @ast::pat;\n+    fn pat_ident(&self, span: Span, ident: ast::ident) -> @ast::pat;\n \n     fn pat_ident_binding_mode(&self,\n-                              span: span,\n+                              span: Span,\n                               ident: ast::ident,\n                               bm: ast::binding_mode) -> @ast::pat;\n-    fn pat_enum(&self, span: span, path: ast::Path, subpats: ~[@ast::pat]) -> @ast::pat;\n-    fn pat_struct(&self, span: span,\n+    fn pat_enum(&self, span: Span, path: ast::Path, subpats: ~[@ast::pat]) -> @ast::pat;\n+    fn pat_struct(&self, span: Span,\n                   path: ast::Path, field_pats: ~[ast::field_pat]) -> @ast::pat;\n \n-    fn arm(&self, span: span, pats: ~[@ast::pat], expr: @ast::expr) -> ast::arm;\n-    fn arm_unreachable(&self, span: span) -> ast::arm;\n+    fn arm(&self, span: Span, pats: ~[@ast::pat], expr: @ast::expr) -> ast::arm;\n+    fn arm_unreachable(&self, span: Span) -> ast::arm;\n \n-    fn expr_match(&self, span: span, arg: @ast::expr, arms: ~[ast::arm]) -> @ast::expr;\n-    fn expr_if(&self, span: span,\n+    fn expr_match(&self, span: Span, arg: @ast::expr, arms: ~[ast::arm]) -> @ast::expr;\n+    fn expr_if(&self, span: Span,\n                cond: @ast::expr, then: @ast::expr, els: Option<@ast::expr>) -> @ast::expr;\n \n-    fn lambda_fn_decl(&self, span: span, fn_decl: ast::fn_decl, blk: ast::Block) -> @ast::expr;\n+    fn lambda_fn_decl(&self, span: Span, fn_decl: ast::fn_decl, blk: ast::Block) -> @ast::expr;\n \n-    fn lambda(&self, span: span, ids: ~[ast::ident], blk: ast::Block) -> @ast::expr;\n-    fn lambda0(&self, span: span, blk: ast::Block) -> @ast::expr;\n-    fn lambda1(&self, span: span, blk: ast::Block, ident: ast::ident) -> @ast::expr;\n+    fn lambda(&self, span: Span, ids: ~[ast::ident], blk: ast::Block) -> @ast::expr;\n+    fn lambda0(&self, span: Span, blk: ast::Block) -> @ast::expr;\n+    fn lambda1(&self, span: Span, blk: ast::Block, ident: ast::ident) -> @ast::expr;\n \n-    fn lambda_expr(&self, span: span, ids: ~[ast::ident], blk: @ast::expr) -> @ast::expr;\n-    fn lambda_expr_0(&self, span: span, expr: @ast::expr) -> @ast::expr;\n-    fn lambda_expr_1(&self, span: span, expr: @ast::expr, ident: ast::ident) -> @ast::expr;\n+    fn lambda_expr(&self, span: Span, ids: ~[ast::ident], blk: @ast::expr) -> @ast::expr;\n+    fn lambda_expr_0(&self, span: Span, expr: @ast::expr) -> @ast::expr;\n+    fn lambda_expr_1(&self, span: Span, expr: @ast::expr, ident: ast::ident) -> @ast::expr;\n \n-    fn lambda_stmts(&self, span: span, ids: ~[ast::ident], blk: ~[@ast::stmt]) -> @ast::expr;\n-    fn lambda_stmts_0(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr;\n-    fn lambda_stmts_1(&self, span: span, stmts: ~[@ast::stmt], ident: ast::ident) -> @ast::expr;\n+    fn lambda_stmts(&self, span: Span, ids: ~[ast::ident], blk: ~[@ast::stmt]) -> @ast::expr;\n+    fn lambda_stmts_0(&self, span: Span, stmts: ~[@ast::stmt]) -> @ast::expr;\n+    fn lambda_stmts_1(&self, span: Span, stmts: ~[@ast::stmt], ident: ast::ident) -> @ast::expr;\n \n     // items\n-    fn item(&self, span: span,\n+    fn item(&self, span: Span,\n             name: ident, attrs: ~[ast::Attribute], node: ast::item_) -> @ast::item;\n \n-    fn arg(&self, span: span, name: ident, ty: ast::Ty) -> ast::arg;\n+    fn arg(&self, span: Span, name: ident, ty: ast::Ty) -> ast::arg;\n     // XXX unused self\n     fn fn_decl(&self, inputs: ~[ast::arg], output: ast::Ty) -> ast::fn_decl;\n \n     fn item_fn_poly(&self,\n-                    span: span,\n+                    span: Span,\n                     name: ident,\n                     inputs: ~[ast::arg],\n                     output: ast::Ty,\n                     generics: Generics,\n                     body: ast::Block) -> @ast::item;\n     fn item_fn(&self,\n-               span: span,\n+               span: Span,\n                name: ident,\n                inputs: ~[ast::arg],\n                output: ast::Ty,\n                body: ast::Block) -> @ast::item;\n \n-    fn variant(&self, span: span, name: ident, tys: ~[ast::Ty]) -> ast::variant;\n+    fn variant(&self, span: Span, name: ident, tys: ~[ast::Ty]) -> ast::variant;\n     fn item_enum_poly(&self,\n-                      span: span,\n+                      span: Span,\n                       name: ident,\n                       enum_definition: ast::enum_def,\n                       generics: Generics) -> @ast::item;\n-    fn item_enum(&self, span: span, name: ident, enum_def: ast::enum_def) -> @ast::item;\n+    fn item_enum(&self, span: Span, name: ident, enum_def: ast::enum_def) -> @ast::item;\n \n     fn item_struct_poly(&self,\n-                        span: span,\n+                        span: Span,\n                         name: ident,\n                         struct_def: ast::struct_def,\n                         generics: Generics) -> @ast::item;\n-    fn item_struct(&self, span: span, name: ident, struct_def: ast::struct_def) -> @ast::item;\n+    fn item_struct(&self, span: Span, name: ident, struct_def: ast::struct_def) -> @ast::item;\n \n-    fn item_mod(&self, span: span,\n+    fn item_mod(&self, span: Span,\n                 name: ident, attrs: ~[ast::Attribute],\n                 vi: ~[ast::view_item], items: ~[@ast::item]) -> @ast::item;\n \n     fn item_ty_poly(&self,\n-                    span: span,\n+                    span: Span,\n                     name: ident,\n                     ty: ast::Ty,\n                     generics: Generics) -> @ast::item;\n-    fn item_ty(&self, span: span, name: ident, ty: ast::Ty) -> @ast::item;\n+    fn item_ty(&self, span: Span, name: ident, ty: ast::Ty) -> @ast::item;\n \n-    fn attribute(&self, sp: span, mi: @ast::MetaItem) -> ast::Attribute;\n+    fn attribute(&self, sp: Span, mi: @ast::MetaItem) -> ast::Attribute;\n \n-    fn meta_word(&self, sp: span, w: @str) -> @ast::MetaItem;\n-    fn meta_list(&self, sp: span, name: @str, mis: ~[@ast::MetaItem]) -> @ast::MetaItem;\n-    fn meta_name_value(&self, sp: span, name: @str, value: ast::lit_) -> @ast::MetaItem;\n+    fn meta_word(&self, sp: Span, w: @str) -> @ast::MetaItem;\n+    fn meta_list(&self, sp: Span, name: @str, mis: ~[@ast::MetaItem]) -> @ast::MetaItem;\n+    fn meta_name_value(&self, sp: Span, name: @str, value: ast::lit_) -> @ast::MetaItem;\n \n-    fn view_use(&self, sp: span,\n+    fn view_use(&self, sp: Span,\n                 vis: ast::visibility, vp: ~[@ast::view_path]) -> ast::view_item;\n-    fn view_use_list(&self, sp: span, vis: ast::visibility,\n+    fn view_use_list(&self, sp: Span, vis: ast::visibility,\n                      path: ~[ast::ident], imports: &[ast::ident]) -> ast::view_item;\n-    fn view_use_glob(&self, sp: span,\n+    fn view_use_glob(&self, sp: Span,\n                      vis: ast::visibility, path: ~[ast::ident]) -> ast::view_item;\n }\n \n impl AstBuilder for @ExtCtxt {\n-    fn path(&self, span: span, strs: ~[ast::ident]) -> ast::Path {\n+    fn path(&self, span: Span, strs: ~[ast::ident]) -> ast::Path {\n         self.path_all(span, false, strs, None, ~[])\n     }\n-    fn path_ident(&self, span: span, id: ast::ident) -> ast::Path {\n+    fn path_ident(&self, span: Span, id: ast::ident) -> ast::Path {\n         self.path(span, ~[id])\n     }\n-    fn path_global(&self, span: span, strs: ~[ast::ident]) -> ast::Path {\n+    fn path_global(&self, span: Span, strs: ~[ast::ident]) -> ast::Path {\n         self.path_all(span, true, strs, None, ~[])\n     }\n     fn path_all(&self,\n-                sp: span,\n+                sp: Span,\n                 global: bool,\n                 mut idents: ~[ast::ident],\n                 rp: Option<ast::Lifetime>,\n@@ -275,7 +275,7 @@ impl AstBuilder for @ExtCtxt {\n         }\n     }\n \n-    fn ty(&self, span: span, ty: ast::ty_) -> ast::Ty {\n+    fn ty(&self, span: Span, ty: ast::ty_) -> ast::Ty {\n         ast::Ty {\n             id: self.next_id(),\n             span: span,\n@@ -291,24 +291,24 @@ impl AstBuilder for @ExtCtxt {\n \n     // Might need to take bounds as an argument in the future, if you ever want\n     // to generate a bounded existential trait type.\n-    fn ty_ident(&self, span: span, ident: ast::ident)\n+    fn ty_ident(&self, span: Span, ident: ast::ident)\n         -> ast::Ty {\n         self.ty_path(self.path_ident(span, ident), None)\n     }\n \n     fn ty_rptr(&self,\n-               span: span,\n+               span: Span,\n                ty: ast::Ty,\n                lifetime: Option<ast::Lifetime>,\n                mutbl: ast::mutability)\n         -> ast::Ty {\n         self.ty(span,\n                 ast::ty_rptr(lifetime, self.ty_mt(ty, mutbl)))\n     }\n-    fn ty_uniq(&self, span: span, ty: ast::Ty) -> ast::Ty {\n+    fn ty_uniq(&self, span: Span, ty: ast::Ty) -> ast::Ty {\n         self.ty(span, ast::ty_uniq(self.ty_mt(ty, ast::m_imm)))\n     }\n-    fn ty_box(&self, span: span,\n+    fn ty_box(&self, span: Span,\n                  ty: ast::Ty, mutbl: ast::mutability) -> ast::Ty {\n         self.ty(span, ast::ty_box(self.ty_mt(ty, mutbl)))\n     }\n@@ -326,15 +326,15 @@ impl AstBuilder for @ExtCtxt {\n                           ~[ ty ]), None)\n     }\n \n-    fn ty_field_imm(&self, span: span, name: ident, ty: ast::Ty) -> ast::TypeField {\n+    fn ty_field_imm(&self, span: Span, name: ident, ty: ast::Ty) -> ast::TypeField {\n         ast::TypeField {\n             ident: name,\n             mt: ast::mt { ty: ~ty, mutbl: ast::m_imm },\n             span: span,\n         }\n     }\n \n-    fn ty_infer(&self, span: span) -> ast::Ty {\n+    fn ty_infer(&self, span: Span) -> ast::Ty {\n         self.ty(span, ast::ty_infer)\n     }\n \n@@ -385,15 +385,15 @@ impl AstBuilder for @ExtCtxt {\n         ast::TraitTyParamBound(self.trait_ref(path))\n     }\n \n-    fn lifetime(&self, span: span, ident: ast::ident) -> ast::Lifetime {\n+    fn lifetime(&self, span: Span, ident: ast::ident) -> ast::Lifetime {\n         ast::Lifetime { id: self.next_id(), span: span, ident: ident }\n     }\n \n     fn stmt_expr(&self, expr: @ast::expr) -> @ast::stmt {\n         @respan(expr.span, ast::stmt_semi(expr, self.next_id()))\n     }\n \n-    fn stmt_let(&self, sp: span, mutbl: bool, ident: ast::ident, ex: @ast::expr) -> @ast::stmt {\n+    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::ident, ex: @ast::expr) -> @ast::stmt {\n         let pat = self.pat_ident(sp, ident);\n         let local = @ast::Local {\n             is_mutbl: mutbl,\n@@ -408,7 +408,7 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn stmt_let_typed(&self,\n-                      sp: span,\n+                      sp: Span,\n                       mutbl: bool,\n                       ident: ast::ident,\n                       typ: ast::Ty,\n@@ -427,15 +427,15 @@ impl AstBuilder for @ExtCtxt {\n         @respan(sp, ast::stmt_decl(@decl, self.next_id()))\n     }\n \n-    fn block(&self, span: span, stmts: ~[@ast::stmt], expr: Option<@expr>) -> ast::Block {\n+    fn block(&self, span: Span, stmts: ~[@ast::stmt], expr: Option<@expr>) -> ast::Block {\n         self.block_all(span, ~[], stmts, expr)\n     }\n \n     fn block_expr(&self, expr: @ast::expr) -> ast::Block {\n         self.block_all(expr.span, ~[], ~[], Some(expr))\n     }\n     fn block_all(&self,\n-                 span: span,\n+                 span: Span,\n                  view_items: ~[ast::view_item],\n                  stmts: ~[@ast::stmt],\n                  expr: Option<@ast::expr>) -> ast::Block {\n@@ -449,7 +449,7 @@ impl AstBuilder for @ExtCtxt {\n            }\n     }\n \n-    fn expr(&self, span: span, node: ast::expr_) -> @ast::expr {\n+    fn expr(&self, span: Span, node: ast::expr_) -> @ast::expr {\n         @ast::expr {\n             id: self.next_id(),\n             node: node,\n@@ -461,53 +461,53 @@ impl AstBuilder for @ExtCtxt {\n         self.expr(path.span, ast::expr_path(path))\n     }\n \n-    fn expr_ident(&self, span: span, id: ast::ident) -> @ast::expr {\n+    fn expr_ident(&self, span: Span, id: ast::ident) -> @ast::expr {\n         self.expr_path(self.path_ident(span, id))\n     }\n-    fn expr_self(&self, span: span) -> @ast::expr {\n+    fn expr_self(&self, span: Span) -> @ast::expr {\n         self.expr(span, ast::expr_self)\n     }\n \n-    fn expr_binary(&self, sp: span, op: ast::binop,\n+    fn expr_binary(&self, sp: Span, op: ast::binop,\n                    lhs: @ast::expr, rhs: @ast::expr) -> @ast::expr {\n         self.expr(sp, ast::expr_binary(self.next_id(), op, lhs, rhs))\n     }\n \n-    fn expr_deref(&self, sp: span, e: @ast::expr) -> @ast::expr {\n+    fn expr_deref(&self, sp: Span, e: @ast::expr) -> @ast::expr {\n         self.expr_unary(sp, ast::deref, e)\n     }\n-    fn expr_unary(&self, sp: span, op: ast::unop, e: @ast::expr)\n+    fn expr_unary(&self, sp: Span, op: ast::unop, e: @ast::expr)\n         -> @ast::expr {\n         self.expr(sp, ast::expr_unary(self.next_id(), op, e))\n     }\n \n-    fn expr_managed(&self, sp: span, e: @ast::expr) -> @ast::expr {\n+    fn expr_managed(&self, sp: Span, e: @ast::expr) -> @ast::expr {\n         self.expr_unary(sp, ast::box(ast::m_imm), e)\n     }\n \n-    fn expr_field_access(&self, sp: span, expr: @ast::expr, ident: ast::ident) -> @ast::expr {\n+    fn expr_field_access(&self, sp: Span, expr: @ast::expr, ident: ast::ident) -> @ast::expr {\n         self.expr(sp, ast::expr_field(expr, ident, ~[]))\n     }\n-    fn expr_addr_of(&self, sp: span, e: @ast::expr) -> @ast::expr {\n+    fn expr_addr_of(&self, sp: Span, e: @ast::expr) -> @ast::expr {\n         self.expr(sp, ast::expr_addr_of(ast::m_imm, e))\n     }\n-    fn expr_mut_addr_of(&self, sp: span, e: @ast::expr) -> @ast::expr {\n+    fn expr_mut_addr_of(&self, sp: Span, e: @ast::expr) -> @ast::expr {\n         self.expr(sp, ast::expr_addr_of(ast::m_mutbl, e))\n     }\n \n-    fn expr_call(&self, span: span, expr: @ast::expr, args: ~[@ast::expr]) -> @ast::expr {\n+    fn expr_call(&self, span: Span, expr: @ast::expr, args: ~[@ast::expr]) -> @ast::expr {\n         self.expr(span, ast::expr_call(expr, args, ast::NoSugar))\n     }\n-    fn expr_call_ident(&self, span: span, id: ast::ident, args: ~[@ast::expr]) -> @ast::expr {\n+    fn expr_call_ident(&self, span: Span, id: ast::ident, args: ~[@ast::expr]) -> @ast::expr {\n         self.expr(span,\n                   ast::expr_call(self.expr_ident(span, id), args, ast::NoSugar))\n     }\n-    fn expr_call_global(&self, sp: span, fn_path: ~[ast::ident],\n+    fn expr_call_global(&self, sp: Span, fn_path: ~[ast::ident],\n                       args: ~[@ast::expr]) -> @ast::expr {\n         let pathexpr = self.expr_path(self.path_global(sp, fn_path));\n         self.expr_call(sp, pathexpr, args)\n     }\n-    fn expr_method_call(&self, span: span,\n+    fn expr_method_call(&self, span: Span,\n                         expr: @ast::expr,\n                         ident: ast::ident,\n                         args: ~[@ast::expr]) -> @ast::expr {\n@@ -517,54 +517,54 @@ impl AstBuilder for @ExtCtxt {\n     fn expr_block(&self, b: ast::Block) -> @ast::expr {\n         self.expr(b.span, ast::expr_block(b))\n     }\n-    fn field_imm(&self, span: span, name: ident, e: @ast::expr) -> ast::Field {\n+    fn field_imm(&self, span: Span, name: ident, e: @ast::expr) -> ast::Field {\n         ast::Field { ident: name, expr: e, span: span }\n     }\n-    fn expr_struct(&self, span: span, path: ast::Path, fields: ~[ast::Field]) -> @ast::expr {\n+    fn expr_struct(&self, span: Span, path: ast::Path, fields: ~[ast::Field]) -> @ast::expr {\n         self.expr(span, ast::expr_struct(path, fields, None))\n     }\n-    fn expr_struct_ident(&self, span: span,\n+    fn expr_struct_ident(&self, span: Span,\n                          id: ast::ident, fields: ~[ast::Field]) -> @ast::expr {\n         self.expr_struct(span, self.path_ident(span, id), fields)\n     }\n \n-    fn expr_lit(&self, sp: span, lit: ast::lit_) -> @ast::expr {\n+    fn expr_lit(&self, sp: Span, lit: ast::lit_) -> @ast::expr {\n         self.expr(sp, ast::expr_lit(@respan(sp, lit)))\n     }\n-    fn expr_uint(&self, span: span, i: uint) -> @ast::expr {\n+    fn expr_uint(&self, span: Span, i: uint) -> @ast::expr {\n         self.expr_lit(span, ast::lit_uint(i as u64, ast::ty_u))\n     }\n-    fn expr_int(&self, sp: span, i: int) -> @ast::expr {\n+    fn expr_int(&self, sp: Span, i: int) -> @ast::expr {\n         self.expr_lit(sp, ast::lit_int(i as i64, ast::ty_i))\n     }\n-    fn expr_u8(&self, sp: span, u: u8) -> @ast::expr {\n+    fn expr_u8(&self, sp: Span, u: u8) -> @ast::expr {\n         self.expr_lit(sp, ast::lit_uint(u as u64, ast::ty_u8))\n     }\n-    fn expr_bool(&self, sp: span, value: bool) -> @ast::expr {\n+    fn expr_bool(&self, sp: Span, value: bool) -> @ast::expr {\n         self.expr_lit(sp, ast::lit_bool(value))\n     }\n \n-    fn expr_vstore(&self, sp: span, expr: @ast::expr, vst: ast::expr_vstore) -> @ast::expr {\n+    fn expr_vstore(&self, sp: Span, expr: @ast::expr, vst: ast::expr_vstore) -> @ast::expr {\n         self.expr(sp, ast::expr_vstore(expr, vst))\n     }\n-    fn expr_vec(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr {\n+    fn expr_vec(&self, sp: Span, exprs: ~[@ast::expr]) -> @ast::expr {\n         self.expr(sp, ast::expr_vec(exprs, ast::m_imm))\n     }\n-    fn expr_vec_uniq(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr {\n+    fn expr_vec_uniq(&self, sp: Span, exprs: ~[@ast::expr]) -> @ast::expr {\n         self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::expr_vstore_uniq)\n     }\n-    fn expr_vec_slice(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr {\n+    fn expr_vec_slice(&self, sp: Span, exprs: ~[@ast::expr]) -> @ast::expr {\n         self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::expr_vstore_slice)\n     }\n-    fn expr_str(&self, sp: span, s: @str) -> @ast::expr {\n+    fn expr_str(&self, sp: Span, s: @str) -> @ast::expr {\n         self.expr_lit(sp, ast::lit_str(s))\n     }\n-    fn expr_str_uniq(&self, sp: span, s: @str) -> @ast::expr {\n+    fn expr_str_uniq(&self, sp: Span, s: @str) -> @ast::expr {\n         self.expr_vstore(sp, self.expr_str(sp, s), ast::expr_vstore_uniq)\n     }\n \n \n-    fn expr_unreachable(&self, span: span) -> @ast::expr {\n+    fn expr_unreachable(&self, span: Span) -> @ast::expr {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         self.expr_call_global(\n             span,\n@@ -582,114 +582,114 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n \n-    fn pat(&self, span: span, pat: ast::pat_) -> @ast::pat {\n+    fn pat(&self, span: Span, pat: ast::pat_) -> @ast::pat {\n         @ast::pat { id: self.next_id(), node: pat, span: span }\n     }\n-    fn pat_wild(&self, span: span) -> @ast::pat {\n+    fn pat_wild(&self, span: Span) -> @ast::pat {\n         self.pat(span, ast::pat_wild)\n     }\n-    fn pat_lit(&self, span: span, expr: @ast::expr) -> @ast::pat {\n+    fn pat_lit(&self, span: Span, expr: @ast::expr) -> @ast::pat {\n         self.pat(span, ast::pat_lit(expr))\n     }\n-    fn pat_ident(&self, span: span, ident: ast::ident) -> @ast::pat {\n+    fn pat_ident(&self, span: Span, ident: ast::ident) -> @ast::pat {\n         self.pat_ident_binding_mode(span, ident, ast::bind_infer)\n     }\n \n     fn pat_ident_binding_mode(&self,\n-                              span: span,\n+                              span: Span,\n                               ident: ast::ident,\n                               bm: ast::binding_mode) -> @ast::pat {\n         let path = self.path_ident(span, ident);\n         let pat = ast::pat_ident(bm, path, None);\n         self.pat(span, pat)\n     }\n-    fn pat_enum(&self, span: span, path: ast::Path, subpats: ~[@ast::pat]) -> @ast::pat {\n+    fn pat_enum(&self, span: Span, path: ast::Path, subpats: ~[@ast::pat]) -> @ast::pat {\n         let pat = ast::pat_enum(path, Some(subpats));\n         self.pat(span, pat)\n     }\n-    fn pat_struct(&self, span: span,\n+    fn pat_struct(&self, span: Span,\n                   path: ast::Path, field_pats: ~[ast::field_pat]) -> @ast::pat {\n         let pat = ast::pat_struct(path, field_pats, false);\n         self.pat(span, pat)\n     }\n \n-    fn arm(&self, _span: span, pats: ~[@ast::pat], expr: @ast::expr) -> ast::arm {\n+    fn arm(&self, _span: Span, pats: ~[@ast::pat], expr: @ast::expr) -> ast::arm {\n         ast::arm {\n             pats: pats,\n             guard: None,\n             body: self.block_expr(expr)\n         }\n     }\n \n-    fn arm_unreachable(&self, span: span) -> ast::arm {\n+    fn arm_unreachable(&self, span: Span) -> ast::arm {\n         self.arm(span, ~[self.pat_wild(span)], self.expr_unreachable(span))\n     }\n \n-    fn expr_match(&self, span: span, arg: @ast::expr, arms: ~[ast::arm]) -> @expr {\n+    fn expr_match(&self, span: Span, arg: @ast::expr, arms: ~[ast::arm]) -> @expr {\n         self.expr(span, ast::expr_match(arg, arms))\n     }\n \n-    fn expr_if(&self, span: span,\n+    fn expr_if(&self, span: Span,\n                cond: @ast::expr, then: @ast::expr, els: Option<@ast::expr>) -> @ast::expr {\n         let els = els.map_move(|x| self.expr_block(self.block_expr(x)));\n         self.expr(span, ast::expr_if(cond, self.block_expr(then), els))\n     }\n \n-    fn lambda_fn_decl(&self, span: span, fn_decl: ast::fn_decl, blk: ast::Block) -> @ast::expr {\n+    fn lambda_fn_decl(&self, span: Span, fn_decl: ast::fn_decl, blk: ast::Block) -> @ast::expr {\n         self.expr(span, ast::expr_fn_block(fn_decl, blk))\n     }\n-    fn lambda(&self, span: span, ids: ~[ast::ident], blk: ast::Block) -> @ast::expr {\n+    fn lambda(&self, span: Span, ids: ~[ast::ident], blk: ast::Block) -> @ast::expr {\n         let fn_decl = self.fn_decl(\n             ids.map(|id| self.arg(span, *id, self.ty_infer(span))),\n             self.ty_infer(span));\n \n         self.expr(span, ast::expr_fn_block(fn_decl, blk))\n     }\n     #[cfg(stage0)]\n-    fn lambda0(&self, _span: span, blk: ast::Block) -> @ast::expr {\n+    fn lambda0(&self, _span: Span, blk: ast::Block) -> @ast::expr {\n         let ext_cx = *self;\n         let blk_e = self.expr(blk.span, ast::expr_block(blk.clone()));\n         quote_expr!(|| $blk_e )\n     }\n     #[cfg(not(stage0))]\n-    fn lambda0(&self, _span: span, blk: ast::Block) -> @ast::expr {\n+    fn lambda0(&self, _span: Span, blk: ast::Block) -> @ast::expr {\n         let blk_e = self.expr(blk.span, ast::expr_block(blk.clone()));\n         quote_expr!(*self, || $blk_e )\n     }\n \n     #[cfg(stage0)]\n-    fn lambda1(&self, _span: span, blk: ast::Block, ident: ast::ident) -> @ast::expr {\n+    fn lambda1(&self, _span: Span, blk: ast::Block, ident: ast::ident) -> @ast::expr {\n         let ext_cx = *self;\n         let blk_e = self.expr(blk.span, ast::expr_block(blk.clone()));\n         quote_expr!(|$ident| $blk_e )\n     }\n     #[cfg(not(stage0))]\n-    fn lambda1(&self, _span: span, blk: ast::Block, ident: ast::ident) -> @ast::expr {\n+    fn lambda1(&self, _span: Span, blk: ast::Block, ident: ast::ident) -> @ast::expr {\n         let blk_e = self.expr(blk.span, ast::expr_block(blk.clone()));\n         quote_expr!(*self, |$ident| $blk_e )\n     }\n \n-    fn lambda_expr(&self, span: span, ids: ~[ast::ident], expr: @ast::expr) -> @ast::expr {\n+    fn lambda_expr(&self, span: Span, ids: ~[ast::ident], expr: @ast::expr) -> @ast::expr {\n         self.lambda(span, ids, self.block_expr(expr))\n     }\n-    fn lambda_expr_0(&self, span: span, expr: @ast::expr) -> @ast::expr {\n+    fn lambda_expr_0(&self, span: Span, expr: @ast::expr) -> @ast::expr {\n         self.lambda0(span, self.block_expr(expr))\n     }\n-    fn lambda_expr_1(&self, span: span, expr: @ast::expr, ident: ast::ident) -> @ast::expr {\n+    fn lambda_expr_1(&self, span: Span, expr: @ast::expr, ident: ast::ident) -> @ast::expr {\n         self.lambda1(span, self.block_expr(expr), ident)\n     }\n \n-    fn lambda_stmts(&self, span: span, ids: ~[ast::ident], stmts: ~[@ast::stmt]) -> @ast::expr {\n+    fn lambda_stmts(&self, span: Span, ids: ~[ast::ident], stmts: ~[@ast::stmt]) -> @ast::expr {\n         self.lambda(span, ids, self.block(span, stmts, None))\n     }\n-    fn lambda_stmts_0(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr {\n+    fn lambda_stmts_0(&self, span: Span, stmts: ~[@ast::stmt]) -> @ast::expr {\n         self.lambda0(span, self.block(span, stmts, None))\n     }\n-    fn lambda_stmts_1(&self, span: span, stmts: ~[@ast::stmt], ident: ast::ident) -> @ast::expr {\n+    fn lambda_stmts_1(&self, span: Span, stmts: ~[@ast::stmt], ident: ast::ident) -> @ast::expr {\n         self.lambda1(span, self.block(span, stmts, None), ident)\n     }\n \n-    fn arg(&self, span: span, ident: ast::ident, ty: ast::Ty) -> ast::arg {\n+    fn arg(&self, span: Span, ident: ast::ident, ty: ast::Ty) -> ast::arg {\n         let arg_pat = self.pat_ident(span, ident);\n         ast::arg {\n             is_mutbl: false,\n@@ -708,7 +708,7 @@ impl AstBuilder for @ExtCtxt {\n         }\n     }\n \n-    fn item(&self, span: span,\n+    fn item(&self, span: Span,\n             name: ident, attrs: ~[ast::Attribute], node: ast::item_) -> @ast::item {\n         // XXX: Would be nice if our generated code didn't violate\n         // Rust coding conventions\n@@ -721,7 +721,7 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn item_fn_poly(&self,\n-                    span: span,\n+                    span: Span,\n                     name: ident,\n                     inputs: ~[ast::arg],\n                     output: ast::Ty,\n@@ -738,7 +738,7 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn item_fn(&self,\n-               span: span,\n+               span: Span,\n                name: ident,\n                inputs: ~[ast::arg],\n                output: ast::Ty,\n@@ -753,7 +753,7 @@ impl AstBuilder for @ExtCtxt {\n             body)\n     }\n \n-    fn variant(&self, span: span, name: ident, tys: ~[ast::Ty]) -> ast::variant {\n+    fn variant(&self, span: Span, name: ident, tys: ~[ast::Ty]) -> ast::variant {\n         let args = tys.move_iter().map(|ty| {\n             ast::variant_arg { ty: ty, id: self.next_id() }\n         }).collect();\n@@ -769,21 +769,21 @@ impl AstBuilder for @ExtCtxt {\n                })\n     }\n \n-    fn item_enum_poly(&self, span: span, name: ident,\n+    fn item_enum_poly(&self, span: Span, name: ident,\n                       enum_definition: ast::enum_def,\n                       generics: Generics) -> @ast::item {\n         self.item(span, name, ~[], ast::item_enum(enum_definition, generics))\n     }\n \n-    fn item_enum(&self, span: span, name: ident,\n+    fn item_enum(&self, span: Span, name: ident,\n                  enum_definition: ast::enum_def) -> @ast::item {\n         self.item_enum_poly(span, name, enum_definition,\n                             ast_util::empty_generics())\n     }\n \n     fn item_struct(\n         &self,\n-        span: span,\n+        span: Span,\n         name: ident,\n         struct_def: ast::struct_def\n     ) -> @ast::item {\n@@ -797,15 +797,15 @@ impl AstBuilder for @ExtCtxt {\n \n     fn item_struct_poly(\n         &self,\n-        span: span,\n+        span: Span,\n         name: ident,\n         struct_def: ast::struct_def,\n         generics: Generics\n     ) -> @ast::item {\n         self.item(span, name, ~[], ast::item_struct(@struct_def, generics))\n     }\n \n-    fn item_mod(&self, span: span, name: ident,\n+    fn item_mod(&self, span: Span, name: ident,\n                 attrs: ~[ast::Attribute],\n                 vi: ~[ast::view_item],\n                 items: ~[@ast::item]) -> @ast::item {\n@@ -820,34 +820,34 @@ impl AstBuilder for @ExtCtxt {\n         )\n     }\n \n-    fn item_ty_poly(&self, span: span, name: ident, ty: ast::Ty,\n+    fn item_ty_poly(&self, span: Span, name: ident, ty: ast::Ty,\n                     generics: Generics) -> @ast::item {\n         self.item(span, name, ~[], ast::item_ty(ty, generics))\n     }\n \n-    fn item_ty(&self, span: span, name: ident, ty: ast::Ty) -> @ast::item {\n+    fn item_ty(&self, span: Span, name: ident, ty: ast::Ty) -> @ast::item {\n         self.item_ty_poly(span, name, ty, ast_util::empty_generics())\n     }\n \n-    fn attribute(&self, sp: span, mi: @ast::MetaItem) -> ast::Attribute {\n+    fn attribute(&self, sp: Span, mi: @ast::MetaItem) -> ast::Attribute {\n         respan(sp, ast::Attribute_ {\n             style: ast::AttrOuter,\n             value: mi,\n             is_sugared_doc: false,\n         })\n     }\n \n-    fn meta_word(&self, sp: span, w: @str) -> @ast::MetaItem {\n+    fn meta_word(&self, sp: Span, w: @str) -> @ast::MetaItem {\n         @respan(sp, ast::MetaWord(w))\n     }\n-    fn meta_list(&self, sp: span, name: @str, mis: ~[@ast::MetaItem]) -> @ast::MetaItem {\n+    fn meta_list(&self, sp: Span, name: @str, mis: ~[@ast::MetaItem]) -> @ast::MetaItem {\n         @respan(sp, ast::MetaList(name, mis))\n     }\n-    fn meta_name_value(&self, sp: span, name: @str, value: ast::lit_) -> @ast::MetaItem {\n+    fn meta_name_value(&self, sp: Span, name: @str, value: ast::lit_) -> @ast::MetaItem {\n         @respan(sp, ast::MetaNameValue(name, respan(sp, value)))\n     }\n \n-    fn view_use(&self, sp: span,\n+    fn view_use(&self, sp: Span,\n                 vis: ast::visibility, vp: ~[@ast::view_path]) -> ast::view_item {\n         ast::view_item {\n             node: ast::view_item_use(vp),\n@@ -857,7 +857,7 @@ impl AstBuilder for @ExtCtxt {\n         }\n     }\n \n-    fn view_use_list(&self, sp: span, vis: ast::visibility,\n+    fn view_use_list(&self, sp: Span, vis: ast::visibility,\n                      path: ~[ast::ident], imports: &[ast::ident]) -> ast::view_item {\n         let imports = do imports.map |id| {\n             respan(sp, ast::path_list_ident_ { name: *id, id: self.next_id() })\n@@ -870,7 +870,7 @@ impl AstBuilder for @ExtCtxt {\n                                                     self.next_id()))])\n     }\n \n-    fn view_use_glob(&self, sp: span,\n+    fn view_use_glob(&self, sp: Span,\n                      vis: ast::visibility, path: ~[ast::ident]) -> ast::view_item {\n         self.view_use(sp, vis,\n                       ~[@respan(sp,"}, {"sha": "1c8f582e7eed93eb02db9799cf7d6af284426407", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -11,12 +11,12 @@\n /* The compiler code necessary to support the bytes! extension. */\n \n use ast;\n-use codemap::span;\n+use codemap::Span;\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n \n-pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree]) -> base::MacResult {\n+pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> base::MacResult {\n     // Gather all argument expressions\n     let exprs = get_exprs_from_tts(cx, sp, tts);\n     let mut bytes = ~[];"}, {"sha": "89e7994530d737535ae2a93ea056a09d469d410c", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -15,7 +15,7 @@ match the current compilation environment.\n */\n \n use ast;\n-use codemap::span;\n+use codemap::Span;\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n@@ -25,7 +25,7 @@ use parse;\n use parse::token;\n use parse::attr::parser_attr;\n \n-pub fn expand_cfg(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree]) -> base::MacResult {\n+pub fn expand_cfg(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> base::MacResult {\n     let p = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg(), tts.to_owned());\n \n     let mut cfgs = ~[];"}, {"sha": "5354a4e2469f132b541907e1698a68912999b3b0", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -9,14 +9,14 @@\n // except according to those terms.\n \n use ast;\n-use codemap::span;\n+use codemap::Span;\n use ext::base::*;\n use ext::base;\n use opt_vec;\n use parse::token;\n use parse::token::{str_to_ident};\n \n-pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let mut res_str = ~\"\";\n     for (i, e) in tts.iter().enumerate() {"}, {"sha": "01cf61f45a478b99e11c59bf552724b03e01de5b", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n use ast::{MetaItem, item, expr};\n-use codemap::span;\n+use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_clone(cx: @ExtCtxt,\n-                             span: span,\n+                             span: Span,\n                              mitem: @MetaItem,\n                              in_items: ~[@item])\n                           -> ~[@item] {\n@@ -40,7 +40,7 @@ pub fn expand_deriving_clone(cx: @ExtCtxt,\n }\n \n pub fn expand_deriving_deep_clone(cx: @ExtCtxt,\n-                                  span: span,\n+                                  span: Span,\n                                   mitem: @MetaItem,\n                                   in_items: ~[@item])\n     -> ~[@item] {\n@@ -68,7 +68,7 @@ pub fn expand_deriving_deep_clone(cx: @ExtCtxt,\n \n fn cs_clone(\n     name: &str,\n-    cx: @ExtCtxt, span: span,\n+    cx: @ExtCtxt, span: Span,\n     substr: &Substructure) -> @expr {\n     let clone_ident = substr.method_ident;\n     let ctor_ident;"}, {"sha": "ce2b9ba7894e549ba9df03e4e1e329880cd4f571", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -9,22 +9,22 @@\n // except according to those terms.\n \n use ast::{MetaItem, item, expr};\n-use codemap::span;\n+use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_eq(cx: @ExtCtxt,\n-                          span: span,\n+                          span: Span,\n                           mitem: @MetaItem,\n                           in_items: ~[@item]) -> ~[@item] {\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n-    fn cs_eq(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n+    fn cs_eq(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @expr {\n         cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n                                  cx, span, substr)\n     }\n-    fn cs_ne(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n+    fn cs_ne(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @expr {\n         cs_or(|cx, span, _, _| cx.expr_bool(span, true),\n               cx, span, substr)\n     }"}, {"sha": "3f7492bb6b641192111dcc0ecd6c5cb687ea38d3", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -10,13 +10,13 @@\n \n use ast;\n use ast::{MetaItem, item, expr};\n-use codemap::span;\n+use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_ord(cx: @ExtCtxt,\n-                           span: span,\n+                           span: Span,\n                            mitem: @MetaItem,\n                            in_items: ~[@item]) -> ~[@item] {\n     macro_rules! md (\n@@ -48,7 +48,7 @@ pub fn expand_deriving_ord(cx: @ExtCtxt,\n }\n \n /// Strict inequality.\n-fn cs_op(less: bool, equal: bool, cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n+fn cs_op(less: bool, equal: bool, cx: @ExtCtxt, span: Span, substr: &Substructure) -> @expr {\n     let op = if less {ast::lt} else {ast::gt};\n     cs_fold(\n         false, // need foldr,"}, {"sha": "97b7464b3b5c3b7d25aa9548b1cdbec198250868", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -9,16 +9,16 @@\n // except according to those terms.\n \n use ast::{MetaItem, item, expr};\n-use codemap::span;\n+use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_totaleq(cx: @ExtCtxt,\n-                               span: span,\n+                               span: Span,\n                                mitem: @MetaItem,\n                                in_items: ~[@item]) -> ~[@item] {\n-    fn cs_equals(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n+    fn cs_equals(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @expr {\n         cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n                cx, span, substr)\n     }"}, {"sha": "8f520ff6c334b7da3d03bb0628378550236aa429", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -10,14 +10,14 @@\n \n use ast;\n use ast::{MetaItem, item, expr};\n-use codemap::span;\n+use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use std::cmp::{Ordering, Equal, Less, Greater};\n \n pub fn expand_deriving_totalord(cx: @ExtCtxt,\n-                                span: span,\n+                                span: Span,\n                                 mitem: @MetaItem,\n                                 in_items: ~[@item]) -> ~[@item] {\n     let trait_def = TraitDef {\n@@ -41,7 +41,7 @@ pub fn expand_deriving_totalord(cx: @ExtCtxt,\n }\n \n \n-pub fn ordering_const(cx: @ExtCtxt, span: span, cnst: Ordering) -> ast::Path {\n+pub fn ordering_const(cx: @ExtCtxt, span: Span, cnst: Ordering) -> ast::Path {\n     let cnst = match cnst {\n         Less => \"Less\",\n         Equal => \"Equal\",\n@@ -53,7 +53,7 @@ pub fn ordering_const(cx: @ExtCtxt, span: span, cnst: Ordering) -> ast::Path {\n                      cx.ident_of(cnst)])\n }\n \n-pub fn cs_cmp(cx: @ExtCtxt, span: span,\n+pub fn cs_cmp(cx: @ExtCtxt, span: Span,\n               substr: &Substructure) -> @expr {\n     let test_id = cx.ident_of(\"__test\");\n     let equals_path = ordering_const(cx, span, Equal);"}, {"sha": "6a2cddb3583d301035f5c9e264f21e9305b7ab81", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -16,13 +16,13 @@ encodable.rs for more.\n use std::vec;\n \n use ast::{MetaItem, item, expr, m_mutbl};\n-use codemap::span;\n+use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_decodable(cx: @ExtCtxt,\n-                                 span: span,\n+                                 span: Span,\n                                  mitem: @MetaItem,\n                                  in_items: ~[@item]) -> ~[@item] {\n     let trait_def = TraitDef {\n@@ -50,7 +50,7 @@ pub fn expand_deriving_decodable(cx: @ExtCtxt,\n     trait_def.expand(cx, span, mitem, in_items)\n }\n \n-fn decodable_substructure(cx: @ExtCtxt, span: span,\n+fn decodable_substructure(cx: @ExtCtxt, span: Span,\n                           substr: &Substructure) -> @expr {\n     let decoder = substr.nonself_args[0];\n     let recurse = ~[cx.ident_of(\"extra\"),"}, {"sha": "ee7863bc270dbbb9ddbc62356c277a890514d706", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -44,7 +44,7 @@ Other interesting scenarios are whe the item has type parameters or\n references other non-built-in types.  A type definition like:\n \n     #[deriving(Encodable, Decodable)]\n-    struct spanned<T> {node: T, span: span}\n+    struct spanned<T> {node: T, span: Span}\n \n would yield functions like:\n \n@@ -76,13 +76,13 @@ would yield functions like:\n */\n \n use ast::{MetaItem, item, expr, m_imm, m_mutbl};\n-use codemap::span;\n+use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_encodable(cx: @ExtCtxt,\n-                                 span: span,\n+                                 span: Span,\n                                  mitem: @MetaItem,\n                                  in_items: ~[@item]) -> ~[@item] {\n     let trait_def = TraitDef {\n@@ -110,7 +110,7 @@ pub fn expand_deriving_encodable(cx: @ExtCtxt,\n     trait_def.expand(cx, span, mitem, in_items)\n }\n \n-fn encodable_substructure(cx: @ExtCtxt, span: span,\n+fn encodable_substructure(cx: @ExtCtxt, span: Span,\n                           substr: &Substructure) -> @expr {\n     let encoder = substr.nonself_args[0];\n     // throw an underscore in front to suppress unused variable warnings"}, {"sha": "c8853e36cdd0c512da2e5220b196ee42c3121d31", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -167,7 +167,7 @@ use ast::{enum_def, expr, ident, Generics, struct_def};\n \n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n-use codemap::{span,respan};\n+use codemap::{Span,respan};\n use opt_vec;\n \n use std::vec;\n@@ -263,23 +263,23 @@ Combine the values of all the fields together. The last argument is\n all the fields of all the structures, see above for details.\n */\n pub type CombineSubstructureFunc<'self> =\n-    &'self fn(@ExtCtxt, span, &Substructure) -> @expr;\n+    &'self fn(@ExtCtxt, Span, &Substructure) -> @expr;\n \n /**\n Deal with non-matching enum variants, the arguments are a list\n representing each variant: (variant index, ast::variant instance,\n [variant fields]), and a list of the nonself args of the type\n */\n pub type EnumNonMatchFunc<'self> =\n-    &'self fn(@ExtCtxt, span,\n+    &'self fn(@ExtCtxt, Span,\n               &[(uint, ast::variant,\n                  ~[(Option<ident>, @expr)])],\n               &[@expr]) -> @expr;\n \n \n impl<'self> TraitDef<'self> {\n     pub fn expand(&self, cx: @ExtCtxt,\n-                  span: span,\n+                  span: Span,\n                   _mitem: @ast::MetaItem,\n                   in_items: ~[@ast::item]) -> ~[@ast::item] {\n         let mut result = ~[];\n@@ -314,7 +314,7 @@ impl<'self> TraitDef<'self> {\n      * where B1, B2, ... are the bounds given by `bounds_paths`.'\n      *\n      */\n-    fn create_derived_impl(&self, cx: @ExtCtxt, span: span,\n+    fn create_derived_impl(&self, cx: @ExtCtxt, span: Span,\n                            type_ident: ident, generics: &Generics,\n                            methods: ~[@ast::method]) -> @ast::item {\n         let trait_path = self.path.to_path(cx, span, type_ident, generics);\n@@ -373,7 +373,7 @@ impl<'self> TraitDef<'self> {\n     }\n \n     fn expand_struct_def(&self, cx: @ExtCtxt,\n-                         span: span,\n+                         span: Span,\n                          struct_def: &struct_def,\n                          type_ident: ident,\n                          generics: &Generics) -> @ast::item {\n@@ -404,7 +404,7 @@ impl<'self> TraitDef<'self> {\n     }\n \n     fn expand_enum_def(&self,\n-                       cx: @ExtCtxt, span: span,\n+                       cx: @ExtCtxt, span: Span,\n                        enum_def: &enum_def,\n                        type_ident: ident,\n                        generics: &Generics) -> @ast::item {\n@@ -438,7 +438,7 @@ impl<'self> TraitDef<'self> {\n impl<'self> MethodDef<'self> {\n     fn call_substructure_method(&self,\n                                 cx: @ExtCtxt,\n-                                span: span,\n+                                span: Span,\n                                 type_ident: ident,\n                                 self_args: &[@expr],\n                                 nonself_args: &[@expr],\n@@ -455,7 +455,7 @@ impl<'self> MethodDef<'self> {\n                                     &substructure)\n     }\n \n-    fn get_ret_ty(&self, cx: @ExtCtxt, span: span,\n+    fn get_ret_ty(&self, cx: @ExtCtxt, span: Span,\n                      generics: &Generics, type_ident: ident) -> ast::Ty {\n         self.ret_ty.to_ty(cx, span, type_ident, generics)\n     }\n@@ -464,7 +464,7 @@ impl<'self> MethodDef<'self> {\n         self.explicit_self.is_none()\n     }\n \n-    fn split_self_nonself_args(&self, cx: @ExtCtxt, span: span,\n+    fn split_self_nonself_args(&self, cx: @ExtCtxt, span: Span,\n                              type_ident: ident, generics: &Generics)\n         -> (ast::explicit_self, ~[@expr], ~[@expr], ~[(ident, ast::Ty)]) {\n \n@@ -510,7 +510,7 @@ impl<'self> MethodDef<'self> {\n         (ast_explicit_self, self_args, nonself_args, arg_tys)\n     }\n \n-    fn create_method(&self, cx: @ExtCtxt, span: span,\n+    fn create_method(&self, cx: @ExtCtxt, span: Span,\n                      type_ident: ident,\n                      generics: &Generics,\n                      explicit_self: ast::explicit_self,\n@@ -569,7 +569,7 @@ impl<'self> MethodDef<'self> {\n     */\n     fn expand_struct_method_body(&self,\n                                  cx: @ExtCtxt,\n-                                 span: span,\n+                                 span: Span,\n                                  struct_def: &struct_def,\n                                  type_ident: ident,\n                                  self_args: &[@expr],\n@@ -623,7 +623,7 @@ impl<'self> MethodDef<'self> {\n \n     fn expand_static_struct_method_body(&self,\n                                         cx: @ExtCtxt,\n-                                        span: span,\n+                                        span: Span,\n                                         struct_def: &struct_def,\n                                         type_ident: ident,\n                                         self_args: &[@expr],\n@@ -665,7 +665,7 @@ impl<'self> MethodDef<'self> {\n     */\n     fn expand_enum_method_body(&self,\n                                cx: @ExtCtxt,\n-                               span: span,\n+                               span: Span,\n                                enum_def: &enum_def,\n                                type_ident: ident,\n                                self_args: &[@expr],\n@@ -700,7 +700,7 @@ impl<'self> MethodDef<'self> {\n     the first call).\n     */\n     fn build_enum_match(&self,\n-                        cx: @ExtCtxt, span: span,\n+                        cx: @ExtCtxt, span: Span,\n                         enum_def: &enum_def,\n                         type_ident: ident,\n                         self_args: &[@expr],\n@@ -850,7 +850,7 @@ impl<'self> MethodDef<'self> {\n \n     fn expand_static_enum_method_body(&self,\n                                cx: @ExtCtxt,\n-                               span: span,\n+                               span: Span,\n                                enum_def: &enum_def,\n                                type_ident: ident,\n                                self_args: &[@expr],\n@@ -873,7 +873,7 @@ impl<'self> MethodDef<'self> {\n     }\n }\n \n-fn summarise_struct(cx: @ExtCtxt, span: span,\n+fn summarise_struct(cx: @ExtCtxt, span: Span,\n                     struct_def: &struct_def) -> Either<uint, ~[ident]> {\n     let mut named_idents = ~[];\n     let mut unnamed_count = 0;\n@@ -896,7 +896,7 @@ fn summarise_struct(cx: @ExtCtxt, span: span,\n }\n \n pub fn create_subpatterns(cx: @ExtCtxt,\n-                          span: span,\n+                          span: Span,\n                           field_paths: ~[ast::Path],\n                           mutbl: ast::mutability)\n                    -> ~[@ast::pat] {\n@@ -912,7 +912,7 @@ enum StructType {\n }\n \n fn create_struct_pattern(cx: @ExtCtxt,\n-                             span: span,\n+                             span: Span,\n                              struct_ident: ident,\n                              struct_def: &struct_def,\n                              prefix: &str,\n@@ -973,7 +973,7 @@ fn create_struct_pattern(cx: @ExtCtxt,\n }\n \n fn create_enum_variant_pattern(cx: @ExtCtxt,\n-                                   span: span,\n+                                   span: Span,\n                                    variant: &ast::variant,\n                                    prefix: &str,\n                                    mutbl: ast::mutability)\n@@ -1022,13 +1022,13 @@ Fold the fields. `use_foldl` controls whether this is done\n left-to-right (`true`) or right-to-left (`false`).\n */\n pub fn cs_fold(use_foldl: bool,\n-               f: &fn(@ExtCtxt, span,\n+               f: &fn(@ExtCtxt, Span,\n                       old: @expr,\n                       self_f: @expr,\n                       other_fs: &[@expr]) -> @expr,\n                base: @expr,\n                enum_nonmatch_f: EnumNonMatchFunc,\n-               cx: @ExtCtxt, span: span,\n+               cx: @ExtCtxt, span: Span,\n                substructure: &Substructure) -> @expr {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n@@ -1064,9 +1064,9 @@ f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n ~~~\n */\n #[inline]\n-pub fn cs_same_method(f: &fn(@ExtCtxt, span, ~[@expr]) -> @expr,\n+pub fn cs_same_method(f: &fn(@ExtCtxt, Span, ~[@expr]) -> @expr,\n                       enum_nonmatch_f: EnumNonMatchFunc,\n-                      cx: @ExtCtxt, span: span,\n+                      cx: @ExtCtxt, span: Span,\n                       substructure: &Substructure) -> @expr {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n@@ -1097,10 +1097,10 @@ fields. `use_foldl` controls whether this is done left-to-right\n */\n #[inline]\n pub fn cs_same_method_fold(use_foldl: bool,\n-                           f: &fn(@ExtCtxt, span, @expr, @expr) -> @expr,\n+                           f: &fn(@ExtCtxt, Span, @expr, @expr) -> @expr,\n                            base: @expr,\n                            enum_nonmatch_f: EnumNonMatchFunc,\n-                           cx: @ExtCtxt, span: span,\n+                           cx: @ExtCtxt, span: Span,\n                            substructure: &Substructure) -> @expr {\n     cs_same_method(\n         |cx, span, vals| {\n@@ -1126,7 +1126,7 @@ on all the fields.\n #[inline]\n pub fn cs_binop(binop: ast::binop, base: @expr,\n                 enum_nonmatch_f: EnumNonMatchFunc,\n-                cx: @ExtCtxt, span: span,\n+                cx: @ExtCtxt, span: Span,\n                 substructure: &Substructure) -> @expr {\n     cs_same_method_fold(\n         true, // foldl is good enough\n@@ -1144,7 +1144,7 @@ pub fn cs_binop(binop: ast::binop, base: @expr,\n /// cs_binop with binop == or\n #[inline]\n pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n-             cx: @ExtCtxt, span: span,\n+             cx: @ExtCtxt, span: Span,\n              substructure: &Substructure) -> @expr {\n     cs_binop(ast::or, cx.expr_bool(span, false),\n              enum_nonmatch_f,\n@@ -1153,7 +1153,7 @@ pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n /// cs_binop with binop == and\n #[inline]\n pub fn cs_and(enum_nonmatch_f: EnumNonMatchFunc,\n-              cx: @ExtCtxt, span: span,\n+              cx: @ExtCtxt, span: Span,\n               substructure: &Substructure) -> @expr {\n     cs_binop(ast::and, cx.expr_bool(span, true),\n              enum_nonmatch_f,"}, {"sha": "4dd628ca7b0b89b8dd6e275f58e066ab76592b61", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -9,14 +9,14 @@\n // except according to those terms.\n \n use ast::{MetaItem, item, expr, and};\n-use codemap::span;\n+use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n \n pub fn expand_deriving_iter_bytes(cx: @ExtCtxt,\n-                                  span: span,\n+                                  span: Span,\n                                   mitem: @MetaItem,\n                                   in_items: ~[@item]) -> ~[@item] {\n     let trait_def = TraitDef {\n@@ -42,7 +42,7 @@ pub fn expand_deriving_iter_bytes(cx: @ExtCtxt,\n     trait_def.expand(cx, span, mitem, in_items)\n }\n \n-fn iter_bytes_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n+fn iter_bytes_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @expr {\n     let (lsb0, f)= match substr.nonself_args {\n         [l, f] => (l, f),\n         _ => cx.span_bug(span, \"Incorrect number of arguments in `deriving(IterBytes)`\")"}, {"sha": "0123044478c2ac3fe33da614631656536ec1d2f1", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -22,7 +22,7 @@ use ast::{enum_def, ident, item, Generics, struct_def};\n use ast::{MetaItem, MetaList, MetaNameValue, MetaWord};\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n-use codemap::span;\n+use codemap::Span;\n \n pub mod clone;\n pub mod iter_bytes;\n@@ -45,20 +45,20 @@ pub mod totalord;\n pub mod generic;\n \n pub type ExpandDerivingStructDefFn<'self> = &'self fn(@ExtCtxt,\n-                                                       span,\n+                                                       Span,\n                                                        x: &struct_def,\n                                                        ident,\n                                                        y: &Generics)\n                                                  -> @item;\n pub type ExpandDerivingEnumDefFn<'self> = &'self fn(@ExtCtxt,\n-                                                    span,\n+                                                    Span,\n                                                     x: &enum_def,\n                                                     ident,\n                                                     y: &Generics)\n                                                  -> @item;\n \n pub fn expand_meta_deriving(cx: @ExtCtxt,\n-                            _span: span,\n+                            _span: Span,\n                             mitem: @MetaItem,\n                             in_items: ~[@item])\n                          -> ~[@item] {"}, {"sha": "485df6084a8900eb6dc4032fa1a1935ce8930c53", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -10,15 +10,15 @@\n \n use ast;\n use ast::{MetaItem, item, expr, ident};\n-use codemap::span;\n+use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::{AstBuilder, Duplicate};\n use ext::deriving::generic::*;\n \n use std::vec;\n \n pub fn expand_deriving_rand(cx: @ExtCtxt,\n-                            span: span,\n+                            span: Span,\n                             mitem: @MetaItem,\n                             in_items: ~[@item])\n     -> ~[@item] {\n@@ -48,7 +48,7 @@ pub fn expand_deriving_rand(cx: @ExtCtxt,\n     trait_def.expand(cx, span, mitem, in_items)\n }\n \n-fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n+fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @expr {\n     let rng = match substr.nonself_args {\n         [rng] => ~[ rng ],\n         _ => cx.bug(\"Incorrect number of arguments to `rand` in `deriving(Rand)`\")\n@@ -128,7 +128,7 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n         _ => cx.bug(\"Non-static method in `deriving(Rand)`\")\n     };\n \n-    fn rand_thing(cx: @ExtCtxt, span: span,\n+    fn rand_thing(cx: @ExtCtxt, span: Span,\n                   ctor_ident: ident,\n                   summary: &Either<uint, ~[ident]>,\n                   rand_call: &fn() -> @expr) -> @expr {"}, {"sha": "1b136983de8d7e7fbee22eefca408a618d51e3a5", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -10,13 +10,13 @@\n \n use ast;\n use ast::{MetaItem, item, expr};\n-use codemap::span;\n+use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n pub fn expand_deriving_to_str(cx: @ExtCtxt,\n-                              span: span,\n+                              span: Span,\n                               mitem: @MetaItem,\n                               in_items: ~[@item])\n     -> ~[@item] {\n@@ -43,7 +43,7 @@ pub fn expand_deriving_to_str(cx: @ExtCtxt,\n // std::sys::log_str, but this isn't sufficient because it doesn't invoke the\n // to_str() method on each field. Hence we mirror the logic of the log_str()\n // method, but with tweaks to call to_str() on sub-fields.\n-fn to_str_substructure(cx: @ExtCtxt, span: span,\n+fn to_str_substructure(cx: @ExtCtxt, span: Span,\n                        substr: &Substructure) -> @expr {\n     let to_str = cx.ident_of(\"to_str\");\n "}, {"sha": "f0b22d9b28876f715ff25333687e6914c2a985e2", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -17,7 +17,7 @@ use ast;\n use ast::{expr,Generics,ident};\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n-use codemap::{span,respan};\n+use codemap::{Span,respan};\n use opt_vec;\n \n /// The types of pointers\n@@ -58,15 +58,15 @@ impl<'self> Path<'self> {\n \n     pub fn to_ty(&self,\n                  cx: @ExtCtxt,\n-                 span: span,\n+                 span: Span,\n                  self_ty: ident,\n                  self_generics: &Generics)\n                  -> ast::Ty {\n         cx.ty_path(self.to_path(cx, span, self_ty, self_generics), None)\n     }\n     pub fn to_path(&self,\n                    cx: @ExtCtxt,\n-                   span: span,\n+                   span: Span,\n                    self_ty: ident,\n                    self_generics: &Generics)\n                    -> ast::Path {\n@@ -109,7 +109,7 @@ pub fn nil_ty() -> Ty<'static> {\n     Tuple(~[])\n }\n \n-fn mk_lifetime(cx: @ExtCtxt, span: span, lt: &Option<&str>) -> Option<ast::Lifetime> {\n+fn mk_lifetime(cx: @ExtCtxt, span: Span, lt: &Option<&str>) -> Option<ast::Lifetime> {\n     match *lt {\n         Some(ref s) => Some(cx.lifetime(span, cx.ident_of(*s))),\n         None => None\n@@ -119,7 +119,7 @@ fn mk_lifetime(cx: @ExtCtxt, span: span, lt: &Option<&str>) -> Option<ast::Lifet\n impl<'self> Ty<'self> {\n     pub fn to_ty(&self,\n                  cx: @ExtCtxt,\n-                 span: span,\n+                 span: Span,\n                  self_ty: ident,\n                  self_generics: &Generics)\n                  -> ast::Ty {\n@@ -157,7 +157,7 @@ impl<'self> Ty<'self> {\n \n     pub fn to_path(&self,\n                    cx: @ExtCtxt,\n-                   span: span,\n+                   span: Span,\n                    self_ty: ident,\n                    self_generics: &Generics)\n                    -> ast::Path {\n@@ -185,7 +185,7 @@ impl<'self> Ty<'self> {\n }\n \n \n-fn mk_ty_param(cx: @ExtCtxt, span: span, name: &str, bounds: &[Path],\n+fn mk_ty_param(cx: @ExtCtxt, span: Span, name: &str, bounds: &[Path],\n                self_ident: ident, self_generics: &Generics) -> ast::TyParam {\n     let bounds = opt_vec::from(\n         do bounds.map |b| {\n@@ -216,7 +216,7 @@ impl<'self> LifetimeBounds<'self> {\n     }\n     pub fn to_generics(&self,\n                        cx: @ExtCtxt,\n-                       span: span,\n+                       span: Span,\n                        self_ty: ident,\n                        self_generics: &Generics)\n                        -> Generics {\n@@ -235,7 +235,7 @@ impl<'self> LifetimeBounds<'self> {\n }\n \n \n-pub fn get_explicit_self(cx: @ExtCtxt, span: span, self_ptr: &Option<PtrTy>)\n+pub fn get_explicit_self(cx: @ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n     -> (@expr, ast::explicit_self) {\n     let self_path = cx.expr_self(span);\n     match *self_ptr {"}, {"sha": "f9cd1b4b35bdc996ad7c6117141b726b4cc36566", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n use ast::{MetaItem, item, expr};\n-use codemap::span;\n+use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n use std::vec;\n \n pub fn expand_deriving_zero(cx: @ExtCtxt,\n-                            span: span,\n+                            span: Span,\n                             mitem: @MetaItem,\n                             in_items: ~[@item])\n     -> ~[@item] {\n@@ -55,7 +55,7 @@ pub fn expand_deriving_zero(cx: @ExtCtxt,\n     trait_def.expand(cx, span, mitem, in_items)\n }\n \n-fn zero_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n+fn zero_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @expr {\n     let zero_ident = ~[\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"num\"),"}, {"sha": "ac8a7d513dd5d5e19c7d9af7d3f88e7a629666f2", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -15,15 +15,15 @@\n  */\n \n use ast;\n-use codemap::span;\n+use codemap::Span;\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n \n use std::os;\n \n #[cfg(stage0)]\n-pub fn expand_option_env(ext_cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_option_env(ext_cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let var = get_single_str_from_tts(ext_cx, sp, tts, \"option_env!\");\n \n@@ -34,7 +34,7 @@ pub fn expand_option_env(ext_cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     MRExpr(e)\n }\n #[cfg(not(stage0))]\n-pub fn expand_option_env(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_option_env(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let var = get_single_str_from_tts(cx, sp, tts, \"option_env!\");\n \n@@ -45,7 +45,7 @@ pub fn expand_option_env(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     MRExpr(e)\n }\n \n-pub fn expand_env(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_env(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let exprs = get_exprs_from_tts(cx, sp, tts);\n "}, {"sha": "eb1eaffe757284d571d5d2ec1b9acdd31a6df74d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -16,7 +16,7 @@ use ast_util::{new_rename, new_mark, resolve};\n use attr;\n use attr::AttrMetaMethods;\n use codemap;\n-use codemap::{span, spanned, ExpnInfo, NameAndSpan};\n+use codemap::{Span, Spanned, spanned, ExpnInfo, NameAndSpan};\n use ext::base::*;\n use fold::*;\n use opt_vec;\n@@ -32,10 +32,10 @@ use std::vec;\n pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                    cx: @ExtCtxt,\n                    e: &expr_,\n-                   s: span,\n+                   s: Span,\n                    fld: @ast_fold,\n-                   orig: @fn(&expr_, span, @ast_fold) -> (expr_, span))\n-                -> (expr_, span) {\n+                   orig: @fn(&expr_, Span, @ast_fold) -> (expr_, Span))\n+                -> (expr_, Span) {\n     match *e {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n@@ -117,7 +117,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n             let lo = s.lo;\n             let hi = s.hi;\n \n-            pub fn mk_expr(cx: @ExtCtxt, span: span,\n+            pub fn mk_expr(cx: @ExtCtxt, span: Span,\n                            node: expr_) -> @ast::expr {\n                 @ast::expr {\n                     id: cx.next_id(),\n@@ -129,7 +129,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n             fn mk_block(cx: @ExtCtxt,\n                         stmts: &[@ast::stmt],\n                         expr: Option<@ast::expr>,\n-                        span: span) -> ast::Block {\n+                        span: Span) -> ast::Block {\n                 ast::Block {\n                     view_items: ~[],\n                     stmts: stmts.to_owned(),\n@@ -140,7 +140,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                 }\n             }\n \n-            fn mk_simple_path(ident: ast::ident, span: span) -> ast::Path {\n+            fn mk_simple_path(ident: ast::ident, span: Span) -> ast::Path {\n                 ast::Path {\n                     span: span,\n                     global: false,\n@@ -367,7 +367,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                        fld: @ast_fold)\n                     -> Option<@ast::item> {\n     let (pth, tts) = match it.node {\n-        item_mac(codemap::spanned { node: mac_invoc_tt(ref pth, ref tts), _}) => {\n+        item_mac(codemap::Spanned { node: mac_invoc_tt(ref pth, ref tts), _}) => {\n             (pth, (*tts).clone())\n         }\n         _ => cx.span_bug(it.span, \"invalid item macro invocation\")\n@@ -449,11 +449,11 @@ fn insert_macro(exts: SyntaxEnv, name: ast::Name, transformer: @Transformer) {\n pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                    cx: @ExtCtxt,\n                    s: &stmt_,\n-                   sp: span,\n+                   sp: Span,\n                    fld: @ast_fold,\n-                   orig: @fn(&stmt_, span, @ast_fold)\n-                             -> (Option<stmt_>, span))\n-                -> (Option<stmt_>, span) {\n+                   orig: @fn(&stmt_, Span, @ast_fold)\n+                             -> (Option<stmt_>, Span))\n+                -> (Option<stmt_>, Span) {\n     let (mac, pth, tts, semi) = match *s {\n         stmt_mac(ref mac, semi) => {\n             match mac.node {\n@@ -484,7 +484,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n             });\n             let expanded = match exp(cx, mac.span, tts) {\n                 MRExpr(e) =>\n-                    @codemap::spanned { node: stmt_expr(e, cx.next_id()),\n+                    @codemap::Spanned { node: stmt_expr(e, cx.next_id()),\n                                     span: e.span},\n                 MRAny(_,_,stmt_mkr) => stmt_mkr(),\n                 _ => cx.span_fatal(\n@@ -563,7 +563,7 @@ impl Visitor<()> for NewNameFinderContext {\n \n     // XXX: Methods below can become default methods.\n \n-    fn visit_mod(&mut self, module: &ast::_mod, _: span, _: NodeId, _: ()) {\n+    fn visit_mod(&mut self, module: &ast::_mod, _: Span, _: NodeId, _: ()) {\n         visit::walk_mod(self, module, ())\n     }\n \n@@ -621,7 +621,7 @@ impl Visitor<()> for NewNameFinderContext {\n                 function_kind: &visit::fn_kind,\n                 function_declaration: &ast::fn_decl,\n                 block: &ast::Block,\n-                span: span,\n+                span: Span,\n                 node_id: NodeId,\n                 _: ()) {\n         visit::walk_fn(self,\n@@ -723,9 +723,9 @@ fn apply_pending_renames(folder : @ast_fold, stmt : ast::stmt) -> @ast::stmt {\n \n \n \n-pub fn new_span(cx: @ExtCtxt, sp: span) -> span {\n+pub fn new_span(cx: @ExtCtxt, sp: Span) -> Span {\n     /* this discards information in the case of macro-defining macros */\n-    return span {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n+    return Span {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n }\n \n // FIXME (#2247): this is a moderately bad kludge to inject some macros into\n@@ -1193,7 +1193,7 @@ mod test {\n     use ast;\n     use ast::{Attribute_, AttrOuter, MetaWord, empty_ctxt};\n     use codemap;\n-    use codemap::spanned;\n+    use codemap::Spanned;\n     use parse;\n     use parse::token::{intern, get_ident_interner};\n     use print::pprust;\n@@ -1282,11 +1282,11 @@ mod test {\n \n     // make a MetaWord outer attribute with the given name\n     fn make_dummy_attr(s: @str) -> ast::Attribute {\n-        spanned {\n+        Spanned {\n             span:codemap::dummy_sp(),\n             node: Attribute_ {\n                 style: AttrOuter,\n-                value: @spanned {\n+                value: @Spanned {\n                     node: MetaWord(s),\n                     span: codemap::dummy_sp(),\n                 },"}, {"sha": "4bfb4da7a49dac42991ae4608051e1d3244d53f4", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -15,7 +15,7 @@\n  */\n \n use ast;\n-use codemap::span;\n+use codemap::Span;\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n@@ -24,7 +24,7 @@ use std::option;\n use std::unstable::extfmt::ct::*;\n use parse::token::{str_to_ident};\n \n-pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let args = get_exprs_from_tts(cx, sp, tts);\n     if args.len() == 0 {\n@@ -35,7 +35,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n                     \"first argument to fmt! must be a string literal.\");\n     let fmtspan = args[0].span;\n     debug!(\"Format string: %s\", fmt);\n-    fn parse_fmt_err_(cx: @ExtCtxt, sp: span, msg: &str) -> ! {\n+    fn parse_fmt_err_(cx: @ExtCtxt, sp: Span, msg: &str) -> ! {\n         cx.span_fatal(sp, msg);\n     }\n     let parse_fmt_err: @fn(&str) -> ! = |s| parse_fmt_err_(cx, fmtspan, s);\n@@ -47,7 +47,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n // probably be factored out in common with other code that builds\n // expressions.  Also: Cleanup the naming of these functions.\n // Note: Moved many of the common ones to build.rs --kevina\n-fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n+fn pieces_to_expr(cx: @ExtCtxt, sp: Span,\n                   pieces: ~[Piece], args: ~[@ast::expr])\n    -> @ast::expr {\n     fn make_path_vec(ident: &str) -> ~[ast::ident] {\n@@ -57,15 +57,15 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                  str_to_ident(\"rt\"),\n                  str_to_ident(ident)];\n     }\n-    fn make_rt_path_expr(cx: @ExtCtxt, sp: span, nm: &str) -> @ast::expr {\n+    fn make_rt_path_expr(cx: @ExtCtxt, sp: Span, nm: &str) -> @ast::expr {\n         let path = make_path_vec(nm);\n         cx.expr_path(cx.path_global(sp, path))\n     }\n     // Produces an AST expression that represents a RT::conv record,\n     // which tells the RT::conv* functions how to perform the conversion\n \n-    fn make_rt_conv_expr(cx: @ExtCtxt, sp: span, cnv: &Conv) -> @ast::expr {\n-        fn make_flags(cx: @ExtCtxt, sp: span, flags: &[Flag]) -> @ast::expr {\n+    fn make_rt_conv_expr(cx: @ExtCtxt, sp: Span, cnv: &Conv) -> @ast::expr {\n+        fn make_flags(cx: @ExtCtxt, sp: Span, flags: &[Flag]) -> @ast::expr {\n             let mut tmp_expr = make_rt_path_expr(cx, sp, \"flag_none\");\n             for f in flags.iter() {\n                 let fstr = match *f {\n@@ -80,7 +80,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n             }\n             return tmp_expr;\n         }\n-        fn make_count(cx: @ExtCtxt, sp: span, cnt: Count) -> @ast::expr {\n+        fn make_count(cx: @ExtCtxt, sp: Span, cnt: Count) -> @ast::expr {\n             match cnt {\n               CountImplied => {\n                 return make_rt_path_expr(cx, sp, \"CountImplied\");\n@@ -94,7 +94,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n               _ => cx.span_unimpl(sp, \"unimplemented fmt! conversion\")\n             }\n         }\n-        fn make_ty(cx: @ExtCtxt, sp: span, t: Ty) -> @ast::expr {\n+        fn make_ty(cx: @ExtCtxt, sp: Span, t: Ty) -> @ast::expr {\n             let rt_type = match t {\n               TyHex(c) => match c {\n                 CaseUpper =>  \"TyHexUpper\",\n@@ -106,7 +106,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n             };\n             return make_rt_path_expr(cx, sp, rt_type);\n         }\n-        fn make_conv_struct(cx: @ExtCtxt, sp: span, flags_expr: @ast::expr,\n+        fn make_conv_struct(cx: @ExtCtxt, sp: Span, flags_expr: @ast::expr,\n                          width_expr: @ast::expr, precision_expr: @ast::expr,\n                          ty_expr: @ast::expr) -> @ast::expr {\n             cx.expr_struct(\n@@ -127,7 +127,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n         make_conv_struct(cx, sp, rt_conv_flags, rt_conv_width,\n                          rt_conv_precision, rt_conv_ty)\n     }\n-    fn make_conv_call(cx: @ExtCtxt, sp: span, conv_type: &str, cnv: &Conv,\n+    fn make_conv_call(cx: @ExtCtxt, sp: Span, conv_type: &str, cnv: &Conv,\n                       arg: @ast::expr, buf: @ast::expr) -> @ast::expr {\n         let fname = ~\"conv_\" + conv_type;\n         let path = make_path_vec(fname);\n@@ -136,7 +136,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n         cx.expr_call_global(arg.span, path, args)\n     }\n \n-    fn make_new_conv(cx: @ExtCtxt, sp: span, cnv: &Conv,\n+    fn make_new_conv(cx: @ExtCtxt, sp: Span, cnv: &Conv,\n                      arg: @ast::expr, buf: @ast::expr) -> @ast::expr {\n         fn is_signed_type(cnv: &Conv) -> bool {\n             match cnv.ty {"}, {"sha": "eab5f6577755193b52d1ff51486ea0e50ec245c5", "filename": "src/libsyntax/ext/ifmt.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fifmt.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use codemap::{span, respan};\n+use codemap::{Span, respan};\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n@@ -30,7 +30,7 @@ enum ArgumentType {\n \n struct Context {\n     ecx: @ExtCtxt,\n-    fmtsp: span,\n+    fmtsp: Span,\n \n     // Parsed argument expressions and the types that we've found so far for\n     // them.\n@@ -53,7 +53,7 @@ struct Context {\n impl Context {\n     /// Parses the arguments from the given list of tokens, returning None if\n     /// there's a parse error so we can continue parsing other fmt! expressions.\n-    fn parse_args(&mut self, sp: span,\n+    fn parse_args(&mut self, sp: Span,\n                   leading_expr: bool,\n                   tts: &[ast::token_tree]) -> (Option<@ast::expr>,\n                                                Option<@ast::expr>) {\n@@ -294,7 +294,7 @@ impl Context {\n     ///\n     /// Obviously `Some(Some(x)) != Some(Some(y))`, but we consider it true\n     /// that: `Some(None) == Some(Some(x))`\n-    fn verify_same(&self, sp: span, ty: ArgumentType,\n+    fn verify_same(&self, sp: Span, ty: ArgumentType,\n                    before: Option<ArgumentType>) {\n         if ty == Unknown { return }\n         let cur = match before {\n@@ -636,7 +636,7 @@ impl Context {\n         self.ecx.expr_block(self.ecx.block(self.fmtsp, lets, Some(result)))\n     }\n \n-    fn format_arg(&self, sp: span, arg: Either<uint, @str>,\n+    fn format_arg(&self, sp: Span, arg: Either<uint, @str>,\n                   ident: ast::ident) -> @ast::expr {\n         let ty = match arg {\n             Left(i) => self.arg_types[i].unwrap(),\n@@ -697,22 +697,22 @@ impl Context {\n     }\n }\n \n-pub fn expand_format(ecx: @ExtCtxt, sp: span,\n+pub fn expand_format(ecx: @ExtCtxt, sp: Span,\n                      tts: &[ast::token_tree]) -> base::MacResult {\n     expand_ifmt(ecx, sp, tts, false, false, \"format\")\n }\n \n-pub fn expand_write(ecx: @ExtCtxt, sp: span,\n+pub fn expand_write(ecx: @ExtCtxt, sp: Span,\n                     tts: &[ast::token_tree]) -> base::MacResult {\n     expand_ifmt(ecx, sp, tts, true, false, \"write\")\n }\n \n-pub fn expand_writeln(ecx: @ExtCtxt, sp: span,\n+pub fn expand_writeln(ecx: @ExtCtxt, sp: Span,\n                       tts: &[ast::token_tree]) -> base::MacResult {\n     expand_ifmt(ecx, sp, tts, true, true, \"write\")\n }\n \n-fn expand_ifmt(ecx: @ExtCtxt, sp: span, tts: &[ast::token_tree],\n+fn expand_ifmt(ecx: @ExtCtxt, sp: Span, tts: &[ast::token_tree],\n                leading_arg: bool, append_newline: bool,\n                function: &str) -> base::MacResult {\n     let mut cx = Context {"}, {"sha": "206cc7be1fdee24e01ef7e29e9d7084ee25c7be0", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -18,7 +18,7 @@ use parse::token::{get_ident_interner};\n use std::io;\n \n pub fn expand_syntax_ext(cx: @ExtCtxt,\n-                         sp: codemap::span,\n+                         sp: codemap::Span,\n                          tt: &[ast::token_tree])\n                       -> base::MacResult {\n \n@@ -31,7 +31,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt,\n     //trivial expression\n     MRExpr(@ast::expr {\n         id: cx.next_id(),\n-        node: ast::expr_lit(@codemap::spanned {\n+        node: ast::expr_lit(@codemap::Spanned {\n             node: ast::lit_nil,\n             span: sp\n         }),"}, {"sha": "05e639632ede0031054f92f9ad21224ad6076218", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use codemap::{BytePos, Pos, span};\n+use codemap::{BytePos, Pos, Span};\n use ext::base::ExtCtxt;\n use ext::base;\n use ext::build::AstBuilder;\n@@ -37,7 +37,7 @@ pub mod rt {\n     pub use ast::*;\n     pub use parse::token::*;\n     pub use parse::new_parser_from_tts;\n-    pub use codemap::{BytePos, span, dummy_spanned};\n+    pub use codemap::{BytePos, Span, dummy_spanned};\n \n     pub trait ToTokens {\n         fn to_tokens(&self, _cx: @ExtCtxt) -> ~[token_tree];\n@@ -290,44 +290,44 @@ pub mod rt {\n }\n \n pub fn expand_quote_tokens(cx: @ExtCtxt,\n-                           sp: span,\n+                           sp: Span,\n                            tts: &[ast::token_tree]) -> base::MacResult {\n     let (cx_expr, expr) = expand_tts(cx, sp, tts);\n     base::MRExpr(expand_wrapper(cx, sp, cx_expr, expr))\n }\n \n pub fn expand_quote_expr(cx: @ExtCtxt,\n-                         sp: span,\n+                         sp: Span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_expr\", ~[], tts))\n }\n \n pub fn expand_quote_item(cx: @ExtCtxt,\n-                         sp: span,\n+                         sp: Span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n     let e_attrs = cx.expr_vec_uniq(sp, ~[]);\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_item\",\n                                     ~[e_attrs], tts))\n }\n \n pub fn expand_quote_pat(cx: @ExtCtxt,\n-                        sp: span,\n+                        sp: Span,\n                         tts: &[ast::token_tree]) -> base::MacResult {\n     let e_refutable = cx.expr_lit(sp, ast::lit_bool(true));\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_pat\",\n                                     ~[e_refutable], tts))\n }\n \n pub fn expand_quote_ty(cx: @ExtCtxt,\n-                       sp: span,\n+                       sp: Span,\n                        tts: &[ast::token_tree]) -> base::MacResult {\n     let e_param_colons = cx.expr_lit(sp, ast::lit_bool(false));\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_ty\",\n                                     ~[e_param_colons], tts))\n }\n \n pub fn expand_quote_stmt(cx: @ExtCtxt,\n-                         sp: span,\n+                         sp: Span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n     let e_attrs = cx.expr_vec_uniq(sp, ~[]);\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_stmt\",\n@@ -343,21 +343,21 @@ fn id_ext(str: &str) -> ast::ident {\n }\n \n // Lift an ident to the expr that evaluates to that ident.\n-fn mk_ident(cx: @ExtCtxt, sp: span, ident: ast::ident) -> @ast::expr {\n+fn mk_ident(cx: @ExtCtxt, sp: Span, ident: ast::ident) -> @ast::expr {\n     let e_str = cx.expr_str(sp, cx.str_of(ident));\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"ident_of\"),\n                         ~[e_str])\n }\n \n-fn mk_bytepos(cx: @ExtCtxt, sp: span, bpos: BytePos) -> @ast::expr {\n+fn mk_bytepos(cx: @ExtCtxt, sp: Span, bpos: BytePos) -> @ast::expr {\n     let path = id_ext(\"BytePos\");\n     let arg = cx.expr_uint(sp, bpos.to_uint());\n     cx.expr_call_ident(sp, path, ~[arg])\n }\n \n-fn mk_binop(cx: @ExtCtxt, sp: span, bop: token::binop) -> @ast::expr {\n+fn mk_binop(cx: @ExtCtxt, sp: Span, bop: token::binop) -> @ast::expr {\n     let name = match bop {\n         PLUS => \"PLUS\",\n         MINUS => \"MINUS\",\n@@ -373,7 +373,7 @@ fn mk_binop(cx: @ExtCtxt, sp: span, bop: token::binop) -> @ast::expr {\n     cx.expr_ident(sp, id_ext(name))\n }\n \n-fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n+fn mk_token(cx: @ExtCtxt, sp: Span, tok: &token::Token) -> @ast::expr {\n \n     match *tok {\n         BINOP(binop) => {\n@@ -514,7 +514,7 @@ fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n }\n \n \n-fn mk_tt(cx: @ExtCtxt, sp: span, tt: &ast::token_tree)\n+fn mk_tt(cx: @ExtCtxt, sp: Span, tt: &ast::token_tree)\n     -> ~[@ast::stmt] {\n \n     match *tt {\n@@ -556,7 +556,7 @@ fn mk_tt(cx: @ExtCtxt, sp: span, tt: &ast::token_tree)\n     }\n }\n \n-fn mk_tts(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n+fn mk_tts(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> ~[@ast::stmt] {\n     let mut ss = ~[];\n     for tt in tts.iter() {\n@@ -566,7 +566,7 @@ fn mk_tts(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n }\n \n fn expand_tts(cx: @ExtCtxt,\n-              sp: span,\n+              sp: Span,\n               tts: &[ast::token_tree]) -> (@ast::expr, @ast::expr) {\n \n     // NB: It appears that the main parser loses its mind if we consider\n@@ -639,7 +639,7 @@ fn expand_tts(cx: @ExtCtxt,\n }\n \n fn expand_wrapper(cx: @ExtCtxt,\n-                  sp: span,\n+                  sp: Span,\n                   cx_expr: @ast::expr,\n                   expr: @ast::expr) -> @ast::expr {\n     let uses = ~[ cx.view_use_glob(sp, ast::public,\n@@ -654,7 +654,7 @@ fn expand_wrapper(cx: @ExtCtxt,\n }\n \n fn expand_parse_call(cx: @ExtCtxt,\n-                     sp: span,\n+                     sp: Span,\n                      parse_method: &str,\n                      arg_exprs: ~[@ast::expr],\n                      tts: &[ast::token_tree]) -> @ast::expr {"}, {"sha": "96c8482c41814095399b74016024d29a6429d996", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -10,7 +10,7 @@\n \n use ast;\n use codemap;\n-use codemap::{Pos, span};\n+use codemap::{Pos, Span};\n use codemap::{ExpnInfo, NameAndSpan};\n use ext::base::*;\n use ext::base;\n@@ -27,7 +27,7 @@ use std::result;\n // a given file into the current one.\n \n /* line!(): expands to the current line number */\n-pub fn expand_line(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_line(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n@@ -38,7 +38,7 @@ pub fn expand_line(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n }\n \n /* col!(): expands to the current column number */\n-pub fn expand_col(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_col(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"col!\");\n \n@@ -50,7 +50,7 @@ pub fn expand_col(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n /* file!(): expands to the current filename */\n /* The filemap (`loc.file`) contains a bunch more information we could spit\n  * out if we wanted. */\n-pub fn expand_file(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_file(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n@@ -60,13 +60,13 @@ pub fn expand_file(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     base::MRExpr(cx.expr_str(topmost.call_site, filename))\n }\n \n-pub fn expand_stringify(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_stringify(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let s = pprust::tts_to_str(tts, get_ident_interner());\n     base::MRExpr(cx.expr_str(sp, s.to_managed()))\n }\n \n-pub fn expand_mod(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_mod(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     base::MRExpr(cx.expr_str(sp,\n@@ -76,7 +76,7 @@ pub fn expand_mod(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n // include! : parse the given file as an expr\n // This is generally a bad idea because it's going to behave\n // unhygienically.\n-pub fn expand_include(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_include(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include!\");\n     let p = parse::new_sub_parser_from_file(\n@@ -86,7 +86,7 @@ pub fn expand_include(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n }\n \n // include_str! : read the given file, insert it as a literal string expr\n-pub fn expand_include_str(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_include_str(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n     let res = io::read_whole_file_str(&res_rel_file(cx, sp, &Path(file)));\n@@ -100,7 +100,7 @@ pub fn expand_include_str(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     }\n }\n \n-pub fn expand_include_bin(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_include_bin(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n     match io::read_whole_file(&res_rel_file(cx, sp, &Path(file))) {\n@@ -142,7 +142,7 @@ fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n \n // resolve a file-system path to an absolute file-system path (if it\n // isn't already)\n-fn res_rel_file(cx: @ExtCtxt, sp: codemap::span, arg: &Path) -> Path {\n+fn res_rel_file(cx: @ExtCtxt, sp: codemap::Span, arg: &Path) -> Path {\n     // NB: relative paths are resolved relative to the compilation unit\n     if !arg.is_absolute {\n         let cu = Path(cx.codemap().span_to_filename(sp));"}, {"sha": "1862d4a88fd4a09e80703274582818d1790fab1c", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n use ast;\n-use codemap::span;\n+use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::base;\n use parse::lexer::{new_tt_reader, reader};\n use parse::parser::Parser;\n use parse::token::keywords;\n \n pub fn expand_trace_macros(cx: @ExtCtxt,\n-                           sp: span,\n+                           sp: Span,\n                            tt: &[ast::token_tree])\n                         -> base::MacResult {\n     let sess = cx.parse_sess();"}, {"sha": "bc4b1010943a1e78613102df32de237e52141b80", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -182,7 +182,7 @@ pub fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n // ast::matcher it was derived from.\n \n pub enum named_match {\n-    matched_seq(~[@named_match], codemap::span),\n+    matched_seq(~[@named_match], codemap::Span),\n     matched_nonterminal(nonterminal)\n }\n \n@@ -193,13 +193,13 @@ pub fn nameize(p_s: @mut ParseSess, ms: &[matcher], res: &[@named_match])\n     fn n_rec(p_s: @mut ParseSess, m: &matcher, res: &[@named_match],\n              ret_val: &mut HashMap<ident, @named_match>) {\n         match *m {\n-          codemap::spanned {node: match_tok(_), _} => (),\n-          codemap::spanned {node: match_seq(ref more_ms, _, _, _, _), _} => {\n+          codemap::Spanned {node: match_tok(_), _} => (),\n+          codemap::Spanned {node: match_seq(ref more_ms, _, _, _, _), _} => {\n             for next_m in more_ms.iter() {\n                 n_rec(p_s, next_m, res, ret_val)\n             };\n           }\n-          codemap::spanned {\n+          codemap::Spanned {\n                 node: match_nonterminal(ref bind_name, _, idx), span: sp\n           } => {\n             if ret_val.contains_key(bind_name) {\n@@ -217,8 +217,8 @@ pub fn nameize(p_s: @mut ParseSess, ms: &[matcher], res: &[@named_match])\n \n pub enum parse_result {\n     success(HashMap<ident, @named_match>),\n-    failure(codemap::span, ~str),\n-    error(codemap::span, ~str)\n+    failure(codemap::Span, ~str),\n+    error(codemap::Span, ~str)\n }\n \n pub fn parse_or_else("}, {"sha": "f336098468b5b6921fa00850b826b17831188ce7", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -11,7 +11,7 @@\n use ast::{ident, matcher_, matcher, match_tok, match_nonterminal, match_seq};\n use ast::{tt_delim};\n use ast;\n-use codemap::{span, spanned, dummy_sp};\n+use codemap::{Span, Spanned, dummy_sp};\n use ext::base::{ExtCtxt, MacResult, MRAny, MRDef, MacroDef, NormalTT};\n use ext::base;\n use ext::tt::macro_parser::{error};\n@@ -24,13 +24,13 @@ use parse::token::{FAT_ARROW, SEMI, nt_matchers, nt_tt};\n use print;\n \n pub fn add_new_extension(cx: @ExtCtxt,\n-                         sp: span,\n+                         sp: Span,\n                          name: ident,\n                          arg: ~[ast::token_tree])\n                       -> base::MacResult {\n     // these spans won't matter, anyways\n     fn ms(m: matcher_) -> matcher {\n-        spanned {\n+        Spanned {\n             node: m.clone(),\n             span: dummy_sp()\n         }\n@@ -74,7 +74,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n     };\n \n     // Given `lhses` and `rhses`, this is the new macro we create\n-    fn generic_extension(cx: @ExtCtxt, sp: span, name: ident,\n+    fn generic_extension(cx: @ExtCtxt, sp: Span, name: ident,\n                          arg: &[ast::token_tree],\n                          lhses: &[@named_match], rhses: &[@named_match])\n     -> MacResult {\n@@ -144,7 +144,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n         cx.span_fatal(best_fail_spot, best_fail_msg);\n     }\n \n-    let exp: @fn(@ExtCtxt, span, &[ast::token_tree]) -> MacResult =\n+    let exp: @fn(@ExtCtxt, Span, &[ast::token_tree]) -> MacResult =\n         |cx, sp, arg| generic_extension(cx, sp, name, arg, *lhses, *rhses);\n \n     return MRDef(MacroDef{"}, {"sha": "668805bf7a8e7d34d62962bc91613f792e60a003", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -10,7 +10,7 @@\n \n use ast;\n use ast::{token_tree, tt_delim, tt_tok, tt_seq, tt_nonterminal,ident};\n-use codemap::{span, dummy_sp};\n+use codemap::{Span, dummy_sp};\n use diagnostic::span_handler;\n use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n use parse::token::{EOF, INTERPOLATED, IDENT, Token, nt_ident};\n@@ -39,7 +39,7 @@ pub struct TtReader {\n     repeat_len: ~[uint],\n     /* cached: */\n     cur_tok: Token,\n-    cur_span: span\n+    cur_span: Span\n }\n \n /** This can do Macro-By-Example transcription. On the other hand, if"}, {"sha": "98ef4e89027cb25a6df015e4ff5c13fffcfe669b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -10,7 +10,7 @@\n \n use ast::*;\n use ast;\n-use codemap::{span, spanned};\n+use codemap::{Span, Spanned};\n use parse::token;\n use opt_vec::OptVec;\n \n@@ -37,7 +37,7 @@ pub trait ast_fold {\n     fn fold_local(@self, @Local) -> @Local;\n     fn map_exprs(@self, @fn(@expr) -> @expr, &[@expr]) -> ~[@expr];\n     fn new_id(@self, NodeId) -> NodeId;\n-    fn new_span(@self, span) -> span;\n+    fn new_span(@self, Span) -> Span;\n }\n \n // We may eventually want to be able to fold over type parameters, too\n@@ -52,21 +52,21 @@ pub struct AstFoldFns {\n     fold_item_underscore: @fn(&item_, @ast_fold) -> item_,\n     fold_method: @fn(@method, @ast_fold) -> @method,\n     fold_block: @fn(&Block, @ast_fold) -> Block,\n-    fold_stmt: @fn(&stmt_, span, @ast_fold) -> (Option<stmt_>, span),\n+    fold_stmt: @fn(&stmt_, Span, @ast_fold) -> (Option<stmt_>, Span),\n     fold_arm: @fn(&arm, @ast_fold) -> arm,\n-    fold_pat: @fn(&pat_, span, @ast_fold) -> (pat_, span),\n-    fold_decl: @fn(&decl_, span, @ast_fold) -> (Option<decl_>, span),\n-    fold_expr: @fn(&expr_, span, @ast_fold) -> (expr_, span),\n-    fold_ty: @fn(&ty_, span, @ast_fold) -> (ty_, span),\n+    fold_pat: @fn(&pat_, Span, @ast_fold) -> (pat_, Span),\n+    fold_decl: @fn(&decl_, Span, @ast_fold) -> (Option<decl_>, Span),\n+    fold_expr: @fn(&expr_, Span, @ast_fold) -> (expr_, Span),\n+    fold_ty: @fn(&ty_, Span, @ast_fold) -> (ty_, Span),\n     fold_mod: @fn(&_mod, @ast_fold) -> _mod,\n     fold_foreign_mod: @fn(&foreign_mod, @ast_fold) -> foreign_mod,\n-    fold_variant: @fn(&variant_, span, @ast_fold) -> (variant_, span),\n+    fold_variant: @fn(&variant_, Span, @ast_fold) -> (variant_, Span),\n     fold_ident: @fn(ident, @ast_fold) -> ident,\n     fold_path: @fn(&Path, @ast_fold) -> Path,\n     fold_local: @fn(@Local, @ast_fold) -> @Local,\n     map_exprs: @fn(@fn(@expr) -> @expr, &[@expr]) -> ~[@expr],\n     new_id: @fn(NodeId) -> NodeId,\n-    new_span: @fn(span) -> span\n+    new_span: @fn(Span) -> Span\n }\n \n pub type ast_fold_fns = @AstFoldFns;\n@@ -75,7 +75,7 @@ pub type ast_fold_fns = @AstFoldFns;\n \n //used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n fn fold_meta_item_(mi: @MetaItem, fld: @ast_fold) -> @MetaItem {\n-    @spanned {\n+    @Spanned {\n         node:\n             match mi.node {\n                 MetaWord(id) => MetaWord(id),\n@@ -92,7 +92,7 @@ fn fold_meta_item_(mi: @MetaItem, fld: @ast_fold) -> @MetaItem {\n }\n //used in noop_fold_item and noop_fold_crate\n fn fold_attribute_(at: Attribute, fld: @ast_fold) -> Attribute {\n-    spanned {\n+    Spanned {\n         span: fld.new_span(at.span),\n         node: ast::Attribute_ {\n             style: at.node.style,\n@@ -114,7 +114,7 @@ fn fold_arg_(a: arg, fld: @ast_fold) -> arg {\n \n //used in noop_fold_expr, and possibly elsewhere in the future\n fn fold_mac_(m: &mac, fld: @ast_fold) -> mac {\n-    spanned {\n+    Spanned {\n         node: match m.node {\n             mac_invoc_tt(ref p,ref tts) =>\n             mac_invoc_tt(fld.fold_path(p),\n@@ -258,7 +258,7 @@ fn noop_fold_struct_field(sf: @struct_field, fld: @ast_fold)\n                        -> @struct_field {\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n-    @spanned {\n+    @Spanned {\n         node: ast::struct_field_ {\n             kind: sf.node.kind,\n             id: sf.node.id,\n@@ -348,7 +348,7 @@ fn fold_trait_ref(p: &trait_ref, fld: @ast_fold) -> trait_ref {\n }\n \n fn fold_struct_field(f: @struct_field, fld: @ast_fold) -> @struct_field {\n-    @spanned {\n+    @Spanned {\n         node: ast::struct_field_ {\n             kind: f.node.kind,\n             id: fld.new_id(f.node.id),\n@@ -479,8 +479,8 @@ fn noop_fold_decl(d: &decl_, fld: @ast_fold) -> Option<decl_> {\n }\n \n pub fn wrap<T>(f: @fn(&T, @ast_fold) -> T)\n-            -> @fn(&T, span, @ast_fold) -> (T, span) {\n-    let result: @fn(&T, span, @ast_fold) -> (T, span) = |x, s, fld| {\n+            -> @fn(&T, Span, @ast_fold) -> (T, Span) {\n+    let result: @fn(&T, Span, @ast_fold) -> (T, Span) = |x, s, fld| {\n         (f(x, fld), s)\n     };\n     result\n@@ -793,7 +793,7 @@ fn noop_map_exprs(f: @fn(@expr) -> @expr, es: &[@expr]) -> ~[@expr] {\n \n fn noop_id(i: NodeId) -> NodeId { return i; }\n \n-fn noop_span(sp: span) -> span { return sp; }\n+fn noop_span(sp: Span) -> Span { return sp; }\n \n pub fn default_ast_fold() -> ast_fold_fns {\n     @AstFoldFns {\n@@ -843,7 +843,7 @@ impl ast_fold for AstFoldFns {\n         (self.fold_item)(i, self as @ast_fold)\n     }\n     fn fold_struct_field(@self, sf: @struct_field) -> @struct_field {\n-        @spanned {\n+        @Spanned {\n             node: ast::struct_field_ {\n                 kind: sf.node.kind,\n                 id: sf.node.id,\n@@ -865,7 +865,7 @@ impl ast_fold for AstFoldFns {\n     fn fold_stmt(@self, x: &stmt) -> Option<@stmt> {\n         let (n_opt, s) = (self.fold_stmt)(&x.node, x.span, self as @ast_fold);\n         match n_opt {\n-            Some(n) => Some(@spanned { node: n, span: (self.new_span)(s) }),\n+            Some(n) => Some(@Spanned { node: n, span: (self.new_span)(s) }),\n             None => None,\n         }\n     }\n@@ -883,7 +883,7 @@ impl ast_fold for AstFoldFns {\n     fn fold_decl(@self, x: @decl) -> Option<@decl> {\n         let (n_opt, s) = (self.fold_decl)(&x.node, x.span, self as @ast_fold);\n         match n_opt {\n-            Some(n) => Some(@spanned { node: n, span: (self.new_span)(s) }),\n+            Some(n) => Some(@Spanned { node: n, span: (self.new_span)(s) }),\n             None => None,\n         }\n     }\n@@ -911,7 +911,7 @@ impl ast_fold for AstFoldFns {\n     }\n     fn fold_variant(@self, x: &variant) -> variant {\n         let (n, s) = (self.fold_variant)(&x.node, x.span, self as @ast_fold);\n-        spanned { node: n, span: (self.new_span)(s) }\n+        Spanned { node: n, span: (self.new_span)(s) }\n     }\n     fn fold_ident(@self, x: ident) -> ident {\n         (self.fold_ident)(x, self as @ast_fold)\n@@ -931,7 +931,7 @@ impl ast_fold for AstFoldFns {\n     fn new_id(@self, node_id: ast::NodeId) -> NodeId {\n         (self.new_id)(node_id)\n     }\n-    fn new_span(@self, span: span) -> span {\n+    fn new_span(@self, span: Span) -> Span {\n         (self.new_span)(span)\n     }\n }"}, {"sha": "1c7e9d66191061eec9acf4aefca57284a1c4d0c8", "filename": "src/libsyntax/oldvisit.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Foldvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Foldvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Foldvisit.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -11,7 +11,7 @@\n use abi::AbiSet;\n use ast::*;\n use ast;\n-use codemap::span;\n+use codemap::Span;\n use parse;\n use opt_vec;\n use opt_vec::OptVec;\n@@ -71,7 +71,7 @@ pub fn generics_of_fn(fk: &fn_kind) -> Generics {\n }\n \n pub struct Visitor<E> {\n-    visit_mod: @fn(&_mod, span, NodeId, (E, vt<E>)),\n+    visit_mod: @fn(&_mod, Span, NodeId, (E, vt<E>)),\n     visit_view_item: @fn(&view_item, (E, vt<E>)),\n     visit_foreign_item: @fn(@foreign_item, (E, vt<E>)),\n     visit_item: @fn(@item, (E, vt<E>)),\n@@ -85,7 +85,7 @@ pub struct Visitor<E> {\n     visit_expr_post: @fn(@expr, (E, vt<E>)),\n     visit_ty: @fn(&Ty, (E, vt<E>)),\n     visit_generics: @fn(&Generics, (E, vt<E>)),\n-    visit_fn: @fn(&fn_kind, &fn_decl, &Block, span, NodeId, (E, vt<E>)),\n+    visit_fn: @fn(&fn_kind, &fn_decl, &Block, Span, NodeId, (E, vt<E>)),\n     visit_ty_method: @fn(&TypeMethod, (E, vt<E>)),\n     visit_trait_method: @fn(&trait_method, (E, vt<E>)),\n     visit_struct_def: @fn(@struct_def, ident, &Generics, NodeId, (E, vt<E>)),\n@@ -123,7 +123,7 @@ pub fn visit_crate<E:Clone>(c: &Crate, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_mod<E:Clone>(m: &_mod,\n-                          _sp: span,\n+                          _sp: Span,\n                           _id: NodeId,\n                           (e, v): (E, vt<E>)) {\n     for vi in m.view_items.iter() {\n@@ -396,7 +396,7 @@ pub fn visit_method_helper<E:Clone>(m: &method, (e, v): (E, vt<E>)) {\n pub fn visit_fn<E:Clone>(fk: &fn_kind,\n                          decl: &fn_decl,\n                          body: &Block,\n-                         _sp: span,\n+                         _sp: Span,\n                          _id: NodeId,\n                          (e, v): (E, vt<E>)) {\n     visit_fn_decl(decl, (e.clone(), v));\n@@ -595,7 +595,7 @@ pub fn visit_arm<E:Clone>(a: &arm, (e, v): (E, vt<E>)) {\n // calls the given functions on the nodes.\n \n pub struct SimpleVisitor {\n-    visit_mod: @fn(&_mod, span, NodeId),\n+    visit_mod: @fn(&_mod, Span, NodeId),\n     visit_view_item: @fn(&view_item),\n     visit_foreign_item: @fn(@foreign_item),\n     visit_item: @fn(@item),\n@@ -609,7 +609,7 @@ pub struct SimpleVisitor {\n     visit_expr_post: @fn(@expr),\n     visit_ty: @fn(&Ty),\n     visit_generics: @fn(&Generics),\n-    visit_fn: @fn(&fn_kind, &fn_decl, &Block, span, NodeId),\n+    visit_fn: @fn(&fn_kind, &fn_decl, &Block, Span, NodeId),\n     visit_ty_method: @fn(&TypeMethod),\n     visit_trait_method: @fn(&trait_method),\n     visit_struct_def: @fn(@struct_def, ident, &Generics, NodeId),\n@@ -648,9 +648,9 @@ pub fn default_simple_visitor() -> @SimpleVisitor {\n \n pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n     fn v_mod(\n-        f: @fn(&_mod, span, NodeId),\n+        f: @fn(&_mod, Span, NodeId),\n         m: &_mod,\n-        sp: span,\n+        sp: Span,\n         id: NodeId,\n         (e, v): ((), vt<()>)\n     ) {\n@@ -734,11 +734,11 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         visit_generics(ps, (e, v));\n     }\n     fn v_fn(\n-        f: @fn(&fn_kind, &fn_decl, &Block, span, NodeId),\n+        f: @fn(&fn_kind, &fn_decl, &Block, Span, NodeId),\n         fk: &fn_kind,\n         decl: &fn_decl,\n         body: &Block,\n-        sp: span,\n+        sp: Span,\n         id: NodeId,\n         (e, v): ((), vt<()>)\n     ) {"}, {"sha": "1bc334f1140b9d1a3fd085e3e0e6688218a4a857", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use codemap::{spanned, mk_sp};\n+use codemap::{spanned, Spanned, mk_sp};\n use parse::common::*; //resolve bug?\n use parse::token;\n use parse::parser::Parser;\n@@ -95,7 +95,7 @@ impl parser_attr for Parser {\n         } else {\n             ast::AttrOuter\n         };\n-        return spanned {\n+        return Spanned {\n             span: span,\n             node: ast::Attribute_ {\n                 style: style,"}, {"sha": "26d66cfcaabe87589d041e29f42faa03fbe07cd5", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use codemap::{BytePos, CharPos, CodeMap, Pos, span};\n+use codemap::{BytePos, CharPos, CodeMap, Pos, Span};\n use codemap;\n use diagnostic::span_handler;\n use ext::tt::transcribe::{tt_next_token};\n@@ -36,7 +36,7 @@ pub trait reader {\n #[deriving(Clone, Eq)]\n pub struct TokenAndSpan {\n     tok: token::Token,\n-    sp: span,\n+    sp: Span,\n }\n \n pub struct StringReader {\n@@ -53,7 +53,7 @@ pub struct StringReader {\n     filemap: @codemap::FileMap,\n     /* cached: */\n     peek_tok: token::Token,\n-    peek_span: span\n+    peek_span: Span\n }\n \n pub fn new_string_reader(span_diagnostic: @mut span_handler,\n@@ -798,7 +798,7 @@ mod test {\n     use super::*;\n \n     use ast;\n-    use codemap::{BytePos, CodeMap, span};\n+    use codemap::{BytePos, CodeMap, Span};\n     use diagnostic;\n     use parse::token;\n     use parse::token::{str_to_ident};\n@@ -827,15 +827,15 @@ mod test {\n         let tok1 = string_reader.next_token();\n         let tok2 = TokenAndSpan{\n             tok:token::IDENT(id, false),\n-            sp:span {lo:BytePos(21),hi:BytePos(23),expn_info: None}};\n+            sp:Span {lo:BytePos(21),hi:BytePos(23),expn_info: None}};\n         assert_eq!(tok1,tok2);\n         // the 'main' id is already read:\n         assert_eq!(string_reader.last_pos.clone(), BytePos(28));\n         // read another token:\n         let tok3 = string_reader.next_token();\n         let tok4 = TokenAndSpan{\n             tok:token::IDENT(str_to_ident(\"main\"), false),\n-            sp:span {lo:BytePos(24),hi:BytePos(28),expn_info: None}};\n+            sp:Span {lo:BytePos(24),hi:BytePos(28),expn_info: None}};\n         assert_eq!(tok3,tok4);\n         // the lparen is already read:\n         assert_eq!(string_reader.last_pos.clone(), BytePos(29))"}, {"sha": "ea1c9ce9b1e1a1008a926c5b587408a6aff890f1", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -13,7 +13,7 @@\n \n use ast::NodeId;\n use ast;\n-use codemap::{span, CodeMap, FileMap, FileSubstr};\n+use codemap::{Span, CodeMap, FileMap, FileSubstr};\n use codemap;\n use diagnostic::{span_handler, mk_span_handler, mk_handler, Emitter};\n use parse::attr::parser_attr;\n@@ -247,7 +247,7 @@ pub fn new_sub_parser_from_file(\n     sess: @mut ParseSess,\n     cfg: ast::CrateConfig,\n     path: &Path,\n-    sp: span\n+    sp: Span\n ) -> Parser {\n     filemap_to_parser(sess,file_to_filemap(sess,path,Some(sp)),cfg)\n }\n@@ -272,7 +272,7 @@ pub fn new_parser_from_tts(sess: @mut ParseSess,\n \n /// Given a session and a path and an optional span (for error reporting),\n /// add the path to the session's codemap and return the new filemap.\n-pub fn file_to_filemap(sess: @mut ParseSess, path: &Path, spanopt: Option<span>)\n+pub fn file_to_filemap(sess: @mut ParseSess, path: &Path, spanopt: Option<Span>)\n     -> @FileMap {\n     match io::read_whole_file_str(path) {\n         Ok(src) => string_to_filemap(sess, src.to_managed(), path.to_str().to_managed()),\n@@ -332,7 +332,7 @@ mod test {\n     use extra::serialize::Encodable;\n     use extra;\n     use std::io;\n-    use codemap::{span, BytePos, spanned};\n+    use codemap::{Span, BytePos, Spanned};\n     use opt_vec;\n     use ast;\n     use abi;\n@@ -357,8 +357,8 @@ mod test {\n     }\n \n     // produce a codemap::span\n-    fn sp (a: uint, b: uint) -> span {\n-        span{lo:BytePos(a),hi:BytePos(b),expn_info:None}\n+    fn sp (a: uint, b: uint) -> Span {\n+        Span{lo:BytePos(a),hi:BytePos(b),expn_info:None}\n     }\n \n     #[test] fn path_exprs_1() {\n@@ -463,7 +463,7 @@ mod test {\n \n     #[test] fn parse_stmt_1 () {\n         assert_eq!(string_to_stmt(@\"b;\"),\n-                   @spanned{\n+                   @Spanned{\n                        node: ast::stmt_expr(@ast::expr {\n                            id: 1,\n                            node: ast::expr_path(ast::Path {\n@@ -571,7 +571,7 @@ mod test {\n                                     },\n                                     ast::Block {\n                                         view_items: ~[],\n-                                        stmts: ~[@spanned{\n+                                        stmts: ~[@Spanned{\n                                             node: ast::stmt_semi(@ast::expr{\n                                                 id: 6,\n                                                 node: ast::expr_path("}, {"sha": "62cf856a2c84d5d90e97ff82aea20bd99420ea9d", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -19,7 +19,7 @@ removed.\n \n use ast::{expr, expr_lit, lit_nil, Attribute};\n use ast;\n-use codemap::{span, respan};\n+use codemap::{Span, respan};\n use parse::parser::Parser;\n use parse::token::{keywords, Token};\n use parse::token;\n@@ -76,12 +76,12 @@ impl to_bytes::IterBytes for ObsoleteSyntax {\n \n pub trait ParserObsoleteMethods {\n     /// Reports an obsolete syntax non-fatal error.\n-    fn obsolete(&self, sp: span, kind: ObsoleteSyntax);\n+    fn obsolete(&self, sp: Span, kind: ObsoleteSyntax);\n     // Reports an obsolete syntax non-fatal error, and returns\n     // a placeholder expression\n-    fn obsolete_expr(&self, sp: span, kind: ObsoleteSyntax) -> @expr;\n+    fn obsolete_expr(&self, sp: Span, kind: ObsoleteSyntax) -> @expr;\n     fn report(&self,\n-              sp: span,\n+              sp: Span,\n               kind: ObsoleteSyntax,\n               kind_str: &str,\n               desc: &str);\n@@ -94,7 +94,7 @@ pub trait ParserObsoleteMethods {\n \n impl ParserObsoleteMethods for Parser {\n     /// Reports an obsolete syntax non-fatal error.\n-    fn obsolete(&self, sp: span, kind: ObsoleteSyntax) {\n+    fn obsolete(&self, sp: Span, kind: ObsoleteSyntax) {\n         let (kind_str, desc) = match kind {\n             ObsoleteLet => (\n                 \"`let` in field declaration\",\n@@ -263,13 +263,13 @@ impl ParserObsoleteMethods for Parser {\n \n     // Reports an obsolete syntax non-fatal error, and returns\n     // a placeholder expression\n-    fn obsolete_expr(&self, sp: span, kind: ObsoleteSyntax) -> @expr {\n+    fn obsolete_expr(&self, sp: Span, kind: ObsoleteSyntax) -> @expr {\n         self.obsolete(sp, kind);\n         self.mk_expr(sp.lo, sp.hi, expr_lit(@respan(sp, lit_nil)))\n     }\n \n     fn report(&self,\n-              sp: span,\n+              sp: Span,\n               kind: ObsoleteSyntax,\n               kind_str: &str,\n               desc: &str) {"}, {"sha": "ea3437820a180834ab0a0b966db96124f6ed9450", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -62,7 +62,7 @@ use ast::visibility;\n use ast;\n use ast_util::{as_prec, operator_prec};\n use ast_util;\n-use codemap::{span, BytePos, spanned, mk_sp};\n+use codemap::{Span, BytePos, Spanned, spanned, mk_sp};\n use codemap;\n use parse::attr::parser_attr;\n use parse::classify;\n@@ -321,9 +321,9 @@ pub struct Parser {\n     // the current token:\n     token: @mut token::Token,\n     // the span of the current token:\n-    span: @mut span,\n+    span: @mut Span,\n     // the span of the prior token:\n-    last_span: @mut span,\n+    last_span: @mut Span,\n     // the previous token or None (only stashed sometimes).\n     last_token: @mut Option<~token::Token>,\n     buffer: @mut [TokenAndSpan, ..4],\n@@ -666,7 +666,7 @@ impl Parser {\n                         ket: &token::Token,\n                         sep: SeqSep,\n                         f: &fn(&Parser) -> T)\n-                        -> spanned<~[T]> {\n+                        -> Spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end(ket, sep, f);\n@@ -736,10 +736,10 @@ impl Parser {\n     pub fn fatal(&self, m: &str) -> ! {\n         self.sess.span_diagnostic.span_fatal(*self.span, m)\n     }\n-    pub fn span_fatal(&self, sp: span, m: &str) -> ! {\n+    pub fn span_fatal(&self, sp: Span, m: &str) -> ! {\n         self.sess.span_diagnostic.span_fatal(sp, m)\n     }\n-    pub fn span_note(&self, sp: span, m: &str) {\n+    pub fn span_note(&self, sp: Span, m: &str) {\n         self.sess.span_diagnostic.span_note(sp, m)\n     }\n     pub fn bug(&self, m: &str) -> ! {\n@@ -748,7 +748,7 @@ impl Parser {\n     pub fn warn(&self, m: &str) {\n         self.sess.span_diagnostic.span_warn(*self.span, m)\n     }\n-    pub fn span_err(&self, sp: span, m: &str) {\n+    pub fn span_err(&self, sp: Span, m: &str) {\n         self.sess.span_diagnostic.span_err(sp, m)\n     }\n     pub fn abort_if_errors(&self) {\n@@ -1349,7 +1349,7 @@ impl Parser {\n             let lit = self.lit_from_token(&token);\n             lit\n         };\n-        codemap::spanned { node: lit, span: mk_sp(lo, self.last_span.hi) }\n+        codemap::Spanned { node: lit, span: mk_sp(lo, self.last_span.hi) }\n     }\n \n     // matches '-' lit | lit\n@@ -1686,14 +1686,14 @@ impl Parser {\n     pub fn mk_mac_expr(&self, lo: BytePos, hi: BytePos, m: mac_) -> @expr {\n         @expr {\n             id: self.get_id(),\n-            node: expr_mac(codemap::spanned {node: m, span: mk_sp(lo, hi)}),\n+            node: expr_mac(codemap::Spanned {node: m, span: mk_sp(lo, hi)}),\n             span: mk_sp(lo, hi),\n         }\n     }\n \n     pub fn mk_lit_u32(&self, i: u32) -> @expr {\n         let span = self.span;\n-        let lv_lit = @codemap::spanned {\n+        let lv_lit = @codemap::Spanned {\n             node: lit_uint(i as u64, ty_u32),\n             span: *span\n         };\n@@ -2060,7 +2060,7 @@ impl Parser {\n                     );\n                     let (s, z) = p.parse_sep_and_zerok();\n                     let seq = match seq {\n-                        spanned { node, _ } => node,\n+                        Spanned { node, _ } => node,\n                     };\n                     tt_seq(\n                         mk_sp(sp.lo, p.span.hi),\n@@ -2219,7 +2219,7 @@ impl Parser {\n                 hi = e.span.hi;\n                 // HACK: turn &[...] into a &-evec\n                 ex = match e.node {\n-                  expr_vec(*) | expr_lit(@codemap::spanned {\n+                  expr_vec(*) | expr_lit(@codemap::Spanned {\n                     node: lit_str(_), span: _\n                   })\n                   if m == m_imm => {\n@@ -2244,7 +2244,7 @@ impl Parser {\n               expr_vec(*) | expr_repeat(*) if m == m_mutbl =>\n                 expr_vstore(e, expr_vstore_mut_box),\n               expr_vec(*) |\n-              expr_lit(@codemap::spanned { node: lit_str(_), span: _}) |\n+              expr_lit(@codemap::Spanned { node: lit_str(_), span: _}) |\n               expr_repeat(*) if m == m_imm => expr_vstore(e, expr_vstore_box),\n               _ => self.mk_unary(box(m), e)\n             };\n@@ -2261,7 +2261,7 @@ impl Parser {\n             // HACK: turn ~[...] into a ~-evec\n             ex = match e.node {\n               expr_vec(*) |\n-              expr_lit(@codemap::spanned { node: lit_str(_), span: _}) |\n+              expr_lit(@codemap::Spanned { node: lit_str(_), span: _}) |\n               expr_repeat(*) => expr_vstore(e, expr_vstore_uniq),\n               _ => self.mk_unary(uniq, e)\n             };\n@@ -2789,7 +2789,7 @@ impl Parser {\n             // HACK: parse @\"...\" as a literal of a vstore @str\n             pat = match sub.node {\n               pat_lit(e@@expr {\n-                node: expr_lit(@codemap::spanned {\n+                node: expr_lit(@codemap::Spanned {\n                     node: lit_str(_),\n                     span: _}), _\n               }) => {\n@@ -2817,7 +2817,7 @@ impl Parser {\n             // HACK: parse ~\"...\" as a literal of a vstore ~str\n             pat = match sub.node {\n               pat_lit(e@@expr {\n-                node: expr_lit(@codemap::spanned {\n+                node: expr_lit(@codemap::Spanned {\n                     node: lit_str(_),\n                     span: _}), _\n               }) => {\n@@ -2846,7 +2846,7 @@ impl Parser {\n               // HACK: parse &\"...\" as a literal of a borrowed str\n               pat = match sub.node {\n                   pat_lit(e@@expr {\n-                      node: expr_lit(@codemap::spanned {\n+                      node: expr_lit(@codemap::Spanned {\n                             node: lit_str(_), span: _}), _\n                   }) => {\n                       let vst = @expr {\n@@ -2884,7 +2884,7 @@ impl Parser {\n             if *self.token == token::RPAREN {\n                 hi = self.span.hi;\n                 self.bump();\n-                let lit = @codemap::spanned {\n+                let lit = @codemap::Spanned {\n                     node: lit_nil,\n                     span: mk_sp(lo, hi)};\n                 let expr = self.mk_expr(lo, hi, expr_lit(lit));\n@@ -3320,7 +3320,7 @@ impl Parser {\n                             match *self.token {\n                                 token::SEMI => {\n                                     self.bump();\n-                                    stmts.push(@codemap::spanned {\n+                                    stmts.push(@codemap::Spanned {\n                                         node: stmt_semi(e, stmt_id),\n                                         span: stmt.span,\n                                     });\n@@ -3357,7 +3357,7 @@ impl Parser {\n \n                             if has_semi {\n                                 self.bump();\n-                                stmts.push(@codemap::spanned {\n+                                stmts.push(@codemap::Spanned {\n                                     node: stmt_mac((*m).clone(), true),\n                                     span: stmt.span,\n                                 });\n@@ -4125,7 +4125,7 @@ impl Parser {\n     fn eval_src_mod(&self,\n                     id: ast::ident,\n                     outer_attrs: &[ast::Attribute],\n-                    id_sp: span)\n+                    id_sp: Span)\n                     -> (ast::item_, ~[ast::Attribute]) {\n         let prefix = Path(self.sess.cm.span_to_filename(*self.span));\n         let prefix = prefix.dir_path();\n@@ -4173,7 +4173,7 @@ impl Parser {\n     fn eval_src_mod_from_path(&self,\n                               path: Path,\n                               outer_attrs: ~[ast::Attribute],\n-                              id_sp: span) -> (ast::item_, ~[ast::Attribute]) {\n+                              id_sp: Span) -> (ast::item_, ~[ast::Attribute]) {\n         let full_path = path.normalize();\n \n         let maybe_i = do self.sess.included_mod_stack.iter().position |p| { *p == full_path };\n@@ -4797,7 +4797,7 @@ impl Parser {\n             };\n             // single-variant-enum... :\n             let m = ast::mac_invoc_tt(pth, tts);\n-            let m: ast::mac = codemap::spanned { node: m,\n+            let m: ast::mac = codemap::Spanned { node: m,\n                                              span: mk_sp(self.span.lo,\n                                                          self.span.hi) };\n             let item_ = item_mac(m);"}, {"sha": "599092f4b1492b6c0a318cf745ca0ba4de8ec40b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -258,10 +258,10 @@ pub fn bopen(s: @ps) {\n     end(s); // close the head-box\n }\n \n-pub fn bclose_(s: @ps, span: codemap::span, indented: uint) {\n+pub fn bclose_(s: @ps, span: codemap::Span, indented: uint) {\n     bclose_maybe_open(s, span, indented, true);\n }\n-pub fn bclose_maybe_open (s: @ps, span: codemap::span, indented: uint,\n+pub fn bclose_maybe_open (s: @ps, span: codemap::Span, indented: uint,\n                           close_box: bool) {\n     maybe_print_comment(s, span.hi);\n     break_offset_if_not_bol(s, 1u, -(indented as int));\n@@ -270,7 +270,7 @@ pub fn bclose_maybe_open (s: @ps, span: codemap::span, indented: uint,\n         end(s); // close the outer-box\n     }\n }\n-pub fn bclose(s: @ps, span: codemap::span) { bclose_(s, span, indent_unit); }\n+pub fn bclose(s: @ps, span: codemap::Span) { bclose_(s, span, indent_unit); }\n \n pub fn is_begin(s: @ps) -> bool {\n     match s.s.last_token() { pp::BEGIN(_) => true, _ => false }\n@@ -328,7 +328,7 @@ pub fn commasep<T>(s: @ps, b: breaks, elts: &[T], op: &fn(@ps, &T)) {\n \n \n pub fn commasep_cmnt<T>(s: @ps, b: breaks, elts: &[T], op: &fn(@ps, &T),\n-                               get_span: &fn(&T) -> codemap::span) {\n+                               get_span: &fn(&T) -> codemap::Span) {\n     box(s, 0u, b);\n     let len = elts.len();\n     let mut i = 0u;\n@@ -618,7 +618,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         }\n         bclose(s, item.span);\n       }\n-      ast::item_mac(codemap::spanned { node: ast::mac_invoc_tt(ref pth, ref tts),\n+      ast::item_mac(codemap::Spanned { node: ast::mac_invoc_tt(ref pth, ref tts),\n                                    _}) => {\n         print_visibility(s, item.vis);\n         print_path(s, pth, false);\n@@ -640,7 +640,7 @@ fn print_trait_ref(s: @ps, t: &ast::trait_ref) {\n \n pub fn print_enum_def(s: @ps, enum_definition: &ast::enum_def,\n                       generics: &ast::Generics, ident: ast::ident,\n-                      span: codemap::span, visibility: ast::visibility) {\n+                      span: codemap::Span, visibility: ast::visibility) {\n     head(s, visibility_qualified(visibility, \"enum\"));\n     print_ident(s, ident);\n     print_generics(s, generics);\n@@ -650,7 +650,7 @@ pub fn print_enum_def(s: @ps, enum_definition: &ast::enum_def,\n \n pub fn print_variants(s: @ps,\n                       variants: &[ast::variant],\n-                      span: codemap::span) {\n+                      span: codemap::Span) {\n     bopen(s);\n     for v in variants.iter() {\n         space_if_not_bol(s);\n@@ -692,7 +692,7 @@ pub fn print_struct(s: @ps,\n                     struct_def: &ast::struct_def,\n                     generics: &ast::Generics,\n                     ident: ast::ident,\n-                    span: codemap::span) {\n+                    span: codemap::Span) {\n     print_ident(s, ident);\n     print_generics(s, generics);\n     if ast_util::struct_def_is_tuple_like(struct_def) {\n@@ -1111,7 +1111,7 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n         print_expr(s, field.expr);\n         end(s);\n     }\n-    fn get_span(field: &ast::Field) -> codemap::span { return field.span; }\n+    fn get_span(field: &ast::Field) -> codemap::Span { return field.span; }\n \n     maybe_print_comment(s, expr.span.lo);\n     ibox(s, indent_unit);\n@@ -1614,7 +1614,7 @@ pub fn print_pat(s: @ps, pat: &ast::pat) {\n             print_pat(s, f.pat);\n             end(s);\n         }\n-        fn get_span(f: &ast::field_pat) -> codemap::span { return f.pat.span; }\n+        fn get_span(f: &ast::field_pat) -> codemap::Span { return f.pat.span; }\n         commasep_cmnt(s, consistent, *fields,\n                       |s, f| print_field(s,f),\n                       get_span);\n@@ -1997,7 +1997,7 @@ pub fn print_ty_fn(s: @ps,\n     end(s);\n }\n \n-pub fn maybe_print_trailing_comment(s: @ps, span: codemap::span,\n+pub fn maybe_print_trailing_comment(s: @ps, span: codemap::Span,\n                                     next_pos: Option<BytePos>) {\n     let cm;\n     match s.cm { Some(ccm) => cm = ccm, _ => return }"}, {"sha": "0656ed1372d7bf3a9df2606080570ed1d1c0f5a1", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66593a733d763e01e6765c7a52476c7693eb211a/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=66593a733d763e01e6765c7a52476c7693eb211a", "patch": "@@ -11,7 +11,7 @@\n use abi::AbiSet;\n use ast::*;\n use ast;\n-use codemap::span;\n+use codemap::Span;\n use parse;\n use opt_vec;\n use opt_vec::OptVec;\n@@ -67,7 +67,7 @@ pub fn generics_of_fn(fk: &fn_kind) -> Generics {\n }\n \n pub trait Visitor<E:Clone> {\n-    fn visit_mod(&mut self, m:&_mod, _s:span, _n:NodeId, e:E) { walk_mod(self, m, e) }\n+    fn visit_mod(&mut self, m:&_mod, _s:Span, _n:NodeId, e:E) { walk_mod(self, m, e) }\n     fn visit_view_item(&mut self, i:&view_item, e:E) { walk_view_item(self, i, e) }\n     fn visit_foreign_item(&mut self, i:@foreign_item, e:E) { walk_foreign_item(self, i, e) }\n     fn visit_item(&mut self, i:@item, e:E) { walk_item(self, i, e) }\n@@ -81,7 +81,7 @@ pub trait Visitor<E:Clone> {\n     fn visit_expr_post(&mut self, _ex:@expr, _e:E) { }\n     fn visit_ty(&mut self, _t:&Ty, _e:E) { }\n     fn visit_generics(&mut self, g:&Generics, e:E) { walk_generics(self, g, e) }\n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:span, n:NodeId, e:E) {\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:Span, n:NodeId, e:E) {\n         walk_fn(self, fk, fd, b, s, n , e)\n     }\n     fn visit_ty_method(&mut self, t:&TypeMethod, e:E) { walk_ty_method(self, t, e) }\n@@ -93,7 +93,7 @@ pub trait Visitor<E:Clone> {\n }\n \n impl<E:Clone> Visitor<E> for @mut Visitor<E> {\n-    fn visit_mod(&mut self, a:&_mod, b:span, c:NodeId, e:E) {\n+    fn visit_mod(&mut self, a:&_mod, b:Span, c:NodeId, e:E) {\n         (*self).visit_mod(a, b, c, e)\n     }\n     fn visit_view_item(&mut self, a:&view_item, e:E) {\n@@ -135,7 +135,7 @@ impl<E:Clone> Visitor<E> for @mut Visitor<E> {\n     fn visit_generics(&mut self, a:&Generics, e:E) {\n         (*self).visit_generics(a, e)\n     }\n-    fn visit_fn(&mut self, a:&fn_kind, b:&fn_decl, c:&Block, d:span, f:NodeId, e:E) {\n+    fn visit_fn(&mut self, a:&fn_kind, b:&fn_decl, c:&Block, d:Span, f:NodeId, e:E) {\n         (*self).visit_fn(a, b, c, d, f, e)\n     }\n     fn visit_ty_method(&mut self, a:&TypeMethod, e:E) {\n@@ -444,7 +444,7 @@ pub fn walk_fn<E:Clone, V:Visitor<E>>(visitor: &mut V,\n                          function_kind: &fn_kind,\n                          function_declaration: &fn_decl,\n                          function_body: &Block,\n-                         _: span,\n+                         _: Span,\n                          _: NodeId,\n                          env: E) {\n     walk_fn_decl(visitor, function_declaration, env.clone());\n@@ -676,7 +676,7 @@ pub fn walk_arm<E:Clone, V:Visitor<E>>(visitor: &mut V, arm: &arm, env: E) {\n // calls the given functions on the nodes.\n \n pub trait SimpleVisitor {\n-    fn visit_mod(&mut self, &_mod, span, NodeId);\n+    fn visit_mod(&mut self, &_mod, Span, NodeId);\n     fn visit_view_item(&mut self, &view_item);\n     fn visit_foreign_item(&mut self, @foreign_item);\n     fn visit_item(&mut self, @item);\n@@ -690,7 +690,7 @@ pub trait SimpleVisitor {\n     fn visit_expr_post(&mut self, @expr);\n     fn visit_ty(&mut self, &Ty);\n     fn visit_generics(&mut self, &Generics);\n-    fn visit_fn(&mut self, &fn_kind, &fn_decl, &Block, span, NodeId);\n+    fn visit_fn(&mut self, &fn_kind, &fn_decl, &Block, Span, NodeId);\n     fn visit_ty_method(&mut self, &TypeMethod);\n     fn visit_trait_method(&mut self, &trait_method);\n     fn visit_struct_def(&mut self, @struct_def, ident, &Generics, NodeId);\n@@ -705,7 +705,7 @@ pub struct SimpleVisitorVisitor {\n impl Visitor<()> for SimpleVisitorVisitor {\n     fn visit_mod(&mut self,\n                  module: &_mod,\n-                 span: span,\n+                 span: Span,\n                  node_id: NodeId,\n                  env: ()) {\n         self.simple_visitor.visit_mod(module, span, node_id);\n@@ -766,7 +766,7 @@ impl Visitor<()> for SimpleVisitorVisitor {\n                 function_kind: &fn_kind,\n                 function_declaration: &fn_decl,\n                 block: &Block,\n-                span: span,\n+                span: Span,\n                 node_id: NodeId,\n                 env: ()) {\n         self.simple_visitor.visit_fn(function_kind,"}]}