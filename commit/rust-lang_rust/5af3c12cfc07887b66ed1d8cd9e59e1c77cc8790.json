{"sha": "5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhZjNjMTJjZmMwNzg4N2I2NmVkMWQ4Y2Q5ZTU5ZTFjNzdjYzg3OTA=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-23T19:39:35Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T16:19:29Z"}, "message": "trans: Move static item handling to consts.", "tree": {"sha": "e69e085e7c6e7a9056c3b012dc43ea4e10ff8dae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e69e085e7c6e7a9056c3b012dc43ea4e10ff8dae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790", "html_url": "https://github.com/rust-lang/rust/commit/5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3f856e7e24be568902a38c6a488aee6098f94cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3f856e7e24be568902a38c6a488aee6098f94cc", "html_url": "https://github.com/rust-lang/rust/commit/c3f856e7e24be568902a38c6a488aee6098f94cc"}], "stats": {"total": 273, "additions": 123, "deletions": 150}, "files": [{"sha": "b189384b7d0dd32d70de6b04a8fc17aab029f4d6", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 7, "deletions": 56, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790", "patch": "@@ -10,8 +10,8 @@\n //! Translate the completed AST to the LLVM IR.\n //!\n //! Some functions here, such as trans_block and trans_expr, return a value --\n-//! the result of the translation to LLVM -- while others, such as trans_fn,\n-//! trans_impl, and trans_item, are called only for the side effect of adding a\n+//! the result of the translation to LLVM -- while others, such as trans_fn\n+//! and trans_item, are called only for the side effect of adding a\n //! particular definition to the LLVM IR output we're producing.\n //!\n //! Hopefully useful general knowledge about trans:\n@@ -228,36 +228,6 @@ pub fn kind_for_closure(ccx: &CrateContext, closure_id: DefId) -> ty::ClosureKin\n     *ccx.tcx().tables.borrow().closure_kinds.get(&closure_id).unwrap()\n }\n \n-pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                  did: DefId,\n-                                  t: Ty<'tcx>)\n-                                  -> ValueRef {\n-    let name = ccx.sess().cstore.item_symbol(did);\n-    let ty = type_of(ccx, t);\n-    if let Some(n) = ccx.externs().borrow_mut().get(&name) {\n-        return *n;\n-    }\n-    // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n-    // FIXME(nagisa): investigate whether it can be changed into define_global\n-    let c = declare::declare_global(ccx, &name[..], ty);\n-    // Thread-local statics in some other crate need to *always* be linked\n-    // against in a thread-local fashion, so we need to be sure to apply the\n-    // thread-local attribute locally if it was present remotely. If we\n-    // don't do this then linker errors can be generated where the linker\n-    // complains that one object files has a thread local version of the\n-    // symbol and another one doesn't.\n-    for attr in ccx.tcx().get_attrs(did).iter() {\n-        if attr.check_name(\"thread_local\") {\n-            llvm::set_thread_local(c, true);\n-        }\n-    }\n-    if ccx.use_dll_storage_attrs() {\n-        llvm::SetDLLStorageClass(c, llvm::DLLImportStorageClass);\n-    }\n-    ccx.externs().borrow_mut().insert(name.to_string(), c);\n-    return c;\n-}\n-\n fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, info_ty: Ty<'tcx>, it: LangItem) -> DefId {\n     match bcx.tcx().lang_items.require(it) {\n         Ok(id) => id,\n@@ -2714,11 +2684,11 @@ pub fn create_entry_wrapper(ccx: &CrateContext, sp: Span, main_llfn: ValueRef) {\n     }\n }\n \n-fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                           id: ast::NodeId,\n-                           ty: Ty<'tcx>,\n-                           attrs: &[ast::Attribute])\n-                           -> String {\n+pub fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                               id: ast::NodeId,\n+                               ty: Ty<'tcx>,\n+                               attrs: &[ast::Attribute])\n+                               -> String {\n     match ccx.external_srcs().borrow().get(&id) {\n         Some(&did) => {\n             let sym = ccx.sess().cstore.item_symbol(did);\n@@ -2768,25 +2738,6 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let sym = || exported_name(ccx, id, ty, &i.attrs);\n \n             let v = match i.node {\n-                hir::ItemStatic(..) => {\n-                    // If this static came from an external crate, then\n-                    // we need to get the symbol from metadata instead of\n-                    // using the current crate's name/version\n-                    // information in the hash of the symbol\n-                    let sym = sym();\n-                    debug!(\"making {}\", sym);\n-\n-                    // Create the global before evaluating the initializer;\n-                    // this is necessary to allow recursive statics.\n-                    let llty = type_of(ccx, ty);\n-                    let g = declare::define_global(ccx, &sym[..], llty).unwrap_or_else(|| {\n-                        ccx.sess()\n-                           .span_fatal(i.span, &format!(\"symbol `{}` is already defined\", sym))\n-                    });\n-\n-                    ccx.item_symbols().borrow_mut().insert(i.id, sym);\n-                    g\n-                }\n \n                 hir::ItemFn(_, _, _, abi, _, _) => {\n                     let sym = sym();"}, {"sha": "eb050c43fa53bffc103eab32675d231b6cf10244", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790", "patch": "@@ -241,7 +241,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n \n     // Create the closure.\n     for (i, freevar) in freevars.iter().enumerate() {\n-        let datum = expr::trans_local_var(bcx, freevar.def);\n+        let datum = expr::trans_var(bcx, freevar.def);\n         let upvar_slot_dest = adt::trans_field_ptr(\n             bcx, &repr, adt::MaybeSizedValue::sized(dest_addr), Disr(0), i);\n         let upvar_id = ty::UpvarId { var_id: freevar.def.var_id(),"}, {"sha": "165a213a91e07a8fe1dffaf7b9df7c7da0cffaf0", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790", "patch": "@@ -1341,14 +1341,3 @@ pub fn shift_mask_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => panic!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n     }\n }\n-\n-pub fn get_static_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                            did: DefId,\n-                            ty: Ty<'tcx>)\n-                            -> ValueRef {\n-    if let Some(node_id) = ccx.tcx().map.as_local_node_id(did) {\n-        base::get_item_val(ccx, node_id)\n-    } else {\n-        base::get_extern_const(ccx, did, ty)\n-    }\n-}"}, {"sha": "35e2646a1abbccdc6ea710a529a3aab676428590", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 80, "deletions": 18, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790", "patch": "@@ -18,16 +18,19 @@ use middle::cstore::LOCAL_CRATE;\n use middle::const_eval::{self, ConstEvalErr};\n use middle::def::Def;\n use middle::def_id::DefId;\n+use rustc::front::map as hir_map;\n use trans::{adt, closure, debuginfo, expr, inline, machine};\n-use trans::base::{self, push_ctxt};\n+use trans::base::{self, exported_name, push_ctxt};\n use trans::callee::Callee;\n use trans::collector::{self, TransItem};\n use trans::common::{self, type_is_sized, ExprOrMethodCall, node_id_substs, C_nil, const_get_elt};\n use trans::common::{CrateContext, C_integral, C_floating, C_bool, C_str_slice, C_bytes, val_ty};\n use trans::common::{C_struct, C_undef, const_to_opt_int, const_to_opt_uint, VariantInfo, C_uint};\n use trans::common::{type_is_fat_ptr, Field, C_vector, C_array, C_null, ExprId, MethodCallKey};\n+use trans::datum::{Datum, Lvalue};\n use trans::declare;\n use trans::monomorphize;\n+use trans::foreign;\n use trans::type_::Type;\n use trans::type_of;\n use trans::value::Value;\n@@ -46,7 +49,7 @@ use std::ffi::{CStr, CString};\n use std::borrow::Cow;\n use libc::c_uint;\n use syntax::ast::{self, LitKind};\n-use syntax::attr;\n+use syntax::attr::{self, AttrMetaMethods};\n use syntax::parse::token;\n use syntax::ptr::P;\n \n@@ -806,7 +809,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n             let opt_def = cx.tcx().def_map.borrow().get(&cur.id).map(|d| d.full_def());\n             if let Some(Def::Static(def_id, _)) = opt_def {\n-                common::get_static_val(cx, def_id, ety)\n+                get_static(cx, def_id).val\n             } else {\n                 // If this isn't the address of a static, then keep going through\n                 // normal constant evaluation.\n@@ -1013,6 +1016,65 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     })\n }\n \n+pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n+                            -> Datum<'tcx, Lvalue> {\n+    let ty = ccx.tcx().lookup_item_type(def_id).ty;\n+\n+    let g = if let Some(id) = ccx.tcx().map.as_local_node_id(def_id) {\n+        match ccx.tcx().map.get(id) {\n+            hir_map::NodeItem(&hir::Item {\n+                ref attrs, span, node: hir::ItemStatic(..), ..\n+            }) => {\n+                // If this static came from an external crate, then\n+                // we need to get the symbol from metadata instead of\n+                // using the current crate's name/version\n+                // information in the hash of the symbol\n+                let sym = exported_name(ccx, id, ty, attrs);\n+                debug!(\"making {}\", sym);\n+\n+                // Create the global before evaluating the initializer;\n+                // this is necessary to allow recursive statics.\n+                let llty = type_of::type_of(ccx, ty);\n+                let g = declare::define_global(ccx, &sym, llty).unwrap_or_else(|| {\n+                    ccx.sess().span_fatal(span,\n+                        &format!(\"symbol `{}` is already defined\", sym))\n+                });\n+\n+                ccx.item_symbols().borrow_mut().insert(id, sym);\n+                g\n+            }\n+\n+            hir_map::NodeForeignItem(ni @ &hir::ForeignItem {\n+                node: hir::ForeignItemStatic(..), ..\n+            }) => foreign::register_static(ccx, ni),\n+\n+            item => unreachable!(\"get_static: expected static, found {:?}\", item)\n+        }\n+    } else {\n+        // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n+        // FIXME(nagisa): investigate whether it can be changed into define_global\n+        let name = ccx.sess().cstore.item_symbol(def_id);\n+        let g = declare::declare_global(ccx, &name, type_of::type_of(ccx, ty));\n+        // Thread-local statics in some other crate need to *always* be linked\n+        // against in a thread-local fashion, so we need to be sure to apply the\n+        // thread-local attribute locally if it was present remotely. If we\n+        // don't do this then linker errors can be generated where the linker\n+        // complains that one object files has a thread local version of the\n+        // symbol and another one doesn't.\n+        for attr in ccx.tcx().get_attrs(def_id).iter() {\n+            if attr.check_name(\"thread_local\") {\n+                llvm::set_thread_local(g, true);\n+            }\n+        }\n+        if ccx.use_dll_storage_attrs() {\n+            llvm::SetDLLStorageClass(g, llvm::DLLImportStorageClass);\n+        }\n+        g\n+    };\n+\n+    Datum::new(g, ty, Lvalue::new(\"static\"))\n+}\n+\n pub fn trans_static(ccx: &CrateContext,\n                     m: hir::Mutability,\n                     expr: &hir::Expr,\n@@ -1026,7 +1088,8 @@ pub fn trans_static(ccx: &CrateContext,\n \n     unsafe {\n         let _icx = push_ctxt(\"trans_static\");\n-        let g = base::get_item_val(ccx, id);\n+        let def_id = ccx.tcx().map.local_def_id(id);\n+        let datum = get_static(ccx, def_id);\n \n         let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n         let (v, _) = try!(const_expr(\n@@ -1039,40 +1102,39 @@ pub fn trans_static(ccx: &CrateContext,\n \n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n-        let mut val_llty = llvm::LLVMTypeOf(v);\n-        let v = if val_llty == Type::i1(ccx).to_ref() {\n-            val_llty = Type::i8(ccx).to_ref();\n-            llvm::LLVMConstZExt(v, val_llty)\n+        let mut val_llty = val_ty(v);\n+        let v = if val_llty == Type::i1(ccx) {\n+            val_llty = Type::i8(ccx);\n+            llvm::LLVMConstZExt(v, val_llty.to_ref())\n         } else {\n             v\n         };\n \n-        let ty = ccx.tcx().node_id_to_type(id);\n-        let llty = type_of::type_of(ccx, ty);\n-        let g = if val_llty == llty.to_ref() {\n-            g\n+        let llty = type_of::type_of(ccx, datum.ty);\n+        let g = if val_llty == llty {\n+            datum.val\n         } else {\n             // If we created the global with the wrong type,\n             // correct the type.\n             let empty_string = CString::new(\"\").unwrap();\n-            let name_str_ref = CStr::from_ptr(llvm::LLVMGetValueName(g));\n+            let name_str_ref = CStr::from_ptr(llvm::LLVMGetValueName(datum.val));\n             let name_string = CString::new(name_str_ref.to_bytes()).unwrap();\n-            llvm::LLVMSetValueName(g, empty_string.as_ptr());\n+            llvm::LLVMSetValueName(datum.val, empty_string.as_ptr());\n             let new_g = llvm::LLVMGetOrInsertGlobal(\n-                ccx.llmod(), name_string.as_ptr(), val_llty);\n+                ccx.llmod(), name_string.as_ptr(), val_llty.to_ref());\n             // To avoid breaking any invariants, we leave around the old\n             // global for the moment; we'll replace all references to it\n             // with the new global later. (See base::trans_crate.)\n-            ccx.statics_to_rauw().borrow_mut().push((g, new_g));\n+            ccx.statics_to_rauw().borrow_mut().push((datum.val, new_g));\n             new_g\n         };\n-        llvm::LLVMSetAlignment(g, type_of::align_of(ccx, ty));\n+        llvm::LLVMSetAlignment(g, type_of::align_of(ccx, datum.ty));\n         llvm::LLVMSetInitializer(g, v);\n \n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n         if m != hir::MutMutable {\n-            let tcontents = ty.type_contents(ccx.tcx());\n+            let tcontents = datum.ty.type_contents(ccx.tcx());\n             if !tcontents.interior_unsafe() {\n                 llvm::LLVMSetGlobalConstant(g, llvm::True);\n             }"}, {"sha": "65fd271d74af193255648d416677aab19b6cda83", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 33, "deletions": 61, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790", "patch": "@@ -44,7 +44,7 @@\n //!   expression and ensures that the result has a cleanup associated with it,\n //!   creating a temporary stack slot if necessary.\n //!\n-//! - `trans_local_var -> Datum`: looks up a local variable or upvar.\n+//! - `trans_var -> Datum`: looks up a local variable, upvar or static.\n \n #![allow(non_camel_case_types)]\n \n@@ -652,7 +652,8 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans(bcx, &e)\n         }\n         hir::ExprPath(..) => {\n-            trans_def(bcx, expr, bcx.def(expr.id))\n+            let var = trans_var(bcx, bcx.def(expr.id));\n+            DatumBlock::new(bcx, var.to_expr_datum())\n         }\n         hir::ExprField(ref base, name) => {\n             trans_rec_field(bcx, &base, name.node)\n@@ -882,27 +883,40 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     DatumBlock::new(bcx, elt_datum)\n }\n \n-fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                         ref_expr: &hir::Expr,\n-                         def: Def)\n-                         -> DatumBlock<'blk, 'tcx, Expr> {\n-    //! Translates a reference to a path.\n+/// Translates a reference to a variable.\n+pub fn trans_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, def: Def)\n+                             -> Datum<'tcx, Lvalue> {\n \n-    let _icx = push_ctxt(\"trans_def_lvalue\");\n     match def {\n-        Def::Static(did, _) => {\n-            let const_ty = expr_ty(bcx, ref_expr);\n-            let val = get_static_val(bcx.ccx(), did, const_ty);\n-            let lval = Lvalue::new(\"expr::trans_def\");\n-            DatumBlock::new(bcx, Datum::new(val, const_ty, LvalueExpr(lval)))\n-        }\n-        Def::Local(..) | Def::Upvar(..) => {\n-            DatumBlock::new(bcx, trans_local_var(bcx, def).to_expr_datum())\n+        Def::Static(did, _) => consts::get_static(bcx.ccx(), did),\n+        Def::Upvar(_, nid, _, _) => {\n+            // Can't move upvars, so this is never a ZeroMemLastUse.\n+            let local_ty = node_id_type(bcx, nid);\n+            let lval = Lvalue::new_with_hint(\"expr::trans_var (upvar)\",\n+                                             bcx, nid, HintKind::ZeroAndMaintain);\n+            match bcx.fcx.llupvars.borrow().get(&nid) {\n+                Some(&val) => Datum::new(val, local_ty, lval),\n+                None => {\n+                    bcx.sess().bug(&format!(\n+                        \"trans_var: no llval for upvar {} found\",\n+                        nid));\n+                }\n+            }\n         }\n-        _ => {\n-            bcx.sess().span_bug(ref_expr.span,\n-                &format!(\"{:?} should not reach expr::trans_def\", def))\n+        Def::Local(_, nid) => {\n+            let datum = match bcx.fcx.lllocals.borrow().get(&nid) {\n+                Some(&v) => v,\n+                None => {\n+                    bcx.sess().bug(&format!(\n+                        \"trans_var: no datum for local/arg {} found\",\n+                        nid));\n+                }\n+            };\n+            debug!(\"take_local(nid={}, v={:?}, ty={})\",\n+                   nid, Value(datum.val), datum.ty);\n+            datum\n         }\n+        _ => unreachable!(\"{:?} should not reach expr::trans_var\", def)\n     }\n }\n \n@@ -1247,48 +1261,6 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-/// Translates a reference to a local variable or argument. This always results in an lvalue datum.\n-pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   def: Def)\n-                                   -> Datum<'tcx, Lvalue> {\n-    let _icx = push_ctxt(\"trans_local_var\");\n-\n-    match def {\n-        Def::Upvar(_, nid, _, _) => {\n-            // Can't move upvars, so this is never a ZeroMemLastUse.\n-            let local_ty = node_id_type(bcx, nid);\n-            let lval = Lvalue::new_with_hint(\"expr::trans_local_var (upvar)\",\n-                                             bcx, nid, HintKind::ZeroAndMaintain);\n-            match bcx.fcx.llupvars.borrow().get(&nid) {\n-                Some(&val) => Datum::new(val, local_ty, lval),\n-                None => {\n-                    bcx.sess().bug(&format!(\n-                        \"trans_local_var: no llval for upvar {} found\",\n-                        nid));\n-                }\n-            }\n-        }\n-        Def::Local(_, nid) => {\n-            let datum = match bcx.fcx.lllocals.borrow().get(&nid) {\n-                Some(&v) => v,\n-                None => {\n-                    bcx.sess().bug(&format!(\n-                        \"trans_local_var: no datum for local/arg {} found\",\n-                        nid));\n-                }\n-            };\n-            debug!(\"take_local(nid={}, v={:?}, ty={})\",\n-                   nid, Value(datum.val), datum.ty);\n-            datum\n-        }\n-        _ => {\n-            bcx.sess().unimpl(&format!(\n-                \"unsupported def type in trans_local_var: {:?}\",\n-                def));\n-        }\n-    }\n-}\n-\n fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             fields: &[hir::Field],\n                             base: Option<&hir::Expr>,"}, {"sha": "14a36c42e6dadba6ba18586f482a3c548ea0ccf6", "filename": "src/librustc_trans/trans/mir/lvalue.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs?ref=5af3c12cfc07887b66ed1d8cd9e59e1c77cc8790", "patch": "@@ -15,6 +15,7 @@ use rustc::mir::tcx::LvalueTy;\n use trans::adt;\n use trans::base;\n use trans::common::{self, BlockAndBuilder};\n+use trans::consts;\n use trans::machine;\n use trans::type_of;\n use trans::mir::drop;\n@@ -89,9 +90,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Lvalue::Arg(index) => self.args[index as usize],\n             mir::Lvalue::Static(def_id) => {\n                 let const_ty = self.mir.lvalue_ty(tcx, lvalue);\n-                LvalueRef::new_sized(\n-                    common::get_static_val(ccx, def_id, const_ty.to_ty(tcx)),\n-                    const_ty)\n+                LvalueRef::new_sized(consts::get_static(ccx, def_id).val, const_ty)\n             },\n             mir::Lvalue::ReturnPointer => {\n                 let fn_return_ty = bcx.monomorphize(&self.mir.return_ty);"}]}