{"sha": "02954ae0a86c5c2f00e9e06b520999c1e67e9cd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyOTU0YWUwYTg2YzVjMmYwMGU5ZTA2YjUyMDk5OWMxZTY3ZTljZDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-18T21:36:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-18T21:36:49Z"}, "message": "Auto merge of #31977 - bluss:partial-eq-save, r=brson\n\nderive: Avoid emitting provided PartialEq, PartialOrd methods for c-like enums\n\nderive: Avoid emitting provided PartialEq, PartialOrd method for c-like enums\n\n`ne` is completely symmetrical with the method `eq`, and we can save\nrust code size and compilation time here if we only emit one of them\nwhen possible.\n\nOne case where it's easy to recognize is when it's a C-like enum. Most\nother cases can not omit ne, because any value field may have a custom\nPartialEq implementation.", "tree": {"sha": "82dbdf0e43aa662e476a1e2d609f29ec10ca9c64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82dbdf0e43aa662e476a1e2d609f29ec10ca9c64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02954ae0a86c5c2f00e9e06b520999c1e67e9cd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02954ae0a86c5c2f00e9e06b520999c1e67e9cd7", "html_url": "https://github.com/rust-lang/rust/commit/02954ae0a86c5c2f00e9e06b520999c1e67e9cd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02954ae0a86c5c2f00e9e06b520999c1e67e9cd7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc9e1d0f55f721461b73628f12cf64de31be55af", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc9e1d0f55f721461b73628f12cf64de31be55af", "html_url": "https://github.com/rust-lang/rust/commit/fc9e1d0f55f721461b73628f12cf64de31be55af"}, {"sha": "edcc02bfee262ce8bc3f087d9793ce68d73b1a40", "url": "https://api.github.com/repos/rust-lang/rust/commits/edcc02bfee262ce8bc3f087d9793ce68d73b1a40", "html_url": "https://github.com/rust-lang/rust/commit/edcc02bfee262ce8bc3f087d9793ce68d73b1a40"}], "stats": {"total": 54, "additions": 43, "deletions": 11}, "files": [{"sha": "6406ee59a5eb555a2e28fc7fabfa3f4ebede0ab3", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/02954ae0a86c5c2f00e9e06b520999c1e67e9cd7/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02954ae0a86c5c2f00e9e06b520999c1e67e9cd7/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=02954ae0a86c5c2f00e9e06b520999c1e67e9cd7", "patch": "@@ -80,17 +80,22 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n         } }\n     }\n \n+    // avoid defining `ne` if we can\n+    // c-like enums, enums without any fields and structs without fields\n+    // can safely define only `eq`.\n+    let mut methods = vec![md!(\"eq\", cs_eq)];\n+    if !is_type_without_fields(item) {\n+        methods.push(md!(\"ne\", cs_ne));\n+    }\n+\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n         path: path_std!(cx, core::cmp::PartialEq),\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n-        methods: vec!(\n-            md!(\"eq\", cs_eq),\n-            md!(\"ne\", cs_ne)\n-        ),\n+        methods: methods,\n         associated_types: Vec::new(),\n     };\n     trait_def.expand(cx, mitem, item, push)"}, {"sha": "e49c77285ab026b5d7ec1fcce286ed3b4be70d2b", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/02954ae0a86c5c2f00e9e06b520999c1e67e9cd7/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02954ae0a86c5c2f00e9e06b520999c1e67e9cd7/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=02954ae0a86c5c2f00e9e06b520999c1e67e9cd7", "patch": "@@ -67,20 +67,29 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n         }))\n     };\n \n+    // avoid defining extra methods if we can\n+    // c-like enums, enums without any fields and structs without fields\n+    // can safely define only `partial_cmp`.\n+    let methods = if is_type_without_fields(item) {\n+        vec![partial_cmp_def]\n+    } else {\n+        vec![\n+            partial_cmp_def,\n+            md!(\"lt\", true, false),\n+            md!(\"le\", true, true),\n+            md!(\"gt\", false, false),\n+            md!(\"ge\", false, true)\n+        ]\n+    };\n+\n     let trait_def = TraitDef {\n         span: span,\n         attributes: vec![],\n         path: path_std!(cx, core::cmp::PartialOrd),\n         additional_bounds: vec![],\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n-        methods: vec![\n-            partial_cmp_def,\n-            md!(\"lt\", true, false),\n-            md!(\"le\", true, true),\n-            md!(\"gt\", false, false),\n-            md!(\"ge\", false, true)\n-        ],\n+        methods: methods,\n         associated_types: Vec::new(),\n     };\n     trait_def.expand(cx, mitem, item, push)"}, {"sha": "6654afd36646549a9efee6440877b9dd1913344e", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/02954ae0a86c5c2f00e9e06b520999c1e67e9cd7/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02954ae0a86c5c2f00e9e06b520999c1e67e9cd7/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=02954ae0a86c5c2f00e9e06b520999c1e67e9cd7", "patch": "@@ -1647,3 +1647,21 @@ pub fn cs_same_method<F>(f: F,\n         }\n     }\n }\n+\n+/// Return true if the type has no value fields\n+/// (for an enum, no variant has any fields)\n+pub fn is_type_without_fields(item: &Annotatable) -> bool {\n+    if let Annotatable::Item(ref item) = *item {\n+        match item.node {\n+            ast::ItemKind::Enum(ref enum_def, _) => {\n+                enum_def.variants.iter().all(|v| v.node.data.fields().is_empty())\n+            }\n+            ast::ItemKind::Struct(ref variant_data, _) => {\n+                variant_data.fields().is_empty()\n+            }\n+            _ => false\n+        }\n+    } else {\n+        false\n+    }\n+}"}]}