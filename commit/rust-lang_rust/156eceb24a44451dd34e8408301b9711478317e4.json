{"sha": "156eceb24a44451dd34e8408301b9711478317e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NmVjZWIyNGE0NDQ1MWRkMzRlODQwODMwMWI5NzExNDc4MzE3ZTQ=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-17T17:24:04Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-17T17:32:52Z"}, "message": "dvec/vec interface cleanup: fixing reach, reverse, adding more pure", "tree": {"sha": "318cea60ac5cce9971d164be2d680c6685019ec3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/318cea60ac5cce9971d164be2d680c6685019ec3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/156eceb24a44451dd34e8408301b9711478317e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/156eceb24a44451dd34e8408301b9711478317e4", "html_url": "https://github.com/rust-lang/rust/commit/156eceb24a44451dd34e8408301b9711478317e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/156eceb24a44451dd34e8408301b9711478317e4/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b67bfe50efcea01a90aff7d13e240a43ecdabd19", "url": "https://api.github.com/repos/rust-lang/rust/commits/b67bfe50efcea01a90aff7d13e240a43ecdabd19", "html_url": "https://github.com/rust-lang/rust/commit/b67bfe50efcea01a90aff7d13e240a43ecdabd19"}], "stats": {"total": 96, "additions": 71, "deletions": 25}, "files": [{"sha": "bdbdb6cef16b5f3e5cd7e253dbae63b280bc694e", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/156eceb24a44451dd34e8408301b9711478317e4/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156eceb24a44451dd34e8408301b9711478317e4/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=156eceb24a44451dd34e8408301b9711478317e4", "patch": "@@ -76,7 +76,7 @@ fn unwrap<A>(-d: dvec<A>) -> ~[mut A] {\n }\n \n impl private_methods<A> for dvec<A> {\n-    fn check_not_borrowed() {\n+    pure fn check_not_borrowed() {\n         unsafe {\n             let data: *() = unsafe::reinterpret_cast(self.data);\n             if data.is_null() {\n@@ -119,11 +119,13 @@ impl extensions<A> for dvec<A> {\n     }\n \n     /// Returns the number of elements currently in the dvec\n-    fn len() -> uint {\n-        do self.borrow |v| {\n-            let l = v.len();\n-            self.return(v);\n-            l\n+    pure fn len() -> uint {\n+        unchecked {\n+            do self.borrow |v| {\n+                let l = v.len();\n+                self.return(v);\n+                l\n+            }\n         }\n     }\n \n@@ -172,6 +174,13 @@ impl extensions<A> for dvec<A> {\n             result\n         }\n     }\n+\n+    // Reverse the elements in the list, in place\n+    fn reverse() {\n+        do self.borrow |v| {\n+            vec::reverse(v);\n+        }\n+    }\n }\n \n impl extensions<A:copy> for dvec<A> {\n@@ -229,23 +238,25 @@ impl extensions<A:copy> for dvec<A> {\n      *\n      * See `unwrap()` if you do not wish to copy the contents.\n      */\n-    fn get() -> ~[A] {\n-        do self.borrow |v| {\n-            let w = vec::from_mut(copy v);\n-            self.return(v);\n-            w\n+    pure fn get() -> ~[A] {\n+        unchecked {\n+            do self.borrow |v| {\n+                let w = vec::from_mut(copy v);\n+                self.return(v);\n+                w\n+            }\n         }\n     }\n \n     /// Copy out an individual element\n     #[inline(always)]\n-    fn [](idx: uint) -> A {\n+    pure fn [](idx: uint) -> A {\n         self.get_elt(idx)\n     }\n \n     /// Copy out an individual element\n     #[inline(always)]\n-    fn get_elt(idx: uint) -> A {\n+    pure fn get_elt(idx: uint) -> A {\n         self.check_not_borrowed();\n         ret self.data[idx];\n     }\n@@ -271,7 +282,7 @@ impl extensions<A:copy> for dvec<A> {\n \n     /// Returns the last element, failing if the vector is empty\n     #[inline(always)]\n-    fn last() -> A {\n+    pure fn last() -> A {\n         self.check_not_borrowed();\n \n         let length = self.len();\n@@ -285,13 +296,12 @@ impl extensions<A:copy> for dvec<A> {\n     /// Iterates over the elements in reverse order\n     #[inline(always)]\n     fn reach(f: fn(A) -> bool) {\n-        let length = self.len();\n-        let mut i = 0u;\n-        while i < length {\n-            if !f(self.get_elt(i)) {\n-                break;\n-            }\n-            i += 1u;\n-        }\n+        do self.swap |v| { vec::reach(v, f); v }\n+    }\n+\n+    /// Iterates over the elements and indices in reverse order\n+    #[inline(always)]\n+    fn reachi(f: fn(uint, A) -> bool) {\n+        do self.swap |v| { vec::reachi(v, f); v }\n     }\n }"}, {"sha": "60e3373fdbe00eeefb37bf4de440abd56ee777ef", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/156eceb24a44451dd34e8408301b9711478317e4/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156eceb24a44451dd34e8408301b9711478317e4/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=156eceb24a44451dd34e8408301b9711478317e4", "patch": "@@ -71,7 +71,7 @@ export zip;\n export swap;\n export reverse;\n export reversed;\n-export iter, iter_between, each, eachi;\n+export iter, iter_between, each, eachi, reach, reachi;\n export iter2;\n export iteri;\n export riter;\n@@ -204,12 +204,12 @@ pure fn from_elem<T: copy>(n_elts: uint, t: T) -> ~[T] {\n }\n \n /// Produces a mut vector from an immutable vector.\n-fn to_mut<T>(+v: ~[T]) -> ~[mut T] {\n+pure fn to_mut<T>(+v: ~[T]) -> ~[mut T] {\n     unsafe { ::unsafe::transmute(v) }\n }\n \n /// Produces an immutable vector from a mut vector.\n-fn from_mut<T>(+v: ~[mut T]) -> ~[T] {\n+pure fn from_mut<T>(+v: ~[mut T]) -> ~[T] {\n     unsafe { ::unsafe::transmute(v) }\n }\n \n@@ -1038,6 +1038,42 @@ pure fn eachi<T>(v: &[const T], f: fn(uint, T) -> bool) {\n     }\n }\n \n+/**\n+ * Iterates over a vector's elements in reverse\n+ *\n+ * Return true to continue, false to break.\n+ */\n+#[inline(always)]\n+pure fn reach<T>(v: &[T], blk: fn(T) -> bool) {\n+    do vec::unpack_slice(v) |p, n| {\n+        let mut i = 1;\n+        while i <= n {\n+            unsafe {\n+                if !blk(*ptr::offset(p, n-i)) { break; }\n+            }\n+            i += 1;\n+        }\n+    }\n+}\n+\n+/**\n+ * Iterates over a vector's elements and indices in reverse\n+ *\n+ * Return true to continue, false to break.\n+ */\n+#[inline(always)]\n+pure fn reachi<T>(v: &[T], blk: fn(uint, T) -> bool) {\n+    do vec::unpack_slice(v) |p, n| {\n+        let mut i = 1;\n+        while i <= n {\n+            unsafe {\n+                if !blk(n-i, *ptr::offset(p, n-i)) { break; }\n+            }\n+            i += 1;\n+        }\n+    }\n+}\n+\n /**\n  * Iterates over two vectors simultaneously\n  *"}]}