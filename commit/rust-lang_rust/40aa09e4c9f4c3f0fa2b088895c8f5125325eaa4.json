{"sha": "40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwYWEwOWU0YzlmNGMzZjBmYTJiMDg4ODk1YzhmNTEyNTMyNWVhYTQ=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-10-08T20:45:46Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-10-13T12:19:25Z"}, "message": "Merge struct fields and struct kind", "tree": {"sha": "0ea29987683fbd21b30e2bc23769517a7984a116", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ea29987683fbd21b30e2bc23769517a7984a116"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "html_url": "https://github.com/rust-lang/rust/commit/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30af54dede8b9f03a83dd5ad588bb430a5a76270", "url": "https://api.github.com/repos/rust-lang/rust/commits/30af54dede8b9f03a83dd5ad588bb430a5a76270", "html_url": "https://github.com/rust-lang/rust/commit/30af54dede8b9f03a83dd5ad588bb430a5a76270"}], "stats": {"total": 370, "additions": 222, "deletions": 148}, "files": [{"sha": "aa5d482b89a831219094ef0dbcbb53cdfc6774ae", "filename": "src/librustc/front/map/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -138,7 +138,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                                         NodeVariant(&**v),\n                                         DefPathData::EnumVariant(v.node.name));\n \n-                    for field in &v.node.data.fields {\n+                    for field in v.node.data.fields() {\n                         self.create_def_with_parent(\n                             Some(variant_def_index),\n                             field.node.id,\n@@ -150,13 +150,13 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n             }\n             ItemStruct(ref struct_def, _) => {\n                 // If this is a tuple-like struct, register the constructor.\n-                if struct_def.kind != VariantKind::Struct {\n+                if !struct_def.is_struct() {\n                     self.insert_def(struct_def.id,\n                                     NodeStructCtor(&**struct_def),\n                                     DefPathData::StructCtor);\n                 }\n \n-                for field in &struct_def.fields {\n+                for field in struct_def.fields() {\n                     self.create_def(field.node.id, DefPathData::Field(field.node.kind));\n                 }\n             }"}, {"sha": "028e1ad5ce97469b935fc50459acd62f18505c73", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -480,9 +480,10 @@ impl<'ast> Map<'ast> {\n                 }\n             }\n             Some(NodeVariant(variant)) => {\n-                match variant.node.data.kind {\n-                    VariantKind::Struct => &variant.node.data,\n-                    _ => panic!(\"struct ID bound to enum variant that isn't struct-like\"),\n+                if variant.node.data.is_struct() {\n+                    &variant.node.data\n+                } else {\n+                    panic!(\"struct ID bound to enum variant that isn't struct-like\")\n                 }\n             }\n             _ => panic!(format!(\"expected struct, found {}\", self.node_to_string(id))),"}, {"sha": "81305099705ce75a546c7418119ed8399f797693", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -381,7 +381,7 @@ fn each_auxiliary_node_id<F>(item: &hir::Item, callback: F) -> bool where\n     match item.node {\n         hir::ItemStruct(ref struct_def, _) => {\n             // If this is a newtype struct, return the constructor.\n-            if struct_def.kind == hir::VariantKind::Tuple {\n+            if struct_def.is_tuple() {\n                 continue_ = callback(struct_def.id);\n             }\n         }\n@@ -1068,7 +1068,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         // Encode inherent implementations for this structure.\n         encode_inherent_implementations(ecx, rbml_w, def_id);\n \n-        if struct_def.kind != hir::VariantKind::Struct {\n+        if !struct_def.is_struct() {\n             let ctor_did = ecx.tcx.map.local_def_id(struct_def.id);\n             rbml_w.wr_tagged_u64(tag_items_data_item_struct_ctor,\n                                  def_to_u64(ctor_did));\n@@ -1081,7 +1081,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         }\n \n         // If this is a tuple-like struct, encode the type of the constructor.\n-        if struct_def.kind != hir::VariantKind::Struct {\n+        if !struct_def.is_struct() {\n             encode_info_for_struct_ctor(ecx, rbml_w, item.name, struct_def.id, index, item.id);\n         }\n       }"}, {"sha": "ca05de81e77c89ed4f815809936e87a36fe7eee3", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -1320,7 +1320,7 @@ fn copy_item_types(dcx: &DecodeContext, ii: &InlinedItem, orig_did: DefId) {\n                 }\n             }\n             hir::ItemStruct(ref def, _) => {\n-                if def.kind != hir::VariantKind::Struct {\n+                if !def.is_struct() {\n                     let ctor_did = dcx.tcx.lookup_adt_def(orig_did)\n                         .struct_variant().did;\n                     debug!(\"astencode: copying ctor {:?} => {:?}\", ctor_did,"}, {"sha": "9d15b53a6d826c68a41e85a7926ec880b0108f03", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -219,7 +219,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n                         _: &hir::Generics, _: ast::NodeId, _: codemap::Span) {\n         let has_extern_repr = self.struct_has_extern_repr;\n         let inherited_pub_visibility = self.inherited_pub_visibility;\n-        let live_fields = def.fields.iter().filter(|f| {\n+        let live_fields = def.fields().filter(|f| {\n             has_extern_repr || inherited_pub_visibility || match f.node.kind {\n                 hir::NamedField(_, hir::Public) => true,\n                 _ => false\n@@ -426,7 +426,7 @@ fn find_live(tcx: &ty::ctxt,\n \n fn get_struct_ctor_id(item: &hir::Item) -> Option<ast::NodeId> {\n     match item.node {\n-        hir::ItemStruct(ref struct_def, _) if struct_def.kind != hir::VariantKind::Struct => {\n+        hir::ItemStruct(ref struct_def, _) if !struct_def.is_struct() => {\n             Some(struct_def.id)\n         }\n         _ => None"}, {"sha": "23bb4a1fe393d5dfe7c523733fe6ec9896568acc", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -185,7 +185,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n                       |v| visit::walk_item(v, i), required);\n \n         if let hir::ItemStruct(ref sd, _) = i.node {\n-            if sd.kind != hir::VariantKind::Struct {\n+            if !sd.is_struct() {\n                 self.annotate(sd.id, true, &i.attrs, i.span, |_| {}, true)\n             }\n         }"}, {"sha": "fd69d2007ff133155f67ceee35d87e79d795dfb1", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -694,11 +694,18 @@ pub fn noop_fold_where_predicate<T: Folder>(pred: WherePredicate, fld: &mut T) -\n }\n \n pub fn noop_fold_struct_def<T: Folder>(struct_def: P<VariantData>, fld: &mut T) -> P<VariantData> {\n-    struct_def.map(|VariantData { fields, id, kind }| {\n+    struct_def.map(|VariantData { data_, id }| {\n         VariantData {\n-            fields: fields.move_map(|f| fld.fold_struct_field(f)),\n+            data_: match data_ {\n+                VariantData_::Struct(fields) => {\n+                    VariantData_::Struct(fields.move_map(|f| fld.fold_struct_field(f)))\n+                }\n+                VariantData_::Tuple(fields) => {\n+                    VariantData_::Tuple(fields.move_map(|f| fld.fold_struct_field(f)))\n+                }\n+                VariantData_::Unit => VariantData_::Unit\n+            },\n             id: fld.new_id(id),\n-            kind: kind,\n         }\n     })\n }"}, {"sha": "b5170b7496b46d1049295c6ea8f9f56d17b5a5b1", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -49,6 +49,7 @@ use print::pprust;\n use util;\n \n use std::fmt;\n+use std::{iter, option, slice};\n use serialize::{Encodable, Encoder, Decoder};\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n@@ -1160,21 +1161,42 @@ impl StructFieldKind {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum VariantKind {\n-    Struct,\n-    Tuple,\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum VariantData_ {\n+    Struct(Vec<StructField>),\n+    Tuple(Vec<StructField>),\n     Unit,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct VariantData {\n-    /// Fields, not including ctor\n-    pub fields: Vec<StructField>,\n+    pub data_: VariantData_,\n     /// ID of the constructor. This is only used for tuple- or enum-like\n     /// structs.\n     pub id: NodeId,\n-    pub kind: VariantKind,\n+}\n+\n+pub type FieldIter<'a> = iter::FlatMap<option::IntoIter<&'a Vec<StructField>>,\n+                                       slice::Iter<'a, StructField>,\n+                                       fn(&Vec<StructField>) -> slice::Iter<StructField>>;\n+\n+impl VariantData {\n+    pub fn fields(&self) -> FieldIter {\n+        fn vec_iter<T>(v: &Vec<T>) -> slice::Iter<T> { v.iter() }\n+        match self.data_ {\n+            VariantData_::Struct(ref fields) | VariantData_::Tuple(ref fields) => Some(fields),\n+            _ => None,\n+        }.into_iter().flat_map(vec_iter)\n+    }\n+    pub fn is_struct(&self) -> bool {\n+        if let VariantData_::Struct(..) = self.data_ { true } else { false }\n+    }\n+    pub fn is_tuple(&self) -> bool {\n+        if let VariantData_::Tuple(..) = self.data_ { true } else { false }\n+    }\n+    pub fn is_unit(&self) -> bool {\n+        if let VariantData_::Unit = self.data_ { true } else { false }\n+    }\n }\n \n /*"}, {"sha": "cd32ad15744bf0a1c0d7505ab3f906a2b034e1ca", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -500,12 +500,15 @@ pub fn lower_where_predicate(_lctx: &LoweringContext,\n \n pub fn lower_struct_def(sd: &VariantData) -> P<hir::VariantData> {\n     P(hir::VariantData {\n-        fields: sd.fields.iter().map(|f| lower_struct_field(_lctx, f)).collect(),\n         id: sd.id,\n-        kind: match sd.kind {\n-            VariantKind::Struct => hir::VariantKind::Struct,\n-            VariantKind::Tuple => hir::VariantKind::Tuple,\n-            VariantKind::Unit => hir::VariantKind::Unit,\n+        data_: match sd.data_ {\n+            VariantData_::Struct(ref fields) => {\n+                hir::VariantData_::Struct(fields.iter().map(|f| lower_struct_field(_lctx, f)).collect())\n+            }\n+            VariantData_::Tuple(ref fields) => {\n+                hir::VariantData_::Tuple(fields.iter().map(|f| lower_struct_field(_lctx, f)).collect())\n+            }\n+            VariantData_::Unit => hir::VariantData_::Unit\n         }\n     })\n }"}, {"sha": "5e78aa5fbc1f8cf66e9af66bdeb41c826b073815", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -896,11 +896,11 @@ impl<'a> State<'a> {\n                         -> io::Result<()> {\n         try!(self.print_name(name));\n         try!(self.print_generics(generics));\n-        if struct_def.kind != hir::VariantKind::Struct {\n-            if struct_def.kind == hir::VariantKind::Tuple {\n+        if !struct_def.is_struct() {\n+            if struct_def.is_tuple() {\n                 try!(self.popen());\n-                try!(self.commasep(Inconsistent,\n-                                   &struct_def.fields,\n+                try!(self.commasep_iter(Inconsistent,\n+                                   struct_def.fields(),\n                                    |s, field| {\n                                        match field.node.kind {\n                                            hir::NamedField(..) => panic!(\"unexpected named field\"),\n@@ -925,7 +925,7 @@ impl<'a> State<'a> {\n             try!(self.bopen());\n             try!(self.hardbreak_if_not_bol());\n \n-            for field in &struct_def.fields {\n+            for field in struct_def.fields() {\n                 match field.node.kind {\n                     hir::UnnamedField(..) => panic!(\"unexpected unnamed field\"),\n                     hir::NamedField(name, visibility) => {"}, {"sha": "00c2c3a3ddd65e1aca2561156be1639cef087d6c", "filename": "src/librustc_front/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_front%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_front%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fvisit.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -629,7 +629,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n }\n \n pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V, struct_definition: &'v VariantData) {\n-    walk_list!(visitor, visit_struct_field, &struct_definition.fields);\n+    walk_list!(visitor, visit_struct_field, struct_definition.fields());\n }\n \n pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V, struct_field: &'v StructField) {"}, {"sha": "693de1740bfee9fdee03e7f453ef361ba40dc583", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -282,7 +282,7 @@ impl LateLintPass for NonSnakeCase {\n \n     fn check_struct_def(&mut self, cx: &LateContext, s: &hir::VariantData,\n                         _: ast::Name, _: &hir::Generics, _: ast::NodeId) {\n-        for sf in &s.fields {\n+        for sf in s.fields() {\n             if let hir::StructField_ { kind: hir::NamedField(name, _), .. } = sf.node {\n                 self.check_snake_case(cx, \"structure field\", &name.as_str(),\n                                       Some(sf.span));"}, {"sha": "ea8ea4ebf0dacaa976a2f440f11fa6504e3de2c7", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -123,7 +123,7 @@ impl LateLintPass for BoxPointers {\n         // If it's a struct, we also have to check the fields' types\n         match it.node {\n             hir::ItemStruct(ref struct_def, _) => {\n-                for struct_field in &struct_def.fields {\n+                for struct_field in struct_def.fields() {\n                     self.check_heap_type(cx, struct_field.span,\n                                          cx.tcx.node_id_to_type(struct_field.node.id));\n                 }"}, {"sha": "b139b275785168a911b820494a65964171c79844", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -132,13 +132,13 @@ impl<'v> Visitor<'v> for ParentVisitor {\n                         _: &'v hir::Generics, item_id: ast::NodeId, _: Span) {\n         // Struct constructors are parented to their struct definitions because\n         // they essentially are the struct definitions.\n-        if s.kind != hir::VariantKind::Struct {\n+        if !s.is_struct() {\n             self.parents.insert(s.id, item_id);\n         }\n \n         // While we have the id of the struct definition, go ahead and parent\n         // all the fields.\n-        for field in &s.fields {\n+        for field in s.fields() {\n             self.parents.insert(field.node.id, self.curparent);\n         }\n         visit::walk_struct_def(self, s)\n@@ -319,11 +319,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n \n             // Struct constructors are public if the struct is all public.\n             hir::ItemStruct(ref def, _) if public_first => {\n-                if def.kind != hir::VariantKind::Struct {\n+                if !def.is_struct() {\n                     self.exported_items.insert(def.id);\n                 }\n                 // fields can be public or private, so lets check\n-                for field in &def.fields {\n+                for field in def.fields() {\n                     let vis = match field.node.kind {\n                         hir::NamedField(_, vis) | hir::UnnamedField(vis) => vis\n                     };\n@@ -1089,7 +1089,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n             }\n         }\n         let check_struct = |def: &hir::VariantData| {\n-            for f in &def.fields {\n+            for f in def.fields() {\n                match f.node.kind {\n                     hir::NamedField(_, p) => check_inherited(tcx, f.span, p),\n                     hir::UnnamedField(..) => {}"}, {"sha": "43943fbb129dc12faa0d81058b41ef9f082aebe5", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -492,9 +492,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             // These items live in both the type and value namespaces.\n             ItemStruct(ref struct_def, _) => {\n                 // Adding to both Type and Value namespaces or just Type?\n-                let (forbid, ctor_id) = match struct_def.kind {\n-                    hir::VariantKind::Struct => (ForbidDuplicateTypesAndModules, None),\n-                    _                     => (ForbidDuplicateTypesAndValues, Some(struct_def.id)),\n+                let (forbid, ctor_id) = if struct_def.is_struct() {\n+                    (ForbidDuplicateTypesAndModules, None)\n+                } else {\n+                    (ForbidDuplicateTypesAndValues, Some(struct_def.id))\n                 };\n \n                 let name_bindings = self.add_child(name, parent, forbid, sp);\n@@ -513,7 +514,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 }\n \n                 // Record the def ID and fields of this struct.\n-                let named_fields = struct_def.fields.iter().filter_map(|f| {\n+                let named_fields = struct_def.fields().filter_map(|f| {\n                     match f.node.kind {\n                         NamedField(name, _) => Some(name),\n                         UnnamedField(_) => None\n@@ -587,14 +588,13 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                        item_id: DefId,\n                                        parent: &Rc<Module>) {\n         let name = variant.node.name;\n-        let is_exported = match variant.node.data.kind {\n-            hir::VariantKind::Struct => {\n-                // Not adding fields for variants as they are not accessed with a self receiver\n-                let variant_def_id = self.ast_map.local_def_id(variant.node.data.id);\n-                self.structs.insert(variant_def_id, Vec::new());\n-                true\n-            }\n-            _ => false,\n+        let is_exported = if variant.node.data.is_struct() {\n+            // Not adding fields for variants as they are not accessed with a self receiver\n+            let variant_def_id = self.ast_map.local_def_id(variant.node.data.id);\n+            self.structs.insert(variant_def_id, Vec::new());\n+            true\n+        } else {\n+            false\n         };\n \n         let child = self.add_child(name, parent,"}, {"sha": "d31b8b6f0e48ddda8ffad42542a2a9892c60609c", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -473,7 +473,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                             &val);\n \n         // fields\n-        for field in &def.fields {\n+        for field in def.fields() {\n             self.process_struct_field_def(field, item.id);\n             self.visit_ty(&field.node.ty);\n         }\n@@ -510,7 +510,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                         &val,\n                                         enum_data.id);\n \n-            for field in &variant.node.data.fields {\n+            for field in variant.node.data.fields() {\n                 self.process_struct_field_def(field, variant.node.data.id);\n                 self.visit_ty(&*field.node.ty);\n             }"}, {"sha": "c692f8a1836054916e2ebcb789e46ab8ac3a75c2", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -2428,12 +2428,12 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n         hir_map::NodeVariant(ref v) => {\n             let llfn;\n-            let fields = if v.node.data.kind == hir::VariantKind::Struct {\n+            let fields = if v.node.data.is_struct() {\n                 ccx.sess().bug(\"struct variant kind unexpected in get_item_val\")\n             } else {\n-                &v.node.data.fields\n+                v.node.data.fields()\n             };\n-            assert!(!fields.is_empty());\n+            assert!(fields.count() != 0);\n             let ty = ccx.tcx().node_id_to_type(id);\n             let parent = ccx.tcx().map.get_parent(id);\n             let enm = ccx.tcx().map.expect_item(parent);\n@@ -2454,12 +2454,11 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n         hir_map::NodeStructCtor(struct_def) => {\n             // Only register the constructor if this is a tuple-like struct.\n-            let ctor_id = match struct_def.kind {\n-                hir::VariantKind::Struct => {\n-                    ccx.sess().bug(\"attempt to register a constructor of \\\n-                                    a non-tuple-like struct\")\n-                }\n-                _ => struct_def.id,\n+            let ctor_id = if struct_def.is_struct() {\n+                ccx.sess().bug(\"attempt to register a constructor of \\\n+                                  a non-tuple-like struct\")\n+            } else {\n+                struct_def.id\n             };\n             let parent = ccx.tcx().map.get_parent(id);\n             let struct_item = ccx.tcx().map.expect_item(parent);"}, {"sha": "c8525e33e2667e6f22619c784cf422f97dd97ace", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -418,7 +418,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n \n         match map_node {\n             hir_map::NodeVariant(v) => {\n-                v.node.data.kind == hir::VariantKind::Tuple\n+                v.node.data.is_tuple()\n             }\n             hir_map::NodeStructCtor(_) => true,\n             _ => false"}, {"sha": "923214a536227e0c2b5c79b854c291ac46853f74", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -115,13 +115,12 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n                     }\n                 }\n                 hir::ItemStruct(ref struct_def, _) => {\n-                    match struct_def.kind {\n-                        hir::VariantKind::Struct => ccx.sess().bug(\"instantiate_inline: called on a \\\n-                                                                 non-tuple struct\"),\n-                        _ => {\n-                            ccx.external().borrow_mut().insert(fn_id, Some(struct_def.id));\n-                            my_id = struct_def.id;\n-                        }\n+                    if struct_def.is_struct() {\n+                        ccx.sess().bug(\"instantiate_inline: called on a \\\n+                                                                 non-tuple struct\")\n+                    } else {\n+                        ccx.external().borrow_mut().insert(fn_id, Some(struct_def.id));\n+                        my_id = struct_def.id;\n                     }\n                 }\n                 _ => ccx.sess().bug(\"instantiate_inline: item has a \\"}, {"sha": "440b667e8012dff22cf739ed0913eb14af14ec24", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -246,7 +246,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         hir_map::NodeStructCtor(struct_def) => {\n             let d = mk_lldecl(abi::Rust);\n             attributes::inline(d, attributes::InlineAttr::Hint);\n-            if struct_def.kind == hir::VariantKind::Struct {\n+            if struct_def.is_struct() {\n                 panic!(\"ast-mapped struct didn't have a ctor id\")\n             }\n             base::trans_tuple_struct(ccx,"}, {"sha": "14947d9955efdce9602e8564b4baf1d9d60f1888", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -627,8 +627,7 @@ fn struct_variant<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                             struct_def: &hir::VariantData)\n                             -> AdtVariant<'tcx> {\n     let fields =\n-        struct_def.fields\n-        .iter()\n+        struct_def.fields()\n         .map(|field| {\n             let field_ty = fcx.tcx().node_id_to_type(field.node.id);\n             let field_ty = fcx.instantiate_type_scheme(field.span,"}, {"sha": "4cfc34dbb2384d836a5d3cf73740a9192e3830d1", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -524,8 +524,7 @@ fn struct_variant<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                             struct_def: &hir::VariantData)\n                             -> AdtVariant<'tcx> {\n     let fields =\n-        struct_def.fields\n-        .iter()\n+        struct_def.fields()\n         .map(|field| {\n             let field_ty = fcx.tcx().node_id_to_type(field.node.id);\n             let field_ty = fcx.instantiate_type_scheme(field.span,"}, {"sha": "44e06688774643879319d58395443a684b09e7ca", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -1010,11 +1010,11 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             let it_def_id = ccx.tcx.map.local_def_id(it.id);\n             let variant = tcx.lookup_adt_def_master(it_def_id).struct_variant();\n \n-            for (f, ty_f) in struct_def.fields.iter().zip(variant.fields.iter()) {\n+            for (f, ty_f) in struct_def.fields().zip(variant.fields.iter()) {\n                 convert_field(ccx, &scheme.generics, &predicates, f, ty_f)\n             }\n \n-            if struct_def.kind != hir::VariantKind::Struct {\n+            if !struct_def.is_struct() {\n                 convert_variant_ctor(tcx, struct_def.id, variant, scheme, predicates);\n             }\n         },\n@@ -1067,7 +1067,7 @@ fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                         variants: &[P<hir::Variant>]) {\n     // fill the field types\n     for (variant, ty_variant) in variants.iter().zip(def.variants.iter()) {\n-        for (f, ty_f) in variant.node.data.fields.iter().zip(ty_variant.fields.iter()) {\n+        for (f, ty_f) in variant.node.data.fields().zip(ty_variant.fields.iter()) {\n             convert_field(ccx, &scheme.generics, &predicates, f, ty_f)\n         }\n \n@@ -1089,7 +1089,7 @@ fn convert_struct_variant<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                 disr_val: ty::Disr,\n                                 def: &hir::VariantData) -> ty::VariantDefData<'tcx, 'tcx> {\n     let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap();\n-    let fields = def.fields.iter().map(|f| {\n+    let fields = def.fields().map(|f| {\n         let fid = tcx.map.local_def_id(f.node.id);\n         match f.node.kind {\n             hir::NamedField(name, vis) => {\n@@ -1125,7 +1125,7 @@ fn convert_struct_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n {\n \n     let did = tcx.map.local_def_id(it.id);\n-    let ctor_id = if def.kind != hir::VariantKind::Struct {\n+    let ctor_id = if !def.is_struct() {\n         tcx.map.local_def_id(def.id)\n     } else {\n         did"}, {"sha": "e5090c167dfe0cb50890bf80ed17cbf6b58dce04", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -1809,7 +1809,7 @@ impl Clean<VariantStruct> for ::rustc_front::hir::VariantData {\n     fn clean(&self, cx: &DocContext) -> VariantStruct {\n         VariantStruct {\n             struct_type: doctree::struct_type_from_def(self),\n-            fields: self.fields.clean(cx),\n+            fields: self.fields().map(|x| x.clean(cx)).collect(),\n             fields_stripped: false,\n         }\n     }\n@@ -1918,12 +1918,12 @@ pub enum VariantKind {\n }\n \n fn struct_def_to_variant_kind(struct_def: &hir::VariantData, cx: &DocContext) -> VariantKind {\n-    if struct_def.kind == hir::VariantKind::Struct {\n+    if struct_def.is_struct() {\n         StructVariant(struct_def.clean(cx))\n-    } else if struct_def.kind == hir::VariantKind::Unit {\n+    } else if struct_def.is_unit() {\n         CLikeVariant\n     } else {\n-        TupleVariant(struct_def.fields.iter().map(|x| x.node.ty.clean(cx)).collect())\n+        TupleVariant(struct_def.fields().map(|x| x.node.ty.clean(cx)).collect())\n     }\n }\n "}, {"sha": "47cc007f605ebd1e10b8579652c24bcab86e0976", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -234,9 +234,9 @@ pub struct Import {\n }\n \n pub fn struct_type_from_def(sd: &hir::VariantData) -> StructType {\n-    if sd.kind != hir::VariantKind::Struct {\n+    if !sd.is_struct() {\n         // We are in a tuple-struct\n-        match sd.fields.len() {\n+        match sd.fields().count() {\n             0 => Unit,\n             1 => Newtype,\n             _ => Tuple"}, {"sha": "19edccc4fe25f0aba5ddd5a665f8fd70baf8306b", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             stab: self.stability(item.id),\n             attrs: item.attrs.clone(),\n             generics: generics.clone(),\n-            fields: sd.fields.clone(),\n+            fields: sd.fields().cloned().collect(),\n             whence: item.span\n         }\n     }"}, {"sha": "34181b2e0971510477d8cd115b9f4b6d4bb61f54", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -65,6 +65,7 @@ use std::fmt;\n use std::rc::Rc;\n use std::borrow::Cow;\n use std::hash::{Hash, Hasher};\n+use std::{iter, option, slice};\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n /// A name is a part of an identifier, representing a string or gensym. It's\n@@ -1740,21 +1741,42 @@ impl StructFieldKind {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum VariantKind {\n-    Struct,\n-    Tuple,\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum VariantData_ {\n+    Struct(Vec<StructField>),\n+    Tuple(Vec<StructField>),\n     Unit,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct VariantData {\n-    /// Fields, not including ctor\n-    pub fields: Vec<StructField>,\n+    pub data_: VariantData_,\n     /// ID of the constructor. This is only used for tuple- or enum-like\n     /// structs.\n     pub id: NodeId,\n-    pub kind: VariantKind,\n+}\n+\n+pub type FieldIter<'a> = iter::FlatMap<option::IntoIter<&'a Vec<StructField>>,\n+                                       slice::Iter<'a, StructField>,\n+                                       fn(&Vec<StructField>) -> slice::Iter<StructField>>;\n+\n+impl VariantData {\n+    pub fn fields(&self) -> FieldIter {\n+        fn vec_iter<T>(v: &Vec<T>) -> slice::Iter<T> { v.iter() }\n+        match self.data_ {\n+            VariantData_::Struct(ref fields) | VariantData_::Tuple(ref fields) => Some(fields),\n+            _ => None,\n+        }.into_iter().flat_map(vec_iter)\n+    }\n+    pub fn is_struct(&self) -> bool {\n+        if let VariantData_::Struct(..) = self.data_ { true } else { false }\n+    }\n+    pub fn is_tuple(&self) -> bool {\n+        if let VariantData_::Tuple(..) = self.data_ { true } else { false }\n+    }\n+    pub fn is_unit(&self) -> bool {\n+        if let VariantData_::Unit = self.data_ { true } else { false }\n+    }\n }\n \n /*"}, {"sha": "739bb36d985257cf0a1bafd798950847f5ad67f3", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -167,13 +167,22 @@ fn fold_item_underscore<F>(cx: &mut Context<F>, item: ast::Item_) -> ast::Item_\n fn fold_struct<F>(cx: &mut Context<F>, def: P<ast::VariantData>) -> P<ast::VariantData> where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n-    def.map(|ast::VariantData { fields, id, kind }| {\n+    def.map(|ast::VariantData { data_, id }| {\n         ast::VariantData {\n-            fields: fields.into_iter().filter(|m| {\n-                (cx.in_cfg)(&m.node.attrs)\n-            }).collect(),\n+            data_: match data_ {\n+                ast::VariantData_::Struct(fields) => {\n+                    ast::VariantData_::Struct(fields.into_iter().filter(|m| {\n+                        (cx.in_cfg)(&m.node.attrs)\n+                    }).collect())\n+                }\n+                ast::VariantData_::Tuple(fields) => {\n+                    ast::VariantData_::Tuple(fields.into_iter().filter(|m| {\n+                        (cx.in_cfg)(&m.node.attrs)\n+                    }).collect())\n+                }\n+                ast::VariantData_::Unit => ast::VariantData_::Unit\n+            },\n             id: id,\n-            kind: kind,\n         }\n     })\n }"}, {"sha": "25657b9c6ccdf41fdfbbf6bdd19bd56fc86d0112", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -1002,15 +1002,18 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             }}\n         }).collect();\n \n-        let kind = if fields.is_empty() { ast::VariantKind::Unit } else { ast::VariantKind::Tuple };\n+        let data_ = if fields.is_empty() {\n+            ast::VariantData_::Unit\n+        } else {\n+            ast::VariantData_::Tuple(fields)\n+        };\n \n         respan(span,\n                ast::Variant_ {\n                    name: name,\n                    attrs: Vec::new(),\n-                   data: P(ast::VariantData { fields: fields,\n-                                           id: ast::DUMMY_NODE_ID,\n-                                           kind: kind }),\n+                   data: P(ast::VariantData { data_: data_,\n+                                           id: ast::DUMMY_NODE_ID}),\n                    disr_expr: None,\n                })\n     }"}, {"sha": "2a5c4993112a992e54edaafb8c94b6e7f5d2d1a7", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -652,7 +652,7 @@ impl<'a> TraitDef<'a> {\n                          struct_def: &'a VariantData,\n                          type_ident: Ident,\n                          generics: &Generics) -> P<ast::Item> {\n-        let field_tys: Vec<P<ast::Ty>> = struct_def.fields.iter()\n+        let field_tys: Vec<P<ast::Ty>> = struct_def.fields()\n             .map(|field| field.node.ty.clone())\n             .collect();\n \n@@ -700,7 +700,7 @@ impl<'a> TraitDef<'a> {\n         let mut field_tys = Vec::new();\n \n         for variant in &enum_def.variants {\n-            field_tys.extend(variant.node.data.fields.iter()\n+            field_tys.extend(variant.node.data.fields()\n                 .map(|field| field.node.ty.clone()));\n         }\n \n@@ -1444,7 +1444,7 @@ impl<'a> TraitDef<'a> {\n                         struct_def: &VariantData) -> StaticFields {\n         let mut named_idents = Vec::new();\n         let mut just_spans = Vec::new();\n-        for field in struct_def.fields.iter(){\n+        for field in struct_def.fields(){\n             let sp = self.set_expn_info(cx, field.span);\n             match field.node.kind {\n                 ast::NamedField(ident, _) => named_idents.push((ident, sp)),\n@@ -1483,15 +1483,15 @@ impl<'a> TraitDef<'a> {\n                              -> (P<ast::Pat>, Vec<(Span, Option<Ident>,\n                                                    P<Expr>,\n                                                    &'a [ast::Attribute])>) {\n-        if struct_def.fields.is_empty() {\n+        if struct_def.fields().count() == 0 {\n             return (cx.pat_enum(self.span, struct_path, vec![]), vec![]);\n         }\n \n         let mut paths = Vec::new();\n         let mut ident_expr = Vec::new();\n         let mut struct_type = Unknown;\n \n-        for (i, struct_field) in struct_def.fields.iter().enumerate() {\n+        for (i, struct_field) in struct_def.fields().enumerate() {\n             let sp = self.set_expn_info(cx, struct_field.span);\n             let opt_id = match struct_field.node.kind {\n                 ast::NamedField(ident, _) if (struct_type == Unknown ||"}, {"sha": "07b587783583e699d1bd6e0c5187999100aa172f", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -95,7 +95,7 @@ fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure\n \n             for variant in &enum_def.variants {\n                 let def = &variant.node.data;\n-                if def.kind != ast::VariantKind::Unit {\n+                if !def.is_unit() {\n                     cx.span_err(trait_span, \"`FromPrimitive` cannot be derived \\\n                                              for enums with non-unit variants\");\n                     return cx.expr_fail(trait_span,"}, {"sha": "be6ad9311114af434c797aec0120439faca7f03d", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -859,11 +859,11 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n \n     fn visit_variant_data(&mut self, s: &'v ast::VariantData, _: ast::Ident,\n                         _: &'v ast::Generics, _: ast::NodeId, span: Span) {\n-        if s.fields.is_empty() {\n-            if s.kind == ast::VariantKind::Struct {\n+        if s.fields().count() == 0 {\n+            if s.is_struct() {\n                 self.gate_feature(\"braced_empty_structs\", span,\n                                   \"empty structs and enum variants with braces are unstable\");\n-            } else if s.kind == ast::VariantKind::Tuple {\n+            } else if s.is_tuple() {\n                 self.context.span_handler.span_err(span, \"empty tuple structs and enum variants \\\n                                                           are not allowed, use unit structs and \\\n                                                           enum variants instead\");"}, {"sha": "329ffb286eb319dbade0bfb37f1335e4fe6723e4", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -815,10 +815,17 @@ pub fn noop_fold_where_predicate<T: Folder>(\n }\n \n pub fn noop_fold_struct_def<T: Folder>(struct_def: P<VariantData>, fld: &mut T) -> P<VariantData> {\n-    struct_def.map(|VariantData { fields, id, kind }| VariantData {\n-        fields: fields.move_map(|f| fld.fold_struct_field(f)),\n+    struct_def.map(|VariantData { data_, id }| VariantData {\n+        data_: match data_ {\n+            ast::VariantData_::Struct(fields) => {\n+                ast::VariantData_::Struct(fields.move_map(|f| fld.fold_struct_field(f)))\n+            }\n+            ast::VariantData_::Tuple(fields) => {\n+                ast::VariantData_::Tuple(fields.move_map(|f| fld.fold_struct_field(f)))\n+            }\n+            ast::VariantData_::Unit => ast::VariantData_::Unit\n+        },\n         id: fld.new_id(id),\n-        kind: kind,\n     })\n }\n "}, {"sha": "2431c8cbe88d8094420387f93f525eeb46f800db", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -45,7 +45,7 @@ use ast::{PatRegion, PatStruct, PatTup, PatVec, PatWild, PatWildMulti};\n use ast::PatWildSingle;\n use ast::{PolyTraitRef, QSelf};\n use ast::{Return, BiShl, BiShr, Stmt, StmtDecl};\n-use ast::{StmtExpr, StmtSemi, StmtMac, VariantData, StructField, VariantKind};\n+use ast::{StmtExpr, StmtSemi, StmtMac, VariantData, StructField, VariantData_};\n use ast::{BiSub, StrStyle};\n use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n use ast::{Delimited, SequenceRepetition, TokenTree, TraitItem, TraitRef};\n@@ -4640,26 +4640,24 @@ impl<'a> Parser<'a> {\n         // Otherwise if we look ahead and see a paren we parse a tuple-style\n         // struct.\n \n-        let (fields, kind) = if self.token.is_keyword(keywords::Where) {\n+        let data_ = if self.token.is_keyword(keywords::Where) {\n             generics.where_clause = try!(self.parse_where_clause());\n             if try!(self.eat(&token::Semi)) {\n                 // If we see a: `struct Foo<T> where T: Copy;` style decl.\n-                (Vec::new(), VariantKind::Unit)\n+                VariantData_::Unit\n             } else {\n                 // If we see: `struct Foo<T> where T: Copy { ... }`\n-                (try!(self.parse_record_struct_body()), VariantKind::Struct)\n+                VariantData_::Struct(try!(self.parse_record_struct_body()))\n             }\n         // No `where` so: `struct Foo<T>;`\n         } else if try!(self.eat(&token::Semi) ){\n-            (Vec::new(), VariantKind::Unit)\n+            VariantData_::Unit\n         // Record-style struct definition\n         } else if self.token == token::OpenDelim(token::Brace) {\n-            let fields = try!(self.parse_record_struct_body());\n-            (fields, VariantKind::Struct)\n+            VariantData_::Struct(try!(self.parse_record_struct_body()))\n         // Tuple-style struct definition with optional where-clause.\n         } else if self.token == token::OpenDelim(token::Paren) {\n-            let fields = try!(self.parse_tuple_struct_body(&mut generics));\n-            (fields, VariantKind::Tuple)\n+            VariantData_::Tuple(try!(self.parse_tuple_struct_body(&mut generics)))\n         } else {\n             let token_str = self.this_token_to_string();\n             return Err(self.fatal(&format!(\"expected `where`, `{{`, `(`, or `;` after struct \\\n@@ -4668,9 +4666,8 @@ impl<'a> Parser<'a> {\n \n         Ok((class_name,\n          ItemStruct(P(ast::VariantData {\n-             fields: fields,\n+             data_: data_,\n              id: ast::DUMMY_NODE_ID,\n-             kind: kind,\n          }), generics),\n          None))\n     }\n@@ -5111,9 +5108,8 @@ impl<'a> Parser<'a> {\n         try!(self.bump());\n \n         Ok(P(VariantData {\n-            fields: fields,\n+            data_: VariantData_::Struct(fields),\n             id: ast::DUMMY_NODE_ID,\n-            kind: VariantKind::Struct,\n         }))\n     }\n \n@@ -5150,19 +5146,16 @@ impl<'a> Parser<'a> {\n                         id: ast::DUMMY_NODE_ID,\n                     }});\n                 }\n-                struct_def = P(VariantData { fields: fields,\n-                                           id: ast::DUMMY_NODE_ID,\n-                                           kind: ast::VariantKind::Tuple });\n+                struct_def = P(VariantData { data_: ast::VariantData_::Tuple(fields),\n+                                           id: ast::DUMMY_NODE_ID});\n             } else if try!(self.eat(&token::Eq) ){\n                 disr_expr = Some(try!(self.parse_expr_nopanic()));\n                 any_disr = disr_expr.as_ref().map(|expr| expr.span);\n-                struct_def = P(VariantData { fields: Vec::new(),\n-                                           id: ast::DUMMY_NODE_ID,\n-                                           kind: ast::VariantKind::Unit });\n+                struct_def = P(VariantData { data_: ast::VariantData_::Unit,\n+                                           id: ast::DUMMY_NODE_ID});\n             } else {\n-                struct_def = P(VariantData { fields: Vec::new(),\n-                                           id: ast::DUMMY_NODE_ID,\n-                                           kind: ast::VariantKind::Unit });\n+                struct_def = P(VariantData { data_: ast::VariantData_::Unit,\n+                                           id: ast::DUMMY_NODE_ID});\n             }\n \n             let vr = ast::Variant_ {"}, {"sha": "161f6243f85ccb404fc0f6debdf1684a662de704", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -520,6 +520,18 @@ pub trait PrintState<'a> {\n         self.end()\n     }\n \n+    fn commasep_iter<'it, T: 'it, F, I>(&mut self, b: Breaks, elts: I, mut op: F) -> io::Result<()>\n+        where F: FnMut(&mut Self, &T) -> io::Result<()>,\n+              I: Iterator<Item=&'it T>,\n+    {\n+        try!(self.rbox(0, b));\n+        let mut first = true;\n+        for elt in elts {\n+            if first { first = false; } else { try!(self.word_space(\",\")); }\n+            try!(op(self, elt));\n+        }\n+        self.end()\n+    }\n \n     fn next_lit(&mut self, pos: BytePos) -> Option<comments::Literal> {\n         let mut cur_lit = self.cur_cmnt_and_lit().cur_lit;\n@@ -1392,11 +1404,11 @@ impl<'a> State<'a> {\n                         print_finalizer: bool) -> io::Result<()> {\n         try!(self.print_ident(ident));\n         try!(self.print_generics(generics));\n-        if struct_def.kind != ast::VariantKind::Struct {\n-            if struct_def.kind == ast::VariantKind::Tuple {\n+        if !struct_def.is_struct() {\n+            if struct_def.is_tuple() {\n                 try!(self.popen());\n-                try!(self.commasep(\n-                    Inconsistent, &struct_def.fields,\n+                try!(self.commasep_iter(\n+                    Inconsistent, struct_def.fields(),\n                     |s, field| {\n                         match field.node.kind {\n                             ast::NamedField(..) => panic!(\"unexpected named field\"),\n@@ -1422,7 +1434,7 @@ impl<'a> State<'a> {\n             try!(self.bopen());\n             try!(self.hardbreak_if_not_bol());\n \n-            for field in &struct_def.fields {\n+            for field in struct_def.fields() {\n                 match field.node.kind {\n                     ast::UnnamedField(..) => panic!(\"unexpected unnamed field\"),\n                     ast::NamedField(ident, visibility) => {\n@@ -3119,9 +3131,8 @@ mod tests {\n             name: ident,\n             attrs: Vec::new(),\n             // making this up as I go.... ?\n-            data: P(ast::VariantData { fields: Vec::new(),\n-                                    id: ast::DUMMY_NODE_ID,\n-                                    kind: ast::VariantKind::Unit }),\n+            data: P(ast::VariantData { data_: ast::VariantData_::Unit,\n+                                    id: ast::DUMMY_NODE_ID}),\n             disr_expr: None,\n         });\n "}, {"sha": "b7d202804c5a42553c8adf8207279604f00c6700", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=40aa09e4c9f4c3f0fa2b088895c8f5125325eaa4", "patch": "@@ -604,7 +604,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n \n pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V,\n                                            struct_definition: &'v VariantData) {\n-    walk_list!(visitor, visit_struct_field, &struct_definition.fields);\n+    walk_list!(visitor, visit_struct_field, struct_definition.fields());\n }\n \n pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V,"}]}