{"sha": "99c258cd742f11de76ca3e57364b4d6438c20cf1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5YzI1OGNkNzQyZjExZGU3NmNhM2U1NzM2NGI0ZDY0MzhjMjBjZjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-17T19:46:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-17T19:46:26Z"}, "message": "auto merge of #13261 : pnkfelix/rust/fsk-fix-12856, r=nikomatsakis\n\nFix #12856.\r\n\r\nI wanted to put this up first because I wanted to get feedback about the second commit in the series, commit 8599236.  Its the more invasive part of the patch and is largely just belt-and-suspenders assertion checking; in the commit message I mentioned at least one other approach we could take here.  Or we could drop the belt-and-suspenders and just rely on the guard added in the first patch, commit 8d6a005 (which is really quite trivial on its own).\r\n\r\nSo any feedback on what would be better is appreciated.\r\n\r\nr? @nikomatsakis", "tree": {"sha": "6df746bbcab8bf1f544ee549ee78ff34b65ac780", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6df746bbcab8bf1f544ee549ee78ff34b65ac780"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99c258cd742f11de76ca3e57364b4d6438c20cf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99c258cd742f11de76ca3e57364b4d6438c20cf1", "html_url": "https://github.com/rust-lang/rust/commit/99c258cd742f11de76ca3e57364b4d6438c20cf1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99c258cd742f11de76ca3e57364b4d6438c20cf1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff0b0d5ceeb94fad1d043a5bd2eb631f1f47caff", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff0b0d5ceeb94fad1d043a5bd2eb631f1f47caff", "html_url": "https://github.com/rust-lang/rust/commit/ff0b0d5ceeb94fad1d043a5bd2eb631f1f47caff"}, {"sha": "3099451020e8ef8dc4c5799e82f926cc364c7034", "url": "https://api.github.com/repos/rust-lang/rust/commits/3099451020e8ef8dc4c5799e82f926cc364c7034", "html_url": "https://github.com/rust-lang/rust/commit/3099451020e8ef8dc4c5799e82f926cc364c7034"}], "stats": {"total": 254, "additions": 219, "deletions": 35}, "files": [{"sha": "f7b444e439f406d378f1fc052359cad43db2cc77", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99c258cd742f11de76ca3e57364b4d6438c20cf1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c258cd742f11de76ca3e57364b4d6438c20cf1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=99c258cd742f11de76ca3e57364b4d6438c20cf1", "patch": "@@ -272,6 +272,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         }\n \n         // Ugh -- but this ensures any new variants won't be forgotten\n+        ast_map::NodeLifetime(..) |\n         ast_map::NodeExpr(..) |\n         ast_map::NodeStmt(..) |\n         ast_map::NodeArg(..) |"}, {"sha": "ecf4f67e7cd736f463983d772f26fadb4185cf9d", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 76, "deletions": 2, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/99c258cd742f11de76ca3e57364b4d6438c20cf1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c258cd742f11de76ca3e57364b4d6438c20cf1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=99c258cd742f11de76ca3e57364b4d6438c20cf1", "patch": "@@ -198,6 +198,7 @@ use arena::Arena;\n use middle::ty;\n use std::fmt;\n use syntax::ast;\n+use syntax::ast_map;\n use syntax::ast_util;\n use syntax::owned_slice::OwnedSlice;\n use syntax::visit;\n@@ -517,6 +518,13 @@ impl<'a> Visitor<()> for ConstraintContext<'a> {\n     }\n }\n \n+/// Is `param_id` a lifetime according to `map`?\n+fn is_lifetime(map: &ast_map::Map, param_id: ast::NodeId) -> bool {\n+    match map.find(param_id) {\n+        Some(ast_map::NodeLifetime(..)) => true, _ => false\n+    }\n+}\n+\n impl<'a> ConstraintContext<'a> {\n     fn tcx(&self) -> &'a ty::ctxt {\n         self.terms_cx.tcx\n@@ -533,6 +541,70 @@ impl<'a> ConstraintContext<'a> {\n         }\n     }\n \n+    fn find_binding_for_lifetime(&self, param_id: ast::NodeId) -> ast::NodeId {\n+        let tcx = self.terms_cx.tcx;\n+        assert!(is_lifetime(&tcx.map, param_id));\n+        match tcx.named_region_map.find(&param_id) {\n+            Some(&ast::DefEarlyBoundRegion(_, lifetime_decl_id))\n+                => lifetime_decl_id,\n+            Some(_) => fail!(\"should not encounter non early-bound cases\"),\n+\n+            // The lookup should only fail when `param_id` is\n+            // itself a lifetime binding: use it as the decl_id.\n+            None    => param_id,\n+        }\n+\n+    }\n+\n+    /// Is `param_id` a type parameter for which we infer variance?\n+    fn is_to_be_inferred(&self, param_id: ast::NodeId) -> bool {\n+        let result = self.terms_cx.inferred_map.contains_key(&param_id);\n+\n+        // To safe-guard against invalid inferred_map constructions,\n+        // double-check if variance is inferred at some use of a type\n+        // parameter (by inspecting parent of its binding declaration\n+        // to see if it is introduced by a type or by a fn/impl).\n+\n+        let check_result = |this:&ConstraintContext| -> bool {\n+            let tcx = this.terms_cx.tcx;\n+            let decl_id = this.find_binding_for_lifetime(param_id);\n+            // Currently only called on lifetimes; double-checking that.\n+            assert!(is_lifetime(&tcx.map, param_id));\n+            let parent_id = tcx.map.get_parent(decl_id);\n+            let parent = tcx.map.find(parent_id).unwrap_or_else(\n+                || fail!(\"tcx.map missing entry for id: {}\", parent_id));\n+\n+            let is_inferred;\n+            macro_rules! cannot_happen { () => { {\n+                fail!(\"invalid parent: {:s} for {:s}\",\n+                      tcx.map.node_to_str(parent_id),\n+                      tcx.map.node_to_str(param_id));\n+            } } }\n+\n+            match parent {\n+                ast_map::NodeItem(p) => {\n+                    match p.node {\n+                        ast::ItemTy(..) |\n+                        ast::ItemEnum(..) |\n+                        ast::ItemStruct(..) |\n+                        ast::ItemTrait(..)   => is_inferred = true,\n+                        ast::ItemFn(..)      => is_inferred = false,\n+                        _                    => cannot_happen!(),\n+                    }\n+                }\n+                ast_map::NodeTraitMethod(..) => is_inferred = false,\n+                ast_map::NodeMethod(_)       => is_inferred = false,\n+                _                            => cannot_happen!(),\n+            }\n+\n+            return is_inferred;\n+        };\n+\n+        assert_eq!(result, check_result(self));\n+\n+        return result;\n+    }\n+\n     fn declared_variance(&self,\n                          param_def_id: ast::DefId,\n                          item_def_id: ast::DefId,\n@@ -788,8 +860,10 @@ impl<'a> ConstraintContext<'a> {\n                                    variance: VarianceTermPtr<'a>) {\n         match region {\n             ty::ReEarlyBound(param_id, _, _) => {\n-                let index = self.inferred_index(param_id);\n-                self.add_constraint(index, variance);\n+                if self.is_to_be_inferred(param_id) {\n+                    let index = self.inferred_index(param_id);\n+                    self.add_constraint(index, variance);\n+                }\n             }\n \n             ty::ReStatic => { }"}, {"sha": "45954800e7e9a0fdc619eb2d162dd5a42481f1f6", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/99c258cd742f11de76ca3e57364b4d6438c20cf1/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c258cd742f11de76ca3e57364b4d6438c20cf1/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=99c258cd742f11de76ca3e57364b4d6438c20cf1", "patch": "@@ -107,6 +107,8 @@ pub enum Node {\n \n     /// NodeStructCtor represents a tuple struct.\n     NodeStructCtor(@StructDef),\n+\n+    NodeLifetime(@Lifetime),\n }\n \n // The odd layout is to bring down the total size.\n@@ -127,6 +129,7 @@ enum MapEntry {\n     EntryLocal(NodeId, @Pat),\n     EntryBlock(NodeId, P<Block>),\n     EntryStructCtor(NodeId, @StructDef),\n+    EntryLifetime(NodeId, @Lifetime),\n \n     // Roots for node trees.\n     RootCrate,\n@@ -153,6 +156,7 @@ impl MapEntry {\n             EntryLocal(id, _) => id,\n             EntryBlock(id, _) => id,\n             EntryStructCtor(id, _) => id,\n+            EntryLifetime(id, _) => id,\n             _ => return None\n         })\n     }\n@@ -170,6 +174,7 @@ impl MapEntry {\n             EntryLocal(_, p) => NodeLocal(p),\n             EntryBlock(_, p) => NodeBlock(p),\n             EntryStructCtor(_, p) => NodeStructCtor(p),\n+            EntryLifetime(_, p) => NodeLifetime(p),\n             _ => return None\n         })\n     }\n@@ -213,6 +218,8 @@ impl Map {\n         self.find_entry(id).and_then(|x| x.to_node())\n     }\n \n+    /// Retrieve the parent NodeId for `id`, or `id` itself if no\n+    /// parent is registered in this map.\n     pub fn get_parent(&self, id: NodeId) -> NodeId {\n         self.find_entry(id).and_then(|x| x.parent()).unwrap_or(id)\n     }\n@@ -500,6 +507,15 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n         SmallVector::one(stmt)\n     }\n \n+    fn fold_type_method(&mut self, m: &TypeMethod) -> TypeMethod {\n+        let parent = self.parent;\n+        self.parent = DUMMY_NODE_ID;\n+        let m = fold::noop_fold_type_method(m, self);\n+        assert_eq!(self.parent, m.id);\n+        self.parent = parent;\n+        m\n+    }\n+\n     fn fold_method(&mut self, m: @Method) -> @Method {\n         let parent = self.parent;\n         self.parent = DUMMY_NODE_ID;\n@@ -522,6 +538,12 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n         self.insert(block.id, EntryBlock(self.parent, block));\n         block\n     }\n+\n+    fn fold_lifetime(&mut self, lifetime: &Lifetime) -> Lifetime {\n+        let lifetime = fold::noop_fold_lifetime(lifetime, self);\n+        self.insert(lifetime.id, EntryLifetime(self.parent, @lifetime));\n+        lifetime\n+    }\n }\n \n pub fn map_crate<F: FoldOps>(krate: Crate, fold_ops: F) -> (Crate, Map) {\n@@ -658,6 +680,9 @@ fn node_id_to_str(map: &Map, id: NodeId) -> ~str {\n         Some(NodeStructCtor(_)) => {\n             format!(\"struct_ctor {} (id={})\", map.path_to_str(id), id)\n         }\n+        Some(NodeLifetime(ref l)) => {\n+            format!(\"lifetime {} (id={})\", pprust::lifetime_to_str(*l), id)\n+        }\n         None => {\n             format!(\"unknown node (id={})\", id)\n         }"}, {"sha": "cc3ae025263d196e03b8ce298f9a55d6a0860df5", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 60, "deletions": 33, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/99c258cd742f11de76ca3e57364b4d6438c20cf1/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c258cd742f11de76ca3e57364b4d6438c20cf1/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=99c258cd742f11de76ca3e57364b4d6438c20cf1", "patch": "@@ -32,14 +32,17 @@ pub trait Folder {\n         view_paths.iter().map(|view_path| {\n             let inner_view_path = match view_path.node {\n                 ViewPathSimple(ref ident, ref path, node_id) => {\n+                    let id = self.new_id(node_id);\n                     ViewPathSimple(ident.clone(),\n                                    self.fold_path(path),\n-                                   self.new_id(node_id))\n+                                   id)\n                 }\n                 ViewPathGlob(ref path, node_id) => {\n-                    ViewPathGlob(self.fold_path(path), self.new_id(node_id))\n+                    let id = self.new_id(node_id);\n+                    ViewPathGlob(self.fold_path(path), id)\n                 }\n                 ViewPathList(ref path, ref path_list_idents, node_id) => {\n+                    let id = self.new_id(node_id);\n                     ViewPathList(self.fold_path(path),\n                                  path_list_idents.iter().map(|path_list_ident| {\n                                     let id = self.new_id(path_list_ident.node\n@@ -55,7 +58,7 @@ pub trait Folder {\n                                             path_list_ident.span)\n                                     }\n                                  }).collect(),\n-                                 self.new_id(node_id))\n+                                 id)\n                 }\n             };\n             @Spanned {\n@@ -78,10 +81,11 @@ pub trait Folder {\n     }\n \n     fn fold_struct_field(&mut self, sf: &StructField) -> StructField {\n+        let id = self.new_id(sf.node.id);\n         Spanned {\n             node: ast::StructField_ {\n                 kind: sf.node.kind,\n-                id: self.new_id(sf.node.id),\n+                id: id,\n                 ty: self.fold_ty(sf.node.ty),\n                 attrs: sf.node.attrs.iter().map(|e| fold_attribute_(*e, self)).collect()\n             },\n@@ -146,6 +150,7 @@ pub trait Folder {\n     }\n \n     fn fold_ty(&mut self, t: P<Ty>) -> P<Ty> {\n+        let id = self.new_id(t.id);\n         let node = match t.node {\n             TyNil | TyBot | TyInfer => t.node.clone(),\n             TyBox(ty) => TyBox(self.fold_ty(ty)),\n@@ -161,7 +166,7 @@ pub trait Folder {\n                     onceness: f.onceness,\n                     bounds: fold_opt_bounds(&f.bounds, self),\n                     decl: self.fold_fn_decl(f.decl),\n-                    lifetimes: f.lifetimes.iter().map(|l| fold_lifetime(l, self)).collect(),\n+                    lifetimes: f.lifetimes.iter().map(|l| self.fold_lifetime(l)).collect(),\n                 }, fold_opt_lifetime(region, self))\n             }\n             TyProc(ref f) => {\n@@ -170,30 +175,31 @@ pub trait Folder {\n                     onceness: f.onceness,\n                     bounds: fold_opt_bounds(&f.bounds, self),\n                     decl: self.fold_fn_decl(f.decl),\n-                    lifetimes: f.lifetimes.iter().map(|l| fold_lifetime(l, self)).collect(),\n+                    lifetimes: f.lifetimes.iter().map(|l| self.fold_lifetime(l)).collect(),\n                 })\n             }\n             TyBareFn(ref f) => {\n                 TyBareFn(@BareFnTy {\n-                    lifetimes: f.lifetimes.iter().map(|l| fold_lifetime(l, self)).collect(),\n+                    lifetimes: f.lifetimes.iter().map(|l| self.fold_lifetime(l)).collect(),\n                     fn_style: f.fn_style,\n                     abi: f.abi,\n                     decl: self.fold_fn_decl(f.decl)\n                 })\n             }\n             TyTup(ref tys) => TyTup(tys.iter().map(|&ty| self.fold_ty(ty)).collect()),\n             TyPath(ref path, ref bounds, id) => {\n+                let id = self.new_id(id);\n                 TyPath(self.fold_path(path),\n                        fold_opt_bounds(bounds, self),\n-                       self.new_id(id))\n+                       id)\n             }\n             TyFixedLengthVec(ty, e) => {\n                 TyFixedLengthVec(self.fold_ty(ty), self.fold_expr(e))\n             }\n             TyTypeof(expr) => TyTypeof(self.fold_expr(expr)),\n         };\n         P(Ty {\n-            id: self.new_id(t.id),\n+            id: id,\n             span: self.new_span(t.span),\n             node: node,\n         })\n@@ -218,6 +224,7 @@ pub trait Folder {\n     }\n \n     fn fold_variant(&mut self, v: &Variant) -> P<Variant> {\n+        let id = self.new_id(v.node.id);\n         let kind;\n         match v.node.kind {\n             TupleVariantKind(ref variant_args) => {\n@@ -243,7 +250,7 @@ pub trait Folder {\n             name: v.node.name,\n             attrs: attrs,\n             kind: kind,\n-            id: self.new_id(v.node.id),\n+            id: id,\n             disr_expr: de,\n             vis: v.node.vis,\n         };\n@@ -263,15 +270,16 @@ pub trait Folder {\n             global: p.global,\n             segments: p.segments.iter().map(|segment| ast::PathSegment {\n                 identifier: self.fold_ident(segment.identifier),\n-                lifetimes: segment.lifetimes.iter().map(|l| fold_lifetime(l, self)).collect(),\n+                lifetimes: segment.lifetimes.iter().map(|l| self.fold_lifetime(l)).collect(),\n                 types: segment.types.iter().map(|&typ| self.fold_ty(typ)).collect(),\n             }).collect()\n         }\n     }\n \n     fn fold_local(&mut self, l: @Local) -> @Local {\n+        let id = self.new_id(l.id); // Needs to be first, for ast_map.\n         @Local {\n-            id: self.new_id(l.id), // Needs to be first, for ast_map.\n+            id: id,\n             ty: self.fold_ty(l.ty),\n             pat: self.fold_pat(l.pat),\n             init: l.init.map(|e| self.fold_expr(e)),\n@@ -319,6 +327,10 @@ pub trait Folder {\n             }\n         }\n     }\n+\n+    fn fold_lifetime(&mut self, l: &Lifetime) -> Lifetime {\n+        noop_fold_lifetime(l, self)\n+    }\n }\n \n /* some little folds that probably aren't useful to have in Folder itself*/\n@@ -353,8 +365,9 @@ fn fold_attribute_<T: Folder>(at: Attribute, fld: &mut T) -> Attribute {\n \n //used in noop_fold_foreign_item and noop_fold_fn_decl\n fn fold_arg_<T: Folder>(a: &Arg, fld: &mut T) -> Arg {\n+    let id = fld.new_id(a.id); // Needs to be first, for ast_map.\n     Arg {\n-        id: fld.new_id(a.id), // Needs to be first, for ast_map.\n+        id: id,\n         ty: fld.fold_ty(a.ty),\n         pat: fld.fold_pat(a.pat),\n     }\n@@ -425,9 +438,10 @@ fn fold_ty_param_bound<T: Folder>(tpb: &TyParamBound, fld: &mut T)\n }\n \n pub fn fold_ty_param<T: Folder>(tp: &TyParam, fld: &mut T) -> TyParam {\n+    let id = fld.new_id(tp.id);\n     TyParam {\n         ident: tp.ident,\n-        id: fld.new_id(tp.id),\n+        id: id,\n         bounds: tp.bounds.map(|x| fold_ty_param_bound(x, fld)),\n         default: tp.default.map(|x| fld.fold_ty(x))\n     }\n@@ -438,22 +452,23 @@ pub fn fold_ty_params<T: Folder>(tps: &OwnedSlice<TyParam>, fld: &mut T)\n     tps.map(|tp| fold_ty_param(tp, fld))\n }\n \n-pub fn fold_lifetime<T: Folder>(l: &Lifetime, fld: &mut T) -> Lifetime {\n+pub fn noop_fold_lifetime<T: Folder>(l: &Lifetime, fld: &mut T) -> Lifetime {\n+    let id = fld.new_id(l.id);\n     Lifetime {\n-        id: fld.new_id(l.id),\n+        id: id,\n         span: fld.new_span(l.span),\n         name: l.name\n     }\n }\n \n pub fn fold_lifetimes<T: Folder>(lts: &Vec<Lifetime>, fld: &mut T)\n                                    -> Vec<Lifetime> {\n-    lts.iter().map(|l| fold_lifetime(l, fld)).collect()\n+    lts.iter().map(|l| fld.fold_lifetime(l)).collect()\n }\n \n pub fn fold_opt_lifetime<T: Folder>(o_lt: &Option<Lifetime>, fld: &mut T)\n                                       -> Option<Lifetime> {\n-    o_lt.as_ref().map(|lt| fold_lifetime(lt, fld))\n+    o_lt.as_ref().map(|lt| fld.fold_lifetime(lt))\n }\n \n pub fn fold_generics<T: Folder>(generics: &Generics, fld: &mut T) -> Generics {\n@@ -469,17 +484,19 @@ fn fold_struct_def<T: Folder>(struct_def: @StructDef, fld: &mut T) -> @StructDef\n }\n \n fn fold_trait_ref<T: Folder>(p: &TraitRef, fld: &mut T) -> TraitRef {\n+    let id = fld.new_id(p.ref_id);\n     ast::TraitRef {\n         path: fld.fold_path(&p.path),\n-        ref_id: fld.new_id(p.ref_id),\n+        ref_id: id,\n     }\n }\n \n fn fold_struct_field<T: Folder>(f: &StructField, fld: &mut T) -> StructField {\n+    let id = fld.new_id(f.node.id);\n     Spanned {\n         node: ast::StructField_ {\n             kind: f.node.kind,\n-            id: fld.new_id(f.node.id),\n+            id: id,\n             ty: fld.fold_ty(f.node.ty),\n             attrs: f.node.attrs.iter().map(|a| fold_attribute_(*a, fld)).collect(),\n         },\n@@ -512,9 +529,10 @@ fn fold_opt_bounds<T: Folder>(b: &Option<OwnedSlice<TyParamBound>>, folder: &mut\n }\n \n fn fold_variant_arg_<T: Folder>(va: &VariantArg, folder: &mut T) -> VariantArg {\n+    let id = folder.new_id(va.id);\n     ast::VariantArg {\n         ty: folder.fold_ty(va.ty),\n-        id: folder.new_id(va.id)\n+        id: id,\n     }\n }\n \n@@ -539,10 +557,11 @@ pub fn noop_fold_view_item<T: Folder>(vi: &ViewItem, folder: &mut T)\n }\n \n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n+    let id = folder.new_id(b.id); // Needs to be first, for ast_map.\n     let view_items = b.view_items.iter().map(|x| folder.fold_view_item(x)).collect();\n     let stmts = b.stmts.iter().flat_map(|s| folder.fold_stmt(*s).move_iter()).collect();\n     P(Block {\n-        id: folder.new_id(b.id), // Needs to be first, for ast_map.\n+        id: id,\n         view_items: view_items,\n         stmts: stmts,\n         expr: b.expr.map(|x| folder.fold_expr(x)),\n@@ -606,8 +625,9 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_\n }\n \n pub fn noop_fold_type_method<T: Folder>(m: &TypeMethod, fld: &mut T) -> TypeMethod {\n+    let id = fld.new_id(m.id); // Needs to be first, for ast_map.\n     TypeMethod {\n-        id: fld.new_id(m.id), // Needs to be first, for ast_map.\n+        id: id,\n         ident: fld.fold_ident(m.ident),\n         attrs: m.attrs.iter().map(|a| fold_attribute_(*a, fld)).collect(),\n         fn_style: m.fn_style,\n@@ -658,8 +678,9 @@ pub fn noop_fold_item<T: Folder>(i: &Item, folder: &mut T) -> SmallVector<@Item>\n }\n \n pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem, folder: &mut T) -> @ForeignItem {\n+    let id = folder.new_id(ni.id); // Needs to be first, for ast_map.\n     @ForeignItem {\n-        id: folder.new_id(ni.id), // Needs to be first, for ast_map.\n+        id: id,\n         ident: folder.fold_ident(ni.ident),\n         attrs: ni.attrs.iter().map(|x| fold_attribute_(*x, folder)).collect(),\n         node: match ni.node {\n@@ -681,8 +702,9 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem, folder: &mut T) -> @F\n }\n \n pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> @Method {\n+    let id = folder.new_id(m.id); // Needs to be first, for ast_map.\n     @Method {\n-        id: folder.new_id(m.id), // Needs to be first, for ast_map.\n+        id: id,\n         ident: folder.fold_ident(m.ident),\n         attrs: m.attrs.iter().map(|a| fold_attribute_(*a, folder)).collect(),\n         generics: fold_generics(&m.generics, folder),\n@@ -696,6 +718,7 @@ pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> @Method {\n }\n \n pub fn noop_fold_pat<T: Folder>(p: @Pat, folder: &mut T) -> @Pat {\n+    let id = folder.new_id(p.id);\n     let node = match p.node {\n         PatWild => PatWild,\n         PatWildMulti => PatWildMulti,\n@@ -733,13 +756,14 @@ pub fn noop_fold_pat<T: Folder>(p: @Pat, folder: &mut T) -> @Pat {\n     };\n \n     @Pat {\n-        id: folder.new_id(p.id),\n+        id: id,\n         span: folder.new_span(p.span),\n         node: node,\n     }\n }\n \n pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n+    let id = folder.new_id(e.id);\n     let node = match e.node {\n         ExprVstore(e, v) => {\n             ExprVstore(folder.fold_expr(e), v)\n@@ -849,24 +873,27 @@ pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n     };\n \n     @Expr {\n-        id: folder.new_id(e.id),\n+        id: id,\n         node: node,\n         span: folder.new_span(e.span),\n     }\n }\n \n pub fn noop_fold_stmt<T: Folder>(s: &Stmt, folder: &mut T) -> SmallVector<@Stmt> {\n     let nodes = match s.node {\n-        StmtDecl(d, nid) => {\n+        StmtDecl(d, id) => {\n+            let id = folder.new_id(id);\n             folder.fold_decl(d).move_iter()\n-                    .map(|d| StmtDecl(d, folder.new_id(nid)))\n+                    .map(|d| StmtDecl(d, id))\n                     .collect()\n         }\n-        StmtExpr(e, nid) => {\n-            SmallVector::one(StmtExpr(folder.fold_expr(e), folder.new_id(nid)))\n+        StmtExpr(e, id) => {\n+            let id = folder.new_id(id);\n+            SmallVector::one(StmtExpr(folder.fold_expr(e), id))\n         }\n-        StmtSemi(e, nid) => {\n-            SmallVector::one(StmtSemi(folder.fold_expr(e), folder.new_id(nid)))\n+        StmtSemi(e, id) => {\n+            let id = folder.new_id(id);\n+            SmallVector::one(StmtSemi(folder.fold_expr(e), id))\n         }\n         StmtMac(ref mac, semi) => SmallVector::one(StmtMac(folder.fold_mac(mac), semi))\n     };"}, {"sha": "429540efd37e772a16dbf1f284ed278a5dc166b1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99c258cd742f11de76ca3e57364b4d6438c20cf1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c258cd742f11de76ca3e57364b4d6438c20cf1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=99c258cd742f11de76ca3e57364b4d6438c20cf1", "patch": "@@ -183,6 +183,18 @@ pub fn generics_to_str(generics: &ast::Generics) -> ~str {\n     to_str(|s| s.print_generics(generics))\n }\n \n+pub fn ty_method_to_str(p: &ast::TypeMethod) -> ~str {\n+    to_str(|s| s.print_ty_method(p))\n+}\n+\n+pub fn method_to_str(p: &ast::Method) -> ~str {\n+    to_str(|s| s.print_method(p))\n+}\n+\n+pub fn fn_block_to_str(p: &ast::FnDecl) -> ~str {\n+    to_str(|s| s.print_fn_block_args(p))\n+}\n+\n pub fn path_to_str(p: &ast::Path) -> ~str {\n     to_str(|s| s.print_path(p, false))\n }"}, {"sha": "3814de79bb6b3413789e4c0b2512b5e01ae4ec15", "filename": "src/test/run-pass/regions-no-variance-from-fn-generics.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/99c258cd742f11de76ca3e57364b4d6438c20cf1/src%2Ftest%2Frun-pass%2Fregions-no-variance-from-fn-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c258cd742f11de76ca3e57364b4d6438c20cf1/src%2Ftest%2Frun-pass%2Fregions-no-variance-from-fn-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-no-variance-from-fn-generics.rs?ref=99c258cd742f11de76ca3e57364b4d6438c20cf1", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #12856: a lifetime formal binding introduced by a generic fn\n+// should not upset the variance inference for actual occurrences of\n+// that lifetime in type expressions.\n+\n+trait HasLife<'a> { }\n+\n+trait UseLife01 {\n+    fn refs<'a, H: HasLife<'a>>(&'a self) -> H;\n+}\n+\n+trait UseLife02 {\n+    fn refs<'a, T, H: HasType<&'a T>>(&'a self) -> H;\n+}\n+\n+\n+trait HasType<T> { }\n+\n+trait UseLife03<T> {\n+    fn refs<'a, H: HasType<&'a T>>(&'a self) -> H;\n+}\n+\n+\n+// (The functions below were not actually a problem observed during\n+// fixing of #12856; they just seem like natural tests to put in to\n+// cover a couple more points in the testing space)\n+\n+pub fn top_refs_1<'a, H: HasLife<'a>>(_s: &'a ()) -> H {\n+    unimplemented!()\n+}\n+\n+pub fn top_refs_2<'a, T, H: HasType<&'a T>>(_s: &'a ()) -> H {\n+    unimplemented!()\n+}\n+\n+pub fn main() {}"}]}