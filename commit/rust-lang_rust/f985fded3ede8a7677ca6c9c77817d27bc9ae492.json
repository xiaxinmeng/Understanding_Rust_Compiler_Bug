{"sha": "f985fded3ede8a7677ca6c9c77817d27bc9ae492", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ODVmZGVkM2VkZThhNzY3N2NhNmM5Yzc3ODE3ZDI3YmM5YWU0OTI=", "commit": {"author": {"name": "Michael Bebenita", "email": "mbebenita@mozilla.com", "date": "2010-09-09T23:01:49Z"}, "committer": {"name": "Michael Bebenita", "email": "mbebenita@mozilla.com", "date": "2010-09-10T21:38:31Z"}, "message": "Added lock_and_signal::signal_all(), and made the rust_kernel::join() use wait instead of yield.", "tree": {"sha": "bf956b68b6b5dfd8744a1b14e55425fac5ce6c3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf956b68b6b5dfd8744a1b14e55425fac5ce6c3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f985fded3ede8a7677ca6c9c77817d27bc9ae492", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f985fded3ede8a7677ca6c9c77817d27bc9ae492", "html_url": "https://github.com/rust-lang/rust/commit/f985fded3ede8a7677ca6c9c77817d27bc9ae492", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f985fded3ede8a7677ca6c9c77817d27bc9ae492/comments", "author": {"login": "mbebenita", "id": 311082, "node_id": "MDQ6VXNlcjMxMTA4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/311082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbebenita", "html_url": "https://github.com/mbebenita", "followers_url": "https://api.github.com/users/mbebenita/followers", "following_url": "https://api.github.com/users/mbebenita/following{/other_user}", "gists_url": "https://api.github.com/users/mbebenita/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbebenita/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbebenita/subscriptions", "organizations_url": "https://api.github.com/users/mbebenita/orgs", "repos_url": "https://api.github.com/users/mbebenita/repos", "events_url": "https://api.github.com/users/mbebenita/events{/privacy}", "received_events_url": "https://api.github.com/users/mbebenita/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mbebenita", "id": 311082, "node_id": "MDQ6VXNlcjMxMTA4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/311082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbebenita", "html_url": "https://github.com/mbebenita", "followers_url": "https://api.github.com/users/mbebenita/followers", "following_url": "https://api.github.com/users/mbebenita/following{/other_user}", "gists_url": "https://api.github.com/users/mbebenita/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbebenita/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbebenita/subscriptions", "organizations_url": "https://api.github.com/users/mbebenita/orgs", "repos_url": "https://api.github.com/users/mbebenita/repos", "events_url": "https://api.github.com/users/mbebenita/events{/privacy}", "received_events_url": "https://api.github.com/users/mbebenita/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79dc07d6487612ebf9ac62e43a5729ea774488b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/79dc07d6487612ebf9ac62e43a5729ea774488b9", "html_url": "https://github.com/rust-lang/rust/commit/79dc07d6487612ebf9ac62e43a5729ea774488b9"}], "stats": {"total": 47, "additions": 31, "deletions": 16}, "files": [{"sha": "549b85d348cc251adafc6fa5c41db2e503cf8450", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f985fded3ede8a7677ca6c9c77817d27bc9ae492/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f985fded3ede8a7677ca6c9c77817d27bc9ae492/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=f985fded3ede8a7677ca6c9c77817d27bc9ae492", "patch": "@@ -22,7 +22,7 @@ rust_kernel::create_domain(const rust_crate *crate, const char *name) {\n     message_queue->associate(handle);\n     domains.append(dom);\n     message_queues.append(message_queue);\n-    _kernel_lock.signal();\n+    _kernel_lock.signal_all();\n     _kernel_lock.unlock();\n     return handle;\n }\n@@ -37,7 +37,7 @@ rust_kernel::destroy_domain(rust_dom *dom) {\n     rust_srv *srv = dom->srv;\n     delete dom;\n     delete srv;\n-    _kernel_lock.signal();\n+    _kernel_lock.signal_all();\n     _kernel_lock.unlock();\n }\n \n@@ -91,10 +91,11 @@ rust_kernel::get_port_handle(rust_port *port) {\n \n void\n rust_kernel::join_all_domains() {\n-    // TODO: Perhaps we can do this a little smarter. Just spin wait for now.\n+    _kernel_lock.lock();\n     while (domains.length() > 0) {\n-        sync::yield();\n+        _kernel_lock.wait();\n     }\n+    _kernel_lock.unlock();\n     log(rust_log::KERN, \"joined domains\");\n }\n \n@@ -162,7 +163,7 @@ rust_kernel::terminate_kernel_loop() {\n     log(rust_log::KERN, \"terminating kernel loop\");\n     _interrupt_kernel_loop = true;\n     _kernel_lock.lock();\n-    _kernel_lock.signal();\n+    _kernel_lock.signal_all();\n     _kernel_lock.unlock();\n     join();\n }"}, {"sha": "f85d55ac201994b0c8302089b1fec9c4cfd8a2c6", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f985fded3ede8a7677ca6c9c77817d27bc9ae492/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/f985fded3ede8a7677ca6c9c77817d27bc9ae492/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=f985fded3ede8a7677ca6c9c77817d27bc9ae492", "patch": "@@ -75,8 +75,6 @@ class rust_kernel : public rust_thread {\n      * live on after their associated domain has died. This way we can safely\n      * communicate with domains that may have died.\n      *\n-     * Although the message_queues list is synchronized, each individual\n-     * message queue is lock free.\n      */\n     indexed_list<rust_message_queue> message_queues;\n "}, {"sha": "7a5d26fc6a913f0a8adea978ceafdc1749b46268", "filename": "src/rt/sync/lock_and_signal.cpp", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f985fded3ede8a7677ca6c9c77817d27bc9ae492/src%2Frt%2Fsync%2Flock_and_signal.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f985fded3ede8a7677ca6c9c77817d27bc9ae492/src%2Frt%2Fsync%2Flock_and_signal.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.cpp?ref=f985fded3ede8a7677ca6c9c77817d27bc9ae492", "patch": "@@ -11,7 +11,12 @@\n \n #if defined(__WIN32__)\n lock_and_signal::lock_and_signal() {\n-    _event = CreateEvent(NULL, FALSE, FALSE, NULL);\n+    // TODO: In order to match the behavior of pthread_cond_broadcast on\n+    // Windows, we create manual reset events. This however breaks the\n+    // behavior of pthread_cond_signal, fixing this is quite involved:\n+    // refer to: http://www.cs.wustl.edu/~schmidt/win32-cv-1.html\n+\n+    _event = CreateEvent(NULL, TRUE, FALSE, NULL);\n     InitializeCriticalSection(&_cs);\n }\n \n@@ -33,21 +38,20 @@ lock_and_signal::~lock_and_signal() {\n \n void lock_and_signal::lock() {\n #if defined(__WIN32__)\n-  EnterCriticalSection(&_cs);\n+    EnterCriticalSection(&_cs);\n #else\n-  pthread_mutex_lock(&_mutex);\n+    pthread_mutex_lock(&_mutex);\n #endif\n }\n \n void lock_and_signal::unlock() {\n #if defined(__WIN32__)\n-  LeaveCriticalSection(&_cs);\n+    LeaveCriticalSection(&_cs);\n #else\n-  pthread_mutex_unlock(&_mutex);\n+    pthread_mutex_unlock(&_mutex);\n #endif\n }\n \n-\n /**\n  * Wait indefinitely until condition is signaled.\n  */\n@@ -57,9 +61,9 @@ void lock_and_signal::wait() {\n \n void lock_and_signal::timed_wait(size_t timeout_in_ns) {\n #if defined(__WIN32__)\n-  LeaveCriticalSection(&_cs);\n-  WaitForSingleObject(_event, INFINITE);\n-  EnterCriticalSection(&_cs);\n+    LeaveCriticalSection(&_cs);\n+    WaitForSingleObject(_event, INFINITE);\n+    EnterCriticalSection(&_cs);\n #else\n     if (timeout_in_ns == 0) {\n         pthread_cond_wait(&_cond, &_mutex);\n@@ -85,6 +89,17 @@ void lock_and_signal::signal() {\n #endif\n }\n \n+/**\n+ * Signal condition, and resume all waiting threads.\n+ */\n+void lock_and_signal::signal_all() {\n+#if defined(__WIN32__)\n+    SetEvent(_event);\n+#else\n+    pthread_cond_broadcast(&_cond);\n+#endif\n+}\n+\n \n //\n // Local Variables:"}, {"sha": "1f1cfb4124b2364f79b0af59091b19b2b3e319d6", "filename": "src/rt/sync/lock_and_signal.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f985fded3ede8a7677ca6c9c77817d27bc9ae492/src%2Frt%2Fsync%2Flock_and_signal.h", "raw_url": "https://github.com/rust-lang/rust/raw/f985fded3ede8a7677ca6c9c77817d27bc9ae492/src%2Frt%2Fsync%2Flock_and_signal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.h?ref=f985fded3ede8a7677ca6c9c77817d27bc9ae492", "patch": "@@ -18,6 +18,7 @@ class lock_and_signal {\n     void wait();\n     void timed_wait(size_t timeout_in_ns);\n     void signal();\n+    void signal_all();\n };\n \n #endif /* LOCK_AND_SIGNAL_H */"}]}