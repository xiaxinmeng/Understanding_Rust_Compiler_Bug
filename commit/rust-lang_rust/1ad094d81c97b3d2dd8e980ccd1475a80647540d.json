{"sha": "1ad094d81c97b3d2dd8e980ccd1475a80647540d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhZDA5NGQ4MWM5N2IzZDJkZDhlOTgwY2NkMTQ3NWE4MDY0NzU0MGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-18T06:02:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-18T06:02:35Z"}, "message": "Auto merge of #47687 - SimonSapin:panic-impl, r=sfackler\n\nRFC 2070 part 1: PanicInfo and Location API changes\n\nThis implements part of https://rust-lang.github.io/rfcs/2070-panic-implementation.html\nTracking issue: https://github.com/rust-lang/rust/issues/44489\n\n* Move `std::panic::PanicInfo` and `std::panic::Location` to a new `core::panic` module. The two types and the `std` module were already `#[stable]` and stay that way, the new `core` module is `#[unstable]`.\n* Add a new `PanicInfo::message(&self) -> Option<&fmt::Arguments>` method, which is `#[unstable]`.\n* Implement `Display` for `PanicInfo` and `Location`", "tree": {"sha": "4ef130d008fe8e80a59a72d974eba196832a7fb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ef130d008fe8e80a59a72d974eba196832a7fb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ad094d81c97b3d2dd8e980ccd1475a80647540d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ad094d81c97b3d2dd8e980ccd1475a80647540d", "html_url": "https://github.com/rust-lang/rust/commit/1ad094d81c97b3d2dd8e980ccd1475a80647540d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ad094d81c97b3d2dd8e980ccd1475a80647540d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8f03b9438d6516fd7067cfda2f09c925d6d92f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8f03b9438d6516fd7067cfda2f09c925d6d92f2", "html_url": "https://github.com/rust-lang/rust/commit/e8f03b9438d6516fd7067cfda2f09c925d6d92f2"}, {"sha": "399dcd112725a35352075262863781b3355452cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/399dcd112725a35352075262863781b3355452cd", "html_url": "https://github.com/rust-lang/rust/commit/399dcd112725a35352075262863781b3355452cd"}], "stats": {"total": 478, "additions": 279, "deletions": 199}, "files": [{"sha": "372d606e4572222c1423ce6de400ef72c026c329", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ad094d81c97b3d2dd8e980ccd1475a80647540d/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad094d81c97b3d2dd8e980ccd1475a80647540d/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=1ad094d81c97b3d2dd8e980ccd1475a80647540d", "patch": "@@ -232,7 +232,7 @@ unsafe impl Alloc for Heap {\n ///\n /// This preserves the non-null invariant for types like `Box<T>`. The address\n /// may overlap with non-zero-size memory allocations.\n-#[rustc_deprecated(since = \"1.19\", reason = \"Use Unique/NonNull::empty() instead\")]\n+#[rustc_deprecated(since = \"1.19.0\", reason = \"Use Unique/NonNull::empty() instead\")]\n #[unstable(feature = \"heap_api\", issue = \"27700\")]\n pub const EMPTY: *mut () = 1 as *mut ();\n "}, {"sha": "d2162d307e038e260500d217cc54a9ef541399ff", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ad094d81c97b3d2dd8e980ccd1475a80647540d/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad094d81c97b3d2dd8e980ccd1475a80647540d/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=1ad094d81c97b3d2dd8e980ccd1475a80647540d", "patch": "@@ -160,6 +160,7 @@ pub mod array;\n pub mod sync;\n pub mod cell;\n pub mod char;\n+pub mod panic;\n pub mod panicking;\n pub mod iter;\n pub mod option;"}, {"sha": "4e72eaa57c73e9c6e3be208fb68f5246cfee6f0c", "filename": "src/libcore/panic.rs", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/1ad094d81c97b3d2dd8e980ccd1475a80647540d/src%2Flibcore%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad094d81c97b3d2dd8e980ccd1475a80647540d/src%2Flibcore%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanic.rs?ref=1ad094d81c97b3d2dd8e980ccd1475a80647540d", "patch": "@@ -0,0 +1,251 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Panic support in the standard library.\n+\n+#![unstable(feature = \"core_panic_info\",\n+            reason = \"newly available in libcore\",\n+            issue = \"44489\")]\n+\n+use any::Any;\n+use fmt;\n+\n+/// A struct providing information about a panic.\n+///\n+/// `PanicInfo` structure is passed to a panic hook set by the [`set_hook`]\n+/// function.\n+///\n+/// [`set_hook`]: ../../std/panic/fn.set_hook.html\n+///\n+/// # Examples\n+///\n+/// ```should_panic\n+/// use std::panic;\n+///\n+/// panic::set_hook(Box::new(|panic_info| {\n+///     println!(\"panic occurred: {:?}\", panic_info.payload().downcast_ref::<&str>().unwrap());\n+/// }));\n+///\n+/// panic!(\"Normal panic\");\n+/// ```\n+#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+#[derive(Debug)]\n+pub struct PanicInfo<'a> {\n+    payload: &'a (Any + Send),\n+    message: Option<&'a fmt::Arguments<'a>>,\n+    location: Location<'a>,\n+}\n+\n+impl<'a> PanicInfo<'a> {\n+    #![unstable(feature = \"panic_internals\",\n+                reason = \"internal details of the implementation of the `panic!` \\\n+                          and related macros\",\n+                issue = \"0\")]\n+    #[doc(hidden)]\n+    pub fn internal_constructor(payload: &'a (Any + Send),\n+                                message: Option<&'a fmt::Arguments<'a>>,\n+                                location: Location<'a>)\n+                                -> Self {\n+        PanicInfo { payload, location, message }\n+    }\n+\n+    /// Returns the payload associated with the panic.\n+    ///\n+    /// This will commonly, but not always, be a `&'static str` or [`String`].\n+    ///\n+    /// [`String`]: ../../std/string/struct.String.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```should_panic\n+    /// use std::panic;\n+    ///\n+    /// panic::set_hook(Box::new(|panic_info| {\n+    ///     println!(\"panic occurred: {:?}\", panic_info.payload().downcast_ref::<&str>().unwrap());\n+    /// }));\n+    ///\n+    /// panic!(\"Normal panic\");\n+    /// ```\n+    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+    pub fn payload(&self) -> &(Any + Send) {\n+        self.payload\n+    }\n+\n+    /// If the `panic!` macro from the `core` crate (not from `std`)\n+    /// was used with a formatting string and some additional arguments,\n+    /// returns that message ready to be used for example with [`fmt::write`]\n+    ///\n+    /// [`fmt::write`]: ../fmt/fn.write.html\n+    #[unstable(feature = \"panic_info_message\", issue = \"44489\")]\n+    pub fn message(&self) -> Option<&fmt::Arguments> {\n+        self.message\n+    }\n+\n+    /// Returns information about the location from which the panic originated,\n+    /// if available.\n+    ///\n+    /// This method will currently always return [`Some`], but this may change\n+    /// in future versions.\n+    ///\n+    /// [`Some`]: ../../std/option/enum.Option.html#variant.Some\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```should_panic\n+    /// use std::panic;\n+    ///\n+    /// panic::set_hook(Box::new(|panic_info| {\n+    ///     if let Some(location) = panic_info.location() {\n+    ///         println!(\"panic occurred in file '{}' at line {}\", location.file(),\n+    ///             location.line());\n+    ///     } else {\n+    ///         println!(\"panic occurred but can't get location information...\");\n+    ///     }\n+    /// }));\n+    ///\n+    /// panic!(\"Normal panic\");\n+    /// ```\n+    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+    pub fn location(&self) -> Option<&Location> {\n+        // NOTE: If this is changed to sometimes return None,\n+        // deal with that case in std::panicking::default_hook.\n+        Some(&self.location)\n+    }\n+}\n+\n+impl<'a> fmt::Display for PanicInfo<'a> {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        formatter.write_str(\"panicked at \")?;\n+        if let Some(message) = self.message {\n+            write!(formatter, \"'{}', \", message)?\n+        } else if let Some(payload) = self.payload.downcast_ref::<&'static str>() {\n+            write!(formatter, \"'{}', \", payload)?\n+        }\n+        // NOTE: we cannot use downcast_ref::<String>() here\n+        // since String is not available in libcore!\n+        // The payload is a String when `std::panic!` is called with multiple arguments,\n+        // but in that case the message is also available.\n+\n+        self.location.fmt(formatter)\n+    }\n+}\n+\n+/// A struct containing information about the location of a panic.\n+///\n+/// This structure is created by the [`location`] method of [`PanicInfo`].\n+///\n+/// [`location`]: ../../std/panic/struct.PanicInfo.html#method.location\n+/// [`PanicInfo`]: ../../std/panic/struct.PanicInfo.html\n+///\n+/// # Examples\n+///\n+/// ```should_panic\n+/// use std::panic;\n+///\n+/// panic::set_hook(Box::new(|panic_info| {\n+///     if let Some(location) = panic_info.location() {\n+///         println!(\"panic occurred in file '{}' at line {}\", location.file(), location.line());\n+///     } else {\n+///         println!(\"panic occurred but can't get location information...\");\n+///     }\n+/// }));\n+///\n+/// panic!(\"Normal panic\");\n+/// ```\n+#[derive(Debug)]\n+#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+pub struct Location<'a> {\n+    file: &'a str,\n+    line: u32,\n+    col: u32,\n+}\n+\n+impl<'a> Location<'a> {\n+    #![unstable(feature = \"panic_internals\",\n+                reason = \"internal details of the implementation of the `panic!` \\\n+                          and related macros\",\n+                issue = \"0\")]\n+    #[doc(hidden)]\n+    pub fn internal_constructor(file: &'a str, line: u32, col: u32) -> Self {\n+        Location { file, line, col }\n+    }\n+\n+    /// Returns the name of the source file from which the panic originated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```should_panic\n+    /// use std::panic;\n+    ///\n+    /// panic::set_hook(Box::new(|panic_info| {\n+    ///     if let Some(location) = panic_info.location() {\n+    ///         println!(\"panic occurred in file '{}'\", location.file());\n+    ///     } else {\n+    ///         println!(\"panic occurred but can't get location information...\");\n+    ///     }\n+    /// }));\n+    ///\n+    /// panic!(\"Normal panic\");\n+    /// ```\n+    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+    pub fn file(&self) -> &str {\n+        self.file\n+    }\n+\n+    /// Returns the line number from which the panic originated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```should_panic\n+    /// use std::panic;\n+    ///\n+    /// panic::set_hook(Box::new(|panic_info| {\n+    ///     if let Some(location) = panic_info.location() {\n+    ///         println!(\"panic occurred at line {}\", location.line());\n+    ///     } else {\n+    ///         println!(\"panic occurred but can't get location information...\");\n+    ///     }\n+    /// }));\n+    ///\n+    /// panic!(\"Normal panic\");\n+    /// ```\n+    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+    pub fn line(&self) -> u32 {\n+        self.line\n+    }\n+\n+    /// Returns the column from which the panic originated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```should_panic\n+    /// use std::panic;\n+    ///\n+    /// panic::set_hook(Box::new(|panic_info| {\n+    ///     if let Some(location) = panic_info.location() {\n+    ///         println!(\"panic occurred at column {}\", location.column());\n+    ///     } else {\n+    ///         println!(\"panic occurred but can't get location information...\");\n+    ///     }\n+    /// }));\n+    ///\n+    /// panic!(\"Normal panic\");\n+    /// ```\n+    #[stable(feature = \"panic_col\", since = \"1.25.0\")]\n+    pub fn column(&self) -> u32 {\n+        self.col\n+    }\n+}\n+\n+impl<'a> fmt::Display for Location<'a> {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        write!(formatter, \"{}:{}:{}\", self.file, self.line, self.col)\n+    }\n+}"}, {"sha": "3c9004cdd19bc25aad41a1fc3d080cbec345bb6e", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ad094d81c97b3d2dd8e980ccd1475a80647540d/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad094d81c97b3d2dd8e980ccd1475a80647540d/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=1ad094d81c97b3d2dd8e980ccd1475a80647540d", "patch": "@@ -289,6 +289,7 @@\n #![feature(on_unimplemented)]\n #![feature(oom)]\n #![feature(optin_builtin_traits)]\n+#![feature(panic_internals)]\n #![feature(panic_unwind)]\n #![feature(peek)]\n #![feature(placement_in_syntax)]"}, {"sha": "eef043683b02e070c851721d472d17f62bbbc57a", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ad094d81c97b3d2dd8e980ccd1475a80647540d/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad094d81c97b3d2dd8e980ccd1475a80647540d/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=1ad094d81c97b3d2dd8e980ccd1475a80647540d", "patch": "@@ -134,14 +134,14 @@ fn each_addr<A: ToSocketAddrs, F, T>(addr: A, mut f: F) -> io::Result<T>\n                                               iterator and returning socket \\\n                                               addresses\",\n            issue = \"27705\")]\n-#[rustc_deprecated(since = \"1.25\", reason = \"Use the ToSocketAddrs trait instead\")]\n+#[rustc_deprecated(since = \"1.25.0\", reason = \"Use the ToSocketAddrs trait instead\")]\n pub struct LookupHost(net_imp::LookupHost);\n \n #[unstable(feature = \"lookup_host\", reason = \"unsure about the returned \\\n                                               iterator and returning socket \\\n                                               addresses\",\n            issue = \"27705\")]\n-#[rustc_deprecated(since = \"1.25\", reason = \"Use the ToSocketAddrs trait instead\")]\n+#[rustc_deprecated(since = \"1.25.0\", reason = \"Use the ToSocketAddrs trait instead\")]\n #[allow(deprecated)]\n impl Iterator for LookupHost {\n     type Item = SocketAddr;\n@@ -152,7 +152,7 @@ impl Iterator for LookupHost {\n                                               iterator and returning socket \\\n                                               addresses\",\n            issue = \"27705\")]\n-#[rustc_deprecated(since = \"1.25\", reason = \"Use the ToSocketAddrs trait instead\")]\n+#[rustc_deprecated(since = \"1.25.0\", reason = \"Use the ToSocketAddrs trait instead\")]\n #[allow(deprecated)]\n impl fmt::Debug for LookupHost {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -186,7 +186,7 @@ impl fmt::Debug for LookupHost {\n                                               iterator and returning socket \\\n                                               addresses\",\n            issue = \"27705\")]\n-#[rustc_deprecated(since = \"1.25\", reason = \"Use the ToSocketAddrs trait instead\")]\n+#[rustc_deprecated(since = \"1.25.0\", reason = \"Use the ToSocketAddrs trait instead\")]\n #[allow(deprecated)]\n pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n     net_imp::lookup_host(host).map(LookupHost)"}, {"sha": "79857104b9b6877bc3f9095d05a9f5707a74355e", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ad094d81c97b3d2dd8e980ccd1475a80647540d/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad094d81c97b3d2dd8e980ccd1475a80647540d/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=1ad094d81c97b3d2dd8e980ccd1475a80647540d", "patch": "@@ -23,7 +23,10 @@ use sync::{Arc, Mutex, RwLock, atomic};\n use thread::Result;\n \n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-pub use panicking::{take_hook, set_hook, PanicInfo, Location};\n+pub use panicking::{take_hook, set_hook};\n+\n+#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+pub use core::panic::{PanicInfo, Location};\n \n /// A marker trait which represents \"panic safe\" types in Rust.\n ///"}, {"sha": "161c3fc7113a7eea96980c8cefc06b0df55c918e", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 17, "deletions": 193, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/1ad094d81c97b3d2dd8e980ccd1475a80647540d/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad094d81c97b3d2dd8e980ccd1475a80647540d/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=1ad094d81c97b3d2dd8e980ccd1475a80647540d", "patch": "@@ -21,6 +21,7 @@ use io::prelude::*;\n \n use any::Any;\n use cell::RefCell;\n+use core::panic::{PanicInfo, Location};\n use fmt;\n use intrinsics;\n use mem;\n@@ -158,182 +159,6 @@ pub fn take_hook() -> Box<Fn(&PanicInfo) + 'static + Sync + Send> {\n     }\n }\n \n-/// A struct providing information about a panic.\n-///\n-/// `PanicInfo` structure is passed to a panic hook set by the [`set_hook`]\n-/// function.\n-///\n-/// [`set_hook`]: ../../std/panic/fn.set_hook.html\n-///\n-/// # Examples\n-///\n-/// ```should_panic\n-/// use std::panic;\n-///\n-/// panic::set_hook(Box::new(|panic_info| {\n-///     println!(\"panic occurred: {:?}\", panic_info.payload().downcast_ref::<&str>().unwrap());\n-/// }));\n-///\n-/// panic!(\"Normal panic\");\n-/// ```\n-#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-#[derive(Debug)]\n-pub struct PanicInfo<'a> {\n-    payload: &'a (Any + Send),\n-    location: Location<'a>,\n-}\n-\n-impl<'a> PanicInfo<'a> {\n-    /// Returns the payload associated with the panic.\n-    ///\n-    /// This will commonly, but not always, be a `&'static str` or [`String`].\n-    ///\n-    /// [`String`]: ../../std/string/struct.String.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```should_panic\n-    /// use std::panic;\n-    ///\n-    /// panic::set_hook(Box::new(|panic_info| {\n-    ///     println!(\"panic occurred: {:?}\", panic_info.payload().downcast_ref::<&str>().unwrap());\n-    /// }));\n-    ///\n-    /// panic!(\"Normal panic\");\n-    /// ```\n-    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-    pub fn payload(&self) -> &(Any + Send) {\n-        self.payload\n-    }\n-\n-    /// Returns information about the location from which the panic originated,\n-    /// if available.\n-    ///\n-    /// This method will currently always return [`Some`], but this may change\n-    /// in future versions.\n-    ///\n-    /// [`Some`]: ../../std/option/enum.Option.html#variant.Some\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```should_panic\n-    /// use std::panic;\n-    ///\n-    /// panic::set_hook(Box::new(|panic_info| {\n-    ///     if let Some(location) = panic_info.location() {\n-    ///         println!(\"panic occurred in file '{}' at line {}\", location.file(),\n-    ///             location.line());\n-    ///     } else {\n-    ///         println!(\"panic occurred but can't get location information...\");\n-    ///     }\n-    /// }));\n-    ///\n-    /// panic!(\"Normal panic\");\n-    /// ```\n-    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-    pub fn location(&self) -> Option<&Location> {\n-        Some(&self.location)\n-    }\n-}\n-\n-/// A struct containing information about the location of a panic.\n-///\n-/// This structure is created by the [`location`] method of [`PanicInfo`].\n-///\n-/// [`location`]: ../../std/panic/struct.PanicInfo.html#method.location\n-/// [`PanicInfo`]: ../../std/panic/struct.PanicInfo.html\n-///\n-/// # Examples\n-///\n-/// ```should_panic\n-/// use std::panic;\n-///\n-/// panic::set_hook(Box::new(|panic_info| {\n-///     if let Some(location) = panic_info.location() {\n-///         println!(\"panic occurred in file '{}' at line {}\", location.file(), location.line());\n-///     } else {\n-///         println!(\"panic occurred but can't get location information...\");\n-///     }\n-/// }));\n-///\n-/// panic!(\"Normal panic\");\n-/// ```\n-#[derive(Debug)]\n-#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-pub struct Location<'a> {\n-    file: &'a str,\n-    line: u32,\n-    col: u32,\n-}\n-\n-impl<'a> Location<'a> {\n-    /// Returns the name of the source file from which the panic originated.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```should_panic\n-    /// use std::panic;\n-    ///\n-    /// panic::set_hook(Box::new(|panic_info| {\n-    ///     if let Some(location) = panic_info.location() {\n-    ///         println!(\"panic occurred in file '{}'\", location.file());\n-    ///     } else {\n-    ///         println!(\"panic occurred but can't get location information...\");\n-    ///     }\n-    /// }));\n-    ///\n-    /// panic!(\"Normal panic\");\n-    /// ```\n-    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-    pub fn file(&self) -> &str {\n-        self.file\n-    }\n-\n-    /// Returns the line number from which the panic originated.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```should_panic\n-    /// use std::panic;\n-    ///\n-    /// panic::set_hook(Box::new(|panic_info| {\n-    ///     if let Some(location) = panic_info.location() {\n-    ///         println!(\"panic occurred at line {}\", location.line());\n-    ///     } else {\n-    ///         println!(\"panic occurred but can't get location information...\");\n-    ///     }\n-    /// }));\n-    ///\n-    /// panic!(\"Normal panic\");\n-    /// ```\n-    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-    pub fn line(&self) -> u32 {\n-        self.line\n-    }\n-\n-    /// Returns the column from which the panic originated.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```should_panic\n-    /// use std::panic;\n-    ///\n-    /// panic::set_hook(Box::new(|panic_info| {\n-    ///     if let Some(location) = panic_info.location() {\n-    ///         println!(\"panic occurred at column {}\", location.column());\n-    ///     } else {\n-    ///         println!(\"panic occurred but can't get location information...\");\n-    ///     }\n-    /// }));\n-    ///\n-    /// panic!(\"Normal panic\");\n-    /// ```\n-    #[stable(feature = \"panic_col\", since = \"1.25\")]\n-    pub fn column(&self) -> u32 {\n-        self.col\n-    }\n-}\n-\n fn default_hook(info: &PanicInfo) {\n     #[cfg(feature = \"backtrace\")]\n     use sys_common::backtrace;\n@@ -351,13 +176,14 @@ fn default_hook(info: &PanicInfo) {\n         }\n     };\n \n-    let file = info.location.file;\n-    let line = info.location.line;\n-    let col = info.location.col;\n+    let location = info.location().unwrap();  // The current implementation always returns Some\n+    let file = location.file();\n+    let line = location.line();\n+    let col = location.column();\n \n-    let msg = match info.payload.downcast_ref::<&'static str>() {\n+    let msg = match info.payload().downcast_ref::<&'static str>() {\n         Some(s) => *s,\n-        None => match info.payload.downcast_ref::<String>() {\n+        None => match info.payload().downcast_ref::<String>() {\n             Some(s) => &s[..],\n             None => \"Box<Any>\",\n         }\n@@ -518,7 +344,7 @@ pub fn begin_panic_fmt(msg: &fmt::Arguments,\n \n     let mut s = String::new();\n     let _ = s.write_fmt(*msg);\n-    begin_panic(s, file_line_col)\n+    rust_panic_with_hook(Box::new(s), Some(msg), file_line_col)\n }\n \n /// This is the entry point of panicking for panic!() and assert!().\n@@ -534,7 +360,7 @@ pub fn begin_panic<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u3\n     // be performed in the parent of this thread instead of the thread that's\n     // panicking.\n \n-    rust_panic_with_hook(Box::new(msg), file_line_col)\n+    rust_panic_with_hook(Box::new(msg), None, file_line_col)\n }\n \n /// Executes the primary logic for a panic, including checking for recursive\n@@ -545,7 +371,8 @@ pub fn begin_panic<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u3\n /// run panic hooks, and then delegate to the actual implementation of panics.\n #[inline(never)]\n #[cold]\n-fn rust_panic_with_hook(msg: Box<Any + Send>,\n+fn rust_panic_with_hook(payload: Box<Any + Send>,\n+                        message: Option<&fmt::Arguments>,\n                         file_line_col: &(&'static str, u32, u32)) -> ! {\n     let (file, line, col) = *file_line_col;\n \n@@ -563,14 +390,11 @@ fn rust_panic_with_hook(msg: Box<Any + Send>,\n     }\n \n     unsafe {\n-        let info = PanicInfo {\n-            payload: &*msg,\n-            location: Location {\n-                file,\n-                line,\n-                col,\n-            },\n-        };\n+        let info = PanicInfo::internal_constructor(\n+            &*payload,\n+            message,\n+            Location::internal_constructor(file, line, col),\n+        );\n         HOOK_LOCK.read();\n         match HOOK {\n             Hook::Default => default_hook(&info),\n@@ -589,7 +413,7 @@ fn rust_panic_with_hook(msg: Box<Any + Send>,\n         unsafe { intrinsics::abort() }\n     }\n \n-    rust_panic(msg)\n+    rust_panic(payload)\n }\n \n /// Shim around rust_panic. Called by resume_unwind."}]}