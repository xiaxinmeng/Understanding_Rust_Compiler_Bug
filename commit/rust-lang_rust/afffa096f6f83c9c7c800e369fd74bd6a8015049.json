{"sha": "afffa096f6f83c9c7c800e369fd74bd6a8015049", "node_id": "C_kwDOAAsO6NoAKGFmZmZhMDk2ZjZmODNjOWM3YzgwMGUzNjlmZDc0YmQ2YTgwMTUwNDk", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-12-27T14:54:51Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-12-28T14:00:55Z"}, "message": "add TopEntryPoint", "tree": {"sha": "3de0a848e68bf24329ed4a956a4b7de8db7f6090", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3de0a848e68bf24329ed4a956a4b7de8db7f6090"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afffa096f6f83c9c7c800e369fd74bd6a8015049", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afffa096f6f83c9c7c800e369fd74bd6a8015049", "html_url": "https://github.com/rust-lang/rust/commit/afffa096f6f83c9c7c800e369fd74bd6a8015049", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afffa096f6f83c9c7c800e369fd74bd6a8015049/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e7fc7be65791c76c363d0a1191f45902564909c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e7fc7be65791c76c363d0a1191f45902564909c", "html_url": "https://github.com/rust-lang/rust/commit/8e7fc7be65791c76c363d0a1191f45902564909c"}], "stats": {"total": 144, "additions": 94, "deletions": 50}, "files": [{"sha": "383ad7f0c83282924817eaef866ad8e0adfea5fd", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/afffa096f6f83c9c7c800e369fd74bd6a8015049/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afffa096f6f83c9c7c800e369fd74bd6a8015049/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=afffa096f6f83c9c7c800e369fd74bd6a8015049", "patch": "@@ -714,8 +714,7 @@ impl Attr {\n         hygiene: &Hygiene,\n         id: AttrId,\n     ) -> Option<Attr> {\n-        let (parse, _) =\n-            mbe::token_tree_to_syntax_node(tt, mbe::ParserEntryPoint::MetaItem).ok()?;\n+        let (parse, _) = mbe::token_tree_to_syntax_node(tt, mbe::TopEntryPoint::MetaItem).ok()?;\n         let ast = ast::Meta::cast(parse.syntax_node())?;\n \n         Self::from_src(db, ast, hygiene, id)"}, {"sha": "c1542f48f0e1967554fdbcee7c3f6358a2e596c4", "filename": "crates/hir_expand/src/builtin_derive_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afffa096f6f83c9c7c800e369fd74bd6a8015049/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afffa096f6f83c9c7c800e369fd74bd6a8015049/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive_macro.rs?ref=afffa096f6f83c9c7c800e369fd74bd6a8015049", "patch": "@@ -72,7 +72,7 @@ struct BasicAdtInfo {\n }\n \n fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, mbe::ExpandError> {\n-    let (parsed, token_map) = mbe::token_tree_to_syntax_node(tt, mbe::ParserEntryPoint::Items)?; // FragmentKind::Items doesn't parse attrs?\n+    let (parsed, token_map) = mbe::token_tree_to_syntax_node(tt, mbe::TopEntryPoint::MacroItems)?; // FragmentKind::Items doesn't parse attrs?\n     let macro_items = ast::MacroItems::cast(parsed.syntax_node()).ok_or_else(|| {\n         debug!(\"derive node didn't parse\");\n         mbe::ExpandError::UnexpectedToken"}, {"sha": "3369e3e5fedff0cd2bf9d15fc2b625b9652b71b8", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afffa096f6f83c9c7c800e369fd74bd6a8015049/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afffa096f6f83c9c7c800e369fd74bd6a8015049/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=afffa096f6f83c9c7c800e369fd74bd6a8015049", "patch": "@@ -497,11 +497,11 @@ fn token_tree_to_syntax_node(\n     expand_to: ExpandTo,\n ) -> Result<(Parse<SyntaxNode>, mbe::TokenMap), ExpandError> {\n     let entry_point = match expand_to {\n-        ExpandTo::Statements => mbe::ParserEntryPoint::Statements,\n-        ExpandTo::Items => mbe::ParserEntryPoint::Items,\n-        ExpandTo::Pattern => mbe::ParserEntryPoint::Pattern,\n-        ExpandTo::Type => mbe::ParserEntryPoint::Type,\n-        ExpandTo::Expr => mbe::ParserEntryPoint::Expr,\n+        ExpandTo::Statements => mbe::TopEntryPoint::MacroStmts,\n+        ExpandTo::Items => mbe::TopEntryPoint::MacroItems,\n+        ExpandTo::Pattern => mbe::TopEntryPoint::Pattern,\n+        ExpandTo::Type => mbe::TopEntryPoint::Type,\n+        ExpandTo::Expr => mbe::TopEntryPoint::Expr,\n     };\n     mbe::token_tree_to_syntax_node(tt, entry_point)\n }"}, {"sha": "1d29ad26307e2205e34a2f1bd6dd7543d2750dc7", "filename": "crates/hir_expand/src/eager.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afffa096f6f83c9c7c800e369fd74bd6a8015049/crates%2Fhir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afffa096f6f83c9c7c800e369fd74bd6a8015049/crates%2Fhir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Feager.rs?ref=afffa096f6f83c9c7c800e369fd74bd6a8015049", "patch": "@@ -131,7 +131,7 @@ pub fn expand_eager_macro(\n     let arg_file_id = arg_id;\n \n     let parsed_args = diagnostic_sink\n-        .result(mbe::token_tree_to_syntax_node(&parsed_args, mbe::ParserEntryPoint::Expr))?\n+        .result(mbe::token_tree_to_syntax_node(&parsed_args, mbe::TopEntryPoint::Expr))?\n         .0;\n     let result = eager_macro_recur(\n         db,"}, {"sha": "62e7509eb37c063edf557e785a953b800f0b3c21", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afffa096f6f83c9c7c800e369fd74bd6a8015049/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afffa096f6f83c9c7c800e369fd74bd6a8015049/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=afffa096f6f83c9c7c800e369fd74bd6a8015049", "patch": "@@ -24,7 +24,7 @@ use crate::{\n };\n \n // FIXME: we probably should re-think  `token_tree_to_syntax_node` interfaces\n-pub use ::parser::ParserEntryPoint;\n+pub use ::parser::TopEntryPoint;\n pub use tt::{Delimiter, DelimiterKind, Punct};\n \n #[derive(Debug, PartialEq, Eq, Clone)]"}, {"sha": "8bdc5e6e9463165dfc55d25c0834bc487a49599a", "filename": "crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afffa096f6f83c9c7c800e369fd74bd6a8015049/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afffa096f6f83c9c7c800e369fd74bd6a8015049/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=afffa096f6f83c9c7c800e369fd74bd6a8015049", "patch": "@@ -9,9 +9,7 @@ use syntax::{\n };\n use tt::buffer::{Cursor, TokenBuffer};\n \n-use crate::{\n-    to_parser_input::to_parser_input, tt_iter::TtIter, ExpandError, ParserEntryPoint, TokenMap,\n-};\n+use crate::{to_parser_input::to_parser_input, tt_iter::TtIter, ExpandError, TokenMap};\n \n /// Convert the syntax node to a `TokenTree` (what macro\n /// will consume).\n@@ -46,7 +44,7 @@ pub fn syntax_node_to_token_tree_censored(\n \n pub fn token_tree_to_syntax_node(\n     tt: &tt::Subtree,\n-    entry_point: ParserEntryPoint,\n+    entry_point: parser::TopEntryPoint,\n ) -> Result<(Parse<SyntaxNode>, TokenMap), ExpandError> {\n     let buffer = match tt {\n         tt::Subtree { delimiter: None, token_trees } => {\n@@ -55,7 +53,7 @@ pub fn token_tree_to_syntax_node(\n         _ => TokenBuffer::from_subtree(tt),\n     };\n     let parser_input = to_parser_input(&buffer);\n-    let parser_output = parser::parse(&parser_input, entry_point);\n+    let parser_output = entry_point.parse(&parser_input);\n     let mut tree_sink = TtTreeSink::new(buffer.begin());\n     for event in parser_output.iter() {\n         match event {"}, {"sha": "5fbeca44323aa81850d627c4225deabfd201b19b", "filename": "crates/parser/src/grammar.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/afffa096f6f83c9c7c800e369fd74bd6a8015049/crates%2Fparser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afffa096f6f83c9c7c800e369fd74bd6a8015049/crates%2Fparser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar.rs?ref=afffa096f6f83c9c7c800e369fd74bd6a8015049", "patch": "@@ -83,41 +83,45 @@ pub(crate) mod entry {\n             attributes::meta(p);\n         }\n     }\n-}\n-\n-pub(crate) mod entry_points {\n-    use super::*;\n \n-    pub(crate) fn source_file(p: &mut Parser) {\n-        let m = p.start();\n-        p.eat(SHEBANG);\n-        items::mod_contents(p, false);\n-        m.complete(p, SOURCE_FILE);\n-    }\n+    pub(crate) mod top {\n+        use super::*;\n \n-    pub(crate) fn stmt_optional_semi(p: &mut Parser) {\n-        expressions::stmt(p, expressions::StmtWithSemi::Optional, false);\n-    }\n+        pub(crate) fn source_file(p: &mut Parser) {\n+            let m = p.start();\n+            p.eat(SHEBANG);\n+            items::mod_contents(p, false);\n+            m.complete(p, SOURCE_FILE);\n+        }\n \n-    pub(crate) fn macro_items(p: &mut Parser) {\n-        let m = p.start();\n-        items::mod_contents(p, false);\n-        m.complete(p, MACRO_ITEMS);\n-    }\n+        pub(crate) fn macro_stmts(p: &mut Parser) {\n+            let m = p.start();\n \n-    pub(crate) fn macro_stmts(p: &mut Parser) {\n-        let m = p.start();\n+            while !p.at(EOF) {\n+                if p.at(T![;]) {\n+                    p.bump(T![;]);\n+                    continue;\n+                }\n \n-        while !p.at(EOF) {\n-            if p.at(T![;]) {\n-                p.bump(T![;]);\n-                continue;\n+                expressions::stmt(p, expressions::StmtWithSemi::Optional, true);\n             }\n \n-            expressions::stmt(p, expressions::StmtWithSemi::Optional, true);\n+            m.complete(p, MACRO_STMTS);\n         }\n \n-        m.complete(p, MACRO_STMTS);\n+        pub(crate) fn macro_items(p: &mut Parser) {\n+            let m = p.start();\n+            items::mod_contents(p, false);\n+            m.complete(p, MACRO_ITEMS);\n+        }\n+    }\n+}\n+\n+pub(crate) mod entry_points {\n+    use super::*;\n+\n+    pub(crate) fn stmt_optional_semi(p: &mut Parser) {\n+        expressions::stmt(p, expressions::StmtWithSemi::Optional, false);\n     }\n \n     pub(crate) fn attr(p: &mut Parser) {"}, {"sha": "23ce233dfd4c30cc29c918909ad150761d4db4c5", "filename": "crates/parser/src/lib.rs", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/afffa096f6f83c9c7c800e369fd74bd6a8015049/crates%2Fparser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afffa096f6f83c9c7c800e369fd74bd6a8015049/crates%2Fparser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Flib.rs?ref=afffa096f6f83c9c7c800e369fd74bd6a8015049", "patch": "@@ -41,7 +41,7 @@ pub use crate::{\n     syntax_kind::SyntaxKind,\n };\n \n-/// Parse a syntactic construct at the *start* of the input.\n+/// Parse a prefix of the input as a given syntactic construct.\n ///\n /// This is used by macro-by-example parser to implement things like `$i:item`\n /// and the naming of variants follows the naming of macro fragments.\n@@ -83,28 +83,74 @@ impl PrefixEntryPoint {\n     }\n }\n \n+/// Parse the whole of the input as a given syntactic construct.\n+///\n+/// This covers two main use-cases:\n+///\n+///   * Parsing a Rust file.\n+///   * Parsing a result of macro expansion.\n+///\n+/// That is, for something like\n+///\n+/// ```\n+/// quick_check! {\n+///    fn prop() {}\n+/// }\n+/// ```\n+///\n+/// the input to the macro will be parsed with [`PrefixEntryPoint::Item`], and\n+/// the result will be [`TopEntryPoint::Items`].\n+///\n+/// This *should* (but currently doesn't) guarantee that all input is consumed.\n+#[derive(Debug)]\n+pub enum TopEntryPoint {\n+    SourceFile,\n+    MacroStmts,\n+    MacroItems,\n+    Pattern,\n+    Type,\n+    Expr,\n+    MetaItem,\n+}\n+\n+impl TopEntryPoint {\n+    pub fn parse(&self, input: &Input) -> Output {\n+        let entry_point: fn(&'_ mut parser::Parser) = match self {\n+            TopEntryPoint::SourceFile => grammar::entry::top::source_file,\n+            TopEntryPoint::MacroStmts => grammar::entry::top::macro_stmts,\n+            TopEntryPoint::MacroItems => grammar::entry::top::macro_items,\n+            // FIXME\n+            TopEntryPoint::Pattern => grammar::entry::prefix::pat,\n+            TopEntryPoint::Type => grammar::entry::prefix::ty,\n+            TopEntryPoint::Expr => grammar::entry::prefix::expr,\n+            TopEntryPoint::MetaItem => grammar::entry::prefix::meta_item,\n+        };\n+        let mut p = parser::Parser::new(input);\n+        entry_point(&mut p);\n+        let events = p.finish();\n+        event::process(events)\n+    }\n+}\n+\n /// rust-analyzer parser allows you to choose one of the possible entry points.\n ///\n /// The primary consumer of this API are declarative macros, `$x:expr` matchers\n /// are implemented by calling into the parser with non-standard entry point.\n #[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]\n pub enum ParserEntryPoint {\n-    SourceFile,\n     Path,\n     Expr,\n     StatementOptionalSemi,\n     Type,\n     Pattern,\n     Item,\n     MetaItem,\n-    Items,\n-    Statements,\n     Attr,\n }\n \n /// Parse given tokens into the given sink as a rust file.\n-pub fn parse_source_file(inp: &Input) -> Output {\n-    parse(inp, ParserEntryPoint::SourceFile)\n+pub fn parse_source_file(input: &Input) -> Output {\n+    TopEntryPoint::SourceFile.parse(input)\n }\n \n /// Parses the given [`Input`] into [`Output`] assuming that the top-level\n@@ -117,16 +163,13 @@ pub fn parse_source_file(inp: &Input) -> Output {\n /// indices between the four stages.\n pub fn parse(inp: &Input, entry_point: ParserEntryPoint) -> Output {\n     let entry_point: fn(&'_ mut parser::Parser) = match entry_point {\n-        ParserEntryPoint::SourceFile => grammar::entry_points::source_file,\n         ParserEntryPoint::Path => grammar::entry::prefix::path,\n         ParserEntryPoint::Expr => grammar::entry::prefix::expr,\n         ParserEntryPoint::Type => grammar::entry::prefix::ty,\n         ParserEntryPoint::Pattern => grammar::entry::prefix::pat,\n         ParserEntryPoint::Item => grammar::entry::prefix::item,\n         ParserEntryPoint::MetaItem => grammar::entry::prefix::meta_item,\n         ParserEntryPoint::StatementOptionalSemi => grammar::entry_points::stmt_optional_semi,\n-        ParserEntryPoint::Items => grammar::entry_points::macro_items,\n-        ParserEntryPoint::Statements => grammar::entry_points::macro_stmts,\n         ParserEntryPoint::Attr => grammar::entry_points::attr,\n     };\n "}]}