{"sha": "7fdffe183d2bb5bb10ed0558cfa460dee9d319e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmZGZmZTE4M2QyYmI1YmIxMGVkMDU1OGNmYTQ2MGRlZTlkMzE5ZTA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-01T15:45:17Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-02T12:09:25Z"}, "message": "Use NonterminalKind for MetaVarDecl\n\nThis is more type safe and allows us to remove a few dead branches", "tree": {"sha": "fb101bc9703ca8da3a452e56deadf9e33127450f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb101bc9703ca8da3a452e56deadf9e33127450f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fdffe183d2bb5bb10ed0558cfa460dee9d319e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fdffe183d2bb5bb10ed0558cfa460dee9d319e0", "html_url": "https://github.com/rust-lang/rust/commit/7fdffe183d2bb5bb10ed0558cfa460dee9d319e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fdffe183d2bb5bb10ed0558cfa460dee9d319e0/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2595d75ea98e6bede1a6c847fe22c8abe3a9401e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2595d75ea98e6bede1a6c847fe22c8abe3a9401e", "html_url": "https://github.com/rust-lang/rust/commit/2595d75ea98e6bede1a6c847fe22c8abe3a9401e"}], "stats": {"total": 229, "additions": 95, "deletions": 134}, "files": [{"sha": "2b348617297e0eb92468ae0ffd77ceb49a2ab541", "filename": "src/librustc_ast/token.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7fdffe183d2bb5bb10ed0558cfa460dee9d319e0/src%2Flibrustc_ast%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fdffe183d2bb5bb10ed0558cfa460dee9d319e0/src%2Flibrustc_ast%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftoken.rs?ref=7fdffe183d2bb5bb10ed0558cfa460dee9d319e0", "patch": "@@ -760,7 +760,7 @@ pub enum Nonterminal {\n #[cfg(target_arch = \"x86_64\")]\n rustc_data_structures::static_assert_size!(Nonterminal, 40);\n \n-#[derive(Copy, Clone)]\n+#[derive(Debug, Copy, Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum NonterminalKind {\n     Item,\n     Block,\n@@ -796,6 +796,29 @@ impl NonterminalKind {\n             _ => return None,\n         })\n     }\n+    fn symbol(self) -> Symbol {\n+        match self {\n+            NonterminalKind::Item => sym::item,\n+            NonterminalKind::Block => sym::block,\n+            NonterminalKind::Stmt => sym::stmt,\n+            NonterminalKind::Pat => sym::pat,\n+            NonterminalKind::Expr => sym::expr,\n+            NonterminalKind::Ty => sym::ty,\n+            NonterminalKind::Ident => sym::ident,\n+            NonterminalKind::Lifetime => sym::lifetime,\n+            NonterminalKind::Literal => sym::literal,\n+            NonterminalKind::Meta => sym::meta,\n+            NonterminalKind::Path => sym::path,\n+            NonterminalKind::Vis => sym::vis,\n+            NonterminalKind::TT => sym::tt,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for NonterminalKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.symbol())\n+    }\n }\n \n impl Nonterminal {"}, {"sha": "6f2daaa81c02f5a6b1bd9669539afbce2d7edb83", "filename": "src/librustc_expand/mbe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fdffe183d2bb5bb10ed0558cfa460dee9d319e0/src%2Flibrustc_expand%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fdffe183d2bb5bb10ed0558cfa460dee9d319e0/src%2Flibrustc_expand%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe.rs?ref=7fdffe183d2bb5bb10ed0558cfa460dee9d319e0", "patch": "@@ -9,7 +9,7 @@ crate mod macro_rules;\n crate mod quoted;\n crate mod transcribe;\n \n-use rustc_ast::token::{self, Token, TokenKind};\n+use rustc_ast::token::{self, NonterminalKind, Token, TokenKind};\n use rustc_ast::tokenstream::DelimSpan;\n \n use rustc_span::symbol::Ident;\n@@ -84,7 +84,7 @@ enum TokenTree {\n     /// e.g., `$var`\n     MetaVar(Span, Ident),\n     /// e.g., `$var:expr`. This is only used in the left hand side of MBE macros.\n-    MetaVarDecl(Span, Ident /* name to bind */, Ident /* kind of nonterminal */),\n+    MetaVarDecl(Span, Ident /* name to bind */, Option<NonterminalKind>),\n }\n \n impl TokenTree {"}, {"sha": "d2fe7fe10a8301b1cd24cdbe4d23a78b2690f04b", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7fdffe183d2bb5bb10ed0558cfa460dee9d319e0/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fdffe183d2bb5bb10ed0558cfa460dee9d319e0/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=7fdffe183d2bb5bb10ed0558cfa460dee9d319e0", "patch": "@@ -76,10 +76,10 @@ use TokenTreeOrTokenTreeSlice::*;\n \n use crate::mbe::{self, TokenTree};\n \n-use rustc_ast::token::{self, DocComment, Nonterminal, NonterminalKind, Token};\n+use rustc_ast::token::{self, DocComment, Nonterminal, Token};\n use rustc_parse::parser::Parser;\n use rustc_session::parse::ParseSess;\n-use rustc_span::symbol::{kw, MacroRulesNormalizedIdent};\n+use rustc_span::symbol::MacroRulesNormalizedIdent;\n \n use smallvec::{smallvec, SmallVec};\n \n@@ -378,7 +378,7 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n                     n_rec(sess, next_m, res.by_ref(), ret_val)?;\n                 }\n             }\n-            TokenTree::MetaVarDecl(span, _, id) if id.name == kw::Invalid => {\n+            TokenTree::MetaVarDecl(span, _, None) => {\n                 if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n                     return Err((span, \"missing fragment specifier\".to_string()));\n                 }\n@@ -561,18 +561,17 @@ fn inner_parse_loop<'root, 'tt>(\n                 }\n \n                 // We need to match a metavar (but the identifier is invalid)... this is an error\n-                TokenTree::MetaVarDecl(span, _, id) if id.name == kw::Invalid => {\n+                TokenTree::MetaVarDecl(span, _, None) => {\n                     if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n                         return Error(span, \"missing fragment specifier\".to_string());\n                     }\n                 }\n \n                 // We need to match a metavar with a valid ident... call out to the black-box\n                 // parser by adding an item to `bb_items`.\n-                TokenTree::MetaVarDecl(_, _, id) => {\n+                TokenTree::MetaVarDecl(_, _, Some(kind)) => {\n                     // Built-in nonterminals never start with these tokens,\n                     // so we can eliminate them from consideration.\n-                    let kind = NonterminalKind::from_symbol(id.name).unwrap();\n                     if Parser::nonterminal_may_begin_with(kind, token) {\n                         bb_items.push(item);\n                     }\n@@ -703,7 +702,7 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n             let nts = bb_items\n                 .iter()\n                 .map(|item| match item.top_elts.get_tt(item.idx) {\n-                    TokenTree::MetaVarDecl(_, bind, name) => format!(\"{} ('{}')\", name, bind),\n+                    TokenTree::MetaVarDecl(_, bind, Some(kind)) => format!(\"{} ('{}')\", kind, bind),\n                     _ => panic!(),\n                 })\n                 .collect::<Vec<String>>()\n@@ -733,17 +732,13 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n             assert_eq!(bb_items.len(), 1);\n \n             let mut item = bb_items.pop().unwrap();\n-            if let TokenTree::MetaVarDecl(span, _, ident) = item.top_elts.get_tt(item.idx) {\n+            if let TokenTree::MetaVarDecl(span, _, Some(kind)) = item.top_elts.get_tt(item.idx) {\n                 let match_cur = item.match_cur;\n-                let kind = NonterminalKind::from_symbol(ident.name).unwrap();\n                 let nt = match parser.to_mut().parse_nonterminal(kind) {\n                     Err(mut err) => {\n                         err.span_label(\n                             span,\n-                            format!(\n-                                \"while parsing argument for this `{}` macro fragment\",\n-                                ident.name\n-                            ),\n+                            format!(\"while parsing argument for this `{}` macro fragment\", kind),\n                         )\n                         .emit();\n                         return ErrorReported;"}, {"sha": "74d4023b41075b52e4872b2518ac4f5be8c6c8ec", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 42, "deletions": 115, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/7fdffe183d2bb5bb10ed0558cfa460dee9d319e0/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fdffe183d2bb5bb10ed0558cfa460dee9d319e0/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=7fdffe183d2bb5bb10ed0558cfa460dee9d319e0", "patch": "@@ -21,18 +21,14 @@ use rustc_parse::parser::Parser;\n use rustc_session::parse::ParseSess;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::Transparency;\n-use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent};\n use rustc_span::Span;\n \n use log::debug;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n use std::{mem, slice};\n \n-const VALID_FRAGMENT_NAMES_MSG: &str = \"valid fragment specifiers are \\\n-                                        `ident`, `block`, `stmt`, `expr`, `pat`, `ty`, `lifetime`, \\\n-                                        `literal`, `path`, `meta`, `tt`, `item` and `vis`\";\n-\n crate struct ParserAnyMacro<'a> {\n     parser: Parser<'a>,\n \n@@ -403,7 +399,7 @@ pub fn compile_declarative_macro(\n     let diag = &sess.span_diagnostic;\n     let lhs_nm = Ident::new(sym::lhs, def.span);\n     let rhs_nm = Ident::new(sym::rhs, def.span);\n-    let tt_spec = Ident::new(sym::tt, def.span);\n+    let tt_spec = Some(NonterminalKind::TT);\n \n     // Parse the macro_rules! invocation\n     let (macro_rules, body) = match &def.kind {\n@@ -571,7 +567,7 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[mbe::TokenTree]) -> bool {\n             TokenTree::Sequence(span, ref seq) => {\n                 if seq.separator.is_none()\n                     && seq.tts.iter().all(|seq_tt| match *seq_tt {\n-                        TokenTree::MetaVarDecl(_, _, id) => id.name == sym::vis,\n+                        TokenTree::MetaVarDecl(_, _, Some(NonterminalKind::Vis)) => true,\n                         TokenTree::Sequence(_, ref sub_seq) => {\n                             sub_seq.kleene.op == mbe::KleeneOp::ZeroOrMore\n                                 || sub_seq.kleene.op == mbe::KleeneOp::ZeroOrOne\n@@ -890,21 +886,7 @@ fn check_matcher_core(\n         // of NT tokens that might end the sequence `... token`.\n         match *token {\n             TokenTree::Token(..) | TokenTree::MetaVar(..) | TokenTree::MetaVarDecl(..) => {\n-                let can_be_followed_by_any;\n-                if let Err(bad_frag) = has_legal_fragment_specifier(sess, features, attrs, token) {\n-                    let msg = format!(\"invalid fragment specifier `{}`\", bad_frag);\n-                    sess.span_diagnostic\n-                        .struct_span_err(token.span(), &msg)\n-                        .help(VALID_FRAGMENT_NAMES_MSG)\n-                        .emit();\n-                    // (This eliminates false positives and duplicates\n-                    // from error messages.)\n-                    can_be_followed_by_any = true;\n-                } else {\n-                    can_be_followed_by_any = token_can_be_followed_by_any(token);\n-                }\n-\n-                if can_be_followed_by_any {\n+                if token_can_be_followed_by_any(token) {\n                     // don't need to track tokens that work with any,\n                     last.replace_with_irrelevant();\n                     // ... and don't need to check tokens that can be\n@@ -967,19 +949,10 @@ fn check_matcher_core(\n \n         // Now `last` holds the complete set of NT tokens that could\n         // end the sequence before SUFFIX. Check that every one works with `suffix`.\n-        'each_last: for token in &last.tokens {\n-            if let TokenTree::MetaVarDecl(_, name, frag_spec) = *token {\n+        for token in &last.tokens {\n+            if let TokenTree::MetaVarDecl(_, name, Some(kind)) = *token {\n                 for next_token in &suffix_first.tokens {\n-                    match is_in_follow(next_token, frag_spec.name) {\n-                        IsInFollow::Invalid(msg, help) => {\n-                            sess.span_diagnostic\n-                                .struct_span_err(next_token.span(), &msg)\n-                                .help(help)\n-                                .emit();\n-                            // don't bother reporting every source of\n-                            // conflict for a particular element of `last`.\n-                            continue 'each_last;\n-                        }\n+                    match is_in_follow(next_token, kind) {\n                         IsInFollow::Yes => {}\n                         IsInFollow::No(possible) => {\n                             let may_be = if last.tokens.len() == 1 && suffix_first.tokens.len() == 1\n@@ -996,22 +969,19 @@ fn check_matcher_core(\n                                     \"`${name}:{frag}` {may_be} followed by `{next}`, which \\\n                                      is not allowed for `{frag}` fragments\",\n                                     name = name,\n-                                    frag = frag_spec,\n+                                    frag = kind,\n                                     next = quoted_tt_to_string(next_token),\n                                     may_be = may_be\n                                 ),\n                             );\n-                            err.span_label(\n-                                sp,\n-                                format!(\"not allowed after `{}` fragments\", frag_spec),\n-                            );\n+                            err.span_label(sp, format!(\"not allowed after `{}` fragments\", kind));\n                             let msg = \"allowed there are: \";\n                             match possible {\n                                 &[] => {}\n                                 &[t] => {\n                                     err.note(&format!(\n                                         \"only {} is allowed after `{}` fragments\",\n-                                        t, frag_spec,\n+                                        t, kind,\n                                     ));\n                                 }\n                                 ts => {\n@@ -1038,8 +1008,8 @@ fn check_matcher_core(\n }\n \n fn token_can_be_followed_by_any(tok: &mbe::TokenTree) -> bool {\n-    if let mbe::TokenTree::MetaVarDecl(_, _, frag_spec) = *tok {\n-        frag_can_be_followed_by_any(frag_spec.name)\n+    if let mbe::TokenTree::MetaVarDecl(_, _, Some(kind)) = *tok {\n+        frag_can_be_followed_by_any(kind)\n     } else {\n         // (Non NT's can always be followed by anything in matchers.)\n         true\n@@ -1054,26 +1024,23 @@ fn token_can_be_followed_by_any(tok: &mbe::TokenTree) -> bool {\n /// specifier which consumes at most one token tree can be followed by\n /// a fragment specifier (indeed, these fragments can be followed by\n /// ANYTHING without fear of future compatibility hazards).\n-fn frag_can_be_followed_by_any(frag: Symbol) -> bool {\n-    match frag {\n-        sym::item     | // always terminated by `}` or `;`\n-        sym::block    | // exactly one token tree\n-        sym::ident    | // exactly one token tree\n-        sym::literal  | // exactly one token tree\n-        sym::meta     | // exactly one token tree\n-        sym::lifetime | // exactly one token tree\n-        sym::tt =>   // exactly one token tree\n-            true,\n-\n-        _ =>\n-            false,\n+fn frag_can_be_followed_by_any(kind: NonterminalKind) -> bool {\n+    match kind {\n+        NonterminalKind::Item           // always terminated by `}` or `;`\n+        | NonterminalKind::Block        // exactly one token tree\n+        | NonterminalKind::Ident        // exactly one token tree\n+        | NonterminalKind::Literal      // exactly one token tree\n+        | NonterminalKind::Meta         // exactly one token tree\n+        | NonterminalKind::Lifetime     // exactly one token tree\n+        | NonterminalKind::TT => true,  // exactly one token tree\n+\n+        _ => false,\n     }\n }\n \n enum IsInFollow {\n     Yes,\n     No(&'static [&'static str]),\n-    Invalid(String, &'static str),\n }\n \n /// Returns `true` if `frag` can legally be followed by the token `tok`. For\n@@ -1084,26 +1051,26 @@ enum IsInFollow {\n /// break macros that were relying on that binary operator as a\n /// separator.\n // when changing this do not forget to update doc/book/macros.md!\n-fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n+fn is_in_follow(tok: &mbe::TokenTree, kind: NonterminalKind) -> IsInFollow {\n     use mbe::TokenTree;\n \n     if let TokenTree::Token(Token { kind: token::CloseDelim(_), .. }) = *tok {\n         // closing a token tree can never be matched by any fragment;\n         // iow, we always require that `(` and `)` match, etc.\n         IsInFollow::Yes\n     } else {\n-        match frag {\n-            sym::item => {\n+        match kind {\n+            NonterminalKind::Item => {\n                 // since items *must* be followed by either a `;` or a `}`, we can\n                 // accept anything after them\n                 IsInFollow::Yes\n             }\n-            sym::block => {\n+            NonterminalKind::Block => {\n                 // anything can follow block, the braces provide an easy boundary to\n                 // maintain\n                 IsInFollow::Yes\n             }\n-            sym::stmt | sym::expr => {\n+            NonterminalKind::Stmt | NonterminalKind::Expr => {\n                 const TOKENS: &[&str] = &[\"`=>`\", \"`,`\", \"`;`\"];\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {\n@@ -1113,7 +1080,7 @@ fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            sym::pat => {\n+            NonterminalKind::Pat => {\n                 const TOKENS: &[&str] = &[\"`=>`\", \"`,`\", \"`=`\", \"`|`\", \"`if`\", \"`in`\"];\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {\n@@ -1124,7 +1091,7 @@ fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            sym::path | sym::ty => {\n+            NonterminalKind::Path | NonterminalKind::Ty => {\n                 const TOKENS: &[&str] = &[\n                     \"`{`\", \"`[`\", \"`=>`\", \"`,`\", \"`>`\", \"`=`\", \"`:`\", \"`;`\", \"`|`\", \"`as`\",\n                     \"`where`\",\n@@ -1146,26 +1113,24 @@ fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n                         }\n                         _ => IsInFollow::No(TOKENS),\n                     },\n-                    TokenTree::MetaVarDecl(_, _, frag) if frag.name == sym::block => {\n-                        IsInFollow::Yes\n-                    }\n+                    TokenTree::MetaVarDecl(_, _, Some(NonterminalKind::Block)) => IsInFollow::Yes,\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            sym::ident | sym::lifetime => {\n+            NonterminalKind::Ident | NonterminalKind::Lifetime => {\n                 // being a single token, idents and lifetimes are harmless\n                 IsInFollow::Yes\n             }\n-            sym::literal => {\n+            NonterminalKind::Literal => {\n                 // literals may be of a single token, or two tokens (negative numbers)\n                 IsInFollow::Yes\n             }\n-            sym::meta | sym::tt => {\n+            NonterminalKind::Meta | NonterminalKind::TT => {\n                 // being either a single token or a delimited sequence, tt is\n                 // harmless\n                 IsInFollow::Yes\n             }\n-            sym::vis => {\n+            NonterminalKind::Vis => {\n                 // Explicitly disallow `priv`, on the off chance it comes back.\n                 const TOKENS: &[&str] = &[\"`,`\", \"an ident\", \"a type\"];\n                 match tok {\n@@ -1180,62 +1145,24 @@ fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n                             }\n                         }\n                     },\n-                    TokenTree::MetaVarDecl(_, _, frag)\n-                        if frag.name == sym::ident\n-                            || frag.name == sym::ty\n-                            || frag.name == sym::path =>\n-                    {\n-                        IsInFollow::Yes\n-                    }\n+                    TokenTree::MetaVarDecl(\n+                        _,\n+                        _,\n+                        Some(NonterminalKind::Ident | NonterminalKind::Ty | NonterminalKind::Path),\n+                    ) => IsInFollow::Yes,\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            kw::Invalid => IsInFollow::Yes,\n-            _ => IsInFollow::Invalid(\n-                format!(\"invalid fragment specifier `{}`\", frag),\n-                VALID_FRAGMENT_NAMES_MSG,\n-            ),\n         }\n     }\n }\n \n-fn has_legal_fragment_specifier(\n-    sess: &ParseSess,\n-    features: &Features,\n-    attrs: &[ast::Attribute],\n-    tok: &mbe::TokenTree,\n-) -> Result<(), String> {\n-    debug!(\"has_legal_fragment_specifier({:?})\", tok);\n-    if let mbe::TokenTree::MetaVarDecl(_, _, ref frag_spec) = *tok {\n-        let frag_span = tok.span();\n-        if !is_legal_fragment_specifier(sess, features, attrs, frag_spec.name, frag_span) {\n-            return Err(frag_spec.to_string());\n-        }\n-    }\n-    Ok(())\n-}\n-\n-fn is_legal_fragment_specifier(\n-    _sess: &ParseSess,\n-    _features: &Features,\n-    _attrs: &[ast::Attribute],\n-    frag_name: Symbol,\n-    _frag_span: Span,\n-) -> bool {\n-    /*\n-     * If new fragment specifiers are invented in nightly, `_sess`,\n-     * `_features`, `_attrs`, and `_frag_span` will be useful here\n-     * for checking against feature gates. See past versions of\n-     * this function.\n-     */\n-    NonterminalKind::from_symbol(frag_name).is_some() || frag_name == kw::Invalid\n-}\n-\n fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n     match *tt {\n         mbe::TokenTree::Token(ref token) => pprust::token_to_string(&token),\n         mbe::TokenTree::MetaVar(_, name) => format!(\"${}\", name),\n-        mbe::TokenTree::MetaVarDecl(_, name, kind) => format!(\"${}:{}\", name, kind),\n+        mbe::TokenTree::MetaVarDecl(_, name, Some(kind)) => format!(\"${}:{}\", name, kind),\n+        mbe::TokenTree::MetaVarDecl(_, name, None) => format!(\"${}:\", name),\n         _ => panic!(\n             \"unexpected mbe::TokenTree::{{Sequence or Delimited}} \\\n              in follow set checker\""}, {"sha": "774cc84afdeb11df0f8fb7c7c1b3d73d9dcaa057", "filename": "src/librustc_expand/mbe/quoted.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7fdffe183d2bb5bb10ed0558cfa460dee9d319e0/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fdffe183d2bb5bb10ed0558cfa460dee9d319e0/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs?ref=7fdffe183d2bb5bb10ed0558cfa460dee9d319e0", "patch": "@@ -12,6 +12,10 @@ use rustc_span::Span;\n \n use rustc_data_structures::sync::Lrc;\n \n+const VALID_FRAGMENT_NAMES_MSG: &str = \"valid fragment specifiers are \\\n+                                        `ident`, `block`, `stmt`, `expr`, `pat`, `ty`, `lifetime`, \\\n+                                        `literal`, `path`, `meta`, `tt`, `item` and `vis`\";\n+\n /// Takes a `tokenstream::TokenStream` and returns a `Vec<self::TokenTree>`. Specifically, this\n /// takes a generic `TokenStream`, such as is used in the rest of the compiler, and returns a\n /// collection of `TokenTree` for use in parsing a macro.\n@@ -55,9 +59,21 @@ pub(super) fn parse(\n                     Some(tokenstream::TokenTree::Token(Token { kind: token::Colon, span })) => {\n                         match trees.next() {\n                             Some(tokenstream::TokenTree::Token(token)) => match token.ident() {\n-                                Some((kind, _)) => {\n+                                Some((frag, _)) => {\n                                     let span = token.span.with_lo(start_sp.lo());\n-                                    result.push(TokenTree::MetaVarDecl(span, ident, kind));\n+                                    let kind = token::NonterminalKind::from_symbol(frag.name)\n+                                        .unwrap_or_else(|| {\n+                                            let msg = format!(\n+                                                \"invalid fragment specifier `{}`\",\n+                                                frag.name\n+                                            );\n+                                            sess.span_diagnostic\n+                                                .struct_span_err(span, &msg)\n+                                                .help(VALID_FRAGMENT_NAMES_MSG)\n+                                                .emit();\n+                                            token::NonterminalKind::Ident\n+                                        });\n+                                    result.push(TokenTree::MetaVarDecl(span, ident, Some(kind)));\n                                     continue;\n                                 }\n                                 _ => token.span,\n@@ -71,7 +87,7 @@ pub(super) fn parse(\n                     // Macros loaded from other crates have dummy node ids.\n                     sess.missing_fragment_specifiers.borrow_mut().insert(span, node_id);\n                 }\n-                result.push(TokenTree::MetaVarDecl(span, ident, Ident::invalid()));\n+                result.push(TokenTree::MetaVarDecl(span, ident, None));\n             }\n \n             // Not a metavar or no matchers allowed, so just return the tree"}]}