{"sha": "01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxZWI1ZThhZDM5YTU3ZTlmYzMxNTY5OTgzYzFiOWQ1OTA1YTdlNTg=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-04-21T15:58:53Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-04-21T15:58:53Z"}, "message": "Rename Div operator trait to Quot and Modulo operator trait to Rem", "tree": {"sha": "5523ef76c48368ff911e1f7399d2f79f73ba43fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5523ef76c48368ff911e1f7399d2f79f73ba43fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "html_url": "https://github.com/rust-lang/rust/commit/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2104cd69d491c622a70208a7b70a4d948fc30d05", "url": "https://api.github.com/repos/rust-lang/rust/commits/2104cd69d491c622a70208a7b70a4d948fc30d05", "html_url": "https://github.com/rust-lang/rust/commit/2104cd69d491c622a70208a7b70a4d948fc30d05"}], "stats": {"total": 579, "additions": 344, "deletions": 235}, "files": [{"sha": "b1eb5521b398f6837652120cb3efb7ab872a90b8", "filename": "doc/rust.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -1467,10 +1467,10 @@ A complete list of the built-in language items follows:\n   : Elements can be subtracted.\n `mul`\n   : Elements can be multiplied.\n-`div`\n-  : Elements can be divided.\n-`mod`\n-  : Elements have a modulo operation.\n+`quot`\n+  : Elements have a quotient operation.\n+`rem`\n+  : Elements have a remainder operation.\n `neg`\n   : Elements can be negated arithmetically.\n `not`\n@@ -1856,11 +1856,11 @@ The default meaning of the operators on standard types is given here.\n   : Multiplication.\n     Calls the `mul` method on the `core::ops::Mul` trait.\n `/`\n-  : Division.\n-    Calls the `div` method on the `core::ops::Div` trait.\n+  : Quotient.\n+    Calls the `quot` method on the `core::ops::Quot` trait.\n `%`\n-  : Modulo (a.k.a. \"remainder\").\n-    Calls the `modulo` method on the `core::ops::Modulo` trait.\n+  : Remainder.\n+    Calls the `rem` method on the `core::ops::Rem` trait.\n \n #### Bitwise operators\n "}, {"sha": "c10bc8a294c5d665cae3a1ffb90a36b6d7ebf451", "filename": "doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -362,7 +362,7 @@ The nil type, written `()`, has a single value, also written `()`.\n ## Operators\n \n Rust's set of operators contains very few surprises. Arithmetic is done with\n-`*`, `/`, `%`, `+`, and `-` (multiply, divide, take remainder, add, and subtract). `-` is\n+`*`, `/`, `%`, `+`, and `-` (multiply, quotient, remainder, add, and subtract). `-` is\n also a unary prefix operator that negates numbers. As in C, the bitwise operators\n `>>`, `<<`, `&`, `|`, and `^` are also supported.\n "}, {"sha": "6a751bd1c858833b9d273d0a4abc22cdc5f9f9ef", "filename": "src/etc/kate/rust.xml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Fetc%2Fkate%2Frust.xml", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Fetc%2Fkate%2Frust.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fkate%2Frust.xml?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -57,8 +57,8 @@\n \t\t<item> Add </item>\n \t\t<item> Sub </item>\n \t\t<item> Mul </item>\n-\t\t<item> Div </item>\n-\t\t<item> Modulo </item>\n+\t\t<item> Quot </item>\n+\t\t<item> Rem </item>\n \t\t<item> Neg </item>\n \t\t<item> BitAnd </item>\n \t\t<item> BitOr </item>"}, {"sha": "eab3627ae16d15d1eae938be0d4c8fcbed94b5f6", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -46,7 +46,7 @@ syn keyword   rustType        off_t dev_t ino_t pid_t mode_t ssize_t\n \n syn keyword   rustTrait       Const Copy Send Owned \" inherent traits\n syn keyword   rustTrait       Eq Ord Num Ptr\n-syn keyword   rustTrait       Drop Add Sub Mul Div Modulo Neg BitAnd BitOr\n+syn keyword   rustTrait       Drop Add Sub Mul Quot Rem Neg BitAnd BitOr\n syn keyword   rustTrait       BitXor Shl Shr Index\n \n syn keyword   rustSelf        self"}, {"sha": "fd8813d0c4a4573dfcd79da0e0b3e65b569efdb1", "filename": "src/libcore/core.rc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -75,7 +75,12 @@ they contained the following prologue:\n \n pub use kinds::{Const, Copy, Owned, Durable};\n pub use ops::{Drop};\n+#[cfg(stage0)]\n pub use ops::{Add, Sub, Mul, Div, Modulo, Neg, Not};\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+pub use ops::{Add, Sub, Mul, Quot, Rem, Neg, Not};\n pub use ops::{BitAnd, BitOr, BitXor};\n pub use ops::{Shl, Shr, Index};\n "}, {"sha": "2e7dc98e3c56c2ecf8ea8014569aab38c4312423", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -16,8 +16,13 @@ use option::Option;\n use from_str;\n use to_str;\n \n-#[cfg(notest)] use cmp;\n-#[cfg(notest)] use ops;\n+#[cfg(notest)] use cmp::{Eq, Ord};\n+#[cfg(stage0,notest)]\n+use ops::{Add, Sub, Mul, Div, Modulo, Neg};\n+#[cfg(stage1,notest)]\n+#[cfg(stage2,notest)]\n+#[cfg(stage3,notest)]\n+use ops::{Add, Sub, Mul, Quot, Rem, Neg};\n \n pub use cmath::c_float_targ_consts::*;\n \n@@ -131,7 +136,7 @@ pub fn sub(x: f32, y: f32) -> f32 { return x - y; }\n pub fn mul(x: f32, y: f32) -> f32 { return x * y; }\n \n #[inline(always)]\n-pub fn div(x: f32, y: f32) -> f32 { return x / y; }\n+pub fn quot(x: f32, y: f32) -> f32 { return x / y; }\n \n #[inline(always)]\n pub fn rem(x: f32, y: f32) -> f32 { return x % y; }\n@@ -265,15 +270,15 @@ pub fn logarithm(n: f32, b: f32) -> f32 {\n }\n \n #[cfg(notest)]\n-impl cmp::Eq for f32 {\n+impl Eq for f32 {\n     #[inline(always)]\n     fn eq(&self, other: &f32) -> bool { (*self) == (*other) }\n     #[inline(always)]\n     fn ne(&self, other: &f32) -> bool { (*self) != (*other) }\n }\n \n #[cfg(notest)]\n-impl cmp::Ord for f32 {\n+impl Ord for f32 {\n     #[inline(always)]\n     fn lt(&self, other: &f32) -> bool { (*self) < (*other) }\n     #[inline(always)]\n@@ -295,33 +300,41 @@ impl num::One for f32 {\n }\n \n #[cfg(notest)]\n-impl ops::Add<f32,f32> for f32 {\n-    #[inline(always)]\n+impl Add<f32,f32> for f32 {\n     fn add(&self, other: &f32) -> f32 { *self + *other }\n }\n #[cfg(notest)]\n-impl ops::Sub<f32,f32> for f32 {\n-    #[inline(always)]\n+impl Sub<f32,f32> for f32 {\n     fn sub(&self, other: &f32) -> f32 { *self - *other }\n }\n #[cfg(notest)]\n-impl ops::Mul<f32,f32> for f32 {\n-    #[inline(always)]\n+impl Mul<f32,f32> for f32 {\n     fn mul(&self, other: &f32) -> f32 { *self * *other }\n }\n-#[cfg(notest)]\n-impl ops::Div<f32,f32> for f32 {\n-    #[inline(always)]\n+#[cfg(stage0,notest)]\n+impl Div<f32,f32> for f32 {\n     fn div(&self, other: &f32) -> f32 { *self / *other }\n }\n-#[cfg(notest)]\n-impl ops::Modulo<f32,f32> for f32 {\n+#[cfg(stage1,notest)]\n+#[cfg(stage2,notest)]\n+#[cfg(stage3,notest)]\n+impl Quot<f32,f32> for f32 {\n     #[inline(always)]\n+    fn quot(&self, other: &f32) -> f32 { *self / *other }\n+}\n+#[cfg(stage0,notest)]\n+impl Modulo<f32,f32> for f32 {\n     fn modulo(&self, other: &f32) -> f32 { *self % *other }\n }\n-#[cfg(notest)]\n-impl ops::Neg<f32> for f32 {\n+#[cfg(stage1,notest)]\n+#[cfg(stage2,notest)]\n+#[cfg(stage3,notest)]\n+impl Rem<f32,f32> for f32 {\n     #[inline(always)]\n+    fn rem(&self, other: &f32) -> f32 { *self % *other }\n+}\n+#[cfg(notest)]\n+impl Neg<f32> for f32 {\n     fn neg(&self) -> f32 { -*self }\n }\n "}, {"sha": "4762c395a2561a745ca4784077e218ba2b130cb6", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -16,8 +16,13 @@ use option::Option;\n use to_str;\n use from_str;\n \n-#[cfg(notest)] use cmp;\n-#[cfg(notest)] use ops;\n+#[cfg(notest)] use cmp::{Eq, Ord};\n+#[cfg(stage0,notest)]\n+use ops::{Add, Sub, Mul, Div, Modulo, Neg};\n+#[cfg(stage1,notest)]\n+#[cfg(stage2,notest)]\n+#[cfg(stage3,notest)]\n+use ops::{Add, Sub, Mul, Quot, Rem, Neg};\n \n pub use cmath::c_double_targ_consts::*;\n pub use cmp::{min, max};\n@@ -155,7 +160,7 @@ pub fn sub(x: f64, y: f64) -> f64 { return x - y; }\n pub fn mul(x: f64, y: f64) -> f64 { return x * y; }\n \n #[inline(always)]\n-pub fn div(x: f64, y: f64) -> f64 { return x / y; }\n+pub fn quot(x: f64, y: f64) -> f64 { return x / y; }\n \n #[inline(always)]\n pub fn rem(x: f64, y: f64) -> f64 { return x % y; }\n@@ -284,15 +289,15 @@ pub fn logarithm(n: f64, b: f64) -> f64 {\n }\n \n #[cfg(notest)]\n-impl cmp::Eq for f64 {\n+impl Eq for f64 {\n     #[inline(always)]\n     fn eq(&self, other: &f64) -> bool { (*self) == (*other) }\n     #[inline(always)]\n     fn ne(&self, other: &f64) -> bool { (*self) != (*other) }\n }\n \n #[cfg(notest)]\n-impl cmp::Ord for f64 {\n+impl Ord for f64 {\n     #[inline(always)]\n     fn lt(&self, other: &f64) -> bool { (*self) < (*other) }\n     #[inline(always)]\n@@ -314,33 +319,41 @@ impl num::One for f64 {\n }\n \n #[cfg(notest)]\n-impl ops::Add<f64,f64> for f64 {\n-    #[inline(always)]\n+impl Add<f64,f64> for f64 {\n     fn add(&self, other: &f64) -> f64 { *self + *other }\n }\n #[cfg(notest)]\n-impl ops::Sub<f64,f64> for f64 {\n-    #[inline(always)]\n+impl Sub<f64,f64> for f64 {\n     fn sub(&self, other: &f64) -> f64 { *self - *other }\n }\n #[cfg(notest)]\n-impl ops::Mul<f64,f64> for f64 {\n-    #[inline(always)]\n+impl Mul<f64,f64> for f64 {\n     fn mul(&self, other: &f64) -> f64 { *self * *other }\n }\n-#[cfg(notest)]\n-impl ops::Div<f64,f64> for f64 {\n-    #[inline(always)]\n+#[cfg(stage0,notest)]\n+impl Div<f64,f64> for f64 {\n     fn div(&self, other: &f64) -> f64 { *self / *other }\n }\n-#[cfg(notest)]\n-impl ops::Modulo<f64,f64> for f64 {\n+#[cfg(stage1,notest)]\n+#[cfg(stage2,notest)]\n+#[cfg(stage3,notest)]\n+impl Quot<f64,f64> for f64 {\n     #[inline(always)]\n+    fn quot(&self, other: &f64) -> f64 { *self / *other }\n+}\n+#[cfg(stage0,notest)]\n+impl Modulo<f64,f64> for f64 {\n     fn modulo(&self, other: &f64) -> f64 { *self % *other }\n }\n-#[cfg(notest)]\n-impl ops::Neg<f64> for f64 {\n+#[cfg(stage1,notest)]\n+#[cfg(stage2,notest)]\n+#[cfg(stage3,notest)]\n+impl Rem<f64,f64> for f64 {\n     #[inline(always)]\n+    fn rem(&self, other: &f64) -> f64 { *self % *other }\n+}\n+#[cfg(notest)]\n+impl Neg<f64> for f64 {\n     fn neg(&self) -> f64 { -*self }\n }\n "}, {"sha": "9cf14cf0f494bbc340ab514007be50dd0d935795", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -28,9 +28,14 @@ use to_str;\n use from_str;\n \n #[cfg(notest)] use cmp::{Eq, Ord};\n-#[cfg(notest)] use ops;\n-\n-pub use f64::{add, sub, mul, div, rem, lt, le, eq, ne, ge, gt};\n+#[cfg(stage0,notest)]\n+use ops::{Add, Sub, Mul, Div, Modulo, Neg};\n+#[cfg(stage1,notest)]\n+#[cfg(stage2,notest)]\n+#[cfg(stage3,notest)]\n+use ops::{Add, Sub, Mul, Quot, Rem, Neg};\n+\n+pub use f64::{add, sub, mul, quot, rem, lt, le, eq, ne, ge, gt};\n pub use f64::logarithm;\n pub use f64::{acos, asin, atan2, cbrt, ceil, copysign, cosh, floor};\n pub use f64::{erf, erfc, exp, expm1, exp2, abs_sub};\n@@ -449,33 +454,41 @@ impl num::Round for float {\n }\n \n #[cfg(notest)]\n-impl ops::Add<float,float> for float {\n-    #[inline(always)]\n+impl Add<float,float> for float {\n     fn add(&self, other: &float) -> float { *self + *other }\n }\n #[cfg(notest)]\n-impl ops::Sub<float,float> for float {\n-    #[inline(always)]\n+impl Sub<float,float> for float {\n     fn sub(&self, other: &float) -> float { *self - *other }\n }\n #[cfg(notest)]\n-impl ops::Mul<float,float> for float {\n-    #[inline(always)]\n+impl Mul<float,float> for float {\n     fn mul(&self, other: &float) -> float { *self * *other }\n }\n-#[cfg(notest)]\n-impl ops::Div<float,float> for float {\n-    #[inline(always)]\n+#[cfg(stage0,notest)]\n+impl Div<float,float> for float {\n     fn div(&self, other: &float) -> float { *self / *other }\n }\n-#[cfg(notest)]\n-impl ops::Modulo<float,float> for float {\n+#[cfg(stage1,notest)]\n+#[cfg(stage2,notest)]\n+#[cfg(stage3,notest)]\n+impl Quot<float,float> for float {\n     #[inline(always)]\n+    fn quot(&self, other: &float) -> float { *self / *other }\n+}\n+#[cfg(stage0,notest)]\n+impl Modulo<float,float> for float {\n     fn modulo(&self, other: &float) -> float { *self % *other }\n }\n-#[cfg(notest)]\n-impl ops::Neg<float> for float {\n+#[cfg(stage1,notest)]\n+#[cfg(stage2,notest)]\n+#[cfg(stage3,notest)]\n+impl Rem<float,float> for float {\n     #[inline(always)]\n+    fn rem(&self, other: &float) -> float { *self % *other }\n+}\n+#[cfg(notest)]\n+impl Neg<float> for float {\n     fn neg(&self) -> float { -*self }\n }\n "}, {"sha": "8f448994c98115f8e45a0ae83d3e693f9a046d54", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -17,8 +17,6 @@ use num::strconv;\n use num;\n use prelude::*;\n \n-#[cfg(notest)] use cmp::{Eq, Ord};\n-\n pub use cmp::{min, max};\n \n pub static bits : uint = inst::bits;\n@@ -34,7 +32,7 @@ pub fn sub(x: T, y: T) -> T { x - y }\n #[inline(always)]\n pub fn mul(x: T, y: T) -> T { x * y }\n #[inline(always)]\n-pub fn div(x: T, y: T) -> T { x / y }\n+pub fn quot(x: T, y: T) -> T { x / y }\n \n /**\n  * Returns the remainder of y / x.\n@@ -176,63 +174,71 @@ impl num::One for T {\n }\n \n #[cfg(notest)]\n-impl ops::Add<T,T> for T {\n-    #[inline(always)]\n+impl Add<T,T> for T {\n     fn add(&self, other: &T) -> T { *self + *other }\n }\n #[cfg(notest)]\n-impl ops::Sub<T,T> for T {\n-    #[inline(always)]\n+impl Sub<T,T> for T {\n     fn sub(&self, other: &T) -> T { *self - *other }\n }\n #[cfg(notest)]\n-impl ops::Mul<T,T> for T {\n-    #[inline(always)]\n+impl Mul<T,T> for T {\n     fn mul(&self, other: &T) -> T { *self * *other }\n }\n-#[cfg(notest)]\n-impl ops::Div<T,T> for T {\n-    #[inline(always)]\n+#[cfg(stage0,notest)]\n+impl Div<T,T> for T {\n     fn div(&self, other: &T) -> T { *self / *other }\n }\n-#[cfg(notest)]\n-impl ops::Modulo<T,T> for T {\n+#[cfg(stage1,notest)]\n+#[cfg(stage2,notest)]\n+#[cfg(stage3,notest)]\n+impl Quot<T,T> for T {\n     #[inline(always)]\n+    fn quot(&self, other: &T) -> T { *self / *other }\n+}\n+#[cfg(stage0,notest)]\n+impl Modulo<T,T> for T {\n     fn modulo(&self, other: &T) -> T { *self % *other }\n }\n-#[cfg(notest)]\n-impl ops::Neg<T> for T {\n+#[cfg(stage1,notest)]\n+#[cfg(stage2,notest)]\n+#[cfg(stage3,notest)]\n+impl Rem<T,T> for T {\n     #[inline(always)]\n+    fn rem(&self, other: &T) -> T { *self % *other }\n+}\n+#[cfg(notest)]\n+impl Neg<T> for T {\n     fn neg(&self) -> T { -*self }\n }\n \n #[cfg(notest)]\n-impl ops::BitOr<T,T> for T {\n+impl BitOr<T,T> for T {\n     #[inline(always)]\n     fn bitor(&self, other: &T) -> T { *self | *other }\n }\n #[cfg(notest)]\n-impl ops::BitAnd<T,T> for T {\n+impl BitAnd<T,T> for T {\n     #[inline(always)]\n     fn bitand(&self, other: &T) -> T { *self & *other }\n }\n #[cfg(notest)]\n-impl ops::BitXor<T,T> for T {\n+impl BitXor<T,T> for T {\n     #[inline(always)]\n     fn bitxor(&self, other: &T) -> T { *self ^ *other }\n }\n #[cfg(notest)]\n-impl ops::Shl<T,T> for T {\n+impl Shl<T,T> for T {\n     #[inline(always)]\n     fn shl(&self, other: &T) -> T { *self << *other }\n }\n #[cfg(notest)]\n-impl ops::Shr<T,T> for T {\n+impl Shr<T,T> for T {\n     #[inline(always)]\n     fn shr(&self, other: &T) -> T { *self >> *other }\n }\n #[cfg(notest)]\n-impl ops::Not<T> for T {\n+impl Not<T> for T {\n     #[inline(always)]\n     fn not(&self) -> T { !*self }\n }"}, {"sha": "a0ff510cde7da0bd04646a134e77a1346e18d027", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -10,7 +10,16 @@\n \n //! An interface for numeric types\n use cmp::{Eq, Ord};\n-use ops::{Neg, Add, Sub, Mul, Div, Modulo};\n+#[cfg(stage0)]\n+use ops::{Add, Sub, Mul, Neg};\n+#[cfg(stage0)]\n+use Quot = ops::Div;\n+#[cfg(stage0)]\n+use Rem = ops::Modulo;\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+use ops::{Add, Sub, Mul, Quot, Rem, Neg};\n use option::Option;\n use kinds::Copy;\n \n@@ -21,8 +30,8 @@ pub trait Num: Eq + Zero + One\n              + Add<Self,Self>\n              + Sub<Self,Self>\n              + Mul<Self,Self>\n-             + Div<Self,Self>\n-             + Modulo<Self,Self> {}\n+             + Quot<Self,Self>\n+             + Rem<Self,Self> {}\n \n impl Num for u8 {}\n impl Num for u16 {}\n@@ -174,7 +183,7 @@ pub trait FromStrRadix {\n  * - If code written to use this function doesn't care about it, it's\n  *   probably assuming that `x^0` always equals `1`.\n  */\n-pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Div<T,T>+Mul<T,T>>(\n+pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Quot<T,T>+Mul<T,T>>(\n     radix: uint, pow: uint) -> T {\n     let _0: T = Zero::zero();\n     let _1: T = One::one();\n@@ -194,7 +203,7 @@ pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Div<T,T>+Mul<T,T>>(\n     total\n }\n \n-#[cfg(test)]\n+#[cfg(stage0,test)]\n fn test_num<T:Num + NumCast>(ten: T, two: T) {\n     assert_eq!(ten.add(&two),    cast(12));\n     assert_eq!(ten.sub(&two),    cast(8));\n@@ -208,6 +217,22 @@ fn test_num<T:Num + NumCast>(ten: T, two: T) {\n     assert_eq!(ten.div(&two),    ten / two);\n     assert_eq!(ten.modulo(&two), ten % two);\n }\n+#[cfg(stage1,test)]\n+#[cfg(stage2,test)]\n+#[cfg(stage3,test)]\n+fn test_num<T:Num + NumCast>(ten: T, two: T) {\n+    assert_eq!(ten.add(&two),  cast(12));\n+    assert_eq!(ten.sub(&two),  cast(8));\n+    assert_eq!(ten.mul(&two),  cast(20));\n+    assert_eq!(ten.quot(&two), cast(5));\n+    assert_eq!(ten.rem(&two),  cast(0));\n+\n+    assert_eq!(ten.add(&two),  ten + two);\n+    assert_eq!(ten.sub(&two),  ten - two);\n+    assert_eq!(ten.mul(&two),  ten * two);\n+    assert_eq!(ten.quot(&two), ten / two);\n+    assert_eq!(ten.rem(&two),  ten % two);\n+}\n \n #[test] fn test_u8_num()    { test_num(10u8,  2u8)  }\n #[test] fn test_u16_num()   { test_num(10u16, 2u16) }"}, {"sha": "4a45a1d97023e1817dbbfab1a67fee1c6bec20e4", "filename": "src/libcore/num/strconv.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibcore%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibcore%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fstrconv.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -9,7 +9,16 @@\n // except according to those terms.\n \n use core::cmp::{Ord, Eq};\n-use ops::{Add, Div, Modulo, Mul, Neg, Sub};\n+#[cfg(stage0)]\n+use ops::{Add, Sub, Mul, Neg};\n+#[cfg(stage0)]\n+use Quot = ops::Div;\n+#[cfg(stage0)]\n+use Rem = ops::Modulo;\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+use ops::{Add, Sub, Mul, Quot, Rem, Neg};\n use option::{None, Option, Some};\n use char;\n use str;\n@@ -58,7 +67,7 @@ fn is_neg_inf<T:Eq+NumStrConv>(num: &T) -> bool {\n }\n \n #[inline(always)]\n-fn is_neg_zero<T:Eq+One+Zero+NumStrConv+Div<T,T>>(num: &T) -> bool {\n+fn is_neg_zero<T:Eq+One+Zero+NumStrConv+Quot<T,T>>(num: &T) -> bool {\n     let _0: T = Zero::zero();\n     let _1: T = One::one();\n \n@@ -171,7 +180,7 @@ static nan_buf:          [u8, ..3] = ['N' as u8, 'a' as u8, 'N' as u8];\n  * - Fails if `radix` < 2 or `radix` > 36.\n  */\n pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n-                                  Div<T,T>+Neg<T>+Modulo<T,T>+Mul<T,T>>(\n+                                  Quot<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: &T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits) -> (~[u8], bool) {\n     if (radix as int) < 2 {\n@@ -379,7 +388,7 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n  */\n #[inline(always)]\n pub fn to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n-                            Div<T,T>+Neg<T>+Modulo<T,T>+Mul<T,T>>(\n+                            Quot<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: &T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits) -> (~str, bool) {\n     let (bytes, special) = to_str_bytes_common(num, radix,\n@@ -432,7 +441,7 @@ priv static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n  * - Fails if `radix` > 18 and `special == true` due to conflict\n  *   between digit and lowest first character in `inf` and `NaN`, the `'i'`.\n  */\n-pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n+pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Quot<T,T>+\n                                     Mul<T,T>+Sub<T,T>+Neg<T>+Add<T,T>+\n                                     NumStrConv>(\n         buf: &[u8], radix: uint, negative: bool, fractional: bool,\n@@ -629,7 +638,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n  * `from_str_bytes_common()`, for details see there.\n  */\n #[inline(always)]\n-pub fn from_str_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+Mul<T,T>+\n+pub fn from_str_common<T:NumCast+Zero+One+Eq+Ord+Copy+Quot<T,T>+Mul<T,T>+\n                               Sub<T,T>+Neg<T>+Add<T,T>+NumStrConv>(\n         buf: &str, radix: uint, negative: bool, fractional: bool,\n         special: bool, exponent: ExponentFormat, empty_zero: bool,"}, {"sha": "6f3f402f92d69022f2d387ec6edeea442f729e7e", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -19,8 +19,6 @@ use num;\n use option::Option;\n use prelude::*;\n \n-#[cfg(notest)] use cmp::{Eq, Ord};\n-\n pub use cmp::{min, max};\n \n pub static bits : uint = inst::bits;\n@@ -36,7 +34,7 @@ pub fn sub(x: T, y: T) -> T { x - y }\n #[inline(always)]\n pub fn mul(x: T, y: T) -> T { x * y }\n #[inline(always)]\n-pub fn div(x: T, y: T) -> T { x / y }\n+pub fn quot(x: T, y: T) -> T { x / y }\n #[inline(always)]\n pub fn rem(x: T, y: T) -> T { x % y }\n \n@@ -141,63 +139,71 @@ impl num::One for T {\n }\n \n #[cfg(notest)]\n-impl ops::Add<T,T> for T {\n-    #[inline(always)]\n+impl Add<T,T> for T {\n     fn add(&self, other: &T) -> T { *self + *other }\n }\n #[cfg(notest)]\n-impl ops::Sub<T,T> for T {\n-    #[inline(always)]\n+impl Sub<T,T> for T {\n     fn sub(&self, other: &T) -> T { *self - *other }\n }\n #[cfg(notest)]\n-impl ops::Mul<T,T> for T {\n-    #[inline(always)]\n+impl Mul<T,T> for T {\n     fn mul(&self, other: &T) -> T { *self * *other }\n }\n-#[cfg(notest)]\n-impl ops::Div<T,T> for T {\n-    #[inline(always)]\n+#[cfg(stage0,notest)]\n+impl Div<T,T> for T {\n     fn div(&self, other: &T) -> T { *self / *other }\n }\n-#[cfg(notest)]\n-impl ops::Modulo<T,T> for T {\n+#[cfg(stage1,notest)]\n+#[cfg(stage2,notest)]\n+#[cfg(stage3,notest)]\n+impl Quot<T,T> for T {\n     #[inline(always)]\n+    fn quot(&self, other: &T) -> T { *self / *other }\n+}\n+#[cfg(stage0,notest)]\n+impl Modulo<T,T> for T {\n     fn modulo(&self, other: &T) -> T { *self % *other }\n }\n-#[cfg(notest)]\n-impl ops::Neg<T> for T {\n+#[cfg(stage1,notest)]\n+#[cfg(stage2,notest)]\n+#[cfg(stage3,notest)]\n+impl Rem<T,T> for T {\n     #[inline(always)]\n+    fn rem(&self, other: &T) -> T { *self % *other }\n+}\n+#[cfg(notest)]\n+impl Neg<T> for T {\n     fn neg(&self) -> T { -*self }\n }\n \n #[cfg(notest)]\n-impl ops::BitOr<T,T> for T {\n+impl BitOr<T,T> for T {\n     #[inline(always)]\n     fn bitor(&self, other: &T) -> T { *self | *other }\n }\n #[cfg(notest)]\n-impl ops::BitAnd<T,T> for T {\n+impl BitAnd<T,T> for T {\n     #[inline(always)]\n     fn bitand(&self, other: &T) -> T { *self & *other }\n }\n #[cfg(notest)]\n-impl ops::BitXor<T,T> for T {\n+impl BitXor<T,T> for T {\n     #[inline(always)]\n     fn bitxor(&self, other: &T) -> T { *self ^ *other }\n }\n #[cfg(notest)]\n-impl ops::Shl<T,T> for T {\n+impl Shl<T,T> for T {\n     #[inline(always)]\n     fn shl(&self, other: &T) -> T { *self << *other }\n }\n #[cfg(notest)]\n-impl ops::Shr<T,T> for T {\n+impl Shr<T,T> for T {\n     #[inline(always)]\n     fn shr(&self, other: &T) -> T { *self >> *other }\n }\n #[cfg(notest)]\n-impl ops::Not<T> for T {\n+impl Not<T> for T {\n     #[inline(always)]\n     fn not(&self) -> T { !*self }\n }"}, {"sha": "465a9330f74c0a6e20eab48dc633e66270695abf", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -31,14 +31,30 @@ pub trait Mul<RHS,Result> {\n }\n \n #[lang=\"div\"]\n+#[cfg(stage0)]\n pub trait Div<RHS,Result> {\n     fn div(&self, rhs: &RHS) -> Result;\n }\n+#[lang=\"quot\"]\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+pub trait Quot<RHS,Result> {\n+    fn quot(&self, rhs: &RHS) -> Result;\n+}\n \n #[lang=\"modulo\"]\n+#[cfg(stage0)]\n pub trait Modulo<RHS,Result> {\n     fn modulo(&self, rhs: &RHS) -> Result;\n }\n+#[lang=\"rem\"]\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+pub trait Rem<RHS,Result> {\n+    fn rem(&self, rhs: &RHS) -> Result;\n+}\n \n #[lang=\"neg\"]\n pub trait Neg<Result> {"}, {"sha": "7d8b3edcab15232615ac8c4812f33e252e7f02ca", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -14,7 +14,12 @@\n \n pub use either::{Either, Left, Right};\n pub use kinds::{Const, Copy, Owned, Durable};\n+#[cfg(stage0)]\n pub use ops::{Add, Sub, Mul, Div, Modulo, Neg, Not};\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+pub use ops::{Add, Sub, Mul, Quot, Rem, Neg, Not};\n pub use ops::{BitAnd, BitOr, BitXor};\n pub use ops::{Drop};\n pub use ops::{Shl, Shr, Index};"}, {"sha": "c1cc01ed05a724a84eb71328a429473b80713979", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -283,7 +283,7 @@ pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n               add => Ok(const_float(a + b)),\n               subtract => Ok(const_float(a - b)),\n               mul => Ok(const_float(a * b)),\n-              div => Ok(const_float(a / b)),\n+              quot => Ok(const_float(a / b)),\n               rem => Ok(const_float(a % b)),\n               eq => fromb(a == b),\n               lt => fromb(a < b),\n@@ -299,9 +299,9 @@ pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n               add => Ok(const_int(a + b)),\n               subtract => Ok(const_int(a - b)),\n               mul => Ok(const_int(a * b)),\n-              div if b == 0 => Err(~\"divide by zero\"),\n-              div => Ok(const_int(a / b)),\n-              rem if b == 0 => Err(~\"modulo zero\"),\n+              quot if b == 0 => Err(~\"quotient zero\"),\n+              quot => Ok(const_int(a / b)),\n+              rem if b == 0 => Err(~\"remainder zero\"),\n               rem => Ok(const_int(a % b)),\n               and | bitand => Ok(const_int(a & b)),\n               or | bitor => Ok(const_int(a | b)),\n@@ -321,9 +321,9 @@ pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n               add => Ok(const_uint(a + b)),\n               subtract => Ok(const_uint(a - b)),\n               mul => Ok(const_uint(a * b)),\n-              div if b == 0 => Err(~\"divide by zero\"),\n-              div => Ok(const_uint(a / b)),\n-              rem if b == 0 => Err(~\"modulo zero\"),\n+              quot if b == 0 => Err(~\"quotient zero\"),\n+              quot => Ok(const_uint(a / b)),\n+              rem if b == 0 => Err(~\"remainder zero\"),\n               rem => Ok(const_uint(a % b)),\n               and | bitand => Ok(const_uint(a & b)),\n               or | bitor => Ok(const_uint(a | b)),"}, {"sha": "0558df60b73037e60e82b5ba4372ee62c541fced", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -480,7 +480,7 @@ pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n \n /// This is rather subtle.  When we are casting a value to a instantiated\n /// trait like `a as trait<'r>`, regionck already ensures that any borrowed\n-/// pointers that appear in the type of `a` are bounded by `'r` (ed.: modulo\n+/// pointers that appear in the type of `a` are bounded by `'r` (ed.: rem\n /// FIXME(#5723)).  However, it is possible that there are *type parameters*\n /// in the type of `a`, and those *type parameters* may have borrowed pointers\n /// within them.  We have to guarantee that the regions which appear in those"}, {"sha": "5b302108ef062f94ba763084ee2a053ff4e19fea", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -45,8 +45,8 @@ pub enum LangItem {\n     AddTraitLangItem,           // 5\n     SubTraitLangItem,           // 6\n     MulTraitLangItem,           // 7\n-    DivTraitLangItem,           // 8\n-    ModuloTraitLangItem,        // 9\n+    QuotTraitLangItem,          // 8\n+    RemTraitLangItem,           // 9\n     NegTraitLangItem,           // 10\n     NotTraitLangItem,           // 11\n     BitXorTraitLangItem,        // 12\n@@ -108,8 +108,8 @@ pub impl LanguageItems {\n             5  => \"add\",\n             6  => \"sub\",\n             7  => \"mul\",\n-            8  => \"div\",\n-            9  => \"modulo\",\n+            8  => \"quot\",\n+            9  => \"rem\",\n             10 => \"neg\",\n             11 => \"not\",\n             12 => \"bitxor\",\n@@ -170,11 +170,11 @@ pub impl LanguageItems {\n     pub fn mul_trait(&const self) -> def_id {\n         self.items[MulTraitLangItem as uint].get()\n     }\n-    pub fn div_trait(&const self) -> def_id {\n-        self.items[DivTraitLangItem as uint].get()\n+    pub fn quot_trait(&const self) -> def_id {\n+        self.items[QuotTraitLangItem as uint].get()\n     }\n-    pub fn modulo_trait(&const self) -> def_id {\n-        self.items[ModuloTraitLangItem as uint].get()\n+    pub fn rem_trait(&const self) -> def_id {\n+        self.items[RemTraitLangItem as uint].get()\n     }\n     pub fn neg_trait(&const self) -> def_id {\n         self.items[NegTraitLangItem as uint].get()\n@@ -271,8 +271,8 @@ fn LanguageItemCollector<'r>(crate: @crate,\n     item_refs.insert(@~\"add\", AddTraitLangItem as uint);\n     item_refs.insert(@~\"sub\", SubTraitLangItem as uint);\n     item_refs.insert(@~\"mul\", MulTraitLangItem as uint);\n-    item_refs.insert(@~\"div\", DivTraitLangItem as uint);\n-    item_refs.insert(@~\"modulo\", ModuloTraitLangItem as uint);\n+    item_refs.insert(@~\"quot\", QuotTraitLangItem as uint);\n+    item_refs.insert(@~\"rem\", RemTraitLangItem as uint);\n     item_refs.insert(@~\"neg\", NegTraitLangItem as uint);\n     item_refs.insert(@~\"not\", NotTraitLangItem as uint);\n     item_refs.insert(@~\"bitxor\", BitXorTraitLangItem as uint);"}, {"sha": "41b372119cd292f103361f820067840073ddb72c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -37,7 +37,7 @@ use syntax::ast::{def_upvar, def_use, def_variant, expr, expr_assign_op};\n use syntax::ast::{expr_binary, expr_break, expr_field};\n use syntax::ast::{expr_fn_block, expr_index, expr_method_call, expr_path};\n use syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param};\n-use syntax::ast::{def_upvar, def_use, def_variant, div, eq};\n+use syntax::ast::{def_upvar, def_use, def_variant, quot, eq};\n use syntax::ast::{expr, expr_again, expr_assign_op};\n use syntax::ast::{expr_index, expr_loop};\n use syntax::ast::{expr_path, expr_struct, expr_unary, fn_decl};\n@@ -4899,13 +4899,13 @@ pub impl Resolver {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.mul_trait());\n             }\n-            expr_binary(div, _, _) | expr_assign_op(div, _, _) => {\n+            expr_binary(quot, _, _) | expr_assign_op(quot, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n-                                              self.lang_items.div_trait());\n+                                              self.lang_items.quot_trait());\n             }\n             expr_binary(rem, _, _) | expr_assign_op(rem, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n-                                              self.lang_items.modulo_trait());\n+                                              self.lang_items.rem_trait());\n             }\n             expr_binary(bitxor, _, _) | expr_assign_op(bitxor, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,"}, {"sha": "3ad021b2f518fb8a8af3da7b815e6f597ad13214", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -782,12 +782,12 @@ pub fn cast_shift_rhs(op: ast::binop,\n     }\n }\n \n-pub fn fail_if_zero(cx: block, span: span, divmod: ast::binop,\n+pub fn fail_if_zero(cx: block, span: span, quotrem: ast::binop,\n                     rhs: ValueRef, rhs_t: ty::t) -> block {\n-    let text = if divmod == ast::div {\n-        @~\"divide by zero\"\n+    let text = if quotrem == ast::quot {\n+        @~\"quotient zero\"\n     } else {\n-        @~\"modulo zero\"\n+        @~\"remainder zero\"\n     };\n     let is_zero = match ty::get(rhs_t).sty {\n       ty::ty_int(t) => {"}, {"sha": "d0aeec89750aafde7ee3e09da2c662df35661a9b", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -272,7 +272,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                 if is_float { llvm::LLVMConstFMul(te1, te2) }\n                 else        { llvm::LLVMConstMul(te1, te2) }\n               }\n-              ast::div    => {\n+              ast::quot   => {\n                 if is_float    { llvm::LLVMConstFDiv(te1, te2) }\n                 else if signed { llvm::LLVMConstSDiv(te1, te2) }\n                 else           { llvm::LLVMConstUDiv(te1, te2) }"}, {"sha": "4b4d0869a3ed3aa87e999a670a74c054eb5b5d45", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -1437,7 +1437,7 @@ fn trans_eager_binop(bcx: block,\n         if is_float { FMul(bcx, lhs, rhs) }\n         else { Mul(bcx, lhs, rhs) }\n       }\n-      ast::div => {\n+      ast::quot => {\n         if is_float {\n             FDiv(bcx, lhs, rhs)\n         } else {"}, {"sha": "033fbecc08b37ec03246a61374036d75fd16453b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -4255,7 +4255,7 @@ pub fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n           ast::add => opcat_add,\n           ast::subtract => opcat_sub,\n           ast::mul => opcat_mult,\n-          ast::div => opcat_mult,\n+          ast::quot => opcat_mult,\n           ast::rem => opcat_mult,\n           ast::and => opcat_logic,\n           ast::or => opcat_logic,"}, {"sha": "cbdd2b19d276c92bfa1e21f6a96fd66934ce4a79", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -118,7 +118,7 @@ pub trait FromBase64 {\n impl FromBase64 for ~[u8] {\n     /**\n      * Convert base64 `u8` vector into u8 byte values.\n-     * Every 4 encoded characters is converted into 3 octets, modulo padding.\n+     * Every 4 encoded characters is converted into 3 octets, rem padding.\n      *\n      * *Example*:\n      *"}, {"sha": "08c65d190bf99e29c039c2e07258830f0a0011e6", "filename": "src/libstd/num/bigint.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibstd%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibstd%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fbigint.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -262,16 +262,16 @@ impl Mul<BigUint, BigUint> for BigUint {\n     }\n }\n \n-impl Div<BigUint, BigUint> for BigUint {\n-    fn div(&self, other: &BigUint) -> BigUint {\n-        let (d, _) = self.divmod(other);\n+impl Quot<BigUint, BigUint> for BigUint {\n+    fn quot(&self, other: &BigUint) -> BigUint {\n+        let (d, _) = self.quot_rem(other);\n         return d;\n     }\n }\n \n-impl Modulo<BigUint, BigUint> for BigUint {\n-    fn modulo(&self, other: &BigUint) -> BigUint {\n-        let (_, m) = self.divmod(other);\n+impl Rem<BigUint, BigUint> for BigUint {\n+    fn rem(&self, other: &BigUint) -> BigUint {\n+        let (_, m) = self.quot_rem(other);\n         return m;\n     }\n }\n@@ -304,7 +304,7 @@ impl ToStrRadix for BigUint {\n             let mut result = ~[];\n             let mut r      = n;\n             while r > divider {\n-                let (d, r0) = r.divmod(&divider);\n+                let (d, r0) = r.quot_rem(&divider);\n                 result += [r0.to_uint() as BigDigit];\n                 r = d;\n             }\n@@ -384,7 +384,7 @@ pub impl BigUint {\n \n     fn abs(&self) -> BigUint { copy *self }\n \n-    fn divmod(&self, other: &BigUint) -> (BigUint, BigUint) {\n+    fn quot_rem(&self, other: &BigUint) -> (BigUint, BigUint) {\n         if other.is_zero() { fail!() }\n         if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n         if *other == One::one() { return (copy *self, Zero::zero()); }\n@@ -402,10 +402,10 @@ pub impl BigUint {\n             shift += 1;\n         }\n         assert!(shift < BigDigit::bits);\n-        let (d, m) = divmod_inner(self << shift, other << shift);\n+        let (d, m) = quot_rem_inner(self << shift, other << shift);\n         return (d, m >> shift);\n \n-        fn divmod_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n+        fn quot_rem_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n             let mut r = a;\n             let mut d = Zero::zero::<BigUint>();\n             let mut n = 1;\n@@ -464,7 +464,7 @@ pub impl BigUint {\n         return r;\n     }\n     fn quotrem(&self, other: &BigUint) -> (BigUint, BigUint) {\n-        self.divmod(other)\n+        self.quot_rem(other)\n     }\n \n     fn is_zero(&self) -> bool { self.data.is_empty() }\n@@ -737,16 +737,16 @@ impl Mul<BigInt, BigInt> for BigInt {\n     }\n }\n \n-impl Div<BigInt, BigInt> for BigInt {\n-    fn div(&self, other: &BigInt) -> BigInt {\n-        let (d, _) = self.divmod(other);\n+impl Quot<BigInt, BigInt> for BigInt {\n+    fn quot(&self, other: &BigInt) -> BigInt {\n+        let (d, _) = self.quot_rem(other);\n         return d;\n     }\n }\n \n-impl Modulo<BigInt, BigInt> for BigInt {\n-    fn modulo(&self, other: &BigInt) -> BigInt {\n-        let (_, m) = self.divmod(other);\n+impl Rem<BigInt, BigInt> for BigInt {\n+    fn rem(&self, other: &BigInt) -> BigInt {\n+        let (_, m) = self.quot_rem(other);\n         return m;\n     }\n }\n@@ -841,9 +841,9 @@ pub impl BigInt {\n         BigInt::from_biguint(Plus, copy self.data)\n     }\n \n-    fn divmod(&self, other: &BigInt) -> (BigInt, BigInt) {\n+    fn quot_rem(&self, other: &BigInt) -> (BigInt, BigInt) {\n         // m.sign == other.sign\n-        let (d_ui, m_ui) = self.data.divmod(&other.data);\n+        let (d_ui, m_ui) = self.data.quot_rem(&other.data);\n         let d = BigInt::from_biguint(Plus, d_ui),\n             m = BigInt::from_biguint(Plus, m_ui);\n         match (self.sign, other.sign) {\n@@ -1150,7 +1150,7 @@ mod biguint_tests {\n         (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n     ];\n \n-    static divmod_quadruples: &'static [(&'static [BigDigit],\n+    static quot_rem_quadruples: &'static [(&'static [BigDigit],\n                                          &'static [BigDigit],\n                                          &'static [BigDigit],\n                                          &'static [BigDigit])]\n@@ -1174,7 +1174,7 @@ mod biguint_tests {\n             assert!(b * a == c);\n         }\n \n-        for divmod_quadruples.each |elm| {\n+        for quot_rem_quadruples.each |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1187,29 +1187,29 @@ mod biguint_tests {\n     }\n \n     #[test]\n-    fn test_divmod() {\n+    fn test_quot_rem() {\n         for mul_triples.each |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n             let c = BigUint::from_slice(cVec);\n \n             if a.is_not_zero() {\n-                assert!(c.divmod(&a) == (b, Zero::zero()));\n+                assert!(c.quot_rem(&a) == (b, Zero::zero()));\n             }\n             if b.is_not_zero() {\n-                assert!(c.divmod(&b) == (a, Zero::zero()));\n+                assert!(c.quot_rem(&b) == (a, Zero::zero()));\n             }\n         }\n \n-        for divmod_quadruples.each |elm| {\n+        for quot_rem_quadruples.each |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n             let c = BigUint::from_slice(cVec);\n             let d = BigUint::from_slice(dVec);\n \n-            if b.is_not_zero() { assert!(a.divmod(&b) == (c, d)); }\n+            if b.is_not_zero() { assert!(a.quot_rem(&b) == (c, d)); }\n         }\n     }\n \n@@ -1516,7 +1516,7 @@ mod bigint_tests {\n         (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n     ];\n \n-    static divmod_quadruples: &'static [(&'static [BigDigit],\n+    static quot_rem_quadruples: &'static [(&'static [BigDigit],\n                                          &'static [BigDigit],\n                                          &'static [BigDigit],\n                                          &'static [BigDigit])]\n@@ -1543,7 +1543,7 @@ mod bigint_tests {\n             assert!((-b) * a == -c);\n         }\n \n-        for divmod_quadruples.each |elm| {\n+        for quot_rem_quadruples.each |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1556,9 +1556,9 @@ mod bigint_tests {\n     }\n \n     #[test]\n-    fn test_divmod() {\n+    fn test_quot_rem() {\n         fn check_sub(a: &BigInt, b: &BigInt, ans_d: &BigInt, ans_m: &BigInt) {\n-            let (d, m) = a.divmod(b);\n+            let (d, m) = a.quot_rem(b);\n             if m.is_not_zero() {\n                 assert!(m.sign == b.sign);\n             }\n@@ -1592,7 +1592,7 @@ mod bigint_tests {\n             if b.is_not_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n-        for divmod_quadruples.each |elm| {\n+        for quot_rem_quadruples.each |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1635,7 +1635,7 @@ mod bigint_tests {\n             if b.is_not_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n-        for divmod_quadruples.each |elm| {\n+        for quot_rem_quadruples.each |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);"}, {"sha": "ef7fa397d7f1bc75686e0a746b517dbd8864673b", "filename": "src/libstd/num/complex.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibstd%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibstd%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fcomplex.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -32,8 +32,7 @@ pub type Complex = Cmplx<float>;\n pub type Complex32 = Cmplx<f32>;\n pub type Complex64 = Cmplx<f64>;\n \n-impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T>>\n-    Cmplx<T> {\n+impl<T: Copy + Num> Cmplx<T> {\n     /// Create a new Cmplx\n     #[inline]\n     pub fn new(re: T, im: T) -> Cmplx<T> {\n@@ -80,24 +79,21 @@ impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T>>\n \n /* arithmetic */\n // (a + i b) + (c + i d) == (a + c) + i (b + d)\n-impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T>>\n-    Add<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Copy + Num> Add<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n     #[inline]\n     fn add(&self, other: &Cmplx<T>) -> Cmplx<T> {\n         Cmplx::new(self.re + other.re, self.im + other.im)\n     }\n }\n // (a + i b) - (c + i d) == (a - c) + i (b - d)\n-impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T>>\n-    Sub<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Copy + Num> Sub<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n     #[inline]\n     fn sub(&self, other: &Cmplx<T>) -> Cmplx<T> {\n         Cmplx::new(self.re - other.re, self.im - other.im)\n     }\n }\n // (a + i b) * (c + i d) == (a*c - b*d) + i (a*d + b*c)\n-impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T>>\n-    Mul<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Copy + Num> Mul<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n     #[inline]\n     fn mul(&self, other: &Cmplx<T>) -> Cmplx<T> {\n         Cmplx::new(self.re*other.re - self.im*other.im,\n@@ -107,43 +103,39 @@ impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T>>\n \n // (a + i b) / (c + i d) == [(a + i b) * (c - i d)] / (c*c + d*d)\n //   == [(a*c + b*d) / (c*c + d*d)] + i [(b*c - a*d) / (c*c + d*d)]\n-impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T>>\n-    Div<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Copy + Num> Quot<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n     #[inline]\n-    fn div(&self, other: &Cmplx<T>) -> Cmplx<T> {\n+    fn quot(&self, other: &Cmplx<T>) -> Cmplx<T> {\n         let norm_sqr = other.norm_sqr();\n         Cmplx::new((self.re*other.re + self.im*other.im) / norm_sqr,\n                      (self.im*other.re - self.re*other.im) / norm_sqr)\n     }\n }\n \n-impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T>>\n-    Neg<Cmplx<T>> for Cmplx<T> {\n+impl<T: Copy + Num> Neg<Cmplx<T>> for Cmplx<T> {\n     #[inline]\n     fn neg(&self) -> Cmplx<T> {\n         Cmplx::new(-self.re, -self.im)\n     }\n }\n \n /* constants */\n-impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T> + Zero>\n-    Zero for Cmplx<T> {\n+impl<T: Copy + Num> Zero for Cmplx<T> {\n     #[inline]\n     fn zero() -> Cmplx<T> {\n         Cmplx::new(Zero::zero(), Zero::zero())\n     }\n }\n \n-impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T> + Zero + One>\n-    One for Cmplx<T> {\n+impl<T: Copy + Num> One for Cmplx<T> {\n     #[inline]\n     fn one() -> Cmplx<T> {\n         Cmplx::new(One::one(), Zero::zero())\n     }\n }\n \n /* string conversions */\n-impl<T: ToStr + Zero + Ord + Neg<T>> ToStr for Cmplx<T> {\n+impl<T: ToStr + Num + Ord> ToStr for Cmplx<T> {\n     fn to_str(&self) -> ~str {\n         if self.im < Zero::zero() {\n             fmt!(\"%s-%si\", self.re.to_str(), (-self.im).to_str())\n@@ -153,7 +145,7 @@ impl<T: ToStr + Zero + Ord + Neg<T>> ToStr for Cmplx<T> {\n     }\n }\n \n-impl<T: ToStrRadix + Zero + Ord + Neg<T>> ToStrRadix for Cmplx<T> {\n+impl<T: ToStrRadix + Num + Ord> ToStrRadix for Cmplx<T> {\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         if self.im < Zero::zero() {\n             fmt!(\"%s-%si\", self.re.to_str_radix(radix), (-self.im).to_str_radix(radix))\n@@ -280,7 +272,7 @@ mod test {\n             }\n         }\n         #[test]\n-        fn test_div() {\n+        fn test_quot() {\n             assert_eq!(_neg1_1i / _0_1i, _1_1i);\n             for all_consts.each |&c| {\n                 if c != Zero::zero() {"}, {"sha": "2098429833dfcb25d254fe0e0aafe4cacadcb9ca", "filename": "src/libstd/num/rational.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibstd%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibstd%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Frational.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -33,7 +33,7 @@ pub type Rational64 = Ratio<i64>;\n /// Alias for arbitrary precision rationals.\n pub type BigRational = Ratio<BigInt>;\n \n-impl<T: Copy + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + Eq>\n+impl<T: Copy + Num + Ord>\n     Ratio<T> {\n     /// Create a ratio representing the integer `t`.\n     #[inline(always)]\n@@ -51,7 +51,7 @@ impl<T: Copy + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + Eq>\n     #[inline(always)]\n     pub fn new(numer: T, denom: T) -> Ratio<T> {\n         if denom == Zero::zero() {\n-            fail!(~\"divide by 0\");\n+            fail!(~\"quotient of 0\");\n         }\n         let mut ret = Ratio::new_raw(numer, denom);\n         ret.reduce();\n@@ -85,7 +85,7 @@ Compute the greatest common divisor of two numbers, via Euclid's algorithm.\n The result can be negative.\n */\n #[inline]\n-pub fn gcd_raw<T: Modulo<T,T> + Zero + Eq>(n: T, m: T) -> T {\n+pub fn gcd_raw<T: Num>(n: T, m: T) -> T {\n     let mut m = m, n = n;\n     while m != Zero::zero() {\n         let temp = m;\n@@ -101,7 +101,7 @@ Compute the greatest common divisor of two numbers, via Euclid's algorithm.\n The result is always positive.\n */\n #[inline]\n-pub fn gcd<T: Modulo<T,T> + Neg<T> + Zero + Ord + Eq>(n: T, m: T) -> T {\n+pub fn gcd<T: Num + Ord>(n: T, m: T) -> T {\n     let g = gcd_raw(n, m);\n     if g < Zero::zero() { -g }\n     else { g }\n@@ -136,7 +136,7 @@ cmp_impl!(impl TotalOrd, cmp -> cmp::Ordering)\n \n /* Arithmetic */\n // a/b * c/d = (a*c)/(b*d)\n-impl<T: Copy + Mul<T,T> + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + Eq>\n+impl<T: Copy + Num + Ord>\n     Mul<Ratio<T>,Ratio<T>> for Ratio<T> {\n     #[inline]\n     fn mul(&self, rhs: &Ratio<T>) -> Ratio<T> {\n@@ -145,20 +145,18 @@ impl<T: Copy + Mul<T,T> + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + E\n }\n \n // (a/b) / (c/d) = (a*d)/(b*c)\n-impl<T: Copy + Mul<T,T> + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + Eq>\n-    Div<Ratio<T>,Ratio<T>> for Ratio<T> {\n+impl<T: Copy + Num + Ord>\n+    Quot<Ratio<T>,Ratio<T>> for Ratio<T> {\n     #[inline]\n-    fn div(&self, rhs: &Ratio<T>) -> Ratio<T> {\n+    fn quot(&self, rhs: &Ratio<T>) -> Ratio<T> {\n         Ratio::new(self.numer * rhs.denom, self.denom * rhs.numer)\n     }\n }\n \n // Abstracts the a/b `op` c/d = (a*d `op` b*d) / (b*d) pattern\n macro_rules! arith_impl {\n     (impl $imp:ident, $method:ident) => {\n-        impl<T: Copy +\n-                Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Modulo<T,T> + Neg<T> +\n-                Zero + One + Ord + Eq>\n+        impl<T: Copy + Num + Ord>\n             $imp<Ratio<T>,Ratio<T>> for Ratio<T> {\n             #[inline]\n             fn $method(&self, rhs: &Ratio<T>) -> Ratio<T> {\n@@ -176,9 +174,9 @@ arith_impl!(impl Add, add)\n arith_impl!(impl Sub, sub)\n \n // a/b % c/d = (a*d % b*c)/(b*d)\n-arith_impl!(impl Modulo, modulo)\n+arith_impl!(impl Rem, rem)\n \n-impl<T: Copy + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + Eq>\n+impl<T: Copy + Num + Ord>\n     Neg<Ratio<T>> for Ratio<T> {\n     #[inline]\n     fn neg(&self) -> Ratio<T> {\n@@ -187,15 +185,15 @@ impl<T: Copy + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + Eq>\n }\n \n /* Constants */\n-impl<T: Copy + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + Eq>\n+impl<T: Copy + Num + Ord>\n     Zero for Ratio<T> {\n     #[inline]\n     fn zero() -> Ratio<T> {\n         Ratio::new_raw(Zero::zero(), One::one())\n     }\n }\n \n-impl<T: Copy + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + Eq>\n+impl<T: Copy + Num + Ord>\n     One for Ratio<T> {\n     #[inline]\n     fn one() -> Ratio<T> {\n@@ -204,8 +202,7 @@ impl<T: Copy + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + Eq>\n }\n \n /* Utils */\n-impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Modulo<T,T> + Neg<T> +\n-    Zero + One + Ord + Eq>\n+impl<T: Copy + Num + Ord>\n     Round for Ratio<T> {\n     fn round(&self, mode: num::RoundMode) -> Ratio<T> {\n         match mode {\n@@ -256,7 +253,7 @@ impl<T: ToStrRadix> ToStrRadix for Ratio<T> {\n     }\n }\n \n-impl<T: FromStr + Copy + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + Eq>\n+impl<T: FromStr + Copy + Num + Ord>\n     FromStr for Ratio<T> {\n     /// Parses `numer/denom`.\n     fn from_str(s: &str) -> Option<Ratio<T>> {\n@@ -273,7 +270,7 @@ impl<T: FromStr + Copy + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + Eq\n         }\n     }\n }\n-impl<T: FromStrRadix + Copy + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + Eq>\n+impl<T: FromStrRadix + Copy + Num + Ord>\n     FromStrRadix for Ratio<T> {\n     /// Parses `numer/denom` where the numbers are in base `radix`.\n     fn from_str_radix(s: &str, radix: uint) -> Option<Ratio<T>> {\n@@ -386,14 +383,14 @@ mod test {\n         }\n \n         #[test]\n-        fn test_div() {\n+        fn test_quot() {\n             assert_eq!(_1 / _1_2, _2);\n             assert_eq!(_3_2 / _1_2, _1 + _2);\n             assert_eq!(_1 / _neg1_2, _neg1_2 + _neg1_2 + _neg1_2 + _neg1_2);\n         }\n \n         #[test]\n-        fn test_modulo() {\n+        fn test_rem() {\n             assert_eq!(_3_2 % _1, _1_2);\n             assert_eq!(_2 % _neg1_2, _0);\n             assert_eq!(_1_2 % _2,  _1_2);\n@@ -415,7 +412,7 @@ mod test {\n         }\n         #[test]\n         #[should_fail]\n-        fn test_div_0() {\n+        fn test_quot_0() {\n             let _a =  _1 / _0;\n         }\n     }"}, {"sha": "7bedef0f84110220257c6a1bf02ca08b4bd399b9", "filename": "src/libstd/std.rc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -98,10 +98,19 @@ pub mod cmp;\n pub mod base64;\n pub mod rl;\n pub mod workcache;\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n #[path=\"num/bigint.rs\"]\n pub mod bigint;\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n #[path=\"num/rational.rs\"]\n pub mod rational;\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n #[path=\"num/complex.rs\"]\n pub mod complex;\n pub mod stats;"}, {"sha": "a086a1db0aaf16f0400a128e30fd2b61e1e2d3b6", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -389,7 +389,7 @@ pub enum binop {\n     add,\n     subtract,\n     mul,\n-    div,\n+    quot,\n     rem,\n     and,\n     or,"}, {"sha": "f0a14b39049a814c10b1e0e301df3c7706f26a46", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -80,7 +80,7 @@ pub fn binop_to_str(op: binop) -> ~str {\n       add => return ~\"+\",\n       subtract => return ~\"-\",\n       mul => return ~\"*\",\n-      div => return ~\"/\",\n+      quot => return ~\"/\",\n       rem => return ~\"%\",\n       and => return ~\"&&\",\n       or => return ~\"||\",\n@@ -103,8 +103,8 @@ pub fn binop_to_method_name(op: binop) -> Option<~str> {\n       add => return Some(~\"add\"),\n       subtract => return Some(~\"sub\"),\n       mul => return Some(~\"mul\"),\n-      div => return Some(~\"div\"),\n-      rem => return Some(~\"modulo\"),\n+      quot => return Some(~\"quot\"),\n+      rem => return Some(~\"rem\"),\n       bitxor => return Some(~\"bitxor\"),\n       bitand => return Some(~\"bitand\"),\n       bitor => return Some(~\"bitor\"),\n@@ -348,7 +348,7 @@ pub fn is_self(d: ast::def) -> bool {\n /// Maps a binary operator to its precedence\n pub fn operator_prec(op: ast::binop) -> uint {\n   match op {\n-      mul | div | rem   => 12u,\n+      mul | quot | rem   => 12u,\n       // 'as' sits between here with 11\n       add | subtract    => 10u,\n       shl | shr         =>  9u,"}, {"sha": "42275aca0a3e2778476e1034d6fd729163189544", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -21,7 +21,7 @@ use ast::{_mod, add, arg, arm, attribute, bind_by_ref, bind_infer};\n use ast::{bind_by_copy, bitand, bitor, bitxor, blk};\n use ast::{blk_check_mode, box, by_copy, by_ref};\n use ast::{crate, crate_cfg, decl, decl_item};\n-use ast::{decl_local, default_blk, deref, div, enum_def};\n+use ast::{decl_local, default_blk, deref, quot, enum_def};\n use ast::{expl, expr, expr_, expr_addr_of, expr_match, expr_again};\n use ast::{expr_assign, expr_assign_op, expr_binary, expr_block};\n use ast::{expr_break, expr_call, expr_cast, expr_copy, expr_do_body};\n@@ -1786,7 +1786,7 @@ pub impl Parser {\n                   token::PLUS => aop = add,\n                   token::MINUS => aop = subtract,\n                   token::STAR => aop = mul,\n-                  token::SLASH => aop = div,\n+                  token::SLASH => aop = quot,\n                   token::PERCENT => aop = rem,\n                   token::CARET => aop = bitxor,\n                   token::AND => aop = bitand,"}, {"sha": "d8c829740fa3f79ff6cb4cb40784c9cfc6776bf0", "filename": "src/libsyntax/parse/prec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibsyntax%2Fparse%2Fprec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Flibsyntax%2Fparse%2Fprec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fprec.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -31,7 +31,7 @@ pub static as_prec: uint = 11u;\n pub fn token_to_binop(tok: Token) -> Option<ast::binop> {\n   match tok {\n       BINOP(STAR)    => Some(mul),\n-      BINOP(SLASH)   => Some(div),\n+      BINOP(SLASH)   => Some(quot),\n       BINOP(PERCENT) => Some(rem),\n       // 'as' sits between here with 11\n       BINOP(PLUS)    => Some(add),"}, {"sha": "d368f9d6769deb87d576a98104df6baac2e0aeba", "filename": "src/test/compile-fail/eval-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Feval-enum.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -1,6 +1,6 @@\n enum test {\n-    div_zero = 1/0, //~ERROR expected constant: divide by zero\n-    rem_zero = 1%0  //~ERROR expected constant: modulo zero\n+    quot_zero = 1/0, //~ERROR expected constant: quotient zero\n+    rem_zero = 1%0  //~ERROR expected constant: remainder zero\n }\n \n fn main() {}"}, {"sha": "7a17dd024153c0cb963cf90ccdfd9f607424a189", "filename": "src/test/run-fail/divide-by-zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:divide by zero\n+// error-pattern:quotient zero\n fn main() {\n     let y = 0;\n     let z = 1 / y;"}, {"sha": "c379a8fc65fd799b4b5925756934531f98c6d140", "filename": "src/test/run-fail/mod-zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Ftest%2Frun-fail%2Fmod-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01eb5e8ad39a57e9fc31569983c1b9d5905a7e58/src%2Ftest%2Frun-fail%2Fmod-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmod-zero.rs?ref=01eb5e8ad39a57e9fc31569983c1b9d5905a7e58", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:modulo zero\n+// error-pattern:remainder zero\n fn main() {\n     let y = 0;\n     let z = 1 % y;"}]}