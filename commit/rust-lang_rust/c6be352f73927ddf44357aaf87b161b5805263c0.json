{"sha": "c6be352f73927ddf44357aaf87b161b5805263c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2YmUzNTJmNzM5MjdkZGY0NDM1N2FhZjg3YjE2MWI1ODA1MjYzYzA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-15T01:22:36Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-15T01:23:13Z"}, "message": "rustc: Implement on-heap resizing for interior vectors", "tree": {"sha": "e32613262ff12470f395ef14d9921c24312f23aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e32613262ff12470f395ef14d9921c24312f23aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6be352f73927ddf44357aaf87b161b5805263c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6be352f73927ddf44357aaf87b161b5805263c0", "html_url": "https://github.com/rust-lang/rust/commit/c6be352f73927ddf44357aaf87b161b5805263c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6be352f73927ddf44357aaf87b161b5805263c0/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7f043eeb785abefe472d34b7934bfda029aef5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7f043eeb785abefe472d34b7934bfda029aef5c", "html_url": "https://github.com/rust-lang/rust/commit/b7f043eeb785abefe472d34b7934bfda029aef5c"}], "stats": {"total": 51, "additions": 23, "deletions": 28}, "files": [{"sha": "1255af2238733828106c5c5592cbc52d2d737452", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c6be352f73927ddf44357aaf87b161b5805263c0/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6be352f73927ddf44357aaf87b161b5805263c0/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c6be352f73927ddf44357aaf87b161b5805263c0", "patch": "@@ -3718,10 +3718,10 @@ fn trans_vec_append(&@block_ctxt cx, &ty::t t,\n                                         dst, src, skip_null]));\n }\n \n-// Returns a tuple consisting of a pointer to the length (to be updated), a\n-// pointer to the newly-reserved space, and a block context.\n+// Returns a tuple consisting of a pointer to the newly-reserved space and a\n+// block context. Updates the length appropriately.\n fn reserve_ivec_space(&@block_ctxt cx, TypeRef llunitty, ValueRef v,\n-        ValueRef len_needed) -> tup(ValueRef, ValueRef, @block_ctxt) {\n+        ValueRef len_needed) -> result {\n     auto stack_len_ptr = cx.build.InBoundsGEP(v, [C_int(0),\n                                                   C_uint(abi::ivec_elt_len)]);\n     auto stack_len = cx.build.Load(stack_len_ptr);\n@@ -3755,7 +3755,7 @@ fn reserve_ivec_space(&@block_ctxt cx, TypeRef llunitty, ValueRef v,\n \n     // We're definitely on the heap. Check whether we need to resize.\n     auto heap_len_ptr = on_heap_cx.build.InBoundsGEP(heap_ptr, [C_int(0),\n-                                                                C_int(0)]);\n+        C_uint(abi::ivec_heap_elt_len)]);\n     auto heap_len = on_heap_cx.build.Load(heap_len_ptr);\n     auto new_heap_len = on_heap_cx.build.Add(heap_len, len_needed);\n     auto heap_len_unscaled = on_heap_cx.build.UDiv(heap_len,\n@@ -3770,6 +3770,7 @@ fn reserve_ivec_space(&@block_ctxt cx, TypeRef llunitty, ValueRef v,\n     // Case (1): We're on the heap and don't need to resize.\n     auto heap_data_no_resize = heap_no_resize_cx.build.InBoundsGEP(heap_ptr,\n         [C_int(0), C_uint(abi::ivec_heap_elt_elems), heap_len_unscaled]);\n+    heap_no_resize_cx.build.Store(new_heap_len, heap_len_ptr);\n     heap_no_resize_cx.build.Br(next_cx.llbb);\n \n     // Case (2): We're on the heap and need to resize. This path is rare, so\n@@ -3801,6 +3802,7 @@ fn reserve_ivec_space(&@block_ctxt cx, TypeRef llunitty, ValueRef v,\n     // Case (3): We're on the stack and don't need to spill.\n     auto stack_data_no_spill = stack_no_spill_cx.build.InBoundsGEP(v,\n         [C_int(0), C_uint(abi::ivec_elt_elems), stack_len_unscaled]);\n+    stack_no_spill_cx.build.Store(new_stack_len, stack_len_ptr);\n     stack_no_spill_cx.build.Br(next_cx.llbb);\n \n     // Case (4): We're on the stack and need to spill. Like case (2), this\n@@ -3824,16 +3826,12 @@ fn reserve_ivec_space(&@block_ctxt cx, TypeRef llunitty, ValueRef v,\n     stack_spill_cx.build.Br(next_cx.llbb);\n \n     // Phi together the different data pointers to get the result.\n-    auto len_ptr = next_cx.build.Phi(T_ptr(T_int()),\n-        [heap_len_ptr, heap_len_ptr, stack_len_ptr, heap_len_ptr_spill],\n-        [heap_no_resize_cx.llbb, heap_resize_cx.llbb, stack_no_spill_cx.llbb,\n-         stack_spill_cx.llbb]);\n     auto data_ptr = next_cx.build.Phi(T_ptr(llunitty),\n         [heap_data_no_resize, heap_data_resize, stack_data_no_spill,\n          heap_data_spill],\n         [heap_no_resize_cx.llbb, heap_resize_cx.llbb, stack_no_spill_cx.llbb,\n          stack_spill_cx.llbb]);\n-    ret tup(len_ptr, data_ptr, next_cx);\n+    ret res(next_cx, data_ptr);\n }\n \n fn trans_ivec_append(&@block_ctxt cx, &ty::t t, ValueRef lhs, ValueRef rhs)\n@@ -3867,11 +3865,9 @@ fn trans_ivec_append(&@block_ctxt cx, &ty::t t, ValueRef lhs, ValueRef rhs)\n     auto rhs_data = rhs_len_and_data._1;\n     bcx = rhs_len_and_data._2;\n \n-    auto lhs_len_ptr_and_data =\n-        reserve_ivec_space(bcx, llunitty, lhs, rhs_len);\n-    auto lhs_len_ptr = lhs_len_ptr_and_data._0;\n-    auto lhs_data = lhs_len_ptr_and_data._1;\n-    bcx = lhs_len_ptr_and_data._2;\n+    rslt = reserve_ivec_space(bcx, llunitty, lhs, rhs_len);\n+    auto lhs_data = rslt.val;\n+    bcx = rslt.bcx;\n \n     // Work out the end pointer.\n     auto lhs_unscaled_idx = bcx.build.UDiv(rhs_len, llsize_of(llunitty));\n@@ -3905,11 +3901,6 @@ fn trans_ivec_append(&@block_ctxt cx, &ty::t t, ValueRef lhs, ValueRef rhs)\n         [C_int(1)]), src_ptr);\n     post_copy_cx.build.Br(copy_loop_header_cx.llbb);\n \n-    // Write in the new length.\n-    auto new_len = next_cx.build.Add(next_cx.build.Load(lhs_len_ptr),\n-                                     rhs_len);\n-    next_cx.build.Store(new_len, lhs_len_ptr);\n-\n     ret res(next_cx, C_nil());\n }\n \n@@ -5866,11 +5857,8 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann)\n     auto rslt = size_of(bcx, unit_ty);\n     auto unit_sz = rslt.val;\n     bcx = rslt.bcx;\n-    rslt = align_of(bcx, unit_ty);\n-    auto unit_align = rslt.val;\n-    bcx = rslt.bcx;\n \n-    auto llalen = bcx.build.Mul(unit_align, C_uint(abi::ivec_default_length));\n+    auto llalen = bcx.build.Mul(unit_sz, C_uint(abi::ivec_default_length));\n \n     auto llunitty = type_of_or_i8(bcx, unit_ty);\n     auto llvecptr;\n@@ -5938,7 +5926,7 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann)\n         auto lleltptr;\n         if (ty::type_has_dynamic_size(bcx.fcx.lcx.ccx.tcx, unit_ty)) {\n             lleltptr = bcx.build.InBoundsGEP(llfirsteltptr,\n-                [bcx.build.Mul(C_uint(i), unit_align)]);\n+                [bcx.build.Mul(C_uint(i), unit_sz)]);\n         } else {\n             lleltptr = bcx.build.InBoundsGEP(llfirsteltptr, [C_uint(i)]);\n         }"}, {"sha": "c58723d1b507aba3b8d550edd6bbb0f204e85750", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c6be352f73927ddf44357aaf87b161b5805263c0/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c6be352f73927ddf44357aaf87b161b5805263c0/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=c6be352f73927ddf44357aaf87b161b5805263c0", "patch": "@@ -581,8 +581,15 @@ extern \"C\" CDECL void\n upcall_ivec_resize(rust_task *task,\n                    rust_ivec *v,\n                    size_t newsz) {\n-    // TODO\n-    task->fail(4);\n+    I(task->dom, !v->fill);\n+\n+    size_t new_alloc = next_power_of_two(newsz);\n+    rust_ivec_heap *new_heap_part = (rust_ivec_heap *)\n+        task->realloc(v->payload.ptr, new_alloc);\n+\n+    new_heap_part->fill = newsz;\n+    v->alloc = new_alloc;\n+    v->payload.ptr = new_heap_part;\n }\n \n /**"}, {"sha": "fe3c245996654c70f39d8be41e6593e7d983f5ea", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6be352f73927ddf44357aaf87b161b5805263c0/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/c6be352f73927ddf44357aaf87b161b5805263c0/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=c6be352f73927ddf44357aaf87b161b5805263c0", "patch": "@@ -197,8 +197,8 @@ rust_ivec_heap\n union\n rust_ivec_payload\n {\n-    uint8_t data[];                 // if on stack\n-    struct rust_ivec_heap *ptr;     // if on heap\n+    rust_ivec_heap *ptr;    // if on heap\n+    uint8_t data[];         // if on stack\n };\n \n struct"}]}