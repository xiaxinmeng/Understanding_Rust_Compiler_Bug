{"sha": "3a5d975fdcef451375df20e5ac234bb01e453e33", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhNWQ5NzVmZGNlZjQ1MTM3NWRmMjBlNWFjMjM0YmIwMWU0NTNlMzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-22T23:33:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-22T23:33:41Z"}, "message": "Auto merge of #36154 - nrc:proc-macro-init, r=@jseyfried\n\nAdds a `ProcMacro` form of syntax extension\n\nThis commit adds syntax extension forms matching the types for procedural macros 2.0 (RFC #1566), these still require the usual syntax extension boiler plate, but this is a first step towards proper implementation and should be useful for macros 1.1 stuff too.\n\nSupports both attribute-like and function-like macros.\n\nNote that RFC #1566 has not been accepted yet, but I think there is consensus that we want to head in vaguely that direction and so this PR will be useful in any case. It is also fairly easy to undo and does not break any existing programs.\n\nThis is related to #35957 in that I hope it can be used in the implementation of macros 1.1, however, there is no direct overlap and is more of a complement than a competing proposal. There is still a fair bit of work to do before the two can be combined.\n\nr? @jseyfried\n\ncc @alexcrichton, @cgswords, @eddyb, @aturon", "tree": {"sha": "5c4c7a4d56802f431fd19f7b5d511c77f95450a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c4c7a4d56802f431fd19f7b5d511c77f95450a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a5d975fdcef451375df20e5ac234bb01e453e33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a5d975fdcef451375df20e5ac234bb01e453e33", "html_url": "https://github.com/rust-lang/rust/commit/3a5d975fdcef451375df20e5ac234bb01e453e33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a5d975fdcef451375df20e5ac234bb01e453e33/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2", "html_url": "https://github.com/rust-lang/rust/commit/4c04e36f94c4b85b613a2d5fe5c9511053cbdec2"}, {"sha": "3863834d9c75230224e36783780d260f52e10d49", "url": "https://api.github.com/repos/rust-lang/rust/commits/3863834d9c75230224e36783780d260f52e10d49", "html_url": "https://github.com/rust-lang/rust/commit/3863834d9c75230224e36783780d260f52e10d49"}], "stats": {"total": 521, "additions": 472, "deletions": 49}, "files": [{"sha": "7b048c0670d5a70d4b69df3a97a4400ef3b0e71e", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=3a5d975fdcef451375df20e5ac234bb01e453e33", "patch": "@@ -15,8 +15,7 @@ use rustc::session::Session;\n \n use rustc::mir::transform::MirMapPass;\n \n-use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT};\n-use syntax::ext::base::{IdentTT, MultiModifier, MultiDecorator};\n+use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT, IdentTT};\n use syntax::ext::base::MacroExpanderFn;\n use syntax::parse::token;\n use syntax::ast;\n@@ -109,8 +108,7 @@ impl<'a> Registry<'a> {\n             IdentTT(ext, _, allow_internal_unstable) => {\n                 IdentTT(ext, Some(self.krate_span), allow_internal_unstable)\n             }\n-            MultiDecorator(ext) => MultiDecorator(ext),\n-            MultiModifier(ext) => MultiModifier(ext),\n+            _ => extension,\n         }));\n     }\n "}, {"sha": "86c4a18343a3f274cba16d2bf059588fd5eb9c07", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=3a5d975fdcef451375df20e5ac234bb01e453e33", "patch": "@@ -73,7 +73,9 @@ impl<'a> base::Resolver for Resolver<'a> {\n             let name = intern(&attrs[i].name());\n             match self.expansion_data[0].module.macros.borrow().get(&name) {\n                 Some(ext) => match **ext {\n-                    MultiModifier(..) | MultiDecorator(..) => return Some(attrs.remove(i)),\n+                    MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n+                        return Some(attrs.remove(i))\n+                    }\n                     _ => {}\n                 },\n                 None => {}"}, {"sha": "917426807110eb97d4eb7608bf4da595f935c062", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 219, "deletions": 8, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=3a5d975fdcef451375df20e5ac234bb01e453e33", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::SyntaxExtension::*;\n+pub use self::SyntaxExtension::{MultiDecorator, MultiModifier, NormalTT, IdentTT};\n \n use ast::{self, Attribute, Name, PatKind};\n use attr::HasAttrs;\n@@ -18,8 +18,9 @@ use errors::DiagnosticBuilder;\n use ext::expand::{self, Invocation, Expansion};\n use ext::hygiene::Mark;\n use ext::tt::macro_rules;\n+use fold;\n use parse;\n-use parse::parser;\n+use parse::parser::{self, Parser};\n use parse::token;\n use parse::token::{InternedString, str_to_ident};\n use ptr::P;\n@@ -31,7 +32,8 @@ use feature_gate;\n use std::collections::HashMap;\n use std::path::PathBuf;\n use std::rc::Rc;\n-use tokenstream;\n+use std::default::Default;\n+use tokenstream::{self, TokenStream};\n \n \n #[derive(Debug,Clone)]\n@@ -146,6 +148,190 @@ impl Into<Vec<Annotatable>> for Annotatable {\n     }\n }\n \n+pub trait ProcMacro {\n+    fn expand<'cx>(&self,\n+                   ecx: &'cx mut ExtCtxt,\n+                   span: Span,\n+                   ts: TokenStream)\n+                   -> TokenStream;\n+}\n+\n+impl<F> ProcMacro for F\n+    where F: Fn(TokenStream) -> TokenStream\n+{\n+    fn expand<'cx>(&self,\n+                   _ecx: &'cx mut ExtCtxt,\n+                   _span: Span,\n+                   ts: TokenStream)\n+                   -> TokenStream {\n+        // FIXME setup implicit context in TLS before calling self.\n+        (*self)(ts)\n+    }\n+}\n+\n+pub trait AttrProcMacro {\n+    fn expand<'cx>(&self,\n+                   ecx: &'cx mut ExtCtxt,\n+                   span: Span,\n+                   annotation: TokenStream,\n+                   annotated: TokenStream)\n+                   -> TokenStream;\n+}\n+\n+impl<F> AttrProcMacro for F\n+    where F: Fn(TokenStream, TokenStream) -> TokenStream\n+{\n+    fn expand<'cx>(&self,\n+                   _ecx: &'cx mut ExtCtxt,\n+                   _span: Span,\n+                   annotation: TokenStream,\n+                   annotated: TokenStream)\n+                   -> TokenStream {\n+        // FIXME setup implicit context in TLS before calling self.\n+        (*self)(annotation, annotated)\n+    }\n+}\n+\n+pub struct TokResult<'a> {\n+    pub parser: Parser<'a>,\n+    pub span: Span,\n+}\n+\n+impl<'a> TokResult<'a> {\n+    // There is quite a lot of overlap here with ParserAnyMacro in ext/tt/macro_rules.rs\n+    // We could probably share more code.\n+    // FIXME(#36641) Unify TokResult and ParserAnyMacro.\n+    fn ensure_complete_parse(&mut self, allow_semi: bool) {\n+        let macro_span = &self.span;\n+        self.parser.ensure_complete_parse(allow_semi, |parser| {\n+            let token_str = parser.this_token_to_string();\n+            let msg = format!(\"macro expansion ignores token `{}` and any following\", token_str);\n+            let span = parser.span;\n+            parser.diagnostic()\n+                  .struct_span_err(span, &msg)\n+                  .span_note(*macro_span, \"caused by the macro expansion here\")\n+                  .emit();\n+        });\n+    }\n+}\n+\n+impl<'a> MacResult for TokResult<'a> {\n+    fn make_items(mut self: Box<Self>) -> Option<SmallVector<P<ast::Item>>> {\n+        if self.parser.sess.span_diagnostic.has_errors() {\n+            return Some(SmallVector::zero());\n+        }\n+\n+        let mut items = SmallVector::zero();\n+        loop {\n+            match self.parser.parse_item() {\n+                Ok(Some(item)) => items.push(item),\n+                Ok(None) => {\n+                    self.ensure_complete_parse(false);\n+                    return Some(items);\n+                }\n+                Err(mut e) => {\n+                    e.emit();\n+                    return Some(SmallVector::zero());\n+                }\n+            }\n+        }\n+    }\n+\n+    fn make_impl_items(mut self: Box<Self>) -> Option<SmallVector<ast::ImplItem>> {\n+        let mut items = SmallVector::zero();\n+        loop {\n+            if self.parser.token == token::Eof {\n+                break;\n+            }\n+            match self.parser.parse_impl_item() {\n+                Ok(item) => items.push(item),\n+                Err(mut e) => {\n+                    e.emit();\n+                    return Some(SmallVector::zero());\n+                }\n+            }\n+        }\n+        self.ensure_complete_parse(false);\n+        Some(items)\n+    }\n+\n+    fn make_trait_items(mut self: Box<Self>) -> Option<SmallVector<ast::TraitItem>> {\n+        let mut items = SmallVector::zero();\n+        loop {\n+            if self.parser.token == token::Eof {\n+                break;\n+            }\n+            match self.parser.parse_trait_item() {\n+                Ok(item) => items.push(item),\n+                Err(mut e) => {\n+                    e.emit();\n+                    return Some(SmallVector::zero());\n+                }\n+            }\n+        }\n+        self.ensure_complete_parse(false);\n+        Some(items)\n+    }\n+\n+    fn make_expr(mut self: Box<Self>) -> Option<P<ast::Expr>> {\n+        match self.parser.parse_expr() {\n+            Ok(e) => {\n+                self.ensure_complete_parse(true);\n+                Some(e)\n+            }\n+            Err(mut e) => {\n+                e.emit();\n+                Some(DummyResult::raw_expr(self.span))\n+            }\n+        }\n+    }\n+\n+    fn make_pat(mut self: Box<Self>) -> Option<P<ast::Pat>> {\n+        match self.parser.parse_pat() {\n+            Ok(e) => {\n+                self.ensure_complete_parse(false);\n+                Some(e)\n+            }\n+            Err(mut e) => {\n+                e.emit();\n+                Some(P(DummyResult::raw_pat(self.span)))\n+            }\n+        }\n+    }\n+\n+    fn make_stmts(mut self: Box<Self>) -> Option<SmallVector<ast::Stmt>> {\n+        let mut stmts = SmallVector::zero();\n+        loop {\n+            if self.parser.token == token::Eof {\n+                break;\n+            }\n+            match self.parser.parse_full_stmt(false) {\n+                Ok(Some(stmt)) => stmts.push(stmt),\n+                Ok(None) => { /* continue */ }\n+                Err(mut e) => {\n+                    e.emit();\n+                    return Some(SmallVector::zero());\n+                }\n+            }\n+        }\n+        self.ensure_complete_parse(false);\n+        Some(stmts)\n+    }\n+\n+    fn make_ty(mut self: Box<Self>) -> Option<P<ast::Ty>> {\n+        match self.parser.parse_ty() {\n+            Ok(e) => {\n+                self.ensure_complete_parse(false);\n+                Some(e)\n+            }\n+            Err(mut e) => {\n+                e.emit();\n+                Some(DummyResult::raw_ty(self.span))\n+            }\n+        }\n+    }\n+}\n+\n /// Represents a thing that maps token trees to Macro Results\n pub trait TTMacroExpander {\n     fn expand<'cx>(&self,\n@@ -439,24 +625,35 @@ pub enum SyntaxExtension {\n     /// based upon it.\n     ///\n     /// `#[derive(...)]` is a `MultiItemDecorator`.\n-    MultiDecorator(Box<MultiItemDecorator + 'static>),\n+    ///\n+    /// Prefer ProcMacro or MultiModifier since they are more flexible.\n+    MultiDecorator(Box<MultiItemDecorator>),\n \n     /// A syntax extension that is attached to an item and modifies it\n-    /// in-place. More flexible version than Modifier.\n-    MultiModifier(Box<MultiItemModifier + 'static>),\n+    /// in-place. Also allows decoration, i.e., creating new items.\n+    MultiModifier(Box<MultiItemModifier>),\n+\n+    /// A function-like procedural macro. TokenStream -> TokenStream.\n+    ProcMacro(Box<ProcMacro>),\n+\n+    /// An attribute-like procedural macro. TokenStream, TokenStream -> TokenStream.\n+    /// The first TokenSteam is the attribute, the second is the annotated item.\n+    /// Allows modification of the input items and adding new items, similar to\n+    /// MultiModifier, but uses TokenStreams, rather than AST nodes.\n+    AttrProcMacro(Box<AttrProcMacro>),\n \n     /// A normal, function-like syntax extension.\n     ///\n     /// `bytes!` is a `NormalTT`.\n     ///\n     /// The `bool` dictates whether the contents of the macro can\n     /// directly use `#[unstable]` things (true == yes).\n-    NormalTT(Box<TTMacroExpander + 'static>, Option<Span>, bool),\n+    NormalTT(Box<TTMacroExpander>, Option<Span>, bool),\n \n     /// A function-like syntax extension that has an extra ident before\n     /// the block.\n     ///\n-    IdentTT(Box<IdentMacroExpander + 'static>, Option<Span>, bool),\n+    IdentTT(Box<IdentMacroExpander>, Option<Span>, bool),\n }\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n@@ -817,3 +1014,17 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n     }\n     Some(es)\n }\n+\n+pub struct ChangeSpan {\n+    pub span: Span\n+}\n+\n+impl Folder for ChangeSpan {\n+    fn new_span(&mut self, _sp: Span) -> Span {\n+        self.span\n+    }\n+\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+        fold::noop_fold_mac(mac, self)\n+    }\n+}"}, {"sha": "18b32e9d0b6e2aeef8283b96e356556d4ca7170a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 79, "deletions": 2, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3a5d975fdcef451375df20e5ac234bb01e453e33", "patch": "@@ -21,9 +21,12 @@ use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n use fold::*;\n+use parse::{ParseSess, lexer};\n+use parse::parser::Parser;\n use parse::token::{intern, keywords};\n+use print::pprust;\n use ptr::P;\n-use tokenstream::TokenTree;\n+use tokenstream::{TokenTree, TokenStream};\n use util::small_vector::SmallVector;\n use visit::Visitor;\n \n@@ -315,6 +318,20 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 items.push(item);\n                 kind.expect_from_annotatables(items)\n             }\n+            SyntaxExtension::AttrProcMacro(ref mac) => {\n+                let attr_toks = TokenStream::from_tts(tts_for_attr(&attr, &self.cx.parse_sess));\n+                let item_toks = TokenStream::from_tts(tts_for_item(&item, &self.cx.parse_sess));\n+\n+                let tok_result = mac.expand(self.cx, attr.span, attr_toks, item_toks);\n+                let parser = self.cx.new_parser_from_tts(&tok_result.to_tts());\n+                let result = Box::new(TokResult { parser: parser, span: attr.span });\n+\n+                kind.make_from(result).unwrap_or_else(|| {\n+                    let msg = format!(\"macro could not be expanded into {} position\", kind.name());\n+                    self.cx.span_err(attr.span, &msg);\n+                    kind.dummy(attr.span)\n+                })\n+            }\n             _ => unreachable!(),\n         }\n     }\n@@ -384,11 +401,41 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 kind.make_from(expander.expand(self.cx, span, ident, marked_tts, attrs))\n             }\n \n-            MultiDecorator(..) | MultiModifier(..) => {\n+            MultiDecorator(..) | MultiModifier(..) | SyntaxExtension::AttrProcMacro(..) => {\n                 self.cx.span_err(path.span,\n                                  &format!(\"`{}` can only be used in attributes\", extname));\n                 return kind.dummy(span);\n             }\n+\n+            SyntaxExtension::ProcMacro(ref expandfun) => {\n+                if ident.name != keywords::Invalid.name() {\n+                    let msg =\n+                        format!(\"macro {}! expects no ident argument, given '{}'\", extname, ident);\n+                    self.cx.span_err(path.span, &msg);\n+                    return kind.dummy(span);\n+                }\n+\n+                self.cx.bt_push(ExpnInfo {\n+                    call_site: span,\n+                    callee: NameAndSpan {\n+                        format: MacroBang(extname),\n+                        // FIXME procedural macros do not have proper span info\n+                        // yet, when they do, we should use it here.\n+                        span: None,\n+                        // FIXME probably want to follow macro_rules macros here.\n+                        allow_internal_unstable: false,\n+                    },\n+                });\n+\n+\n+                let tok_result = expandfun.expand(self.cx,\n+                                                  span,\n+                                                  TokenStream::from_tts(marked_tts));\n+                let parser = self.cx.new_parser_from_tts(&tok_result.to_tts());\n+                let result = Box::new(TokResult { parser: parser, span: span });\n+                // FIXME better span info.\n+                kind.make_from(result).map(|i| i.fold_with(&mut ChangeSpan { span: span }))\n+            }\n         };\n \n         let expanded = if let Some(expanded) = opt_expanded {\n@@ -460,6 +507,36 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     }\n }\n \n+// These are pretty nasty. Ideally, we would keep the tokens around, linked from\n+// the AST. However, we don't so we need to create new ones. Since the item might\n+// have come from a macro expansion (possibly only in part), we can't use the\n+// existing codemap.\n+//\n+// Therefore, we must use the pretty printer (yuck) to turn the AST node into a\n+// string, which we then re-tokenise (double yuck), but first we have to patch\n+// the pretty-printed string on to the end of the existing codemap (infinity-yuck).\n+fn tts_for_item(item: &Annotatable, parse_sess: &ParseSess) -> Vec<TokenTree> {\n+    let text = match *item {\n+        Annotatable::Item(ref i) => pprust::item_to_string(i),\n+        Annotatable::TraitItem(ref ti) => pprust::trait_item_to_string(ti),\n+        Annotatable::ImplItem(ref ii) => pprust::impl_item_to_string(ii),\n+    };\n+    string_to_tts(text, parse_sess)\n+}\n+\n+fn tts_for_attr(attr: &ast::Attribute, parse_sess: &ParseSess) -> Vec<TokenTree> {\n+    string_to_tts(pprust::attr_to_string(attr), parse_sess)\n+}\n+\n+fn string_to_tts(text: String, parse_sess: &ParseSess) -> Vec<TokenTree> {\n+    let filemap = parse_sess.codemap()\n+                            .new_filemap(String::from(\"<macro expansion>\"), None, text);\n+\n+    let lexer = lexer::StringReader::new(&parse_sess.span_diagnostic, filemap);\n+    let mut parser = Parser::new(parse_sess, Vec::new(), Box::new(lexer));\n+    panictry!(parser.parse_all_token_trees())\n+}\n+\n impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let mut expr = self.cfg.configure_expr(expr).unwrap();"}, {"sha": "dc3a01f41bc9db92392877a147d44d9ac48923f8", "filename": "src/libsyntax/ext/proc_macro_shim.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs?ref=3a5d975fdcef451375df20e5ac234bb01e453e33", "patch": "@@ -24,7 +24,9 @@ use ext::base::*;\n \n /// Take a `ExtCtxt`, `Span`, and `TokenStream`, and produce a Macro Result that parses\n /// the TokenStream as a block and returns it as an `Expr`.\n-pub fn build_block_emitter<'cx>(cx: &'cx mut ExtCtxt, sp: Span, output: TokenStream)\n+pub fn build_block_emitter<'cx>(cx: &'cx mut ExtCtxt,\n+                                sp: Span,\n+                                output: TokenStream)\n                                 -> Box<MacResult + 'cx> {\n     let parser = cx.new_parser_from_tts(&output.to_tts());\n \n@@ -60,7 +62,7 @@ pub fn build_block_emitter<'cx>(cx: &'cx mut ExtCtxt, sp: Span, output: TokenStr\n }\n \n pub mod prelude {\n-    pub use ext::proc_macro_shim::build_block_emitter;\n+    pub use super::build_block_emitter;\n     pub use ast::Ident;\n     pub use codemap::{DUMMY_SP, Span};\n     pub use ext::base::{ExtCtxt, MacResult};"}, {"sha": "3746a51d359bde4ce21b1859d8a38ffc228ae329", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=3a5d975fdcef451375df20e5ac234bb01e453e33", "patch": "@@ -49,22 +49,19 @@ impl<'a> ParserAnyMacro<'a> {\n     /// allowed to be there.\n     fn ensure_complete_parse(&self, allow_semi: bool, context: &str) {\n         let mut parser = self.parser.borrow_mut();\n-        if allow_semi && parser.token == token::Semi {\n-            parser.bump();\n-        }\n-        if parser.token != token::Eof {\n+        parser.ensure_complete_parse(allow_semi, |parser| {\n             let token_str = parser.this_token_to_string();\n             let msg = format!(\"macro expansion ignores token `{}` and any \\\n                                following\",\n                               token_str);\n             let span = parser.span;\n-            let mut err = parser.diagnostic().struct_span_err(span, &msg[..]);\n+            let mut err = parser.diagnostic().struct_span_err(span, &msg);\n             let msg = format!(\"caused by the macro expansion here; the usage \\\n                                of `{}!` is likely invalid in {} context\",\n                                self.macro_ident, context);\n-            err.span_note(self.site_span, &msg[..])\n+            err.span_note(self.site_span, &msg)\n                .emit();\n-        }\n+        });\n     }\n }\n "}, {"sha": "6c0e2425d37ad6288ca8757e9edd63ca7580cfd3", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=3a5d975fdcef451375df20e5ac234bb01e453e33", "patch": "@@ -85,6 +85,12 @@ pub struct StringReader<'a> {\n     /// The last character to be read\n     pub curr: Option<char>,\n     pub filemap: Rc<syntax_pos::FileMap>,\n+    /// If Some, stop reading the source at this position (inclusive).\n+    pub terminator: Option<BytePos>,\n+    /// Whether to record new-lines in filemap. This is only necessary the first\n+    /// time a filemap is lexed. If part of a filemap is being re-lexed, this\n+    /// should be set to false.\n+    pub save_new_lines: bool,\n     // cached:\n     pub peek_tok: token::Token,\n     pub peek_span: Span,\n@@ -96,7 +102,14 @@ pub struct StringReader<'a> {\n \n impl<'a> Reader for StringReader<'a> {\n     fn is_eof(&self) -> bool {\n-        self.curr.is_none()\n+        if self.curr.is_none() {\n+            return true;\n+        }\n+\n+        match self.terminator {\n+            Some(t) => self.pos > t,\n+            None => false,\n+        }\n     }\n     /// Return the next token. EFFECT: advances the string_reader.\n     fn try_next_token(&mut self) -> Result<TokenAndSpan, ()> {\n@@ -164,6 +177,14 @@ impl<'a> StringReader<'a> {\n     pub fn new_raw<'b>(span_diagnostic: &'b Handler,\n                        filemap: Rc<syntax_pos::FileMap>)\n                        -> StringReader<'b> {\n+        let mut sr = StringReader::new_raw_internal(span_diagnostic, filemap);\n+        sr.bump();\n+        sr\n+    }\n+\n+    fn new_raw_internal<'b>(span_diagnostic: &'b Handler,\n+                            filemap: Rc<syntax_pos::FileMap>)\n+                            -> StringReader<'b> {\n         if filemap.src.is_none() {\n             span_diagnostic.bug(&format!(\"Cannot lex filemap \\\n                                           without source: {}\",\n@@ -172,21 +193,21 @@ impl<'a> StringReader<'a> {\n \n         let source_text = (*filemap.src.as_ref().unwrap()).clone();\n \n-        let mut sr = StringReader {\n+        StringReader {\n             span_diagnostic: span_diagnostic,\n             pos: filemap.start_pos,\n             last_pos: filemap.start_pos,\n             col: CharPos(0),\n             curr: Some('\\n'),\n             filemap: filemap,\n+            terminator: None,\n+            save_new_lines: true,\n             // dummy values; not read\n             peek_tok: token::Eof,\n             peek_span: syntax_pos::DUMMY_SP,\n             source_text: source_text,\n             fatal_errs: Vec::new(),\n-        };\n-        sr.bump();\n-        sr\n+        }\n     }\n \n     pub fn new<'b>(span_diagnostic: &'b Handler,\n@@ -405,7 +426,9 @@ impl<'a> StringReader<'a> {\n             self.curr = Some(ch);\n             self.col = self.col + CharPos(1);\n             if last_char == '\\n' {\n-                self.filemap.next_line(self.last_pos);\n+                if self.save_new_lines {\n+                    self.filemap.next_line(self.last_pos);\n+                }\n                 self.col = CharPos(0);\n             }\n "}, {"sha": "23085fadc5e6068c3c32bb217fd05a655a08da32", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3a5d975fdcef451375df20e5ac234bb01e453e33", "patch": "@@ -3872,15 +3872,17 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_stmt_(&mut self, macro_expanded: bool) -> Option<Stmt> {\n-        self.parse_stmt_without_recovery(macro_expanded).unwrap_or_else(|mut e| {\n+    fn parse_stmt_(&mut self, macro_legacy_warnings: bool) -> Option<Stmt> {\n+        self.parse_stmt_without_recovery(macro_legacy_warnings).unwrap_or_else(|mut e| {\n             e.emit();\n             self.recover_stmt_(SemiColonMode::Break);\n             None\n         })\n     }\n \n-    fn parse_stmt_without_recovery(&mut self, macro_expanded: bool) -> PResult<'a, Option<Stmt>> {\n+    fn parse_stmt_without_recovery(&mut self,\n+                                   macro_legacy_warnings: bool)\n+                                   -> PResult<'a, Option<Stmt>> {\n         maybe_whole!(Some deref self, NtStmt);\n \n         let attrs = self.parse_outer_attributes()?;\n@@ -3950,7 +3952,7 @@ impl<'a> Parser<'a> {\n                 // We used to incorrectly stop parsing macro-expanded statements here.\n                 // If the next token will be an error anyway but could have parsed with the\n                 // earlier behavior, stop parsing here and emit a warning to avoid breakage.\n-                else if macro_expanded && self.token.can_begin_expr() && match self.token {\n+                else if macro_legacy_warnings && self.token.can_begin_expr() && match self.token {\n                     // These can continue an expression, so we can't stop parsing and warn.\n                     token::OpenDelim(token::Paren) | token::OpenDelim(token::Bracket) |\n                     token::BinOp(token::Minus) | token::BinOp(token::Star) |\n@@ -4125,8 +4127,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a statement, including the trailing semicolon.\n-    pub fn parse_full_stmt(&mut self, macro_expanded: bool) -> PResult<'a, Option<Stmt>> {\n-        let mut stmt = match self.parse_stmt_(macro_expanded) {\n+    pub fn parse_full_stmt(&mut self, macro_legacy_warnings: bool) -> PResult<'a, Option<Stmt>> {\n+        let mut stmt = match self.parse_stmt_(macro_legacy_warnings) {\n             Some(stmt) => stmt,\n             None => return Ok(None),\n         };\n@@ -4146,7 +4148,7 @@ impl<'a> Parser<'a> {\n             }\n             StmtKind::Local(..) => {\n                 // We used to incorrectly allow a macro-expanded let statement to lack a semicolon.\n-                if macro_expanded && self.token != token::Semi {\n+                if macro_legacy_warnings && self.token != token::Semi {\n                     self.warn_missing_semicolon();\n                 } else {\n                     self.expect_one_of(&[token::Semi], &[])?;\n@@ -6169,4 +6171,15 @@ impl<'a> Parser<'a> {\n             _ =>  Err(self.fatal(\"expected string literal\"))\n         }\n     }\n+\n+    pub fn ensure_complete_parse<F>(&mut self, allow_semi: bool, on_err: F)\n+        where F: FnOnce(&Parser)\n+    {\n+        if allow_semi && self.token == token::Semi {\n+            self.bump();\n+        }\n+        if self.token != token::Eof {\n+            on_err(self);\n+        }\n+    }\n }"}, {"sha": "b35b4617ea11ec139e8abe989f1861e7cf49fef5", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=3a5d975fdcef451375df20e5ac234bb01e453e33", "patch": "@@ -33,6 +33,7 @@ use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::lexer;\n use parse;\n use parse::token::{self, Token, Lit, Nonterminal};\n+use print::pprust;\n \n use std::fmt;\n use std::iter::*;\n@@ -781,6 +782,12 @@ impl TokenStream {\n     }\n }\n \n+impl fmt::Display for TokenStream {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(&pprust::tts_to_string(&self.to_tts()))\n+    }\n+}\n+\n // FIXME Reimplement this iterator to hold onto a slice iterator for a leaf, getting the\n // next leaf's iterator when the current one is exhausted.\n pub struct Iter<'a> {"}, {"sha": "624fabd1424e158bcc96d013a4d27aea06e60180", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=3a5d975fdcef451375df20e5ac234bb01e453e33", "patch": "@@ -15,7 +15,7 @@ use rustc_macro::{TokenStream, __internal};\n use syntax::ast::{self, ItemKind};\n use syntax::codemap::{ExpnInfo, MacroAttribute, NameAndSpan, Span};\n use syntax::ext::base::*;\n-use syntax::fold::{self, Folder};\n+use syntax::fold::Folder;\n use syntax::parse::token::intern;\n use syntax::print::pprust;\n \n@@ -97,14 +97,3 @@ impl MultiItemModifier for CustomDerive {\n     }\n }\n \n-struct ChangeSpan { span: Span }\n-\n-impl Folder for ChangeSpan {\n-    fn new_span(&mut self, _sp: Span) -> Span {\n-        self.span\n-    }\n-\n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-        fold::noop_fold_mac(mac, self)\n-    }\n-}"}, {"sha": "52c38a6ee038cee8a9d6764ba73435462c47a541", "filename": "src/test/run-pass-fulldeps/auxiliary/proc_macro_def.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs?ref=3a5d975fdcef451375df20e5ac234bb01e453e33", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(plugin, plugin_registrar, rustc_private)]\n+\n+extern crate proc_macro;\n+extern crate rustc_plugin;\n+extern crate syntax;\n+\n+use proc_macro::prelude::*;\n+use rustc_plugin::Registry;\n+use syntax::ext::base::SyntaxExtension;\n+use syntax::ext::proc_macro_shim::prelude::*;\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(reg: &mut Registry) {\n+    reg.register_syntax_extension(token::intern(\"attr_tru\"),\n+                                  SyntaxExtension::AttrProcMacro(Box::new(attr_tru)));\n+    reg.register_syntax_extension(token::intern(\"attr_identity\"),\n+                                  SyntaxExtension::AttrProcMacro(Box::new(attr_identity)));\n+    reg.register_syntax_extension(token::intern(\"tru\"),\n+                                  SyntaxExtension::ProcMacro(Box::new(tru)));\n+    reg.register_syntax_extension(token::intern(\"ret_tru\"),\n+                                  SyntaxExtension::ProcMacro(Box::new(ret_tru)));\n+    reg.register_syntax_extension(token::intern(\"identity\"),\n+                                  SyntaxExtension::ProcMacro(Box::new(identity)));\n+}\n+\n+fn attr_tru(_attr: TokenStream, _item: TokenStream) -> TokenStream {\n+    lex(\"fn f1() -> bool { true }\")\n+}\n+\n+fn attr_identity(_attr: TokenStream, item: TokenStream) -> TokenStream {\n+    let source = item.to_string();\n+    lex(&source)\n+}\n+\n+fn tru(_ts: TokenStream) -> TokenStream {\n+    lex(\"true\")\n+}\n+\n+fn ret_tru(_ts: TokenStream) -> TokenStream {\n+    lex(\"return true;\")\n+}\n+\n+fn identity(ts: TokenStream) -> TokenStream {\n+    let source = ts.to_string();\n+    lex(&source)\n+}"}, {"sha": "22cc9f0f8d40e32e8b497f040c5b1a782fe0dce6", "filename": "src/test/run-pass-fulldeps/proc_macro.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Ftest%2Frun-pass-fulldeps%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d975fdcef451375df20e5ac234bb01e453e33/src%2Ftest%2Frun-pass-fulldeps%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc_macro.rs?ref=3a5d975fdcef451375df20e5ac234bb01e453e33", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:proc_macro_def.rs\n+// ignore-stage1\n+// ignore-cross-compile\n+\n+#![feature(plugin, custom_attribute)]\n+#![feature(type_macros)]\n+\n+#![plugin(proc_macro_def)]\n+\n+#[attr_tru]\n+fn f1() -> bool {\n+    return false;\n+}\n+\n+#[attr_identity]\n+fn f2() -> bool {\n+    return identity!(true);\n+}\n+\n+fn f3() -> identity!(bool) {\n+    ret_tru!();\n+}\n+\n+fn f4(x: bool) -> bool {\n+    match x {\n+        identity!(true) => false,\n+        identity!(false) => true,\n+    }\n+}\n+\n+fn main() {\n+    assert!(f1());\n+    assert!(f2());\n+    assert!(tru!());\n+    assert!(f3());\n+    assert!(identity!(5 == 5));\n+    assert!(f4(false));\n+}"}]}