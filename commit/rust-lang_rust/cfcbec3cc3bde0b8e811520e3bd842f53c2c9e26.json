{"sha": "cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmY2JlYzNjYzNiZGUwYjhlODExNTIwZTNiZDg0MmY1M2MyYzllMjY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-14T19:16:46Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-21T03:39:40Z"}, "message": "Implement an initial version of placement new.", "tree": {"sha": "f6b837b27e979fabfca3bc1df10a2b742d42d351", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6b837b27e979fabfca3bc1df10a2b742d42d351"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "html_url": "https://github.com/rust-lang/rust/commit/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba39e277e2c63909cb35a0dd68e9f3bab728c425", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba39e277e2c63909cb35a0dd68e9f3bab728c425", "html_url": "https://github.com/rust-lang/rust/commit/ba39e277e2c63909cb35a0dd68e9f3bab728c425"}], "stats": {"total": 353, "additions": 266, "deletions": 87}, "files": [{"sha": "e7315633cf2c45ccc422a7ddefeb761a031c2651", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -434,8 +434,8 @@ fn for_each_package(c: cargo, b: fn(source, package)) {\n \n // Runs all programs in directory <buildpath>\n fn run_programs(buildpath: str) {\n-    let new = os::list_dir(buildpath);\n-    for ct: str in new {\n+    let newv = os::list_dir(buildpath);\n+    for ct: str in newv {\n         run::run_program(ct, []);\n     }\n }\n@@ -471,9 +471,9 @@ fn install_one_crate(c: cargo, path: str, cf: str) {\n       none { ret; }\n       some(bp) { bp }\n     };\n-    let new = os::list_dir(buildpath);\n+    let newv = os::list_dir(buildpath);\n     let exec_suffix = os::exe_suffix();\n-    for ct: str in new {\n+    for ct: str in newv {\n         if (exec_suffix != \"\" && str::ends_with(ct, exec_suffix)) ||\n             (exec_suffix == \"\" && !str::starts_with(path::basename(ct),\n                                                     \"lib\")) {"}, {"sha": "9e4a1f3ad29b3e817d5c38f9b57ed726340f17aa", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -488,23 +488,23 @@ fn file_might_not_converge(filename: str) -> bool {\n fn check_roundtrip_convergence(code: @str, maxIters: uint) {\n \n     let i = 0u;\n-    let new = code;\n-    let old = code;\n+    let newv = code;\n+    let oldv = code;\n \n     while i < maxIters {\n-        old = new;\n-        if content_might_not_converge(*old) { ret; }\n-        new = @parse_and_print(old);\n-        if old == new { break; }\n+        oldv = newv;\n+        if content_might_not_converge(*oldv) { ret; }\n+        newv = @parse_and_print(oldv);\n+        if oldv == newv { break; }\n         i += 1u;\n     }\n \n-    if old == new {\n+    if oldv == newv {\n         #error(\"Converged after %u iterations\", i);\n     } else {\n         #error(\"Did not converge after %u iterations!\", i);\n-        write_file(\"round-trip-a.rs\", *old);\n-        write_file(\"round-trip-b.rs\", *new);\n+        write_file(\"round-trip-a.rs\", *oldv);\n+        write_file(\"round-trip-b.rs\", *newv);\n         run::run_program(\"diff\",\n                          [\"-w\", \"-u\", \"round-trip-a.rs\",\n                           \"round-trip-b.rs\"]);"}, {"sha": "d722e56cdab1aed1ba2409202d728b2f4c9aad06", "filename": "src/libcore/path.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -266,30 +266,30 @@ fn normalize(p: path) -> path {\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"freebsd\")]\n-    fn reabsolute(orig: path, new: path) -> path {\n+    fn reabsolute(orig: path, n: path) -> path {\n         if path_is_absolute(orig) {\n-            path_sep() + new\n+            path_sep() + n\n         } else {\n-            new\n+            n\n         }\n     }\n \n     #[cfg(target_os = \"win32\")]\n-    fn reabsolute(orig: path, new: path) -> path {\n+    fn reabsolute(orig: path, newp: path) -> path {\n        if path_is_absolute(orig) && orig[0] == consts::path_sep as u8 {\n-           str::from_char(consts::path_sep) + new\n+           str::from_char(consts::path_sep) + newp\n        } else {\n-           new\n+           newp\n        }\n     }\n \n-    fn reterminate(orig: path, new: path) -> path {\n+    fn reterminate(orig: path, newp: path) -> path {\n         let last = orig[str::len(orig) - 1u];\n         if last == consts::path_sep as u8\n             || last == consts::path_sep as u8 {\n-            ret new + path_sep();\n+            ret newp + path_sep();\n         } else {\n-            ret new;\n+            ret newp;\n         }\n     }\n }"}, {"sha": "3950aa817072c7d6c5d447af018784ac6c48c826", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -468,22 +468,22 @@ Concatenate a vector of vectors.\n Flattens a vector of vectors of T into a single vector of T.\n \"]\n fn concat<T: copy>(v: [const [const T]]) -> [T] {\n-    let mut new: [T] = [];\n-    for inner: [T] in v { new += inner; }\n-    ret new;\n+    let mut r: [T] = [];\n+    for inner: [T] in v { r += inner; }\n+    ret r;\n }\n \n #[doc = \"\n Concatenate a vector of vectors, placing a given separator between each\n \"]\n fn connect<T: copy>(v: [const [const T]], sep: T) -> [T] {\n-    let mut new: [T] = [];\n+    let mut r: [T] = [];\n     let mut first = true;\n     for inner: [T] in v {\n-        if first { first = false; } else { push(new, sep); }\n-        new += inner;\n+        if first { first = false; } else { push(r, sep); }\n+        r += inner;\n     }\n-    ret new;\n+    ret r;\n }\n \n #[doc = \"Reduce a vector from left to right\"]"}, {"sha": "bfc6be4825328e4dfdc5c6e935deee2d9de61e39", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -2308,6 +2308,9 @@ fn resolve_impl_in_expr(e: @env, x: @ast::expr, sc: iscopes, v: vt<iscopes>) {\n       ast::expr_assign_op(_, _, _) | ast::expr_index(_, _) {\n         e.impl_map.insert(x.id, sc);\n       }\n+      ast::expr_new(p, _, _) {\n+        e.impl_map.insert(p.id, sc);\n+      }\n       _ {}\n     }\n     visit::visit_expr(x, sc, v);"}, {"sha": "c0dbdc962104b0ee9d7ebf8ad32d96eb3f7f3e4c", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 78, "deletions": 26, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -1261,9 +1261,9 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n       some(origin) {\n         let callee_id = ast_util::op_expr_callee_id(un_expr);\n         let fty = node_id_type(bcx, callee_id);\n-        ret trans_call_inner(bcx, fty, {|bcx|\n+        ret trans_call_inner(bcx, fty, expr_ty(bcx, un_expr), {|bcx|\n             impl::trans_method_callee(bcx, callee_id, e, origin)\n-        }, [], un_expr.id, dest);\n+        }, arg_exprs([]), dest);\n       }\n       _ {}\n     }\n@@ -1450,10 +1450,10 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n       some(origin) {\n         let callee_id = ast_util::op_expr_callee_id(ex);\n         let fty = node_id_type(bcx, callee_id);\n-        ret trans_call_inner(bcx, fty, {|bcx|\n+        ret trans_call_inner(bcx, fty, expr_ty(bcx, ex), {|bcx|\n             // FIXME provide the already-computed address, not the expr\n             impl::trans_method_callee(bcx, callee_id, dst, origin)\n-        }, [src], ex.id, save_in(lhs_res.val));\n+        }, arg_exprs([src]), save_in(lhs_res.val));\n       }\n       _ {}\n     }\n@@ -1561,9 +1561,9 @@ fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n       some(origin) {\n         let callee_id = ast_util::op_expr_callee_id(ex);\n         let fty = node_id_type(bcx, callee_id);\n-        ret trans_call_inner(bcx, fty, {|bcx|\n+        ret trans_call_inner(bcx, fty, expr_ty(bcx, ex), {|bcx|\n             impl::trans_method_callee(bcx, callee_id, lhs, origin)\n-        }, [rhs], ex.id, dest);\n+        }, arg_exprs([rhs]), dest);\n       }\n       _ {}\n     }\n@@ -2498,19 +2498,23 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n     ret rslt(bcx, val);\n }\n \n+enum call_args {\n+    arg_exprs([@ast::expr]),\n+    arg_vals([ValueRef])\n+}\n \n // NB: must keep 4 fns in sync:\n //\n //  - type_of_fn\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-fn trans_args(cx: block, llenv: ValueRef, es: [@ast::expr], fn_ty: ty::t,\n+fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n               dest: dest, generic_intrinsic: bool)\n     -> {bcx: block, args: [ValueRef], retslot: ValueRef} {\n \n     let temp_cleanups = [];\n-    let args = ty::ty_fn_args(fn_ty);\n+    let arg_tys = ty::ty_fn_args(fn_ty);\n     let llargs: [ValueRef] = [];\n \n     let ccx = cx.ccx();\n@@ -2546,13 +2550,21 @@ fn trans_args(cx: block, llenv: ValueRef, es: [@ast::expr], fn_ty: ty::t,\n     // First we figure out the caller's view of the types of the arguments.\n     // This will be needed if this is a generic call, because the callee has\n     // to cast her view of the arguments to the caller's view.\n-    let arg_tys = type_of_explicit_args(ccx, args);\n-    let i = 0u;\n-    for e: @ast::expr in es {\n-        let r = trans_arg_expr(bcx, args[i], arg_tys[i], e, temp_cleanups);\n-        bcx = r.bcx;\n-        llargs += [r.val];\n-        i += 1u;\n+    alt args {\n+      arg_exprs(es) {\n+        let llarg_tys = type_of_explicit_args(ccx, arg_tys);\n+        let i = 0u;\n+        for e: @ast::expr in es {\n+            let r = trans_arg_expr(bcx, arg_tys[i], llarg_tys[i],\n+                                   e, temp_cleanups);\n+            bcx = r.bcx;\n+            llargs += [r.val];\n+            i += 1u;\n+        }\n+      }\n+      arg_vals(vs) {\n+        llargs += vs;\n+      }\n     }\n \n     // now that all arguments have been successfully built, we can revoke any\n@@ -2568,15 +2580,15 @@ fn trans_args(cx: block, llenv: ValueRef, es: [@ast::expr], fn_ty: ty::t,\n }\n \n fn trans_call(in_cx: block, f: @ast::expr,\n-              args: [@ast::expr], id: ast::node_id, dest: dest)\n+              args: call_args, id: ast::node_id, dest: dest)\n     -> block {\n-    trans_call_inner(in_cx, expr_ty(in_cx, f),\n-                     {|cx| trans_callee(cx, f)}, args, id, dest)\n+    trans_call_inner(in_cx, expr_ty(in_cx, f), node_id_type(in_cx, id),\n+                     {|cx| trans_callee(cx, f)}, args, dest)\n }\n \n-fn trans_call_inner(in_cx: block, fn_expr_ty: ty::t,\n+fn trans_call_inner(in_cx: block, fn_expr_ty: ty::t, ret_ty: ty::t,\n                     get_callee: fn(block) -> lval_maybe_callee,\n-                    args: [@ast::expr], id: ast::node_id, dest: dest)\n+                    args: call_args, dest: dest)\n     -> block {\n     with_scope(in_cx, \"call\") {|cx|\n         let f_res = get_callee(cx);\n@@ -2603,9 +2615,10 @@ fn trans_call_inner(in_cx: block, fn_expr_ty: ty::t,\n           }\n         };\n \n-        let ret_ty = node_id_type(bcx, id);\n-        let args_res = trans_args(bcx, llenv, args, fn_expr_ty, dest,\n-                                  option::is_some(f_res.tds));\n+        let args_res = {\n+            trans_args(bcx, llenv, args, fn_expr_ty, dest,\n+                       option::is_some(f_res.tds))\n+        };\n         bcx = args_res.bcx;\n         let llargs = args_res.args;\n         option::may(f_res.tds) {|vals|\n@@ -2923,7 +2936,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n       }\n       ast::expr_cast(val, _) { ret trans_cast(bcx, val, e.id, dest); }\n       ast::expr_call(f, args, _) {\n-        ret trans_call(bcx, f, args, e.id, dest);\n+        ret trans_call(bcx, f, arg_exprs(args), e.id, dest);\n       }\n       ast::expr_field(base, _, _) {\n         if dest == ignore { ret trans_expr(bcx, base, ignore); }\n@@ -2937,9 +2950,9 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n         let origin = bcx.ccx().maps.method_map.get(e.id);\n         let callee_id = ast_util::op_expr_callee_id(e);\n         let fty = node_id_type(bcx, callee_id);\n-        ret trans_call_inner(bcx, fty, {|bcx|\n+        ret trans_call_inner(bcx, fty, expr_ty(bcx, e), {|bcx|\n             impl::trans_method_callee(bcx, callee_id, base, origin)\n-        }, [idx], e.id, dest);\n+        }, arg_exprs([idx]), dest);\n       }\n \n       // These return nothing\n@@ -3037,6 +3050,45 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n         assert dest == ignore;\n         ret trans_assign_op(bcx, e, op, dst, src);\n       }\n+      ast::expr_new(pool, alloc_id, val) {\n+        // First, call pool->alloc(sz, align) to get back a void*.  Then, cast\n+        // this memory to the required type and evaluate value into it.\n+        let ccx = bcx.ccx();\n+\n+        // Allocate space for the ptr that will be returned from\n+        // `pool.alloc()`:\n+        let ptr_ty = expr_ty(bcx, e);\n+        let {bcx, val: ptr_ptr_val} = alloc_ty(bcx, ptr_ty);\n+\n+        #debug[\"ptr_ty = %s\", ty_to_str(tcx, ptr_ty)];\n+        #debug[\"ptr_ptr_val = %s\", val_str(ccx.tn, ptr_ptr_val)];\n+\n+        let void_ty = ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx),\n+                                       mutbl: ast::m_imm});\n+        let voidval = {\n+            let llvoid_ty = type_of(ccx, void_ty);\n+            PointerCast(bcx, ptr_ptr_val, T_ptr(llvoid_ty))\n+        };\n+\n+        #debug[\"voidval = %s\", val_str(ccx.tn, voidval)];\n+\n+        let llval_ty = type_of(ccx, expr_ty(bcx, val));\n+        let args = [llsize_of(ccx, llval_ty), llalign_of(ccx, llval_ty)];\n+        let origin = bcx.ccx().maps.method_map.get(alloc_id);\n+        let bcx = trans_call_inner(\n+            bcx,\n+            node_id_type(bcx, alloc_id),\n+            void_ty,\n+            {|bcx| impl::trans_method_callee(bcx, alloc_id, pool, origin) },\n+            arg_vals(args),\n+            save_in(voidval));\n+\n+        #debug[\"dest = %s\", dest_str(ccx, dest)];\n+        let ptr_val = Load(bcx, ptr_ptr_val);\n+        #debug[\"ptr_val = %s\", val_str(ccx.tn, ptr_val)];\n+        let bcx = trans_expr(bcx, val, save_in(ptr_val));\n+        store_in_dest(bcx, ptr_val, dest)\n+      }\n       _ { bcx.tcx().sess.span_bug(e.span, \"trans_expr reached \\\n              fall-through case\"); }\n "}, {"sha": "738879b8d8a9c038bab9bd25950789f1889bc4d7", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -111,27 +111,28 @@ fn classify_ty(ty: TypeRef) -> [x86_64_reg_class] {\n         }\n     }\n \n-    fn unify(cls: [mut x86_64_reg_class], i: uint,\n-             new: x86_64_reg_class) {\n-        if cls[i] == new {\n+    fn unify(cls: [mut x86_64_reg_class],\n+             i: uint,\n+             newv: x86_64_reg_class) {\n+        if cls[i] == newv {\n             ret;\n         } else if cls[i] == no_class {\n-            cls[i] = new;\n-        } else if new == no_class {\n+            cls[i] = newv;\n+        } else if newv == no_class {\n             ret;\n-        } else if cls[i] == memory_class || new == memory_class {\n+        } else if cls[i] == memory_class || newv == memory_class {\n             cls[i] = memory_class;\n-        } else if cls[i] == integer_class || new == integer_class {\n+        } else if cls[i] == integer_class || newv == integer_class {\n             cls[i] = integer_class;\n         } else if cls[i] == x87_class ||\n                   cls[i] == x87up_class ||\n                   cls[i] == complex_x87_class ||\n-                  new == x87_class ||\n-                  new == x87up_class ||\n-                  new == complex_x87_class {\n+                  newv == x87_class ||\n+                  newv == x87up_class ||\n+                  newv == complex_x87_class {\n             cls[i] = memory_class;\n         } else {\n-            cls[i] = new;\n+            cls[i] = newv;\n         }\n     }\n "}, {"sha": "68779c7e71ec29a57cbb2461880d25e31d0a3713", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -168,6 +168,9 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n       expr_log(_, _, val) {\n         node_type_needs(cx, use_tydesc, val.id);\n       }\n+      expr_new(_, _, v) {\n+        node_type_needs(cx, use_repr, v.id);\n+      }\n       expr_for(_, _, _) | expr_do_while(_, _) | expr_alt(_, _, _) |\n       expr_block(_) | expr_if(_, _, _) | expr_while(_, _) |\n       expr_fail(_) | expr_break | expr_cont | expr_unary(_, _) |"}, {"sha": "82388f9b89f8fba17d4cdee132d1a6890a663af3", "filename": "src/rustc/middle/tstate/ann.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -183,14 +183,14 @@ fn set_poststate(a: ts_ann, p: poststate) -> bool {\n \n \n // Set all the bits in p that are set in new\n-fn extend_prestate(p: prestate, new: poststate) -> bool {\n-    ret tritv_union(p, new);\n+fn extend_prestate(p: prestate, newv: poststate) -> bool {\n+    ret tritv_union(p, newv);\n }\n \n \n // Set all the bits in p that are set in new\n-fn extend_poststate(p: poststate, new: poststate) -> bool {\n-    ret tritv_union(p, new);\n+fn extend_poststate(p: poststate, newv: poststate) -> bool {\n+    ret tritv_union(p, newv);\n }\n \n // Sets the given bit in p to \"don't care\""}, {"sha": "e6f5ca1dd64aac850b9616fa483ccf1cde13c279", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -709,8 +709,8 @@ fn find_instances(_fcx: fn_ctxt, subst: subst, c: constraint) ->\n         for d: pred_args in *descs {\n             if args_mention(d.node.args, find_in_subst_bool, subst) {\n                 let old_bit_num = d.node.bit_num;\n-                let new = replace(subst, d);\n-                alt find_instance_(new, *descs) {\n+                let newv = replace(subst, d);\n+                alt find_instance_(newv, *descs) {\n                   some(d1) { rslt += [{from: old_bit_num, to: d1}]; }\n                   _ { }\n                 }\n@@ -753,7 +753,7 @@ fn replace(subst: subst, d: pred_args) -> [constr_arg_general_<inst>] {\n         alt c.node {\n           carg_ident(p) {\n             alt find_in_subst(p.node, subst) {\n-              some(new) { rslt += [carg_ident(new)]; }\n+              some(newv) { rslt += [carg_ident(newv)]; }\n               _ { rslt += [c.node]; }\n             }\n           }"}, {"sha": "89e7409ed961386eab0e9193d55785abd52d196d", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -325,6 +325,9 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         clear_pp(rslt);\n         handle_var(fcx, rslt, e.id, path_to_ident(p));\n       }\n+      expr_new(p, _, v) {\n+        find_pre_post_exprs(fcx, [p, v], e.id);\n+      }\n       expr_log(_, lvl, arg) {\n         find_pre_post_exprs(fcx, [lvl, arg], e.id);\n       }"}, {"sha": "7bb16a5ec9eb7e1d70ac67d074ab5daba5890d96", "filename": "src/rustc/middle/tstate/states.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -355,6 +355,9 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n     let num_constrs = num_constraints(fcx.enclosing);\n \n     alt e.node {\n+      expr_new(p, _, v) {\n+        ret find_pre_post_state_two(fcx, pres, p, v, e.id, oper_pure);\n+      }\n       expr_vec(elts, _) {\n         ret find_pre_post_state_exprs(fcx, pres, e.id,\n                                       vec::from_elem(vec::len(elts),"}, {"sha": "98b27e0e3baef1d834a5a0743c459acabea2ea81", "filename": "src/rustc/middle/tstate/tritv.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -155,8 +155,8 @@ fn trit_and(a: trit, b: trit) -> trit {\n     // a and b were both dont_care\n }\n \n-fn change(changed: bool, old: trit, new: trit) -> bool {\n-    changed || new != old\n+fn change(changed: bool, old: trit, newv: trit) -> bool {\n+    changed || newv != old\n }\n \n fn tritv_difference(p1: t, p2: t) -> bool {\n@@ -166,9 +166,9 @@ fn tritv_difference(p1: t, p2: t) -> bool {\n     let changed = false;\n     while i < sz {\n         let old = tritv_get(p1, i);\n-        let new = trit_minus(old, tritv_get(p2, i));\n-        changed = change(changed, old, new);\n-        tritv_set(i, p1, new);\n+        let newv = trit_minus(old, tritv_get(p2, i));\n+        changed = change(changed, old, newv);\n+        tritv_set(i, p1, newv);\n         i += 1u;\n     }\n     ret changed;\n@@ -181,9 +181,9 @@ fn tritv_union(p1: t, p2: t) -> bool {\n     let changed = false;\n     while i < sz {\n         let old = tritv_get(p1, i);\n-        let new = trit_or(old, tritv_get(p2, i));\n-        changed = change(changed, old, new);\n-        tritv_set(i, p1, new);\n+        let newv = trit_or(old, tritv_get(p2, i));\n+        changed = change(changed, old, newv);\n+        tritv_set(i, p1, newv);\n         i += 1u;\n     }\n     ret changed;\n@@ -196,9 +196,9 @@ fn tritv_intersect(p1: t, p2: t) -> bool {\n     let changed = false;\n     while i < sz {\n         let old = tritv_get(p1, i);\n-        let new = trit_and(old, tritv_get(p2, i));\n-        changed = change(changed, old, new);\n-        tritv_set(i, p1, new);\n+        let newv = trit_and(old, tritv_get(p2, i));\n+        changed = change(changed, old, newv);\n+        tritv_set(i, p1, newv);\n         i += 1u;\n     }\n     ret changed;"}, {"sha": "a6c23cdca5868738c23b8799fcf9b21862d18bdc", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -1888,6 +1888,12 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n                   origin: method_origin,\n                   self_sub: option<self_subst>}> {\n     let tcx = fcx.ccx.tcx;\n+\n+    #debug[\"lookup_method_inner: expr=%s name=%s ty=%s\",\n+           expr_to_str(expr),\n+           name,\n+           ty_to_str(fcx.ccx.tcx, ty)];\n+\n     // First, see whether this is an interface-bounded parameter\n     alt ty::get(ty).struct {\n       ty::ty_param(n, did) {\n@@ -2870,6 +2876,51 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           }\n         }\n       }\n+      ast::expr_new(p, alloc_id, v) {\n+        bot |= check_expr(fcx, p);\n+        bot |= check_expr(fcx, v);\n+\n+        let p_ty = expr_ty(tcx, p);\n+\n+        alt lookup_method(fcx, p, alloc_id, \"alloc\", p_ty, []) {\n+          some(origin) {\n+            fcx.ccx.method_map.insert(alloc_id, origin);\n+\n+            // Check that the alloc() method has the expected type, which\n+            // should be fn(sz: uint, align: uint) -> *().\n+            let expected_ty = {\n+                let ty_uint = ty::mk_uint(tcx);\n+                let ty_nilp = ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx),\n+                                              mutbl: ast::m_imm});\n+                let m = ast::expl(ty::default_arg_mode_for_ty(ty_uint));\n+                ty::mk_fn(tcx, {proto: ast::proto_any,\n+                                inputs: [{mode: m, ty: ty_uint},\n+                                         {mode: m, ty: ty_uint}],\n+                                output: ty_nilp,\n+                                ret_style: ast::return_val,\n+                                constraints: []})\n+            };\n+\n+            demand::simple(fcx, expr.span,\n+                           expected_ty, node_id_to_type(tcx, alloc_id));\n+          }\n+\n+          none {\n+            let t_err = resolve_type_vars_if_possible(fcx, p_ty);\n+            let msg = #fmt[\"no `alloc()` method found for type `%s`\",\n+                           ty_to_str(tcx, t_err)];\n+            tcx.sess.span_err(expr.span, msg);\n+          }\n+        }\n+\n+        // The region value must have a type like &r.T.  The resulting\n+        // memory will be allocated into the region `r`.\n+        let pool_region = region_of(fcx, p);\n+        let v_ty = expr_ty(tcx, v);\n+        let res_ty = ty::mk_rptr(tcx, pool_region, {ty: v_ty,\n+                                                    mutbl: ast::m_imm});\n+        write_ty(tcx, expr.id, res_ty);\n+      }\n     }\n     if bot { write_ty(tcx, expr.id, ty::mk_bot(tcx)); }\n "}, {"sha": "93f60519114c062c443b873b6482551f5f2c73eb", "filename": "src/rustc/syntax/ast.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fast.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -325,6 +325,10 @@ enum expr_ {\n     expr_be(@expr),\n     expr_log(int, @expr, @expr),\n \n+    expr_new(/* arena */ @expr,\n+             /* id for the alloc() call */ node_id,\n+             /* value */ @expr),\n+\n     /* just an assert, no significance to typestate */\n     expr_assert(@expr),\n "}, {"sha": "ab5659b1ff43569a39b4f9ea798f790a0978ccea", "filename": "src/rustc/syntax/fold.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Ffold.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -382,6 +382,11 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n     let fold_mac = bind fold_mac_(_, fld);\n \n     ret alt e {\n+          expr_new(p, i, v) {\n+            expr_new(fld.fold_expr(p),\n+                     fld.new_id(i),\n+                     fld.fold_expr(v))\n+          }\n           expr_vec(exprs, mutt) {\n             expr_vec(fld.map_exprs(fld.fold_expr, exprs), mutt)\n           }"}, {"sha": "99746aed84a7f79dda64ceb31da94145d1903e84", "filename": "src/rustc/syntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -150,7 +150,7 @@ fn bad_expr_word_table() -> hashmap<str, ()> {\n                  \"enum\", \"export\", \"fail\", \"fn\", \"for\", \"if\",  \"iface\",\n                  \"impl\", \"import\", \"let\", \"log\", \"loop\", \"mod\", \"mut\",\n                  \"mutable\", \"native\", \"pure\", \"resource\", \"ret\", \"trait\",\n-                 \"type\", \"unchecked\", \"unsafe\", \"while\"] {\n+                 \"type\", \"unchecked\", \"unsafe\", \"while\", \"new\"] {\n         words.insert(word, ());\n     }\n     words\n@@ -852,6 +852,13 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n             let blk = parse_block_tail(p, lo, ast::default_blk);\n             ret mk_pexpr(p, blk.span.lo, blk.span.hi, ast::expr_block(blk));\n         }\n+    } else if eat_word(p, \"new\") {\n+        expect(p, token::LPAREN);\n+        let r = parse_expr(p);\n+        expect(p, token::RPAREN);\n+        let v = parse_expr(p);\n+        ret mk_pexpr(p, lo, p.span.hi,\n+                     ast::expr_new(r, p.get_id(), v));\n     } else if eat_word(p, \"if\") {\n         ret pexpr(parse_if_expr(p));\n     } else if eat_word(p, \"for\") {"}, {"sha": "6bdd4d843069fcbe3b699540bec3e2d5ed5178cb", "filename": "src/rustc/syntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -1089,6 +1089,13 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         word_nbsp(s, \"assert\");\n         print_expr(s, expr);\n       }\n+      ast::expr_new(p, _, v) {\n+        word_nbsp(s, \"new\");\n+        popen(s);\n+        print_expr(s, p);\n+        pclose(s);\n+        print_expr(s, v);\n+      }\n       ast::expr_mac(m) { print_mac(s, m); }\n     }\n     s.ann.post(ann_node);"}, {"sha": "fa3c043d647b23272ce760b7aa37181af14e6af5", "filename": "src/rustc/syntax/visit.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Frustc%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fvisit.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -315,6 +315,10 @@ fn visit_mac<E>(m: mac, e: E, v: vt<E>) {\n \n fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n     alt ex.node {\n+      expr_new(pool, _, val) {\n+        v.visit_expr(pool, e, v);\n+        v.visit_expr(val, e, v);\n+      }\n       expr_vec(es, _) { visit_exprs(es, e, v); }\n       expr_rec(flds, base) {\n         for f: field in flds { v.visit_expr(f.node.expr, e, v); }"}, {"sha": "562faf84136a13df3dcdf2425312c478c4876162", "filename": "src/test/compile-fail/placement-new-bad-method-type.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Ftest%2Fcompile-fail%2Fplacement-new-bad-method-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Ftest%2Fcompile-fail%2Fplacement-new-bad-method-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fplacement-new-bad-method-type.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -0,0 +1,15 @@\n+import libc, unsafe;\n+\n+enum malloc_pool = ();\n+\n+impl methods for malloc_pool {\n+    fn alloc(sz: int, align: int) -> *() {\n+        fail;\n+    }\n+}\n+\n+fn main() {\n+    let p = &malloc_pool(());\n+    let x = new(*p) 4u;\n+    //!^ ERROR mismatched types: expected `fn(uint, uint) -> *()`\n+}"}, {"sha": "20eb185b02a433bbc181fc990b764373c81b3d71", "filename": "src/test/run-pass/chan-leak.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Ftest%2Frun-pass%2Fchan-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Ftest%2Frun-pass%2Fchan-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchan-leak.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -21,7 +21,7 @@ fn request_task(c: chan<ctx>) {\n     req = recv(p);\n }\n \n-fn new() -> ctx {\n+fn new_cx() -> ctx {\n     let p = port();\n     let ch = chan(p);\n     let t = task::spawn {|| request_task(ch); };\n@@ -31,7 +31,7 @@ fn new() -> ctx {\n }\n \n fn main() {\n-    let cx = new();\n+    let cx = new_cx();\n \n     let p = port::<bool>();\n     send(cx, close(chan(p)));"}, {"sha": "e429dfacbc3296511f49dae2336cc898d4e8f352", "filename": "src/test/run-pass/placement-new-leaky.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Ftest%2Frun-pass%2Fplacement-new-leaky.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26/src%2Ftest%2Frun-pass%2Fplacement-new-leaky.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fplacement-new-leaky.rs?ref=cfcbec3cc3bde0b8e811520e3bd842f53c2c9e26", "patch": "@@ -0,0 +1,21 @@\n+import libc, unsafe;\n+\n+enum malloc_pool = ();\n+\n+impl methods for malloc_pool {\n+    fn alloc(sz: uint, align: uint) -> *() {\n+        unsafe {\n+            unsafe::reinterpret_cast(libc::malloc(sz))\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let p = &malloc_pool(());\n+    let x = new(*p) 4u;\n+    io::print(#fmt[\"%u\", *x]);\n+    assert *x == 4u;\n+    unsafe {\n+        libc::free(unsafe::reinterpret_cast(x));\n+    }\n+}"}]}