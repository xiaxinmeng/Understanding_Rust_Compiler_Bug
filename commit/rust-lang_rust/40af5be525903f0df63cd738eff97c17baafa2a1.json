{"sha": "40af5be525903f0df63cd738eff97c17baafa2a1", "node_id": "C_kwDOAAsO6NoAKDQwYWY1YmU1MjU5MDNmMGRmNjNjZDczOGVmZjk3YzE3YmFhZmEyYTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-27T05:59:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-27T05:59:56Z"}, "message": "Auto merge of #9674 - smoelius:needless-borrow-fp, r=Jarcho\n\nFix `needless_borrow` false positive\n\nThe PR fixes the false positive exposed by `@BusyJay's` example in: https://github.com/rust-lang/rust-clippy/issues/9111#issuecomment-1277114280\n\nThe current approach is described in https://github.com/rust-lang/rust-clippy/pull/9674#issuecomment-1289294201 and https://github.com/rust-lang/rust-clippy/pull/9674#issuecomment-1292225232.\n\nThe original approach appears below.\n\n---\n\nThe proposed fix is to flag only \"simple\" trait implementations involving references, a concept\nthat I introduce next.\n\nIntuitively, a trait implementation is \"simple\" if all it does is dereference and apply the trait\nimplementation of a type named by a type parameter. `AsRef` provides a good example of a simple\nimplementation: https://doc.rust-lang.org/std/convert/trait.AsRef.html#impl-AsRef%3CU%3E-for-%26T\n\nWe can make this idea more precise as follows. Given a trait implementation, first determine\nwhether the implementation is \"used defined.\" If so, then examine its nested obligations.\nConsider the implementation simple if-and-only-if:\n- there is at least one nested obligation for the same trait\n- for each type `X` in the nested obligation's substitution, either `X` is the same as that of\n  the original obligation's substitution, or the original type is `&X`\n\nFor example, the following implementation from `@BusyJay's` example is \"complex\" (i.e., not simple)\nbecause it produces no nested obligations:\n\n```rust\nimpl<'a> Extend<&'a u8> for A { ... }\n```\n\nOn the other hand, the following slightly modified implementation is simple, because it produces\na nested obligation for `Extend<X>`:\n\n```rust\nimpl<'a, X> Extend<&'a X> for A where A: Extend<X> { ... }\n```\n\nHow does flagging only simple implementations help? One way of interpreting the false positive in\n`@BusyJay's` example is that it separates a reference from a concrete type. Doing so turns a\nsuccessful type inference into a failing one. By flagging only simple implementations, we\nseparate references from type variables only, thereby eliminating this class of false positives.\n\nNote that `Deref` is a special case, as the obligations generated for it already involve the\nunderlying type.\n\nr? `@Jarcho` (Sorry to keep pinging you with `needless_borrow` stuff. But my impression is no one knows this code better than you.)\n\nchangelog: fix `needless_borrow` false positive", "tree": {"sha": "f63a118a6f9ae85d5ccab9ce244277a1cbceb634", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f63a118a6f9ae85d5ccab9ce244277a1cbceb634"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40af5be525903f0df63cd738eff97c17baafa2a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40af5be525903f0df63cd738eff97c17baafa2a1", "html_url": "https://github.com/rust-lang/rust/commit/40af5be525903f0df63cd738eff97c17baafa2a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40af5be525903f0df63cd738eff97c17baafa2a1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70187c7d112414e40f877aed9787258e5770467d", "url": "https://api.github.com/repos/rust-lang/rust/commits/70187c7d112414e40f877aed9787258e5770467d", "html_url": "https://github.com/rust-lang/rust/commit/70187c7d112414e40f877aed9787258e5770467d"}, {"sha": "83771c524225176616db45ebe67045a6f89b7117", "url": "https://api.github.com/repos/rust-lang/rust/commits/83771c524225176616db45ebe67045a6f89b7117", "html_url": "https://github.com/rust-lang/rust/commit/83771c524225176616db45ebe67045a6f89b7117"}], "stats": {"total": 93, "additions": 90, "deletions": 3}, "files": [{"sha": "7e2e32a20d4fc3d2d074fb6e57a1a8d5d591866d", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/40af5be525903f0df63cd738eff97c17baafa2a1/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40af5be525903f0df63cd738eff97c17baafa2a1/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=40af5be525903f0df63cd738eff97c17baafa2a1", "patch": "@@ -1049,7 +1049,7 @@ fn ty_contains_infer(ty: &hir::Ty<'_>) -> bool {\n // If the conditions are met, returns `Some(Position::ImplArg(..))`; otherwise, returns `None`.\n //   The \"is copyable\" condition is to avoid the case where removing the `&` means `e` would have to\n // be moved, but it cannot be.\n-#[expect(clippy::too_many_arguments)]\n+#[expect(clippy::too_many_arguments, clippy::too_many_lines)]\n fn needless_borrow_impl_arg_position<'tcx>(\n     cx: &LateContext<'tcx>,\n     possible_borrowers: &mut Vec<(LocalDefId, PossibleBorrowerMap<'tcx, 'tcx>)>,\n@@ -1092,7 +1092,7 @@ fn needless_borrow_impl_arg_position<'tcx>(\n         .iter()\n         .filter_map(|predicate| {\n             if let PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder()\n-                && trait_predicate.trait_ref.self_ty() == param_ty.to_ty(cx.tcx)\n+                && trait_predicate.self_ty() == param_ty.to_ty(cx.tcx)\n             {\n                 Some(trait_predicate.trait_ref.def_id)\n             } else {\n@@ -1111,6 +1111,16 @@ fn needless_borrow_impl_arg_position<'tcx>(\n         return Position::Other(precedence);\n     }\n \n+    // See:\n+    // - https://github.com/rust-lang/rust-clippy/pull/9674#issuecomment-1289294201\n+    // - https://github.com/rust-lang/rust-clippy/pull/9674#issuecomment-1292225232\n+    if projection_predicates\n+        .iter()\n+        .any(|projection_predicate| is_mixed_projection_predicate(cx, callee_def_id, projection_predicate))\n+    {\n+        return Position::Other(precedence);\n+    }\n+\n     // `substs_with_referent_ty` can be constructed outside of `check_referent` because the same\n     // elements are modified each time `check_referent` is called.\n     let mut substs_with_referent_ty = substs_with_expr_ty.to_vec();\n@@ -1190,8 +1200,39 @@ fn has_ref_mut_self_method(cx: &LateContext<'_>, trait_def_id: DefId) -> bool {\n         })\n }\n \n-fn referent_used_exactly_once<'tcx>(\n+fn is_mixed_projection_predicate<'tcx>(\n     cx: &LateContext<'tcx>,\n+    callee_def_id: DefId,\n+    projection_predicate: &ProjectionPredicate<'tcx>,\n+) -> bool {\n+    let generics = cx.tcx.generics_of(callee_def_id);\n+    // The predicate requires the projected type to equal a type parameter from the parent context.\n+    if let Some(term_ty) = projection_predicate.term.ty()\n+        && let ty::Param(term_param_ty) = term_ty.kind()\n+        && (term_param_ty.index as usize) < generics.parent_count\n+    {\n+        // The inner-most self type is a type parameter from the current function.\n+        let mut projection_ty = projection_predicate.projection_ty;\n+        loop {\n+            match projection_ty.self_ty().kind() {\n+                ty::Projection(inner_projection_ty) => {\n+                    projection_ty = *inner_projection_ty;\n+                }\n+                ty::Param(param_ty) => {\n+                    return (param_ty.index as usize) >= generics.parent_count;\n+                }\n+                _ => {\n+                    return false;\n+                }\n+            }\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+fn referent_used_exactly_once<'a, 'tcx>(\n+    cx: &'a LateContext<'tcx>,\n     possible_borrowers: &mut Vec<(LocalDefId, PossibleBorrowerMap<'tcx, 'tcx>)>,\n     reference: &Expr<'tcx>,\n ) -> bool {"}, {"sha": "57a682d62c0c0f30c0836eea62f2e6cab31b15e9", "filename": "tests/ui/needless_borrow.fixed", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/40af5be525903f0df63cd738eff97c17baafa2a1/tests%2Fui%2Fneedless_borrow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/40af5be525903f0df63cd738eff97c17baafa2a1/tests%2Fui%2Fneedless_borrow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.fixed?ref=40af5be525903f0df63cd738eff97c17baafa2a1", "patch": "@@ -385,3 +385,26 @@ mod used_more_than_once {\n     fn use_x(_: impl AsRef<str>) {}\n     fn use_x_again(_: impl AsRef<str>) {}\n }\n+\n+// https://github.com/rust-lang/rust-clippy/issues/9111#issuecomment-1277114280\n+#[allow(dead_code)]\n+mod issue_9111 {\n+    struct A;\n+\n+    impl Extend<u8> for A {\n+        fn extend<T: IntoIterator<Item = u8>>(&mut self, _: T) {\n+            unimplemented!()\n+        }\n+    }\n+\n+    impl<'a> Extend<&'a u8> for A {\n+        fn extend<T: IntoIterator<Item = &'a u8>>(&mut self, _: T) {\n+            unimplemented!()\n+        }\n+    }\n+\n+    fn main() {\n+        let mut a = A;\n+        a.extend(&[]); // vs a.extend([]);\n+    }\n+}"}, {"sha": "0d325b48ab8109822c735bf10a2c07a1d14f7a2a", "filename": "tests/ui/needless_borrow.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/40af5be525903f0df63cd738eff97c17baafa2a1/tests%2Fui%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40af5be525903f0df63cd738eff97c17baafa2a1/tests%2Fui%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.rs?ref=40af5be525903f0df63cd738eff97c17baafa2a1", "patch": "@@ -385,3 +385,26 @@ mod used_more_than_once {\n     fn use_x(_: impl AsRef<str>) {}\n     fn use_x_again(_: impl AsRef<str>) {}\n }\n+\n+// https://github.com/rust-lang/rust-clippy/issues/9111#issuecomment-1277114280\n+#[allow(dead_code)]\n+mod issue_9111 {\n+    struct A;\n+\n+    impl Extend<u8> for A {\n+        fn extend<T: IntoIterator<Item = u8>>(&mut self, _: T) {\n+            unimplemented!()\n+        }\n+    }\n+\n+    impl<'a> Extend<&'a u8> for A {\n+        fn extend<T: IntoIterator<Item = &'a u8>>(&mut self, _: T) {\n+            unimplemented!()\n+        }\n+    }\n+\n+    fn main() {\n+        let mut a = A;\n+        a.extend(&[]); // vs a.extend([]);\n+    }\n+}"}]}