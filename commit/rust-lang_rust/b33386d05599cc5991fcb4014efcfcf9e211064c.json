{"sha": "b33386d05599cc5991fcb4014efcfcf9e211064c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMzM4NmQwNTU5OWNjNTk5MWZjYjQwMTRlZmNmY2Y5ZTIxMTA2NGM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-27T20:01:44Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-03T22:01:56Z"}, "message": "libsyntax: De-`@mut` `StringReader::pos`", "tree": {"sha": "1e1f508accd4cefb8e286e2f33d569ed0c1c902e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e1f508accd4cefb8e286e2f33d569ed0c1c902e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b33386d05599cc5991fcb4014efcfcf9e211064c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b33386d05599cc5991fcb4014efcfcf9e211064c", "html_url": "https://github.com/rust-lang/rust/commit/b33386d05599cc5991fcb4014efcfcf9e211064c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b33386d05599cc5991fcb4014efcfcf9e211064c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3aa19a6b86ef8317cd95fd517dcc24216d857eb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3aa19a6b86ef8317cd95fd517dcc24216d857eb1", "html_url": "https://github.com/rust-lang/rust/commit/3aa19a6b86ef8317cd95fd517dcc24216d857eb1"}], "stats": {"total": 27, "additions": 14, "deletions": 13}, "files": [{"sha": "648858f8a76faf07c6d2a0119088601c7e5cb348", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b33386d05599cc5991fcb4014efcfcf9e211064c/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33386d05599cc5991fcb4014efcfcf9e211064c/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=b33386d05599cc5991fcb4014efcfcf9e211064c", "patch": "@@ -18,6 +18,7 @@ use parse::token;\n use parse::token::{str_to_ident};\n \n use std::cast::transmute;\n+use std::cell::Cell;\n use std::char;\n use std::num::from_str_radix;\n use std::util;\n@@ -43,7 +44,7 @@ pub struct StringReader {\n     span_diagnostic: @mut SpanHandler,\n     src: @str,\n     // The absolute offset within the codemap of the next character to read\n-    pos: BytePos,\n+    pos: Cell<BytePos>,\n     // The absolute offset within the codemap of the last character read(curr)\n     last_pos: BytePos,\n     // The column of the next character to read\n@@ -73,7 +74,7 @@ pub fn new_low_level_string_reader(span_diagnostic: @mut SpanHandler,\n     let r = @mut StringReader {\n         span_diagnostic: span_diagnostic,\n         src: filemap.src,\n-        pos: filemap.start_pos,\n+        pos: Cell::new(filemap.start_pos),\n         last_pos: filemap.start_pos,\n         col: CharPos(0),\n         curr: initial_char,\n@@ -93,7 +94,7 @@ fn dup_string_reader(r: @mut StringReader) -> @mut StringReader {\n     @mut StringReader {\n         span_diagnostic: r.span_diagnostic,\n         src: r.src,\n-        pos: r.pos,\n+        pos: Cell::new(r.pos.get()),\n         last_pos: r.last_pos,\n         col: r.col,\n         curr: r.curr,\n@@ -239,14 +240,14 @@ fn with_str_from_to<T>(\n // EFFECT: advance the StringReader by one character. If a newline is\n // discovered, add it to the FileMap's list of line start offsets.\n pub fn bump(rdr: &mut StringReader) {\n-    rdr.last_pos = rdr.pos;\n-    let current_byte_offset = byte_offset(rdr, rdr.pos).to_uint();\n+    rdr.last_pos = rdr.pos.get();\n+    let current_byte_offset = byte_offset(rdr, rdr.pos.get()).to_uint();\n     if current_byte_offset < (rdr.src).len() {\n         assert!(rdr.curr != unsafe { transmute(-1u32) }); // FIXME: #8971: unsound\n         let last_char = rdr.curr;\n         let next = rdr.src.char_range_at(current_byte_offset);\n         let byte_offset_diff = next.next - current_byte_offset;\n-        rdr.pos = rdr.pos + Pos::from_uint(byte_offset_diff);\n+        rdr.pos.set(rdr.pos.get() + Pos::from_uint(byte_offset_diff));\n         rdr.curr = next.ch;\n         rdr.col = rdr.col + CharPos(1u);\n         if last_char == '\\n' {\n@@ -266,7 +267,7 @@ pub fn is_eof(rdr: @mut StringReader) -> bool {\n     rdr.curr == unsafe { transmute(-1u32) } // FIXME: #8971: unsound\n }\n pub fn nextch(rdr: @mut StringReader) -> char {\n-    let offset = byte_offset(rdr, rdr.pos).to_uint();\n+    let offset = byte_offset(rdr, rdr.pos.get()).to_uint();\n     if offset < (rdr.src).len() {\n         return rdr.src.char_at(offset);\n     } else { return unsafe { transmute(-1u32) }; } // FIXME: #8971: unsound\n@@ -318,7 +319,7 @@ fn consume_any_line_comment(rdr: @mut StringReader)\n             bump(rdr);\n             // line comments starting with \"///\" or \"//!\" are doc-comments\n             if rdr.curr == '/' || rdr.curr == '!' {\n-                let start_bpos = rdr.pos - BytePos(3);\n+                let start_bpos = rdr.pos.get() - BytePos(3);\n                 while rdr.curr != '\\n' && !is_eof(rdr) {\n                     bump(rdr);\n                 }\n@@ -327,7 +328,7 @@ fn consume_any_line_comment(rdr: @mut StringReader)\n                     if !is_line_non_doc_comment(string) {\n                         Some(TokenAndSpan{\n                             tok: token::DOC_COMMENT(str_to_ident(string)),\n-                            sp: codemap::mk_sp(start_bpos, rdr.pos)\n+                            sp: codemap::mk_sp(start_bpos, rdr.pos.get())\n                         })\n                     } else {\n                         None\n@@ -371,7 +372,7 @@ fn consume_block_comment(rdr: @mut StringReader)\n                       -> Option<TokenAndSpan> {\n     // block comments starting with \"/**\" or \"/*!\" are doc-comments\n     let is_doc_comment = rdr.curr == '*' || rdr.curr == '!';\n-    let start_bpos = rdr.pos - BytePos(if is_doc_comment {3} else {2});\n+    let start_bpos = rdr.pos.get() - BytePos(if is_doc_comment {3} else {2});\n \n     let mut level: int = 1;\n     while level > 0 {\n@@ -401,7 +402,7 @@ fn consume_block_comment(rdr: @mut StringReader)\n             if !is_block_non_doc_comment(string) {\n                 Some(TokenAndSpan{\n                         tok: token::DOC_COMMENT(str_to_ident(string)),\n-                        sp: codemap::mk_sp(start_bpos, rdr.pos)\n+                        sp: codemap::mk_sp(start_bpos, rdr.pos.get())\n                     })\n             } else {\n                 None\n@@ -592,7 +593,7 @@ fn scan_numeric_escape(rdr: @mut StringReader, n_hex_digits: uint) -> char {\n     while i != 0u {\n         let n = rdr.curr;\n         if !is_hex_digit(n) {\n-            fatal_span_char(rdr, rdr.last_pos, rdr.pos,\n+            fatal_span_char(rdr, rdr.last_pos, rdr.pos.get(),\n                             ~\"illegal character in numeric character escape\",\n                             n);\n         }\n@@ -932,7 +933,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n       '^' => { return binop(rdr, token::CARET); }\n       '%' => { return binop(rdr, token::PERCENT); }\n       c => {\n-          fatal_span_char(rdr, rdr.last_pos, rdr.pos,\n+          fatal_span_char(rdr, rdr.last_pos, rdr.pos.get(),\n                           ~\"unknown start of token\", c);\n       }\n     }"}]}