{"sha": "1447242bf98d7bf3e094d2e5d6029472cfdcc75d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NDcyNDJiZjk4ZDdiZjNlMDk0ZDJlNWQ2MDI5NDcyY2ZkY2M3NWQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-15T15:50:43Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-15T16:12:58Z"}, "message": "refactor to simplify", "tree": {"sha": "3889bdaa2ea7c63648fa3efc4eb2189f964d4c62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3889bdaa2ea7c63648fa3efc4eb2189f964d4c62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1447242bf98d7bf3e094d2e5d6029472cfdcc75d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1447242bf98d7bf3e094d2e5d6029472cfdcc75d", "html_url": "https://github.com/rust-lang/rust/commit/1447242bf98d7bf3e094d2e5d6029472cfdcc75d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1447242bf98d7bf3e094d2e5d6029472cfdcc75d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f676f2265b6473c4e84f38c0384ed1f6e3211255", "url": "https://api.github.com/repos/rust-lang/rust/commits/f676f2265b6473c4e84f38c0384ed1f6e3211255", "html_url": "https://github.com/rust-lang/rust/commit/f676f2265b6473c4e84f38c0384ed1f6e3211255"}], "stats": {"total": 82, "additions": 29, "deletions": 53}, "files": [{"sha": "a3910fd0c43dd0cde58a0de09059b2c2b94b804b", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 29, "deletions": 53, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1447242bf98d7bf3e094d2e5d6029472cfdcc75d/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1447242bf98d7bf3e094d2e5d6029472cfdcc75d/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=1447242bf98d7bf3e094d2e5d6029472cfdcc75d", "patch": "@@ -214,51 +214,21 @@ impl Permission {\n     }\n \n     /// This defines for a given permission, which other permissions it can tolerate \"above\" itself\n-    /// for which kinds of accesses.\n-    /// If true, then `other` is allowed to remain on top of `self` when `access` happens.\n-    fn compatible_with(self, access: AccessKind, other: Permission) -> bool {\n-        use self::Permission::*;\n-\n-        match (self, access, other) {\n-            // Some cases are impossible.\n-            (SharedReadOnly, _, SharedReadWrite) |\n-            (SharedReadOnly, _, Unique) =>\n-                bug!(\"There can never be a SharedReadWrite or a Unique on top of a SharedReadOnly\"),\n-            // When `other` is `SharedReadOnly`, that is NEVER compatible with\n-            // write accesses.\n-            // This makes sure read-only pointers become invalid on write accesses (ensures F2a).\n-            (_, AccessKind::Write, SharedReadOnly) =>\n-                false,\n-            // When `other` is `Unique`, that is compatible with nothing.\n-            // This makes sure unique pointers become invalid on incompatible accesses (ensures U2).\n-            (_, _, Unique) =>\n-                false,\n-            // When we are unique and this is a write/dealloc, we tolerate nothing.\n-            // This makes sure we re-assert uniqueness (\"being on top\") on write accesses.\n-            // (This is particularily important such that when a new mutable ref gets created, it gets\n-            // pushed onto the right item -- this behaves like a write and we assert uniqueness of the\n-            // pointer from which this comes, *if* it was a unique pointer.)\n-            (Unique, AccessKind::Write, _) =>\n-                false,\n-            // `SharedReadWrite` items can tolerate any other akin items for any kind of access.\n-            (SharedReadWrite, _, SharedReadWrite) =>\n-                true,\n-            // Any item can tolerate read accesses for shared items.\n-            // This includes unique items!  Reads from unique pointers do not invalidate\n-            // other pointers.\n-            (_, AccessKind::Read, SharedReadWrite) |\n-            (_, AccessKind::Read, SharedReadOnly) =>\n-                true,\n-            // That's it.\n-        }\n+    /// when it is written to.\n+    /// If true, then `other` is allowed to remain on top of `self` when a write access happens.\n+    fn write_compatible_with(self, other: Permission) -> bool {\n+        // Only writes to SharedRW can tolerate any other items above them, and they only\n+        // tolerate other SharedRW.  So, basically, searching the first write-incompatible item above X treats\n+        // consecutive SharedRW as one \"group\", and skips to the first item outside X's group.\n+        return self == Permission::SharedReadWrite && other == Permission::SharedReadWrite;\n     }\n }\n \n /// Core per-location operations: access, dealloc, reborrow.\n impl<'tcx> Stack {\n-    /// Find the item granting the given kind of access to the given tag, and where\n-    /// *the first incompatible item above it* is on the stack.\n-    fn find_granting(&self, access: AccessKind, tag: Tag) -> Option<(Permission, usize)> {\n+    /// Find the item granting the given kind of access to the given tag, and return where\n+    /// *the first write-incompatible item above it* is on the stack.\n+    fn check_granting(&self, access: AccessKind, tag: Tag) -> Option<usize> {\n         let (perm, idx) = self.borrows.iter()\n             .enumerate() // we also need to know *where* in the stack\n             .rev() // search top-to-bottom\n@@ -274,15 +244,15 @@ impl<'tcx> Stack {\n \n         let mut first_incompatible_idx = idx+1;\n         while let Some(item) = self.borrows.get(first_incompatible_idx) {\n-            if perm.compatible_with(access, item.perm) {\n+            if perm.write_compatible_with(item.perm) {\n                 // Keep this, check next.\n                 first_incompatible_idx += 1;\n             } else {\n                 // Found it!\n                 break;\n             }\n         }\n-        return Some((perm, first_incompatible_idx));\n+        return Some(first_incompatible_idx);\n     }\n \n     /// Test if a memory `access` using pointer tagged `tag` is granted.\n@@ -293,29 +263,35 @@ impl<'tcx> Stack {\n         tag: Tag,\n         global: &GlobalState,\n     ) -> EvalResult<'tcx> {\n-        // Two main steps: Find granting item, remove all incompatible items above.\n+        // Two main steps: Find granting item, remove incompatible items above.\n \n         // Step 1: Find granting item.\n-        let (granting_perm, first_incompatible_idx) = self.find_granting(access, tag)\n+        let first_incompatible_idx = self.check_granting(access, tag)\n             .ok_or_else(|| InterpError::MachineError(format!(\n                 \"no item granting {} access to tag {} found in borrow stack\",\n                 access, tag,\n             )))?;\n \n-        // Step 2: Remove everything incompatible above them.  Make sure we do not remove protected\n-        // items.\n-        // For writes, this is a simple stack. For reads, however, it is not:\n-        // in `let raw = &mut *x as *mut _; let _val = *x;`, the second statement would pop the `Unique`\n-        // from the reborrow of the first statement, and subsequently also pop the `SharedReadWrite` for `raw`.\n+        // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n+        // items.  Behavior differs for reads and writes.\n+        //\n+        // For writes, this is a simple stack, where everything starting with the first incompatible item\n+        // gets removed. This makes sure read-only and unique pointers become invalid on write accesses\n+        // (ensures F2a, and ensures U2 for write accesses).\n+        //\n+        // For reads, however, we just filter away the Unique items, which is sufficient to ensure U2 for read\n+        // accesses. The reason is that in `let raw = &mut *x as *mut _; let _val = *x;`, the second statement\n+        // would pop the `Unique` from the reborrow of the first statement, and subsequently also pop the\n+        // `SharedReadWrite` for `raw`.\n         // This pattern occurs a lot in the standard library: create a raw pointer, then also create a shared\n         // reference and use that.\n         {\n             // Implemented with indices because there does not seem to be a nice iterator and range-based\n             // API for this.\n             let mut cur = first_incompatible_idx;\n             while let Some(item) = self.borrows.get(cur) {\n-                // If this is a read, we double-check if we really want to kill this.\n-                if access == AccessKind::Read && granting_perm.compatible_with(access, item.perm) {\n+                // If this is a read, only remove Unique items!\n+                if access == AccessKind::Read && item.perm != Permission::Unique {\n                     // Keep this, check next.\n                     cur += 1;\n                 } else {\n@@ -346,7 +322,7 @@ impl<'tcx> Stack {\n         global: &GlobalState,\n     ) -> EvalResult<'tcx> {\n         // Step 1: Find granting item.\n-        self.find_granting(AccessKind::Write, tag)\n+        self.check_granting(AccessKind::Write, tag)\n             .ok_or_else(|| InterpError::MachineError(format!(\n                 \"no item granting write access for deallocation to tag {} found in borrow stack\",\n                 tag,\n@@ -403,7 +379,7 @@ impl<'tcx> Stack {\n         };\n         // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n         // We use that to determine where to put the new item.\n-        let (_, first_incompatible_idx) = self.find_granting(access, derived_from)\n+        let first_incompatible_idx = self.check_granting(access, derived_from)\n             .ok_or_else(|| InterpError::MachineError(format!(\n                 \"no item to reborrow for {:?} from tag {} found in borrow stack\", new.perm, derived_from,\n             )))?;"}]}