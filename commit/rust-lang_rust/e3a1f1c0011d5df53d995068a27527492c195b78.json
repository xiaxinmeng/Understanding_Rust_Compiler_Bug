{"sha": "e3a1f1c0011d5df53d995068a27527492c195b78", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzYTFmMWMwMDExZDVkZjUzZDk5NTA2OGEyNzUyNzQ5MmMxOTViNzg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-01T10:01:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-01T10:01:16Z"}, "message": "Merge #3765\n\n3765: Adds sort for RecordLit comparison in SSR r=edwin0cheng a=mikhail-m1\n\nan item from #3186 \n\nCo-authored-by: Mikhail Modin <mikhailm1@gmail.com>", "tree": {"sha": "ab1cbe056a4d3a4ee56aeb0d233dcb7ef2ffba35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab1cbe056a4d3a4ee56aeb0d233dcb7ef2ffba35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3a1f1c0011d5df53d995068a27527492c195b78", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJehGZsCRBK7hj4Ov3rIwAAdHIIAJphMpoUv+qFfZH7FP1r3L67\nMHUh/fYtO6SRnPrwS/DzKhH/q/7jqKcUTmXCrJ5m9OX3puVNifwZa3GFZY/L7gYK\nsJurAsjIWiwSwHFzWuXE7qgh1WDeqaWx3tHyVfAYHKQrG9+vWW4TtazzVzZ+Mj/A\n0DPYWAjDVH4Pdc+iXjdzeu4pIzn2NL9/CCurrLo2/fK2KaMfrTHMi9l8D97TDpaJ\n1kKVTWgPAFCOodSrKZ4MpMRbhnzLJcns9R2shOozIPtqaaUV8r3vhYjnBKlQf0R4\n+6D+ydEB0+Wd6p1lGuRN2EqO5WHJOqJxApv+YUN6nrYec/4lvmB67i3xo4B6Mpo=\n=fkQE\n-----END PGP SIGNATURE-----\n", "payload": "tree ab1cbe056a4d3a4ee56aeb0d233dcb7ef2ffba35\nparent 8cce752bcb83c86f300c9a8e830dd7d411f6bc48\nparent 47e8f3c93ba16b06ea2f62595b42659664a2f960\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1585735276 +0000\ncommitter GitHub <noreply@github.com> 1585735276 +0000\n\nMerge #3765\n\n3765: Adds sort for RecordLit comparison in SSR r=edwin0cheng a=mikhail-m1\n\nan item from #3186 \n\nCo-authored-by: Mikhail Modin <mikhailm1@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3a1f1c0011d5df53d995068a27527492c195b78", "html_url": "https://github.com/rust-lang/rust/commit/e3a1f1c0011d5df53d995068a27527492c195b78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3a1f1c0011d5df53d995068a27527492c195b78/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cce752bcb83c86f300c9a8e830dd7d411f6bc48", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cce752bcb83c86f300c9a8e830dd7d411f6bc48", "html_url": "https://github.com/rust-lang/rust/commit/8cce752bcb83c86f300c9a8e830dd7d411f6bc48"}, {"sha": "47e8f3c93ba16b06ea2f62595b42659664a2f960", "url": "https://api.github.com/repos/rust-lang/rust/commits/47e8f3c93ba16b06ea2f62595b42659664a2f960", "html_url": "https://github.com/rust-lang/rust/commit/47e8f3c93ba16b06ea2f62595b42659664a2f960"}], "stats": {"total": 116, "additions": 90, "deletions": 26}, "files": [{"sha": "1abb891c17486ce05d4ad12e8b19c34fed0f47a1", "filename": "crates/ra_ide/src/ssr.rs", "status": "modified", "additions": 90, "deletions": 26, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/e3a1f1c0011d5df53d995068a27527492c195b78/crates%2Fra_ide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3a1f1c0011d5df53d995068a27527492c195b78/crates%2Fra_ide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fssr.rs?ref=e3a1f1c0011d5df53d995068a27527492c195b78", "patch": "@@ -5,7 +5,7 @@ use ra_db::{SourceDatabase, SourceDatabaseExt};\n use ra_ide_db::symbol_index::SymbolsDatabase;\n use ra_ide_db::RootDatabase;\n use ra_syntax::ast::make::try_expr_from_text;\n-use ra_syntax::ast::{AstToken, Comment};\n+use ra_syntax::ast::{AstToken, Comment, RecordField, RecordLit};\n use ra_syntax::{AstNode, SyntaxElement, SyntaxNode};\n use ra_text_edit::{TextEdit, TextEditBuilder};\n use rustc_hash::FxHashMap;\n@@ -186,47 +186,102 @@ fn create_name<'a>(name: &str, vars: &'a mut Vec<Var>) -> Result<&'a str, SsrErr\n }\n \n fn find(pattern: &SsrPattern, code: &SyntaxNode) -> SsrMatches {\n+    fn check_record_lit(\n+        pattern: RecordLit,\n+        code: RecordLit,\n+        placeholders: &[Var],\n+        match_: Match,\n+    ) -> Option<Match> {\n+        let match_ = check_opt_nodes(pattern.path(), code.path(), placeholders, match_)?;\n+\n+        let mut pattern_fields =\n+            pattern.record_field_list().map(|x| x.fields().collect()).unwrap_or(vec![]);\n+        let mut code_fields =\n+            code.record_field_list().map(|x| x.fields().collect()).unwrap_or(vec![]);\n+\n+        if pattern_fields.len() != code_fields.len() {\n+            return None;\n+        }\n+\n+        let by_name = |a: &RecordField, b: &RecordField| {\n+            a.name_ref()\n+                .map(|x| x.syntax().text().to_string())\n+                .cmp(&b.name_ref().map(|x| x.syntax().text().to_string()))\n+        };\n+        pattern_fields.sort_by(by_name);\n+        code_fields.sort_by(by_name);\n+\n+        pattern_fields.into_iter().zip(code_fields.into_iter()).fold(\n+            Some(match_),\n+            |accum, (a, b)| {\n+                accum.and_then(|match_| check_opt_nodes(Some(a), Some(b), placeholders, match_))\n+            },\n+        )\n+    }\n+\n+    fn check_opt_nodes(\n+        pattern: Option<impl AstNode>,\n+        code: Option<impl AstNode>,\n+        placeholders: &[Var],\n+        match_: Match,\n+    ) -> Option<Match> {\n+        match (pattern, code) {\n+            (Some(pattern), Some(code)) => check(\n+                &SyntaxElement::from(pattern.syntax().clone()),\n+                &SyntaxElement::from(code.syntax().clone()),\n+                placeholders,\n+                match_,\n+            ),\n+            (None, None) => Some(match_),\n+            _ => None,\n+        }\n+    }\n+\n     fn check(\n         pattern: &SyntaxElement,\n         code: &SyntaxElement,\n         placeholders: &[Var],\n         mut match_: Match,\n     ) -> Option<Match> {\n-        match (pattern, code) {\n-            (SyntaxElement::Token(ref pattern), SyntaxElement::Token(ref code)) => {\n+        match (&pattern, &code) {\n+            (SyntaxElement::Token(pattern), SyntaxElement::Token(code)) => {\n                 if pattern.text() == code.text() {\n                     Some(match_)\n                 } else {\n                     None\n                 }\n             }\n-            (SyntaxElement::Node(ref pattern), SyntaxElement::Node(ref code)) => {\n+            (SyntaxElement::Node(pattern), SyntaxElement::Node(code)) => {\n                 if placeholders.iter().any(|n| n.0.as_str() == pattern.text()) {\n                     match_.binding.insert(Var(pattern.text().to_string()), code.clone());\n                     Some(match_)\n                 } else {\n-                    let mut pattern_children = pattern\n-                        .children_with_tokens()\n-                        .filter(|element| !element.kind().is_trivia());\n-                    let mut code_children =\n-                        code.children_with_tokens().filter(|element| !element.kind().is_trivia());\n-                    let new_ignored_comments = code.children_with_tokens().filter_map(|element| {\n-                        element.as_token().and_then(|token| Comment::cast(token.clone()))\n-                    });\n-                    match_.ignored_comments.extend(new_ignored_comments);\n-                    let match_from_children = pattern_children\n-                        .by_ref()\n-                        .zip(code_children.by_ref())\n-                        .fold(Some(match_), |accum, (a, b)| {\n-                            accum.and_then(|match_| check(&a, &b, placeholders, match_))\n-                        });\n-                    match_from_children.and_then(|match_| {\n-                        if pattern_children.count() == 0 && code_children.count() == 0 {\n-                            Some(match_)\n-                        } else {\n-                            None\n-                        }\n-                    })\n+                    if let (Some(pattern), Some(code)) =\n+                        (RecordLit::cast(pattern.clone()), RecordLit::cast(code.clone()))\n+                    {\n+                        check_record_lit(pattern, code, placeholders, match_)\n+                    } else {\n+                        let mut pattern_children = pattern\n+                            .children_with_tokens()\n+                            .filter(|element| !element.kind().is_trivia());\n+                        let mut code_children = code\n+                            .children_with_tokens()\n+                            .filter(|element| !element.kind().is_trivia());\n+                        let new_ignored_comments =\n+                            code.children_with_tokens().filter_map(|element| {\n+                                element.as_token().and_then(|token| Comment::cast(token.clone()))\n+                            });\n+                        match_.ignored_comments.extend(new_ignored_comments);\n+                        pattern_children\n+                            .by_ref()\n+                            .zip(code_children.by_ref())\n+                            .fold(Some(match_), |accum, (a, b)| {\n+                                accum.and_then(|match_| check(&a, &b, placeholders, match_))\n+                            })\n+                            .filter(|_| {\n+                                pattern_children.next().is_none() && code_children.next().is_none()\n+                            })\n+                    }\n                 }\n             }\n             _ => None,\n@@ -434,4 +489,13 @@ mod tests {\n             \"fn main() { bar(5)/* using 5 */ }\",\n         )\n     }\n+\n+    #[test]\n+    fn ssr_struct_lit() {\n+        assert_ssr_transform(\n+            \"foo{a: $a:expr, b: $b:expr} ==>> foo::new($a, $b)\",\n+            \"fn main() { foo{b:2, a:1} }\",\n+            \"fn main() { foo::new(1, 2) }\",\n+        )\n+    }\n }"}]}