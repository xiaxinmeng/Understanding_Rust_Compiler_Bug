{"sha": "6132f7f6660c29fe3fc02422b7047246033db84f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxMzJmN2Y2NjYwYzI5ZmUzZmMwMjQyMmI3MDQ3MjQ2MDMzZGI4NGY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-30T19:30:21Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-03T17:32:34Z"}, "message": "rustdoc: Remove io_error usage", "tree": {"sha": "f2f69cf1a50f1208653d94297700a779ee913caa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2f69cf1a50f1208653d94297700a779ee913caa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6132f7f6660c29fe3fc02422b7047246033db84f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6132f7f6660c29fe3fc02422b7047246033db84f", "html_url": "https://github.com/rust-lang/rust/commit/6132f7f6660c29fe3fc02422b7047246033db84f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6132f7f6660c29fe3fc02422b7047246033db84f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0f0a2f67f6bb66626bb3b7624e7bdb0198a1c47", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0f0a2f67f6bb66626bb3b7624e7bdb0198a1c47", "html_url": "https://github.com/rust-lang/rust/commit/e0f0a2f67f6bb66626bb3b7624e7bdb0198a1c47"}], "stats": {"total": 911, "additions": 495, "deletions": 416}, "files": [{"sha": "82850dffa2b14db89aa6a487f1c53a3b895871a0", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6132f7f6660c29fe3fc02422b7047246033db84f/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6132f7f6660c29fe3fc02422b7047246033db84f/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=6132f7f6660c29fe3fc02422b7047246033db84f", "patch": "@@ -20,7 +20,7 @@ use std::fmt;\n pub struct Escape<'a>(&'a str);\n \n impl<'a> fmt::Show for Escape<'a> {\n-    fn fmt(s: &Escape<'a>, fmt: &mut fmt::Formatter) {\n+    fn fmt(s: &Escape<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n         // Because the internet is always right, turns out there's not that many\n         // characters to escape: http://stackoverflow.com/questions/7381974\n         let Escape(s) = *s;\n@@ -29,7 +29,7 @@ impl<'a> fmt::Show for Escape<'a> {\n         for (i, ch) in s.bytes().enumerate() {\n             match ch as char {\n                 '<' | '>' | '&' | '\\'' | '\"' => {\n-                    fmt.buf.write(pile_o_bits.slice(last, i).as_bytes());\n+                    if_ok!(fmt.buf.write(pile_o_bits.slice(last, i).as_bytes()));\n                     let s = match ch as char {\n                         '>' => \"&gt;\",\n                         '<' => \"&lt;\",\n@@ -38,15 +38,16 @@ impl<'a> fmt::Show for Escape<'a> {\n                         '\"' => \"&quot;\",\n                         _ => unreachable!()\n                     };\n-                    fmt.buf.write(s.as_bytes());\n+                    if_ok!(fmt.buf.write(s.as_bytes()));\n                     last = i + 1;\n                 }\n                 _ => {}\n             }\n         }\n \n         if last < s.len() {\n-            fmt.buf.write(pile_o_bits.slice_from(last).as_bytes());\n+            if_ok!(fmt.buf.write(pile_o_bits.slice_from(last).as_bytes()));\n         }\n+        Ok(())\n     }\n }"}, {"sha": "687f391c07fcb36c1cbc9696621b170f6439342c", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 124, "deletions": 88, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/6132f7f6660c29fe3fc02422b7047246033db84f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6132f7f6660c29fe3fc02422b7047246033db84f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=6132f7f6660c29fe3fc02422b7047246033db84f", "patch": "@@ -48,99 +48,120 @@ impl PuritySpace {\n }\n \n impl fmt::Show for clean::Generics {\n-    fn fmt(g: &clean::Generics, f: &mut fmt::Formatter) {\n-        if g.lifetimes.len() == 0 && g.type_params.len() == 0 { return }\n-        f.buf.write(\"&lt;\".as_bytes());\n+impl fmt::Default for clean::Generics {\n+    fn fmt(g: &clean::Generics, f: &mut fmt::Formatter) -> fmt::Result {\n+        if g.lifetimes.len() == 0 && g.type_params.len() == 0 { return Ok(()) }\n+        if_ok!(f.buf.write(\"&lt;\".as_bytes()));\n \n         for (i, life) in g.lifetimes.iter().enumerate() {\n-            if i > 0 { f.buf.write(\", \".as_bytes()); }\n-            write!(f.buf, \"{}\", *life);\n+            if i > 0 {\n+                if_ok!(f.buf.write(\", \".as_bytes()));\n+            }\n+            if_ok!(write!(f.buf, \"{}\", *life));\n         }\n \n         if g.type_params.len() > 0 {\n-            if g.lifetimes.len() > 0 { f.buf.write(\", \".as_bytes()); }\n+            if g.lifetimes.len() > 0 {\n+                if_ok!(f.buf.write(\", \".as_bytes()));\n+            }\n \n             for (i, tp) in g.type_params.iter().enumerate() {\n-                if i > 0 { f.buf.write(\", \".as_bytes()) }\n-                f.buf.write(tp.name.as_bytes());\n+                if i > 0 {\n+                    if_ok!(f.buf.write(\", \".as_bytes()))\n+                }\n+                if_ok!(f.buf.write(tp.name.as_bytes()));\n \n                 if tp.bounds.len() > 0 {\n-                    f.buf.write(\": \".as_bytes());\n+                    if_ok!(f.buf.write(\": \".as_bytes()));\n                     for (i, bound) in tp.bounds.iter().enumerate() {\n-                        if i > 0 { f.buf.write(\" + \".as_bytes()); }\n-                        write!(f.buf, \"{}\", *bound);\n+                        if i > 0 {\n+                            if_ok!(f.buf.write(\" + \".as_bytes()));\n+                        }\n+                        if_ok!(write!(f.buf, \"{}\", *bound));\n                     }\n                 }\n             }\n         }\n-        f.buf.write(\"&gt;\".as_bytes());\n+        if_ok!(f.buf.write(\"&gt;\".as_bytes()));\n+        Ok(())\n     }\n }\n \n impl fmt::Show for clean::Lifetime {\n-    fn fmt(l: &clean::Lifetime, f: &mut fmt::Formatter) {\n-        f.buf.write(\"'\".as_bytes());\n-        f.buf.write(l.get_ref().as_bytes());\n+    fn fmt(l: &clean::Lifetime, f: &mut fmt::Formatter) -> fmt::Result {\n+        if_ok!(f.buf.write(\"'\".as_bytes()));\n+        if_ok!(f.buf.write(l.get_ref().as_bytes()));\n+        Ok(())\n     }\n }\n \n impl fmt::Show for clean::TyParamBound {\n-    fn fmt(bound: &clean::TyParamBound, f: &mut fmt::Formatter) {\n+    fn fmt(bound: &clean::TyParamBound, f: &mut fmt::Formatter) -> fmt::Result {\n         match *bound {\n             clean::RegionBound => {\n                 f.buf.write(\"'static\".as_bytes())\n             }\n             clean::TraitBound(ref ty) => {\n-                write!(f.buf, \"{}\", *ty);\n+                write!(f.buf, \"{}\", *ty)\n             }\n         }\n     }\n }\n \n impl fmt::Show for clean::Path {\n-    fn fmt(path: &clean::Path, f: &mut fmt::Formatter) {\n-        if path.global { f.buf.write(\"::\".as_bytes()) }\n+    fn fmt(path: &clean::Path, f: &mut fmt::Formatter) -> fmt::Result {\n+        if path.global {\n+            if_ok!(f.buf.write(\"::\".as_bytes()))\n+        }\n         for (i, seg) in path.segments.iter().enumerate() {\n-            if i > 0 { f.buf.write(\"::\".as_bytes()) }\n-            f.buf.write(seg.name.as_bytes());\n+            if i > 0 {\n+                if_ok!(f.buf.write(\"::\".as_bytes()))\n+            }\n+            if_ok!(f.buf.write(seg.name.as_bytes()));\n \n             if seg.lifetimes.len() > 0 || seg.types.len() > 0 {\n-                f.buf.write(\"&lt;\".as_bytes());\n+                if_ok!(f.buf.write(\"&lt;\".as_bytes()));\n                 let mut comma = false;\n                 for lifetime in seg.lifetimes.iter() {\n-                    if comma { f.buf.write(\", \".as_bytes()); }\n+                    if comma {\n+                        if_ok!(f.buf.write(\", \".as_bytes()));\n+                    }\n                     comma = true;\n-                    write!(f.buf, \"{}\", *lifetime);\n+                    if_ok!(write!(f.buf, \"{}\", *lifetime));\n                 }\n                 for ty in seg.types.iter() {\n-                    if comma { f.buf.write(\", \".as_bytes()); }\n+                    if comma {\n+                        if_ok!(f.buf.write(\", \".as_bytes()));\n+                    }\n                     comma = true;\n-                    write!(f.buf, \"{}\", *ty);\n+                    if_ok!(write!(f.buf, \"{}\", *ty));\n                 }\n-                f.buf.write(\"&gt;\".as_bytes());\n+                if_ok!(f.buf.write(\"&gt;\".as_bytes()));\n             }\n         }\n+        Ok(())\n     }\n }\n \n /// Used when rendering a `ResolvedPath` structure. This invokes the `path`\n /// rendering function with the necessary arguments for linking to a local path.\n fn resolved_path(w: &mut io::Writer, id: ast::NodeId, p: &clean::Path,\n-                 print_all: bool) {\n+                 print_all: bool) -> fmt::Result {\n     path(w, p, print_all,\n         |_cache, loc| { Some(\"../\".repeat(loc.len())) },\n         |cache| {\n             match cache.paths.find(&id) {\n                 None => None,\n                 Some(&(ref fqp, shortty)) => Some((fqp.clone(), shortty))\n             }\n-        });\n+        })\n }\n \n /// Used when rendering an `ExternalPath` structure. Like `resolved_path` this\n /// will invoke `path` with proper linking-style arguments.\n fn external_path(w: &mut io::Writer, p: &clean::Path, print_all: bool,\n-                 fqn: &[~str], kind: clean::TypeKind, crate: ast::CrateNum) {\n+                 fqn: &[~str], kind: clean::TypeKind,\n+                 crate: ast::CrateNum) -> fmt::Result {\n     path(w, p, print_all,\n         |cache, loc| {\n             match *cache.extern_locations.get(&crate) {\n@@ -161,7 +182,9 @@ fn external_path(w: &mut io::Writer, p: &clean::Path, print_all: bool,\n \n fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n         root: |&render::Cache, &[~str]| -> Option<~str>,\n-        info: |&render::Cache| -> Option<(~[~str], &'static str)>) {\n+        info: |&render::Cache| -> Option<(~[~str], &'static str)>)\n+    -> fmt::Result\n+{\n     // The generics will get written to both the title and link\n     let mut generics = ~\"\";\n     let last = path.segments.last().unwrap();\n@@ -200,20 +223,20 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n                         let mut root = root;\n                         for seg in path.segments.slice_to(amt).iter() {\n                             if \"super\" == seg.name || \"self\" == seg.name {\n-                                write!(w, \"{}::\", seg.name);\n+                                if_ok!(write!(w, \"{}::\", seg.name));\n                             } else {\n                                 root.push_str(seg.name);\n                                 root.push_str(\"/\");\n-                                write!(w, \"<a class='mod'\n-                                              href='{}index.html'>{}</a>::\",\n-                                       root,\n-                                       seg.name);\n+                                if_ok!(write!(w, \"<a class='mod'\n+                                                    href='{}index.html'>{}</a>::\",\n+                                              root,\n+                                              seg.name));\n                             }\n                         }\n                     }\n                     None => {\n                         for seg in path.segments.slice_to(amt).iter() {\n-                            write!(w, \"{}::\", seg.name);\n+                            if_ok!(write!(w, \"{}::\", seg.name));\n                         }\n                     }\n                 }\n@@ -241,51 +264,57 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n                         }\n                     }\n \n-                    write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>\",\n-                           shortty, url, fqp.connect(\"::\"), last.name);\n+                    if_ok!(write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>\",\n+                                  shortty, url, fqp.connect(\"::\"), last.name));\n                 }\n \n                 _ => {\n-                    write!(w, \"{}\", last.name);\n+                    if_ok!(write!(w, \"{}\", last.name));\n                 }\n             }\n-            write!(w, \"{}\", generics);\n+            if_ok!(write!(w, \"{}\", generics));\n+            Ok(())\n         })\n     })\n }\n \n /// Helper to render type parameters\n-fn typarams(w: &mut io::Writer, typarams: &Option<~[clean::TyParamBound]>) {\n+fn typarams(w: &mut io::Writer,\n+            typarams: &Option<~[clean::TyParamBound]>) -> fmt::Result {\n     match *typarams {\n         Some(ref params) => {\n-            write!(w, \"&lt;\");\n+            if_ok!(write!(w, \"&lt;\"));\n             for (i, param) in params.iter().enumerate() {\n-                if i > 0 { write!(w, \", \"); }\n-                write!(w, \"{}\", *param);\n+                if i > 0 {\n+                    if_ok!(write!(w, \", \"));\n+                }\n+                if_ok!(write!(w, \"{}\", *param));\n             }\n-            write!(w, \"&gt;\");\n+            if_ok!(write!(w, \"&gt;\"));\n+            Ok(())\n         }\n-        None => {}\n+        None => Ok(())\n     }\n }\n \n impl fmt::Show for clean::Type {\n-    fn fmt(g: &clean::Type, f: &mut fmt::Formatter) {\n+    fn fmt(g: &clean::Type, f: &mut fmt::Formatter) -> fmt::Result {\n         match *g {\n             clean::TyParamBinder(id) | clean::Generic(id) => {\n                 local_data::get(cache_key, |cache| {\n                     let m = cache.unwrap().get();\n-                    f.buf.write(m.typarams.get(&id).as_bytes());\n+                    f.buf.write(m.typarams.get(&id).as_bytes())\n                 })\n             }\n             clean::ResolvedPath{id, typarams: ref tp, path: ref path} => {\n-                resolved_path(f.buf, id, path, false);\n-                typarams(f.buf, tp);\n+                if_ok!(resolved_path(f.buf, id, path, false));\n+                typarams(f.buf, tp)\n             }\n             clean::ExternalPath{path: ref path, typarams: ref tp,\n                                 fqn: ref fqn, kind, crate} => {\n-                external_path(f.buf, path, false, fqn.as_slice(), kind, crate);\n-                typarams(f.buf, tp);\n+                if_ok!(external_path(f.buf, path, false, fqn.as_slice(), kind,\n+                                     crate))\n+                typarams(f.buf, tp)\n             }\n             clean::Self(..) => f.buf.write(\"Self\".as_bytes()),\n             clean::Primitive(prim) => {\n@@ -306,7 +335,7 @@ impl fmt::Show for clean::Type {\n                     ast::TyBool => \"bool\",\n                     ast::TyChar => \"char\",\n                 };\n-                f.buf.write(s.as_bytes());\n+                f.buf.write(s.as_bytes())\n             }\n             clean::Closure(ref decl) => {\n                 let region = match decl.region {\n@@ -322,7 +351,7 @@ impl fmt::Show for clean::Type {\n                            ast::ManagedSigil => format!(\"@{}fn({})\", region, decl.decl.inputs),\n                        },\n                        arrow = match decl.decl.output { clean::Unit => \"no\", _ => \"yes\" },\n-                       ret = decl.decl.output);\n+                       ret = decl.decl.output)\n                 // FIXME: where are bounds and lifetimes printed?!\n             }\n             clean::BareFunction(ref decl) => {\n@@ -333,19 +362,21 @@ impl fmt::Show for clean::Type {\n                            ref s => \" \" + *s + \" \",\n                        },\n                        decl.generics,\n-                       decl.decl);\n+                       decl.decl)\n             }\n             clean::Tuple(ref typs) => {\n-                f.buf.write(\"(\".as_bytes());\n+                if_ok!(f.buf.write(\"(\".as_bytes()));\n                 for (i, typ) in typs.iter().enumerate() {\n-                    if i > 0 { f.buf.write(\", \".as_bytes()) }\n-                    write!(f.buf, \"{}\", *typ);\n+                    if i > 0 {\n+                        if_ok!(f.buf.write(\", \".as_bytes()))\n+                    }\n+                    if_ok!(write!(f.buf, \"{}\", *typ));\n                 }\n-                f.buf.write(\")\".as_bytes());\n+                f.buf.write(\")\".as_bytes())\n             }\n             clean::Vector(ref t) => write!(f.buf, \"[{}]\", **t),\n             clean::FixedVector(ref t, ref s) => {\n-                write!(f.buf, \"[{}, ..{}]\", **t, *s);\n+                write!(f.buf, \"[{}, ..{}]\", **t, *s)\n             }\n             clean::String => f.buf.write(\"str\".as_bytes()),\n             clean::Bool => f.buf.write(\"bool\".as_bytes()),\n@@ -368,23 +399,23 @@ impl fmt::Show for clean::Type {\n                            clean::Mutable => \"mut \",\n                            clean::Immutable => \"\",\n                        },\n-                       **ty);\n+                       **ty)\n             }\n         }\n     }\n }\n \n impl fmt::Show for clean::FnDecl {\n-    fn fmt(d: &clean::FnDecl, f: &mut fmt::Formatter) {\n+    fn fmt(d: &clean::FnDecl, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f.buf, \"({args}){arrow, select, yes{ -&gt; {ret}} other{}}\",\n                args = d.inputs,\n                arrow = match d.output { clean::Unit => \"no\", _ => \"yes\" },\n-               ret = d.output);\n+               ret = d.output)\n     }\n }\n \n impl fmt::Show for ~[clean::Argument] {\n-    fn fmt(inputs: &~[clean::Argument], f: &mut fmt::Formatter) {\n+    fn fmt(inputs: &~[clean::Argument], f: &mut fmt::Formatter) -> fmt::Result {\n         let mut args = ~\"\";\n         for (i, input) in inputs.iter().enumerate() {\n             if i > 0 { args.push_str(\", \"); }\n@@ -393,12 +424,12 @@ impl fmt::Show for ~[clean::Argument] {\n             }\n             args.push_str(format!(\"{}\", input.type_));\n         }\n-        f.buf.write(args.as_bytes());\n+        f.buf.write(args.as_bytes())\n     }\n }\n \n impl<'a> fmt::Show for Method<'a> {\n-    fn fmt(m: &Method<'a>, f: &mut fmt::Formatter) {\n+    fn fmt(m: &Method<'a>, f: &mut fmt::Formatter) -> fmt::Result {\n         let Method(selfty, d) = *m;\n         let mut args = ~\"\";\n         match *selfty {\n@@ -429,74 +460,79 @@ impl<'a> fmt::Show for Method<'a> {\n         write!(f.buf, \"({args}){arrow, select, yes{ -&gt; {ret}} other{}}\",\n                args = args,\n                arrow = match d.output { clean::Unit => \"no\", _ => \"yes\" },\n-               ret = d.output);\n+               ret = d.output)\n     }\n }\n \n impl fmt::Show for VisSpace {\n-    fn fmt(v: &VisSpace, f: &mut fmt::Formatter) {\n+    fn fmt(v: &VisSpace, f: &mut fmt::Formatter) -> fmt::Result {\n         match v.get() {\n-            Some(ast::Public) => { write!(f.buf, \"pub \"); }\n-            Some(ast::Private) => { write!(f.buf, \"priv \"); }\n-            Some(ast::Inherited) | None => {}\n+            Some(ast::Public) => write!(f.buf, \"pub \"),\n+            Some(ast::Private) => write!(f.buf, \"priv \"),\n+            Some(ast::Inherited) | None => Ok(())\n         }\n     }\n }\n \n impl fmt::Show for PuritySpace {\n-    fn fmt(p: &PuritySpace, f: &mut fmt::Formatter) {\n+    fn fmt(p: &PuritySpace, f: &mut fmt::Formatter) -> fmt::Result {\n         match p.get() {\n             ast::UnsafeFn => write!(f.buf, \"unsafe \"),\n             ast::ExternFn => write!(f.buf, \"extern \"),\n-            ast::ImpureFn => {}\n+            ast::ImpureFn => Ok(())\n         }\n     }\n }\n \n impl fmt::Show for clean::ViewPath {\n-    fn fmt(v: &clean::ViewPath, f: &mut fmt::Formatter) {\n+    fn fmt(v: &clean::ViewPath, f: &mut fmt::Formatter) -> fmt::Result {\n         match *v {\n             clean::SimpleImport(ref name, ref src) => {\n                 if *name == src.path.segments.last().unwrap().name {\n-                    write!(f.buf, \"use {};\", *src);\n+                    write!(f.buf, \"use {};\", *src)\n                 } else {\n-                    write!(f.buf, \"use {} = {};\", *name, *src);\n+                    write!(f.buf, \"use {} = {};\", *name, *src)\n                 }\n             }\n             clean::GlobImport(ref src) => {\n-                write!(f.buf, \"use {}::*;\", *src);\n+                write!(f.buf, \"use {}::*;\", *src)\n             }\n             clean::ImportList(ref src, ref names) => {\n-                write!(f.buf, \"use {}::\\\\{\", *src);\n+                if_ok!(write!(f.buf, \"use {}::\\\\{\", *src));\n                 for (i, n) in names.iter().enumerate() {\n-                    if i > 0 { write!(f.buf, \", \"); }\n-                    write!(f.buf, \"{}\", *n);\n+                    if i > 0 {\n+                        if_ok!(write!(f.buf, \", \"));\n+                    }\n+                    if_ok!(write!(f.buf, \"{}\", *n));\n                 }\n-                write!(f.buf, \"\\\\};\");\n+                write!(f.buf, \"\\\\};\")\n             }\n         }\n     }\n }\n \n impl fmt::Show for clean::ImportSource {\n-    fn fmt(v: &clean::ImportSource, f: &mut fmt::Formatter) {\n+    fn fmt(v: &clean::ImportSource, f: &mut fmt::Formatter) -> fmt::Result {\n         match v.did {\n             // FIXME: shouldn't be restricted to just local imports\n             Some(did) if ast_util::is_local(did) => {\n-                resolved_path(f.buf, did.node, &v.path, true);\n+                resolved_path(f.buf, did.node, &v.path, true)\n             }\n             _ => {\n                 for (i, seg) in v.path.segments.iter().enumerate() {\n-                    if i > 0 { write!(f.buf, \"::\") }\n-                    write!(f.buf, \"{}\", seg.name);\n+                    if i > 0 {\n+                        if_ok!(write!(f.buf, \"::\"))\n+                    }\n+                    if_ok!(write!(f.buf, \"{}\", seg.name));\n                 }\n+                Ok(())\n             }\n         }\n     }\n }\n \n impl fmt::Show for clean::ViewListIdent {\n-    fn fmt(v: &clean::ViewListIdent, f: &mut fmt::Formatter) {\n+    fn fmt(v: &clean::ViewListIdent, f: &mut fmt::Formatter) -> fmt::Result {\n         match v.source {\n             // FIXME: shouldn't be limited to just local imports\n             Some(did) if ast_util::is_local(did) => {\n@@ -508,7 +544,7 @@ impl fmt::Show for clean::ViewListIdent {\n                         types: ~[],\n                     }]\n                 };\n-                resolved_path(f.buf, did.node, &path, false);\n+                resolved_path(f.buf, did.node, &path, false)\n             }\n             _ => write!(f.buf, \"{}\", v.name),\n         }"}, {"sha": "db7c882ab4203a0e5e60be2881c039a05edfaae8", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6132f7f6660c29fe3fc02422b7047246033db84f/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6132f7f6660c29fe3fc02422b7047246033db84f/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=6132f7f6660c29fe3fc02422b7047246033db84f", "patch": "@@ -26,6 +26,7 @@ pub struct Page<'a> {\n \n pub fn render<T: fmt::Show, S: fmt::Show>(\n     dst: &mut io::Writer, layout: &Layout, page: &Page, sidebar: &S, t: &T)\n+    -> fmt::Result\n {\n     write!(dst,\n \"<!DOCTYPE html>\n@@ -121,7 +122,7 @@ pub fn render<T: fmt::Show, S: fmt::Show>(\n     favicon   = nonestr(layout.favicon),\n     sidebar   = *sidebar,\n     crate     = layout.crate,\n-    );\n+    )\n }\n \n fn nonestr<'a>(s: &'a str) -> &'a str {"}, {"sha": "c2203a352c53f5202fcd8f5b053c800437f0acac", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6132f7f6660c29fe3fc02422b7047246033db84f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6132f7f6660c29fe3fc02422b7047246033db84f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=6132f7f6660c29fe3fc02422b7047246033db84f", "patch": "@@ -109,7 +109,7 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n     }\n }\n \n-pub fn render(w: &mut io::Writer, s: &str) {\n+pub fn render(w: &mut io::Writer, s: &str) -> fmt::Result {\n     extern fn block(ob: *buf, text: *buf, lang: *buf, opaque: *libc::c_void) {\n         unsafe {\n             let my_opaque: &my_opaque = cast::transmute(opaque);\n@@ -159,11 +159,12 @@ pub fn render(w: &mut io::Writer, s: &str) {\n         sd_markdown_render(ob, s.as_ptr(), s.len() as libc::size_t, markdown);\n         sd_markdown_free(markdown);\n \n-        vec::raw::buf_as_slice((*ob).data, (*ob).size as uint, |buf| {\n-            w.write(buf);\n+        let ret = vec::raw::buf_as_slice((*ob).data, (*ob).size as uint, |buf| {\n+            w.write(buf)\n         });\n \n         bufrelease(ob);\n+        ret\n     }\n }\n \n@@ -210,10 +211,10 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n }\n \n impl<'a> fmt::Show for Markdown<'a> {\n-    fn fmt(md: &Markdown<'a>, fmt: &mut fmt::Formatter) {\n+    fn fmt(md: &Markdown<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let Markdown(md) = *md;\n         // This is actually common enough to special-case\n-        if md.len() == 0 { return; }\n-        render(fmt.buf, md.as_slice());\n+        if md.len() == 0 { return Ok(()) }\n+        render(fmt.buf, md.as_slice())\n     }\n }"}, {"sha": "7dc89cca745cedfb22190344aa12500261f2d11c", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 340, "deletions": 308, "changes": 648, "blob_url": "https://github.com/rust-lang/rust/blob/6132f7f6660c29fe3fc02422b7047246033db84f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6132f7f6660c29fe3fc02422b7047246033db84f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=6132f7f6660c29fe3fc02422b7047246033db84f", "patch": "@@ -195,7 +195,7 @@ local_data_key!(pub cache_key: Arc<Cache>)\n local_data_key!(pub current_location_key: ~[~str])\n \n /// Generates the documentation for `crate` into the directory `dst`\n-pub fn run(mut crate: clean::Crate, dst: Path) {\n+pub fn run(mut crate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     let mut cx = Context {\n         dst: dst,\n         current: ~[],\n@@ -208,7 +208,7 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n         },\n         include_sources: true,\n     };\n-    mkdir(&cx.dst);\n+    if_ok!(mkdir(&cx.dst));\n \n     match crate.module.as_ref().map(|m| m.doc_list().unwrap_or(&[])) {\n         Some(attrs) => {\n@@ -248,47 +248,55 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n \n     // Add all the static files\n     let mut dst = cx.dst.join(crate.name.as_slice());\n-    mkdir(&dst);\n-    write(dst.join(\"jquery.js\"), include_str!(\"static/jquery-2.0.3.min.js\"));\n-    write(dst.join(\"main.js\"), include_str!(\"static/main.js\"));\n-    write(dst.join(\"main.css\"), include_str!(\"static/main.css\"));\n-    write(dst.join(\"normalize.css\"), include_str!(\"static/normalize.css\"));\n+    if_ok!(mkdir(&dst));\n+    if_ok!(write(dst.join(\"jquery.js\"),\n+                 include_str!(\"static/jquery-2.0.3.min.js\")));\n+    if_ok!(write(dst.join(\"main.js\"), include_str!(\"static/main.js\")));\n+    if_ok!(write(dst.join(\"main.css\"), include_str!(\"static/main.css\")));\n+    if_ok!(write(dst.join(\"normalize.css\"),\n+                 include_str!(\"static/normalize.css\")));\n \n     // Publish the search index\n     {\n         dst.push(\"search-index.js\");\n         let mut w = BufferedWriter::new(File::create(&dst).unwrap());\n         let w = &mut w as &mut Writer;\n-        write!(w, \"var searchIndex = [\");\n+        if_ok!(write!(w, \"var searchIndex = [\"));\n         for (i, item) in cache.search_index.iter().enumerate() {\n-            if i > 0 { write!(w, \",\"); }\n-            write!(w, \"\\\\{ty:\\\"{}\\\",name:\\\"{}\\\",path:\\\"{}\\\",desc:{}\",\n-                   item.ty, item.name, item.path,\n-                   item.desc.to_json().to_str())\n+            if i > 0 {\n+                if_ok!(write!(w, \",\"));\n+            }\n+            if_ok!(write!(w, \"\\\\{ty:\\\"{}\\\",name:\\\"{}\\\",path:\\\"{}\\\",desc:{}\",\n+                          item.ty, item.name, item.path,\n+                          item.desc.to_json().to_str()));\n             match item.parent {\n-                Some(id) => { write!(w, \",parent:'{}'\", id); }\n+                Some(id) => {\n+                    if_ok!(write!(w, \",parent:'{}'\", id));\n+                }\n                 None => {}\n             }\n-            write!(w, \"\\\\}\");\n+            if_ok!(write!(w, \"\\\\}\"));\n         }\n-        write!(w, \"];\");\n-        write!(w, \"var allPaths = \\\\{\");\n+        if_ok!(write!(w, \"];\"));\n+        if_ok!(write!(w, \"var allPaths = \\\\{\"));\n         for (i, (&id, &(ref fqp, short))) in cache.paths.iter().enumerate() {\n-            if i > 0 { write!(w, \",\"); }\n-            write!(w, \"'{}':\\\\{type:'{}',name:'{}'\\\\}\",\n-                   id, short, *fqp.last().unwrap());\n+            if i > 0 {\n+                if_ok!(write!(w, \",\"));\n+            }\n+            if_ok!(write!(w, \"'{}':\\\\{type:'{}',name:'{}'\\\\}\",\n+                          id, short, *fqp.last().unwrap()));\n         }\n-        write!(w, \"\\\\};\");\n-        w.flush();\n+        if_ok!(write!(w, \"\\\\};\"));\n+        if_ok!(w.flush());\n     }\n \n     // Render all source files (this may turn into a giant no-op)\n     {\n         info!(\"emitting source files\");\n         let dst = cx.dst.join(\"src\");\n-        mkdir(&dst);\n+        if_ok!(mkdir(&dst));\n         let dst = dst.join(crate.name.as_slice());\n-        mkdir(&dst);\n+        if_ok!(mkdir(&dst));\n         let mut folder = SourceCollector {\n             dst: dst,\n             seen: HashSet::new(),\n@@ -302,27 +310,23 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n     }\n \n     // And finally render the whole crate's documentation\n-    cx.crate(crate, cache);\n+    cx.crate(crate, cache)\n }\n \n /// Writes the entire contents of a string to a destination, not attempting to\n /// catch any errors.\n-fn write(dst: Path, contents: &str) {\n-    File::create(&dst).write(contents.as_bytes());\n+fn write(dst: Path, contents: &str) -> io::IoResult<()> {\n+    File::create(&dst).write(contents.as_bytes())\n }\n \n /// Makes a directory on the filesystem, failing the task if an error occurs and\n /// skipping if the directory already exists.\n-fn mkdir(path: &Path) {\n-    io::io_error::cond.trap(|err| {\n-        error!(\"Couldn't create directory `{}`: {}\",\n-                path.display(), err.desc);\n-        fail!()\n-    }).inside(|| {\n-        if !path.is_dir() {\n-            fs::mkdir(path, io::UserRWX);\n-        }\n-    })\n+fn mkdir(path: &Path) -> io::IoResult<()> {\n+    if !path.exists() {\n+        fs::mkdir(path, io::UserRWX)\n+    } else {\n+        Ok(())\n+    }\n }\n \n /// Takes a path to a source file and cleans the path to it. This canonicalizes\n@@ -387,15 +391,17 @@ impl<'a> DocFolder for SourceCollector<'a> {\n             // something like that), so just don't include sources for the\n             // entire crate. The other option is maintaining this mapping on a\n             // per-file basis, but that's probably not worth it...\n-            self.cx.include_sources = self.emit_source(item.source.filename);\n+            self.cx.include_sources = match self.emit_source(item.source.filename) {\n+                Ok(()) => true,\n+                Err(e) => {\n+                    println!(\"warning: source code was requested to be rendered, \\\n+                              but processing `{}` had an error: {}\",\n+                             item.source.filename, e);\n+                    println!(\"         skipping rendering of source code\");\n+                    false\n+                }\n+            };\n             self.seen.insert(item.source.filename.clone());\n-\n-            if !self.cx.include_sources {\n-                println!(\"warning: source code was requested to be rendered, \\\n-                          but `{}` is a missing source file.\",\n-                         item.source.filename);\n-                println!(\"         skipping rendering of source code\");\n-            }\n         }\n \n         self.fold_item_recur(item)\n@@ -404,54 +410,42 @@ impl<'a> DocFolder for SourceCollector<'a> {\n \n impl<'a> SourceCollector<'a> {\n     /// Renders the given filename into its corresponding HTML source file.\n-    fn emit_source(&mut self, filename: &str) -> bool {\n+    fn emit_source(&mut self, filename: &str) -> io::IoResult<()> {\n         let p = Path::new(filename);\n \n-        // Read the contents of the file\n-        let mut contents = ~[];\n-        {\n-            let mut buf = [0, ..1024];\n-            // If we couldn't open this file, then just returns because it\n-            // probably means that it's some standard library macro thing and we\n-            // can't have the source to it anyway.\n-            let mut r = match io::result(|| File::open(&p)) {\n-                Ok(r) => r,\n-                // eew macro hacks\n-                Err(..) => return filename == \"<std-macros>\"\n-            };\n-\n-            // read everything\n-            loop {\n-                match r.read(buf) {\n-                    Some(n) => contents.push_all(buf.slice_to(n)),\n-                    None => break\n-                }\n-            }\n-        }\n+        // If we couldn't open this file, then just returns because it\n+        // probably means that it's some standard library macro thing and we\n+        // can't have the source to it anyway.\n+        let contents = match File::open(&p).read_to_end() {\n+            Ok(r) => r,\n+            // eew macro hacks\n+            Err(..) if filename == \"<std-macros>\" => return Ok(()),\n+            Err(e) => return Err(e)\n+        };\n         let contents = str::from_utf8_owned(contents).unwrap();\n \n         // Create the intermediate directories\n         let mut cur = self.dst.clone();\n         let mut root_path = ~\"../../\";\n         clean_srcpath(p.dirname(), |component| {\n             cur.push(component);\n-            mkdir(&cur);\n+            mkdir(&cur).unwrap();\n             root_path.push_str(\"../\");\n         });\n \n         cur.push(p.filename().expect(\"source has no filename\") + bytes!(\".html\"));\n-        let mut w = BufferedWriter::new(File::create(&cur).unwrap());\n+        let mut w = BufferedWriter::new(if_ok!(File::create(&cur)));\n \n         let title = cur.filename_display().with_str(|s| format!(\"{} -- source\", s));\n         let page = layout::Page {\n             title: title,\n             ty: \"source\",\n             root_path: root_path,\n         };\n-        layout::render(&mut w as &mut Writer, &self.cx.layout,\n-                       &page, &(\"\"), &Source(contents.as_slice()));\n-        w.flush();\n-        return true;\n+        if_ok!(layout::render(&mut w as &mut Writer, &self.cx.layout,\n+                              &page, &(\"\"), &Source(contents.as_slice())));\n+        if_ok!(w.flush());\n+        return Ok(());\n     }\n }\n \n@@ -665,7 +659,7 @@ impl Context {\n \n         info!(\"Recursing into {}\", self.dst.display());\n \n-        mkdir(&self.dst);\n+        mkdir(&self.dst).unwrap();\n         let ret = f(self);\n \n         info!(\"Recursed; leaving {}\", self.dst.display());\n@@ -683,10 +677,10 @@ impl Context {\n     ///\n     /// This currently isn't parallelized, but it'd be pretty easy to add\n     /// parallelization to this function.\n-    fn crate(self, mut crate: clean::Crate, cache: Cache) {\n+    fn crate(self, mut crate: clean::Crate, cache: Cache) -> io::IoResult<()> {\n         let mut item = match crate.module.take() {\n             Some(i) => i,\n-            None => return\n+            None => return Ok(())\n         };\n         item.name = Some(crate.name);\n \n@@ -696,22 +690,24 @@ impl Context {\n         let mut work = ~[(self, item)];\n         loop {\n             match work.pop() {\n-                Some((mut cx, item)) => cx.item(item, |cx, item| {\n+                Some((mut cx, item)) => if_ok!(cx.item(item, |cx, item| {\n                     work.push((cx.clone(), item));\n-                }),\n+                })),\n                 None => break,\n             }\n         }\n+        Ok(())\n     }\n \n     /// Non-parellelized version of rendering an item. This will take the input\n     /// item, render its contents, and then invoke the specified closure with\n     /// all sub-items which need to be rendered.\n     ///\n     /// The rendering driver uses this closure to queue up more work.\n-    fn item(&mut self, item: clean::Item, f: |&mut Context, clean::Item|) {\n+    fn item(&mut self, item: clean::Item,\n+            f: |&mut Context, clean::Item|) -> io::IoResult<()> {\n         fn render(w: io::File, cx: &mut Context, it: &clean::Item,\n-                  pushname: bool) {\n+                  pushname: bool) -> io::IoResult<()> {\n             info!(\"Rendering an item to {}\", w.path().display());\n             // A little unfortunate that this is done like this, but it sure\n             // does make formatting *a lot* nicer.\n@@ -733,10 +729,10 @@ impl Context {\n             // of the pain by using a buffered writer instead of invoking the\n             // write sycall all the time.\n             let mut writer = BufferedWriter::new(w);\n-            layout::render(&mut writer as &mut Writer, &cx.layout, &page,\n-                           &Sidebar{ cx: cx, item: it },\n-                           &Item{ cx: cx, item: it });\n-            writer.flush();\n+            if_ok!(layout::render(&mut writer as &mut Writer, &cx.layout, &page,\n+                                  &Sidebar{ cx: cx, item: it },\n+                                  &Item{ cx: cx, item: it }));\n+            writer.flush()\n         }\n \n         match item.inner {\n@@ -748,7 +744,8 @@ impl Context {\n                 self.recurse(name, |this| {\n                     let item = item.take_unwrap();\n                     let dst = this.dst.join(\"index.html\");\n-                    render(File::create(&dst).unwrap(), this, &item, false);\n+                    let dst = if_ok!(File::create(&dst));\n+                    if_ok!(render(dst, this, &item, false));\n \n                     let m = match item.inner {\n                         clean::ModuleItem(m) => m,\n@@ -758,17 +755,19 @@ impl Context {\n                     for item in m.items.move_iter() {\n                         f(this,item);\n                     }\n+                    Ok(())\n                 })\n             }\n \n             // Things which don't have names (like impls) don't get special\n             // pages dedicated to them.\n             _ if item.name.is_some() => {\n                 let dst = self.dst.join(item_path(&item));\n-                render(File::create(&dst).unwrap(), self, &item, true);\n+                let dst = if_ok!(File::create(&dst));\n+                render(dst, self, &item, true)\n             }\n \n-            _ => {}\n+            _ => Ok(())\n         }\n     }\n }\n@@ -802,7 +801,7 @@ impl<'a> Item<'a> {\n }\n \n impl<'a> fmt::Show for Item<'a> {\n-    fn fmt(it: &Item<'a>, fmt: &mut fmt::Formatter) {\n+    fn fmt(it: &Item<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match attr::find_stability(it.item.attrs.iter()) {\n             Some(ref stability) => {\n                 write!(fmt.buf,\n@@ -826,23 +825,24 @@ impl<'a> fmt::Show for Item<'a> {\n             } else {\n                 format!(\"{}-{}\", it.item.source.loline, it.item.source.hiline)\n             };\n-            write!(fmt.buf,\n-                   \"<a class='source'\n-                       href='{root}src/{crate}/{path}.html\\\\#{href}'>[src]</a>\",\n-                   root = it.cx.root_path,\n-                   crate = it.cx.layout.crate,\n-                   path = path.connect(\"/\"),\n-                   href = href);\n+            if_ok!(write!(fmt.buf,\n+                          \"<a class='source'\n+                              href='{root}src/{crate}/{path}.html\\\\#{href}'>\\\n+                              [src]</a>\",\n+                          root = it.cx.root_path,\n+                          crate = it.cx.layout.crate,\n+                          path = path.connect(\"/\"),\n+                          href = href));\n         }\n \n         // Write the breadcrumb trail header for the top\n-        write!(fmt.buf, \"<h1 class='fqn'>\");\n+        if_ok!(write!(fmt.buf, \"<h1 class='fqn'>\"));\n         match it.item.inner {\n-            clean::ModuleItem(..) => write!(fmt.buf, \"Module \"),\n-            clean::FunctionItem(..) => write!(fmt.buf, \"Function \"),\n-            clean::TraitItem(..) => write!(fmt.buf, \"Trait \"),\n-            clean::StructItem(..) => write!(fmt.buf, \"Struct \"),\n-            clean::EnumItem(..) => write!(fmt.buf, \"Enum \"),\n+            clean::ModuleItem(..) => if_ok!(write!(fmt.buf, \"Module \")),\n+            clean::FunctionItem(..) => if_ok!(write!(fmt.buf, \"Function \")),\n+            clean::TraitItem(..) => if_ok!(write!(fmt.buf, \"Trait \")),\n+            clean::StructItem(..) => if_ok!(write!(fmt.buf, \"Struct \")),\n+            clean::EnumItem(..) => if_ok!(write!(fmt.buf, \"Enum \")),\n             _ => {}\n         }\n         let cur = it.cx.current.as_slice();\n@@ -852,11 +852,11 @@ impl<'a> fmt::Show for Item<'a> {\n             for _ in range(0, cur.len() - i - 1) {\n                 trail.push_str(\"../\");\n             }\n-            write!(fmt.buf, \"<a href='{}index.html'>{}</a>::\",\n-                   trail, component.as_slice());\n+            if_ok!(write!(fmt.buf, \"<a href='{}index.html'>{}</a>::\",\n+                          trail, component.as_slice()));\n         }\n-        write!(fmt.buf, \"<a class='{}' href=''>{}</a></h1>\",\n-               shortty(it.item), it.item.name.get_ref().as_slice());\n+        if_ok!(write!(fmt.buf, \"<a class='{}' href=''>{}</a></h1>\",\n+                      shortty(it.item), it.item.name.get_ref().as_slice()));\n \n         match it.item.inner {\n             clean::ModuleItem(ref m) => item_module(fmt.buf, it.cx,\n@@ -867,7 +867,7 @@ impl<'a> fmt::Show for Item<'a> {\n             clean::StructItem(ref s) => item_struct(fmt.buf, it.item, s),\n             clean::EnumItem(ref e) => item_enum(fmt.buf, it.item, e),\n             clean::TypedefItem(ref t) => item_typedef(fmt.buf, it.item, t),\n-            _ => {}\n+            _ => Ok(())\n         }\n     }\n }\n@@ -903,18 +903,19 @@ fn shorter<'a>(s: Option<&'a str>) -> &'a str {\n     }\n }\n \n-fn document(w: &mut Writer, item: &clean::Item) {\n+fn document(w: &mut Writer, item: &clean::Item) -> fmt::Result {\n     match item.doc_value() {\n         Some(s) => {\n-            write!(w, \"<div class='docblock'>{}</div>\", Markdown(s));\n+            if_ok!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(s)));\n         }\n         None => {}\n     }\n+    Ok(())\n }\n \n fn item_module(w: &mut Writer, cx: &Context,\n-               item: &clean::Item, items: &[clean::Item]) {\n-    document(w, item);\n+               item: &clean::Item, items: &[clean::Item]) -> fmt::Result {\n+    if_ok!(document(w, item));\n     debug!(\"{:?}\", items);\n     let mut indices = vec::from_fn(items.len(), |i| i);\n \n@@ -965,10 +966,10 @@ fn item_module(w: &mut Writer, cx: &Context,\n         let myty = shortty(myitem);\n         if myty != curty {\n             if curty != \"\" {\n-                write!(w, \"</table>\");\n+                if_ok!(write!(w, \"</table>\"));\n             }\n             curty = myty;\n-            write!(w, \"<h2>{}</h2>\\n<table>\", match myitem.inner {\n+            if_ok!(write!(w, \"<h2>{}</h2>\\n<table>\", match myitem.inner {\n                 clean::ModuleItem(..)          => \"Modules\",\n                 clean::StructItem(..)          => \"Structs\",\n                 clean::EnumItem(..)            => \"Enums\",\n@@ -984,24 +985,26 @@ fn item_module(w: &mut Writer, cx: &Context,\n                 clean::VariantItem(..)         => \"Variants\",\n                 clean::ForeignFunctionItem(..) => \"Foreign Functions\",\n                 clean::ForeignStaticItem(..)   => \"Foreign Statics\",\n-            });\n+            }));\n         }\n \n         match myitem.inner {\n             clean::StaticItem(ref s) | clean::ForeignStaticItem(ref s) => {\n                 struct Initializer<'a>(&'a str);\n                 impl<'a> fmt::Show for Initializer<'a> {\n-                    fn fmt(s: &Initializer<'a>, f: &mut fmt::Formatter) {\n+                    fn fmt(s: &Initializer<'a>,\n+                           f: &mut fmt::Formatter) -> fmt::Result {\n                         let Initializer(s) = *s;\n-                        if s.len() == 0 { return; }\n-                        write!(f.buf, \"<code> = </code>\");\n+                        if s.len() == 0 { return Ok(()); }\n+                        if_ok!(write!(f.buf, \"<code> = </code>\"));\n                         let tag = if s.contains(\"\\n\") { \"pre\" } else { \"code\" };\n-                        write!(f.buf, \"<{tag}>{}</{tag}>\",\n-                               s.as_slice(), tag=tag);\n+                        if_ok!(write!(f.buf, \"<{tag}>{}</{tag}>\",\n+                                      s.as_slice(), tag=tag));\n+                        Ok(())\n                     }\n                 }\n \n-                write!(w, \"\n+                if_ok!(write!(w, \"\n                     <tr>\n                         <td><code>{}static {}: {}</code>{}</td>\n                         <td class='docblock'>{}&nbsp;</td>\n@@ -1011,27 +1014,27 @@ fn item_module(w: &mut Writer, cx: &Context,\n                 *myitem.name.get_ref(),\n                 s.type_,\n                 Initializer(s.expr),\n-                Markdown(blank(myitem.doc_value())));\n+                Markdown(blank(myitem.doc_value()))));\n             }\n \n             clean::ViewItemItem(ref item) => {\n                 match item.inner {\n                     clean::ExternMod(ref name, ref src, _) => {\n-                        write!(w, \"<tr><td><code>extern mod {}\",\n-                               name.as_slice());\n+                        if_ok!(write!(w, \"<tr><td><code>extern mod {}\",\n+                                      name.as_slice()));\n                         match *src {\n-                            Some(ref src) => write!(w, \" = \\\"{}\\\"\",\n-                                                    src.as_slice()),\n+                            Some(ref src) => if_ok!(write!(w, \" = \\\"{}\\\"\",\n+                                                           src.as_slice())),\n                             None => {}\n                         }\n-                        write!(w, \";</code></td></tr>\");\n+                        if_ok!(write!(w, \";</code></td></tr>\"));\n                     }\n \n                     clean::Import(ref imports) => {\n                         for import in imports.iter() {\n-                            write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n-                                   VisSpace(myitem.visibility),\n-                                   *import);\n+                            if_ok!(write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n+                                          VisSpace(myitem.visibility),\n+                                          *import));\n                         }\n                     }\n                 }\n@@ -1040,7 +1043,7 @@ fn item_module(w: &mut Writer, cx: &Context,\n \n             _ => {\n                 if myitem.name.is_none() { continue }\n-                write!(w, \"\n+                if_ok!(write!(w, \"\n                     <tr>\n                         <td><a class='{class}' href='{href}'\n                                title='{title}'>{}</a></td>\n@@ -1051,24 +1054,26 @@ fn item_module(w: &mut Writer, cx: &Context,\n                 Markdown(shorter(myitem.doc_value())),\n                 class = shortty(myitem),\n                 href = item_path(myitem),\n-                title = full_path(cx, myitem));\n+                title = full_path(cx, myitem)));\n             }\n         }\n     }\n-    write!(w, \"</table>\");\n+    write!(w, \"</table>\")\n }\n \n-fn item_function(w: &mut Writer, it: &clean::Item, f: &clean::Function) {\n-    write!(w, \"<pre class='fn'>{vis}{purity}fn {name}{generics}{decl}</pre>\",\n+fn item_function(w: &mut Writer, it: &clean::Item,\n+                 f: &clean::Function) -> fmt::Result {\n+    if_ok!(write!(w, \"<pre class='fn'>{vis}{purity}fn {name}{generics}{decl}</pre>\",\n            vis = VisSpace(it.visibility),\n            purity = PuritySpace(f.purity),\n            name = it.name.get_ref().as_slice(),\n            generics = f.generics,\n-           decl = f.decl);\n-    document(w, it);\n+           decl = f.decl));\n+    document(w, it)\n }\n \n-fn item_trait(w: &mut Writer, it: &clean::Item, t: &clean::Trait) {\n+fn item_trait(w: &mut Writer, it: &clean::Item,\n+              t: &clean::Trait) -> fmt::Result {\n     let mut parents = ~\"\";\n     if t.parents.len() > 0 {\n         parents.push_str(\": \");\n@@ -1079,99 +1084,102 @@ fn item_trait(w: &mut Writer, it: &clean::Item, t: &clean::Trait) {\n     }\n \n     // Output the trait definition\n-    write!(w, \"<pre class='trait'>{}trait {}{}{} \",\n-           VisSpace(it.visibility),\n-           it.name.get_ref().as_slice(),\n-           t.generics,\n-           parents);\n+    if_ok!(write!(w, \"<pre class='trait'>{}trait {}{}{} \",\n+                  VisSpace(it.visibility),\n+                  it.name.get_ref().as_slice(),\n+                  t.generics,\n+                  parents));\n     let required = t.methods.iter().filter(|m| m.is_req()).to_owned_vec();\n     let provided = t.methods.iter().filter(|m| !m.is_req()).to_owned_vec();\n \n     if t.methods.len() == 0 {\n-        write!(w, \"\\\\{ \\\\}\");\n+        if_ok!(write!(w, \"\\\\{ \\\\}\"));\n     } else {\n-        write!(w, \"\\\\{\\n\");\n+        if_ok!(write!(w, \"\\\\{\\n\"));\n         for m in required.iter() {\n-            write!(w, \"    \");\n-            render_method(w, m.item(), true);\n-            write!(w, \";\\n\");\n+            if_ok!(write!(w, \"    \"));\n+            if_ok!(render_method(w, m.item(), true));\n+            if_ok!(write!(w, \";\\n\"));\n         }\n         if required.len() > 0 && provided.len() > 0 {\n-            w.write(\"\\n\".as_bytes());\n+            if_ok!(w.write(\"\\n\".as_bytes()));\n         }\n         for m in provided.iter() {\n-            write!(w, \"    \");\n-            render_method(w, m.item(), true);\n-            write!(w, \" \\\\{ ... \\\\}\\n\");\n+            if_ok!(write!(w, \"    \"));\n+            if_ok!(render_method(w, m.item(), true));\n+            if_ok!(write!(w, \" \\\\{ ... \\\\}\\n\"));\n         }\n-        write!(w, \"\\\\}\");\n+        if_ok!(write!(w, \"\\\\}\"));\n     }\n-    write!(w, \"</pre>\");\n+    if_ok!(write!(w, \"</pre>\"));\n \n     // Trait documentation\n-    document(w, it);\n-\n-    fn meth(w: &mut Writer, m: &clean::TraitMethod) {\n-        write!(w, \"<h3 id='{}.{}' class='method'><code>\",\n-               shortty(m.item()),\n-               *m.item().name.get_ref());\n-        render_method(w, m.item(), false);\n-        write!(w, \"</code></h3>\");\n-        document(w, m.item());\n+    if_ok!(document(w, it));\n+\n+    fn meth(w: &mut Writer, m: &clean::TraitMethod) -> fmt::Result {\n+        if_ok!(write!(w, \"<h3 id='{}.{}' class='method'><code>\",\n+                      shortty(m.item()),\n+                      *m.item().name.get_ref()));\n+        if_ok!(render_method(w, m.item(), false));\n+        if_ok!(write!(w, \"</code></h3>\"));\n+        if_ok!(document(w, m.item()));\n+        Ok(())\n     }\n \n     // Output the documentation for each function individually\n     if required.len() > 0 {\n-        write!(w, \"\n+        if_ok!(write!(w, \"\n             <h2 id='required-methods'>Required Methods</h2>\n             <div class='methods'>\n-        \");\n+        \"));\n         for m in required.iter() {\n-            meth(w, *m);\n+            if_ok!(meth(w, *m));\n         }\n-        write!(w, \"</div>\");\n+        if_ok!(write!(w, \"</div>\"));\n     }\n     if provided.len() > 0 {\n-        write!(w, \"\n+        if_ok!(write!(w, \"\n             <h2 id='provided-methods'>Provided Methods</h2>\n             <div class='methods'>\n-        \");\n+        \"));\n         for m in provided.iter() {\n-            meth(w, *m);\n+            if_ok!(meth(w, *m));\n         }\n-        write!(w, \"</div>\");\n+        if_ok!(write!(w, \"</div>\"));\n     }\n \n     local_data::get(cache_key, |cache| {\n         let cache = cache.unwrap().get();\n         match cache.implementors.find(&it.id) {\n             Some(implementors) => {\n-                write!(w, \"\n+                if_ok!(write!(w, \"\n                     <h2 id='implementors'>Implementors</h2>\n                     <ul class='item-list'>\n-                \");\n+                \"));\n                 for i in implementors.iter() {\n                     match *i {\n                         PathType(ref ty) => {\n-                            write!(w, \"<li><code>{}</code></li>\", *ty);\n+                            if_ok!(write!(w, \"<li><code>{}</code></li>\", *ty));\n                         }\n                         OtherType(ref generics, ref trait_, ref for_) => {\n-                            write!(w, \"<li><code>impl{} {} for {}</code></li>\",\n-                                   *generics, *trait_, *for_);\n+                            if_ok!(write!(w, \"<li><code>impl{} {} for {}</code></li>\",\n+                                          *generics, *trait_, *for_));\n                         }\n                     }\n                 }\n-                write!(w, \"</ul>\");\n+                if_ok!(write!(w, \"</ul>\"));\n             }\n             None => {}\n         }\n+        Ok(())\n     })\n }\n \n-fn render_method(w: &mut Writer, meth: &clean::Item, withlink: bool) {\n+fn render_method(w: &mut Writer, meth: &clean::Item,\n+                 withlink: bool) -> fmt::Result {\n     fn fun(w: &mut Writer, it: &clean::Item, purity: ast::Purity,\n            g: &clean::Generics, selfty: &clean::SelfTy, d: &clean::FnDecl,\n-           withlink: bool) {\n+           withlink: bool) -> fmt::Result {\n         write!(w, \"{}fn {withlink, select,\n                             true{<a href='\\\\#{ty}.{name}'\n                                     class='fnname'>{name}</a>}\n@@ -1185,118 +1193,125 @@ fn render_method(w: &mut Writer, meth: &clean::Item, withlink: bool) {\n                name = it.name.get_ref().as_slice(),\n                generics = *g,\n                decl = Method(selfty, d),\n-               withlink = if withlink {\"true\"} else {\"false\"});\n+               withlink = if withlink {\"true\"} else {\"false\"})\n     }\n     match meth.inner {\n         clean::TyMethodItem(ref m) => {\n-            fun(w, meth, m.purity, &m.generics, &m.self_, &m.decl, withlink);\n+            fun(w, meth, m.purity, &m.generics, &m.self_, &m.decl, withlink)\n         }\n         clean::MethodItem(ref m) => {\n-            fun(w, meth, m.purity, &m.generics, &m.self_, &m.decl, withlink);\n+            fun(w, meth, m.purity, &m.generics, &m.self_, &m.decl, withlink)\n         }\n         _ => unreachable!()\n     }\n }\n \n-fn item_struct(w: &mut Writer, it: &clean::Item, s: &clean::Struct) {\n-    write!(w, \"<pre class='struct'>\");\n-    render_struct(w, it, Some(&s.generics), s.struct_type, s.fields,\n-                  s.fields_stripped, \"\", true);\n-    write!(w, \"</pre>\");\n+fn item_struct(w: &mut Writer, it: &clean::Item,\n+               s: &clean::Struct) -> fmt::Result {\n+    if_ok!(write!(w, \"<pre class='struct'>\"));\n+    if_ok!(render_struct(w, it, Some(&s.generics), s.struct_type, s.fields,\n+                         s.fields_stripped, \"\", true));\n+    if_ok!(write!(w, \"</pre>\"));\n \n-    document(w, it);\n+    if_ok!(document(w, it));\n     match s.struct_type {\n         doctree::Plain if s.fields.len() > 0 => {\n-            write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\");\n+            if_ok!(write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\"));\n             for field in s.fields.iter() {\n-                write!(w, \"<tr><td id='structfield.{name}'>\\\n-                                <code>{name}</code></td><td>\",\n-                       name = field.name.get_ref().as_slice());\n-                document(w, field);\n-                write!(w, \"</td></tr>\");\n+                if_ok!(write!(w, \"<tr><td id='structfield.{name}'>\\\n+                                  <code>{name}</code></td><td>\",\n+                              name = field.name.get_ref().as_slice()));\n+                if_ok!(document(w, field));\n+                if_ok!(write!(w, \"</td></tr>\"));\n             }\n-            write!(w, \"</table>\");\n+            if_ok!(write!(w, \"</table>\"));\n         }\n         _ => {}\n     }\n-    render_methods(w, it);\n+    render_methods(w, it)\n }\n \n-fn item_enum(w: &mut Writer, it: &clean::Item, e: &clean::Enum) {\n-    write!(w, \"<pre class='enum'>{}enum {}{}\",\n-           VisSpace(it.visibility),\n-           it.name.get_ref().as_slice(),\n-           e.generics);\n+fn item_enum(w: &mut Writer, it: &clean::Item, e: &clean::Enum) -> fmt::Result {\n+    if_ok!(write!(w, \"<pre class='enum'>{}enum {}{}\",\n+                  VisSpace(it.visibility),\n+                  it.name.get_ref().as_slice(),\n+                  e.generics));\n     if e.variants.len() == 0 && !e.variants_stripped {\n-        write!(w, \" \\\\{\\\\}\");\n+        if_ok!(write!(w, \" \\\\{\\\\}\"));\n     } else {\n-        write!(w, \" \\\\{\\n\");\n+        if_ok!(write!(w, \" \\\\{\\n\"));\n         for v in e.variants.iter() {\n-            write!(w, \"    \");\n+            if_ok!(write!(w, \"    \"));\n             let name = v.name.get_ref().as_slice();\n             match v.inner {\n                 clean::VariantItem(ref var) => {\n                     match var.kind {\n-                        clean::CLikeVariant => write!(w, \"{}\", name),\n+                        clean::CLikeVariant => if_ok!(write!(w, \"{}\", name)),\n                         clean::TupleVariant(ref tys) => {\n-                            write!(w, \"{}(\", name);\n+                            if_ok!(write!(w, \"{}(\", name));\n                             for (i, ty) in tys.iter().enumerate() {\n-                                if i > 0 { write!(w, \", \") }\n-                                write!(w, \"{}\", *ty);\n+                                if i > 0 {\n+                                    if_ok!(write!(w, \", \"))\n+                                }\n+                                if_ok!(write!(w, \"{}\", *ty));\n                             }\n-                            write!(w, \")\");\n+                            if_ok!(write!(w, \")\"));\n                         }\n                         clean::StructVariant(ref s) => {\n-                            render_struct(w, v, None, s.struct_type, s.fields,\n-                                          s.fields_stripped, \"    \", false);\n+                            if_ok!(render_struct(w, v, None, s.struct_type,\n+                                                 s.fields, s.fields_stripped,\n+                                                 \"    \", false));\n                         }\n                     }\n                 }\n                 _ => unreachable!()\n             }\n-            write!(w, \",\\n\");\n+            if_ok!(write!(w, \",\\n\"));\n         }\n \n         if e.variants_stripped {\n-            write!(w, \"    // some variants omitted\\n\");\n+            if_ok!(write!(w, \"    // some variants omitted\\n\"));\n         }\n-        write!(w, \"\\\\}\");\n+        if_ok!(write!(w, \"\\\\}\"));\n     }\n-    write!(w, \"</pre>\");\n+    if_ok!(write!(w, \"</pre>\"));\n \n-    document(w, it);\n+    if_ok!(document(w, it));\n     if e.variants.len() > 0 {\n-        write!(w, \"<h2 class='variants'>Variants</h2>\\n<table>\");\n+        if_ok!(write!(w, \"<h2 class='variants'>Variants</h2>\\n<table>\"));\n         for variant in e.variants.iter() {\n-            write!(w, \"<tr><td id='variant.{name}'><code>{name}</code></td><td>\",\n-                   name = variant.name.get_ref().as_slice());\n-            document(w, variant);\n+            if_ok!(write!(w, \"<tr><td id='variant.{name}'><code>{name}</code></td><td>\",\n+                          name = variant.name.get_ref().as_slice()));\n+            if_ok!(document(w, variant));\n             match variant.inner {\n                 clean::VariantItem(ref var) => {\n                     match var.kind {\n                         clean::StructVariant(ref s) => {\n-                            write!(w, \"<h3 class='fields'>Fields</h3>\\n<table>\");\n+                            if_ok!(write!(w, \"<h3 class='fields'>Fields</h3>\\n\n+                                              <table>\"));\n                             for field in s.fields.iter() {\n-                                write!(w, \"<tr><td id='variant.{v}.field.{f}'>\\\n-                                           <code>{f}</code></td><td>\",\n-                                       v = variant.name.get_ref().as_slice(),\n-                                       f = field.name.get_ref().as_slice());\n-                                document(w, field);\n-                                write!(w, \"</td></tr>\");\n+                                if_ok!(write!(w, \"<tr><td \\\n+                                                  id='variant.{v}.field.{f}'>\\\n+                                                  <code>{f}</code></td><td>\",\n+                                              v = variant.name.get_ref().as_slice(),\n+                                              f = field.name.get_ref().as_slice()));\n+                                if_ok!(document(w, field));\n+                                if_ok!(write!(w, \"</td></tr>\"));\n                             }\n-                            write!(w, \"</table>\");\n+                            if_ok!(write!(w, \"</table>\"));\n                         }\n                         _ => ()\n                     }\n                 }\n                 _ => ()\n             }\n-            write!(w, \"</td></tr>\");\n+            if_ok!(write!(w, \"</td></tr>\"));\n         }\n-        write!(w, \"</table>\");\n+        if_ok!(write!(w, \"</table>\"));\n \n     }\n-    render_methods(w, it);\n+    if_ok!(render_methods(w, it));\n+    Ok(())\n }\n \n fn render_struct(w: &mut Writer, it: &clean::Item,\n@@ -1305,54 +1320,59 @@ fn render_struct(w: &mut Writer, it: &clean::Item,\n                  fields: &[clean::Item],\n                  fields_stripped: bool,\n                  tab: &str,\n-                 structhead: bool) {\n-    write!(w, \"{}{}{}\",\n-           VisSpace(it.visibility),\n-           if structhead {\"struct \"} else {\"\"},\n-           it.name.get_ref().as_slice());\n+                 structhead: bool) -> fmt::Result {\n+    if_ok!(write!(w, \"{}{}{}\",\n+                  VisSpace(it.visibility),\n+                  if structhead {\"struct \"} else {\"\"},\n+                  it.name.get_ref().as_slice()));\n     match g {\n-        Some(g) => write!(w, \"{}\", *g),\n+        Some(g) => if_ok!(write!(w, \"{}\", *g)),\n         None => {}\n     }\n     match ty {\n         doctree::Plain => {\n-            write!(w, \" \\\\{\\n{}\", tab);\n+            if_ok!(write!(w, \" \\\\{\\n{}\", tab));\n             for field in fields.iter() {\n                 match field.inner {\n                     clean::StructFieldItem(ref ty) => {\n-                        write!(w, \"    {}{}: {},\\n{}\",\n-                               VisSpace(field.visibility),\n-                               field.name.get_ref().as_slice(),\n-                               ty.type_,\n-                               tab);\n+                        if_ok!(write!(w, \"    {}{}: {},\\n{}\",\n+                                      VisSpace(field.visibility),\n+                                      field.name.get_ref().as_slice(),\n+                                      ty.type_,\n+                                      tab));\n                     }\n                     _ => unreachable!()\n                 }\n             }\n \n             if fields_stripped {\n-                write!(w, \"    // some fields omitted\\n{}\", tab);\n+                if_ok!(write!(w, \"    // some fields omitted\\n{}\", tab));\n             }\n-            write!(w, \"\\\\}\");\n+            if_ok!(write!(w, \"\\\\}\"));\n         }\n         doctree::Tuple | doctree::Newtype => {\n-            write!(w, \"(\");\n+            if_ok!(write!(w, \"(\"));\n             for (i, field) in fields.iter().enumerate() {\n-                if i > 0 { write!(w, \", \") }\n+                if i > 0 {\n+                    if_ok!(write!(w, \", \"));\n+                }\n                 match field.inner {\n                     clean::StructFieldItem(ref field) => {\n-                        write!(w, \"{}\", field.type_);\n+                        if_ok!(write!(w, \"{}\", field.type_));\n                     }\n                     _ => unreachable!()\n                 }\n             }\n-            write!(w, \");\");\n+            if_ok!(write!(w, \");\"));\n+        }\n+        doctree::Unit => {\n+            if_ok!(write!(w, \";\"));\n         }\n-        doctree::Unit => { write!(w, \";\"); }\n     }\n+    Ok(())\n }\n \n-fn render_methods(w: &mut Writer, it: &clean::Item) {\n+fn render_methods(w: &mut Writer, it: &clean::Item) -> fmt::Result {\n     local_data::get(cache_key, |cache| {\n         let c = cache.unwrap().get();\n         match c.impls.find(&it.id) {\n@@ -1367,62 +1387,64 @@ fn render_methods(w: &mut Writer, it: &clean::Item) {\n                 let traits = traits.to_owned_vec();\n \n                 if non_trait.len() > 0 {\n-                    write!(w, \"<h2 id='methods'>Methods</h2>\");\n+                    if_ok!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n                     for &(ref i, ref dox) in non_trait.move_iter() {\n-                        render_impl(w, i, dox);\n+                        if_ok!(render_impl(w, i, dox));\n                     }\n                 }\n                 if traits.len() > 0 {\n-                    write!(w, \"<h2 id='implementations'>Trait \\\n-                               Implementations</h2>\");\n+                    if_ok!(write!(w, \"<h2 id='implementations'>Trait \\\n+                                      Implementations</h2>\"));\n                     for &(ref i, ref dox) in traits.move_iter() {\n-                        render_impl(w, i, dox);\n+                        if_ok!(render_impl(w, i, dox));\n                     }\n                 }\n             }\n             None => {}\n         }\n+        Ok(())\n     })\n }\n \n-fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n-    write!(w, \"<h3 class='impl'><code>impl{} \", i.generics);\n+fn render_impl(w: &mut Writer, i: &clean::Impl,\n+               dox: &Option<~str>) -> fmt::Result {\n+    if_ok!(write!(w, \"<h3 class='impl'><code>impl{} \", i.generics));\n     let trait_id = match i.trait_ {\n         Some(ref ty) => {\n-            write!(w, \"{} for \", *ty);\n+            if_ok!(write!(w, \"{} for \", *ty));\n             match *ty {\n                 clean::ResolvedPath { id, .. } => Some(id),\n                 _ => None,\n             }\n         }\n         None => None\n     };\n-    write!(w, \"{}</code></h3>\", i.for_);\n+    if_ok!(write!(w, \"{}</code></h3>\", i.for_));\n     match *dox {\n         Some(ref dox) => {\n-            write!(w, \"<div class='docblock'>{}</div>\",\n-                   Markdown(dox.as_slice()));\n+            if_ok!(write!(w, \"<div class='docblock'>{}</div>\",\n+                          Markdown(dox.as_slice())));\n         }\n         None => {}\n     }\n \n-    fn docmeth(w: &mut Writer, item: &clean::Item) -> bool {\n-        write!(w, \"<h4 id='method.{}' class='method'><code>\",\n-               *item.name.get_ref());\n-        render_method(w, item, false);\n-        write!(w, \"</code></h4>\\n\");\n+    fn docmeth(w: &mut Writer, item: &clean::Item) -> io::IoResult<bool> {\n+        if_ok!(write!(w, \"<h4 id='method.{}' class='method'><code>\",\n+                      *item.name.get_ref()));\n+        if_ok!(render_method(w, item, false));\n+        if_ok!(write!(w, \"</code></h4>\\n\"));\n         match item.doc_value() {\n             Some(s) => {\n-                write!(w, \"<div class='docblock'>{}</div>\", Markdown(s));\n-                true\n+                if_ok!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(s)));\n+                Ok(true)\n             }\n-            None => false\n+            None => Ok(false)\n         }\n     }\n \n-    write!(w, \"<div class='methods'>\");\n+    if_ok!(write!(w, \"<div class='methods'>\"));\n     for meth in i.methods.iter() {\n-        if docmeth(w, meth) {\n+        if if_ok!(docmeth(w, meth)) {\n             continue\n         }\n \n@@ -1431,7 +1453,7 @@ fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n             None => continue,\n             Some(id) => id,\n         };\n-        local_data::get(cache_key, |cache| {\n+        if_ok!(local_data::get(cache_key, |cache| {\n             let cache = cache.unwrap().get();\n             match cache.traits.find(&trait_id) {\n                 Some(t) => {\n@@ -1440,9 +1462,9 @@ fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n                         Some(method) => {\n                             match method.item().doc_value() {\n                                 Some(s) => {\n-                                    write!(w,\n-                                           \"<div class='docblock'>{}</div>\",\n-                                           Markdown(s));\n+                                    if_ok!(write!(w,\n+                                                  \"<div class='docblock'>{}</div>\",\n+                                                  Markdown(s)));\n                                 }\n                                 None => {}\n                             }\n@@ -1452,15 +1474,16 @@ fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n                 }\n                 None => {}\n             }\n-        })\n+            Ok(())\n+        }))\n     }\n \n     // If we've implemented a trait, then also emit documentation for all\n     // default methods which weren't overridden in the implementation block.\n     match trait_id {\n         None => {}\n         Some(id) => {\n-            local_data::get(cache_key, |cache| {\n+            if_ok!(local_data::get(cache_key, |cache| {\n                 let cache = cache.unwrap().get();\n                 match cache.traits.find(&id) {\n                     Some(t) => {\n@@ -1471,50 +1494,56 @@ fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n                                 None => {}\n                             }\n \n-                            docmeth(w, method.item());\n+                            if_ok!(docmeth(w, method.item()));\n                         }\n                     }\n                     None => {}\n                 }\n-            })\n+                Ok(())\n+            }))\n         }\n     }\n-    write!(w, \"</div>\");\n+    if_ok!(write!(w, \"</div>\"));\n+    Ok(())\n }\n \n-fn item_typedef(w: &mut Writer, it: &clean::Item, t: &clean::Typedef) {\n-    write!(w, \"<pre class='typedef'>type {}{} = {};</pre>\",\n-           it.name.get_ref().as_slice(),\n-           t.generics,\n-           t.type_);\n+fn item_typedef(w: &mut Writer, it: &clean::Item,\n+                t: &clean::Typedef) -> fmt::Result {\n+    if_ok!(write!(w, \"<pre class='typedef'>type {}{} = {};</pre>\",\n+                  it.name.get_ref().as_slice(),\n+                  t.generics,\n+                  t.type_));\n \n-    document(w, it);\n+    document(w, it)\n }\n \n impl<'a> fmt::Show for Sidebar<'a> {\n-    fn fmt(s: &Sidebar<'a>, fmt: &mut fmt::Formatter) {\n+    fn fmt(s: &Sidebar<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let cx = s.cx;\n         let it = s.item;\n-        write!(fmt.buf, \"<p class='location'>\");\n+        if_ok!(write!(fmt.buf, \"<p class='location'>\"));\n         let len = cx.current.len() - if it.is_mod() {1} else {0};\n         for (i, name) in cx.current.iter().take(len).enumerate() {\n-            if i > 0 { write!(fmt.buf, \"&\\\\#8203;::\") }\n-            write!(fmt.buf, \"<a href='{}index.html'>{}</a>\",\n-                   cx.root_path.slice_to((cx.current.len() - i - 1) * 3), *name);\n+            if i > 0 {\n+                if_ok!(write!(fmt.buf, \"&\\\\#8203;::\"));\n+            }\n+            if_ok!(write!(fmt.buf, \"<a href='{}index.html'>{}</a>\",\n+                          cx.root_path.slice_to((cx.current.len() - i - 1) * 3),\n+                          *name));\n         }\n-        write!(fmt.buf, \"</p>\");\n+        if_ok!(write!(fmt.buf, \"</p>\"));\n \n         fn block(w: &mut Writer, short: &str, longty: &str,\n-                 cur: &clean::Item, cx: &Context) {\n+                 cur: &clean::Item, cx: &Context) -> fmt::Result {\n             let items = match cx.sidebar.find_equiv(&short) {\n                 Some(items) => items.as_slice(),\n-                None => return\n+                None => return Ok(())\n             };\n-            write!(w, \"<div class='block {}'><h2>{}</h2>\", short, longty);\n+            if_ok!(write!(w, \"<div class='block {}'><h2>{}</h2>\", short, longty));\n             for item in items.iter() {\n                 let class = if cur.name.get_ref() == item &&\n                                short == shortty(cur) { \"current\" } else { \"\" };\n-                write!(w, \"<a class='{ty} {class}' href='{curty, select,\n+                if_ok!(write!(w, \"<a class='{ty} {class}' href='{curty, select,\n                                 mod{../}\n                                 other{}\n                            }{tysel, select,\n@@ -1525,16 +1554,18 @@ impl<'a> fmt::Show for Sidebar<'a> {\n                        tysel = short,\n                        class = class,\n                        curty = shortty(cur),\n-                       name = item.as_slice());\n+                       name = item.as_slice()));\n             }\n-            write!(w, \"</div>\");\n+            if_ok!(write!(w, \"</div>\"));\n+            Ok(())\n         }\n \n-        block(fmt.buf, \"mod\", \"Modules\", it, cx);\n-        block(fmt.buf, \"struct\", \"Structs\", it, cx);\n-        block(fmt.buf, \"enum\", \"Enums\", it, cx);\n-        block(fmt.buf, \"trait\", \"Traits\", it, cx);\n-        block(fmt.buf, \"fn\", \"Functions\", it, cx);\n+        if_ok!(block(fmt.buf, \"mod\", \"Modules\", it, cx));\n+        if_ok!(block(fmt.buf, \"struct\", \"Structs\", it, cx));\n+        if_ok!(block(fmt.buf, \"enum\", \"Enums\", it, cx));\n+        if_ok!(block(fmt.buf, \"trait\", \"Traits\", it, cx));\n+        if_ok!(block(fmt.buf, \"fn\", \"Functions\", it, cx));\n+        Ok(())\n     }\n }\n \n@@ -1557,7 +1588,7 @@ fn build_sidebar(m: &clean::Module) -> HashMap<~str, ~[~str]> {\n }\n \n impl<'a> fmt::Show for Source<'a> {\n-    fn fmt(s: &Source<'a>, fmt: &mut fmt::Formatter) {\n+    fn fmt(s: &Source<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let Source(s) = *s;\n         let lines = s.lines().len();\n         let mut cols = 0;\n@@ -1566,13 +1597,14 @@ impl<'a> fmt::Show for Source<'a> {\n             cols += 1;\n             tmp /= 10;\n         }\n-        write!(fmt.buf, \"<pre class='line-numbers'>\");\n+        if_ok!(write!(fmt.buf, \"<pre class='line-numbers'>\"));\n         for i in range(1, lines + 1) {\n-            write!(fmt.buf, \"<span id='{0:u}'>{0:1$u}</span>\\n\", i, cols);\n+            if_ok!(write!(fmt.buf, \"<span id='{0:u}'>{0:1$u}</span>\\n\", i, cols));\n         }\n-        write!(fmt.buf, \"</pre>\");\n-        write!(fmt.buf, \"<pre class='rust'>\");\n-        write!(fmt.buf, \"{}\", Escape(s.as_slice()));\n-        write!(fmt.buf, \"</pre>\");\n+        if_ok!(write!(fmt.buf, \"</pre>\"));\n+        if_ok!(write!(fmt.buf, \"<pre class='rust'>\"));\n+        if_ok!(write!(fmt.buf, \"{}\", Escape(s.as_slice())));\n+        if_ok!(write!(fmt.buf, \"</pre>\"));\n+        Ok(())\n     }\n }"}, {"sha": "fe989279e7147dd13286e0cd41009c59f1f9c3b3", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6132f7f6660c29fe3fc02422b7047246033db84f/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6132f7f6660c29fe3fc02422b7047246033db84f/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=6132f7f6660c29fe3fc02422b7047246033db84f", "patch": "@@ -162,10 +162,16 @@ pub fn main_args(args: &[~str]) -> int {\n     let output = matches.opt_str(\"o\").map(|s| Path::new(s));\n     match matches.opt_str(\"w\") {\n         Some(~\"html\") | None => {\n-            html::render::run(crate, output.unwrap_or(Path::new(\"doc\")))\n+            match html::render::run(crate, output.unwrap_or(Path::new(\"doc\"))) {\n+                Ok(()) => {}\n+                Err(e) => fail!(\"failed to generate documentation: {}\", e),\n+            }\n         }\n         Some(~\"json\") => {\n-            json_output(crate, res, output.unwrap_or(Path::new(\"doc.json\")))\n+            match json_output(crate, res, output.unwrap_or(Path::new(\"doc.json\"))) {\n+                Ok(()) => {}\n+                Err(e) => fail!(\"failed to write json: {}\", e),\n+            }\n         }\n         Some(s) => {\n             println!(\"unknown output format: {}\", s);\n@@ -276,8 +282,8 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n /// run over the deserialized output.\n fn json_input(input: &str) -> Result<Output, ~str> {\n     let mut input = match File::open(&Path::new(input)) {\n-        Some(f) => f,\n-        None => return Err(format!(\"couldn't open {} for reading\", input)),\n+        Ok(f) => f,\n+        Err(e) => return Err(format!(\"couldn't open {}: {}\", input, e)),\n     };\n     match json::from_reader(&mut input) {\n         Err(s) => Err(s.to_str()),\n@@ -312,7 +318,8 @@ fn json_input(input: &str) -> Result<Output, ~str> {\n \n /// Outputs the crate/plugin json as a giant json blob at the specified\n /// destination.\n-fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n+fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson],\n+               dst: Path) -> io::IoResult<()> {\n     // {\n     //   \"schema\": version,\n     //   \"crate\": { parsed crate ... },\n@@ -340,6 +347,7 @@ fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n     json.insert(~\"crate\", crate_json);\n     json.insert(~\"plugins\", json::Object(plugins_json));\n \n-    let mut file = File::create(&dst).unwrap();\n-    json::Object(json).to_writer(&mut file);\n+    let mut file = if_ok!(File::create(&dst));\n+    if_ok!(json::Object(json).to_writer(&mut file));\n+    Ok(())\n }"}, {"sha": "9e3b217f69f68953c5b4ac755ddb3fa420ebfa27", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6132f7f6660c29fe3fc02422b7047246033db84f/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6132f7f6660c29fe3fc02422b7047246033db84f/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=6132f7f6660c29fe3fc02422b7047246033db84f", "patch": "@@ -127,8 +127,8 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>) {\n     let exe = outdir.path().join(\"rust_out\");\n     let out = run::process_output(exe.as_str().unwrap(), []);\n     match out {\n-        None => fail!(\"couldn't run the test\"),\n-        Some(out) => {\n+        Err(e) => fail!(\"couldn't run the test: {}\", e),\n+        Ok(out) => {\n             if !out.status.success() {\n                 fail!(\"test executable failed:\\n{}\",\n                       str::from_utf8(out.error));"}]}