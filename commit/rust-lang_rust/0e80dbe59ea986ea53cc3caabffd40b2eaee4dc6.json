{"sha": "0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlODBkYmU1OWVhOTg2ZWE1M2NjM2NhYWJmZmQ0MGIyZWFlZTRkYzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-10T23:26:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-10T23:26:39Z"}, "message": "auto merge of #15336 : jakub-/rust/diagnostics, r=brson\n\nThis is a continuation of @brson's work from https://github.com/rust-lang/rust/pull/12144.\r\n\r\nThis implements the minimal scaffolding that allows mapping diagnostic messages to alpha-numeric codes, which could improve the searchability of errors. In addition, there's a new compiler option, `--explain {code}` which takes an error code and prints out a somewhat detailed explanation of the error. Example:\r\n\r\n```rust\r\nfn f(x: Option<bool>) {\r\n\tmatch x {\r\n\t\tSome(true) | Some(false) => (),\r\n\t\tNone => (),\r\n\t\tSome(true) => ()\r\n\t}\r\n}\r\n```\r\n\r\n```shell\r\n[~/rust]$ ./build/x86_64-apple-darwin/stage2/bin/rustc ./diagnostics.rs --crate-type dylib\r\ndiagnostics.rs:5:3: 5:13 error: unreachable pattern [E0001] (pass `--explain E0001` to see a detailed explanation)\r\ndiagnostics.rs:5 \t\tSome(true) => ()\r\n                 \t\t^~~~~~~~~~\r\nerror: aborting due to previous error\r\n[~/rust]$ ./build/x86_64-apple-darwin/stage2/bin/rustc --explain E0001\r\n\r\n    This error suggests that the expression arm corresponding to the noted pattern\r\n    will never be reached as for all possible values of the expression being matched,\r\n    one of the preceeding patterns will match.\r\n\r\n    This means that perhaps some of the preceeding patterns are too general, this\r\n    one is too specific or the ordering is incorrect.\r\n\r\n```\r\n\r\nI've refrained from migrating many errors to actually use the new macros as it can be done in an incremental fashion but if we're happy with the approach, it'd be good to do all of them sooner rather than later.\r\n\r\nOriginally, I was going to make libdiagnostics a separate crate but that's posing some interesting challenges with semi-circular dependencies. In particular, librustc would have a plugin-phase dependency on libdiagnostics, which itself depends on librustc. Per my conversation with @alexcrichton, it seems like the snapshotting process would also have to change. So for now the relevant modules from libdiagnostics are included using `#[path = ...] mod`.", "tree": {"sha": "3044cbdb7fe356d52a07c9048bc431aac3de5c4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3044cbdb7fe356d52a07c9048bc431aac3de5c4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "html_url": "https://github.com/rust-lang/rust/commit/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a672456c40d28f051ecbdb2caf5bf6733371d494", "url": "https://api.github.com/repos/rust-lang/rust/commits/a672456c40d28f051ecbdb2caf5bf6733371d494", "html_url": "https://github.com/rust-lang/rust/commit/a672456c40d28f051ecbdb2caf5bf6733371d494"}, {"sha": "9b9cce2316119a2ffdc9556d410e464b7542d64d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b9cce2316119a2ffdc9556d410e464b7542d64d", "html_url": "https://github.com/rust-lang/rust/commit/9b9cce2316119a2ffdc9556d410e464b7542d64d"}], "stats": {"total": 550, "additions": 466, "deletions": 84}, "files": [{"sha": "0499795f890fd20960c08b00fb30cfbd35400d86", "filename": "src/librustc/diagnostics.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+register_diagnostic!(E0001, r##\"\n+    This error suggests that the expression arm corresponding to the noted pattern\n+    will never be reached as for all possible values of the expression being matched,\n+    one of the preceeding patterns will match.\n+\n+    This means that perhaps some of the preceeding patterns are too general, this\n+    one is too specific or the ordering is incorrect.\n+\"##)"}, {"sha": "b726c50afe9d1202850cbfdc5b7b73fb20a2d0a6", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -532,6 +532,7 @@ pub fn optgroups() -> Vec<getopts::OptGroup> {\n         optopt(\"\", \"opt-level\", \"Optimize with possible levels 0-3\", \"LEVEL\"),\n         optopt( \"\",  \"out-dir\", \"Write output to compiler-chosen filename in <dir>\", \"DIR\"),\n         optflag(\"\", \"parse-only\", \"Parse only; do not compile, assemble, or link\"),\n+        optopt(\"\", \"explain\", \"Provide a detailed explanation of an error message\", \"OPT\"),\n         optflagopt(\"\", \"pretty\",\n                    \"Pretty-print the input instead of compiling;\n                    valid types are: `normal` (un-annotated source),\n@@ -807,6 +808,7 @@ mod test {\n     use getopts::getopts;\n     use syntax::attr;\n     use syntax::attr::AttrMetaMethods;\n+    use syntax::diagnostics;\n \n     // When the user supplies --test we should implicitly supply --cfg test\n     #[test]\n@@ -816,8 +818,9 @@ mod test {\n               Ok(m) => m,\n               Err(f) => fail!(\"test_switch_implies_cfg_test: {}\", f)\n             };\n+        let registry = diagnostics::registry::Registry::new([]);\n         let sessopts = build_session_options(matches);\n-        let sess = build_session(sessopts, None);\n+        let sess = build_session(sessopts, None, registry);\n         let cfg = build_configuration(&sess);\n         assert!((attr::contains_name(cfg.as_slice(), \"test\")));\n     }\n@@ -834,8 +837,9 @@ mod test {\n                 fail!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f)\n               }\n             };\n+        let registry = diagnostics::registry::Registry::new([]);\n         let sessopts = build_session_options(matches);\n-        let sess = build_session(sessopts, None);\n+        let sess = build_session(sessopts, None, registry);\n         let cfg = build_configuration(&sess);\n         let mut test_items = cfg.iter().filter(|m| m.name().equiv(&(\"test\")));\n         assert!(test_items.next().is_some());"}, {"sha": "8173e2ab582a043315a3882cd0e561f0c799284c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -16,6 +16,7 @@ use driver::{PpmFlowGraph, PpmExpanded, PpmExpandedIdentified, PpmTyped};\n use driver::{PpmIdentified};\n use front;\n use lib::llvm::{ContextRef, ModuleRef};\n+use lint;\n use metadata::common::LinkMeta;\n use metadata::creader;\n use middle::cfg;\n@@ -26,7 +27,7 @@ use middle;\n use plugin::load::Plugins;\n use plugin::registry::Registry;\n use plugin;\n-use lint;\n+\n use util::common::time;\n use util::ppaux;\n use util::nodemap::{NodeSet};\n@@ -41,6 +42,7 @@ use std::io::MemReader;\n use syntax::ast;\n use syntax::attr;\n use syntax::attr::{AttrMetaMethods};\n+use syntax::diagnostics;\n use syntax::parse;\n use syntax::parse::token;\n use syntax::print::{pp, pprust};\n@@ -213,6 +215,15 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     let mut registry = Registry::new(&krate);\n \n     time(time_passes, \"plugin registration\", (), |_| {\n+        if sess.features.rustc_diagnostic_macros.get() {\n+            registry.register_macro(\"__diagnostic_used\",\n+                diagnostics::plugin::expand_diagnostic_used);\n+            registry.register_macro(\"__register_diagnostic\",\n+                diagnostics::plugin::expand_register_diagnostic);\n+            registry.register_macro(\"__build_diagnostic_array\",\n+                diagnostics::plugin::expand_build_diagnostic_array);\n+        }\n+\n         for &registrar in registrars.iter() {\n             registrar(&mut registry);\n         }"}, {"sha": "2614c9ebf98b003fa74d2fb3678bd519afb603cd", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -26,6 +26,7 @@ use std::task::TaskBuilder;\n use syntax::ast;\n use syntax::parse;\n use syntax::diagnostic::Emitter;\n+use syntax::diagnostics;\n \n use getopts;\n \n@@ -49,8 +50,24 @@ fn run_compiler(args: &[String]) {\n         Some(matches) => matches,\n         None => return\n     };\n-    let sopts = config::build_session_options(&matches);\n \n+    let descriptions = diagnostics::registry::Registry::new(super::DIAGNOSTICS);\n+    match matches.opt_str(\"explain\") {\n+        Some(ref code) => {\n+            match descriptions.find_description(code.as_slice()) {\n+                Some(ref description) => {\n+                    println!(\"{}\", description);\n+                }\n+                None => {\n+                    early_error(format!(\"no extended information for {}\", code).as_slice());\n+                }\n+            }\n+            return;\n+        },\n+        None => ()\n+    }\n+\n+    let sopts = config::build_session_options(&matches);\n     let (input, input_file_path) = match matches.free.len() {\n         0u => {\n             if sopts.describe_lints {\n@@ -75,7 +92,7 @@ fn run_compiler(args: &[String]) {\n         _ => early_error(\"multiple input filenames provided\")\n     };\n \n-    let sess = build_session(sopts, input_file_path);\n+    let sess = build_session(sopts, input_file_path, descriptions);\n     let cfg = config::build_configuration(&sess);\n     let odir = matches.opt_str(\"out-dir\").map(|o| Path::new(o));\n     let ofile = matches.opt_str(\"o\").map(|o| Path::new(o));\n@@ -383,14 +400,14 @@ fn parse_crate_attrs(sess: &Session, input: &Input) ->\n }\n \n pub fn early_error(msg: &str) -> ! {\n-    let mut emitter = diagnostic::EmitterWriter::stderr(diagnostic::Auto);\n-    emitter.emit(None, msg, diagnostic::Fatal);\n+    let mut emitter = diagnostic::EmitterWriter::stderr(diagnostic::Auto, None);\n+    emitter.emit(None, msg, None, diagnostic::Fatal);\n     fail!(diagnostic::FatalError);\n }\n \n pub fn early_warn(msg: &str) {\n-    let mut emitter = diagnostic::EmitterWriter::stderr(diagnostic::Auto);\n-    emitter.emit(None, msg, diagnostic::Warning);\n+    let mut emitter = diagnostic::EmitterWriter::stderr(diagnostic::Auto, None);\n+    emitter.emit(None, msg, None, diagnostic::Warning);\n }\n \n pub fn list_metadata(sess: &Session, path: &Path,\n@@ -429,14 +446,15 @@ fn monitor(f: proc():Send) {\n         Err(value) => {\n             // Task failed without emitting a fatal diagnostic\n             if !value.is::<diagnostic::FatalError>() {\n-                let mut emitter = diagnostic::EmitterWriter::stderr(diagnostic::Auto);\n+                let mut emitter = diagnostic::EmitterWriter::stderr(diagnostic::Auto, None);\n \n                 // a .span_bug or .bug call has already printed what\n                 // it wants to print.\n                 if !value.is::<diagnostic::ExplicitBug>() {\n                     emitter.emit(\n                         None,\n                         \"unexpected failure\",\n+                        None,\n                         diagnostic::Bug);\n                 }\n \n@@ -447,7 +465,7 @@ fn monitor(f: proc():Send) {\n                     \"run with `RUST_BACKTRACE=1` for a backtrace\".to_string(),\n                 ];\n                 for note in xs.iter() {\n-                    emitter.emit(None, note.as_slice(), diagnostic::Note)\n+                    emitter.emit(None, note.as_slice(), None, diagnostic::Note)\n                 }\n \n                 match r.read_to_string() {\n@@ -457,6 +475,7 @@ fn monitor(f: proc():Send) {\n                                      format!(\"failed to read internal \\\n                                               stderr: {}\",\n                                              e).as_slice(),\n+                                     None,\n                                      diagnostic::Error)\n                     }\n                 }"}, {"sha": "8669a733f61345a7f7fb5d4f9d908036afa86189", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -20,6 +20,7 @@ use util::nodemap::NodeMap;\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use syntax::diagnostic;\n+use syntax::diagnostics;\n use syntax::parse;\n use syntax::parse::token;\n use syntax::parse::ParseSess;\n@@ -65,6 +66,9 @@ impl Session {\n     pub fn span_err(&self, sp: Span, msg: &str) {\n         self.diagnostic().span_err(sp, msg)\n     }\n+    pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n+        self.diagnostic().span_err_with_code(sp, msg, code)\n+    }\n     pub fn err(&self, msg: &str) {\n         self.diagnostic().handler().err(msg)\n     }\n@@ -197,11 +201,12 @@ impl Session {\n }\n \n pub fn build_session(sopts: config::Options,\n-                     local_crate_source_file: Option<Path>)\n+                     local_crate_source_file: Option<Path>,\n+                     registry: diagnostics::registry::Registry)\n                      -> Session {\n     let codemap = codemap::CodeMap::new();\n     let diagnostic_handler =\n-        diagnostic::default_handler(sopts.color);\n+        diagnostic::default_handler(sopts.color, Some(registry));\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n "}, {"sha": "8b92166388d8608aadec35fbca6e4934948c3794", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -66,6 +66,8 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n \n     (\"quad_precision_float\", Removed),\n \n+    (\"rustc_diagnostic_macros\", Active),\n+\n     // A temporary feature gate used to enable parser extensions needed\n     // to bootstrap fix for #5723.\n     (\"issue_5723_bootstrap\", Active),\n@@ -93,6 +95,7 @@ pub struct Features {\n     pub default_type_params: Cell<bool>,\n     pub issue_5723_bootstrap: Cell<bool>,\n     pub overloaded_calls: Cell<bool>,\n+    pub rustc_diagnostic_macros: Cell<bool>\n }\n \n impl Features {\n@@ -101,6 +104,7 @@ impl Features {\n             default_type_params: Cell::new(false),\n             issue_5723_bootstrap: Cell::new(false),\n             overloaded_calls: Cell::new(false),\n+            rustc_diagnostic_macros: Cell::new(false)\n         }\n     }\n }\n@@ -425,4 +429,5 @@ pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n     sess.features.default_type_params.set(cx.has_feature(\"default_type_params\"));\n     sess.features.issue_5723_bootstrap.set(cx.has_feature(\"issue_5723_bootstrap\"));\n     sess.features.overloaded_calls.set(cx.has_feature(\"overloaded_calls\"));\n+    sess.features.rustc_diagnostic_macros.set(cx.has_feature(\"rustc_diagnostic_macros\"));\n }"}, {"sha": "97ea425df9970ed5ff60ff8196ebb1585743effd", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -32,16 +32,21 @@ This API is completely unstable and subject to change.\n #![feature(macro_rules, globs, struct_variant, managed_boxes, quote)]\n #![feature(default_type_params, phase, unsafe_destructor)]\n \n+#![allow(unknown_features)] // NOTE: Remove after next snapshot\n+#![feature(rustc_diagnostic_macros)]\n+\n extern crate arena;\n extern crate debug;\n extern crate flate;\n extern crate getopts;\n extern crate graphviz;\n extern crate libc;\n extern crate serialize;\n-extern crate syntax;\n extern crate time;\n #[phase(plugin, link)] extern crate log;\n+#[phase(plugin, link)] extern crate syntax;\n+\n+mod diagnostics;\n \n pub mod middle {\n     pub mod def;\n@@ -127,6 +132,8 @@ pub mod lib {\n     pub mod llvmdeps;\n }\n \n+__build_diagnostic_array!(DIAGNOSTICS)\n+\n // A private module so that macro-expanded idents like\n // `::rustc::lint::Lint` will also work in `rustc` itself.\n //"}, {"sha": "f31c247abd38c3c83935d0d5bad13221db1ffddf", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -194,7 +194,7 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n \n             let v = vec!(*pat);\n             match is_useful(cx, &seen, v.as_slice(), LeaveOutWitness) {\n-                NotUseful => cx.tcx.sess.span_err(pat.span, \"unreachable pattern\"),\n+                NotUseful => span_err!(cx.tcx.sess, pat.span, E0001, \"unreachable pattern\"),\n                 Useful => (),\n                 UsefulWithWitness(_) => unreachable!()\n             }"}, {"sha": "c06e40fce14f915e410208e5393bb57eccbf885f", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -78,6 +78,7 @@ impl Emitter for ExpectErrorEmitter {\n     fn emit(&mut self,\n             _cmsp: Option<(&codemap::CodeMap, Span)>,\n             msg: &str,\n+            _: Option<&str>,\n             lvl: Level)\n     {\n         remove_message(self, msg, lvl);"}, {"sha": "e62c8b63a294070b0c873f5cccecc9775b22a24f", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -101,7 +101,7 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n \n \n     let codemap = syntax::codemap::CodeMap::new();\n-    let diagnostic_handler = syntax::diagnostic::default_handler(syntax::diagnostic::Auto);\n+    let diagnostic_handler = syntax::diagnostic::default_handler(syntax::diagnostic::Auto, None);\n     let span_diagnostic_handler =\n         syntax::diagnostic::mk_span_handler(diagnostic_handler, codemap);\n "}, {"sha": "055019aa481ffebaf06edc9aab9f3a467be8efd8", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -54,7 +54,7 @@ pub fn run(input: &str,\n \n \n     let codemap = CodeMap::new();\n-    let diagnostic_handler = diagnostic::default_handler(diagnostic::Auto);\n+    let diagnostic_handler = diagnostic::default_handler(diagnostic::Auto, None);\n     let span_diagnostic_handler =\n     diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n@@ -150,7 +150,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n         };\n         io::util::copy(&mut p, &mut err).unwrap();\n     });\n-    let emitter = diagnostic::EmitterWriter::new(box w2);\n+    let emitter = diagnostic::EmitterWriter::new(box w2, None);\n \n     // Compile the code\n     let codemap = CodeMap::new();"}, {"sha": "9bb5eae2ed2d66c893378ee316e419c01e53f90b", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 60, "deletions": 27, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -12,6 +12,7 @@ extern crate libc;\n \n use codemap::{Pos, Span};\n use codemap;\n+use diagnostics;\n \n use std::cell::{RefCell, Cell};\n use std::fmt;\n@@ -59,7 +60,7 @@ pub enum ColorConfig {\n \n pub trait Emitter {\n     fn emit(&mut self, cmsp: Option<(&codemap::CodeMap, Span)>,\n-            msg: &str, lvl: Level);\n+            msg: &str, code: Option<&str>, lvl: Level);\n     fn custom_emit(&mut self, cm: &codemap::CodeMap,\n                    sp: RenderSpan, msg: &str, lvl: Level);\n }\n@@ -90,6 +91,10 @@ impl SpanHandler {\n         self.handler.emit(Some((&self.cm, sp)), msg, Error);\n         self.handler.bump_err_count();\n     }\n+    pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n+        self.handler.emit_with_code(Some((&self.cm, sp)), msg, code, Error);\n+        self.handler.bump_err_count();\n+    }\n     pub fn span_warn(&self, sp: Span, msg: &str) {\n         self.handler.emit(Some((&self.cm, sp)), msg, Warning);\n     }\n@@ -124,11 +129,11 @@ pub struct Handler {\n \n impl Handler {\n     pub fn fatal(&self, msg: &str) -> ! {\n-        self.emit.borrow_mut().emit(None, msg, Fatal);\n+        self.emit.borrow_mut().emit(None, msg, None, Fatal);\n         fail!(FatalError);\n     }\n     pub fn err(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(None, msg, Error);\n+        self.emit.borrow_mut().emit(None, msg, None, Error);\n         self.bump_err_count();\n     }\n     pub fn bump_err_count(&self) {\n@@ -153,13 +158,13 @@ impl Handler {\n         self.fatal(s.as_slice());\n     }\n     pub fn warn(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(None, msg, Warning);\n+        self.emit.borrow_mut().emit(None, msg, None, Warning);\n     }\n     pub fn note(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(None, msg, Note);\n+        self.emit.borrow_mut().emit(None, msg, None, Note);\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n-        self.emit.borrow_mut().emit(None, msg, Bug);\n+        self.emit.borrow_mut().emit(None, msg, None, Bug);\n         fail!(ExplicitBug);\n     }\n     pub fn unimpl(&self, msg: &str) -> ! {\n@@ -169,7 +174,14 @@ impl Handler {\n                 cmsp: Option<(&codemap::CodeMap, Span)>,\n                 msg: &str,\n                 lvl: Level) {\n-        self.emit.borrow_mut().emit(cmsp, msg, lvl);\n+        self.emit.borrow_mut().emit(cmsp, msg, None, lvl);\n+    }\n+    pub fn emit_with_code(&self,\n+                          cmsp: Option<(&codemap::CodeMap, Span)>,\n+                          msg: &str,\n+                          code: &str,\n+                          lvl: Level) {\n+        self.emit.borrow_mut().emit(cmsp, msg, Some(code), lvl);\n     }\n     pub fn custom_emit(&self, cm: &codemap::CodeMap,\n                        sp: RenderSpan, msg: &str, lvl: Level) {\n@@ -184,8 +196,9 @@ pub fn mk_span_handler(handler: Handler, cm: codemap::CodeMap) -> SpanHandler {\n     }\n }\n \n-pub fn default_handler(color_config: ColorConfig) -> Handler {\n-    mk_handler(box EmitterWriter::stderr(color_config))\n+pub fn default_handler(color_config: ColorConfig,\n+                       registry: Option<diagnostics::registry::Registry>) -> Handler {\n+    mk_handler(box EmitterWriter::stderr(color_config, registry))\n }\n \n pub fn mk_handler(e: Box<Emitter + Send>) -> Handler {\n@@ -262,8 +275,8 @@ fn print_maybe_styled(w: &mut EmitterWriter,\n     }\n }\n \n-fn print_diagnostic(dst: &mut EmitterWriter,\n-                    topic: &str, lvl: Level, msg: &str) -> io::IoResult<()> {\n+fn print_diagnostic(dst: &mut EmitterWriter, topic: &str, lvl: Level,\n+                    msg: &str, code: Option<&str>) -> io::IoResult<()> {\n     if !topic.is_empty() {\n         try!(write!(&mut dst.dst, \"{} \", topic));\n     }\n@@ -272,13 +285,32 @@ fn print_diagnostic(dst: &mut EmitterWriter,\n                             format!(\"{}: \", lvl.to_string()).as_slice(),\n                             term::attr::ForegroundColor(lvl.color())));\n     try!(print_maybe_styled(dst,\n-                            format!(\"{}\\n\", msg).as_slice(),\n+                            format!(\"{}\", msg).as_slice(),\n                             term::attr::Bold));\n+\n+    match code {\n+        Some(code) => {\n+            let style = term::attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n+            try!(print_maybe_styled(dst, format!(\" [{}]\", code.clone()).as_slice(), style));\n+            match dst.registry.as_ref().and_then(|registry| registry.find_description(code)) {\n+                Some(_) => {\n+                    try!(write!(&mut dst.dst,\n+                        \" (pass `--explain {}` to see a detailed explanation)\",\n+                        code\n+                    ));\n+                }\n+                None => ()\n+            }\n+        }\n+        None => ()\n+    }\n+    try!(dst.dst.write_char('\\n'));\n     Ok(())\n }\n \n pub struct EmitterWriter {\n     dst: Destination,\n+    registry: Option<diagnostics::registry::Registry>\n }\n \n enum Destination {\n@@ -287,7 +319,8 @@ enum Destination {\n }\n \n impl EmitterWriter {\n-    pub fn stderr(color_config: ColorConfig) -> EmitterWriter {\n+    pub fn stderr(color_config: ColorConfig,\n+                  registry: Option<diagnostics::registry::Registry>) -> EmitterWriter {\n         let stderr = io::stderr();\n \n         let use_color = match color_config {\n@@ -301,14 +334,15 @@ impl EmitterWriter {\n                 Some(t) => Terminal(t),\n                 None    => Raw(box stderr),\n             };\n-            EmitterWriter { dst: dst }\n+            EmitterWriter { dst: dst, registry: registry }\n         } else {\n-            EmitterWriter { dst: Raw(box stderr) }\n+            EmitterWriter { dst: Raw(box stderr), registry: registry }\n         }\n     }\n \n-    pub fn new(dst: Box<Writer + Send>) -> EmitterWriter {\n-        EmitterWriter { dst: Raw(dst) }\n+    pub fn new(dst: Box<Writer + Send>,\n+               registry: Option<diagnostics::registry::Registry>) -> EmitterWriter {\n+        EmitterWriter { dst: Raw(dst), registry: registry }\n     }\n }\n \n@@ -324,11 +358,10 @@ impl Writer for Destination {\n impl Emitter for EmitterWriter {\n     fn emit(&mut self,\n             cmsp: Option<(&codemap::CodeMap, Span)>,\n-            msg: &str,\n-            lvl: Level) {\n+            msg: &str, code: Option<&str>, lvl: Level) {\n         let error = match cmsp {\n-            Some((cm, sp)) => emit(self, cm, FullSpan(sp), msg, lvl, false),\n-            None => print_diagnostic(self, \"\", lvl, msg),\n+            Some((cm, sp)) => emit(self, cm, FullSpan(sp), msg, code, lvl, false),\n+            None => print_diagnostic(self, \"\", lvl, msg, code),\n         };\n \n         match error {\n@@ -339,15 +372,15 @@ impl Emitter for EmitterWriter {\n \n     fn custom_emit(&mut self, cm: &codemap::CodeMap,\n                    sp: RenderSpan, msg: &str, lvl: Level) {\n-        match emit(self, cm, sp, msg, lvl, true) {\n+        match emit(self, cm, sp, msg, None, lvl, true) {\n             Ok(()) => {}\n             Err(e) => fail!(\"failed to print diagnostics: {}\", e),\n         }\n     }\n }\n \n fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n-        msg: &str, lvl: Level, custom: bool) -> io::IoResult<()> {\n+        msg: &str, code: Option<&str>, lvl: Level, custom: bool) -> io::IoResult<()> {\n     let sp = rsp.span();\n     let ss = cm.span_to_string(sp);\n     let lines = cm.span_to_lines(sp);\n@@ -357,12 +390,12 @@ fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n         // the span)\n         let span_end = Span { lo: sp.hi, hi: sp.hi, expn_info: sp.expn_info};\n         let ses = cm.span_to_string(span_end);\n-        try!(print_diagnostic(dst, ses.as_slice(), lvl, msg));\n+        try!(print_diagnostic(dst, ses.as_slice(), lvl, msg, code));\n         if rsp.is_full_span() {\n             try!(custom_highlight_lines(dst, cm, sp, lvl, lines));\n         }\n     } else {\n-        try!(print_diagnostic(dst, ss.as_slice(), lvl, msg));\n+        try!(print_diagnostic(dst, ss.as_slice(), lvl, msg, code));\n         if rsp.is_full_span() {\n             try!(highlight_lines(dst, cm, sp, lvl, lines));\n         }\n@@ -501,9 +534,9 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n         try!(print_diagnostic(w, ss.as_slice(), Note,\n                               format!(\"in expansion of {}{}{}\", pre,\n                                       ei.callee.name,\n-                                      post).as_slice()));\n+                                      post).as_slice(), None));\n         let ss = cm.span_to_string(ei.call_site);\n-        try!(print_diagnostic(w, ss.as_slice(), Note, \"expansion site\"));\n+        try!(print_diagnostic(w, ss.as_slice(), Note, \"expansion site\", None));\n         try!(print_macro_backtrace(w, cm, ei.call_site));\n     }\n     Ok(())"}, {"sha": "b0260e1180f8f89b655e59749b758b0ef3d63dfe", "filename": "src/libsyntax/diagnostics/macros.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![macro_escape]\n+\n+// NOTE: remove after next snapshot\n+#[cfg(stage0)]\n+#[macro_export]\n+macro_rules! __register_diagnostic(\n+    ($code:tt, $description:tt) => ();\n+    ($code:tt) => ()\n+)\n+\n+#[macro_export]\n+macro_rules! register_diagnostic(\n+    ($code:tt, $description:tt) => (__register_diagnostic!($code, $description));\n+    ($code:tt) => (__register_diagnostic!($code))\n+)\n+\n+// NOTE: remove after next snapshot\n+#[cfg(stage0)]\n+#[macro_export]\n+macro_rules! __build_diagnostic_array(\n+    ($name:ident) => {\n+        pub static $name: [(&'static str, &'static str), ..0] = [];\n+    }\n+)\n+\n+// NOTE: remove after next snapshot\n+#[cfg(stage0)]\n+#[macro_export]\n+macro_rules! __diagnostic_used(\n+    ($code:ident) => {\n+        ()\n+    }\n+)\n+\n+#[macro_export]\n+macro_rules! span_err(\n+    ($session:expr, $span:expr, $code:ident, $($arg:expr),*) => ({\n+        __diagnostic_used!($code);\n+        ($session).span_err_with_code($span, format!($($arg),*).as_slice(), stringify!($code))\n+    })\n+)"}, {"sha": "6582d2e44c8e391c3f0e4b9c43a1d431931210dd", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -0,0 +1,132 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::RefCell;\n+use std::collections::HashMap;\n+use std::gc::Gc;\n+use ast;\n+use ast::{Ident, Name, TokenTree};\n+use codemap::Span;\n+use ext::base::{ExtCtxt, MacExpr, MacItem, MacResult};\n+use ext::build::AstBuilder;\n+use parse::token;\n+\n+local_data_key!(registered_diagnostics: RefCell<HashMap<Name, Option<Name>>>)\n+local_data_key!(used_diagnostics: RefCell<HashMap<Name, Span>>)\n+\n+fn with_registered_diagnostics<T>(f: |&mut HashMap<Name, Option<Name>>| -> T) -> T {\n+    match registered_diagnostics.get() {\n+        Some(cell) => f(cell.borrow_mut().deref_mut()),\n+        None => {\n+            let mut map = HashMap::new();\n+            let value = f(&mut map);\n+            registered_diagnostics.replace(Some(RefCell::new(map)));\n+            value\n+        }\n+    }\n+}\n+\n+fn with_used_diagnostics<T>(f: |&mut HashMap<Name, Span>| -> T) -> T {\n+    match used_diagnostics.get() {\n+        Some(cell) => f(cell.borrow_mut().deref_mut()),\n+        None => {\n+            let mut map = HashMap::new();\n+            let value = f(&mut map);\n+            used_diagnostics.replace(Some(RefCell::new(map)));\n+            value\n+        }\n+    }\n+}\n+\n+pub fn expand_diagnostic_used(ecx: &mut ExtCtxt, span: Span,\n+                              token_tree: &[TokenTree]) -> Box<MacResult> {\n+    let code = match token_tree {\n+        [ast::TTTok(_, token::IDENT(code, _))] => code,\n+        _ => unreachable!()\n+    };\n+    with_registered_diagnostics(|diagnostics| {\n+        if !diagnostics.contains_key(&code.name) {\n+            ecx.span_err(span, format!(\n+                \"unknown diagnostic code {}\", token::get_ident(code).get()\n+            ).as_slice());\n+        }\n+        ()\n+    });\n+    with_used_diagnostics(|diagnostics| {\n+        match diagnostics.swap(code.name, span) {\n+            Some(previous_span) => {\n+                ecx.span_warn(span, format!(\n+                    \"diagnostic code {} already used\", token::get_ident(code).get()\n+                ).as_slice());\n+                ecx.span_note(previous_span, \"previous invocation\");\n+            },\n+            None => ()\n+        }\n+        ()\n+    });\n+    MacExpr::new(quote_expr!(ecx, ()))\n+}\n+\n+pub fn expand_register_diagnostic(ecx: &mut ExtCtxt, span: Span,\n+                                  token_tree: &[TokenTree]) -> Box<MacResult> {\n+    let (code, description) = match token_tree {\n+        [ast::TTTok(_, token::IDENT(ref code, _))] => {\n+            (code, None)\n+        },\n+        [ast::TTTok(_, token::IDENT(ref code, _)),\n+         ast::TTTok(_, token::COMMA),\n+         ast::TTTok(_, token::LIT_STR_RAW(description, _))] => {\n+            (code, Some(description))\n+        }\n+        _ => unreachable!()\n+    };\n+    with_registered_diagnostics(|diagnostics| {\n+        if !diagnostics.insert(code.name, description) {\n+            ecx.span_err(span, format!(\n+                \"diagnostic code {} already registered\", token::get_ident(*code).get()\n+            ).as_slice());\n+        }\n+    });\n+    let sym = Ident::new(token::gensym((\n+        \"__register_diagnostic_\".to_string() + token::get_ident(*code).get()\n+    ).as_slice()));\n+    MacItem::new(quote_item!(ecx, mod $sym {}).unwrap())\n+}\n+\n+pub fn expand_build_diagnostic_array(ecx: &mut ExtCtxt, span: Span,\n+                                     token_tree: &[TokenTree]) -> Box<MacResult> {\n+    let name = match token_tree {\n+        [ast::TTTok(_, token::IDENT(ref name, _))] => name,\n+        _ => unreachable!()\n+    };\n+\n+    let (count, expr) = with_used_diagnostics(|diagnostics_in_use| {\n+        with_registered_diagnostics(|diagnostics| {\n+            let descriptions: Vec<Gc<ast::Expr>> = diagnostics\n+                .iter().filter_map(|(code, description)| {\n+                if !diagnostics_in_use.contains_key(code) {\n+                    ecx.span_warn(span, format!(\n+                        \"diagnostic code {} never used\", token::get_name(*code).get()\n+                    ).as_slice());\n+                }\n+                description.map(|description| {\n+                    ecx.expr_tuple(span, vec![\n+                        ecx.expr_str(span, token::get_name(*code)),\n+                        ecx.expr_str(span, token::get_name(description))\n+                    ])\n+                })\n+            }).collect();\n+            (descriptions.len(), ecx.expr_vec(span, descriptions))\n+        })\n+    });\n+    MacItem::new(quote_item!(ecx,\n+        pub static $name: [(&'static str, &'static str), ..$count] = $expr;\n+    ).unwrap())\n+}"}, {"sha": "7bc191df55af3d8482a538878580349b769eb520", "filename": "src/libsyntax/diagnostics/registry.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibsyntax%2Fdiagnostics%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibsyntax%2Fdiagnostics%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fregistry.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashMap;\n+\n+pub struct Registry {\n+    descriptions: HashMap<&'static str, &'static str>\n+}\n+\n+impl Registry {\n+    pub fn new(descriptions: &[(&'static str, &'static str)]) -> Registry {\n+        Registry { descriptions: descriptions.iter().map(|&tuple| tuple).collect() }\n+    }\n+\n+    pub fn find_description(&self, code: &str) -> Option<&'static str> {\n+        self.descriptions.find_equiv(&code).map(|desc| *desc)\n+    }\n+}"}, {"sha": "4d3913da3656a2c90e048c6276665be2a045f05b", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -148,6 +148,8 @@ pub trait AstBuilder {\n     fn expr_some(&self, sp: Span, expr: Gc<ast::Expr>) -> Gc<ast::Expr>;\n     fn expr_none(&self, sp: Span) -> Gc<ast::Expr>;\n \n+    fn expr_tuple(&self, sp: Span, exprs: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr>;\n+\n     fn expr_fail(&self, span: Span, msg: InternedString) -> Gc<ast::Expr>;\n     fn expr_unreachable(&self, span: Span) -> Gc<ast::Expr>;\n \n@@ -674,6 +676,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_path(none)\n     }\n \n+    fn expr_tuple(&self, sp: Span, exprs: Vec<Gc<ast::Expr>>) -> Gc<ast::Expr> {\n+        self.expr(sp, ast::ExprTup(exprs))\n+    }\n+\n     fn expr_fail(&self, span: Span, msg: InternedString) -> Gc<ast::Expr> {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         self.expr_call_global("}, {"sha": "b5f7005c2a3e005f2fdca7153e0260596456701d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -58,7 +58,7 @@ pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n                         None => {\n                             fld.cx.span_err(\n                                 pth.span,\n-                                format!(\"macro undefined: '{}'\",\n+                                format!(\"macro undefined: '{}!'\",\n                                         extnamestr.get()).as_slice());\n \n                             // let compilation continue\n@@ -567,7 +567,7 @@ fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<Gc<Stmt>> {\n     let marked_after = match fld.extsbox.find(&extname.name) {\n         None => {\n             fld.cx.span_err(pth.span,\n-                            format!(\"macro undefined: '{}'\",\n+                            format!(\"macro undefined: '{}!'\",\n                                     extnamestr).as_slice());\n             return SmallVector::zero();\n         }"}, {"sha": "184ce39aaf2a27749285a8d46174ab770176d638", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -27,12 +27,11 @@\n #![feature(quote, unsafe_destructor)]\n #![allow(deprecated)]\n \n-extern crate serialize;\n-extern crate term;\n-#[phase(plugin, link)] extern crate log;\n-\n extern crate fmt_macros;\n extern crate debug;\n+#[phase(plugin, link)] extern crate log;\n+extern crate serialize;\n+extern crate term;\n \n pub mod util {\n     pub mod interner;\n@@ -41,26 +40,30 @@ pub mod util {\n     pub mod small_vector;\n }\n \n+pub mod diagnostics {\n+    pub mod macros;\n+    pub mod plugin;\n+    pub mod registry;\n+}\n+\n pub mod syntax {\n     pub use ext;\n     pub use parse;\n     pub use ast;\n }\n \n-pub mod owned_slice;\n-pub mod attr;\n-pub mod diagnostic;\n-pub mod codemap;\n pub mod abi;\n pub mod ast;\n-pub mod ast_util;\n pub mod ast_map;\n-pub mod visit;\n+pub mod ast_util;\n+pub mod attr;\n+pub mod codemap;\n+pub mod crateid;\n+pub mod diagnostic;\n pub mod fold;\n-\n-\n+pub mod owned_slice;\n pub mod parse;\n-pub mod crateid;\n+pub mod visit;\n \n pub mod print {\n     pub mod pp;\n@@ -70,31 +73,25 @@ pub mod print {\n pub mod ext {\n     pub mod asm;\n     pub mod base;\n+    pub mod build;\n+    pub mod bytes;\n+    pub mod cfg;\n+    pub mod concat;\n+    pub mod concat_idents;\n+    pub mod deriving;\n+    pub mod env;\n     pub mod expand;\n-\n+    pub mod fmt;\n+    pub mod format;\n+    pub mod log_syntax;\n+    pub mod mtwt;\n     pub mod quote;\n-\n-    pub mod deriving;\n-\n-    pub mod build;\n+    pub mod source_util;\n+    pub mod trace_macros;\n \n     pub mod tt {\n         pub mod transcribe;\n         pub mod macro_parser;\n         pub mod macro_rules;\n     }\n-\n-    pub mod mtwt;\n-\n-    pub mod cfg;\n-    pub mod fmt;\n-    pub mod format;\n-    pub mod env;\n-    pub mod bytes;\n-    pub mod concat;\n-    pub mod concat_idents;\n-    pub mod log_syntax;\n-    pub mod source_util;\n-\n-    pub mod trace_macros;\n }"}, {"sha": "5c5943f0cd47c10e5fd461800b0ffbae3024a978", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -1308,7 +1308,7 @@ mod test {\n     use std::io::util;\n \n     fn mk_sh() -> diagnostic::SpanHandler {\n-        let emitter = diagnostic::EmitterWriter::new(box util::NullWriter);\n+        let emitter = diagnostic::EmitterWriter::new(box util::NullWriter, None);\n         let handler = diagnostic::mk_handler(box emitter);\n         diagnostic::mk_span_handler(handler, CodeMap::new())\n     }"}, {"sha": "a3e169cd5116d53c0c22834e70ea6c85c8ca33d1", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -40,7 +40,7 @@ pub struct ParseSess {\n \n pub fn new_parse_sess() -> ParseSess {\n     ParseSess {\n-        span_diagnostic: mk_span_handler(default_handler(Auto), CodeMap::new()),\n+        span_diagnostic: mk_span_handler(default_handler(Auto, None), CodeMap::new()),\n         included_mod_stack: RefCell::new(Vec::new()),\n     }\n }"}, {"sha": "6a3b0b91ffe297ed9d24f03a8d685f687c0c344e", "filename": "src/test/compile-fail-fulldeps/macro-crate-unexported-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -18,5 +18,5 @@\n extern crate macro_crate_test;\n \n fn main() {\n-    assert_eq!(3, unexported_macro!()); //~ ERROR macro undefined: 'unexported_macro'\n+    assert_eq!(3, unexported_macro!()); //~ ERROR macro undefined: 'unexported_macro!'\n }"}, {"sha": "09cf9739614040679a39ddb73be474e7b7d50b71", "filename": "src/test/compile-fail/issue-11692.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Ftest%2Fcompile-fail%2Fissue-11692.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Ftest%2Fcompile-fail%2Fissue-11692.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11692.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -10,9 +10,9 @@\n \n fn main() {\n     print!(test!());\n-    //~^ ERROR: macro undefined: 'test'\n+    //~^ ERROR: macro undefined: 'test!'\n     //~^^ ERROR: format argument must be a string literal\n \n     concat!(test!());\n-    //~^ ERROR: macro undefined: 'test'\n+    //~^ ERROR: macro undefined: 'test!'\n }"}, {"sha": "55d836092fa710a2f95befdd2ae43c7d0071f100", "filename": "src/test/compile-fail/rustc-diagnostics-1.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Ftest%2Fcompile-fail%2Frustc-diagnostics-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Ftest%2Fcompile-fail%2Frustc-diagnostics-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frustc-diagnostics-1.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_diagnostic_macros)]\n+\n+__register_diagnostic!(E0001)\n+__register_diagnostic!(E0003)\n+\n+fn main() {\n+    __diagnostic_used!(E0002);\n+    //~^ ERROR unknown diagnostic code E0002\n+\n+    __diagnostic_used!(E0001);\n+    //~^ NOTE previous invocation\n+\n+    __diagnostic_used!(E0001);\n+    //~^ WARNING diagnostic code E0001 already used\n+}\n+\n+__build_diagnostic_array!(DIAGNOSTICS)\n+//~^ WARN diagnostic code E0003 never used"}, {"sha": "c4e011bcea042162096ea6f10399b7b8e9d92872", "filename": "src/test/compile-fail/rustc-diagnostics-2.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Ftest%2Fcompile-fail%2Frustc-diagnostics-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Ftest%2Fcompile-fail%2Frustc-diagnostics-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frustc-diagnostics-2.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_diagnostic_macros)]\n+\n+__register_diagnostic!(E0001)\n+__register_diagnostic!(E0001)\n+//~^ ERROR diagnostic code E0001 already registered\n+\n+fn main() {\n+}\n+\n+__build_diagnostic_array!(DIAGNOSTICS)"}, {"sha": "d160664a48c780e2e18d48662c153f8a967e97cb", "filename": "src/test/compile-fail/rustc-diagnostics-3.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Ftest%2Fcompile-fail%2Frustc-diagnostics-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6/src%2Ftest%2Fcompile-fail%2Frustc-diagnostics-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frustc-diagnostics-3.rs?ref=0e80dbe59ea986ea53cc3caabffd40b2eaee4dc6", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+__register_diagnostic!(E0001)\n+//~^ ERROR macro undefined: '__register_diagnostic!'\n+\n+fn main() {\n+    __diagnostic_used!(E0001);\n+    //~^ ERROR macro undefined: '__diagnostic_used!'\n+}\n+\n+__build_diagnostic_array!(DIAGNOSTICS)\n+//~^ ERROR macro undefined: '__build_diagnostic_array!'"}]}