{"sha": "f75f440bbf98a6a419240ce9cc1c82f13e37b76f", "node_id": "C_kwDOAAsO6NoAKGY3NWY0NDBiYmY5OGE2YTQxOTI0MGNlOWNjMWM4MmYxM2UzN2I3NmY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-02T22:05:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-02T22:05:27Z"}, "message": "Rollup merge of #108022 - CraftSpider:align-bytes, r=oli-obk\n\nSupport allocations with non-Box<[u8]> bytes\n\nThis is prep work for allowing miri to support passing pointers to C code, which will require `Allocation`s to be correctly aligned. Currently, it just makes `Allocation` generic and plumbs the necessary changes through the right places.\n\nThe follow-up to this will be adding a type in the miri interpreter which correctly aligns the bytes, using that for the Miri engine, then allowing Miri to pass pointers into these allocations to C calls.\n\nBased off of #100467, credit to ```@emarteca``` for the code", "tree": {"sha": "06ede899a7e08224de9ec62055dc1245b81cf8ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06ede899a7e08224de9ec62055dc1245b81cf8ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f75f440bbf98a6a419240ce9cc1c82f13e37b76f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkAR2nCRBK7hj4Ov3rIwAAXsAIAFd7NUZqO21YetecMGYIOqmR\nWDfsLySSQcJFku/oRKrgHvjhFH86WNVBasjAD7e3KXa4ZRDHmiJTC5CKS3Yd8str\ne+vVV3aeMdDCBf2z/qTg9S6Pf/ino3Pe2137f0p5Ny7mPsfmkusj1h6WTu4cDPou\nnOyN7gPbFIm7tRzq9VZsQL79Bi0PRF6KEzNExKDt48xqPsSSd59xVNNhgAPO1bSd\nxsmxvOUPRhkQxsYNKPJ77ooxM6jzdSr5qE9LPy8oVpaz2uGO48Eh72M2kqRjvh6e\nLj2VmKHDOliXBsRZocufcI7gxtXYsiizDqHZEowfuXj6jkbtZOgrstschPXVSwg=\n=pxkd\n-----END PGP SIGNATURE-----\n", "payload": "tree 06ede899a7e08224de9ec62055dc1245b81cf8ce\nparent 13471d3b2046cce78181dde6cfc146c09f55e29e\nparent f26b0a29487c6501fa4c14b9b43b3fa0228001ba\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1677794727 +0100\ncommitter GitHub <noreply@github.com> 1677794727 +0100\n\nRollup merge of #108022 - CraftSpider:align-bytes, r=oli-obk\n\nSupport allocations with non-Box<[u8]> bytes\n\nThis is prep work for allowing miri to support passing pointers to C code, which will require `Allocation`s to be correctly aligned. Currently, it just makes `Allocation` generic and plumbs the necessary changes through the right places.\n\nThe follow-up to this will be adding a type in the miri interpreter which correctly aligns the bytes, using that for the Miri engine, then allowing Miri to pass pointers into these allocations to C calls.\n\nBased off of #100467, credit to ```@emarteca``` for the code\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f75f440bbf98a6a419240ce9cc1c82f13e37b76f", "html_url": "https://github.com/rust-lang/rust/commit/f75f440bbf98a6a419240ce9cc1c82f13e37b76f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f75f440bbf98a6a419240ce9cc1c82f13e37b76f/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13471d3b2046cce78181dde6cfc146c09f55e29e", "url": "https://api.github.com/repos/rust-lang/rust/commits/13471d3b2046cce78181dde6cfc146c09f55e29e", "html_url": "https://github.com/rust-lang/rust/commit/13471d3b2046cce78181dde6cfc146c09f55e29e"}, {"sha": "f26b0a29487c6501fa4c14b9b43b3fa0228001ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/f26b0a29487c6501fa4c14b9b43b3fa0228001ba", "html_url": "https://github.com/rust-lang/rust/commit/f26b0a29487c6501fa4c14b9b43b3fa0228001ba"}], "stats": {"total": 178, "additions": 128, "deletions": 50}, "files": [{"sha": "92fa59aec6e5f0fc462beb0babf219d53f5026ee", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f75f440bbf98a6a419240ce9cc1c82f13e37b76f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f75f440bbf98a6a419240ce9cc1c82f13e37b76f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=f75f440bbf98a6a419240ce9cc1c82f13e37b76f", "patch": "@@ -16,8 +16,8 @@ use rustc_target::spec::abi::Abi as CallAbi;\n use crate::const_eval::CheckAlignment;\n \n use super::{\n-    AllocId, AllocRange, Allocation, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n-    MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar, StackPopUnwind,\n+    AllocBytes, AllocId, AllocRange, Allocation, ConstAllocation, Frame, ImmTy, InterpCx,\n+    InterpResult, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar, StackPopUnwind,\n };\n \n /// Data returned by Machine::stack_pop,\n@@ -105,10 +105,16 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Extra data stored in every allocation.\n     type AllocExtra: Debug + Clone + 'static;\n \n+    /// Type for the bytes of the allocation.\n+    type Bytes: AllocBytes + 'static;\n+\n     /// Memory's allocation map\n     type MemoryMap: AllocMap<\n             AllocId,\n-            (MemoryKind<Self::MemoryKind>, Allocation<Self::Provenance, Self::AllocExtra>),\n+            (\n+                MemoryKind<Self::MemoryKind>,\n+                Allocation<Self::Provenance, Self::AllocExtra, Self::Bytes>,\n+            ),\n         > + Default\n         + Clone;\n \n@@ -338,7 +344,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n-    ) -> InterpResult<'tcx, Cow<'b, Allocation<Self::Provenance, Self::AllocExtra>>>;\n+    ) -> InterpResult<'tcx, Cow<'b, Allocation<Self::Provenance, Self::AllocExtra, Self::Bytes>>>;\n \n     fn eval_inline_asm(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n@@ -459,6 +465,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n \n     type AllocExtra = ();\n     type FrameExtra = ();\n+    type Bytes = Box<[u8]>;\n \n     #[inline(always)]\n     fn use_addr_for_alignment_check(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {"}, {"sha": "a3764a7d142663d454030eac69b3a3eda82768cd", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f75f440bbf98a6a419240ce9cc1c82f13e37b76f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f75f440bbf98a6a419240ce9cc1c82f13e37b76f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=f75f440bbf98a6a419240ce9cc1c82f13e37b76f", "patch": "@@ -21,8 +21,9 @@ use rustc_target::abi::{Align, HasDataLayout, Size};\n use crate::const_eval::CheckAlignment;\n \n use super::{\n-    alloc_range, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg, GlobalAlloc, InterpCx,\n-    InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Provenance, Scalar,\n+    alloc_range, AllocBytes, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg,\n+    GlobalAlloc, InterpCx, InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Provenance,\n+    Scalar,\n };\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n@@ -114,16 +115,16 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n /// A reference to some allocation that was already bounds-checked for the given region\n /// and had the on-access machine hooks run.\n #[derive(Copy, Clone)]\n-pub struct AllocRef<'a, 'tcx, Prov: Provenance, Extra> {\n-    alloc: &'a Allocation<Prov, Extra>,\n+pub struct AllocRef<'a, 'tcx, Prov: Provenance, Extra, Bytes: AllocBytes = Box<[u8]>> {\n+    alloc: &'a Allocation<Prov, Extra, Bytes>,\n     range: AllocRange,\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n }\n /// A reference to some allocation that was already bounds-checked for the given region\n /// and had the on-access machine hooks run.\n-pub struct AllocRefMut<'a, 'tcx, Prov: Provenance, Extra> {\n-    alloc: &'a mut Allocation<Prov, Extra>,\n+pub struct AllocRefMut<'a, 'tcx, Prov: Provenance, Extra, Bytes: AllocBytes = Box<[u8]>> {\n+    alloc: &'a mut Allocation<Prov, Extra, Bytes>,\n     range: AllocRange,\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n@@ -483,7 +484,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         id: AllocId,\n         is_write: bool,\n-    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::Provenance, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::Provenance, M::AllocExtra, M::Bytes>>> {\n         let (alloc, def_id) = match self.tcx.try_get_global_alloc(id) {\n             Some(GlobalAlloc::Memory(mem)) => {\n                 // Memory of a constant or promoted or anonymous memory referenced by a static.\n@@ -526,14 +527,25 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         )\n     }\n \n+    /// Get the base address for the bytes in an `Allocation` specified by the\n+    /// `AllocID` passed in; error if no such allocation exists.\n+    ///\n+    /// It is up to the caller to take sufficient care when using this address:\n+    /// there could be provenance or uninit memory in there, and other memory\n+    /// accesses could invalidate the exposed pointer.\n+    pub fn alloc_base_addr(&self, id: AllocId) -> InterpResult<'tcx, *const u8> {\n+        let alloc = self.get_alloc_raw(id)?;\n+        Ok(alloc.base_addr())\n+    }\n+\n     /// Gives raw access to the `Allocation`, without bounds or alignment checks.\n     /// The caller is responsible for calling the access hooks!\n     ///\n     /// You almost certainly want to use `get_ptr_alloc`/`get_ptr_alloc_mut` instead.\n     fn get_alloc_raw(\n         &self,\n         id: AllocId,\n-    ) -> InterpResult<'tcx, &Allocation<M::Provenance, M::AllocExtra>> {\n+    ) -> InterpResult<'tcx, &Allocation<M::Provenance, M::AllocExtra, M::Bytes>> {\n         // The error type of the inner closure here is somewhat funny. We have two\n         // ways of \"erroring\": An actual error, or because we got a reference from\n         // `get_global_alloc` that we can actually use directly without inserting anything anywhere.\n@@ -569,7 +581,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ptr: Pointer<Option<M::Provenance>>,\n         size: Size,\n         align: Align,\n-    ) -> InterpResult<'tcx, Option<AllocRef<'a, 'tcx, M::Provenance, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Option<AllocRef<'a, 'tcx, M::Provenance, M::AllocExtra, M::Bytes>>>\n+    {\n         let ptr_and_alloc = self.check_and_deref_ptr(\n             ptr,\n             size,\n@@ -612,7 +625,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn get_alloc_raw_mut(\n         &mut self,\n         id: AllocId,\n-    ) -> InterpResult<'tcx, (&mut Allocation<M::Provenance, M::AllocExtra>, &mut M)> {\n+    ) -> InterpResult<'tcx, (&mut Allocation<M::Provenance, M::AllocExtra, M::Bytes>, &mut M)> {\n         // We have \"NLL problem case #3\" here, which cannot be worked around without loss of\n         // efficiency even for the common case where the key is in the map.\n         // <https://rust-lang.github.io/rfcs/2094-nll.html#problem-case-3-conditional-control-flow-across-functions>\n@@ -641,7 +654,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ptr: Pointer<Option<M::Provenance>>,\n         size: Size,\n         align: Align,\n-    ) -> InterpResult<'tcx, Option<AllocRefMut<'a, 'tcx, M::Provenance, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Option<AllocRefMut<'a, 'tcx, M::Provenance, M::AllocExtra, M::Bytes>>>\n+    {\n         let parts = self.get_ptr_access(ptr, size, align)?;\n         if let Some((alloc_id, offset, prov)) = parts {\n             let tcx = *self.tcx;\n@@ -840,11 +854,11 @@ pub struct DumpAllocs<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a, 'mir, 'tcx, M> {\n     fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         // Cannot be a closure because it is generic in `Prov`, `Extra`.\n-        fn write_allocation_track_relocs<'tcx, Prov: Provenance, Extra>(\n+        fn write_allocation_track_relocs<'tcx, Prov: Provenance, Extra, Bytes: AllocBytes>(\n             fmt: &mut std::fmt::Formatter<'_>,\n             tcx: TyCtxt<'tcx>,\n             allocs_to_print: &mut VecDeque<AllocId>,\n-            alloc: &Allocation<Prov, Extra>,\n+            alloc: &Allocation<Prov, Extra, Bytes>,\n         ) -> std::fmt::Result {\n             for alloc_id in alloc.provenance().provenances().filter_map(|prov| prov.get_alloc_id())\n             {\n@@ -912,7 +926,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n }\n \n /// Reading and writing.\n-impl<'tcx, 'a, Prov: Provenance, Extra> AllocRefMut<'a, 'tcx, Prov, Extra> {\n+impl<'tcx, 'a, Prov: Provenance, Extra, Bytes: AllocBytes>\n+    AllocRefMut<'a, 'tcx, Prov, Extra, Bytes>\n+{\n     /// `range` is relative to this allocation reference, not the base of the allocation.\n     pub fn write_scalar(&mut self, range: AllocRange, val: Scalar<Prov>) -> InterpResult<'tcx> {\n         let range = self.range.subrange(range);\n@@ -937,7 +953,7 @@ impl<'tcx, 'a, Prov: Provenance, Extra> AllocRefMut<'a, 'tcx, Prov, Extra> {\n     }\n }\n \n-impl<'tcx, 'a, Prov: Provenance, Extra> AllocRef<'a, 'tcx, Prov, Extra> {\n+impl<'tcx, 'a, Prov: Provenance, Extra, Bytes: AllocBytes> AllocRef<'a, 'tcx, Prov, Extra, Bytes> {\n     /// `range` is relative to this allocation reference, not the base of the allocation.\n     pub fn read_scalar(\n         &self,"}, {"sha": "3c463500a609e1f7c12cd3a9cad823144f8c4c32", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f75f440bbf98a6a419240ce9cc1c82f13e37b76f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f75f440bbf98a6a419240ce9cc1c82f13e37b76f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=f75f440bbf98a6a419240ce9cc1c82f13e37b76f", "patch": "@@ -353,7 +353,8 @@ where\n     pub(super) fn get_place_alloc(\n         &self,\n         place: &MPlaceTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, Option<AllocRef<'_, 'tcx, M::Provenance, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Option<AllocRef<'_, 'tcx, M::Provenance, M::AllocExtra, M::Bytes>>>\n+    {\n         assert!(place.layout.is_sized());\n         assert!(!place.meta.has_meta());\n         let size = place.layout.size;\n@@ -364,7 +365,8 @@ where\n     pub(super) fn get_place_alloc_mut(\n         &mut self,\n         place: &MPlaceTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, Option<AllocRefMut<'_, 'tcx, M::Provenance, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Option<AllocRefMut<'_, 'tcx, M::Provenance, M::AllocExtra, M::Bytes>>>\n+    {\n         assert!(place.layout.is_sized());\n         assert!(!place.meta.has_meta());\n         let size = place.layout.size;"}, {"sha": "48375ed301d22cd3331e88e91ed05787b88e2087", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 67, "deletions": 15, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/f75f440bbf98a6a419240ce9cc1c82f13e37b76f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f75f440bbf98a6a419240ce9cc1c82f13e37b76f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=f75f440bbf98a6a419240ce9cc1c82f13e37b76f", "patch": "@@ -8,7 +8,8 @@ mod tests;\n use std::borrow::Cow;\n use std::fmt;\n use std::hash;\n-use std::ops::Range;\n+use std::hash::Hash;\n+use std::ops::{Deref, DerefMut, Range};\n use std::ptr;\n \n use either::{Left, Right};\n@@ -29,6 +30,39 @@ use provenance_map::*;\n \n pub use init_mask::{InitChunk, InitChunkIter};\n \n+/// Functionality required for the bytes of an `Allocation`.\n+pub trait AllocBytes:\n+    Clone + fmt::Debug + Eq + PartialEq + Hash + Deref<Target = [u8]> + DerefMut<Target = [u8]>\n+{\n+    /// Adjust the bytes to the specified alignment -- by default, this is a no-op.\n+    fn adjust_to_align(self, _align: Align) -> Self;\n+\n+    /// Create an `AllocBytes` from a slice of `u8`.\n+    fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, _align: Align) -> Self;\n+\n+    /// Create a zeroed `AllocBytes` of the specified size and alignment;\n+    /// call the callback error handler if there is an error in allocating the memory.\n+    fn zeroed(size: Size, _align: Align) -> Option<Self>;\n+}\n+\n+// Default `bytes` for `Allocation` is a `Box<[u8]>`.\n+impl AllocBytes for Box<[u8]> {\n+    fn adjust_to_align(self, _align: Align) -> Self {\n+        self\n+    }\n+\n+    fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, _align: Align) -> Self {\n+        Box::<[u8]>::from(slice.into())\n+    }\n+\n+    fn zeroed(size: Size, _align: Align) -> Option<Self> {\n+        let bytes = Box::<[u8]>::try_new_zeroed_slice(size.bytes_usize()).ok()?;\n+        // SAFETY: the box was zero-allocated, which is a valid initial value for Box<[u8]>\n+        let bytes = unsafe { bytes.assume_init() };\n+        Some(bytes)\n+    }\n+}\n+\n /// This type represents an Allocation in the Miri/CTFE core engine.\n ///\n /// Its public API is rather low-level, working directly with allocation offsets and a custom error\n@@ -38,10 +72,10 @@ pub use init_mask::{InitChunk, InitChunkIter};\n // hashed. (see the `Hash` impl below for more details), so the impl is not derived.\n #[derive(Clone, Eq, PartialEq, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n-pub struct Allocation<Prov: Provenance = AllocId, Extra = ()> {\n+pub struct Allocation<Prov: Provenance = AllocId, Extra = (), Bytes = Box<[u8]>> {\n     /// The actual bytes of the allocation.\n     /// Note that the bytes of a pointer represent the offset of the pointer.\n-    bytes: Box<[u8]>,\n+    bytes: Bytes,\n     /// Maps from byte addresses to extra provenance data for each pointer.\n     /// Only the first byte of a pointer is inserted into the map; i.e.,\n     /// every entry in this map applies to `pointer_size` consecutive bytes starting\n@@ -220,14 +254,27 @@ impl AllocRange {\n }\n \n // The constructors are all without extra; the extra gets added by a machine hook later.\n-impl<Prov: Provenance> Allocation<Prov> {\n+impl<Prov: Provenance, Bytes: AllocBytes> Allocation<Prov, (), Bytes> {\n+    /// Creates an allocation from an existing `Bytes` value - this is needed for miri FFI support\n+    pub fn from_raw_bytes(bytes: Bytes, align: Align, mutability: Mutability) -> Self {\n+        let size = Size::from_bytes(bytes.len());\n+        Self {\n+            bytes,\n+            provenance: ProvenanceMap::new(),\n+            init_mask: InitMask::new(size, true),\n+            align,\n+            mutability,\n+            extra: (),\n+        }\n+    }\n+\n     /// Creates an allocation initialized by the given bytes\n     pub fn from_bytes<'a>(\n         slice: impl Into<Cow<'a, [u8]>>,\n         align: Align,\n         mutability: Mutability,\n     ) -> Self {\n-        let bytes = Box::<[u8]>::from(slice.into());\n+        let bytes = Bytes::from_bytes(slice, align);\n         let size = Size::from_bytes(bytes.len());\n         Self {\n             bytes,\n@@ -248,7 +295,7 @@ impl<Prov: Provenance> Allocation<Prov> {\n     ///\n     /// If `panic_on_fail` is true, this will never return `Err`.\n     pub fn uninit<'tcx>(size: Size, align: Align, panic_on_fail: bool) -> InterpResult<'tcx, Self> {\n-        let bytes = Box::<[u8]>::try_new_zeroed_slice(size.bytes_usize()).map_err(|_| {\n+        let bytes = Bytes::zeroed(size, align).ok_or_else(|| {\n             // This results in an error that can happen non-deterministically, since the memory\n             // available to the compiler can change between runs. Normally queries are always\n             // deterministic. However, we can be non-deterministic here because all uses of const\n@@ -262,8 +309,7 @@ impl<Prov: Provenance> Allocation<Prov> {\n             });\n             InterpError::ResourceExhaustion(ResourceExhaustionInfo::MemoryExhausted)\n         })?;\n-        // SAFETY: the box was zero-allocated, which is a valid initial value for Box<[u8]>\n-        let bytes = unsafe { bytes.assume_init() };\n+\n         Ok(Allocation {\n             bytes,\n             provenance: ProvenanceMap::new(),\n@@ -275,17 +321,19 @@ impl<Prov: Provenance> Allocation<Prov> {\n     }\n }\n \n-impl Allocation {\n+impl<Bytes: AllocBytes> Allocation<AllocId, (), Bytes> {\n     /// Adjust allocation from the ones in tcx to a custom Machine instance\n     /// with a different Provenance and Extra type.\n     pub fn adjust_from_tcx<Prov: Provenance, Extra, Err>(\n         self,\n         cx: &impl HasDataLayout,\n         extra: Extra,\n         mut adjust_ptr: impl FnMut(Pointer<AllocId>) -> Result<Pointer<Prov>, Err>,\n-    ) -> Result<Allocation<Prov, Extra>, Err> {\n-        // Compute new pointer provenance, which also adjusts the bytes.\n-        let mut bytes = self.bytes;\n+    ) -> Result<Allocation<Prov, Extra, Bytes>, Err> {\n+        // Compute new pointer provenance, which also adjusts the bytes, and realign the pointer if\n+        // necessary.\n+        let mut bytes = self.bytes.adjust_to_align(self.align);\n+\n         let mut new_provenance = Vec::with_capacity(self.provenance.ptrs().len());\n         let ptr_size = cx.data_layout().pointer_size.bytes_usize();\n         let endian = cx.data_layout().endian;\n@@ -311,7 +359,7 @@ impl Allocation {\n }\n \n /// Raw accessors. Provide access to otherwise private bytes.\n-impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n+impl<Prov: Provenance, Extra, Bytes: AllocBytes> Allocation<Prov, Extra, Bytes> {\n     pub fn len(&self) -> usize {\n         self.bytes.len()\n     }\n@@ -340,7 +388,11 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n }\n \n /// Byte accessors.\n-impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n+impl<Prov: Provenance, Extra, Bytes: AllocBytes> Allocation<Prov, Extra, Bytes> {\n+    pub fn base_addr(&self) -> *const u8 {\n+        self.bytes.as_ptr()\n+    }\n+\n     /// This is the entirely abstraction-violating way to just grab the raw bytes without\n     /// caring about provenance or initialization.\n     ///\n@@ -412,7 +464,7 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n }\n \n /// Reading and writing.\n-impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n+impl<Prov: Provenance, Extra, Bytes: AllocBytes> Allocation<Prov, Extra, Bytes> {\n     /// Sets the init bit for the given range.\n     fn mark_init(&mut self, range: AllocRange, is_init: bool) {\n         if range.size.bytes() == 0 {"}, {"sha": "1766d7a66980461e51b54de99105b39dd89b74f9", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f75f440bbf98a6a419240ce9cc1c82f13e37b76f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f75f440bbf98a6a419240ce9cc1c82f13e37b76f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=f75f440bbf98a6a419240ce9cc1c82f13e37b76f", "patch": "@@ -127,8 +127,8 @@ pub use self::error::{\n pub use self::value::{get_slice_bytes, ConstAlloc, ConstValue, Scalar};\n \n pub use self::allocation::{\n-    alloc_range, AllocError, AllocRange, AllocResult, Allocation, ConstAllocation, InitChunk,\n-    InitChunkIter,\n+    alloc_range, AllocBytes, AllocError, AllocRange, AllocResult, Allocation, ConstAllocation,\n+    InitChunk, InitChunkIter,\n };\n \n pub use self::pointer::{Pointer, PointerArithmetic, Provenance};"}, {"sha": "d8829e3e782c5c40b931714cfa30d717cc9f9f55", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f75f440bbf98a6a419240ce9cc1c82f13e37b76f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f75f440bbf98a6a419240ce9cc1c82f13e37b76f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=f75f440bbf98a6a419240ce9cc1c82f13e37b76f", "patch": "@@ -12,8 +12,8 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{\n-    alloc_range, read_target_uint, AllocId, Allocation, ConstAllocation, ConstValue, GlobalAlloc,\n-    Pointer, Provenance,\n+    alloc_range, read_target_uint, AllocBytes, AllocId, Allocation, ConstAllocation, ConstValue,\n+    GlobalAlloc, Pointer, Provenance,\n };\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n@@ -787,21 +787,21 @@ pub fn write_allocations<'tcx>(\n /// After the hex dump, an ascii dump follows, replacing all unprintable characters (control\n /// characters or characters whose value is larger than 127) with a `.`\n /// This also prints provenance adequately.\n-pub fn display_allocation<'a, 'tcx, Prov: Provenance, Extra>(\n+pub fn display_allocation<'a, 'tcx, Prov: Provenance, Extra, Bytes: AllocBytes>(\n     tcx: TyCtxt<'tcx>,\n-    alloc: &'a Allocation<Prov, Extra>,\n-) -> RenderAllocation<'a, 'tcx, Prov, Extra> {\n+    alloc: &'a Allocation<Prov, Extra, Bytes>,\n+) -> RenderAllocation<'a, 'tcx, Prov, Extra, Bytes> {\n     RenderAllocation { tcx, alloc }\n }\n \n #[doc(hidden)]\n-pub struct RenderAllocation<'a, 'tcx, Prov: Provenance, Extra> {\n+pub struct RenderAllocation<'a, 'tcx, Prov: Provenance, Extra, Bytes: AllocBytes> {\n     tcx: TyCtxt<'tcx>,\n-    alloc: &'a Allocation<Prov, Extra>,\n+    alloc: &'a Allocation<Prov, Extra, Bytes>,\n }\n \n-impl<'a, 'tcx, Prov: Provenance, Extra> std::fmt::Display\n-    for RenderAllocation<'a, 'tcx, Prov, Extra>\n+impl<'a, 'tcx, Prov: Provenance, Extra, Bytes: AllocBytes> std::fmt::Display\n+    for RenderAllocation<'a, 'tcx, Prov, Extra, Bytes>\n {\n     fn fmt(&self, w: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         let RenderAllocation { tcx, alloc } = *self;\n@@ -845,9 +845,9 @@ fn write_allocation_newline(\n /// The `prefix` argument allows callers to add an arbitrary prefix before each line (even if there\n /// is only one line). Note that your prefix should contain a trailing space as the lines are\n /// printed directly after it.\n-fn write_allocation_bytes<'tcx, Prov: Provenance, Extra>(\n+fn write_allocation_bytes<'tcx, Prov: Provenance, Extra, Bytes: AllocBytes>(\n     tcx: TyCtxt<'tcx>,\n-    alloc: &Allocation<Prov, Extra>,\n+    alloc: &Allocation<Prov, Extra, Bytes>,\n     w: &mut dyn std::fmt::Write,\n     prefix: &str,\n ) -> std::fmt::Result {"}, {"sha": "969c81f7e32beefca931171b4758a32255bdd59f", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f75f440bbf98a6a419240ce9cc1c82f13e37b76f/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f75f440bbf98a6a419240ce9cc1c82f13e37b76f/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=f75f440bbf98a6a419240ce9cc1c82f13e37b76f", "patch": "@@ -777,10 +777,11 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n \n     type Provenance = Provenance;\n     type ProvenanceExtra = ProvenanceExtra;\n+    type Bytes = Box<[u8]>;\n \n     type MemoryMap = MonoHashMap<\n         AllocId,\n-        (MemoryKind<MiriMemoryKind>, Allocation<Provenance, Self::AllocExtra>),\n+        (MemoryKind<MiriMemoryKind>, Allocation<Provenance, Self::AllocExtra, Self::Bytes>),\n     >;\n \n     const GLOBAL_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::Global);"}]}