{"sha": "5d70a7fbe489b96272a25b3a75b5f2ef46a846a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNzBhN2ZiZTQ4OWI5NjI3MmEyNWIzYTc1YjVmMmVmNDZhODQ2YTM=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2017-02-01T03:10:35Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2017-02-10T17:42:39Z"}, "message": "AdtDef now contains discr_ty same as layouted", "tree": {"sha": "345a1f97daefc8afab47f70c200f57813a8789af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/345a1f97daefc8afab47f70c200f57813a8789af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d70a7fbe489b96272a25b3a75b5f2ef46a846a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d70a7fbe489b96272a25b3a75b5f2ef46a846a3", "html_url": "https://github.com/rust-lang/rust/commit/5d70a7fbe489b96272a25b3a75b5f2ef46a846a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d70a7fbe489b96272a25b3a75b5f2ef46a846a3/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24c93efbb58f6644a62c231916144cc0af55a503", "url": "https://api.github.com/repos/rust-lang/rust/commits/24c93efbb58f6644a62c231916144cc0af55a503", "html_url": "https://github.com/rust-lang/rust/commit/24c93efbb58f6644a62c231916144cc0af55a503"}], "stats": {"total": 95, "additions": 72, "deletions": 23}, "files": [{"sha": "8b76381a5861a468cee1e7c9b948806e4d10ec25", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d70a7fbe489b96272a25b3a75b5f2ef46a846a3/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5d70a7fbe489b96272a25b3a75b5f2ef46a846a3/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=5d70a7fbe489b96272a25b3a75b5f2ef46a846a3", "patch": "@@ -578,6 +578,7 @@ dependencies = [\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"rustc_platform_intrinsics 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\","}, {"sha": "b61849abe689dcfafa0e3aa45a90714ccfbf6f52", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 57, "deletions": 9, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/5d70a7fbe489b96272a25b3a75b5f2ef46a846a3/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d70a7fbe489b96272a25b3a75b5f2ef46a846a3/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=5d70a7fbe489b96272a25b3a75b5f2ef46a846a3", "patch": "@@ -382,6 +382,23 @@ impl Integer {\n         }\n     }\n \n+    pub fn to_attr(&self, signed: bool) -> attr::IntType {\n+        match (*self, signed) {\n+            (I1, false) => attr::IntType::UnsignedInt(UintTy::U8),\n+            (I8, false) => attr::IntType::UnsignedInt(UintTy::U8),\n+            (I16, false) => attr::IntType::UnsignedInt(UintTy::U16),\n+            (I32, false) => attr::IntType::UnsignedInt(UintTy::U32),\n+            (I64, false) => attr::IntType::UnsignedInt(UintTy::U64),\n+            (I128, false) => attr::IntType::UnsignedInt(UintTy::U128),\n+            (I1, true) => attr::IntType::SignedInt(IntTy::I8),\n+            (I8, true) => attr::IntType::SignedInt(IntTy::I8),\n+            (I16, true) => attr::IntType::SignedInt(IntTy::I16),\n+            (I32, true) => attr::IntType::SignedInt(IntTy::I32),\n+            (I64, true) => attr::IntType::SignedInt(IntTy::I64),\n+            (I128, true) => attr::IntType::SignedInt(IntTy::I128),\n+        }\n+    }\n+\n     /// Find the smallest Integer type which can represent the signed value.\n     pub fn fit_signed(x: i64) -> Integer {\n         match x {\n@@ -436,18 +453,24 @@ impl Integer {\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u64 values above i64::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n+<<<<<<< HEAD\n     fn repr_discr(tcx: TyCtxt, ty: Ty, repr: &ReprOptions, min: i64, max: i64)\n                       -> (Integer, bool) {\n+=======\n+    pub fn repr_discr(tcx: TyCtxt, hints: &[attr::ReprAttr], min: i128, max: i128)\n+    -> (Integer, bool) {\n+>>>>>>> cade130ae8... AdtDef now contains discr_ty same as layouted\n         // Theoretically, negative values could be larger in unsigned representation\n         // than the unsigned representation of the signed minimum. However, if there\n         // are any negative values, the only valid unsigned representation is u64\n         // which can fit all i64 values, so the result remains unaffected.\n-        let unsigned_fit = Integer::fit_unsigned(cmp::max(min as u64, max as u64));\n+        let unsigned_fit = Integer::fit_unsigned(cmp::max(min as u128, max as u128));\n         let signed_fit = cmp::max(Integer::fit_signed(min), Integer::fit_signed(max));\n \n         let mut min_from_extern = None;\n         let min_default = I8;\n \n+<<<<<<< HEAD\n         if let Some(ity) = repr.int {\n             let discr = Integer::from_attr(&tcx.data_layout, ity);\n             let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n@@ -466,11 +489,40 @@ impl Integer {\n                 // lower bound.  However, we don't run on those yet...?\n                 \"arm\" => min_from_extern = Some(I32),\n                 _ => min_from_extern = Some(I32),\n+=======\n+        for &r in hints.iter() {\n+            match r {\n+                attr::ReprInt(ity) => {\n+                    let discr = Integer::from_attr(&tcx.data_layout, ity);\n+                    let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n+                    if discr < fit {\n+                        bug!(\"Integer::repr_discr: `#[repr]` hint too small for \\\n+                              discriminant range of enum\")\n+                    }\n+                    return (discr, ity.is_signed());\n+                }\n+                attr::ReprExtern => {\n+                    match &tcx.sess.target.target.arch[..] {\n+                        // WARNING: the ARM EABI has two variants; the one corresponding\n+                        // to `at_least == I32` appears to be used on Linux and NetBSD,\n+                        // but some systems may use the variant corresponding to no\n+                        // lower bound.  However, we don't run on those yet...?\n+                        \"arm\" => min_from_extern = Some(I32),\n+                        _ => min_from_extern = Some(I32),\n+                    }\n+                }\n+                attr::ReprAny => {},\n+                attr::ReprPacked => {\n+                    bug!(\"Integer::repr_discr: found #[repr(packed)] on enum\");\n+                }\n+                attr::ReprSimd => {\n+                    bug!(\"Integer::repr_discr: found #[repr(simd)] on enum\");\n+                }\n+>>>>>>> cade130ae8... AdtDef now contains discr_ty same as layouted\n             }\n         }\n \n         let at_least = min_from_extern.unwrap_or(min_default);\n-\n         // If there are no negative values, we can use the unsigned fit.\n         if min >= 0 {\n             (cmp::max(unsigned_fit, at_least), false)\n@@ -1196,9 +1248,8 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n                     // FIXME: should handle i128? signed-value based impl is weird and hard to\n                     // grok.\n-                    let (discr, signed) = Integer::repr_discr(tcx, ty, &def.repr,\n-                                                              min,\n-                                                              max);\n+                    let discr = Integer::from_attr(&tcx.data_layout, def.discr_ty);\n+                    let signed = def.discr_ty.is_signed();\n                     return success(CEnum {\n                         discr: discr,\n                         signed: signed,\n@@ -1313,10 +1364,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 }\n \n                 // The general case.\n-                let discr_max = (variants.len() - 1) as i64;\n-                assert!(discr_max >= 0);\n-                let (min_ity, _) = Integer::repr_discr(tcx, ty, &def.repr, 0, discr_max);\n-\n+                let min_ity = Integer::from_attr(&tcx.data_layout, def.discr_ty);\n                 let mut align = dl.aggregate_align;\n                 let mut size = Size::from_bytes(0);\n "}, {"sha": "067893552427b0940b9f833f014fa246ee79dbd3", "filename": "src/librustc_typeck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d70a7fbe489b96272a25b3a75b5f2ef46a846a3/src%2Flibrustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5d70a7fbe489b96272a25b3a75b5f2ef46a846a3/src%2Flibrustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FCargo.toml?ref=5d70a7fbe489b96272a25b3a75b5f2ef46a846a3", "patch": "@@ -22,3 +22,4 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_errors = { path = \"../librustc_errors\" }\n+rustc_i128 = { path = \"../librustc_i128\" }"}, {"sha": "30bd22454e75407fda6b5ef560ce1210f49ce4e7", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5d70a7fbe489b96272a25b3a75b5f2ef46a846a3/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d70a7fbe489b96272a25b3a75b5f2ef46a846a3/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=5d70a7fbe489b96272a25b3a75b5f2ef46a846a3", "patch": "@@ -66,7 +66,7 @@ use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::{ConstContext, report_const_eval_err};\n use rustc::ty::subst::Substs;\n use rustc::ty::{ToPredicate, ImplContainer, AssociatedItemContainer, TraitContainer, ReprOptions};\n-use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n+use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt, layout};\n use rustc::ty::util::IntTypeExt;\n use rustc::dep_graph::DepNode;\n use util::common::{ErrorReported, MemoizationMap};\n@@ -86,6 +86,8 @@ use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n \n+use rustc_i128::i128;\n+\n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n \n@@ -1022,14 +1024,9 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 -> &'tcx ty::AdtDef\n {\n     let did = ccx.tcx.hir.local_def_id(it.id);\n-<<<<<<< HEAD\n-    let variants = vec![convert_struct_variant(ccx, did, it.name, ConstInt::Infer(0), def)];\n-\n-    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Union, variants, ReprOptions::new(&ccx.tcx, did));\n-=======\n     let variants = vec![convert_struct_variant(ccx, did, it.name, 0, def)];\n-    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Union, None, variants);\n->>>>>>> b1934037e6... Move type of discriminant to AdtDef\n+    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Union, None, variants,\n+                                    ReprOptions::new(&ccx.tcx, did));\n     ccx.tcx.adt_defs.borrow_mut().insert(did, adt);\n     adt\n }\n@@ -1097,9 +1094,11 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let repr_type = tcx.enum_repr_type(repr_hints.get(0));\n     let initial = repr_type.initial_discriminant(tcx);\n     let mut prev_disr = None::<ty::Disr>;\n+    let (mut min, mut max) = (i128::max_value(), i128::min_value());\n     let variants = def.variants.iter().map(|v| {\n         let wrapped_disr = prev_disr.map_or(initial, |d| d.wrapping_add(1));\n         let disr = if let Some(e) = v.node.disr_expr {\n+            // FIXME: i128 discriminants\n             evaluate_disr_expr(ccx, repr_type, e)\n         } else if let Some(disr) = repr_type.disr_incr(tcx, prev_disr) {\n             Some(disr)\n@@ -1113,16 +1112,14 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             None\n         }.unwrap_or(wrapped_disr);\n         prev_disr = Some(disr);\n-\n+        if (disr as i128) < min { min = disr as i128; }\n+        if (disr as i128) > max { max = disr as i128; }\n         let did = tcx.hir.local_def_id(v.node.data.id());\n         convert_struct_variant(ccx, did, v.node.name, disr, &v.node.data)\n     }).collect();\n \n-<<<<<<< HEAD\n-    let adt = tcx.alloc_adt_def(did, AdtKind::Enum, variants, ReprOptions::new(&ccx.tcx, did));\n-=======\n-    let adt = tcx.alloc_adt_def(did, AdtKind::Enum, Some(repr_type), variants);\n->>>>>>> b1934037e6... Move type of discriminant to AdtDef\n+    let adt = tcx.alloc_adt_def(did, AdtKind::Enum, Some(repr_int.to_attr(signed)), variants,\n+                                ReprOptions::new(&ccx.tcx, did));\n     tcx.adt_defs.borrow_mut().insert(did, adt);\n     adt\n }"}, {"sha": "aa2695b9553e7d72232fa1c3e4f45608eaef9469", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d70a7fbe489b96272a25b3a75b5f2ef46a846a3/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d70a7fbe489b96272a25b3a75b5f2ef46a846a3/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=5d70a7fbe489b96272a25b3a75b5f2ef46a846a3", "patch": "@@ -98,6 +98,8 @@ extern crate rustc_const_eval;\n extern crate rustc_data_structures;\n extern crate rustc_errors as errors;\n \n+extern crate rustc_i128;\n+\n pub use rustc::dep_graph;\n pub use rustc::hir;\n pub use rustc::lint;"}]}