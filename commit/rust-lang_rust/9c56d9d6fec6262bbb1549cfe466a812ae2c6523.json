{"sha": "9c56d9d6fec6262bbb1549cfe466a812ae2c6523", "node_id": "C_kwDOAAsO6NoAKDljNTZkOWQ2ZmVjNjI2MmJiYjE1NDljZmU0NjZhODEyYWUyYzY1MjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-29T19:52:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-29T19:52:48Z"}, "message": "Auto merge of #102482 - notriddle:rollup-fjm618g, r=notriddle\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #102214 (Fix span of byte-escaped left format args brace)\n - #102426 (Don't export `__wasm_init_memory` on WebAssembly.)\n - #102437 (rustdoc: cut margin-top from first header in docblock)\n - #102442 (rustdoc: remove bad CSS font-weight on `.impl`, `.method`, etc)\n - #102447 (rustdoc: add method spacing to trait methods)\n - #102468 (tidy: make rustc dependency error less confusing)\n - #102476 (Split out the error reporting logic into a separate function)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "fece705fa574e50248f1e758d7a04f27ade855da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fece705fa574e50248f1e758d7a04f27ade855da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c56d9d6fec6262bbb1549cfe466a812ae2c6523", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c56d9d6fec6262bbb1549cfe466a812ae2c6523", "html_url": "https://github.com/rust-lang/rust/commit/9c56d9d6fec6262bbb1549cfe466a812ae2c6523", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f1a21ae2bd41b3dd335c44f38f29a1fb8712ddc", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f1a21ae2bd41b3dd335c44f38f29a1fb8712ddc", "html_url": "https://github.com/rust-lang/rust/commit/9f1a21ae2bd41b3dd335c44f38f29a1fb8712ddc"}, {"sha": "98075708dde5b75e69d3294783c1f6abf5236dba", "url": "https://api.github.com/repos/rust-lang/rust/commits/98075708dde5b75e69d3294783c1f6abf5236dba", "html_url": "https://github.com/rust-lang/rust/commit/98075708dde5b75e69d3294783c1f6abf5236dba"}], "stats": {"total": 418, "additions": 243, "deletions": 175}, "files": [{"sha": "f59a753a5ceffb31025669d84b874c1acd6ed191", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=9c56d9d6fec6262bbb1549cfe466a812ae2c6523", "patch": "@@ -1180,18 +1180,12 @@ impl<'a> WasmLd<'a> {\n         //   sharing memory and instantiating the module multiple times. As a\n         //   result if it were exported then we'd just have no sharing.\n         //\n-        // * `--export=__wasm_init_memory` - when using `--passive-segments` the\n-        //   linker will synthesize this function, and so we need to make sure\n-        //   that our usage of `--export` below won't accidentally cause this\n-        //   function to get deleted.\n-        //\n         // * `--export=*tls*` - when `#[thread_local]` symbols are used these\n         //   symbols are how the TLS segments are initialized and configured.\n         if sess.target_features.contains(&sym::atomics) {\n             cmd.arg(\"--shared-memory\");\n             cmd.arg(\"--max-memory=1073741824\");\n             cmd.arg(\"--import-memory\");\n-            cmd.arg(\"--export=__wasm_init_memory\");\n             cmd.arg(\"--export=__wasm_init_tls\");\n             cmd.arg(\"--export=__tls_size\");\n             cmd.arg(\"--export=__tls_align\");"}, {"sha": "080771844a44c4bf40424ef95372a015f7f81d47", "filename": "compiler/rustc_hir_analysis/src/check/callee.rs", "status": "modified", "additions": 140, "deletions": 134, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcallee.rs?ref=9c56d9d6fec6262bbb1549cfe466a812ae2c6523", "patch": "@@ -394,140 +394,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             ty::FnPtr(sig) => (sig, None),\n             _ => {\n-                let mut unit_variant = None;\n-                if let hir::ExprKind::Path(qpath) = &callee_expr.kind\n-                    && let Res::Def(def::DefKind::Ctor(kind, def::CtorKind::Const), _)\n-                        = self.typeck_results.borrow().qpath_res(qpath, callee_expr.hir_id)\n-                    // Only suggest removing parens if there are no arguments\n-                    && arg_exprs.is_empty()\n-                {\n-                    let descr = match kind {\n-                        def::CtorOf::Struct => \"struct\",\n-                        def::CtorOf::Variant => \"enum variant\",\n-                    };\n-                    let removal_span =\n-                        callee_expr.span.shrink_to_hi().to(call_expr.span.shrink_to_hi());\n-                    unit_variant =\n-                        Some((removal_span, descr, rustc_hir_pretty::qpath_to_string(qpath)));\n-                }\n-\n-                let callee_ty = self.resolve_vars_if_possible(callee_ty);\n-                let mut err = type_error_struct!(\n-                    self.tcx.sess,\n-                    callee_expr.span,\n-                    callee_ty,\n-                    E0618,\n-                    \"expected function, found {}\",\n-                    match &unit_variant {\n-                        Some((_, kind, path)) => format!(\"{kind} `{path}`\"),\n-                        None => format!(\"`{callee_ty}`\"),\n-                    }\n-                );\n-\n-                self.identify_bad_closure_def_and_call(\n-                    &mut err,\n-                    call_expr.hir_id,\n-                    &callee_expr.kind,\n-                    callee_expr.span,\n-                );\n-\n-                if let Some((removal_span, kind, path)) = &unit_variant {\n-                    err.span_suggestion_verbose(\n-                        *removal_span,\n-                        &format!(\n-                            \"`{path}` is a unit {kind}, and does not take parentheses to be constructed\",\n-                        ),\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-\n-                let mut inner_callee_path = None;\n-                let def = match callee_expr.kind {\n-                    hir::ExprKind::Path(ref qpath) => {\n-                        self.typeck_results.borrow().qpath_res(qpath, callee_expr.hir_id)\n-                    }\n-                    hir::ExprKind::Call(ref inner_callee, _) => {\n-                        // If the call spans more than one line and the callee kind is\n-                        // itself another `ExprCall`, that's a clue that we might just be\n-                        // missing a semicolon (Issue #51055)\n-                        let call_is_multiline =\n-                            self.tcx.sess.source_map().is_multiline(call_expr.span);\n-                        if call_is_multiline {\n-                            err.span_suggestion(\n-                                callee_expr.span.shrink_to_hi(),\n-                                \"consider using a semicolon here\",\n-                                \";\",\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                        if let hir::ExprKind::Path(ref inner_qpath) = inner_callee.kind {\n-                            inner_callee_path = Some(inner_qpath);\n-                            self.typeck_results.borrow().qpath_res(inner_qpath, inner_callee.hir_id)\n-                        } else {\n-                            Res::Err\n-                        }\n-                    }\n-                    _ => Res::Err,\n-                };\n-\n-                if !self.maybe_suggest_bad_array_definition(&mut err, call_expr, callee_expr) {\n-                    if let Some((maybe_def, output_ty, _)) = self.extract_callable_info(callee_expr, callee_ty)\n-                        && !self.type_is_sized_modulo_regions(self.param_env, output_ty, callee_expr.span)\n-                    {\n-                        let descr = match maybe_def {\n-                            DefIdOrName::DefId(def_id) => self.tcx.def_kind(def_id).descr(def_id),\n-                            DefIdOrName::Name(name) => name,\n-                        };\n-                        err.span_label(\n-                            callee_expr.span,\n-                            format!(\"this {descr} returns an unsized value `{output_ty}`, so it cannot be called\")\n-                        );\n-                        if let DefIdOrName::DefId(def_id) = maybe_def\n-                            && let Some(def_span) = self.tcx.hir().span_if_local(def_id)\n-                        {\n-                            err.span_label(def_span, \"the callable type is defined here\");\n-                        }\n-                    } else {\n-                        err.span_label(call_expr.span, \"call expression requires function\");\n-                    }\n-                }\n-\n-                if let Some(span) = self.tcx.hir().res_span(def) {\n-                    let callee_ty = callee_ty.to_string();\n-                    let label = match (unit_variant, inner_callee_path) {\n-                        (Some((_, kind, path)), _) => Some(format!(\"{kind} `{path}` defined here\")),\n-                        (_, Some(hir::QPath::Resolved(_, path))) => self\n-                            .tcx\n-                            .sess\n-                            .source_map()\n-                            .span_to_snippet(path.span)\n-                            .ok()\n-                            .map(|p| format!(\"`{p}` defined here returns `{callee_ty}`\")),\n-                        _ => {\n-                            match def {\n-                                // Emit a different diagnostic for local variables, as they are not\n-                                // type definitions themselves, but rather variables *of* that type.\n-                                Res::Local(hir_id) => Some(format!(\n-                                    \"`{}` has type `{}`\",\n-                                    self.tcx.hir().name(hir_id),\n-                                    callee_ty\n-                                )),\n-                                Res::Def(kind, def_id) if kind.ns() == Some(Namespace::ValueNS) => {\n-                                    Some(format!(\n-                                        \"`{}` defined here\",\n-                                        self.tcx.def_path_str(def_id),\n-                                    ))\n-                                }\n-                                _ => Some(format!(\"`{callee_ty}` defined here\")),\n-                            }\n-                        }\n-                    };\n-                    if let Some(label) = label {\n-                        err.span_label(span, label);\n-                    }\n-                }\n-                err.emit();\n+                self.report_invalid_callee(call_expr, callee_expr, callee_ty, arg_exprs);\n \n                 // This is the \"default\" function signature, used in case of error.\n                 // In that case, we check each argument against \"error\" in order to\n@@ -574,6 +441,145 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         fn_sig.output()\n     }\n \n+    fn report_invalid_callee(\n+        &self,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        callee_expr: &'tcx hir::Expr<'tcx>,\n+        callee_ty: Ty<'tcx>,\n+        arg_exprs: &'tcx [hir::Expr<'tcx>],\n+    ) {\n+        let mut unit_variant = None;\n+        if let hir::ExprKind::Path(qpath) = &callee_expr.kind\n+            && let Res::Def(def::DefKind::Ctor(kind, def::CtorKind::Const), _)\n+                = self.typeck_results.borrow().qpath_res(qpath, callee_expr.hir_id)\n+            // Only suggest removing parens if there are no arguments\n+            && arg_exprs.is_empty()\n+        {\n+            let descr = match kind {\n+                def::CtorOf::Struct => \"struct\",\n+                def::CtorOf::Variant => \"enum variant\",\n+            };\n+            let removal_span =\n+                callee_expr.span.shrink_to_hi().to(call_expr.span.shrink_to_hi());\n+            unit_variant =\n+                Some((removal_span, descr, rustc_hir_pretty::qpath_to_string(qpath)));\n+        }\n+\n+        let callee_ty = self.resolve_vars_if_possible(callee_ty);\n+        let mut err = type_error_struct!(\n+            self.tcx.sess,\n+            callee_expr.span,\n+            callee_ty,\n+            E0618,\n+            \"expected function, found {}\",\n+            match &unit_variant {\n+                Some((_, kind, path)) => format!(\"{kind} `{path}`\"),\n+                None => format!(\"`{callee_ty}`\"),\n+            }\n+        );\n+\n+        self.identify_bad_closure_def_and_call(\n+            &mut err,\n+            call_expr.hir_id,\n+            &callee_expr.kind,\n+            callee_expr.span,\n+        );\n+\n+        if let Some((removal_span, kind, path)) = &unit_variant {\n+            err.span_suggestion_verbose(\n+                *removal_span,\n+                &format!(\n+                    \"`{path}` is a unit {kind}, and does not take parentheses to be constructed\",\n+                ),\n+                \"\",\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+\n+        let mut inner_callee_path = None;\n+        let def = match callee_expr.kind {\n+            hir::ExprKind::Path(ref qpath) => {\n+                self.typeck_results.borrow().qpath_res(qpath, callee_expr.hir_id)\n+            }\n+            hir::ExprKind::Call(ref inner_callee, _) => {\n+                // If the call spans more than one line and the callee kind is\n+                // itself another `ExprCall`, that's a clue that we might just be\n+                // missing a semicolon (Issue #51055)\n+                let call_is_multiline = self.tcx.sess.source_map().is_multiline(call_expr.span);\n+                if call_is_multiline {\n+                    err.span_suggestion(\n+                        callee_expr.span.shrink_to_hi(),\n+                        \"consider using a semicolon here\",\n+                        \";\",\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                if let hir::ExprKind::Path(ref inner_qpath) = inner_callee.kind {\n+                    inner_callee_path = Some(inner_qpath);\n+                    self.typeck_results.borrow().qpath_res(inner_qpath, inner_callee.hir_id)\n+                } else {\n+                    Res::Err\n+                }\n+            }\n+            _ => Res::Err,\n+        };\n+\n+        if !self.maybe_suggest_bad_array_definition(&mut err, call_expr, callee_expr) {\n+            if let Some((maybe_def, output_ty, _)) = self.extract_callable_info(callee_expr, callee_ty)\n+                && !self.type_is_sized_modulo_regions(self.param_env, output_ty, callee_expr.span)\n+            {\n+                let descr = match maybe_def {\n+                    DefIdOrName::DefId(def_id) => self.tcx.def_kind(def_id).descr(def_id),\n+                    DefIdOrName::Name(name) => name,\n+                };\n+                err.span_label(\n+                    callee_expr.span,\n+                    format!(\"this {descr} returns an unsized value `{output_ty}`, so it cannot be called\")\n+                );\n+                if let DefIdOrName::DefId(def_id) = maybe_def\n+                    && let Some(def_span) = self.tcx.hir().span_if_local(def_id)\n+                {\n+                    err.span_label(def_span, \"the callable type is defined here\");\n+                }\n+            } else {\n+                err.span_label(call_expr.span, \"call expression requires function\");\n+            }\n+        }\n+\n+        if let Some(span) = self.tcx.hir().res_span(def) {\n+            let callee_ty = callee_ty.to_string();\n+            let label = match (unit_variant, inner_callee_path) {\n+                (Some((_, kind, path)), _) => Some(format!(\"{kind} `{path}` defined here\")),\n+                (_, Some(hir::QPath::Resolved(_, path))) => self\n+                    .tcx\n+                    .sess\n+                    .source_map()\n+                    .span_to_snippet(path.span)\n+                    .ok()\n+                    .map(|p| format!(\"`{p}` defined here returns `{callee_ty}`\")),\n+                _ => {\n+                    match def {\n+                        // Emit a different diagnostic for local variables, as they are not\n+                        // type definitions themselves, but rather variables *of* that type.\n+                        Res::Local(hir_id) => Some(format!(\n+                            \"`{}` has type `{}`\",\n+                            self.tcx.hir().name(hir_id),\n+                            callee_ty\n+                        )),\n+                        Res::Def(kind, def_id) if kind.ns() == Some(Namespace::ValueNS) => {\n+                            Some(format!(\"`{}` defined here\", self.tcx.def_path_str(def_id),))\n+                        }\n+                        _ => Some(format!(\"`{callee_ty}` defined here\")),\n+                    }\n+                }\n+            };\n+            if let Some(label) = label {\n+                err.span_label(span, label);\n+            }\n+        }\n+        err.emit();\n+    }\n+\n     fn confirm_deferred_closure_call(\n         &self,\n         call_expr: &'tcx hir::Expr<'tcx>,"}, {"sha": "df22d79f82e85cacd876388730a4a344c786952d", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=9c56d9d6fec6262bbb1549cfe466a812ae2c6523", "patch": "@@ -224,7 +224,7 @@ impl<'a> Iterator for Parser<'a> {\n                 '{' => {\n                     let curr_last_brace = self.last_opening_brace;\n                     let byte_pos = self.to_span_index(pos);\n-                    let lbrace_end = InnerOffset(byte_pos.0 + 1);\n+                    let lbrace_end = self.to_span_index(pos + 1);\n                     self.last_opening_brace = Some(byte_pos.to(lbrace_end));\n                     self.cur.next();\n                     if self.consume('{') {"}, {"sha": "9f6b6b5253605a5e74c2e12a77724968fedbe767", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=9c56d9d6fec6262bbb1549cfe466a812ae2c6523", "patch": "@@ -716,7 +716,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n         document(&mut content, cx, m, Some(t), HeadingOffset::H5);\n         let toggled = !content.is_empty();\n         if toggled {\n-            write!(w, \"<details class=\\\"rustdoc-toggle\\\" open><summary>\");\n+            write!(w, \"<details class=\\\"rustdoc-toggle method-toggle\\\" open><summary>\");\n         }\n         write!(w, \"<div id=\\\"{}\\\" class=\\\"method has-srclink\\\">\", id);\n         render_rightside(w, cx, m, t, RenderMode::Normal);"}, {"sha": "e92e9137d6402d74a13ea96827579317cbc2074a", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=9c56d9d6fec6262bbb1549cfe466a812ae2c6523", "patch": "@@ -138,6 +138,13 @@ h1, h2, h3, h4 {\n .docblock h3, .docblock h4, h5, h6 {\n \tmargin: 15px 0 5px 0;\n }\n+.docblock > h2:first-child,\n+.docblock > h3:first-child,\n+.docblock > h4:first-child,\n+.docblock > h5:first-child,\n+.docblock > h6:first-child {\n+\tmargin-top: 0;\n+}\n h1.fqn {\n \tmargin: 0;\n \tpadding: 0;\n@@ -187,7 +194,6 @@ h4.code-header {\n .impl-items .associatedtype,\n .methods .associatedtype {\n \tflex-basis: 100%;\n-\tfont-weight: 600;\n \tposition: relative;\n }\n \n@@ -2008,7 +2014,8 @@ in storage.js plus the media query with (min-width: 701px)\n \n .method-toggle summary,\n .implementors-toggle summary,\n-.impl {\n+.impl,\n+#implementors-list > .docblock {\n \tmargin-bottom: 0.75em;\n }\n "}, {"sha": "14653f0bfc7487077990eafe2b838ddd9b43891a", "filename": "src/test/rustdoc-gui/anchor-navigable.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/src%2Ftest%2Frustdoc-gui%2Fanchor-navigable.goml", "raw_url": "https://github.com/rust-lang/rust/raw/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/src%2Ftest%2Frustdoc-gui%2Fanchor-navigable.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fanchor-navigable.goml?ref=9c56d9d6fec6262bbb1549cfe466a812ae2c6523", "patch": "@@ -7,5 +7,5 @@\n goto: file://|DOC_PATH|/test_docs/struct.Foo.html\n // We check that \".item-info\" is bigger than its content.\n move-cursor-to: \".impl\"\n-assert-property: (\".impl > a.anchor\", {\"offsetWidth\": \"9\"})\n+assert-property: (\".impl > a.anchor\", {\"offsetWidth\": \"8\"})\n assert-css: (\".impl > a.anchor\", {\"left\": \"-8px\"})"}, {"sha": "d5c934551a57237cfd3e40adc0e5a7ffc50a6ef5", "filename": "src/test/rustdoc-gui/font-weight.goml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/src%2Ftest%2Frustdoc-gui%2Ffont-weight.goml", "raw_url": "https://github.com/rust-lang/rust/raw/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/src%2Ftest%2Frustdoc-gui%2Ffont-weight.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Ffont-weight.goml?ref=9c56d9d6fec6262bbb1549cfe466a812ae2c6523", "patch": "@@ -13,7 +13,7 @@ goto: file://|DOC_PATH|/test_docs/type.SomeType.html\n assert-css: (\".top-doc .docblock p\", {\"font-weight\": \"400\"}, ALL)\n \n goto: file://|DOC_PATH|/test_docs/struct.Foo.html\n-assert-css: (\".impl-items .method\", {\"font-weight\": \"600\"}, ALL)\n+assert-css: (\".impl-items .method > .code-header\", {\"font-weight\": \"600\"}, ALL)\n \n goto: file://|DOC_PATH|/lib2/trait.Trait.html\n \n@@ -41,4 +41,4 @@ assert-count: (\".methods .associatedtype\", 1)\n assert-css: (\".methods .associatedtype\", {\"font-weight\": \"600\"})\n assert-count: (\".methods .constant\", 1)\n assert-css: (\".methods .constant\", {\"font-weight\": \"600\"})\n-assert-css: (\".methods .method\", {\"font-weight\": \"600\"})\n+assert-css: (\".methods .method > .code-header\", {\"font-weight\": \"600\"})"}, {"sha": "ebb413b8c412c123335310bc6fda891087a29e2c", "filename": "src/test/rustdoc-gui/src-font-size.goml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/src%2Ftest%2Frustdoc-gui%2Fsrc-font-size.goml", "raw_url": "https://github.com/rust-lang/rust/raw/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/src%2Ftest%2Frustdoc-gui%2Fsrc-font-size.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc-font-size.goml?ref=9c56d9d6fec6262bbb1549cfe466a812ae2c6523", "patch": "@@ -4,8 +4,8 @@\n goto: file://|DOC_PATH|/test_docs/struct.Foo.html\n show-text: true\n // Check the impl headers.\n-assert-css: (\".impl.has-srclink .srclink\", {\"font-size\": \"16px\"}, ALL)\n-assert-css: (\".impl.has-srclink .code-header\", {\"font-size\": \"18px\"}, ALL)\n+assert-css: (\".impl.has-srclink .srclink\", {\"font-size\": \"16px\", \"font-weight\": 400}, ALL)\n+assert-css: (\".impl.has-srclink .code-header\", {\"font-size\": \"18px\", \"font-weight\": 600}, ALL)\n // Check the impl items.\n-assert-css: (\".impl-items .has-srclink .srclink\", {\"font-size\": \"16px\"}, ALL)\n-assert-css: (\".impl-items .has-srclink .code-header\", {\"font-size\": \"16px\"}, ALL)\n+assert-css: (\".impl-items .has-srclink .srclink\", {\"font-size\": \"16px\", \"font-weight\": 400}, ALL)\n+assert-css: (\".impl-items .has-srclink .code-header\", {\"font-size\": \"16px\", \"font-weight\": 600}, ALL)"}, {"sha": "e41422ce7c516b5033d7185ce068dce5b9f1e6f6", "filename": "src/test/rustdoc/toggle-trait-fn.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/src%2Ftest%2Frustdoc%2Ftoggle-trait-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/src%2Ftest%2Frustdoc%2Ftoggle-trait-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftoggle-trait-fn.rs?ref=9c56d9d6fec6262bbb1549cfe466a812ae2c6523", "patch": "@@ -4,12 +4,12 @@\n // summary. Trait methods with no documentation should not be wrapped.\n //\n // @has foo/trait.Foo.html\n-// @has -  '//details[@class=\"rustdoc-toggle\"]//summary//h4[@class=\"code-header\"]' 'is_documented()'\n-// @!has - '//details[@class=\"rustdoc-toggle\"]//summary//h4[@class=\"code-header\"]' 'not_documented()'\n-// @has -  '//details[@class=\"rustdoc-toggle\"]//*[@class=\"docblock\"]' 'is_documented is documented'\n-// @has -  '//details[@class=\"rustdoc-toggle\"]//summary//h4[@class=\"code-header\"]' 'is_documented_optional()'\n-// @!has - '//details[@class=\"rustdoc-toggle\"]//summary//h4[@class=\"code-header\"]' 'not_documented_optional()'\n-// @has -  '//details[@class=\"rustdoc-toggle\"]//*[@class=\"docblock\"]' 'is_documented_optional is documented'\n+// @has -  '//details[@class=\"rustdoc-toggle method-toggle\"]//summary//h4[@class=\"code-header\"]' 'is_documented()'\n+// @!has - '//details[@class=\"rustdoc-toggle method-toggle\"]//summary//h4[@class=\"code-header\"]' 'not_documented()'\n+// @has -  '//details[@class=\"rustdoc-toggle method-toggle\"]//*[@class=\"docblock\"]' 'is_documented is documented'\n+// @has -  '//details[@class=\"rustdoc-toggle method-toggle\"]//summary//h4[@class=\"code-header\"]' 'is_documented_optional()'\n+// @!has - '//details[@class=\"rustdoc-toggle method-toggle\"]//summary//h4[@class=\"code-header\"]' 'not_documented_optional()'\n+// @has -  '//details[@class=\"rustdoc-toggle method-toggle\"]//*[@class=\"docblock\"]' 'is_documented_optional is documented'\n pub trait Foo {\n     fn not_documented();\n "}, {"sha": "b8089d49bcb3bff1aec49f615fe8680b21368da4", "filename": "src/test/ui/fmt/format-args-capture-issue-102057.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/src%2Ftest%2Fui%2Ffmt%2Fformat-args-capture-issue-102057.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/src%2Ftest%2Fui%2Ffmt%2Fformat-args-capture-issue-102057.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fformat-args-capture-issue-102057.rs?ref=9c56d9d6fec6262bbb1549cfe466a812ae2c6523", "patch": "@@ -0,0 +1,19 @@\n+fn main() {\n+    format!(\"\\x7Ba}\");\n+    //~^ ERROR cannot find value `a` in this scope\n+    format!(\"\\x7Ba\\x7D\");\n+    //~^ ERROR cannot find value `a` in this scope\n+\n+    let a = 0;\n+\n+    format!(\"\\x7Ba} {b}\");\n+    //~^ ERROR cannot find value `b` in this scope\n+    format!(\"\\x7Ba\\x7D {b}\");\n+    //~^ ERROR cannot find value `b` in this scope\n+    format!(\"\\x7Ba} \\x7Bb}\");\n+    //~^ ERROR cannot find value `b` in this scope\n+    format!(\"\\x7Ba\\x7D \\x7Bb}\");\n+    //~^ ERROR cannot find value `b` in this scope\n+    format!(\"\\x7Ba\\x7D \\x7Bb\\x7D\");\n+    //~^ ERROR cannot find value `b` in this scope\n+}"}, {"sha": "f2d625e7f8dc88e88fe503a65b417dca998d9081", "filename": "src/test/ui/fmt/format-args-capture-issue-102057.stderr", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/src%2Ftest%2Fui%2Ffmt%2Fformat-args-capture-issue-102057.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/src%2Ftest%2Fui%2Ffmt%2Fformat-args-capture-issue-102057.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fformat-args-capture-issue-102057.stderr?ref=9c56d9d6fec6262bbb1549cfe466a812ae2c6523", "patch": "@@ -0,0 +1,45 @@\n+error[E0425]: cannot find value `a` in this scope\n+  --> $DIR/format-args-capture-issue-102057.rs:2:18\n+   |\n+LL |     format!(\"\\x7Ba}\");\n+   |                  ^ not found in this scope\n+\n+error[E0425]: cannot find value `a` in this scope\n+  --> $DIR/format-args-capture-issue-102057.rs:4:18\n+   |\n+LL |     format!(\"\\x7Ba\\x7D\");\n+   |                  ^ not found in this scope\n+\n+error[E0425]: cannot find value `b` in this scope\n+  --> $DIR/format-args-capture-issue-102057.rs:9:22\n+   |\n+LL |     format!(\"\\x7Ba} {b}\");\n+   |                      ^ help: a local variable with a similar name exists: `a`\n+\n+error[E0425]: cannot find value `b` in this scope\n+  --> $DIR/format-args-capture-issue-102057.rs:11:25\n+   |\n+LL |     format!(\"\\x7Ba\\x7D {b}\");\n+   |                         ^ help: a local variable with a similar name exists: `a`\n+\n+error[E0425]: cannot find value `b` in this scope\n+  --> $DIR/format-args-capture-issue-102057.rs:13:25\n+   |\n+LL |     format!(\"\\x7Ba} \\x7Bb}\");\n+   |                         ^ help: a local variable with a similar name exists: `a`\n+\n+error[E0425]: cannot find value `b` in this scope\n+  --> $DIR/format-args-capture-issue-102057.rs:15:28\n+   |\n+LL |     format!(\"\\x7Ba\\x7D \\x7Bb}\");\n+   |                            ^ help: a local variable with a similar name exists: `a`\n+\n+error[E0425]: cannot find value `b` in this scope\n+  --> $DIR/format-args-capture-issue-102057.rs:17:28\n+   |\n+LL |     format!(\"\\x7Ba\\x7D \\x7Bb\\x7D\");\n+   |                            ^ help: a local variable with a similar name exists: `a`\n+\n+error: aborting due to 7 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "d4733107e793dfe318531e64ab00b4110effb9ca", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c56d9d6fec6262bbb1549cfe466a812ae2c6523/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=9c56d9d6fec6262bbb1549cfe466a812ae2c6523", "patch": "@@ -73,14 +73,11 @@ const EXCEPTIONS_BOOTSTRAP: &[(&str, &str)] = &[\n /// these and all their dependencies *must not* be in the exception list.\n const RUNTIME_CRATES: &[&str] = &[\"std\", \"core\", \"alloc\", \"test\", \"panic_abort\", \"panic_unwind\"];\n \n-/// Crates whose dependencies must be explicitly permitted.\n-const RESTRICTED_DEPENDENCY_CRATES: &[&str] = &[\"rustc_driver\", \"rustc_codegen_llvm\"];\n-\n /// Crates rustc is allowed to depend on. Avoid adding to the list if possible.\n ///\n /// This list is here to provide a speed-bump to adding a new dependency to\n /// rustc. Please check with the compiler team before adding an entry.\n-const PERMITTED_DEPENDENCIES: &[&str] = &[\n+const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"addr2line\",\n     \"adler\",\n     \"ahash\",\n@@ -307,7 +304,7 @@ const PERMITTED_CRANELIFT_DEPENDENCIES: &[&str] = &[\n ];\n \n const FORBIDDEN_TO_HAVE_DUPLICATES: &[&str] = &[\n-    // These two crates take quite a long time to build, so don't allow two versions of them\n+    // This crate takes quite a long time to build, so don't allow two versions of them\n     // to accidentally sneak into our dependency graph, in order to ensure we keep our CI times\n     // under control.\n     \"cargo\",\n@@ -324,12 +321,12 @@ pub fn check(root: &Path, cargo: &Path, bad: &mut bool) {\n         .features(cargo_metadata::CargoOpt::AllFeatures);\n     let metadata = t!(cmd.exec());\n     let runtime_ids = compute_runtime_crates(&metadata);\n-    check_exceptions(&metadata, EXCEPTIONS, runtime_ids, bad);\n-    check_dependencies(\n+    check_license_exceptions(&metadata, EXCEPTIONS, runtime_ids, bad);\n+    check_permitted_dependencies(\n         &metadata,\n-        \"main workspace\",\n-        PERMITTED_DEPENDENCIES,\n-        RESTRICTED_DEPENDENCY_CRATES,\n+        \"rustc\",\n+        PERMITTED_RUSTC_DEPENDENCIES,\n+        &[\"rustc_driver\", \"rustc_codegen_llvm\"],\n         bad,\n     );\n     check_crate_duplicate(&metadata, FORBIDDEN_TO_HAVE_DUPLICATES, bad);\n@@ -342,8 +339,8 @@ pub fn check(root: &Path, cargo: &Path, bad: &mut bool) {\n         .features(cargo_metadata::CargoOpt::AllFeatures);\n     let metadata = t!(cmd.exec());\n     let runtime_ids = HashSet::new();\n-    check_exceptions(&metadata, EXCEPTIONS_CRANELIFT, runtime_ids, bad);\n-    check_dependencies(\n+    check_license_exceptions(&metadata, EXCEPTIONS_CRANELIFT, runtime_ids, bad);\n+    check_permitted_dependencies(\n         &metadata,\n         \"cranelift\",\n         PERMITTED_CRANELIFT_DEPENDENCIES,\n@@ -358,13 +355,13 @@ pub fn check(root: &Path, cargo: &Path, bad: &mut bool) {\n         .features(cargo_metadata::CargoOpt::AllFeatures);\n     let metadata = t!(cmd.exec());\n     let runtime_ids = HashSet::new();\n-    check_exceptions(&metadata, EXCEPTIONS_BOOTSTRAP, runtime_ids, bad);\n+    check_license_exceptions(&metadata, EXCEPTIONS_BOOTSTRAP, runtime_ids, bad);\n }\n \n /// Check that all licenses are in the valid list in `LICENSES`.\n ///\n-/// Packages listed in `EXCEPTIONS` are allowed for tools.\n-fn check_exceptions(\n+/// Packages listed in `exceptions` are allowed for tools.\n+fn check_license_exceptions(\n     metadata: &Metadata,\n     exceptions: &[(&str, &str)],\n     runtime_ids: HashSet<&PackageId>,\n@@ -434,11 +431,11 @@ fn check_exceptions(\n     }\n }\n \n-/// Checks the dependency of `RESTRICTED_DEPENDENCY_CRATES` at the given path. Changes `bad` to\n+/// Checks the dependency of `restricted_dependency_crates` at the given path. Changes `bad` to\n /// `true` if a check failed.\n ///\n-/// Specifically, this checks that the dependencies are on the `PERMITTED_DEPENDENCIES`.\n-fn check_dependencies(\n+/// Specifically, this checks that the dependencies are on the `permitted_dependencies`.\n+fn check_permitted_dependencies(\n     metadata: &Metadata,\n     descr: &str,\n     permitted_dependencies: &[&'static str],"}]}