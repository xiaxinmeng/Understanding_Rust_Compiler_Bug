{"sha": "d4ae9ff82664a1d7473e32d59819c208efce48c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0YWU5ZmY4MjY2NGExZDc0NzNlMzJkNTk4MTljMjA4ZWZjZTQ4Yzc=", "commit": {"author": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2021-01-23T03:55:41Z"}, "committer": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2021-03-09T16:54:14Z"}, "message": "Build StKind::CopyOverlapping\n\nThis replaces where it was previously being constructed in intrinsics, with direct construction\nof the Statement.", "tree": {"sha": "d185bf306fef03d55367dfde891542f487f665e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d185bf306fef03d55367dfde891542f487f665e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4ae9ff82664a1d7473e32d59819c208efce48c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4ae9ff82664a1d7473e32d59819c208efce48c7", "html_url": "https://github.com/rust-lang/rust/commit/d4ae9ff82664a1d7473e32d59819c208efce48c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4ae9ff82664a1d7473e32d59819c208efce48c7/comments", "author": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "845e4b5962aa84fcfc0b8a6b1e4b9e32725547ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/845e4b5962aa84fcfc0b8a6b1e4b9e32725547ef", "html_url": "https://github.com/rust-lang/rust/commit/845e4b5962aa84fcfc0b8a6b1e4b9e32725547ef"}], "stats": {"total": 173, "additions": 98, "deletions": 75}, "files": [{"sha": "8b5ae9e0541ade6210bfd3436f2c9b9228085328", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d4ae9ff82664a1d7473e32d59819c208efce48c7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ae9ff82664a1d7473e32d59819c208efce48c7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=d4ae9ff82664a1d7473e32d59819c208efce48c7", "patch": "@@ -837,10 +837,21 @@ fn codegen_stmt<'tcx>(\n           dst,\n           count,\n         }) => {\n-            let dst = codegen_operand(fx, dst).load_scalar(fx);\n+            let dst = codegen_operand(fx, dst);\n+            let pointee = dst\n+              .layout()\n+              .pointee_info_at(fx, rustc_target::abi::Size::ZERO)\n+              .expect(\"Expected pointer\");\n+            let dst = dst.load_scalar(fx);\n             let src = codegen_operand(fx, src).load_scalar(fx);\n             let count = codegen_operand(fx, count).load_scalar(fx);\n-            fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, count);\n+            let elem_size: u64 = pointee.size.bytes();\n+            let bytes = if elem_size != 1 {\n+               fx.bcx.ins().imul_imm(count, elem_size as i64)\n+            } else {\n+               count\n+            };\n+            fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, bytes);\n         }\n     }\n }"}, {"sha": "2c2330409fd709b51bd3c0195e2353713cb76fc5", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4ae9ff82664a1d7473e32d59819c208efce48c7/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ae9ff82664a1d7473e32d59819c208efce48c7/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=d4ae9ff82664a1d7473e32d59819c208efce48c7", "patch": "@@ -9,6 +9,7 @@\n #![feature(or_patterns)]\n #![feature(associated_type_bounds)]\n #![recursion_limit = \"256\"]\n+#![feature(box_syntax)]\n \n //! This crate contains codegen code that is used by all codegen backends (LLVM and others).\n //! The backend-agnostic functions of this crate use functions defined in various traits that"}, {"sha": "1150d4d734870ef587fd57691252d80b3146f15d", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 76, "deletions": 54, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/d4ae9ff82664a1d7473e32d59819c208efce48c7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ae9ff82664a1d7473e32d59819c208efce48c7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=d4ae9ff82664a1d7473e32d59819c208efce48c7", "patch": "@@ -641,67 +641,89 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             return;\n         }\n \n-        if intrinsic.is_some() && intrinsic != Some(sym::drop_in_place) {\n-            let intrinsic = intrinsic.unwrap();\n-            let dest = match ret_dest {\n-                _ if fn_abi.ret.is_indirect() => llargs[0],\n-                ReturnDest::Nothing => {\n-                    bx.const_undef(bx.type_ptr_to(bx.arg_memory_ty(&fn_abi.ret)))\n-                }\n-                ReturnDest::IndirectOperand(dst, _) | ReturnDest::Store(dst) => dst.llval,\n-                ReturnDest::DirectOperand(_) => {\n-                    bug!(\"Cannot use direct operand with an intrinsic call\")\n-                }\n-            };\n+        match intrinsic {\n+            None | Some(sym::drop_in_place) => {}\n+            Some(sym::copy_nonoverlapping) => {\n+                bx = self.codegen_statement(\n+                    bx,\n+                    &rustc_middle::mir::Statement {\n+                        source_info: rustc_middle::mir::SourceInfo::outermost(span),\n+                        kind: rustc_middle::mir::StatementKind::CopyNonOverlapping(\n+                            box rustc_middle::mir::CopyNonOverlapping {\n+                                src: args[0].clone(),\n+                                dst: args[1].clone(),\n+                                count: args[2].clone(),\n+                            },\n+                        ),\n+                    },\n+                );\n+                helper.funclet_br(self, &mut bx, destination.unwrap().1);\n+                return;\n+            }\n+            Some(intrinsic) => {\n+                let dest = match ret_dest {\n+                    _ if fn_abi.ret.is_indirect() => llargs[0],\n+                    ReturnDest::Nothing => {\n+                        bx.const_undef(bx.type_ptr_to(bx.arg_memory_ty(&fn_abi.ret)))\n+                    }\n+                    ReturnDest::IndirectOperand(dst, _) | ReturnDest::Store(dst) => dst.llval,\n+                    ReturnDest::DirectOperand(_) => {\n+                        bug!(\"Cannot use direct operand with an intrinsic call\")\n+                    }\n+                };\n \n-            let args: Vec<_> = args\n-                .iter()\n-                .enumerate()\n-                .map(|(i, arg)| {\n-                    // The indices passed to simd_shuffle* in the\n-                    // third argument must be constant. This is\n-                    // checked by const-qualification, which also\n-                    // promotes any complex rvalues to constants.\n-                    if i == 2 && intrinsic.as_str().starts_with(\"simd_shuffle\") {\n-                        if let mir::Operand::Constant(constant) = arg {\n-                            let c = self.eval_mir_constant(constant);\n-                            let (llval, ty) = self.simd_shuffle_indices(\n-                                &bx,\n-                                constant.span,\n-                                constant.literal.ty,\n-                                c,\n-                            );\n-                            return OperandRef { val: Immediate(llval), layout: bx.layout_of(ty) };\n-                        } else {\n-                            span_bug!(span, \"shuffle indices must be constant\");\n+                let args: Vec<_> = args\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(i, arg)| {\n+                        // The indices passed to simd_shuffle* in the\n+                        // third argument must be constant. This is\n+                        // checked by const-qualification, which also\n+                        // promotes any complex rvalues to constants.\n+                        if i == 2 && intrinsic.as_str().starts_with(\"simd_shuffle\") {\n+                            if let mir::Operand::Constant(constant) = arg {\n+                                let c = self.eval_mir_constant(constant);\n+                                let (llval, ty) = self.simd_shuffle_indices(\n+                                    &bx,\n+                                    constant.span,\n+                                    constant.literal.ty,\n+                                    c,\n+                                );\n+                                return OperandRef {\n+                                    val: Immediate(llval),\n+                                    layout: bx.layout_of(ty),\n+                                };\n+                            } else {\n+                                span_bug!(span, \"shuffle indices must be constant\");\n+                            }\n                         }\n-                    }\n \n-                    self.codegen_operand(&mut bx, arg)\n-                })\n-                .collect();\n+                        self.codegen_operand(&mut bx, arg)\n+                    })\n+                    .collect();\n+\n+                self.codegen_intrinsic_call(\n+                    &mut bx,\n+                    *instance.as_ref().unwrap(),\n+                    &fn_abi,\n+                    &args,\n+                    dest,\n+                    span,\n+                );\n \n-            Self::codegen_intrinsic_call(\n-                &mut bx,\n-                *instance.as_ref().unwrap(),\n-                &fn_abi,\n-                &args,\n-                dest,\n-                span,\n-            );\n+                if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n+                    self.store_return(&mut bx, ret_dest, &fn_abi.ret, dst.llval);\n+                }\n \n-            if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n-                self.store_return(&mut bx, ret_dest, &fn_abi.ret, dst.llval);\n-            }\n+                if let Some((_, target)) = *destination {\n+                    helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+                    helper.funclet_br(self, &mut bx, target);\n+                } else {\n+                    bx.unreachable();\n+                }\n \n-            if let Some((_, target)) = *destination {\n-                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n-                helper.funclet_br(self, &mut bx, target);\n-            } else {\n-                bx.unreachable();\n+                return;\n             }\n-\n-            return;\n         }\n \n         // Split the rust-call tupled arguments off."}, {"sha": "00fc5b6606151a6eee2bc1a39b118dad0fe96dc5", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d4ae9ff82664a1d7473e32d59819c208efce48c7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ae9ff82664a1d7473e32d59819c208efce48c7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=d4ae9ff82664a1d7473e32d59819c208efce48c7", "patch": "@@ -49,6 +49,7 @@ fn memset_intrinsic<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_intrinsic_call(\n+        &self,\n         bx: &mut Bx,\n         instance: ty::Instance<'tcx>,\n         fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n@@ -127,16 +128,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             sym::copy_nonoverlapping => {\n-                copy_intrinsic(\n-                    bx,\n-                    false,\n-                    false,\n-                    substs.type_at(0),\n-                    args[1].immediate(),\n-                    args[0].immediate(),\n-                    args[2].immediate(),\n-                );\n-                return;\n+                // handled explicitly in compiler/rustc_codegen_ssa/src/mir/block.rs\n+                unreachable!();\n             }\n             sym::copy => {\n                 copy_intrinsic("}, {"sha": "5523e5f2e8604d737f86987380b657182de113c0", "filename": "compiler/rustc_codegen_ssa/src/mir/statement.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d4ae9ff82664a1d7473e32d59819c208efce48c7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ae9ff82664a1d7473e32d59819c208efce48c7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs?ref=d4ae9ff82664a1d7473e32d59819c208efce48c7", "patch": "@@ -123,20 +123,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let dst_val = self.codegen_operand(&mut bx, dst);\n                 let src_val = self.codegen_operand(&mut bx, src);\n                 let count = self.codegen_operand(&mut bx, count).immediate();\n-                let get_val_align = |oper_ref: crate::mir::OperandRef<'_, _>| match oper_ref.val {\n-                    OperandValue::Ref(val, _, align) => (val, align),\n-                    _ => unreachable!(),\n-                };\n                 let pointee_layout = dst_val\n                     .layout\n                     .pointee_info_at(&mut bx, rustc_target::abi::Size::ZERO)\n                     .expect(\"Expected pointer\");\n-                let elem_size = bx.const_u64(pointee_layout.size.bytes());\n-                let byte_count = bx.mul(count, elem_size);\n+                let bytes = bx.mul(count, bx.const_usize(pointee_layout.size.bytes()));\n \n-                let (dst, dst_align) = get_val_align(dst_val);\n-                let (src, src_align) = get_val_align(src_val);\n-                bx.memcpy(dst, dst_align, src, src_align, byte_count, crate::MemFlags::empty());\n+                let align = pointee_layout.align;\n+                let dst = dst_val.immediate();\n+                let src = src_val.immediate();\n+                bx.memcpy(dst, align, src, align, bytes, crate::MemFlags::empty());\n                 bx\n             }\n             mir::StatementKind::FakeRead(..)"}]}