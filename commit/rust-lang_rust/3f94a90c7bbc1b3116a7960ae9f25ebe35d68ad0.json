{"sha": "3f94a90c7bbc1b3116a7960ae9f25ebe35d68ad0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmOTRhOTBjN2JiYzFiMzExNmE3OTYwYWU5ZjI1ZWJlMzVkNjhhZDA=", "commit": {"author": {"name": "adamrk", "email": "ark.email@gmail.com", "date": "2020-06-07T19:57:29Z"}, "committer": {"name": "adamrk", "email": "ark.email@gmail.com", "date": "2020-06-19T20:51:25Z"}, "message": "Infer FnSig from Fn traits", "tree": {"sha": "82d8a965b9e01e136df4eeaee4c4fee4630ab2a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82d8a965b9e01e136df4eeaee4c4fee4630ab2a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f94a90c7bbc1b3116a7960ae9f25ebe35d68ad0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f94a90c7bbc1b3116a7960ae9f25ebe35d68ad0", "html_url": "https://github.com/rust-lang/rust/commit/3f94a90c7bbc1b3116a7960ae9f25ebe35d68ad0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f94a90c7bbc1b3116a7960ae9f25ebe35d68ad0/comments", "author": {"login": "adamrk", "id": 16367467, "node_id": "MDQ6VXNlcjE2MzY3NDY3", "avatar_url": "https://avatars.githubusercontent.com/u/16367467?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adamrk", "html_url": "https://github.com/adamrk", "followers_url": "https://api.github.com/users/adamrk/followers", "following_url": "https://api.github.com/users/adamrk/following{/other_user}", "gists_url": "https://api.github.com/users/adamrk/gists{/gist_id}", "starred_url": "https://api.github.com/users/adamrk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adamrk/subscriptions", "organizations_url": "https://api.github.com/users/adamrk/orgs", "repos_url": "https://api.github.com/users/adamrk/repos", "events_url": "https://api.github.com/users/adamrk/events{/privacy}", "received_events_url": "https://api.github.com/users/adamrk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "adamrk", "id": 16367467, "node_id": "MDQ6VXNlcjE2MzY3NDY3", "avatar_url": "https://avatars.githubusercontent.com/u/16367467?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adamrk", "html_url": "https://github.com/adamrk", "followers_url": "https://api.github.com/users/adamrk/followers", "following_url": "https://api.github.com/users/adamrk/following{/other_user}", "gists_url": "https://api.github.com/users/adamrk/gists{/gist_id}", "starred_url": "https://api.github.com/users/adamrk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adamrk/subscriptions", "organizations_url": "https://api.github.com/users/adamrk/orgs", "repos_url": "https://api.github.com/users/adamrk/repos", "events_url": "https://api.github.com/users/adamrk/events{/privacy}", "received_events_url": "https://api.github.com/users/adamrk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6654055308515cb330f23942f347de5605f69be1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6654055308515cb330f23942f347de5605f69be1", "html_url": "https://github.com/rust-lang/rust/commit/6654055308515cb330f23942f347de5605f69be1"}], "stats": {"total": 215, "additions": 197, "deletions": 18}, "files": [{"sha": "4c5f171de5a7962a99c006916a6540b445baeff8", "filename": "crates/ra_hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f94a90c7bbc1b3116a7960ae9f25ebe35d68ad0/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f94a90c7bbc1b3116a7960ae9f25ebe35d68ad0/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=3f94a90c7bbc1b3116a7960ae9f25ebe35d68ad0", "patch": "@@ -38,8 +38,8 @@ impl<'a> InferenceContext<'a> {\n                 // Special case: two function types. Try to coerce both to\n                 // pointers to have a chance at getting a match. See\n                 // https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src/librustc_typeck/check/coercion.rs#L877-L916\n-                let sig1 = ty1.callable_sig(self.db).expect(\"FnDef without callable sig\");\n-                let sig2 = ty2.callable_sig(self.db).expect(\"FnDef without callable sig\");\n+                let sig1 = self.callable_sig(ty1).expect(\"FnDef without callable sig\");\n+                let sig2 = self.callable_sig(ty2).expect(\"FnDef without callable sig\");\n                 let ptr_ty1 = Ty::fn_ptr(sig1);\n                 let ptr_ty2 = Ty::fn_ptr(sig2);\n                 self.coerce_merge_branch(&ptr_ty1, &ptr_ty2)\n@@ -93,7 +93,7 @@ impl<'a> InferenceContext<'a> {\n \n             // `{function_type}` -> `fn()`\n             (ty_app!(TypeCtor::FnDef(_)), ty_app!(TypeCtor::FnPtr { .. })) => {\n-                match from_ty.callable_sig(self.db) {\n+                match self.callable_sig(&from_ty) {\n                     None => return false,\n                     Some(sig) => {\n                         from_ty = Ty::fn_ptr(sig);"}, {"sha": "bba6daeb9fec834e6b6c896e83424c7f83e291f0", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 89, "deletions": 13, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/3f94a90c7bbc1b3116a7960ae9f25ebe35d68ad0/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f94a90c7bbc1b3116a7960ae9f25ebe35d68ad0/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=3f94a90c7bbc1b3116a7960ae9f25ebe35d68ad0", "patch": "@@ -15,15 +15,15 @@ use ra_syntax::ast::RangeOp;\n \n use crate::{\n     autoderef, method_resolution, op,\n-    traits::InEnvironment,\n+    traits::{builtin::get_fn_trait, FnTrait, InEnvironment, SolutionVariables},\n     utils::{generics, variant_data, Generics},\n-    ApplicationTy, Binders, CallableDef, InferTy, IntTy, Mutability, Obligation, Rawness, Substs,\n-    TraitRef, Ty, TypeCtor,\n+    ApplicationTy, Binders, CallableDef, FnSig, InferTy, IntTy, Mutability, Obligation, Rawness,\n+    Substs, TraitRef, Ty, TypeCtor,\n };\n \n use super::{\n     find_breakable, BindingMode, BreakableContext, Diverges, Expectation, InferenceContext,\n-    InferenceDiagnostic, TypeMismatch,\n+    InferenceDiagnostic, Solution, TypeMismatch,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -63,6 +63,75 @@ impl<'a> InferenceContext<'a> {\n         self.resolve_ty_as_possible(ty)\n     }\n \n+    fn callable_sig_from_fn_trait(&mut self, ty: &Ty) -> Option<FnSig> {\n+        if let Some(krate) = self.resolver.krate() {\n+            let fn_traits: Vec<crate::TraitId> = [FnTrait::FnOnce, FnTrait::FnMut, FnTrait::Fn]\n+                .iter()\n+                .filter_map(|f| get_fn_trait(self.db, krate, *f))\n+                .collect();\n+            for fn_trait in fn_traits {\n+                let fn_trait_data = self.db.trait_data(fn_trait);\n+                let generic_params = generics(self.db.upcast(), fn_trait.into());\n+                if generic_params.len() != 2 {\n+                    continue;\n+                }\n+\n+                let arg_ty = self.table.new_type_var();\n+                let substs = Substs::build_for_generics(&generic_params)\n+                    .push(ty.clone())\n+                    .push(arg_ty.clone())\n+                    .build();\n+\n+                let trait_ref = TraitRef { trait_: fn_trait, substs: substs.clone() };\n+                let trait_env = Arc::clone(&self.trait_env);\n+                let implements_fn_goal =\n+                    self.canonicalizer().canonicalize_obligation(InEnvironment {\n+                        value: Obligation::Trait(trait_ref),\n+                        environment: trait_env,\n+                    });\n+                if let Some(Solution::Unique(SolutionVariables(solution))) =\n+                    self.db.trait_solve(krate, implements_fn_goal.value.clone())\n+                {\n+                    match solution.value.as_slice() {\n+                        [Ty::Apply(ApplicationTy {\n+                            ctor: TypeCtor::Tuple { cardinality: _ },\n+                            parameters,\n+                        })] => {\n+                            let output_assoc_type = match fn_trait_data\n+                                .associated_types()\n+                                .collect::<Vec<hir_def::TypeAliasId>>()\n+                                .as_slice()\n+                            {\n+                                [output] => *output,\n+                                _ => {\n+                                    continue;\n+                                }\n+                            };\n+                            let output_proj_ty = crate::ProjectionTy {\n+                                associated_ty: output_assoc_type,\n+                                parameters: substs,\n+                            };\n+                            let return_ty = self.normalize_projection_ty(output_proj_ty);\n+                            return Some(FnSig::from_params_and_return(\n+                                parameters.into_iter().map(|ty| ty.clone()).collect(),\n+                                return_ty,\n+                            ));\n+                        }\n+                        _ => (),\n+                    }\n+                }\n+            }\n+        };\n+        None\n+    }\n+\n+    pub fn callable_sig(&mut self, ty: &Ty) -> Option<FnSig> {\n+        match ty.callable_sig(self.db) {\n+            result @ Some(_) => result,\n+            None => self.callable_sig_from_fn_trait(ty),\n+        }\n+    }\n+\n     fn infer_expr_inner(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n         let ty = match &body[tgt_expr] {\n@@ -198,14 +267,21 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Call { callee, args } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n-                let (param_tys, ret_ty) = match callee_ty.callable_sig(self.db) {\n-                    Some(sig) => (sig.params().to_vec(), sig.ret().clone()),\n-                    None => {\n-                        // Not callable\n-                        // FIXME: report an error\n-                        (Vec::new(), Ty::Unknown)\n-                    }\n-                };\n+                let canonicalized = self.canonicalizer().canonicalize_ty(callee_ty.clone());\n+                let mut derefs = autoderef(\n+                    self.db,\n+                    self.resolver.krate(),\n+                    InEnvironment {\n+                        value: canonicalized.value.clone(),\n+                        environment: self.trait_env.clone(),\n+                    },\n+                );\n+                let (param_tys, ret_ty): (Vec<Ty>, Ty) = derefs\n+                    .find_map(|callee_deref_ty| {\n+                        self.callable_sig(&canonicalized.decanonicalize_ty(callee_deref_ty.value))\n+                            .map(|sig| (sig.params().to_vec(), sig.ret().clone()))\n+                    })\n+                    .unwrap_or((Vec::new(), Ty::Unknown));\n                 self.register_obligations_for_call(&callee_ty);\n                 self.check_call_arguments(args, &param_tys);\n                 self.normalize_associated_types_in(ret_ty)\n@@ -692,7 +768,7 @@ impl<'a> InferenceContext<'a> {\n         let method_ty = method_ty.subst(&substs);\n         let method_ty = self.insert_type_vars(method_ty);\n         self.register_obligations_for_call(&method_ty);\n-        let (expected_receiver_ty, param_tys, ret_ty) = match method_ty.callable_sig(self.db) {\n+        let (expected_receiver_ty, param_tys, ret_ty) = match self.callable_sig(&method_ty) {\n             Some(sig) => {\n                 if !sig.params().is_empty() {\n                     (sig.params()[0].clone(), sig.params()[1..].to_vec(), sig.ret().clone())"}, {"sha": "9fef9240d34b26be3f0958402936a1b423d44bda", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f94a90c7bbc1b3116a7960ae9f25ebe35d68ad0/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f94a90c7bbc1b3116a7960ae9f25ebe35d68ad0/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=3f94a90c7bbc1b3116a7960ae9f25ebe35d68ad0", "patch": "@@ -14,7 +14,7 @@ use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty,\n use self::chalk::{from_chalk, Interner, ToChalk};\n \n pub(crate) mod chalk;\n-mod builtin;\n+pub(crate) mod builtin;\n \n // This controls the maximum size of types Chalk considers. If we set this too\n // high, we can run into slow edge cases; if we set it too low, Chalk won't"}, {"sha": "b05e679ada45ac35cd73bb0c269da69ded4a947d", "filename": "crates/ra_hir_ty/src/traits/builtin.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f94a90c7bbc1b3116a7960ae9f25ebe35d68ad0/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f94a90c7bbc1b3116a7960ae9f25ebe35d68ad0/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs?ref=3f94a90c7bbc1b3116a7960ae9f25ebe35d68ad0", "patch": "@@ -360,7 +360,11 @@ fn super_trait_object_unsize_impl_datum(\n     BuiltinImplData { num_vars, trait_ref, where_clauses: Vec::new(), assoc_ty_values: Vec::new() }\n }\n \n-fn get_fn_trait(db: &dyn HirDatabase, krate: CrateId, fn_trait: super::FnTrait) -> Option<TraitId> {\n+pub fn get_fn_trait(\n+    db: &dyn HirDatabase,\n+    krate: CrateId,\n+    fn_trait: super::FnTrait,\n+) -> Option<TraitId> {\n     let target = db.lang_item(krate, fn_trait.lang_item_name().into())?;\n     match target {\n         LangItemTarget::TraitId(t) => Some(t),"}, {"sha": "9a88b4977f0f50aba7e3d9c3e43a8875f598bd25", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/3f94a90c7bbc1b3116a7960ae9f25ebe35d68ad0/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f94a90c7bbc1b3116a7960ae9f25ebe35d68ad0/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=3f94a90c7bbc1b3116a7960ae9f25ebe35d68ad0", "patch": "@@ -2410,4 +2410,103 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             ]\n             \"###);\n     }\n+\n+    #[test]\n+    fn infer_closure_arg() {\n+        check_hover_result(\n+            r#\"\n+            //- /lib.rs\n+\n+            enum Option<T> {\n+                None,\n+                Some(T)\n+            }\n+\n+            fn foo() {\n+                let s<|> = Option::None;\n+                let f = |x: Option<i32>| {};\n+                (&f)(s)\n+            }\n+        \"#,\n+            &[\"Option<i32>\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn infer_fn_trait_arg() {\n+        check_hover_result(\n+            r#\"\n+            //- /lib.rs deps:std\n+\n+            #[lang = \"fn\"]\n+            pub trait Fn<Args> {\n+                type Output;\n+\n+                extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n+            }\n+\n+            enum Option<T> {\n+                None,\n+                Some(T)\n+            }\n+\n+            fn foo<F, T>(f: F) -> T\n+            where\n+                F: Fn(Option<i32>) -> T,\n+            {\n+                let s<|> = None;\n+                f(s)\n+            }\n+            \"#,\n+            &[\"Option<i32>\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn infer_box_fn_arg() {\n+        check_hover_result(\n+            r#\"\n+            //- /lib.rs deps:std\n+\n+            #[lang = \"fn_once\"]\n+            pub trait FnOnce<Args> {\n+                type Output;\n+\n+                extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+            }\n+\n+            #[lang = \"deref\"]\n+            pub trait Deref {\n+                type Target: ?Sized;\n+\n+                fn deref(&self) -> &Self::Target;\n+            }\n+\n+            #[lang = \"owned_box\"]\n+            pub struct Box<T: ?Sized> {\n+                inner: *mut T,\n+            }\n+\n+            impl<T: ?Sized> Deref for Box<T> {\n+                type Target = T;\n+\n+                fn deref(&self) -> &T {\n+                    &self.inner\n+                }\n+            }\n+\n+            enum Option<T> {\n+                None,\n+                Some(T)\n+            }\n+\n+            fn foo() {\n+                let s<|> = Option::None;\n+                let f: Box<dyn FnOnce(&Option<i32>)> = box (|ps| {});\n+                f(&s)\n+            }\n+        \"#,\n+            &[\"Option<i32>\"],\n+        );\n+    }\n }"}]}