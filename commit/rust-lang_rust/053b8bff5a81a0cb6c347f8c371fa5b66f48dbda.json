{"sha": "053b8bff5a81a0cb6c347f8c371fa5b66f48dbda", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1M2I4YmZmNWE4MWEwY2I2YzM0N2Y4YzM3MWZhNWI2NmY0OGRiZGE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-13T01:43:44Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-16T17:29:08Z"}, "message": "Accept main(args: [str]) as main signature", "tree": {"sha": "752d4e2080007d6e51545193bbdf8d7ce8e0f316", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/752d4e2080007d6e51545193bbdf8d7ce8e0f316"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/053b8bff5a81a0cb6c347f8c371fa5b66f48dbda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/053b8bff5a81a0cb6c347f8c371fa5b66f48dbda", "html_url": "https://github.com/rust-lang/rust/commit/053b8bff5a81a0cb6c347f8c371fa5b66f48dbda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/053b8bff5a81a0cb6c347f8c371fa5b66f48dbda/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76aab80e3988caf71b7d6299e5a7ebb06cf2bbbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/76aab80e3988caf71b7d6299e5a7ebb06cf2bbbb", "html_url": "https://github.com/rust-lang/rust/commit/76aab80e3988caf71b7d6299e5a7ebb06cf2bbbb"}], "stats": {"total": 240, "additions": 221, "deletions": 19}, "files": [{"sha": "e6f40709f38e3d2513f6398a0cbbe7edd86fb33c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 136, "deletions": 11, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/053b8bff5a81a0cb6c347f8c371fa5b66f48dbda/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053b8bff5a81a0cb6c347f8c371fa5b66f48dbda/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=053b8bff5a81a0cb6c347f8c371fa5b66f48dbda", "patch": "@@ -6345,28 +6345,153 @@ fn decl_fn_and_pair_full(ccx: &@crate_ctxt, sp: &span, path: &[str],\n       }\n       _ { ccx.sess.bug(\"decl_fn_and_pair(): fn item doesn't have fn type!\"); }\n     }\n-    let is_main: bool = is_main_name(path) && !ccx.sess.get_opts().library;\n-    // Declare the function itself.\n \n-    let s: str =\n-        if is_main {\n-            \"_rust_main\"\n-        } else { mangle_internal_name_by_path(ccx, path) };\n+    let s: str =  mangle_internal_name_by_path(ccx, path);\n     let llfn: ValueRef = decl_internal_fastcall_fn(ccx.llmod, s, llfty);\n     // Declare the global constant pair that points to it.\n \n     let ps: str = mangle_exported_name(ccx, path, node_type);\n     register_fn_pair(ccx, ps, llfty, llfn, node_id);\n+\n+    let is_main: bool = is_main_name(path) && !ccx.sess.get_opts().library;\n     if is_main {\n-        if ccx.main_fn != none[ValueRef] {\n-            ccx.sess.span_fatal(sp, \"multiple 'main' functions\");\n+        create_main_wrapper(ccx, sp, llfn, node_type);\n+    }\n+}\n+\n+fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span,\n+                       main_llfn: ValueRef, main_node_type: ty::t) {\n+\n+    if ccx.main_fn != none[ValueRef] {\n+        ccx.sess.span_fatal(sp, \"multiple 'main' functions\");\n+    }\n+\n+    tag main_mode {\n+        mm_nil;\n+        mm_vec;\n+        mm_ivec;\n+    };\n+\n+    let main_mode = alt ty::struct(ccx.tcx, main_node_type) {\n+      ty::ty_fn(_, args, _ ,_ ,_) {\n+        if std::ivec::len(args) == 0u {\n+            mm_nil\n+        } else {\n+            alt ty::struct(ccx.tcx, args.(0).ty) {\n+              ty::ty_ivec(_) { mm_ivec }\n+              ty::ty_vec(_) { mm_vec }\n+            }\n         }\n-        llvm::LLVMSetLinkage(llfn,\n-                             lib::llvm::LLVMExternalLinkage as llvm::Linkage);\n-        ccx.main_fn = some(llfn);\n+      }\n+    };\n+\n+    // Have to create two different main functions depending on whether\n+    // main was declared to take vec or ivec\n+    let llfn_vec = create_main_wrapper_vec(ccx, sp, main_llfn, main_mode);\n+    let llfn_ivec = create_main_wrapper_ivec(ccx, sp, main_llfn, main_mode);\n+    let takes_ivec = main_mode == mm_ivec;\n+    // Create a global to tell main.ll which main we want to use\n+    create_main_type_indicator(ccx, takes_ivec);\n+    ccx.main_fn = takes_ivec ? some(llfn_ivec) : some(llfn_vec);\n+\n+    fn create_main_wrapper_vec(ccx: &@crate_ctxt,\n+                               sp: &span,\n+                               main_llfn: ValueRef,\n+                               main_mode: main_mode) -> ValueRef {\n+\n+        let vecarg = {\n+            mode: ty::mo_val,\n+            ty: ty::mk_vec(ccx.tcx, {\n+                ty: ty::mk_str(ccx.tcx),\n+                mut: ast::imm\n+            })\n+        };\n+        let llfty = type_of_fn(ccx, sp,\n+                               ast::proto_fn,\n+                               ~[vecarg],\n+                               ty::mk_nil(ccx.tcx),\n+                               0u);\n+        let llfdecl = decl_fastcall_fn(ccx.llmod, \"_rust_main\", llfty);\n+\n+        let fcx = new_fn_ctxt(new_local_ctxt(ccx), sp, llfdecl);\n+        let bcx = new_top_block_ctxt(fcx);\n+\n+        if main_mode != mm_ivec {\n+            let lloutputarg = llvm::LLVMGetParam(llfdecl, 0u);\n+            let lltaskarg = llvm::LLVMGetParam(llfdecl, 1u);\n+            let llenvarg = llvm::LLVMGetParam(llfdecl, 2u);\n+            let llargvarg = llvm::LLVMGetParam(llfdecl, 3u);\n+            let args = alt main_mode {\n+              mm_nil. { ~[lloutputarg,\n+                          lltaskarg,\n+                          llenvarg] }\n+              mm_vec. { ~[lloutputarg,\n+                          lltaskarg,\n+                          llenvarg,\n+                          llargvarg] }\n+            };\n+            bcx.build.FastCall(main_llfn, args);\n+        }\n+        bcx.build.RetVoid();\n+\n+        let lltop = bcx.llbb;\n+        finish_fn(fcx, lltop);\n+\n+        ret llfdecl;\n+    }\n+\n+    fn create_main_wrapper_ivec(ccx: &@crate_ctxt,\n+                                sp: &span,\n+                                main_llfn: ValueRef,\n+                                main_mode: main_mode) -> ValueRef {\n+        let ivecarg = {\n+            mode: ty::mo_val,\n+            ty: ty::mk_ivec(ccx.tcx, {\n+                ty: ty::mk_str(ccx.tcx),\n+                mut: ast::imm\n+            })\n+        };\n+        let llfty = type_of_fn(ccx, sp,\n+                               ast::proto_fn,\n+                               ~[ivecarg],\n+                               ty::mk_nil(ccx.tcx),\n+                               0u);\n+        let llfdecl = decl_fastcall_fn(ccx.llmod, \"_rust_main_ivec\", llfty);\n+\n+        let fcx = new_fn_ctxt(new_local_ctxt(ccx), sp, llfdecl);\n+        let bcx = new_top_block_ctxt(fcx);\n+\n+        if main_mode == mm_ivec {\n+            let lloutputarg = llvm::LLVMGetParam(llfdecl, 0u);\n+            let lltaskarg = llvm::LLVMGetParam(llfdecl, 1u);\n+            let llenvarg = llvm::LLVMGetParam(llfdecl, 2u);\n+            let llargvarg = llvm::LLVMGetParam(llfdecl, 3u);\n+            let args = ~[lloutputarg,\n+                         lltaskarg,\n+                         llenvarg,\n+                         llargvarg];\n+            bcx.build.FastCall(main_llfn, args);\n+        }\n+        bcx.build.RetVoid();\n+\n+        let lltop = bcx.llbb;\n+        finish_fn(fcx, lltop);\n+\n+        ret llfdecl;\n+    }\n+\n+    // FIXME: Remove after main takes only ivec\n+    // Sets a global value hinting to the runtime whether main takes\n+    // a vec or an ivec\n+    fn create_main_type_indicator(ccx: &@crate_ctxt, takes_ivec: bool) {\n+        let i = llvm::LLVMAddGlobal(ccx.llmod, T_int(),\n+                                    str::buf(\"_rust_main_is_ivec\"));\n+        llvm::LLVMSetInitializer(i, C_int(takes_ivec as int));\n+        llvm::LLVMSetGlobalConstant(i, True);\n     }\n }\n \n+\n // Create a closure: a pair containing (1) a ValueRef, pointing to where the\n // fn's definition is in the executable we're creating, and (2) a pointer to\n // space for the function's environment."}, {"sha": "b2a232c33c70e6bd1c484c8033823b122165a8ea", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/053b8bff5a81a0cb6c347f8c371fa5b66f48dbda/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053b8bff5a81a0cb6c347f8c371fa5b66f48dbda/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=053b8bff5a81a0cb6c347f8c371fa5b66f48dbda", "patch": "@@ -2715,13 +2715,21 @@ fn check_item(ccx: @crate_ctxt, it: &@ast::item) {\n \n fn arg_is_argv_ty(tcx: &ty::ctxt, a: &ty::arg) -> bool {\n     alt ty::struct(tcx, a.ty) {\n+      // FIXME: Remove after main takes only ivec\n       ty::ty_vec(mt) {\n         if mt.mut != ast::imm { ret false; }\n         alt ty::struct(tcx, mt.ty) {\n           ty::ty_str. { ret true; }\n           _ { ret false; }\n         }\n       }\n+      ty::ty_ivec(mt) {\n+        if mt.mut != ast::imm { ret false; }\n+        alt ty::struct(tcx, mt.ty) {\n+          ty::ty_str. { ret true; }\n+          _ { ret false; }\n+        }\n+      }\n       _ { ret false; }\n     }\n }"}, {"sha": "2081200ba9471acd01a4f004c400ca1b415e6198", "filename": "src/rt/main.ll.in", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/053b8bff5a81a0cb6c347f8c371fa5b66f48dbda/src%2Frt%2Fmain.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/053b8bff5a81a0cb6c347f8c371fa5b66f48dbda/src%2Frt%2Fmain.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmain.ll.in?ref=053b8bff5a81a0cb6c347f8c371fa5b66f48dbda", "patch": "@@ -6,23 +6,48 @@\n %5 = type { i32, i32, i32, i32, [0 x %6*] }\n %6 = type { i32, i32, i32, i32, [0 x i8] }\n \n+%tydesc = type { %tydesc**, i32, i32, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*, i8*, i8)* }\n+\n+%task = type { i32, i32, i32, i32, i32, i32, i32, i32 }\n+\n+%ivec = type { i32, i32, [4 x { i32, i32, i32, i32, [0 x i8] }*] }\n \n @_rust_crate_map_toplevel = external global %0\n \n-declare fastcc void @_rust_main(i1* nocapture, %task*, %2* nocapture, %5*);\n-declare i32 @rust_start(i32, i32, i32, i32)\n+; FIXME: Remove after main takes only ivec\n+@_rust_main_is_ivec = external global i32\n \n-%tydesc = type { %tydesc**, i32, i32, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*, i8*, i8)* }\n+declare i32 @rust_start(i32, i32, i32, i32)\n \n-%task = type { i32, i32, i32, i32, i32, i32, i32, i32 }\n+declare external fastcc void @_rust_main(i1* nocapture, %task*, %2* nocapture, %5*);\n \n define void @_rust_main_wrap(i1* nocapture, %task *, %2* nocapture, %5 *)\n {\n   tail call fastcc void @_rust_main(i1* %0, %task *%1, %2* nocapture %2, %5 *%3)\n   ret void\n }\n \n+declare i32 @rust_start_ivec(i32, i32, i32, i32, i32)\n+\n+declare external fastcc void @_rust_main_ivec(i1* nocapture, %task*, %2* nocapture, %ivec)\n+\n+define void @_rust_main_wrap_ivec(i1* nocapture, %task *, %2* nocapture, %ivec *)\n+{\n+  %ivec = load %ivec *%3\n+  tail call fastcc void @_rust_main_ivec(i1* %0, %task *%1, %2* nocapture %2, %ivec %ivec)\n+  ret void\n+}\n+\n define i32 @\"MAIN\"(i32, i32) {\n+  %is_ivec = load i32 *@_rust_main_is_ivec\n+  %is_ivec1 = trunc i32 %is_ivec to i1\n+  br i1 %is_ivec1, label %ivec, label %evec\n+\n+evec:\n   %3 = tail call i32 @rust_start(i32 ptrtoint (void (i1*, %task*, %2*, %5*)* @_rust_main_wrap to i32), i32 %0, i32 %1, i32 ptrtoint (%0* @_rust_crate_map_toplevel to i32))\n   ret i32 %3\n+\n+ivec:\n+  %4 = tail call i32 @rust_start_ivec(i32 ptrtoint (void (i1*, %task*, %2*, %ivec*)* @_rust_main_wrap_ivec to i32), i32 %0, i32 %1, i32 ptrtoint (%0* @_rust_crate_map_toplevel to i32), i32 %is_ivec)\n+  ret i32 %4\n }"}, {"sha": "c211408d4d4de1755916dc223ae47155da25220e", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/053b8bff5a81a0cb6c347f8c371fa5b66f48dbda/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/053b8bff5a81a0cb6c347f8c371fa5b66f48dbda/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=053b8bff5a81a0cb6c347f8c371fa5b66f48dbda", "patch": "@@ -10,10 +10,12 @@ command_line_args : public kernel_owned<command_line_args>\n \n     // vec[str] passed to rust_task::start.\n     rust_vec *args;\n+    rust_ivec *args_ivec;\n \n     command_line_args(rust_task *task,\n                       int sys_argc,\n-                      char **sys_argv)\n+                      char **sys_argv,\n+                      bool main_is_ivec)\n         : kernel(task->kernel),\n           task(task),\n           argc(sys_argc),\n@@ -49,15 +51,39 @@ command_line_args : public kernel_owned<command_line_args>\n             mem = kernel->malloc(str_alloc, \"command line arg\");\n             strs[i] = new (mem) rust_str(str_alloc, str_fill,\n                                          (uint8_t const *)argv[i]);\n+            strs[i]->ref_count++;\n         }\n         args->fill = vec_fill;\n         // If the caller has a declared args array, they may drop; but\n         // we don't know if they have such an array. So we pin the args\n         // array here to ensure it survives to program-shutdown.\n         args->ref();\n+\n+        if (main_is_ivec) {\n+            size_t ivec_interior_sz =\n+                sizeof(size_t) * 2 + sizeof(rust_str *) * 4;\n+            args_ivec = (rust_ivec *)\n+                kernel->malloc(ivec_interior_sz,\n+                               \"command line arg interior\");\n+            args_ivec->fill = 0;\n+            size_t ivec_exterior_sz = sizeof(rust_str *) * argc;\n+            args_ivec->alloc = ivec_exterior_sz;\n+            // NB: This is freed by some ivec machinery, probably the drop\n+            // glue in main, so we don't free it ourselves\n+            args_ivec->payload.ptr = (rust_ivec_heap *)\n+                kernel->malloc(ivec_exterior_sz + sizeof(size_t),\n+                               \"command line arg exterior\");\n+            args_ivec->payload.ptr->fill = ivec_exterior_sz;\n+            memcpy(&args_ivec->payload.ptr->data, strs, ivec_exterior_sz);\n+        } else {\n+            args_ivec = NULL;\n+        }\n     }\n \n     ~command_line_args() {\n+        if (args_ivec) {\n+            kernel->free(args_ivec);\n+        }\n         if (args) {\n             // Drop the args we've had pinned here.\n             rust_str **strs = (rust_str**) &args->data[0];\n@@ -84,7 +110,8 @@ command_line_args : public kernel_owned<command_line_args>\n int check_claims = 0;\n \n extern \"C\" CDECL int\n-rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n+rust_start_ivec(uintptr_t main_fn, int argc, char **argv,\n+                void* crate_map, int main_is_ivec) {\n \n     rust_env *env = load_env();\n \n@@ -99,15 +126,21 @@ rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n     rust_scheduler *sched = root_task->sched;\n     command_line_args *args\n         = new (kernel, \"main command line args\")\n-        command_line_args(root_task, argc, argv);\n+        command_line_args(root_task, argc, argv, main_is_ivec);\n \n     DLOG(sched, dom, \"startup: %d args in 0x%\" PRIxPTR,\n              args->argc, (uintptr_t)args->args);\n     for (int i = 0; i < args->argc; i++) {\n         DLOG(sched, dom, \"startup: arg[%d] = '%s'\", i, args->argv[i]);\n     }\n \n-    root_task->start(main_fn, (uintptr_t)args->args);\n+    if (main_is_ivec) {\n+        DLOG(sched, dom, \"main takes ivec\");\n+        root_task->start(main_fn, (uintptr_t)args->args_ivec);\n+    } else {\n+        DLOG(sched, dom, \"main takes vec\");\n+        root_task->start(main_fn, (uintptr_t)args->args);\n+    }\n     root_task->deref();\n     root_task = NULL;\n \n@@ -127,6 +160,13 @@ rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n     return ret;\n }\n \n+extern \"C\" CDECL int\n+rust_start(uintptr_t main_fn, int argc, char **argv,\n+           void* crate_map) {\n+    return rust_start_ivec(main_fn, argc, argv, crate_map, 0);\n+}\n+\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "88da5814c610a3729fb054120651b8d21dd59c81", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/053b8bff5a81a0cb6c347f8c371fa5b66f48dbda/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/053b8bff5a81a0cb6c347f8c371fa5b66f48dbda/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=053b8bff5a81a0cb6c347f8c371fa5b66f48dbda", "patch": "@@ -62,6 +62,7 @@ rust_process_wait\n rust_ptr_eq\n rust_run_program\n rust_start\n+rust_start_ivec\n rust_getcwd\n set_min_stack\n sched_threads"}, {"sha": "e3d1403411b14626ec4b1bd3f76200695153784c", "filename": "src/test/run-pass/main-ivec.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/053b8bff5a81a0cb6c347f8c371fa5b66f48dbda/src%2Ftest%2Frun-pass%2Fmain-ivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053b8bff5a81a0cb6c347f8c371fa5b66f48dbda/src%2Ftest%2Frun-pass%2Fmain-ivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmain-ivec.rs?ref=053b8bff5a81a0cb6c347f8c371fa5b66f48dbda", "patch": "@@ -0,0 +1,3 @@\n+fn main(args: [str]) {\n+    for s in args { log s }\n+}\n\\ No newline at end of file"}]}