{"sha": "9fba7cf827cf332800053eb26f10d67efeee7886", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmYmE3Y2Y4MjdjZjMzMjgwMDA1M2ViMjZmMTBkNjdlZmVlZTc4ODY=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-09T12:18:58Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-09T12:18:58Z"}, "message": "Move some more stuff to better places", "tree": {"sha": "1c1ddd6474b7b8864e918471e0fbe23f3f67ff93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c1ddd6474b7b8864e918471e0fbe23f3f67ff93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fba7cf827cf332800053eb26f10d67efeee7886", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fba7cf827cf332800053eb26f10d67efeee7886", "html_url": "https://github.com/rust-lang/rust/commit/9fba7cf827cf332800053eb26f10d67efeee7886", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fba7cf827cf332800053eb26f10d67efeee7886/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ca481bbdc75bd3a9dbce4c94b014bd0eb8bd9e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ca481bbdc75bd3a9dbce4c94b014bd0eb8bd9e8", "html_url": "https://github.com/rust-lang/rust/commit/5ca481bbdc75bd3a9dbce4c94b014bd0eb8bd9e8"}], "stats": {"total": 193, "additions": 93, "deletions": 100}, "files": [{"sha": "9d07ad597bc446a27605f9e2d009020a1c3ee631", "filename": "crates/hir_ty/src/chalk_db.rs", "status": "modified", "additions": 61, "deletions": 40, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/9fba7cf827cf332800053eb26f10d67efeee7886/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fba7cf827cf332800053eb26f10d67efeee7886/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs?ref=9fba7cf827cf332800053eb26f10d67efeee7886", "patch": "@@ -4,30 +4,28 @@ use std::sync::Arc;\n \n use log::debug;\n \n-use chalk_ir::{fold::shift::Shift, CanonicalVarKinds};\n+use chalk_ir::{cast::Cast, fold::shift::Shift, CanonicalVarKinds};\n use chalk_solve::rust_ir::{self, OpaqueTyDatumBound, WellKnownTrait};\n \n-use base_db::{salsa::InternKey, CrateId};\n+use base_db::CrateId;\n use hir_def::{\n     lang_item::{lang_attr, LangItemTarget},\n-    AssocContainerId, AssocItemId, HasModule, Lookup, TypeAliasId,\n+    AssocContainerId, AssocItemId, GenericDefId, HasModule, Lookup, TypeAliasId,\n };\n use hir_expand::name::name;\n \n use crate::{\n     db::HirDatabase,\n     display::HirDisplay,\n     from_assoc_type_id, make_only_type_binders,\n-    mapping::{\n-        convert_where_clauses, from_chalk, generic_predicate_to_inline_bound, ToChalk,\n-        TypeAliasAsValue,\n-    },\n+    mapping::{from_chalk, ToChalk, TypeAliasAsValue},\n     method_resolution::{TyFingerprint, ALL_FLOAT_FPS, ALL_INT_FPS},\n     to_assoc_type_id, to_chalk_trait_id,\n     traits::ChalkContext,\n     utils::generics,\n     AliasEq, AliasTy, BoundVar, CallableDefId, DebruijnIndex, FnDefId, Interner, ProjectionTy,\n-    Substitution, TraitRef, TraitRefExt, Ty, TyBuilder, TyExt, TyKind, WhereClause,\n+    ProjectionTyExt, QuantifiedWhereClause, Substitution, TraitRef, TraitRefExt, Ty, TyBuilder,\n+    TyExt, TyKind, WhereClause,\n };\n \n pub(crate) type AssociatedTyDatum = chalk_solve::rust_ir::AssociatedTyDatum<Interner>;\n@@ -39,7 +37,6 @@ pub(crate) type OpaqueTyDatum = chalk_solve::rust_ir::OpaqueTyDatum<Interner>;\n pub(crate) type AssocTypeId = chalk_ir::AssocTypeId<Interner>;\n pub(crate) type TraitId = chalk_ir::TraitId<Interner>;\n pub(crate) type AdtId = chalk_ir::AdtId<Interner>;\n-pub(crate) type OpaqueTyId = chalk_ir::OpaqueTyId<Interner>;\n pub(crate) type ImplId = chalk_ir::ImplId<Interner>;\n pub(crate) type AssociatedTyValueId = chalk_solve::rust_ir::AssociatedTyValueId<Interner>;\n pub(crate) type AssociatedTyValue = chalk_solve::rust_ir::AssociatedTyValue<Interner>;\n@@ -679,38 +676,62 @@ pub(crate) fn adt_variance_query(\n     )\n }\n \n-impl From<FnDefId> for crate::db::InternedCallableDefId {\n-    fn from(fn_def_id: FnDefId) -> Self {\n-        InternKey::from_intern_id(fn_def_id.0)\n-    }\n-}\n-\n-impl From<crate::db::InternedCallableDefId> for FnDefId {\n-    fn from(callable_def_id: crate::db::InternedCallableDefId) -> Self {\n-        chalk_ir::FnDefId(callable_def_id.as_intern_id())\n-    }\n-}\n-\n-impl From<OpaqueTyId> for crate::db::InternedOpaqueTyId {\n-    fn from(id: OpaqueTyId) -> Self {\n-        InternKey::from_intern_id(id.0)\n-    }\n-}\n-\n-impl From<crate::db::InternedOpaqueTyId> for OpaqueTyId {\n-    fn from(id: crate::db::InternedOpaqueTyId) -> Self {\n-        chalk_ir::OpaqueTyId(id.as_intern_id())\n-    }\n-}\n-\n-impl From<chalk_ir::ClosureId<Interner>> for crate::db::InternedClosureId {\n-    fn from(id: chalk_ir::ClosureId<Interner>) -> Self {\n-        Self::from_intern_id(id.0)\n-    }\n+pub(super) fn convert_where_clauses(\n+    db: &dyn HirDatabase,\n+    def: GenericDefId,\n+    substs: &Substitution,\n+) -> Vec<chalk_ir::QuantifiedWhereClause<Interner>> {\n+    let generic_predicates = db.generic_predicates(def);\n+    let mut result = Vec::with_capacity(generic_predicates.len());\n+    for pred in generic_predicates.iter() {\n+        result.push(pred.clone().substitute(&Interner, substs));\n+    }\n+    result\n }\n \n-impl From<crate::db::InternedClosureId> for chalk_ir::ClosureId<Interner> {\n-    fn from(id: crate::db::InternedClosureId) -> Self {\n-        chalk_ir::ClosureId(id.as_intern_id())\n+pub(super) fn generic_predicate_to_inline_bound(\n+    db: &dyn HirDatabase,\n+    pred: &QuantifiedWhereClause,\n+    self_ty: &Ty,\n+) -> Option<chalk_ir::Binders<rust_ir::InlineBound<Interner>>> {\n+    // An InlineBound is like a GenericPredicate, except the self type is left out.\n+    // We don't have a special type for this, but Chalk does.\n+    let self_ty_shifted_in = self_ty.clone().shifted_in_from(&Interner, DebruijnIndex::ONE);\n+    let (pred, binders) = pred.as_ref().into_value_and_skipped_binders();\n+    match pred {\n+        WhereClause::Implemented(trait_ref) => {\n+            if trait_ref.self_type_parameter(&Interner) != self_ty_shifted_in {\n+                // we can only convert predicates back to type bounds if they\n+                // have the expected self type\n+                return None;\n+            }\n+            let args_no_self = trait_ref.substitution.as_slice(&Interner)[1..]\n+                .iter()\n+                .map(|ty| ty.clone().cast(&Interner))\n+                .collect();\n+            let trait_bound = rust_ir::TraitBound { trait_id: trait_ref.trait_id, args_no_self };\n+            Some(chalk_ir::Binders::new(binders, rust_ir::InlineBound::TraitBound(trait_bound)))\n+        }\n+        WhereClause::AliasEq(AliasEq { alias: AliasTy::Projection(projection_ty), ty }) => {\n+            if projection_ty.self_type_parameter(&Interner) != self_ty_shifted_in {\n+                return None;\n+            }\n+            let trait_ = projection_ty.trait_(db);\n+            let args_no_self = projection_ty.substitution.as_slice(&Interner)[1..]\n+                .iter()\n+                .map(|ty| ty.clone().cast(&Interner))\n+                .collect();\n+            let alias_eq_bound = rust_ir::AliasEqBound {\n+                value: ty.clone(),\n+                trait_bound: rust_ir::TraitBound { trait_id: trait_.to_chalk(db), args_no_self },\n+                associated_ty_id: projection_ty.associated_ty_id,\n+                parameters: Vec::new(), // FIXME we don't support generic associated types yet\n+            };\n+            Some(chalk_ir::Binders::new(\n+                binders,\n+                rust_ir::InlineBound::AliasEqBound(alias_eq_bound),\n+            ))\n+        }\n+        _ => None,\n     }\n }"}, {"sha": "37c93519413d696101643c7dd9e3f16cbca173d6", "filename": "crates/hir_ty/src/mapping.rs", "status": "modified", "additions": 32, "deletions": 60, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/9fba7cf827cf332800053eb26f10d67efeee7886/crates%2Fhir_ty%2Fsrc%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fba7cf827cf332800053eb26f10d67efeee7886/crates%2Fhir_ty%2Fsrc%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmapping.rs?ref=9fba7cf827cf332800053eb26f10d67efeee7886", "patch": "@@ -3,16 +3,12 @@\n //! Chalk (in both directions); plus some helper functions for more specialized\n //! conversions.\n \n-use chalk_ir::{cast::Cast, fold::Shift, DebruijnIndex};\n use chalk_solve::rust_ir;\n \n use base_db::salsa::InternKey;\n-use hir_def::{GenericDefId, TypeAliasId};\n+use hir_def::TypeAliasId;\n \n-use crate::{\n-    chalk_db, db::HirDatabase, AliasEq, AliasTy, CallableDefId, FnDefId, Interner, ProjectionTyExt,\n-    QuantifiedWhereClause, Substitution, Ty, WhereClause,\n-};\n+use crate::{chalk_db, db::HirDatabase, CallableDefId, FnDefId, Interner, OpaqueTyId};\n \n pub(crate) trait ToChalk {\n     type Chalk;\n@@ -80,62 +76,38 @@ impl ToChalk for TypeAliasAsValue {\n     }\n }\n \n-pub(super) fn convert_where_clauses(\n-    db: &dyn HirDatabase,\n-    def: GenericDefId,\n-    substs: &Substitution,\n-) -> Vec<chalk_ir::QuantifiedWhereClause<Interner>> {\n-    let generic_predicates = db.generic_predicates(def);\n-    let mut result = Vec::with_capacity(generic_predicates.len());\n-    for pred in generic_predicates.iter() {\n-        result.push(pred.clone().substitute(&Interner, substs));\n+impl From<FnDefId> for crate::db::InternedCallableDefId {\n+    fn from(fn_def_id: FnDefId) -> Self {\n+        InternKey::from_intern_id(fn_def_id.0)\n     }\n-    result\n }\n \n-pub(super) fn generic_predicate_to_inline_bound(\n-    db: &dyn HirDatabase,\n-    pred: &QuantifiedWhereClause,\n-    self_ty: &Ty,\n-) -> Option<chalk_ir::Binders<rust_ir::InlineBound<Interner>>> {\n-    // An InlineBound is like a GenericPredicate, except the self type is left out.\n-    // We don't have a special type for this, but Chalk does.\n-    let self_ty_shifted_in = self_ty.clone().shifted_in_from(&Interner, DebruijnIndex::ONE);\n-    let (pred, binders) = pred.as_ref().into_value_and_skipped_binders();\n-    match pred {\n-        WhereClause::Implemented(trait_ref) => {\n-            if trait_ref.self_type_parameter(&Interner) != self_ty_shifted_in {\n-                // we can only convert predicates back to type bounds if they\n-                // have the expected self type\n-                return None;\n-            }\n-            let args_no_self = trait_ref.substitution.as_slice(&Interner)[1..]\n-                .iter()\n-                .map(|ty| ty.clone().cast(&Interner))\n-                .collect();\n-            let trait_bound = rust_ir::TraitBound { trait_id: trait_ref.trait_id, args_no_self };\n-            Some(chalk_ir::Binders::new(binders, rust_ir::InlineBound::TraitBound(trait_bound)))\n-        }\n-        WhereClause::AliasEq(AliasEq { alias: AliasTy::Projection(projection_ty), ty }) => {\n-            if projection_ty.self_type_parameter(&Interner) != self_ty_shifted_in {\n-                return None;\n-            }\n-            let trait_ = projection_ty.trait_(db);\n-            let args_no_self = projection_ty.substitution.as_slice(&Interner)[1..]\n-                .iter()\n-                .map(|ty| ty.clone().cast(&Interner))\n-                .collect();\n-            let alias_eq_bound = rust_ir::AliasEqBound {\n-                value: ty.clone(),\n-                trait_bound: rust_ir::TraitBound { trait_id: trait_.to_chalk(db), args_no_self },\n-                associated_ty_id: projection_ty.associated_ty_id,\n-                parameters: Vec::new(), // FIXME we don't support generic associated types yet\n-            };\n-            Some(chalk_ir::Binders::new(\n-                binders,\n-                rust_ir::InlineBound::AliasEqBound(alias_eq_bound),\n-            ))\n-        }\n-        _ => None,\n+impl From<crate::db::InternedCallableDefId> for FnDefId {\n+    fn from(callable_def_id: crate::db::InternedCallableDefId) -> Self {\n+        chalk_ir::FnDefId(callable_def_id.as_intern_id())\n+    }\n+}\n+\n+impl From<OpaqueTyId> for crate::db::InternedOpaqueTyId {\n+    fn from(id: OpaqueTyId) -> Self {\n+        InternKey::from_intern_id(id.0)\n+    }\n+}\n+\n+impl From<crate::db::InternedOpaqueTyId> for OpaqueTyId {\n+    fn from(id: crate::db::InternedOpaqueTyId) -> Self {\n+        chalk_ir::OpaqueTyId(id.as_intern_id())\n+    }\n+}\n+\n+impl From<chalk_ir::ClosureId<Interner>> for crate::db::InternedClosureId {\n+    fn from(id: chalk_ir::ClosureId<Interner>) -> Self {\n+        Self::from_intern_id(id.0)\n+    }\n+}\n+\n+impl From<crate::db::InternedClosureId> for chalk_ir::ClosureId<Interner> {\n+    fn from(id: crate::db::InternedClosureId) -> Self {\n+        chalk_ir::ClosureId(id.as_intern_id())\n     }\n }"}]}