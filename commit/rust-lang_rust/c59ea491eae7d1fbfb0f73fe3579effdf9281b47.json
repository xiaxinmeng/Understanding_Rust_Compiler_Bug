{"sha": "c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1OWVhNDkxZWFlN2QxZmJmYjBmNzNmZTM1NzllZmZkZjkyODFiNDc=", "commit": {"author": {"name": "Benjamin Herr", "email": "ben@0x539.de", "date": "2016-03-28T23:46:02Z"}, "committer": {"name": "Benjamin Herr", "email": "ben@0x539.de", "date": "2016-03-31T20:06:52Z"}, "message": "librustc_trans: use bug!(), span_bug!()", "tree": {"sha": "05de85808fdf36bc557542100a8374a9fcaf1d6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05de85808fdf36bc557542100a8374a9fcaf1d6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "html_url": "https://github.com/rust-lang/rust/commit/c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/comments", "author": {"login": "ben0x539", "id": 24142, "node_id": "MDQ6VXNlcjI0MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/24142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ben0x539", "html_url": "https://github.com/ben0x539", "followers_url": "https://api.github.com/users/ben0x539/followers", "following_url": "https://api.github.com/users/ben0x539/following{/other_user}", "gists_url": "https://api.github.com/users/ben0x539/gists{/gist_id}", "starred_url": "https://api.github.com/users/ben0x539/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ben0x539/subscriptions", "organizations_url": "https://api.github.com/users/ben0x539/orgs", "repos_url": "https://api.github.com/users/ben0x539/repos", "events_url": "https://api.github.com/users/ben0x539/events{/privacy}", "received_events_url": "https://api.github.com/users/ben0x539/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ben0x539", "id": 24142, "node_id": "MDQ6VXNlcjI0MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/24142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ben0x539", "html_url": "https://github.com/ben0x539", "followers_url": "https://api.github.com/users/ben0x539/followers", "following_url": "https://api.github.com/users/ben0x539/following{/other_user}", "gists_url": "https://api.github.com/users/ben0x539/gists{/gist_id}", "starred_url": "https://api.github.com/users/ben0x539/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ben0x539/subscriptions", "organizations_url": "https://api.github.com/users/ben0x539/orgs", "repos_url": "https://api.github.com/users/ben0x539/repos", "events_url": "https://api.github.com/users/ben0x539/events{/privacy}", "received_events_url": "https://api.github.com/users/ben0x539/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35e160364df35104313ad0d6d884037e360bbd46", "url": "https://api.github.com/repos/rust-lang/rust/commits/35e160364df35104313ad0d6d884037e360bbd46", "html_url": "https://github.com/rust-lang/rust/commit/35e160364df35104313ad0d6d884037e360bbd46"}], "stats": {"total": 920, "additions": 436, "deletions": 484}, "files": [{"sha": "b27929c80c2d8a9a789d66d9130294f5a6b4ad3f", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -242,7 +242,7 @@ impl<'a> ConstantExpr<'a> {\n     fn eq(self, other: ConstantExpr<'a>, tcx: &TyCtxt) -> bool {\n         match compare_lit_exprs(tcx, self.0, other.0) {\n             Some(result) => result == Ordering::Equal,\n-            None => panic!(\"compare_list_exprs: type mismatch\"),\n+            None => bug!(\"compare_list_exprs: type mismatch\"),\n         }\n     }\n }\n@@ -828,7 +828,7 @@ impl FailureHandler {\n     fn handle_fail(&self, bcx: Block) {\n         match *self {\n             Infallible =>\n-                panic!(\"attempted to panic in a non-panicking panic handler!\"),\n+                bug!(\"attempted to panic in a non-panicking panic handler!\"),\n             JumpToBasicBlock(basic_block) =>\n                 Br(bcx, basic_block, DebugLoc::None),\n             Unreachable =>\n@@ -939,11 +939,11 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n \n                     compare_str(cx, lhs_data, lhs_len, rhs_data, rhs_len, rhs_t, debug_loc)\n                 },\n-                _ => cx.sess().bug(\"only byte strings supported in compare_values\"),\n+                _ => bug!(\"only byte strings supported in compare_values\"),\n             },\n-            _ => cx.sess().bug(\"only string and byte strings supported in compare_values\"),\n+            _ => bug!(\"only string and byte strings supported in compare_values\"),\n         },\n-        _ => cx.sess().bug(\"only scalars, byte strings, and strings supported in compare_values\"),\n+        _ => bug!(\"only scalars, byte strings, and strings supported in compare_values\"),\n     }\n }\n \n@@ -986,7 +986,7 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         Lvalue::new_with_hint(\"_match::insert_lllocals (match_input)\",\n                                               bcx, binding_info.id, hint_kind)\n                     }\n-                    _ => unreachable!(),\n+                    _ => bug!(),\n                 };\n                 let datum = Datum::new(llval, binding_info.ty, lvalue);\n                 call_lifetime_start(bcx, llbinding);\n@@ -1317,7 +1317,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                             bcx = r.bcx;\n                         }\n                         _ => {\n-                            bcx.sess().bug(\n+                            bug!(\n                                 \"in compile_submatch, expected \\\n                                  opt.trans() to return a SingleResult\")\n                         }"}, {"sha": "6edc26c70097ac4c470ce42c475350ff1de48025", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -218,7 +218,7 @@ impl FnType {\n             Rust | RustCall => llvm::CCallConv,\n \n             // It's the ABI's job to select this, not us.\n-            System => ccx.sess().bug(\"system abi should be selected elsewhere\"),\n+            System => bug!(\"system abi should be selected elsewhere\"),\n \n             Stdcall => llvm::X86StdcallCallConv,\n             Fastcall => llvm::X86FastcallCallConv,\n@@ -241,8 +241,8 @@ impl FnType {\n                     &tupled_arguments[..]\n                 }\n                 _ => {\n-                    unreachable!(\"argument to function with \\\"rust-call\\\" ABI \\\n-                                  is not a tuple\");\n+                    bug!(\"argument to function with \\\"rust-call\\\" ABI \\\n+                          is not a tuple\");\n                 }\n             }\n         } else {"}, {"sha": "8922aa061820f3ac8bd61e7abd07f03a194de735", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -302,9 +302,8 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // non-empty body, explicit discriminants should have\n             // been rejected by a checker before this point.\n             if !cases.iter().enumerate().all(|(i,c)| c.discr == Disr::from(i)) {\n-                cx.sess().bug(&format!(\"non-C-like enum {} with specified \\\n-                                        discriminants\",\n-                                       cx.tcx().item_path_str(def.did)));\n+                bug!(\"non-C-like enum {} with specified discriminants\",\n+                     cx.tcx().item_path_str(def.did));\n             }\n \n             if cases.len() == 1 {\n@@ -430,7 +429,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             General(ity, fields, dtor_to_init_u8(dtor))\n         }\n-        _ => cx.sess().bug(&format!(\"adt::represent_type called on non-ADT type: {}\", t))\n+        _ => bug!(\"adt::represent_type called on non-ADT type: {}\", t)\n     }\n }\n \n@@ -615,7 +614,7 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n     match hint {\n         attr::ReprInt(span, ity) => {\n             if !bounds_usable(cx, ity, bounds) {\n-                cx.sess().span_bug(span, \"representation hint insufficient for discriminant range\")\n+                span_bug!(span, \"representation hint insufficient for discriminant range\")\n             }\n             return ity;\n         }\n@@ -632,10 +631,10 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n             attempts = choose_shortest;\n         },\n         attr::ReprPacked => {\n-            cx.tcx().sess.bug(\"range_to_inttype: found ReprPacked on an enum\");\n+            bug!(\"range_to_inttype: found ReprPacked on an enum\");\n         }\n         attr::ReprSimd => {\n-            cx.tcx().sess.bug(\"range_to_inttype: found ReprSimd on an enum\");\n+            bug!(\"range_to_inttype: found ReprSimd on an enum\");\n         }\n     }\n     for &ity in attempts {\n@@ -835,7 +834,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                  Type::array(&Type::i64(cx), align_units),\n                 a if a.count_ones() == 1 => Type::array(&Type::vector(&Type::i32(cx), a / 4),\n                                                               align_units),\n-                _ => panic!(\"unsupported enum alignment: {}\", align)\n+                _ => bug!(\"unsupported enum alignment: {}\", align)\n             };\n             assert_eq!(machine::llalign_of_min(cx, fill_ty), align);\n             assert_eq!(padded_discr_size % discr_size, 0); // Ensure discr_ty can fill pad evenly\n@@ -984,7 +983,7 @@ pub fn trans_case<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr, discr: Disr)\n             C_integral(ll_inttype(bcx.ccx(), ity), discr.0, true)\n         }\n         Univariant(..) => {\n-            bcx.ccx().sess().bug(\"no cases for univariants or structs\")\n+            bug!(\"no cases for univariants or structs\")\n         }\n         RawNullablePointer { .. } |\n         StructWrappedNullablePointer { .. } => {\n@@ -1088,7 +1087,7 @@ pub fn trans_field_ptr_builder<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n     // someday), it will need to return a possibly-new bcx as well.\n     match *r {\n         CEnum(..) => {\n-            bcx.ccx().sess().bug(\"element access in C-like enum\")\n+            bug!(\"element access in C-like enum\")\n         }\n         Univariant(ref st, _dtor) => {\n             assert_eq!(discr, Disr(0));\n@@ -1279,7 +1278,7 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n             bcx_next\n         }\n-        _ => unreachable!()\n+        _ => bug!()\n     }\n }\n \n@@ -1319,7 +1318,7 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n             datum::DatumBlock::new(bcx, expr_datum)\n         }\n-        _ => bcx.ccx().sess().bug(\"tried to get drop flag of non-droppable type\")\n+        _ => bug!(\"tried to get drop flag of non-droppable type\")\n     }\n }\n \n@@ -1478,7 +1477,7 @@ pub fn const_get_discrim(r: &Repr, val: ValueRef) -> Disr {\n         }\n         Univariant(..) => Disr(0),\n         RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n-            unreachable!(\"const discrim access of non c-like enum\")\n+            bug!(\"const discrim access of non c-like enum\")\n         }\n     }\n }\n@@ -1488,10 +1487,10 @@ pub fn const_get_discrim(r: &Repr, val: ValueRef) -> Disr {\n ///\n /// (Not to be confused with `common::const_get_elt`, which operates on\n /// raw LLVM-level structs and arrays.)\n-pub fn const_get_field(ccx: &CrateContext, r: &Repr, val: ValueRef,\n-                       _discr: Disr, ix: usize) -> ValueRef {\n+pub fn const_get_field(r: &Repr, val: ValueRef, _discr: Disr,\n+                       ix: usize) -> ValueRef {\n     match *r {\n-        CEnum(..) => ccx.sess().bug(\"element access in C-like enum const\"),\n+        CEnum(..) => bug!(\"element access in C-like enum const\"),\n         Univariant(..) => const_struct_field(val, ix),\n         General(..) => const_struct_field(val, ix + 1),\n         RawNullablePointer { .. } => {"}, {"sha": "bd98b3950d44c634f1d019724666004be0aa8809", "filename": "src/librustc_trans/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_dep_graph.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -221,7 +221,7 @@ fn dump_graph(tcx: &TyCtxt) {\n             // Expect one of: \"-> target\", \"source -> target\", or \"source ->\".\n             let parts: Vec<_> = string.split(\"->\").collect();\n             if parts.len() > 2 {\n-                panic!(\"Invalid RUST_DEP_GRAPH_FILTER: expected '[source] -> [target]'\");\n+                bug!(\"Invalid RUST_DEP_GRAPH_FILTER: expected '[source] -> [target]'\");\n             }\n             let sources = node_set(&query, &parts[0]);\n             let targets = node_set(&query, &parts[1]);"}, {"sha": "7aef1d912ecceaabce11a024982902b8aa465674", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -187,8 +187,8 @@ pub fn link_binary(sess: &Session,\n     let mut out_filenames = Vec::new();\n     for &crate_type in sess.crate_types.borrow().iter() {\n         if invalid_output_for_target(sess, crate_type) {\n-            sess.bug(&format!(\"invalid output type `{:?}` for target os `{}`\",\n-                             crate_type, sess.opts.target_triple));\n+           bug!(\"invalid output type `{:?}` for target os `{}`\",\n+                crate_type, sess.opts.target_triple);\n         }\n         let out_file = link_binary_output(sess, trans, crate_type, outputs,\n                                           crate_name);\n@@ -282,7 +282,7 @@ pub fn each_linked_rlib(sess: &Session,\n     let fmts = fmts.get(&config::CrateTypeExecutable).or_else(|| {\n         fmts.get(&config::CrateTypeStaticlib)\n     }).unwrap_or_else(|| {\n-        sess.bug(\"could not find formats for rlibs\")\n+        bug!(\"could not find formats for rlibs\")\n     });\n     for (cnum, path) in crates {\n         match fmts[cnum as usize - 1] {\n@@ -895,7 +895,7 @@ fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n         match kind {\n             NativeLibraryKind::NativeUnknown => cmd.link_dylib(l),\n             NativeLibraryKind::NativeFramework => cmd.link_framework(l),\n-            NativeLibraryKind::NativeStatic => unreachable!(),\n+            NativeLibraryKind::NativeStatic => bug!(),\n         }\n     }\n }\n@@ -1081,7 +1081,7 @@ fn add_upstream_native_libraries(cmd: &mut Linker, sess: &Session) {\n                 NativeLibraryKind::NativeUnknown => cmd.link_dylib(lib),\n                 NativeLibraryKind::NativeFramework => cmd.link_framework(lib),\n                 NativeLibraryKind::NativeStatic => {\n-                    sess.bug(\"statics shouldn't be propagated\");\n+                    bug!(\"statics shouldn't be propagated\");\n                 }\n             }\n         }"}, {"sha": "c02a482f81275c2248e3a796608cf7e06e1fc078", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -271,10 +271,10 @@ impl<'a> Linker for MsvcLinker<'a> {\n     }\n \n     fn framework_path(&mut self, _path: &Path) {\n-        panic!(\"frameworks are not supported on windows\")\n+        bug!(\"frameworks are not supported on windows\")\n     }\n     fn link_framework(&mut self, _framework: &str) {\n-        panic!(\"frameworks are not supported on windows\")\n+        bug!(\"frameworks are not supported on windows\")\n     }\n \n     fn link_whole_staticlib(&mut self, lib: &str, _search_path: &[PathBuf]) {"}, {"sha": "a458307da407048b5ac3e26ed0a1c4dd8595963e", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -224,8 +224,8 @@ fn exported_name_with_opt_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 // to be a value or type-def or something in there\n                 // *somewhere*\n                 ty_def_id.index = key.parent.unwrap_or_else(|| {\n-                    panic!(\"finding type for {:?}, encountered def-id {:?} with no \\\n-                            parent\", def_id, ty_def_id);\n+                    bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n+                         parent\", def_id, ty_def_id);\n                 });\n             }\n         }"}, {"sha": "e6a51eb7c87e994a2f86398f40bff8c54f0f1e76", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -113,7 +113,7 @@ impl Emitter for SharedEmitter {\n     }\n \n     fn custom_emit(&mut self, _sp: &errors::RenderSpan, _msg: &str, _lvl: Level) {\n-        panic!(\"SharedEmitter doesn't support custom_emit\");\n+        bug!(\"SharedEmitter doesn't support custom_emit\");\n     }\n }\n \n@@ -159,7 +159,7 @@ pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n                                  .cg\n                                  .relocation_model));\n             sess.abort_if_errors();\n-            unreachable!();\n+            bug!();\n         }\n     };\n \n@@ -190,7 +190,7 @@ pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n                                  .cg\n                                  .code_model));\n             sess.abort_if_errors();\n-            unreachable!();\n+            bug!();\n         }\n     };\n "}, {"sha": "e5667e06b44113b2fc368721b8d4db72c5ab0761", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 41, "deletions": 45, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -227,8 +227,7 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n \n-pub fn bin_op_to_icmp_predicate(ccx: &CrateContext,\n-                                op: hir::BinOp_,\n+pub fn bin_op_to_icmp_predicate(op: hir::BinOp_,\n                                 signed: bool)\n                                 -> llvm::IntPredicate {\n     match op {\n@@ -239,15 +238,14 @@ pub fn bin_op_to_icmp_predicate(ccx: &CrateContext,\n         hir::BiGt => if signed { llvm::IntSGT } else { llvm::IntUGT },\n         hir::BiGe => if signed { llvm::IntSGE } else { llvm::IntUGE },\n         op => {\n-            ccx.sess()\n-               .bug(&format!(\"comparison_op_to_icmp_predicate: expected comparison operator, \\\n-                              found {:?}\",\n-                             op));\n+            bug!(\"comparison_op_to_icmp_predicate: expected comparison operator, \\\n+                  found {:?}\",\n+                 op)\n         }\n     }\n }\n \n-pub fn bin_op_to_fcmp_predicate(ccx: &CrateContext, op: hir::BinOp_) -> llvm::RealPredicate {\n+pub fn bin_op_to_fcmp_predicate(op: hir::BinOp_) -> llvm::RealPredicate {\n     match op {\n         hir::BiEq => llvm::RealOEQ,\n         hir::BiNe => llvm::RealUNE,\n@@ -256,10 +254,9 @@ pub fn bin_op_to_fcmp_predicate(ccx: &CrateContext, op: hir::BinOp_) -> llvm::Re\n         hir::BiGt => llvm::RealOGT,\n         hir::BiGe => llvm::RealOGE,\n         op => {\n-            ccx.sess()\n-               .bug(&format!(\"comparison_op_to_fcmp_predicate: expected comparison operator, \\\n-                              found {:?}\",\n-                             op));\n+            bug!(\"comparison_op_to_fcmp_predicate: expected comparison operator, \\\n+                  found {:?}\",\n+                 op);\n         }\n     }\n }\n@@ -291,7 +288,7 @@ pub fn compare_fat_ptrs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 hir::BiLe => (llvm::IntULE, llvm::IntULT),\n                 hir::BiGt => (llvm::IntUGT, llvm::IntUGT),\n                 hir::BiGe => (llvm::IntUGE, llvm::IntUGT),\n-                _ => unreachable!(),\n+                _ => bug!(),\n             };\n \n             let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n@@ -302,7 +299,7 @@ pub fn compare_fat_ptrs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             Or(bcx, addr_strict, addr_eq_extra_op, debug_loc)\n         }\n         _ => {\n-            bcx.tcx().sess.bug(\"unexpected fat ptr binop\");\n+            bug!(\"unexpected fat ptr binop\");\n         }\n     }\n }\n@@ -322,19 +319,19 @@ pub fn compare_scalar_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 hir::BiEq | hir::BiLe | hir::BiGe => return C_bool(bcx.ccx(), true),\n                 hir::BiNe | hir::BiLt | hir::BiGt => return C_bool(bcx.ccx(), false),\n                 // refinements would be nice\n-                _ => bcx.sess().bug(\"compare_scalar_types: must be a comparison operator\"),\n+                _ => bug!(\"compare_scalar_types: must be a comparison operator\"),\n             }\n         }\n         ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyBool | ty::TyUint(_) | ty::TyChar => {\n             ICmp(bcx,\n-                 bin_op_to_icmp_predicate(bcx.ccx(), op, false),\n+                 bin_op_to_icmp_predicate(op, false),\n                  lhs,\n                  rhs,\n                  debug_loc)\n         }\n         ty::TyRawPtr(mt) if common::type_is_sized(bcx.tcx(), mt.ty) => {\n             ICmp(bcx,\n-                 bin_op_to_icmp_predicate(bcx.ccx(), op, false),\n+                 bin_op_to_icmp_predicate(op, false),\n                  lhs,\n                  rhs,\n                  debug_loc)\n@@ -356,20 +353,20 @@ pub fn compare_scalar_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         ty::TyInt(_) => {\n             ICmp(bcx,\n-                 bin_op_to_icmp_predicate(bcx.ccx(), op, true),\n+                 bin_op_to_icmp_predicate(op, true),\n                  lhs,\n                  rhs,\n                  debug_loc)\n         }\n         ty::TyFloat(_) => {\n             FCmp(bcx,\n-                 bin_op_to_fcmp_predicate(bcx.ccx(), op),\n+                 bin_op_to_fcmp_predicate(op),\n                  lhs,\n                  rhs,\n                  debug_loc)\n         }\n         // Should never get here, because t is scalar.\n-        _ => bcx.sess().bug(\"non-scalar type passed to compare_scalar_types\"),\n+        _ => bug!(\"non-scalar type passed to compare_scalar_types\"),\n     }\n }\n \n@@ -383,15 +380,15 @@ pub fn compare_simd_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                       -> ValueRef {\n     let signed = match t.sty {\n         ty::TyFloat(_) => {\n-            let cmp = bin_op_to_fcmp_predicate(bcx.ccx(), op);\n+            let cmp = bin_op_to_fcmp_predicate(op);\n             return SExt(bcx, FCmp(bcx, cmp, lhs, rhs, debug_loc), ret_ty);\n         },\n         ty::TyUint(_) => false,\n         ty::TyInt(_) => true,\n-        _ => bcx.sess().bug(\"compare_simd_types: invalid SIMD type\"),\n+        _ => bug!(\"compare_simd_types: invalid SIMD type\"),\n     };\n \n-    let cmp = bin_op_to_icmp_predicate(bcx.ccx(), op, signed);\n+    let cmp = bin_op_to_icmp_predicate(op, signed);\n     // LLVM outputs an `< size x i1 >`, so we need to perform a sign extension\n     // to get the correctly sized type. This will compile to a single instruction\n     // once the IR is converted to assembly if the SIMD instruction is supported\n@@ -578,9 +575,9 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n             consts::ptrcast(meth::get_vtable(ccx, trait_ref),\n                             Type::vtable_ptr(ccx))\n         }\n-        _ => ccx.sess().bug(&format!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n+        _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n                                      source,\n-                                     target)),\n+                                     target),\n     }\n }\n \n@@ -604,7 +601,7 @@ pub fn unsize_thin_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             (PointerCast(bcx, src, ptr_ty),\n              unsized_info(bcx.ccx(), a, b, None))\n         }\n-        _ => bcx.sess().bug(\"unsize_thin_ptr: called on bad types\"),\n+        _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n     }\n }\n \n@@ -638,12 +635,12 @@ pub fn coerce_unsized_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let src_repr = adt::represent_type(bcx.ccx(), src_ty);\n             let src_fields = match &*src_repr {\n                 &adt::Repr::Univariant(ref s, _) => &s.fields,\n-                _ => bcx.sess().bug(\"struct has non-univariant repr\"),\n+                _ => bug!(\"struct has non-univariant repr\"),\n             };\n             let dst_repr = adt::represent_type(bcx.ccx(), dst_ty);\n             let dst_fields = match &*dst_repr {\n                 &adt::Repr::Univariant(ref s, _) => &s.fields,\n-                _ => bcx.sess().bug(\"struct has non-univariant repr\"),\n+                _ => bug!(\"struct has non-univariant repr\"),\n             };\n \n             let src = adt::MaybeSizedValue::sized(src);\n@@ -664,9 +661,9 @@ pub fn coerce_unsized_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n             }\n         }\n-        _ => bcx.sess().bug(&format!(\"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n-                                     src_ty,\n-                                     dst_ty)),\n+        _ => bug!(\"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n+                  src_ty,\n+                  dst_ty),\n     }\n }\n \n@@ -689,8 +686,7 @@ pub fn custom_coerce_unsize_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n             ccx.tcx().custom_coerce_unsized_kind(impl_def_id)\n         }\n         vtable => {\n-            ccx.sess().bug(&format!(\"invalid CoerceUnsized vtable: {:?}\",\n-                                    vtable));\n+            bug!(\"invalid CoerceUnsized vtable: {:?}\", vtable);\n         }\n     }\n }\n@@ -758,7 +754,7 @@ pub fn llty_and_min_for_signed_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n             };\n             (llty, min)\n         }\n-        _ => unreachable!(),\n+        _ => bug!(),\n     }\n }\n \n@@ -798,7 +794,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n             (res, false)\n         }\n         _ => {\n-            cx.sess().bug(&format!(\"fail-if-zero on unexpected type: {}\", rhs_t));\n+            bug!(\"fail-if-zero on unexpected type: {}\", rhs_t);\n         }\n     };\n     let bcx = with_cond(cx, is_zero, |bcx| {\n@@ -1323,30 +1319,30 @@ fn build_cfg(tcx: &TyCtxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>) {\n                 hir::ItemFn(_, _, _, _, _, ref blk) => {\n                     blk\n                 }\n-                _ => tcx.sess.bug(\"unexpected item variant in has_nested_returns\"),\n+                _ => bug!(\"unexpected item variant in has_nested_returns\"),\n             }\n         }\n         Some(hir_map::NodeTraitItem(trait_item)) => {\n             match trait_item.node {\n                 hir::MethodTraitItem(_, Some(ref body)) => body,\n                 _ => {\n-                    tcx.sess.bug(\"unexpected variant: trait item other than a provided method in \\\n-                                  has_nested_returns\")\n+                    bug!(\"unexpected variant: trait item other than a provided method in \\\n+                          has_nested_returns\")\n                 }\n             }\n         }\n         Some(hir_map::NodeImplItem(impl_item)) => {\n             match impl_item.node {\n                 hir::ImplItemKind::Method(_, ref body) => body,\n                 _ => {\n-                    tcx.sess.bug(\"unexpected variant: non-method impl item in has_nested_returns\")\n+                    bug!(\"unexpected variant: non-method impl item in has_nested_returns\")\n                 }\n             }\n         }\n         Some(hir_map::NodeExpr(e)) => {\n             match e.node {\n                 hir::ExprClosure(_, _, ref blk) => blk,\n-                _ => tcx.sess.bug(\"unexpected expr variant in has_nested_returns\"),\n+                _ => bug!(\"unexpected expr variant in has_nested_returns\"),\n             }\n         }\n         Some(hir_map::NodeVariant(..)) |\n@@ -1355,8 +1351,8 @@ fn build_cfg(tcx: &TyCtxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>) {\n         // glue, shims, etc\n         None if id == ast::DUMMY_NODE_ID => return (ast::DUMMY_NODE_ID, None),\n \n-        _ => tcx.sess.bug(&format!(\"unexpected variant in has_nested_returns: {}\",\n-                                   tcx.map.path_to_string(id))),\n+        _ => bug!(\"unexpected variant in has_nested_returns: {}\",\n+                  tcx.map.path_to_string(id)),\n     };\n \n     (blk.id, Some(cfg::CFG::new(tcx, blk)))\n@@ -1675,7 +1671,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n                 // FIXME(pcwalton): Reduce the amount of code bloat this is responsible for.\n                 let tupled_arg_tys = match arg_ty.sty {\n                     ty::TyTuple(ref tys) => tys,\n-                    _ => unreachable!(\"last argument of `rust-call` fn isn't a tuple?!\")\n+                    _ => bug!(\"last argument of `rust-call` fn isn't a tuple?!\")\n                 };\n \n                 unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx,\n@@ -1978,7 +1974,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                       expr::SaveIn(llresult),\n                                       debug_loc);\n             }\n-            _ => ccx.sess().bug(\"expected expr as arguments for variant/struct tuple constructor\"),\n+            _ => bug!(\"expected expr as arguments for variant/struct tuple constructor\"),\n         }\n     } else {\n         // Just eval all the expressions (if any). Since expressions in Rust can have arbitrary\n@@ -2381,7 +2377,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext, sp: Span, main_llfn: ValueRef) {\n                       .help(\"did you use #[no_mangle] on `fn main`? Use #[start] instead\")\n                       .emit();\n             ccx.sess().abort_if_errors();\n-            panic!();\n+            bug!();\n         }\n         let llfn = declare::declare_cfn(ccx, \"main\", llfty);\n \n@@ -2734,7 +2730,7 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n         });\n \n         if POISONED {\n-            tcx.sess.bug(\"couldn't enable multi-threaded LLVM\");\n+            bug!(\"couldn't enable multi-threaded LLVM\");\n         }\n     }\n "}, {"sha": "0185d1587625c378c476add77f94d05d1066da0a", "filename": "src/librustc_trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuild.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -32,7 +32,7 @@ pub fn terminate(cx: Block, _: &str) {\n \n pub fn check_not_terminated(cx: Block) {\n     if cx.terminated.get() {\n-        panic!(\"already terminated!\");\n+        bug!(\"already terminated!\");\n     }\n }\n "}, {"sha": "92fb342497b5adc9a207ac4b58785250d882b91f", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -871,12 +871,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             .zip(args.iter().map(|&v| val_ty(v)));\n         for (i, (expected_ty, actual_ty)) in iter.enumerate() {\n             if expected_ty != actual_ty {\n-                self.ccx.sess().bug(\n-                    &format!(\n-                        \"Type mismatch in function call of {:?}. \\\n-                         Expected {:?} for param {}, got {:?}\",\n-                        Value(llfn),\n-                        expected_ty, i, actual_ty));\n+                bug!(\"Type mismatch in function call of {:?}. \\\n+                      Expected {:?} for param {}, got {:?}\",\n+                     Value(llfn),\n+                     expected_ty, i, actual_ty);\n \n             }\n         }"}, {"sha": "4903af2a6ff7df5442aa848b4dfc6412f97a3057", "filename": "src/librustc_trans/cabi_aarch64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_aarch64.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -49,7 +49,7 @@ fn ty_align(ty: Type) -> usize {\n             let elt = ty.element_type();\n             ty_align(elt) * len\n         }\n-        _ => panic!(\"ty_align: unhandled type\")\n+        _ => bug!(\"ty_align: unhandled type\")\n     }\n }\n \n@@ -81,7 +81,7 @@ fn ty_size(ty: Type) -> usize {\n             let eltsz = ty_size(elt);\n             len * eltsz\n         }\n-        _ => panic!(\"ty_size: unhandled type\")\n+        _ => bug!(\"ty_size: unhandled type\")\n     }\n }\n "}, {"sha": "35099399e317c3c86673a2af67881eebffd802fc", "filename": "src/librustc_trans/cabi_arm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_arm.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -56,7 +56,7 @@ fn general_ty_align(ty: Type) -> usize {\n             let elt = ty.element_type();\n             general_ty_align(elt) * len\n         }\n-        _ => panic!(\"ty_align: unhandled type\")\n+        _ => bug!(\"ty_align: unhandled type\")\n     }\n }\n \n@@ -90,7 +90,7 @@ fn ios_ty_align(ty: Type) -> usize {\n             let elt = ty.element_type();\n             ios_ty_align(elt) * len\n         }\n-        _ => panic!(\"ty_align: unhandled type\")\n+        _ => bug!(\"ty_align: unhandled type\")\n     }\n }\n \n@@ -125,7 +125,7 @@ fn ty_size(ty: Type, align_fn: TyAlignFn) -> usize {\n             let eltsz = ty_size(elt, align_fn);\n             len * eltsz\n         }\n-        _ => panic!(\"ty_size: unhandled type\")\n+        _ => bug!(\"ty_size: unhandled type\")\n     }\n }\n "}, {"sha": "be9d4cad1db684af77eed434f5f9e37da7fbba4d", "filename": "src/librustc_trans/cabi_mips.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -50,7 +50,7 @@ fn ty_align(ty: Type) -> usize {\n             let elt = ty.element_type();\n             ty_align(elt) * len\n         }\n-        _ => panic!(\"ty_align: unhandled type\")\n+        _ => bug!(\"ty_align: unhandled type\")\n     }\n }\n \n@@ -82,7 +82,7 @@ fn ty_size(ty: Type) -> usize {\n             let eltsz = ty_size(elt);\n             len * eltsz\n         }\n-        _ => panic!(\"ty_size: unhandled type\")\n+        _ => bug!(\"ty_size: unhandled type\")\n     }\n }\n "}, {"sha": "d118cc86f2443056bc8051568fc99601b917eb90", "filename": "src/librustc_trans/cabi_powerpc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -48,7 +48,7 @@ fn ty_align(ty: Type) -> usize {\n             let elt = ty.element_type();\n             ty_align(elt)\n         }\n-        _ => panic!(\"ty_size: unhandled type\")\n+        _ => bug!(\"ty_size: unhandled type\")\n     }\n }\n \n@@ -78,7 +78,7 @@ fn ty_size(ty: Type) -> usize {\n             let eltsz = ty_size(elt);\n             len * eltsz\n         }\n-        _ => panic!(\"ty_size: unhandled type\")\n+        _ => bug!(\"ty_size: unhandled type\")\n     }\n }\n "}, {"sha": "7bc41d26f8b757b41ab446d0dc4a29900d1d1cc3", "filename": "src/librustc_trans/cabi_powerpc64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc64.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -49,7 +49,7 @@ fn ty_align(ty: Type) -> usize {\n             let elt = ty.element_type();\n             ty_align(elt)\n         }\n-        _ => panic!(\"ty_align: unhandled type\")\n+        _ => bug!(\"ty_align: unhandled type\")\n     }\n }\n \n@@ -75,7 +75,7 @@ fn ty_size(ty: Type) -> usize {\n             let eltsz = ty_size(elt);\n             len * eltsz\n         }\n-        _ => panic!(\"ty_size: unhandled type\")\n+        _ => bug!(\"ty_size: unhandled type\")\n     }\n }\n "}, {"sha": "e9e9e266c77863ea61794edc516a30cb01e90e69", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -112,7 +112,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                 let elt = ty.element_type();\n                 ty_align(elt) * len\n             }\n-            _ => panic!(\"ty_align: unhandled type\")\n+            _ => bug!(\"ty_align: unhandled type\")\n         }\n     }\n \n@@ -144,7 +144,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                 len * eltsz\n             }\n \n-            _ => panic!(\"ty_size: unhandled type\")\n+            _ => bug!(\"ty_size: unhandled type\")\n         }\n     }\n \n@@ -255,7 +255,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                     Integer => SSEInt(elt.int_width()),\n                     Float => SSEFv,\n                     Double => SSEDv,\n-                    _ => panic!(\"classify: unhandled vector element type\")\n+                    _ => bug!(\"classify: unhandled vector element type\")\n                 };\n \n                 let mut i = 0;\n@@ -268,7 +268,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                     i += 1;\n                 }\n             }\n-            _ => panic!(\"classify: unhandled type\")\n+            _ => bug!(\"classify: unhandled type\")\n         }\n     }\n \n@@ -357,7 +357,7 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n                                 \"llreg_ty: unsupported SSEInt width {}\", bits);\n                         (64 / bits, Type::ix(ccx, bits))\n                     }\n-                    _ => unreachable!(),\n+                    _ => bug!(),\n                 };\n                 let vec_len = llvec_len(&cls[i + 1..]);\n                 let vec_ty = Type::vector(&elt_ty, vec_len as u64 * elts_per_word);\n@@ -371,7 +371,7 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n             SSEDs => {\n                 tys.push(Type::f64(ccx));\n             }\n-            _ => panic!(\"llregtype: unhandled class\")\n+            _ => bug!(\"llregtype: unhandled class\")\n         }\n         i += 1;\n     }"}, {"sha": "a323d63adaeb665a32255234bea4113462dfe1ea", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -184,8 +184,8 @@ impl<'tcx> Callee<'tcx> {\n                 let method_ty = def_ty(tcx, def_id, substs);\n                 let fn_ptr_ty = match method_ty.sty {\n                     ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n-                    _ => unreachable!(\"expected fn item type, found {}\",\n-                                      method_ty)\n+                    _ => bug!(\"expected fn item type, found {}\",\n+                              method_ty)\n                 };\n                 Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n             }\n@@ -196,8 +196,8 @@ impl<'tcx> Callee<'tcx> {\n                 let method_ty = def_ty(tcx, def_id, substs);\n                 let fn_ptr_ty = match method_ty.sty {\n                     ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n-                    _ => unreachable!(\"expected fn item type, found {}\",\n-                                      method_ty)\n+                    _ => bug!(\"expected fn item type, found {}\",\n+                              method_ty)\n                 };\n                 Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n             }\n@@ -209,7 +209,7 @@ impl<'tcx> Callee<'tcx> {\n                 }\n             }\n             vtable => {\n-                unreachable!(\"resolved vtable bad vtable {:?} in trans\", vtable);\n+                bug!(\"resolved vtable bad vtable {:?} in trans\", vtable);\n             }\n         }\n     }\n@@ -269,9 +269,9 @@ impl<'tcx> Callee<'tcx> {\n                 ty::TyFnDef(def_id, substs, _) => {\n                     return get_fn(ccx, def_id, substs);\n                 }\n-                _ => unreachable!(\"expected fn item type, found {}\", self.ty)\n+                _ => bug!(\"expected fn item type, found {}\", self.ty)\n             },\n-            Intrinsic => unreachable!(\"intrinsic {} getting reified\", self.ty)\n+            Intrinsic => bug!(\"intrinsic {} getting reified\", self.ty)\n         }\n     }\n }\n@@ -356,8 +356,8 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                                     ref sig }) => sig,\n \n         _ => {\n-            tcx.sess.bug(&format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n-                                    bare_fn_ty));\n+            bug!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n+                 bare_fn_ty);\n         }\n     };\n     let sig = tcx.erase_late_bound_regions(sig);\n@@ -481,7 +481,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 // Create a fn pointer with the substituted signature.\n                 tcx.mk_ty(ty::TyFnPtr(fty))\n             }\n-            _ => unreachable!(\"expected fn item type, found {}\", fn_ty)\n+            _ => bug!(\"expected fn item type, found {}\", fn_ty)\n         };\n         assert_eq!(type_of::type_of(ccx, fn_ptr_ty), common::val_ty(val));\n         return immediate_rvalue(val, fn_ptr_ty);\n@@ -494,7 +494,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // Create a fn pointer with the normalized signature.\n             tcx.mk_fn_ptr(infer::normalize_associated_type(tcx, fty))\n         }\n-        _ => unreachable!(\"expected fn item type, found {}\", ty)\n+        _ => bug!(\"expected fn item type, found {}\", ty)\n     };\n \n     let instance = Instance::mono(ccx.tcx(), def_id);\n@@ -537,7 +537,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n \n         ref variant => {\n-            ccx.sess().bug(&format!(\"get_fn: unexpected variant: {:?}\", variant))\n+            bug!(\"get_fn: unexpected variant: {:?}\", variant)\n         }\n     };\n \n@@ -689,7 +689,7 @@ fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     let llfn = match callee {\n         Fn(f) => f,\n-        _ => unreachable!(\"expected fn pointer callee, found {:?}\", callee)\n+        _ => bug!(\"expected fn pointer callee, found {:?}\", callee)\n     };\n \n     let (llret, mut bcx) = base::invoke(bcx, llfn, &llargs, debug_loc);\n@@ -830,8 +830,8 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n             }\n         }\n         _ => {\n-            bcx.sess().span_bug(tuple_expr.span,\n-                                \"argument to `.call()` wasn't a tuple?!\")\n+            span_bug!(tuple_expr.span,\n+                      \"argument to `.call()` wasn't a tuple?!\")\n         }\n     };\n "}, {"sha": "514e6bda594277dfae7dd8e64f1f98e825a4237a", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -378,7 +378,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                 return id;\n             }\n         }\n-        self.ccx.sess().bug(\"no loop scope found\");\n+        bug!(\"no loop scope found\");\n     }\n \n     /// Returns a block to branch to which will perform all pending cleanups and\n@@ -568,9 +568,8 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             }\n         }\n \n-        self.ccx.sess().bug(\n-            &format!(\"no cleanup scope {} found\",\n-                    self.ccx.tcx().map.node_to_string(cleanup_scope)));\n+        bug!(\"no cleanup scope {} found\",\n+             self.ccx.tcx().map.node_to_string(cleanup_scope));\n     }\n \n     /// Schedules a cleanup to occur in the top-most scope, which must be a temporary scope.\n@@ -763,9 +762,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                     }\n \n                     LoopExit(id, _) => {\n-                        self.ccx.sess().bug(&format!(\n-                                \"cannot exit from scope {}, \\\n-                                not in scope\", id));\n+                        bug!(\"cannot exit from scope {}, not in scope\", id);\n                     }\n                 }\n             }\n@@ -1189,8 +1186,7 @@ pub fn temporary_scope(tcx: &TyCtxt,\n             r\n         }\n         None => {\n-            tcx.sess.bug(&format!(\"no temporary scope available for expr {}\",\n-                                 id))\n+            bug!(\"no temporary scope available for expr {}\", id)\n         }\n     }\n }"}, {"sha": "cb94c9dfeb8d99a459f9e24fe90566211a76d8b2", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -297,7 +297,6 @@ pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     let llfn_closure_kind = ccx.tcx().closure_kind(closure_def_id);\n \n     let _icx = push_ctxt(\"trans_closure_adapter_shim\");\n-    let tcx = ccx.tcx();\n \n     debug!(\"trans_closure_adapter_shim(llfn_closure_kind={:?}, \\\n            trait_closure_kind={:?}, llfn={:?})\",\n@@ -329,9 +328,9 @@ pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n             trans_fn_once_adapter_shim(ccx, closure_def_id, substs, llfn)\n         }\n         _ => {\n-            tcx.sess.bug(&format!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n-                                  llfn_closure_kind,\n-                                  trait_closure_kind));\n+            bug!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n+                 llfn_closure_kind,\n+                 trait_closure_kind);\n         }\n     }\n }"}, {"sha": "1c18f3ca393c209f91a4a85f81443850e36853ea", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -597,7 +597,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         let substs = match fulfill_obligation(ccx, DUMMY_SP, trait_ref) {\n             traits::VtableImpl(data) => data.substs,\n-            _ => unreachable!()\n+            _ => bug!()\n         };\n \n         if can_have_local_instance(ccx, destructor_did) {\n@@ -665,7 +665,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::TyParam(_)      |\n         ty::TyInfer(_)      |\n         ty::TyError         => {\n-            ccx.sess().bug(\"encountered unexpected type\");\n+            bug!(\"encountered unexpected type\");\n         }\n     }\n }\n@@ -701,7 +701,7 @@ fn do_static_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     }\n                 }\n             }\n-            _ => unreachable!()\n+            _ => bug!()\n         }\n     } else {\n         debug!(\" => regular function\");\n@@ -760,7 +760,7 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             None\n         }\n         _ => {\n-            tcx.sess.bug(&format!(\"static call to invalid vtable: {:?}\", vtbl))\n+            bug!(\"static call to invalid vtable: {:?}\", vtbl)\n         }\n     }\n }\n@@ -845,10 +845,9 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                            target_fields[coerce_index].ty(ccx.tcx(),\n                                                                           target_substs))\n         }\n-        _ => ccx.sess()\n-                .bug(&format!(\"find_vtable_types_for_unsizing: invalid coercion {:?} -> {:?}\",\n-                               source_ty,\n-                               target_ty))\n+        _ => bug!(\"find_vtable_types_for_unsizing: invalid coercion {:?} -> {:?}\",\n+                  source_ty,\n+                  target_ty)\n     }\n }\n \n@@ -1019,7 +1018,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                         generics.is_type_parameterized()\n                     }\n                     _ => {\n-                        unreachable!()\n+                        bug!()\n                     }\n                 };\n \n@@ -1101,7 +1100,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             }\n         }\n         _ => {\n-            unreachable!()\n+            bug!()\n         }\n     }\n }\n@@ -1252,8 +1251,8 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyInfer(_) |\n         ty::TyProjection(..) |\n         ty::TyParam(_) => {\n-            cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\\n-                unexpected type: {:?}\", t));\n+            bug!(\"debuginfo: Trying to create type name for \\\n+                  unexpected type: {:?}\", t);\n         }\n     }\n }"}, {"sha": "589e6f3266e8e5b1d6476f4571d803f725a4d7f1", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -194,9 +194,7 @@ impl<'tcx> VariantInfo<'tcx> {\n             }\n \n             _ => {\n-                tcx.sess.bug(&format!(\n-                    \"cannot get field types from the type {:?}\",\n-                    ty));\n+                bug!(\"cannot get field types from the type {:?}\", ty);\n             }\n         }\n     }\n@@ -209,7 +207,7 @@ impl<'tcx> VariantInfo<'tcx> {\n \n     pub fn field_index(&self, name: ast::Name) -> usize {\n         self.fields.iter().position(|&Field(n,_)| n == name).unwrap_or_else(|| {\n-            panic!(\"unknown field `{}`\", name)\n+            bug!(\"unknown field `{}`\", name)\n         })\n     }\n }\n@@ -596,8 +594,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n         match self.tcx().def_map.borrow().get(&nid) {\n             Some(v) => v.full_def(),\n             None => {\n-                self.tcx().sess.bug(&format!(\n-                    \"no def associated with node id {}\", nid));\n+                bug!(\"no def associated with node id {}\", nid);\n             }\n         }\n     }\n@@ -910,7 +907,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n         let gsym = token::gensym(\"str\");\n         let sym = format!(\"str{}\", gsym.0);\n         let g = declare::define_global(cx, &sym[..], val_ty(sc)).unwrap_or_else(||{\n-            cx.sess().bug(&format!(\"symbol `{}` is already defined\", sym));\n+            bug!(\"symbol `{}` is already defined\", sym);\n         });\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n@@ -1102,11 +1099,11 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 \"reached the recursion limit during monomorphization (selection ambiguity)\");\n         }\n         Err(e) => {\n-            tcx.sess.span_bug(\n+            span_bug!(\n                 span,\n-                &format!(\"Encountered error `{:?}` selecting `{:?}` during trans\",\n-                        e,\n-                        trait_ref))\n+                \"Encountered error `{:?}` selecting `{:?}` during trans\",\n+                e,\n+                trait_ref)\n         }\n     };\n \n@@ -1194,7 +1191,7 @@ pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         inlined_vid_def_id == v.did ||\n             ccx.external().borrow().get(&v.did) == Some(&Some(inlined_vid))\n     }).unwrap_or_else(|| {\n-        ccx.sess().bug(&format!(\"no variant for {:?}::{}\", adt_def, inlined_vid))\n+        bug!(\"no variant for {:?}::{}\", adt_def, inlined_vid)\n     })\n }\n \n@@ -1255,6 +1252,6 @@ pub fn shift_mask_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let mask = shift_mask_val(bcx, llty.element_type(), mask_llty.element_type(), invert);\n             build::VectorSplat(bcx, mask_llty.vector_length(), mask)\n         },\n-        _ => panic!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n+        _ => bug!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n     }\n }"}, {"sha": "3e516c0eec418b1b697c9c55d6c084ea694e7644", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 39, "deletions": 41, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -75,10 +75,10 @@ pub fn const_lit(cx: &CrateContext, e: &hir::Expr, lit: &ast::Lit)\n                 ty::TyUint(t) => {\n                     C_integral(Type::uint_from_ty(cx, t), i as u64, false)\n                 }\n-                _ => cx.sess().span_bug(lit.span,\n-                        &format!(\"integer literal has type {:?} (expected int \\\n-                                 or usize)\",\n-                                lit_int_ty))\n+                _ => span_bug!(lit.span,\n+                        \"integer literal has type {:?} (expected int \\\n+                         or usize)\",\n+                        lit_int_ty)\n             }\n         }\n         LitKind::Float(ref fs, t) => {\n@@ -91,7 +91,7 @@ pub fn const_lit(cx: &CrateContext, e: &hir::Expr, lit: &ast::Lit)\n                     C_floating(&fs, Type::float_from_ty(cx, t))\n                 }\n                 _ => {\n-                    cx.sess().span_bug(lit.span,\n+                    span_bug!(lit.span,\n                         \"floating point literal doesn't have the right type\");\n                 }\n             }\n@@ -121,7 +121,7 @@ fn addr_of_mut(ccx: &CrateContext,\n         let gsym = token::gensym(\"_\");\n         let name = format!(\"{}{}\", kind, gsym.0);\n         let gv = declare::define_global(ccx, &name[..], val_ty(cv)).unwrap_or_else(||{\n-            ccx.sess().bug(&format!(\"symbol `{}` is already defined\", name));\n+            bug!(\"symbol `{}` is already defined\", name);\n         });\n         llvm::LLVMSetInitializer(gv, cv);\n         llvm::LLVMSetAlignment(gv, align);\n@@ -186,8 +186,7 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n         }\n         None => {\n-            cx.sess().bug(&format!(\"unexpected dereferenceable type {:?}\",\n-                                   ty))\n+            bug!(\"unexpected dereferenceable type {:?}\", ty)\n         }\n     }\n }\n@@ -232,7 +231,7 @@ pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     match lookup_const_by_id(ccx.tcx(), def_id, Some(substs)) {\n         Some((ref expr, _ty)) => expr,\n         None => {\n-            ccx.sess().span_bug(ref_expr.span, \"constant item not found\")\n+            span_bug!(ref_expr.span, \"constant item not found\")\n         }\n     }\n }\n@@ -357,7 +356,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     llconst = Callee::def(cx, def_id, substs).reify(cx).val;\n                 }\n                 _ => {\n-                    unreachable!(\"{} cannot be reified to a fn ptr\", ety)\n+                    bug!(\"{} cannot be reified to a fn ptr\", ety)\n                 }\n             }\n         }\n@@ -441,9 +440,9 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             llvm::LLVMDumpValue(llconst);\n             llvm::LLVMDumpValue(C_undef(llty));\n         }\n-        cx.sess().bug(&format!(\"const {:?} of type {:?} has size {} instead of {}\",\n-                         e, ety_adjusted,\n-                         csize, tsize));\n+        bug!(\"const {:?} of type {:?} has size {} instead of {}\",\n+             e, ety_adjusted,\n+             csize, tsize);\n     }\n     Ok((llconst, ety_adjusted))\n }\n@@ -550,7 +549,7 @@ fn const_err(cx: &CrateContext,\n fn check_binary_expr_validity(cx: &CrateContext, e: &hir::Expr, t: Ty,\n                               te1: ValueRef, te2: ValueRef,\n                               trueconst: TrueConst) -> Result<(), ConstEvalFailure> {\n-    let b = if let hir::ExprBinary(b, _, _) = e.node { b } else { unreachable!() };\n+    let b = if let hir::ExprBinary(b, _, _) = e.node { b } else { bug!() };\n     let (lhs, rhs) = match (to_const_int(te1, t, cx.tcx()), to_const_int(te2, t, cx.tcx())) {\n         (Some(v1), Some(v2)) => (v1, v2),\n         _ => return Ok(()),\n@@ -642,10 +641,10 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 },\n                 hir::BiEq | hir::BiNe | hir::BiLt | hir::BiLe | hir::BiGt | hir::BiGe => {\n                     if is_float {\n-                        let cmp = base::bin_op_to_fcmp_predicate(cx, b.node);\n+                        let cmp = base::bin_op_to_fcmp_predicate(b.node);\n                         ConstFCmp(cmp, te1, te2)\n                     } else {\n-                        let cmp = base::bin_op_to_icmp_predicate(cx, b.node, signed);\n+                        let cmp = base::bin_op_to_icmp_predicate(b.node, signed);\n                         ConstICmp(cmp, te1, te2)\n                     }\n                 },\n@@ -669,21 +668,21 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let brepr = adt::represent_type(cx, bt);\n             let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n             let ix = vinfo.field_index(field.node);\n-            adt::const_get_field(cx, &brepr, bv, vinfo.discr, ix)\n+            adt::const_get_field(&brepr, bv, vinfo.discr, ix)\n         },\n         hir::ExprTupField(ref base, idx) => {\n             let (bv, bt) = const_expr(cx, &base, param_substs, fn_args, trueconst)?;\n             let brepr = adt::represent_type(cx, bt);\n             let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n-            adt::const_get_field(cx, &brepr, bv, vinfo.discr, idx.node)\n+            adt::const_get_field(&brepr, bv, vinfo.discr, idx.node)\n         },\n         hir::ExprIndex(ref base, ref index) => {\n             let (bv, bt) = const_expr(cx, &base, param_substs, fn_args, trueconst)?;\n             let iv = const_expr(cx, &index, param_substs, fn_args, TrueConst::Yes)?.0;\n             let iv = if let Some(iv) = const_to_opt_uint(iv) {\n                 iv\n             } else {\n-                cx.sess().span_bug(index.span, \"index is not an integer-constant expression\");\n+                span_bug!(index.span, \"index is not an integer-constant expression\");\n             };\n             let (arr, len) = match bt.sty {\n                 ty::TyArray(_, u) => (bv, C_uint(cx, u)),\n@@ -695,15 +694,15 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     ty::TyArray(_, u) => {\n                         (load_const(cx, bv, mt.ty), C_uint(cx, u))\n                     },\n-                    _ => cx.sess().span_bug(base.span,\n-                                            &format!(\"index-expr base must be a vector \\\n-                                                      or string type, found {:?}\",\n-                                                     bt)),\n+                    _ => span_bug!(base.span,\n+                                   \"index-expr base must be a vector \\\n+                                    or string type, found {:?}\",\n+                                   bt),\n                 },\n-                _ => cx.sess().span_bug(base.span,\n-                                        &format!(\"index-expr base must be a vector \\\n-                                                  or string type, found {:?}\",\n-                                                 bt)),\n+                _ => span_bug!(base.span,\n+                               \"index-expr base must be a vector \\\n+                                or string type, found {:?}\",\n+                               bt),\n             };\n \n             let len = unsafe { llvm::LLVMConstIntGetZExtValue(len) as u64 };\n@@ -784,8 +783,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                   llvm::LLVMConstPtrToInt(v, llty.to_ref())\n                 },\n                 _ => {\n-                  cx.sess().impossible_case(e.span,\n-                                            \"bad combination of types for cast\")\n+                  span_bug!(e.span, \"bad combination of types for cast\")\n                 },\n             } } // unsafe { match ( ... ) {\n         },\n@@ -845,8 +843,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     (Some(ref f), _) => {\n                         const_expr(cx, &f.expr, param_substs, fn_args, trueconst).map(|(l, _)| l)\n                     },\n-                    (_, Some((bv, _))) => Ok(adt::const_get_field(cx, &repr, bv, discr, ix)),\n-                    (_, None) => cx.sess().span_bug(e.span, \"missing struct field\"),\n+                    (_, Some((bv, _))) => Ok(adt::const_get_field(&repr, bv, discr, ix)),\n+                    (_, None) => span_bug!(e.span, \"missing struct field\"),\n                 }\n             })\n             .collect::<Vec<Result<_, ConstEvalFailure>>>()\n@@ -900,7 +898,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     if let Some(val) = fn_args.and_then(|args| args.get(&id).cloned()) {\n                         val\n                     } else {\n-                        cx.sess().span_bug(e.span, \"const fn argument not found\")\n+                        span_bug!(e.span, \"const fn argument not found\")\n                     }\n                 }\n                 Def::Fn(..) | Def::Method(..) => C_nil(cx),\n@@ -917,15 +915,15 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         }\n                         ty::VariantKind::Tuple => C_nil(cx),\n                         ty::VariantKind::Struct => {\n-                            cx.sess().span_bug(e.span, \"path-expr refers to a dict variant!\")\n+                            span_bug!(e.span, \"path-expr refers to a dict variant!\")\n                         }\n                     }\n                 }\n                 // Unit struct or ctor.\n                 Def::Struct(..) => C_null(type_of::type_of(cx, ety)),\n                 _ => {\n-                    cx.sess().span_bug(e.span, \"expected a const, fn, struct, \\\n-                                                or variant def\")\n+                    span_bug!(e.span, \"expected a const, fn, struct, \\\n+                                       or variant def\")\n                 }\n             }\n         },\n@@ -969,7 +967,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      Disr::from(vinfo.disr_val),\n                                      &arg_vals[..])\n                 }\n-                _ => cx.sess().span_bug(e.span, \"expected a struct, variant, or const fn def\"),\n+                _ => span_bug!(e.span, \"expected a struct, variant, or const fn def\"),\n             }\n         },\n         hir::ExprMethodCall(_, _, ref args) => {\n@@ -1003,14 +1001,14 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                 substs);\n                 }\n                 _ =>\n-                    cx.sess().span_bug(\n+                    span_bug!(\n                         e.span,\n-                        &format!(\"bad type for closure expr: {:?}\", ety))\n+                        \"bad type for closure expr: {:?}\", ety)\n             }\n             C_null(type_of::type_of(cx, ety))\n         },\n-        _ => cx.sess().span_bug(e.span,\n-                                \"bad constant expression type in consts::const_expr\"),\n+        _ => span_bug!(e.span,\n+                       \"bad constant expression type in consts::const_expr\"),\n     })\n }\n \n@@ -1105,7 +1103,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                 g\n             }\n \n-            item => unreachable!(\"get_static: expected static, found {:?}\", item)\n+            item => bug!(\"get_static: expected static, found {:?}\", item)\n         }\n     } else {\n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?"}, {"sha": "3574883c5f58823ddf4b56521e593fbed12bcc79", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -596,7 +596,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         }\n         match declare_intrinsic(self, key) {\n             Some(v) => return v,\n-            None => panic!(\"unknown intrinsic '{}'\", key)\n+            None => bug!(\"unknown intrinsic '{}'\", key)\n         }\n     }\n \n@@ -785,7 +785,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         match &self.sess().target.target.target_pointer_width[..] {\n             \"32\" => 1 << 31,\n             \"64\" => 1 << 47,\n-            _ => unreachable!() // error handled by config::build_target_config\n+            _ => bug!() // error handled by config::build_target_config\n         }\n     }\n "}, {"sha": "6d4b02f076c872c47131f6cdf38d1b6d58c36673", "filename": "src/librustc_trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontrolflow.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -322,7 +322,7 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match bcx.tcx().def_map.borrow().get(&expr.id).map(|d| d.full_def())  {\n                 Some(Def::Label(loop_id)) => loop_id,\n                 r => {\n-                    bcx.tcx().sess.bug(&format!(\"{:?} in def-map for label\", r))\n+                    bug!(\"{:?} in def-map for label\", r)\n                 }\n             }\n         }"}, {"sha": "0ed38f0681762468fc3e629adf85c87efda9f0eb", "filename": "src/librustc_trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdatum.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -584,10 +584,10 @@ impl<'tcx> Datum<'tcx, Expr> {\n \n     /// Asserts that this datum *is* an lvalue and returns it.\n     #[allow(dead_code)] // potentially useful\n-    pub fn assert_lvalue(self, bcx: Block) -> Datum<'tcx, Lvalue> {\n+    pub fn assert_lvalue(self) -> Datum<'tcx, Lvalue> {\n         self.match_kind(\n             |d| d,\n-            |_| bcx.sess().bug(\"assert_lvalue given rvalue\"))\n+            |_| bug!(\"assert_lvalue given rvalue\"))\n     }\n \n     pub fn store_to_dest<'blk>(self,"}, {"sha": "a7f2bf4a5fa23e5b92e2fb25f3ba8d08d6cce837", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -98,7 +98,7 @@ fn with_new_scope<F>(cx: &CrateContext,\n     }\n \n     if scope_stack.last().unwrap().scope_metadata != scope_metadata {\n-        cx.sess().span_bug(scope_span, \"debuginfo: Inconsistency in scope management.\");\n+        span_bug!(scope_span, \"debuginfo: Inconsistency in scope management.\");\n     }\n \n     scope_stack.pop();"}, {"sha": "cf312855d75bc8bf081d13cbcf2e985d902244fc", "filename": "src/librustc_trans/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -71,7 +71,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n \n             let section_var = declare::define_global(ccx, section_var_name,\n                                                      llvm_type).unwrap_or_else(||{\n-                ccx.sess().bug(&format!(\"symbol `{}` is already defined\", section_var_name))\n+                bug!(\"symbol `{}` is already defined\", section_var_name)\n             });\n             llvm::LLVMSetSection(section_var, section_name.as_ptr() as *const _);\n             llvm::LLVMSetInitializer(section_var, C_bytes(ccx, section_contents));"}, {"sha": "5690b18bc8edefea77a5aa180f9afe9c53e73c23", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 74, "deletions": 85, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -102,25 +102,22 @@ impl<'tcx> TypeMap<'tcx> {\n     // Adds a Ty to metadata mapping to the TypeMap. The method will fail if\n     // the mapping already exists.\n     fn register_type_with_metadata<'a>(&mut self,\n-                                       cx: &CrateContext<'a, 'tcx>,\n                                        type_: Ty<'tcx>,\n                                        metadata: DIType) {\n         if self.type_to_metadata.insert(type_, metadata).is_some() {\n-            cx.sess().bug(&format!(\"Type metadata for Ty '{}' is already in the TypeMap!\",\n-                                   type_));\n+            bug!(\"Type metadata for Ty '{}' is already in the TypeMap!\", type_);\n         }\n     }\n \n     // Adds a UniqueTypeId to metadata mapping to the TypeMap. The method will\n     // fail if the mapping already exists.\n     fn register_unique_id_with_metadata(&mut self,\n-                                        cx: &CrateContext,\n                                         unique_type_id: UniqueTypeId,\n                                         metadata: DIType) {\n         if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n             let unique_type_id_str = self.get_unique_type_id_as_string(unique_type_id);\n-            cx.sess().bug(&format!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n-                                  &unique_type_id_str[..]));\n+            bug!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n+                 &unique_type_id_str[..]);\n         }\n     }\n \n@@ -305,8 +302,8 @@ impl<'tcx> TypeMap<'tcx> {\n                 }\n             },\n             _ => {\n-                cx.sess().bug(&format!(\"get_unique_type_id_of_type() - unexpected type: {:?}\",\n-                                       type_))\n+                bug!(\"get_unique_type_id_of_type() - unexpected type: {:?}\",\n+                     type_)\n             }\n         };\n \n@@ -415,8 +412,8 @@ fn create_and_register_recursive_type_forward_declaration<'a, 'tcx>(\n \n     // Insert the stub into the TypeMap in order to allow for recursive references\n     let mut type_map = debug_context(cx).type_map.borrow_mut();\n-    type_map.register_unique_id_with_metadata(cx, unique_type_id, metadata_stub);\n-    type_map.register_type_with_metadata(cx, unfinished_type, metadata_stub);\n+    type_map.register_unique_id_with_metadata(unique_type_id, metadata_stub);\n+    type_map.register_type_with_metadata(unfinished_type, metadata_stub);\n \n     UnfinishedMetadata {\n         unfinished_type: unfinished_type,\n@@ -452,10 +449,9 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                     let type_map = debug_context(cx).type_map.borrow();\n                     if type_map.find_metadata_for_unique_id(unique_type_id).is_none() ||\n                        type_map.find_metadata_for_type(unfinished_type).is_none() {\n-                        cx.sess().bug(&format!(\"Forward declaration of potentially recursive type \\\n-                                              '{:?}' was not found in TypeMap!\",\n-                                              unfinished_type)\n-                                      );\n+                        bug!(\"Forward declaration of potentially recursive type \\\n+                              '{:?}' was not found in TypeMap!\",\n+                             unfinished_type);\n                     }\n                 }\n \n@@ -640,9 +636,9 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let def_id = match trait_type.sty {\n         ty::TyTrait(ref data) => data.principal_def_id(),\n         _ => {\n-            cx.sess().bug(&format!(\"debuginfo: Unexpected trait-object type in \\\n-                                   trait_pointer_metadata(): {:?}\",\n-                                   trait_type));\n+            bug!(\"debuginfo: Unexpected trait-object type in \\\n+                  trait_pointer_metadata(): {:?}\",\n+                 trait_type);\n         }\n     };\n \n@@ -688,7 +684,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         // There is already an equivalent type in the TypeMap.\n                         // Register this Ty as an alias in the cache and\n                         // return the cached metadata.\n-                        type_map.register_type_with_metadata(cx, t, metadata);\n+                        type_map.register_type_with_metadata(t, metadata);\n                         return metadata;\n                     },\n                     None => {\n@@ -803,8 +799,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    usage_site_span).finalize(cx)\n         }\n         _ => {\n-            cx.sess().bug(&format!(\"debuginfo: unexpected type in type_metadata: {:?}\",\n-                                  sty))\n+            bug!(\"debuginfo: unexpected type in type_metadata: {:?}\", sty)\n         }\n     };\n \n@@ -818,13 +813,13 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 None => {\n                     let unique_type_id_str =\n                         type_map.get_unique_type_id_as_string(unique_type_id);\n-                    let error_message = format!(\"Expected type metadata for unique \\\n-                                                 type id '{}' to already be in \\\n-                                                 the debuginfo::TypeMap but it \\\n-                                                 was not. (Ty = {})\",\n-                                                &unique_type_id_str[..],\n-                                                t);\n-                    cx.sess().span_bug(usage_site_span, &error_message[..]);\n+                    span_bug!(usage_site_span,\n+                              \"Expected type metadata for unique \\\n+                               type id '{}' to already be in \\\n+                               the debuginfo::TypeMap but it \\\n+                               was not. (Ty = {})\",\n+                              &unique_type_id_str[..],\n+                              t);\n                 }\n             };\n \n@@ -833,22 +828,22 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     if metadata != metadata_for_uid {\n                         let unique_type_id_str =\n                             type_map.get_unique_type_id_as_string(unique_type_id);\n-                        let error_message = format!(\"Mismatch between Ty and \\\n-                                                     UniqueTypeId maps in \\\n-                                                     debuginfo::TypeMap. \\\n-                                                     UniqueTypeId={}, Ty={}\",\n-                            &unique_type_id_str[..],\n-                            t);\n-                        cx.sess().span_bug(usage_site_span, &error_message[..]);\n+                        span_bug!(usage_site_span,\n+                                  \"Mismatch between Ty and \\\n+                                   UniqueTypeId maps in \\\n+                                   debuginfo::TypeMap. \\\n+                                   UniqueTypeId={}, Ty={}\",\n+                                  &unique_type_id_str[..],\n+                                  t);\n                     }\n                 }\n                 None => {\n-                    type_map.register_type_with_metadata(cx, t, metadata);\n+                    type_map.register_type_with_metadata(t, metadata);\n                 }\n             }\n         } else {\n-            type_map.register_type_with_metadata(cx, t, metadata);\n-            type_map.register_unique_id_with_metadata(cx, unique_type_id, metadata);\n+            type_map.register_type_with_metadata(t, metadata);\n+            type_map.register_unique_id_with_metadata(unique_type_id, metadata);\n         }\n     }\n \n@@ -901,16 +896,16 @@ pub fn scope_metadata(fcx: &FunctionContext,\n                   error_reporting_span: Span)\n                -> DIScope {\n     let scope_map = &fcx.debug_context\n-                        .get_ref(fcx.ccx, error_reporting_span)\n+                        .get_ref(error_reporting_span)\n                         .scope_map;\n     match scope_map.borrow().get(&node_id).cloned() {\n         Some(scope_metadata) => scope_metadata,\n         None => {\n             let node = fcx.ccx.tcx().map.get(node_id);\n \n-            fcx.ccx.sess().span_bug(error_reporting_span,\n-                &format!(\"debuginfo: Could not find scope info for node {:?}\",\n-                        node));\n+            span_bug!(error_reporting_span,\n+                      \"debuginfo: Could not find scope info for node {:?}\",\n+                      node);\n         }\n     }\n }\n@@ -945,7 +940,7 @@ fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyFloat(float_ty) => {\n             (float_ty.ty_to_string(), DW_ATE_float)\n         },\n-        _ => cx.sess().bug(\"debuginfo::basic_type_metadata - t is invalid type\")\n+        _ => bug!(\"debuginfo::basic_type_metadata - t is invalid type\")\n     };\n \n     let llvm_type = type_of::type_of(cx, t);\n@@ -1162,7 +1157,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let (variant, substs) = match struct_type.sty {\n         ty::TyStruct(def, substs) => (def.struct_variant(), substs),\n-        _ => cx.tcx().sess.bug(\"prepare_struct_metadata on a non-struct\")\n+        _ => bug!(\"prepare_struct_metadata on a non-struct\")\n     };\n \n     let (containing_scope, _) = get_namespace_and_span_for_item(cx, variant.did);\n@@ -1362,7 +1357,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         ty::VariantKind::Struct => {\n                             non_null_variant.fields[0].name.to_string()\n                         }\n-                        ty::VariantKind::Unit => unreachable!()\n+                        ty::VariantKind::Unit => bug!()\n                     },\n                     llvm_type: non_null_llvm_type,\n                     type_metadata: non_null_type_metadata,\n@@ -1452,7 +1447,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     }\n                 ]\n             },\n-            adt::CEnum(..) => cx.sess().span_bug(self.span, \"This should be unreachable.\")\n+            adt::CEnum(..) => span_bug!(self.span, \"This should be unreachable.\")\n         }\n     }\n }\n@@ -1747,8 +1742,8 @@ fn set_members_of_composite_type(cx: &CrateContext,\n         let mut composite_types_completed =\n             debug_context(cx).composite_types_completed.borrow_mut();\n         if composite_types_completed.contains(&composite_type_metadata) {\n-            cx.sess().bug(\"debuginfo::set_members_of_composite_type() - \\\n-                           Already completed forward declaration re-encountered.\");\n+            bug!(\"debuginfo::set_members_of_composite_type() - \\\n+                  Already completed forward declaration re-encountered.\");\n         } else {\n             composite_types_completed.insert(composite_type_metadata);\n         }\n@@ -1855,20 +1850,19 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                 hir::ItemStatic(..) => (item.name, item.span),\n                 hir::ItemConst(..) => (item.name, item.span),\n                 _ => {\n-                    cx.sess()\n-                      .span_bug(item.span,\n-                                &format!(\"debuginfo::\\\n-                                         create_global_var_metadata() -\n-                                         Captured var-id refers to \\\n-                                         unexpected ast_item variant: {:?}\",\n-                                        var_item))\n+                    span_bug!(item.span,\n+                              \"debuginfo::\\\n+                               create_global_var_metadata() -\n+                               Captured var-id refers to \\\n+                               unexpected ast_item variant: {:?}\",\n+                              var_item)\n                 }\n             }\n         },\n-        _ => cx.sess().bug(&format!(\"debuginfo::create_global_var_metadata() \\\n-                                    - Captured var-id refers to unexpected \\\n-                                    hir_map variant: {:?}\",\n-                                   var_item))\n+        _ => bug!(\"debuginfo::create_global_var_metadata() \\\n+                   - Captured var-id refers to unexpected \\\n+                   hir_map variant: {:?}\",\n+                  var_item)\n     };\n \n     let (file_metadata, line_number) = if span != codemap::DUMMY_SP {\n@@ -1924,15 +1918,15 @@ pub fn create_local_var_metadata(bcx: Block, local: &hir::Local) {\n         let datum = match locals.get(&node_id) {\n             Some(datum) => datum,\n             None => {\n-                bcx.sess().span_bug(span,\n-                    &format!(\"no entry in lllocals table for {}\",\n-                            node_id));\n+                span_bug!(span,\n+                          \"no entry in lllocals table for {}\",\n+                          node_id);\n             }\n         };\n \n         if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n-            cx.sess().span_bug(span, \"debuginfo::create_local_var_metadata() - \\\n-                                      Referenced variable location is not an alloca!\");\n+            span_bug!(span, \"debuginfo::create_local_var_metadata() - \\\n+                             Referenced variable location is not an alloca!\");\n         }\n \n         let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n@@ -1968,36 +1962,33 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let variable_name = match ast_item {\n         None => {\n-            cx.sess().span_bug(span, \"debuginfo::create_captured_var_metadata: node not found\");\n+            span_bug!(span, \"debuginfo::create_captured_var_metadata: node not found\");\n         }\n         Some(hir_map::NodeLocal(pat)) => {\n             match pat.node {\n                 PatKind::Ident(_, ref path1, _) => {\n                     path1.node.name\n                 }\n                 _ => {\n-                    cx.sess()\n-                      .span_bug(span,\n-                                &format!(\n-                                \"debuginfo::create_captured_var_metadata() - \\\n-                                 Captured var-id refers to unexpected \\\n-                                 hir_map variant: {:?}\",\n-                                 ast_item));\n+                    span_bug!(span,\n+                              \"debuginfo::create_captured_var_metadata() - \\\n+                               Captured var-id refers to unexpected \\\n+                               hir_map variant: {:?}\",\n+                              ast_item);\n                 }\n             }\n         }\n         _ => {\n-            cx.sess()\n-              .span_bug(span,\n-                        &format!(\"debuginfo::create_captured_var_metadata() - \\\n-                                 Captured var-id refers to unexpected \\\n-                                 hir_map variant: {:?}\",\n-                                ast_item));\n+            span_bug!(span,\n+                      \"debuginfo::create_captured_var_metadata() - \\\n+                       Captured var-id refers to unexpected \\\n+                       hir_map variant: {:?}\",\n+                      ast_item);\n         }\n     };\n \n     let variable_type = common::node_id_type(bcx, node_id);\n-    let scope_metadata = bcx.fcx.debug_context.get_ref(cx, span).fn_metadata;\n+    let scope_metadata = bcx.fcx.debug_context.get_ref(span).fn_metadata;\n \n     // env_pointer is the alloca containing the pointer to the environment,\n     // so it's type is **EnvironmentType. In order to find out the type of\n@@ -2096,30 +2087,28 @@ pub fn create_argument_metadata(bcx: Block, arg: &hir::Arg) {\n     let scope_metadata = bcx\n                          .fcx\n                          .debug_context\n-                         .get_ref(bcx.ccx(), arg.pat.span)\n+                         .get_ref(arg.pat.span)\n                          .fn_metadata;\n     let locals = bcx.fcx.lllocals.borrow();\n \n     pat_util::pat_bindings(def_map, &arg.pat, |_, node_id, span, var_name| {\n         let datum = match locals.get(&node_id) {\n             Some(v) => v,\n             None => {\n-                bcx.sess().span_bug(span,\n-                    &format!(\"no entry in lllocals table for {}\",\n-                            node_id));\n+                span_bug!(span, \"no entry in lllocals table for {}\", node_id);\n             }\n         };\n \n         if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n-            bcx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n-                                       Referenced variable location is not an alloca!\");\n+            span_bug!(span, \"debuginfo::create_argument_metadata() - \\\n+                             Referenced variable location is not an alloca!\");\n         }\n \n         let argument_index = {\n             let counter = &bcx\n                           .fcx\n                           .debug_context\n-                          .get_ref(bcx.ccx(), span)\n+                          .get_ref(span)\n                           .argument_counter;\n             let argument_index = counter.get();\n             counter.set(argument_index + 1);"}, {"sha": "6b92989cf464856a803a83a971689df1bc628ab1", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -119,18 +119,19 @@ pub enum FunctionDebugContext {\n \n impl FunctionDebugContext {\n     fn get_ref<'a>(&'a self,\n-                   cx: &CrateContext,\n                    span: Span)\n                    -> &'a FunctionDebugContextData {\n         match *self {\n             FunctionDebugContext::RegularContext(box ref data) => data,\n             FunctionDebugContext::DebugInfoDisabled => {\n-                cx.sess().span_bug(span,\n-                                   FunctionDebugContext::debuginfo_disabled_message());\n+                span_bug!(span,\n+                          \"{}\",\n+                          FunctionDebugContext::debuginfo_disabled_message());\n             }\n             FunctionDebugContext::FunctionWithoutDebugInfo => {\n-                cx.sess().span_bug(span,\n-                                   FunctionDebugContext::should_be_ignored_message());\n+                span_bug!(span,\n+                          \"{}\",\n+                          FunctionDebugContext::should_be_ignored_message());\n             }\n         }\n     }\n@@ -253,7 +254,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     (item.name, fn_decl, generics, top_level_block, item.span, true)\n                 }\n                 _ => {\n-                    cx.sess().span_bug(item.span,\n+                    span_bug!(item.span,\n                         \"create_function_debug_context: item bound to non-function\");\n                 }\n             }\n@@ -273,9 +274,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                      true)\n                 }\n                 _ => {\n-                    cx.sess().span_bug(impl_item.span,\n-                                       \"create_function_debug_context() \\\n-                                        called on non-method impl item?!\")\n+                    span_bug!(impl_item.span,\n+                              \"create_function_debug_context() \\\n+                               called on non-method impl item?!\")\n                 }\n             }\n         }\n@@ -293,7 +294,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         // Don't try to lookup the item path:\n                         false)\n                 }\n-                _ => cx.sess().span_bug(expr.span,\n+                _ => span_bug!(expr.span,\n                         \"create_function_debug_context: expected an expr_fn_block here\")\n             }\n         }\n@@ -312,10 +313,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                      true)\n                 }\n                 _ => {\n-                    cx.sess()\n-                      .bug(&format!(\"create_function_debug_context: \\\n-                                    unexpected sort of node: {:?}\",\n-                                    fnitem))\n+                    bug!(\"create_function_debug_context: \\\n+                          unexpected sort of node: {:?}\",\n+                         fnitem)\n                 }\n             }\n         }\n@@ -324,9 +324,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         hir_map::NodeStructCtor(..) => {\n             return FunctionDebugContext::FunctionWithoutDebugInfo;\n         }\n-        _ => cx.sess().bug(&format!(\"create_function_debug_context: \\\n-                                    unexpected sort of node: {:?}\",\n-                                   fnitem))\n+        _ => bug!(\"create_function_debug_context: \\\n+                   unexpected sort of node: {:?}\",\n+                  fnitem)\n     };\n \n     // This can be the case for functions inlined from another crate\n@@ -441,7 +441,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 (sig, closure_type.abi)\n             }\n \n-            _ => cx.sess().bug(\"get_function_metdata: Expected a function type!\")\n+            _ => bug!(\"get_function_metdata: Expected a function type!\")\n         };\n \n         let mut signature = Vec::with_capacity(sig.inputs.len() + 1);\n@@ -640,7 +640,7 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ArgumentVariable(_) | CapturedVariable => {\n             assert!(!bcx.fcx\n                         .debug_context\n-                        .get_ref(cx, span)\n+                        .get_ref(span)\n                         .source_locations_enabled\n                         .get());\n             source_loc::set_debug_location(cx, InternalDebugLocation::UnknownLocation);"}, {"sha": "445f85c52fc75b89c20eda87fe7cc709bbf148d7", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -126,9 +126,9 @@ pub fn namespace_for_item(cx: &CrateContext, def_id: DefId) -> Rc<NamespaceTreeN\n         match parent_node {\n             Some(node) => node,\n             None => {\n-                cx.sess().bug(&format!(\"debuginfo::namespace_for_item(): \\\n-                                       path too short for {:?}\",\n-                                      def_id));\n+                bug!(\"debuginfo::namespace_for_item(): \\\n+                      path too short for {:?}\",\n+                     def_id);\n             }\n         }\n     })"}, {"sha": "a6aa8df92db291d70abe1877aebcce853aac065b", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -154,8 +154,8 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyInfer(_) |\n         ty::TyProjection(..) |\n         ty::TyParam(_) => {\n-            cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\\n-                unexpected type: {:?}\", t));\n+            bug!(\"debuginfo: Trying to create type name for \\\n+                unexpected type: {:?}\", t);\n         }\n     }\n \n@@ -178,7 +178,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n \n                 if path_element_count == 0 {\n-                    cx.sess().bug(\"debuginfo: Encountered empty item path!\");\n+                    bug!(\"debuginfo: Encountered empty item path!\");\n                 }\n \n                 output.pop();"}, {"sha": "61dc3dc3f8fdbf8c22499af737feccc068e67fd4", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -91,8 +91,8 @@ pub fn assert_type_for_node_id(cx: &CrateContext,\n                            node_id: ast::NodeId,\n                            error_reporting_span: Span) {\n     if !cx.tcx().node_types().contains_key(&node_id) {\n-        cx.sess().span_bug(error_reporting_span,\n-                           \"debuginfo: Could not find type for node id!\");\n+        span_bug!(error_reporting_span,\n+                  \"debuginfo: Could not find type for node id!\");\n     }\n }\n "}, {"sha": "f49d303a5a802a519e63c6b55027cf8a0cb3a2dd", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -38,7 +38,7 @@ use libc::c_uint;\n pub fn declare_global(ccx: &CrateContext, name: &str, ty: Type) -> llvm::ValueRef {\n     debug!(\"declare_global(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n-        ccx.sess().bug(&format!(\"name {:?} contains an interior null byte\", name))\n+        bug!(\"name {:?} contains an interior null byte\", name)\n     });\n     unsafe {\n         llvm::LLVMGetOrInsertGlobal(ccx.llmod(), namebuf.as_ptr(), ty.to_ref())\n@@ -53,7 +53,7 @@ pub fn declare_global(ccx: &CrateContext, name: &str, ty: Type) -> llvm::ValueRe\n fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty: Type) -> ValueRef {\n     debug!(\"declare_raw_fn(name={:?}, ty={:?})\", name, ty);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n-        ccx.sess().bug(&format!(\"name {:?} contains an interior null byte\", name))\n+        bug!(\"name {:?} contains an interior null byte\", name)\n     });\n     let llfn = unsafe {\n         llvm::LLVMGetOrInsertFunction(ccx.llmod(), namebuf.as_ptr(), ty.to_ref())\n@@ -152,7 +152,7 @@ pub fn define_internal_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n pub fn get_defined_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n     debug!(\"get_defined_value(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n-        ccx.sess().bug(&format!(\"name {:?} contains an interior null byte\", name))\n+        bug!(\"name {:?} contains an interior null byte\", name)\n     });\n     let val = unsafe { llvm::LLVMGetNamedValue(ccx.llmod(), namebuf.as_ptr()) };\n     if val.is_null() {"}, {"sha": "5e193b962783b233098d00555c6abd654fc1429c", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 67, "deletions": 74, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -388,7 +388,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         .reify(bcx.ccx()).to_expr_datum();\n                 }\n                 _ => {\n-                    unreachable!(\"{} cannot be reified to a fn ptr\", datum.ty)\n+                    bug!(\"{} cannot be reified to a fn ptr\", datum.ty)\n                 }\n             }\n         }\n@@ -516,16 +516,16 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let repr_source = adt::represent_type(bcx.ccx(), source.ty);\n             let src_fields = match &*repr_source {\n                 &adt::Repr::Univariant(ref s, _) => &s.fields,\n-                _ => bcx.sess().span_bug(span,\n-                                         &format!(\"Non univariant struct? (repr_source: {:?})\",\n-                                                  repr_source)),\n+                _ => span_bug!(span,\n+                               \"Non univariant struct? (repr_source: {:?})\",\n+                               repr_source),\n             };\n             let repr_target = adt::represent_type(bcx.ccx(), target.ty);\n             let target_fields = match &*repr_target {\n                 &adt::Repr::Univariant(ref s, _) => &s.fields,\n-                _ => bcx.sess().span_bug(span,\n-                                         &format!(\"Non univariant struct? (repr_target: {:?})\",\n-                                                  repr_target)),\n+                _ => span_bug!(span,\n+                               \"Non univariant struct? (repr_target: {:?})\",\n+                               repr_target),\n             };\n \n             let coerce_index = match kind {\n@@ -555,9 +555,9 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n             }\n         }\n-        _ => bcx.sess().bug(&format!(\"coerce_unsized: invalid coercion {:?} -> {:?}\",\n-                                     source.ty,\n-                                     target.ty))\n+        _ => bug!(\"coerce_unsized: invalid coercion {:?} -> {:?}\",\n+                  source.ty,\n+                  target.ty)\n     }\n     bcx\n }\n@@ -671,8 +671,8 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 ty::TyBox(..) => {\n                     trans_uniq_expr(bcx, expr, box_ty, &contents, contents_ty)\n                 }\n-                _ => bcx.sess().span_bug(expr.span,\n-                                         \"expected unique box\")\n+                _ => span_bug!(expr.span,\n+                               \"expected unique box\")\n             }\n \n         }\n@@ -708,11 +708,11 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_imm_cast(bcx, &val, expr.id)\n         }\n         _ => {\n-            bcx.tcx().sess.span_bug(\n+            span_bug!(\n                 expr.span,\n-                &format!(\"trans_rvalue_datum_unadjusted reached \\\n-                         fall-through case: {:?}\",\n-                        expr.node));\n+                \"trans_rvalue_datum_unadjusted reached \\\n+                 fall-through case: {:?}\",\n+                expr.node);\n         }\n     }\n }\n@@ -798,9 +798,9 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap().unwrap();\n             let elt_ty = match ref_ty.builtin_deref(true, ty::NoPreference) {\n                 None => {\n-                    bcx.tcx().sess.span_bug(index_expr.span,\n-                                            \"index method didn't return a \\\n-                                             dereferenceable type?!\")\n+                    span_bug!(index_expr.span,\n+                              \"index method didn't return a \\\n+                              dereferenceable type?!\")\n                 }\n                 Some(elt_tm) => elt_tm.ty,\n             };\n@@ -895,26 +895,22 @@ pub fn trans_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, def: Def)\n             match bcx.fcx.llupvars.borrow().get(&nid) {\n                 Some(&val) => Datum::new(val, local_ty, lval),\n                 None => {\n-                    bcx.sess().bug(&format!(\n-                        \"trans_var: no llval for upvar {} found\",\n-                        nid));\n+                    bug!(\"trans_var: no llval for upvar {} found\", nid);\n                 }\n             }\n         }\n         Def::Local(_, nid) => {\n             let datum = match bcx.fcx.lllocals.borrow().get(&nid) {\n                 Some(&v) => v,\n                 None => {\n-                    bcx.sess().bug(&format!(\n-                        \"trans_var: no datum for local/arg {} found\",\n-                        nid));\n+                    bug!(\"trans_var: no datum for local/arg {} found\", nid);\n                 }\n             };\n             debug!(\"take_local(nid={}, v={:?}, ty={})\",\n                    nid, Value(datum.val), datum.ty);\n             datum\n         }\n-        _ => unreachable!(\"{:?} should not reach expr::trans_var\", def)\n+        _ => bug!(\"{:?} should not reach expr::trans_var\", def)\n     }\n }\n \n@@ -1051,11 +1047,11 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx\n         }\n         _ => {\n-            bcx.tcx().sess.span_bug(\n+            span_bug!(\n                 expr.span,\n-                &format!(\"trans_rvalue_stmt_unadjusted reached \\\n-                         fall-through case: {:?}\",\n-                        expr.node));\n+                \"trans_rvalue_stmt_unadjusted reached \\\n+                 fall-through case: {:?}\",\n+                expr.node);\n         }\n     }\n }\n@@ -1114,11 +1110,9 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     tvec::trans_lit_str(bcx, expr, (*s).clone(), dest)\n                 }\n                 _ => {\n-                    bcx.tcx()\n-                       .sess\n-                       .span_bug(expr.span,\n-                                 \"trans_rvalue_dps_unadjusted shouldn't be \\\n-                                  translating this type of literal\")\n+                    span_bug!(expr.span,\n+                              \"trans_rvalue_dps_unadjusted shouldn't be \\\n+                              translating this type of literal\")\n                 }\n             }\n         }\n@@ -1141,9 +1135,9 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let (def_id, substs) = match expr_ty(bcx, expr).sty {\n                 ty::TyClosure(def_id, ref substs) => (def_id, substs),\n                 ref t =>\n-                    bcx.tcx().sess.span_bug(\n+                    span_bug!(\n                         expr.span,\n-                        &format!(\"closure expr without closure type: {:?}\", t)),\n+                        \"closure expr without closure type: {:?}\", t),\n             };\n \n             closure::trans_closure_expr(dest,\n@@ -1172,8 +1166,8 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         Callee::ptr(f)\n                     }\n                     _ => {\n-                        bcx.tcx().sess.span_bug(expr.span,\n-                            &format!(\"type of callee is not a fn: {}\", f.ty));\n+                        span_bug!(expr.span,\n+                            \"type of callee is not a fn: {}\", f.ty);\n                     }\n                 }, ArgExprs(&args))\n             };\n@@ -1205,20 +1199,20 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         hir::ExprCast(..) => {\n             // Trait casts used to come this way, now they should be coercions.\n-            bcx.tcx().sess.span_bug(expr.span, \"DPS expr_cast (residual trait cast?)\")\n+            span_bug!(expr.span, \"DPS expr_cast (residual trait cast?)\")\n         }\n         hir::ExprAssignOp(op, _, _) => {\n-            bcx.tcx().sess.span_bug(\n+            span_bug!(\n                 expr.span,\n-                &format!(\"augmented assignment `{}=` should always be a rvalue_stmt\",\n-                         rustc_front::util::binop_to_string(op.node)))\n+                \"augmented assignment `{}=` should always be a rvalue_stmt\",\n+                rustc_front::util::binop_to_string(op.node))\n         }\n         _ => {\n-            bcx.tcx().sess.span_bug(\n+            span_bug!(\n                 expr.span,\n-                &format!(\"trans_rvalue_dps_unadjusted reached fall-through \\\n-                         case: {:?}\",\n-                        expr.node));\n+                \"trans_rvalue_dps_unadjusted reached fall-through \\\n+                 case: {:?}\",\n+                expr.node);\n         }\n     }\n }\n@@ -1261,9 +1255,9 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx\n         }\n         _ => {\n-            bcx.tcx().sess.span_bug(ref_expr.span, &format!(\n-                \"Non-DPS def {:?} referened by {}\",\n-                def, bcx.node_id_to_string(ref_expr.id)));\n+            span_bug!(ref_expr.span,\n+                      \"Non-DPS def {:?} referened by {}\",\n+                      def, bcx.node_id_to_string(ref_expr.id));\n         }\n     }\n }\n@@ -1301,7 +1295,7 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         None => {\n             if need_base.iter().any(|b| *b) {\n-                tcx.sess.span_bug(expr_span, \"missing fields and no base expr\")\n+                span_bug!(expr_span, \"missing fields and no base expr\")\n             }\n             None\n         }\n@@ -1415,7 +1409,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 bcx = trans_into(bcx, &base.expr, SaveIn(addr.value));\n             },\n             ExprKind::RvalueStmt => {\n-                bcx.tcx().sess.bug(\"unexpected expr kind for struct base expr\")\n+                bug!(\"unexpected expr kind for struct base expr\")\n             }\n             _ => {\n                 let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &base.expr, \"base\"));\n@@ -1728,7 +1722,7 @@ fn trans_scalar_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n           base::compare_scalar_types(bcx, lhs, rhs, lhs_t, op.node, binop_debug_loc)\n       }\n       _ => {\n-        bcx.tcx().sess.span_bug(binop_expr.span, \"unexpected binop\");\n+        span_bug!(binop_expr.span, \"unexpected binop\");\n       }\n     };\n \n@@ -1968,12 +1962,11 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         (Float, Int(I)) => FPToSI(bcx, llexpr, ll_t_out),\n         (Float, Int(_)) => FPToUI(bcx, llexpr, ll_t_out),\n \n-        _ => ccx.sess().span_bug(expr.span,\n-                                  &format!(\"translating unsupported cast: \\\n-                                            {:?} -> {:?}\",\n-                                           t_in,\n-                                           t_out)\n-                                 )\n+        _ => span_bug!(expr.span,\n+                       \"translating unsupported cast: \\\n+                        {:?} -> {:?}\",\n+                       t_in,\n+                       t_out)\n     };\n     return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n }\n@@ -2140,10 +2133,10 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n \n         _ => {\n-            bcx.tcx().sess.span_bug(\n+            span_bug!(\n                 expr.span,\n-                &format!(\"deref invoked on expr of invalid type {:?}\",\n-                        datum.ty));\n+                \"deref invoked on expr of invalid type {:?}\",\n+                datum.ty);\n         }\n     };\n \n@@ -2200,16 +2193,16 @@ impl OverflowOpViaIntrinsic {\n             TyInt(Is) => match &tcx.sess.target.target.target_pointer_width[..] {\n                 \"32\" => TyInt(I32),\n                 \"64\" => TyInt(I64),\n-                _ => panic!(\"unsupported target word size\")\n+                _ => bug!(\"unsupported target word size\")\n             },\n             TyUint(Us) => match &tcx.sess.target.target.target_pointer_width[..] {\n                 \"32\" => TyUint(U32),\n                 \"64\" => TyUint(U64),\n-                _ => panic!(\"unsupported target word size\")\n+                _ => bug!(\"unsupported target word size\")\n             },\n             ref t @ TyUint(_) | ref t @ TyInt(_) => t.clone(),\n-            _ => panic!(\"tried to get overflow intrinsic for {:?} applied to non-int type\",\n-                        *self)\n+            _ => bug!(\"tried to get overflow intrinsic for {:?} applied to non-int type\",\n+                      *self)\n         };\n \n         match *self {\n@@ -2224,7 +2217,7 @@ impl OverflowOpViaIntrinsic {\n                 TyUint(U32) => \"llvm.uadd.with.overflow.i32\",\n                 TyUint(U64) => \"llvm.uadd.with.overflow.i64\",\n \n-                _ => unreachable!(),\n+                _ => bug!(),\n             },\n             OverflowOpViaIntrinsic::Sub => match new_sty {\n                 TyInt(I8) => \"llvm.ssub.with.overflow.i8\",\n@@ -2237,7 +2230,7 @@ impl OverflowOpViaIntrinsic {\n                 TyUint(U32) => \"llvm.usub.with.overflow.i32\",\n                 TyUint(U64) => \"llvm.usub.with.overflow.i64\",\n \n-                _ => unreachable!(),\n+                _ => bug!(),\n             },\n             OverflowOpViaIntrinsic::Mul => match new_sty {\n                 TyInt(I8) => \"llvm.smul.with.overflow.i8\",\n@@ -2250,7 +2243,7 @@ impl OverflowOpViaIntrinsic {\n                 TyUint(U32) => \"llvm.umul.with.overflow.i32\",\n                 TyUint(U64) => \"llvm.umul.with.overflow.i64\",\n \n-                _ => unreachable!(),\n+                _ => bug!(),\n             },\n         }\n     }\n@@ -2337,7 +2330,7 @@ fn build_nonzero_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let int_value = BitCast(bcx, value, Type::ix(bcx.ccx(), width));\n             build_nonzero_check(bcx, int_value, binop_debug_loc)\n         },\n-        _ => panic!(\"build_nonzero_check: expected Integer or Vector, found {:?}\", kind),\n+        _ => bug!(\"build_nonzero_check: expected Integer or Vector, found {:?}\", kind),\n     }\n }\n \n@@ -2423,11 +2416,11 @@ fn expr_kind(tcx: &TyCtxt, expr: &hir::Expr) -> ExprKind {\n                 Def::AssociatedConst(..) => ExprKind::RvalueDatum,\n \n                 def => {\n-                    tcx.sess.span_bug(\n+                    span_bug!(\n                         expr.span,\n-                        &format!(\"uncategorized def for expr {}: {:?}\",\n-                                expr.id,\n-                                def));\n+                        \"uncategorized def for expr {}: {:?}\",\n+                        expr.id,\n+                        def);\n                 }\n             }\n         }"}, {"sha": "6ef4ed4b87e55792bb25ac2cecec776c81a33cbd", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -367,7 +367,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     });\n     let vtbl = match fulfill_obligation(bcx.ccx(), DUMMY_SP, trait_ref) {\n         traits::VtableImpl(data) => data,\n-        _ => tcx.sess.bug(&format!(\"dtor for {:?} is not an impl???\", t))\n+        _ => bug!(\"dtor for {:?} is not an impl???\", t)\n     };\n     let dtor_did = def.destructor().unwrap();\n     bcx = Callee::def(bcx.ccx(), dtor_did, vtbl.substs)\n@@ -482,7 +482,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n             (bcx.mul(info, C_uint(bcx.ccx(), unit_size)),\n              C_uint(bcx.ccx(), unit_align))\n         }\n-        _ => bcx.sess().bug(&format!(\"Unexpected unsized type, found {}\", t))\n+        _ => bug!(\"Unexpected unsized type, found {}\", t)\n     }\n }\n "}, {"sha": "4d18e3bd4958ff971c8323ba8c73c1d46688d137", "filename": "src/librustc_trans/inline.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Finline.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -102,16 +102,16 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n                 }\n                 hir::ItemStruct(ref struct_def, _) => {\n                     if struct_def.is_struct() {\n-                        ccx.sess().bug(\"instantiate_inline: called on a \\\n-                                                                 non-tuple struct\")\n+                        bug!(\"instantiate_inline: called on a \\\n+                              non-tuple struct\")\n                     } else {\n                         ccx.external().borrow_mut().insert(fn_id, Some(struct_def.id()));\n                         ccx.external_srcs().borrow_mut().insert(struct_def.id(), fn_id);\n                         my_id = struct_def.id();\n                     }\n                 }\n-                _ => ccx.sess().bug(\"instantiate_inline: item has a \\\n-                                 non-enum, non-struct parent\")\n+                _ => bug!(\"instantiate_inline: item has a \\\n+                           non-enum, non-struct parent\")\n             }\n             my_id\n         }"}, {"sha": "219f970835a4a305283424107d808637bb65fc17", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -188,7 +188,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             let sig = tcx.erase_late_bound_regions(&fty.sig);\n             (def_id, substs, infer::normalize_associated_type(tcx, &sig))\n         }\n-        _ => unreachable!(\"expected fn item type, found {}\", callee_ty)\n+        _ => bug!(\"expected fn item type, found {}\", callee_ty)\n     };\n     let arg_tys = sig.inputs;\n     let ret_ty = sig.output;\n@@ -311,7 +311,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n \n             _ => {\n-                ccx.sess().bug(\"expected expr as argument for transmute\");\n+                bug!(\"expected expr as argument for transmute\");\n             }\n         }\n     }\n@@ -323,7 +323,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     if name == \"move_val_init\" {\n         if let callee::ArgExprs(ref exprs) = args {\n             let (dest_expr, source_expr) = if exprs.len() != 2 {\n-                ccx.sess().bug(\"expected two exprs as arguments for `move_val_init` intrinsic\");\n+                bug!(\"expected two exprs as arguments for `move_val_init` intrinsic\");\n             } else {\n                 (&exprs[0], &exprs[1])\n             };\n@@ -350,7 +350,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n             return Result::new(bcx, llresult);\n         } else {\n-            ccx.sess().bug(\"expected two exprs as arguments for `move_val_init` intrinsic\");\n+            bug!(\"expected two exprs as arguments for `move_val_init` intrinsic\");\n         }\n     }\n \n@@ -388,7 +388,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     let ret_ty = match ret_ty {\n         ty::FnConverging(ret_ty) => ret_ty,\n-        ty::FnDiverging => unreachable!()\n+        ty::FnDiverging => bug!()\n     };\n \n     let llret_ty = type_of::type_of(ccx, ret_ty);\n@@ -651,7 +651,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                             } else {\n                                 URem(bcx, llargs[0], llargs[1], call_debug_location)\n                             },\n-                        _ => unreachable!(),\n+                        _ => bug!(),\n                     },\n                 None => {\n                     span_invalid_monomorphization_error(\n@@ -674,7 +674,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         \"fmul_fast\" => FMulFast(bcx, llargs[0], llargs[1], call_debug_location),\n                         \"fdiv_fast\" => FDivFast(bcx, llargs[0], llargs[1], call_debug_location),\n                         \"frem_fast\" => FRemFast(bcx, llargs[0], llargs[1], call_debug_location),\n-                        _ => unreachable!(),\n+                        _ => bug!(),\n                     },\n                 None => {\n                     span_invalid_monomorphization_error(\n@@ -820,7 +820,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, _) => {\n             let intr = match Intrinsic::find(&name) {\n                 Some(intr) => intr,\n-                None => unreachable!(\"unknown intrinsic '{}'\", name),\n+                None => bug!(\"unknown intrinsic '{}'\", name),\n             };\n             fn one<T>(x: Vec<T>) -> T {\n                 assert_eq!(x.len(), 1);\n@@ -839,7 +839,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         match x {\n                             32 => vec![Type::f32(ccx)],\n                             64 => vec![Type::f64(ccx)],\n-                            _ => unreachable!()\n+                            _ => bug!()\n                         }\n                     }\n                     Pointer(ref t, ref llvm_elem, _const) => {\n@@ -1242,7 +1242,7 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             Some(did) => {\n                 Callee::def(ccx, did, tcx.mk_substs(Substs::empty())).reify(ccx).val\n             }\n-            None => ccx.sess().bug(\"eh_personality_catch not defined\"),\n+            None => bug!(\"eh_personality_catch not defined\"),\n         };\n \n         let then = bcx.fcx.new_temp_block(\"then\");\n@@ -1357,7 +1357,7 @@ fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         Some(did) => {\n             Callee::def(ccx, did, tcx.mk_substs(Substs::empty())).reify(ccx).val\n         }\n-        None => ccx.sess().bug(\"msvc_try_filter not defined\"),\n+        None => bug!(\"msvc_try_filter not defined\"),\n     };\n \n     let output = ty::FnOutput::FnConverging(tcx.types.i32);\n@@ -1417,7 +1417,7 @@ fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n             do_trans(bcx, exn, rbp);\n         })\n     } else {\n-        panic!(\"unknown target to generate a filter function\")\n+        bug!(\"unknown target to generate a filter function\")\n     }\n }\n \n@@ -1513,8 +1513,8 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n     if name.starts_with(\"simd_shuffle\") {\n         let n: usize = match name[\"simd_shuffle\".len()..].parse() {\n             Ok(n) => n,\n-            Err(_) => tcx.sess.span_bug(span,\n-                                        \"bad `simd_shuffle` instruction only caught in trans?\")\n+            Err(_) => span_bug!(span,\n+                                \"bad `simd_shuffle` instruction only caught in trans?\")\n         };\n \n         require_simd!(ret_ty, \"return\");\n@@ -1687,7 +1687,7 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n         simd_or: TyUint, TyInt => Or;\n         simd_xor: TyUint, TyInt => Xor;\n     }\n-    bcx.sess().span_bug(span, \"unknown SIMD intrinsic\");\n+    span_bug!(span, \"unknown SIMD intrinsic\");\n }\n \n // Returns the width of an int TypeVariant, and if it's signed or not\n@@ -1701,7 +1701,7 @@ fn int_type_width_signed<'tcx>(sty: &ty::TypeVariants<'tcx>, ccx: &CrateContext)\n                 match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n                     \"32\" => 32,\n                     \"64\" => 64,\n-                    tws => panic!(\"Unsupported target word size for isize: {}\", tws),\n+                    tws => bug!(\"Unsupported target word size for isize: {}\", tws),\n                 }\n             },\n             ast::IntTy::I8 => 8,\n@@ -1714,7 +1714,7 @@ fn int_type_width_signed<'tcx>(sty: &ty::TypeVariants<'tcx>, ccx: &CrateContext)\n                 match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n                     \"32\" => 32,\n                     \"64\" => 64,\n-                    tws => panic!(\"Unsupported target word size for usize: {}\", tws),\n+                    tws => bug!(\"Unsupported target word size for usize: {}\", tws),\n                 }\n             },\n             ast::UintTy::U8 => 8,"}, {"sha": "8c6a68cfcf11032706d1f33f171aebeb571ed056", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -43,7 +43,7 @@ extern crate flate;\n extern crate getopts;\n extern crate graphviz;\n extern crate libc;\n-extern crate rustc;\n+#[macro_use] extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_data_structures;\n extern crate rustc_front;"}, {"sha": "82b61e15f2bfe1561d04dfc1c80979519eb3a9e3", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -186,15 +186,13 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 // this would imply that the Self type being erased is\n                 // an object type; this cannot happen because we\n                 // cannot cast an unsized type into a trait object\n-                tcx.sess.bug(\n-                    &format!(\"cannot get vtable for an object type: {:?}\",\n-                            data));\n+                bug!(\"cannot get vtable for an object type: {:?}\",\n+                     data);\n             }\n             traits::VtableParam(..) => {\n-                tcx.sess.bug(\n-                    &format!(\"resolved vtable for {:?} to bad vtable {:?} in trans\",\n-                            trait_ref,\n-                            vtable));\n+                bug!(\"resolved vtable for {:?} to bad vtable {:?} in trans\",\n+                     trait_ref,\n+                     vtable);\n             }\n         }\n     });\n@@ -229,8 +227,8 @@ pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let trt_id = match tcx.impl_trait_ref(impl_id) {\n         Some(t_id) => t_id.def_id,\n-        None       => ccx.sess().bug(\"make_impl_vtable: don't know how to \\\n-                                      make a vtable for a type impl!\")\n+        None       => bug!(\"make_impl_vtable: don't know how to \\\n+                            make a vtable for a type impl!\")\n     };\n \n     tcx.populate_implementations_for_trait_if_necessary(trt_id);\n@@ -256,7 +254,7 @@ pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n             let trait_method_type = match tcx.impl_or_trait_item(trait_method_def_id) {\n                 ty::MethodTraitItem(m) => m,\n-                _ => ccx.sess().bug(\"should be a method, not other assoc item\"),\n+                _ => bug!(\"should be a method, not other assoc item\"),\n             };\n             let name = trait_method_type.name;\n \n@@ -330,7 +328,7 @@ pub fn get_impl_method<'tcx>(tcx: &TyCtxt<'tcx>,\n             }\n         }\n         None => {\n-            tcx.sess.bug(&format!(\"method {:?} not found in {:?}\", name, impl_def_id))\n+            bug!(\"method {:?} not found in {:?}\", name, impl_def_id)\n         }\n     }\n }"}, {"sha": "cbe21664d28a75bfca0d86435df8265111eec53f", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -166,7 +166,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             ty: callee.ty\n                         }, f.abi, &f.sig)\n                     }\n-                    _ => unreachable!(\"{} is not callable\", callee.ty)\n+                    _ => bug!(\"{} is not callable\", callee.ty)\n                 };\n \n                 // Handle intrinsics old trans wants Expr's for, ourselves.\n@@ -295,7 +295,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         return;\n                     }\n                     Fn(f) => f,\n-                    Virtual(_) => unreachable!(\"Virtual fn ptr not extracted\")\n+                    Virtual(_) => bug!(\"Virtual fn ptr not extracted\")\n                 };\n \n                 // Many different ways to call a function handled here\n@@ -417,7 +417,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n             Immediate(llval) => (llval, false),\n             Ref(llval) => (llval, true),\n-            FatPtr(_, _) => unreachable!(\"fat pointers handled above\")\n+            FatPtr(_, _) => bug!(\"fat pointers handled above\")\n         };\n \n         if by_ref && !arg.is_indirect() {\n@@ -470,9 +470,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let lv_ty = lv.ty.to_ty(bcx.tcx());\n         let result_types = match lv_ty.sty {\n             ty::TyTuple(ref tys) => tys,\n-            _ => bcx.tcx().sess.span_bug(\n+            _ => span_bug!(\n                 self.mir.span,\n-                &format!(\"bad final argument to \\\"rust-call\\\" fn {:?}\", lv_ty))\n+                \"bad final argument to \\\"rust-call\\\" fn {:?}\", lv_ty)\n         };\n \n         let base_repr = adt::represent_type(bcx.ccx(), lv_ty);"}, {"sha": "cf85595c08e961053db44534dd32d22b9f9c91cb", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -89,10 +89,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             ConstVal::Struct(_) | ConstVal::Tuple(_) |\n             ConstVal::Array(..) | ConstVal::Repeat(..) |\n             ConstVal::Function(_) => {\n-                unreachable!(\"MIR must not use {:?} (which refers to a local ID)\", cv)\n+                bug!(\"MIR must not use {:?} (which refers to a local ID)\", cv)\n             }\n             ConstVal::Char(c) => C_integral(Type::char(ccx), c as u64, false),\n-            ConstVal::Dummy => unreachable!(),\n+            ConstVal::Dummy => bug!(),\n         }\n     }\n "}, {"sha": "c9087181f9ddcea7d0b3db273dae8adaa64264a6", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -81,7 +81,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 assert!(lvalue.llextra != ptr::null_mut());\n                 lvalue.llextra\n             }\n-            _ => bcx.sess().bug(\"unexpected type in lvalue_len\"),\n+            _ => bug!(\"unexpected type in lvalue_len\"),\n         }\n     }\n \n@@ -100,7 +100,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 TempRef::Lvalue(lvalue) =>\n                     lvalue,\n                 TempRef::Operand(..) =>\n-                    tcx.sess.bug(&format!(\"using operand temp {:?} as lvalue\", lvalue)),\n+                    bug!(\"using operand temp {:?} as lvalue\", lvalue),\n             },\n             mir::Lvalue::Arg(index) => self.args[index as usize],\n             mir::Lvalue::Static(def_id) => {"}, {"sha": "a7e57fc714b92b3d24a5fd4e7b5520a5e0d5d2a9", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -180,7 +180,7 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n \n             let tupled_arg_tys = match arg_ty.sty {\n                 ty::TyTuple(ref tys) => tys,\n-                _ => unreachable!(\"spread argument isn't a tuple?!\")\n+                _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n             let lltemp = bcx.with_block(|bcx| {"}, {"sha": "c15d6cd5b2440929536cf4a4030a9ac8b74e705d", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -79,7 +79,7 @@ impl<'tcx> OperandRef<'tcx> {\n     pub fn immediate(self) -> ValueRef {\n         match self.val {\n             OperandValue::Immediate(s) => s,\n-            _ => unreachable!()\n+            _ => bug!()\n         }\n     }\n }\n@@ -124,8 +124,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             return o;\n                         }\n                         TempRef::Operand(None) => {\n-                            bcx.tcx().sess.bug(\n-                                &format!(\"use of {:?} before def\", lvalue));\n+                            bug!(\"use of {:?} before def\", lvalue);\n                         }\n                         TempRef::Lvalue(..) => {\n                             // use path below"}, {"sha": "3f7a6c5f180451f3ae669f7423347dc7f9d68c42", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -70,7 +70,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let operand = self.trans_operand(&bcx, source);\n                 bcx.with_block(|bcx| {\n                     match operand.val {\n-                        OperandValue::FatPtr(..) => unreachable!(),\n+                        OperandValue::FatPtr(..) => bug!(),\n                         OperandValue::Immediate(llval) => {\n                             // unsize from an immediate structure. We don't\n                             // really need a temporary alloca here, but\n@@ -185,7 +185,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     ty::TySlice(_) | ty::TyStr => {\n                         (bcx.gepi(input.llval, &[from_start]), input.llextra)\n                     }\n-                    _ => unreachable!(\"cannot slice {}\", ty)\n+                    _ => bug!(\"cannot slice {}\", ty)\n                 };\n                 let adj = C_uint(ccx, from_start + from_end);\n                 let lllen1 = bcx.sub(lllen, adj);\n@@ -246,7 +246,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                         .reify(bcx.ccx()).val)\n                             }\n                             _ => {\n-                                unreachable!(\"{} cannot be reified to a fn ptr\", operand.ty)\n+                                bug!(\"{} cannot be reified to a fn ptr\", operand.ty)\n                             }\n                         }\n                     }\n@@ -279,9 +279,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 OperandValue::FatPtr(lldata, llextra)\n                             }\n                             OperandValue::Ref(_) => {\n-                                bcx.sess().bug(\n-                                    &format!(\"by-ref operand {:?} in trans_rvalue_operand\",\n-                                             operand));\n+                                bug!(\"by-ref operand {:?} in trans_rvalue_operand\",\n+                                     operand);\n                             }\n                         }\n                     }\n@@ -341,9 +340,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 bcx.fptosi(llval, ll_t_out),\n                             (CastTy::Float, CastTy::Int(_)) =>\n                                 bcx.fptoui(llval, ll_t_out),\n-                            _ => bcx.ccx().sess().bug(\n-                                &format!(\"unsupported cast: {:?} to {:?}\", operand.ty, cast_ty)\n-                            )\n+                            _ => bug!(\"unsupported cast: {:?} to {:?}\", operand.ty, cast_ty)\n                         };\n                         OperandValue::Immediate(newval)\n                     }\n@@ -364,7 +361,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 OperandValue::Immediate(llval)\n                             }\n                         } else {\n-                            panic!(\"Unexpected non-FatPtr operand\")\n+                            bug!(\"Unexpected non-FatPtr operand\")\n                         }\n                     }\n                 };\n@@ -425,7 +422,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                        DebugLoc::None)\n                             })\n                         }\n-                        _ => unreachable!()\n+                        _ => bug!()\n                     }\n \n                 } else {\n@@ -489,7 +486,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Rvalue::Aggregate(..) |\n             mir::Rvalue::Slice { .. } |\n             mir::Rvalue::InlineAsm { .. } => {\n-                bcx.tcx().sess.bug(&format!(\"cannot generate operand from rvalue {:?}\", rvalue));\n+                bug!(\"cannot generate operand from rvalue {:?}\", rvalue);\n+\n             }\n         }\n     }"}, {"sha": "1d85ac6fb796074867e003d5b158a4cb78ff1703", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -36,9 +36,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 bcx\n                             }\n                             TempRef::Operand(Some(_)) => {\n-                                bcx.tcx().sess.span_bug(\n-                                    statement.span,\n-                                    &format!(\"operand {:?} already assigned\", rvalue));\n+                                span_bug!(statement.span,\n+                                          \"operand {:?} already assigned\",\n+                                          rvalue);\n                             }\n                         }\n                     }"}, {"sha": "554e1948fe9de2e729df0bed93189503ceefd685", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -149,13 +149,13 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     Disr::from(inlined_variant_def(ccx, fn_node_id).disr_val)\n                 }\n                 hir_map::NodeStructCtor(_) => Disr(0),\n-                _ => unreachable!()\n+                _ => bug!()\n             };\n             attributes::inline(lldecl, attributes::InlineAttr::Hint);\n             base::trans_ctor_shim(ccx, fn_node_id, disr, psubsts, lldecl);\n         }\n \n-        _ => unreachable!(\"can't monomorphize a {:?}\", map_node)\n+        _ => bug!(\"can't monomorphize a {:?}\", map_node)\n     };\n \n     ccx.monomorphizing().borrow_mut().insert(fn_id, depth);"}, {"sha": "b9af02ac529f513f1d75cea9e6e3906fc1f7a4dd", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -183,8 +183,7 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     }\n                 }\n                 _ => {\n-                    bcx.tcx().sess.span_bug(content_expr.span,\n-                                            \"unexpected evec content\");\n+                    span_bug!(content_expr.span, \"unexpected evec content\");\n                 }\n             }\n         }\n@@ -236,8 +235,7 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         _ => {\n-            bcx.tcx().sess.span_bug(content_expr.span,\n-                                    \"unexpected vec content\");\n+            span_bug!(content_expr.span, \"unexpected vec content\");\n         }\n     }\n }\n@@ -264,17 +262,15 @@ fn elements_required(bcx: Block, content_expr: &hir::Expr) -> usize {\n             match lit.node {\n                 ast::LitKind::Str(ref s, _) => s.len(),\n                 _ => {\n-                    bcx.tcx().sess.span_bug(content_expr.span,\n-                                            \"unexpected evec content\")\n+                    span_bug!(content_expr.span, \"unexpected evec content\")\n                 }\n             }\n         },\n         hir::ExprVec(ref es) => es.len(),\n         hir::ExprRepeat(_, ref count_expr) => {\n             eval_repeat_count(bcx.tcx(), &count_expr)\n         }\n-        _ => bcx.tcx().sess.span_bug(content_expr.span,\n-                                     \"unexpected vec content\")\n+        _ => span_bug!(content_expr.span, \"unexpected vec content\")\n     }\n }\n \n@@ -298,8 +294,6 @@ pub fn get_base_and_len<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     llval: ValueRef,\n                                     vec_ty: Ty<'tcx>)\n                                     -> (ValueRef, ValueRef) {\n-    let ccx = bcx.ccx();\n-\n     match vec_ty.sty {\n         ty::TyArray(_, n) => get_fixed_base_and_len(bcx, llval, n),\n         ty::TySlice(_) | ty::TyStr => {\n@@ -317,7 +311,7 @@ pub fn get_base_and_len<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n             get_base_and_len(bcx, inner, ty)\n         },\n-        _ => ccx.sess().bug(\"unexpected type in get_base_and_len\"),\n+        _ => bug!(\"unexpected type in get_base_and_len\"),\n     }\n }\n "}, {"sha": "35a60cd5422b40ac0dcc5be1a1aa6876c0bbbb89", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -124,7 +124,7 @@ impl Type {\n         match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n             \"32\" => Type::i32(ccx),\n             \"64\" => Type::i64(ccx),\n-            tws => panic!(\"Unsupported target word size for int: {}\", tws),\n+            tws => bug!(\"Unsupported target word size for int: {}\", tws),\n         }\n     }\n \n@@ -288,7 +288,7 @@ impl Type {\n             Double => 64,\n             X86_FP80 => 80,\n             FP128 | PPC_FP128 => 128,\n-            _ => panic!(\"llvm_float_width called on a non-float type\")\n+            _ => bug!(\"llvm_float_width called on a non-float type\")\n         }\n     }\n "}, {"sha": "8b1aaafab58ed243de3f5b953ece999994595b50", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59ea491eae7d1fbfb0f73fe3579effdf9281b47/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=c59ea491eae7d1fbfb0f73fe3579effdf9281b47", "patch": "@@ -113,10 +113,9 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         }\n \n         ty::TyProjection(..) | ty::TyInfer(..) | ty::TyParam(..) | ty::TyError => {\n-            cx.sess().bug(&format!(\"fictitious type {:?} in sizing_type_of()\",\n-                                   t))\n+            bug!(\"fictitious type {:?} in sizing_type_of()\", t)\n         }\n-        ty::TySlice(_) | ty::TyTrait(..) | ty::TyStr => unreachable!()\n+        ty::TySlice(_) | ty::TyTrait(..) | ty::TyStr => bug!()\n     };\n \n     debug!(\"--> mapped t={:?} to llsizingty={:?}\", t, llsizingty);\n@@ -132,7 +131,7 @@ fn unsized_info_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type\n             Type::uint_from_ty(ccx, ast::UintTy::Us)\n         }\n         ty::TyTrait(_) => Type::vtable_ptr(ccx),\n-        _ => unreachable!(\"Unexpected tail in unsized_info_ty: {:?} for ty={:?}\",\n+        _ => bug!(\"Unexpected tail in unsized_info_ty: {:?} for ty={:?}\",\n                           unsized_part, ty)\n     }\n }\n@@ -296,10 +295,10 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           }\n       }\n \n-      ty::TyInfer(..) => cx.sess().bug(\"type_of with TyInfer\"),\n-      ty::TyProjection(..) => cx.sess().bug(\"type_of with TyProjection\"),\n-      ty::TyParam(..) => cx.sess().bug(\"type_of with ty_param\"),\n-      ty::TyError => cx.sess().bug(\"type_of with TyError\"),\n+      ty::TyInfer(..) => bug!(\"type_of with TyInfer\"),\n+      ty::TyProjection(..) => bug!(\"type_of with TyProjection\"),\n+      ty::TyParam(..) => bug!(\"type_of with ty_param\"),\n+      ty::TyError => bug!(\"type_of with TyError\"),\n     };\n \n     debug!(\"--> mapped t={:?} to llty={:?}\", t, llty);"}]}