{"sha": "4d6019d07a942f5041e3d81f974f34515b024d0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkNjAxOWQwN2E5NDJmNTA0MWUzZDgxZjk3NGYzNDUxNWIwMjRkMGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-15T22:02:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-15T22:02:36Z"}, "message": "Auto merge of #39457 - bvinc:master, r=alexcrichton\n\nDont segfault if btree range is not in order\n\nThis is a first attempt to fix issue #33197.  The issue is that the BTree iterator uses next_unchecked for fast iteration, but it can be tricked into running off the end of the tree and segfaulting if range is called with a maximum that is less than the minimum.\n\nSince a user defined Ord should not determine the safety of BTreeMap, and we still want fast iteration, I've implemented the idea of @gereeter and walk the tree simultaneously searching for both keys to make sure that if our keys diverge, the min key is to the left of our max key.  I currently panic if that is not the case.\n\nOpen questions:\n\n1.  Do we want to panic in this error case or do we want to return an empty iterator?  The drain API panics if the range is bad, but drain is given a range of index values, while this is a generic key type.  Panicking is brittle and returning an empty iterator is probably the most flexible and matches what people would want it to do... but artificially returning a BTreeMap::Range with start==end seems like a pretty weird and unnatural thing to do, although it's doable since those fields are not accessible.\n\nThe same question for other weird cases:\n2.  (Included(101), Excluded(100)) on a map that contains [1,2,3].  Both BTree edges end up on the same part of the map, but comparing the keys shows the range is backwards.\n3.  (Excluded(5), Excluded(5)).  The keys are equal but BTree edges end up backwards if the map contains 5.\n4.  (Included(5), Excluded(5)).  Should naturally produce an empty iterator, right?", "tree": {"sha": "58bff51025b45b8f6161c2b79d279928ae272f83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58bff51025b45b8f6161c2b79d279928ae272f83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d6019d07a942f5041e3d81f974f34515b024d0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d6019d07a942f5041e3d81f974f34515b024d0a", "html_url": "https://github.com/rust-lang/rust/commit/4d6019d07a942f5041e3d81f974f34515b024d0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d6019d07a942f5041e3d81f974f34515b024d0a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62eb6056d332be09206dc664f2e949ae64341e64", "url": "https://api.github.com/repos/rust-lang/rust/commits/62eb6056d332be09206dc664f2e949ae64341e64", "html_url": "https://github.com/rust-lang/rust/commit/62eb6056d332be09206dc664f2e949ae64341e64"}, {"sha": "fb9104768c0991b935e4b5cbc67180e49d425f2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb9104768c0991b935e4b5cbc67180e49d425f2c", "html_url": "https://github.com/rust-lang/rust/commit/fb9104768c0991b935e4b5cbc67180e49d425f2c"}], "stats": {"total": 249, "additions": 134, "deletions": 115}, "files": [{"sha": "7218d15ded5f802df0f7b19d926da531d4e8136b", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 91, "deletions": 113, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/4d6019d07a942f5041e3d81f974f34515b024d0a/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d6019d07a942f5041e3d81f974f34515b024d0a/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=4d6019d07a942f5041e3d81f974f34515b024d0a", "patch": "@@ -714,6 +714,11 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// `range((Excluded(4), Included(10)))` will yield a left-exclusive, right-inclusive\n     /// range from 4 to 10.\n     ///\n+    /// # Panics\n+    ///\n+    /// Panics if range `start > end`.\n+    /// Panics if range `start == end` and both bounds are `Excluded`.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -739,64 +744,11 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn range<T: ?Sized, R>(&self, range: R) -> Range<K, V>\n         where T: Ord, K: Borrow<T>, R: RangeArgument<T>\n     {\n-        let min = range.start();\n-        let max = range.end();\n-        let front = match min {\n-            Included(key) => {\n-                match search::search_tree(self.root.as_ref(), key) {\n-                    Found(kv_handle) => {\n-                        match kv_handle.left_edge().force() {\n-                            Leaf(bottom) => bottom,\n-                            Internal(internal) => last_leaf_edge(internal.descend()),\n-                        }\n-                    }\n-                    GoDown(bottom) => bottom,\n-                }\n-            }\n-            Excluded(key) => {\n-                match search::search_tree(self.root.as_ref(), key) {\n-                    Found(kv_handle) => {\n-                        match kv_handle.right_edge().force() {\n-                            Leaf(bottom) => bottom,\n-                            Internal(internal) => first_leaf_edge(internal.descend()),\n-                        }\n-                    }\n-                    GoDown(bottom) => bottom,\n-                }\n-            }\n-            Unbounded => first_leaf_edge(self.root.as_ref()),\n-        };\n+        let root1 = self.root.as_ref();\n+        let root2 = self.root.as_ref();\n+        let (f, b) = range_search(root1, root2, range);\n \n-        let back = match max {\n-            Included(key) => {\n-                match search::search_tree(self.root.as_ref(), key) {\n-                    Found(kv_handle) => {\n-                        match kv_handle.right_edge().force() {\n-                            Leaf(bottom) => bottom,\n-                            Internal(internal) => first_leaf_edge(internal.descend()),\n-                        }\n-                    }\n-                    GoDown(bottom) => bottom,\n-                }\n-            }\n-            Excluded(key) => {\n-                match search::search_tree(self.root.as_ref(), key) {\n-                    Found(kv_handle) => {\n-                        match kv_handle.left_edge().force() {\n-                            Leaf(bottom) => bottom,\n-                            Internal(internal) => last_leaf_edge(internal.descend()),\n-                        }\n-                    }\n-                    GoDown(bottom) => bottom,\n-                }\n-            }\n-            Unbounded => last_leaf_edge(self.root.as_ref()),\n-        };\n-\n-        Range {\n-            front: front,\n-            back: back,\n-        }\n+        Range { front: f, back: b}\n     }\n \n     /// Constructs a mutable double-ended iterator over a sub-range of elements in the map.\n@@ -806,6 +758,11 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// `range((Excluded(4), Included(10)))` will yield a left-exclusive, right-inclusive\n     /// range from 4 to 10.\n     ///\n+    /// # Panics\n+    ///\n+    /// Panics if range `start > end`.\n+    /// Panics if range `start == end` and both bounds are `Excluded`.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -831,66 +788,13 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn range_mut<T: ?Sized, R>(&mut self, range: R) -> RangeMut<K, V>\n         where T: Ord, K: Borrow<T>, R: RangeArgument<T>\n     {\n-        let min = range.start();\n-        let max = range.end();\n         let root1 = self.root.as_mut();\n         let root2 = unsafe { ptr::read(&root1) };\n-\n-        let front = match min {\n-            Included(key) => {\n-                match search::search_tree(root1, key) {\n-                    Found(kv_handle) => {\n-                        match kv_handle.left_edge().force() {\n-                            Leaf(bottom) => bottom,\n-                            Internal(internal) => last_leaf_edge(internal.descend()),\n-                        }\n-                    }\n-                    GoDown(bottom) => bottom,\n-                }\n-            }\n-            Excluded(key) => {\n-                match search::search_tree(root1, key) {\n-                    Found(kv_handle) => {\n-                        match kv_handle.right_edge().force() {\n-                            Leaf(bottom) => bottom,\n-                            Internal(internal) => first_leaf_edge(internal.descend()),\n-                        }\n-                    }\n-                    GoDown(bottom) => bottom,\n-                }\n-            }\n-            Unbounded => first_leaf_edge(root1),\n-        };\n-\n-        let back = match max {\n-            Included(key) => {\n-                match search::search_tree(root2, key) {\n-                    Found(kv_handle) => {\n-                        match kv_handle.right_edge().force() {\n-                            Leaf(bottom) => bottom,\n-                            Internal(internal) => first_leaf_edge(internal.descend()),\n-                        }\n-                    }\n-                    GoDown(bottom) => bottom,\n-                }\n-            }\n-            Excluded(key) => {\n-                match search::search_tree(root2, key) {\n-                    Found(kv_handle) => {\n-                        match kv_handle.left_edge().force() {\n-                            Leaf(bottom) => bottom,\n-                            Internal(internal) => last_leaf_edge(internal.descend()),\n-                        }\n-                    }\n-                    GoDown(bottom) => bottom,\n-                }\n-            }\n-            Unbounded => last_leaf_edge(root2),\n-        };\n+        let (f, b) = range_search(root1, root2, range);\n \n         RangeMut {\n-            front: front,\n-            back: back,\n+            front: f,\n+            back: b,\n             _marker: PhantomData,\n         }\n     }\n@@ -1827,6 +1731,80 @@ fn last_leaf_edge<BorrowType, K, V>\n     }\n }\n \n+fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeArgument<Q>>(\n+    root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+    root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+    range: R\n+)-> (Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+     Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>)\n+        where Q: Ord, K: Borrow<Q>\n+{\n+    match (range.start(), range.end()) {\n+        (Excluded(s), Excluded(e)) if s==e =>\n+            panic!(\"range start and end are equal and excluded in BTreeMap\"),\n+        (Included(s), Included(e)) |\n+        (Included(s), Excluded(e)) |\n+        (Excluded(s), Included(e)) |\n+        (Excluded(s), Excluded(e)) if s>e =>\n+            panic!(\"range start is greater than range end in BTreeMap\"),\n+        _ => {},\n+    };\n+\n+    let mut min_node = root1;\n+    let mut max_node = root2;\n+    let mut min_found = false;\n+    let mut max_found = false;\n+    let mut diverged = false;\n+\n+    loop {\n+        let min_edge = match (min_found, range.start()) {\n+            (false, Included(key)) => match search::search_linear(&min_node, key) {\n+                (i, true) => { min_found = true; i },\n+                (i, false) => i,\n+            },\n+            (false, Excluded(key)) => match search::search_linear(&min_node, key) {\n+                (i, true) => { min_found = true; i+1 },\n+                (i, false) => i,\n+            },\n+            (_, Unbounded) => 0,\n+            (true, Included(_)) => min_node.keys().len(),\n+            (true, Excluded(_)) => 0,\n+        };\n+\n+        let max_edge = match (max_found, range.end()) {\n+            (false, Included(key)) => match search::search_linear(&max_node, key) {\n+                (i, true) => { max_found = true; i+1 },\n+                (i, false) => i,\n+            },\n+            (false, Excluded(key)) => match search::search_linear(&max_node, key) {\n+                (i, true) => { max_found = true; i },\n+                (i, false) => i,\n+            },\n+            (_, Unbounded) => max_node.keys().len(),\n+            (true, Included(_)) => 0,\n+            (true, Excluded(_)) => max_node.keys().len(),\n+        };\n+\n+        if !diverged {\n+            if max_edge < min_edge { panic!(\"Ord is ill-defined in BTreeMap range\") }\n+            if min_edge != max_edge { diverged = true; }\n+        }\n+\n+        let front = Handle::new_edge(min_node, min_edge);\n+        let back = Handle::new_edge(max_node, max_edge);\n+        match (front.force(), back.force()) {\n+            (Leaf(f), Leaf(b)) => {\n+                return (f, b);\n+            },\n+            (Internal(min_int), Internal(max_int)) => {\n+                min_node = min_int.descend();\n+                max_node = max_int.descend();\n+            },\n+            _ => unreachable!(\"BTreeMap has different depths\"),\n+        };\n+    }\n+}\n+\n #[inline(always)]\n unsafe fn unwrap_unchecked<T>(val: Option<T>) -> T {\n     val.unwrap_or_else(|| {"}, {"sha": "bc1272fbc786e7aa4c2c9e39e24345c3a84f68a4", "filename": "src/libcollections/btree/search.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d6019d07a942f5041e3d81f974f34515b024d0a/src%2Flibcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d6019d07a942f5041e3d81f974f34515b024d0a/src%2Flibcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fsearch.rs?ref=4d6019d07a942f5041e3d81f974f34515b024d0a", "patch": "@@ -58,7 +58,7 @@ pub fn search_node<BorrowType, K, V, Type, Q: ?Sized>(\n     }\n }\n \n-fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n+pub fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n     node: &NodeRef<BorrowType, K, V, Type>,\n     key: &Q\n ) -> (usize, bool)\n@@ -73,4 +73,3 @@ fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n     }\n     (node.keys().len(), false)\n }\n-"}, {"sha": "f33923f99631911fc4752262235314528361a9b9", "filename": "src/libcollectionstest/btree/map.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4d6019d07a942f5041e3d81f974f34515b024d0a/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d6019d07a942f5041e3d81f974f34515b024d0a/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmap.rs?ref=4d6019d07a942f5041e3d81f974f34515b024d0a", "patch": "@@ -178,6 +178,48 @@ fn test_range_small() {\n     assert_eq!(j, size - 2);\n }\n \n+#[test]\n+fn test_range_equal_empty_cases() {\n+    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    assert_eq!(map.range((Included(2), Excluded(2))).next(), None);\n+    assert_eq!(map.range((Excluded(2), Included(2))).next(), None);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_range_equal_excluded() {\n+    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    map.range((Excluded(2), Excluded(2)));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_range_backwards_1() {\n+    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    map.range((Included(3), Included(2)));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_range_backwards_2() {\n+    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    map.range((Included(3), Excluded(2)));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_range_backwards_3() {\n+    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    map.range((Excluded(3), Included(2)));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_range_backwards_4() {\n+    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    map.range((Excluded(3), Excluded(2)));\n+}\n+\n #[test]\n fn test_range_1000() {\n     let size = 1000;"}]}