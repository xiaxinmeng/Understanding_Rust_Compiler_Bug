{"sha": "5d56e1daed3aab8149ecbf69baf5bc1785f08627", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNTZlMWRhZWQzYWFiODE0OWVjYmY2OWJhZjViYzE3ODVmMDg2Mjc=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2016-04-05T12:06:20Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2016-04-05T12:06:20Z"}, "message": "Specialize equality for [T] and comparison for [u8]\n\nWhere T is a type that can be compared for equality bytewise, we can use\nmemcmp. We can also use memcmp for PartialOrd, Ord for [u8] and by\nextension &str.\n\nThis is an improvement for example for the comparison [u8] == [u8] that\nused to emit a loop that compared the slices byte by byte.\n\nOne worry here could be that this introduces function calls to memcmp\nin contexts where it should really inline the comparison or even\noptimize it out, but llvm takes care of recognizing memcmp specifically.", "tree": {"sha": "2d86430d73b671e5b2ccd494278490130645cc6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d86430d73b671e5b2ccd494278490130645cc6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d56e1daed3aab8149ecbf69baf5bc1785f08627", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d56e1daed3aab8149ecbf69baf5bc1785f08627", "html_url": "https://github.com/rust-lang/rust/commit/5d56e1daed3aab8149ecbf69baf5bc1785f08627", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d56e1daed3aab8149ecbf69baf5bc1785f08627/comments", "author": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a09f386e8d1c31133f0ce1123fbeaedcff40a77d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a09f386e8d1c31133f0ce1123fbeaedcff40a77d", "html_url": "https://github.com/rust-lang/rust/commit/a09f386e8d1c31133f0ce1123fbeaedcff40a77d"}], "stats": {"total": 177, "additions": 139, "deletions": 38}, "files": [{"sha": "fa5e90562d80e1b28721b0b3baea998f569262ca", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d56e1daed3aab8149ecbf69baf5bc1785f08627/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d56e1daed3aab8149ecbf69baf5bc1785f08627/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=5d56e1daed3aab8149ecbf69baf5bc1785f08627", "patch": "@@ -75,6 +75,7 @@\n #![feature(unwind_attributes)]\n #![feature(repr_simd, platform_intrinsics)]\n #![feature(rustc_attrs)]\n+#![feature(specialization)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(question_mark)]"}, {"sha": "e9cf650af70726fcca65f3543efb533df95838cb", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 135, "deletions": 16, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/5d56e1daed3aab8149ecbf69baf5bc1785f08627/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d56e1daed3aab8149ecbf69baf5bc1785f08627/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=5d56e1daed3aab8149ecbf69baf5bc1785f08627", "patch": "@@ -1630,12 +1630,59 @@ pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] {\n }\n \n //\n-// Boilerplate traits\n+// Comparison traits\n //\n \n+extern {\n+    /// Call implementation provided memcmp\n+    ///\n+    /// Interprets the data as u8.\n+    ///\n+    /// Return 0 for equal, < 0 for less than and > 0 for greater\n+    /// than.\n+    // FIXME(#32610): Return type should be c_int\n+    fn memcmp(s1: *const u8, s2: *const u8, n: usize) -> i32;\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n     fn eq(&self, other: &[B]) -> bool {\n+        SlicePartialEq::equal(self, other)\n+    }\n+\n+    fn ne(&self, other: &[B]) -> bool {\n+        SlicePartialEq::not_equal(self, other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Eq> Eq for [T] {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Ord> Ord for [T] {\n+    fn cmp(&self, other: &[T]) -> Ordering {\n+        SliceOrd::compare(self, other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: PartialOrd> PartialOrd for [T] {\n+    fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {\n+        SlicePartialOrd::partial_compare(self, other)\n+    }\n+}\n+\n+// intermediate trait for specialization of slice's PartialEq\n+trait SlicePartialEq<B> {\n+    fn equal(&self, other: &[B]) -> bool;\n+    fn not_equal(&self, other: &[B]) -> bool;\n+}\n+\n+// Generic slice equality\n+impl<A, B> SlicePartialEq<B> for [A]\n+    where A: PartialEq<B>\n+{\n+    default fn equal(&self, other: &[B]) -> bool {\n         if self.len() != other.len() {\n             return false;\n         }\n@@ -1648,7 +1695,8 @@ impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n \n         true\n     }\n-    fn ne(&self, other: &[B]) -> bool {\n+\n+    default fn not_equal(&self, other: &[B]) -> bool {\n         if self.len() != other.len() {\n             return true;\n         }\n@@ -1663,12 +1711,35 @@ impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Eq> Eq for [T] {}\n+// Use memcmp for bytewise equality when the types allow\n+impl<A> SlicePartialEq<A> for [A]\n+    where A: PartialEq<A> + BytewiseEquality\n+{\n+    fn equal(&self, other: &[A]) -> bool {\n+        if self.len() != other.len() {\n+            return false;\n+        }\n+        unsafe {\n+            let size = mem::size_of_val(self);\n+            memcmp(self.as_ptr() as *const u8,\n+                   other.as_ptr() as *const u8, size) == 0\n+        }\n+    }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord> Ord for [T] {\n-    fn cmp(&self, other: &[T]) -> Ordering {\n+    fn not_equal(&self, other: &[A]) -> bool {\n+        !self.equal(other)\n+    }\n+}\n+\n+// intermediate trait for specialization of slice's PartialOrd\n+trait SlicePartialOrd<B> {\n+    fn partial_compare(&self, other: &[B]) -> Option<Ordering>;\n+}\n+\n+impl<A> SlicePartialOrd<A> for [A]\n+    where A: PartialOrd\n+{\n+    default fn partial_compare(&self, other: &[A]) -> Option<Ordering> {\n         let l = cmp::min(self.len(), other.len());\n \n         // Slice to the loop iteration range to enable bound check\n@@ -1677,19 +1748,32 @@ impl<T: Ord> Ord for [T] {\n         let rhs = &other[..l];\n \n         for i in 0..l {\n-            match lhs[i].cmp(&rhs[i]) {\n-                Ordering::Equal => (),\n+            match lhs[i].partial_cmp(&rhs[i]) {\n+                Some(Ordering::Equal) => (),\n                 non_eq => return non_eq,\n             }\n         }\n \n-        self.len().cmp(&other.len())\n+        self.len().partial_cmp(&other.len())\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: PartialOrd> PartialOrd for [T] {\n-    fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {\n+impl SlicePartialOrd<u8> for [u8] {\n+    #[inline]\n+    fn partial_compare(&self, other: &[u8]) -> Option<Ordering> {\n+        Some(SliceOrd::compare(self, other))\n+    }\n+}\n+\n+// intermediate trait for specialization of slice's Ord\n+trait SliceOrd<B> {\n+    fn compare(&self, other: &[B]) -> Ordering;\n+}\n+\n+impl<A> SliceOrd<A> for [A]\n+    where A: Ord\n+{\n+    default fn compare(&self, other: &[A]) -> Ordering {\n         let l = cmp::min(self.len(), other.len());\n \n         // Slice to the loop iteration range to enable bound check\n@@ -1698,12 +1782,47 @@ impl<T: PartialOrd> PartialOrd for [T] {\n         let rhs = &other[..l];\n \n         for i in 0..l {\n-            match lhs[i].partial_cmp(&rhs[i]) {\n-                Some(Ordering::Equal) => (),\n+            match lhs[i].cmp(&rhs[i]) {\n+                Ordering::Equal => (),\n                 non_eq => return non_eq,\n             }\n         }\n \n-        self.len().partial_cmp(&other.len())\n+        self.len().cmp(&other.len())\n+    }\n+}\n+\n+// memcmp compares a sequence of unsigned bytes lexicographically.\n+// this matches the order we want for [u8], but no others (not even [i8]).\n+impl SliceOrd<u8> for [u8] {\n+    #[inline]\n+    fn compare(&self, other: &[u8]) -> Ordering {\n+        let order = unsafe {\n+            memcmp(self.as_ptr(), other.as_ptr(),\n+                   cmp::min(self.len(), other.len()))\n+        };\n+        if order == 0 {\n+            self.len().cmp(&other.len())\n+        } else if order < 0 {\n+            Less\n+        } else {\n+            Greater\n+        }\n+    }\n+}\n+\n+/// Trait implemented for types that can be compared for equality using\n+/// their bytewise representation\n+trait BytewiseEquality { }\n+\n+macro_rules! impl_marker_for {\n+    ($traitname:ident, $($ty:ty)*) => {\n+        $(\n+            impl $traitname for $ty { }\n+        )*\n     }\n }\n+\n+impl_marker_for!(BytewiseEquality,\n+                 u8 i8 u16 i16 u32 i32 u64 i64 usize isize char bool);\n+"}, {"sha": "305546df5be2da171140dd5aaad372dae1ea6ba2", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5d56e1daed3aab8149ecbf69baf5bc1785f08627/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d56e1daed3aab8149ecbf69baf5bc1785f08627/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=5d56e1daed3aab8149ecbf69baf5bc1785f08627", "patch": "@@ -1150,16 +1150,7 @@ Section: Comparing strings\n #[lang = \"str_eq\"]\n #[inline]\n fn eq_slice(a: &str, b: &str) -> bool {\n-    a.len() == b.len() && unsafe { cmp_slice(a, b, a.len()) == 0 }\n-}\n-\n-/// Bytewise slice comparison.\n-/// NOTE: This uses the system's memcmp, which is currently dramatically\n-/// faster than comparing each byte in a loop.\n-#[inline]\n-unsafe fn cmp_slice(a: &str, b: &str, len: usize) -> i32 {\n-    extern { fn memcmp(s1: *const i8, s2: *const i8, n: usize) -> i32; }\n-    memcmp(a.as_ptr() as *const i8, b.as_ptr() as *const i8, len)\n+    a.as_bytes() == b.as_bytes()\n }\n \n /*\n@@ -1328,8 +1319,7 @@ Section: Trait implementations\n */\n \n mod traits {\n-    use cmp::{self, Ordering, Ord, PartialEq, PartialOrd, Eq};\n-    use cmp::Ordering::{Less, Greater};\n+    use cmp::{Ord, Ordering, PartialEq, PartialOrd, Eq};\n     use iter::Iterator;\n     use option::Option;\n     use option::Option::Some;\n@@ -1340,16 +1330,7 @@ mod traits {\n     impl Ord for str {\n         #[inline]\n         fn cmp(&self, other: &str) -> Ordering {\n-            let cmp = unsafe {\n-                super::cmp_slice(self, other, cmp::min(self.len(), other.len()))\n-            };\n-            if cmp == 0 {\n-                self.len().cmp(&other.len())\n-            } else if cmp < 0 {\n-                Less\n-            } else {\n-                Greater\n-            }\n+            self.as_bytes().cmp(other.as_bytes())\n         }\n     }\n "}]}