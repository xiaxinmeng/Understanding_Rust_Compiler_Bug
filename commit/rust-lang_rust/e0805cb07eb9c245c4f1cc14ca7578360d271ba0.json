{"sha": "e0805cb07eb9c245c4f1cc14ca7578360d271ba0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwODA1Y2IwN2ViOWMyNDVjNGYxY2MxNGNhNzU3ODM2MGQyNzFiYTA=", "commit": {"author": {"name": "Jesse Jones", "email": "jesse9jones@gmail.com", "date": "2012-11-17T17:57:14Z"}, "committer": {"name": "Jesse Jones", "email": "jesse9jones@gmail.com", "date": "2012-11-17T17:57:14Z"}, "message": "Made most of the URL functions pure.\n\nThis closes #3782.", "tree": {"sha": "23e6356ffc6c3ea854936d0937b652cd1e64211f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23e6356ffc6c3ea854936d0937b652cd1e64211f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0805cb07eb9c245c4f1cc14ca7578360d271ba0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0805cb07eb9c245c4f1cc14ca7578360d271ba0", "html_url": "https://github.com/rust-lang/rust/commit/e0805cb07eb9c245c4f1cc14ca7578360d271ba0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0805cb07eb9c245c4f1cc14ca7578360d271ba0/comments", "author": {"login": "jesse99", "id": 425055, "node_id": "MDQ6VXNlcjQyNTA1NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/425055?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jesse99", "html_url": "https://github.com/jesse99", "followers_url": "https://api.github.com/users/jesse99/followers", "following_url": "https://api.github.com/users/jesse99/following{/other_user}", "gists_url": "https://api.github.com/users/jesse99/gists{/gist_id}", "starred_url": "https://api.github.com/users/jesse99/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jesse99/subscriptions", "organizations_url": "https://api.github.com/users/jesse99/orgs", "repos_url": "https://api.github.com/users/jesse99/repos", "events_url": "https://api.github.com/users/jesse99/events{/privacy}", "received_events_url": "https://api.github.com/users/jesse99/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jesse99", "id": 425055, "node_id": "MDQ6VXNlcjQyNTA1NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/425055?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jesse99", "html_url": "https://github.com/jesse99", "followers_url": "https://api.github.com/users/jesse99/followers", "following_url": "https://api.github.com/users/jesse99/following{/other_user}", "gists_url": "https://api.github.com/users/jesse99/gists{/gist_id}", "starred_url": "https://api.github.com/users/jesse99/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jesse99/subscriptions", "organizations_url": "https://api.github.com/users/jesse99/orgs", "repos_url": "https://api.github.com/users/jesse99/repos", "events_url": "https://api.github.com/users/jesse99/events{/privacy}", "received_events_url": "https://api.github.com/users/jesse99/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3f845db521aca3d8b8815a0c969a40446390757", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3f845db521aca3d8b8815a0c969a40446390757", "html_url": "https://github.com/rust-lang/rust/commit/a3f845db521aca3d8b8815a0c969a40446390757"}], "stats": {"total": 74, "additions": 40, "deletions": 34}, "files": [{"sha": "dd76f65a046bc06cbd8281027ba08858e4264e87", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 40, "deletions": 34, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/e0805cb07eb9c245c4f1cc14ca7578360d271ba0/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0805cb07eb9c245c4f1cc14ca7578360d271ba0/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=e0805cb07eb9c245c4f1cc14ca7578360d271ba0", "patch": "@@ -27,15 +27,15 @@ type UserInfo = {\n \n pub type Query = ~[(~str, ~str)];\n \n-pub fn Url(scheme: ~str, user: Option<UserInfo>, host: ~str,\n+pub pure fn Url(scheme: ~str, user: Option<UserInfo>, host: ~str,\n        port: Option<~str>, path: ~str, query: Query,\n        fragment: Option<~str>) -> Url {\n     Url { scheme: move scheme, user: move user, host: move host,\n          port: move port, path: move path, query: move query,\n          fragment: move fragment }\n }\n \n-fn UserInfo(user: ~str, pass: Option<~str>) -> UserInfo {\n+pure fn UserInfo(user: ~str, pass: Option<~str>) -> UserInfo {\n     {user: move user, pass: move pass}\n }\n \n@@ -84,8 +84,9 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n  *\n  * This function is compliant with RFC 3986.\n  */\n-pub fn encode(s: &str) -> ~str {\n-    encode_inner(s, true)\n+pub pure fn encode(s: &str) -> ~str {\n+    // unsafe only because encode_inner does (string) IO\n+    unsafe {encode_inner(s, true)}\n }\n \n /**\n@@ -95,8 +96,9 @@ pub fn encode(s: &str) -> ~str {\n  * This function is compliant with RFC 3986.\n  */\n \n-pub fn encode_component(s: &str) -> ~str {\n-    encode_inner(s, false)\n+pub pure fn encode_component(s: &str) -> ~str {\n+    // unsafe only because encode_inner does (string) IO\n+    unsafe {encode_inner(s, false)}\n }\n \n fn decode_inner(s: &str, full_url: bool) -> ~str {\n@@ -142,15 +144,17 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n  *\n  * This will only decode escape sequences generated by encode_uri.\n  */\n-pub fn decode(s: &str) -> ~str {\n-    decode_inner(s, true)\n+pub pure fn decode(s: &str) -> ~str {\n+    // unsafe only because decode_inner does (string) IO\n+    unsafe {decode_inner(s, true)}\n }\n \n /**\n  * Decode a string encoded with percent encoding.\n  */\n-pub fn decode_component(s: &str) -> ~str {\n-    decode_inner(s, false)\n+pub pure fn decode_component(s: &str) -> ~str {\n+    // unsafe only because decode_inner does (string) IO\n+    unsafe {decode_inner(s, false)}\n }\n \n fn encode_plus(s: &str) -> ~str {\n@@ -264,19 +268,21 @@ pub fn decode_form_urlencoded(s: ~[u8]) ->\n }\n \n \n-fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n+pure fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n     let len = str::len(s);\n     let mut index = len;\n     let mut mat = 0;\n-    do io::with_str_reader(s) |rdr| {\n-        let mut ch : char;\n-        while !rdr.eof() {\n-            ch = rdr.read_byte() as char;\n-            if ch == c {\n-                // found a match, adjust markers\n-                index = rdr.tell()-1;\n-                mat = 1;\n-                break;\n+    unsafe {\n+        do io::with_str_reader(s) |rdr| {\n+            let mut ch : char;\n+            while !rdr.eof() {\n+                ch = rdr.read_byte() as char;\n+                if ch == c {\n+                    // found a match, adjust markers\n+                    index = rdr.tell()-1;\n+                    mat = 1;\n+                    break;\n+                }\n             }\n         }\n     }\n@@ -288,7 +294,7 @@ fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n     }\n }\n \n-fn userinfo_from_str(uinfo: &str) -> UserInfo {\n+pure fn userinfo_from_str(uinfo: &str) -> UserInfo {\n     let (user, p) = split_char_first(uinfo, ':');\n     let pass = if str::len(p) == 0 {\n         option::None\n@@ -315,12 +321,12 @@ impl UserInfo : Eq {\n     pure fn ne(other: &UserInfo) -> bool { !self.eq(other) }\n }\n \n-fn query_from_str(rawquery: &str) -> Query {\n+pure fn query_from_str(rawquery: &str) -> Query {\n     let mut query: Query = ~[];\n     if str::len(rawquery) != 0 {\n         for str::split_char(rawquery, '&').each |p| {\n             let (k, v) = split_char_first(*p, '=');\n-            query.push((decode_component(k), decode_component(v)));\n+            unsafe {query.push((decode_component(k), decode_component(v)));}\n         };\n     }\n     return query;\n@@ -340,7 +346,7 @@ pub pure fn query_to_str(query: Query) -> ~str {\n }\n \n // returns the scheme and the rest of the url, or a parsing error\n-pub fn get_scheme(rawurl: &str) -> result::Result<(~str, ~str), @~str> {\n+pub pure fn get_scheme(rawurl: &str) -> result::Result<(~str, ~str), @~str> {\n     for str::each_chari(rawurl) |i,c| {\n         match c {\n           'A' .. 'Z' | 'a' .. 'z' => loop,\n@@ -387,7 +393,7 @@ impl Input : Eq {\n }\n \n // returns userinfo, host, port, and unparsed part, or an error\n-fn get_authority(rawurl: &str) ->\n+pure fn get_authority(rawurl: &str) ->\n     result::Result<(Option<UserInfo>, ~str, Option<~str>, ~str), @~str> {\n     if !str::starts_with(rawurl, ~\"//\") {\n         // there is no authority.\n@@ -517,7 +523,7 @@ fn get_authority(rawurl: &str) ->\n \n     let end = end; // make end immutable so it can be captured\n \n-    let host_is_end_plus_one: &fn() -> bool = || {\n+    let host_is_end_plus_one: &pure fn() -> bool = || {\n         end+1 == len\n             && !['?', '#', '/'].contains(&(rawurl[end] as char))\n     };\n@@ -556,7 +562,7 @@ fn get_authority(rawurl: &str) ->\n \n \n // returns the path and unparsed part of url, or an error\n-fn get_path(rawurl: &str, authority : bool) ->\n+pure fn get_path(rawurl: &str, authority : bool) ->\n     result::Result<(~str, ~str), @~str> {\n     let len = str::len(rawurl);\n     let mut end = len;\n@@ -587,7 +593,7 @@ fn get_path(rawurl: &str, authority : bool) ->\n }\n \n // returns the parsed query and the fragment, if present\n-fn get_query_fragment(rawurl: &str) ->\n+pure fn get_query_fragment(rawurl: &str) ->\n     result::Result<(Query, Option<~str>), @~str> {\n     if !str::starts_with(rawurl, ~\"?\") {\n         if str::starts_with(rawurl, ~\"#\") {\n@@ -619,42 +625,42 @@ fn get_query_fragment(rawurl: &str) ->\n  *\n  */\n \n-pub fn from_str(rawurl: &str) -> result::Result<Url, ~str> {\n+pub pure fn from_str(rawurl: &str) -> result::Result<Url, ~str> {\n     // scheme\n     let mut schm = get_scheme(rawurl);\n     if result::is_err(&schm) {\n         return result::Err(copy *result::get_err(&schm));\n     }\n-    let (scheme, rest) = result::unwrap(schm);\n+    let (scheme, rest) = schm.get();\n \n     // authority\n     let mut auth = get_authority(rest);\n     if result::is_err(&auth) {\n         return result::Err(copy *result::get_err(&auth));\n     }\n-    let (userinfo, host, port, rest) = result::unwrap(auth);\n+    let (userinfo, host, port, rest) = auth.get();\n \n     // path\n     let has_authority = if host == ~\"\" { false } else { true };\n     let mut pth = get_path(rest, has_authority);\n     if result::is_err(&pth) {\n         return result::Err(copy *result::get_err(&pth));\n     }\n-    let (path, rest) = result::unwrap(pth);\n+    let (path, rest) = pth.get();\n \n     // query and fragment\n     let mut qry = get_query_fragment(rest);\n     if result::is_err(&qry) {\n         return result::Err(copy *result::get_err(&qry));\n     }\n-    let (query, fragment) = result::unwrap(qry);\n+    let (query, fragment) = qry.get();\n \n     return result::Ok(Url(scheme, userinfo, host,\n                        port, path, query, fragment));\n }\n \n impl Url : FromStr {\n-    static fn from_str(s: &str) -> Option<Url> {\n+    static pure fn from_str(s: &str) -> Option<Url> {\n         match from_str(s) {\n             Ok(move url) => Some(url),\n             Err(_) => None"}]}