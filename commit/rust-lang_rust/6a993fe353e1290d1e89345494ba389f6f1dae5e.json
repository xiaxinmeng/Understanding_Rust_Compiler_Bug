{"sha": "6a993fe353e1290d1e89345494ba389f6f1dae5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhOTkzZmUzNTNlMTI5MGQxZTg5MzQ1NDk0YmEzODlmNmYxZGFlNWU=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-09-20T13:47:22Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:33:10Z"}, "message": "Generalized mir::codegen_mir (and all subsequent functions)", "tree": {"sha": "c57d28d4569abb1c369b055e063d96096fe97eda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c57d28d4569abb1c369b055e063d96096fe97eda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a993fe353e1290d1e89345494ba389f6f1dae5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a993fe353e1290d1e89345494ba389f6f1dae5e", "html_url": "https://github.com/rust-lang/rust/commit/6a993fe353e1290d1e89345494ba389f6f1dae5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a993fe353e1290d1e89345494ba389f6f1dae5e/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3", "html_url": "https://github.com/rust-lang/rust/commit/cbe31a4229c519d7af7b5d86f9295fd23adb8cd3"}], "stats": {"total": 3082, "additions": 1735, "deletions": 1347}, "files": [{"sha": "4c2ff2db8adad75122826186ac077265828810f4", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -16,11 +16,12 @@ use mir::operand::OperandValue;\n use type_::Type;\n use type_of::{LayoutLlvmExt, PointerKind};\n use value::Value;\n+use rustc_target::abi::call::ArgType;\n \n-use interfaces::{BuilderMethods, ConstMethods, BaseTypeMethods, DerivedTypeMethods};\n+use interfaces::*;\n \n use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TyLayout, Abi as LayoutAbi};\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, Ty, Instance};\n use rustc::ty::layout;\n \n use libc::c_uint;\n@@ -280,6 +281,27 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n     }\n }\n \n+impl ArgTypeMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+    fn store_fn_arg(\n+        &self,\n+        ty: &ArgType<'tcx, Ty<'tcx>>,\n+        idx: &mut usize, dst: PlaceRef<'tcx, Self::Value>\n+    ) {\n+        ty.store_fn_arg(self, idx, dst)\n+    }\n+    fn store_arg_ty(\n+        &self,\n+        ty: &ArgType<'tcx, Ty<'tcx>>,\n+        val: &'ll Value,\n+        dst: PlaceRef<'tcx, &'ll Value>\n+    ) {\n+        ty.store(self, val, dst)\n+    }\n+    fn memory_ty(&self, ty: &ArgType<'tcx, Ty<'tcx>>) -> &'ll Type {\n+        ty.memory_ty(self.cx())\n+    }\n+}\n+\n pub trait FnTypeExt<'tcx> {\n     fn of_instance(cx: &CodegenCx<'ll, 'tcx>, instance: &ty::Instance<'tcx>) -> Self;\n     fn new(cx: &CodegenCx<'ll, 'tcx>,\n@@ -790,3 +812,29 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n         }\n     }\n }\n+\n+impl AbiMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+    fn new_fn_type(&self, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> FnType<'tcx, Ty<'tcx>> {\n+        FnType::new(&self, sig, extra_args)\n+    }\n+    fn new_vtable(\n+        &self,\n+        sig: ty::FnSig<'tcx>,\n+        extra_args: &[Ty<'tcx>]\n+    ) -> FnType<'tcx, Ty<'tcx>> {\n+        FnType::new_vtable(&self, sig, extra_args)\n+    }\n+    fn fn_type_of_instance(&self, instance: &Instance<'tcx>) -> FnType<'tcx, Ty<'tcx>> {\n+        FnType::of_instance(&self, instance)\n+    }\n+}\n+\n+impl AbiBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+    fn apply_attrs_callsite(\n+        &self,\n+        ty: &FnType<'tcx, Ty<'tcx>>,\n+        callsite: Self::Value\n+    ) {\n+        ty.apply_attrs_callsite(self, callsite)\n+    }\n+}"}, {"sha": "d6699548c91e5032298b7813be00398ddd85e289", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 96, "deletions": 92, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -15,114 +15,118 @@ use builder::Builder;\n use value::Value;\n \n use rustc::hir;\n-use interfaces::{BuilderMethods, ConstMethods, BaseTypeMethods};\n+use interfaces::*;\n \n use mir::place::PlaceRef;\n use mir::operand::OperandValue;\n \n use std::ffi::CString;\n use libc::{c_uint, c_char};\n \n-// Take an inline assembly expression and splat it out via LLVM\n-pub fn codegen_inline_asm(\n-    bx: &Builder<'a, 'll, 'tcx>,\n-    ia: &hir::InlineAsm,\n-    outputs: Vec<PlaceRef<'tcx, &'ll Value>>,\n-    mut inputs: Vec<&'ll Value>\n-) -> bool {\n-    let mut ext_constraints = vec![];\n-    let mut output_types = vec![];\n-\n-    // Prepare the output operands\n-    let mut indirect_outputs = vec![];\n-    for (i, (out, &place)) in ia.outputs.iter().zip(&outputs).enumerate() {\n-        if out.is_rw {\n-            inputs.push(bx.load_operand(place).immediate());\n-            ext_constraints.push(i.to_string());\n+\n+impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+    // Take an inline assembly expression and splat it out via LLVM\n+    fn codegen_inline_asm(\n+        &self,\n+        ia: &hir::InlineAsm,\n+        outputs: Vec<PlaceRef<'tcx, &'ll Value>>,\n+        mut inputs: Vec<&'ll Value>\n+    ) -> bool {\n+        let mut ext_constraints = vec![];\n+        let mut output_types = vec![];\n+\n+        // Prepare the output operands\n+        let mut indirect_outputs = vec![];\n+        for (i, (out, &place)) in ia.outputs.iter().zip(&outputs).enumerate() {\n+            if out.is_rw {\n+                inputs.push(self.load_operand(place).immediate());\n+                ext_constraints.push(i.to_string());\n+            }\n+            if out.is_indirect {\n+                indirect_outputs.push(self.load_operand(place).immediate());\n+            } else {\n+                output_types.push(place.layout.llvm_type(self.cx()));\n+            }\n         }\n-        if out.is_indirect {\n-            indirect_outputs.push(bx.load_operand(place).immediate());\n-        } else {\n-            output_types.push(place.layout.llvm_type(bx.cx()));\n+        if !indirect_outputs.is_empty() {\n+            indirect_outputs.extend_from_slice(&inputs);\n+            inputs = indirect_outputs;\n         }\n-    }\n-    if !indirect_outputs.is_empty() {\n-        indirect_outputs.extend_from_slice(&inputs);\n-        inputs = indirect_outputs;\n-    }\n \n-    let clobbers = ia.clobbers.iter()\n-                              .map(|s| format!(\"~{{{}}}\", &s));\n-\n-    // Default per-arch clobbers\n-    // Basically what clang does\n-    let arch_clobbers = match &bx.sess().target.target.arch[..] {\n-        \"x86\" | \"x86_64\"  => vec![\"~{dirflag}\", \"~{fpsr}\", \"~{flags}\"],\n-        \"mips\" | \"mips64\" => vec![\"~{$1}\"],\n-        _                 => Vec::new()\n-    };\n-\n-    let all_constraints =\n-        ia.outputs.iter().map(|out| out.constraint.to_string())\n-          .chain(ia.inputs.iter().map(|s| s.to_string()))\n-          .chain(ext_constraints)\n-          .chain(clobbers)\n-          .chain(arch_clobbers.iter().map(|s| s.to_string()))\n-          .collect::<Vec<String>>().join(\",\");\n-\n-    debug!(\"Asm Constraints: {}\", &all_constraints);\n-\n-    // Depending on how many outputs we have, the return type is different\n-    let num_outputs = output_types.len();\n-    let output_type = match num_outputs {\n-        0 => bx.cx().type_void(),\n-        1 => output_types[0],\n-        _ => bx.cx().type_struct(&output_types, false)\n-    };\n-\n-    let asm = CString::new(ia.asm.as_str().as_bytes()).unwrap();\n-    let constraint_cstr = CString::new(all_constraints).unwrap();\n-    let r = bx.inline_asm_call(\n-        asm.as_ptr(),\n-        constraint_cstr.as_ptr(),\n-        &inputs,\n-        output_type,\n-        ia.volatile,\n-        ia.alignstack,\n-        ia.dialect\n-    );\n-    if r.is_none() {\n-        return false;\n-    }\n-    let r = r.unwrap();\n+        let clobbers = ia.clobbers.iter()\n+                                  .map(|s| format!(\"~{{{}}}\", &s));\n+\n+        // Default per-arch clobbers\n+        // Basically what clang does\n+        let arch_clobbers = match &self.cx().sess().target.target.arch[..] {\n+            \"x86\" | \"x86_64\"  => vec![\"~{dirflag}\", \"~{fpsr}\", \"~{flags}\"],\n+            \"mips\" | \"mips64\" => vec![\"~{$1}\"],\n+            _                 => Vec::new()\n+        };\n+\n+        let all_constraints =\n+            ia.outputs.iter().map(|out| out.constraint.to_string())\n+              .chain(ia.inputs.iter().map(|s| s.to_string()))\n+              .chain(ext_constraints)\n+              .chain(clobbers)\n+              .chain(arch_clobbers.iter().map(|s| s.to_string()))\n+              .collect::<Vec<String>>().join(\",\");\n+\n+        debug!(\"Asm Constraints: {}\", &all_constraints);\n+\n+        // Depending on how many outputs we have, the return type is different\n+        let num_outputs = output_types.len();\n+        let output_type = match num_outputs {\n+            0 => self.cx().type_void(),\n+            1 => output_types[0],\n+            _ => self.cx().type_struct(&output_types, false)\n+        };\n+\n+        let asm = CString::new(ia.asm.as_str().as_bytes()).unwrap();\n+        let constraint_cstr = CString::new(all_constraints).unwrap();\n+        let r = self.inline_asm_call(\n+            asm.as_ptr(),\n+            constraint_cstr.as_ptr(),\n+            &inputs,\n+            output_type,\n+            ia.volatile,\n+            ia.alignstack,\n+            ia.dialect\n+        );\n+        if r.is_none() {\n+            return false;\n+        }\n+        let r = r.unwrap();\n \n-    // Again, based on how many outputs we have\n-    let outputs = ia.outputs.iter().zip(&outputs).filter(|&(ref o, _)| !o.is_indirect);\n-    for (i, (_, &place)) in outputs.enumerate() {\n-        let v = if num_outputs == 1 { r } else { bx.extract_value(r, i as u64) };\n-        OperandValue::Immediate(v).store(bx, place);\n-    }\n+        // Again, based on how many outputs we have\n+        let outputs = ia.outputs.iter().zip(&outputs).filter(|&(ref o, _)| !o.is_indirect);\n+        for (i, (_, &place)) in outputs.enumerate() {\n+            let v = if num_outputs == 1 { r } else { self.extract_value(r, i as u64) };\n+            OperandValue::Immediate(v).store(self, place);\n+        }\n \n-    // Store mark in a metadata node so we can map LLVM errors\n-    // back to source locations.  See #17552.\n-    unsafe {\n-        let key = \"srcloc\";\n-        let kind = llvm::LLVMGetMDKindIDInContext(bx.cx().llcx,\n-            key.as_ptr() as *const c_char, key.len() as c_uint);\n+        // Store mark in a metadata node so we can map LLVM errors\n+        // back to source locations.  See #17552.\n+        unsafe {\n+            let key = \"srcloc\";\n+            let kind = llvm::LLVMGetMDKindIDInContext(self.cx().llcx,\n+                key.as_ptr() as *const c_char, key.len() as c_uint);\n \n-        let val: &'ll Value = bx.cx().const_i32(ia.ctxt.outer().as_u32() as i32);\n+            let val: &'ll Value = self.cx().const_i32(ia.ctxt.outer().as_u32() as i32);\n \n-        llvm::LLVMSetMetadata(r, kind,\n-            llvm::LLVMMDNodeInContext(bx.cx().llcx, &val, 1));\n-    }\n+            llvm::LLVMSetMetadata(r, kind,\n+                llvm::LLVMMDNodeInContext(self.cx().llcx, &val, 1));\n+        }\n \n-    return true;\n+        true\n+    }\n }\n \n-pub fn codegen_global_asm<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                  ga: &hir::GlobalAsm) {\n-    let asm = CString::new(ga.asm.as_str().as_bytes()).unwrap();\n-    unsafe {\n-        llvm::LLVMRustAppendModuleInlineAsm(cx.llmod, asm.as_ptr());\n+impl AsmMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+    fn codegen_global_asm(&self, ga: &hir::GlobalAsm) {\n+        let asm = CString::new(ga.asm.as_str().as_bytes()).unwrap();\n+        unsafe {\n+            llvm::LLVMRustAppendModuleInlineAsm(self.llmod, asm.as_ptr());\n+        }\n     }\n }"}, {"sha": "7570d22c4dfca84a2e8a0b32449a44f8dcf0e3eb", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -21,6 +21,7 @@ use rustc::ty::query::Providers;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_target::spec::PanicStrategy;\n+use interfaces::*;\n \n use attributes;\n use llvm::{self, Attribute};"}, {"sha": "c58e548f69ddd69f778d0148c0bd6e35fdab88ce", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -57,7 +57,6 @@ use rustc_mir::monomorphize::item::DefPathBasedNames;\n use common::{self, IntPredicate, RealPredicate, TypeKind};\n use context::CodegenCx;\n use debuginfo;\n-use declare;\n use meth;\n use mir;\n use monomorphize::Instance;\n@@ -392,15 +391,18 @@ pub fn wants_msvc_seh(sess: &Session) -> bool {\n     sess.target.target.options.is_like_msvc\n }\n \n-pub fn call_assume(bx: &Builder<'_, 'll, '_>, val: &'ll Value) {\n+pub fn call_assume<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    val: Bx::Value\n+) {\n     let assume_intrinsic = bx.cx().get_intrinsic(\"llvm.assume\");\n     bx.call(assume_intrinsic, &[val], None);\n }\n \n-pub fn from_immediate<'a, 'tcx: 'a, Builder: BuilderMethods<'a, 'tcx>>(\n-    bx: &Builder,\n-    val: Builder::Value\n-) -> Builder::Value {\n+pub fn from_immediate<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    val: Bx::Value\n+) -> Bx::Value {\n     if bx.cx().val_ty(val) == bx.cx().type_i1() {\n         bx.zext(val, bx.cx().type_i8())\n     } else {\n@@ -447,7 +449,7 @@ pub fn memcpy_ty<'a, 'tcx: 'a, Builder: BuilderMethods<'a, 'tcx>>(\n     bx.memcpy(dst, dst_align, src, src_align, bx.cx().const_usize(size), flags);\n }\n \n-pub fn codegen_instance<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, instance: Instance<'tcx>) {\n+pub fn codegen_instance(cx: &CodegenCx<'_, 'tcx>, instance: Instance<'tcx>) {\n     let _s = if cx.sess().codegen_stats() {\n         let mut instance_name = String::new();\n         DefPathBasedNames::new(cx.tcx, true, true)\n@@ -471,7 +473,7 @@ pub fn codegen_instance<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, instance: Instance<'\n     cx.stats.borrow_mut().n_closures += 1;\n \n     let mir = cx.tcx.instance_mir(instance.def);\n-    mir::codegen_mir(cx, lldecl, &mir, instance, sig);\n+    mir::codegen_mir::<Builder>(cx, lldecl, &mir, instance, sig);\n }\n \n pub fn set_link_section(llval: &Value, attrs: &CodegenFnAttrs) {\n@@ -532,15 +534,15 @@ fn maybe_create_entry_wrapper(cx: &CodegenCx) {\n             &main_ret_ty.no_bound_vars().unwrap(),\n         );\n \n-        if declare::get_defined_value(cx, \"main\").is_some() {\n+        if cx.get_defined_value(\"main\").is_some() {\n             // FIXME: We should be smart and show a better diagnostic here.\n             cx.sess().struct_span_err(sp, \"entry symbol `main` defined multiple times\")\n                      .help(\"did you use #[no_mangle] on `fn main`? Use #[start] instead\")\n                      .emit();\n             cx.sess().abort_if_errors();\n             bug!();\n         }\n-        let llfn = declare::declare_cfn(cx, \"main\", llfty);\n+        let llfn = cx.declare_cfn(\"main\", llfty);\n \n         // `main` should respect same config for frame pointer elimination as rest of code\n         attributes::set_frame_pointer_elimination(cx, llfn);"}, {"sha": "9c7e7951de88231926bb063cd7d3db667b29792d", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -18,7 +18,7 @@ use value::Value;\n use libc::{c_uint, c_char};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, Size, TyLayout};\n-use rustc::session::{config, Session};\n+use rustc::session::config;\n use rustc_data_structures::small_c_str::SmallCStr;\n use interfaces::*;\n use syntax;\n@@ -59,11 +59,13 @@ bitflags! {\n     }\n }\n \n-impl BackendTypes for Builder<'_, 'll, '_> {\n-    type Value = &'ll Value;\n-    type BasicBlock = &'ll BasicBlock;\n-    type Type = &'ll Type;\n-    type Context = &'ll llvm::Context;\n+impl BackendTypes for Builder<'_, 'll, 'tcx> {\n+    type Value = <CodegenCx<'ll, 'tcx> as BackendTypes>::Value;\n+    type BasicBlock = <CodegenCx<'ll, 'tcx> as BackendTypes>::BasicBlock;\n+    type Type = <CodegenCx<'ll, 'tcx> as BackendTypes>::Type;\n+    type Context = <CodegenCx<'ll, 'tcx> as BackendTypes>::Context;\n+\n+    type DIScope = <CodegenCx<'ll, 'tcx> as BackendTypes>::DIScope;\n }\n \n impl ty::layout::HasDataLayout for Builder<'_, '_, '_> {\n@@ -126,10 +128,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         Builder::new_block(self.cx, self.llfn(), name)\n     }\n \n-    fn sess(&self) -> &Session {\n-        self.cx.sess()\n-    }\n-\n     fn llfn(&self) -> &'ll Value {\n         unsafe {\n             llvm::LLVMGetBasicBlockParent(self.llbb())\n@@ -223,14 +221,15 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                   args: &[&'ll Value],\n                   then: &'ll BasicBlock,\n                   catch: &'ll BasicBlock,\n-                  bundle: Option<&common::OperandBundleDef<&'ll Value>>) -> &'ll Value {\n+                  funclet: Option<&common::Funclet<&'ll Value>>) -> &'ll Value {\n         self.count_insn(\"invoke\");\n \n         debug!(\"Invoke {:?} with args ({:?})\",\n                llfn,\n                args);\n \n         let args = self.check_call(\"invoke\", llfn, args);\n+        let bundle = funclet.map(|funclet| funclet.bundle());\n         let bundle = bundle.map(OperandBundleDef::from_generic);\n         let bundle = bundle.as_ref().map(|b| &*b.raw);\n \n@@ -610,7 +609,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n \n     fn range_metadata(&self, load: &'ll Value, range: Range<u128>) {\n-        if self.sess().target.target.arch == \"amdgpu\" {\n+        if self.cx().sess().target.target.arch == \"amdgpu\" {\n             // amdgpu/LLVM does something weird and thinks a i64 value is\n             // split into a v2i32, halving the bitwidth LLVM expects,\n             // tripping an assertion. So, for now, just disable this\n@@ -920,7 +919,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         align: Align,\n         flags: MemFlags,\n     ) {\n-        let ptr_width = &self.sess().target.target.target_pointer_width;\n+        let ptr_width = &self.cx().sess().target.target.target_pointer_width;\n         let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n         let llintrinsicfn = self.cx().get_intrinsic(&intrinsic_key);\n         let ptr = self.pointercast(ptr, self.cx().type_i8p());\n@@ -1362,14 +1361,15 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn call(&self, llfn: &'ll Value, args: &[&'ll Value],\n-                bundle: Option<&common::OperandBundleDef<&'ll Value>>) -> &'ll Value {\n+                funclet: Option<&common::Funclet<&'ll Value>>) -> &'ll Value {\n         self.count_insn(\"call\");\n \n         debug!(\"Call {:?} with args ({:?})\",\n                llfn,\n                args);\n \n         let args = self.check_call(\"call\", llfn, args);\n+        let bundle = funclet.map(|funclet| funclet.bundle());\n         let bundle = bundle.map(OperandBundleDef::from_generic);\n         let bundle = bundle.as_ref().map(|b| &*b.raw);\n \n@@ -1399,7 +1399,17 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn cx(&self) -> &'a CodegenCx<'ll, 'tcx> {\n+    fn cx(&self) -> &CodegenCx<'ll, 'tcx> {\n         self.cx\n     }\n+\n+    fn delete_basic_block(&self, bb: &'ll BasicBlock) {\n+        unsafe {\n+            llvm::LLVMDeleteBasicBlock(bb);\n+        }\n+    }\n+\n+    fn do_not_inline(&self, llret: &'ll Value) {\n+        llvm::Attribute::NoInline.apply_callsite(llvm::AttributePlace::Function, llret);\n+    }\n }"}, {"sha": "37eeb93e21736db7cec409bb17d35da8884d36ca", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -15,18 +15,15 @@\n //! closure.\n \n use attributes;\n-use common::{CodegenCx};\n-use consts;\n-use declare;\n use llvm;\n use monomorphize::Instance;\n-use type_of::LayoutLlvmExt;\n+use context::CodegenCx;\n use value::Value;\n use interfaces::*;\n \n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, TypeFoldable};\n-use rustc::ty::layout::LayoutOf;\n+use rustc::ty::layout::{LayoutOf, HasTyCtxt};\n use rustc::ty::subst::Substs;\n \n /// Codegens a reference to a fn/method item, monomorphizing and\n@@ -40,16 +37,16 @@ pub fn get_fn(\n     cx: &CodegenCx<'ll, 'tcx>,\n     instance: Instance<'tcx>,\n ) -> &'ll Value {\n-    let tcx = cx.tcx;\n+    let tcx = cx.tcx();\n \n     debug!(\"get_fn(instance={:?})\", instance);\n \n     assert!(!instance.substs.needs_infer());\n     assert!(!instance.substs.has_escaping_bound_vars());\n     assert!(!instance.substs.has_param_types());\n \n-    let sig = instance.fn_sig(cx.tcx);\n-    if let Some(&llfn) = cx.instances.borrow().get(&instance) {\n+    let sig = instance.fn_sig(cx.tcx());\n+    if let Some(&llfn) = cx.instances().borrow().get(&instance) {\n         return llfn;\n     }\n \n@@ -58,9 +55,9 @@ pub fn get_fn(\n \n     // Create a fn pointer with the substituted signature.\n     let fn_ptr_ty = tcx.mk_fn_ptr(sig);\n-    let llptrty = cx.layout_of(fn_ptr_ty).llvm_type(cx);\n+    let llptrty = cx.backend_type(cx.layout_of(fn_ptr_ty));\n \n-    let llfn = if let Some(llfn) = declare::get_declared_value(cx, &sym) {\n+    let llfn = if let Some(llfn) = cx.get_declared_value(&sym) {\n         // This is subtle and surprising, but sometimes we have to bitcast\n         // the resulting fn pointer.  The reason has to do with external\n         // functions.  If you have two crates that both bind the same C\n@@ -86,13 +83,13 @@ pub fn get_fn(\n         // other weird situations. Annoying.\n         if cx.val_ty(llfn) != llptrty {\n             debug!(\"get_fn: casting {:?} to {:?}\", llfn, llptrty);\n-            consts::ptrcast(llfn, llptrty)\n+            cx.static_ptrcast(llfn, llptrty)\n         } else {\n             debug!(\"get_fn: not casting pointer!\");\n             llfn\n         }\n     } else {\n-        let llfn = declare::declare_fn(cx, &sym, sig);\n+        let llfn = cx.declare_fn(&sym, sig);\n         assert_eq!(cx.val_ty(llfn), llptrty);\n         debug!(\"get_fn: not casting pointer!\");\n "}, {"sha": "e66c7db0090cae777539038863c14722c5da8a65", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 115, "deletions": 32, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -17,21 +17,23 @@ use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::LangItem;\n use abi;\n use base;\n-use builder::Builder;\n use consts;\n-use declare;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use value::Value;\n-use interfaces::{BackendTypes, BuilderMethods, ConstMethods, BaseTypeMethods};\n+use interfaces::*;\n \n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{HasDataLayout, LayoutOf};\n+use rustc::ty::layout::{HasDataLayout, LayoutOf, self, TyLayout, Size};\n+use rustc::mir::interpret::{Scalar, AllocType, Allocation};\n use rustc::hir;\n+use mir::constant::const_alloc_to_llvm;\n+use mir::place::PlaceRef;\n \n use libc::{c_uint, c_char};\n \n use syntax::symbol::LocalInternedString;\n+use syntax::ast::Mutability;\n use syntax_pos::{Span, DUMMY_SP};\n \n pub use context::CodegenCx;\n@@ -48,13 +50,13 @@ pub fn type_is_freeze<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bo\n     ty.is_freeze(tcx, ty::ParamEnv::reveal_all(), DUMMY_SP)\n }\n \n-pub struct OperandBundleDef<'a, Value> {\n+pub struct OperandBundleDef<'a, V> {\n     pub name: &'a str,\n-    pub val: Value\n+    pub val: V\n }\n \n-impl<'a, Value> OperandBundleDef<'a, Value> {\n-    pub fn new(name: &'a str, val: Value) -> Self {\n+impl<'a, V> OperandBundleDef<'a, V> {\n+    pub fn new(name: &'a str, val: V) -> Self {\n         OperandBundleDef {\n             name,\n             val\n@@ -190,24 +192,24 @@ pub enum TypeKind {\n /// When inside of a landing pad, each function call in LLVM IR needs to be\n /// annotated with which landing pad it's a part of. This is accomplished via\n /// the `OperandBundleDef` value created for MSVC landing pads.\n-pub struct Funclet<'ll> {\n-    cleanuppad: &'ll Value,\n-    operand: OperandBundleDef<'ll, &'ll Value>,\n+pub struct Funclet<'a, V> {\n+    cleanuppad: V,\n+    operand: OperandBundleDef<'a, V>,\n }\n \n-impl Funclet<'ll> {\n-    pub fn new(cleanuppad: &'ll Value) -> Self {\n+impl<'a, V: CodegenObject> Funclet<'a, V> {\n+    pub fn new(cleanuppad: V) -> Self {\n         Funclet {\n             cleanuppad,\n             operand: OperandBundleDef::new(\"funclet\", cleanuppad),\n         }\n     }\n \n-    pub fn cleanuppad(&self) -> &'ll Value {\n+    pub fn cleanuppad(&self) -> V {\n         self.cleanuppad\n     }\n \n-    pub fn bundle(&self) -> &OperandBundleDef<'ll, &'ll Value> {\n+    pub fn bundle(&self) -> &OperandBundleDef<'a, V> {\n         &self.operand\n     }\n }\n@@ -217,6 +219,8 @@ impl BackendTypes for CodegenCx<'ll, 'tcx> {\n     type BasicBlock = &'ll BasicBlock;\n     type Type = &'ll Type;\n     type Context = &'ll llvm::Context;\n+\n+    type DIScope = &'ll llvm::debuginfo::DIScope;\n }\n \n impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n@@ -300,7 +304,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                                                     s.len() as c_uint,\n                                                     !null_terminated as Bool);\n             let sym = self.generate_local_symbol_name(\"str\");\n-            let g = declare::define_global(&self, &sym[..], self.val_ty(sc)).unwrap_or_else(||{\n+            let g = self.define_global(&sym[..], self.val_ty(sc)).unwrap_or_else(||{\n                 bug!(\"symbol `{}` is already defined\", sym);\n             });\n             llvm::LLVMSetInitializer(g, sc);\n@@ -415,6 +419,79 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             }\n         }\n     }\n+\n+    fn scalar_to_backend(\n+        &self,\n+        cv: Scalar,\n+        layout: &layout::Scalar,\n+        llty: &'ll Type,\n+    ) -> &'ll Value {\n+        let bitsize = if layout.is_bool() { 1 } else { layout.value.size(self).bits() };\n+        match cv {\n+            Scalar::Bits { size: 0, .. } => {\n+                assert_eq!(0, layout.value.size(self).bytes());\n+                self.const_undef(self.type_ix(0))\n+            },\n+            Scalar::Bits { bits, size } => {\n+                assert_eq!(size as u64, layout.value.size(self).bytes());\n+                let llval = self.const_uint_big(self.type_ix(bitsize), bits);\n+                if layout.value == layout::Pointer {\n+                    unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n+                } else {\n+                    self.static_bitcast(llval, llty)\n+                }\n+            },\n+            Scalar::Ptr(ptr) => {\n+                let alloc_type = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n+                let base_addr = match alloc_type {\n+                    Some(AllocType::Memory(alloc)) => {\n+                        let init = const_alloc_to_llvm(self, alloc);\n+                        if alloc.mutability == Mutability::Mutable {\n+                            self.static_addr_of_mut(init, alloc.align, None)\n+                        } else {\n+                            self.static_addr_of(init, alloc.align, None)\n+                        }\n+                    }\n+                    Some(AllocType::Function(fn_instance)) => {\n+                        self.get_fn(fn_instance)\n+                    }\n+                    Some(AllocType::Static(def_id)) => {\n+                        assert!(self.tcx.is_static(def_id).is_some());\n+                        self.get_static(def_id)\n+                    }\n+                    None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n+                };\n+                let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n+                    self.static_bitcast(base_addr, self.type_i8p()),\n+                    &self.const_usize(ptr.offset.bytes()),\n+                    1,\n+                ) };\n+                if layout.value != layout::Pointer {\n+                    unsafe { llvm::LLVMConstPtrToInt(llval, llty) }\n+                } else {\n+                    self.static_bitcast(llval, llty)\n+                }\n+            }\n+        }\n+    }\n+\n+    fn from_const_alloc(\n+        &self,\n+        layout: TyLayout<'tcx>,\n+        alloc: &Allocation,\n+        offset: Size,\n+    ) -> PlaceRef<'tcx, &'ll Value> {\n+        let init = const_alloc_to_llvm(self, alloc);\n+        let base_addr = self.static_addr_of(init, layout.align, None);\n+\n+        let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n+            self.static_bitcast(base_addr, self.type_i8p()),\n+            &self.const_usize(offset.bytes()),\n+            1,\n+        )};\n+        let llval = self.static_bitcast(llval, self.type_ptr_to(layout.llvm_type(self)));\n+        PlaceRef::new_sized(llval, layout, alloc.align)\n+    }\n }\n \n pub fn val_ty(v: &'ll Value) -> &'ll Type {\n@@ -466,20 +543,23 @@ pub fn langcall(tcx: TyCtxt,\n // all shifts). For 32- and 64-bit types, this matches the semantics\n // of Java. (See related discussion on #1877 and #10183.)\n \n-pub fn build_unchecked_lshift(\n-    bx: &Builder<'a, 'll, 'tcx>,\n-    lhs: &'ll Value,\n-    rhs: &'ll Value\n-) -> &'ll Value {\n+pub fn build_unchecked_lshift<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    lhs: Bx::Value,\n+    rhs: Bx::Value\n+) -> Bx::Value {\n     let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shl, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bx, rhs);\n     bx.shl(lhs, rhs)\n }\n \n-pub fn build_unchecked_rshift(\n-    bx: &Builder<'a, 'll, 'tcx>, lhs_t: Ty<'tcx>, lhs: &'ll Value, rhs: &'ll Value\n-) -> &'ll Value {\n+pub fn build_unchecked_rshift<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    lhs_t: Ty<'tcx>,\n+    lhs: Bx::Value,\n+    rhs: Bx::Value\n+) -> Bx::Value {\n     let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shr, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bx, rhs);\n@@ -491,26 +571,29 @@ pub fn build_unchecked_rshift(\n     }\n }\n \n-fn shift_mask_rhs(bx: &Builder<'a, 'll, 'tcx>, rhs: &'ll Value) -> &'ll Value {\n+fn shift_mask_rhs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    rhs: Bx::Value\n+) -> Bx::Value {\n     let rhs_llty = bx.cx().val_ty(rhs);\n     bx.and(rhs, shift_mask_val(bx, rhs_llty, rhs_llty, false))\n }\n \n-pub fn shift_mask_val(\n-    bx: &Builder<'a, 'll, 'tcx>,\n-    llty: &'ll Type,\n-    mask_llty: &'ll Type,\n+pub fn shift_mask_val<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    llty: Bx::Type,\n+    mask_llty: Bx::Type,\n     invert: bool\n-) -> &'ll Value {\n+) -> Bx::Value {\n     let kind = bx.cx().type_kind(llty);\n     match kind {\n         TypeKind::Integer => {\n             // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc.\n             let val = bx.cx().int_width(llty) - 1;\n             if invert {\n-                bx.cx.const_int(mask_llty, !val as i64)\n+                bx.cx().const_int(mask_llty, !val as i64)\n             } else {\n-                bx.cx.const_uint(mask_llty, val)\n+                bx.cx().const_uint(mask_llty, val)\n             }\n         },\n         TypeKind::Vector => {"}, {"sha": "aef13a208772b1c9c938b84a99df21857300d45e", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -16,15 +16,14 @@ use debuginfo;\n use base;\n use monomorphize::MonoItem;\n use common::CodegenCx;\n-use declare;\n use monomorphize::Instance;\n use syntax_pos::Span;\n use syntax_pos::symbol::LocalInternedString;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use value::Value;\n use rustc::ty::{self, Ty};\n-use interfaces::{BaseTypeMethods, DerivedTypeMethods, StaticMethods};\n+use interfaces::*;\n \n use rustc::ty::layout::{Align, LayoutOf};\n \n@@ -79,7 +78,7 @@ fn check_and_apply_linkage(\n         };\n         unsafe {\n             // Declare a symbol `foo` with the desired linkage.\n-            let g1 = declare::declare_global(cx, &sym, llty2);\n+            let g1 = cx.declare_global(&sym, llty2);\n             llvm::LLVMRustSetLinkage(g1, base::linkage_to_llvm(linkage));\n \n             // Declare an internal global `extern_with_linkage_foo` which\n@@ -90,7 +89,7 @@ fn check_and_apply_linkage(\n             // zero.\n             let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n             real_name.push_str(&sym);\n-            let g2 = declare::define_global(cx, &real_name, llty).unwrap_or_else(||{\n+            let g2 = cx.define_global(&real_name, llty).unwrap_or_else(||{\n                 if let Some(span) = span {\n                     cx.sess().span_fatal(\n                         span,\n@@ -107,7 +106,7 @@ fn check_and_apply_linkage(\n     } else {\n         // Generate an external declaration.\n         // FIXME(nagisa): investigate whether it can be changed into define_global\n-        declare::declare_global(cx, &sym, llty)\n+        cx.declare_global(&sym, llty)\n     }\n }\n \n@@ -139,14 +138,14 @@ impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             let gv = match kind {\n                 Some(kind) if !self.tcx.sess.fewer_names() => {\n                     let name = self.generate_local_symbol_name(kind);\n-                    let gv = declare::define_global(&self, &name[..],\n+                    let gv = self.define_global(&name[..],\n                         self.val_ty(cv)).unwrap_or_else(||{\n                             bug!(\"symbol `{}` is already defined\", name);\n                     });\n                     llvm::LLVMRustSetLinkage(gv, llvm::Linkage::PrivateLinkage);\n                     gv\n                 },\n-                _ => declare::define_private_global(&self, self.val_ty(cv)),\n+                _ => self.define_private_global(self.val_ty(cv)),\n             };\n             llvm::LLVMSetInitializer(gv, cv);\n             set_global_alignment(&self, gv, align);\n@@ -206,11 +205,11 @@ impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 Node::Item(&hir::Item {\n                     ref attrs, span, node: hir::ItemKind::Static(..), ..\n                 }) => {\n-                    if declare::get_declared_value(&self, &sym[..]).is_some() {\n+                    if self.get_declared_value(&sym[..]).is_some() {\n                         span_bug!(span, \"Conflicting symbol names for static?\");\n                     }\n \n-                    let g = declare::define_global(&self, &sym[..], llty).unwrap();\n+                    let g = self.define_global(&sym[..], llty).unwrap();\n \n                     if !self.tcx.is_reachable_non_generic(def_id) {\n                         unsafe {"}, {"sha": "d7f850b84a919f25fbd66ae64238c2c7273c4f77", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 97, "deletions": 87, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -15,14 +15,14 @@ use rustc::hir;\n use debuginfo;\n use callee;\n use base;\n-use declare;\n use monomorphize::Instance;\n use value::Value;\n \n use monomorphize::partitioning::CodegenUnit;\n use type_::Type;\n use type_of::PointeeInfo;\n use interfaces::*;\n+use libc::c_uint;\n \n use rustc_data_structures::base_n;\n use rustc_data_structures::small_c_str::SmallCStr;\n@@ -315,21 +315,108 @@ impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n     }\n }\n \n-impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n-    pub fn sess<'a>(&'a self) -> &'a Session {\n-        &self.tcx.sess\n-    }\n-}\n-\n impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn vtables(&self) -> &RefCell<FxHashMap<(Ty<'tcx>,\n                                 ty::PolyExistentialTraitRef<'tcx>), &'ll Value>>\n     {\n         &self.vtables\n     }\n+\n+    fn instances(&self) -> &RefCell<FxHashMap<Instance<'tcx>, &'ll Value>> {\n+        &self.instances\n+    }\n+\n     fn get_fn(&self, instance: Instance<'tcx>) -> &'ll Value {\n         callee::get_fn(&&self,instance)\n     }\n+\n+    fn get_param(&self, llfn: &'ll Value, index: c_uint) -> &'ll Value {\n+        llvm::get_param(llfn, index)\n+    }\n+\n+    fn eh_personality(&self) -> &'ll Value {\n+        // The exception handling personality function.\n+        //\n+        // If our compilation unit has the `eh_personality` lang item somewhere\n+        // within it, then we just need to codegen that. Otherwise, we're\n+        // building an rlib which will depend on some upstream implementation of\n+        // this function, so we just codegen a generic reference to it. We don't\n+        // specify any of the types for the function, we just make it a symbol\n+        // that LLVM can later use.\n+        //\n+        // Note that MSVC is a little special here in that we don't use the\n+        // `eh_personality` lang item at all. Currently LLVM has support for\n+        // both Dwarf and SEH unwind mechanisms for MSVC targets and uses the\n+        // *name of the personality function* to decide what kind of unwind side\n+        // tables/landing pads to emit. It looks like Dwarf is used by default,\n+        // injecting a dependency on the `_Unwind_Resume` symbol for resuming\n+        // an \"exception\", but for MSVC we want to force SEH. This means that we\n+        // can't actually have the personality function be our standard\n+        // `rust_eh_personality` function, but rather we wired it up to the\n+        // CRT's custom personality function, which forces LLVM to consider\n+        // landing pads as \"landing pads for SEH\".\n+        if let Some(llpersonality) = self.eh_personality.get() {\n+            return llpersonality\n+        }\n+        let tcx = self.tcx;\n+        let llfn = match tcx.lang_items().eh_personality() {\n+            Some(def_id) if !base::wants_msvc_seh(self.sess()) => {\n+                callee::resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]))\n+            }\n+            _ => {\n+                let name = if base::wants_msvc_seh(self.sess()) {\n+                    \"__CxxFrameHandler3\"\n+                } else {\n+                    \"rust_eh_personality\"\n+                };\n+                let fty = self.type_variadic_func(&[], self.type_i32());\n+                self.declare_cfn(name, fty)\n+            }\n+        };\n+        attributes::apply_target_cpu_attr(self, llfn);\n+        self.eh_personality.set(Some(llfn));\n+        llfn\n+    }\n+\n+    // Returns a Value of the \"eh_unwind_resume\" lang item if one is defined,\n+    // otherwise declares it as an external function.\n+    fn eh_unwind_resume(&self) -> &'ll Value {\n+        use attributes;\n+        let unwresume = &self.eh_unwind_resume;\n+        if let Some(llfn) = unwresume.get() {\n+            return llfn;\n+        }\n+\n+        let tcx = self.tcx;\n+        assert!(self.sess().target.target.options.custom_unwind_resume);\n+        if let Some(def_id) = tcx.lang_items().eh_unwind_resume() {\n+            let llfn = callee::resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]));\n+            unwresume.set(Some(llfn));\n+            return llfn;\n+        }\n+\n+        let sig = ty::Binder::bind(tcx.mk_fn_sig(\n+            iter::once(tcx.mk_mut_ptr(tcx.types.u8)),\n+            tcx.types.never,\n+            false,\n+            hir::Unsafety::Unsafe,\n+            Abi::C\n+        ));\n+\n+        let llfn = self.declare_fn(\"rust_eh_unwind_resume\", sig);\n+        attributes::unwind(llfn, true);\n+        attributes::apply_target_cpu_attr(self, llfn);\n+        unwresume.set(Some(llfn));\n+        llfn\n+    }\n+\n+    fn sess(&self) -> &Session {\n+        &self.tcx.sess\n+    }\n+\n+    fn check_overflow(&self) -> bool {\n+        self.check_overflow\n+    }\n }\n \n impl IntrinsicDeclarationMethods<'tcx> for CodegenCx<'b, 'tcx> {\n@@ -349,23 +436,23 @@ impl IntrinsicDeclarationMethods<'tcx> for CodegenCx<'b, 'tcx> {\n         macro_rules! ifn {\n             ($name:expr, fn() -> $ret:expr) => (\n                 if key == $name {\n-                    let f = declare::declare_cfn(&self, $name, self.type_func(&[], $ret));\n+                    let f = self.declare_cfn($name, self.type_func(&[], $ret));\n                     llvm::SetUnnamedAddr(f, false);\n                     self.intrinsics.borrow_mut().insert($name, f.clone());\n                     return Some(f);\n                 }\n             );\n             ($name:expr, fn(...) -> $ret:expr) => (\n                 if key == $name {\n-                    let f = declare::declare_cfn(&self, $name, self.type_variadic_func(&[], $ret));\n+                    let f = self.declare_cfn($name, self.type_variadic_func(&[], $ret));\n                     llvm::SetUnnamedAddr(f, false);\n                     self.intrinsics.borrow_mut().insert($name, f.clone());\n                     return Some(f);\n                 }\n             );\n             ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n                 if key == $name {\n-                    let f = declare::declare_cfn(&self, $name, self.type_func(&[$($arg),*], $ret));\n+                    let f = self.declare_cfn($name, self.type_func(&[$($arg),*], $ret));\n                     llvm::SetUnnamedAddr(f, false);\n                     self.intrinsics.borrow_mut().insert($name, f.clone());\n                     return Some(f);\n@@ -668,83 +755,6 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n         base_n::push_str(idx as u128, base_n::ALPHANUMERIC_ONLY, &mut name);\n         name\n     }\n-\n-    pub fn eh_personality(&self) -> &'b Value {\n-        // The exception handling personality function.\n-        //\n-        // If our compilation unit has the `eh_personality` lang item somewhere\n-        // within it, then we just need to codegen that. Otherwise, we're\n-        // building an rlib which will depend on some upstream implementation of\n-        // this function, so we just codegen a generic reference to it. We don't\n-        // specify any of the types for the function, we just make it a symbol\n-        // that LLVM can later use.\n-        //\n-        // Note that MSVC is a little special here in that we don't use the\n-        // `eh_personality` lang item at all. Currently LLVM has support for\n-        // both Dwarf and SEH unwind mechanisms for MSVC targets and uses the\n-        // *name of the personality function* to decide what kind of unwind side\n-        // tables/landing pads to emit. It looks like Dwarf is used by default,\n-        // injecting a dependency on the `_Unwind_Resume` symbol for resuming\n-        // an \"exception\", but for MSVC we want to force SEH. This means that we\n-        // can't actually have the personality function be our standard\n-        // `rust_eh_personality` function, but rather we wired it up to the\n-        // CRT's custom personality function, which forces LLVM to consider\n-        // landing pads as \"landing pads for SEH\".\n-        if let Some(llpersonality) = self.eh_personality.get() {\n-            return llpersonality\n-        }\n-        let tcx = self.tcx;\n-        let llfn = match tcx.lang_items().eh_personality() {\n-            Some(def_id) if !base::wants_msvc_seh(self.sess()) => {\n-                callee::resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]))\n-            }\n-            _ => {\n-                let name = if base::wants_msvc_seh(self.sess()) {\n-                    \"__CxxFrameHandler3\"\n-                } else {\n-                    \"rust_eh_personality\"\n-                };\n-                let fty = self.type_variadic_func(&[], self.type_i32());\n-                declare::declare_cfn(self, name, fty)\n-            }\n-        };\n-        attributes::apply_target_cpu_attr(self, llfn);\n-        self.eh_personality.set(Some(llfn));\n-        llfn\n-    }\n-\n-    // Returns a Value of the \"eh_unwind_resume\" lang item if one is defined,\n-    // otherwise declares it as an external function.\n-    pub fn eh_unwind_resume(&self) -> &'b Value {\n-        use attributes;\n-        let unwresume = &self.eh_unwind_resume;\n-        if let Some(llfn) = unwresume.get() {\n-            return llfn;\n-        }\n-\n-        let tcx = self.tcx;\n-        assert!(self.sess().target.target.options.custom_unwind_resume);\n-        if let Some(def_id) = tcx.lang_items().eh_unwind_resume() {\n-            let llfn = callee::resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]));\n-            unwresume.set(Some(llfn));\n-            return llfn;\n-        }\n-\n-        let sig = ty::Binder::bind(tcx.mk_fn_sig(\n-            iter::once(tcx.mk_mut_ptr(tcx.types.u8)),\n-            tcx.types.never,\n-            false,\n-            hir::Unsafety::Unsafe,\n-            Abi::C\n-        ));\n-\n-        let llfn = declare::declare_fn(self, \"rust_eh_unwind_resume\", sig);\n-        attributes::unwind(llfn, true);\n-        attributes::apply_target_cpu_attr(self, llfn);\n-        unwresume.set(Some(llfn));\n-        llfn\n-    }\n-\n }\n \n impl ty::layout::HasDataLayout for CodegenCx<'ll, 'tcx> {"}, {"sha": "0fd5f7fb8cd773733b0e25c94dc052bf11763b31", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -13,7 +13,7 @@ use super::metadata::file_metadata;\n use super::utils::{DIB, span_start};\n \n use llvm;\n-use llvm::debuginfo::DIScope;\n+use llvm::debuginfo::{DIScope, DISubprogram};\n use common::CodegenCx;\n use rustc::mir::{Mir, SourceScope};\n \n@@ -27,15 +27,15 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use syntax_pos::BytePos;\n \n #[derive(Clone, Copy, Debug)]\n-pub struct MirDebugScope<'ll> {\n-    pub scope_metadata: Option<&'ll DIScope>,\n+pub struct MirDebugScope<D> {\n+    pub scope_metadata: Option<D>,\n     // Start and end offsets of the file to which this DIScope belongs.\n     // These are used to quickly determine whether some span refers to the same file.\n     pub file_start_pos: BytePos,\n     pub file_end_pos: BytePos,\n }\n \n-impl MirDebugScope<'ll> {\n+impl<D> MirDebugScope<D> {\n     pub fn is_valid(&self) -> bool {\n         self.scope_metadata.is_some()\n     }\n@@ -46,8 +46,8 @@ impl MirDebugScope<'ll> {\n pub fn create_mir_scopes(\n     cx: &CodegenCx<'ll, '_>,\n     mir: &Mir,\n-    debug_context: &FunctionDebugContext<'ll>,\n-) -> IndexVec<SourceScope, MirDebugScope<'ll>> {\n+    debug_context: &FunctionDebugContext<&'ll DISubprogram>,\n+) -> IndexVec<SourceScope, MirDebugScope<&'ll DIScope>> {\n     let null_scope = MirDebugScope {\n         scope_metadata: None,\n         file_start_pos: BytePos(0),\n@@ -82,9 +82,9 @@ pub fn create_mir_scopes(\n fn make_mir_scope(cx: &CodegenCx<'ll, '_>,\n                   mir: &Mir,\n                   has_variables: &BitSet<SourceScope>,\n-                  debug_context: &FunctionDebugContextData<'ll>,\n+                  debug_context: &FunctionDebugContextData<&'ll DISubprogram>,\n                   scope: SourceScope,\n-                  scopes: &mut IndexVec<SourceScope, MirDebugScope<'ll>>) {\n+                  scopes: &mut IndexVec<SourceScope, MirDebugScope<&'ll DIScope>>) {\n     if scopes[scope].is_valid() {\n         return;\n     }"}, {"sha": "607920091bca43c26f6cf6525fa10e7446cb4177", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -14,10 +14,9 @@ use llvm;\n \n use common::CodegenCx;\n use builder::Builder;\n-use declare;\n use rustc::session::config::DebugInfo;\n use value::Value;\n-use interfaces::{BuilderMethods, ConstMethods, BaseTypeMethods};\n+use interfaces::*;\n \n use syntax::attr;\n \n@@ -58,7 +57,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>)\n             let llvm_type = cx.type_array(cx.type_i8(),\n                                         section_contents.len() as u64);\n \n-            let section_var = declare::define_global(cx, section_var_name,\n+            let section_var = cx.define_global(section_var_name,\n                                                      llvm_type).unwrap_or_else(||{\n                 bug!(\"symbol `{}` is already defined\", section_var_name)\n             });"}, {"sha": "8da138f10e981cc86df67f3549d4eb90520813e0", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 62, "deletions": 58, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -1968,6 +1968,68 @@ pub fn create_global_var_metadata(\n     }\n }\n \n+/// Creates debug information for the given vtable, which is for the\n+/// given type.\n+///\n+/// Adds the created metadata nodes directly to the crate's IR.\n+pub fn create_vtable_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    ty: ty::Ty<'tcx>,\n+    vtable: &'ll Value,\n+) {\n+    if cx.dbg_cx.is_none() {\n+        return;\n+    }\n+\n+    let type_metadata = type_metadata(cx, ty, syntax_pos::DUMMY_SP);\n+\n+    unsafe {\n+        // LLVMRustDIBuilderCreateStructType() wants an empty array. A null\n+        // pointer will lead to hard to trace and debug LLVM assertions\n+        // later on in llvm/lib/IR/Value.cpp.\n+        let empty_array = create_DIArray(DIB(cx), &[]);\n+\n+        let name = const_cstr!(\"vtable\");\n+\n+        // Create a new one each time.  We don't want metadata caching\n+        // here, because each vtable will refer to a unique containing\n+        // type.\n+        let vtable_type = llvm::LLVMRustDIBuilderCreateStructType(\n+            DIB(cx),\n+            NO_SCOPE_METADATA,\n+            name.as_ptr(),\n+            unknown_file_metadata(cx),\n+            UNKNOWN_LINE_NUMBER,\n+            Size::ZERO.bits(),\n+            cx.tcx.data_layout.pointer_align.abi_bits() as u32,\n+            DIFlags::FlagArtificial,\n+            None,\n+            empty_array,\n+            0,\n+            Some(type_metadata),\n+            name.as_ptr()\n+        );\n+\n+        llvm::LLVMRustDIBuilderCreateStaticVariable(DIB(cx),\n+                                                    NO_SCOPE_METADATA,\n+                                                    name.as_ptr(),\n+                                                    // LLVM 3.9\n+                                                    // doesn't accept\n+                                                    // null here, so\n+                                                    // pass the name\n+                                                    // as the linkage\n+                                                    // name.\n+                                                    name.as_ptr(),\n+                                                    unknown_file_metadata(cx),\n+                                                    UNKNOWN_LINE_NUMBER,\n+                                                    vtable_type,\n+                                                    true,\n+                                                    vtable,\n+                                                    None,\n+                                                    0);\n+    }\n+}\n+\n // Creates an \"extension\" of an existing DIScope into another file.\n pub fn extend_scope_to_file(\n     cx: &CodegenCx<'ll, '_>,\n@@ -1983,61 +2045,3 @@ pub fn extend_scope_to_file(\n             file_metadata)\n     }\n }\n-\n-impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n-    /// Creates debug information for the given vtable, which is for the\n-    /// given type.\n-    ///\n-    /// Adds the created metadata nodes directly to the crate's IR.\n-    fn create_vtable_metadata(\n-        &self,\n-        ty: ty::Ty<'tcx>,\n-        vtable: &'ll Value,\n-    ) {\n-        if self.dbg_cx.is_none() {\n-            return;\n-        }\n-\n-        let type_metadata = type_metadata(&self, ty, syntax_pos::DUMMY_SP);\n-\n-        unsafe {\n-            // LLVMRustDIBuilderCreateStructType() wants an empty array. A null\n-            // pointer will lead to hard to trace and debug LLVM assertions\n-            // later on in llvm/lib/IR/Value.cpp.\n-            let empty_array = create_DIArray(DIB(&self), &[]);\n-\n-            let name = const_cstr!(\"vtable\");\n-\n-            // Create a new one each time.  We don't want metadata caching\n-            // here, because each vtable will refer to a unique containing\n-            // type.\n-            let vtable_type = llvm::LLVMRustDIBuilderCreateStructType(\n-                DIB(&self),\n-                NO_SCOPE_METADATA,\n-                name.as_ptr(),\n-                unknown_file_metadata(&self),\n-                UNKNOWN_LINE_NUMBER,\n-                Size::ZERO.bits(),\n-                self.tcx.data_layout.pointer_align.abi_bits() as u32,\n-                DIFlags::FlagArtificial,\n-                None,\n-                empty_array,\n-                0,\n-                Some(type_metadata),\n-                name.as_ptr()\n-            );\n-\n-            llvm::LLVMRustDIBuilderCreateStaticVariable(DIB(&self),\n-                                                        NO_SCOPE_METADATA,\n-                                                        name.as_ptr(),\n-                                                        ptr::null(),\n-                                                        unknown_file_metadata(&self),\n-                                                        UNKNOWN_LINE_NUMBER,\n-                                                        vtable_type,\n-                                                        true,\n-                                                        vtable,\n-                                                        None,\n-                                                        0);\n-        }\n-    }\n-}"}, {"sha": "b802acb04bda28fa540abcd2cbe6e402c59aadf1", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 356, "deletions": 314, "changes": 670, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -21,7 +21,8 @@ use self::metadata::{type_metadata, file_metadata, TypeMap};\n use self::source_loc::InternalDebugLocation::{self, UnknownLocation};\n \n use llvm;\n-use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilder, DISubprogram, DIArray, DIFlags};\n+use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilder, DISubprogram, DIArray, DIFlags,\n+    DILexicalBlock};\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::{DefId, CrateNum};\n use rustc::ty::subst::{Substs, UnpackedKind};\n@@ -35,6 +36,7 @@ use rustc::mir;\n use rustc::session::config::{self, DebugInfo};\n use rustc::util::nodemap::{DefIdMap, FxHashMap, FxHashSet};\n use rustc_data_structures::small_c_str::SmallCStr;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use value::Value;\n \n use libc::c_uint;\n@@ -44,8 +46,8 @@ use std::ffi::CString;\n use syntax_pos::{self, Span, Pos};\n use syntax::ast;\n use syntax::symbol::{Symbol, InternedString};\n-use rustc::ty::layout::{self, LayoutOf};\n-use interfaces::BuilderMethods;\n+use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n+use interfaces::*;\n \n pub mod gdb;\n mod utils;\n@@ -109,21 +111,21 @@ impl<'a, 'tcx> CrateDebugContext<'a, 'tcx> {\n     }\n }\n \n-pub enum FunctionDebugContext<'ll> {\n-    RegularContext(FunctionDebugContextData<'ll>),\n+pub enum FunctionDebugContext<D> {\n+    RegularContext(FunctionDebugContextData<D>),\n     DebugInfoDisabled,\n     FunctionWithoutDebugInfo,\n }\n \n-impl FunctionDebugContext<'ll> {\n-    pub fn get_ref<'a>(&'a self, span: Span) -> &'a FunctionDebugContextData<'ll> {\n+impl<D> FunctionDebugContext<D> {\n+    pub fn get_ref<'a>(&'a self, span: Span) -> &'a FunctionDebugContextData<D> {\n         match *self {\n             FunctionDebugContext::RegularContext(ref data) => data,\n             FunctionDebugContext::DebugInfoDisabled => {\n-                span_bug!(span, \"{}\", FunctionDebugContext::debuginfo_disabled_message());\n+                span_bug!(span, \"{}\", Self::debuginfo_disabled_message());\n             }\n             FunctionDebugContext::FunctionWithoutDebugInfo => {\n-                span_bug!(span, \"{}\", FunctionDebugContext::should_be_ignored_message());\n+                span_bug!(span, \"{}\", Self::should_be_ignored_message());\n             }\n         }\n     }\n@@ -138,18 +140,18 @@ impl FunctionDebugContext<'ll> {\n     }\n }\n \n-pub struct FunctionDebugContextData<'ll> {\n-    fn_metadata: &'ll DISubprogram,\n+pub struct FunctionDebugContextData<D> {\n+    fn_metadata: D,\n     source_locations_enabled: Cell<bool>,\n     pub defining_crate: CrateNum,\n }\n \n-pub enum VariableAccess<'a, 'll> {\n+pub enum VariableAccess<'a, V> {\n     // The llptr given is an alloca containing the variable's value\n-    DirectVariable { alloca: &'ll Value },\n+    DirectVariable { alloca: V },\n     // The llptr given is an alloca containing the start of some pointer chain\n     // leading to the variable's content.\n-    IndirectVariable { alloca: &'ll Value, address_operations: &'a [i64] }\n+    IndirectVariable { alloca: V, address_operations: &'a [i64] }\n }\n \n pub enum VariableKind {\n@@ -202,348 +204,388 @@ pub fn finalize(cx: &CodegenCx) {\n     };\n }\n \n-/// Creates the function-specific debug context.\n-///\n-/// Returns the FunctionDebugContext for the function which holds state needed\n-/// for debug info creation. The function may also return another variant of the\n-/// FunctionDebugContext enum which indicates why no debuginfo should be created\n-/// for the function.\n-pub fn create_function_debug_context(\n-    cx: &CodegenCx<'ll, 'tcx>,\n-    instance: Instance<'tcx>,\n-    sig: ty::FnSig<'tcx>,\n-    llfn: &'ll Value,\n-    mir: &mir::Mir,\n-) -> FunctionDebugContext<'ll> {\n-    if cx.sess().opts.debuginfo == DebugInfo::None {\n-        return FunctionDebugContext::DebugInfoDisabled;\n+impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+    fn declare_local(\n+        &self,\n+        dbg_context: &FunctionDebugContext<&'ll DISubprogram>,\n+        variable_name: ast::Name,\n+        variable_type: Ty<'tcx>,\n+        scope_metadata: &'ll DIScope,\n+        variable_access: VariableAccess<'_, &'ll Value>,\n+        variable_kind: VariableKind,\n+        span: Span,\n+    ) {\n+        assert!(!dbg_context.get_ref(span).source_locations_enabled.get());\n+        let cx = self.cx();\n+\n+        let file = span_start(cx, span).file;\n+        let file_metadata = file_metadata(cx,\n+                                          &file.name,\n+                                          dbg_context.get_ref(span).defining_crate);\n+\n+        let loc = span_start(cx, span);\n+        let type_metadata = type_metadata(cx, variable_type, span);\n+\n+        let (argument_index, dwarf_tag) = match variable_kind {\n+            ArgumentVariable(index) => (index as c_uint, DW_TAG_arg_variable),\n+            LocalVariable => (0, DW_TAG_auto_variable)\n+        };\n+        let align = cx.align_of(variable_type);\n+\n+        let name = SmallCStr::new(&variable_name.as_str());\n+        match (variable_access, &[][..]) {\n+            (DirectVariable { alloca }, address_operations) |\n+            (IndirectVariable {alloca, address_operations}, _) => {\n+                let metadata = unsafe {\n+                    llvm::LLVMRustDIBuilderCreateVariable(\n+                        DIB(cx),\n+                        dwarf_tag,\n+                        scope_metadata,\n+                        name.as_ptr(),\n+                        file_metadata,\n+                        loc.line as c_uint,\n+                        type_metadata,\n+                        cx.sess().opts.optimize != config::OptLevel::No,\n+                        DIFlags::FlagZero,\n+                        argument_index,\n+                        align.abi() as u32,\n+                    )\n+                };\n+                source_loc::set_debug_location(self,\n+                    InternalDebugLocation::new(scope_metadata, loc.line, loc.col.to_usize()));\n+                unsafe {\n+                    let debug_loc = llvm::LLVMGetCurrentDebugLocation(self.llbuilder);\n+                    let instr = llvm::LLVMRustDIBuilderInsertDeclareAtEnd(\n+                        DIB(cx),\n+                        alloca,\n+                        metadata,\n+                        address_operations.as_ptr(),\n+                        address_operations.len() as c_uint,\n+                        debug_loc,\n+                        self.llbb());\n+\n+                    llvm::LLVMSetInstDebugLocation(self.llbuilder, instr);\n+                }\n+                source_loc::set_debug_location(self, UnknownLocation);\n+            }\n+        }\n     }\n \n-    if let InstanceDef::Item(def_id) = instance.def {\n-        if cx.tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::NO_DEBUG) {\n-            return FunctionDebugContext::FunctionWithoutDebugInfo;\n-        }\n+    fn set_source_location(\n+        &self,\n+        debug_context: &FunctionDebugContext<&'ll DISubprogram>,\n+        scope: Option<&'ll DIScope>,\n+        span: Span,\n+    ) {\n+        set_source_location(debug_context, &self, scope, span)\n     }\n+}\n \n-    let span = mir.span;\n+impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+    /// Creates the function-specific debug context.\n+    ///\n+    /// Returns the FunctionDebugContext for the function which holds state needed\n+    /// for debug info creation. The function may also return another variant of the\n+    /// FunctionDebugContext enum which indicates why no debuginfo should be created\n+    /// for the function.\n+    fn create_function_debug_context(\n+        &self,\n+        instance: Instance<'tcx>,\n+        sig: ty::FnSig<'tcx>,\n+        llfn: &'ll Value,\n+        mir: &mir::Mir,\n+    ) -> FunctionDebugContext<&'ll DISubprogram> {\n+        if self.sess().opts.debuginfo == DebugInfo::None {\n+            return FunctionDebugContext::DebugInfoDisabled;\n+        }\n \n-    // This can be the case for functions inlined from another crate\n-    if span.is_dummy() {\n-        // FIXME(simulacrum): Probably can't happen; remove.\n-        return FunctionDebugContext::FunctionWithoutDebugInfo;\n-    }\n+        if let InstanceDef::Item(def_id) = instance.def {\n+            if self.tcx().codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::NO_DEBUG) {\n+                return FunctionDebugContext::FunctionWithoutDebugInfo;\n+            }\n+        }\n \n-    let def_id = instance.def_id();\n-    let containing_scope = get_containing_scope(cx, instance);\n-    let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, &loc.file.name, def_id.krate);\n+        let span = mir.span;\n \n-    let function_type_metadata = unsafe {\n-        let fn_signature = get_function_signature(cx, sig);\n-        llvm::LLVMRustDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n-    };\n+        // This can be the case for functions inlined from another crate\n+        if span.is_dummy() {\n+            // FIXME(simulacrum): Probably can't happen; remove.\n+            return FunctionDebugContext::FunctionWithoutDebugInfo;\n+        }\n \n-    // Find the enclosing function, in case this is a closure.\n-    let def_key = cx.tcx.def_key(def_id);\n-    let mut name = def_key.disambiguated_data.data.to_string();\n+        let def_id = instance.def_id();\n+        let containing_scope = get_containing_scope(self, instance);\n+        let loc = span_start(self, span);\n+        let file_metadata = file_metadata(self, &loc.file.name, def_id.krate);\n \n-    let enclosing_fn_def_id = cx.tcx.closure_base_def_id(def_id);\n+        let function_type_metadata = unsafe {\n+            let fn_signature = get_function_signature(self, sig);\n+            llvm::LLVMRustDIBuilderCreateSubroutineType(DIB(self), file_metadata, fn_signature)\n+        };\n+\n+        // Find the enclosing function, in case this is a closure.\n+        let def_key = self.tcx().def_key(def_id);\n+        let mut name = def_key.disambiguated_data.data.to_string();\n+\n+        let enclosing_fn_def_id = self.tcx().closure_base_def_id(def_id);\n \n-    // Get_template_parameters() will append a `<...>` clause to the function\n-    // name if necessary.\n-    let generics = cx.tcx.generics_of(enclosing_fn_def_id);\n-    let substs = instance.substs.truncate_to(cx.tcx, generics);\n-    let template_parameters = get_template_parameters(cx,\n-                                                      &generics,\n-                                                      substs,\n-                                                      file_metadata,\n-                                                      &mut name);\n+        // Get_template_parameters() will append a `<...>` clause to the function\n+        // name if necessary.\n+        let generics = self.tcx().generics_of(enclosing_fn_def_id);\n+        let substs = instance.substs.truncate_to(self.tcx(), generics);\n+        let template_parameters = get_template_parameters(self,\n+                                                          &generics,\n+                                                          substs,\n+                                                          file_metadata,\n+                                                          &mut name);\n \n-    // Get the linkage_name, which is just the symbol name\n-    let linkage_name = mangled_name_of_instance(cx, instance);\n+        // Get the linkage_name, which is just the symbol name\n+        let linkage_name = mangled_name_of_instance(self, instance);\n \n-    let scope_line = span_start(cx, span).line;\n-    let is_local_to_unit = is_node_local_to_unit(cx, def_id);\n+        let scope_line = span_start(self, span).line;\n+        let is_local_to_unit = is_node_local_to_unit(self, def_id);\n \n-    let function_name = CString::new(name).unwrap();\n-    let linkage_name = SmallCStr::new(&linkage_name.as_str());\n+        let function_name = CString::new(name).unwrap();\n+        let linkage_name = SmallCStr::new(&linkage_name.as_str());\n \n-    let mut flags = DIFlags::FlagPrototyped;\n+        let mut flags = DIFlags::FlagPrototyped;\n \n-    let local_id = cx.tcx.hir.as_local_node_id(def_id);\n-    if let Some((id, _, _)) = *cx.sess().entry_fn.borrow() {\n-        if local_id == Some(id) {\n-            flags |= DIFlags::FlagMainSubprogram;\n+        let local_id = self.tcx().hir.as_local_node_id(def_id);\n+        if let Some((id, _, _)) = *self.sess().entry_fn.borrow() {\n+            if local_id == Some(id) {\n+                flags |= DIFlags::FlagMainSubprogram;\n+            }\n         }\n-    }\n \n-    if cx.layout_of(sig.output()).abi.is_uninhabited() {\n-        flags |= DIFlags::FlagNoReturn;\n-    }\n+        if self.layout_of(sig.output()).abi.is_uninhabited() {\n+            flags |= DIFlags::FlagNoReturn;\n+        }\n \n-    let fn_metadata = unsafe {\n-        llvm::LLVMRustDIBuilderCreateFunction(\n-            DIB(cx),\n-            containing_scope,\n-            function_name.as_ptr(),\n-            linkage_name.as_ptr(),\n-            file_metadata,\n-            loc.line as c_uint,\n-            function_type_metadata,\n-            is_local_to_unit,\n-            true,\n-            scope_line as c_uint,\n-            flags,\n-            cx.sess().opts.optimize != config::OptLevel::No,\n-            llfn,\n-            template_parameters,\n-            None)\n-    };\n+        let fn_metadata = unsafe {\n+            llvm::LLVMRustDIBuilderCreateFunction(\n+                DIB(self),\n+                containing_scope,\n+                function_name.as_ptr(),\n+                linkage_name.as_ptr(),\n+                file_metadata,\n+                loc.line as c_uint,\n+                function_type_metadata,\n+                is_local_to_unit,\n+                true,\n+                scope_line as c_uint,\n+                flags,\n+                self.sess().opts.optimize != config::OptLevel::No,\n+                llfn,\n+                template_parameters,\n+                None)\n+        };\n \n-    // Initialize fn debug context (including scope map and namespace map)\n-    let fn_debug_context = FunctionDebugContextData {\n-        fn_metadata,\n-        source_locations_enabled: Cell::new(false),\n-        defining_crate: def_id.krate,\n-    };\n+        // Initialize fn debug context (including scope map and namespace map)\n+        let fn_debug_context = FunctionDebugContextData {\n+            fn_metadata,\n+            source_locations_enabled: Cell::new(false),\n+            defining_crate: def_id.krate,\n+        };\n \n-    return FunctionDebugContext::RegularContext(fn_debug_context);\n+        return FunctionDebugContext::RegularContext(fn_debug_context);\n \n-    fn get_function_signature(\n-        cx: &CodegenCx<'ll, 'tcx>,\n-        sig: ty::FnSig<'tcx>,\n-    ) -> &'ll DIArray {\n-        if cx.sess().opts.debuginfo == DebugInfo::Limited {\n-            return create_DIArray(DIB(cx), &[]);\n-        }\n+        fn get_function_signature<'ll, 'tcx>(\n+            cx: &CodegenCx<'ll, 'tcx>,\n+            sig: ty::FnSig<'tcx>,\n+        ) -> &'ll DIArray {\n+            if cx.sess().opts.debuginfo == DebugInfo::Limited {\n+                return create_DIArray(DIB(cx), &[]);\n+            }\n \n-        let mut signature = Vec::with_capacity(sig.inputs().len() + 1);\n+            let mut signature = Vec::with_capacity(sig.inputs().len() + 1);\n \n-        // Return type -- llvm::DIBuilder wants this at index 0\n-        signature.push(match sig.output().sty {\n-            ty::Tuple(ref tys) if tys.is_empty() => None,\n-            _ => Some(type_metadata(cx, sig.output(), syntax_pos::DUMMY_SP))\n-        });\n+            // Return type -- llvm::DIBuilder wants this at index 0\n+            signature.push(match sig.output().sty {\n+                ty::Tuple(ref tys) if tys.is_empty() => None,\n+                _ => Some(type_metadata(cx, sig.output(), syntax_pos::DUMMY_SP))\n+            });\n \n-        let inputs = if sig.abi == Abi::RustCall {\n-            &sig.inputs()[..sig.inputs().len() - 1]\n-        } else {\n-            sig.inputs()\n-        };\n+            let inputs = if sig.abi == Abi::RustCall {\n+                &sig.inputs()[..sig.inputs().len() - 1]\n+            } else {\n+                sig.inputs()\n+            };\n \n-        // Arguments types\n-        if cx.sess().target.target.options.is_like_msvc {\n-            // FIXME(#42800):\n-            // There is a bug in MSDIA that leads to a crash when it encounters\n-            // a fixed-size array of `u8` or something zero-sized in a\n-            // function-type (see #40477).\n-            // As a workaround, we replace those fixed-size arrays with a\n-            // pointer-type. So a function `fn foo(a: u8, b: [u8; 4])` would\n-            // appear as `fn foo(a: u8, b: *const u8)` in debuginfo,\n-            // and a function `fn bar(x: [(); 7])` as `fn bar(x: *const ())`.\n-            // This transformed type is wrong, but these function types are\n-            // already inaccurate due to ABI adjustments (see #42800).\n-            signature.extend(inputs.iter().map(|&t| {\n-                let t = match t.sty {\n-                    ty::Array(ct, _)\n-                        if (ct == cx.tcx.types.u8) || cx.layout_of(ct).is_zst() => {\n-                        cx.tcx.mk_imm_ptr(ct)\n-                    }\n-                    _ => t\n-                };\n-                Some(type_metadata(cx, t, syntax_pos::DUMMY_SP))\n-            }));\n-        } else {\n-            signature.extend(inputs.iter().map(|t| {\n-                Some(type_metadata(cx, t, syntax_pos::DUMMY_SP))\n-            }));\n-        }\n+            // Arguments types\n+            if cx.sess().target.target.options.is_like_msvc {\n+                // FIXME(#42800):\n+                // There is a bug in MSDIA that leads to a crash when it encounters\n+                // a fixed-size array of `u8` or something zero-sized in a\n+                // function-type (see #40477).\n+                // As a workaround, we replace those fixed-size arrays with a\n+                // pointer-type. So a function `fn foo(a: u8, b: [u8; 4])` would\n+                // appear as `fn foo(a: u8, b: *const u8)` in debuginfo,\n+                // and a function `fn bar(x: [(); 7])` as `fn bar(x: *const ())`.\n+                // This transformed type is wrong, but these function types are\n+                // already inaccurate due to ABI adjustments (see #42800).\n+                signature.extend(inputs.iter().map(|&t| {\n+                    let t = match t.sty {\n+                        ty::Array(ct, _)\n+                            if (ct == cx.tcx.types.u8) || cx.layout_of(ct).is_zst() => {\n+                            cx.tcx.mk_imm_ptr(ct)\n+                        }\n+                        _ => t\n+                    };\n+                    Some(type_metadata(cx, t, syntax_pos::DUMMY_SP))\n+                }));\n+            } else {\n+                signature.extend(inputs.iter().map(|t| {\n+                    Some(type_metadata(cx, t, syntax_pos::DUMMY_SP))\n+                }));\n+            }\n \n-        if sig.abi == Abi::RustCall && !sig.inputs().is_empty() {\n-            if let ty::Tuple(args) = sig.inputs()[sig.inputs().len() - 1].sty {\n-                signature.extend(\n-                    args.iter().map(|argument_type| {\n-                        Some(type_metadata(cx, argument_type, syntax_pos::DUMMY_SP))\n-                    })\n-                );\n+            if sig.abi == Abi::RustCall && !sig.inputs().is_empty() {\n+                if let ty::Tuple(args) = sig.inputs()[sig.inputs().len() - 1].sty {\n+                    signature.extend(\n+                        args.iter().map(|argument_type| {\n+                            Some(type_metadata(cx, argument_type, syntax_pos::DUMMY_SP))\n+                        })\n+                    );\n+                }\n             }\n+\n+            create_DIArray(DIB(cx), &signature[..])\n         }\n \n-        create_DIArray(DIB(cx), &signature[..])\n-    }\n+        fn get_template_parameters<'ll, 'tcx>(\n+            cx: &CodegenCx<'ll, 'tcx>,\n+            generics: &ty::Generics,\n+            substs: &Substs<'tcx>,\n+            file_metadata: &'ll DIFile,\n+            name_to_append_suffix_to: &mut String,\n+        ) -> &'ll DIArray {\n+            if substs.types().next().is_none() {\n+                return create_DIArray(DIB(cx), &[]);\n+            }\n \n-    fn get_template_parameters(\n-        cx: &CodegenCx<'ll, 'tcx>,\n-        generics: &ty::Generics,\n-        substs: &Substs<'tcx>,\n-        file_metadata: &'ll DIFile,\n-        name_to_append_suffix_to: &mut String,\n-    ) -> &'ll DIArray {\n-        if substs.types().next().is_none() {\n-            return create_DIArray(DIB(cx), &[]);\n-        }\n+            name_to_append_suffix_to.push('<');\n+            for (i, actual_type) in substs.types().enumerate() {\n+                if i != 0 {\n+                    name_to_append_suffix_to.push_str(\",\");\n+                }\n \n-        name_to_append_suffix_to.push('<');\n-        for (i, actual_type) in substs.types().enumerate() {\n-            if i != 0 {\n-                name_to_append_suffix_to.push_str(\",\");\n+                let actual_type =\n+                    cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), actual_type);\n+                // Add actual type name to <...> clause of function name\n+                let actual_type_name = compute_debuginfo_type_name(cx,\n+                                                                   actual_type,\n+                                                                   true);\n+                name_to_append_suffix_to.push_str(&actual_type_name[..]);\n             }\n+            name_to_append_suffix_to.push('>');\n+\n+            // Again, only create type information if full debuginfo is enabled\n+            let template_params: Vec<_> = if cx.sess().opts.debuginfo == DebugInfo::Full {\n+                let names = get_parameter_names(cx, generics);\n+                substs.iter().zip(names).filter_map(|(kind, name)| {\n+                    if let UnpackedKind::Type(ty) = kind.unpack() {\n+                        let actual_type =\n+                            cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n+                        let actual_type_metadata =\n+                            type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n+                        let name = SmallCStr::new(&name.as_str());\n+                        Some(unsafe {\n+                            Some(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n+                                DIB(cx),\n+                                None,\n+                                name.as_ptr(),\n+                                actual_type_metadata,\n+                                file_metadata,\n+                                0,\n+                                0,\n+                            ))\n+                        })\n+                    } else {\n+                        None\n+                    }\n+                }).collect()\n+            } else {\n+                vec![]\n+            };\n+\n+            return create_DIArray(DIB(cx), &template_params[..]);\n+        }\n \n-            let actual_type = cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), actual_type);\n-            // Add actual type name to <...> clause of function name\n-            let actual_type_name = compute_debuginfo_type_name(cx,\n-                                                               actual_type,\n-                                                               true);\n-            name_to_append_suffix_to.push_str(&actual_type_name[..]);\n+        fn get_parameter_names(cx: &CodegenCx,\n+                               generics: &ty::Generics)\n+                               -> Vec<InternedString> {\n+            let mut names = generics.parent.map_or(vec![], |def_id| {\n+                get_parameter_names(cx, cx.tcx.generics_of(def_id))\n+            });\n+            names.extend(generics.params.iter().map(|param| param.name));\n+            names\n         }\n-        name_to_append_suffix_to.push('>');\n-\n-        // Again, only create type information if full debuginfo is enabled\n-        let template_params: Vec<_> = if cx.sess().opts.debuginfo == DebugInfo::Full {\n-            let names = get_parameter_names(cx, generics);\n-            substs.iter().zip(names).filter_map(|(kind, name)| {\n-                if let UnpackedKind::Type(ty) = kind.unpack() {\n-                    let actual_type = cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n-                    let actual_type_metadata =\n-                        type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n-                    let name = SmallCStr::new(&name.as_str());\n-                    Some(unsafe {\n-                        Some(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n-                            DIB(cx),\n-                            None,\n-                            name.as_ptr(),\n-                            actual_type_metadata,\n-                            file_metadata,\n-                            0,\n-                            0,\n-                        ))\n-                    })\n+\n+        fn get_containing_scope<'ll, 'tcx>(\n+            cx: &CodegenCx<'ll, 'tcx>,\n+            instance: Instance<'tcx>,\n+        ) -> &'ll DIScope {\n+            // First, let's see if this is a method within an inherent impl. Because\n+            // if yes, we want to make the result subroutine DIE a child of the\n+            // subroutine's self-type.\n+            let self_type = cx.tcx.impl_of_method(instance.def_id()).and_then(|impl_def_id| {\n+                // If the method does *not* belong to a trait, proceed\n+                if cx.tcx.trait_id_of_impl(impl_def_id).is_none() {\n+                    let impl_self_ty = cx.tcx.subst_and_normalize_erasing_regions(\n+                        instance.substs,\n+                        ty::ParamEnv::reveal_all(),\n+                        &cx.tcx.type_of(impl_def_id),\n+                    );\n+\n+                    // Only \"class\" methods are generally understood by LLVM,\n+                    // so avoid methods on other types (e.g. `<*mut T>::null`).\n+                    match impl_self_ty.sty {\n+                        ty::Adt(def, ..) if !def.is_box() => {\n+                            Some(type_metadata(cx, impl_self_ty, syntax_pos::DUMMY_SP))\n+                        }\n+                        _ => None\n+                    }\n                 } else {\n+                    // For trait method impls we still use the \"parallel namespace\"\n+                    // strategy\n                     None\n                 }\n-            }).collect()\n-        } else {\n-            vec![]\n-        };\n-\n-        create_DIArray(DIB(cx), &template_params[..])\n+            });\n+\n+            self_type.unwrap_or_else(|| {\n+                namespace::item_namespace(cx, DefId {\n+                    krate: instance.def_id().krate,\n+                    index: cx.tcx\n+                             .def_key(instance.def_id())\n+                             .parent\n+                             .expect(\"get_containing_scope: missing parent?\")\n+                })\n+            })\n+        }\n     }\n \n-    fn get_parameter_names(cx: &CodegenCx,\n-                           generics: &ty::Generics)\n-                           -> Vec<InternedString> {\n-        let mut names = generics.parent.map_or(vec![], |def_id| {\n-            get_parameter_names(cx, cx.tcx.generics_of(def_id))\n-        });\n-        names.extend(generics.params.iter().map(|param| param.name));\n-        names\n+    fn create_vtable_metadata(\n+        &self,\n+        ty: Ty<'tcx>,\n+        vtable: Self::Value,\n+    ) {\n+        metadata::create_vtable_metadata(self, ty, vtable)\n     }\n \n-    fn get_containing_scope(\n-        cx: &CodegenCx<'ll, 'tcx>,\n-        instance: Instance<'tcx>,\n-    ) -> &'ll DIScope {\n-        // First, let's see if this is a method within an inherent impl. Because\n-        // if yes, we want to make the result subroutine DIE a child of the\n-        // subroutine's self-type.\n-        let self_type = cx.tcx.impl_of_method(instance.def_id()).and_then(|impl_def_id| {\n-            // If the method does *not* belong to a trait, proceed\n-            if cx.tcx.trait_id_of_impl(impl_def_id).is_none() {\n-                let impl_self_ty = cx.tcx.subst_and_normalize_erasing_regions(\n-                    instance.substs,\n-                    ty::ParamEnv::reveal_all(),\n-                    &cx.tcx.type_of(impl_def_id),\n-                );\n-\n-                // Only \"class\" methods are generally understood by LLVM,\n-                // so avoid methods on other types (e.g. `<*mut T>::null`).\n-                match impl_self_ty.sty {\n-                    ty::Adt(def, ..) if !def.is_box() => {\n-                        Some(type_metadata(cx, impl_self_ty, syntax_pos::DUMMY_SP))\n-                    }\n-                    _ => None\n-                }\n-            } else {\n-                // For trait method impls we still use the \"parallel namespace\"\n-                // strategy\n-                None\n-            }\n-        });\n-\n-        self_type.unwrap_or_else(|| {\n-            namespace::item_namespace(cx, DefId {\n-                krate: instance.def_id().krate,\n-                index: cx.tcx\n-                         .def_key(instance.def_id())\n-                         .parent\n-                         .expect(\"get_containing_scope: missing parent?\")\n-            })\n-        })\n+    fn create_mir_scopes(\n+        &self,\n+        mir: &mir::Mir,\n+        debug_context: &FunctionDebugContext<&'ll DISubprogram>,\n+    ) -> IndexVec<mir::SourceScope, MirDebugScope<&'ll DIScope>> {\n+        create_scope_map::create_mir_scopes(self, mir, debug_context)\n     }\n-}\n \n-pub fn declare_local(\n-    bx: &Builder<'a, 'll, 'tcx>,\n-    dbg_context: &FunctionDebugContext<'ll>,\n-    variable_name: ast::Name,\n-    variable_type: Ty<'tcx>,\n-    scope_metadata: &'ll DIScope,\n-    variable_access: VariableAccess<'_, 'll>,\n-    variable_kind: VariableKind,\n-    span: Span,\n-) {\n-    assert!(!dbg_context.get_ref(span).source_locations_enabled.get());\n-    let cx = bx.cx();\n-\n-    let file = span_start(cx, span).file;\n-    let file_metadata = file_metadata(cx,\n-                                      &file.name,\n-                                      dbg_context.get_ref(span).defining_crate);\n-\n-    let loc = span_start(cx, span);\n-    let type_metadata = type_metadata(cx, variable_type, span);\n-\n-    let (argument_index, dwarf_tag) = match variable_kind {\n-        ArgumentVariable(index) => (index as c_uint, DW_TAG_arg_variable),\n-        LocalVariable => (0, DW_TAG_auto_variable)\n-    };\n-    let align = cx.align_of(variable_type);\n-\n-    let name = SmallCStr::new(&variable_name.as_str());\n-    match (variable_access, &[][..]) {\n-        (DirectVariable { alloca }, address_operations) |\n-        (IndirectVariable {alloca, address_operations}, _) => {\n-            let metadata = unsafe {\n-                llvm::LLVMRustDIBuilderCreateVariable(\n-                    DIB(cx),\n-                    dwarf_tag,\n-                    scope_metadata,\n-                    name.as_ptr(),\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    type_metadata,\n-                    cx.sess().opts.optimize != config::OptLevel::No,\n-                    DIFlags::FlagZero,\n-                    argument_index,\n-                    align.abi() as u32,\n-                )\n-            };\n-            source_loc::set_debug_location(bx,\n-                InternalDebugLocation::new(scope_metadata, loc.line, loc.col.to_usize()));\n-            unsafe {\n-                let debug_loc = llvm::LLVMGetCurrentDebugLocation(bx.llbuilder);\n-                let instr = llvm::LLVMRustDIBuilderInsertDeclareAtEnd(\n-                    DIB(cx),\n-                    alloca,\n-                    metadata,\n-                    address_operations.as_ptr(),\n-                    address_operations.len() as c_uint,\n-                    debug_loc,\n-                    bx.llbb());\n-\n-                llvm::LLVMSetInstDebugLocation(bx.llbuilder, instr);\n-            }\n-            source_loc::set_debug_location(bx, UnknownLocation);\n-        }\n+    fn extend_scope_to_file(\n+        &self,\n+        scope_metadata: &'ll DIScope,\n+        file: &syntax_pos::SourceFile,\n+        defining_crate: CrateNum,\n+    ) -> &'ll DILexicalBlock {\n+        metadata::extend_scope_to_file(&self, scope_metadata, file, defining_crate)\n     }\n }"}, {"sha": "514649290e2fb487ffed50c88b7bcbc86defb0de", "filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -17,16 +17,16 @@ use super::FunctionDebugContext;\n use llvm;\n use llvm::debuginfo::DIScope;\n use builder::Builder;\n-use interfaces::BuilderMethods;\n+use interfaces::*;\n \n use libc::c_uint;\n use syntax_pos::{Span, Pos};\n \n /// Sets the current debug location at the beginning of the span.\n ///\n /// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...).\n-pub fn set_source_location(\n-    debug_context: &FunctionDebugContext<'ll>,\n+pub fn set_source_location<D>(\n+    debug_context: &FunctionDebugContext<D>,\n     bx: &Builder<'_, 'll, '_>,\n     scope: Option<&'ll DIScope>,\n     span: Span,\n@@ -41,7 +41,7 @@ pub fn set_source_location(\n     };\n \n     let dbg_loc = if function_debug_context.source_locations_enabled.get() {\n-        debug!(\"set_source_location: {}\", bx.sess().source_map().span_to_string(span));\n+        debug!(\"set_source_location: {}\", bx.cx().sess().source_map().span_to_string(span));\n         let loc = span_start(bx.cx(), span);\n         InternalDebugLocation::new(scope.unwrap(), loc.line, loc.col.to_usize())\n     } else {\n@@ -56,7 +56,7 @@ pub fn set_source_location(\n /// they are disabled when beginning to codegen a new function. This functions\n /// switches source location emitting on and must therefore be called before the\n /// first real statement/expression of the function is codegened.\n-pub fn start_emitting_source_locations(dbg_context: &FunctionDebugContext<'ll>) {\n+pub fn start_emitting_source_locations<D>(dbg_context: &FunctionDebugContext<D>) {\n     if let FunctionDebugContext::RegularContext(ref data) = *dbg_context {\n         data.source_locations_enabled.set(true);\n     }"}, {"sha": "5fbeb2124ac37a32c12684acab1728f6817b0f3f", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -14,6 +14,7 @@ use common::CodegenCx;\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n+use interfaces::*;\n \n use rustc::hir;\n "}, {"sha": "2d1ec840882cd3a1cce4293eaa148310f250c53f", "filename": "src/librustc_codegen_llvm/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -19,6 +19,7 @@ use rustc::ty::DefIdTree;\n use llvm;\n use llvm::debuginfo::{DIScope, DIBuilder, DIDescriptor, DIArray};\n use common::{CodegenCx};\n+use interfaces::*;\n \n use syntax_pos::{self, Span};\n "}, {"sha": "ef13f2be8a919b6c0bd12c6298a324a068fc404a", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 128, "deletions": 120, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -23,30 +23,17 @@\n use llvm;\n use llvm::AttributePlace::Function;\n use rustc::ty::{self, PolyFnSig};\n-use rustc::ty::layout::LayoutOf;\n+use rustc::ty::layout::{self, LayoutOf};\n use rustc::session::config::Sanitizer;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_target::spec::PanicStrategy;\n use abi::{Abi, FnType, FnTypeExt};\n use attributes;\n use context::CodegenCx;\n use type_::Type;\n+use interfaces::*;\n use value::Value;\n \n-\n-/// Declare a global value.\n-///\n-/// If there\u2019s a value with the same name already declared, the function will\n-/// return its Value instead.\n-pub fn declare_global(cx: &CodegenCx<'ll, '_>, name: &str, ty: &'ll Type) -> &'ll Value {\n-    debug!(\"declare_global(name={:?})\", name);\n-    let namebuf = SmallCStr::new(name);\n-    unsafe {\n-        llvm::LLVMRustGetOrInsertGlobal(cx.llmod, namebuf.as_ptr(), ty)\n-    }\n-}\n-\n-\n /// Declare a function.\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n@@ -108,127 +95,148 @@ fn declare_raw_fn(\n     llfn\n }\n \n+impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+\n+    /// Declare a global value.\n+    ///\n+    /// If there\u2019s a value with the same name already declared, the function will\n+    /// return its Value instead.\n+    fn declare_global(\n+        &self,\n+        name: &str, ty: &'ll Type\n+    ) -> &'ll Value {\n+        debug!(\"declare_global(name={:?})\", name);\n+        let namebuf = SmallCStr::new(name);\n+        unsafe {\n+            llvm::LLVMRustGetOrInsertGlobal(self.llmod, namebuf.as_ptr(), ty)\n+        }\n+    }\n \n-/// Declare a C ABI function.\n-///\n-/// Only use this for foreign function ABIs and glue. For Rust functions use\n-/// `declare_fn` instead.\n-///\n-/// If there\u2019s a value with the same name already declared, the function will\n-/// update the declaration and return existing Value instead.\n-pub fn declare_cfn(\n-    cx: &CodegenCx<'ll, '_>,\n-    name: &str,\n-    fn_type: &'ll Type\n-) -> &'ll Value {\n-    declare_raw_fn(cx, name, llvm::CCallConv, fn_type)\n-}\n+    /// Declare a C ABI function.\n+    ///\n+    /// Only use this for foreign function ABIs and glue. For Rust functions use\n+    /// `declare_fn` instead.\n+    ///\n+    /// If there\u2019s a value with the same name already declared, the function will\n+    /// update the declaration and return existing Value instead.\n+    fn declare_cfn(\n+        &self,\n+        name: &str,\n+        fn_type: &'ll Type\n+    ) -> &'ll Value {\n+        declare_raw_fn(self, name, llvm::CCallConv, fn_type)\n+    }\n \n \n-/// Declare a Rust function.\n-///\n-/// If there\u2019s a value with the same name already declared, the function will\n-/// update the declaration and return existing Value instead.\n-pub fn declare_fn(\n-    cx: &CodegenCx<'ll, 'tcx>,\n-    name: &str,\n-    sig: PolyFnSig<'tcx>,\n-) -> &'ll Value {\n-    debug!(\"declare_rust_fn(name={:?}, sig={:?})\", name, sig);\n-    let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n-    debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n+    /// Declare a Rust function.\n+    ///\n+    /// If there\u2019s a value with the same name already declared, the function will\n+    /// update the declaration and return existing Value instead.\n+    fn declare_fn(\n+        &self,\n+        name: &str,\n+        sig: PolyFnSig<'tcx>,\n+    ) -> &'ll Value {\n+        debug!(\"declare_rust_fn(name={:?}, sig={:?})\", name, sig);\n+        let sig = self.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+        debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n+\n+        let fty = FnType::new(self, sig, &[]);\n+        let llfn = declare_raw_fn(self, name, fty.llvm_cconv(), fty.llvm_type(self));\n+\n+        if self.layout_of(sig.output()).abi == layout::Abi::Uninhabited {\n+            llvm::Attribute::NoReturn.apply_llfn(Function, llfn);\n+        }\n \n-    let fty = FnType::new(cx, sig, &[]);\n-    let llfn = declare_raw_fn(cx, name, fty.llvm_cconv(), fty.llvm_type(cx));\n+        if sig.abi != Abi::Rust && sig.abi != Abi::RustCall {\n+            attributes::unwind(llfn, false);\n+        }\n \n-    if cx.layout_of(sig.output()).abi.is_uninhabited() {\n-        llvm::Attribute::NoReturn.apply_llfn(Function, llfn);\n-    }\n+        fty.apply_attrs_llfn(llfn);\n \n-    if sig.abi != Abi::Rust && sig.abi != Abi::RustCall {\n-        attributes::unwind(llfn, false);\n+        llfn\n     }\n \n-    fty.apply_attrs_llfn(llfn);\n \n-    llfn\n-}\n-\n-\n-/// Declare a global with an intention to define it.\n-///\n-/// Use this function when you intend to define a global. This function will\n-/// return None if the name already has a definition associated with it. In that\n-/// case an error should be reported to the user, because it usually happens due\n-/// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n-pub fn define_global(cx: &CodegenCx<'ll, '_>, name: &str, ty: &'ll Type) -> Option<&'ll Value> {\n-    if get_defined_value(cx, name).is_some() {\n-        None\n-    } else {\n-        Some(declare_global(cx, name, ty))\n+    /// Declare a global with an intention to define it.\n+    ///\n+    /// Use this function when you intend to define a global. This function will\n+    /// return None if the name already has a definition associated with it. In that\n+    /// case an error should be reported to the user, because it usually happens due\n+    /// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n+    fn define_global(\n+        &self,\n+        name: &str,\n+        ty: &'ll Type\n+    ) -> Option<&'ll Value> {\n+        if self.get_defined_value(name).is_some() {\n+            None\n+        } else {\n+            Some(self.declare_global(name, ty))\n+        }\n     }\n-}\n \n-/// Declare a private global\n-///\n-/// Use this function when you intend to define a global without a name.\n-pub fn define_private_global(cx: &CodegenCx<'ll, '_>, ty: &'ll Type) -> &'ll Value {\n-    unsafe {\n-        llvm::LLVMRustInsertPrivateGlobal(cx.llmod, ty)\n+    /// Declare a private global\n+    ///\n+    /// Use this function when you intend to define a global without a name.\n+    fn define_private_global(&self, ty: &'ll Type) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMRustInsertPrivateGlobal(self.llmod, ty)\n+        }\n     }\n-}\n \n-/// Declare a Rust function with an intention to define it.\n-///\n-/// Use this function when you intend to define a function. This function will\n-/// return panic if the name already has a definition associated with it. This\n-/// can happen with #[no_mangle] or #[export_name], for example.\n-pub fn define_fn(\n-    cx: &CodegenCx<'ll, 'tcx>,\n-    name: &str,\n-    fn_sig: PolyFnSig<'tcx>,\n-) -> &'ll Value {\n-    if get_defined_value(cx, name).is_some() {\n-        cx.sess().fatal(&format!(\"symbol `{}` already defined\", name))\n-    } else {\n-        declare_fn(cx, name, fn_sig)\n+    /// Declare a Rust function with an intention to define it.\n+    ///\n+    /// Use this function when you intend to define a function. This function will\n+    /// return panic if the name already has a definition associated with it. This\n+    /// can happen with #[no_mangle] or #[export_name], for example.\n+    fn define_fn(\n+        &self,\n+        name: &str,\n+        fn_sig: PolyFnSig<'tcx>,\n+    ) -> &'ll Value {\n+        if self.get_defined_value(name).is_some() {\n+            self.sess().fatal(&format!(\"symbol `{}` already defined\", name))\n+        } else {\n+            self.declare_fn(name, fn_sig)\n+        }\n     }\n-}\n \n-/// Declare a Rust function with an intention to define it.\n-///\n-/// Use this function when you intend to define a function. This function will\n-/// return panic if the name already has a definition associated with it. This\n-/// can happen with #[no_mangle] or #[export_name], for example.\n-pub fn define_internal_fn(\n-    cx: &CodegenCx<'ll, 'tcx>,\n-    name: &str,\n-    fn_sig: PolyFnSig<'tcx>,\n-) -> &'ll Value {\n-    let llfn = define_fn(cx, name, fn_sig);\n-    unsafe { llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::InternalLinkage) };\n-    llfn\n-}\n+    /// Declare a Rust function with an intention to define it.\n+    ///\n+    /// Use this function when you intend to define a function. This function will\n+    /// return panic if the name already has a definition associated with it. This\n+    /// can happen with #[no_mangle] or #[export_name], for example.\n+    fn define_internal_fn(\n+        &self,\n+        name: &str,\n+        fn_sig: PolyFnSig<'tcx>,\n+    ) -> &'ll Value {\n+        let llfn = self.define_fn(name, fn_sig);\n+        unsafe { llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::InternalLinkage) };\n+        llfn\n+    }\n \n \n-/// Get declared value by name.\n-pub fn get_declared_value(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Value> {\n-    debug!(\"get_declared_value(name={:?})\", name);\n-    let namebuf = SmallCStr::new(name);\n-    unsafe { llvm::LLVMRustGetNamedValue(cx.llmod, namebuf.as_ptr()) }\n-}\n+    /// Get declared value by name.\n+    fn get_declared_value(&self, name: &str) -> Option<&'ll Value> {\n+        debug!(\"get_declared_value(name={:?})\", name);\n+        let namebuf = SmallCStr::new(name);\n+        unsafe { llvm::LLVMRustGetNamedValue(self.llmod, namebuf.as_ptr()) }\n+    }\n \n-/// Get defined or externally defined (AvailableExternally linkage) value by\n-/// name.\n-pub fn get_defined_value(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Value> {\n-    get_declared_value(cx, name).and_then(|val|{\n-        let declaration = unsafe {\n-            llvm::LLVMIsDeclaration(val) != 0\n-        };\n-        if !declaration {\n-            Some(val)\n-        } else {\n-            None\n-        }\n-    })\n+    /// Get defined or externally defined (AvailableExternally linkage) value by\n+    /// name.\n+    fn get_defined_value(&self, name: &str) -> Option<&'ll Value> {\n+        self.get_declared_value(name).and_then(|val|{\n+            let declaration = unsafe {\n+                llvm::LLVMIsDeclaration(val) != 0\n+            };\n+            if !declaration {\n+                Some(val)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n }"}, {"sha": "528599e9690af43cc447a762bda4d9ae78cc5339", "filename": "src/librustc_codegen_llvm/interfaces/abi.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fabi.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::HasCodegen;\n+use abi::FnType;\n+use rustc::ty::{FnSig, Instance, Ty};\n+\n+pub trait AbiMethods<'tcx> {\n+    fn new_fn_type(&self, sig: FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> FnType<'tcx, Ty<'tcx>>;\n+    fn new_vtable(&self, sig: FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> FnType<'tcx, Ty<'tcx>>;\n+    fn fn_type_of_instance(&self, instance: &Instance<'tcx>) -> FnType<'tcx, Ty<'tcx>>;\n+}\n+\n+pub trait AbiBuilderMethods<'tcx>: HasCodegen<'tcx> {\n+    fn apply_attrs_callsite(&self, ty: &FnType<'tcx, Ty<'tcx>>, callsite: Self::Value);\n+}"}, {"sha": "155eceffb05c658718bf2d4be9fcc3dbe8b997e6", "filename": "src/librustc_codegen_llvm/interfaces/asm.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fasm.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::backend::Backend;\n+use super::HasCodegen;\n+use mir::place::PlaceRef;\n+use rustc::hir::{GlobalAsm, InlineAsm};\n+\n+pub trait AsmBuilderMethods<'tcx>: HasCodegen<'tcx> {\n+    fn codegen_inline_asm(\n+        &self,\n+        ia: &InlineAsm,\n+        outputs: Vec<PlaceRef<'tcx, Self::Value>>,\n+        inputs: Vec<Self::Value>,\n+    ) -> bool;\n+}\n+\n+pub trait AsmMethods<'tcx>: Backend<'tcx> {\n+    fn codegen_global_asm(&self, ga: &GlobalAsm);\n+}"}, {"sha": "7e95cb248045a938678d98d7e81352dc7df13ebd", "filename": "src/librustc_codegen_llvm/interfaces/backend.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbackend.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -15,9 +15,11 @@ use super::CodegenObject;\n \n pub trait BackendTypes {\n     type Value: CodegenObject;\n-    type BasicBlock;\n+    type BasicBlock: Copy;\n     type Type: CodegenObject;\n     type Context;\n+\n+    type DIScope: Copy;\n }\n \n pub trait Backend<'tcx>:"}, {"sha": "926550355bf7603b57e6dd7257eb5486ee4f1493", "filename": "src/librustc_codegen_llvm/interfaces/builder.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbuilder.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -8,25 +8,35 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use super::abi::AbiBuilderMethods;\n+use super::asm::AsmBuilderMethods;\n+use super::debuginfo::DebugInfoBuilderMethods;\n+use super::intrinsic::IntrinsicCallMethods;\n+use super::type_::ArgTypeMethods;\n use super::HasCodegen;\n use builder::MemFlags;\n use common::*;\n use libc::c_char;\n use mir::operand::OperandRef;\n use mir::place::PlaceRef;\n-use rustc::session::Session;\n use rustc::ty::layout::{Align, Size};\n \n use std::borrow::Cow;\n use std::ops::Range;\n use syntax::ast::AsmDialect;\n \n-pub trait BuilderMethods<'a, 'tcx: 'a>: HasCodegen<'tcx> {\n+pub trait BuilderMethods<'a, 'tcx: 'a>:\n+    HasCodegen<'tcx>\n+    + DebugInfoBuilderMethods<'tcx>\n+    + ArgTypeMethods<'tcx>\n+    + AbiBuilderMethods<'tcx>\n+    + IntrinsicCallMethods<'tcx>\n+    + AsmBuilderMethods<'tcx>\n+{\n     fn new_block<'b>(cx: &'a Self::CodegenCx, llfn: Self::Value, name: &'b str) -> Self;\n     fn with_cx(cx: &'a Self::CodegenCx) -> Self;\n     fn build_sibling_block<'b>(&self, name: &'b str) -> Self;\n-    fn sess(&self) -> &Session;\n-    fn cx(&self) -> &'a Self::CodegenCx; // FIXME(eddyb) remove 'a\n+    fn cx(&self) -> &Self::CodegenCx;\n     fn llfn(&self) -> Self::Value;\n     fn llbb(&self) -> Self::BasicBlock;\n     fn count_insn(&self, category: &str);\n@@ -45,7 +55,7 @@ pub trait BuilderMethods<'a, 'tcx: 'a>: HasCodegen<'tcx> {\n         args: &[Self::Value],\n         then: Self::BasicBlock,\n         catch: Self::BasicBlock,\n-        bundle: Option<&OperandBundleDef<Self::Value>>,\n+        funclet: Option<&Funclet<Self::Value>>,\n     ) -> Self::Value;\n     fn unreachable(&self);\n     fn add(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n@@ -252,7 +262,10 @@ pub trait BuilderMethods<'a, 'tcx: 'a>: HasCodegen<'tcx> {\n         &self,\n         llfn: Self::Value,\n         args: &[Self::Value],\n-        bundle: Option<&OperandBundleDef<Self::Value>>,\n+        funclet: Option<&Funclet<Self::Value>>,\n     ) -> Self::Value;\n     fn zext(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n+\n+    fn delete_basic_block(&self, bb: Self::BasicBlock);\n+    fn do_not_inline(&self, llret: Self::Value);\n }"}, {"sha": "4070e8b8d6d303ba512d709104c8dd6407d336e7", "filename": "src/librustc_codegen_llvm/interfaces/consts.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fconsts.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -9,6 +9,10 @@\n // except according to those terms.\n \n use super::Backend;\n+use mir::place::PlaceRef;\n+use rustc::mir::interpret::Allocation;\n+use rustc::mir::interpret::Scalar;\n+use rustc::ty::layout;\n use syntax::symbol::LocalInternedString;\n \n pub trait ConstMethods<'tcx>: Backend<'tcx> {\n@@ -39,4 +43,17 @@ pub trait ConstMethods<'tcx>: Backend<'tcx> {\n \n     fn is_const_integral(&self, v: Self::Value) -> bool;\n     fn is_const_real(&self, v: Self::Value) -> bool;\n+\n+    fn scalar_to_backend(\n+        &self,\n+        cv: Scalar,\n+        layout: &layout::Scalar,\n+        llty: Self::Type,\n+    ) -> Self::Value;\n+    fn from_const_alloc(\n+        &self,\n+        layout: layout::TyLayout<'tcx>,\n+        alloc: &Allocation,\n+        offset: layout::Size,\n+    ) -> PlaceRef<'tcx, Self::Value>;\n }"}, {"sha": "9b583e9c753963d2bbec70a12ab4d19cb82e1df0", "filename": "src/librustc_codegen_llvm/interfaces/debuginfo.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fdebuginfo.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -9,8 +9,53 @@\n // except according to those terms.\n \n use super::backend::Backend;\n-use rustc::ty::Ty;\n+use super::HasCodegen;\n+use debuginfo::{FunctionDebugContext, MirDebugScope, VariableAccess, VariableKind};\n+use monomorphize::Instance;\n+use rustc::hir::def_id::CrateNum;\n+use rustc::mir;\n+use rustc::ty::{self, Ty};\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use syntax::ast::Name;\n+use syntax_pos::{SourceFile, Span};\n \n pub trait DebugInfoMethods<'tcx>: Backend<'tcx> {\n     fn create_vtable_metadata(&self, ty: Ty<'tcx>, vtable: Self::Value);\n+    fn create_function_debug_context(\n+        &self,\n+        instance: Instance<'tcx>,\n+        sig: ty::FnSig<'tcx>,\n+        llfn: Self::Value,\n+        mir: &mir::Mir,\n+    ) -> FunctionDebugContext<Self::DIScope>;\n+    fn create_mir_scopes(\n+        &self,\n+        mir: &mir::Mir,\n+        debug_context: &FunctionDebugContext<Self::DIScope>,\n+    ) -> IndexVec<mir::SourceScope, MirDebugScope<Self::DIScope>>;\n+    fn extend_scope_to_file(\n+        &self,\n+        scope_metadata: Self::DIScope,\n+        file: &SourceFile,\n+        defining_crate: CrateNum,\n+    ) -> Self::DIScope;\n+}\n+\n+pub trait DebugInfoBuilderMethods<'tcx>: HasCodegen<'tcx> {\n+    fn declare_local(\n+        &self,\n+        dbg_context: &FunctionDebugContext<Self::DIScope>,\n+        variable_name: Name,\n+        variable_type: Ty<'tcx>,\n+        scope_metadata: Self::DIScope,\n+        variable_access: VariableAccess<'_, Self::Value>,\n+        variable_kind: VariableKind,\n+        span: Span,\n+    );\n+    fn set_source_location(\n+        &self,\n+        debug_context: &FunctionDebugContext<Self::DIScope>,\n+        scope: Option<Self::DIScope>,\n+        span: Span,\n+    );\n }"}, {"sha": "d8a7382e45ff22c4a2791f6b28896beb3769d21a", "filename": "src/librustc_codegen_llvm/interfaces/declare.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fdeclare.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::backend::Backend;\n+use rustc::ty;\n+\n+pub trait DeclareMethods<'tcx>: Backend<'tcx> {\n+    fn declare_global(&self, name: &str, ty: Self::Type) -> Self::Value;\n+    fn declare_cfn(&self, name: &str, fn_type: Self::Type) -> Self::Value;\n+    fn declare_fn(&self, name: &str, sig: ty::PolyFnSig<'tcx>) -> Self::Value;\n+    fn define_global(&self, name: &str, ty: Self::Type) -> Option<Self::Value>;\n+    fn define_private_global(&self, ty: Self::Type) -> Self::Value;\n+    fn define_fn(&self, name: &str, fn_sig: ty::PolyFnSig<'tcx>) -> Self::Value;\n+    fn define_internal_fn(&self, name: &str, fn_sig: ty::PolyFnSig<'tcx>) -> Self::Value;\n+    fn get_declared_value(&self, name: &str) -> Option<Self::Value>;\n+    fn get_defined_value(&self, name: &str) -> Option<Self::Value>;\n+}"}, {"sha": "e8237ed4a8adc59bebe64fdfa4abfd174a75f605", "filename": "src/librustc_codegen_llvm/interfaces/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fintrinsic.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n use super::backend::Backend;\n-use super::builder::BuilderMethods;\n+use super::HasCodegen;\n use abi::FnType;\n use mir::operand::OperandRef;\n use rustc::ty::Ty;\n use syntax_pos::Span;\n \n-pub trait IntrinsicCallMethods<'a, 'tcx: 'a>: BuilderMethods<'a, 'tcx> {\n+pub trait IntrinsicCallMethods<'tcx>: HasCodegen<'tcx> {\n     fn codegen_intrinsic_call(\n         &self,\n         callee_ty: Ty<'tcx>,"}, {"sha": "eb278a36b09f24e93e5bc07b5d23046a1a5c07ae", "filename": "src/librustc_codegen_llvm/interfaces/misc.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmisc.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n use super::backend::Backend;\n+use libc::c_uint;\n+use rustc::session::Session;\n use rustc::ty::{self, Instance, Ty};\n use rustc::util::nodemap::FxHashMap;\n use std::cell::RefCell;\n@@ -17,5 +19,11 @@ pub trait MiscMethods<'tcx>: Backend<'tcx> {\n     fn vtables(\n         &self,\n     ) -> &RefCell<FxHashMap<(Ty<'tcx>, ty::PolyExistentialTraitRef<'tcx>), Self::Value>>;\n+    fn check_overflow(&self) -> bool;\n+    fn instances(&self) -> &RefCell<FxHashMap<Instance<'tcx>, Self::Value>>;\n     fn get_fn(&self, instance: Instance<'tcx>) -> Self::Value;\n+    fn get_param(&self, llfn: Self::Value, index: c_uint) -> Self::Value;\n+    fn eh_personality(&self) -> Self::Value;\n+    fn eh_unwind_resume(&self) -> Self::Value;\n+    fn sess(&self) -> &Session;\n }"}, {"sha": "d1365fb62a6ab673737a582a67e294baca73c96b", "filename": "src/librustc_codegen_llvm/interfaces/mod.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmod.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -8,23 +8,31 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+mod abi;\n+mod asm;\n mod backend;\n mod builder;\n mod consts;\n mod debuginfo;\n+mod declare;\n mod intrinsic;\n mod misc;\n mod statics;\n mod type_;\n \n+pub use self::abi::{AbiBuilderMethods, AbiMethods};\n+pub use self::asm::{AsmBuilderMethods, AsmMethods};\n pub use self::backend::{Backend, BackendTypes};\n pub use self::builder::BuilderMethods;\n pub use self::consts::ConstMethods;\n-pub use self::debuginfo::DebugInfoMethods;\n+pub use self::debuginfo::{DebugInfoBuilderMethods, DebugInfoMethods};\n+pub use self::declare::DeclareMethods;\n pub use self::intrinsic::{IntrinsicCallMethods, IntrinsicDeclarationMethods};\n pub use self::misc::MiscMethods;\n pub use self::statics::StaticMethods;\n-pub use self::type_::{BaseTypeMethods, DerivedTypeMethods, LayoutTypeMethods, TypeMethods};\n+pub use self::type_::{\n+    ArgTypeMethods, BaseTypeMethods, DerivedTypeMethods, LayoutTypeMethods, TypeMethods,\n+};\n \n use std::fmt;\n \n@@ -35,6 +43,10 @@ pub trait CodegenMethods<'tcx>:\n     + ConstMethods<'tcx>\n     + StaticMethods<'tcx>\n     + DebugInfoMethods<'tcx>\n+    + AbiMethods<'tcx>\n+    + IntrinsicDeclarationMethods<'tcx>\n+    + DeclareMethods<'tcx>\n+    + AsmMethods<'tcx>\n {\n }\n \n@@ -45,6 +57,10 @@ impl<'tcx, T> CodegenMethods<'tcx> for T where\n         + ConstMethods<'tcx>\n         + StaticMethods<'tcx>\n         + DebugInfoMethods<'tcx>\n+        + AbiMethods<'tcx>\n+        + IntrinsicDeclarationMethods<'tcx>\n+        + DeclareMethods<'tcx>\n+        + AsmMethods<'tcx>\n {}\n \n pub trait HasCodegen<'tcx>: Backend<'tcx> {\n@@ -54,6 +70,7 @@ pub trait HasCodegen<'tcx>: Backend<'tcx> {\n             BasicBlock = Self::BasicBlock,\n             Type = Self::Type,\n             Context = Self::Context,\n+            DIScope = Self::DIScope,\n         >;\n }\n "}, {"sha": "7f110d37051eaf6a1bb1ae9a263a2695c0b287e4", "filename": "src/librustc_codegen_llvm/interfaces/type_.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Finterfaces%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Ftype_.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -9,11 +9,14 @@\n // except according to those terms.\n \n use super::backend::Backend;\n+use super::HasCodegen;\n use common::TypeKind;\n+use mir::place::PlaceRef;\n use rustc::ty::layout::TyLayout;\n use rustc::ty::layout::{self, Align, Size};\n use rustc::ty::Ty;\n use rustc::util::nodemap::FxHashMap;\n+use rustc_target::abi::call::{ArgType, CastTarget, FnType, Reg};\n use std::cell::RefCell;\n use syntax::ast;\n \n@@ -70,6 +73,10 @@ pub trait DerivedTypeMethods<'tcx>: Backend<'tcx> {\n \n pub trait LayoutTypeMethods<'tcx>: Backend<'tcx> {\n     fn backend_type(&self, layout: TyLayout<'tcx>) -> Self::Type;\n+    fn cast_backend_type(&self, ty: &CastTarget) -> Self::Type;\n+    fn fn_backend_type(&self, ty: &FnType<'tcx, Ty<'tcx>>) -> Self::Type;\n+    fn fn_ptr_backend_type(&self, ty: &FnType<'tcx, Ty<'tcx>>) -> Self::Type;\n+    fn reg_backend_type(&self, ty: &Reg) -> Self::Type;\n     fn immediate_backend_type(&self, layout: TyLayout<'tcx>) -> Self::Type;\n     fn is_backend_immediate(&self, layout: TyLayout<'tcx>) -> bool;\n     fn scalar_pair_element_backend_type<'a>(\n@@ -80,6 +87,22 @@ pub trait LayoutTypeMethods<'tcx>: Backend<'tcx> {\n     ) -> Self::Type;\n }\n \n+pub trait ArgTypeMethods<'tcx>: HasCodegen<'tcx> {\n+    fn store_fn_arg(\n+        &self,\n+        ty: &ArgType<'tcx, Ty<'tcx>>,\n+        idx: &mut usize,\n+        dst: PlaceRef<'tcx, Self::Value>,\n+    );\n+    fn store_arg_ty(\n+        &self,\n+        ty: &ArgType<'tcx, Ty<'tcx>>,\n+        val: Self::Value,\n+        dst: PlaceRef<'tcx, Self::Value>,\n+    );\n+    fn memory_ty(&self, ty: &ArgType<'tcx, Ty<'tcx>>) -> Self::Type;\n+}\n+\n pub trait TypeMethods<'tcx>:\n     BaseTypeMethods<'tcx> + DerivedTypeMethods<'tcx> + LayoutTypeMethods<'tcx>\n {"}, {"sha": "40a94f51d044eddecff0f0e4ef80ddaa0a3fdd29", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -20,7 +20,6 @@ use mir::operand::{OperandRef, OperandValue};\n use base::*;\n use common::*;\n use context::CodegenCx;\n-use declare;\n use glue;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n@@ -87,7 +86,7 @@ fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Valu\n     Some(cx.get_intrinsic(&llvm_name))\n }\n \n-impl IntrinsicCallMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n+impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     /// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n     /// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n     /// add them to librustc_codegen_llvm/context.rs\n@@ -274,12 +273,12 @@ impl IntrinsicCallMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             },\n             \"volatile_store\" => {\n                 let dst = args[0].deref(cx);\n-                args[1].val.volatile_store(&self, dst);\n+                args[1].val.volatile_store(self, dst);\n                 return;\n             },\n             \"unaligned_volatile_store\" => {\n                 let dst = args[0].deref(cx);\n-                args[1].val.unaligned_volatile_store(&self, dst);\n+                args[1].val.unaligned_volatile_store(self, dst);\n                 return;\n             },\n             \"prefetch_read_data\" | \"prefetch_write_data\" |\n@@ -451,7 +450,7 @@ impl IntrinsicCallMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             },\n \n             \"discriminant_value\" => {\n-                args[0].deref(cx).codegen_get_discr(&self, ret_ty)\n+                args[0].deref(cx).codegen_get_discr(self, ret_ty)\n             }\n \n             name if name.starts_with(\"simd_\") => {\n@@ -600,7 +599,7 @@ impl IntrinsicCallMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n             \"nontemporal_store\" => {\n                 let dst = args[0].deref(cx);\n-                args[1].val.nontemporal_store(&self, dst);\n+                args[1].val.nontemporal_store(self, dst);\n                 return;\n             }\n \n@@ -716,9 +715,10 @@ impl IntrinsicCallMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n                 let val = match intr.definition {\n                     intrinsics::IntrinsicDef::Named(name) => {\n-                        let f = declare::declare_cfn(cx,\n-                                                     name,\n-                                                     cx.type_func(&inputs, outputs));\n+                        let f = cx.declare_cfn(\n+                            name,\n+                            cx.type_func(&inputs, outputs),\n+                        );\n                         self.call(f, &llargs, None)\n                     }\n                 };\n@@ -745,7 +745,7 @@ impl IntrinsicCallMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 let ptr = self.pointercast(result.llval, cx.type_ptr_to(ty.llvm_type(cx)));\n                 self.store(llval, ptr, result.align);\n             } else {\n-                OperandRef::from_immediate_or_packed_pair(&self, llval, result.layout)\n+                OperandRef::from_immediate_or_packed_pair(self, llval, result.layout)\n                     .val.store(self, result);\n             }\n         }\n@@ -801,11 +801,11 @@ fn try_intrinsic(\n     local_ptr: &'ll Value,\n     dest: &'ll Value,\n ) {\n-    if bx.sess().no_landing_pads() {\n+    if bx.cx().sess().no_landing_pads() {\n         bx.call(func, &[data], None);\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n         bx.store(cx.const_null(cx.type_i8p()), dest, ptr_align);\n-    } else if wants_msvc_seh(bx.sess()) {\n+    } else if wants_msvc_seh(bx.cx().sess()) {\n         codegen_msvc_try(bx, cx, func, data, local_ptr, dest);\n     } else {\n         codegen_gnu_try(bx, cx, func, data, local_ptr, dest);\n@@ -1003,7 +1003,7 @@ fn gen_fn<'ll, 'tcx>(\n         hir::Unsafety::Unsafe,\n         Abi::Rust\n     ));\n-    let llfn = declare::define_internal_fn(cx, name, rust_fn_sig);\n+    let llfn = cx.define_internal_fn(name, rust_fn_sig);\n     attributes::from_fn_attrs(cx, llfn, None);\n     let bx = Builder::new_block(cx, llfn, \"entry-block\");\n     codegen(bx);\n@@ -1058,7 +1058,7 @@ fn generic_simd_intrinsic(\n         };\n         ($msg: tt, $($fmt: tt)*) => {\n             span_invalid_monomorphization_error(\n-                bx.sess(), span,\n+                bx.cx().sess(), span,\n                 &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n                          name, $($fmt)*));\n         }\n@@ -1229,7 +1229,7 @@ fn generic_simd_intrinsic(\n             };\n             ($msg: tt, $($fmt: tt)*) => {\n                 span_invalid_monomorphization_error(\n-                    bx.sess(), span,\n+                    bx.cx().sess(), span,\n                     &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n                              name, $($fmt)*));\n             }\n@@ -1447,7 +1447,7 @@ fn generic_simd_intrinsic(\n \n         let llvm_intrinsic = format!(\"llvm.masked.gather.{}.{}\",\n                                      llvm_elem_vec_str, llvm_pointer_vec_str);\n-        let f = declare::declare_cfn(bx.cx(), &llvm_intrinsic,\n+        let f = bx.cx().declare_cfn(&llvm_intrinsic,\n                                      bx.cx().type_func(&[\n                                          llvm_pointer_vec_ty,\n                                          alignment_ty,\n@@ -1549,7 +1549,7 @@ fn generic_simd_intrinsic(\n \n         let llvm_intrinsic = format!(\"llvm.masked.scatter.{}.{}\",\n                                      llvm_elem_vec_str, llvm_pointer_vec_str);\n-        let f = declare::declare_cfn(bx.cx(), &llvm_intrinsic,\n+        let f = bx.cx().declare_cfn(&llvm_intrinsic,\n                                      bx.cx().type_func(&[llvm_elem_vec_ty,\n                                                   llvm_pointer_vec_ty,\n                                                   alignment_ty,"}, {"sha": "2be1c288440a0b663d34e5b6f9d4e0c2863bdd68", "filename": "src/librustc_codegen_llvm/meth.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmeth.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -8,16 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{FnType, FnTypeExt};\n+use abi::FnType;\n use callee;\n-use builder::Builder;\n use monomorphize;\n-use value::Value;\n \n use interfaces::*;\n \n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::HasTyCtxt;\n \n #[derive(Copy, Clone, Debug)]\n pub struct VirtualIndex(u64);\n@@ -31,15 +28,18 @@ impl<'a, 'tcx: 'a> VirtualIndex {\n         VirtualIndex(index as u64 + 3)\n     }\n \n-    pub fn get_fn(self, bx: &Builder<'a, 'll, 'tcx>,\n-                  llvtable: &'ll Value,\n-                  fn_ty: &FnType<'tcx, Ty<'tcx>>) -> &'ll Value {\n+    pub fn get_fn<Bx: BuilderMethods<'a, 'tcx>>(\n+        self,\n+        bx: &Bx,\n+        llvtable: Bx::Value,\n+        fn_ty: &FnType<'tcx, Ty<'tcx>>\n+    ) -> Bx::Value {\n         // Load the data pointer from the object.\n         debug!(\"get_fn({:?}, {:?})\", llvtable, self);\n \n         let llvtable = bx.pointercast(\n             llvtable,\n-            bx.cx().type_ptr_to(fn_ty.ptr_to_llvm_type(bx.cx()))\n+            bx.cx().type_ptr_to(bx.cx().fn_ptr_backend_type(fn_ty))\n         );\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n         let ptr = bx.load("}, {"sha": "9e54330b4ef824a51dceff1979f2d724bcc65c43", "filename": "src/librustc_codegen_llvm/mir/analyze.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -18,13 +18,14 @@ use rustc::mir::{self, Location, TerminatorKind};\n use rustc::mir::visit::{Visitor, PlaceContext, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::traversal;\n use rustc::ty;\n-use rustc::ty::layout::LayoutOf;\n+use rustc::ty::layout::{LayoutOf, HasTyCtxt};\n use type_of::LayoutLlvmExt;\n use super::FunctionCx;\n-use value::Value;\n use interfaces::*;\n \n-pub fn non_ssa_locals(fx: &FunctionCx<'a, 'll, 'tcx, &'ll Value>) -> BitSet<mir::Local> {\n+pub fn non_ssa_locals<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    fx: &FunctionCx<'a, 'tcx, Bx>\n+) -> BitSet<mir::Local> {\n     let mir = fx.mir;\n     let mut analyzer = LocalAnalyzer::new(fx);\n \n@@ -53,17 +54,17 @@ pub fn non_ssa_locals(fx: &FunctionCx<'a, 'll, 'tcx, &'ll Value>) -> BitSet<mir:\n     analyzer.non_ssa_locals\n }\n \n-struct LocalAnalyzer<'mir, 'a: 'mir, 'll: 'a, 'tcx: 'll, V: 'll> {\n-    fx: &'mir FunctionCx<'a, 'll, 'tcx, V>,\n+struct LocalAnalyzer<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> {\n+    fx: &'mir FunctionCx<'a, 'tcx, Bx>,\n     dominators: Dominators<mir::BasicBlock>,\n     non_ssa_locals: BitSet<mir::Local>,\n     // The location of the first visited direct assignment to each\n     // local, or an invalid location (out of bounds `block` index).\n     first_assignment: IndexVec<mir::Local, Location>\n }\n \n-impl LocalAnalyzer<'mir, 'a, 'll, 'tcx, &'ll Value> {\n-    fn new(fx: &'mir FunctionCx<'a, 'll, 'tcx, &'ll Value>) -> Self {\n+impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n+    fn new(fx: &'mir FunctionCx<'a, 'tcx, Bx>) -> Self {\n         let invalid_location =\n             mir::BasicBlock::new(fx.mir.basic_blocks().len()).start_location();\n         let mut analyzer = LocalAnalyzer {\n@@ -104,7 +105,8 @@ impl LocalAnalyzer<'mir, 'a, 'll, 'tcx, &'ll Value> {\n     }\n }\n \n-impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx, &'ll Value> {\n+impl<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n+    for LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n     fn visit_assign(&mut self,\n                     block: mir::BasicBlock,\n                     place: &mir::Place<'tcx>,\n@@ -143,7 +145,7 @@ impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx, &'ll Value> {\n             _ => None,\n         };\n         if let Some((def_id, args)) = check {\n-            if Some(def_id) == self.fx.cx.tcx.lang_items().box_free_fn() {\n+            if Some(def_id) == self.fx.cx.tcx().lang_items().box_free_fn() {\n                 // box_free(x) shares with `drop x` the property that it\n                 // is not guaranteed to be statically dominated by the\n                 // definition of x, so x must always be in an alloca.\n@@ -175,20 +177,20 @@ impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx, &'ll Value> {\n                 _ => false\n             };\n             if is_consume {\n-                let base_ty = proj.base.ty(self.fx.mir, cx.tcx);\n+                let base_ty = proj.base.ty(self.fx.mir, cx.tcx());\n                 let base_ty = self.fx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access.\n                 let elem_ty = base_ty\n-                    .projection_ty(cx.tcx, &proj.elem)\n-                    .to_ty(cx.tcx);\n+                    .projection_ty(cx.tcx(), &proj.elem)\n+                    .to_ty(cx.tcx());\n                 let elem_ty = self.fx.monomorphize(&elem_ty);\n                 if cx.layout_of(elem_ty).is_zst() {\n                     return;\n                 }\n \n                 if let mir::ProjectionElem::Field(..) = proj.elem {\n-                    let layout = cx.layout_of(base_ty.to_ty(cx.tcx));\n+                    let layout = cx.layout_of(base_ty.to_ty(cx.tcx()));\n                     if layout.is_llvm_immediate() || layout.is_llvm_scalar_pair() {\n                         // Recurse with the same context, instead of `Projection`,\n                         // potentially stopping at non-operand projections,\n@@ -254,8 +256,8 @@ impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx, &'ll Value> {\n             }\n \n             PlaceContext::MutatingUse(MutatingUseContext::Drop) => {\n-                let ty = mir::Place::Local(local).ty(self.fx.mir, self.fx.cx.tcx);\n-                let ty = self.fx.monomorphize(&ty.to_ty(self.fx.cx.tcx));\n+                let ty = mir::Place::Local(local).ty(self.fx.mir, self.fx.cx.tcx());\n+                let ty = self.fx.monomorphize(&ty.to_ty(self.fx.cx.tcx()));\n \n                 // Only need the place if we're actually dropping it.\n                 if self.fx.cx.type_needs_drop(ty) {"}, {"sha": "cdde24a0755eaae7d61cb92a7a4a1730812ff493", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 172, "deletions": 126, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -8,22 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, BasicBlock};\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n use rustc::mir;\n use rustc::mir::interpret::EvalErrorKind;\n-use abi::{Abi, ArgType, ArgTypeExt, FnType, FnTypeExt, LlvmType, PassMode};\n+use abi::{Abi, FnType, PassMode};\n+use rustc_target::abi::call::ArgType;\n use base;\n-use callee;\n-use builder::{Builder, MemFlags};\n-use common::{self, IntPredicate};\n+use builder::MemFlags;\n+use common::{self, Funclet, IntPredicate};\n use meth;\n use monomorphize;\n-use type_of::LayoutLlvmExt;\n-use type_::Type;\n-use value::Value;\n \n use interfaces::*;\n \n@@ -35,8 +31,11 @@ use super::place::PlaceRef;\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n-impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n-    pub fn codegen_block(&mut self, bb: mir::BasicBlock) {\n+impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+    pub fn codegen_block(\n+        &mut self,\n+        bb: mir::BasicBlock,\n+    ) {\n         let mut bx = self.build_block(bb);\n         let data = &self.mir[bb];\n \n@@ -49,21 +48,35 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         self.codegen_terminator(bx, bb, data.terminator());\n     }\n \n-    fn codegen_terminator(&mut self,\n-                          mut bx: Builder<'a, 'll, 'tcx>,\n-                          bb: mir::BasicBlock,\n-                          terminator: &mir::Terminator<'tcx>)\n-    {\n+    fn codegen_terminator(\n+        &mut self,\n+        mut bx: Bx,\n+        bb: mir::BasicBlock,\n+        terminator: &mir::Terminator<'tcx>\n+    ) {\n         debug!(\"codegen_terminator: {:?}\", terminator);\n \n         // Create the cleanup bundle, if needed.\n-        let tcx = self.cx.tcx;\n+        let tcx = self.cx.tcx();\n         let span = terminator.source_info.span;\n         let funclet_bb = self.cleanup_kinds[bb].funclet_bb(bb);\n-        let funclet = funclet_bb.and_then(|funclet_bb| self.funclets[funclet_bb].as_ref());\n \n-        let cleanup_pad = funclet.map(|lp| lp.cleanuppad());\n-        let cleanup_bundle = funclet.map(|l| l.bundle());\n+        // HACK(eddyb) force the right lifetimes, NLL can't figure them out.\n+        fn funclet_closure_factory<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+            funclet_bb: Option<mir::BasicBlock>\n+        ) -> impl for<'b> Fn(\n+            &'b FunctionCx<'a, 'tcx, Bx>,\n+        ) -> Option<&'b Funclet<'static, Bx::Value>> {\n+            move |this| {\n+                match funclet_bb {\n+                    Some(funclet_bb) => this.funclets[funclet_bb].as_ref(),\n+                    None => None,\n+                }\n+            }\n+        }\n+        let funclet = funclet_closure_factory(funclet_bb);\n+\n+        let cleanup_pad = |this: &Self| funclet(this).map(|lp| lp.cleanuppad());\n \n         let lltarget = |this: &mut Self, target: mir::BasicBlock| {\n             let lltarget = this.blocks[target];\n@@ -92,32 +105,32 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n                 let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", bb, target);\n                 let trampoline = this.new_block(name);\n-                trampoline.cleanup_ret(cleanup_pad.unwrap(), Some(lltarget));\n+                trampoline.cleanup_ret(cleanup_pad(this).unwrap(), Some(lltarget));\n                 trampoline.llbb()\n             } else {\n                 lltarget\n             }\n         };\n \n         let funclet_br =\n-            |this: &mut Self, bx: Builder<'_, 'll, '_>, target: mir::BasicBlock| {\n+            |this: &mut Self, bx: &Bx, target: mir::BasicBlock| {\n                 let (lltarget, is_cleanupret) = lltarget(this, target);\n                 if is_cleanupret {\n                     // micro-optimization: generate a `ret` rather than a jump\n                     // to a trampoline.\n-                    bx.cleanup_ret(cleanup_pad.unwrap(), Some(lltarget));\n+                    bx.cleanup_ret(cleanup_pad(this).unwrap(), Some(lltarget));\n                 } else {\n                     bx.br(lltarget);\n                 }\n             };\n \n         let do_call = |\n             this: &mut Self,\n-            bx: Builder<'a, 'll, 'tcx>,\n+            bx: &Bx,\n             fn_ty: FnType<'tcx, Ty<'tcx>>,\n-            fn_ptr: &'ll Value,\n-            llargs: &[&'ll Value],\n-            destination: Option<(ReturnDest<'tcx, &'ll Value>, mir::BasicBlock)>,\n+            fn_ptr: Bx::Value,\n+            llargs: &[Bx::Value],\n+            destination: Option<(ReturnDest<'tcx, Bx::Value>, mir::BasicBlock)>,\n             cleanup: Option<mir::BasicBlock>\n         | {\n             if let Some(cleanup) = cleanup {\n@@ -130,27 +143,27 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                                           &llargs,\n                                           ret_bx,\n                                           llblock(this, cleanup),\n-                                          cleanup_bundle);\n-                fn_ty.apply_attrs_callsite(&bx, invokeret);\n+                                          funclet(this));\n+                bx.apply_attrs_callsite(&fn_ty, invokeret);\n \n                 if let Some((ret_dest, target)) = destination {\n                     let ret_bx = this.build_block(target);\n                     this.set_debug_loc(&ret_bx, terminator.source_info);\n                     this.store_return(&ret_bx, ret_dest, &fn_ty.ret, invokeret);\n                 }\n             } else {\n-                let llret = bx.call(fn_ptr, &llargs, cleanup_bundle);\n-                fn_ty.apply_attrs_callsite(&bx, llret);\n+                let llret = bx.call(fn_ptr, &llargs, funclet(this));\n+                bx.apply_attrs_callsite(&fn_ty, llret);\n                 if this.mir[bb].is_cleanup {\n                     // Cleanup is always the cold path. Don't inline\n                     // drop glue. Also, when there is a deeply-nested\n                     // struct, there are \"symmetry\" issues that cause\n                     // exponential inlining - see issue #41696.\n-                    llvm::Attribute::NoInline.apply_callsite(llvm::AttributePlace::Function, llret);\n+                    bx.do_not_inline(llret);\n                 }\n \n                 if let Some((ret_dest, target)) = destination {\n-                    this.store_return(&bx, ret_dest, &fn_ty.ret, llret);\n+                    this.store_return(bx, ret_dest, &fn_ty.ret, llret);\n                     funclet_br(this, bx, target);\n                 } else {\n                     bx.unreachable();\n@@ -161,21 +174,21 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         self.set_debug_loc(&bx, terminator.source_info);\n         match terminator.kind {\n             mir::TerminatorKind::Resume => {\n-                if let Some(cleanup_pad) = cleanup_pad {\n+                if let Some(cleanup_pad) = cleanup_pad(self) {\n                     bx.cleanup_ret(cleanup_pad, None);\n                 } else {\n                     let slot = self.get_personality_slot(&bx);\n                     let lp0 = bx.load_operand(slot.project_field(&bx, 0)).immediate();\n                     let lp1 = bx.load_operand(slot.project_field(&bx, 1)).immediate();\n                     slot.storage_dead(&bx);\n \n-                    if !bx.sess().target.target.options.custom_unwind_resume {\n+                    if !bx.cx().sess().target.target.options.custom_unwind_resume {\n                         let mut lp = bx.cx().const_undef(self.landing_pad_type());\n                         lp = bx.insert_value(lp, lp0, 0);\n                         lp = bx.insert_value(lp, lp1, 1);\n                         bx.resume(lp);\n                     } else {\n-                        bx.call(bx.cx().eh_unwind_resume(), &[lp0], cleanup_bundle);\n+                        bx.call(bx.cx().eh_unwind_resume(), &[lp0], funclet(self));\n                         bx.unreachable();\n                     }\n                 }\n@@ -189,7 +202,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             }\n \n             mir::TerminatorKind::Goto { target } => {\n-                funclet_br(self, bx, target);\n+                funclet_br(self, &bx, target);\n             }\n \n             mir::TerminatorKind::SwitchInt { ref discr, switch_ty, ref values, ref targets } => {\n@@ -207,7 +220,9 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                             bx.cond_br(discr.immediate(), lltrue, llfalse);\n                         }\n                     } else {\n-                        let switch_llty = bx.cx().layout_of(switch_ty).immediate_llvm_type(bx.cx());\n+                        let switch_llty = bx.cx().immediate_backend_type(\n+                            bx.cx().layout_of(switch_ty)\n+                        );\n                         let llval = bx.cx().const_uint_big(switch_llty, values[0]);\n                         let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n                         bx.cond_br(cmp, lltrue, llfalse);\n@@ -217,9 +232,11 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     let switch = bx.switch(discr.immediate(),\n                                            llblock(self, *otherwise),\n                                            values.len());\n-                    let switch_llty = bx.cx().layout_of(switch_ty).immediate_llvm_type(bx.cx());\n+                    let switch_llty = bx.cx().immediate_backend_type(\n+                        bx.cx().layout_of(switch_ty)\n+                    );\n                     for (&value, target) in values.iter().zip(targets) {\n-                        let llval =bx.cx().const_uint_big(switch_llty, value);\n+                        let llval = bx.cx().const_uint_big(switch_llty, value);\n                         let llbb = llblock(self, *target);\n                         bx.add_case(switch, llval, llbb)\n                     }\n@@ -267,7 +284,9 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                             }\n                         };\n                         bx.load(\n-                            bx.pointercast(llslot, bx.cx().type_ptr_to(cast_ty.llvm_type(bx.cx()))),\n+                            bx.pointercast(llslot, bx.cx().type_ptr_to(\n+                                bx.cx().cast_backend_type(&cast_ty)\n+                            )),\n                             self.fn_ty.ret.layout.align)\n                     }\n                 };\n@@ -281,11 +300,11 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n                 let ty = location.ty(self.mir, bx.tcx()).to_ty(bx.tcx());\n                 let ty = self.monomorphize(&ty);\n-                let drop_fn = monomorphize::resolve_drop_in_place(bx.cx().tcx, ty);\n+                let drop_fn = monomorphize::resolve_drop_in_place(bx.cx().tcx(), ty);\n \n                 if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n                     // we don't actually need to drop anything.\n-                    funclet_br(self, bx, target);\n+                    funclet_br(self, &bx, target);\n                     return\n                 }\n \n@@ -300,22 +319,22 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 };\n                 let (drop_fn, fn_ty) = match ty.sty {\n                     ty::Dynamic(..) => {\n-                        let sig = drop_fn.fn_sig(bx.tcx());\n-                        let sig = bx.tcx().normalize_erasing_late_bound_regions(\n+                        let sig = drop_fn.fn_sig(tcx);\n+                        let sig = tcx.normalize_erasing_late_bound_regions(\n                             ty::ParamEnv::reveal_all(),\n                             &sig,\n                         );\n-                        let fn_ty = FnType::new_vtable(bx.cx(), sig, &[]);\n+                        let fn_ty = bx.cx().new_vtable(sig, &[]);\n                         let vtable = args[1];\n                         args = &args[..1];\n                         (meth::DESTRUCTOR.get_fn(&bx, vtable, &fn_ty), fn_ty)\n                     }\n                     _ => {\n-                        (callee::get_fn(bx.cx(), drop_fn),\n-                         FnType::of_instance(bx.cx(), &drop_fn))\n+                        (bx.cx().get_fn(drop_fn),\n+                         bx.cx().fn_type_of_instance(&drop_fn))\n                     }\n                 };\n-                do_call(self, bx, fn_ty, drop_fn, args,\n+                do_call(self, &bx, fn_ty, drop_fn, args,\n                         Some((ReturnDest::Nothing, target)),\n                         unwind);\n             }\n@@ -331,15 +350,15 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 // NOTE: Unlike binops, negation doesn't have its own\n                 // checked operation, just a comparison with the minimum\n                 // value, so we have to check for the assert message.\n-                if !bx.cx().check_overflow {\n+                if !bx.cx().check_overflow() {\n                     if let mir::interpret::EvalErrorKind::OverflowNeg = *msg {\n                         const_cond = Some(expected);\n                     }\n                 }\n \n                 // Don't codegen the panic block if success if known.\n                 if const_cond == Some(expected) {\n-                    funclet_br(self, bx, target);\n+                    funclet_br(self, &bx, target);\n                     return;\n                 }\n \n@@ -361,7 +380,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 self.set_debug_loc(&bx, terminator.source_info);\n \n                 // Get the location information.\n-                let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n+                let loc = bx.cx().sess().source_map().lookup_char_pos(span.lo());\n                 let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n                 let filename = bx.cx().const_str_slice(filename);\n                 let line = bx.cx().const_u32(loc.line as u32);\n@@ -373,8 +392,8 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 // Put together the arguments to the panic entry point.\n                 let (lang_item, args) = match *msg {\n                     EvalErrorKind::BoundsCheck { ref len, ref index } => {\n-                        let len = self.codegen_operand(&mut bx, len).immediate();\n-                        let index = self.codegen_operand(&mut bx, index).immediate();\n+                        let len = self.codegen_operand(&bx, len).immediate();\n+                        let index = self.codegen_operand(&bx, index).immediate();\n \n                         let file_line_col = bx.cx().const_struct(&[filename, line, col], false);\n                         let file_line_col = bx.cx().static_addr_of(\n@@ -406,11 +425,11 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 // Obtain the panic entry point.\n                 let def_id = common::langcall(bx.tcx(), Some(span), \"\", lang_item);\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                let fn_ty = FnType::of_instance(bx.cx(), &instance);\n-                let llfn = callee::get_fn(bx.cx(), instance);\n+                let fn_ty = bx.cx().fn_type_of_instance(&instance);\n+                let llfn = bx.cx().get_fn(instance);\n \n                 // Codegen the actual panic invoke/call.\n-                do_call(self, bx, fn_ty, llfn, &args, None, cleanup);\n+                do_call(self, &bx, fn_ty, llfn, &args, None, cleanup);\n             }\n \n             mir::TerminatorKind::DropAndReplace { .. } => {\n@@ -429,7 +448,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n                 let (instance, mut llfn) = match callee.layout.ty.sty {\n                     ty::FnDef(def_id, substs) => {\n-                        (Some(ty::Instance::resolve(bx.cx().tcx,\n+                        (Some(ty::Instance::resolve(bx.cx().tcx(),\n                                                     ty::ParamEnv::reveal_all(),\n                                                     def_id,\n                                                     substs).unwrap()),\n@@ -460,7 +479,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     if let Some(destination_ref) = destination.as_ref() {\n                         let &(ref dest, target) = destination_ref;\n                         self.codegen_transmute(&bx, &args[0], dest);\n-                        funclet_br(self, bx, target);\n+                        funclet_br(self, &bx, target);\n                     } else {\n                         // If we are trying to transmute to an uninhabited type,\n                         // it is likely there is no allotted destination. In fact,\n@@ -482,26 +501,26 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n                 let fn_ty = match def {\n                     Some(ty::InstanceDef::Virtual(..)) => {\n-                        FnType::new_vtable(bx.cx(), sig, &extra_args)\n+                        bx.cx().new_vtable(sig, &extra_args)\n                     }\n                     Some(ty::InstanceDef::DropGlue(_, None)) => {\n                         // empty drop glue - a nop.\n                         let &(_, target) = destination.as_ref().unwrap();\n-                        funclet_br(self, bx, target);\n+                        funclet_br(self, &bx, target);\n                         return;\n                     }\n-                    _ => FnType::new(bx.cx(), sig, &extra_args)\n+                    _ => bx.cx().new_fn_type(sig, &extra_args)\n                 };\n \n                 // emit a panic instead of instantiating an uninhabited type\n                 if (intrinsic == Some(\"init\") || intrinsic == Some(\"uninit\")) &&\n                     fn_ty.ret.layout.abi.is_uninhabited()\n                 {\n-                    let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n+                    let loc = bx.cx().sess().source_map().lookup_char_pos(span.lo());\n                     let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n-                    let filename = bx.cx.const_str_slice(filename);\n-                    let line = bx.cx.const_u32(loc.line as u32);\n-                    let col = bx.cx.const_u32(loc.col.to_usize() as u32 + 1);\n+                    let filename = bx.cx().const_str_slice(filename);\n+                    let line = bx.cx().const_u32(loc.line as u32);\n+                    let col = bx.cx().const_u32(loc.col.to_usize() as u32 + 1);\n                     let align = tcx.data_layout.aggregate_align\n                         .max(tcx.data_layout.i32_align)\n                         .max(tcx.data_layout.pointer_align);\n@@ -512,12 +531,12 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         if intrinsic == Some(\"init\") { \"zeroed\" } else { \"uninitialized\" }\n                     );\n                     let msg_str = Symbol::intern(&str).as_str();\n-                    let msg_str = bx.cx.const_str_slice(msg_str);\n-                    let msg_file_line_col = bx.cx.const_struct(\n+                    let msg_str = bx.cx().const_str_slice(msg_str);\n+                    let msg_file_line_col = bx.cx().const_struct(\n                         &[msg_str, filename, line, col],\n                         false,\n                     );\n-                    let msg_file_line_col = bx.cx.static_addr_of(\n+                    let msg_file_line_col = bx.cx().static_addr_of(\n                         msg_file_line_col,\n                         align,\n                         Some(\"panic_loc\"),\n@@ -527,13 +546,13 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     let def_id =\n                         common::langcall(bx.tcx(), Some(span), \"\", lang_items::PanicFnLangItem);\n                     let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                    let fn_ty = FnType::of_instance(bx.cx, &instance);\n-                    let llfn = callee::get_fn(bx.cx, instance);\n+                    let fn_ty = bx.cx().fn_type_of_instance(&instance);\n+                    let llfn = bx.cx().get_fn(instance);\n \n                     // Codegen the actual panic invoke/call.\n                     do_call(\n                         self,\n-                        bx,\n+                        &bx,\n                         fn_ty,\n                         llfn,\n                         &[msg_file_line_col],\n@@ -560,7 +579,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     let dest = match ret_dest {\n                         _ if fn_ty.ret.is_indirect() => llargs[0],\n                         ReturnDest::Nothing => {\n-                            bx.cx().const_undef(bx.cx().type_ptr_to(fn_ty.ret.memory_ty(bx.cx())))\n+                            bx.cx().const_undef(bx.cx().type_ptr_to(bx.memory_ty(&fn_ty.ret)))\n                         }\n                         ReturnDest::IndirectOperand(dst, _) |\n                         ReturnDest::Store(dst) => dst.llval,\n@@ -622,16 +641,16 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     }).collect();\n \n \n-                    let callee_ty = instance.as_ref().unwrap().ty(bx.cx().tcx);\n-                    &bx.codegen_intrinsic_call(callee_ty, &fn_ty, &args, dest,\n+                    let callee_ty = instance.as_ref().unwrap().ty(bx.cx().tcx());\n+                    bx.codegen_intrinsic_call(callee_ty, &fn_ty, &args, dest,\n                                                terminator.source_info.span);\n \n                     if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n                         self.store_return(&bx, ret_dest, &fn_ty.ret, dst.llval);\n                     }\n \n                     if let Some((_, target)) = *destination {\n-                        funclet_br(self, bx, target);\n+                        funclet_br(self, &bx, target);\n                     } else {\n                         bx.unreachable();\n                     }\n@@ -719,11 +738,11 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n                 let fn_ptr = match (llfn, instance) {\n                     (Some(llfn), _) => llfn,\n-                    (None, Some(instance)) => callee::get_fn(bx.cx(), instance),\n+                    (None, Some(instance)) => bx.cx().get_fn(instance),\n                     _ => span_bug!(span, \"no llfn for call\"),\n                 };\n \n-                do_call(self, bx, fn_ty, fn_ptr, &llargs,\n+                do_call(self, &bx, fn_ty, fn_ptr, &llargs,\n                         destination.as_ref().map(|&(_, target)| (ret_dest, target)),\n                         cleanup);\n             }\n@@ -734,14 +753,16 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         }\n     }\n \n-    fn codegen_argument(&mut self,\n-                      bx: &Builder<'a, 'll, 'tcx>,\n-                      op: OperandRef<'tcx, &'ll Value>,\n-                      llargs: &mut Vec<&'ll Value>,\n-                      arg: &ArgType<'tcx, Ty<'tcx>>) {\n+    fn codegen_argument(\n+        &mut self,\n+        bx: &Bx,\n+        op: OperandRef<'tcx, Bx::Value>,\n+        llargs: &mut Vec<Bx::Value>,\n+        arg: &ArgType<'tcx, Ty<'tcx>>\n+    ) {\n         // Fill padding with undef value, where applicable.\n         if let Some(ty) = arg.pad {\n-            llargs.push(bx.cx().const_undef(ty.llvm_type(bx.cx())));\n+            llargs.push(bx.cx().const_undef(bx.cx().reg_backend_type(&ty)))\n         }\n \n         if arg.is_ignore() {\n@@ -801,8 +822,9 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n             if let PassMode::Cast(ty) = arg.mode {\n-                llval = bx.load(bx.pointercast(llval, bx.cx().type_ptr_to(ty.llvm_type(bx.cx()))),\n-                                align.min(arg.layout.align));\n+                llval = bx.load(bx.pointercast(llval, bx.cx().type_ptr_to(\n+                    bx.cx().cast_backend_type(&ty))\n+                ), align.min(arg.layout.align));\n             } else {\n                 // We can't use `PlaceRef::load` here because the argument\n                 // may have a type we don't treat as immediate, but the ABI\n@@ -823,11 +845,13 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         llargs.push(llval);\n     }\n \n-    fn codegen_arguments_untupled(&mut self,\n-                                  bx: &Builder<'a, 'll, 'tcx>,\n-                                  operand: &mir::Operand<'tcx>,\n-                                  llargs: &mut Vec<&'ll Value>,\n-                                  args: &[ArgType<'tcx, Ty<'tcx>>]) {\n+    fn codegen_arguments_untupled(\n+        &mut self,\n+        bx: &Bx,\n+        operand: &mir::Operand<'tcx>,\n+        llargs: &mut Vec<Bx::Value>,\n+        args: &[ArgType<'tcx, Ty<'tcx>>]\n+    ) {\n         let tuple = self.codegen_operand(bx, operand);\n \n         // Handle both by-ref and immediate tuples.\n@@ -850,15 +874,15 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n     fn get_personality_slot(\n         &mut self,\n-        bx: &Builder<'a, 'll, 'tcx>\n-    ) -> PlaceRef<'tcx, &'ll Value> {\n+        bx: &Bx\n+    ) -> PlaceRef<'tcx, Bx::Value> {\n         let cx = bx.cx();\n         if let Some(slot) = self.personality_slot {\n             slot\n         } else {\n-            let layout = cx.layout_of(cx.tcx.intern_tup(&[\n-                cx.tcx.mk_mut_ptr(cx.tcx.types.u8),\n-                cx.tcx.types.i32\n+            let layout = cx.layout_of(cx.tcx().intern_tup(&[\n+                cx.tcx().mk_mut_ptr(cx.tcx().types.u8),\n+                cx.tcx().types.i32\n             ]));\n             let slot = PlaceRef::alloca(bx, layout, \"personalityslot\");\n             self.personality_slot = Some(slot);\n@@ -869,7 +893,10 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n     /// Return the landingpad wrapper around the given basic block\n     ///\n     /// No-op in MSVC SEH scheme.\n-    fn landing_pad_to(&mut self, target_bb: mir::BasicBlock) -> &'ll BasicBlock {\n+    fn landing_pad_to(\n+        &mut self,\n+        target_bb: mir::BasicBlock\n+    ) -> Bx::BasicBlock {\n         if let Some(block) = self.landing_pads[target_bb] {\n             return block;\n         }\n@@ -880,7 +907,10 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         landing_pad\n     }\n \n-    fn landing_pad_uncached(&mut self, target_bb: &'ll BasicBlock) -> &'ll BasicBlock {\n+    fn landing_pad_uncached(\n+        &mut self,\n+        target_bb: Bx::BasicBlock\n+    ) -> Bx::BasicBlock {\n         if base::wants_msvc_seh(self.cx.sess()) {\n             span_bug!(self.mir.span, \"landing pad was not inserted?\")\n         }\n@@ -900,34 +930,42 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         bx.llbb()\n     }\n \n-    fn landing_pad_type(&self) -> &'ll Type {\n+    fn landing_pad_type(&self) -> Bx::Type {\n         let cx = self.cx;\n-        cx.type_struct( &[cx.type_i8p(), cx.type_i32()], false)\n+        cx.type_struct(&[cx.type_i8p(), cx.type_i32()], false)\n     }\n \n-    fn unreachable_block(&mut self) -> &'ll BasicBlock {\n+    fn unreachable_block(\n+        &mut self\n+    ) -> Bx::BasicBlock {\n         self.unreachable_block.unwrap_or_else(|| {\n-            let bl = self.new_block(\"unreachable\");\n-            bl.unreachable();\n-            self.unreachable_block = Some(bl.llbb());\n-            bl.llbb()\n+            let bx = self.new_block(\"unreachable\");\n+            bx.unreachable();\n+            self.unreachable_block = Some(bx.llbb());\n+            bx.llbb()\n         })\n     }\n \n-    pub fn new_block(&self, name: &str) -> Builder<'a, 'll, 'tcx> {\n-        Builder::new_block(self.cx, self.llfn, name)\n+    pub fn new_block(&self, name: &str) -> Bx {\n+        Bx::new_block(self.cx, self.llfn, name)\n     }\n \n-    pub fn build_block(&self, bb: mir::BasicBlock) -> Builder<'a, 'll, 'tcx> {\n-        let bx = Builder::with_cx(self.cx);\n+    pub fn build_block(\n+        &self,\n+        bb: mir::BasicBlock\n+    ) -> Bx {\n+        let bx = Bx::with_cx(self.cx);\n         bx.position_at_end(self.blocks[bb]);\n         bx\n     }\n \n-    fn make_return_dest(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n-                        dest: &mir::Place<'tcx>, fn_ret: &ArgType<'tcx, Ty<'tcx>>,\n-                        llargs: &mut Vec<&'ll Value>, is_intrinsic: bool)\n-                        -> ReturnDest<'tcx, &'ll Value> {\n+    fn make_return_dest(\n+        &mut self,\n+        bx: &Bx,\n+        dest: &mir::Place<'tcx>,\n+        fn_ret: &ArgType<'tcx, Ty<'tcx>>,\n+        llargs: &mut Vec<Bx::Value>, is_intrinsic: bool\n+    ) -> ReturnDest<'tcx, Bx::Value> {\n         // If the return is ignored, we can just return a do-nothing ReturnDest\n         if fn_ret.is_ignore() {\n             return ReturnDest::Nothing;\n@@ -981,9 +1019,12 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         }\n     }\n \n-    fn codegen_transmute(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n-                         src: &mir::Operand<'tcx>,\n-                         dst: &mir::Place<'tcx>) {\n+    fn codegen_transmute(\n+        &mut self,\n+        bx: &Bx,\n+        src: &mir::Operand<'tcx>,\n+        dst: &mir::Place<'tcx>\n+    ) {\n         if let mir::Place::Local(index) = *dst {\n             match self.locals[index] {\n                 LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),\n@@ -1009,28 +1050,33 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         }\n     }\n \n-    fn codegen_transmute_into(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n-                              src: &mir::Operand<'tcx>,\n-                              dst: PlaceRef<'tcx, &'ll Value>) {\n+    fn codegen_transmute_into(\n+        &mut self,\n+        bx: &Bx,\n+        src: &mir::Operand<'tcx>,\n+        dst: PlaceRef<'tcx, Bx::Value>\n+    ) {\n         let src = self.codegen_operand(bx, src);\n-        let llty = src.layout.llvm_type(bx.cx());\n+        let llty = bx.cx().backend_type(src.layout);\n         let cast_ptr = bx.pointercast(dst.llval, bx.cx().type_ptr_to(llty));\n         let align = src.layout.align.min(dst.layout.align);\n         src.val.store(bx, PlaceRef::new_sized(cast_ptr, src.layout, align));\n     }\n \n \n     // Stores the return value of a function call into it's final location.\n-    fn store_return(&mut self,\n-                    bx: &Builder<'a, 'll, 'tcx>,\n-                    dest: ReturnDest<'tcx, &'ll Value>,\n-                    ret_ty: &ArgType<'tcx, Ty<'tcx>>,\n-                    llval: &'ll Value) {\n+    fn store_return(\n+        &mut self,\n+        bx: &Bx,\n+        dest: ReturnDest<'tcx, Bx::Value>,\n+        ret_ty: &ArgType<'tcx, Ty<'tcx>>,\n+        llval: Bx::Value\n+    ) {\n         use self::ReturnDest::*;\n \n         match dest {\n             Nothing => (),\n-            Store(dst) => ret_ty.store(bx, llval, dst),\n+            Store(dst) => bx.store_arg_ty(&ret_ty, llval, dst),\n             IndirectOperand(tmp, index) => {\n                 let op = bx.load_operand(tmp);\n                 tmp.storage_dead(bx);\n@@ -1041,7 +1087,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 let op = if let PassMode::Cast(_) = ret_ty.mode {\n                     let tmp = PlaceRef::alloca(bx, ret_ty.layout, \"tmp_ret\");\n                     tmp.storage_live(bx);\n-                    ret_ty.store(bx, llval, tmp);\n+                    bx.store_arg_ty(&ret_ty, llval, tmp);\n                     let op = bx.load_operand(tmp);\n                     tmp.storage_dead(bx);\n                     op"}, {"sha": "a052473beec75a78ff5a5a9cd92e8ae36963c064", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 14, "deletions": 76, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -8,82 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm;\n use rustc::mir::interpret::{ErrorHandled, read_target_uint};\n use rustc_mir::const_eval::const_field;\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::mir::interpret::{GlobalId, Pointer, Scalar, Allocation, ConstValue, AllocType};\n+use rustc::mir::interpret::{GlobalId, Pointer, Allocation, ConstValue};\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Size, HasTyCtxt};\n-use builder::Builder;\n-use common::{CodegenCx};\n-use type_of::LayoutLlvmExt;\n-use type_::Type;\n-use syntax::ast::Mutability;\n+use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Size};\n+use common::CodegenCx;\n use syntax::source_map::Span;\n use value::Value;\n-use interfaces::{BuilderMethods, ConstMethods, BaseTypeMethods, DerivedTypeMethods, StaticMethods};\n+use interfaces::*;\n \n-use super::super::callee;\n use super::FunctionCx;\n \n-pub fn scalar_to_llvm(\n-    cx: &CodegenCx<'ll, '_>,\n-    cv: Scalar,\n-    layout: &layout::Scalar,\n-    llty: &'ll Type,\n-) -> &'ll Value {\n-    let bitsize = if layout.is_bool() { 1 } else { layout.value.size(cx).bits() };\n-    match cv {\n-        Scalar::Bits { size: 0, .. } => {\n-            assert_eq!(0, layout.value.size(cx).bytes());\n-            cx.const_undef(cx.type_ix(0))\n-        },\n-        Scalar::Bits { bits, size } => {\n-            assert_eq!(size as u64, layout.value.size(cx).bytes());\n-            let llval = cx.const_uint_big(cx.type_ix(bitsize), bits);\n-            if layout.value == layout::Pointer {\n-                unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n-            } else {\n-                cx.static_bitcast(llval, llty)\n-            }\n-        },\n-        Scalar::Ptr(ptr) => {\n-            let alloc_type = cx.tcx.alloc_map.lock().get(ptr.alloc_id);\n-            let base_addr = match alloc_type {\n-                Some(AllocType::Memory(alloc)) => {\n-                    let init = const_alloc_to_llvm(cx, alloc);\n-                    if alloc.mutability == Mutability::Mutable {\n-                        cx.static_addr_of_mut(init, alloc.align, None)\n-                    } else {\n-                        cx.static_addr_of(init, alloc.align, None)\n-                    }\n-                }\n-                Some(AllocType::Function(fn_instance)) => {\n-                    callee::get_fn(cx, fn_instance)\n-                }\n-                Some(AllocType::Static(def_id)) => {\n-                    assert!(cx.tcx.is_static(def_id).is_some());\n-                    cx.get_static(def_id)\n-                }\n-                None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n-            };\n-            let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n-                cx.static_bitcast(base_addr, cx.type_i8p()),\n-                &cx.const_usize(ptr.offset.bytes()),\n-                1,\n-            ) };\n-            if layout.value != layout::Pointer {\n-                unsafe { llvm::LLVMConstPtrToInt(llval, llty) }\n-            } else {\n-                cx.static_bitcast(llval, llty)\n-            }\n-        }\n-    }\n-}\n-\n pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n     let mut llvals = Vec::with_capacity(alloc.relocations.len() + 1);\n     let dl = cx.data_layout();\n@@ -101,8 +40,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n             dl.endian,\n             &alloc.bytes[offset..(offset + pointer_size)],\n         ).expect(\"const_alloc_to_llvm: could not read relocation pointer\") as u64;\n-        llvals.push(scalar_to_llvm(\n-            cx,\n+        llvals.push(cx.scalar_to_backend(\n             Pointer::new(alloc_id, Size::from_bytes(ptr_offset)).into(),\n             &layout::Scalar {\n                 value: layout::Primitive::Pointer,\n@@ -138,10 +76,10 @@ pub fn codegen_static_initializer(\n     Ok((const_alloc_to_llvm(cx, alloc), alloc))\n }\n \n-impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n+impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn fully_evaluate(\n         &mut self,\n-        bx: &Builder<'a, 'll, 'tcx>,\n+        bx: &Bx,\n         constant: &'tcx ty::Const<'tcx>,\n     ) -> Result<&'tcx ty::Const<'tcx>, ErrorHandled> {\n         match constant.val {\n@@ -161,7 +99,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n     pub fn eval_mir_constant(\n         &mut self,\n-        bx: &Builder<'a, 'll, 'tcx>,\n+        bx: &Bx,\n         constant: &mir::Constant<'tcx>,\n     ) -> Result<&'tcx ty::Const<'tcx>, ErrorHandled> {\n         let c = self.monomorphize(&constant.literal);\n@@ -171,11 +109,11 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n     /// process constant containing SIMD shuffle indices\n     pub fn simd_shuffle_indices(\n         &mut self,\n-        bx: &Builder<'a, 'll, 'tcx>,\n+        bx: &Bx,\n         span: Span,\n         ty: Ty<'tcx>,\n         constant: Result<&'tcx ty::Const<'tcx>, ErrorHandled>,\n-    ) -> (&'ll Value, Ty<'tcx>) {\n+    ) -> (Bx::Value, Ty<'tcx>) {\n         constant\n             .and_then(|c| {\n                 let field_ty = c.ty.builtin_index().unwrap();\n@@ -198,9 +136,9 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                             layout::Abi::Scalar(ref x) => x,\n                             _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n                         };\n-                        Ok(scalar_to_llvm(\n-                            bx.cx(), prim, scalar,\n-                            layout.immediate_llvm_type(bx.cx()),\n+                        Ok(bx.cx().scalar_to_backend(\n+                            prim, scalar,\n+                            bx.cx().immediate_backend_type(layout),\n                         ))\n                     } else {\n                         bug!(\"simd shuffle field {:?}\", field)\n@@ -216,7 +154,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 );\n                 // We've errored, so we don't have to produce working code.\n                 let ty = self.monomorphize(&ty);\n-                let llty = bx.cx().layout_of(ty).llvm_type(bx.cx());\n+                let llty = bx.cx().backend_type(bx.cx().layout_of(ty));\n                 (bx.cx().const_undef(llty), ty)\n             })\n     }"}, {"sha": "4e55964bd001b4b65932f33fb27e06ca1e7d9cff", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 75, "deletions": 79, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -9,22 +9,19 @@\n // except according to those terms.\n \n use libc::c_uint;\n-use llvm::{self, BasicBlock};\n-use llvm::debuginfo::DIScope;\n+use llvm;\n use llvm_util;\n use rustc::ty::{self, Ty, TypeFoldable, UpvarSubsts};\n use rustc::ty::layout::{LayoutOf, TyLayout, HasTyCtxt};\n use rustc::mir::{self, Mir};\n use rustc::ty::subst::Substs;\n use rustc::session::config::DebugInfo;\n use base;\n-use builder::Builder;\n-use common::{CodegenCx, Funclet};\n-use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n+use debuginfo::{self, VariableAccess, VariableKind, FunctionDebugContext};\n+use common::Funclet;\n use monomorphize::Instance;\n-use abi::{ArgTypeExt, FnType, FnTypeExt, PassMode};\n-use value::Value;\n-use interfaces::{BuilderMethods, ConstMethods, DerivedTypeMethods};\n+use abi::{FnType, PassMode};\n+use interfaces::*;\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n use syntax::symbol::keywords;\n@@ -43,16 +40,16 @@ use rustc::mir::traversal;\n use self::operand::{OperandRef, OperandValue};\n \n /// Master context for codegenning from MIR.\n-pub struct FunctionCx<'a, 'll: 'a, 'tcx: 'll, V> {\n+pub struct FunctionCx<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> {\n     instance: Instance<'tcx>,\n \n     mir: &'a mir::Mir<'tcx>,\n \n-    debug_context: FunctionDebugContext<'ll>,\n+    debug_context: FunctionDebugContext<Bx::DIScope>,\n \n-    llfn: V,\n+    llfn: Bx::Value,\n \n-    cx: &'a CodegenCx<'ll, 'tcx>,\n+    cx: &'a Bx::CodegenCx,\n \n     fn_ty: FnType<'tcx, Ty<'tcx>>,\n \n@@ -63,25 +60,24 @@ pub struct FunctionCx<'a, 'll: 'a, 'tcx: 'll, V> {\n     /// don't really care about it very much. Anyway, this value\n     /// contains an alloca into which the personality is stored and\n     /// then later loaded when generating the DIVERGE_BLOCK.\n-    personality_slot: Option<PlaceRef<'tcx, V>>,\n+    personality_slot: Option<PlaceRef<'tcx, Bx::Value,>>,\n \n     /// A `Block` for each MIR `BasicBlock`\n-    blocks: IndexVec<mir::BasicBlock, &'ll BasicBlock>,\n+    blocks: IndexVec<mir::BasicBlock, Bx::BasicBlock>,\n \n     /// The funclet status of each basic block\n     cleanup_kinds: IndexVec<mir::BasicBlock, analyze::CleanupKind>,\n \n     /// When targeting MSVC, this stores the cleanup info for each funclet\n-    /// BB. Thisrustup component add rustfmt-preview is initialized as we compute the funclets'\n-    /// head block in RPO.\n-    funclets: &'a IndexVec<mir::BasicBlock, Option<Funclet<'ll>>>,\n+    /// BB. This is initialized as we compute the funclets' head block in RPO.\n+    funclets: IndexVec<mir::BasicBlock, Option<Funclet<'static, Bx::Value>>>,\n \n     /// This stores the landing-pad block for a given BB, computed lazily on GNU\n     /// and eagerly on MSVC.\n-    landing_pads: IndexVec<mir::BasicBlock, Option<&'ll BasicBlock>>,\n+    landing_pads: IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>>,\n \n     /// Cached unreachable block\n-    unreachable_block: Option<&'ll BasicBlock>,\n+    unreachable_block: Option<Bx::BasicBlock>,\n \n     /// The location where each MIR arg/var/tmp/ret is stored. This is\n     /// usually an `PlaceRef` representing an alloca, but not always:\n@@ -98,20 +94,20 @@ pub struct FunctionCx<'a, 'll: 'a, 'tcx: 'll, V> {\n     ///\n     /// Avoiding allocs can also be important for certain intrinsics,\n     /// notably `expect`.\n-    locals: IndexVec<mir::Local, LocalRef<'tcx, V>>,\n+    locals: IndexVec<mir::Local, LocalRef<'tcx, Bx::Value>>,\n \n     /// Debug information for MIR scopes.\n-    scopes: IndexVec<mir::SourceScope, debuginfo::MirDebugScope<'ll>>,\n+    scopes: IndexVec<mir::SourceScope, debuginfo::MirDebugScope<Bx::DIScope>>,\n \n     /// If this function is being monomorphized, this contains the type substitutions used.\n     param_substs: &'tcx Substs<'tcx>,\n }\n \n-impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n+impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n         where T: TypeFoldable<'tcx>\n     {\n-        self.cx.tcx.subst_and_normalize_erasing_regions(\n+        self.cx.tcx().subst_and_normalize_erasing_regions(\n             self.param_substs,\n             ty::ParamEnv::reveal_all(),\n             value,\n@@ -120,14 +116,14 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n     pub fn set_debug_loc(\n         &mut self,\n-        bx: &Builder<'_, 'll, '_>,\n+        bx: &Bx,\n         source_info: mir::SourceInfo\n     ) {\n         let (scope, span) = self.debug_loc(source_info);\n-        debuginfo::set_source_location(&self.debug_context, bx, scope, span);\n+        bx.set_source_location(&self.debug_context, scope, span);\n     }\n \n-    pub fn debug_loc(&mut self, source_info: mir::SourceInfo) -> (Option<&'ll DIScope>, Span) {\n+    pub fn debug_loc(&self, source_info: mir::SourceInfo) -> (Option<Bx::DIScope>, Span) {\n         // Bail out if debug info emission is not enabled.\n         match self.debug_context {\n             FunctionDebugContext::DebugInfoDisabled |\n@@ -167,16 +163,17 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n     // corresponding to span's containing source scope.  If so, we need to create a DIScope\n     // \"extension\" into that file.\n     fn scope_metadata_for_loc(&self, scope_id: mir::SourceScope, pos: BytePos)\n-                              -> Option<&'ll DIScope> {\n+                              -> Option<Bx::DIScope> {\n         let scope_metadata = self.scopes[scope_id].scope_metadata;\n         if pos < self.scopes[scope_id].file_start_pos ||\n            pos >= self.scopes[scope_id].file_end_pos {\n-            let cm = self.cx.sess().source_map();\n+            let sm = self.cx.sess().source_map();\n             let defining_crate = self.debug_context.get_ref(DUMMY_SP).defining_crate;\n-            Some(debuginfo::extend_scope_to_file(self.cx,\n-                                                 scope_metadata.unwrap(),\n-                                                 &cm.lookup_char_pos(pos).file,\n-                                                 defining_crate))\n+            Some(self.cx.extend_scope_to_file(\n+                scope_metadata.unwrap(),\n+                &sm.lookup_char_pos(pos).file,\n+                defining_crate,\n+            ))\n         } else {\n             scope_metadata\n         }\n@@ -193,11 +190,11 @@ enum LocalRef<'tcx, V> {\n     Operand(Option<OperandRef<'tcx, V>>),\n }\n \n-impl LocalRef<'tcx, &'ll Value> {\n-    fn new_operand(\n-        cx: &CodegenCx<'ll, 'tcx>,\n+impl<'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n+    fn new_operand<Cx: CodegenMethods<'tcx, Value = V>>(\n+        cx: &Cx,\n         layout: TyLayout<'tcx>,\n-    ) -> LocalRef<'tcx, &'ll Value> {\n+    ) -> LocalRef<'tcx, V> {\n         if layout.is_zst() {\n             // Zero-size temporaries aren't always initialized, which\n             // doesn't matter because they don't contain data, but\n@@ -211,18 +208,18 @@ impl LocalRef<'tcx, &'ll Value> {\n \n ///////////////////////////////////////////////////////////////////////////\n \n-pub fn codegen_mir(\n-    cx: &'a CodegenCx<'ll, 'tcx>,\n-    llfn: &'ll Value,\n+pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    cx: &'a Bx::CodegenCx,\n+    llfn: Bx::Value,\n     mir: &'a Mir<'tcx>,\n     instance: Instance<'tcx>,\n     sig: ty::FnSig<'tcx>,\n ) {\n-    let fn_ty = FnType::new(cx, sig, &[]);\n+    let fn_ty = cx.new_fn_type(sig, &[]);\n     debug!(\"fn_ty: {:?}\", fn_ty);\n     let debug_context =\n-        debuginfo::create_function_debug_context(cx, instance, sig, llfn, mir);\n-    let bx = Builder::new_block(cx, llfn, \"start\");\n+        cx.create_function_debug_context(instance, sig, llfn, mir);\n+    let bx = Bx::new_block(cx, llfn, \"start\");\n \n     if mir.basic_blocks().iter().any(|bb| bb.is_cleanup) {\n         bx.set_personality_fn(cx.eh_personality());\n@@ -232,7 +229,7 @@ pub fn codegen_mir(\n     // Allocate a `Block` for every basic block, except\n     // the start block, if nothing loops back to it.\n     let reentrant_start_block = !mir.predecessors_for(mir::START_BLOCK).is_empty();\n-    let block_bxs: IndexVec<mir::BasicBlock, &'ll BasicBlock> =\n+    let block_bxs: IndexVec<mir::BasicBlock, Bx::BasicBlock> =\n         mir.basic_blocks().indices().map(|bb| {\n             if bb == mir::START_BLOCK && !reentrant_start_block {\n                 bx.llbb()\n@@ -242,7 +239,7 @@ pub fn codegen_mir(\n         }).collect();\n \n     // Compute debuginfo scopes from MIR scopes.\n-    let scopes = debuginfo::create_mir_scopes(cx, mir, &debug_context);\n+    let scopes = cx.create_mir_scopes(mir, &debug_context);\n     let (landing_pads, funclets) = create_funclets(mir, &bx, &cleanup_kinds, &block_bxs);\n \n     let mut fx = FunctionCx {\n@@ -256,7 +253,7 @@ pub fn codegen_mir(\n         unreachable_block: None,\n         cleanup_kinds,\n         landing_pads,\n-        funclets: &funclets,\n+        funclets,\n         scopes,\n         locals: IndexVec::new(),\n         debug_context,\n@@ -272,15 +269,16 @@ pub fn codegen_mir(\n     fx.locals = {\n         let args = arg_local_refs(&bx, &fx, &fx.scopes, &memory_locals);\n \n-        let mut allocate_local = |local| {\n+        let allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n             let layout = bx.cx().layout_of(fx.monomorphize(&decl.ty));\n             assert!(!layout.ty.has_erasable_regions());\n \n             if let Some(name) = decl.name {\n                 // User variable\n                 let debug_scope = fx.scopes[decl.visibility_scope];\n-                let dbg = debug_scope.is_valid() && bx.sess().opts.debuginfo == DebugInfo::Full;\n+                let dbg = debug_scope.is_valid() &&\n+                    bx.cx().sess().opts.debuginfo == DebugInfo::Full;\n \n                 if !memory_locals.contains(local) && !dbg {\n                     debug!(\"alloc: {:?} ({}) -> operand\", local, name);\n@@ -300,7 +298,7 @@ pub fn codegen_mir(\n                             span: decl.source_info.span,\n                             scope: decl.visibility_scope,\n                         });\n-                        declare_local(&bx, &fx.debug_context, name, layout.ty, scope.unwrap(),\n+                        bx.declare_local(&fx.debug_context, name, layout.ty, scope.unwrap(),\n                             VariableAccess::DirectVariable { alloca: place.llval },\n                             VariableKind::LocalVariable, span);\n                     }\n@@ -310,7 +308,7 @@ pub fn codegen_mir(\n                 // Temporary or return place\n                 if local == mir::RETURN_PLACE && fx.fn_ty.ret.is_indirect() {\n                     debug!(\"alloc: {:?} (return place) -> place\", local);\n-                    let llretptr = llvm::get_param(llfn, 0);\n+                    let llretptr = fx.cx.get_param(llfn, 0);\n                     LocalRef::Place(PlaceRef::new_sized(llretptr, layout, layout.align))\n                 } else if memory_locals.contains(local) {\n                     debug!(\"alloc: {:?} -> place\", local);\n@@ -363,24 +361,22 @@ pub fn codegen_mir(\n         // Unreachable block\n         if !visited.contains(bb.index()) {\n             debug!(\"codegen_mir: block {:?} was not visited\", bb);\n-            unsafe {\n-                llvm::LLVMDeleteBasicBlock(fx.blocks[bb]);\n-            }\n+            bx.delete_basic_block(fx.blocks[bb]);\n         }\n     }\n }\n \n-fn create_funclets(\n+fn create_funclets<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     mir: &'a Mir<'tcx>,\n-    bx: &Builder<'a, 'll, 'tcx>,\n+    bx: &Bx,\n     cleanup_kinds: &IndexVec<mir::BasicBlock, CleanupKind>,\n-    block_bxs: &IndexVec<mir::BasicBlock, &'ll BasicBlock>)\n-    -> (IndexVec<mir::BasicBlock, Option<&'ll BasicBlock>>,\n-        IndexVec<mir::BasicBlock, Option<Funclet<'ll>>>)\n+    block_bxs: &IndexVec<mir::BasicBlock, Bx::BasicBlock>)\n+    -> (IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>>,\n+        IndexVec<mir::BasicBlock, Option<Funclet<'static, Bx::Value>>>)\n {\n     block_bxs.iter_enumerated().zip(cleanup_kinds).map(|((bb, &llbb), cleanup_kind)| {\n         match *cleanup_kind {\n-            CleanupKind::Funclet if base::wants_msvc_seh(bx.sess()) => {}\n+            CleanupKind::Funclet if base::wants_msvc_seh(bx.cx().sess()) => {}\n             _ => return (None, None)\n         }\n \n@@ -439,20 +435,23 @@ fn create_funclets(\n /// Produce, for each argument, a `Value` pointing at the\n /// argument's value. As arguments are places, these are always\n /// indirect.\n-fn arg_local_refs(\n-    bx: &Builder<'a, 'll, 'tcx>,\n-    fx: &FunctionCx<'a, 'll, 'tcx, &'ll Value>,\n-    scopes: &IndexVec<mir::SourceScope, debuginfo::MirDebugScope<'ll>>,\n+fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    fx: &FunctionCx<'a, 'tcx, Bx>,\n+    scopes: &IndexVec<\n+        mir::SourceScope,\n+        debuginfo::MirDebugScope<Bx::DIScope>\n+    >,\n     memory_locals: &BitSet<mir::Local>,\n-) -> Vec<LocalRef<'tcx, &'ll Value>> {\n+) -> Vec<LocalRef<'tcx, Bx::Value>> {\n     let mir = fx.mir;\n     let tcx = bx.tcx();\n     let mut idx = 0;\n     let mut llarg_idx = fx.fn_ty.ret.is_indirect() as usize;\n \n     // Get the argument scope, if it exists and if we need it.\n     let arg_scope = scopes[mir::OUTERMOST_SOURCE_SCOPE];\n-    let arg_scope = if bx.sess().opts.debuginfo == DebugInfo::Full {\n+    let arg_scope = if bx.cx().sess().opts.debuginfo == DebugInfo::Full {\n         arg_scope.scope_metadata\n     } else {\n         None\n@@ -486,7 +485,7 @@ fn arg_local_refs(\n                 if arg.pad.is_some() {\n                     llarg_idx += 1;\n                 }\n-                arg.store_fn_arg(bx, &mut llarg_idx, place.project_field(bx, i));\n+                bx.store_fn_arg(arg, &mut llarg_idx, place.project_field(bx, i));\n             }\n \n             // Now that we have one alloca that contains the aggregate value,\n@@ -495,8 +494,7 @@ fn arg_local_refs(\n                 let variable_access = VariableAccess::DirectVariable {\n                     alloca: place.llval\n                 };\n-                declare_local(\n-                    bx,\n+                bx.declare_local(\n                     &fx.debug_context,\n                     arg_decl.name.unwrap_or(keywords::Invalid.name()),\n                     arg_ty, scope,\n@@ -525,18 +523,18 @@ fn arg_local_refs(\n                     return local(OperandRef::new_zst(bx.cx(), arg.layout));\n                 }\n                 PassMode::Direct(_) => {\n-                    let llarg = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n+                    let llarg = bx.cx().get_param(bx.llfn(), llarg_idx as c_uint);\n                     bx.set_value_name(llarg, &name);\n                     llarg_idx += 1;\n                     return local(\n                         OperandRef::from_immediate_or_packed_pair(bx, llarg, arg.layout));\n                 }\n                 PassMode::Pair(..) => {\n-                    let a = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n+                    let a = bx.cx().get_param(bx.llfn(), llarg_idx as c_uint);\n                     bx.set_value_name(a, &(name.clone() + \".0\"));\n                     llarg_idx += 1;\n \n-                    let b = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n+                    let b = bx.cx().get_param(bx.llfn(), llarg_idx as c_uint);\n                     bx.set_value_name(b, &(name + \".1\"));\n                     llarg_idx += 1;\n \n@@ -553,16 +551,16 @@ fn arg_local_refs(\n             // Don't copy an indirect argument to an alloca, the caller\n             // already put it in a temporary alloca and gave it up.\n             // FIXME: lifetimes\n-            let llarg = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n+            let llarg = bx.cx().get_param(bx.llfn(), llarg_idx as c_uint);\n             bx.set_value_name(llarg, &name);\n             llarg_idx += 1;\n             PlaceRef::new_sized(llarg, arg.layout, arg.layout.align)\n         } else if arg.is_unsized_indirect() {\n             // As the storage for the indirect argument lives during\n             // the whole function call, we just copy the fat pointer.\n-            let llarg = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n+            let llarg = bx.cx().get_param(bx.llfn(), llarg_idx as c_uint);\n             llarg_idx += 1;\n-            let llextra = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n+            let llextra = bx.cx().get_param(bx.llfn(), llarg_idx as c_uint);\n             llarg_idx += 1;\n             let indirect_operand = OperandValue::Pair(llarg, llextra);\n \n@@ -571,7 +569,7 @@ fn arg_local_refs(\n             tmp\n         } else {\n             let tmp = PlaceRef::alloca(bx, arg.layout, &name);\n-            arg.store_fn_arg(bx, &mut llarg_idx, tmp);\n+            bx.store_fn_arg(arg, &mut llarg_idx, tmp);\n             tmp\n         };\n         arg_scope.map(|scope| {\n@@ -585,8 +583,7 @@ fn arg_local_refs(\n                     alloca: place.llval\n                 };\n \n-                declare_local(\n-                    bx,\n+                bx.declare_local(\n                     &fx.debug_context,\n                     arg_decl.name.unwrap_or(keywords::Invalid.name()),\n                     arg.layout.ty,\n@@ -658,8 +655,7 @@ fn arg_local_refs(\n                     alloca: env_ptr,\n                     address_operations: &ops\n                 };\n-                declare_local(\n-                    bx,\n+                bx.declare_local(\n                     &fx.debug_context,\n                     decl.debug_name,\n                     ty,\n@@ -680,7 +676,7 @@ fn arg_local_refs(\n \n mod analyze;\n mod block;\n-mod constant;\n+pub mod constant;\n pub mod place;\n pub mod operand;\n mod rvalue;"}, {"sha": "f2f6031572845929c7b4da931224cf87ed13edcd", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 67, "deletions": 79, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -14,18 +14,14 @@ use rustc::ty;\n use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n \n use base;\n-use common::CodegenCx;\n-use builder::{Builder, MemFlags};\n-use value::Value;\n-use type_of::LayoutLlvmExt;\n+use builder::MemFlags;\n use glue;\n \n use interfaces::*;\n \n use std::fmt;\n \n use super::{FunctionCx, LocalRef};\n-use super::constant::scalar_to_llvm;\n use super::place::PlaceRef;\n \n /// The representation of a Rust value. The enum variant is in fact\n@@ -61,13 +57,13 @@ pub struct OperandRef<'tcx, V> {\n     pub layout: TyLayout<'tcx>,\n }\n \n-impl fmt::Debug for OperandRef<'tcx, &'ll Value> {\n+impl<V: CodegenObject> fmt::Debug for OperandRef<'tcx, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"OperandRef({:?} @ {:?})\", self.val, self.layout)\n     }\n }\n \n-impl<'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n+impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n     pub fn new_zst<Cx: CodegenMethods<'tcx, Value = V>>(\n         cx: &Cx,\n         layout: TyLayout<'tcx>\n@@ -78,12 +74,11 @@ impl<'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n             layout\n         }\n     }\n-}\n \n-impl OperandRef<'tcx, &'ll Value> {\n-    pub fn from_const(bx: &Builder<'a, 'll, 'tcx>,\n-                      val: &'tcx ty::Const<'tcx>)\n-                      -> Result<OperandRef<'tcx, &'ll Value>, ErrorHandled> {\n+    pub fn from_const<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        bx: &Bx,\n+        val: &'tcx ty::Const<'tcx>\n+    ) -> Result<Self, ErrorHandled> {\n         let layout = bx.cx().layout_of(val.ty);\n \n         if layout.is_zst() {\n@@ -97,11 +92,10 @@ impl OperandRef<'tcx, &'ll Value> {\n                     layout::Abi::Scalar(ref x) => x,\n                     _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n                 };\n-                let llval = scalar_to_llvm(\n-                    bx.cx(),\n+                let llval = bx.cx().scalar_to_backend(\n                     x,\n                     scalar,\n-                    layout.immediate_llvm_type(bx.cx()),\n+                    bx.cx().immediate_backend_type(layout),\n                 );\n                 OperandValue::Immediate(llval)\n             },\n@@ -110,23 +104,20 @@ impl OperandRef<'tcx, &'ll Value> {\n                     layout::Abi::ScalarPair(ref a, ref b) => (a, b),\n                     _ => bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout)\n                 };\n-                let a_llval = scalar_to_llvm(\n-                    bx.cx(),\n+                let a_llval = bx.cx().scalar_to_backend(\n                     a,\n                     a_scalar,\n-                    layout.scalar_pair_element_llvm_type(bx.cx(), 0, true),\n+                    bx.cx().scalar_pair_element_backend_type(layout, 0, true),\n                 );\n-                let b_layout = layout.scalar_pair_element_llvm_type(bx.cx(), 1, true);\n-                let b_llval = scalar_to_llvm(\n-                    bx.cx(),\n+                let b_llval = bx.cx().scalar_to_backend(\n                     b,\n                     b_scalar,\n-                    b_layout,\n+                    bx.cx().scalar_pair_element_backend_type(layout, 1, true),\n                 );\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n             ConstValue::ByRef(_, alloc, offset) => {\n-                return Ok(bx.load_operand(PlaceRef::from_const_alloc(bx, layout, alloc, offset)));\n+                return Ok(bx.load_operand(bx.cx().from_const_alloc(layout, alloc, offset)));\n             },\n         };\n \n@@ -138,14 +129,17 @@ impl OperandRef<'tcx, &'ll Value> {\n \n     /// Asserts that this operand refers to a scalar and returns\n     /// a reference to its value.\n-    pub fn immediate(self) -> &'ll Value {\n+    pub fn immediate(self) -> V {\n         match self.val {\n             OperandValue::Immediate(s) => s,\n             _ => bug!(\"not immediate: {:?}\", self)\n         }\n     }\n \n-    pub fn deref(self, cx: &CodegenCx<'ll, 'tcx>) -> PlaceRef<'tcx, &'ll Value> {\n+    pub fn deref<Cx: CodegenMethods<'tcx, Value = V>>(\n+        self,\n+        cx: &Cx\n+    ) -> PlaceRef<'tcx, V> {\n         let projected_ty = self.layout.ty.builtin_deref(true)\n             .unwrap_or_else(|| bug!(\"deref of non-pointer {:?}\", self)).ty;\n         let (llptr, llextra) = match self.val {\n@@ -164,9 +158,12 @@ impl OperandRef<'tcx, &'ll Value> {\n \n     /// If this operand is a `Pair`, we return an aggregate with the two values.\n     /// For other cases, see `immediate`.\n-    pub fn immediate_or_packed_pair(self, bx: &Builder<'a, 'll, 'tcx>) -> &'ll Value {\n+    pub fn immediate_or_packed_pair<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        self,\n+        bx: &Bx\n+    ) -> V {\n         if let OperandValue::Pair(a, b) = self.val {\n-            let llty = self.layout.llvm_type(bx.cx());\n+            let llty = bx.cx().backend_type(self.layout);\n             debug!(\"Operand::immediate_or_packed_pair: packing {:?} into {:?}\",\n                    self, llty);\n             // Reconstruct the immediate aggregate.\n@@ -180,10 +177,11 @@ impl OperandRef<'tcx, &'ll Value> {\n     }\n \n     /// If the type is a pair, we return a `Pair`, otherwise, an `Immediate`.\n-    pub fn from_immediate_or_packed_pair(bx: &Builder<'a, 'll, 'tcx>,\n-                                         llval: &'ll Value,\n-                                         layout: TyLayout<'tcx>)\n-                                         -> OperandRef<'tcx, &'ll Value> {\n+    pub fn from_immediate_or_packed_pair<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        bx: &Bx,\n+        llval: V,\n+        layout: TyLayout<'tcx>\n+    ) -> Self {\n         let val = if let layout::Abi::ScalarPair(ref a, ref b) = layout.abi {\n             debug!(\"Operand::from_immediate_or_packed_pair: unpacking {:?} @ {:?}\",\n                     llval, layout);\n@@ -198,11 +196,11 @@ impl OperandRef<'tcx, &'ll Value> {\n         OperandRef { val, layout }\n     }\n \n-    pub fn extract_field(\n+    pub fn extract_field<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         &self,\n-        bx: &Builder<'a, 'll, 'tcx>,\n-        i: usize,\n-    ) -> OperandRef<'tcx, &'ll Value> {\n+        bx: &Bx,\n+        i: usize\n+    ) -> Self {\n         let field = self.layout.field(bx.cx(), i);\n         let offset = self.layout.fields.offset(i);\n \n@@ -244,11 +242,11 @@ impl OperandRef<'tcx, &'ll Value> {\n         // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n         match val {\n             OperandValue::Immediate(ref mut llval) => {\n-                *llval = bx.bitcast(*llval, field.immediate_llvm_type(bx.cx()));\n+                *llval = bx.bitcast(*llval, bx.cx().immediate_backend_type(field));\n             }\n             OperandValue::Pair(ref mut a, ref mut b) => {\n-                *a = bx.bitcast(*a, field.scalar_pair_element_llvm_type(bx.cx(), 0, true));\n-                *b = bx.bitcast(*b, field.scalar_pair_element_llvm_type(bx.cx(), 1, true));\n+                *a = bx.bitcast(*a, bx.cx().scalar_pair_element_backend_type(field, 0, true));\n+                *b = bx.bitcast(*b, bx.cx().scalar_pair_element_backend_type(field, 1, true));\n             }\n             OperandValue::Ref(..) => bug!()\n         }\n@@ -264,46 +262,39 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandValue<V> {\n     pub fn store<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         self,\n         bx: &Bx,\n-        dest: PlaceRef<'tcx, Bx::Value>\n+        dest: PlaceRef<'tcx, V>\n     ) {\n         self.store_with_flags(bx, dest, MemFlags::empty());\n     }\n-}\n-\n-impl OperandValue<&'ll Value> {\n \n-    pub fn volatile_store(\n+    pub fn volatile_store<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         self,\n-        bx: &Builder<'a, 'll, 'tcx>,\n-        dest: PlaceRef<'tcx, &'ll Value>\n+        bx: &Bx,\n+        dest: PlaceRef<'tcx, V>\n     ) {\n         self.store_with_flags(bx, dest, MemFlags::VOLATILE);\n     }\n \n-    pub fn unaligned_volatile_store(\n+    pub fn unaligned_volatile_store<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         self,\n-        bx: &Builder<'a, 'll, 'tcx>,\n-        dest: PlaceRef<'tcx, &'ll Value>,\n+        bx: &Bx,\n+        dest: PlaceRef<'tcx, V>,\n     ) {\n         self.store_with_flags(bx, dest, MemFlags::VOLATILE | MemFlags::UNALIGNED);\n     }\n-}\n \n-impl<'a, 'll: 'a, 'tcx: 'll> OperandValue<&'ll Value> {\n-    pub fn nontemporal_store(\n+    pub fn nontemporal_store<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         self,\n-        bx: &Builder<'a, 'll, 'tcx>,\n-        dest: PlaceRef<'tcx, &'ll Value>\n+        bx: &Bx,\n+        dest: PlaceRef<'tcx, V>\n     ) {\n         self.store_with_flags(bx, dest, MemFlags::NONTEMPORAL);\n     }\n-}\n \n-impl<'a, 'tcx: 'a, V: CodegenObject> OperandValue<V> {\n     fn store_with_flags<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         self,\n         bx: &Bx,\n-        dest: PlaceRef<'tcx, Bx::Value>,\n+        dest: PlaceRef<'tcx, V>,\n         flags: MemFlags,\n     ) {\n         debug!(\"OperandRef::store: operand={:?}, dest={:?}\", self, dest);\n@@ -333,13 +324,10 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandValue<V> {\n             }\n         }\n     }\n-}\n-\n-impl OperandValue<&'ll Value> {\n-    pub fn store_unsized(\n+    pub fn store_unsized<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         self,\n-        bx: &Builder<'a, 'll, 'tcx>,\n-        indirect_dest: PlaceRef<'tcx, &'ll Value>\n+        bx: &Bx,\n+        indirect_dest: PlaceRef<'tcx, V>\n     ) {\n         debug!(\"OperandRef::store_unsized: operand={:?}, indirect_dest={:?}\", self, indirect_dest);\n         let flags = MemFlags::empty();\n@@ -370,12 +358,12 @@ impl OperandValue<&'ll Value> {\n     }\n }\n \n-impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n-    fn maybe_codegen_consume_direct(&mut self,\n-                                  bx: &Builder<'a, 'll, 'tcx>,\n-                                  place: &mir::Place<'tcx>)\n-                                   -> Option<OperandRef<'tcx, &'ll Value>>\n-    {\n+impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+    fn maybe_codegen_consume_direct(\n+        &mut self,\n+        bx: &Bx,\n+        place: &mir::Place<'tcx>\n+    ) -> Option<OperandRef<'tcx, Bx::Value>> {\n         debug!(\"maybe_codegen_consume_direct(place={:?})\", place);\n \n         // watch out for locals that do not have an\n@@ -419,11 +407,11 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         None\n     }\n \n-    pub fn codegen_consume(&mut self,\n-                         bx: &Builder<'a, 'll, 'tcx>,\n-                         place: &mir::Place<'tcx>)\n-                         -> OperandRef<'tcx, &'ll Value>\n-    {\n+    pub fn codegen_consume(\n+        &mut self,\n+        bx: &Bx,\n+        place: &mir::Place<'tcx>\n+    ) -> OperandRef<'tcx, Bx::Value> {\n         debug!(\"codegen_consume(place={:?})\", place);\n \n         let ty = self.monomorphized_place_ty(place);\n@@ -443,11 +431,11 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         bx.load_operand(self.codegen_place(bx, place))\n     }\n \n-    pub fn codegen_operand(&mut self,\n-                         bx: &Builder<'a, 'll, 'tcx>,\n-                         operand: &mir::Operand<'tcx>)\n-                         -> OperandRef<'tcx, &'ll Value>\n-    {\n+    pub fn codegen_operand(\n+        &mut self,\n+        bx: &Bx,\n+        operand: &mir::Operand<'tcx>\n+    ) -> OperandRef<'tcx, Bx::Value> {\n         debug!(\"codegen_operand(operand={:?})\", operand);\n \n         match *operand {\n@@ -475,7 +463,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         // We've errored, so we don't have to produce working code.\n                         let layout = bx.cx().layout_of(ty);\n                         bx.load_operand(PlaceRef::new_sized(\n-                            bx.cx().const_undef(bx.cx().type_ptr_to(layout.llvm_type(bx.cx()))),\n+                            bx.cx().const_undef(bx.cx().type_ptr_to(bx.cx().backend_type(layout))),\n                             layout,\n                             layout.align,\n                         ))"}, {"sha": "549dc31612ca76b4e65d6ab495c8a1dc20ee85cb", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 61, "deletions": 69, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -8,17 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::LLVMConstInBoundsGEP;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, Size, VariantIdx, HasTyCtxt};\n+use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n use rustc::mir;\n use rustc::mir::tcx::PlaceTy;\n-use builder::{Builder, MemFlags};\n-use common::{CodegenCx, IntPredicate};\n+use builder::MemFlags;\n+use common::IntPredicate;\n use type_of::LayoutLlvmExt;\n-use value::Value;\n use glue;\n-use mir::constant::const_alloc_to_llvm;\n \n use interfaces::*;\n \n@@ -40,12 +37,12 @@ pub struct PlaceRef<'tcx, V> {\n     pub align: Align,\n }\n \n-impl PlaceRef<'tcx, &'ll Value> {\n+impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n     pub fn new_sized(\n-        llval: &'ll Value,\n+        llval: V,\n         layout: TyLayout<'tcx>,\n         align: Align,\n-    ) -> PlaceRef<'tcx, &'ll Value> {\n+    ) -> PlaceRef<'tcx, V> {\n         assert!(!layout.is_unsized());\n         PlaceRef {\n             llval,\n@@ -55,46 +52,34 @@ impl PlaceRef<'tcx, &'ll Value> {\n         }\n     }\n \n-    pub fn from_const_alloc(\n-        bx: &Builder<'a, 'll, 'tcx>,\n+    pub fn alloca<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        bx: &Bx,\n         layout: TyLayout<'tcx>,\n-        alloc: &mir::interpret::Allocation,\n-        offset: Size,\n-    ) -> PlaceRef<'tcx, &'ll Value> {\n-        let init = const_alloc_to_llvm(bx.cx(), alloc);\n-        let base_addr = bx.cx().static_addr_of(init, layout.align, None);\n-\n-        let llval = unsafe { LLVMConstInBoundsGEP(\n-            bx.cx().static_bitcast(base_addr, bx.cx().type_i8p()),\n-            &bx.cx().const_usize(offset.bytes()),\n-            1,\n-        )};\n-        let llval = bx.cx().static_bitcast(llval, bx.cx().type_ptr_to(layout.llvm_type(bx.cx())));\n-        PlaceRef::new_sized(llval, layout, alloc.align)\n-    }\n-\n-    pub fn alloca(bx: &Builder<'a, 'll, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n-                  -> PlaceRef<'tcx, &'ll Value> {\n+        name: &str\n+    ) -> Self {\n         debug!(\"alloca({:?}: {:?})\", name, layout);\n         assert!(!layout.is_unsized(), \"tried to statically allocate unsized place\");\n-        let tmp = bx.alloca(layout.llvm_type(bx.cx()), name, layout.align);\n+        let tmp = bx.alloca(bx.cx().backend_type(layout), name, layout.align);\n         Self::new_sized(tmp, layout, layout.align)\n     }\n \n     /// Returns a place for an indirect reference to an unsized place.\n-    pub fn alloca_unsized_indirect(\n-        bx: &Builder<'a, 'll, 'tcx>,\n+    pub fn alloca_unsized_indirect<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        bx: &Bx,\n         layout: TyLayout<'tcx>,\n         name: &str,\n-    ) -> PlaceRef<'tcx, &'ll Value> {\n+    ) -> Self {\n         debug!(\"alloca_unsized_indirect({:?}: {:?})\", name, layout);\n         assert!(layout.is_unsized(), \"tried to allocate indirect place for sized values\");\n-        let ptr_ty = bx.cx().tcx.mk_mut_ptr(layout.ty);\n+        let ptr_ty = bx.cx().tcx().mk_mut_ptr(layout.ty);\n         let ptr_layout = bx.cx().layout_of(ptr_ty);\n         Self::alloca(bx, ptr_layout, name)\n     }\n \n-    pub fn len(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Value {\n+    pub fn len<Cx: CodegenMethods<'tcx, Value = V>>(\n+        &self,\n+        cx: &Cx\n+    ) -> V {\n         if let layout::FieldPlacement::Array { count, .. } = self.layout.fields {\n             if self.layout.is_unsized() {\n                 assert_eq!(count, 0);\n@@ -114,7 +99,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n     pub fn project_field<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         self, bx: &Bx,\n         ix: usize,\n-    ) -> PlaceRef<'tcx, Bx::Value> {\n+    ) -> Self {\n         let cx = bx.cx();\n         let field = self.layout.field(cx, ix);\n         let offset = self.layout.fields.offset(ix);\n@@ -216,25 +201,22 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n             align: effective_field_align,\n         }\n     }\n-}\n-\n-impl PlaceRef<'tcx, &'ll Value> {\n \n     /// Obtain the actual discriminant of a value.\n-    pub fn codegen_get_discr(\n+    pub fn codegen_get_discr<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         self,\n-        bx: &Builder<'a, 'll, 'tcx>,\n+        bx: &Bx,\n         cast_to: Ty<'tcx>\n-    ) -> &'ll Value {\n-        let cast_to = bx.cx().layout_of(cast_to).immediate_llvm_type(bx.cx());\n+    ) -> V {\n+        let cast_to = bx.cx().immediate_backend_type(bx.cx().layout_of(cast_to));\n         if self.layout.abi.is_uninhabited() {\n             return bx.cx().const_undef(cast_to);\n         }\n         match self.layout.variants {\n             layout::Variants::Single { index } => {\n                 let discr_val = self.layout.ty.ty_adt_def().map_or(\n                     index.as_u32() as u128,\n-                    |def| def.discriminant_for_variant(bx.cx().tcx, index).val);\n+                    |def| def.discriminant_for_variant(bx.cx().tcx(), index).val);\n                 return bx.cx().const_uint_big(cast_to, discr_val);\n             }\n             layout::Variants::Tagged { .. } |\n@@ -262,7 +244,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n                 niche_start,\n                 ..\n             } => {\n-                let niche_llty = discr.layout.immediate_llvm_type(bx.cx());\n+                let niche_llty = bx.cx().immediate_backend_type(discr.layout);\n                 if niche_variants.start() == niche_variants.end() {\n                     // FIXME(eddyb) Check the actual primitive type here.\n                     let niche_llval = if niche_start == 0 {\n@@ -290,7 +272,11 @@ impl PlaceRef<'tcx, &'ll Value> {\n \n     /// Set the discriminant for a new value of the given case of the given\n     /// representation.\n-    pub fn codegen_set_discr(&self, bx: &Builder<'a, 'll, 'tcx>, variant_index: VariantIdx) {\n+    pub fn codegen_set_discr<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        &self,\n+        bx: &Bx,\n+        variant_index: VariantIdx\n+    ) {\n         if self.layout.for_variant(bx.cx(), variant_index).abi.is_uninhabited() {\n             return;\n         }\n@@ -304,7 +290,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n                     .discriminant_for_variant(bx.tcx(), variant_index)\n                     .val;\n                 bx.store(\n-                    bx.cx().const_uint_big(ptr.layout.llvm_type(bx.cx()), to),\n+                    bx.cx().const_uint_big(bx.cx().backend_type(ptr.layout), to),\n                     ptr.llval,\n                     ptr.align);\n             }\n@@ -315,8 +301,8 @@ impl PlaceRef<'tcx, &'ll Value> {\n                 ..\n             } => {\n                 if variant_index != dataful_variant {\n-                    if bx.sess().target.target.arch == \"arm\" ||\n-                       bx.sess().target.target.arch == \"aarch64\" {\n+                    if bx.cx().sess().target.target.arch == \"arm\" ||\n+                       bx.cx().sess().target.target.arch == \"aarch64\" {\n                         // Issue #34427: As workaround for LLVM bug on ARM,\n                         // use memset of 0 before assigning niche value.\n                         let fill_byte = bx.cx().const_u8(0);\n@@ -326,7 +312,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n                     }\n \n                     let niche = self.project_field(bx, 0);\n-                    let niche_llty = niche.layout.immediate_llvm_type(bx.cx());\n+                    let niche_llty = bx.cx().immediate_backend_type(niche.layout);\n                     let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n                     let niche_value = (niche_value as u128)\n                         .wrapping_add(niche_start);\n@@ -343,8 +329,11 @@ impl PlaceRef<'tcx, &'ll Value> {\n         }\n     }\n \n-    pub fn project_index(&self, bx: &Builder<'a, 'll, 'tcx>, llindex: &'ll Value)\n-                         -> PlaceRef<'tcx, &'ll Value> {\n+    pub fn project_index<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        &self,\n+        bx: &Bx,\n+        llindex: V\n+    ) -> Self {\n         PlaceRef {\n             llval: bx.inbounds_gep(self.llval, &[bx.cx().const_usize(0), llindex]),\n             llextra: None,\n@@ -353,44 +342,48 @@ impl PlaceRef<'tcx, &'ll Value> {\n         }\n     }\n \n-    pub fn project_downcast(&self, bx: &Builder<'a, 'll, 'tcx>, variant_index: VariantIdx)\n-                            -> PlaceRef<'tcx, &'ll Value> {\n+    pub fn project_downcast<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        &self,\n+        bx: &Bx,\n+        variant_index: VariantIdx\n+    ) -> Self {\n         let mut downcast = *self;\n         downcast.layout = self.layout.for_variant(bx.cx(), variant_index);\n \n         // Cast to the appropriate variant struct type.\n-        let variant_ty = downcast.layout.llvm_type(bx.cx());\n+        let variant_ty = bx.cx().backend_type(downcast.layout);\n         downcast.llval = bx.pointercast(downcast.llval, bx.cx().type_ptr_to(variant_ty));\n \n         downcast\n     }\n \n-    pub fn storage_live(&self, bx: &Builder<'a, 'll, 'tcx>) {\n+    pub fn storage_live<Bx: BuilderMethods<'a, 'tcx, Value = V>>(&self, bx: &Bx) {\n         bx.lifetime_start(self.llval, self.layout.size);\n     }\n \n-    pub fn storage_dead(&self, bx: &Builder<'a, 'll, 'tcx>) {\n+    pub fn storage_dead<Bx: BuilderMethods<'a, 'tcx, Value = V>>(&self, bx: &Bx) {\n         bx.lifetime_end(self.llval, self.layout.size);\n     }\n }\n \n-impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n-    pub fn codegen_place(&mut self,\n-                        bx: &Builder<'a, 'll, 'tcx>,\n-                        place: &mir::Place<'tcx>)\n-                        -> PlaceRef<'tcx, &'ll Value> {\n+impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+    pub fn codegen_place(\n+        &mut self,\n+        bx: &Bx,\n+        place: &mir::Place<'tcx>\n+    ) -> PlaceRef<'tcx, Bx::Value> {\n         debug!(\"codegen_place(place={:?})\", place);\n \n         let cx = bx.cx();\n-        let tcx = cx.tcx;\n+        let tcx = cx.tcx();\n \n         if let mir::Place::Local(index) = *place {\n             match self.locals[index] {\n                 LocalRef::Place(place) => {\n                     return place;\n                 }\n                 LocalRef::UnsizedPlace(place) => {\n-                    return bx.load_operand(place).deref(&cx);\n+                    return bx.load_operand(place).deref(cx);\n                 }\n                 LocalRef::Operand(..) => {\n                     bug!(\"using operand local {:?} as place\", place);\n@@ -410,7 +403,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 match bx.tcx().const_eval(param_env.and(cid)) {\n                     Ok(val) => match val.val {\n                         mir::interpret::ConstValue::ByRef(_, alloc, offset) => {\n-                            PlaceRef::from_const_alloc(bx, layout, alloc, offset)\n+                            bx.cx().from_const_alloc(layout, alloc, offset)\n                         }\n                         _ => bug!(\"promoteds should have an allocation: {:?}\", val),\n                     },\n@@ -422,7 +415,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         let fnname = bx.cx().get_intrinsic(&(\"llvm.trap\"));\n                         bx.call(fnname, &[], None);\n                         let llval = bx.cx().const_undef(\n-                            bx.cx().type_ptr_to(layout.llvm_type(bx.cx()))\n+                            bx.cx().type_ptr_to(bx.cx().backend_type(layout))\n                         );\n                         PlaceRef::new_sized(llval, layout, layout.align)\n                     }\n@@ -471,8 +464,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         let mut subslice = cg_base.project_index(bx,\n                             bx.cx().const_usize(from as u64));\n                         let projected_ty = PlaceTy::Ty { ty: cg_base.layout.ty }\n-                            .projection_ty(tcx, &projection.elem)\n-                            .to_ty(bx.tcx());\n+                            .projection_ty(tcx, &projection.elem).to_ty(tcx);\n                         subslice.layout = bx.cx().layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {\n@@ -483,7 +475,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         // Cast the place pointer type to the new\n                         // array or slice type (*[%_; new_len]).\n                         subslice.llval = bx.pointercast(subslice.llval,\n-                            bx.cx().type_ptr_to(subslice.layout.llvm_type(bx.cx())));\n+                            bx.cx().type_ptr_to(bx.cx().backend_type(subslice.layout)));\n \n                         subslice\n                     }\n@@ -498,7 +490,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n     }\n \n     pub fn monomorphized_place_ty(&self, place: &mir::Place<'tcx>) -> Ty<'tcx> {\n-        let tcx = self.cx.tcx;\n+        let tcx = self.cx.tcx();\n         let place_ty = place.ty(self.mir, tcx);\n         self.monomorphize(&place_ty.to_ty(tcx))\n     }"}, {"sha": "4f57a1dfd60d3dd0356e92942c4308c0ce95b560", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 86, "deletions": 78, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -17,27 +17,25 @@ use rustc_apfloat::{ieee, Float, Status, Round};\n use std::{u128, i128};\n \n use base;\n-use builder::{Builder, MemFlags};\n+use builder::MemFlags;\n use callee;\n use common::{self, IntPredicate, RealPredicate};\n use monomorphize;\n-use type_::Type;\n use type_of::LayoutLlvmExt;\n-use value::Value;\n \n use interfaces::*;\n \n use super::{FunctionCx, LocalRef};\n use super::operand::{OperandRef, OperandValue};\n use super::place::PlaceRef;\n \n-impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n-    pub fn codegen_rvalue(&mut self,\n-                        bx: Builder<'a, 'll, 'tcx>,\n-                        dest: PlaceRef<'tcx, &'ll Value>,\n-                        rvalue: &mir::Rvalue<'tcx>)\n-                        -> Builder<'a, 'll, 'tcx>\n-    {\n+impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+    pub fn codegen_rvalue(\n+        &mut self,\n+        bx: Bx,\n+        dest: PlaceRef<'tcx, Bx::Value>,\n+        rvalue: &mir::Rvalue<'tcx>\n+    ) -> Bx {\n         debug!(\"codegen_rvalue(dest.llval={:?}, rvalue={:?})\",\n                dest.llval, rvalue);\n \n@@ -176,12 +174,12 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         }\n     }\n \n-    pub fn codegen_rvalue_unsized(&mut self,\n-                        bx: Builder<'a, 'll, 'tcx>,\n-                        indirect_dest: PlaceRef<'tcx, &'ll Value>,\n-                        rvalue: &mir::Rvalue<'tcx>)\n-                        -> Builder<'a, 'll, 'tcx>\n-    {\n+    pub fn codegen_rvalue_unsized(\n+        &mut self,\n+        bx: Bx,\n+        indirect_dest: PlaceRef<'tcx, Bx::Value>,\n+        rvalue: &mir::Rvalue<'tcx>,\n+    ) -> Bx {\n         debug!(\"codegen_rvalue_unsized(indirect_dest.llval={:?}, rvalue={:?})\",\n                indirect_dest.llval, rvalue);\n \n@@ -198,9 +196,9 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n     pub fn codegen_rvalue_operand(\n         &mut self,\n-        bx: Builder<'a, 'll, 'tcx>,\n+        bx: Bx,\n         rvalue: &mir::Rvalue<'tcx>\n-    ) -> (Builder<'a, 'll, 'tcx>, OperandRef<'tcx, &'ll Value>) {\n+    ) -> (Bx, OperandRef<'tcx, Bx::Value>) {\n         assert!(self.rvalue_creates_operand(rvalue), \"cannot codegen {:?} to operand\", rvalue);\n \n         match *rvalue {\n@@ -213,7 +211,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     mir::CastKind::ReifyFnPointer => {\n                         match operand.layout.ty.sty {\n                             ty::FnDef(def_id, substs) => {\n-                                if bx.cx().tcx.has_attr(def_id, \"rustc_args_required_const\") {\n+                                if bx.cx().tcx().has_attr(def_id, \"rustc_args_required_const\") {\n                                     bug!(\"reifying a fn ptr that requires \\\n                                           const arguments\");\n                                 }\n@@ -229,8 +227,8 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         match operand.layout.ty.sty {\n                             ty::Closure(def_id, substs) => {\n                                 let instance = monomorphize::resolve_closure(\n-                                    bx.cx().tcx, def_id, substs, ty::ClosureKind::FnOnce);\n-                                OperandValue::Immediate(callee::get_fn(bx.cx(), instance))\n+                                    bx.cx().tcx(), def_id, substs, ty::ClosureKind::FnOnce);\n+                                OperandValue::Immediate(bx.cx().get_fn(instance))\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be cast to a fn ptr\", operand.layout.ty)\n@@ -253,7 +251,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                                 // HACK(eddyb) have to bitcast pointers\n                                 // until LLVM removes pointee types.\n                                 let lldata = bx.pointercast(lldata,\n-                                    cast.scalar_pair_element_llvm_type(bx.cx(), 0, true));\n+                                    bx.cx().scalar_pair_element_backend_type(cast, 0, true));\n                                 OperandValue::Pair(lldata, llextra)\n                             }\n                             OperandValue::Immediate(lldata) => {\n@@ -272,12 +270,12 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         if let OperandValue::Pair(data_ptr, meta) = operand.val {\n                             if cast.is_llvm_scalar_pair() {\n                                 let data_cast = bx.pointercast(data_ptr,\n-                                    cast.scalar_pair_element_llvm_type(bx.cx(), 0, true));\n+                                    bx.cx().scalar_pair_element_backend_type(cast, 0, true));\n                                 OperandValue::Pair(data_cast, meta)\n                             } else { // cast to thin-ptr\n                                 // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n                                 // pointer-cast of that pointer to desired pointer type.\n-                                let llcast_ty = cast.immediate_llvm_type(bx.cx());\n+                                let llcast_ty = bx.cx().immediate_backend_type(cast);\n                                 let llval = bx.pointercast(data_ptr, llcast_ty);\n                                 OperandValue::Immediate(llval)\n                             }\n@@ -287,7 +285,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     }\n                     mir::CastKind::Misc => {\n                         assert!(cast.is_llvm_immediate());\n-                        let ll_t_out = cast.immediate_llvm_type(bx.cx());\n+                        let ll_t_out = bx.cx().immediate_backend_type(cast);\n                         if operand.layout.abi.is_uninhabited() {\n                             let val = OperandValue::Immediate(bx.cx().const_undef(ll_t_out));\n                             return (bx, OperandRef {\n@@ -298,12 +296,12 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         let r_t_in = CastTy::from_ty(operand.layout.ty)\n                             .expect(\"bad input type for cast\");\n                         let r_t_out = CastTy::from_ty(cast.ty).expect(\"bad output type for cast\");\n-                        let ll_t_in = operand.layout.immediate_llvm_type(bx.cx());\n+                        let ll_t_in = bx.cx().immediate_backend_type(operand.layout);\n                         match operand.layout.variants {\n                             layout::Variants::Single { index } => {\n                                 if let Some(def) = operand.layout.ty.ty_adt_def() {\n                                     let discr_val = def\n-                                        .discriminant_for_variant(bx.cx().tcx, index)\n+                                        .discriminant_for_variant(bx.cx().tcx(), index)\n                                         .val;\n                                     let discr = bx.cx().const_uint_big(ll_t_out, discr_val);\n                                     return (bx, OperandRef {\n@@ -365,7 +363,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                             (CastTy::FnPtr, CastTy::Int(_)) =>\n                                 bx.ptrtoint(llval, ll_t_out),\n                             (CastTy::Int(_), CastTy::Ptr(_)) => {\n-                                let usize_llval = bx.intcast(llval, bx.cx().isize_ty, signed);\n+                                let usize_llval = bx.intcast(llval, bx.cx().type_isize(), signed);\n                                 bx.inttoptr(usize_llval, ll_t_out)\n                             }\n                             (CastTy::Int(_), CastTy::Float) =>\n@@ -399,8 +397,8 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 };\n                 (bx, OperandRef {\n                     val,\n-                    layout: self.cx.layout_of(self.cx.tcx.mk_ref(\n-                        self.cx.tcx.types.re_erased,\n+                    layout: self.cx.layout_of(self.cx.tcx().mk_ref(\n+                        self.cx.tcx().types.re_erased,\n                         ty::TypeAndMut { ty, mutbl: bk.to_mutbl_lossy() }\n                     )),\n                 })\n@@ -487,8 +485,8 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n                 assert!(bx.cx().type_is_sized(ty));\n-                let val = bx.cx().const_usize(bx.cx().size_of(ty).bytes());\n-                let tcx = self.cx.tcx;\n+                let val = bx.cx().const_usize(bx.cx().layout_of(ty).size.bytes());\n+                let tcx = self.cx.tcx();\n                 (bx, OperandRef {\n                     val: OperandValue::Immediate(val),\n                     layout: self.cx.layout_of(tcx.types.usize),\n@@ -497,21 +495,21 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n             mir::Rvalue::NullaryOp(mir::NullOp::Box, content_ty) => {\n                 let content_ty: Ty<'tcx> = self.monomorphize(&content_ty);\n-                let (size, align) = bx.cx().size_and_align_of(content_ty);\n+                let (size, align) = bx.cx().layout_of(content_ty).size_and_align();\n                 let llsize = bx.cx().const_usize(size.bytes());\n                 let llalign = bx.cx().const_usize(align.abi());\n                 let box_layout = bx.cx().layout_of(bx.tcx().mk_box(content_ty));\n-                let llty_ptr = box_layout.llvm_type(bx.cx());\n+                let llty_ptr = bx.cx().backend_type(box_layout);\n \n                 // Allocate space:\n                 let def_id = match bx.tcx().lang_items().require(ExchangeMallocFnLangItem) {\n                     Ok(id) => id,\n                     Err(s) => {\n-                        bx.sess().fatal(&format!(\"allocation of `{}` {}\", box_layout.ty, s));\n+                        bx.cx().sess().fatal(&format!(\"allocation of `{}` {}\", box_layout.ty, s));\n                     }\n                 };\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                let r = callee::get_fn(bx.cx(), instance);\n+                let r = bx.cx().get_fn(instance);\n                 let val = bx.pointercast(bx.call(r, &[llsize, llalign], None), llty_ptr);\n \n                 let operand = OperandRef {\n@@ -528,7 +526,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             mir::Rvalue::Aggregate(..) => {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n-                let ty = rvalue.ty(self.mir, self.cx.tcx);\n+                let ty = rvalue.ty(self.mir, self.cx.tcx());\n                 (bx, OperandRef::new_zst(self.cx,\n                     self.cx.layout_of(self.monomorphize(&ty))))\n             }\n@@ -537,32 +535,32 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n     fn evaluate_array_len(\n         &mut self,\n-        bx: &Builder<'a, 'll, 'tcx>,\n+        bx: &Bx,\n         place: &mir::Place<'tcx>,\n-    ) -> &'ll Value {\n+    ) -> Bx::Value {\n         // ZST are passed as operands and require special handling\n         // because codegen_place() panics if Local is operand.\n         if let mir::Place::Local(index) = *place {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::Array(_, n) = op.layout.ty.sty {\n-                    let n = n.unwrap_usize(bx.cx().tcx);\n+                    let n = n.unwrap_usize(bx.cx().tcx());\n                     return bx.cx().const_usize(n);\n                 }\n             }\n         }\n         // use common size calculation for non zero-sized types\n-        let cg_value = self.codegen_place(&bx, place);\n+        let cg_value = self.codegen_place(bx, place);\n         return cg_value.len(bx.cx());\n     }\n \n     pub fn codegen_scalar_binop(\n         &mut self,\n-        bx: &Builder<'a, 'll, 'tcx>,\n+        bx: &Bx,\n         op: mir::BinOp,\n-        lhs: &'ll Value,\n-        rhs: &'ll Value,\n+        lhs: Bx::Value,\n+        rhs: Bx::Value,\n         input_ty: Ty<'tcx>,\n-    ) -> &'ll Value {\n+    ) -> Bx::Value {\n         let is_float = input_ty.is_fp();\n         let is_signed = input_ty.is_signed();\n         let is_unit = input_ty.is_unit();\n@@ -625,14 +623,14 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n     pub fn codegen_fat_ptr_binop(\n         &mut self,\n-        bx: &Builder<'a, 'll, 'tcx>,\n+        bx: &Bx,\n         op: mir::BinOp,\n-        lhs_addr: &'ll Value,\n-        lhs_extra: &'ll Value,\n-        rhs_addr: &'ll Value,\n-        rhs_extra: &'ll Value,\n+        lhs_addr: Bx::Value,\n+        lhs_extra: Bx::Value,\n+        rhs_addr: Bx::Value,\n+        rhs_extra: Bx::Value,\n         _input_ty: Ty<'tcx>,\n-    ) -> &'ll Value {\n+    ) -> Bx::Value {\n         match op {\n             mir::BinOp::Eq => {\n                 bx.and(\n@@ -671,17 +669,19 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         }\n     }\n \n-    pub fn codegen_scalar_checked_binop(&mut self,\n-                                      bx: &Builder<'a, 'll, 'tcx>,\n-                                      op: mir::BinOp,\n-                                      lhs: &'ll Value,\n-                                      rhs: &'ll Value,\n-                                      input_ty: Ty<'tcx>) -> OperandValue<&'ll Value> {\n+    pub fn codegen_scalar_checked_binop(\n+        &mut self,\n+        bx: &Bx,\n+        op: mir::BinOp,\n+        lhs: Bx::Value,\n+        rhs: Bx::Value,\n+        input_ty: Ty<'tcx>\n+    ) -> OperandValue<Bx::Value> {\n         // This case can currently arise only from functions marked\n         // with #[rustc_inherit_overflow_checks] and inlined from\n         // another crate (mostly core::num generic/#[inline] fns),\n         // while the current crate doesn't use overflow checks.\n-        if !bx.cx().check_overflow {\n+        if !bx.cx().check_overflow() {\n             let val = self.codegen_scalar_binop(bx, op, lhs, rhs, input_ty);\n             return OperandValue::Pair(val, bx.cx().const_bool(false));\n         }\n@@ -704,7 +704,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             mir::BinOp::Shl | mir::BinOp::Shr => {\n                 let lhs_llty = bx.cx().val_ty(lhs);\n                 let rhs_llty = bx.cx().val_ty(rhs);\n-                let invert_mask = common::shift_mask_val(&bx, lhs_llty, rhs_llty, true);\n+                let invert_mask = common::shift_mask_val(bx, lhs_llty, rhs_llty, true);\n                 let outer_bits = bx.and(rhs, invert_mask);\n \n                 let of = bx.icmp(IntPredicate::IntNE, outer_bits, bx.cx().const_null(rhs_llty));\n@@ -719,7 +719,9 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n         OperandValue::Pair(val, of)\n     }\n+}\n \n+impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn rvalue_creates_operand(&self, rvalue: &mir::Rvalue<'tcx>) -> bool {\n         match *rvalue {\n             mir::Rvalue::Ref(..) |\n@@ -734,7 +736,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 true,\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) => {\n-                let ty = rvalue.ty(self.mir, self.cx.tcx);\n+                let ty = rvalue.ty(self.mir, self.cx.tcx());\n                 let ty = self.monomorphize(&ty);\n                 self.cx.layout_of(ty).is_zst()\n             }\n@@ -749,11 +751,11 @@ enum OverflowOp {\n     Add, Sub, Mul\n }\n \n-fn get_overflow_intrinsic(\n+fn get_overflow_intrinsic<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     oop: OverflowOp,\n-    bx: &Builder<'_, 'll, '_>,\n+    bx: &Bx,\n     ty: Ty\n-) -> &'ll Value {\n+) -> Bx::Value {\n     use syntax::ast::IntTy::*;\n     use syntax::ast::UintTy::*;\n     use rustc::ty::{Int, Uint};\n@@ -818,11 +820,13 @@ fn get_overflow_intrinsic(\n     bx.cx().get_intrinsic(&name)\n }\n \n-fn cast_int_to_float(bx: &Builder<'_, 'll, '_>,\n-                     signed: bool,\n-                     x: &'ll Value,\n-                     int_ty: &'ll Type,\n-                     float_ty: &'ll Type) -> &'ll Value {\n+fn cast_int_to_float<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    signed: bool,\n+    x: Bx::Value,\n+    int_ty: Bx::Type,\n+    float_ty: Bx::Type\n+) -> Bx::Value {\n     // Most integer types, even i128, fit into [-f32::MAX, f32::MAX] after rounding.\n     // It's only u128 -> f32 that can cause overflows (i.e., should yield infinity).\n     // LLVM's uitofp produces undef in those cases, so we manually check for that case.\n@@ -850,18 +854,20 @@ fn cast_int_to_float(bx: &Builder<'_, 'll, '_>,\n     }\n }\n \n-fn cast_float_to_int(bx: &Builder<'_, 'll, '_>,\n-                     signed: bool,\n-                     x: &'ll Value,\n-                     float_ty: &'ll Type,\n-                     int_ty: &'ll Type) -> &'ll Value {\n+fn cast_float_to_int<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    signed: bool,\n+    x: Bx::Value,\n+    float_ty: Bx::Type,\n+    int_ty: Bx::Type\n+) -> Bx::Value {\n     let fptosui_result = if signed {\n         bx.fptosi(x, int_ty)\n     } else {\n         bx.fptoui(x, int_ty)\n     };\n \n-    if !bx.sess().opts.debugging_opts.saturating_float_casts {\n+    if !bx.cx().sess().opts.debugging_opts.saturating_float_casts {\n         return fptosui_result;\n     }\n     // LLVM's fpto[su]i returns undef when the input x is infinite, NaN, or does not fit into the\n@@ -883,30 +889,32 @@ fn cast_float_to_int(bx: &Builder<'_, 'll, '_>,\n     // On the other hand, f_max works even if int_ty::MAX is greater than float_ty::MAX. Because\n     // we're rounding towards zero, we just get float_ty::MAX (which is always an integer).\n     // This already happens today with u128::MAX = 2^128 - 1 > f32::MAX.\n-    let int_max = |signed: bool, int_ty: &'ll Type| -> u128 {\n+    let int_max = |signed: bool, int_ty: Bx::Type| -> u128 {\n         let shift_amount = 128 - bx.cx().int_width(int_ty);\n         if signed {\n             i128::MAX as u128 >> shift_amount\n         } else {\n             u128::MAX >> shift_amount\n         }\n     };\n-    let int_min = |signed: bool, int_ty: &'ll Type| -> i128 {\n+    let int_min = |signed: bool, int_ty: Bx::Type| -> i128 {\n         if signed {\n             i128::MIN >> (128 - bx.cx().int_width(int_ty))\n         } else {\n             0\n         }\n     };\n \n-    let compute_clamp_bounds_single = |signed: bool, int_ty: &'ll Type| -> (u128, u128) {\n+    let compute_clamp_bounds_single =\n+    |signed: bool, int_ty: Bx::Type| -> (u128, u128) {\n         let rounded_min = ieee::Single::from_i128_r(int_min(signed, int_ty), Round::TowardZero);\n         assert_eq!(rounded_min.status, Status::OK);\n         let rounded_max = ieee::Single::from_u128_r(int_max(signed, int_ty), Round::TowardZero);\n         assert!(rounded_max.value.is_finite());\n         (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n     };\n-    let compute_clamp_bounds_double = |signed: bool, int_ty: &'ll Type| -> (u128, u128) {\n+    let compute_clamp_bounds_double =\n+    |signed: bool, int_ty: Bx::Type| -> (u128, u128) {\n         let rounded_min = ieee::Double::from_i128_r(int_min(signed, int_ty), Round::TowardZero);\n         assert_eq!(rounded_min.status, Status::OK);\n         let rounded_max = ieee::Double::from_u128_r(int_max(signed, int_ty), Round::TowardZero);"}, {"sha": "40af52c05a374c9173b8c367efe2c00c75808fce", "filename": "src/librustc_codegen_llvm/mir/statement.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -10,20 +10,18 @@\n \n use rustc::mir;\n \n-use asm;\n-use builder::Builder;\n use interfaces::BuilderMethods;\n-\n use super::FunctionCx;\n use super::LocalRef;\n use super::OperandValue;\n-use value::Value;\n+use interfaces::*;\n \n-impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n-    pub fn codegen_statement(&mut self,\n-                           bx: Builder<'a, 'll, 'tcx>,\n-                           statement: &mir::Statement<'tcx>)\n-                           -> Builder<'a, 'll, 'tcx> {\n+impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+    pub fn codegen_statement(\n+        &mut self,\n+        bx: Bx,\n+        statement: &mir::Statement<'tcx>\n+    ) -> Bx {\n         debug!(\"codegen_statement(statement={:?})\", statement);\n \n         self.set_debug_loc(&bx, statement.source_info);\n@@ -91,16 +89,16 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         if let OperandValue::Immediate(_) = op.val {\n                             acc.push(op.immediate());\n                         } else {\n-                            span_err!(bx.sess(), span.to_owned(), E0669,\n+                            span_err!(bx.cx().sess(), span.to_owned(), E0669,\n                                      \"invalid value for constraint in inline assembly\");\n                         }\n                         acc\n                 });\n \n                 if input_vals.len() == inputs.len() {\n-                    let res = asm::codegen_inline_asm(&bx, asm, outputs, input_vals);\n+                    let res = bx.codegen_inline_asm(asm, outputs, input_vals);\n                     if !res {\n-                        span_err!(bx.sess(), statement.source_info.span, E0668,\n+                        span_err!(bx.cx().sess(), statement.source_info.span, E0668,\n                                   \"malformed inline assembly\");\n                     }\n                 }"}, {"sha": "2e54c52cb0e2e71a7d07058156002864750b4461", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -14,11 +14,9 @@\n //! item-path. This is used for unit testing the code that generates\n //! paths etc in all kinds of annoying scenarios.\n \n-use asm;\n use attributes;\n use base;\n use context::CodegenCx;\n-use declare;\n use llvm;\n use monomorphize::Instance;\n use type_of::LayoutLlvmExt;\n@@ -29,7 +27,7 @@ use rustc::mir::mono::{Linkage, Visibility};\n use rustc::ty::TypeFoldable;\n use rustc::ty::layout::LayoutOf;\n use std::fmt;\n-use interfaces::StaticMethods;\n+use interfaces::*;\n \n pub use rustc::mir::mono::MonoItem;\n \n@@ -59,7 +57,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n             MonoItem::GlobalAsm(node_id) => {\n                 let item = cx.tcx.hir.expect_item(node_id);\n                 if let hir::ItemKind::GlobalAsm(ref ga) = item.node {\n-                    asm::codegen_global_asm(cx, ga);\n+                    cx.codegen_global_asm(ga);\n                 } else {\n                     span_bug!(item.span, \"Mismatch between hir::Item type and MonoItem type\")\n                 }\n@@ -132,7 +130,7 @@ fn predefine_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     let ty = instance.ty(cx.tcx);\n     let llty = cx.layout_of(ty).llvm_type(cx);\n \n-    let g = declare::define_global(cx, symbol_name, llty).unwrap_or_else(|| {\n+    let g = cx.define_global(symbol_name, llty).unwrap_or_else(|| {\n         cx.sess().span_fatal(cx.tcx.def_span(def_id),\n             &format!(\"symbol `{}` is already defined\", symbol_name))\n     });\n@@ -155,7 +153,7 @@ fn predefine_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n     let mono_sig = instance.fn_sig(cx.tcx);\n     let attrs = cx.tcx.codegen_fn_attrs(instance.def_id());\n-    let lldecl = declare::declare_fn(cx, symbol_name, mono_sig);\n+    let lldecl = cx.declare_fn(symbol_name, mono_sig);\n     unsafe { llvm::LLVMRustSetLinkage(lldecl, base::linkage_to_llvm(linkage)) };\n     base::set_link_section(lldecl, &attrs);\n     if linkage == Linkage::LinkOnceODR ||"}, {"sha": "6065e0cb22b92412cc87fc62b71da5e21a596afd", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -24,9 +24,11 @@ use rustc::ty::layout::{self, Align, Size, HasTyCtxt};\n use rustc::util::nodemap::FxHashMap;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::TyLayout;\n+use rustc_target::abi::call::{CastTarget, FnType, Reg};\n use rustc_data_structures::small_c_str::SmallCStr;\n use common::{self, TypeKind};\n use type_of::LayoutLlvmExt;\n+use abi::{LlvmType, FnTypeExt};\n \n use std::fmt;\n use std::cell::RefCell;\n@@ -395,7 +397,7 @@ impl DerivedTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n impl LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn backend_type(&self, layout: TyLayout<'tcx>) -> &'ll Type {\n-        layout.llvm_type(&self)\n+        layout.llvm_type(self)\n     }\n     fn immediate_backend_type(&self, layout: TyLayout<'tcx>) -> &'ll Type {\n         layout.immediate_llvm_type(self)\n@@ -411,4 +413,16 @@ impl LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     ) -> &'ll Type {\n         layout.scalar_pair_element_llvm_type(self, index, immediate)\n     }\n+    fn cast_backend_type(&self, ty: &CastTarget) -> &'ll Type {\n+        ty.llvm_type(self)\n+    }\n+    fn fn_backend_type(&self, ty: &FnType<'tcx, Ty<'tcx>>) -> &'ll Type {\n+        ty.llvm_type(self)\n+    }\n+    fn fn_ptr_backend_type(&self, ty: &FnType<'tcx, Ty<'tcx>>) -> &'ll Type {\n+        ty.ptr_to_llvm_type(self)\n+    }\n+    fn reg_backend_type(&self, ty: &Reg) -> &'ll Type {\n+        ty.llvm_type(self)\n+    }\n }"}, {"sha": "de87b522439928f4fd108783857070ca53b65d3f", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a993fe353e1290d1e89345494ba389f6f1dae5e/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=6a993fe353e1290d1e89345494ba389f6f1dae5e", "patch": "@@ -16,7 +16,7 @@ use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n use rustc_target::abi::FloatTy;\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n use type_::Type;\n-use interfaces::{BaseTypeMethods, DerivedTypeMethods};\n+use interfaces::*;\n \n use std::fmt::Write;\n \n@@ -266,7 +266,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                         ty::ParamEnv::reveal_all(),\n                         &sig,\n                     );\n-                    FnType::new(cx, sig, &[]).ptr_to_llvm_type(cx)\n+                    cx.fn_ptr_backend_type(&FnType::new(cx, sig, &[]))\n                 }\n                 _ => self.scalar_llvm_type_at(cx, scalar, Size::ZERO)\n             };"}]}