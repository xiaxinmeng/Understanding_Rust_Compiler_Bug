{"sha": "ad66f56afd7fd3127d6991bd6078246a799573c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkNjZmNTZhZmQ3ZmQzMTI3ZDY5OTFiZDYwNzgyNDZhNzk5NTczYzA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-04-08T23:13:33Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-04-10T00:43:26Z"}, "message": "doc: Add \"A 30-minute Introduction to Rust\"\n\nBy Steve Klabnik.", "tree": {"sha": "dedf3c868aa192809fac97e84693f548f69c7c4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dedf3c868aa192809fac97e84693f548f69c7c4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad66f56afd7fd3127d6991bd6078246a799573c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad66f56afd7fd3127d6991bd6078246a799573c0", "html_url": "https://github.com/rust-lang/rust/commit/ad66f56afd7fd3127d6991bd6078246a799573c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad66f56afd7fd3127d6991bd6078246a799573c0/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2c84a78b4a3e95ea0def29172022ef4cf695958", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2c84a78b4a3e95ea0def29172022ef4cf695958", "html_url": "https://github.com/rust-lang/rust/commit/e2c84a78b4a3e95ea0def29172022ef4cf695958"}], "stats": {"total": 367, "additions": 366, "deletions": 1}, "files": [{"sha": "7fa943283373b361d9b2c3e590497fb6ac080fd5", "filename": "mk/docs.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad66f56afd7fd3127d6991bd6078246a799573c0/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ad66f56afd7fd3127d6991bd6078246a799573c0/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=ad66f56afd7fd3127d6991bd6078246a799573c0", "patch": "@@ -26,7 +26,7 @@\n # L10N_LANGS are the languages for which the docs have been\n # translated.\n ######################################################################\n-DOCS := index tutorial guide-ffi guide-macros guide-lifetimes \\\n+DOCS := index intro tutorial guide-ffi guide-macros guide-lifetimes \\\n \tguide-tasks guide-container guide-pointers guide-testing \\\n \tguide-runtime complement-bugreport complement-cheatsheet \\\n \tcomplement-lang-faq complement-project-faq rust rustdoc \\"}, {"sha": "4f01f7f0e04cbe1047768ecaa4a75eeab590c467", "filename": "src/doc/index.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad66f56afd7fd3127d6991bd6078246a799573c0/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/ad66f56afd7fd3127d6991bd6078246a799573c0/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=ad66f56afd7fd3127d6991bd6078246a799573c0", "patch": "@@ -7,6 +7,7 @@\n li {list-style-type: none; }\n </style>\n \n+* [A 30-minute Intro to Rust](intro.html) (read this first)\n * [The Rust tutorial](tutorial.html)  (* [PDF](tutorial.pdf))\n * [The Rust reference manual](rust.html) (* [PDF](rust.pdf))\n "}, {"sha": "9948895a2cba48bdbb888cd30bf77ad95174b11e", "filename": "src/doc/intro.md", "status": "added", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/ad66f56afd7fd3127d6991bd6078246a799573c0/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/ad66f56afd7fd3127d6991bd6078246a799573c0/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=ad66f56afd7fd3127d6991bd6078246a799573c0", "patch": "@@ -0,0 +1,364 @@\n+% A 30-minute Introduction to Rust\n+\n+Rust is a systems programming language that focuses on strong compile-time correctness guarantees.\n+It improves upon the ideas other systems languages like C++, D,\n+and Cyclone by providing very strong guarantees and explicit control over the life cycle of memory.\n+Strong memory guarantees make writing correct concurrent Rust code easier than in other languages.\n+This might sound very complex, but it's easier than it sounds!\n+This tutorial will give you an idea of what Rust is like in about thirty minutes.\n+It expects that you're at least vaguely familiar with a previous 'curly brace' language.\n+The concepts are more important than the syntax,\n+so don't worry if you don't get every last detail:\n+the [tutorial](http://static.rust-lang.org/doc/master/tutorial.html) can help you out with that later.\n+\n+Let's talk about the most important concept in Rust, \"ownership,\"\n+and its implications on a task that programmers usually find very difficult: concurrency.\n+\n+## Ownership\n+\n+Ownership is central to Rust,\n+and is one of its more interesting and unique features.\n+\"Ownership\" refers to which parts of your code are allowed to modify various parts of memory.\n+Let's start by looking at some C++ code:\n+\n+```\n+int *dangling(void)\n+{\n+    int i = 1234;\n+    return &i;\n+}\n+\n+int add_one(void)\n+{\n+    int *num = dangling();\n+    return *num + 1;\n+}\n+```\n+\n+This function allocates an integer on the stack,\n+and stores it in a variable, `i`.\n+It then returns a reference to the variable `i`.\n+There's just one problem:\n+stack memory becomes invalid when the function returns.\n+This means that in the second line of `add_one`,\n+`num` points to some garbage values,\n+and we won't get the effect that we want.\n+While this is a trivial example,\n+it can happen quite often in C++ code.\n+There's a similar problem when memory on the heap is allocated with `malloc` (or `new`),\n+then freed with `free` (or `delete`),\n+yet your code attempts to do something with the pointer to that memory.\n+More modern C++ uses RAII with constructors/destructors,\n+but it amounts to the same thing.\n+This problem is called a 'dangling pointer,'\n+and it's not possible to write Rust code that has it.\n+Let's try:\n+\n+```\n+fn dangling() -> &int {\n+    let i = 1234;\n+    return &i;\n+}\n+\n+fn add_one() -> int {\n+    let num = dangling();\n+    return *num + 1;\n+}\n+```\n+\n+When you try to compile this program, you'll get an interesting (and long) error message:\n+\n+```\n+temp.rs:3:11: 3:13 error: borrowed value does not live long enough\n+temp.rs:3     return &i;\n+\n+temp.rs:1:22: 4:1 note: borrowed pointer must be valid for the anonymous lifetime #1 defined on the block at 1:22...\n+temp.rs:1 fn dangling() -> &int {\n+temp.rs:2     let i = 1234;\n+temp.rs:3     return &i;\n+temp.rs:4 }\n+                            \n+temp.rs:1:22: 4:1 note: ...but borrowed value is only valid for the block at 1:22\n+temp.rs:1 fn dangling() -> &int {      \n+temp.rs:2     let i = 1234;            \n+temp.rs:3     return &i;               \n+temp.rs:4  }                            \n+error: aborting due to previous error\n+```\n+\n+In order to fully understand this error message,\n+we need to talk about what it means to \"own\" something.\n+So for now,\n+let's just accept that Rust will not allow us to write code with a dangling pointer,\n+and we'll come back to this code once we understand ownership.\n+\n+Let's forget about programming for a second and talk about books.\n+I like to read physical books,\n+and sometimes I really like one and tell my friends they should read it.\n+While I'm reading my book, I own it: the book is in my possession.\n+When I loan the book out to someone else for a while, they \"borrow\" it from me.\n+And when you borrow a book, it's yours for a certain period of time,\n+and then you give it back to me, and I own it again. Right?\n+\n+This concept applies directly to Rust code as well:\n+some code \"owns\" a particular pointer to memory.\n+It's the sole owner of that pointer.\n+It can also lend that memory out to some other code for a while:\n+the code \"borrows\" it.\n+It borrows it for a certain period of time, called a \"lifetime.\"\n+\n+That's all there is to it.\n+That doesn't seem so hard, right?\n+Let's go back to that error message:\n+`error: borrowed value does not live long enough`.\n+We tried to loan out a particular variable, `i`,\n+using Rust's borrowed pointers: the `&`.\n+But Rust knew that the variable would be invalid after the function returns,\n+and so it tells us that:\n+`borrowed pointer must be valid for the anonymous lifetime #1... but borrowed value is only valid for the block`.\n+Neat!\n+\n+That's a great example for stack memory,\n+but what about heap memory?\n+Rust has a second kind of pointer,\n+a 'unique' pointer,\n+that you can create with a `~`.\n+Check it out:\n+\n+```\n+fn dangling() -> ~int {\n+    let i = ~1234;\n+    return i;\n+}\n+\n+fn add_one() -> int {\n+    let num = dangling();\n+    return *num + 1;\n+}\n+```\n+\n+This code will successfully compile.\n+Note that instead of a stack allocated `1234`,\n+we use an owned pointer to that value instead: `~1234`.\n+You can roughly compare these two lines:\n+\n+```\n+// rust\n+let i = ~1234;\n+\n+// C++\n+int *i = new int;\n+*i = 1234;\n+```\n+\n+Rust is able to infer the size of the type,\n+then allocates the correct amount of memory and sets it to the value you asked for.\n+This means that it's impossible to allocate uninitialized memory:\n+Rust does not have the concept of null.\n+Hooray!\n+There's one other difference between this line of Rust and the C++:\n+The Rust compiler also figures out the lifetime of `i`,\n+and then inserts a corresponding `free` call after it's invalid,\n+like a destructor in C++.\n+You get all of the benefits of manually allocated heap memory without having to do all the bookkeeping yourself.\n+Furthermore, all of this checking is done at compile time,\n+so there's no runtime overhead.\n+You'll get (basically) the exact same code that you'd get if you wrote the correct C++,\n+but it's impossible to write the incorrect version, thanks to the compiler.\n+\n+You've seen one way that ownership and lifetimes are useful to prevent code that would normally be dangerous in a less-strict language,\n+but let's talk about another: concurrency.\n+\n+## Concurrency\n+\n+Concurrency is an incredibly hot topic in the software world right now.\n+It's always been an interesting area of study for computer scientists,\n+but as usage of the Internet explodes,\n+people are looking to improve the number of users a given service can handle.\n+Concurrency is one way of achieving this goal.\n+There is a pretty big drawback to concurrent code, though:\n+it can be hard to reason about,\n+because it is non-deterministic.\n+There are a few different approaches to writing good concurrent code,\n+but let's talk about how Rust's notions of ownership and lifetimes can assist with achieving correct but concurrent code.\n+\n+First, let's go over a simple concurrency example in Rust.\n+Rust allows you to spin up 'tasks,'\n+which are lightweight, 'green' threads.\n+These tasks do not have any shared memory, and so,\n+we communicate between tasks with a 'channel'.\n+Like this:\n+\n+```\n+fn main() {\n+    let numbers = [1,2,3];\n+\n+    let (port, chan)  = Chan::new();\n+    chan.send(numbers);\n+\n+    do spawn {\n+        let numbers = port.recv();\n+        println!(\"{:d}\", numbers[0]);\n+    }\n+}\n+```\n+\n+In this example, we create a vector of numbers.\n+We then make a new `Chan`,\n+which is the name of the package Rust implements channels with.\n+This returns two different ends of the channel:\n+a channel and a port.\n+You send data into the channel end, and it comes out the port end.\n+The `spawn` function spins up a new task.\n+As you can see in the code,\n+we call `port.recv()` (short for 'receive') inside of the new task,\n+and we call `chan.send()` outside,\n+passing in our vector.\n+We then print the first element of the vector.\n+\n+This works out because Rust copies the vector when it is sent through the channel.\n+That way, if it were mutable, there wouldn't be a race condition.\n+However, if we're making a lot of tasks, or if our data is very large,\n+making a copy for each task inflates our memory usage with no real benefit.\n+\n+Enter Arc.\n+Arc stands for 'atomically reference counted,'\n+and it's a way to share immutable data between multiple tasks.\n+Here's some code:\n+\n+```\n+extern mod extra;\n+use extra::arc::Arc;\n+\n+fn main() {\n+    let numbers = [1,2,3];\n+\n+    let numbers_arc = Arc::new(numbers);\n+\n+    for num in range(0, 3) {\n+        let (port, chan)  = Chan::new();\n+        chan.send(numbers_arc.clone());\n+\n+        do spawn {\n+            let local_arc = port.recv();\n+            let task_numbers = local_arc.get();\n+            println!(\"{:d}\", task_numbers[num]);\n+        }\n+    }\n+}\n+```\n+\n+This is very similar to the code we had before,\n+except now we loop three times,\n+making three tasks,\n+and sending an `Arc` between them.\n+`Arc::new` creates a new Arc,\n+`.clone()` makes a new reference to that Arc,\n+and `.get()` gets the value out of the Arc.\n+So we make a new reference for each task,\n+send that reference down the channel,\n+and then use the reference to print out a number.\n+Now we're not copying our vector.\n+\n+Arcs are great for immutable data,\n+but what about mutable data?\n+Shared mutable state is the bane of the concurrent programmer.\n+You can use a mutex to protect shared mutable state,\n+but if you forget to acquire the mutex, bad things can happen.\n+\n+Rust provides a tool for shared mutable state: `RWArc`.\n+This variant of an Arc allows the contents of the Arc to be mutated.\n+Check it out:\n+\n+```\n+extern mod extra;\n+use extra::arc::RWArc;\n+\n+fn main() {\n+    let numbers = [1,2,3];\n+\n+    let numbers_arc = RWArc::new(numbers);\n+\n+    for num in range(0, 3) {\n+        let (port, chan)  = Chan::new();\n+        chan.send(numbers_arc.clone());\n+\n+        do spawn {\n+            let local_arc = port.recv();\n+\n+            local_arc.write(|nums| {\n+                nums[num] += 1\n+            });\n+\n+            local_arc.read(|nums| {\n+                println!(\"{:d}\", nums[num]);\n+            })\n+        }\n+    }\n+}\n+```\n+\n+We now use the `RWArc` package to get a read/write Arc.\n+The read/write Arc has a slightly different API than `Arc`:\n+`read` and `write` allow you to, well, read and write the data.\n+They both take closures as arguments,\n+and the read/write Arc will, in the case of write,\n+acquire a mutex,\n+and then pass the data to this closure.\n+After the closure does its thing, the mutex is released.\n+\n+You can see how this makes it impossible to mutate the state without remembering to aquire the lock.\n+We gain the efficiency of shared mutable state,\n+while retaining the safety of disallowing shared mutable state.\n+\n+But wait, how is that possible?\n+We can't both allow and disallow mutable state.\n+What gives?\n+\n+## A footnote: unsafe\n+\n+So, the Rust language does not allow for shared mutable state,\n+yet I just showed you some code that has it.\n+How's this possible? The answer: `unsafe`.\n+\n+You see, while the Rust compiler is very smart,\n+and saves you from making mistakes you might normally make,\n+it's not an artificial intelligence.\n+Because we're smarter than the compiler,\n+sometimes, we need to over-ride this safe behavior.\n+For this purpose, Rust has an `unsafe` keyword.\n+Within an `unsafe` block,\n+Rust turns off many of its safety checks.\n+If something bad happens to your program,\n+you only have to audit what you've done inside `unsafe`,\n+and not the entire program itself.\n+\n+If one of the major goals of Rust was safety,\n+why allow that safety to be turned off?\n+Well, there are really only three main reasons to do it:\n+interfacing with external code,\n+such as doing FFI into a C library,\n+performance (in certain cases),\n+and to provide a safe abstraction around operations that normally would not be safe.\n+Our Arcs are an example of this last purpose.\n+We can safely hand out multiple references to the `Arc`,\n+because we are sure the data is immutable,\n+and therefore it is safe to share.\n+We can hand out multiple references to the `RWArc`,\n+because we know that we've wrapped the data in a mutex,\n+and therefore it is safe to share.\n+But the Rust compiler can't know that we've made these choices,\n+so _inside_ the implementation of the Arcs,\n+we use `unsafe` blocks to do (normally) dangerous things.\n+But we expose a safe interface,\n+which means that the Arcs are impossible to use incorrectly.\n+\n+This is how Rust's type system allows you to not make some of the mistakes that make concurrent programming difficult,\n+yet get the efficiency of languages such as C++.\n+\n+## That's all, folks\n+\n+I hope that this taste of Rust has given you an idea if Rust is the right language for you.\n+If that's true,\n+I encourage you to check out [the tutorial](http://static.rust-lang.org/doc/0.9/tutorial.html) for a full,\n+in-depth exploration of Rust's syntax and concepts.\n\\ No newline at end of file"}]}