{"sha": "224c6ca2ee31d717a412d6c1901fac04ab780edb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyNGM2Y2EyZWUzMWQ3MTdhNDEyZDZjMTkwMWZhYzA0YWI3ODBlZGI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-08-21T09:31:35Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-08-21T11:10:13Z"}, "message": "Moved support code for `rustc_mir::borrow_check` query out of `mod transform`.", "tree": {"sha": "cf9cf334f90e39c49639766f1d0f7bb9e5d7b660", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf9cf334f90e39c49639766f1d0f7bb9e5d7b660"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/224c6ca2ee31d717a412d6c1901fac04ab780edb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/224c6ca2ee31d717a412d6c1901fac04ab780edb", "html_url": "https://github.com/rust-lang/rust/commit/224c6ca2ee31d717a412d6c1901fac04ab780edb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/224c6ca2ee31d717a412d6c1901fac04ab780edb/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c280afcc1c6b7c14218bf2a8322ebb3ac692485a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c280afcc1c6b7c14218bf2a8322ebb3ac692485a", "html_url": "https://github.com/rust-lang/rust/commit/c280afcc1c6b7c14218bf2a8322ebb3ac692485a"}], "stats": {"total": 2479, "additions": 1231, "deletions": 1248}, "files": [{"sha": "5ae3bee3267001de68b7f4c4d96202f1a1a117ad", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 1231, "deletions": 4, "changes": 1235, "blob_url": "https://github.com/rust-lang/rust/blob/224c6ca2ee31d717a412d6c1901fac04ab780edb/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/224c6ca2ee31d717a412d6c1901fac04ab780edb/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=224c6ca2ee31d717a412d6c1901fac04ab780edb", "patch": "@@ -8,10 +8,34 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! This query borrow-checks the MIR to (further) ensure it is not broken.\n+\n use rustc::hir::def_id::{DefId};\n-use rustc::mir::transform::{MirSource};\n-use rustc::ty::{TyCtxt};\n+use rustc::infer::{InferCtxt};\n+use rustc::ty::{self, TyCtxt, ParamEnv};\n use rustc::ty::maps::Providers;\n+use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Location, Lvalue};\n+use rustc::mir::{Mir, Mutability, Operand, Projection, ProjectionElem, Rvalue};\n+use rustc::mir::{Statement, StatementKind, Terminator, TerminatorKind};\n+use rustc::mir::transform::{MirSource};\n+\n+use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n+use rustc_data_structures::indexed_vec::{Idx};\n+\n+use syntax::ast::{self};\n+use syntax_pos::{DUMMY_SP, Span};\n+\n+use dataflow::{do_dataflow};\n+use dataflow::{MoveDataParamEnv};\n+use dataflow::{BitDenotation, BlockSets, DataflowResults, DataflowResultsConsumer};\n+use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n+use dataflow::{Borrows, BorrowData, BorrowIndex};\n+use dataflow::move_paths::{HasMoveData, MoveData, MovePathIndex, LookupResult};\n+use util::borrowck_errors::{BorrowckErrors, Origin};\n+\n+use self::MutateMode::{JustWrite, WriteAndRead};\n+use self::ConsumeKind::{Consume};\n+\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n@@ -25,7 +49,1210 @@ fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n     let src = MirSource::from_local_def_id(tcx, def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.node_path_str(src.item_id()));\n \n-    if tcx.has_attr(def_id, \"rustc_mir_borrowck\") || tcx.sess.opts.debugging_opts.borrowck_mir {\n-        ::transform::borrow_check::borrowck_mir(tcx, src, &mir.borrow());\n+    let mir: &Mir<'tcx> = &mir.borrow();\n+    if !tcx.has_attr(def_id, \"rustc_mir_borrowck\") || !tcx.sess.opts.debugging_opts.borrowck_mir {\n+        return;\n+    }\n+\n+    let id = src.item_id();\n+    let attributes = tcx.get_attrs(def_id);\n+    let param_env = tcx.param_env(def_id);\n+    tcx.infer_ctxt().enter(|_infcx| {\n+\n+        let move_data = MoveData::gather_moves(mir, tcx, param_env);\n+        let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n+        let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n+        let flow_borrows = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                       Borrows::new(tcx, mir),\n+                                       |bd, i| bd.location(i));\n+        let flow_inits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                     MaybeInitializedLvals::new(tcx, mir, &mdpe),\n+                                     |bd, i| &bd.move_data().move_paths[i]);\n+        let flow_uninits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                       MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n+                                       |bd, i| &bd.move_data().move_paths[i]);\n+\n+        let mut mbcx = MirBorrowckCtxt {\n+            tcx: tcx,\n+            mir: mir,\n+            node_id: id,\n+            move_data: &mdpe.move_data,\n+            param_env: param_env,\n+            fake_infer_ctxt: &_infcx,\n+        };\n+\n+        let mut state = InProgress::new(flow_borrows,\n+                                        flow_inits,\n+                                        flow_uninits);\n+\n+        mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n+    });\n+\n+    debug!(\"mir_borrowck done\");\n+}\n+\n+#[allow(dead_code)]\n+pub struct MirBorrowckCtxt<'c, 'b, 'a: 'b+'c, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+    mir: &'b Mir<'gcx>,\n+    node_id: ast::NodeId,\n+    move_data: &'b MoveData<'gcx>,\n+    param_env: ParamEnv<'tcx>,\n+    fake_infer_ctxt: &'c InferCtxt<'c, 'gcx, 'tcx>,\n+}\n+\n+// (forced to be `pub` due to its use as an associated type below.)\n+pub struct InProgress<'b, 'tcx: 'b> {\n+    borrows: FlowInProgress<Borrows<'b, 'tcx>>,\n+    inits: FlowInProgress<MaybeInitializedLvals<'b, 'tcx>>,\n+    uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>>,\n+}\n+\n+struct FlowInProgress<BD> where BD: BitDenotation {\n+    base_results: DataflowResults<BD>,\n+    curr_state: IdxSetBuf<BD::Idx>,\n+    stmt_gen: IdxSetBuf<BD::Idx>,\n+    stmt_kill: IdxSetBuf<BD::Idx>,\n+}\n+\n+// Check that:\n+// 1. assignments are always made to mutable locations (FIXME: does that still really go here?)\n+// 2. loans made in overlapping scopes do not conflict\n+// 3. assignments do not affect things loaned out as immutable\n+// 4. moves do not affect things loaned out in any way\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n+    for MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n+{\n+    type FlowState = InProgress<'b, 'gcx>;\n+\n+    fn mir(&self) -> &'b Mir<'gcx> { self.mir }\n+\n+    fn reset_to_entry_of(&mut self, bb: BasicBlock, flow_state: &mut Self::FlowState) {\n+        flow_state.each_flow(|b| b.reset_to_entry_of(bb),\n+                             |i| i.reset_to_entry_of(bb),\n+                             |u| u.reset_to_entry_of(bb));\n+    }\n+\n+    fn reconstruct_statement_effect(&mut self,\n+                                    location: Location,\n+                                    flow_state: &mut Self::FlowState) {\n+        flow_state.each_flow(|b| b.reconstruct_statement_effect(location),\n+                             |i| i.reconstruct_statement_effect(location),\n+                             |u| u.reconstruct_statement_effect(location));\n+    }\n+\n+    fn apply_local_effect(&mut self,\n+                          _location: Location,\n+                          flow_state: &mut Self::FlowState) {\n+        flow_state.each_flow(|b| b.apply_local_effect(),\n+                             |i| i.apply_local_effect(),\n+                             |u| u.apply_local_effect());\n+    }\n+\n+    fn reconstruct_terminator_effect(&mut self,\n+                                     location: Location,\n+                                     flow_state: &mut Self::FlowState) {\n+        flow_state.each_flow(|b| b.reconstruct_terminator_effect(location),\n+                             |i| i.reconstruct_terminator_effect(location),\n+                             |u| u.reconstruct_terminator_effect(location));\n+    }\n+\n+    fn visit_block_entry(&mut self,\n+                         bb: BasicBlock,\n+                         flow_state: &Self::FlowState) {\n+        let summary = flow_state.summary();\n+        debug!(\"MirBorrowckCtxt::process_block({:?}): {}\", bb, summary);\n+    }\n+\n+    fn visit_statement_entry(&mut self,\n+                             location: Location,\n+                             stmt: &Statement<'gcx>,\n+                             flow_state: &Self::FlowState) {\n+        let summary = flow_state.summary();\n+        debug!(\"MirBorrowckCtxt::process_statement({:?}, {:?}): {}\", location, stmt, summary);\n+        let span = stmt.source_info.span;\n+        match stmt.kind {\n+            StatementKind::Assign(ref lhs, ref rhs) => {\n+                self.mutate_lvalue(ContextKind::AssignLhs.new(location),\n+                                   (lhs, span), JustWrite, flow_state);\n+                self.consume_rvalue(ContextKind::AssignRhs.new(location),\n+                                    (rhs, span), location, flow_state);\n+            }\n+            StatementKind::SetDiscriminant { ref lvalue, variant_index: _ } => {\n+                self.mutate_lvalue(ContextKind::SetDiscrim.new(location),\n+                                   (lvalue, span), JustWrite, flow_state);\n+            }\n+            StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n+                for (o, output) in asm.outputs.iter().zip(outputs) {\n+                    if o.is_indirect {\n+                        self.consume_lvalue(ContextKind::InlineAsm.new(location),\n+                                            Consume,\n+                                            (output, span),\n+                                            flow_state);\n+                    } else {\n+                        self.mutate_lvalue(ContextKind::InlineAsm.new(location),\n+                                           (output, span),\n+                                           if o.is_rw { WriteAndRead } else { JustWrite },\n+                                           flow_state);\n+                    }\n+                }\n+                for input in inputs {\n+                    self.consume_operand(ContextKind::InlineAsm.new(location),\n+                                         Consume,\n+                                         (input, span), flow_state);\n+                }\n+            }\n+            StatementKind::EndRegion(ref _rgn) => {\n+                // ignored when consuming results (update to\n+                // flow_state already handled).\n+            }\n+            StatementKind::Nop |\n+            StatementKind::Validate(..) |\n+            StatementKind::StorageLive(..) => {\n+                // ignored by borrowck\n+            }\n+\n+            StatementKind::StorageDead(ref lvalue) => {\n+                // causes non-drop values to be dropped.\n+                self.consume_lvalue(ContextKind::StorageDead.new(location),\n+                                    ConsumeKind::Consume,\n+                                    (lvalue, span),\n+                                    flow_state)\n+            }\n+        }\n+    }\n+\n+    fn visit_terminator_entry(&mut self,\n+                              location: Location,\n+                              term: &Terminator<'gcx>,\n+                              flow_state: &Self::FlowState) {\n+        let loc = location;\n+        let summary = flow_state.summary();\n+        debug!(\"MirBorrowckCtxt::process_terminator({:?}, {:?}): {}\", location, term, summary);\n+        let span = term.source_info.span;\n+        match term.kind {\n+            TerminatorKind::SwitchInt { ref discr, switch_ty: _, values: _, targets: _ } => {\n+                self.consume_operand(ContextKind::SwitchInt.new(loc),\n+                                     Consume,\n+                                     (discr, span), flow_state);\n+            }\n+            TerminatorKind::Drop { location: ref drop_lvalue, target: _, unwind: _ } => {\n+                self.consume_lvalue(ContextKind::Drop.new(loc),\n+                                    ConsumeKind::Drop,\n+                                    (drop_lvalue, span), flow_state);\n+            }\n+            TerminatorKind::DropAndReplace { location: ref drop_lvalue,\n+                                             value: ref new_value,\n+                                             target: _,\n+                                             unwind: _ } => {\n+                self.mutate_lvalue(ContextKind::DropAndReplace.new(loc),\n+                                   (drop_lvalue, span), JustWrite, flow_state);\n+                self.consume_operand(ContextKind::DropAndReplace.new(loc),\n+                                     ConsumeKind::Drop,\n+                                     (new_value, span), flow_state);\n+            }\n+            TerminatorKind::Call { ref func, ref args, ref destination, cleanup: _ } => {\n+                self.consume_operand(ContextKind::CallOperator.new(loc),\n+                                     Consume,\n+                                     (func, span), flow_state);\n+                for arg in args {\n+                    self.consume_operand(ContextKind::CallOperand.new(loc),\n+                                         Consume,\n+                                         (arg, span), flow_state);\n+                }\n+                if let Some((ref dest, _/*bb*/)) = *destination {\n+                    self.mutate_lvalue(ContextKind::CallDest.new(loc),\n+                                       (dest, span), JustWrite, flow_state);\n+                }\n+            }\n+            TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n+                self.consume_operand(ContextKind::Assert.new(loc),\n+                                     Consume,\n+                                     (cond, span), flow_state);\n+                match *msg {\n+                    AssertMessage::BoundsCheck { ref len, ref index } => {\n+                        self.consume_operand(ContextKind::Assert.new(loc),\n+                                             Consume,\n+                                             (len, span), flow_state);\n+                        self.consume_operand(ContextKind::Assert.new(loc),\n+                                             Consume,\n+                                             (index, span), flow_state);\n+                    }\n+                    AssertMessage::Math(_/*const_math_err*/) => {}\n+                }\n+            }\n+\n+            TerminatorKind::Goto { target: _ } |\n+            TerminatorKind::Resume |\n+            TerminatorKind::Return |\n+            TerminatorKind::Unreachable => {\n+                // no data used, thus irrelevant to borrowck\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum MutateMode { JustWrite, WriteAndRead }\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum ConsumeKind { Drop, Consume }\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum Control { Continue, Break }\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    fn mutate_lvalue(&mut self,\n+                     context: Context,\n+                     lvalue_span: (&Lvalue<'gcx>, Span),\n+                     mode: MutateMode,\n+                     flow_state: &InProgress<'b, 'gcx>) {\n+        // Write of P[i] or *P, or WriteAndRead of any P, requires P init'd.\n+        match mode {\n+            MutateMode::WriteAndRead => {\n+                self.check_if_path_is_moved(context, lvalue_span, flow_state);\n+            }\n+            MutateMode::JustWrite => {\n+                self.check_if_assigned_path_is_moved(context, lvalue_span, flow_state);\n+            }\n+        }\n+\n+        // check we don't invalidate any outstanding loans\n+        self.each_borrow_involving_path(context,\n+                                        lvalue_span.0, flow_state, |this, _index, _data| {\n+                                            this.report_illegal_mutation_of_borrowed(context,\n+                                                                                     lvalue_span);\n+                                            Control::Break\n+                                        });\n+\n+        // check for reassignments to immutable local variables\n+        self.check_if_reassignment_to_immutable_state(context, lvalue_span, flow_state);\n+    }\n+\n+    fn consume_rvalue(&mut self,\n+                      context: Context,\n+                      (rvalue, span): (&Rvalue<'gcx>, Span),\n+                      location: Location,\n+                      flow_state: &InProgress<'b, 'gcx>) {\n+        match *rvalue {\n+            Rvalue::Ref(_/*rgn*/, bk, ref lvalue) => {\n+                self.borrow(context, location, bk, (lvalue, span), flow_state)\n+            }\n+\n+            Rvalue::Use(ref operand) |\n+            Rvalue::Repeat(ref operand, _) |\n+            Rvalue::UnaryOp(_/*un_op*/, ref operand) |\n+            Rvalue::Cast(_/*cast_kind*/, ref operand, _/*ty*/) => {\n+                self.consume_operand(context, Consume, (operand, span), flow_state)\n+            }\n+\n+            Rvalue::Len(ref lvalue) |\n+            Rvalue::Discriminant(ref lvalue) => {\n+                // len(_)/discriminant(_) merely read, not consume.\n+                self.check_if_path_is_moved(context, (lvalue, span), flow_state);\n+            }\n+\n+            Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2) |\n+            Rvalue::CheckedBinaryOp(_bin_op, ref operand1, ref operand2) => {\n+                self.consume_operand(context, Consume, (operand1, span), flow_state);\n+                self.consume_operand(context, Consume, (operand2, span), flow_state);\n+            }\n+\n+            Rvalue::NullaryOp(_op, _ty) => {\n+                // nullary ops take no dynamic input; no borrowck effect.\n+                //\n+                // FIXME: is above actually true? Do we want to track\n+                // the fact that uninitialized data can be created via\n+                // `NullOp::Box`?\n+            }\n+\n+            Rvalue::Aggregate(ref _aggregate_kind, ref operands) => {\n+                for operand in operands {\n+                    self.consume_operand(context, Consume, (operand, span), flow_state);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn consume_operand(&mut self,\n+                       context: Context,\n+                       consume_via_drop: ConsumeKind,\n+                       (operand, span): (&Operand<'gcx>, Span),\n+                       flow_state: &InProgress<'b, 'gcx>) {\n+        match *operand {\n+            Operand::Consume(ref lvalue) =>\n+                self.consume_lvalue(context, consume_via_drop, (lvalue, span), flow_state),\n+            Operand::Constant(_) => {}\n+        }\n+    }\n+\n+    fn consume_lvalue(&mut self,\n+                      context: Context,\n+                      consume_via_drop: ConsumeKind,\n+                      lvalue_span: (&Lvalue<'gcx>, Span),\n+                      flow_state: &InProgress<'b, 'gcx>) {\n+        let lvalue = lvalue_span.0;\n+        let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n+        let moves_by_default =\n+            self.fake_infer_ctxt.type_moves_by_default(self.param_env, ty, DUMMY_SP);\n+        if moves_by_default {\n+            // move of lvalue: check if this is move of already borrowed path\n+            self.each_borrow_involving_path(\n+                context, lvalue_span.0, flow_state, |this, _idx, borrow| {\n+                    if !borrow.compatible_with(BorrowKind::Mut) {\n+                        this.report_move_out_while_borrowed(context, lvalue_span);\n+                        Control::Break\n+                    } else {\n+                        Control::Continue\n+                    }\n+                });\n+        } else {\n+            // copy of lvalue: check if this is \"copy of frozen path\" (FIXME: see check_loans.rs)\n+            self.each_borrow_involving_path(\n+                context, lvalue_span.0, flow_state, |this, _idx, borrow| {\n+                    if !borrow.compatible_with(BorrowKind::Shared) {\n+                        this.report_use_while_mutably_borrowed(context, lvalue_span);\n+                        Control::Break\n+                    } else {\n+                        Control::Continue\n+                    }\n+                });\n+        }\n+\n+        // Finally, check if path was already moved.\n+        match consume_via_drop {\n+            ConsumeKind::Drop => {\n+                // If path is merely being dropped, then we'll already\n+                // check the drop flag to see if it is moved (thus we\n+                // skip this check in that case).\n+            }\n+            ConsumeKind::Consume => {\n+                self.check_if_path_is_moved(context, lvalue_span, flow_state);\n+            }\n+        }\n+    }\n+\n+    fn borrow(&mut self,\n+              context: Context,\n+              location: Location,\n+              bk: BorrowKind,\n+              lvalue_span: (&Lvalue<'gcx>, Span),\n+              flow_state: &InProgress<'b, 'gcx>) {\n+        debug!(\"borrow location: {:?} lvalue: {:?} span: {:?}\",\n+               location, lvalue_span.0, lvalue_span.1);\n+        self.check_if_path_is_moved(context, lvalue_span, flow_state);\n+        self.check_for_conflicting_loans(context, location, bk, lvalue_span, flow_state);\n+    }\n+}\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    fn check_if_reassignment_to_immutable_state(&mut self,\n+                                                context: Context,\n+                                                (lvalue, span): (&Lvalue<'gcx>, Span),\n+                                                flow_state: &InProgress<'b, 'gcx>) {\n+        let move_data = flow_state.inits.base_results.operator().move_data();\n+\n+        // determine if this path has a non-mut owner (and thus needs checking).\n+        let mut l = lvalue;\n+        loop {\n+            match *l {\n+                Lvalue::Projection(ref proj) => {\n+                    l = &proj.base;\n+                    continue;\n+                }\n+                Lvalue::Local(local) => {\n+                    match self.mir.local_decls[local].mutability {\n+                        Mutability::Not => break, // needs check\n+                        Mutability::Mut => return,\n+                    }\n+                }\n+                Lvalue::Static(_) => {\n+                    // mutation of non-mut static is always illegal,\n+                    // independent of dataflow.\n+                    self.report_assignment_to_static(context, (lvalue, span));\n+                    return;\n+                }\n+            }\n+        }\n+\n+        if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n+            if flow_state.inits.curr_state.contains(&mpi) {\n+                // may already be assigned before reaching this statement;\n+                // report error.\n+                self.report_illegal_reassignment(context, (lvalue, span));\n+            }\n+        }\n+    }\n+\n+    fn check_if_path_is_moved(&mut self,\n+                              context: Context,\n+                              lvalue_span: (&Lvalue<'gcx>, Span),\n+                              flow_state: &InProgress<'b, 'gcx>) {\n+        // FIXME: analogous code in check_loans first maps `lvalue` to\n+        // its base_path ... but is that what we want here?\n+        let lvalue = self.base_path(lvalue_span.0);\n+\n+        let maybe_uninits = &flow_state.uninits;\n+        let move_data = maybe_uninits.base_results.operator().move_data();\n+        if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n+            if maybe_uninits.curr_state.contains(&mpi) {\n+                // find and report move(s) that could cause this to be uninitialized\n+                self.report_use_of_moved(context, lvalue_span);\n+            } else {\n+                // sanity check: initialized on *some* path, right?\n+                assert!(flow_state.inits.curr_state.contains(&mpi));\n+            }\n+        }\n+    }\n+\n+    fn move_path_for_lvalue(&mut self,\n+                            _context: Context,\n+                            move_data: &MoveData<'gcx>,\n+                            lvalue: &Lvalue<'gcx>)\n+                            -> Option<MovePathIndex>\n+    {\n+        // If returns None, then there is no move path corresponding\n+        // to a direct owner of `lvalue` (which means there is nothing\n+        // that borrowck tracks for its analysis).\n+\n+        match move_data.rev_lookup.find(lvalue) {\n+            LookupResult::Parent(_) => None,\n+            LookupResult::Exact(mpi) => Some(mpi),\n+        }\n+    }\n+\n+    fn check_if_assigned_path_is_moved(&mut self,\n+                                       context: Context,\n+                                       (lvalue, span): (&Lvalue<'gcx>, Span),\n+                                       flow_state: &InProgress<'b, 'gcx>) {\n+        // recur down lvalue; dispatch to check_if_path_is_moved when necessary\n+        let mut lvalue = lvalue;\n+        loop {\n+            match *lvalue {\n+                Lvalue::Local(_) | Lvalue::Static(_) => {\n+                    // assigning to `x` does not require `x` be initialized.\n+                    break;\n+                }\n+                Lvalue::Projection(ref proj) => {\n+                    let Projection { ref base, ref elem } = **proj;\n+                    match *elem {\n+                        ProjectionElem::Deref |\n+                        // assigning to *P requires `P` initialized.\n+                        ProjectionElem::Index(_/*operand*/) |\n+                        ProjectionElem::ConstantIndex { .. } |\n+                        // assigning to P[i] requires `P` initialized.\n+                        ProjectionElem::Downcast(_/*adt_def*/, _/*variant_idx*/) =>\n+                        // assigning to (P->variant) is okay if assigning to `P` is okay\n+                        //\n+                        // FIXME: is this true even if P is a adt with a dtor?\n+                        { }\n+\n+                        ProjectionElem::Subslice { .. } => {\n+                            panic!(\"we dont allow assignments to subslices, context: {:?}\",\n+                                   context);\n+                        }\n+\n+                        ProjectionElem::Field(..) => {\n+                            // if type of `P` has a dtor, then\n+                            // assigning to `P.f` requires `P` itself\n+                            // be already initialized\n+                            let tcx = self.tcx;\n+                            match base.ty(self.mir, tcx).to_ty(tcx).sty {\n+                                ty::TyAdt(def, _) if def.has_dtor(tcx) => {\n+\n+                                    // FIXME: analogous code in\n+                                    // check_loans.rs first maps\n+                                    // `base` to its base_path.\n+\n+                                    self.check_if_path_is_moved(context,\n+                                                                (base, span), flow_state);\n+\n+                                    // (base initialized; no need to\n+                                    // recur further)\n+                                    break;\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+                    }\n+\n+                    lvalue = base;\n+                    continue;\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_for_conflicting_loans(&mut self,\n+                                   context: Context,\n+                                   _location: Location,\n+                                   _bk: BorrowKind,\n+                                   lvalue_span: (&Lvalue<'gcx>, Span),\n+                                   flow_state: &InProgress<'b, 'gcx>) {\n+        // NOTE FIXME: The analogous code in old borrowck\n+        // check_loans.rs is careful to iterate over every *issued*\n+        // loan, as opposed to just the in scope ones.\n+        //\n+        // (Or if you prefer, all the *other* iterations over loans\n+        // only consider loans that are in scope of some given\n+        // CodeExtent)\n+        //\n+        // The (currently skeletal) code here does not encode such a\n+        // distinction, which means it is almost certainly over\n+        // looking something.\n+        //\n+        // (It is probably going to reject code that should be\n+        // accepted, I suspect, by treated issued-but-out-of-scope\n+        // loans as issued-and-in-scope, and thus causing them to\n+        // interfere with other loans.)\n+        //\n+        // However, I just want to get something running, especially\n+        // since I am trying to move into new territory with NLL, so\n+        // lets get this going first, and then address the issued vs\n+        // in-scope distinction later.\n+\n+        let state = &flow_state.borrows;\n+        let data = &state.base_results.operator().borrows();\n+\n+        debug!(\"check_for_conflicting_loans location: {:?}\", _location);\n+\n+        // does any loan generated here conflict with a previously issued loan?\n+        let mut loans_generated = 0;\n+        for (g, gen) in state.elems_generated().map(|g| (g, &data[g])) {\n+            loans_generated += 1;\n+            for (i, issued) in state.elems_incoming().map(|i| (i, &data[i])) {\n+                debug!(\"check_for_conflicting_loans gen: {:?} issued: {:?} conflicts: {}\",\n+                       (g, gen, self.base_path(&gen.lvalue),\n+                        self.restrictions(&gen.lvalue).collect::<Vec<_>>()),\n+                       (i, issued, self.base_path(&issued.lvalue),\n+                        self.restrictions(&issued.lvalue).collect::<Vec<_>>()),\n+                       self.conflicts_with(gen, issued));\n+                if self.conflicts_with(gen, issued) {\n+                    self.report_conflicting_borrow(context, lvalue_span, gen, issued);\n+                }\n+            }\n+        }\n+\n+        // MIR statically ensures each statement gens *at most one*\n+        // loan; mutual conflict (within a statement) can't arise.\n+        //\n+        // As safe-guard, assert that above property actually holds.\n+        assert!(loans_generated <= 1);\n+    } }\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    fn each_borrow_involving_path<F>(&mut self,\n+                                     _context: Context,\n+                                     lvalue: &Lvalue<'gcx>,\n+                                     flow_state: &InProgress<'b, 'gcx>,\n+                                     mut op: F)\n+        where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'gcx>) -> Control\n+    {\n+        // FIXME: analogous code in check_loans first maps `lvalue` to\n+        // its base_path.\n+\n+        let domain = flow_state.borrows.base_results.operator();\n+        let data = domain.borrows();\n+\n+        // check for loan restricting path P being used. Accounts for\n+        // borrows of P, P.a.b, etc.\n+        for i in flow_state.borrows.elems_incoming() {\n+            // FIXME: check_loans.rs filtered this to \"in scope\"\n+            // loans; i.e. it took a scope S and checked that each\n+            // restriction's kill_scope was a superscope of S.\n+            let borrowed = &data[i];\n+            for restricted in self.restrictions(&borrowed.lvalue) {\n+                if restricted == lvalue {\n+                    let ctrl = op(self, i, borrowed);\n+                    if ctrl == Control::Break { return; }\n+                }\n+            }\n+        }\n+\n+        // check for loans (not restrictions) on any base path.\n+        // e.g. Rejects `{ let x = &mut a.b; let y = a.b.c; }`,\n+        // since that moves out of borrowed path `a.b`.\n+        //\n+        // Limiting to loans (not restrictions) keeps this one\n+        // working: `{ let x = &mut a.b; let y = a.c; }`\n+        let mut cursor = lvalue;\n+        loop {\n+            // FIXME: check_loans.rs invoked `op` *before* cursor\n+            // shift here.  Might just work (and even avoid redundant\n+            // errors?) given code above?  But for now, I want to try\n+            // doing what I think is more \"natural\" check.\n+            for i in flow_state.borrows.elems_incoming() {\n+                let borrowed = &data[i];\n+                if borrowed.lvalue == *cursor {\n+                    let ctrl = op(self, i, borrowed);\n+                    if ctrl == Control::Break { return; }\n+                }\n+            }\n+\n+            match *cursor {\n+                Lvalue::Local(_) | Lvalue::Static(_) => break,\n+                Lvalue::Projection(ref proj) => cursor = &proj.base,\n+            }\n+        }\n+    }\n+}\n+\n+mod restrictions {\n+    use super::MirBorrowckCtxt;\n+\n+    use rustc::hir;\n+    use rustc::ty::{self, TyCtxt};\n+    use rustc::mir::{Lvalue, Mir, Operand, ProjectionElem};\n+\n+    pub(super) struct Restrictions<'c, 'tcx: 'c> {\n+        mir: &'c Mir<'tcx>,\n+        tcx: TyCtxt<'c, 'tcx, 'tcx>,\n+        lvalue_stack: Vec<&'c Lvalue<'tcx>>,\n+    }\n+\n+    impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+        pub(super) fn restrictions<'d>(&self,\n+                                       lvalue: &'d Lvalue<'gcx>)\n+                                       -> Restrictions<'d, 'gcx> where 'b: 'd\n+        {\n+            let lvalue_stack = if self.has_restrictions(lvalue) { vec![lvalue] } else { vec![] };\n+            Restrictions { lvalue_stack: lvalue_stack, mir: self.mir, tcx: self.tcx }\n+        }\n+\n+        fn has_restrictions(&self, lvalue: &Lvalue<'gcx>) -> bool {\n+            let mut cursor = lvalue;\n+            loop {\n+                let proj = match *cursor {\n+                    Lvalue::Local(_) => return true,\n+                    Lvalue::Static(_) => return false,\n+                    Lvalue::Projection(ref proj) => proj,\n+                };\n+                match proj.elem {\n+                    ProjectionElem::Index(..) |\n+                    ProjectionElem::ConstantIndex { .. } |\n+                    ProjectionElem::Downcast(..) |\n+                    ProjectionElem::Subslice { .. } |\n+                    ProjectionElem::Field(_/*field*/, _/*ty*/) => {\n+                        cursor = &proj.base;\n+                        continue;\n+                    }\n+                    ProjectionElem::Deref => {\n+                        let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        match ty.sty {\n+                            ty::TyRawPtr(_) => {\n+                                return false;\n+                            }\n+                            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+                                // FIXME: do I need to check validity of\n+                                // region here though? (I think the original\n+                                // check_loans code did, like readme says)\n+                                return false;\n+                            }\n+                            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+                                cursor = &proj.base;\n+                                continue;\n+                            }\n+                            ty::TyAdt(..) if ty.is_box() => {\n+                                cursor = &proj.base;\n+                                continue;\n+                            }\n+                            _ => {\n+                                panic!(\"unknown type fed to Projection Deref.\");\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    impl<'c, 'tcx> Iterator for Restrictions<'c, 'tcx> {\n+        type Item = &'c Lvalue<'tcx>;\n+        fn next(&mut self) -> Option<Self::Item> {\n+            'pop: loop {\n+                let lvalue = match self.lvalue_stack.pop() {\n+                    None => return None,\n+                    Some(lvalue) => lvalue,\n+                };\n+\n+                // `lvalue` may not be a restriction itself, but may\n+                // hold one further down (e.g. we never return\n+                // downcasts here, but may return a base of a\n+                // downcast).\n+                //\n+                // Also, we need to enqueue any additional\n+                // subrestrictions that it implies, since we can only\n+                // return from from this call alone.\n+\n+                let mut cursor = lvalue;\n+                'cursor: loop {\n+                    let proj = match *cursor {\n+                        Lvalue::Local(_) => return Some(cursor), // search yielded this leaf\n+                        Lvalue::Static(_) => continue 'pop, // fruitless leaf; try next on stack\n+                        Lvalue::Projection(ref proj) => proj,\n+                    };\n+\n+                    match proj.elem {\n+                        ProjectionElem::Field(_/*field*/, _/*ty*/) => {\n+                            // FIXME: add union handling\n+                            self.lvalue_stack.push(&proj.base);\n+                            return Some(cursor);\n+                        }\n+                        ProjectionElem::Downcast(..) |\n+                        ProjectionElem::Subslice { .. } |\n+                        ProjectionElem::ConstantIndex { .. } |\n+                        ProjectionElem::Index(Operand::Constant(..)) => {\n+                            cursor = &proj.base;\n+                            continue 'cursor;\n+                        }\n+                        ProjectionElem::Index(Operand::Consume(ref index)) => {\n+                            self.lvalue_stack.push(index); // FIXME: did old borrowck do this?\n+                            cursor = &proj.base;\n+                            continue 'cursor;\n+                        }\n+                        ProjectionElem::Deref => {\n+                            // (handled below)\n+                        }\n+                    }\n+\n+                    assert_eq!(proj.elem, ProjectionElem::Deref);\n+\n+                    let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                    match ty.sty {\n+                        ty::TyRawPtr(_) => {\n+                            // borrowck ignores raw ptrs; treat analogous to imm borrow\n+                            continue 'pop;\n+                        }\n+                        // R-Deref-Imm-Borrowed\n+                        ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+                            // immutably-borrowed referents do not\n+                            // have recursively-implied restrictions\n+                            // (because preventing actions on `*LV`\n+                            // does nothing about aliases like `*LV1`)\n+\n+                            // FIXME: do I need to check validity of\n+                            // `_r` here though? (I think the original\n+                            // check_loans code did, like the readme\n+                            // says)\n+\n+                            // (And do I *really* not have to\n+                            // recursively process the `base` as a\n+                            // further search here? Leaving this `if\n+                            // false` here as a hint to look at this\n+                            // again later.\n+                            //\n+                            // Ah, it might be because the\n+                            // restrictions are distinct from the path\n+                            // substructure. Note that there is a\n+                            // separate loop over the path\n+                            // substructure in fn\n+                            // each_borrow_involving_path, for better\n+                            // or for worse.\n+\n+                            if false {\n+                                cursor = &proj.base;\n+                                continue 'cursor;\n+                            } else {\n+                                continue 'pop;\n+                            }\n+                        }\n+\n+                        // R-Deref-Mut-Borrowed\n+                        ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+                            // mutably-borrowed referents are\n+                            // themselves restricted.\n+\n+                            // FIXME: do I need to check validity of\n+                            // `_r` here though? (I think the original\n+                            // check_loans code did, like the readme\n+                            // says)\n+\n+                            // schedule base for future iteration.\n+                            self.lvalue_stack.push(&proj.base);\n+                            return Some(cursor); // search yielded interior node\n+                        }\n+\n+                        // R-Deref-Send-Pointer\n+                        ty::TyAdt(..) if ty.is_box() => {\n+                            // borrowing interior of a box implies that\n+                            // its base can no longer be mutated (o/w box\n+                            // storage would be freed)\n+                            self.lvalue_stack.push(&proj.base);\n+                            return Some(cursor); // search yielded interior node\n+                        }\n+\n+                        _ => panic!(\"unknown type fed to Projection Deref.\"),\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    fn report_use_of_moved(&mut self,\n+                           _context: Context,\n+                           (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_act_on_uninitialized_variable(\n+            span, \"use\", &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME: add span_label for use of uninitialized variable\n+        err.emit();\n+    }\n+\n+    fn report_move_out_while_borrowed(&mut self,\n+                                      _context: Context,\n+                                      (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_move_when_borrowed(\n+            span, &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME 1: add span_label for \"borrow of `()` occurs here\"\n+        // FIXME 2: add span_label for \"move out of `{}` occurs here\"\n+        err.emit();\n+    }\n+\n+    fn report_use_while_mutably_borrowed(&mut self,\n+                                         _context: Context,\n+                                         (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_use_when_mutably_borrowed(\n+            span, &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME 1: add span_label for \"borrow of `()` occurs here\"\n+        // FIXME 2: add span_label for \"use of `{}` occurs here\"\n+        err.emit();\n+    }\n+\n+    fn report_conflicting_borrow(&mut self,\n+                                 _context: Context,\n+                                 (lvalue, span): (&Lvalue, Span),\n+                                 loan1: &BorrowData,\n+                                 loan2: &BorrowData) {\n+        // FIXME: obviously falsifiable. Generalize for non-eq lvalues later.\n+        assert_eq!(loan1.lvalue, loan2.lvalue);\n+\n+        // FIXME: supply non-\"\" `opt_via` when appropriate\n+        let mut err = match (loan1.kind, \"immutable\", \"mutable\",\n+                             loan2.kind, \"immutable\", \"mutable\") {\n+            (BorrowKind::Shared, lft, _, BorrowKind::Mut, _, rgt) |\n+            (BorrowKind::Mut, _, lft, BorrowKind::Shared, rgt, _) |\n+            (BorrowKind::Mut, _, lft, BorrowKind::Mut, _, rgt) =>\n+                self.tcx.cannot_reborrow_already_borrowed(\n+                    span, &self.describe_lvalue(lvalue),\n+                    \"\", lft, \"it\", rgt, \"\", Origin::Mir),\n+\n+            _ =>  self.tcx.cannot_mutably_borrow_multiply(\n+                span, &self.describe_lvalue(lvalue), \"\", Origin::Mir),\n+            // FIXME: add span labels for first and second mutable borrows, as well as\n+            // end point for first.\n+        };\n+        err.emit();\n+    }\n+\n+    fn report_illegal_mutation_of_borrowed(&mut self, _: Context, (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_assign_to_borrowed(\n+            span, &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME: add span labels for borrow and assignment points\n+        err.emit();\n+    }\n+\n+    fn report_illegal_reassignment(&mut self, _context: Context, (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_reassign_immutable(\n+            span, &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME: add span labels for borrow and assignment points\n+        err.emit();\n+    }\n+\n+    fn report_assignment_to_static(&mut self, _context: Context, (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_assign_static(\n+            span, &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME: add span labels for borrow and assignment points\n+        err.emit();\n+    }\n+}\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    // End-user visible description of `lvalue`\n+    fn describe_lvalue(&self, lvalue: &Lvalue) -> String {\n+        let mut buf = String::new();\n+        self.append_lvalue_to_string(lvalue, &mut buf);\n+        buf\n+    }\n+\n+    // Appends end-user visible description of `lvalue` to `buf`.\n+    fn append_lvalue_to_string(&self, lvalue: &Lvalue, buf: &mut String) {\n+        match *lvalue {\n+            Lvalue::Local(local) => {\n+                let local = &self.mir.local_decls[local];\n+                match local.name {\n+                    Some(name) => buf.push_str(&format!(\"{}\", name)),\n+                    None => buf.push_str(\"_\"),\n+                }\n+            }\n+            Lvalue::Static(ref static_) => {\n+                buf.push_str(&format!(\"{}\", &self.tcx.item_name(static_.def_id)));\n+            }\n+            Lvalue::Projection(ref proj) => {\n+                let (prefix, suffix, index_operand) = match proj.elem {\n+                    ProjectionElem::Deref =>\n+                        (\"(*\", format!(\")\"), None),\n+                    ProjectionElem::Downcast(..) =>\n+                        (\"\",   format!(\"\"), None), // (dont emit downcast info)\n+                    ProjectionElem::Field(field, _ty) =>\n+                        (\"\",   format!(\".{}\", field.index()), None),\n+                    ProjectionElem::Index(ref index) =>\n+                        (\"\",   format!(\"\"), Some(index)),\n+                    ProjectionElem::ConstantIndex { offset, min_length, from_end: true } =>\n+                        (\"\",   format!(\"[{} of {}]\", offset, min_length), None),\n+                    ProjectionElem::ConstantIndex { offset, min_length, from_end: false } =>\n+                        (\"\",   format!(\"[-{} of {}]\", offset, min_length), None),\n+                    ProjectionElem::Subslice { from, to: 0 } =>\n+                        (\"\",   format!(\"[{}:]\", from), None),\n+                    ProjectionElem::Subslice { from: 0, to } =>\n+                        (\"\",   format!(\"[:-{}]\", to), None),\n+                    ProjectionElem::Subslice { from, to } =>\n+                        (\"\",   format!(\"[{}:-{}]\", from, to), None),\n+                };\n+                buf.push_str(prefix);\n+                self.append_lvalue_to_string(&proj.base, buf);\n+                if let Some(index) = index_operand {\n+                    buf.push_str(\"[\");\n+                    self.append_operand_to_string(index, buf);\n+                    buf.push_str(\"]\");\n+                } else {\n+                    buf.push_str(&suffix);\n+                }\n+\n+            }\n+        }\n+    }\n+\n+    fn append_operand_to_string(&self, operand: &Operand, buf: &mut String) {\n+        match *operand {\n+            Operand::Consume(ref lvalue) => {\n+                self.append_lvalue_to_string(lvalue, buf);\n+            }\n+            Operand::Constant(ref constant) => {\n+                buf.push_str(&format!(\"{:?}\", constant));\n+            }\n+        }\n+    }\n+}\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    // FIXME: needs to be able to express errors analogous to check_loans.rs\n+    fn conflicts_with(&self, loan1: &BorrowData<'gcx>, loan2: &BorrowData<'gcx>) -> bool {\n+        if loan1.compatible_with(loan2.kind) { return false; }\n+\n+        let loan2_base_path = self.base_path(&loan2.lvalue);\n+        for restricted in self.restrictions(&loan1.lvalue) {\n+            if restricted != loan2_base_path { continue; }\n+            return true;\n+        }\n+\n+        let loan1_base_path = self.base_path(&loan1.lvalue);\n+        for restricted in self.restrictions(&loan2.lvalue) {\n+            if restricted != loan1_base_path { continue; }\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    // FIXME (#16118): function intended to allow the borrow checker\n+    // to be less precise in its handling of Box while still allowing\n+    // moves out of a Box. They should be removed when/if we stop\n+    // treating Box specially (e.g. when/if DerefMove is added...)\n+\n+    fn base_path<'d>(&self, lvalue: &'d Lvalue<'gcx>) -> &'d Lvalue<'gcx> {\n+        //! Returns the base of the leftmost (deepest) dereference of an\n+        //! Box in `lvalue`. If there is no dereference of an Box\n+        //! in `lvalue`, then it just returns `lvalue` itself.\n+\n+        let mut cursor = lvalue;\n+        let mut deepest = lvalue;\n+        loop {\n+            let proj = match *cursor {\n+                Lvalue::Local(..) | Lvalue::Static(..) => return deepest,\n+                Lvalue::Projection(ref proj) => proj,\n+            };\n+            if proj.elem == ProjectionElem::Deref &&\n+                lvalue.ty(self.mir, self.tcx).to_ty(self.tcx).is_box()\n+            {\n+                deepest = &proj.base;\n+            }\n+            cursor = &proj.base;\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+struct Context {\n+    kind: ContextKind,\n+    loc: Location,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum ContextKind {\n+    AssignLhs,\n+    AssignRhs,\n+    SetDiscrim,\n+    InlineAsm,\n+    SwitchInt,\n+    Drop,\n+    DropAndReplace,\n+    CallOperator,\n+    CallOperand,\n+    CallDest,\n+    Assert,\n+    StorageDead,\n+}\n+\n+impl ContextKind {\n+    fn new(self, loc: Location) -> Context { Context { kind: self, loc: loc } }\n+}\n+\n+impl<'b, 'tcx: 'b> InProgress<'b, 'tcx> {\n+    pub(super) fn new(borrows: DataflowResults<Borrows<'b, 'tcx>>,\n+                      inits: DataflowResults<MaybeInitializedLvals<'b, 'tcx>>,\n+                      uninits: DataflowResults<MaybeUninitializedLvals<'b, 'tcx>>)\n+                      -> Self {\n+        InProgress {\n+            borrows: FlowInProgress::new(borrows),\n+            inits: FlowInProgress::new(inits),\n+            uninits: FlowInProgress::new(uninits),\n+        }\n+    }\n+\n+    fn each_flow<XB, XI, XU>(&mut self,\n+                             mut xform_borrows: XB,\n+                             mut xform_inits: XI,\n+                             mut xform_uninits: XU) where\n+        XB: FnMut(&mut FlowInProgress<Borrows<'b, 'tcx>>),\n+        XI: FnMut(&mut FlowInProgress<MaybeInitializedLvals<'b, 'tcx>>),\n+        XU: FnMut(&mut FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>>),\n+    {\n+        xform_borrows(&mut self.borrows);\n+        xform_inits(&mut self.inits);\n+        xform_uninits(&mut self.uninits);\n+    }\n+\n+    fn summary(&self) -> String {\n+        let mut s = String::new();\n+\n+        s.push_str(\"borrows in effect: [\");\n+        let mut saw_one = false;\n+        self.borrows.each_state_bit(|borrow| {\n+            if saw_one { s.push_str(\", \"); };\n+            saw_one = true;\n+            let borrow_data = &self.borrows.base_results.operator().borrows()[borrow];\n+            s.push_str(&format!(\"{}\", borrow_data));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"borrows generated: [\");\n+        let mut saw_one = false;\n+        self.borrows.each_gen_bit(|borrow| {\n+            if saw_one { s.push_str(\", \"); };\n+            saw_one = true;\n+            let borrow_data = &self.borrows.base_results.operator().borrows()[borrow];\n+            s.push_str(&format!(\"{}\", borrow_data));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"inits: [\");\n+        let mut saw_one = false;\n+        self.inits.each_state_bit(|mpi_init| {\n+            if saw_one { s.push_str(\", \"); };\n+            saw_one = true;\n+            let move_path =\n+                &self.inits.base_results.operator().move_data().move_paths[mpi_init];\n+            s.push_str(&format!(\"{}\", move_path));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"uninits: [\");\n+        let mut saw_one = false;\n+        self.uninits.each_state_bit(|mpi_uninit| {\n+            if saw_one { s.push_str(\", \"); };\n+            saw_one = true;\n+            let move_path =\n+                &self.uninits.base_results.operator().move_data().move_paths[mpi_uninit];\n+            s.push_str(&format!(\"{}\", move_path));\n+        });\n+        s.push_str(\"]\");\n+\n+        return s;\n+    }\n+}\n+\n+impl<BD> FlowInProgress<BD> where BD: BitDenotation {\n+    fn each_state_bit<F>(&self, f: F) where F: FnMut(BD::Idx) {\n+        self.curr_state.each_bit(self.base_results.operator().bits_per_block(), f)\n+    }\n+\n+    fn each_gen_bit<F>(&self, f: F) where F: FnMut(BD::Idx) {\n+        self.stmt_gen.each_bit(self.base_results.operator().bits_per_block(), f)\n+    }\n+\n+    fn new(results: DataflowResults<BD>) -> Self {\n+        let bits_per_block = results.sets().bits_per_block();\n+        let curr_state = IdxSetBuf::new_empty(bits_per_block);\n+        let stmt_gen = IdxSetBuf::new_empty(bits_per_block);\n+        let stmt_kill = IdxSetBuf::new_empty(bits_per_block);\n+        FlowInProgress {\n+            base_results: results,\n+            curr_state: curr_state,\n+            stmt_gen: stmt_gen,\n+            stmt_kill: stmt_kill,\n+        }\n+    }\n+\n+    fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n+        (*self.curr_state).clone_from(self.base_results.sets().on_entry_set_for(bb.index()));\n+    }\n+\n+    fn reconstruct_statement_effect(&mut self, loc: Location) {\n+        self.stmt_gen.reset_to_empty();\n+        self.stmt_kill.reset_to_empty();\n+        let mut ignored = IdxSetBuf::new_empty(0);\n+        let mut sets = BlockSets {\n+            on_entry: &mut ignored, gen_set: &mut self.stmt_gen, kill_set: &mut self.stmt_kill,\n+        };\n+        self.base_results.operator().statement_effect(&mut sets, loc);\n+    }\n+\n+    fn reconstruct_terminator_effect(&mut self, loc: Location) {\n+        self.stmt_gen.reset_to_empty();\n+        self.stmt_kill.reset_to_empty();\n+        let mut ignored = IdxSetBuf::new_empty(0);\n+        let mut sets = BlockSets {\n+            on_entry: &mut ignored, gen_set: &mut self.stmt_gen, kill_set: &mut self.stmt_kill,\n+        };\n+        self.base_results.operator().terminator_effect(&mut sets, loc);\n+    }\n+\n+    fn apply_local_effect(&mut self) {\n+        self.curr_state.union(&self.stmt_gen);\n+        self.curr_state.subtract(&self.stmt_kill);\n+    }\n+\n+    fn elems_generated(&self) -> indexed_set::Elems<BD::Idx> {\n+        let univ = self.base_results.sets().bits_per_block();\n+        self.stmt_gen.elems(univ)\n+    }\n+\n+    fn elems_incoming(&self) -> indexed_set::Elems<BD::Idx> {\n+        let univ = self.base_results.sets().bits_per_block();\n+        self.curr_state.elems(univ)\n+    }\n+}\n+\n+impl<'tcx> BorrowData<'tcx> {\n+    fn compatible_with(&self, bk: BorrowKind) -> bool {\n+        match (self.kind, bk) {\n+            (BorrowKind::Shared, BorrowKind::Shared) => true,\n+\n+            (BorrowKind::Mut, _) |\n+            (BorrowKind::Unique, _) |\n+            (_, BorrowKind::Mut) |\n+            (_, BorrowKind::Unique) => false,\n+        }\n     }\n }"}, {"sha": "c8e3dfedd7621779e37bdb52536e51032f363ab7", "filename": "src/librustc_mir/transform/borrow_check.rs", "status": "removed", "additions": 0, "deletions": 1243, "changes": 1243, "blob_url": "https://github.com/rust-lang/rust/blob/c280afcc1c6b7c14218bf2a8322ebb3ac692485a/src%2Flibrustc_mir%2Ftransform%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c280afcc1c6b7c14218bf2a8322ebb3ac692485a/src%2Flibrustc_mir%2Ftransform%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fborrow_check.rs?ref=c280afcc1c6b7c14218bf2a8322ebb3ac692485a", "patch": "@@ -1,1243 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! This pass borrow-checks the MIR to (further) ensure it is not broken.\n-\n-use rustc::infer::{InferCtxt};\n-use rustc::ty::{self, TyCtxt, ParamEnv};\n-use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Location, Lvalue};\n-use rustc::mir::{Mir, Mutability, Operand, Projection, ProjectionElem, Rvalue};\n-use rustc::mir::{Statement, StatementKind, Terminator, TerminatorKind};\n-use rustc::mir::transform::{MirSource};\n-\n-use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n-use rustc_data_structures::indexed_vec::{Idx};\n-\n-use syntax::ast::{self};\n-use syntax_pos::{DUMMY_SP, Span};\n-\n-use dataflow::{do_dataflow};\n-use dataflow::{MoveDataParamEnv};\n-use dataflow::{BitDenotation, BlockSets, DataflowResults, DataflowResultsConsumer};\n-use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n-use dataflow::{Borrows, BorrowData, BorrowIndex};\n-use dataflow::move_paths::{HasMoveData, MoveData, MovePathIndex, LookupResult};\n-use util::borrowck_errors::{BorrowckErrors, Origin};\n-\n-use self::MutateMode::{JustWrite, WriteAndRead};\n-use self::ConsumeKind::{Consume};\n-\n-pub(crate) fn borrowck_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &Mir<'tcx>)\n-{\n-    let id = src.item_id();\n-    let def_id = tcx.hir.local_def_id(id);\n-    debug!(\"borrowck_mir({}) UNIMPLEMENTED\", tcx.item_path_str(def_id));\n-\n-    let attributes = tcx.get_attrs(def_id);\n-    let param_env = tcx.param_env(def_id);\n-    tcx.infer_ctxt().enter(|_infcx| {\n-\n-        let move_data = MoveData::gather_moves(mir, tcx, param_env);\n-        let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n-        let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n-        let flow_borrows = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n-                                       Borrows::new(tcx, mir),\n-                                       |bd, i| bd.location(i));\n-        let flow_inits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n-                                     MaybeInitializedLvals::new(tcx, mir, &mdpe),\n-                                     |bd, i| &bd.move_data().move_paths[i]);\n-        let flow_uninits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n-                                       MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n-                                       |bd, i| &bd.move_data().move_paths[i]);\n-\n-        let mut mbcx = MirBorrowckCtxt {\n-            tcx: tcx,\n-            mir: mir,\n-            node_id: id,\n-            move_data: &mdpe.move_data,\n-            param_env: param_env,\n-            fake_infer_ctxt: &_infcx,\n-        };\n-\n-        let mut state = InProgress::new(flow_borrows,\n-                                        flow_inits,\n-                                        flow_uninits);\n-\n-        mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n-    });\n-\n-    debug!(\"borrowck_mir done\");\n-}\n-\n-#[allow(dead_code)]\n-pub struct MirBorrowckCtxt<'c, 'b, 'a: 'b+'c, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-    mir: &'b Mir<'gcx>,\n-    node_id: ast::NodeId,\n-    move_data: &'b MoveData<'gcx>,\n-    param_env: ParamEnv<'tcx>,\n-    fake_infer_ctxt: &'c InferCtxt<'c, 'gcx, 'tcx>,\n-}\n-\n-// (forced to be `pub` due to its use as an associated type below.)\n-pub struct InProgress<'b, 'tcx: 'b> {\n-    borrows: FlowInProgress<Borrows<'b, 'tcx>>,\n-    inits: FlowInProgress<MaybeInitializedLvals<'b, 'tcx>>,\n-    uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>>,\n-}\n-\n-struct FlowInProgress<BD> where BD: BitDenotation {\n-    base_results: DataflowResults<BD>,\n-    curr_state: IdxSetBuf<BD::Idx>,\n-    stmt_gen: IdxSetBuf<BD::Idx>,\n-    stmt_kill: IdxSetBuf<BD::Idx>,\n-}\n-\n-// Check that:\n-// 1. assignments are always made to mutable locations (FIXME: does that still really go here?)\n-// 2. loans made in overlapping scopes do not conflict\n-// 3. assignments do not affect things loaned out as immutable\n-// 4. moves do not affect things loaned out in any way\n-impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n-    for MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n-{\n-    type FlowState = InProgress<'b, 'gcx>;\n-\n-    fn mir(&self) -> &'b Mir<'gcx> { self.mir }\n-\n-    fn reset_to_entry_of(&mut self, bb: BasicBlock, flow_state: &mut Self::FlowState) {\n-        flow_state.each_flow(|b| b.reset_to_entry_of(bb),\n-                             |i| i.reset_to_entry_of(bb),\n-                             |u| u.reset_to_entry_of(bb));\n-    }\n-\n-    fn reconstruct_statement_effect(&mut self,\n-                                    location: Location,\n-                                    flow_state: &mut Self::FlowState) {\n-        flow_state.each_flow(|b| b.reconstruct_statement_effect(location),\n-                             |i| i.reconstruct_statement_effect(location),\n-                             |u| u.reconstruct_statement_effect(location));\n-    }\n-\n-    fn apply_local_effect(&mut self,\n-                          _location: Location,\n-                          flow_state: &mut Self::FlowState) {\n-        flow_state.each_flow(|b| b.apply_local_effect(),\n-                             |i| i.apply_local_effect(),\n-                             |u| u.apply_local_effect());\n-    }\n-\n-    fn reconstruct_terminator_effect(&mut self,\n-                                     location: Location,\n-                                     flow_state: &mut Self::FlowState) {\n-        flow_state.each_flow(|b| b.reconstruct_terminator_effect(location),\n-                             |i| i.reconstruct_terminator_effect(location),\n-                             |u| u.reconstruct_terminator_effect(location));\n-    }\n-\n-    fn visit_block_entry(&mut self,\n-                         bb: BasicBlock,\n-                         flow_state: &Self::FlowState) {\n-        let summary = flow_state.summary();\n-        debug!(\"MirBorrowckCtxt::process_block({:?}): {}\", bb, summary);\n-    }\n-\n-    fn visit_statement_entry(&mut self,\n-                             location: Location,\n-                             stmt: &Statement<'gcx>,\n-                             flow_state: &Self::FlowState) {\n-        let summary = flow_state.summary();\n-        debug!(\"MirBorrowckCtxt::process_statement({:?}, {:?}): {}\", location, stmt, summary);\n-        let span = stmt.source_info.span;\n-        match stmt.kind {\n-            StatementKind::Assign(ref lhs, ref rhs) => {\n-                self.mutate_lvalue(ContextKind::AssignLhs.new(location),\n-                                   (lhs, span), JustWrite, flow_state);\n-                self.consume_rvalue(ContextKind::AssignRhs.new(location),\n-                                    (rhs, span), location, flow_state);\n-            }\n-            StatementKind::SetDiscriminant { ref lvalue, variant_index: _ } => {\n-                self.mutate_lvalue(ContextKind::SetDiscrim.new(location),\n-                                   (lvalue, span), JustWrite, flow_state);\n-            }\n-            StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n-                for (o, output) in asm.outputs.iter().zip(outputs) {\n-                    if o.is_indirect {\n-                        self.consume_lvalue(ContextKind::InlineAsm.new(location),\n-                                            Consume,\n-                                            (output, span),\n-                                            flow_state);\n-                    } else {\n-                        self.mutate_lvalue(ContextKind::InlineAsm.new(location),\n-                                           (output, span),\n-                                           if o.is_rw { WriteAndRead } else { JustWrite },\n-                                           flow_state);\n-                    }\n-                }\n-                for input in inputs {\n-                    self.consume_operand(ContextKind::InlineAsm.new(location),\n-                                         Consume,\n-                                         (input, span), flow_state);\n-                }\n-            }\n-            StatementKind::EndRegion(ref _rgn) => {\n-                // ignored when consuming results (update to\n-                // flow_state already handled).\n-            }\n-            StatementKind::Nop |\n-            StatementKind::Validate(..) |\n-            StatementKind::StorageLive(..) => {\n-                // ignored by borrowck\n-            }\n-\n-            StatementKind::StorageDead(ref lvalue) => {\n-                // causes non-drop values to be dropped.\n-                self.consume_lvalue(ContextKind::StorageDead.new(location),\n-                                    ConsumeKind::Consume,\n-                                    (lvalue, span),\n-                                    flow_state)\n-            }\n-        }\n-    }\n-\n-    fn visit_terminator_entry(&mut self,\n-                              location: Location,\n-                              term: &Terminator<'gcx>,\n-                              flow_state: &Self::FlowState) {\n-        let loc = location;\n-        let summary = flow_state.summary();\n-        debug!(\"MirBorrowckCtxt::process_terminator({:?}, {:?}): {}\", location, term, summary);\n-        let span = term.source_info.span;\n-        match term.kind {\n-            TerminatorKind::SwitchInt { ref discr, switch_ty: _, values: _, targets: _ } => {\n-                self.consume_operand(ContextKind::SwitchInt.new(loc),\n-                                     Consume,\n-                                     (discr, span), flow_state);\n-            }\n-            TerminatorKind::Drop { location: ref drop_lvalue, target: _, unwind: _ } => {\n-                self.consume_lvalue(ContextKind::Drop.new(loc),\n-                                    ConsumeKind::Drop,\n-                                    (drop_lvalue, span), flow_state);\n-            }\n-            TerminatorKind::DropAndReplace { location: ref drop_lvalue,\n-                                             value: ref new_value,\n-                                             target: _,\n-                                             unwind: _ } => {\n-                self.mutate_lvalue(ContextKind::DropAndReplace.new(loc),\n-                                   (drop_lvalue, span), JustWrite, flow_state);\n-                self.consume_operand(ContextKind::DropAndReplace.new(loc),\n-                                     ConsumeKind::Drop,\n-                                     (new_value, span), flow_state);\n-            }\n-            TerminatorKind::Call { ref func, ref args, ref destination, cleanup: _ } => {\n-                self.consume_operand(ContextKind::CallOperator.new(loc),\n-                                     Consume,\n-                                     (func, span), flow_state);\n-                for arg in args {\n-                    self.consume_operand(ContextKind::CallOperand.new(loc),\n-                                         Consume,\n-                                         (arg, span), flow_state);\n-                }\n-                if let Some((ref dest, _/*bb*/)) = *destination {\n-                    self.mutate_lvalue(ContextKind::CallDest.new(loc),\n-                                       (dest, span), JustWrite, flow_state);\n-                }\n-            }\n-            TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n-                self.consume_operand(ContextKind::Assert.new(loc),\n-                                     Consume,\n-                                     (cond, span), flow_state);\n-                match *msg {\n-                    AssertMessage::BoundsCheck { ref len, ref index } => {\n-                        self.consume_operand(ContextKind::Assert.new(loc),\n-                                             Consume,\n-                                             (len, span), flow_state);\n-                        self.consume_operand(ContextKind::Assert.new(loc),\n-                                             Consume,\n-                                             (index, span), flow_state);\n-                    }\n-                    AssertMessage::Math(_/*const_math_err*/) => {}\n-                }\n-            }\n-\n-            TerminatorKind::Goto { target: _ } |\n-            TerminatorKind::Resume |\n-            TerminatorKind::Return |\n-            TerminatorKind::Unreachable => {\n-                // no data used, thus irrelevant to borrowck\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum MutateMode { JustWrite, WriteAndRead }\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum ConsumeKind { Drop, Consume }\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum Control { Continue, Break }\n-\n-impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n-    fn mutate_lvalue(&mut self,\n-                     context: Context,\n-                     lvalue_span: (&Lvalue<'gcx>, Span),\n-                     mode: MutateMode,\n-                     flow_state: &InProgress<'b, 'gcx>) {\n-        // Write of P[i] or *P, or WriteAndRead of any P, requires P init'd.\n-        match mode {\n-            MutateMode::WriteAndRead => {\n-                self.check_if_path_is_moved(context, lvalue_span, flow_state);\n-            }\n-            MutateMode::JustWrite => {\n-                self.check_if_assigned_path_is_moved(context, lvalue_span, flow_state);\n-            }\n-        }\n-\n-        // check we don't invalidate any outstanding loans\n-        self.each_borrow_involving_path(context,\n-                                        lvalue_span.0, flow_state, |this, _index, _data| {\n-                                            this.report_illegal_mutation_of_borrowed(context,\n-                                                                                     lvalue_span);\n-                                            Control::Break\n-                                        });\n-\n-        // check for reassignments to immutable local variables\n-        self.check_if_reassignment_to_immutable_state(context, lvalue_span, flow_state);\n-    }\n-\n-    fn consume_rvalue(&mut self,\n-                      context: Context,\n-                      (rvalue, span): (&Rvalue<'gcx>, Span),\n-                      location: Location,\n-                      flow_state: &InProgress<'b, 'gcx>) {\n-        match *rvalue {\n-            Rvalue::Ref(_/*rgn*/, bk, ref lvalue) => {\n-                self.borrow(context, location, bk, (lvalue, span), flow_state)\n-            }\n-\n-            Rvalue::Use(ref operand) |\n-            Rvalue::Repeat(ref operand, _) |\n-            Rvalue::UnaryOp(_/*un_op*/, ref operand) |\n-            Rvalue::Cast(_/*cast_kind*/, ref operand, _/*ty*/) => {\n-                self.consume_operand(context, Consume, (operand, span), flow_state)\n-            }\n-\n-            Rvalue::Len(ref lvalue) |\n-            Rvalue::Discriminant(ref lvalue) => {\n-                // len(_)/discriminant(_) merely read, not consume.\n-                self.check_if_path_is_moved(context, (lvalue, span), flow_state);\n-            }\n-\n-            Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2) |\n-            Rvalue::CheckedBinaryOp(_bin_op, ref operand1, ref operand2) => {\n-                self.consume_operand(context, Consume, (operand1, span), flow_state);\n-                self.consume_operand(context, Consume, (operand2, span), flow_state);\n-            }\n-\n-            Rvalue::NullaryOp(_op, _ty) => {\n-                // nullary ops take no dynamic input; no borrowck effect.\n-                //\n-                // FIXME: is above actually true? Do we want to track\n-                // the fact that uninitialized data can be created via\n-                // `NullOp::Box`?\n-            }\n-\n-            Rvalue::Aggregate(ref _aggregate_kind, ref operands) => {\n-                for operand in operands {\n-                    self.consume_operand(context, Consume, (operand, span), flow_state);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn consume_operand(&mut self,\n-                       context: Context,\n-                       consume_via_drop: ConsumeKind,\n-                       (operand, span): (&Operand<'gcx>, Span),\n-                       flow_state: &InProgress<'b, 'gcx>) {\n-        match *operand {\n-            Operand::Consume(ref lvalue) =>\n-                self.consume_lvalue(context, consume_via_drop, (lvalue, span), flow_state),\n-            Operand::Constant(_) => {}\n-        }\n-    }\n-\n-    fn consume_lvalue(&mut self,\n-                      context: Context,\n-                      consume_via_drop: ConsumeKind,\n-                      lvalue_span: (&Lvalue<'gcx>, Span),\n-                      flow_state: &InProgress<'b, 'gcx>) {\n-        let lvalue = lvalue_span.0;\n-        let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n-        let moves_by_default =\n-            self.fake_infer_ctxt.type_moves_by_default(self.param_env, ty, DUMMY_SP);\n-        if moves_by_default {\n-            // move of lvalue: check if this is move of already borrowed path\n-            self.each_borrow_involving_path(\n-                context, lvalue_span.0, flow_state, |this, _idx, borrow| {\n-                    if !borrow.compatible_with(BorrowKind::Mut) {\n-                        this.report_move_out_while_borrowed(context, lvalue_span);\n-                        Control::Break\n-                    } else {\n-                        Control::Continue\n-                    }\n-                });\n-        } else {\n-            // copy of lvalue: check if this is \"copy of frozen path\" (FIXME: see check_loans.rs)\n-            self.each_borrow_involving_path(\n-                context, lvalue_span.0, flow_state, |this, _idx, borrow| {\n-                    if !borrow.compatible_with(BorrowKind::Shared) {\n-                        this.report_use_while_mutably_borrowed(context, lvalue_span);\n-                        Control::Break\n-                    } else {\n-                        Control::Continue\n-                    }\n-                });\n-        }\n-\n-        // Finally, check if path was already moved.\n-        match consume_via_drop {\n-            ConsumeKind::Drop => {\n-                // If path is merely being dropped, then we'll already\n-                // check the drop flag to see if it is moved (thus we\n-                // skip this check in that case).\n-            }\n-            ConsumeKind::Consume => {\n-                self.check_if_path_is_moved(context, lvalue_span, flow_state);\n-            }\n-        }\n-    }\n-\n-    fn borrow(&mut self,\n-              context: Context,\n-              location: Location,\n-              bk: BorrowKind,\n-              lvalue_span: (&Lvalue<'gcx>, Span),\n-              flow_state: &InProgress<'b, 'gcx>) {\n-        debug!(\"borrow location: {:?} lvalue: {:?} span: {:?}\",\n-               location, lvalue_span.0, lvalue_span.1);\n-        self.check_if_path_is_moved(context, lvalue_span, flow_state);\n-        self.check_for_conflicting_loans(context, location, bk, lvalue_span, flow_state);\n-    }\n-}\n-\n-impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n-    fn check_if_reassignment_to_immutable_state(&mut self,\n-                                                context: Context,\n-                                                (lvalue, span): (&Lvalue<'gcx>, Span),\n-                                                flow_state: &InProgress<'b, 'gcx>) {\n-        let move_data = flow_state.inits.base_results.operator().move_data();\n-\n-        // determine if this path has a non-mut owner (and thus needs checking).\n-        let mut l = lvalue;\n-        loop {\n-            match *l {\n-                Lvalue::Projection(ref proj) => {\n-                    l = &proj.base;\n-                    continue;\n-                }\n-                Lvalue::Local(local) => {\n-                    match self.mir.local_decls[local].mutability {\n-                        Mutability::Not => break, // needs check\n-                        Mutability::Mut => return,\n-                    }\n-                }\n-                Lvalue::Static(_) => {\n-                    // mutation of non-mut static is always illegal,\n-                    // independent of dataflow.\n-                    self.report_assignment_to_static(context, (lvalue, span));\n-                    return;\n-                }\n-            }\n-        }\n-\n-        if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n-            if flow_state.inits.curr_state.contains(&mpi) {\n-                // may already be assigned before reaching this statement;\n-                // report error.\n-                self.report_illegal_reassignment(context, (lvalue, span));\n-            }\n-        }\n-    }\n-\n-    fn check_if_path_is_moved(&mut self,\n-                              context: Context,\n-                              lvalue_span: (&Lvalue<'gcx>, Span),\n-                              flow_state: &InProgress<'b, 'gcx>) {\n-        // FIXME: analogous code in check_loans first maps `lvalue` to\n-        // its base_path ... but is that what we want here?\n-        let lvalue = self.base_path(lvalue_span.0);\n-\n-        let maybe_uninits = &flow_state.uninits;\n-        let move_data = maybe_uninits.base_results.operator().move_data();\n-        if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n-            if maybe_uninits.curr_state.contains(&mpi) {\n-                // find and report move(s) that could cause this to be uninitialized\n-                self.report_use_of_moved(context, lvalue_span);\n-            } else {\n-                // sanity check: initialized on *some* path, right?\n-                assert!(flow_state.inits.curr_state.contains(&mpi));\n-            }\n-        }\n-    }\n-\n-    fn move_path_for_lvalue(&mut self,\n-                            _context: Context,\n-                            move_data: &MoveData<'gcx>,\n-                            lvalue: &Lvalue<'gcx>)\n-                            -> Option<MovePathIndex>\n-    {\n-        // If returns None, then there is no move path corresponding\n-        // to a direct owner of `lvalue` (which means there is nothing\n-        // that borrowck tracks for its analysis).\n-\n-        match move_data.rev_lookup.find(lvalue) {\n-            LookupResult::Parent(_) => None,\n-            LookupResult::Exact(mpi) => Some(mpi),\n-        }\n-    }\n-\n-    fn check_if_assigned_path_is_moved(&mut self,\n-                                       context: Context,\n-                                       (lvalue, span): (&Lvalue<'gcx>, Span),\n-                                       flow_state: &InProgress<'b, 'gcx>) {\n-        // recur down lvalue; dispatch to check_if_path_is_moved when necessary\n-        let mut lvalue = lvalue;\n-        loop {\n-            match *lvalue {\n-                Lvalue::Local(_) | Lvalue::Static(_) => {\n-                    // assigning to `x` does not require `x` be initialized.\n-                    break;\n-                }\n-                Lvalue::Projection(ref proj) => {\n-                    let Projection { ref base, ref elem } = **proj;\n-                    match *elem {\n-                        ProjectionElem::Deref |\n-                        // assigning to *P requires `P` initialized.\n-                        ProjectionElem::Index(_/*operand*/) |\n-                        ProjectionElem::ConstantIndex { .. } |\n-                        // assigning to P[i] requires `P` initialized.\n-                        ProjectionElem::Downcast(_/*adt_def*/, _/*variant_idx*/) =>\n-                        // assigning to (P->variant) is okay if assigning to `P` is okay\n-                        //\n-                        // FIXME: is this true even if P is a adt with a dtor?\n-                        { }\n-\n-                        ProjectionElem::Subslice { .. } => {\n-                            panic!(\"we dont allow assignments to subslices, context: {:?}\",\n-                                   context);\n-                        }\n-\n-                        ProjectionElem::Field(..) => {\n-                            // if type of `P` has a dtor, then\n-                            // assigning to `P.f` requires `P` itself\n-                            // be already initialized\n-                            let tcx = self.tcx;\n-                            match base.ty(self.mir, tcx).to_ty(tcx).sty {\n-                                ty::TyAdt(def, _) if def.has_dtor(tcx) => {\n-\n-                                    // FIXME: analogous code in\n-                                    // check_loans.rs first maps\n-                                    // `base` to its base_path.\n-\n-                                    self.check_if_path_is_moved(context,\n-                                                                (base, span), flow_state);\n-\n-                                    // (base initialized; no need to\n-                                    // recur further)\n-                                    break;\n-                                }\n-                                _ => {}\n-                            }\n-                        }\n-                    }\n-\n-                    lvalue = base;\n-                    continue;\n-                }\n-            }\n-        }\n-    }\n-\n-    fn check_for_conflicting_loans(&mut self,\n-                                   context: Context,\n-                                   _location: Location,\n-                                   _bk: BorrowKind,\n-                                   lvalue_span: (&Lvalue<'gcx>, Span),\n-                                   flow_state: &InProgress<'b, 'gcx>) {\n-        // NOTE FIXME: The analogous code in old borrowck\n-        // check_loans.rs is careful to iterate over every *issued*\n-        // loan, as opposed to just the in scope ones.\n-        //\n-        // (Or if you prefer, all the *other* iterations over loans\n-        // only consider loans that are in scope of some given\n-        // CodeExtent)\n-        //\n-        // The (currently skeletal) code here does not encode such a\n-        // distinction, which means it is almost certainly over\n-        // looking something.\n-        //\n-        // (It is probably going to reject code that should be\n-        // accepted, I suspect, by treated issued-but-out-of-scope\n-        // loans as issued-and-in-scope, and thus causing them to\n-        // interfere with other loans.)\n-        //\n-        // However, I just want to get something running, especially\n-        // since I am trying to move into new territory with NLL, so\n-        // lets get this going first, and then address the issued vs\n-        // in-scope distinction later.\n-\n-        let state = &flow_state.borrows;\n-        let data = &state.base_results.operator().borrows();\n-\n-        debug!(\"check_for_conflicting_loans location: {:?}\", _location);\n-\n-        // does any loan generated here conflict with a previously issued loan?\n-        let mut loans_generated = 0;\n-        for (g, gen) in state.elems_generated().map(|g| (g, &data[g])) {\n-            loans_generated += 1;\n-            for (i, issued) in state.elems_incoming().map(|i| (i, &data[i])) {\n-                debug!(\"check_for_conflicting_loans gen: {:?} issued: {:?} conflicts: {}\",\n-                       (g, gen, self.base_path(&gen.lvalue),\n-                        self.restrictions(&gen.lvalue).collect::<Vec<_>>()),\n-                       (i, issued, self.base_path(&issued.lvalue),\n-                        self.restrictions(&issued.lvalue).collect::<Vec<_>>()),\n-                       self.conflicts_with(gen, issued));\n-                if self.conflicts_with(gen, issued) {\n-                    self.report_conflicting_borrow(context, lvalue_span, gen, issued);\n-                }\n-            }\n-        }\n-\n-        // MIR statically ensures each statement gens *at most one*\n-        // loan; mutual conflict (within a statement) can't arise.\n-        //\n-        // As safe-guard, assert that above property actually holds.\n-        assert!(loans_generated <= 1);\n-    } }\n-\n-impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n-    fn each_borrow_involving_path<F>(&mut self,\n-                                     _context: Context,\n-                                     lvalue: &Lvalue<'gcx>,\n-                                     flow_state: &InProgress<'b, 'gcx>,\n-                                     mut op: F)\n-        where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'gcx>) -> Control\n-    {\n-        // FIXME: analogous code in check_loans first maps `lvalue` to\n-        // its base_path.\n-\n-        let domain = flow_state.borrows.base_results.operator();\n-        let data = domain.borrows();\n-\n-        // check for loan restricting path P being used. Accounts for\n-        // borrows of P, P.a.b, etc.\n-        for i in flow_state.borrows.elems_incoming() {\n-            // FIXME: check_loans.rs filtered this to \"in scope\"\n-            // loans; i.e. it took a scope S and checked that each\n-            // restriction's kill_scope was a superscope of S.\n-            let borrowed = &data[i];\n-            for restricted in self.restrictions(&borrowed.lvalue) {\n-                if restricted == lvalue {\n-                    let ctrl = op(self, i, borrowed);\n-                    if ctrl == Control::Break { return; }\n-                }\n-            }\n-        }\n-\n-        // check for loans (not restrictions) on any base path.\n-        // e.g. Rejects `{ let x = &mut a.b; let y = a.b.c; }`,\n-        // since that moves out of borrowed path `a.b`.\n-        //\n-        // Limiting to loans (not restrictions) keeps this one\n-        // working: `{ let x = &mut a.b; let y = a.c; }`\n-        let mut cursor = lvalue;\n-        loop {\n-            // FIXME: check_loans.rs invoked `op` *before* cursor\n-            // shift here.  Might just work (and even avoid redundant\n-            // errors?) given code above?  But for now, I want to try\n-            // doing what I think is more \"natural\" check.\n-            for i in flow_state.borrows.elems_incoming() {\n-                let borrowed = &data[i];\n-                if borrowed.lvalue == *cursor {\n-                    let ctrl = op(self, i, borrowed);\n-                    if ctrl == Control::Break { return; }\n-                }\n-            }\n-\n-            match *cursor {\n-                Lvalue::Local(_) | Lvalue::Static(_) => break,\n-                Lvalue::Projection(ref proj) => cursor = &proj.base,\n-            }\n-        }\n-    }\n-}\n-\n-mod restrictions {\n-    use super::MirBorrowckCtxt;\n-\n-    use rustc::hir;\n-    use rustc::ty::{self, TyCtxt};\n-    use rustc::mir::{Lvalue, Mir, Operand, ProjectionElem};\n-\n-    pub(super) struct Restrictions<'c, 'tcx: 'c> {\n-        mir: &'c Mir<'tcx>,\n-        tcx: TyCtxt<'c, 'tcx, 'tcx>,\n-        lvalue_stack: Vec<&'c Lvalue<'tcx>>,\n-    }\n-\n-    impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n-        pub(super) fn restrictions<'d>(&self,\n-                                       lvalue: &'d Lvalue<'gcx>)\n-                                       -> Restrictions<'d, 'gcx> where 'b: 'd\n-        {\n-            let lvalue_stack = if self.has_restrictions(lvalue) { vec![lvalue] } else { vec![] };\n-            Restrictions { lvalue_stack: lvalue_stack, mir: self.mir, tcx: self.tcx }\n-        }\n-\n-        fn has_restrictions(&self, lvalue: &Lvalue<'gcx>) -> bool {\n-            let mut cursor = lvalue;\n-            loop {\n-                let proj = match *cursor {\n-                    Lvalue::Local(_) => return true,\n-                    Lvalue::Static(_) => return false,\n-                    Lvalue::Projection(ref proj) => proj,\n-                };\n-                match proj.elem {\n-                    ProjectionElem::Index(..) |\n-                    ProjectionElem::ConstantIndex { .. } |\n-                    ProjectionElem::Downcast(..) |\n-                    ProjectionElem::Subslice { .. } |\n-                    ProjectionElem::Field(_/*field*/, _/*ty*/) => {\n-                        cursor = &proj.base;\n-                        continue;\n-                    }\n-                    ProjectionElem::Deref => {\n-                        let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                        match ty.sty {\n-                            ty::TyRawPtr(_) => {\n-                                return false;\n-                            }\n-                            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n-                                // FIXME: do I need to check validity of\n-                                // region here though? (I think the original\n-                                // check_loans code did, like readme says)\n-                                return false;\n-                            }\n-                            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n-                                cursor = &proj.base;\n-                                continue;\n-                            }\n-                            ty::TyAdt(..) if ty.is_box() => {\n-                                cursor = &proj.base;\n-                                continue;\n-                            }\n-                            _ => {\n-                                panic!(\"unknown type fed to Projection Deref.\");\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    impl<'c, 'tcx> Iterator for Restrictions<'c, 'tcx> {\n-        type Item = &'c Lvalue<'tcx>;\n-        fn next(&mut self) -> Option<Self::Item> {\n-            'pop: loop {\n-                let lvalue = match self.lvalue_stack.pop() {\n-                    None => return None,\n-                    Some(lvalue) => lvalue,\n-                };\n-\n-                // `lvalue` may not be a restriction itself, but may\n-                // hold one further down (e.g. we never return\n-                // downcasts here, but may return a base of a\n-                // downcast).\n-                //\n-                // Also, we need to enqueue any additional\n-                // subrestrictions that it implies, since we can only\n-                // return from from this call alone.\n-\n-                let mut cursor = lvalue;\n-                'cursor: loop {\n-                    let proj = match *cursor {\n-                        Lvalue::Local(_) => return Some(cursor), // search yielded this leaf\n-                        Lvalue::Static(_) => continue 'pop, // fruitless leaf; try next on stack\n-                        Lvalue::Projection(ref proj) => proj,\n-                    };\n-\n-                    match proj.elem {\n-                        ProjectionElem::Field(_/*field*/, _/*ty*/) => {\n-                            // FIXME: add union handling\n-                            self.lvalue_stack.push(&proj.base);\n-                            return Some(cursor);\n-                        }\n-                        ProjectionElem::Downcast(..) |\n-                        ProjectionElem::Subslice { .. } |\n-                        ProjectionElem::ConstantIndex { .. } |\n-                        ProjectionElem::Index(Operand::Constant(..)) => {\n-                            cursor = &proj.base;\n-                            continue 'cursor;\n-                        }\n-                        ProjectionElem::Index(Operand::Consume(ref index)) => {\n-                            self.lvalue_stack.push(index); // FIXME: did old borrowck do this?\n-                            cursor = &proj.base;\n-                            continue 'cursor;\n-                        }\n-                        ProjectionElem::Deref => {\n-                            // (handled below)\n-                        }\n-                    }\n-\n-                    assert_eq!(proj.elem, ProjectionElem::Deref);\n-\n-                    let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                    match ty.sty {\n-                        ty::TyRawPtr(_) => {\n-                            // borrowck ignores raw ptrs; treat analogous to imm borrow\n-                            continue 'pop;\n-                        }\n-                        // R-Deref-Imm-Borrowed\n-                        ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n-                            // immutably-borrowed referents do not\n-                            // have recursively-implied restrictions\n-                            // (because preventing actions on `*LV`\n-                            // does nothing about aliases like `*LV1`)\n-\n-                            // FIXME: do I need to check validity of\n-                            // `_r` here though? (I think the original\n-                            // check_loans code did, like the readme\n-                            // says)\n-\n-                            // (And do I *really* not have to\n-                            // recursively process the `base` as a\n-                            // further search here? Leaving this `if\n-                            // false` here as a hint to look at this\n-                            // again later.\n-                            //\n-                            // Ah, it might be because the\n-                            // restrictions are distinct from the path\n-                            // substructure. Note that there is a\n-                            // separate loop over the path\n-                            // substructure in fn\n-                            // each_borrow_involving_path, for better\n-                            // or for worse.\n-\n-                            if false {\n-                                cursor = &proj.base;\n-                                continue 'cursor;\n-                            } else {\n-                                continue 'pop;\n-                            }\n-                        }\n-\n-                        // R-Deref-Mut-Borrowed\n-                        ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n-                            // mutably-borrowed referents are\n-                            // themselves restricted.\n-\n-                            // FIXME: do I need to check validity of\n-                            // `_r` here though? (I think the original\n-                            // check_loans code did, like the readme\n-                            // says)\n-\n-                            // schedule base for future iteration.\n-                            self.lvalue_stack.push(&proj.base);\n-                            return Some(cursor); // search yielded interior node\n-                        }\n-\n-                        // R-Deref-Send-Pointer\n-                        ty::TyAdt(..) if ty.is_box() => {\n-                            // borrowing interior of a box implies that\n-                            // its base can no longer be mutated (o/w box\n-                            // storage would be freed)\n-                            self.lvalue_stack.push(&proj.base);\n-                            return Some(cursor); // search yielded interior node\n-                        }\n-\n-                        _ => panic!(\"unknown type fed to Projection Deref.\"),\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n-    fn report_use_of_moved(&mut self,\n-                           _context: Context,\n-                           (lvalue, span): (&Lvalue, Span)) {\n-        let mut err = self.tcx.cannot_act_on_uninitialized_variable(\n-            span, \"use\", &self.describe_lvalue(lvalue), Origin::Mir);\n-        // FIXME: add span_label for use of uninitialized variable\n-        err.emit();\n-    }\n-\n-    fn report_move_out_while_borrowed(&mut self,\n-                                      _context: Context,\n-                                      (lvalue, span): (&Lvalue, Span)) {\n-        let mut err = self.tcx.cannot_move_when_borrowed(\n-            span, &self.describe_lvalue(lvalue), Origin::Mir);\n-        // FIXME 1: add span_label for \"borrow of `()` occurs here\"\n-        // FIXME 2: add span_label for \"move out of `{}` occurs here\"\n-        err.emit();\n-    }\n-\n-    fn report_use_while_mutably_borrowed(&mut self,\n-                                         _context: Context,\n-                                         (lvalue, span): (&Lvalue, Span)) {\n-        let mut err = self.tcx.cannot_use_when_mutably_borrowed(\n-            span, &self.describe_lvalue(lvalue), Origin::Mir);\n-        // FIXME 1: add span_label for \"borrow of `()` occurs here\"\n-        // FIXME 2: add span_label for \"use of `{}` occurs here\"\n-        err.emit();\n-    }\n-\n-    fn report_conflicting_borrow(&mut self,\n-                                 _context: Context,\n-                                 (lvalue, span): (&Lvalue, Span),\n-                                 loan1: &BorrowData,\n-                                 loan2: &BorrowData) {\n-        // FIXME: obviously falsifiable. Generalize for non-eq lvalues later.\n-        assert_eq!(loan1.lvalue, loan2.lvalue);\n-\n-        // FIXME: supply non-\"\" `opt_via` when appropriate\n-        let mut err = match (loan1.kind, \"immutable\", \"mutable\",\n-                             loan2.kind, \"immutable\", \"mutable\") {\n-            (BorrowKind::Shared, lft, _, BorrowKind::Mut, _, rgt) |\n-            (BorrowKind::Mut, _, lft, BorrowKind::Shared, rgt, _) |\n-            (BorrowKind::Mut, _, lft, BorrowKind::Mut, _, rgt) =>\n-                self.tcx.cannot_reborrow_already_borrowed(\n-                    span, &self.describe_lvalue(lvalue),\n-                    \"\", lft, \"it\", rgt, \"\", Origin::Mir),\n-\n-            _ =>  self.tcx.cannot_mutably_borrow_multiply(\n-                span, &self.describe_lvalue(lvalue), \"\", Origin::Mir),\n-            // FIXME: add span labels for first and second mutable borrows, as well as\n-            // end point for first.\n-        };\n-        err.emit();\n-    }\n-\n-    fn report_illegal_mutation_of_borrowed(&mut self, _: Context, (lvalue, span): (&Lvalue, Span)) {\n-        let mut err = self.tcx.cannot_assign_to_borrowed(\n-            span, &self.describe_lvalue(lvalue), Origin::Mir);\n-        // FIXME: add span labels for borrow and assignment points\n-        err.emit();\n-    }\n-\n-    fn report_illegal_reassignment(&mut self, _context: Context, (lvalue, span): (&Lvalue, Span)) {\n-        let mut err = self.tcx.cannot_reassign_immutable(\n-            span, &self.describe_lvalue(lvalue), Origin::Mir);\n-        // FIXME: add span labels for borrow and assignment points\n-        err.emit();\n-    }\n-\n-    fn report_assignment_to_static(&mut self, _context: Context, (lvalue, span): (&Lvalue, Span)) {\n-        let mut err = self.tcx.cannot_assign_static(\n-            span, &self.describe_lvalue(lvalue), Origin::Mir);\n-        // FIXME: add span labels for borrow and assignment points\n-        err.emit();\n-    }\n-}\n-\n-impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n-    // End-user visible description of `lvalue`\n-    fn describe_lvalue(&self, lvalue: &Lvalue) -> String {\n-        let mut buf = String::new();\n-        self.append_lvalue_to_string(lvalue, &mut buf);\n-        buf\n-    }\n-\n-    // Appends end-user visible description of `lvalue` to `buf`.\n-    fn append_lvalue_to_string(&self, lvalue: &Lvalue, buf: &mut String) {\n-        match *lvalue {\n-            Lvalue::Local(local) => {\n-                let local = &self.mir.local_decls[local];\n-                match local.name {\n-                    Some(name) => buf.push_str(&format!(\"{}\", name)),\n-                    None => buf.push_str(\"_\"),\n-                }\n-            }\n-            Lvalue::Static(ref static_) => {\n-                buf.push_str(&format!(\"{}\", &self.tcx.item_name(static_.def_id)));\n-            }\n-            Lvalue::Projection(ref proj) => {\n-                let (prefix, suffix, index_operand) = match proj.elem {\n-                    ProjectionElem::Deref =>\n-                        (\"(*\", format!(\")\"), None),\n-                    ProjectionElem::Downcast(..) =>\n-                        (\"\",   format!(\"\"), None), // (dont emit downcast info)\n-                    ProjectionElem::Field(field, _ty) =>\n-                        (\"\",   format!(\".{}\", field.index()), None),\n-                    ProjectionElem::Index(ref index) =>\n-                        (\"\",   format!(\"\"), Some(index)),\n-                    ProjectionElem::ConstantIndex { offset, min_length, from_end: true } =>\n-                        (\"\",   format!(\"[{} of {}]\", offset, min_length), None),\n-                    ProjectionElem::ConstantIndex { offset, min_length, from_end: false } =>\n-                        (\"\",   format!(\"[-{} of {}]\", offset, min_length), None),\n-                    ProjectionElem::Subslice { from, to: 0 } =>\n-                        (\"\",   format!(\"[{}:]\", from), None),\n-                    ProjectionElem::Subslice { from: 0, to } =>\n-                        (\"\",   format!(\"[:-{}]\", to), None),\n-                    ProjectionElem::Subslice { from, to } =>\n-                        (\"\",   format!(\"[{}:-{}]\", from, to), None),\n-                };\n-                buf.push_str(prefix);\n-                self.append_lvalue_to_string(&proj.base, buf);\n-                if let Some(index) = index_operand {\n-                    buf.push_str(\"[\");\n-                    self.append_operand_to_string(index, buf);\n-                    buf.push_str(\"]\");\n-                } else {\n-                    buf.push_str(&suffix);\n-                }\n-\n-            }\n-        }\n-    }\n-\n-    fn append_operand_to_string(&self, operand: &Operand, buf: &mut String) {\n-        match *operand {\n-            Operand::Consume(ref lvalue) => {\n-                self.append_lvalue_to_string(lvalue, buf);\n-            }\n-            Operand::Constant(ref constant) => {\n-                buf.push_str(&format!(\"{:?}\", constant));\n-            }\n-        }\n-    }\n-}\n-\n-impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n-    // FIXME: needs to be able to express errors analogous to check_loans.rs\n-    fn conflicts_with(&self, loan1: &BorrowData<'gcx>, loan2: &BorrowData<'gcx>) -> bool {\n-        if loan1.compatible_with(loan2.kind) { return false; }\n-\n-        let loan2_base_path = self.base_path(&loan2.lvalue);\n-        for restricted in self.restrictions(&loan1.lvalue) {\n-            if restricted != loan2_base_path { continue; }\n-            return true;\n-        }\n-\n-        let loan1_base_path = self.base_path(&loan1.lvalue);\n-        for restricted in self.restrictions(&loan2.lvalue) {\n-            if restricted != loan1_base_path { continue; }\n-            return true;\n-        }\n-\n-        return false;\n-    }\n-\n-    // FIXME (#16118): function intended to allow the borrow checker\n-    // to be less precise in its handling of Box while still allowing\n-    // moves out of a Box. They should be removed when/if we stop\n-    // treating Box specially (e.g. when/if DerefMove is added...)\n-\n-    fn base_path<'d>(&self, lvalue: &'d Lvalue<'gcx>) -> &'d Lvalue<'gcx> {\n-        //! Returns the base of the leftmost (deepest) dereference of an\n-        //! Box in `lvalue`. If there is no dereference of an Box\n-        //! in `lvalue`, then it just returns `lvalue` itself.\n-\n-        let mut cursor = lvalue;\n-        let mut deepest = lvalue;\n-        loop {\n-            let proj = match *cursor {\n-                Lvalue::Local(..) | Lvalue::Static(..) => return deepest,\n-                Lvalue::Projection(ref proj) => proj,\n-            };\n-            if proj.elem == ProjectionElem::Deref &&\n-                lvalue.ty(self.mir, self.tcx).to_ty(self.tcx).is_box()\n-            {\n-                deepest = &proj.base;\n-            }\n-            cursor = &proj.base;\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-struct Context {\n-    kind: ContextKind,\n-    loc: Location,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum ContextKind {\n-    AssignLhs,\n-    AssignRhs,\n-    SetDiscrim,\n-    InlineAsm,\n-    SwitchInt,\n-    Drop,\n-    DropAndReplace,\n-    CallOperator,\n-    CallOperand,\n-    CallDest,\n-    Assert,\n-    StorageDead,\n-}\n-\n-impl ContextKind {\n-    fn new(self, loc: Location) -> Context { Context { kind: self, loc: loc } }\n-}\n-\n-impl<'b, 'tcx: 'b> InProgress<'b, 'tcx> {\n-    pub(super) fn new(borrows: DataflowResults<Borrows<'b, 'tcx>>,\n-                      inits: DataflowResults<MaybeInitializedLvals<'b, 'tcx>>,\n-                      uninits: DataflowResults<MaybeUninitializedLvals<'b, 'tcx>>)\n-                      -> Self {\n-        InProgress {\n-            borrows: FlowInProgress::new(borrows),\n-            inits: FlowInProgress::new(inits),\n-            uninits: FlowInProgress::new(uninits),\n-        }\n-    }\n-\n-    fn each_flow<XB, XI, XU>(&mut self,\n-                             mut xform_borrows: XB,\n-                             mut xform_inits: XI,\n-                             mut xform_uninits: XU) where\n-        XB: FnMut(&mut FlowInProgress<Borrows<'b, 'tcx>>),\n-        XI: FnMut(&mut FlowInProgress<MaybeInitializedLvals<'b, 'tcx>>),\n-        XU: FnMut(&mut FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>>),\n-    {\n-        xform_borrows(&mut self.borrows);\n-        xform_inits(&mut self.inits);\n-        xform_uninits(&mut self.uninits);\n-    }\n-\n-    fn summary(&self) -> String {\n-        let mut s = String::new();\n-\n-        s.push_str(\"borrows in effect: [\");\n-        let mut saw_one = false;\n-        self.borrows.each_state_bit(|borrow| {\n-            if saw_one { s.push_str(\", \"); };\n-            saw_one = true;\n-            let borrow_data = &self.borrows.base_results.operator().borrows()[borrow];\n-            s.push_str(&format!(\"{}\", borrow_data));\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"borrows generated: [\");\n-        let mut saw_one = false;\n-        self.borrows.each_gen_bit(|borrow| {\n-            if saw_one { s.push_str(\", \"); };\n-            saw_one = true;\n-            let borrow_data = &self.borrows.base_results.operator().borrows()[borrow];\n-            s.push_str(&format!(\"{}\", borrow_data));\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"inits: [\");\n-        let mut saw_one = false;\n-        self.inits.each_state_bit(|mpi_init| {\n-            if saw_one { s.push_str(\", \"); };\n-            saw_one = true;\n-            let move_path =\n-                &self.inits.base_results.operator().move_data().move_paths[mpi_init];\n-            s.push_str(&format!(\"{}\", move_path));\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"uninits: [\");\n-        let mut saw_one = false;\n-        self.uninits.each_state_bit(|mpi_uninit| {\n-            if saw_one { s.push_str(\", \"); };\n-            saw_one = true;\n-            let move_path =\n-                &self.uninits.base_results.operator().move_data().move_paths[mpi_uninit];\n-            s.push_str(&format!(\"{}\", move_path));\n-        });\n-        s.push_str(\"]\");\n-\n-        return s;\n-    }\n-}\n-\n-impl<BD> FlowInProgress<BD> where BD: BitDenotation {\n-    fn each_state_bit<F>(&self, f: F) where F: FnMut(BD::Idx) {\n-        self.curr_state.each_bit(self.base_results.operator().bits_per_block(), f)\n-    }\n-\n-    fn each_gen_bit<F>(&self, f: F) where F: FnMut(BD::Idx) {\n-        self.stmt_gen.each_bit(self.base_results.operator().bits_per_block(), f)\n-    }\n-\n-    fn new(results: DataflowResults<BD>) -> Self {\n-        let bits_per_block = results.sets().bits_per_block();\n-        let curr_state = IdxSetBuf::new_empty(bits_per_block);\n-        let stmt_gen = IdxSetBuf::new_empty(bits_per_block);\n-        let stmt_kill = IdxSetBuf::new_empty(bits_per_block);\n-        FlowInProgress {\n-            base_results: results,\n-            curr_state: curr_state,\n-            stmt_gen: stmt_gen,\n-            stmt_kill: stmt_kill,\n-        }\n-    }\n-\n-    fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n-        (*self.curr_state).clone_from(self.base_results.sets().on_entry_set_for(bb.index()));\n-    }\n-\n-    fn reconstruct_statement_effect(&mut self, loc: Location) {\n-        self.stmt_gen.reset_to_empty();\n-        self.stmt_kill.reset_to_empty();\n-        let mut ignored = IdxSetBuf::new_empty(0);\n-        let mut sets = BlockSets {\n-            on_entry: &mut ignored, gen_set: &mut self.stmt_gen, kill_set: &mut self.stmt_kill,\n-        };\n-        self.base_results.operator().statement_effect(&mut sets, loc);\n-    }\n-\n-    fn reconstruct_terminator_effect(&mut self, loc: Location) {\n-        self.stmt_gen.reset_to_empty();\n-        self.stmt_kill.reset_to_empty();\n-        let mut ignored = IdxSetBuf::new_empty(0);\n-        let mut sets = BlockSets {\n-            on_entry: &mut ignored, gen_set: &mut self.stmt_gen, kill_set: &mut self.stmt_kill,\n-        };\n-        self.base_results.operator().terminator_effect(&mut sets, loc);\n-    }\n-\n-    fn apply_local_effect(&mut self) {\n-        self.curr_state.union(&self.stmt_gen);\n-        self.curr_state.subtract(&self.stmt_kill);\n-    }\n-\n-    fn elems_generated(&self) -> indexed_set::Elems<BD::Idx> {\n-        let univ = self.base_results.sets().bits_per_block();\n-        self.stmt_gen.elems(univ)\n-    }\n-\n-    fn elems_incoming(&self) -> indexed_set::Elems<BD::Idx> {\n-        let univ = self.base_results.sets().bits_per_block();\n-        self.curr_state.elems(univ)\n-    }\n-}\n-\n-impl<'tcx> BorrowData<'tcx> {\n-    fn compatible_with(&self, bk: BorrowKind) -> bool {\n-        match (self.kind, bk) {\n-            (BorrowKind::Shared, BorrowKind::Shared) => true,\n-\n-            (BorrowKind::Mut, _) |\n-            (BorrowKind::Unique, _) |\n-            (_, BorrowKind::Mut) |\n-            (_, BorrowKind::Unique) => false,\n-        }\n-    }\n-}"}, {"sha": "d8dffa036621a7d466702d07e472ac4a36baeb09", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/224c6ca2ee31d717a412d6c1901fac04ab780edb/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/224c6ca2ee31d717a412d6c1901fac04ab780edb/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=224c6ca2ee31d717a412d6c1901fac04ab780edb", "patch": "@@ -31,7 +31,6 @@ pub mod simplify;\n pub mod erase_regions;\n pub mod no_landing_pads;\n pub mod type_check;\n-pub mod borrow_check;\n pub mod rustc_peek;\n pub mod elaborate_drops;\n pub mod add_call_guards;"}]}