{"sha": "886c6f3534e6f03916eeff2ea8b235e85dd04b42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NmM2ZjM1MzRlNmYwMzkxNmVlZmYyZWE4YjIzNWU4NWRkMDRiNDI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-21T19:53:49Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-21T19:53:49Z"}, "message": "rollup merge of #21258: aturon/stab-3-index\n\nConflicts:\n\tsrc/libcore/ops.rs\n\tsrc/librustc_typeck/astconv.rs\n\tsrc/libstd/io/mem.rs\n\tsrc/libsyntax/parse/lexer/mod.rs", "tree": {"sha": "616ec48db83b768a4be84225bed9b0c0f730072d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/616ec48db83b768a4be84225bed9b0c0f730072d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/886c6f3534e6f03916eeff2ea8b235e85dd04b42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/886c6f3534e6f03916eeff2ea8b235e85dd04b42", "html_url": "https://github.com/rust-lang/rust/commit/886c6f3534e6f03916eeff2ea8b235e85dd04b42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/886c6f3534e6f03916eeff2ea8b235e85dd04b42/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "036d8c41897099b5822eafa40e3f1fd2cdc4a92a", "url": "https://api.github.com/repos/rust-lang/rust/commits/036d8c41897099b5822eafa40e3f1fd2cdc4a92a", "html_url": "https://github.com/rust-lang/rust/commit/036d8c41897099b5822eafa40e3f1fd2cdc4a92a"}, {"sha": "537889aa78c984ee6484d16fec4a67f35778aec6", "url": "https://api.github.com/repos/rust-lang/rust/commits/537889aa78c984ee6484d16fec4a67f35778aec6", "html_url": "https://github.com/rust-lang/rust/commit/537889aa78c984ee6484d16fec4a67f35778aec6"}], "stats": {"total": 783, "additions": 353, "deletions": 430}, "files": [{"sha": "d7af767688e81e7ecc92dc001ed6bf14d4f6e6c9", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -332,8 +332,7 @@ pub fn parse_name_value_directive(line: &str, directive: &str)\n     let keycolon = format!(\"{}:\", directive);\n     match line.find_str(keycolon.as_slice()) {\n         Some(colon) => {\n-            let value = line.slice(colon + keycolon.len(),\n-                                   line.len()).to_string();\n+            let value = line[(colon + keycolon.len()) .. line.len()].to_string();\n             debug!(\"{}: {}\", directive, value);\n             Some(value)\n         }"}, {"sha": "f075cff769fbaa26b962212db355152fd51a6b1a", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -863,7 +863,7 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n                         break;\n                     }\n                     Some(i) => {\n-                        rest = rest.slice_from(i + frag.len());\n+                        rest = &rest[(i + frag.len())..];\n                     }\n                 }\n                 first = false;\n@@ -1046,7 +1046,7 @@ fn scan_until_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n-    let opt = haystack.slice_from(*idx).find(needle);\n+    let opt = haystack[(*idx)..].find(needle);\n     if opt.is_none() {\n         return false;\n     }"}, {"sha": "b92d38215c29b3ecdd66ba4b99566ad51612f8ed", "filename": "src/doc/intro.md", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -480,14 +480,12 @@ use std::sync::{Arc,Mutex};\n fn main() {\n     let numbers = Arc::new(Mutex::new(vec![1is, 2, 3]));\n \n-    for i in 0..3 {\n+    for i in 0us..3 {\n         let number = numbers.clone();\n         Thread::spawn(move || {\n             let mut array = number.lock().unwrap();\n-\n-            (*array)[i] += 1;\n-\n-            println!(\"numbers[{}] is {}\", i, (*array)[i]);\n+            array[i] += 1;\n+            println!(\"numbers[{}] is {}\", i, array[i]);\n         });\n     }\n }"}, {"sha": "4301149d1f8b3d62a26c07ba395f43976c5c3a5c", "filename": "src/doc/trpl/looping.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Fdoc%2Ftrpl%2Flooping.md", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Fdoc%2Ftrpl%2Flooping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flooping.md?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -123,7 +123,7 @@ We now loop forever with `loop` and use `break` to break out early.\n iteration. This will only print the odd numbers:\n \n ```{rust}\n-for x in 0..10 {\n+for x in 0u32..10 {\n     if x % 2 == 0 { continue; }\n \n     println!(\"{}\", x);"}, {"sha": "a801a1ab0e9217e1982f406aeabe5160b42662ef", "filename": "src/doc/trpl/threads.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Fdoc%2Ftrpl%2Fthreads.md", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Fdoc%2Ftrpl%2Fthreads.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fthreads.md?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -179,7 +179,7 @@ for init_val in 0 .. 3 {\n }\n \n let result = rx.recv().unwrap() + rx.recv().unwrap() + rx.recv().unwrap();\n-# fn some_expensive_computation(_i: u32) -> u32 { 42 }\n+# fn some_expensive_computation(_i: i32) -> i32 { 42 }\n ```\n \n Cloning a `Sender` produces a new handle to the same channel, allowing multiple\n@@ -207,7 +207,7 @@ let rxs = (0 .. 3).map(|&:init_val| {\n \n // Wait on each port, accumulating the results\n let result = rxs.iter().fold(0, |&:accum, rx| accum + rx.recv().unwrap() );\n-# fn some_expensive_computation(_i: u32) -> u32 { 42 }\n+# fn some_expensive_computation(_i: i32) -> i32 { 42 }\n ```\n \n ## Backgrounding computations: Futures"}, {"sha": "50857c78469cf1a24cf5e24c556b7b0d679209a4", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -21,7 +21,7 @@ use core::prelude::*;\n use core::borrow::BorrowFrom;\n use core::cmp::Ordering::{Greater, Less, Equal};\n use core::iter::Zip;\n-use core::ops::{Deref, DerefMut};\n+use core::ops::{Deref, DerefMut, Index, IndexMut};\n use core::ptr::Unique;\n use core::{slice, mem, ptr, cmp, num, raw};\n use alloc::heap;\n@@ -1487,7 +1487,7 @@ impl<K, V, E, Impl> AbsTraversal<Impl>\n \n macro_rules! node_slice_impl {\n     ($NodeSlice:ident, $Traversal:ident,\n-     $as_slices_internal:ident, $slice_from:ident, $slice_to:ident, $iter:ident) => {\n+     $as_slices_internal:ident, $index:ident, $iter:ident) => {\n         impl<'a, K: Ord + 'a, V: 'a> $NodeSlice<'a, K, V> {\n             /// Performs linear search in a slice. Returns a tuple of (index, is_exact_match).\n             fn search_linear<Q: ?Sized>(&self, key: &Q) -> (uint, bool)\n@@ -1521,10 +1521,10 @@ macro_rules! node_slice_impl {\n                     edges: if !self.has_edges {\n                         self.edges\n                     } else {\n-                        self.edges.$slice_from(pos)\n+                        self.edges.$index(&(pos ..))\n                     },\n-                    keys: self.keys.slice_from(pos),\n-                    vals: self.vals.$slice_from(pos),\n+                    keys: &self.keys[pos ..],\n+                    vals: self.vals.$index(&(pos ..)),\n                     head_is_edge: !pos_is_kv,\n                     tail_is_edge: self.tail_is_edge,\n                 }\n@@ -1550,10 +1550,10 @@ macro_rules! node_slice_impl {\n                     edges: if !self.has_edges {\n                         self.edges\n                     } else {\n-                        self.edges.$slice_to(pos + 1)\n+                        self.edges.$index(&(.. (pos + 1)))\n                     },\n-                    keys: self.keys.slice_to(pos),\n-                    vals: self.vals.$slice_to(pos),\n+                    keys: &self.keys[..pos],\n+                    vals: self.vals.$index(&(.. pos)),\n                     head_is_edge: self.head_is_edge,\n                     tail_is_edge: !pos_is_kv,\n                 }\n@@ -1583,6 +1583,5 @@ macro_rules! node_slice_impl {\n     }\n }\n \n-node_slice_impl!(NodeSlice, Traversal, as_slices_internal, slice_from, slice_to, iter);\n-node_slice_impl!(MutNodeSlice, MutTraversal, as_slices_internal_mut, slice_from_mut,\n-                                                                     slice_to_mut, iter_mut);\n+node_slice_impl!(NodeSlice, Traversal, as_slices_internal, index, iter);\n+node_slice_impl!(MutNodeSlice, MutTraversal, as_slices_internal_mut, index_mut, iter_mut);"}, {"sha": "338166c2f0b7488f2458ac75f094b886149e1f9f", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -578,7 +578,7 @@ impl<T> RingBuf<T> {\n \n             if contiguous {\n                 let (empty, buf) = buf.split_at_mut(0);\n-                (buf.slice_mut(tail, head), empty)\n+                (&mut buf[tail .. head], empty)\n             } else {\n                 let (mid, right) = buf.split_at_mut(tail);\n                 let (left, _) = mid.split_at_mut(head);"}, {"sha": "8c7f79d4d787ba4be5693f91932c14dd13781680", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 19, "deletions": 45, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -169,29 +169,16 @@ pub trait SliceExt {\n     #[unstable = \"uncertain about this API approach\"]\n     fn move_from(&mut self, src: Vec<Self::Item>, start: uint, end: uint) -> uint;\n \n-    /// Returns a subslice spanning the interval [`start`, `end`).\n-    ///\n-    /// Panics when the end of the new slice lies beyond the end of the\n-    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n-    ///\n-    /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    /// Deprecated: use `&s[start .. end]` notation instead.\n+    #[deprecated = \"use &s[start .. end] instead\"]\n     fn slice(&self, start: uint, end: uint) -> &[Self::Item];\n \n-    /// Returns a subslice from `start` to the end of the slice.\n-    ///\n-    /// Panics when `start` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    /// Deprecated: use `&s[start..]` notation instead.\n+    #[deprecated = \"use &s[start..] isntead\"]\n     fn slice_from(&self, start: uint) -> &[Self::Item];\n \n-    /// Returns a subslice from the start of the slice to `end`.\n-    ///\n-    /// Panics when `end` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    /// Deprecated: use `&s[..end]` notation instead.\n+    #[deprecated = \"use &s[..end] instead\"]\n     fn slice_to(&self, end: uint) -> &[Self::Item];\n \n     /// Divides one slice into two at an index.\n@@ -378,29 +365,16 @@ pub trait SliceExt {\n     #[stable]\n     fn as_mut_slice(&mut self) -> &mut [Self::Item];\n \n-    /// Returns a mutable subslice spanning the interval [`start`, `end`).\n-    ///\n-    /// Panics when the end of the new slice lies beyond the end of the\n-    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n-    ///\n-    /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    /// Deprecated: use `&mut s[start .. end]` instead.\n+    #[deprecated = \"use &mut s[start .. end] instead\"]\n     fn slice_mut(&mut self, start: uint, end: uint) -> &mut [Self::Item];\n \n-    /// Returns a mutable subslice from `start` to the end of the slice.\n-    ///\n-    /// Panics when `start` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    /// Deprecated: use `&mut s[start ..]` instead.\n+    #[deprecated = \"use &mut s[start ..] instead\"]\n     fn slice_from_mut(&mut self, start: uint) -> &mut [Self::Item];\n \n-    /// Returns a mutable subslice from the start of the slice to `end`.\n-    ///\n-    /// Panics when `end` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    /// Deprecated: use `&mut s[.. end]` instead.\n+    #[deprecated = \"use &mut s[.. end] instead\"]\n     fn slice_to_mut(&mut self, end: uint) -> &mut [Self::Item];\n \n     /// Returns an iterator that allows modifying each value\n@@ -712,25 +686,25 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn move_from(&mut self, mut src: Vec<T>, start: uint, end: uint) -> uint {\n-        for (a, b) in self.iter_mut().zip(src.slice_mut(start, end).iter_mut()) {\n+        for (a, b) in self.iter_mut().zip(src[start .. end].iter_mut()) {\n             mem::swap(a, b);\n         }\n         cmp::min(self.len(), end-start)\n     }\n \n     #[inline]\n     fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice(self, start, end)\n+        &self[start .. end]\n     }\n \n     #[inline]\n     fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice_from(self, start)\n+        &self[start ..]\n     }\n \n     #[inline]\n     fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice_to(self, end)\n+        &self[.. end]\n     }\n \n     #[inline]\n@@ -834,17 +808,17 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_mut(self, start, end)\n+        &mut self[start .. end]\n     }\n \n     #[inline]\n     fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_from_mut(self, start)\n+        &mut self[start ..]\n     }\n \n     #[inline]\n     fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_to_mut(self, end)\n+        &mut self[.. end]\n     }\n \n     #[inline]"}, {"sha": "6608d0ee9a7ec92ddab020fbbb3a17e6f2988dc7", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 22, "deletions": 60, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -750,67 +750,17 @@ pub trait StrExt: Index<FullRange, Output = str> {\n         core_str::StrExt::lines_any(&self[])\n     }\n \n-    /// Returns a slice of the given string from the byte range\n-    /// [`begin`..`end`).\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// Panics when `begin` and `end` do not point to valid characters\n-    /// or point beyond the last character of the string.\n-    ///\n-    /// See also `slice_to` and `slice_from` for slicing prefixes and\n-    /// suffixes of strings, and `slice_chars` for slicing based on\n-    /// code point counts.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert_eq!(s.slice(0, 1), \"L\");\n-    ///\n-    /// assert_eq!(s.slice(1, 9), \"\u00f6we \u8001\");\n-    ///\n-    /// // these will panic:\n-    /// // byte 2 lies within `\u00f6`:\n-    /// // s.slice(2, 3);\n-    ///\n-    /// // byte 8 lies within `\u8001`\n-    /// // s.slice(1, 8);\n-    ///\n-    /// // byte 100 is outside the string\n-    /// // s.slice(3, 100);\n-    /// ```\n-    #[unstable = \"use slice notation [a..b] instead\"]\n-    fn slice(&self, begin: uint, end: uint) -> &str {\n-        core_str::StrExt::slice(&self[], begin, end)\n-    }\n+    /// Deprecated: use `s[a .. b]` instead.\n+    #[deprecated = \"use slice notation [a..b] instead\"]\n+    fn slice(&self, begin: uint, end: uint) -> &str;\n \n-    /// Returns a slice of the string from `begin` to its end.\n-    ///\n-    /// Equivalent to `self.slice(begin, self.len())`.\n-    ///\n-    /// Panics when `begin` does not point to a valid character, or is\n-    /// out of bounds.\n-    ///\n-    /// See also `slice`, `slice_to` and `slice_chars`.\n-    #[unstable = \"use slice notation [a..] instead\"]\n-    fn slice_from(&self, begin: uint) -> &str {\n-        core_str::StrExt::slice_from(&self[], begin)\n-    }\n+    /// Deprecated: use `s[a..]` instead.\n+    #[deprecated = \"use slice notation [a..] instead\"]\n+    fn slice_from(&self, begin: uint) -> &str;\n \n-    /// Returns a slice of the string from the beginning to byte\n-    /// `end`.\n-    ///\n-    /// Equivalent to `self.slice(0, end)`.\n-    ///\n-    /// Panics when `end` does not point to a valid character, or is\n-    /// out of bounds.\n-    ///\n-    /// See also `slice`, `slice_from` and `slice_chars`.\n-    #[unstable = \"use slice notation [..a] instead\"]\n-    fn slice_to(&self, end: uint) -> &str {\n-        core_str::StrExt::slice_to(&self[], end)\n-    }\n+    /// Deprecated: use `s[..a]` instead.\n+    #[deprecated = \"use slice notation [..a] instead\"]\n+    fn slice_to(&self, end: uint) -> &str;\n \n     /// Returns a slice of the string from the character range\n     /// [`begin`..`end`).\n@@ -1348,7 +1298,19 @@ pub trait StrExt: Index<FullRange, Output = str> {\n }\n \n #[stable]\n-impl StrExt for str {}\n+impl StrExt for str {\n+    fn slice(&self, begin: uint, end: uint) -> &str {\n+        &self[begin..end]\n+    }\n+\n+    fn slice_from(&self, begin: uint) -> &str {\n+        &self[begin..]\n+    }\n+\n+    fn slice_to(&self, end: uint) -> &str {\n+        &self[..end]\n+    }\n+}\n \n #[cfg(test)]\n mod tests {"}, {"sha": "c965aedbc5d2f3267e23ab4fe94af0ad68aeb69a", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -849,27 +849,31 @@ impl<'a> Add<&'a str> for String {\n     }\n }\n \n+#[stable]\n impl ops::Index<ops::Range<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &str {\n         &self[][*index]\n     }\n }\n+#[stable]\n impl ops::Index<ops::RangeTo<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n         &self[][*index]\n     }\n }\n+#[stable]\n impl ops::Index<ops::RangeFrom<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n         &self[][*index]\n     }\n }\n+#[stable]\n impl ops::Index<ops::FullRange> for String {\n     type Output = str;\n     #[inline]"}, {"sha": "52590297a6afa6db04f711f104e7fc1224f78349", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -1229,7 +1229,7 @@ impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for Vec<T> {\n     }\n }\n \n-#[unstable = \"waiting on Index stability\"]\n+#[stable]\n impl<T> Index<uint> for Vec<T> {\n     type Output = T;\n \n@@ -1239,6 +1239,7 @@ impl<T> Index<uint> for Vec<T> {\n     }\n }\n \n+#[stable]\n impl<T> IndexMut<uint> for Vec<T> {\n     type Output = T;\n \n@@ -1249,27 +1250,31 @@ impl<T> IndexMut<uint> for Vec<T> {\n }\n \n \n+#[stable]\n impl<T> ops::Index<ops::Range<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n+#[stable]\n impl<T> ops::Index<ops::RangeTo<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n+#[stable]\n impl<T> ops::Index<ops::RangeFrom<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n+#[stable]\n impl<T> ops::Index<ops::FullRange> for Vec<T> {\n     type Output = [T];\n     #[inline]\n@@ -1278,27 +1283,31 @@ impl<T> ops::Index<ops::FullRange> for Vec<T> {\n     }\n }\n \n+#[stable]\n impl<T> ops::IndexMut<ops::Range<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n+#[stable]\n impl<T> ops::IndexMut<ops::RangeTo<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n+#[stable]\n impl<T> ops::IndexMut<ops::RangeFrom<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n+#[stable]\n impl<T> ops::IndexMut<ops::FullRange> for Vec<T> {\n     type Output = [T];\n     #[inline]\n@@ -1307,7 +1316,6 @@ impl<T> ops::IndexMut<ops::FullRange> for Vec<T> {\n     }\n }\n \n-\n #[stable]\n impl<T> ops::Deref for Vec<T> {\n     type Target = [T];"}, {"sha": "245dc00d838244cf7746107a3e7773eef1aa2cfc", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -179,7 +179,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n         _ => ()\n     }\n \n-    buf.slice_to_mut(end).reverse();\n+    buf[..end].reverse();\n \n     // Remember start of the fractional digits.\n     // Points one beyond end of buf if none get generated,\n@@ -316,7 +316,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n \n             impl<'a> fmt::Writer for Filler<'a> {\n                 fn write_str(&mut self, s: &str) -> fmt::Result {\n-                    slice::bytes::copy_memory(self.buf.slice_from_mut(*self.end),\n+                    slice::bytes::copy_memory(&mut self.buf[(*self.end)..],\n                                               s.as_bytes());\n                     *self.end += s.len();\n                     Ok(())"}, {"sha": "773ac99b0dee2ff803f85430105c4a1c20596218", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 67, "deletions": 37, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -2715,63 +2715,93 @@ impl<A: Int> Iterator for RangeStepInclusive<A> {\n     }\n }\n \n-\n-/// The `Step` trait identifies objects which can be stepped over in both\n-/// directions. The `steps_between` function provides a way to\n-/// compare two Step objects (it could be provided using `step()` and `Ord`,\n-/// but the implementation would be so inefficient as to be useless).\n-#[unstable = \"design of range notation/iteration is in flux\"]\n-pub trait Step: Ord {\n-    /// Change self to the next object.\n-    fn step(&mut self);\n-    /// Change self to the previous object.\n-    fn step_back(&mut self);\n-    /// The steps_between two step objects.\n-    /// start should always be less than end, so the result should never be negative.\n-    /// Return None if it is not possible to calculate steps_between without\n-    /// overflow.\n-    fn steps_between(start: &Self, end: &Self) -> Option<uint>;\n-}\n-\n-macro_rules! step_impl {\n+macro_rules! range_impl {\n     ($($t:ty)*) => ($(\n-        #[unstable = \"Trait is unstable.\"]\n-        impl Step for $t {\n-            #[inline]\n-            fn step(&mut self) { *self += 1; }\n+        #[stable]\n+        impl Iterator for ::ops::Range<$t> {\n+            type Item = $t;\n+\n             #[inline]\n-            fn step_back(&mut self) { *self -= 1; }\n+            fn next(&mut self) -> Option<$t> {\n+                if self.start < self.end {\n+                    let result = self.start;\n+                    self.start += 1;\n+                    return Some(result);\n+                }\n+\n+                return None;\n+            }\n+\n             #[inline]\n-            fn steps_between(start: &$t, end: &$t) -> Option<uint> {\n-                debug_assert!(end >= start);\n-                Some((*end - *start) as uint)\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                debug_assert!(self.end >= self.start);\n+                let hint = (self.end - self.start) as uint;\n+                (hint, Some(hint))\n             }\n         }\n+\n+        #[stable]\n+        impl ExactSizeIterator for ::ops::Range<$t> {}\n     )*)\n }\n \n-macro_rules! step_impl_no_between {\n+macro_rules! range_impl_no_hint {\n     ($($t:ty)*) => ($(\n-        #[unstable = \"Trait is unstable.\"]\n-        impl Step for $t {\n+        #[stable]\n+        impl Iterator for ::ops::Range<$t> {\n+            type Item = $t;\n+\n             #[inline]\n-            fn step(&mut self) { *self += 1; }\n+            fn next(&mut self) -> Option<$t> {\n+                if self.start < self.end {\n+                    let result = self.start;\n+                    self.start += 1;\n+                    return Some(result);\n+                }\n+\n+                return None;\n+            }\n+        }\n+    )*)\n+}\n+\n+macro_rules! range_other_impls {\n+    ($($t:ty)*) => ($(\n+        #[stable]\n+        impl DoubleEndedIterator for ::ops::Range<$t> {\n             #[inline]\n-            fn step_back(&mut self) { *self -= 1; }\n+            fn next_back(&mut self) -> Option<$t> {\n+                if self.start < self.end {\n+                    self.end -= 1;\n+                    return Some(self.end);\n+                }\n+\n+                return None;\n+            }\n+        }\n+\n+        #[stable]\n+        impl Iterator for ::ops::RangeFrom<$t> {\n+            type Item = $t;\n+\n             #[inline]\n-            fn steps_between(_start: &$t, _end: &$t) -> Option<uint> {\n-                None\n+            fn next(&mut self) -> Option<$t> {\n+                let result = self.start;\n+                self.start += 1;\n+                debug_assert!(result < self.start);\n+                return Some(result);\n             }\n         }\n     )*)\n }\n \n-step_impl!(uint u8 u16 u32 int i8 i16 i32);\n+range_impl!(uint u8 u16 u32 int i8 i16 i32);\n #[cfg(target_pointer_width = \"64\")]\n-step_impl!(u64 i64);\n+range_impl!(u64 i64);\n #[cfg(target_pointer_width = \"32\")]\n-step_impl_no_between!(u64 i64);\n+range_impl_no_hint!(u64 i64);\n \n+range_other_impls!(uint u8 u16 u32 u64 int i8 i16 i32 i64);\n \n /// An iterator that repeats an element endlessly\n #[derive(Clone)]"}, {"sha": "372596cdd44ecfb3c30c5be0e7ec974f00c80c39", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 8, "deletions": 59, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -67,10 +67,7 @@\n \n #![stable]\n \n-use clone::Clone;\n-use iter::{Step, Iterator,DoubleEndedIterator,ExactSizeIterator};\n use marker::Sized;\n-use option::Option::{self, Some, None};\n use fmt;\n \n /// The `Drop` trait is used to run some code when a value goes out of scope. This\n@@ -898,10 +895,12 @@ shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n /// }\n /// ```\n #[lang=\"index\"]\n+#[stable]\n pub trait Index<Index: ?Sized> {\n     type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n+    #[stable]\n     fn index<'a>(&'a self, index: &Index) -> &'a Self::Output;\n }\n \n@@ -934,17 +933,19 @@ pub trait Index<Index: ?Sized> {\n /// }\n /// ```\n #[lang=\"index_mut\"]\n+#[stable]\n pub trait IndexMut<Index: ?Sized> {\n     type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n+    #[stable]\n     fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Self::Output;\n }\n \n /// An unbounded range.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"full_range\"]\n-#[unstable = \"API still in development\"]\n+#[unstable = \"may be renamed to RangeFull\"]\n pub struct FullRange;\n \n #[stable]\n@@ -957,55 +958,14 @@ impl fmt::Debug for FullRange {\n /// A (half-open) range which is bounded at both ends.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range\"]\n-#[unstable = \"API still in development\"]\n+#[stable]\n pub struct Range<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n     /// The upper bound of the range (exclusive).\n     pub end: Idx,\n }\n \n-#[unstable = \"API still in development\"]\n-impl<Idx: Clone + Step> Iterator for Range<Idx> {\n-    type Item = Idx;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<Idx> {\n-        if self.start < self.end {\n-            let result = self.start.clone();\n-            self.start.step();\n-            return Some(result);\n-        }\n-\n-        return None;\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if let Some(hint) = Step::steps_between(&self.start, &self.end) {\n-            (hint, Some(hint))\n-        } else {\n-            (0, None)\n-        }\n-    }\n-}\n-\n-#[unstable = \"API still in development\"]\n-impl<Idx: Clone + Step> DoubleEndedIterator for Range<Idx> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<Idx> {\n-        if self.start < self.end {\n-            self.end.step_back();\n-            return Some(self.end.clone());\n-        }\n-\n-        return None;\n-    }\n-}\n-\n-#[unstable = \"API still in development\"]\n-impl<Idx: Clone + Step> ExactSizeIterator for Range<Idx> {}\n-\n #[stable]\n impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n@@ -1016,24 +976,13 @@ impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n /// A range which is only bounded below.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range_from\"]\n-#[unstable = \"API still in development\"]\n+#[stable]\n pub struct RangeFrom<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n }\n \n-#[unstable = \"API still in development\"]\n-impl<Idx: Clone + Step> Iterator for RangeFrom<Idx> {\n-    type Item = Idx;\n \n-    #[inline]\n-    fn next(&mut self) -> Option<Idx> {\n-        // Deliberately overflow so we loop forever.\n-        let result = self.start.clone();\n-        self.start.step();\n-        return Some(result);\n-    }\n-}\n \n #[stable]\n impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n@@ -1045,7 +994,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n /// A range which is only bounded above.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range_to\"]\n-#[unstable = \"API still in development\"]\n+#[stable]\n pub struct RangeTo<Idx> {\n     /// The upper bound of the range (exclusive).\n     pub end: Idx,"}, {"sha": "ec43a35248e2e69c882ff4f54629394545d66584", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 18, "deletions": 50, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -67,9 +67,6 @@ use raw::Slice as RawSlice;\n pub trait SliceExt {\n     type Item;\n \n-    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [Self::Item];\n-    fn slice_from<'a>(&'a self, start: uint) -> &'a [Self::Item];\n-    fn slice_to<'a>(&'a self, end: uint) -> &'a [Self::Item];\n     fn split_at<'a>(&'a self, mid: uint) -> (&'a [Self::Item], &'a [Self::Item]);\n     fn iter<'a>(&'a self) -> Iter<'a, Self::Item>;\n     fn split<'a, P>(&'a self, pred: P) -> Split<'a, Self::Item, P>\n@@ -93,9 +90,6 @@ pub trait SliceExt {\n     fn is_empty(&self) -> bool { self.len() == 0 }\n     fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut Self::Item>;\n     fn as_mut_slice<'a>(&'a mut self) -> &'a mut [Self::Item];\n-    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [Self::Item];\n-    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [Self::Item];\n-    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [Self::Item];\n     fn iter_mut<'a>(&'a mut self) -> IterMut<'a, Self::Item>;\n     fn first_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n     fn tail_mut<'a>(&'a mut self) -> &'a mut [Self::Item];\n@@ -135,28 +129,6 @@ pub trait SliceExt {\n impl<T> SliceExt for [T] {\n     type Item = T;\n \n-    #[inline]\n-    fn slice(&self, start: uint, end: uint) -> &[T] {\n-        assert!(start <= end);\n-        assert!(end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                data: self.as_ptr().offset(start as int),\n-                len: (end - start)\n-            })\n-        }\n-    }\n-\n-    #[inline]\n-    fn slice_from(&self, start: uint) -> &[T] {\n-        self.slice(start, self.len())\n-    }\n-\n-    #[inline]\n-    fn slice_to(&self, end: uint) -> &[T] {\n-        self.slice(0, end)\n-    }\n-\n     #[inline]\n     fn split_at(&self, mid: uint) -> (&[T], &[T]) {\n         (&self[..mid], &self[mid..])\n@@ -291,20 +263,6 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn as_mut_slice(&mut self) -> &mut [T] { self }\n \n-    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T] {\n-        ops::IndexMut::index_mut(self, &ops::Range { start: start, end: end } )\n-    }\n-\n-    #[inline]\n-    fn slice_from_mut(&mut self, start: uint) -> &mut [T] {\n-        ops::IndexMut::index_mut(self, &ops::RangeFrom { start: start } )\n-    }\n-\n-    #[inline]\n-    fn slice_to_mut(&mut self, end: uint) -> &mut [T] {\n-        ops::IndexMut::index_mut(self, &ops::RangeTo { end: end } )\n-    }\n-\n     #[inline]\n     fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]) {\n         unsafe {\n@@ -345,13 +303,13 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn tail_mut(&mut self) -> &mut [T] {\n-        self.slice_from_mut(1)\n+        &mut self[1 ..]\n     }\n \n     #[inline]\n     fn init_mut(&mut self) -> &mut [T] {\n         let len = self.len();\n-        self.slice_to_mut(len-1)\n+        &mut self[.. (len - 1)]\n     }\n \n     #[inline]\n@@ -483,7 +441,7 @@ impl<T> SliceExt for [T] {\n         self.swap(j, i-1);\n \n         // Step 4: Reverse the (previously) weakly decreasing part\n-        self.slice_from_mut(i).reverse();\n+        self[i..].reverse();\n \n         true\n     }\n@@ -505,7 +463,7 @@ impl<T> SliceExt for [T] {\n         }\n \n         // Step 2: Reverse the weakly increasing part\n-        self.slice_from_mut(i).reverse();\n+        self[i..].reverse();\n \n         // Step 3: Find the rightmost element equal to or bigger than the pivot (i-1)\n         let mut j = self.len() - 1;\n@@ -522,15 +480,16 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn clone_from_slice(&mut self, src: &[T]) -> uint where T: Clone {\n         let min = cmp::min(self.len(), src.len());\n-        let dst = self.slice_to_mut(min);\n-        let src = src.slice_to(min);\n+        let dst = &mut self[.. min];\n+        let src = &src[.. min];\n         for i in range(0, min) {\n             dst[i].clone_from(&src[i]);\n         }\n         min\n     }\n }\n \n+#[stable]\n impl<T> ops::Index<uint> for [T] {\n     type Output = T;\n \n@@ -541,6 +500,7 @@ impl<T> ops::Index<uint> for [T] {\n     }\n }\n \n+#[stable]\n impl<T> ops::IndexMut<uint> for [T] {\n     type Output = T;\n \n@@ -551,6 +511,7 @@ impl<T> ops::IndexMut<uint> for [T] {\n     }\n }\n \n+#[stable]\n impl<T> ops::Index<ops::Range<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -565,20 +526,23 @@ impl<T> ops::Index<ops::Range<uint>> for [T] {\n         }\n     }\n }\n+#[stable]\n impl<T> ops::Index<ops::RangeTo<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.index(&ops::Range{ start: 0, end: index.end })\n     }\n }\n+#[stable]\n impl<T> ops::Index<ops::RangeFrom<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.index(&ops::Range{ start: index.start, end: self.len() })\n     }\n }\n+#[stable]\n impl<T> ops::Index<ops::FullRange> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -587,6 +551,7 @@ impl<T> ops::Index<ops::FullRange> for [T] {\n     }\n }\n \n+#[stable]\n impl<T> ops::IndexMut<ops::Range<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -601,13 +566,15 @@ impl<T> ops::IndexMut<ops::Range<uint>> for [T] {\n         }\n     }\n }\n+#[stable]\n impl<T> ops::IndexMut<ops::RangeTo<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.index_mut(&ops::Range{ start: 0, end: index.end })\n     }\n }\n+#[stable]\n impl<T> ops::IndexMut<ops::RangeFrom<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -616,6 +583,7 @@ impl<T> ops::IndexMut<ops::RangeFrom<uint>> for [T] {\n         self.index_mut(&ops::Range{ start: index.start, end: len })\n     }\n }\n+#[stable]\n impl<T> ops::IndexMut<ops::FullRange> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -1051,7 +1019,7 @@ impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n             Some(idx) => {\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n-                self.v = tail.slice_from_mut(1);\n+                self.v = &mut tail[1..];\n                 Some(head)\n             }\n         }\n@@ -1087,7 +1055,7 @@ impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n                 self.v = head;\n-                Some(tail.slice_from_mut(1))\n+                Some(&mut tail[1..])\n             }\n         }\n     }"}, {"sha": "bdac686cb66bd3edfa34607a3c671d4e3ac1d821", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 69, "deletions": 41, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -928,13 +928,13 @@ impl<'a> Iterator for SplitStr<'a> {\n \n         match self.it.next() {\n             Some((from, to)) => {\n-                let ret = Some(self.it.haystack.slice(self.last_end, from));\n+                let ret = Some(&self.it.haystack[self.last_end .. from]);\n                 self.last_end = to;\n                 ret\n             }\n             None => {\n                 self.finished = true;\n-                Some(self.it.haystack.slice(self.last_end, self.it.haystack.len()))\n+                Some(&self.it.haystack[self.last_end .. self.it.haystack.len()])\n             }\n         }\n     }\n@@ -1141,27 +1141,90 @@ mod traits {\n         }\n     }\n \n+    /// Returns a slice of the given string from the byte range\n+    /// [`begin`..`end`).\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// Panics when `begin` and `end` do not point to valid characters\n+    /// or point beyond the last character of the string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert_eq!(&s[0 .. 1], \"L\");\n+    ///\n+    /// assert_eq!(&s[1 .. 9], \"\u00f6we \u8001\");\n+    ///\n+    /// // these will panic:\n+    /// // byte 2 lies within `\u00f6`:\n+    /// // &s[2 ..3];\n+    ///\n+    /// // byte 8 lies within `\u8001`\n+    /// // &s[1 .. 8];\n+    ///\n+    /// // byte 100 is outside the string\n+    /// // &s[3 .. 100];\n+    /// ```\n+    #[stable]\n     impl ops::Index<ops::Range<uint>> for str {\n         type Output = str;\n         #[inline]\n         fn index(&self, index: &ops::Range<uint>) -> &str {\n-            self.slice(index.start, index.end)\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if index.start <= index.end &&\n+               self.is_char_boundary(index.start) &&\n+               self.is_char_boundary(index.end) {\n+                unsafe { self.slice_unchecked(index.start, index.end) }\n+            } else {\n+                super::slice_error_fail(self, index.start, index.end)\n+            }\n         }\n     }\n+\n+    /// Returns a slice of the string from the beginning to byte\n+    /// `end`.\n+    ///\n+    /// Equivalent to `self[0 .. end]`.\n+    ///\n+    /// Panics when `end` does not point to a valid character, or is\n+    /// out of bounds.\n+    #[stable]\n     impl ops::Index<ops::RangeTo<uint>> for str {\n         type Output = str;\n         #[inline]\n         fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n-            self.slice_to(index.end)\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if self.is_char_boundary(index.end) {\n+                unsafe { self.slice_unchecked(0, index.end) }\n+            } else {\n+                super::slice_error_fail(self, 0, index.end)\n+            }\n         }\n     }\n+\n+    /// Returns a slice of the string from `begin` to its end.\n+    ///\n+    /// Equivalent to `self[begin .. self.len()]`.\n+    ///\n+    /// Panics when `begin` does not point to a valid character, or is\n+    /// out of bounds.\n+    #[stable]\n     impl ops::Index<ops::RangeFrom<uint>> for str {\n         type Output = str;\n         #[inline]\n         fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n-            self.slice_from(index.start)\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if self.is_char_boundary(index.start) {\n+                unsafe { self.slice_unchecked(index.start, self.len()) }\n+            } else {\n+                super::slice_error_fail(self, index.start, self.len())\n+            }\n         }\n     }\n+\n+    #[stable]\n     impl ops::Index<ops::FullRange> for str {\n         type Output = str;\n         #[inline]\n@@ -1234,9 +1297,6 @@ pub trait StrExt {\n     fn lines<'a>(&'a self) -> Lines<'a>;\n     fn lines_any<'a>(&'a self) -> LinesAny<'a>;\n     fn char_len(&self) -> uint;\n-    fn slice<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n-    fn slice_from<'a>(&'a self, begin: uint) -> &'a str;\n-    fn slice_to<'a>(&'a self, end: uint) -> &'a str;\n     fn slice_chars<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n     unsafe fn slice_unchecked<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n     fn starts_with(&self, pat: &str) -> bool;\n@@ -1358,7 +1418,7 @@ impl StrExt for str {\n     fn lines_any(&self) -> LinesAny {\n         fn f(line: &str) -> &str {\n             let l = line.len();\n-            if l > 0 && line.as_bytes()[l - 1] == b'\\r' { line.slice(0, l - 1) }\n+            if l > 0 && line.as_bytes()[l - 1] == b'\\r' { &line[0 .. l - 1] }\n             else { line }\n         }\n \n@@ -1369,38 +1429,6 @@ impl StrExt for str {\n     #[inline]\n     fn char_len(&self) -> uint { self.chars().count() }\n \n-    #[inline]\n-    fn slice(&self, begin: uint, end: uint) -> &str {\n-        // is_char_boundary checks that the index is in [0, .len()]\n-        if begin <= end &&\n-           self.is_char_boundary(begin) &&\n-           self.is_char_boundary(end) {\n-            unsafe { self.slice_unchecked(begin, end) }\n-        } else {\n-            slice_error_fail(self, begin, end)\n-        }\n-    }\n-\n-    #[inline]\n-    fn slice_from(&self, begin: uint) -> &str {\n-        // is_char_boundary checks that the index is in [0, .len()]\n-        if self.is_char_boundary(begin) {\n-            unsafe { self.slice_unchecked(begin, self.len()) }\n-        } else {\n-            slice_error_fail(self, begin, self.len())\n-        }\n-    }\n-\n-    #[inline]\n-    fn slice_to(&self, end: uint) -> &str {\n-        // is_char_boundary checks that the index is in [0, .len()]\n-        if self.is_char_boundary(end) {\n-            unsafe { self.slice_unchecked(0, end) }\n-        } else {\n-            slice_error_fail(self, 0, end)\n-        }\n-    }\n-\n     fn slice_chars(&self, begin: uint, end: uint) -> &str {\n         assert!(begin <= end);\n         let mut count = 0;"}, {"sha": "3332e06e19e74e25220a5087537ed5100f92085b", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -174,7 +174,7 @@ impl<'a> SeedableRng<&'a [u32]> for ChaChaRng {\n         // reset state\n         self.init(&[0u32; KEY_WORDS]);\n         // set key in place\n-        let key = self.state.slice_mut(4, 4+KEY_WORDS);\n+        let key = &mut self.state[4 .. 4+KEY_WORDS];\n         for (k, s) in key.iter_mut().zip(seed.iter()) {\n             *k = *s;\n         }\n@@ -292,4 +292,3 @@ mod test {\n         }\n     }\n }\n-"}, {"sha": "9c746c69baafcf1f72eafc6df0b5eca5c3a24636", "filename": "src/librbml/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -103,7 +103,7 @@ impl Writer for SeekableMemWriter {\n \n             // Do the necessary writes\n             if left.len() > 0 {\n-                slice::bytes::copy_memory(self.buf.slice_from_mut(self.pos), left);\n+                slice::bytes::copy_memory(&mut self.buf[self.pos..], left);\n             }\n             if right.len() > 0 {\n                 self.buf.push_all(right);"}, {"sha": "1b68ad500caa57820d936bfcd33831bb60faef03", "filename": "src/libregex/re.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -459,7 +459,7 @@ impl<'t> Captures<'t> {\n     pub fn at(&self, i: uint) -> Option<&'t str> {\n         match self.pos(i) {\n             None => None,\n-            Some((s, e)) => Some(self.text.slice(s, e))\n+            Some((s, e)) => Some(&self.text[s.. e])\n         }\n     }\n "}, {"sha": "7b7159da4385df37d9536543846695990caaf599", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -242,7 +242,7 @@ impl MetadataBlob {\n                        ((slice[2] as u32) << 8) |\n                        ((slice[3] as u32) << 0)) as uint;\n             if len + 4 <= slice.len() {\n-                slice.slice(4, len + 4)\n+                &slice[4.. len + 4]\n             } else {\n                 &[] // corrupt or old metadata\n             }"}, {"sha": "b1043a4152cfc74d1867f49a9313756f49a32483", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -392,11 +392,11 @@ impl<'a> Context<'a> {\n             };\n             let (hash, rlib) = if file.starts_with(&rlib_prefix[]) &&\n                     file.ends_with(\".rlib\") {\n-                (file.slice(rlib_prefix.len(), file.len() - \".rlib\".len()),\n+                (&file[(rlib_prefix.len()) .. (file.len() - \".rlib\".len())],\n                  true)\n             } else if file.starts_with(dylib_prefix.as_slice()) &&\n                       file.ends_with(dypair.1.as_slice()) {\n-                (file.slice(dylib_prefix.len(), file.len() - dypair.1.len()),\n+                (&file[(dylib_prefix.len()) .. (file.len() - dypair.1.len())],\n                  false)\n             } else {\n                 return FileDoesntMatch"}, {"sha": "1a2162b3076ece7a2a85affafe7f025635796369", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -424,7 +424,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             ast::ExprMethodCall(_, _, ref args) => {\n-                self.call(expr, pred, &*args[0], args.slice_from(1).iter().map(|e| &**e))\n+                self.call(expr, pred, &*args[0], args[1..].iter().map(|e| &**e))\n             }\n \n             ast::ExprIndex(ref l, ref r) |"}, {"sha": "a17278698103167229069e82b10248c4ff08b49f", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -118,17 +118,17 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n             assert!(self.bits_per_id > 0);\n             let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n             let (start, end) = self.compute_id_range(cfgidx);\n-            let on_entry = self.on_entry.slice(start, end);\n+            let on_entry = &self.on_entry[start.. end];\n             let entry_str = bits_to_string(on_entry);\n \n-            let gens = self.gens.slice(start, end);\n+            let gens = &self.gens[start.. end];\n             let gens_str = if gens.iter().any(|&u| u != 0) {\n                 format!(\" gen: {}\", bits_to_string(gens))\n             } else {\n                 \"\".to_string()\n             };\n \n-            let kills = self.kills.slice(start, end);\n+            let kills = &self.kills[start .. end];\n             let kills_str = if kills.iter().any(|&u| u != 0) {\n                 format!(\" kill: {}\", bits_to_string(kills))\n             } else {\n@@ -232,7 +232,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n         let (start, end) = self.compute_id_range(cfgidx);\n-        let gens = self.gens.slice_mut(start, end);\n+        let gens = &mut self.gens[start.. end];\n         set_bit(gens, bit);\n     }\n \n@@ -245,7 +245,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n         let (start, end) = self.compute_id_range(cfgidx);\n-        let kills = self.kills.slice_mut(start, end);\n+        let kills = &mut self.kills[start.. end];\n         set_bit(kills, bit);\n     }\n \n@@ -256,9 +256,9 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         assert!(self.bits_per_id > 0);\n \n         let (start, end) = self.compute_id_range(cfgidx);\n-        let gens = self.gens.slice(start, end);\n+        let gens = &self.gens[start.. end];\n         bitwise(bits, gens, &Union);\n-        let kills = self.kills.slice(start, end);\n+        let kills = &self.kills[start.. end];\n         bitwise(bits, kills, &Subtract);\n \n         debug!(\"{} apply_gen_kill(cfgidx={:?}, bits={}) [after]\",\n@@ -304,7 +304,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         }\n \n         let (start, end) = self.compute_id_range(cfgidx);\n-        let on_entry = self.on_entry.slice(start, end);\n+        let on_entry = &self.on_entry[start.. end];\n         let temp_bits;\n         let slice = match e {\n             Entry => on_entry,\n@@ -336,7 +336,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n         let (start, end) = self.compute_id_range(cfgidx);\n-        let gens = self.gens.slice(start, end);\n+        let gens = &self.gens[start.. end];\n         debug!(\"{} each_gen_bit(id={}, gens={})\",\n                self.analysis_name, id, bits_to_string(gens));\n         self.each_bit(gens, f)\n@@ -396,15 +396,15 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         cfg.graph.each_edge(|_edge_index, edge| {\n             let flow_exit = edge.source();\n             let (start, end) = self.compute_id_range(flow_exit);\n-            let mut orig_kills = self.kills.slice(start, end).to_vec();\n+            let mut orig_kills = self.kills[start.. end].to_vec();\n \n             let mut changed = false;\n             for &node_id in edge.data.exiting_scopes.iter() {\n                 let opt_cfg_idx = self.nodeid_to_index.get(&node_id).map(|&i|i);\n                 match opt_cfg_idx {\n                     Some(cfg_idx) => {\n                         let (start, end) = self.compute_id_range(cfg_idx);\n-                        let kills = self.kills.slice(start, end);\n+                        let kills = &self.kills[start.. end];\n                         if bitwise(orig_kills.as_mut_slice(), kills, &Union) {\n                             changed = true;\n                         }\n@@ -418,7 +418,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n             }\n \n             if changed {\n-                let bits = self.kills.slice_mut(start, end);\n+                let bits = &mut self.kills[start.. end];\n                 debug!(\"{} add_kills_from_flow_exits flow_exit={:?} bits={} [before]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n                 bits.clone_from_slice(&orig_kills[]);\n@@ -487,7 +487,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n             let (start, end) = self.dfcx.compute_id_range(node_index);\n \n             // Initialize local bitvector with state on-entry.\n-            in_out.clone_from_slice(self.dfcx.on_entry.slice(start, end));\n+            in_out.clone_from_slice(&self.dfcx.on_entry[start.. end]);\n \n             // Compute state on-exit by applying transfer function to\n             // state on-entry.\n@@ -528,13 +528,13 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n         let (start, end) = self.dfcx.compute_id_range(cfgidx);\n         let changed = {\n             // (scoping mutable borrow of self.dfcx.on_entry)\n-            let on_entry = self.dfcx.on_entry.slice_mut(start, end);\n+            let on_entry = &mut self.dfcx.on_entry[start.. end];\n             bitwise(on_entry, pred_bits, &self.dfcx.oper)\n         };\n         if changed {\n             debug!(\"{} changed entry set for {:?} to {}\",\n                    self.dfcx.analysis_name, cfgidx,\n-                   bits_to_string(self.dfcx.on_entry.slice(start, end)));\n+                   bits_to_string(&self.dfcx.on_entry[start.. end]));\n             self.changed = true;\n         }\n     }"}, {"sha": "9339f435d8fa01853080f199079612fb11b3ca14", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -609,8 +609,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     pub fn vars_created_since_snapshot(&self, mark: &RegionSnapshot)\n                                        -> Vec<RegionVid>\n     {\n-        self.undo_log.borrow()\n-            .slice_from(mark.length)\n+        self.undo_log.borrow()[mark.length..]\n             .iter()\n             .filter_map(|&elt| match elt {\n                 AddVar(vid) => Some(vid),\n@@ -637,7 +636,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             debug!(\"result_index={}, r={:?}\", result_index, r);\n \n             for undo_entry in\n-                self.undo_log.borrow().slice_from(mark.length).iter()\n+                self.undo_log.borrow()[mark.length..].iter()\n             {\n                 match undo_entry {\n                     &AddConstraint(ConstrainVarSubVar(a, b)) => {"}, {"sha": "889d8b4052f0f4d0a73c834dc36f76348da16d68", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -373,12 +373,12 @@ impl<T> VecPerParamSpace<T> {\n \n     pub fn get_slice<'a>(&'a self, space: ParamSpace) -> &'a [T] {\n         let (start, limit) = self.limits(space);\n-        self.content.slice(start, limit)\n+        &self.content[start.. limit]\n     }\n \n     pub fn get_mut_slice<'a>(&'a mut self, space: ParamSpace) -> &'a mut [T] {\n         let (start, limit) = self.limits(space);\n-        self.content.slice_mut(start, limit)\n+        &mut self.content[start.. limit]\n     }\n \n     pub fn opt_get<'a>(&'a self,"}, {"sha": "dfc27d3ae684d1370611c95d43d75de579724619", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -36,13 +36,13 @@ impl SearchPaths {\n \n     pub fn add_path(&mut self, path: &str) {\n         let (kind, path) = if path.starts_with(\"native=\") {\n-            (PathKind::Native, path.slice_from(\"native=\".len()))\n+            (PathKind::Native, &path[\"native=\".len()..])\n         } else if path.starts_with(\"crate=\") {\n-            (PathKind::Crate, path.slice_from(\"crate=\".len()))\n+            (PathKind::Crate, &path[\"crate=\".len()..])\n         } else if path.starts_with(\"dependency=\") {\n-            (PathKind::Dependency, path.slice_from(\"dependency=\".len()))\n+            (PathKind::Dependency, &path[\"dependency=\".len()..])\n         } else if path.starts_with(\"all=\") {\n-            (PathKind::All, path.slice_from(\"all=\".len()))\n+            (PathKind::All, &path[\"all=\".len()..])\n         } else {\n             (PathKind::All, path)\n         };"}, {"sha": "0ade916f6390a34c0b6350e850ab9372a4eeafa7", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -370,7 +370,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n         for (i, &x) in new_loan_indices.iter().enumerate() {\n             let old_loan = &self.all_loans[x];\n-            for &y in new_loan_indices.slice_from(i+1).iter() {\n+            for &y in new_loan_indices[(i+1) ..].iter() {\n                 let new_loan = &self.all_loans[y];\n                 self.report_error_if_loans_conflict(old_loan, new_loan);\n             }"}, {"sha": "eedfc9407515c99d000276da650b57ef03b4ae54", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -178,7 +178,7 @@ pub fn build_link_meta(sess: &Session, krate: &ast::Crate,\n fn truncated_hash_result(symbol_hasher: &mut Sha256) -> String {\n     let output = symbol_hasher.result_bytes();\n     // 64 bits should be enough to avoid collisions.\n-    output.slice_to(8).to_hex().to_string()\n+    output[.. 8].to_hex().to_string()\n }\n \n "}, {"sha": "26a9ddf95a0e0a6716ef08965875e9a8f3a05327", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -157,7 +157,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             return;\n         }\n \n-        let sub_paths = sub_paths.slice(0, len-1);\n+        let sub_paths = &sub_paths[.. (len-1)];\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n@@ -174,7 +174,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         if len <= 1 {\n             return;\n         }\n-        let sub_paths = sub_paths.slice_to(len-1);\n+        let sub_paths = &sub_paths[.. (len-1)];\n \n         // write the trait part of the sub-path\n         let (ref span, ref qualname) = sub_paths[len-2];"}, {"sha": "9df1b236fe8f64fbac2a725f610516004d65f4a6", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -1635,8 +1635,8 @@ fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n                         let prefix: &[u8] = &[dotdot[0], ::std::path::SEP_BYTE];\n                         let mut path_bytes = p.as_vec().to_vec();\n \n-                        if path_bytes.slice_to(2) != prefix &&\n-                           path_bytes.slice_to(2) != dotdot {\n+                        if &path_bytes[..2] != prefix &&\n+                           &path_bytes[..2] != dotdot {\n                             path_bytes.insert(0, prefix[0]);\n                             path_bytes.insert(1, prefix[1]);\n                         }\n@@ -4142,4 +4142,3 @@ fn needs_gdb_debug_scripts_section(ccx: &CrateContext) -> bool {\n     !ccx.sess().target.target.options.is_like_windows &&\n     ccx.sess().opts.debuginfo != NoDebugInfo\n }\n-"}, {"sha": "c2f19670e4f1558234e15fa575fb7174cd0eabfd", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -495,7 +495,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ty::ty_bare_fn(_, ref f) if f.abi == Rust || f.abi == RustCall => {\n             let fake_sig =\n                 ty::Binder(ty::FnSig {\n-                    inputs: f.sig.0.inputs.slice_from(1).to_vec(),\n+                    inputs: f.sig.0.inputs[1..].to_vec(),\n                     output: f.sig.0.output,\n                     variadic: f.sig.0.variadic,\n                 });\n@@ -635,7 +635,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n             }\n             _ => {\n                 // skip the self parameter:\n-                sig.inputs.slice_from(1)\n+                &sig.inputs[1..]\n             }\n         };\n "}, {"sha": "921ed505fa3af3517fadc1d4ba1818a23748c865", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -1313,7 +1313,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n \n     // HACK(eddyb) replace the fake self type in the AST with the actual type.\n     let input_params = if self_ty.is_some() {\n-        decl.inputs.slice_from(1)\n+        &decl.inputs[1..]\n     } else {\n         &decl.inputs[]\n     };\n@@ -1331,9 +1331,9 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n     let lifetimes_for_params = if implied_output_region.is_none() {\n         let input_tys = if self_ty.is_some() {\n             // Skip the first argument if `self` is present.\n-            self_and_input_tys.slice_from(1)\n+            &self_and_input_tys[1..]\n         } else {\n-            self_and_input_tys.slice_from(0)\n+            &self_and_input_tys[]\n         };\n \n         let (ior, lfp) = find_implied_output_region(input_tys, input_pats);\n@@ -1648,7 +1648,7 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // of derived region bounds. If so, use that. Otherwise, report an\n     // error.\n     let r = derived_region_bounds[0];\n-    if derived_region_bounds.slice_from(1).iter().any(|r1| r != *r1) {\n+    if derived_region_bounds[1..].iter().any(|r1| r != *r1) {\n         span_err!(tcx.sess, span, E0227,\n             \"ambiguous lifetime bound, \\\n                      explicit lifetime bound required\");"}, {"sha": "56b700663d419de034e65b6abca9ef55d4597809", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -542,7 +542,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n \n         ast::ExprMethodCall(_, _, ref args) => {\n             constrain_call(rcx, expr, Some(&*args[0]),\n-                           args.slice_from(1).iter().map(|e| &**e), false);\n+                           args[1..].iter().map(|e| &**e), false);\n \n             visit::walk_expr(rcx, expr);\n         }"}, {"sha": "a7bad3dc789aaadcf981e58d42add7d394d6ffca", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -65,7 +65,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n                 continue;\n             }\n \n-            for &impl2_def_id in trait_impls.slice_from(i+1).iter() {\n+            for &impl2_def_id in trait_impls[(i+1)..].iter() {\n                 self.check_if_impls_overlap(trait_def_id,\n                                             impl1_def_id,\n                                             impl2_def_id);"}, {"sha": "fe8ac3fde5fcc596e3a2f4f37dd0e09302e7859e", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -29,7 +29,7 @@ impl<'a> fmt::Display for Escape<'a> {\n         for (i, ch) in s.bytes().enumerate() {\n             match ch as char {\n                 '<' | '>' | '&' | '\\'' | '\"' => {\n-                    try!(fmt.write_str(pile_o_bits.slice(last, i)));\n+                    try!(fmt.write_str(&pile_o_bits[last.. i]));\n                     let s = match ch as char {\n                         '>' => \"&gt;\",\n                         '<' => \"&lt;\",\n@@ -46,7 +46,7 @@ impl<'a> fmt::Display for Escape<'a> {\n         }\n \n         if last < s.len() {\n-            try!(fmt.write_str(pile_o_bits.slice_from(last)));\n+            try!(fmt.write_str(&pile_o_bits[last..]));\n         }\n         Ok(())\n     }"}, {"sha": "6f19519ee7cb24171d6250fc66ba78e54ed31b04", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -146,7 +146,7 @@ extern {\n fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n     let trimmed = s.trim();\n     if trimmed.starts_with(\"# \") {\n-        Some(trimmed.slice_from(2))\n+        Some(&trimmed[2..])\n     } else {\n         None\n     }"}, {"sha": "3656c3a459ce62938076ba8010c26588fd013228", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -749,7 +749,7 @@ impl<'a> SourceCollector<'a> {\n \n         // Remove the utf-8 BOM if any\n         let contents = if contents.starts_with(\"\\u{feff}\") {\n-            contents.slice_from(3)\n+            &contents[3..]\n         } else {\n             contents\n         };\n@@ -1469,7 +1469,7 @@ fn full_path(cx: &Context, item: &clean::Item) -> String {\n fn shorter<'a>(s: Option<&'a str>) -> &'a str {\n     match s {\n         Some(s) => match s.find_str(\"\\n\\n\") {\n-            Some(pos) => s.slice_to(pos),\n+            Some(pos) => &s[..pos],\n             None => s,\n         },\n         None => \"\""}, {"sha": "594cf3dcd43992d0a6dfeefd17a46fe9f0d11b80", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -28,10 +28,10 @@ fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n     for line in s.lines() {\n         if line.starts_with(\"%\") {\n             // remove %<whitespace>\n-            metadata.push(line.slice_from(1).trim_left())\n+            metadata.push(line[1..].trim_left())\n         } else {\n             let line_start_byte = s.subslice_offset(line);\n-            return (metadata, s.slice_from(line_start_byte));\n+            return (metadata, &s[line_start_byte..]);\n         }\n     }\n     // if we're here, then all lines were metadata % lines."}, {"sha": "34a23774e5b1bd7fd62cda494dee97fdc6c67e3d", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -357,7 +357,7 @@ pub fn unindent(s: &str) -> String {\n                 line.to_string()\n             } else {\n                 assert!(line.len() >= min_indent);\n-                line.slice_from(min_indent).to_string()\n+                line[min_indent..].to_string()\n             }\n         }).collect::<Vec<_>>().as_slice());\n         unindented.connect(\"\\n\")"}, {"sha": "7d0e42e8e49e82278ccd0e5a07d282bae57d9d79", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -115,7 +115,7 @@ impl Deref for CString {\n     type Target = [libc::c_char];\n \n     fn deref(&self) -> &[libc::c_char] {\n-        self.inner.slice_to(self.inner.len() - 1)\n+        &self.inner[..(self.inner.len() - 1)]\n     }\n }\n "}, {"sha": "73c73209f00fcf3c55f90cc8e888a030f0e6e56c", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -221,7 +221,7 @@ impl<W: Writer> Writer for BufferedWriter<W> {\n         if buf.len() > self.buf.len() {\n             self.inner.as_mut().unwrap().write(buf)\n         } else {\n-            let dst = self.buf.slice_from_mut(self.pos);\n+            let dst = &mut self.buf[self.pos..];\n             slice::bytes::copy_memory(dst, buf);\n             self.pos += buf.len();\n             Ok(())"}, {"sha": "4649012d454b0b99e5f1cbe43b8f4f92c2a5f38a", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -72,7 +72,7 @@ impl Buffer for ChanReader {\n         if self.closed {\n             Err(io::standard_error(io::EndOfFile))\n         } else {\n-            Ok(self.buf.slice_from(self.pos))\n+            Ok(&self.buf[self.pos..])\n         }\n     }\n \n@@ -88,7 +88,7 @@ impl Reader for ChanReader {\n         loop {\n             let count = match self.fill_buf().ok() {\n                 Some(src) => {\n-                    let dst = buf.slice_from_mut(num_read);\n+                    let dst = &mut buf[num_read..];\n                     let count = cmp::min(src.len(), dst.len());\n                     bytes::copy_memory(dst, &src[..count]);\n                     count"}, {"sha": "786b5a08eed7995ca29d5bb6d88a09df4a220459", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -160,7 +160,7 @@ impl Reader for MemReader {\n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n             let input = &self.buf[self.pos.. self.pos + write_len];\n-            let output = buf.slice_to_mut(write_len);\n+            let output = &mut buf[..write_len];\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n         }\n@@ -205,11 +205,11 @@ impl<'a> Reader for &'a [u8] {\n         let write_len = min(buf.len(), self.len());\n         {\n             let input = &self[..write_len];\n-            let output = buf.slice_to_mut(write_len);\n+            let output = &mut buf[.. write_len];\n             slice::bytes::copy_memory(output, input);\n         }\n \n-        *self = self.slice_from(write_len);\n+        *self = &self[write_len..];\n \n         Ok(write_len)\n     }\n@@ -270,7 +270,7 @@ impl<'a> BufWriter<'a> {\n impl<'a> Writer for BufWriter<'a> {\n     #[inline]\n     fn write(&mut self, src: &[u8]) -> IoResult<()> {\n-        let dst = self.buf.slice_from_mut(self.pos);\n+        let dst = &mut self.buf[self.pos..];\n         let dst_len = dst.len();\n \n         if dst_len == 0 {\n@@ -350,7 +350,7 @@ impl<'a> Reader for BufReader<'a> {\n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n             let input = &self.buf[self.pos.. self.pos + write_len];\n-            let output = buf.slice_to_mut(write_len);\n+            let output = &mut buf.slice_to_mut[..write_len];\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n         }"}, {"sha": "f106e9464c52ac9c3fcaecaaca16fdfd65af5862", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -504,7 +504,7 @@ pub trait Reader {\n         while read < min {\n             let mut zeroes = 0;\n             loop {\n-                match self.read(buf.slice_from_mut(read)) {\n+                match self.read(&mut buf[read..]) {\n                     Ok(0) => {\n                         zeroes += 1;\n                         if zeroes >= NO_PROGRESS_LIMIT {\n@@ -1467,7 +1467,7 @@ pub trait Buffer: Reader {\n         {\n             let mut start = 1;\n             while start < width {\n-                match try!(self.read(buf.slice_mut(start, width))) {\n+                match try!(self.read(&mut buf[start .. width])) {\n                     n if n == width - start => break,\n                     n if n < width - start => { start += n; }\n                     _ => return Err(standard_error(InvalidInput)),"}, {"sha": "e4622781ae7eaf26ebb29881fee8f2c0358aa349", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -253,7 +253,7 @@ impl<'a> Parser<'a> {\n             assert!(head.len() + tail.len() <= 8);\n             let mut gs = [0u16; 8];\n             gs.clone_from_slice(head);\n-            gs.slice_mut(8 - tail.len(), 8).clone_from_slice(tail);\n+            gs[(8 - tail.len()) .. 8].clone_from_slice(tail);\n             Ipv6Addr(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n         }\n "}, {"sha": "e4bf38a9ef5d8e0d7de059153cc00c366aaa5934", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -48,7 +48,7 @@ impl<R: Reader> Reader for LimitReader<R> {\n         }\n \n         let len = cmp::min(self.limit, buf.len());\n-        let res = self.inner.read(buf.slice_to_mut(len));\n+        let res = self.inner.read(&mut buf[..len]);\n         match res {\n             Ok(len) => self.limit -= len,\n             _ => {}"}, {"sha": "1d3bf484edb9ab458150dbd6213b2884fb423da3", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -379,14 +379,14 @@ pub fn float_to_str_bytes_common<T: Float>(\n \n             // only resize buf if we actually remove digits\n             if i < buf_max_i {\n-                buf = buf.slice(0, i + 1).to_vec();\n+                buf = buf[.. (i + 1)].to_vec();\n             }\n         }\n     } // If exact and trailing '.', just cut that\n     else {\n         let max_i = buf.len() - 1;\n         if buf[max_i] == b'.' {\n-            buf = buf.slice(0, max_i).to_vec();\n+            buf = buf[.. max_i].to_vec();\n         }\n     }\n "}, {"sha": "bafbde2511dec6096816b5fc92e987b0f3cdba4a", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -65,7 +65,7 @@ mod imp {\n         let mut read = 0;\n         let len = v.len();\n         while read < len {\n-            let result = getrandom(v.slice_from_mut(read));\n+            let result = getrandom(&mut v[read..]);\n             if result == -1 {\n                 let err = errno() as libc::c_int;\n                 if err == libc::EINTR {"}, {"sha": "4023a0a4c100b3b86f5ee319bf857920048f248f", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -130,7 +130,7 @@ pub fn abort(args: fmt::Arguments) -> ! {\n     }\n     impl<'a> fmt::Writer for BufWriter<'a> {\n         fn write_str(&mut self, bytes: &str) -> fmt::Result {\n-            let left = self.buf.slice_from_mut(self.pos);\n+            let left = &mut self.buf[self.pos..];\n             let to_write = &bytes.as_bytes()[..cmp::min(bytes.len(), left.len())];\n             slice::bytes::copy_memory(left, to_write);\n             self.pos += to_write.len();"}, {"sha": "d069d9ee3b8b89889b378c4841db7ae5a8bfc7e7", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -42,10 +42,10 @@ pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n     let mut valid = true;\n     let mut inner = s;\n     if s.len() > 4 && s.starts_with(\"_ZN\") && s.ends_with(\"E\") {\n-        inner = s.slice(3, s.len() - 1);\n+        inner = &s[3 .. s.len() - 1];\n     // On Windows, dbghelp strips leading underscores, so we accept \"ZN...E\" form too.\n     } else if s.len() > 3 && s.starts_with(\"ZN\") && s.ends_with(\"E\") {\n-        inner = s.slice(2, s.len() - 1);\n+        inner = &s[2 .. s.len() - 1];\n     } else {\n         valid = false;\n     }\n@@ -83,11 +83,11 @@ pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n             }\n             let mut rest = inner;\n             while rest.char_at(0).is_numeric() {\n-                rest = rest.slice_from(1);\n+                rest = &rest[1..];\n             }\n-            let i: uint = inner.slice_to(inner.len() - rest.len()).parse().unwrap();\n-            inner = rest.slice_from(i);\n-            rest = rest.slice_to(i);\n+            let i: uint = inner[.. (inner.len() - rest.len())].parse().unwrap();\n+            inner = &rest[i..];\n+            rest = &rest[..i];\n             while rest.len() > 0 {\n                 if rest.starts_with(\"$\") {\n                     macro_rules! demangle {\n@@ -128,8 +128,8 @@ pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n                         None => rest.len(),\n                         Some(i) => i,\n                     };\n-                    try!(writer.write_str(rest.slice_to(idx)));\n-                    rest = rest.slice_from(idx);\n+                    try!(writer.write_str(&rest[..idx]));\n+                    rest = &rest[idx..];\n                 }\n             }\n         }"}, {"sha": "2b4d168d881f6a1c25f6449aed1b3b6d64c5bbcd", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -125,9 +125,9 @@ impl Process {\n                     let mut bytes = [0; 8];\n                     return match input.read(&mut bytes) {\n                         Ok(8) => {\n-                            assert!(combine(CLOEXEC_MSG_FOOTER) == combine(bytes.slice(4, 8)),\n+                            assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n                                 \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n-                            let errno = combine(bytes.slice(0, 4));\n+                            let errno = combine(&bytes[0.. 4]);\n                             assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n                             Err(super::decode_error(errno))\n                         }"}, {"sha": "cb8ef7eb66bc414d30658135feef4d382a213930", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -376,7 +376,7 @@ pub fn readlink(p: &Path) -> IoResult<Path> {\n     });\n     let ret = match ret {\n         Some(ref s) if s.starts_with(r\"\\\\?\\\") => { // \"\n-            Ok(Path::new(s.slice_from(4)))\n+            Ok(Path::new(&s[4..]))\n         }\n         Some(s) => Ok(Path::new(s)),\n         None => Err(super::last_error()),"}, {"sha": "36dc9b2afe49feb673cfd58081e7634ca22a08c2", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -146,7 +146,7 @@ pub fn fill_utf16_buf_and_decode<F>(mut f: F) -> Option<String> where\n                 done = true;\n             }\n             if k != 0 && done {\n-                let sub = buf.slice(0, k as uint);\n+                let sub = &buf[.. (k as uint)];\n                 // We want to explicitly catch the case when the\n                 // closure returned invalid UTF-16, rather than\n                 // set `res` to None and continue."}, {"sha": "33e37aa51bd990a6de53a1ab1479a24f1ea7a107", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -271,9 +271,9 @@ impl<'a> StringReader<'a> {\n     fn with_str_from_to<T, F>(&self, start: BytePos, end: BytePos, f: F) -> T where\n         F: FnOnce(&str) -> T,\n     {\n-        f(self.filemap.src.slice(\n-                self.byte_offset(start).to_usize(),\n-                self.byte_offset(end).to_usize()))\n+        f(self.filemap.src[\n+                self.byte_offset(start).to_usize()..\n+                self.byte_offset(end).to_usize()])\n     }\n \n     /// Converts CRLF to LF in the given string, raising an error on bare CR."}, {"sha": "20946c48884cf6430b2249e28e8c9cdcb8a2cfc7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -5223,7 +5223,7 @@ impl<'a> Parser<'a> {\n             Some(i) => {\n                 let mut err = String::from_str(\"circular modules: \");\n                 let len = included_mod_stack.len();\n-                for p in included_mod_stack.slice(i, len).iter() {\n+                for p in included_mod_stack[i.. len].iter() {\n                     err.push_str(&p.display().as_cow()[]);\n                     err.push_str(\" -> \");\n                 }"}, {"sha": "af470e14a353f2f6ba9e53777f535490911b0f81", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -1590,7 +1590,7 @@ impl<'a> State<'a> {\n                               ident: ast::SpannedIdent,\n                               tys: &[P<ast::Ty>],\n                               args: &[P<ast::Expr>]) -> IoResult<()> {\n-        let base_args = args.slice_from(1);\n+        let base_args = &args[1..];\n         try!(self.print_expr(&*args[0]));\n         try!(word(&mut self.s, \".\"));\n         try!(self.print_ident(ident.node));\n@@ -2312,7 +2312,7 @@ impl<'a> State<'a> {\n         let args = if first {\n             &decl.inputs[]\n         } else {\n-            decl.inputs.slice_from(1)\n+            &decl.inputs[1..]\n         };\n \n         for arg in args.iter() {"}, {"sha": "66cdf03a51ea6656b6c68d68b47da578028e1b57", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -249,8 +249,8 @@ impl<'a> Iterator for Graphemes<'a> {\n             Some(cat)\n         };\n \n-        let retstr = self.string.slice_to(idx);\n-        self.string = self.string.slice_from(idx);\n+        let retstr = &self.string[..idx];\n+        self.string = &self.string[idx..];\n         Some(retstr)\n     }\n }\n@@ -350,8 +350,8 @@ impl<'a> DoubleEndedIterator for Graphemes<'a> {\n             Some(cat)\n         };\n \n-        let retstr = self.string.slice_from(idx);\n-        self.string = self.string.slice_to(idx);\n+        let retstr = &self.string[idx..];\n+        self.string = &self.string[..idx];\n         Some(retstr)\n     }\n }"}, {"sha": "4182f8b651b2eaf1fec970b70fa031de789457ce", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -41,7 +41,7 @@\n extern crate arena;\n \n use std::iter::range_step;\n-use std::thread::Thread;\n+use std::thread::{Thread, JoinGuard};\n use arena::TypedArena;\n \n struct Tree<'a> {\n@@ -71,6 +71,18 @@ fn bottom_up_tree<'r>(arena: &'r TypedArena<Tree<'r>>, item: i32, depth: i32)\n     }\n }\n \n+fn inner(depth: i32, iterations: i32) -> String {\n+    let mut chk = 0;\n+    for i in 1 .. iterations + 1 {\n+        let arena = TypedArena::new();\n+        let a = bottom_up_tree(&arena, i, depth);\n+        let b = bottom_up_tree(&arena, -i, depth);\n+        chk += item_check(&a) + item_check(&b);\n+    }\n+    format!(\"{}\\t trees of depth {}\\t check: {}\",\n+            iterations * 2, depth, chk)\n+}\n+\n fn main() {\n     let args = std::os::args();\n     let args = args.as_slice();\n@@ -97,20 +109,10 @@ fn main() {\n     let long_lived_tree = bottom_up_tree(&long_lived_arena, 0, max_depth);\n \n     let messages = range_step(min_depth, max_depth + 1, 2).map(|depth| {\n-            use std::num::Int;\n-            let iterations = 2.pow((max_depth - depth + min_depth) as usize);\n-            Thread::scoped(move|| {\n-                let mut chk = 0;\n-                for i in 1 .. iterations + 1 {\n-                    let arena = TypedArena::new();\n-                    let a = bottom_up_tree(&arena, i, depth);\n-                    let b = bottom_up_tree(&arena, -i, depth);\n-                    chk += item_check(&a) + item_check(&b);\n-                }\n-                format!(\"{}\\t trees of depth {}\\t check: {}\",\n-                        iterations * 2, depth, chk)\n-            })\n-        }).collect::<Vec<_>>();\n+        use std::num::Int;\n+        let iterations = 2.pow((max_depth - depth + min_depth) as usize);\n+        Thread::scoped(move || inner(depth, iterations))\n+    }).collect::<Vec<_>>();\n \n     for message in messages.into_iter() {\n         println!(\"{}\", message.join().ok().unwrap());"}, {"sha": "8ee6054f8ba5634cdcdb97663cfedbe33ce5cc30", "filename": "src/test/run-pass/init-large-type.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Ftest%2Frun-pass%2Finit-large-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/886c6f3534e6f03916eeff2ea8b235e85dd04b42/src%2Ftest%2Frun-pass%2Finit-large-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finit-large-type.rs?ref=886c6f3534e6f03916eeff2ea8b235e85dd04b42", "patch": "@@ -14,12 +14,17 @@\n \n #![feature(intrinsics)]\n \n+use std::thread::Thread;\n+\n extern \"rust-intrinsic\" {\n     pub fn init<T>() -> T;\n }\n \n const SIZE: usize = 1024 * 1024;\n \n fn main() {\n-    let _memory: [u8; SIZE] = unsafe { init() };\n+    // do the test in a new thread to avoid (spurious?) stack overflows\n+    let _ = Thread::scoped(|| {\n+        let _memory: [u8; SIZE] = unsafe { init() };\n+    }).join();\n }"}]}