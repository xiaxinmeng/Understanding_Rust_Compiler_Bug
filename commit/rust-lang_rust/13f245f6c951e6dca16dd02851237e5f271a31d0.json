{"sha": "13f245f6c951e6dca16dd02851237e5f271a31d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzZjI0NWY2Yzk1MWU2ZGNhMTZkZDAyODUxMjM3ZTVmMjcxYTMxZDA=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-05T23:13:29Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-05T23:13:29Z"}, "message": "Fix util/update_wiki.py warnings and be consistent in declare_lint! invocations", "tree": {"sha": "dacee40b2eaca904b92a3bfea9943cda26a8d5b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dacee40b2eaca904b92a3bfea9943cda26a8d5b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13f245f6c951e6dca16dd02851237e5f271a31d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13f245f6c951e6dca16dd02851237e5f271a31d0", "html_url": "https://github.com/rust-lang/rust/commit/13f245f6c951e6dca16dd02851237e5f271a31d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13f245f6c951e6dca16dd02851237e5f271a31d0/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0494071ab78ba4648e64a268ef1a4fffaa6c39b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0494071ab78ba4648e64a268ef1a4fffaa6c39b6", "html_url": "https://github.com/rust-lang/rust/commit/0494071ab78ba4648e64a268ef1a4fffaa6c39b6"}], "stats": {"total": 507, "additions": 341, "deletions": 166}, "files": [{"sha": "f224b7dff29c6adb97a8f061e546c821b632715e", "filename": "src/attrs.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -22,8 +22,10 @@ use utils::{in_macro, match_path, span_lint, BEGIN_UNWIND};\n /// #[inline(always)]\n /// fn not_quite_hot_code(..) { ... }\n /// ```\n-declare_lint! { pub INLINE_ALWAYS, Warn,\n-    \"`#[inline(always)]` is a bad idea in most cases\" }\n+declare_lint! {\n+    pub INLINE_ALWAYS, Warn,\n+    \"`#[inline(always)]` is a bad idea in most cases\"\n+}\n \n /// **What it does:** This lint `Warn`s on `#[deprecated]` annotations with a `since` field that is not a valid semantic version..\n ///\n@@ -36,8 +38,10 @@ declare_lint! { pub INLINE_ALWAYS, Warn,\n /// #[deprecated(since = \"forever\")]\n /// fn something_else(..) { ... }\n /// ```\n-declare_lint! { pub DEPRECATED_SEMVER, Warn,\n-    \"`Warn` on `#[deprecated(since = \\\"x\\\")]` where x is not semver\" }\n+declare_lint! {\n+    pub DEPRECATED_SEMVER, Warn,\n+    \"`Warn` on `#[deprecated(since = \\\"x\\\")]` where x is not semver\"\n+}\n \n #[derive(Copy,Clone)]\n pub struct AttrPass;"}, {"sha": "7eab7c1935fbaae458aaac5363c78b1c9ba9e151", "filename": "src/cyclomatic_complexity.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcyclomatic_complexity.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -18,8 +18,10 @@ use utils::{in_macro, LimitStack, span_help_and_lint};\n /// **Known problems:** Sometimes it's hard to find a way to reduce the complexity\n ///\n /// **Example:** No. You'll see it when you get the warning.\n-declare_lint! { pub CYCLOMATIC_COMPLEXITY, Warn,\n-    \"finds functions that should be split up into multiple functions\" }\n+declare_lint! {\n+    pub CYCLOMATIC_COMPLEXITY, Warn,\n+    \"finds functions that should be split up into multiple functions\"\n+}\n \n pub struct CyclomaticComplexity {\n     limit: LimitStack,"}, {"sha": "f7a0ca59f01a1a30df682f1e00d57185cc2f0d5f", "filename": "src/drop_ref.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fdrop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fdrop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdrop_ref.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -18,9 +18,11 @@ use utils::{match_def_path, span_note_and_lint};\n /// std::mem::drop(&lock_guard) //Should have been drop(lock_guard), mutex still locked\n /// operation_that_requires_mutex_to_be_unlocked();\n /// ```\n-declare_lint!(pub DROP_REF, Warn,\n+declare_lint! {\n+    pub DROP_REF, Warn,\n     \"call to `std::mem::drop` with a reference instead of an owned value, \\\n-    which will not call the `Drop::drop` method on the underlying value\");\n+    which will not call the `Drop::drop` method on the underlying value\"\n+}\n \n #[allow(missing_copy_implementations)]\n pub struct DropRefPass;"}, {"sha": "8ceaca1bbf3938f3eb09c9fd41493fd2c14f1e12", "filename": "src/enum_variants.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fenum_variants.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -14,8 +14,10 @@ use utils::span_help_and_lint;\n /// **Known problems:** None\n ///\n /// **Example:** enum Cake { BlackForestCake, HummingbirdCake }\n-declare_lint! { pub ENUM_VARIANT_NAMES, Warn,\n-    \"finds enums where all variants share a prefix/postfix\" }\n+declare_lint! {\n+    pub ENUM_VARIANT_NAMES, Warn,\n+    \"finds enums where all variants share a prefix/postfix\"\n+}\n \n pub struct EnumVariantNames;\n "}, {"sha": "b7bec46c3fdce21e882af0b896deeba6891fd1ac", "filename": "src/escape.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fescape.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -29,7 +29,9 @@ pub struct EscapePass;\n ///     println!(\"{}\", *x);\n /// }\n /// ```\n-declare_lint!(pub BOXED_LOCAL, Warn, \"using Box<T> where unnecessary\");\n+declare_lint! {\n+    pub BOXED_LOCAL, Warn, \"using Box<T> where unnecessary\"\n+}\n \n fn is_non_trait_box(ty: ty::Ty) -> bool {\n     match ty.sty {"}, {"sha": "39063f91ba3b1025cf1dc215154dc6927cac6fee", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -16,8 +16,10 @@ pub struct EtaPass;\n /// **Known problems:** None\n ///\n /// **Example:** `xs.map(|x| foo(x))` where `foo(_)` is a plain function that takes the exact argument type of `x`.\n-declare_lint!(pub REDUNDANT_CLOSURE, Warn,\n-              \"using redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\");\n+declare_lint! {\n+    pub REDUNDANT_CLOSURE, Warn,\n+    \"using redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\"\n+}\n \n impl LintPass for EtaPass {\n     fn get_lints(&self) -> LintArray {"}, {"sha": "093c37783eb83b1d4b01db686d79c2373a781123", "filename": "src/identity_op.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fidentity_op.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -12,8 +12,10 @@ use utils::{span_lint, snippet, in_macro};\n /// **Known problems:** None\n ///\n /// **Example:** `x / 1 + 0 * 1 - 0 | 0`\n-declare_lint! { pub IDENTITY_OP, Warn,\n-                \"using identity operations, e.g. `x + 0` or `y / 1`\" }\n+declare_lint! {\n+    pub IDENTITY_OP, Warn,\n+    \"using identity operations, e.g. `x + 0` or `y / 1`\"\n+}\n \n #[derive(Copy,Clone)]\n pub struct IdentityOp;"}, {"sha": "2f061d32546c6237c1b157a3788a2bdf6ae77a10", "filename": "src/items_after_statements.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems_after_statements.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -27,7 +27,11 @@ use utils::in_macro;\n ///     foo(); // prints \"foo\"\n /// }\n /// ```\n-declare_lint! { pub ITEMS_AFTER_STATEMENTS, Warn, \"finds blocks where an item comes after a statement\" }\n+declare_lint! {\n+    pub ITEMS_AFTER_STATEMENTS,\n+    Warn,\n+    \"finds blocks where an item comes after a statement\"\n+}\n \n pub struct ItemsAfterStatemets;\n "}, {"sha": "48fc10ef23692286fa0e092cd26639d9c97a5823", "filename": "src/len_zero.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -18,9 +18,11 @@ use utils::{get_item_name, snippet, span_lint, walk_ptrs_ty};\n /// **Known problems:** None\n ///\n /// **Example:** `if x.len() == 0 { .. }`\n-declare_lint!(pub LEN_ZERO, Warn,\n-              \"checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` \\\n-               could be used instead\");\n+declare_lint! {\n+    pub LEN_ZERO, Warn,\n+    \"checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` \\\n+     could be used instead\"\n+}\n \n /// **What it does:** This lint checks for items that implement `.len()` but not `.is_empty()`. It is `Warn` by default.\n ///\n@@ -34,8 +36,10 @@ declare_lint!(pub LEN_ZERO, Warn,\n ///     fn len(&self) -> usize { .. }\n /// }\n /// ```\n-declare_lint!(pub LEN_WITHOUT_IS_EMPTY, Warn,\n-              \"traits and impls that have `.len()` but not `.is_empty()`\");\n+declare_lint! {\n+    pub LEN_WITHOUT_IS_EMPTY, Warn,\n+    \"traits and impls that have `.len()` but not `.is_empty()`\"\n+}\n \n #[derive(Copy,Clone)]\n pub struct LenZero;"}, {"sha": "f2f33a634bc9fc19093a5c4ded2c14f1b9446a2b", "filename": "src/lifetimes.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -15,9 +15,12 @@ use utils::{in_external_macro, span_lint};\n /// **Known problems:** Potential false negatives: we bail out if the function has a `where` clause where lifetimes are mentioned.\n ///\n /// **Example:** `fn in_and_out<'a>(x: &'a u8, y: u8) -> &'a u8 { x }`\n-declare_lint!(pub NEEDLESS_LIFETIMES, Warn,\n-              \"using explicit lifetimes for references in function arguments when elision rules \\\n-               would allow omitting them\");\n+declare_lint! {\n+    pub NEEDLESS_LIFETIMES,\n+    Warn,\n+    \"using explicit lifetimes for references in function arguments when elision rules \\\n+     would allow omitting them\"\n+}\n \n /// **What it does:** This lint checks for lifetimes in generics that are never used anywhere else. It is `Warn` by default.\n ///\n@@ -26,8 +29,11 @@ declare_lint!(pub NEEDLESS_LIFETIMES, Warn,\n /// **Known problems:** None\n ///\n /// **Example:** `fn unused_lifetime<'a>(x: u8) { .. }`\n-declare_lint!(pub UNUSED_LIFETIMES, Warn,\n-              \"unused lifetimes in function definitions\");\n+declare_lint! {\n+    pub UNUSED_LIFETIMES,\n+    Warn,\n+    \"unused lifetimes in function definitions\"\n+}\n \n #[derive(Copy,Clone)]\n pub struct LifetimePass;"}, {"sha": "bfd0e9895e57eac83534716c66647ec98607dde0", "filename": "src/loops.rs", "status": "modified", "additions": 61, "deletions": 22, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -25,8 +25,11 @@ use utils::{BTREEMAP_PATH, HASHMAP_PATH, LL_PATH, OPTION_PATH, RESULT_PATH, VEC_\n ///     println!(\"{}\", vec[i]);\n /// }\n /// ```\n-declare_lint!{ pub NEEDLESS_RANGE_LOOP, Warn,\n-               \"for-looping over a range of indices where an iterator over items would do\" }\n+declare_lint! {\n+    pub NEEDLESS_RANGE_LOOP,\n+    Warn,\n+    \"for-looping over a range of indices where an iterator over items would do\"\n+}\n \n /// **What it does:** This lint checks for loops on `x.iter()` where `&x` will do, and suggest the latter. It is `Warn` by default.\n ///\n@@ -35,8 +38,11 @@ declare_lint!{ pub NEEDLESS_RANGE_LOOP, Warn,\n /// **Known problems:** False negatives. We currently only warn on some known types.\n ///\n /// **Example:** `for x in y.iter() { .. }` (where y is a `Vec` or slice)\n-declare_lint!{ pub EXPLICIT_ITER_LOOP, Warn,\n-               \"for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\" }\n+declare_lint! {\n+    pub EXPLICIT_ITER_LOOP,\n+    Warn,\n+    \"for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\"\n+}\n \n /// **What it does:** This lint checks for loops on `x.next()`. It is `Warn` by default.\n ///\n@@ -45,8 +51,11 @@ declare_lint!{ pub EXPLICIT_ITER_LOOP, Warn,\n /// **Known problems:** None\n ///\n /// **Example:** `for x in y.next() { .. }`\n-declare_lint!{ pub ITER_NEXT_LOOP, Warn,\n-               \"for-looping over `_.next()` which is probably not intended\" }\n+declare_lint! {\n+    pub ITER_NEXT_LOOP,\n+    Warn,\n+    \"for-looping over `_.next()` which is probably not intended\"\n+}\n \n /// **What it does:** This lint checks for `for` loops over `Option` values. It is `Warn` by default.\n ///\n@@ -55,8 +64,11 @@ declare_lint!{ pub ITER_NEXT_LOOP, Warn,\n /// **Known problems:** None\n ///\n /// **Example:** `for x in option { .. }`. This should be `if let Some(x) = option { .. }`.\n-declare_lint!{ pub FOR_LOOP_OVER_OPTION, Warn,\n-               \"for-looping over an `Option`, which is more clearly expressed as an `if let`\" }\n+declare_lint! {\n+    pub FOR_LOOP_OVER_OPTION,\n+    Warn,\n+    \"for-looping over an `Option`, which is more clearly expressed as an `if let`\"\n+}\n \n /// **What it does:** This lint checks for `for` loops over `Result` values. It is `Warn` by default.\n ///\n@@ -65,8 +77,11 @@ declare_lint!{ pub FOR_LOOP_OVER_OPTION, Warn,\n /// **Known problems:** None\n ///\n /// **Example:** `for x in result { .. }`. This should be `if let Ok(x) = result { .. }`.\n-declare_lint!{ pub FOR_LOOP_OVER_RESULT, Warn,\n-               \"for-looping over a `Result`, which is more clearly expressed as an `if let`\" }\n+declare_lint! {\n+    pub FOR_LOOP_OVER_RESULT,\n+    Warn,\n+    \"for-looping over a `Result`, which is more clearly expressed as an `if let`\"\n+}\n \n /// **What it does:** This lint detects `loop + match` combinations that are easier written as a `while let` loop. It is `Warn` by default.\n ///\n@@ -89,8 +104,11 @@ declare_lint!{ pub FOR_LOOP_OVER_RESULT, Warn,\n ///     // .. do something with x\n /// }\n /// ```\n-declare_lint!{ pub WHILE_LET_LOOP, Warn,\n-               \"`loop { if let { ... } else break }` can be written as a `while let` loop\" }\n+declare_lint! {\n+    pub WHILE_LET_LOOP,\n+    Warn,\n+    \"`loop { if let { ... } else break }` can be written as a `while let` loop\"\n+}\n \n /// **What it does:** This lint checks for using `collect()` on an iterator without using the result. It is `Warn` by default.\n ///\n@@ -99,9 +117,12 @@ declare_lint!{ pub WHILE_LET_LOOP, Warn,\n /// **Known problems:** None\n ///\n /// **Example:** `vec.iter().map(|x| /* some operation returning () */).collect::<Vec<_>>();`\n-declare_lint!{ pub UNUSED_COLLECT, Warn,\n-               \"`collect()`ing an iterator without using the result; this is usually better \\\n-                written as a for loop\" }\n+declare_lint! {\n+    pub UNUSED_COLLECT,\n+    Warn,\n+    \"`collect()`ing an iterator without using the result; this is usually better \\\n+     written as a for loop\"\n+}\n \n /// **What it does:** This lint checks for loops over ranges `x..y` where both `x` and `y` are constant and `x` is greater or equal to `y`, unless the range is reversed or has a negative `.step_by(_)`. It is `Warn` by default.\n ///\n@@ -110,8 +131,11 @@ declare_lint!{ pub UNUSED_COLLECT, Warn,\n /// **Known problems:** The lint cannot catch loops over dynamically defined ranges. Doing this would require simulating all possible inputs and code paths through the program, which would be complex and error-prone.\n ///\n /// **Examples**: `for x in 5..10-5 { .. }` (oops, stray `-`)\n-declare_lint!{ pub REVERSE_RANGE_LOOP, Warn,\n-               \"Iterating over an empty range, such as `10..0` or `5..5`\" }\n+declare_lint! {\n+    pub REVERSE_RANGE_LOOP,\n+    Warn,\n+    \"Iterating over an empty range, such as `10..0` or `5..5`\"\n+}\n \n /// **What it does:** This lint checks `for` loops over slices with an explicit counter and suggests the use of `.enumerate()`. It is `Warn` by default.\n ///\n@@ -120,8 +144,11 @@ declare_lint!{ pub REVERSE_RANGE_LOOP, Warn,\n /// **Known problems:** None.\n ///\n /// **Example:** `for i in 0..v.len() { foo(v[i]); }` or `for i in 0..v.len() { bar(i, v[i]); }`\n-declare_lint!{ pub EXPLICIT_COUNTER_LOOP, Warn,\n-               \"for-looping with an explicit counter when `_.enumerate()` would do\" }\n+declare_lint! {\n+    pub EXPLICIT_COUNTER_LOOP,\n+    Warn,\n+    \"for-looping with an explicit counter when `_.enumerate()` would do\"\n+}\n \n /// **What it does:** This lint checks for empty `loop` expressions. It is `Warn` by default.\n ///\n@@ -130,7 +157,11 @@ declare_lint!{ pub EXPLICIT_COUNTER_LOOP, Warn,\n /// **Known problems:** None\n ///\n /// **Example:** `loop {}`\n-declare_lint!{ pub EMPTY_LOOP, Warn, \"empty `loop {}` detected\" }\n+declare_lint! {\n+    pub EMPTY_LOOP,\n+    Warn,\n+    \"empty `loop {}` detected\"\n+}\n \n /// **What it does:** This lint checks for `while let` expressions on iterators. It is `Warn` by default.\n ///\n@@ -139,7 +170,11 @@ declare_lint!{ pub EMPTY_LOOP, Warn, \"empty `loop {}` detected\" }\n /// **Known problems:** None\n ///\n /// **Example:** `while let Some(val) = iter() { .. }`\n-declare_lint!{ pub WHILE_LET_ON_ITERATOR, Warn, \"using a while-let loop instead of a for loop on an iterator\" }\n+declare_lint! {\n+    pub WHILE_LET_ON_ITERATOR,\n+    Warn,\n+    \"using a while-let loop instead of a for loop on an iterator\"\n+}\n \n /// **What it does:** This warns when you iterate on a map (`HashMap` or `BTreeMap`) and ignore\n /// either the keys or values.\n@@ -157,7 +192,11 @@ declare_lint!{ pub WHILE_LET_ON_ITERATOR, Warn, \"using a while-let loop instead\n /// ```rust\n /// for k in map.keys() { .. }\n /// ```\n-declare_lint!{ pub FOR_KV_MAP, Warn, \"looping on a map using `iter` when `keys` or `values` would do\" }\n+declare_lint! {\n+    pub FOR_KV_MAP,\n+    Warn,\n+    \"looping on a map using `iter` when `keys` or `values` would do\"\n+}\n \n #[derive(Copy, Clone)]\n pub struct LoopsPass;"}, {"sha": "d47739863993e5653dba47a94729474c67478107", "filename": "src/map_clone.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmap_clone.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -11,9 +11,11 @@ use utils::{walk_ptrs_ty, walk_ptrs_ty_depth};\n /// **Known problems:** None\n ///\n /// **Example:** `x.map(|e| e.clone());`\n-declare_lint!(pub MAP_CLONE, Warn,\n-              \"using `.map(|x| x.clone())` to clone an iterator or option's contents (recommends \\\n-              `.cloned()` instead)\");\n+declare_lint! {\n+    pub MAP_CLONE, Warn,\n+    \"using `.map(|x| x.clone())` to clone an iterator or option's contents (recommends \\\n+     `.cloned()` instead)\"\n+}\n \n #[derive(Copy, Clone)]\n pub struct MapClonePass;"}, {"sha": "fb0663117fa62ccdfacc6026b36d01c97a5b1fbe", "filename": "src/matches.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -24,9 +24,11 @@ use utils::{match_type, snippet, span_lint, span_note_and_lint, span_lint_and_th\n ///     _ => ()\n /// }\n /// ```\n-declare_lint!(pub SINGLE_MATCH, Warn,\n-              \"a match statement with a single nontrivial arm (i.e, where the other arm \\\n-               is `_ => {}`) is used; recommends `if let` instead\");\n+declare_lint! {\n+    pub SINGLE_MATCH, Warn,\n+    \"a match statement with a single nontrivial arm (i.e, where the other arm \\\n+     is `_ => {}`) is used; recommends `if let` instead\"\n+}\n \n /// **What it does:** This lint checks for matches with a two arms where an `if let` will usually suffice. It is `Allow` by default.\n ///\n@@ -41,9 +43,11 @@ declare_lint!(pub SINGLE_MATCH, Warn,\n ///     _ => bar(other_ref),\n /// }\n /// ```\n-declare_lint!(pub SINGLE_MATCH_ELSE, Allow,\n-             \"a match statement with a two arms where the second arm's pattern is a wildcard; \\\n-              recommends `if let` instead\");\n+declare_lint! {\n+    pub SINGLE_MATCH_ELSE, Allow,\n+    \"a match statement with a two arms where the second arm's pattern is a wildcard; \\\n+     recommends `if let` instead\"\n+}\n \n /// **What it does:** This lint checks for matches where all arms match a reference, suggesting to remove the reference and deref the matched expression instead. It also checks for `if let &foo = bar` blocks. It is `Warn` by default.\n ///\n@@ -60,9 +64,11 @@ declare_lint!(pub SINGLE_MATCH_ELSE, Allow,\n ///     _ => frob(&x),\n /// }\n /// ```\n-declare_lint!(pub MATCH_REF_PATS, Warn,\n-              \"a match or `if let` has all arms prefixed with `&`; the match expression can be \\\n-               dereferenced instead\");\n+declare_lint! {\n+    pub MATCH_REF_PATS, Warn,\n+    \"a match or `if let` has all arms prefixed with `&`; the match expression can be \\\n+     dereferenced instead\"\n+}\n \n /// **What it does:** This lint checks for matches where match expression is a `bool`. It suggests to replace the expression with an `if...else` block. It is `Warn` by default.\n ///\n@@ -79,8 +85,10 @@ declare_lint!(pub MATCH_REF_PATS, Warn,\n ///     false => bar(),\n /// }\n /// ```\n-declare_lint!(pub MATCH_BOOL, Warn,\n-              \"a match on boolean expression; recommends `if..else` block instead\");\n+declare_lint! {\n+    pub MATCH_BOOL, Warn,\n+    \"a match on boolean expression; recommends `if..else` block instead\"\n+}\n \n /// **What it does:** This lint checks for overlapping match arms. It is `Warn` by default.\n ///\n@@ -98,8 +106,9 @@ declare_lint!(pub MATCH_BOOL, Warn,\n ///     _ => (),\n /// }\n /// ```\n-declare_lint!(pub MATCH_OVERLAPPING_ARM, Warn,\n-              \"a match has overlapping arms\");\n+declare_lint! {\n+    pub MATCH_OVERLAPPING_ARM, Warn, \"a match has overlapping arms\"\n+}\n \n #[allow(missing_copy_implementations)]\n pub struct MatchPass;"}, {"sha": "4cd957d0fe72138acde06440f85eb00fc7d39513", "filename": "src/methods.rs", "status": "modified", "additions": 72, "deletions": 40, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -25,8 +25,10 @@ pub struct MethodsPass;\n /// **Known problems:** None\n ///\n /// **Example:** `x.unwrap()`\n-declare_lint!(pub OPTION_UNWRAP_USED, Allow,\n-              \"using `Option.unwrap()`, which should at least get a better message using `expect()`\");\n+declare_lint! {\n+    pub OPTION_UNWRAP_USED, Allow,\n+    \"using `Option.unwrap()`, which should at least get a better message using `expect()`\"\n+}\n \n /// **What it does:** This lint checks for `.unwrap()` calls on `Result`s. It is `Allow` by default.\n ///\n@@ -37,8 +39,10 @@ declare_lint!(pub OPTION_UNWRAP_USED, Allow,\n /// **Known problems:** None\n ///\n /// **Example:** `x.unwrap()`\n-declare_lint!(pub RESULT_UNWRAP_USED, Allow,\n-              \"using `Result.unwrap()`, which might be better handled\");\n+declare_lint! {\n+    pub RESULT_UNWRAP_USED, Allow,\n+    \"using `Result.unwrap()`, which might be better handled\"\n+}\n \n /// **What it does:** This lint checks for `.to_string()` method calls on values of type `&str`. It is `Warn` by default.\n ///\n@@ -47,8 +51,10 @@ declare_lint!(pub RESULT_UNWRAP_USED, Allow,\n /// **Known problems:** None\n ///\n /// **Example:** `s.to_string()` where `s: &str`\n-declare_lint!(pub STR_TO_STRING, Warn,\n-              \"using `to_string()` on a str, which should be `to_owned()`\");\n+declare_lint! {\n+    pub STR_TO_STRING, Warn,\n+    \"using `to_string()` on a str, which should be `to_owned()`\"\n+}\n \n /// **What it does:** This lint checks for `.to_string()` method calls on values of type `String`. It is `Warn` by default.\n ///\n@@ -58,8 +64,10 @@ declare_lint!(pub STR_TO_STRING, Warn,\n /// **Known problems:** None\n ///\n /// **Example:** `s.to_string()` where `s: String`\n-declare_lint!(pub STRING_TO_STRING, Warn,\n-              \"calling `String::to_string` which is inefficient\");\n+declare_lint! {\n+    pub STRING_TO_STRING, Warn,\n+    \"calling `String::to_string` which is inefficient\"\n+}\n \n /// **What it does:** This lint checks for methods that should live in a trait implementation of a `std` trait (see [llogiq's blog post](http://llogiq.github.io/2015/07/30/traits.html) for further information) instead of an inherent implementation. It is `Warn` by default.\n ///\n@@ -74,8 +82,10 @@ declare_lint!(pub STRING_TO_STRING, Warn,\n ///    fn add(&self, other: &X) -> X { .. }\n /// }\n /// ```\n-declare_lint!(pub SHOULD_IMPLEMENT_TRAIT, Warn,\n-              \"defining a method that should be implementing a std trait\");\n+declare_lint! {\n+    pub SHOULD_IMPLEMENT_TRAIT, Warn,\n+    \"defining a method that should be implementing a std trait\"\n+}\n \n /// **What it does:** This lint checks for methods with certain name prefixes and `Warn`s (by default) if the prefix doesn't match how self is taken. The actual rules are:\n ///\n@@ -98,9 +108,11 @@ declare_lint!(pub SHOULD_IMPLEMENT_TRAIT, Warn,\n ///     fn as_str(self) -> &str { .. }\n /// }\n /// ```\n-declare_lint!(pub WRONG_SELF_CONVENTION, Warn,\n-              \"defining a method named with an established prefix (like \\\"into_\\\") that takes \\\n-               `self` with the wrong convention\");\n+declare_lint! {\n+    pub WRONG_SELF_CONVENTION, Warn,\n+    \"defining a method named with an established prefix (like \\\"into_\\\") that takes \\\n+     `self` with the wrong convention\"\n+}\n \n /// **What it does:** This is the same as [`wrong_self_convention`](#wrong_self_convention), but for public items. This lint is `Allow` by default.\n ///\n@@ -114,9 +126,11 @@ declare_lint!(pub WRONG_SELF_CONVENTION, Warn,\n ///     pub fn as_str(self) -> &str { .. }\n /// }\n /// ```\n-declare_lint!(pub WRONG_PUB_SELF_CONVENTION, Allow,\n-              \"defining a public method named with an established prefix (like \\\"into_\\\") that takes \\\n-               `self` with the wrong convention\");\n+declare_lint! {\n+    pub WRONG_PUB_SELF_CONVENTION, Allow,\n+    \"defining a public method named with an established prefix (like \\\"into_\\\") that takes \\\n+     `self` with the wrong convention\"\n+}\n \n /// **What it does:** This lint `Warn`s on using `ok().expect(..)`.\n ///\n@@ -125,9 +139,11 @@ declare_lint!(pub WRONG_PUB_SELF_CONVENTION, Allow,\n /// **Known problems:** None.\n ///\n /// **Example:** `x.ok().expect(\"why did I do this again?\")`\n-declare_lint!(pub OK_EXPECT, Warn,\n-              \"using `ok().expect()`, which gives worse error messages than \\\n-               calling `expect` directly on the Result\");\n+declare_lint! {\n+    pub OK_EXPECT, Warn,\n+    \"using `ok().expect()`, which gives worse error messages than \\\n+     calling `expect` directly on the Result\"\n+}\n \n /// **What it does:** This lint `Warn`s on `_.map(_).unwrap_or(_)`.\n ///\n@@ -136,9 +152,11 @@ declare_lint!(pub OK_EXPECT, Warn,\n /// **Known problems:** None.\n ///\n /// **Example:** `x.map(|a| a + 1).unwrap_or(0)`\n-declare_lint!(pub OPTION_MAP_UNWRAP_OR, Warn,\n-              \"using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as \\\n-               `map_or(a, f)`\");\n+declare_lint! {\n+    pub OPTION_MAP_UNWRAP_OR, Warn,\n+    \"using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as \\\n+     `map_or(a, f)`\"\n+}\n \n /// **What it does:** This lint `Warn`s on `_.map(_).unwrap_or_else(_)`.\n ///\n@@ -147,9 +165,11 @@ declare_lint!(pub OPTION_MAP_UNWRAP_OR, Warn,\n /// **Known problems:** None.\n ///\n /// **Example:** `x.map(|a| a + 1).unwrap_or_else(some_function)`\n-declare_lint!(pub OPTION_MAP_UNWRAP_OR_ELSE, Warn,\n-              \"using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as \\\n-               `map_or_else(g, f)`\");\n+declare_lint! {\n+    pub OPTION_MAP_UNWRAP_OR_ELSE, Warn,\n+    \"using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as \\\n+     `map_or_else(g, f)`\"\n+}\n \n /// **What it does:** This lint `Warn`s on `_.filter(_).next()`.\n ///\n@@ -158,8 +178,10 @@ declare_lint!(pub OPTION_MAP_UNWRAP_OR_ELSE, Warn,\n /// **Known problems:** None.\n ///\n /// **Example:** `iter.filter(|x| x == 0).next()`\n-declare_lint!(pub FILTER_NEXT, Warn,\n-              \"using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\");\n+declare_lint! {\n+    pub FILTER_NEXT, Warn,\n+    \"using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\"\n+}\n \n /// **What it does:** This lint `Warn`s on an iterator search (such as `find()`, `position()`, or\n /// `rposition()`) followed by a call to `is_some()`.\n@@ -169,9 +191,11 @@ declare_lint!(pub FILTER_NEXT, Warn,\n /// **Known problems:** None.\n ///\n /// **Example:** `iter.find(|x| x == 0).is_some()`\n-declare_lint!(pub SEARCH_IS_SOME, Warn,\n-              \"using an iterator search followed by `is_some()`, which is more succinctly \\\n-               expressed as a call to `any()`\");\n+declare_lint! {\n+    pub SEARCH_IS_SOME, Warn,\n+    \"using an iterator search followed by `is_some()`, which is more succinctly \\\n+     expressed as a call to `any()`\"\n+}\n \n /// **What it does:** This lint `Warn`s on using `.chars().next()` on a `str` to check if it\n /// starts with a given char.\n@@ -181,8 +205,10 @@ declare_lint!(pub SEARCH_IS_SOME, Warn,\n /// **Known problems:** None.\n ///\n /// **Example:** `name.chars().next() == Some('_')`\n-declare_lint!(pub CHARS_NEXT_CMP, Warn,\n-              \"using `.chars().next()` to check if a string starts with a char\");\n+declare_lint! {\n+    pub CHARS_NEXT_CMP, Warn,\n+    \"using `.chars().next()` to check if a string starts with a char\"\n+}\n \n /// **What it does:** This lint checks for calls to `.or(foo(..))`, `.unwrap_or(foo(..))`, etc., and\n /// suggests to use `or_else`, `unwrap_or_else`, etc., or `unwrap_or_default` instead.\n@@ -203,8 +229,10 @@ declare_lint!(pub CHARS_NEXT_CMP, Warn,\n ///\n /// **Known problems:** If the function as side-effects, not calling it will change the semantic of\n /// the program, but you shouldn't rely on that anyway.\n-declare_lint!(pub OR_FUN_CALL, Warn,\n-              \"using any `*or` method when the `*or_else` would do\");\n+declare_lint! {\n+    pub OR_FUN_CALL, Warn,\n+    \"using any `*or` method when the `*or_else` would do\"\n+}\n \n /// **What it does:** This lint `Warn`s on using `.extend(s)` on a `vec` to extend the vec by a slice.\n ///\n@@ -213,8 +241,10 @@ declare_lint!(pub OR_FUN_CALL, Warn,\n /// **Known problems:** None.\n ///\n /// **Example:** `my_vec.extend(&xs)`\n-declare_lint!(pub EXTEND_FROM_SLICE, Warn,\n-              \"`.extend_from_slice(_)` is a faster way to extend a Vec by a slice\");\n+declare_lint! {\n+    pub EXTEND_FROM_SLICE, Warn,\n+    \"`.extend_from_slice(_)` is a faster way to extend a Vec by a slice\"\n+}\n \n /// **What it does:** This lint warns on using `.clone()` on a `Copy` type.\n ///\n@@ -224,8 +254,9 @@ declare_lint!(pub EXTEND_FROM_SLICE, Warn,\n /// **Known problems:** None.\n ///\n /// **Example:** `42u64.clone()`\n-declare_lint!(pub CLONE_ON_COPY, Warn,\n-              \"using `clone` on a `Copy` type\");\n+declare_lint! {\n+    pub CLONE_ON_COPY, Warn, \"using `clone` on a `Copy` type\"\n+}\n \n /// **What it does:** This lint warns on using `.clone()` on an `&&T`\n ///\n@@ -244,8 +275,9 @@ declare_lint!(pub CLONE_ON_COPY, Warn,\n /// }\n /// ```\n /// \n-declare_lint!(pub CLONE_DOUBLE_REF, Warn,\n-              \"using `clone` on `&&T`\");\n+declare_lint! {\n+    pub CLONE_DOUBLE_REF, Warn, \"using `clone` on `&&T`\"\n+}\n \n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {"}, {"sha": "2e1993455792a088cbfcea5df1f92bf343aaf448", "filename": "src/minmax.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fminmax.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -15,9 +15,10 @@ use self::MinMax::{Min, Max};\n /// **Known problems:** None\n ///\n /// **Example:** `min(0, max(100, x))` will always be equal to `0`. Probably the author meant to clamp the value between 0 and 100, but has erroneously swapped `min` and `max`.\n-declare_lint!(pub MIN_MAX, Warn,\n-    \"`min(_, max(_, _))` (or vice versa) with bounds clamping the result \\\n-    to a constant\");\n+declare_lint! {\n+    pub MIN_MAX, Warn,\n+    \"`min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\"\n+}\n \n #[allow(missing_copy_implementations)]\n pub struct MinMaxPass;"}, {"sha": "099b1797e8e1316cce6148d8577eeec1defeb646", "filename": "src/misc.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -22,10 +22,12 @@ use utils::{span_help_and_lint, walk_ptrs_ty, is_integer_literal, implements_tra\n /// **Known problems:** If the argument is dereferenced within the function, removing the `ref` will lead to errors. This can be fixed by removing the dereferences, e.g. changing `*x` to `x` within the function.\n ///\n /// **Example:** `fn foo(ref x: u8) -> bool { .. }`\n-declare_lint!(pub TOPLEVEL_REF_ARG, Warn,\n-              \"An entire binding was declared as `ref`, in a function argument (`fn foo(ref x: Bar)`), \\\n-               or a `let` statement (`let ref x = foo()`). In such cases, it is preferred to take \\\n-               references with `&`.\");\n+declare_lint! {\n+    pub TOPLEVEL_REF_ARG, Warn,\n+    \"An entire binding was declared as `ref`, in a function argument (`fn foo(ref x: Bar)`), \\\n+     or a `let` statement (`let ref x = foo()`). In such cases, it is preferred to take \\\n+     references with `&`.\"\n+}\n \n #[allow(missing_copy_implementations)]\n pub struct TopLevelRefPass;"}, {"sha": "de3c428935375bfbf9689c4ecf4dc0d7d31cd0e3", "filename": "src/misc_early.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc_early.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -15,8 +15,10 @@ use utils::{span_lint, span_help_and_lint};\n /// **Known problems:** None.\n ///\n /// **Example:** `let { a: _, b: ref b, c: _ } = ..`\n-declare_lint!(pub UNNEEDED_FIELD_PATTERN, Warn,\n-              \"Struct fields are bound to a wildcard instead of using `..`\");\n+declare_lint! {\n+    pub UNNEEDED_FIELD_PATTERN, Warn,\n+    \"Struct fields are bound to a wildcard instead of using `..`\"\n+}\n \n /// **What it does:** This lint `Warn`s on function arguments having the similar names differing by an underscore\n ///\n@@ -25,8 +27,10 @@ declare_lint!(pub UNNEEDED_FIELD_PATTERN, Warn,\n /// **Known problems:** None.\n ///\n /// **Example:** `fn foo(a: i32, _a: i32) {}`\n-declare_lint!(pub DUPLICATE_UNDERSCORE_ARGUMENT, Warn,\n-              \"Function arguments having names which only differ by an underscore\");\n+declare_lint! {\n+    pub DUPLICATE_UNDERSCORE_ARGUMENT, Warn,\n+    \"Function arguments having names which only differ by an underscore\"\n+}\n \n #[derive(Copy, Clone)]\n pub struct MiscEarly;"}, {"sha": "99c1d040fd2b4fad427f132cfd265ee2aea7ef70", "filename": "src/mut_mut.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_mut.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -11,9 +11,12 @@ use utils::{in_external_macro, span_lint};\n /// **Known problems:** None\n ///\n /// **Example:** `let x = &mut &mut y;`\n-declare_lint!(pub MUT_MUT, Allow,\n-              \"usage of double-mut refs, e.g. `&mut &mut ...` (either copy'n'paste error, \\\n-               or shows a fundamental misunderstanding of references)\");\n+declare_lint! {\n+    pub MUT_MUT,\n+    Allow,\n+    \"usage of double-mut refs, e.g. `&mut &mut ...` (either copy'n'paste error, \\\n+     or shows a fundamental misunderstanding of references)\"\n+}\n \n #[derive(Copy,Clone)]\n pub struct MutMut;"}, {"sha": "dc30f710830000a1dc0bff370e97a4741213654e", "filename": "src/panic.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpanic.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -13,7 +13,9 @@ use utils::{span_lint, in_external_macro, match_path, BEGIN_UNWIND};\n /// ```\n /// panic!(\"This panic! is probably missing a parameter there: {}\");\n /// ```\n-declare_lint!(pub PANIC_PARAMS, Warn, \"missing parameters in `panic!`\");\n+declare_lint! {\n+    pub PANIC_PARAMS, Warn, \"missing parameters in `panic!`\"\n+}\n \n #[allow(missing_copy_implementations)]\n pub struct PanicPass;"}, {"sha": "a316f183863442a1da90c38e83009f270a6ba47b", "filename": "src/precedence.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprecedence.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -15,9 +15,11 @@ use utils::{span_lint, snippet};\n /// **Examples:**\n /// * `1 << 2 + 3` equals 32, while `(1 << 2) + 3` equals 7\n /// * `-1i32.abs()` equals -1, while `(-1i32).abs()` equals 1\n-declare_lint!(pub PRECEDENCE, Warn,\n-              \"catches operations where precedence may be unclear. See the wiki for a \\\n-               list of cases caught\");\n+declare_lint! {\n+    pub PRECEDENCE, Warn,\n+    \"catches operations where precedence may be unclear. See the wiki for a \\\n+     list of cases caught\"\n+}\n \n #[derive(Copy,Clone)]\n pub struct Precedence;"}, {"sha": "0b0c4d14bdfe1d6d83ca8f4ffa7375ac3dde8132", "filename": "src/returns.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freturns.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -13,18 +13,23 @@ use utils::{span_lint, span_lint_and_then, snippet_opt, match_path_ast, in_exter\n /// **Known problems:** None\n ///\n /// **Example:** `fn foo(x: usize) { return x; }`\n-declare_lint!(pub NEEDLESS_RETURN, Warn,\n-              \"using a return statement like `return expr;` where an expression would suffice\");\n+declare_lint! {\n+    pub NEEDLESS_RETURN, Warn,\n+    \"using a return statement like `return expr;` where an expression would suffice\"\n+}\n+\n /// **What it does:** This lint checks for `let`-bindings, which are subsequently returned. It is `Warn` by default.\n ///\n /// **Why is this bad?** It is just extraneous code. Remove it to make your code more rusty.\n ///\n /// **Known problems:** None\n ///\n /// **Example:** `{ let x = ..; x }`\n-declare_lint!(pub LET_AND_RETURN, Warn,\n-              \"creating a let-binding and then immediately returning it like `let x = expr; x` at \\\n-               the end of a block\");\n+declare_lint! {\n+    pub LET_AND_RETURN, Warn,\n+    \"creating a let-binding and then immediately returning it like `let x = expr; x` at \\\n+     the end of a block\"\n+}\n \n #[derive(Copy, Clone)]\n pub struct ReturnPass;"}, {"sha": "f772f97c81e88ce220b69421074584e5fa846e0c", "filename": "src/shadow.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -16,27 +16,35 @@ use utils::{is_from_for_desugar, in_external_macro, snippet, span_lint, span_not\n /// **Known problems:** This lint, as the other shadowing related lints, currently only catches very simple patterns.\n ///\n /// **Example:** `let x = &x;`\n-declare_lint!(pub SHADOW_SAME, Allow,\n-    \"rebinding a name to itself, e.g. `let mut x = &mut x`\");\n+declare_lint! {\n+    pub SHADOW_SAME, Allow,\n+    \"rebinding a name to itself, e.g. `let mut x = &mut x`\"\n+}\n+\n /// **What it does:** This lint checks for bindings that shadow other bindings already in scope, while reusing the original value. It is `Allow` by default.\n ///\n /// **Why is this bad?** Not too much, in fact it's a common pattern in Rust code. Still, some argue that name shadowing like this hurts readability, because a value may be bound to different things depending on position in the code.\n ///\n /// **Known problems:** This lint, as the other shadowing related lints, currently only catches very simple patterns.\n ///\n /// **Example:** `let x = x + 1;`\n-declare_lint!(pub SHADOW_REUSE, Allow,\n+declare_lint! {\n+    pub SHADOW_REUSE, Allow,\n     \"rebinding a name to an expression that re-uses the original value, e.g. \\\n-    `let x = x + 1`\");\n+    `let x = x + 1`\"\n+}\n+\n /// **What it does:** This lint checks for bindings that shadow other bindings already in scope, either without a initialization or with one that does not even use the original value. This lint is `Warn` by default.\n ///\n /// **Why is this bad?** Name shadowing can hurt readability, especially in large code bases, because it is easy to lose track of the active binding at any place in the code. This can be alleviated by either giving more specific names to bindings ore introducing more scopes to contain the bindings.\n ///\n /// **Known problems:** This lint, as the other shadowing related lints, currently only catches very simple patterns.\n ///\n /// **Example:** `let x = y; let x = z; // shadows the earlier binding`\n-declare_lint!(pub SHADOW_UNRELATED, Allow,\n-    \"The name is re-bound without even using the original value\");\n+declare_lint! {\n+    pub SHADOW_UNRELATED, Allow,\n+    \"The name is re-bound without even using the original value\"\n+}\n \n #[derive(Copy, Clone)]\n pub struct ShadowPass;"}, {"sha": "bb1201547b38aa6a298d9e0429b2ac19cca024a5", "filename": "src/types.rs", "status": "modified", "additions": 48, "deletions": 23, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -22,8 +22,10 @@ pub struct TypePass;\n /// **Known problems:** None\n ///\n /// **Example:** `struct X { values: Box<Vec<Foo>> }`\n-declare_lint!(pub BOX_VEC, Warn,\n-              \"usage of `Box<Vec<T>>`, vector elements are already on the heap\");\n+declare_lint! {\n+    pub BOX_VEC, Warn,\n+    \"usage of `Box<Vec<T>>`, vector elements are already on the heap\"\n+}\n \n /// **What it does:** This lint checks for usage of any `LinkedList`, suggesting to use a `Vec` or a `VecDeque` (formerly called `RingBuf`). It is `Warn` by default.\n ///\n@@ -36,9 +38,11 @@ declare_lint!(pub BOX_VEC, Warn,\n /// **Known problems:** False positives \u2013 the instances where using a `LinkedList` makes sense are few and far between, but they can still happen.\n ///\n /// **Example:** `let x = LinkedList::new();`\n-declare_lint!(pub LINKEDLIST, Warn,\n-              \"usage of LinkedList, usually a vector is faster, or a more specialized data \\\n-               structure like a VecDeque\");\n+declare_lint! {\n+    pub LINKEDLIST, Warn,\n+    \"usage of LinkedList, usually a vector is faster, or a more specialized data \\\n+     structure like a VecDeque\"\n+}\n \n impl LintPass for TypePass {\n     fn get_lints(&self) -> LintArray {\n@@ -81,8 +85,10 @@ pub struct LetPass;\n /// **Known problems:** None\n ///\n /// **Example:** `let x = { 1; };`\n-declare_lint!(pub LET_UNIT_VALUE, Warn,\n-              \"creating a let binding to a value of unit type, which usually can't be used afterwards\");\n+declare_lint! {\n+    pub LET_UNIT_VALUE, Warn,\n+    \"creating a let binding to a value of unit type, which usually can't be used afterwards\"\n+}\n \n fn check_let_unit(cx: &LateContext, decl: &Decl) {\n     if let DeclLocal(ref local) = decl.node {\n@@ -122,8 +128,10 @@ impl LateLintPass for LetPass {\n /// **Known problems:** None\n ///\n /// **Example:** `if { foo(); } == { bar(); } { baz(); }` is equal to `{ foo(); bar(); baz(); }`\n-declare_lint!(pub UNIT_CMP, Warn,\n-              \"comparing unit values (which is always `true` or `false`, respectively)\");\n+declare_lint! {\n+    pub UNIT_CMP, Warn,\n+    \"comparing unit values (which is always `true` or `false`, respectively)\"\n+}\n \n #[allow(missing_copy_implementations)]\n pub struct UnitCmp;\n@@ -169,35 +177,46 @@ pub struct CastPass;\n /// **Known problems:** None\n ///\n /// **Example:** `let x = u64::MAX; x as f64`\n-declare_lint!(pub CAST_PRECISION_LOSS, Allow,\n-              \"casts that cause loss of precision, e.g `x as f32` where `x: u64`\");\n+declare_lint! {\n+    pub CAST_PRECISION_LOSS, Allow,\n+    \"casts that cause loss of precision, e.g `x as f32` where `x: u64`\"\n+}\n+\n /// **What it does:** This lint checks for casts from a signed to an unsigned numerical type. In this case, negative values wrap around to large positive values, which can be quite surprising in practice. However, as the cast works as defined, this lint is `Allow` by default.\n ///\n /// **Why is this bad?** Possibly surprising results. You can activate this lint as a one-time check to see where numerical wrapping can arise.\n ///\n /// **Known problems:** None\n ///\n /// **Example:** `let y : i8 = -1; y as u64` will return 18446744073709551615\n-declare_lint!(pub CAST_SIGN_LOSS, Allow,\n-              \"casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\");\n+declare_lint! {\n+    pub CAST_SIGN_LOSS, Allow,\n+    \"casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\"\n+}\n+\n /// **What it does:** This lint checks for on casts between numerical types that may truncate large values. This is expected behavior, so the cast is `Allow` by default.\n ///\n /// **Why is this bad?** In some problem domains, it is good practice to avoid truncation. This lint can be activated to help assess where additional checks could be beneficial.\n ///\n /// **Known problems:** None\n ///\n /// **Example:** `fn as_u8(x: u64) -> u8 { x as u8 }`\n-declare_lint!(pub CAST_POSSIBLE_TRUNCATION, Allow,\n-              \"casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, or `x as i32` where `x: f32`\");\n+declare_lint! {\n+    pub CAST_POSSIBLE_TRUNCATION, Allow,\n+    \"casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, or `x as i32` where `x: f32`\"\n+}\n+\n /// **What it does:** This lint checks for casts from an unsigned type to a signed type of the same size. Performing such a cast is a 'no-op' for the compiler, i.e. nothing is changed at the bit level, and the binary representation of the value is reinterpreted. This can cause wrapping if the value is too big for the target signed type. However, the cast works as defined, so this lint is `Allow` by default.\n ///\n /// **Why is this bad?** While such a cast is not bad in itself, the results can be surprising when this is not the intended behavior, as demonstrated by the example below.\n ///\n /// **Known problems:** None\n ///\n /// **Example:** `u32::MAX as i32` will yield a value of `-1`.\n-declare_lint!(pub CAST_POSSIBLE_WRAP, Allow,\n-              \"casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x > i32::MAX`\");\n+declare_lint! {\n+    pub CAST_POSSIBLE_WRAP, Allow,\n+    \"casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x > i32::MAX`\"\n+}\n \n /// Returns the size in bits of an integral type.\n /// Will return 0 if the type is not an int or uint variant\n@@ -393,8 +412,10 @@ impl LateLintPass for CastPass {\n /// **Known problems:** None\n ///\n /// **Example:** `struct Foo { inner: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>> }`\n-declare_lint!(pub TYPE_COMPLEXITY, Warn,\n-              \"usage of very complex types; recommends factoring out parts into `type` definitions\");\n+declare_lint! {\n+    pub TYPE_COMPLEXITY, Warn,\n+    \"usage of very complex types; recommends factoring out parts into `type` definitions\"\n+}\n \n #[allow(missing_copy_implementations)]\n pub struct TypeComplexityPass;\n@@ -525,8 +546,10 @@ impl<'v> Visitor<'v> for TypeComplexityVisitor {\n /// **Known problems:** None\n ///\n /// **Example:** `'x' as u8`\n-declare_lint!(pub CHAR_LIT_AS_U8, Warn,\n-              \"Casting a character literal to u8\");\n+declare_lint! {\n+    pub CHAR_LIT_AS_U8, Warn,\n+    \"Casting a character literal to u8\"\n+}\n \n pub struct CharLitAsU8;\n \n@@ -565,8 +588,10 @@ impl LateLintPass for CharLitAsU8 {\n /// **Known problems:** None\n ///\n /// **Example:** `vec.len() <= 0`\n-declare_lint!(pub ABSURD_UNSIGNED_COMPARISONS, Warn,\n-              \"testing whether an unsigned integer is non-positive\");\n+declare_lint! {\n+    pub ABSURD_UNSIGNED_COMPARISONS, Warn,\n+    \"testing whether an unsigned integer is non-positive\"\n+}\n \n pub struct AbsurdUnsignedComparisons;\n "}, {"sha": "92d365f0323c38371e201c3dd44d89a22fcc7ed8", "filename": "src/unicode.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funicode.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -15,28 +15,36 @@ use utils::{snippet, span_help_and_lint};\n /// **Known problems:** None\n ///\n /// **Example:** You don't see it, but there may be a zero-width space somewhere in this text.\n-declare_lint!{ pub ZERO_WIDTH_SPACE, Deny,\n-               \"using a zero-width space in a string literal, which is confusing\" }\n+declare_lint! {\n+    pub ZERO_WIDTH_SPACE, Deny,\n+    \"using a zero-width space in a string literal, which is confusing\"\n+}\n+\n /// **What it does:** This lint checks for non-ascii characters in string literals. It is `Allow` by default.\n ///\n /// **Why is this bad?** Yeah, we know, the 90's called and wanted their charset back. Even so, there still are editors and other programs out there that don't work well with unicode. So if the code is meant to be used internationally, on multiple operating systems, or has other portability requirements, activating this lint could be useful.\n ///\n /// **Known problems:** None\n ///\n /// **Example:** `let x = \"H\u00e4?\"`\n-declare_lint!{ pub NON_ASCII_LITERAL, Allow,\n-               \"using any literal non-ASCII chars in a string literal; suggests \\\n-                using the \\\\u escape instead\" }\n+declare_lint! {\n+    pub NON_ASCII_LITERAL, Allow,\n+    \"using any literal non-ASCII chars in a string literal; suggests \\\n+     using the \\\\u escape instead\"\n+}\n+\n /// **What it does:** This lint checks for string literals that contain unicode in a form that is not equal to its [NFC-recomposition](http://www.unicode.org/reports/tr15/#Norm_Forms). This lint is `Allow` by default.\n ///\n /// **Why is this bad?** If such a string is compared to another, the results may be surprising.\n ///\n /// **Known problems** None\n ///\n /// **Example:** You may not see it, but \"a\u0300\" and \"\u00e0\" aren't the same string. The former when escaped is actually \"a\\u{300}\" while the latter is \"\\u{e0}\".\n-declare_lint!{ pub UNICODE_NOT_NFC, Allow,\n-               \"using a unicode literal not in NFC normal form (see \\\n-               http://www.unicode.org/reports/tr15/ for further information)\" }\n+declare_lint! {\n+    pub UNICODE_NOT_NFC, Allow,\n+    \"using a unicode literal not in NFC normal form (see \\\n+     http://www.unicode.org/reports/tr15/ for further information)\"\n+}\n \n \n #[derive(Copy, Clone)]"}, {"sha": "9c5c07cd6783be998ddfd0d7356e8c5a28cc671c", "filename": "src/zero_div_zero.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f245f6c951e6dca16dd02851237e5f271a31d0/src%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fzero_div_zero.rs?ref=13f245f6c951e6dca16dd02851237e5f271a31d0", "patch": "@@ -16,8 +16,11 @@ pub struct ZeroDivZeroPass;\n /// **Known problems:** None\n ///\n /// **Example** `0.0f32 / 0.0`\n-declare_lint!(pub ZERO_DIVIDED_BY_ZERO, Warn,\n-              \"usage of `0.0 / 0.0` to obtain NaN instead of std::f32::NaN or std::f64::NaN\");\n+declare_lint! {\n+    pub ZERO_DIVIDED_BY_ZERO,\n+    Warn,\n+    \"usage of `0.0 / 0.0` to obtain NaN instead of std::f32::NaN or std::f64::NaN\"\n+}\n \n impl LintPass for ZeroDivZeroPass {\n     fn get_lints(&self) -> LintArray {"}]}