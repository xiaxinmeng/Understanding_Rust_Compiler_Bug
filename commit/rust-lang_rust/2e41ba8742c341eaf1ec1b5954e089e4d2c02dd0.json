{"sha": "2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlNDFiYTg3NDJjMzQxZWFmMWVjMWI1OTU0ZTA4OWU0ZDJjMDJkZDA=", "commit": {"author": {"name": "Tim Vermeulen", "email": "tvermeulen@me.com", "date": "2019-07-06T21:22:20Z"}, "committer": {"name": "Tim Vermeulen", "email": "tvermeulen@me.com", "date": "2019-07-29T00:40:50Z"}, "message": "Use internal iteration in the Sum and Product impls of Result and Option", "tree": {"sha": "18eff9da3d21d47a8c64f992c33e88d76f24fdfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18eff9da3d21d47a8c64f992c33e88d76f24fdfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0", "html_url": "https://github.com/rust-lang/rust/commit/2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0/comments", "author": {"login": "timvermeulen", "id": 2904179, "node_id": "MDQ6VXNlcjI5MDQxNzk=", "avatar_url": "https://avatars.githubusercontent.com/u/2904179?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timvermeulen", "html_url": "https://github.com/timvermeulen", "followers_url": "https://api.github.com/users/timvermeulen/followers", "following_url": "https://api.github.com/users/timvermeulen/following{/other_user}", "gists_url": "https://api.github.com/users/timvermeulen/gists{/gist_id}", "starred_url": "https://api.github.com/users/timvermeulen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timvermeulen/subscriptions", "organizations_url": "https://api.github.com/users/timvermeulen/orgs", "repos_url": "https://api.github.com/users/timvermeulen/repos", "events_url": "https://api.github.com/users/timvermeulen/events{/privacy}", "received_events_url": "https://api.github.com/users/timvermeulen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "timvermeulen", "id": 2904179, "node_id": "MDQ6VXNlcjI5MDQxNzk=", "avatar_url": "https://avatars.githubusercontent.com/u/2904179?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timvermeulen", "html_url": "https://github.com/timvermeulen", "followers_url": "https://api.github.com/users/timvermeulen/followers", "following_url": "https://api.github.com/users/timvermeulen/following{/other_user}", "gists_url": "https://api.github.com/users/timvermeulen/gists{/gist_id}", "starred_url": "https://api.github.com/users/timvermeulen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timvermeulen/subscriptions", "organizations_url": "https://api.github.com/users/timvermeulen/orgs", "repos_url": "https://api.github.com/users/timvermeulen/repos", "events_url": "https://api.github.com/users/timvermeulen/events{/privacy}", "received_events_url": "https://api.github.com/users/timvermeulen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4560cb830fce63fcffdc4558f4281aaac6a3a1ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/4560cb830fce63fcffdc4558f4281aaac6a3a1ba", "html_url": "https://github.com/rust-lang/rust/commit/4560cb830fce63fcffdc4558f4281aaac6a3a1ba"}], "stats": {"total": 186, "additions": 67, "deletions": 119}, "files": [{"sha": "2a8286d29b80c73091d7549a8ab2418e523641ab", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 37, "deletions": 109, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0", "patch": "@@ -2063,137 +2063,65 @@ impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n impl<I: FusedIterator, F> FusedIterator for Inspect<I, F>\n     where F: FnMut(&I::Item) {}\n \n-/// An iterator adapter that produces output as long as the underlying\n-/// iterator produces `Option::Some` values.\n-pub(crate) struct OptionShunt<I> {\n-    iter: I,\n-    exited_early: bool,\n-}\n-\n-impl<I, T> OptionShunt<I>\n-where\n-    I: Iterator<Item = Option<T>>,\n-{\n-    /// Process the given iterator as if it yielded a `T` instead of a\n-    /// `Option<T>`. Any `None` value will stop the inner iterator and\n-    /// the overall result will be a `None`.\n-    pub fn process<F, U>(iter: I, mut f: F) -> Option<U>\n-    where\n-        F: FnMut(&mut Self) -> U,\n-    {\n-        let mut shunt = OptionShunt::new(iter);\n-        let value = f(shunt.by_ref());\n-        shunt.reconstruct(value)\n-    }\n-\n-    fn new(iter: I) -> Self {\n-        OptionShunt {\n-            iter,\n-            exited_early: false,\n-        }\n-    }\n-\n-    /// Consume the adapter and rebuild a `Option` value.\n-    fn reconstruct<U>(self, val: U) -> Option<U> {\n-        if self.exited_early {\n-            None\n-        } else {\n-            Some(val)\n-        }\n-    }\n-}\n-\n-impl<I, T> Iterator for OptionShunt<I>\n-where\n-    I: Iterator<Item = Option<T>>,\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        match self.iter.next() {\n-            Some(Some(v)) => Some(v),\n-            Some(None) => {\n-                self.exited_early = true;\n-                None\n-            }\n-            None => None,\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.exited_early {\n-            (0, Some(0))\n-        } else {\n-            let (_, upper) = self.iter.size_hint();\n-            (0, upper)\n-        }\n-    }\n-}\n-\n /// An iterator adapter that produces output as long as the underlying\n /// iterator produces `Result::Ok` values.\n ///\n /// If an error is encountered, the iterator stops and the error is\n-/// stored. The error may be recovered later via `reconstruct`.\n-pub(crate) struct ResultShunt<I, E> {\n+/// stored.\n+pub(crate) struct ResultShunt<'a, I, E> {\n     iter: I,\n-    error: Option<E>,\n+    error: &'a mut Result<(), E>,\n }\n \n-impl<I, T, E> ResultShunt<I, E>\n-    where I: Iterator<Item = Result<T, E>>\n+/// Process the given iterator as if it yielded a `T` instead of a\n+/// `Result<T, _>`. Any errors will stop the inner iterator and\n+/// the overall result will be an error.\n+pub(crate) fn process_results<I, T, E, F, U>(iter: I, mut f: F) -> Result<U, E>\n+where\n+    I: Iterator<Item = Result<T, E>>,\n+    for<'a> F: FnMut(ResultShunt<'a, I, E>) -> U,\n {\n-    /// Process the given iterator as if it yielded a `T` instead of a\n-    /// `Result<T, _>`. Any errors will stop the inner iterator and\n-    /// the overall result will be an error.\n-    pub fn process<F, U>(iter: I, mut f: F) -> Result<U, E>\n-        where F: FnMut(&mut Self) -> U\n-    {\n-        let mut shunt = ResultShunt::new(iter);\n-        let value = f(shunt.by_ref());\n-        shunt.reconstruct(value)\n-    }\n-\n-    fn new(iter: I) -> Self {\n-        ResultShunt {\n-            iter,\n-            error: None,\n-        }\n-    }\n-\n-    /// Consume the adapter and rebuild a `Result` value. This should\n-    /// *always* be called, otherwise any potential error would be\n-    /// lost.\n-    fn reconstruct<U>(self, val: U) -> Result<U, E> {\n-        match self.error {\n-            None => Ok(val),\n-            Some(e) => Err(e),\n-        }\n-    }\n+    let mut error = Ok(());\n+    let shunt = ResultShunt {\n+        iter,\n+        error: &mut error,\n+    };\n+    let value = f(shunt);\n+    error.map(|()| value)\n }\n \n-impl<I, T, E> Iterator for ResultShunt<I, E>\n+impl<I, T, E> Iterator for ResultShunt<'_, I, E>\n     where I: Iterator<Item = Result<T, E>>\n {\n     type Item = T;\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        match self.iter.next() {\n-            Some(Ok(v)) => Some(v),\n-            Some(Err(e)) => {\n-                self.error = Some(e);\n-                None\n-            }\n-            None => None,\n-        }\n+        self.find(|_| true)\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.error.is_some() {\n+        if self.error.is_err() {\n             (0, Some(0))\n         } else {\n             let (_, upper) = self.iter.size_hint();\n             (0, upper)\n         }\n     }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        let error = &mut *self.error;\n+        self.iter\n+            .try_fold(init, |acc, x| match x {\n+                Ok(x) => LoopState::from_try(f(acc, x)),\n+                Err(e) => {\n+                    *error = Err(e);\n+                    LoopState::Break(Try::from_ok(acc))\n+                }\n+            })\n+            .into_try()\n+    }\n }"}, {"sha": "aba8e84d58be553566165846b39eb2990f2da84b", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0", "patch": "@@ -360,7 +360,7 @@ pub use self::adapters::Flatten;\n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n pub use self::adapters::Copied;\n \n-pub(crate) use self::adapters::{TrustedRandomAccess, OptionShunt, ResultShunt};\n+pub(crate) use self::adapters::{TrustedRandomAccess, process_results};\n \n mod range;\n mod sources;"}, {"sha": "812463e77f9767476c4ae42b474db34a8e88b339", "filename": "src/libcore/iter/traits/accum.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0", "patch": "@@ -1,6 +1,6 @@\n use crate::ops::{Mul, Add};\n use crate::num::Wrapping;\n-use crate::iter::adapters::{OptionShunt, ResultShunt};\n+use crate::iter;\n \n /// Trait to represent types that can be created by summing up an iterator.\n ///\n@@ -139,7 +139,7 @@ impl<T, U, E> Sum<Result<U, E>> for Result<T, E>\n     fn sum<I>(iter: I) -> Result<T, E>\n         where I: Iterator<Item = Result<U, E>>,\n     {\n-        ResultShunt::process(iter, |i| i.sum())\n+        iter::process_results(iter, |i| i.sum())\n     }\n }\n \n@@ -153,7 +153,7 @@ impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n     fn product<I>(iter: I) -> Result<T, E>\n         where I: Iterator<Item = Result<U, E>>,\n     {\n-        ResultShunt::process(iter, |i| i.product())\n+        iter::process_results(iter, |i| i.product())\n     }\n }\n \n@@ -180,7 +180,7 @@ where\n     where\n         I: Iterator<Item = Option<U>>,\n     {\n-        OptionShunt::process(iter, |i| i.sum())\n+        iter.map(|x| x.ok_or(())).sum::<Result<_, _>>().ok()\n     }\n }\n \n@@ -196,6 +196,6 @@ where\n     where\n         I: Iterator<Item = Option<U>>,\n     {\n-        OptionShunt::process(iter, |i| i.product())\n+        iter.map(|x| x.ok_or(())).product::<Result<_, _>>().ok()\n     }\n }"}, {"sha": "693ec0053223e1280e7acf3071eac171860356db", "filename": "src/libcore/option.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0", "patch": "@@ -135,7 +135,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::iter::{FromIterator, FusedIterator, TrustedLen, OptionShunt};\n+use crate::iter::{FromIterator, FusedIterator, TrustedLen};\n use crate::{convert, fmt, hint, mem, ops::{self, Deref, DerefMut}};\n use crate::pin::Pin;\n \n@@ -1499,7 +1499,10 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n-        OptionShunt::process(iter.into_iter(), |i| i.collect())\n+        iter.into_iter()\n+            .map(|x| x.ok_or(()))\n+            .collect::<Result<_, _>>()\n+            .ok()\n     }\n }\n "}, {"sha": "8c60a9c1b501d0497aec7faea4154e086f89c16e", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0", "patch": "@@ -231,7 +231,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fmt;\n-use crate::iter::{FromIterator, FusedIterator, TrustedLen, ResultShunt};\n+use crate::iter::{self, FromIterator, FusedIterator, TrustedLen};\n use crate::ops::{self, Deref, DerefMut};\n \n /// `Result` is a type that represents either success ([`Ok`]) or failure ([`Err`]).\n@@ -1343,7 +1343,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n-        ResultShunt::process(iter.into_iter(), |i| i.collect())\n+        iter::process_results(iter.into_iter(), |i| i.collect())\n     }\n }\n "}, {"sha": "31530cc2c94c445664a6e03aebd925caab146443", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=2e41ba8742c341eaf1ec1b5954e089e4d2c02dd0", "patch": "@@ -1082,6 +1082,23 @@ fn test_iterator_sum_result() {\n     assert_eq!(v.iter().cloned().sum::<Result<i32, _>>(), Ok(10));\n     let v: &[Result<i32, ()>] = &[Ok(1), Err(()), Ok(3), Ok(4)];\n     assert_eq!(v.iter().cloned().sum::<Result<i32, _>>(), Err(()));\n+\n+    #[derive(PartialEq, Debug)]\n+    struct S(Result<i32, ()>);\n+\n+    impl Sum<Result<i32, ()>> for S {\n+        fn sum<I: Iterator<Item = Result<i32, ()>>>(mut iter: I) -> Self {\n+            // takes the sum by repeatedly calling `next` on `iter`,\n+            // thus testing that repeated calls to `ResultShunt::try_fold`\n+            // produce the expected results\n+            Self(iter.by_ref().sum())\n+        }\n+    }\n+\n+    let v: &[Result<i32, ()>] = &[Ok(1), Ok(2), Ok(3), Ok(4)];\n+    assert_eq!(v.iter().cloned().sum::<S>(), S(Ok(10)));\n+    let v: &[Result<i32, ()>] = &[Ok(1), Err(()), Ok(3), Ok(4)];\n+    assert_eq!(v.iter().cloned().sum::<S>(), S(Err(())));\n }\n \n #[test]"}]}