{"sha": "9a239ef4ded03d155c72b68b5a2dd7aff013e141", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMjM5ZWY0ZGVkMDNkMTU1YzcyYjY4YjVhMmRkN2FmZjAxM2UxNDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-28T01:03:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-28T01:03:16Z"}, "message": "Auto merge of #63057 - Centril:rollup-z3a3c6v, r=Centril\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #61207 (Allow lifetime elision in `Pin<&(mut) Self>`)\n - #62074 (squash of all commits for nth_back on ChunksMut)\n - #62771 (Break dependencies between `syntax_ext` and other crates)\n - #62883 (Refactoring use common code between option, result and accum)\n - #62949 (Re-enable assertions in PPC dist builder)\n - #62996 (tidy: Add a check for inline unit tests)\n - #63038 (Make more informative error on outer attribute after inner)\n - #63050 (ci: download awscli from our mirror)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "ddecacf7cf04b32211999b7d65dae0bbf2012102", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddecacf7cf04b32211999b7d65dae0bbf2012102"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a239ef4ded03d155c72b68b5a2dd7aff013e141", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a239ef4ded03d155c72b68b5a2dd7aff013e141", "html_url": "https://github.com/rust-lang/rust/commit/9a239ef4ded03d155c72b68b5a2dd7aff013e141", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a239ef4ded03d155c72b68b5a2dd7aff013e141/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c798dffac9dc8c82374db48f5b474690cc6e9686", "url": "https://api.github.com/repos/rust-lang/rust/commits/c798dffac9dc8c82374db48f5b474690cc6e9686", "html_url": "https://github.com/rust-lang/rust/commit/c798dffac9dc8c82374db48f5b474690cc6e9686"}, {"sha": "34c0f4698bda7e06d66ee9040a2923250b0c12d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/34c0f4698bda7e06d66ee9040a2923250b0c12d0", "html_url": "https://github.com/rust-lang/rust/commit/34c0f4698bda7e06d66ee9040a2923250b0c12d0"}], "stats": {"total": 3233, "additions": 2335, "deletions": 898}, "files": [{"sha": "1e49cc00921cd7ad5a6ff17828aa814eb93df8a4", "filename": ".azure-pipelines/steps/run.yml", "status": "modified", "additions": 5, "deletions": 37, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/.azure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/.azure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.azure-pipelines%2Fsteps%2Frun.yml?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -138,43 +138,11 @@ steps:\n \n # Ensure the `aws` CLI is installed so we can deploy later on, cache docker\n # images, etc.\n-- bash: |\n-    set -e\n-    # Temporary code to debug #62967.\n-    debug_failed_connections() {\n-        echo \"trying to ping pypi.org\"\n-        ping pypi.org -c10 || true\n-        echo \"trying to ping google.com\"\n-        ping google.com -c10 || true\n-        echo \"trying to ping 8.8.8.8\"\n-        ping 8.8.8.8 -c10 || true\n-        echo \"trying to download pypi.org\"\n-        curl https://pypi.org || true\n-        echo \"trying to download from our S3 bucket\"\n-        curl https://rust-lang-ci2.s3.amazonaws.com || true\n-        echo \"trying to dig pypi.org\"\n-        dig pypi.org || true\n-        echo \"trying to dig files.pythonhosted.org\"\n-        dig files.pythonhosted.org || true\n-        echo \"trying to connect to pypi.org with openssl\"\n-        echo | openssl s_client -connect pypi.org:443 || true\n-        echo \"trying to connect to files.pythonhosted.org with openssl\"\n-        echo | openssl s_client -connect files.pythonhosted.org:443 || true\n-    }\n-    debug_failed_connections_and_fail() {\n-        debug_failed_connections\n-        return 1\n-    }\n-    source src/ci/shared.sh\n-    sudo apt-get install -y python3-setuptools\n-    debug_failed_connections\n-    retry pip3 install -r src/ci/awscli-requirements.txt --upgrade --user || debug_failed_connections_and_fail\n-    echo \"##vso[task.prependpath]$HOME/.local/bin\"\n-  displayName: Install awscli (Linux)\n-  condition: and(succeeded(), not(variables.SKIP_JOB), eq(variables['Agent.OS'], 'Linux'))\n-- script: pip install -r src/ci/awscli-requirements.txt\n-  displayName: Install awscli (non-Linux)\n-  condition: and(succeeded(), not(variables.SKIP_JOB), ne(variables['Agent.OS'], 'Linux'))\n+- bash: src/ci/install-awscli.sh\n+  env:\n+    AGENT_OS: $(Agent.OS)\n+  condition: and(succeeded(), not(variables.SKIP_JOB))\n+  displayName: Install awscli\n \n # Configure our CI_JOB_NAME variable which log analyzers can use for the main\n # step to see what's going on."}, {"sha": "46d8b3de806ffc1ff259ab39afca12282a83452d", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -2863,31 +2863,20 @@ dependencies = [\n name = \"rustc_driver\"\n version = \"0.0.0\"\n dependencies = [\n- \"arena 0.0.0\",\n  \"env_logger 0.5.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_ast_borrowck 0.0.0\",\n  \"rustc_codegen_utils 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n- \"rustc_incremental 0.0.0\",\n  \"rustc_interface 0.0.0\",\n- \"rustc_lint 0.0.0\",\n  \"rustc_metadata 0.0.0\",\n  \"rustc_mir 0.0.0\",\n- \"rustc_passes 0.0.0\",\n- \"rustc_plugin 0.0.0\",\n- \"rustc_privacy 0.0.0\",\n- \"rustc_resolve 0.0.0\",\n  \"rustc_save_analysis 0.0.0\",\n  \"rustc_target 0.0.0\",\n- \"rustc_traits 0.0.0\",\n- \"rustc_typeck 0.0.0\",\n  \"serialize 0.0.0\",\n- \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -3019,7 +3008,6 @@ dependencies = [\n  \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"stable_deref_trait 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n- \"syntax_ext 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n \n@@ -3064,9 +3052,7 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n- \"rustc_mir 0.0.0\",\n  \"syntax 0.0.0\",\n- \"syntax_ext 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n "}, {"sha": "c1ffa525a1b41509a20416831ce605c4670f2815", "filename": "src/ci/awscli-requirements.txt", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c798dffac9dc8c82374db48f5b474690cc6e9686/src%2Fci%2Fawscli-requirements.txt", "raw_url": "https://github.com/rust-lang/rust/raw/c798dffac9dc8c82374db48f5b474690cc6e9686/src%2Fci%2Fawscli-requirements.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fawscli-requirements.txt?ref=c798dffac9dc8c82374db48f5b474690cc6e9686", "patch": "@@ -1,13 +0,0 @@\n-awscli==1.16.201\n-botocore==1.12.191\n-colorama==0.3.9\n-docutils==0.14\n-jmespath==0.9.4\n-pyasn1==0.4.5\n-python-dateutil==2.8.0\n-PyYAML==5.1\n-rsa==3.4.2\n-s3transfer==0.2.1\n-six==1.12.0\n-urllib3==1.25.3\n-futures==3.3.0; python_version < '3.0'"}, {"sha": "8c052db1b0dde9283d4b856c615ca09db410db23", "filename": "src/ci/docker/dist-powerpc-linux/Dockerfile", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -36,7 +36,3 @@ ENV HOSTS=powerpc-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n-\n-# FIXME(#36150) this will fail the bootstrap. Probably means something bad is\n-#               happening!\n-ENV NO_LLVM_ASSERTIONS 1"}, {"sha": "d491b9fbcdcf81a6ae67ac5496fe05b5f8635fb2", "filename": "src/ci/install-awscli.sh", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Fci%2Finstall-awscli.sh", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Fci%2Finstall-awscli.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Finstall-awscli.sh?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,35 @@\n+#!/bin/bash\n+# This script downloads and installs awscli from the packages mirrored in our\n+# own S3 bucket. This follows the recommendations at:\n+#\n+#    https://packaging.python.org/guides/index-mirrors-and-caches/#caching-with-pip\n+#\n+# To create a new mirrored copy you can run the command:\n+#\n+#    pip wheel awscli\n+#\n+# Before compressing please make sure all the wheels end with `-none-any.whl`.\n+# If that's not the case you'll need to remove the non-cross-platform ones and\n+# replace them with the .tar.gz downloaded from https://pypi.org. Also make\n+# sure it's possible to call this script with both Python 2 and Python 3.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+MIRROR=\"https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2019-07-27-awscli.tar\"\n+DEPS_DIR=\"/tmp/awscli-deps\"\n+\n+pip=\"pip\"\n+pipflags=\"\"\n+if [[ \"${AGENT_OS}\" == \"Linux\" ]]; then\n+    pip=\"pip3\"\n+    pipflags=\"--user\"\n+\n+    sudo apt-get install -y python3-setuptools\n+    echo \"##vso[task.prependpath]$HOME/.local/bin\"\n+fi\n+\n+mkdir -p \"${DEPS_DIR}\"\n+curl \"${MIRROR}\" | tar xf - -C \"${DEPS_DIR}\"\n+\"${pip}\" install ${pipflags} --no-index \"--find-links=${DEPS_DIR}\" awscli\n+rm -rf \"${DEPS_DIR}\""}, {"sha": "8eae52ffd3277e43a2b44048a53b83be93a72b8d", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -2062,3 +2062,138 @@ impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I: FusedIterator, F> FusedIterator for Inspect<I, F>\n     where F: FnMut(&I::Item) {}\n+\n+/// An iterator adapter that produces output as long as the underlying\n+/// iterator produces `Option::Some` values.\n+pub(crate) struct OptionShunt<I> {\n+    iter: I,\n+    exited_early: bool,\n+}\n+\n+impl<I, T> OptionShunt<I>\n+where\n+    I: Iterator<Item = Option<T>>,\n+{\n+    /// Process the given iterator as if it yielded a `T` instead of a\n+    /// `Option<T>`. Any `None` value will stop the inner iterator and\n+    /// the overall result will be a `None`.\n+    pub fn process<F, U>(iter: I, mut f: F) -> Option<U>\n+    where\n+        F: FnMut(&mut Self) -> U,\n+    {\n+        let mut shunt = OptionShunt::new(iter);\n+        let value = f(shunt.by_ref());\n+        shunt.reconstruct(value)\n+    }\n+\n+    fn new(iter: I) -> Self {\n+        OptionShunt {\n+            iter,\n+            exited_early: false,\n+        }\n+    }\n+\n+    /// Consume the adapter and rebuild a `Option` value.\n+    fn reconstruct<U>(self, val: U) -> Option<U> {\n+        if self.exited_early {\n+            None\n+        } else {\n+            Some(val)\n+        }\n+    }\n+}\n+\n+impl<I, T> Iterator for OptionShunt<I>\n+where\n+    I: Iterator<Item = Option<T>>,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self.iter.next() {\n+            Some(Some(v)) => Some(v),\n+            Some(None) => {\n+                self.exited_early = true;\n+                None\n+            }\n+            None => None,\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.exited_early {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper)\n+        }\n+    }\n+}\n+\n+/// An iterator adapter that produces output as long as the underlying\n+/// iterator produces `Result::Ok` values.\n+///\n+/// If an error is encountered, the iterator stops and the error is\n+/// stored. The error may be recovered later via `reconstruct`.\n+pub(crate) struct ResultShunt<I, E> {\n+    iter: I,\n+    error: Option<E>,\n+}\n+\n+impl<I, T, E> ResultShunt<I, E>\n+    where I: Iterator<Item = Result<T, E>>\n+{\n+    /// Process the given iterator as if it yielded a `T` instead of a\n+    /// `Result<T, _>`. Any errors will stop the inner iterator and\n+    /// the overall result will be an error.\n+    pub fn process<F, U>(iter: I, mut f: F) -> Result<U, E>\n+        where F: FnMut(&mut Self) -> U\n+    {\n+        let mut shunt = ResultShunt::new(iter);\n+        let value = f(shunt.by_ref());\n+        shunt.reconstruct(value)\n+    }\n+\n+    fn new(iter: I) -> Self {\n+        ResultShunt {\n+            iter,\n+            error: None,\n+        }\n+    }\n+\n+    /// Consume the adapter and rebuild a `Result` value. This should\n+    /// *always* be called, otherwise any potential error would be\n+    /// lost.\n+    fn reconstruct<U>(self, val: U) -> Result<U, E> {\n+        match self.error {\n+            None => Ok(val),\n+            Some(e) => Err(e),\n+        }\n+    }\n+}\n+\n+impl<I, T, E> Iterator for ResultShunt<I, E>\n+    where I: Iterator<Item = Result<T, E>>\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self.iter.next() {\n+            Some(Ok(v)) => Some(v),\n+            Some(Err(e)) => {\n+                self.error = Some(e);\n+                None\n+            }\n+            None => None,\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.error.is_some() {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper)\n+        }\n+    }\n+}"}, {"sha": "4a7d7f96b9b041c2a86acab81f9862837171e347", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -360,7 +360,7 @@ pub use self::adapters::Flatten;\n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n pub use self::adapters::Copied;\n \n-pub(crate) use self::adapters::TrustedRandomAccess;\n+pub(crate) use self::adapters::{TrustedRandomAccess, OptionShunt, ResultShunt};\n \n mod range;\n mod sources;"}, {"sha": "01b64fb08acf760da1ab29445a1e4867a8eadc8f", "filename": "src/libcore/iter/traits/accum.rs", "status": "modified", "additions": 1, "deletions": 135, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -1,5 +1,6 @@\n use crate::ops::{Mul, Add};\n use crate::num::Wrapping;\n+use crate::iter::adapters::{OptionShunt, ResultShunt};\n \n /// Trait to represent types that can be created by summing up an iterator.\n ///\n@@ -114,74 +115,6 @@ macro_rules! float_sum_product {\n integer_sum_product! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n float_sum_product! { f32 f64 }\n \n-/// An iterator adapter that produces output as long as the underlying\n-/// iterator produces `Result::Ok` values.\n-///\n-/// If an error is encountered, the iterator stops and the error is\n-/// stored. The error may be recovered later via `reconstruct`.\n-struct ResultShunt<I, E> {\n-    iter: I,\n-    error: Option<E>,\n-}\n-\n-impl<I, T, E> ResultShunt<I, E>\n-    where I: Iterator<Item = Result<T, E>>\n-{\n-    /// Process the given iterator as if it yielded a `T` instead of a\n-    /// `Result<T, _>`. Any errors will stop the inner iterator and\n-    /// the overall result will be an error.\n-    pub fn process<F, U>(iter: I, mut f: F) -> Result<U, E>\n-        where F: FnMut(&mut Self) -> U\n-    {\n-        let mut shunt = ResultShunt::new(iter);\n-        let value = f(shunt.by_ref());\n-        shunt.reconstruct(value)\n-    }\n-\n-    fn new(iter: I) -> Self {\n-        ResultShunt {\n-            iter,\n-            error: None,\n-        }\n-    }\n-\n-    /// Consume the adapter and rebuild a `Result` value. This should\n-    /// *always* be called, otherwise any potential error would be\n-    /// lost.\n-    fn reconstruct<U>(self, val: U) -> Result<U, E> {\n-        match self.error {\n-            None => Ok(val),\n-            Some(e) => Err(e),\n-        }\n-    }\n-}\n-\n-impl<I, T, E> Iterator for ResultShunt<I, E>\n-    where I: Iterator<Item = Result<T, E>>\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        match self.iter.next() {\n-            Some(Ok(v)) => Some(v),\n-            Some(Err(e)) => {\n-                self.error = Some(e);\n-                None\n-            }\n-            None => None,\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.error.is_some() {\n-            (0, Some(0))\n-        } else {\n-            let (_, upper) = self.iter.size_hint();\n-            (0, upper)\n-        }\n-    }\n-}\n-\n #[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]\n impl<T, U, E> Sum<Result<U, E>> for Result<T, E>\n     where T: Sum<U>,\n@@ -224,73 +157,6 @@ impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n     }\n }\n \n-/// An iterator adapter that produces output as long as the underlying\n-/// iterator produces `Option::Some` values.\n-struct OptionShunt<I> {\n-    iter: I,\n-    exited_early: bool,\n-}\n-\n-impl<I, T> OptionShunt<I>\n-where\n-    I: Iterator<Item = Option<T>>,\n-{\n-    /// Process the given iterator as if it yielded a `T` instead of a\n-    /// `Option<T>`. Any `None` value will stop the inner iterator and\n-    /// the overall result will be a `None`.\n-    pub fn process<F, U>(iter: I, mut f: F) -> Option<U>\n-    where\n-        F: FnMut(&mut Self) -> U,\n-    {\n-        let mut shunt = OptionShunt::new(iter);\n-        let value = f(shunt.by_ref());\n-        shunt.reconstruct(value)\n-    }\n-\n-    fn new(iter: I) -> Self {\n-        OptionShunt {\n-            iter,\n-            exited_early: false,\n-        }\n-    }\n-\n-    /// Consume the adapter and rebuild a `Option` value.\n-    fn reconstruct<U>(self, val: U) -> Option<U> {\n-        if self.exited_early {\n-            None\n-        } else {\n-            Some(val)\n-        }\n-    }\n-}\n-\n-impl<I, T> Iterator for OptionShunt<I>\n-where\n-    I: Iterator<Item = Option<T>>,\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        match self.iter.next() {\n-            Some(Some(v)) => Some(v),\n-            Some(None) => {\n-                self.exited_early = true;\n-                None\n-            }\n-            None => None,\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.exited_early {\n-            (0, Some(0))\n-        } else {\n-            let (_, upper) = self.iter.size_hint();\n-            (0, upper)\n-        }\n-    }\n-}\n-\n #[stable(feature = \"iter_arith_traits_option\", since = \"1.37.0\")]\n impl<T, U> Sum<Option<U>> for Option<T>\n where"}, {"sha": "70a87cfe5a78ab5ca87f0f90edc76ebbae526751", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 40, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -135,7 +135,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::iter::{FromIterator, FusedIterator, TrustedLen};\n+use crate::iter::{FromIterator, FusedIterator, TrustedLen, OptionShunt};\n use crate::{convert, fmt, hint, mem, ops::{self, Deref, DerefMut}};\n use crate::pin::Pin;\n \n@@ -1499,45 +1499,7 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n-        struct Adapter<Iter> {\n-            iter: Iter,\n-            found_none: bool,\n-        }\n-\n-        impl<T, Iter: Iterator<Item=Option<T>>> Iterator for Adapter<Iter> {\n-            type Item = T;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<T> {\n-                match self.iter.next() {\n-                    Some(Some(value)) => Some(value),\n-                    Some(None) => {\n-                        self.found_none = true;\n-                        None\n-                    }\n-                    None => None,\n-                }\n-            }\n-\n-            #[inline]\n-            fn size_hint(&self) -> (usize, Option<usize>) {\n-                if self.found_none {\n-                    (0, Some(0))\n-                } else {\n-                    let (_, upper) = self.iter.size_hint();\n-                    (0, upper)\n-                }\n-            }\n-        }\n-\n-        let mut adapter = Adapter { iter: iter.into_iter(), found_none: false };\n-        let v: V = FromIterator::from_iter(adapter.by_ref());\n-\n-        if adapter.found_none {\n-            None\n-        } else {\n-            Some(v)\n-        }\n+        OptionShunt::process(iter.into_iter(), |i| i.collect())\n     }\n }\n "}, {"sha": "559877ddd5a1ce0e166dd4afb5d0bf61a72fa4d6", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -231,7 +231,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fmt;\n-use crate::iter::{FromIterator, FusedIterator, TrustedLen};\n+use crate::iter::{FromIterator, FusedIterator, TrustedLen, ResultShunt};\n use crate::ops::{self, Deref, DerefMut};\n \n /// `Result` is a type that represents either success ([`Ok`]) or failure ([`Err`]).\n@@ -1343,39 +1343,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n-        struct Adapter<Iter, E> {\n-            iter: Iter,\n-            err: Option<E>,\n-        }\n-\n-        impl<T, E, Iter: Iterator<Item=Result<T, E>>> Iterator for Adapter<Iter, E> {\n-            type Item = T;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<T> {\n-                match self.iter.next() {\n-                    Some(Ok(value)) => Some(value),\n-                    Some(Err(err)) => {\n-                        self.err = Some(err);\n-                        None\n-                    }\n-                    None => None,\n-                }\n-            }\n-\n-            fn size_hint(&self) -> (usize, Option<usize>) {\n-                let (_min, max) = self.iter.size_hint();\n-                (0, max)\n-            }\n-        }\n-\n-        let mut adapter = Adapter { iter: iter.into_iter(), err: None };\n-        let v: V = FromIterator::from_iter(adapter.by_ref());\n-\n-        match adapter.err {\n-            Some(err) => Err(err),\n-            None => Ok(v),\n-        }\n+        ResultShunt::process(iter.into_iter(), |i| i.collect())\n     }\n }\n "}, {"sha": "b06511cad975ce8120bb845993792e3315354f5d", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -4339,6 +4339,25 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n             Some(tail)\n         }\n     }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            let start = (len - 1 - n) * self.chunk_size;\n+            let end = match start.checked_add(self.chunk_size) {\n+                Some(res) => cmp::min(res, self.v.len()),\n+                None => self.v.len(),\n+            };\n+            let (temp, _tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n+            let (head, nth_back) = temp.split_at_mut(start);\n+            self.v = head;\n+            Some(nth_back)\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "b046c3ce5ce6ab94a51f285be5cc4e46cc1677d7", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -222,6 +222,28 @@ fn test_chunks_mut_nth() {\n     assert_eq!(c2.next(), None);\n }\n \n+#[test]\n+fn test_chunks_mut_nth_back() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let mut c = v.chunks_mut(2);\n+    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[0, 1]);\n+\n+    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let mut c1 = v1.chunks_mut(3);\n+    assert_eq!(c1.nth_back(1).unwrap(), &[0, 1, 2]);\n+    assert_eq!(c1.next(), None);\n+\n+    let v3: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let mut c3 = v3.chunks_mut(10);\n+    assert_eq!(c3.nth_back(0).unwrap(), &[0, 1, 2, 3, 4]);\n+    assert_eq!(c3.next(), None);\n+\n+    let v4: &mut [i32] = &mut [0, 1, 2];\n+    let mut c4 = v4.chunks_mut(10);\n+    assert_eq!(c4.nth_back(1_000_000_000usize), None);\n+}\n+\n #[test]\n fn test_chunks_mut_last() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];"}, {"sha": "eb0ea9e08a40ee95cad1772cab2fd35e88522937", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -63,7 +63,6 @@ use syntax::errors;\n use syntax::ext::hygiene::ExpnId;\n use syntax::print::pprust;\n use syntax::source_map::{respan, ExpnInfo, ExpnKind, DesugaringKind, Spanned};\n-use syntax::std_inject;\n use syntax::symbol::{kw, sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::{self, Token};\n@@ -241,7 +240,7 @@ pub fn lower_crate(\n     dep_graph.assert_ignored();\n \n     LoweringContext {\n-        crate_root: std_inject::injected_crate_name().map(Symbol::intern),\n+        crate_root: sess.parse_sess.injected_crate_name.try_get().copied(),\n         sess,\n         cstore,\n         resolver,"}, {"sha": "e2b1b54cef39f8ac423b1ba888ea7d1f783df666", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 62, "deletions": 33, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -2146,48 +2146,77 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // First (determined here), if `self` is by-reference, then the\n         // implied output region is the region of the self parameter.\n         if has_self {\n-            // Look for `self: &'a Self` - also desugared from `&'a self`,\n-            // and if that matches, use it for elision and return early.\n-            let is_self_ty = |res: Res| {\n-                if let Res::SelfTy(..) = res {\n-                    return true;\n-                }\n-\n-                // Can't always rely on literal (or implied) `Self` due\n-                // to the way elision rules were originally specified.\n-                let impl_self = impl_self.map(|ty| &ty.node);\n-                if let Some(&hir::TyKind::Path(hir::QPath::Resolved(None, ref path))) = impl_self {\n-                    match path.res {\n-                        // Whitelist the types that unambiguously always\n-                        // result in the same type constructor being used\n-                        // (it can't differ between `Self` and `self`).\n-                        Res::Def(DefKind::Struct, _)\n-                        | Res::Def(DefKind::Union, _)\n-                        | Res::Def(DefKind::Enum, _)\n-                        | Res::PrimTy(_) => {\n-                            return res == path.res\n+            struct SelfVisitor<'a> {\n+                map: &'a NamedRegionMap,\n+                impl_self: Option<&'a hir::TyKind>,\n+                lifetime: Set1<Region>,\n+            }\n+\n+            impl SelfVisitor<'_> {\n+                // Look for `self: &'a Self` - also desugared from `&'a self`,\n+                // and if that matches, use it for elision and return early.\n+                fn is_self_ty(&self, res: Res) -> bool {\n+                    if let Res::SelfTy(..) = res {\n+                        return true;\n+                    }\n+\n+                    // Can't always rely on literal (or implied) `Self` due\n+                    // to the way elision rules were originally specified.\n+                    if let Some(&hir::TyKind::Path(hir::QPath::Resolved(None, ref path))) =\n+                        self.impl_self\n+                    {\n+                        match path.res {\n+                            // Whitelist the types that unambiguously always\n+                            // result in the same type constructor being used\n+                            // (it can't differ between `Self` and `self`).\n+                            Res::Def(DefKind::Struct, _)\n+                            | Res::Def(DefKind::Union, _)\n+                            | Res::Def(DefKind::Enum, _)\n+                            | Res::PrimTy(_) => {\n+                                return res == path.res\n+                            }\n+                            _ => {}\n                         }\n-                        _ => {}\n                     }\n+\n+                    false\n                 }\n+            }\n \n-                false\n-            };\n+            impl<'a> Visitor<'a> for SelfVisitor<'a> {\n+                fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'a> {\n+                    NestedVisitorMap::None\n+                }\n \n-            if let hir::TyKind::Rptr(lifetime_ref, ref mt) = inputs[0].node {\n-                if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = mt.ty.node {\n-                    if is_self_ty(path.res) {\n-                        if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.hir_id) {\n-                            let scope = Scope::Elision {\n-                                elide: Elide::Exact(lifetime),\n-                                s: self.scope,\n-                            };\n-                            self.with(scope, |_, this| this.visit_ty(output));\n-                            return;\n+                fn visit_ty(&mut self, ty: &'a hir::Ty) {\n+                    if let hir::TyKind::Rptr(lifetime_ref, ref mt) = ty.node {\n+                        if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = mt.ty.node\n+                        {\n+                            if self.is_self_ty(path.res) {\n+                                if let Some(lifetime) = self.map.defs.get(&lifetime_ref.hir_id) {\n+                                    self.lifetime.insert(*lifetime);\n+                                }\n+                            }\n                         }\n                     }\n+                    intravisit::walk_ty(self, ty)\n                 }\n             }\n+\n+            let mut visitor = SelfVisitor {\n+                map: self.map,\n+                impl_self: impl_self.map(|ty| &ty.node),\n+                lifetime: Set1::Empty,\n+            };\n+            visitor.visit_ty(&inputs[0]);\n+            if let Set1::One(lifetime) = visitor.lifetime {\n+                let scope = Scope::Elision {\n+                    elide: Elide::Exact(lifetime),\n+                    s: self.scope,\n+                };\n+                self.with(scope, |_, this| this.visit_ty(output));\n+                return;\n+            }\n         }\n \n         // Second, if there was exactly one lifetime (either a substitution or a"}, {"sha": "42aa8203cba0eb21882745ff5287fed5bdc557a6", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -10,30 +10,19 @@ path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n-arena = { path = \"../libarena\" }\n graphviz = { path = \"../libgraphviz\" }\n log = \"0.4\"\n env_logger = { version = \"0.5\", default-features = false }\n-rayon = { version = \"0.2.0\", package = \"rustc-rayon\" }\n rustc = { path = \"../librustc\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_ast_borrowck = { path = \"../librustc_ast_borrowck\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n-rustc_incremental = { path = \"../librustc_incremental\" }\n-rustc_lint = { path = \"../librustc_lint\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n-rustc_passes = { path = \"../librustc_passes\" }\n-rustc_plugin = { path = \"../librustc_plugin\" }\n-rustc_privacy = { path = \"../librustc_privacy\" }\n-rustc_resolve = { path = \"../librustc_resolve\" }\n rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n-rustc_traits = { path = \"../librustc_traits\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n-rustc_typeck = { path = \"../librustc_typeck\" }\n rustc_interface = { path = \"../librustc_interface\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n-smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "3c7d854b36b13b651efeb0e0955e2c11dc37f972", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -278,7 +278,12 @@ pub fn register_plugins<'a>(\n \n     krate = time(sess, \"crate injection\", || {\n         let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| &**s);\n-        syntax::std_inject::maybe_inject_crates_ref(krate, alt_std_name, sess.edition())\n+        let (krate, name) =\n+            syntax_ext::standard_library_imports::inject(krate, alt_std_name, sess.edition());\n+        if let Some(name) = name {\n+            sess.parse_sess.injected_crate_name.set(name);\n+        }\n+        krate\n     });\n \n     let registrars = time(sess, \"plugin loading\", || {\n@@ -456,7 +461,7 @@ fn configure_and_expand_inner<'a>(\n     sess.profiler(|p| p.end_activity(\"macro expansion\"));\n \n     time(sess, \"maybe building test harness\", || {\n-        syntax::test::modify_for_testing(\n+        syntax_ext::test_harness::inject(\n             &sess.parse_sess,\n             &mut resolver,\n             sess.opts.test,\n@@ -485,7 +490,7 @@ fn configure_and_expand_inner<'a>(\n             let num_crate_types = crate_types.len();\n             let is_proc_macro_crate = crate_types.contains(&config::CrateType::ProcMacro);\n             let is_test_crate = sess.opts.test;\n-            syntax_ext::proc_macro_decls::modify(\n+            syntax_ext::proc_macro_harness::inject(\n                 &sess.parse_sess,\n                 &mut resolver,\n                 krate,"}, {"sha": "5ff60a9267bad52ba8dbde98a128679ceace9f42", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -21,5 +21,4 @@ rustc_target = { path = \"../librustc_target\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n stable_deref_trait = \"1.0.0\"\n syntax = { path = \"../libsyntax\" }\n-syntax_ext = { path = \"../libsyntax_ext\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "d5f1e715186f4ca984eb3c1f1a218bfe0aa4630d", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -586,8 +586,7 @@ impl<'a> CrateLoader<'a> {\n         use std::{env, mem};\n         use crate::dynamic_lib::DynamicLibrary;\n         use proc_macro::bridge::client::ProcMacro;\n-        use syntax_ext::deriving::custom::ProcMacroDerive;\n-        use syntax_ext::proc_macro_impl::{AttrProcMacro, BangProcMacro};\n+        use syntax::ext::proc_macro::{BangProcMacro, AttrProcMacro, ProcMacroDerive};\n \n         let path = match dylib {\n             Some(dylib) => dylib,"}, {"sha": "ee1175e798d806cddfb85c3f0618a316979b3e33", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -31,10 +31,10 @@ use syntax::attr;\n use syntax::source_map;\n use syntax::edition::Edition;\n use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n+use syntax::ext::proc_macro::BangProcMacro;\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n use syntax::symbol::{Symbol, sym};\n-use syntax_ext::proc_macro_impl::BangProcMacro;\n use syntax_pos::{Span, NO_EXPANSION, FileName};\n use rustc_data_structures::bit_set::BitSet;\n "}, {"sha": "596ec6c19bcbfd0b5e419173ca1d6541a47270df", "filename": "src/librustc_passes/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibrustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibrustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2FCargo.toml?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -11,9 +11,7 @@ path = \"lib.rs\"\n [dependencies]\n log = \"0.4\"\n rustc = { path = \"../librustc\" }\n-rustc_mir = { path = \"../librustc_mir\"}\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n syntax = { path = \"../libsyntax\" }\n-syntax_ext = { path = \"../libsyntax_ext\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }"}, {"sha": "562865ef55f4cff5a6b2e0d2cc0aad2337bcdbf6", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -14,12 +14,12 @@ use rustc::session::Session;\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast::*;\n use syntax::attr;\n+use syntax::ext::proc_macro::is_proc_macro_attr;\n use syntax::feature_gate::is_builtin_attr;\n use syntax::source_map::Spanned;\n use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n use syntax::{span_err, struct_span_err, walk_list};\n-use syntax_ext::proc_macro_decls::is_proc_macro_attr;\n use syntax_pos::{Span, MultiSpan};\n use errors::{Applicability, FatalError};\n "}, {"sha": "41349cf72a16024c5ef48bcc6a333cbc084e4c39", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -34,7 +34,6 @@ use syntax::ext::hygiene::ExpnId;\n use syntax::feature_gate::is_builtin_attr;\n use syntax::parse::token::{self, Token};\n use syntax::span_err;\n-use syntax::std_inject::injected_crate_name;\n use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n \n@@ -367,8 +366,10 @@ impl<'a> Resolver<'a> {\n                 };\n \n                 self.populate_module_if_necessary(module);\n-                if injected_crate_name().map_or(false, |name| ident.name.as_str() == name) {\n-                    self.injected_crate = Some(module);\n+                if let Some(name) = self.session.parse_sess.injected_crate_name.try_get() {\n+                    if name.as_str() == ident.name.as_str() {\n+                        self.injected_crate = Some(module);\n+                    }\n                 }\n \n                 let used = self.process_legacy_macro_imports(item, module, &parent_scope);"}, {"sha": "bb7834a133f039a564681a514b1ab064d758071a", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -1,6 +1,6 @@\n use crate::ast::{self, Attribute, Name, PatKind};\n use crate::attr::{HasAttrs, Stability, Deprecation};\n-use crate::source_map::{SourceMap, Spanned, FileName, respan};\n+use crate::source_map::{SourceMap, Spanned, respan};\n use crate::edition::Edition;\n use crate::ext::expand::{self, AstFragment, Invocation};\n use crate::ext::hygiene::{ExpnId, SyntaxContext, Transparency};\n@@ -14,7 +14,7 @@ use crate::tokenstream::{self, TokenStream, TokenTree};\n \n use errors::{DiagnosticBuilder, DiagnosticId};\n use smallvec::{smallvec, SmallVec};\n-use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n+use syntax_pos::{FileName, Span, MultiSpan, DUMMY_SP};\n use syntax_pos::hygiene::{ExpnInfo, ExpnKind};\n \n use rustc_data_structures::fx::FxHashMap;"}, {"sha": "ff9ad46deecc078c0d3a7cf1683d2f08f502bb2d", "filename": "src/libsyntax/ext/derive.rs", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c798dffac9dc8c82374db48f5b474690cc6e9686/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c798dffac9dc8c82374db48f5b474690cc6e9686/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=c798dffac9dc8c82374db48f5b474690cc6e9686", "patch": "@@ -1,72 +0,0 @@\n-use crate::attr::HasAttrs;\n-use crate::ast;\n-use crate::source_map::{ExpnInfo, ExpnKind};\n-use crate::ext::base::{ExtCtxt, MacroKind};\n-use crate::ext::build::AstBuilder;\n-use crate::parse::parser::PathStyle;\n-use crate::symbol::{Symbol, sym};\n-use crate::errors::Applicability;\n-\n-use syntax_pos::Span;\n-use rustc_data_structures::fx::FxHashSet;\n-\n-pub fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>) -> Vec<ast::Path> {\n-    let mut result = Vec::new();\n-    attrs.retain(|attr| {\n-        if attr.path != sym::derive {\n-            return true;\n-        }\n-        if !attr.is_meta_item_list() {\n-            cx.struct_span_err(attr.span, \"malformed `derive` attribute input\")\n-                .span_suggestion(\n-                    attr.span,\n-                    \"missing traits to be derived\",\n-                    \"#[derive(Trait1, Trait2, ...)]\".to_owned(),\n-                    Applicability::HasPlaceholders,\n-                ).emit();\n-            return false;\n-        }\n-\n-        match attr.parse_list(cx.parse_sess,\n-                              |parser| parser.parse_path_allowing_meta(PathStyle::Mod)) {\n-            Ok(traits) => {\n-                result.extend(traits);\n-                true\n-            }\n-            Err(mut e) => {\n-                e.emit();\n-                false\n-            }\n-        }\n-    });\n-    result\n-}\n-\n-pub fn add_derived_markers<T>(cx: &mut ExtCtxt<'_>, span: Span, traits: &[ast::Path], item: &mut T)\n-    where T: HasAttrs,\n-{\n-    let (mut names, mut pretty_name) = (FxHashSet::default(), String::new());\n-    for (i, path) in traits.iter().enumerate() {\n-        if i > 0 {\n-            pretty_name.push_str(\", \");\n-        }\n-        pretty_name.push_str(&path.to_string());\n-        names.insert(unwrap_or!(path.segments.get(0), continue).ident.name);\n-    }\n-\n-    let span = span.fresh_expansion(cx.current_expansion.id, ExpnInfo::allow_unstable(\n-        ExpnKind::Macro(MacroKind::Derive, Symbol::intern(&pretty_name)), span,\n-        cx.parse_sess.edition, cx.allow_derive_markers.clone(),\n-    ));\n-\n-    item.visit_attrs(|attrs| {\n-        if names.contains(&sym::Eq) && names.contains(&sym::PartialEq) {\n-            let meta = cx.meta_word(span, sym::structural_match);\n-            attrs.push(cx.attribute(span, meta));\n-        }\n-        if names.contains(&sym::Copy) {\n-            let meta = cx.meta_word(span, sym::rustc_copy_clone_marker);\n-            attrs.push(cx.attribute(span, meta));\n-        }\n-    });\n-}"}, {"sha": "cd602d08c5baaf0e886cc9be4422800173a4eb06", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -4,7 +4,7 @@ use crate::attr::{self, HasAttrs};\n use crate::source_map::{dummy_spanned, respan};\n use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n-use crate::ext::derive::{add_derived_markers, collect_derives};\n+use crate::ext::proc_macro::{add_derived_markers, collect_derives};\n use crate::ext::hygiene::{ExpnId, SyntaxContext, ExpnInfo, ExpnKind};\n use crate::ext::placeholders::{placeholder, PlaceholderExpander};\n use crate::feature_gate::{self, Features, GateIssue, is_builtin_attr, emit_feature_err};"}, {"sha": "425b9813f5904da34431bf194c120c7bfe4f42e6", "filename": "src/libsyntax/ext/proc_macro.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,249 @@\n+use crate::ast::{self, ItemKind, Attribute, Mac};\n+use crate::attr::{mark_used, mark_known, HasAttrs};\n+use crate::errors::{Applicability, FatalError};\n+use crate::ext::base::{self, *};\n+use crate::ext::build::AstBuilder;\n+use crate::ext::proc_macro_server;\n+use crate::parse::{self, token};\n+use crate::parse::parser::PathStyle;\n+use crate::symbol::{sym, Symbol};\n+use crate::tokenstream::{self, TokenStream};\n+use crate::visit::Visitor;\n+\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sync::Lrc;\n+use syntax_pos::hygiene::{ExpnInfo, ExpnKind};\n+use syntax_pos::{Span, DUMMY_SP};\n+\n+const EXEC_STRATEGY: proc_macro::bridge::server::SameThread =\n+    proc_macro::bridge::server::SameThread;\n+\n+pub struct BangProcMacro {\n+    pub client: proc_macro::bridge::client::Client<\n+        fn(proc_macro::TokenStream) -> proc_macro::TokenStream,\n+    >,\n+}\n+\n+impl base::ProcMacro for BangProcMacro {\n+    fn expand<'cx>(&self,\n+                   ecx: &'cx mut ExtCtxt<'_>,\n+                   span: Span,\n+                   input: TokenStream)\n+                   -> TokenStream {\n+        let server = proc_macro_server::Rustc::new(ecx);\n+        match self.client.run(&EXEC_STRATEGY, server, input) {\n+            Ok(stream) => stream,\n+            Err(e) => {\n+                let msg = \"proc macro panicked\";\n+                let mut err = ecx.struct_span_fatal(span, msg);\n+                if let Some(s) = e.as_str() {\n+                    err.help(&format!(\"message: {}\", s));\n+                }\n+\n+                err.emit();\n+                FatalError.raise();\n+            }\n+        }\n+    }\n+}\n+\n+pub struct AttrProcMacro {\n+    pub client: proc_macro::bridge::client::Client<\n+        fn(proc_macro::TokenStream, proc_macro::TokenStream) -> proc_macro::TokenStream,\n+    >,\n+}\n+\n+impl base::AttrProcMacro for AttrProcMacro {\n+    fn expand<'cx>(&self,\n+                   ecx: &'cx mut ExtCtxt<'_>,\n+                   span: Span,\n+                   annotation: TokenStream,\n+                   annotated: TokenStream)\n+                   -> TokenStream {\n+        let server = proc_macro_server::Rustc::new(ecx);\n+        match self.client.run(&EXEC_STRATEGY, server, annotation, annotated) {\n+            Ok(stream) => stream,\n+            Err(e) => {\n+                let msg = \"custom attribute panicked\";\n+                let mut err = ecx.struct_span_fatal(span, msg);\n+                if let Some(s) = e.as_str() {\n+                    err.help(&format!(\"message: {}\", s));\n+                }\n+\n+                err.emit();\n+                FatalError.raise();\n+            }\n+        }\n+    }\n+}\n+\n+pub struct ProcMacroDerive {\n+    pub client: proc_macro::bridge::client::Client<\n+        fn(proc_macro::TokenStream) -> proc_macro::TokenStream,\n+    >,\n+    pub attrs: Vec<ast::Name>,\n+}\n+\n+impl MultiItemModifier for ProcMacroDerive {\n+    fn expand(&self,\n+              ecx: &mut ExtCtxt<'_>,\n+              span: Span,\n+              _meta_item: &ast::MetaItem,\n+              item: Annotatable)\n+              -> Vec<Annotatable> {\n+        let item = match item {\n+            Annotatable::Item(item) => item,\n+            Annotatable::ImplItem(_) |\n+            Annotatable::TraitItem(_) |\n+            Annotatable::ForeignItem(_) |\n+            Annotatable::Stmt(_) |\n+            Annotatable::Expr(_) => {\n+                ecx.span_err(span, \"proc-macro derives may only be \\\n+                                    applied to a struct, enum, or union\");\n+                return Vec::new()\n+            }\n+        };\n+        match item.node {\n+            ItemKind::Struct(..) |\n+            ItemKind::Enum(..) |\n+            ItemKind::Union(..) => {},\n+            _ => {\n+                ecx.span_err(span, \"proc-macro derives may only be \\\n+                                    applied to a struct, enum, or union\");\n+                return Vec::new()\n+            }\n+        }\n+\n+        // Mark attributes as known, and used.\n+        MarkAttrs(&self.attrs).visit_item(&item);\n+\n+        let token = token::Interpolated(Lrc::new(token::NtItem(item)));\n+        let input = tokenstream::TokenTree::token(token, DUMMY_SP).into();\n+\n+        let server = proc_macro_server::Rustc::new(ecx);\n+        let stream = match self.client.run(&EXEC_STRATEGY, server, input) {\n+            Ok(stream) => stream,\n+            Err(e) => {\n+                let msg = \"proc-macro derive panicked\";\n+                let mut err = ecx.struct_span_fatal(span, msg);\n+                if let Some(s) = e.as_str() {\n+                    err.help(&format!(\"message: {}\", s));\n+                }\n+\n+                err.emit();\n+                FatalError.raise();\n+            }\n+        };\n+\n+        let error_count_before = ecx.parse_sess.span_diagnostic.err_count();\n+        let msg = \"proc-macro derive produced unparseable tokens\";\n+\n+        let mut parser = parse::stream_to_parser(ecx.parse_sess, stream, Some(\"proc-macro derive\"));\n+        let mut items = vec![];\n+\n+        loop {\n+            match parser.parse_item() {\n+                Ok(None) => break,\n+                Ok(Some(item)) => {\n+                    items.push(Annotatable::Item(item))\n+                }\n+                Err(mut err) => {\n+                    // FIXME: handle this better\n+                    err.cancel();\n+                    ecx.struct_span_fatal(span, msg).emit();\n+                    FatalError.raise();\n+                }\n+            }\n+        }\n+\n+\n+        // fail if there have been errors emitted\n+        if ecx.parse_sess.span_diagnostic.err_count() > error_count_before {\n+            ecx.struct_span_fatal(span, msg).emit();\n+            FatalError.raise();\n+        }\n+\n+        items\n+    }\n+}\n+\n+struct MarkAttrs<'a>(&'a [ast::Name]);\n+\n+impl<'a> Visitor<'a> for MarkAttrs<'a> {\n+    fn visit_attribute(&mut self, attr: &Attribute) {\n+        if let Some(ident) = attr.ident() {\n+            if self.0.contains(&ident.name) {\n+                mark_used(attr);\n+                mark_known(attr);\n+            }\n+        }\n+    }\n+\n+    fn visit_mac(&mut self, _mac: &Mac) {}\n+}\n+\n+pub fn is_proc_macro_attr(attr: &Attribute) -> bool {\n+    [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n+        .iter().any(|kind| attr.check_name(*kind))\n+}\n+\n+crate fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>) -> Vec<ast::Path> {\n+    let mut result = Vec::new();\n+    attrs.retain(|attr| {\n+        if attr.path != sym::derive {\n+            return true;\n+        }\n+        if !attr.is_meta_item_list() {\n+            cx.struct_span_err(attr.span, \"malformed `derive` attribute input\")\n+                .span_suggestion(\n+                    attr.span,\n+                    \"missing traits to be derived\",\n+                    \"#[derive(Trait1, Trait2, ...)]\".to_owned(),\n+                    Applicability::HasPlaceholders,\n+                ).emit();\n+            return false;\n+        }\n+\n+        match attr.parse_list(cx.parse_sess,\n+                              |parser| parser.parse_path_allowing_meta(PathStyle::Mod)) {\n+            Ok(traits) => {\n+                result.extend(traits);\n+                true\n+            }\n+            Err(mut e) => {\n+                e.emit();\n+                false\n+            }\n+        }\n+    });\n+    result\n+}\n+\n+crate fn add_derived_markers<T: HasAttrs>(\n+    cx: &mut ExtCtxt<'_>, span: Span, traits: &[ast::Path], item: &mut T\n+) {\n+    let (mut names, mut pretty_name) = (FxHashSet::default(), String::new());\n+    for (i, path) in traits.iter().enumerate() {\n+        if i > 0 {\n+            pretty_name.push_str(\", \");\n+        }\n+        pretty_name.push_str(&path.to_string());\n+        names.insert(unwrap_or!(path.segments.get(0), continue).ident.name);\n+    }\n+\n+    let span = span.fresh_expansion(cx.current_expansion.id, ExpnInfo::allow_unstable(\n+        ExpnKind::Macro(MacroKind::Derive, Symbol::intern(&pretty_name)), span,\n+        cx.parse_sess.edition, cx.allow_derive_markers.clone(),\n+    ));\n+\n+    item.visit_attrs(|attrs| {\n+        if names.contains(&sym::Eq) && names.contains(&sym::PartialEq) {\n+            let meta = cx.meta_word(span, sym::structural_match);\n+            attrs.push(cx.attribute(span, meta));\n+        }\n+        if names.contains(&sym::Copy) {\n+            let meta = cx.meta_word(span, sym::rustc_copy_clone_marker);\n+            attrs.push(cx.attribute(span, meta));\n+        }\n+    });\n+}"}, {"sha": "8d0023c9ab1eb986e57c69a8a6ef3e81b41e4758", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "renamed", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -1,21 +1,19 @@\n-use errors::{Diagnostic, DiagnosticBuilder};\n-\n-use std::panic;\n-\n-use proc_macro::bridge::{server, TokenTree};\n-use proc_macro::{Delimiter, Level, LineColumn, Spacing};\n+use crate::ast;\n+use crate::ext::base::ExtCtxt;\n+use crate::parse::{self, token, ParseSess};\n+use crate::parse::lexer::comments;\n+use crate::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint};\n \n+use errors::{Diagnostic, DiagnosticBuilder};\n use rustc_data_structures::sync::Lrc;\n-use std::ascii;\n-use std::ops::Bound;\n-use syntax::ast;\n-use syntax::ext::base::ExtCtxt;\n-use syntax::parse::lexer::comments;\n-use syntax::parse::{self, token, ParseSess};\n-use syntax::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint};\n+use syntax_pos::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n use syntax_pos::hygiene::{SyntaxContext, Transparency};\n use syntax_pos::symbol::{kw, sym, Symbol};\n-use syntax_pos::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n+\n+use proc_macro::{Delimiter, Level, LineColumn, Spacing};\n+use proc_macro::bridge::{server, TokenTree};\n+use std::{ascii, panic};\n+use std::ops::Bound;\n \n trait FromInternal<T> {\n     fn from_internal(x: T) -> Self;\n@@ -52,7 +50,7 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n {\n     fn from_internal(((tree, is_joint), sess, stack): (TreeAndJoint, &ParseSess, &mut Vec<Self>))\n                     -> Self {\n-        use syntax::parse::token::*;\n+        use crate::parse::token::*;\n \n         let joint = is_joint == Joint;\n         let Token { kind, span } = match tree {\n@@ -193,7 +191,7 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n \n impl ToInternal<TokenStream> for TokenTree<Group, Punct, Ident, Literal> {\n     fn to_internal(self) -> TokenStream {\n-        use syntax::parse::token::*;\n+        use crate::parse::token::*;\n \n         let (ch, joint, span) = match self {\n             TokenTree::Punct(Punct { ch, joint, span }) => (ch, joint, span),", "previous_filename": "src/libsyntax_ext/proc_macro_server.rs"}, {"sha": "bb6a8dfb1411ecf5c355103a458a38229e8047c8", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -18,12 +18,17 @@\n #![feature(label_break_value)]\n #![feature(mem_take)]\n #![feature(nll)]\n+#![feature(proc_macro_diagnostic)]\n+#![feature(proc_macro_internals)]\n+#![feature(proc_macro_span)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(try_trait)]\n #![feature(unicode_internals)]\n \n #![recursion_limit=\"256\"]\n \n+extern crate proc_macro;\n+\n pub use errors;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::bit_set::GrowableBitSet;\n@@ -37,6 +42,7 @@ const MACRO_ARGUMENTS: Option<&'static str> = Some(\"macro arguments\");\n // way towards a non-panic!-prone parser. It should be used for fatal parsing\n // errors; eventually we plan to convert all code using panictry to just use\n // normal try.\n+#[macro_export]\n macro_rules! panictry {\n     ($e:expr) => ({\n         use std::result::Result::{Ok, Err};\n@@ -147,10 +153,8 @@ pub mod mut_visit;\n pub mod parse;\n pub mod ptr;\n pub mod show_span;\n-pub mod std_inject;\n pub use syntax_pos::edition;\n pub use syntax_pos::symbol;\n-pub mod test;\n pub mod tokenstream;\n pub mod visit;\n \n@@ -161,14 +165,15 @@ pub mod print {\n }\n \n pub mod ext {\n+    mod placeholders;\n+    mod proc_macro_server;\n+\n     pub use syntax_pos::hygiene;\n     pub mod allocator;\n     pub mod base;\n     pub mod build;\n-    pub mod derive;\n     pub mod expand;\n-    pub mod placeholders;\n-    pub mod source_util;\n+    pub mod proc_macro;\n \n     pub mod tt {\n         pub mod transcribe;"}, {"sha": "af484c886ab35b7d796995d6eea834fd2938251d", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 45, "deletions": 16, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -4,14 +4,15 @@ use crate::parse::{SeqSep, PResult};\n use crate::parse::token::{self, Nonterminal, DelimToken};\n use crate::parse::parser::{Parser, TokenType, PathStyle};\n use crate::tokenstream::{TokenStream, TokenTree};\n+use crate::source_map::Span;\n \n use log::debug;\n use smallvec::smallvec;\n \n #[derive(Debug)]\n enum InnerAttributeParsePolicy<'a> {\n     Permitted,\n-    NotPermitted { reason: &'a str },\n+    NotPermitted { reason: &'a str, saw_doc_comment: bool, prev_attr_sp: Option<Span> },\n }\n \n const DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG: &str = \"an inner attribute is not \\\n@@ -42,7 +43,11 @@ impl<'a> Parser<'a> {\n                         DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG\n                     };\n                     let inner_parse_policy =\n-                        InnerAttributeParsePolicy::NotPermitted { reason: inner_error_reason };\n+                        InnerAttributeParsePolicy::NotPermitted {\n+                            reason: inner_error_reason,\n+                            saw_doc_comment: just_parsed_doc_comment,\n+                            prev_attr_sp: attrs.last().and_then(|a| Some(a.span))\n+                        };\n                     let attr = self.parse_attribute_with_inner_parse_policy(inner_parse_policy)?;\n                     attrs.push(attr);\n                     just_parsed_doc_comment = false;\n@@ -76,8 +81,11 @@ impl<'a> Parser<'a> {\n         let inner_parse_policy = if permit_inner {\n             InnerAttributeParsePolicy::Permitted\n         } else {\n-            InnerAttributeParsePolicy::NotPermitted\n-                { reason: DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG }\n+            InnerAttributeParsePolicy::NotPermitted {\n+                reason: DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG,\n+                saw_doc_comment: false,\n+                prev_attr_sp: None\n+            }\n         };\n         self.parse_attribute_with_inner_parse_policy(inner_parse_policy)\n     }\n@@ -98,19 +106,9 @@ impl<'a> Parser<'a> {\n                 if let InnerAttributeParsePolicy::Permitted = inner_parse_policy {\n                     self.expected_tokens.push(TokenType::Token(token::Not));\n                 }\n+\n                 let style = if self.token == token::Not {\n                     self.bump();\n-                    if let InnerAttributeParsePolicy::NotPermitted { reason } = inner_parse_policy\n-                    {\n-                        let span = self.token.span;\n-                        self.diagnostic()\n-                            .struct_span_err(span, reason)\n-                            .note(\"inner attributes, like `#![no_std]`, annotate the item \\\n-                                   enclosing them, and are usually found at the beginning of \\\n-                                   source files. Outer attributes, like `#[test]`, annotate the \\\n-                                   item following them.\")\n-                            .emit()\n-                    }\n                     ast::AttrStyle::Inner\n                 } else {\n                     ast::AttrStyle::Outer\n@@ -121,7 +119,38 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::CloseDelim(token::Bracket))?;\n                 let hi = self.prev_span;\n \n-                (lo.to(hi), path, tokens, style)\n+                let attr_sp = lo.to(hi);\n+\n+                // Emit error if inner attribute is encountered and not permitted\n+                if style == ast::AttrStyle::Inner {\n+                    if let InnerAttributeParsePolicy::NotPermitted { reason,\n+                        saw_doc_comment, prev_attr_sp } = inner_parse_policy {\n+                        let prev_attr_note = if saw_doc_comment {\n+                            \"previous doc comment\"\n+                        } else {\n+                            \"previous outer attribute\"\n+                        };\n+\n+                        let mut diagnostic = self\n+                            .diagnostic()\n+                            .struct_span_err(attr_sp, reason);\n+\n+                        if let Some(prev_attr_sp) = prev_attr_sp {\n+                            diagnostic\n+                                .span_label(attr_sp, \"not permitted following an outer attibute\")\n+                                .span_label(prev_attr_sp, prev_attr_note);\n+                        }\n+\n+                        diagnostic\n+                            .note(\"inner attributes, like `#![no_std]`, annotate the item \\\n+                                   enclosing them, and are usually found at the beginning of \\\n+                                   source files. Outer attributes, like `#[test]`, annotate the \\\n+                                   item following them.\")\n+                            .emit()\n+                    }\n+                }\n+\n+                (attr_sp, path, tokens, style)\n             }\n             _ => {\n                 let token_str = self.this_token_to_string();"}, {"sha": "3cd5464f35710c4fd67c6c57cc3a57a409a0462c", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -794,7 +794,7 @@ mod tests {\n     use std::path::PathBuf;\n     use syntax_pos::{BytePos, Span, NO_EXPANSION, edition::Edition};\n     use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-    use rustc_data_structures::sync::Lock;\n+    use rustc_data_structures::sync::{Lock, Once};\n \n     fn mk_sess(sm: Lrc<SourceMap>) -> ParseSess {\n         let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()),\n@@ -817,6 +817,7 @@ mod tests {\n             param_attr_spans: Lock::new(Vec::new()),\n             let_chains_spans: Lock::new(Vec::new()),\n             async_closure_spans: Lock::new(Vec::new()),\n+            injected_crate_name: Once::new(),\n         }\n     }\n "}, {"sha": "1aac8bbb7aa46589d9d07a3af0017a1757f838ef", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -10,9 +10,10 @@ use crate::parse::token::TokenKind;\n use crate::tokenstream::{TokenStream, TokenTree};\n use crate::diagnostics::plugin::ErrorMap;\n use crate::print::pprust;\n+use crate::symbol::Symbol;\n \n use errors::{Applicability, FatalError, Level, Handler, ColorConfig, Diagnostic, DiagnosticBuilder};\n-use rustc_data_structures::sync::{Lrc, Lock};\n+use rustc_data_structures::sync::{Lrc, Lock, Once};\n use syntax_pos::{Span, SourceFile, FileName, MultiSpan};\n use syntax_pos::edition::Edition;\n \n@@ -58,6 +59,7 @@ pub struct ParseSess {\n     pub let_chains_spans: Lock<Vec<Span>>,\n     // Places where `async || ..` exprs were used and should be feature gated.\n     pub async_closure_spans: Lock<Vec<Span>>,\n+    pub injected_crate_name: Once<Symbol>,\n }\n \n impl ParseSess {\n@@ -86,6 +88,7 @@ impl ParseSess {\n             param_attr_spans: Lock::new(Vec::new()),\n             let_chains_spans: Lock::new(Vec::new()),\n             async_closure_spans: Lock::new(Vec::new()),\n+            injected_crate_name: Once::new(),\n         }\n     }\n "}, {"sha": "c462357639506d50a29a18f625151d0c703bac1e", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -10,7 +10,6 @@ use crate::parse::{self, ParseSess};\n use crate::print::pp::{self, Breaks};\n use crate::print::pp::Breaks::{Consistent, Inconsistent};\n use crate::ptr::P;\n-use crate::std_inject;\n use crate::symbol::{kw, sym};\n use crate::tokenstream::{self, TokenStream, TokenTree};\n \n@@ -114,7 +113,7 @@ pub fn print_crate<'a>(cm: &'a SourceMap,\n         is_expanded,\n     };\n \n-    if is_expanded && std_inject::injected_crate_name().is_some() {\n+    if is_expanded && sess.injected_crate_name.try_get().is_some() {\n         // We need to print `#![no_std]` (and its feature gate) so that\n         // compiling pretty-printed source won't inject libstd again.\n         // However we don't want these attributes in the AST because"}, {"sha": "73310df305b32cb9892b5e5ce2e1327f6ac794c7", "filename": "src/libsyntax_ext/Cargo.toml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax_ext%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax_ext%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2FCargo.toml?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -10,11 +10,11 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-fmt_macros = { path = \"../libfmt_macros\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n-syntax = { path = \"../libsyntax\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }\n+fmt_macros = { path = \"../libfmt_macros\" }\n+log = \"0.4\"\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_target = { path = \"../librustc_target\" }\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n-log = \"0.4\"\n+syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "98465d75e4680e9d31beb6665f871e22e0ade22b", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/c798dffac9dc8c82374db48f5b474690cc6e9686/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c798dffac9dc8c82374db48f5b474690cc6e9686/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=c798dffac9dc8c82374db48f5b474690cc6e9686", "patch": "@@ -1,119 +0,0 @@\n-use crate::proc_macro_impl::EXEC_STRATEGY;\n-use crate::proc_macro_server;\n-\n-use errors::FatalError;\n-use rustc_data_structures::sync::Lrc;\n-use syntax::ast::{self, ItemKind, Attribute, Mac};\n-use syntax::attr::{mark_used, mark_known};\n-use syntax::source_map::Span;\n-use syntax::ext::base::*;\n-use syntax::parse;\n-use syntax::parse::token;\n-use syntax::tokenstream;\n-use syntax::visit::Visitor;\n-use syntax_pos::DUMMY_SP;\n-\n-struct MarkAttrs<'a>(&'a [ast::Name]);\n-\n-impl<'a> Visitor<'a> for MarkAttrs<'a> {\n-    fn visit_attribute(&mut self, attr: &Attribute) {\n-        if let Some(ident) = attr.ident() {\n-            if self.0.contains(&ident.name) {\n-                mark_used(attr);\n-                mark_known(attr);\n-            }\n-        }\n-    }\n-\n-    fn visit_mac(&mut self, _mac: &Mac) {}\n-}\n-\n-pub struct ProcMacroDerive {\n-    pub client: proc_macro::bridge::client::Client<\n-        fn(proc_macro::TokenStream) -> proc_macro::TokenStream,\n-    >,\n-    pub attrs: Vec<ast::Name>,\n-}\n-\n-impl MultiItemModifier for ProcMacroDerive {\n-    fn expand(&self,\n-              ecx: &mut ExtCtxt<'_>,\n-              span: Span,\n-              _meta_item: &ast::MetaItem,\n-              item: Annotatable)\n-              -> Vec<Annotatable> {\n-        let item = match item {\n-            Annotatable::Item(item) => item,\n-            Annotatable::ImplItem(_) |\n-            Annotatable::TraitItem(_) |\n-            Annotatable::ForeignItem(_) |\n-            Annotatable::Stmt(_) |\n-            Annotatable::Expr(_) => {\n-                ecx.span_err(span, \"proc-macro derives may only be \\\n-                                    applied to a struct, enum, or union\");\n-                return Vec::new()\n-            }\n-        };\n-        match item.node {\n-            ItemKind::Struct(..) |\n-            ItemKind::Enum(..) |\n-            ItemKind::Union(..) => {},\n-            _ => {\n-                ecx.span_err(span, \"proc-macro derives may only be \\\n-                                    applied to a struct, enum, or union\");\n-                return Vec::new()\n-            }\n-        }\n-\n-        // Mark attributes as known, and used.\n-        MarkAttrs(&self.attrs).visit_item(&item);\n-\n-        let token = token::Interpolated(Lrc::new(token::NtItem(item)));\n-        let input = tokenstream::TokenTree::token(token, DUMMY_SP).into();\n-\n-        let server = proc_macro_server::Rustc::new(ecx);\n-        let stream = match self.client.run(&EXEC_STRATEGY, server, input) {\n-            Ok(stream) => stream,\n-            Err(e) => {\n-                let msg = \"proc-macro derive panicked\";\n-                let mut err = ecx.struct_span_fatal(span, msg);\n-                if let Some(s) = e.as_str() {\n-                    err.help(&format!(\"message: {}\", s));\n-                }\n-\n-                err.emit();\n-                FatalError.raise();\n-            }\n-        };\n-\n-        let error_count_before = ecx.parse_sess.span_diagnostic.err_count();\n-        let msg = \"proc-macro derive produced unparseable tokens\";\n-\n-        let mut parser = parse::stream_to_parser(ecx.parse_sess, stream, Some(\"proc-macro derive\"));\n-        let mut items = vec![];\n-\n-        loop {\n-            match parser.parse_item() {\n-                Ok(None) => break,\n-                Ok(Some(item)) => {\n-                    items.push(Annotatable::Item(item))\n-                }\n-                Err(mut err) => {\n-                    // FIXME: handle this better\n-                    err.cancel();\n-                    ecx.struct_span_fatal(span, msg).emit();\n-                    FatalError.raise();\n-                }\n-            }\n-        }\n-\n-\n-        // fail if there have been errors emitted\n-        if ecx.parse_sess.span_diagnostic.err_count() > error_count_before {\n-            ecx.struct_span_fatal(span, msg).emit();\n-            FatalError.raise();\n-        }\n-\n-        items\n-    }\n-}"}, {"sha": "7f27769f236e29b97b4a1c098980254b5a1d8a8e", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -1770,50 +1770,6 @@ pub fn cs_fold1<F, B>(use_foldl: bool,\n     }\n }\n \n-/// Call the method that is being derived on all the fields, and then\n-/// process the collected results. i.e.\n-///\n-/// ```ignore (only-for-syntax-highlight)\n-/// f(cx, span, vec![self_1.method(__arg_1_1, __arg_2_1),\n-///                  self_2.method(__arg_1_2, __arg_2_2)])\n-/// ```\n-#[inline]\n-pub fn cs_same_method<F>(f: F,\n-                         mut enum_nonmatch_f: EnumNonMatchCollapsedFunc<'_>,\n-                         cx: &mut ExtCtxt<'_>,\n-                         trait_span: Span,\n-                         substructure: &Substructure<'_>)\n-                         -> P<Expr>\n-    where F: FnOnce(&mut ExtCtxt<'_>, Span, Vec<P<Expr>>) -> P<Expr>\n-{\n-    match *substructure.fields {\n-        EnumMatching(.., ref all_fields) |\n-        Struct(_, ref all_fields) => {\n-            // call self_n.method(other_1_n, other_2_n, ...)\n-            let called = all_fields.iter()\n-                .map(|field| {\n-                    cx.expr_method_call(field.span,\n-                                        field.self_.clone(),\n-                                        substructure.method_ident,\n-                                        field.other\n-                                            .iter()\n-                                            .map(|e| cx.expr_addr_of(field.span, e.clone()))\n-                                            .collect())\n-                })\n-                .collect();\n-\n-            f(cx, trait_span, called)\n-        }\n-        EnumNonMatchingCollapsed(ref all_self_args, _, tuple) => {\n-            enum_nonmatch_f(cx,\n-                            trait_span,\n-                            (&all_self_args[..], tuple),\n-                            substructure.nonself_args)\n-        }\n-        StaticEnum(..) | StaticStruct(..) => cx.span_bug(trait_span, \"static function in `derive`\"),\n-    }\n-}\n-\n /// Returns `true` if the type has no value fields\n /// (for an enum, no variant has any fields)\n pub fn is_type_without_fields(item: &Annotatable) -> bool {"}, {"sha": "394beb141712d8b7ad254120a04677da7496e578", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -18,6 +18,7 @@ pub enum PtrTy<'a> {\n     /// &'lifetime mut\n     Borrowed(Option<&'a str>, ast::Mutability),\n     /// *mut\n+    #[allow(dead_code)]\n     Raw(ast::Mutability),\n }\n \n@@ -107,13 +108,6 @@ pub enum Ty<'a> {\n     Tuple(Vec<Ty<'a>>),\n }\n \n-/// A const expression. Supports literals and blocks.\n-#[derive(Clone, Eq, PartialEq)]\n-pub enum Const {\n-    Literal,\n-    Block,\n-}\n-\n pub fn borrowed_ptrty<'r>() -> PtrTy<'r> {\n     Borrowed(None, ast::Mutability::Immutable)\n }"}, {"sha": "cad79917af284a623841f5e7104a718482f96a2b", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -26,7 +26,6 @@ pub mod decodable;\n pub mod hash;\n pub mod debug;\n pub mod default;\n-pub mod custom;\n \n #[path=\"cmp/partial_eq.rs\"]\n pub mod partial_eq;"}, {"sha": "fae884860ed56f262322f6f12aa5347659c8cac4", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -1,4 +1,5 @@\n-//! Syntax extensions in the Rust compiler.\n+//! This crate contains implementations of built-in macros and other code generating facilities\n+//! injecting code into the crate before it is lowered to HIR.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n@@ -7,21 +8,15 @@\n \n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n+#![feature(mem_take)]\n #![feature(nll)]\n-#![feature(proc_macro_diagnostic)]\n-#![feature(proc_macro_internals)]\n-#![feature(proc_macro_span)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(unicode_internals)]\n-\n-extern crate proc_macro;\n \n use crate::deriving::*;\n \n use syntax::ast::Ident;\n use syntax::edition::Edition;\n use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind, MacroExpanderFn};\n-use syntax::ext::source_util;\n use syntax::symbol::sym;\n \n mod error_codes;\n@@ -32,21 +27,21 @@ mod cfg;\n mod compile_error;\n mod concat;\n mod concat_idents;\n+mod deriving;\n mod env;\n mod format;\n mod format_foreign;\n mod global_allocator;\n mod global_asm;\n mod log_syntax;\n-mod proc_macro_server;\n+mod source_util;\n mod test;\n-mod test_case;\n mod trace_macros;\n \n-pub mod deriving;\n pub mod plugin_macro_defs;\n-pub mod proc_macro_decls;\n-pub mod proc_macro_impl;\n+pub mod proc_macro_harness;\n+pub mod standard_library_imports;\n+pub mod test_harness;\n \n pub fn register_builtin_macros(resolver: &mut dyn syntax::ext::base::Resolver, edition: Edition) {\n     let mut register = |name, kind| resolver.register_builtin_macro(\n@@ -93,7 +88,7 @@ pub fn register_builtin_macros(resolver: &mut dyn syntax::ext::base::Resolver, e\n         bench: test::expand_bench,\n         global_allocator: global_allocator::expand,\n         test: test::expand_test,\n-        test_case: test_case::expand,\n+        test_case: test::expand_test_case,\n     }\n \n     register_derive! {"}, {"sha": "fc6cd5dc94cd596e617abdb2813ad8d0dc3e5f9e", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "renamed", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -7,21 +7,15 @@ use syntax::ext::base::{ExtCtxt, MacroKind};\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n use syntax::ext::hygiene::ExpnId;\n+use syntax::ext::proc_macro::is_proc_macro_attr;\n use syntax::mut_visit::MutVisitor;\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n \n-const PROC_MACRO_KINDS: [Symbol; 3] = [\n-    sym::proc_macro_derive,\n-    sym::proc_macro_attribute,\n-    sym::proc_macro\n-];\n-\n struct ProcMacroDerive {\n     trait_name: ast::Name,\n     function_name: Ident,\n@@ -44,7 +38,7 @@ struct CollectProcMacros<'a> {\n     is_test_crate: bool,\n }\n \n-pub fn modify(sess: &ParseSess,\n+pub fn inject(sess: &ParseSess,\n               resolver: &mut dyn (::syntax::ext::base::Resolver),\n               mut krate: ast::Crate,\n               is_proc_macro_crate: bool,\n@@ -88,10 +82,6 @@ pub fn modify(sess: &ParseSess,\n     krate\n }\n \n-pub fn is_proc_macro_attr(attr: &ast::Attribute) -> bool {\n-    PROC_MACRO_KINDS.iter().any(|kind| attr.check_name(*kind))\n-}\n-\n impl<'a> CollectProcMacros<'a> {\n     fn check_not_pub_in_root(&self, vis: &ast::Visibility, sp: Span) {\n         if self.is_proc_macro_crate && self.in_root && vis.node.is_pub() {", "previous_filename": "src/libsyntax_ext/proc_macro_decls.rs"}, {"sha": "f0fc6392cd73f593f7e963e8c4342f8ce2182b37", "filename": "src/libsyntax_ext/proc_macro_impl.rs", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c798dffac9dc8c82374db48f5b474690cc6e9686/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c798dffac9dc8c82374db48f5b474690cc6e9686/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_impl.rs?ref=c798dffac9dc8c82374db48f5b474690cc6e9686", "patch": "@@ -1,68 +0,0 @@\n-use crate::proc_macro_server;\n-\n-use errors::FatalError;\n-use syntax::source_map::Span;\n-use syntax::ext::base::{self, *};\n-use syntax::tokenstream::TokenStream;\n-\n-pub const EXEC_STRATEGY: proc_macro::bridge::server::SameThread =\n-    proc_macro::bridge::server::SameThread;\n-\n-pub struct AttrProcMacro {\n-    pub client: proc_macro::bridge::client::Client<\n-        fn(proc_macro::TokenStream, proc_macro::TokenStream) -> proc_macro::TokenStream,\n-    >,\n-}\n-\n-impl base::AttrProcMacro for AttrProcMacro {\n-    fn expand<'cx>(&self,\n-                   ecx: &'cx mut ExtCtxt<'_>,\n-                   span: Span,\n-                   annotation: TokenStream,\n-                   annotated: TokenStream)\n-                   -> TokenStream {\n-        let server = proc_macro_server::Rustc::new(ecx);\n-        match self.client.run(&EXEC_STRATEGY, server, annotation, annotated) {\n-            Ok(stream) => stream,\n-            Err(e) => {\n-                let msg = \"custom attribute panicked\";\n-                let mut err = ecx.struct_span_fatal(span, msg);\n-                if let Some(s) = e.as_str() {\n-                    err.help(&format!(\"message: {}\", s));\n-                }\n-\n-                err.emit();\n-                FatalError.raise();\n-            }\n-        }\n-    }\n-}\n-\n-pub struct BangProcMacro {\n-    pub client: proc_macro::bridge::client::Client<\n-        fn(proc_macro::TokenStream) -> proc_macro::TokenStream,\n-    >,\n-}\n-\n-impl base::ProcMacro for BangProcMacro {\n-    fn expand<'cx>(&self,\n-                   ecx: &'cx mut ExtCtxt<'_>,\n-                   span: Span,\n-                   input: TokenStream)\n-                   -> TokenStream {\n-        let server = proc_macro_server::Rustc::new(ecx);\n-        match self.client.run(&EXEC_STRATEGY, server, input) {\n-            Ok(stream) => stream,\n-            Err(e) => {\n-                let msg = \"proc macro panicked\";\n-                let mut err = ecx.struct_span_fatal(span, msg);\n-                if let Some(s) = e.as_str() {\n-                    err.help(&format!(\"message: {}\", s));\n-                }\n-\n-                err.emit();\n-                FatalError.raise();\n-            }\n-        }\n-    }\n-}"}, {"sha": "8ecfd4ddda7bfe7abc78b1f7f96b9137ca47c532", "filename": "src/libsyntax_ext/source_util.rs", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax_ext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax_ext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fsource_util.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -1,11 +1,11 @@\n-use crate::ast;\n-use crate::ext::base::{self, *};\n-use crate::ext::build::AstBuilder;\n-use crate::parse::{self, token, DirectoryOwnership};\n-use crate::print::pprust;\n-use crate::ptr::P;\n-use crate::symbol::Symbol;\n-use crate::tokenstream;\n+use syntax::{ast, panictry};\n+use syntax::ext::base::{self, *};\n+use syntax::ext::build::AstBuilder;\n+use syntax::parse::{self, token, DirectoryOwnership};\n+use syntax::print::pprust;\n+use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n+use syntax::tokenstream;\n \n use smallvec::SmallVec;\n use syntax_pos::{self, Pos, Span};\n@@ -94,7 +94,7 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt<'_>, sp: Span, tts: &[tokenstrea\n             while self.p.token != token::Eof {\n                 match panictry!(self.p.parse_item()) {\n                     Some(item) => ret.push(item),\n-                    None => self.p.diagnostic().span_fatal(self.p.token.span,\n+                    None => self.p.sess.span_diagnostic.span_fatal(self.p.token.span,\n                                                            &format!(\"expected item, found `{}`\",\n                                                                     self.p.this_token_to_string()))\n                                                .raise()", "previous_filename": "src/libsyntax/ext/source_util.rs"}, {"sha": "81bb32d79a2aa84eead684dbbe190065925ea2de", "filename": "src/libsyntax_ext/standard_library_imports.rs", "status": "renamed", "additions": 13, "deletions": 30, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fstandard_library_imports.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -1,37 +1,22 @@\n-use crate::ast;\n-use crate::attr;\n-use crate::edition::Edition;\n-use crate::ext::hygiene::{ExpnId, MacroKind};\n-use crate::symbol::{Ident, Symbol, kw, sym};\n-use crate::source_map::{ExpnInfo, ExpnKind, dummy_spanned, respan};\n-use crate::ptr::P;\n-use crate::tokenstream::TokenStream;\n-\n-use std::cell::Cell;\n-use std::iter;\n+use syntax::{ast, attr};\n+use syntax::edition::Edition;\n+use syntax::ext::hygiene::{ExpnId, MacroKind};\n+use syntax::ptr::P;\n+use syntax::source_map::{ExpnInfo, ExpnKind, dummy_spanned, respan};\n+use syntax::symbol::{Ident, Symbol, kw, sym};\n+use syntax::tokenstream::TokenStream;\n use syntax_pos::DUMMY_SP;\n \n-pub fn injected_crate_name() -> Option<&'static str> {\n-    INJECTED_CRATE_NAME.with(|name| name.get())\n-}\n-\n-thread_local! {\n-    // A `Symbol` might make more sense here, but it doesn't work, probably for\n-    // reasons relating to the use of thread-local storage for the Symbol\n-    // interner.\n-    static INJECTED_CRATE_NAME: Cell<Option<&'static str>> = Cell::new(None);\n-}\n+use std::iter;\n \n-pub fn maybe_inject_crates_ref(\n-    mut krate: ast::Crate,\n-    alt_std_name: Option<&str>,\n-    edition: Edition,\n-) -> ast::Crate {\n+pub fn inject(\n+    mut krate: ast::Crate, alt_std_name: Option<&str>, edition: Edition\n+) -> (ast::Crate, Option<Symbol>) {\n     let rust_2018 = edition >= Edition::Edition2018;\n \n     // the first name in this list is the crate name of the crate with the prelude\n     let names: &[&str] = if attr::contains_name(&krate.attrs, sym::no_core) {\n-        return krate;\n+        return (krate, None);\n     } else if attr::contains_name(&krate.attrs, sym::no_std) {\n         if attr::contains_name(&krate.attrs, sym::compiler_builtins) {\n             &[\"core\"]\n@@ -73,8 +58,6 @@ pub fn maybe_inject_crates_ref(\n     // the prelude.\n     let name = names[0];\n \n-    INJECTED_CRATE_NAME.with(|opt_name| opt_name.set(Some(name)));\n-\n     let span = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n         ExpnKind::Macro(MacroKind::Attr, sym::std_inject), DUMMY_SP, edition,\n         [sym::prelude_import][..].into(),\n@@ -108,5 +91,5 @@ pub fn maybe_inject_crates_ref(\n         tokens: None,\n     }));\n \n-    krate\n+    (krate, Some(Symbol::intern(name)))\n }", "previous_filename": "src/libsyntax/std_inject.rs"}, {"sha": "a2d93d01cec5623c9e463008ad69cb6baa11f0db", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -7,11 +7,44 @@ use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::print::pprust;\n+use syntax::source_map::respan;\n use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n \n use std::iter;\n \n+// #[test_case] is used by custom test authors to mark tests\n+// When building for test, it needs to make the item public and gensym the name\n+// Otherwise, we'll omit the item. This behavior means that any item annotated\n+// with #[test_case] is never addressable.\n+//\n+// We mark item with an inert attribute \"rustc_test_marker\" which the test generation\n+// logic will pick up on.\n+pub fn expand_test_case(\n+    ecx: &mut ExtCtxt<'_>,\n+    attr_sp: Span,\n+    meta_item: &ast::MetaItem,\n+    anno_item: Annotatable\n+) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(ecx, meta_item, sym::test_case);\n+\n+    if !ecx.ecfg.should_test { return vec![]; }\n+\n+    let sp = attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.id));\n+    let mut item = anno_item.expect_item();\n+    item = item.map(|mut item| {\n+        item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n+        item.ident = item.ident.gensym();\n+        item.attrs.push(\n+            ecx.attribute(sp,\n+                ecx.meta_word(sp, sym::rustc_test_marker))\n+        );\n+        item\n+    });\n+\n+    return vec![Annotatable::Item(item)]\n+}\n+\n pub fn expand_test(\n     cx: &mut ExtCtxt<'_>,\n     attr_sp: Span,"}, {"sha": "ea4a8d541ab9928f8636bdde77b24a1adfc17532", "filename": "src/libsyntax_ext/test_case.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c798dffac9dc8c82374db48f5b474690cc6e9686/src%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c798dffac9dc8c82374db48f5b474690cc6e9686/src%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_case.rs?ref=c798dffac9dc8c82374db48f5b474690cc6e9686", "patch": "@@ -1,44 +0,0 @@\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-\n-// #[test_case] is used by custom test authors to mark tests\n-// When building for test, it needs to make the item public and gensym the name\n-// Otherwise, we'll omit the item. This behavior means that any item annotated\n-// with #[test_case] is never addressable.\n-//\n-// We mark item with an inert attribute \"rustc_test_marker\" which the test generation\n-// logic will pick up on.\n-\n-use syntax::ast;\n-use syntax::attr::check_builtin_macro_attribute;\n-use syntax::ext::base::*;\n-use syntax::ext::build::AstBuilder;\n-use syntax::ext::hygiene::SyntaxContext;\n-use syntax::source_map::respan;\n-use syntax::symbol::sym;\n-use syntax_pos::Span;\n-\n-pub fn expand(\n-    ecx: &mut ExtCtxt<'_>,\n-    attr_sp: Span,\n-    meta_item: &ast::MetaItem,\n-    anno_item: Annotatable\n-) -> Vec<Annotatable> {\n-    check_builtin_macro_attribute(ecx, meta_item, sym::test_case);\n-\n-    if !ecx.ecfg.should_test { return vec![]; }\n-\n-    let sp = attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.id));\n-    let mut item = anno_item.expect_item();\n-    item = item.map(|mut item| {\n-        item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n-        item.ident = item.ident.gensym();\n-        item.attrs.push(\n-            ecx.attribute(sp,\n-                ecx.meta_word(sp, sym::rustc_test_marker))\n-        );\n-        item\n-    });\n-\n-    return vec![Annotatable::Item(item)]\n-}"}, {"sha": "848c797856ea9c39d3f99f55612d8a8973d2cac6", "filename": "src/libsyntax_ext/test_harness.rs", "status": "renamed", "additions": 24, "deletions": 54, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax_ext%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Flibsyntax_ext%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_harness.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -1,35 +1,23 @@\n // Code that generates a test runner to run all the tests in a crate\n \n-#![allow(dead_code)]\n-#![allow(unused_imports)]\n-\n-use HasTestSignature::*;\n-\n-use std::iter;\n-use std::slice;\n-use std::mem;\n-use std::vec;\n-\n use log::debug;\n use smallvec::{smallvec, SmallVec};\n-use syntax_pos::{DUMMY_SP, NO_EXPANSION, Span, SourceFile, BytePos};\n-\n-use crate::attr::{self, HasAttrs};\n-use crate::source_map::{self, SourceMap, ExpnInfo, ExpnKind, dummy_spanned, respan};\n-use crate::config;\n-use crate::entry::{self, EntryPointType};\n-use crate::ext::base::{ExtCtxt, Resolver};\n-use crate::ext::build::AstBuilder;\n-use crate::ext::expand::ExpansionConfig;\n-use crate::ext::hygiene::{self, ExpnId, SyntaxContext, MacroKind};\n-use crate::mut_visit::{*, ExpectOne};\n-use crate::feature_gate::Features;\n-use crate::util::map_in_place::MapInPlace;\n-use crate::parse::{token, ParseSess};\n-use crate::ast::{self, Ident};\n-use crate::ptr::P;\n-use crate::symbol::{self, Symbol, kw, sym};\n-use crate::ThinVec;\n+use syntax::ast::{self, Ident};\n+use syntax::attr;\n+use syntax::entry::{self, EntryPointType};\n+use syntax::ext::base::{ExtCtxt, Resolver};\n+use syntax::ext::build::AstBuilder;\n+use syntax::ext::expand::ExpansionConfig;\n+use syntax::ext::hygiene::{ExpnId, MacroKind};\n+use syntax::feature_gate::Features;\n+use syntax::mut_visit::{*, ExpectOne};\n+use syntax::parse::ParseSess;\n+use syntax::ptr::P;\n+use syntax::source_map::{ExpnInfo, ExpnKind, dummy_spanned};\n+use syntax::symbol::{kw, sym, Symbol};\n+use syntax_pos::{Span, DUMMY_SP};\n+\n+use std::{iter, mem};\n \n struct Test {\n     span: Span,\n@@ -42,22 +30,21 @@ struct TestCtxt<'a> {\n     ext_cx: ExtCtxt<'a>,\n     test_cases: Vec<Test>,\n     reexport_test_harness_main: Option<Symbol>,\n-    is_libtest: bool,\n-    features: &'a Features,\n     test_runner: Option<ast::Path>,\n-\n     // top-level re-export submodule, filled out after folding is finished\n     toplevel_reexport: Option<Ident>,\n }\n \n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n-pub fn modify_for_testing(sess: &ParseSess,\n-                          resolver: &mut dyn Resolver,\n-                          should_test: bool,\n-                          krate: &mut ast::Crate,\n-                          span_diagnostic: &errors::Handler,\n-                          features: &Features) {\n+pub fn inject(\n+    sess: &ParseSess,\n+    resolver: &mut dyn Resolver,\n+    should_test: bool,\n+    krate: &mut ast::Crate,\n+    span_diagnostic: &errors::Handler,\n+    features: &Features,\n+) {\n     // Check for #[reexport_test_harness_main = \"some_name\"] which\n     // creates a `use __test::main as some_name;`. This needs to be\n     // unconditional, so that the attribute is still marked as used in\n@@ -267,11 +254,7 @@ fn generate_test_harness(sess: &ParseSess,\n         path: Vec::new(),\n         test_cases: Vec::new(),\n         reexport_test_harness_main,\n-        // N.B., doesn't consider the value of `--crate-name` passed on the command line.\n-        is_libtest: attr::find_crate_name(&krate.attrs)\n-            .map(|s| s == sym::test).unwrap_or(false),\n         toplevel_reexport: None,\n-        features,\n         test_runner\n     };\n \n@@ -282,19 +265,6 @@ fn generate_test_harness(sess: &ParseSess,\n     }.visit_crate(krate);\n }\n \n-enum HasTestSignature {\n-    Yes,\n-    No(BadTestSignature),\n-}\n-\n-#[derive(PartialEq)]\n-enum BadTestSignature {\n-    NotEvenAFunction,\n-    WrongTypeSignature,\n-    NoArgumentsAllowed,\n-    ShouldPanicOnlyWithNoArgs,\n-}\n-\n /// Creates a function item for use as the main function of a test build.\n /// This function will call the `test_runner` as specified by the crate attribute\n fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {", "previous_filename": "src/libsyntax/test.rs"}, {"sha": "c0d4ce1243e015f0dee62a0a8ab701602600286a", "filename": "src/test/ui/issues/issue-45296.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fissues%2Fissue-45296.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fissues%2Fissue-45296.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45296.stderr?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -1,8 +1,8 @@\n error: an inner attribute is not permitted in this context\n-  --> $DIR/issue-45296.rs:4:7\n+  --> $DIR/issue-45296.rs:4:5\n    |\n LL |     #![allow(unused_variables)]\n-   |       ^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n "}, {"sha": "400a0276b3b608f8719535175c3ad846dd52b2c4", "filename": "src/test/ui/parser/attr.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fparser%2Fattr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fparser%2Fattr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr.stderr?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -1,8 +1,8 @@\n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr.rs:5:3\n+  --> $DIR/attr.rs:5:1\n    |\n LL | #![lang = \"foo\"]\n-   |   ^\n+   | ^^^^^^^^^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n "}, {"sha": "b012abc25e7f3bd2b7755ce28798495da3be813a", "filename": "src/test/ui/parser/inner-attr-after-doc-comment.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fparser%2Finner-attr-after-doc-comment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fparser%2Finner-attr-after-doc-comment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Finner-attr-after-doc-comment.stderr?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -1,8 +1,13 @@\n error: an inner attribute is not permitted following an outer doc comment\n-  --> $DIR/inner-attr-after-doc-comment.rs:6:3\n+  --> $DIR/inner-attr-after-doc-comment.rs:6:1\n    |\n-LL | #![recursion_limit=\"100\"]\n-   |   ^\n+LL | / /**\n+LL | |  * My module\n+LL | |  */\n+   | |___- previous doc comment\n+LL | \n+LL |   #![recursion_limit=\"100\"]\n+   |   ^^^^^^^^^^^^^^^^^^^^^^^^^ not permitted following an outer attibute\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n "}, {"sha": "070d9f47d96f925e04bcc7abb412ebb1e06d193f", "filename": "src/test/ui/parser/inner-attr.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fparser%2Finner-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fparser%2Finner-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Finner-attr.stderr?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -1,8 +1,11 @@\n error: an inner attribute is not permitted following an outer attribute\n-  --> $DIR/inner-attr.rs:3:3\n+  --> $DIR/inner-attr.rs:3:1\n    |\n+LL | #[feature(lang_items)]\n+   | ---------------------- previous outer attribute\n+LL | \n LL | #![recursion_limit=\"100\"]\n-   |   ^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^ not permitted following an outer attibute\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n "}, {"sha": "3002013881249c8c526681f9c70e636ab8bf8c88", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,60 @@\n+// check-pass\n+\n+use std::pin::Pin;\n+use std::task::{Context, Poll};\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn pin_ref(self: Pin<&Self>) -> Pin<&Self> { self }\n+\n+    fn pin_mut(self: Pin<&mut Self>) -> Pin<&mut Self> { self }\n+\n+    fn pin_pin_pin_ref(self: Pin<Pin<Pin<&Self>>>) -> Pin<Pin<Pin<&Self>>> { self }\n+\n+    fn pin_ref_impl_trait(self: Pin<&Self>) -> impl Clone + '_ { self }\n+\n+    fn b(self: Pin<&Foo>, f: &Foo) -> Pin<&Foo> { self }\n+}\n+\n+type Alias<T> = Pin<T>;\n+impl Foo {\n+    fn bar<'a>(self: Alias<&Self>, arg: &'a ()) -> Alias<&Self> { self }\n+}\n+\n+struct Bar<T: Unpin, U: Unpin> {\n+    field1: T,\n+    field2: U,\n+}\n+\n+impl<T: Unpin, U: Unpin> Bar<T, U> {\n+    fn fields(self: Pin<&mut Self>) -> (Pin<&mut T>, Pin<&mut U>) {\n+        let this = self.get_mut();\n+        (Pin::new(&mut this.field1), Pin::new(&mut this.field2))\n+    }\n+}\n+\n+trait AsyncBufRead {\n+    fn poll_fill_buf(self: Pin<&mut Self>, cx: &mut Context<'_>)\n+        -> Poll<std::io::Result<&[u8]>>;\n+}\n+\n+struct Baz(Vec<u8>);\n+\n+impl AsyncBufRead for Baz {\n+    fn poll_fill_buf(self: Pin<&mut Self>, cx: &mut Context<'_>)\n+        -> Poll<std::io::Result<&[u8]>>\n+    {\n+        Poll::Ready(Ok(&self.get_mut().0))\n+    }\n+}\n+\n+fn main() {\n+    let mut foo = Foo;\n+    { Pin::new(&foo).pin_ref() };\n+    { Pin::new(&mut foo).pin_mut() };\n+    { Pin::new(Pin::new(Pin::new(&foo))).pin_pin_pin_ref() };\n+    { Pin::new(&foo).pin_ref_impl_trait() };\n+    let mut bar = Bar { field1: 0u8, field2: 1u8 };\n+    { Pin::new(&mut bar).fields() };\n+}"}, {"sha": "dcfc9ba511d740a7ec03c0e2a25080a81e69fb5d", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait.nll.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.nll.stderr?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,14 @@\n+error: lifetime may not live long enough\n+  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:8:31\n+   |\n+LL |     fn f(self: Pin<&Self>) -> impl Clone { self }\n+   |                    -          ^^^^^^^^^^ opaque type requires that `'1` must outlive `'static`\n+   |                    |\n+   |                    let's call the lifetime of this reference `'1`\n+help: to allow this `impl Trait` to capture borrowed data with lifetime `'1`, add `'_` as a constraint\n+   |\n+LL |     fn f(self: Pin<&Self>) -> impl Clone + '_ { self }\n+   |                               ^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "ad8959727cbee5abb0405a4dd7ebc78fb618e0f6", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,13 @@\n+// compile-fail\n+\n+use std::pin::Pin;\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn f(self: Pin<&Self>) -> impl Clone { self } //~ ERROR cannot infer an appropriate lifetime\n+}\n+\n+fn main() {\n+    { Pin::new(&Foo).f() };\n+}"}, {"sha": "5118280e7ec0cbde38da93b7c01d6a0a10a5d111", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,20 @@\n+error: cannot infer an appropriate lifetime\n+  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:8:44\n+   |\n+LL |     fn f(self: Pin<&Self>) -> impl Clone { self }\n+   |                               ----------   ^^^^ ...but this borrow...\n+   |                               |\n+   |                               this return type evaluates to the `'static` lifetime...\n+   |\n+note: ...can't outlive the anonymous lifetime #1 defined on the method body at 8:5\n+  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:8:5\n+   |\n+LL |     fn f(self: Pin<&Self>) -> impl Clone { self }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: you can add a constraint to the return type to make it last less than `'static` and match the anonymous lifetime #1 defined on the method body at 8:5\n+   |\n+LL |     fn f(self: Pin<&Self>) -> impl Clone + '_ { self }\n+   |                               ^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "8a0f1a804ad826efbadab059e809da3b39ff5499", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_mismatch.nll.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch.nll.stderr?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,28 @@\n+error: lifetime may not live long enough\n+  --> $DIR/arbitrary_self_types_pin_lifetime_mismatch.rs:8:46\n+   |\n+LL |     fn a(self: Pin<&Foo>, f: &Foo) -> &Foo { f }\n+   |                    -         -               ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |                    |         |\n+   |                    |         let's call the lifetime of this reference `'1`\n+   |                    let's call the lifetime of this reference `'2`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/arbitrary_self_types_pin_lifetime_mismatch.rs:10:69\n+   |\n+LL |     fn c(self: Pin<&Self>, f: &Foo, g: &Foo) -> (Pin<&Foo>, &Foo) { (self, f) }\n+   |                    -          -                                     ^^^^^^^^^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |                    |          |\n+   |                    |          let's call the lifetime of this reference `'1`\n+   |                    let's call the lifetime of this reference `'2`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/arbitrary_self_types_pin_lifetime_mismatch.rs:15:58\n+   |\n+LL |     fn bar<'a>(self: Alias<&Self>, arg: &'a ()) -> &() { arg }\n+   |            --  ---- has type `std::pin::Pin<&'1 Foo>`    ^^^ function was supposed to return data with lifetime `'1` but it is returning data with lifetime `'a`\n+   |            |\n+   |            lifetime `'a` defined here\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "fc5f94201b81aecc82b63c2e6e0b18061a490720", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_mismatch.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,18 @@\n+// compile-fail\n+\n+use std::pin::Pin;\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn a(self: Pin<&Foo>, f: &Foo) -> &Foo { f } //~ ERROR E0623\n+\n+    fn c(self: Pin<&Self>, f: &Foo, g: &Foo) -> (Pin<&Foo>, &Foo) { (self, f) } //~ ERROR E0623\n+}\n+\n+type Alias<T> = Pin<T>;\n+impl Foo {\n+    fn bar<'a>(self: Alias<&Self>, arg: &'a ()) -> &() { arg } //~ ERROR E0623\n+}\n+\n+fn main() {}"}, {"sha": "3296e14f806e1822d61cc39f4139e224f38a8304", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_mismatch.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch.stderr?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,26 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/arbitrary_self_types_pin_lifetime_mismatch.rs:8:46\n+   |\n+LL |     fn a(self: Pin<&Foo>, f: &Foo) -> &Foo { f }\n+   |                              ----     ----   ^ ...but data from `f` is returned here\n+   |                              |\n+   |                              this parameter and the return type are declared with different lifetimes...\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/arbitrary_self_types_pin_lifetime_mismatch.rs:10:76\n+   |\n+LL |     fn c(self: Pin<&Self>, f: &Foo, g: &Foo) -> (Pin<&Foo>, &Foo) { (self, f) }\n+   |                               ----              -----------------          ^ ...but data from `f` is returned here\n+   |                               |\n+   |                               this parameter and the return type are declared with different lifetimes...\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/arbitrary_self_types_pin_lifetime_mismatch.rs:15:58\n+   |\n+LL |     fn bar<'a>(self: Alias<&Self>, arg: &'a ()) -> &() { arg }\n+   |                                         ------     ---   ^^^ ...but data from `arg` is returned here\n+   |                                         |\n+   |                                         this parameter and the return type are declared with different lifetimes...\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "7ace2e0c89039ba65da249ce4246b4285a44293e", "filename": "src/test/ui/self/elision/README.md", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2FREADME.md?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,44 @@\n+Test cases intended to document behavior and try to exhaustively\n+explore the combinations.\n+\n+## Confidence\n+\n+These tests are not yet considered 100% normative, in that some\n+aspects of the current behavior are not desirable. This is expressed\n+in the \"confidence\" field in the following table. Values:\n+\n+| Confidence | Interpretation |\n+| --- | --- |\n+| 100% | this will remain recommended behavior |\n+| 75% | unclear whether we will continue to accept this |\n+| 50% | this will likely be deprecated but remain valid |\n+| 25% | this could change in the future |\n+| 0% | this is definitely bogus and will likely change in the future in *some* way |\n+\n+## Tests\n+\n+| Test file | `Self` type | Pattern | Current elision behavior | Confidence |\n+| --- | --- | --- | --- | --- |\n+| `self.rs` | `Struct` | `Self` | ignore `self` parameter | 100% |\n+| `struct.rs` | `Struct` | `Struct` | ignore `self` parameter | 100% |\n+| `alias.rs` | `Struct` | `Alias` | ignore `self` parameter | 100% |\n+| `ref-self.rs` | `Struct` | `&Self` | take lifetime from `&Self` | 100% |\n+| `ref-mut-self.rs` | `Struct` | `&mut Self` | take lifetime from `&mut Self` | 100% |\n+| `ref-struct.rs` | `Struct` | `&Struct` | take lifetime from `&Self` | 50% |\n+| `ref-mut-struct.rs` | `Struct` | `&mut Struct` | take lifetime from `&mut Self` | 50% |\n+| `ref-alias.rs` | `Struct` | `&Alias` | ignore `Alias` | 0% |\n+| `ref-mut-alias.rs` | `Struct` | `&mut Alias` | ignore `Alias` | 0% |\n+| `lt-self.rs` | `Struct<'a>` | `Self` | ignore `Self` (and hence `'a`) | 25% |\n+| `lt-struct.rs` | `Struct<'a>` | `Self` | ignore `Self` (and hence `'a`) | 0% |\n+| `lt-alias.rs`   | `Alias<'a>` | `Self` | ignore `Self` (and hence `'a`) | 0% |\n+| `lt-ref-self.rs` | `Struct<'a>` | `&Self` | take lifetime from `&Self` | 75% |\n+\n+In each case, we test the following patterns:\n+\n+- `self: XXX`\n+- `self: Box<XXX>`\n+- `self: Pin<XXX>`\n+- `self: Box<Box<XXX>>`\n+- `self: Box<Pin<XXX>>`\n+\n+In the non-reference cases, `Pin` causes errors so we substitute `Rc`."}, {"sha": "b5aacfaeec427355b0d59bc3c153270f42448e1a", "filename": "src/test/ui/self/elision/alias.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Falias.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,36 @@\n+// check-pass\n+\n+#![feature(arbitrary_self_types)]\n+#![allow(non_snake_case)]\n+\n+use std::rc::Rc;\n+\n+struct Struct { }\n+\n+type Alias = Struct;\n+\n+impl Struct {\n+    // Test using an alias for `Struct`:\n+\n+    fn alias(self: Alias, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn box_Alias(self: Box<Alias>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn rc_Alias(self: Rc<Alias>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn box_box_Alias(self: Box<Box<Alias>>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn box_rc_Alias(self: Box<Rc<Alias>>, f: &u32) -> &u32 {\n+        f\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "163eb49383a877169f9e6ae0fd8bc69cab7f669a", "filename": "src/test/ui/self/elision/assoc.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fassoc.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,40 @@\n+// check-pass\n+\n+#![feature(arbitrary_self_types)]\n+#![allow(non_snake_case)]\n+\n+use std::rc::Rc;\n+\n+trait Trait {\n+    type AssocType;\n+}\n+\n+struct Struct { }\n+\n+impl Trait for Struct {\n+    type AssocType = Self;\n+}\n+\n+impl Struct {\n+    fn assoc(self: <Struct as Trait>::AssocType, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn box_AssocType(self: Box<<Struct as Trait>::AssocType>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn rc_AssocType(self: Rc<<Struct as Trait>::AssocType>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn box_box_AssocType(self: Box<Box<<Struct as Trait>::AssocType>>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn box_rc_AssocType(self: Box<Rc<<Struct as Trait>::AssocType>>, f: &u32) -> &u32 {\n+        f\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "df2300deda25fd3b40a989f45b0238a611620e63", "filename": "src/test/ui/self/elision/lt-alias.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Flt-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Flt-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Flt-alias.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,38 @@\n+// check-pass\n+\n+#![feature(arbitrary_self_types)]\n+#![allow(non_snake_case)]\n+\n+use std::rc::Rc;\n+\n+struct Struct<'a> { x: &'a u32 }\n+\n+type Alias<'a> = Struct<'a>;\n+\n+impl<'a> Alias<'a> {\n+    fn take_self(self, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Alias(self: Alias<'a>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Box_Alias(self: Box<Alias<'a>>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Box_Box_Alias(self: Box<Box<Alias<'a>>>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Rc_Alias(self: Rc<Alias<'a>>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Box_Rc_Alias(self: Box<Rc<Alias<'a>>>, f: &u32) -> &u32 {\n+        f\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "70573598fcb16b4cbd9d90c404e26740601c0378", "filename": "src/test/ui/self/elision/lt-assoc.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Flt-assoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Flt-assoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Flt-assoc.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,44 @@\n+// check-pass\n+\n+#![feature(arbitrary_self_types)]\n+#![allow(non_snake_case)]\n+\n+use std::rc::Rc;\n+\n+trait Trait {\n+    type AssocType;\n+}\n+\n+struct Struct<'a> { x: &'a u32 }\n+\n+impl<'a> Trait for Struct<'a> {\n+    type AssocType = Self;\n+}\n+\n+impl<'a> Struct<'a> {\n+    fn take_self(self, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_AssocType(self: <Struct<'a> as Trait>::AssocType, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Box_AssocType(self: Box<<Struct<'a> as Trait>::AssocType>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Box_Box_AssocType(self: Box<Box<<Struct<'a> as Trait>::AssocType>>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Rc_AssocType(self: Rc<<Struct<'a> as Trait>::AssocType>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Box_Rc_AssocType(self: Box<Rc<<Struct<'a> as Trait>::AssocType>>, f: &u32) -> &u32 {\n+        f\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "e97a01e746d4b8e5a52bb872a6d6e1ed6466c339", "filename": "src/test/ui/self/elision/lt-ref-self.nll.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self.nll.stderr?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,62 @@\n+error: lifetime may not live long enough\n+  --> $DIR/lt-ref-self.rs:12:9\n+   |\n+LL |     fn ref_self(&self, f: &u32) -> &u32 {\n+   |                 -         - let's call the lifetime of this reference `'1`\n+   |                 |\n+   |                 let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/lt-ref-self.rs:18:9\n+   |\n+LL |     fn ref_Self(self: &Self, f: &u32) -> &u32 {\n+   |                       -         - let's call the lifetime of this reference `'1`\n+   |                       |\n+   |                       let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/lt-ref-self.rs:22:9\n+   |\n+LL |     fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n+   |                               -          - let's call the lifetime of this reference `'1`\n+   |                               |\n+   |                               let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/lt-ref-self.rs:26:9\n+   |\n+LL |     fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n+   |                               -          - let's call the lifetime of this reference `'1`\n+   |                               |\n+   |                               let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/lt-ref-self.rs:30:9\n+   |\n+LL |     fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n+   |                                       -           - let's call the lifetime of this reference `'1`\n+   |                                       |\n+   |                                       let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/lt-ref-self.rs:34:9\n+   |\n+LL |     fn box_pin_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n+   |                                   -           - let's call the lifetime of this reference `'1`\n+   |                                   |\n+   |                                   let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "8abf2876a5c1b155136dd6fbe39fe872a7661aca", "filename": "src/test/ui/self/elision/lt-ref-self.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,38 @@\n+#![feature(arbitrary_self_types)]\n+#![allow(non_snake_case)]\n+\n+use std::pin::Pin;\n+\n+struct Struct<'a> { data: &'a u32 }\n+\n+impl<'a> Struct<'a> {\n+    // Test using `&self` sugar:\n+\n+    fn ref_self(&self, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    // Test using `&Self` explicitly:\n+\n+    fn ref_Self(self: &Self, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn box_pin_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "f73b3eddd38215aa5ad164abfff6d337fec839e6", "filename": "src/test/ui/self/elision/lt-ref-self.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self.stderr?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,62 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/lt-ref-self.rs:12:9\n+   |\n+LL |     fn ref_self(&self, f: &u32) -> &u32 {\n+   |                           ----     ----\n+   |                           |\n+   |                           this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/lt-ref-self.rs:18:9\n+   |\n+LL |     fn ref_Self(self: &Self, f: &u32) -> &u32 {\n+   |                                 ----     ----\n+   |                                 |\n+   |                                 this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/lt-ref-self.rs:22:9\n+   |\n+LL |     fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n+   |                                          ----     ----\n+   |                                          |\n+   |                                          this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/lt-ref-self.rs:26:9\n+   |\n+LL |     fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n+   |                                          ----     ----\n+   |                                          |\n+   |                                          this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/lt-ref-self.rs:30:9\n+   |\n+LL |     fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n+   |                                                   ----     ----\n+   |                                                   |\n+   |                                                   this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/lt-ref-self.rs:34:9\n+   |\n+LL |     fn box_pin_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n+   |                                               ----     ----\n+   |                                               |\n+   |                                               this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "9b0ee5e42a51ade616bb70d5df839257c7943155", "filename": "src/test/ui/self/elision/lt-self.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Flt-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Flt-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Flt-self.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,49 @@\n+// check-pass\n+\n+#![feature(arbitrary_self_types)]\n+#![allow(non_snake_case)]\n+\n+use std::pin::Pin;\n+use std::rc::Rc;\n+\n+struct Struct<'a> {\n+    x: &'a u32\n+}\n+\n+impl<'a> Struct<'a> {\n+    fn take_self(self, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Self(self: Self, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Box_Self(self: Box<Self>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Box_Box_Self(self: Box<Box<Self>>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Rc_Self(self: Rc<Self>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Box_Rc_Self(self: Box<Rc<Self>>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    // N/A\n+    //fn take_Pin_Self(self: Pin<Self>, f: &u32) -> &u32 {\n+    //    f\n+    //}\n+\n+    // N/A\n+    //fn take_Box_Pin_Self(self: Box<Pin<Self>>, f: &u32) -> &u32 {\n+    //    f\n+    //}\n+}\n+\n+fn main() { }"}, {"sha": "e41dfbbe0bf0d1265b61863cdb05dde49b12b6ec", "filename": "src/test/ui/self/elision/lt-struct.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Flt-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Flt-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Flt-struct.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,36 @@\n+// check-pass\n+\n+#![feature(arbitrary_self_types)]\n+#![allow(non_snake_case)]\n+\n+use std::rc::Rc;\n+\n+struct Struct<'a> { x: &'a u32 }\n+\n+impl<'a> Struct<'a> {\n+    fn take_self(self, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Struct(self: Struct<'a>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Box_Struct(self: Box<Struct<'a>>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Box_Box_Struct(self: Box<Box<Struct<'a>>>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Rc_Struct(self: Rc<Struct<'a>>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Box_Rc_Struct(self: Box<Rc<Struct<'a>>>, f: &u32) -> &u32 {\n+        f\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "f39613d0c90072edb30f67e9bb485503f4a083fb", "filename": "src/test/ui/self/elision/multiple-ref-self.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fmultiple-ref-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fmultiple-ref-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fmultiple-ref-self.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,43 @@\n+// check-pass\n+\n+#![feature(arbitrary_self_types)]\n+#![allow(non_snake_case)]\n+\n+use std::marker::PhantomData;\n+use std::ops::Deref;\n+use std::pin::Pin;\n+\n+struct Struct { }\n+\n+struct Wrap<T, P>(T, PhantomData<P>);\n+\n+impl<T, P> Deref for Wrap<T, P> {\n+    type Target = T;\n+    fn deref(&self) -> &T { &self.0 }\n+}\n+\n+impl Struct {\n+    // Test using multiple `&Self`:\n+\n+    fn wrap_ref_Self_ref_Self(self: Wrap<&Self, &Self>, f: &u8) -> &u8 {\n+        f\n+    }\n+\n+    fn box_wrap_ref_Self_ref_Self(self: Box<Wrap<&Self, &Self>>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn pin_wrap_ref_Self_ref_Self(self: Pin<Wrap<&Self, &Self>>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn box_box_wrap_ref_Self_ref_Self(self: Box<Box<Wrap<&Self, &Self>>>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn box_pin_wrap_ref_Self_ref_Self(self: Box<Pin<Wrap<&Self, &Self>>>, f: &u32) -> &u32 {\n+        f\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "d83ac612235e35766fc89c03863fd0b9ffbfb1b1", "filename": "src/test/ui/self/elision/ref-alias.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-alias.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,39 @@\n+// check-pass\n+\n+#![feature(arbitrary_self_types)]\n+#![allow(non_snake_case)]\n+\n+use std::pin::Pin;\n+\n+struct Struct { }\n+\n+type Alias = Struct;\n+\n+impl Struct {\n+    // Test using an alias for `Struct`:\n+    //\n+    // FIXME. We currently fail to recognize this as the self type, which\n+    // feels like a bug.\n+\n+    fn ref_Alias(self: &Alias, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn box_ref_Alias(self: Box<&Alias>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn pin_ref_Alias(self: Pin<&Alias>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn box_box_ref_Alias(self: Box<Box<&Alias>>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn box_pin_ref_Alias(self: Box<Pin<&Alias>>, f: &u32) -> &u32 {\n+        f\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "f9354bc884710e42e21e1adb0d6b2f22d1ec3d25", "filename": "src/test/ui/self/elision/ref-assoc.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-assoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-assoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-assoc.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,40 @@\n+// check-pass\n+\n+#![feature(arbitrary_self_types)]\n+#![allow(non_snake_case)]\n+\n+use std::pin::Pin;\n+\n+trait Trait {\n+    type AssocType;\n+}\n+\n+struct Struct { }\n+\n+impl Trait for Struct {\n+    type AssocType = Self;\n+}\n+\n+impl Struct {\n+    fn ref_AssocType(self: &<Struct as Trait>::AssocType, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn box_ref_AssocType(self: Box<&<Struct as Trait>::AssocType>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn pin_ref_AssocType(self: Pin<&<Struct as Trait>::AssocType>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn box_box_ref_AssocType(self: Box<Box<&<Struct as Trait>::AssocType>>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn box_pin_ref_AssocType(self: Box<Pin<&<Struct as Trait>::AssocType>>, f: &u32) -> &u32 {\n+        f\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "395816f8f5d80f75aeaedd719bfd05663c8704d3", "filename": "src/test/ui/self/elision/ref-mut-alias.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-alias.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,36 @@\n+// check-pass\n+\n+#![feature(arbitrary_self_types)]\n+#![allow(non_snake_case)]\n+\n+use std::pin::Pin;\n+\n+struct Struct { }\n+\n+type Alias = Struct;\n+\n+impl Struct {\n+    // Test using an alias for `Struct`:\n+\n+    fn ref_Alias(self: &mut Alias, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn box_ref_Alias(self: Box<&mut Alias>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn pin_ref_Alias(self: Pin<&mut Alias>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn box_box_ref_Alias(self: Box<Box<&mut Alias>>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn box_pin_ref_Alias(self: Box<Pin<&mut Alias>>, f: &u32) -> &u32 {\n+        f\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "3a8ae3fdcba8c0ff759472b613d5d56bb719fde6", "filename": "src/test/ui/self/elision/ref-mut-self.nll.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self.nll.stderr?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,62 @@\n+error: lifetime may not live long enough\n+  --> $DIR/ref-mut-self.rs:12:9\n+   |\n+LL |     fn ref_self(&mut self, f: &u32) -> &u32 {\n+   |                 -             - let's call the lifetime of this reference `'1`\n+   |                 |\n+   |                 let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-mut-self.rs:18:9\n+   |\n+LL |     fn ref_Self(self: &mut Self, f: &u32) -> &u32 {\n+   |                       -             - let's call the lifetime of this reference `'1`\n+   |                       |\n+   |                       let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-mut-self.rs:22:9\n+   |\n+LL |     fn box_ref_Self(self: Box<&mut Self>, f: &u32) -> &u32 {\n+   |                               -              - let's call the lifetime of this reference `'1`\n+   |                               |\n+   |                               let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-mut-self.rs:26:9\n+   |\n+LL |     fn pin_ref_Self(self: Pin<&mut Self>, f: &u32) -> &u32 {\n+   |                               -              - let's call the lifetime of this reference `'1`\n+   |                               |\n+   |                               let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-mut-self.rs:30:9\n+   |\n+LL |     fn box_box_ref_Self(self: Box<Box<&mut Self>>, f: &u32) -> &u32 {\n+   |                                       -               - let's call the lifetime of this reference `'1`\n+   |                                       |\n+   |                                       let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-mut-self.rs:34:9\n+   |\n+LL |     fn box_pin_ref_Self(self: Box<Pin<&mut Self>>, f: &u32) -> &u32 {\n+   |                                       -               - let's call the lifetime of this reference `'1`\n+   |                                       |\n+   |                                       let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "a7ea47bb7f6de87e037492dff3b737b6254ef465", "filename": "src/test/ui/self/elision/ref-mut-self.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,38 @@\n+#![feature(arbitrary_self_types)]\n+#![allow(non_snake_case)]\n+\n+use std::pin::Pin;\n+\n+struct Struct { }\n+\n+impl Struct {\n+    // Test using `&mut self` sugar:\n+\n+    fn ref_self(&mut self, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    // Test using `&mut Self` explicitly:\n+\n+    fn ref_Self(self: &mut Self, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn box_ref_Self(self: Box<&mut Self>, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn pin_ref_Self(self: Pin<&mut Self>, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn box_box_ref_Self(self: Box<Box<&mut Self>>, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn box_pin_ref_Self(self: Box<Pin<&mut Self>>, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "37984cd72fbace0d3d7cdd38d830834ee0fbf551", "filename": "src/test/ui/self/elision/ref-mut-self.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self.stderr?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,62 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-mut-self.rs:12:9\n+   |\n+LL |     fn ref_self(&mut self, f: &u32) -> &u32 {\n+   |                               ----     ----\n+   |                               |\n+   |                               this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-mut-self.rs:18:9\n+   |\n+LL |     fn ref_Self(self: &mut Self, f: &u32) -> &u32 {\n+   |                                     ----     ----\n+   |                                     |\n+   |                                     this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-mut-self.rs:22:9\n+   |\n+LL |     fn box_ref_Self(self: Box<&mut Self>, f: &u32) -> &u32 {\n+   |                                              ----     ----\n+   |                                              |\n+   |                                              this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-mut-self.rs:26:9\n+   |\n+LL |     fn pin_ref_Self(self: Pin<&mut Self>, f: &u32) -> &u32 {\n+   |                                              ----     ----\n+   |                                              |\n+   |                                              this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-mut-self.rs:30:9\n+   |\n+LL |     fn box_box_ref_Self(self: Box<Box<&mut Self>>, f: &u32) -> &u32 {\n+   |                                                       ----     ----\n+   |                                                       |\n+   |                                                       this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-mut-self.rs:34:9\n+   |\n+LL |     fn box_pin_ref_Self(self: Box<Pin<&mut Self>>, f: &u32) -> &u32 {\n+   |                                                       ----     ----\n+   |                                                       |\n+   |                                                       this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "66152ba40a5f5bdf51eeeb82a93990c87d28cf3f", "filename": "src/test/ui/self/elision/ref-mut-struct.nll.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct.nll.stderr?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,52 @@\n+error: lifetime may not live long enough\n+  --> $DIR/ref-mut-struct.rs:12:9\n+   |\n+LL |     fn ref_Struct(self: &mut Struct, f: &u32) -> &u32 {\n+   |                         -               - let's call the lifetime of this reference `'1`\n+   |                         |\n+   |                         let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-mut-struct.rs:16:9\n+   |\n+LL |     fn box_ref_Struct(self: Box<&mut Struct>, f: &u32) -> &u32 {\n+   |                                 -                - let's call the lifetime of this reference `'1`\n+   |                                 |\n+   |                                 let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-mut-struct.rs:20:9\n+   |\n+LL |     fn pin_ref_Struct(self: Pin<&mut Struct>, f: &u32) -> &u32 {\n+   |                                 -                - let's call the lifetime of this reference `'1`\n+   |                                 |\n+   |                                 let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-mut-struct.rs:24:9\n+   |\n+LL |     fn box_box_ref_Struct(self: Box<Box<&mut Struct>>, f: &u32) -> &u32 {\n+   |                                         -                 - let's call the lifetime of this reference `'1`\n+   |                                         |\n+   |                                         let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-mut-struct.rs:28:9\n+   |\n+LL |     fn box_pin_ref_Struct(self: Box<Pin<&mut Struct>>, f: &u32) -> &u32 {\n+   |                                         -                 - let's call the lifetime of this reference `'1`\n+   |                                         |\n+   |                                         let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "795ddf8ac1354066681f475f85c027ca48c6b536", "filename": "src/test/ui/self/elision/ref-mut-struct.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,32 @@\n+#![feature(arbitrary_self_types)]\n+#![allow(non_snake_case)]\n+\n+use std::pin::Pin;\n+\n+struct Struct { }\n+\n+impl Struct {\n+    // Test using `&mut Struct` explicitly:\n+\n+    fn ref_Struct(self: &mut Struct, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn box_ref_Struct(self: Box<&mut Struct>, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn pin_ref_Struct(self: Pin<&mut Struct>, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn box_box_ref_Struct(self: Box<Box<&mut Struct>>, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn box_pin_ref_Struct(self: Box<Pin<&mut Struct>>, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "2a4826905b94a0b8e1d04169a4b3baae6e20a160", "filename": "src/test/ui/self/elision/ref-mut-struct.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct.stderr?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,52 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-mut-struct.rs:12:9\n+   |\n+LL |     fn ref_Struct(self: &mut Struct, f: &u32) -> &u32 {\n+   |                                         ----     ----\n+   |                                         |\n+   |                                         this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-mut-struct.rs:16:9\n+   |\n+LL |     fn box_ref_Struct(self: Box<&mut Struct>, f: &u32) -> &u32 {\n+   |                                                  ----     ----\n+   |                                                  |\n+   |                                                  this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-mut-struct.rs:20:9\n+   |\n+LL |     fn pin_ref_Struct(self: Pin<&mut Struct>, f: &u32) -> &u32 {\n+   |                                                  ----     ----\n+   |                                                  |\n+   |                                                  this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-mut-struct.rs:24:9\n+   |\n+LL |     fn box_box_ref_Struct(self: Box<Box<&mut Struct>>, f: &u32) -> &u32 {\n+   |                                                           ----     ----\n+   |                                                           |\n+   |                                                           this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-mut-struct.rs:28:9\n+   |\n+LL |     fn box_pin_ref_Struct(self: Box<Pin<&mut Struct>>, f: &u32) -> &u32 {\n+   |                                                           ----     ----\n+   |                                                           |\n+   |                                                           this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "20045be0527a4a233b03d0db20e26525a58906cc", "filename": "src/test/ui/self/elision/ref-self.nll.stderr", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self.nll.stderr?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,72 @@\n+error: lifetime may not live long enough\n+  --> $DIR/ref-self.rs:21:9\n+   |\n+LL |     fn ref_self(&self, f: &u32) -> &u32 {\n+   |                 -         - let's call the lifetime of this reference `'1`\n+   |                 |\n+   |                 let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-self.rs:27:9\n+   |\n+LL |     fn ref_Self(self: &Self, f: &u32) -> &u32 {\n+   |                       -         - let's call the lifetime of this reference `'1`\n+   |                       |\n+   |                       let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-self.rs:31:9\n+   |\n+LL |     fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n+   |                               -          - let's call the lifetime of this reference `'1`\n+   |                               |\n+   |                               let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-self.rs:35:9\n+   |\n+LL |     fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n+   |                               -          - let's call the lifetime of this reference `'1`\n+   |                               |\n+   |                               let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-self.rs:39:9\n+   |\n+LL |     fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n+   |                                       -           - let's call the lifetime of this reference `'1`\n+   |                                       |\n+   |                                       let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-self.rs:43:9\n+   |\n+LL |     fn box_pin_ref_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n+   |                                       -           - let's call the lifetime of this reference `'1`\n+   |                                       |\n+   |                                       let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-self.rs:47:9\n+   |\n+LL |     fn wrap_ref_Self_Self(self: Wrap<&Self, Self>, f: &u8) -> &u8 {\n+   |                                      -                - let's call the lifetime of this reference `'1`\n+   |                                      |\n+   |                                      let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "e389d8518ada4f6a375e4d48c8cba91324aed168", "filename": "src/test/ui/self/elision/ref-self.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,51 @@\n+#![feature(arbitrary_self_types)]\n+#![allow(non_snake_case)]\n+\n+use std::marker::PhantomData;\n+use std::ops::Deref;\n+use std::pin::Pin;\n+\n+struct Struct { }\n+\n+struct Wrap<T, P>(T, PhantomData<P>);\n+\n+impl<T, P> Deref for Wrap<T, P> {\n+    type Target = T;\n+    fn deref(&self) -> &T { &self.0 }\n+}\n+\n+impl Struct {\n+    // Test using `&self` sugar:\n+\n+    fn ref_self(&self, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    // Test using `&Self` explicitly:\n+\n+    fn ref_Self(self: &Self, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn box_pin_ref_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn wrap_ref_Self_Self(self: Wrap<&Self, Self>, f: &u8) -> &u8 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "611498f18da4232030acf5c7713950cd75c96186", "filename": "src/test/ui/self/elision/ref-self.stderr", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self.stderr?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,72 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-self.rs:21:9\n+   |\n+LL |     fn ref_self(&self, f: &u32) -> &u32 {\n+   |                           ----     ----\n+   |                           |\n+   |                           this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-self.rs:27:9\n+   |\n+LL |     fn ref_Self(self: &Self, f: &u32) -> &u32 {\n+   |                                 ----     ----\n+   |                                 |\n+   |                                 this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-self.rs:31:9\n+   |\n+LL |     fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n+   |                                          ----     ----\n+   |                                          |\n+   |                                          this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-self.rs:35:9\n+   |\n+LL |     fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n+   |                                          ----     ----\n+   |                                          |\n+   |                                          this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-self.rs:39:9\n+   |\n+LL |     fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n+   |                                                   ----     ----\n+   |                                                   |\n+   |                                                   this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-self.rs:43:9\n+   |\n+LL |     fn box_pin_ref_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n+   |                                                   ----     ----\n+   |                                                   |\n+   |                                                   this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-self.rs:47:9\n+   |\n+LL |     fn wrap_ref_Self_Self(self: Wrap<&Self, Self>, f: &u8) -> &u8 {\n+   |                                                       ---     ---\n+   |                                                       |\n+   |                                                       this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "a258bc9f7439038b5f6498418312edab3ae495c5", "filename": "src/test/ui/self/elision/ref-struct.nll.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct.nll.stderr?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,52 @@\n+error: lifetime may not live long enough\n+  --> $DIR/ref-struct.rs:12:9\n+   |\n+LL |     fn ref_Struct(self: &Struct, f: &u32) -> &u32 {\n+   |                         -           - let's call the lifetime of this reference `'1`\n+   |                         |\n+   |                         let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-struct.rs:16:9\n+   |\n+LL |     fn box_ref_Struct(self: Box<&Struct>, f: &u32) -> &u32 {\n+   |                                 -            - let's call the lifetime of this reference `'1`\n+   |                                 |\n+   |                                 let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-struct.rs:20:9\n+   |\n+LL |     fn pin_ref_Struct(self: Pin<&Struct>, f: &u32) -> &u32 {\n+   |                                 -            - let's call the lifetime of this reference `'1`\n+   |                                 |\n+   |                                 let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-struct.rs:24:9\n+   |\n+LL |     fn box_box_ref_Struct(self: Box<Box<&Struct>>, f: &u32) -> &u32 {\n+   |                                         -             - let's call the lifetime of this reference `'1`\n+   |                                         |\n+   |                                         let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/ref-struct.rs:28:9\n+   |\n+LL |     fn box_pin_Struct(self: Box<Pin<&Struct>>, f: &u32) -> &u32 {\n+   |                                     -             - let's call the lifetime of this reference `'1`\n+   |                                     |\n+   |                                     let's call the lifetime of this reference `'2`\n+LL |         f\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "342d6d2b36357bffa93dc9d84a556e6f716637df", "filename": "src/test/ui/self/elision/ref-struct.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,32 @@\n+#![feature(arbitrary_self_types)]\n+#![allow(non_snake_case)]\n+\n+use std::pin::Pin;\n+\n+struct Struct { }\n+\n+impl Struct {\n+    // Test using `&Struct` explicitly:\n+\n+    fn ref_Struct(self: &Struct, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn box_ref_Struct(self: Box<&Struct>, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn pin_ref_Struct(self: Pin<&Struct>, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn box_box_ref_Struct(self: Box<Box<&Struct>>, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+\n+    fn box_pin_Struct(self: Box<Pin<&Struct>>, f: &u32) -> &u32 {\n+        f //~ ERROR lifetime mismatch\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "186e651c143bf547030ba09beea8de646230a070", "filename": "src/test/ui/self/elision/ref-struct.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct.stderr?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,52 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-struct.rs:12:9\n+   |\n+LL |     fn ref_Struct(self: &Struct, f: &u32) -> &u32 {\n+   |                                     ----     ----\n+   |                                     |\n+   |                                     this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-struct.rs:16:9\n+   |\n+LL |     fn box_ref_Struct(self: Box<&Struct>, f: &u32) -> &u32 {\n+   |                                              ----     ----\n+   |                                              |\n+   |                                              this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-struct.rs:20:9\n+   |\n+LL |     fn pin_ref_Struct(self: Pin<&Struct>, f: &u32) -> &u32 {\n+   |                                              ----     ----\n+   |                                              |\n+   |                                              this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-struct.rs:24:9\n+   |\n+LL |     fn box_box_ref_Struct(self: Box<Box<&Struct>>, f: &u32) -> &u32 {\n+   |                                                       ----     ----\n+   |                                                       |\n+   |                                                       this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/ref-struct.rs:28:9\n+   |\n+LL |     fn box_pin_Struct(self: Box<Pin<&Struct>>, f: &u32) -> &u32 {\n+   |                                                   ----     ----\n+   |                                                   |\n+   |                                                   this parameter and the return type are declared with different lifetimes...\n+LL |         f\n+   |         ^ ...but data from `f` is returned here\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "dbcef71ba14fc451ad33cc33ecc860066ab287b2", "filename": "src/test/ui/self/elision/self.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fself.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fself.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fself.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,36 @@\n+// check-pass\n+\n+#![feature(arbitrary_self_types)]\n+#![allow(non_snake_case)]\n+\n+use std::rc::Rc;\n+\n+struct Struct { }\n+\n+impl Struct {\n+    fn take_self(self, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Self(self: Self, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Box_Self(self: Box<Self>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Box_Box_Self(self: Box<Box<Self>>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Rc_Self(self: Rc<Self>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn take_Box_Rc_Self(self: Box<Rc<Self>>, f: &u32) -> &u32 {\n+        f\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "227e993bd3c61bff39d00748017868088d2ed9b4", "filename": "src/test/ui/self/elision/struct.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Felision%2Fstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fstruct.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,32 @@\n+// check-pass\n+\n+#![feature(arbitrary_self_types)]\n+#![allow(non_snake_case)]\n+\n+use std::rc::Rc;\n+\n+struct Struct { }\n+\n+impl Struct {\n+    fn ref_Struct(self: Struct, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn box_Struct(self: Box<Struct>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn rc_Struct(self: Rc<Struct>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn box_box_Struct(self: Box<Box<Struct>>, f: &u32) -> &u32 {\n+        f\n+    }\n+\n+    fn box_rc_Struct(self: Box<Rc<Struct>>, f: &u32) -> &u32 {\n+        f\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "f04bd83ab6e4c4360467105181cf12c2c1fc990c", "filename": "src/test/ui/self/self_lifetime.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Fself_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fself%2Fself_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fself_lifetime.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,15 @@\n+// check-pass\n+\n+// https://github.com/rust-lang/rust/pull/60944#issuecomment-495346120\n+\n+struct Foo<'a>(&'a ());\n+impl<'a> Foo<'a> {\n+    fn foo<'b>(self: &'b Foo<'a>) -> &() { self.0 }\n+}\n+\n+type Alias = Foo<'static>;\n+impl Alias {\n+    fn bar<'a>(self: &Alias, arg: &'a ()) -> &() { arg }\n+}\n+\n+fn main() {}"}, {"sha": "3d40bdced63e069705107bff7bf51c0db5b76868", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -38,8 +38,8 @@ pub mod pal;\n pub mod deps;\n pub mod extdeps;\n pub mod ui_tests;\n+pub mod unit_tests;\n pub mod unstable_book;\n-pub mod libcoretest;\n \n fn filter_dirs(path: &Path) -> bool {\n     let skip = ["}, {"sha": "579a20e1142bea7d9d1959516a606ddcd328c54e", "filename": "src/tools/tidy/src/libcoretest.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c798dffac9dc8c82374db48f5b474690cc6e9686/src%2Ftools%2Ftidy%2Fsrc%2Flibcoretest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c798dffac9dc8c82374db48f5b474690cc6e9686/src%2Ftools%2Ftidy%2Fsrc%2Flibcoretest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flibcoretest.rs?ref=c798dffac9dc8c82374db48f5b474690cc6e9686", "patch": "@@ -1,28 +0,0 @@\n-//! Tidy check to ensure `#[test]` is not used directly inside `libcore`.\n-//!\n-//! `#![no_core]` libraries cannot be tested directly due to duplicating lang\n-//! item. All tests must be written externally in `libcore/tests`.\n-\n-use std::path::Path;\n-\n-pub fn check(path: &Path, bad: &mut bool) {\n-    let libcore_path = path.join(\"libcore\");\n-    super::walk(\n-        &libcore_path,\n-        &mut |subpath| t!(subpath.strip_prefix(&libcore_path)).starts_with(\"tests\"),\n-        &mut |entry, contents| {\n-            let subpath = entry.path();\n-            if let Some(\"rs\") = subpath.extension().and_then(|e| e.to_str()) {\n-                let contents = contents.trim();\n-                if !contents.starts_with(\"//\") && contents.contains(\"#[test]\") {\n-                    tidy_error!(\n-                        bad,\n-                        \"`{}` contains `#[test]`; libcore tests must be placed inside \\\n-                        `src/libcore/tests/`\",\n-                        subpath.display()\n-                    );\n-                }\n-            }\n-        },\n-    );\n-}"}, {"sha": "19f02f0a96e1da029667269280fc38189c0c6645", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -27,7 +27,7 @@ fn main() {\n     let collected = features::check(&path, &mut bad, verbose);\n     pal::check(&path, &mut bad);\n     unstable_book::check(&path, collected, &mut bad);\n-    libcoretest::check(&path, &mut bad);\n+    unit_tests::check(&path, &mut bad);\n     if !args.iter().any(|s| *s == \"--no-vendor\") {\n         deps::check(&path, &mut bad);\n     }"}, {"sha": "b789e5cfd48d5c1e5c4d0255028db6cc96740707", "filename": "src/tools/tidy/src/unit_tests.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -0,0 +1,95 @@\n+//! Tidy check to ensure `#[test]` and `#[bench]` are not used directly inside\n+//! `libcore` or `liballoc`.\n+//!\n+//! `#![no_std]` libraries cannot be tested directly due to duplicating lang\n+//! items. All tests and benchmarks must be written externally in `libcore/{tests,benches}`\n+//! or `liballoc/{tests,benches}`.\n+//!\n+//! Outside of libcore and liballoc tests and benchmarks should be outlined into separate files\n+//! named `tests.rs` or `benches.rs`, or directories named `tests` or `benches` unconfigured\n+//! during normal build.\n+\n+use std::path::Path;\n+\n+pub fn check(root_path: &Path, bad: &mut bool) {\n+    let libcore = &root_path.join(\"libcore\");\n+    let liballoc = &root_path.join(\"liballoc\");\n+    let libcore_tests = &root_path.join(\"libcore/tests\");\n+    let liballoc_tests = &root_path.join(\"liballoc/tests\");\n+    let libcore_benches = &root_path.join(\"libcore/benches\");\n+    let liballoc_benches = &root_path.join(\"liballoc/benches\");\n+    let is_core_or_alloc = |path: &Path| {\n+        let is_core = path.starts_with(libcore) &&\n+                      !(path.starts_with(libcore_tests) || path.starts_with(libcore_benches));\n+        let is_alloc = path.starts_with(liballoc) &&\n+                       !(path.starts_with(liballoc_tests) || path.starts_with(liballoc_benches));\n+        is_core || is_alloc\n+    };\n+    let fixme = [\n+        \"liballoc\",\n+        \"libpanic_unwind/dwarf\",\n+        \"librustc\",\n+        \"librustc_data_structures\",\n+        \"librustc_incremental/persist\",\n+        \"librustc_lexer/src\",\n+        \"librustc_target/spec\",\n+        \"librustdoc\",\n+        \"libserialize\",\n+        \"libstd\",\n+        \"libsyntax\",\n+        \"libsyntax_pos\",\n+        \"libterm/terminfo\",\n+        \"libtest\",\n+        \"tools/compiletest/src\",\n+        \"tools/tidy/src\",\n+    ];\n+\n+    let mut skip = |path: &Path| {\n+        let file_name = path.file_name().unwrap_or_default();\n+        if path.is_dir() {\n+            super::filter_dirs(path) ||\n+            path.ends_with(\"src/test\") ||\n+            path.ends_with(\"src/doc\") ||\n+            (file_name == \"tests\" || file_name == \"benches\") && !is_core_or_alloc(path) ||\n+            fixme.iter().any(|p| path.ends_with(p))\n+        } else {\n+            let extension = path.extension().unwrap_or_default();\n+            extension != \"rs\" ||\n+            (file_name == \"tests.rs\" || file_name == \"benches.rs\") && !is_core_or_alloc(path)\n+        }\n+    };\n+\n+    super::walk(\n+        root_path,\n+        &mut skip,\n+        &mut |entry, contents| {\n+            let path = entry.path();\n+            let is_libcore = path.starts_with(libcore);\n+            let is_liballoc = path.starts_with(liballoc);\n+            for (i, line) in contents.lines().enumerate() {\n+                let line = line.trim();\n+                let is_test = || line.contains(\"#[test]\") && !line.contains(\"`#[test]\");\n+                let is_bench = || line.contains(\"#[bench]\") && !line.contains(\"`#[bench]\");\n+                if !line.starts_with(\"//\") && (is_test() || is_bench()) {\n+                    let explanation = if is_libcore {\n+                        \"libcore unit tests and benchmarks must be placed into \\\n+                         `libcore/tests` or `libcore/benches`\"\n+                    } else if is_liballoc {\n+                        \"liballoc unit tests and benchmarks must be placed into \\\n+                         `liballoc/tests` or `liballoc/benches`\"\n+                    } else {\n+                        \"unit tests and benchmarks must be placed into \\\n+                         separate files or directories named \\\n+                         `tests.rs`, `benches.rs`, `tests` or `benches`\"\n+                    };\n+                    let name = if is_test() { \"test\" } else { \"bench\" };\n+                    tidy_error!(\n+                        bad, \"`{}:{}` contains `#[{}]`; {}\",\n+                        path.display(), i + 1, name, explanation,\n+                    );\n+                    return;\n+                }\n+            }\n+        },\n+    );\n+}"}]}