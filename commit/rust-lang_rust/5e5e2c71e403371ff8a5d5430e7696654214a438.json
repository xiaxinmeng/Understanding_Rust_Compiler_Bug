{"sha": "5e5e2c71e403371ff8a5d5430e7696654214a438", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNWUyYzcxZTQwMzM3MWZmOGE1ZDU0MzBlNzY5NjY1NDIxNGE0Mzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-23T07:16:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-23T07:16:28Z"}, "message": "auto merge of #8677 : bblum/rust/scratch, r=alexcrichton\n\nr anybody; there isn't anything complicated here", "tree": {"sha": "25ca443f4dd0b513202ddf00a4ad53515f8b184c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25ca443f4dd0b513202ddf00a4ad53515f8b184c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e5e2c71e403371ff8a5d5430e7696654214a438", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e5e2c71e403371ff8a5d5430e7696654214a438", "html_url": "https://github.com/rust-lang/rust/commit/5e5e2c71e403371ff8a5d5430e7696654214a438", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e5e2c71e403371ff8a5d5430e7696654214a438/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0688bde47f1288eec730a3e01dcbf825900db3c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0688bde47f1288eec730a3e01dcbf825900db3c0", "html_url": "https://github.com/rust-lang/rust/commit/0688bde47f1288eec730a3e01dcbf825900db3c0"}, {"sha": "0081961c57494162d9f2d19265175af95fbdd8d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0081961c57494162d9f2d19265175af95fbdd8d7", "html_url": "https://github.com/rust-lang/rust/commit/0081961c57494162d9f2d19265175af95fbdd8d7"}], "stats": {"total": 164, "additions": 110, "deletions": 54}, "files": [{"sha": "0dee86e2a196cd07b85e40aca6c8cff4f3a53675", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e5e2c71e403371ff8a5d5430e7696654214a438/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e5e2c71e403371ff8a5d5430e7696654214a438/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=5e5e2c71e403371ff8a5d5430e7696654214a438", "patch": "@@ -4814,9 +4814,13 @@ impl Resolver {\n                                         DontAllowCapturingSelf) {\n                         Some(dl_def(def)) => return Some(def),\n                         _ => {\n-                            self.session.span_bug(span,\n-                                                  \"self wasn't mapped to a \\\n-                                                   def?!\")\n+                            if self.session.has_errors() {\n+                                // May happen inside a nested fn item, cf #6642.\n+                                return None;\n+                            } else {\n+                                self.session.span_bug(span,\n+                                        \"self wasn't mapped to a def?!\")\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "f9f5b66acb60dcc4ef3de90dfb0cfd140a457b26", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e5e2c71e403371ff8a5d5430e7696654214a438/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e5e2c71e403371ff8a5d5430e7696654214a438/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=5e5e2c71e403371ff8a5d5430e7696654214a438", "patch": "@@ -50,6 +50,12 @@ impl<T> Cell<T> {\n         this.value.take_unwrap()\n     }\n \n+    /// Yields the value if the cell is full, or `None` if it is empty.\n+    pub fn take_opt(&self) -> Option<T> {\n+        let this = unsafe { transmute_mut(self) };\n+        this.value.take()\n+    }\n+\n     /// Returns the value, failing if the cell is full.\n     pub fn put_back(&self, value: T) {\n         let this = unsafe { transmute_mut(self) };"}, {"sha": "600d0bb133eff45573bdc6eb2a7e8bd60431805a", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5e5e2c71e403371ff8a5d5430e7696654214a438/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e5e2c71e403371ff8a5d5430e7696654214a438/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=5e5e2c71e403371ff8a5d5430e7696654214a438", "patch": "@@ -40,3 +40,39 @@ macro_rules! rtabort(\n     } )\n )\n \n+macro_rules! assert_once_ever(\n+    ($( $msg:expr),+) => ( {\n+        // FIXME(#8472) extra function should not be needed to hide unsafe\n+        fn assert_once_ever() {\n+            unsafe {\n+                static mut already_happened: int = 0;\n+                // Double-check lock to avoid a swap in the common case.\n+                if already_happened != 0 ||\n+                    ::unstable::intrinsics::atomic_xchg_relaxed(&mut already_happened, 1) != 0 {\n+                        fail!(fmt!(\"assert_once_ever happened twice: %s\", fmt!($($msg),+)));\n+                }\n+            }\n+        }\n+        assert_once_ever();\n+    } )\n+)\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_assert_once_ever_ok() {\n+        assert_once_ever!(\"help i'm stuck in an\");\n+        assert_once_ever!(\"assertion error message\");\n+    }\n+\n+    #[test] #[ignore(cfg(windows))] #[should_fail]\n+    fn test_assert_once_ever_fail() {\n+        use task;\n+\n+        fn f() { assert_once_ever!(\"if you're seeing this... good!\") }\n+\n+        // linked & watched, naturally\n+        task::spawn(f);\n+        task::spawn(f);\n+    }\n+}"}, {"sha": "8ef9c1332f9e9ea220e0daded4ea57928211d3bf", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5e5e2c71e403371ff8a5d5430e7696654214a438/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e5e2c71e403371ff8a5d5430e7696654214a438/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=5e5e2c71e403371ff8a5d5430e7696654214a438", "patch": "@@ -499,13 +499,14 @@ impl<T> GenericPort<T> for Port<T> {\n     }\n \n     fn try_recv(&self) -> Option<T> {\n-        let pone = self.next.take();\n-        match pone.try_recv() {\n-            Some(StreamPayload { val, next }) => {\n-                self.next.put_back(next);\n-                Some(val)\n+        do self.next.take_opt().map_move_default(None) |pone| {\n+            match pone.try_recv() {\n+                Some(StreamPayload { val, next }) => {\n+                    self.next.put_back(next);\n+                    Some(val)\n+                }\n+                None => None\n             }\n-            None => None\n         }\n     }\n }"}, {"sha": "8b3e65b57ab7abe37995025474d11b7414f2bc84", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e5e2c71e403371ff8a5d5430e7696654214a438/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e5e2c71e403371ff8a5d5430e7696654214a438/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=5e5e2c71e403371ff8a5d5430e7696654214a438", "patch": "@@ -323,6 +323,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n     // task tree, shut down the schedulers and set the exit code.\n     let handles = Cell::new(handles);\n     let on_exit: ~fn(bool) = |exit_success| {\n+        assert_once_ever!(\"last task exiting\");\n \n         let mut handles = handles.take();\n         for handle in handles.mut_iter() {"}, {"sha": "980141d29c3984e1e7e7fa68b7b576942d876ebf", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 32, "deletions": 45, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/5e5e2c71e403371ff8a5d5430e7696654214a438/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e5e2c71e403371ff8a5d5430e7696654214a438/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=5e5e2c71e403371ff8a5d5430e7696654214a438", "patch": "@@ -446,8 +446,7 @@ fn taskgroup_key() -> local_data::Key<@@mut Taskgroup> {\n // Transitionary.\n struct RuntimeGlue;\n impl RuntimeGlue {\n-    fn kill_task(handle: KillHandle) {\n-        let mut handle = handle;\n+    fn kill_task(mut handle: KillHandle) {\n         do handle.kill().map_move |killed_task| {\n             let killed_task = Cell::new(killed_task);\n             do Local::borrow::<Scheduler, ()> |sched| {\n@@ -457,44 +456,38 @@ impl RuntimeGlue {\n     }\n \n     fn with_task_handle_and_failing(blk: &fn(&KillHandle, bool)) {\n-        if in_green_task_context() {\n-            unsafe {\n-                // Can't use safe borrow, because the taskgroup destructor needs to\n-                // access the scheduler again to send kill signals to other tasks.\n-                let me = Local::unsafe_borrow::<Task>();\n-                blk((*me).death.kill_handle.get_ref(), (*me).unwinder.unwinding)\n-            }\n-        } else {\n-            rtabort!(\"task dying in bad context\")\n+        rtassert!(in_green_task_context());\n+        unsafe {\n+            // Can't use safe borrow, because the taskgroup destructor needs to\n+            // access the scheduler again to send kill signals to other tasks.\n+            let me = Local::unsafe_borrow::<Task>();\n+            blk((*me).death.kill_handle.get_ref(), (*me).unwinder.unwinding)\n         }\n     }\n \n     fn with_my_taskgroup<U>(blk: &fn(&Taskgroup) -> U) -> U {\n-        if in_green_task_context() {\n-            unsafe {\n-                // Can't use safe borrow, because creating new hashmaps for the\n-                // tasksets requires an rng, which needs to borrow the sched.\n-                let me = Local::unsafe_borrow::<Task>();\n-                blk(match (*me).taskgroup {\n-                    None => {\n-                        // First task in its (unlinked/unsupervised) taskgroup.\n-                        // Lazily initialize.\n-                        let mut members = TaskSet::new();\n-                        let my_handle = (*me).death.kill_handle.get_ref().clone();\n-                        members.insert(my_handle);\n-                        let tasks = Exclusive::new(Some(TaskGroupData {\n-                            members: members,\n-                            descendants: TaskSet::new(),\n-                        }));\n-                        let group = Taskgroup(tasks, AncestorList(None), None);\n-                        (*me).taskgroup = Some(group);\n-                        (*me).taskgroup.get_ref()\n-                    }\n-                    Some(ref group) => group,\n-                })\n-            }\n-        } else {\n-            rtabort!(\"spawning in bad context\")\n+        rtassert!(in_green_task_context());\n+        unsafe {\n+            // Can't use safe borrow, because creating new hashmaps for the\n+            // tasksets requires an rng, which needs to borrow the sched.\n+            let me = Local::unsafe_borrow::<Task>();\n+            blk(match (*me).taskgroup {\n+                None => {\n+                    // First task in its (unlinked/unsupervised) taskgroup.\n+                    // Lazily initialize.\n+                    let mut members = TaskSet::new();\n+                    let my_handle = (*me).death.kill_handle.get_ref().clone();\n+                    members.insert(my_handle);\n+                    let tasks = Exclusive::new(Some(TaskGroupData {\n+                        members: members,\n+                        descendants: TaskSet::new(),\n+                    }));\n+                    let group = Taskgroup(tasks, AncestorList(None), None);\n+                    (*me).taskgroup = Some(group);\n+                    (*me).taskgroup.get_ref()\n+                }\n+                Some(ref group) => group,\n+            })\n         }\n     }\n }\n@@ -567,17 +560,11 @@ fn enlist_many(child: &KillHandle, child_arc: &TaskGroupArc,\n     result\n }\n \n-pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n-    if in_green_task_context() {\n-        spawn_raw_newsched(opts, f)\n-    } else {\n-        fail!(\"can't spawn from this context\")\n-    }\n-}\n-\n-fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n+pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n     use rt::sched::*;\n \n+    rtassert!(in_green_task_context());\n+\n     let child_data = Cell::new(gen_child_taskgroup(opts.linked, opts.supervised));\n     let indestructible = opts.indestructible;\n "}, {"sha": "bffca995b8e3a7116cdddb6573855868eca23891", "filename": "src/test/compile-fail/issue-6642.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5e5e2c71e403371ff8a5d5430e7696654214a438/src%2Ftest%2Fcompile-fail%2Fissue-6642.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e5e2c71e403371ff8a5d5430e7696654214a438/src%2Ftest%2Fcompile-fail%2Fissue-6642.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6642.rs?ref=5e5e2c71e403371ff8a5d5430e7696654214a438", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct A;\n+impl A {\n+    fn m(&self) {\n+          fn x() {\n+              self.m()\n+              //~^ ERROR can't capture dynamic environment in a fn item\n+              //~^^ ERROR `self` is not allowed in this context\n+          }\n+    }\n+}\n+fn main() {}"}]}