{"sha": "c94f0f49f8e025aae11534f9f2b4c59c34b1edb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5NGYwZjQ5ZjhlMDI1YWFlMTE1MzRmOWYyYjRjNTljMzRiMWVkYjg=", "commit": {"author": {"name": "rail", "email": "12975677+rail-rain@users.noreply.github.com", "date": "2020-04-27T06:22:10Z"}, "committer": {"name": "rail", "email": "12975677+rail-rain@users.noreply.github.com", "date": "2020-04-27T06:22:10Z"}, "message": "Remove all `ref` keyword", "tree": {"sha": "a9aca41551659817ff7fceabc32ba7797c99dff4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9aca41551659817ff7fceabc32ba7797c99dff4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c94f0f49f8e025aae11534f9f2b4c59c34b1edb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c94f0f49f8e025aae11534f9f2b4c59c34b1edb8", "html_url": "https://github.com/rust-lang/rust/commit/c94f0f49f8e025aae11534f9f2b4c59c34b1edb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c94f0f49f8e025aae11534f9f2b4c59c34b1edb8/comments", "author": {"login": "rail-rain", "id": 12975677, "node_id": "MDQ6VXNlcjEyOTc1Njc3", "avatar_url": "https://avatars.githubusercontent.com/u/12975677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rail-rain", "html_url": "https://github.com/rail-rain", "followers_url": "https://api.github.com/users/rail-rain/followers", "following_url": "https://api.github.com/users/rail-rain/following{/other_user}", "gists_url": "https://api.github.com/users/rail-rain/gists{/gist_id}", "starred_url": "https://api.github.com/users/rail-rain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rail-rain/subscriptions", "organizations_url": "https://api.github.com/users/rail-rain/orgs", "repos_url": "https://api.github.com/users/rail-rain/repos", "events_url": "https://api.github.com/users/rail-rain/events{/privacy}", "received_events_url": "https://api.github.com/users/rail-rain/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rail-rain", "id": 12975677, "node_id": "MDQ6VXNlcjEyOTc1Njc3", "avatar_url": "https://avatars.githubusercontent.com/u/12975677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rail-rain", "html_url": "https://github.com/rail-rain", "followers_url": "https://api.github.com/users/rail-rain/followers", "following_url": "https://api.github.com/users/rail-rain/following{/other_user}", "gists_url": "https://api.github.com/users/rail-rain/gists{/gist_id}", "starred_url": "https://api.github.com/users/rail-rain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rail-rain/subscriptions", "organizations_url": "https://api.github.com/users/rail-rain/orgs", "repos_url": "https://api.github.com/users/rail-rain/repos", "events_url": "https://api.github.com/users/rail-rain/events{/privacy}", "received_events_url": "https://api.github.com/users/rail-rain/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75ad839cd26c1da17fe6ba3aae1153ee96de26c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/75ad839cd26c1da17fe6ba3aae1153ee96de26c8", "html_url": "https://github.com/rust-lang/rust/commit/75ad839cd26c1da17fe6ba3aae1153ee96de26c8"}], "stats": {"total": 26, "additions": 12, "deletions": 14}, "files": [{"sha": "502bd42214eed9ec3c114c7df19f6031e99987fe", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c94f0f49f8e025aae11534f9f2b4c59c34b1edb8/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c94f0f49f8e025aae11534f9f2b4c59c34b1edb8/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=c94f0f49f8e025aae11534f9f2b4c59c34b1edb8", "patch": "@@ -772,8 +772,8 @@ fn check_for_loop<'a, 'tcx>(\n \n fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>, var: HirId) -> bool {\n     if_chain! {\n-        if let ExprKind::Path(ref qpath) = expr.kind;\n-        if let QPath::Resolved(None, ref path) = *qpath;\n+        if let ExprKind::Path(qpath) = &expr.kind;\n+        if let QPath::Resolved(None, path) = qpath;\n         if path.segments.len() == 1;\n         if let Res::Local(local_id) = qpath_res(cx, qpath, expr.hir_id);\n         // our variable!\n@@ -821,8 +821,8 @@ fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'_>) -> bool {\n \n fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>, var: HirId) -> Option<FixedOffsetVar> {\n     fn extract_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &Expr<'_>, var: HirId) -> Option<String> {\n-        match e.kind {\n-            ExprKind::Lit(ref l) => match l.node {\n+        match &e.kind {\n+            ExprKind::Lit(l) => match l.node {\n                 ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n                 _ => None,\n             },\n@@ -831,14 +831,14 @@ fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>, v\n         }\n     }\n \n-    if let ExprKind::Index(ref seqexpr, ref idx) = expr.kind {\n+    if let ExprKind::Index(seqexpr, idx) = expr.kind {\n         let ty = cx.tables.expr_ty(seqexpr);\n         if !is_slice_like(cx, ty) {\n             return None;\n         }\n \n         let offset = match idx.kind {\n-            ExprKind::Binary(op, ref lhs, ref rhs) => match op.node {\n+            ExprKind::Binary(op, lhs, rhs) => match op.node {\n                 BinOpKind::Add => {\n                     let offset_opt = if same_var(cx, lhs, var) {\n                         extract_offset(cx, rhs, var)\n@@ -878,7 +878,7 @@ fn fetch_cloned_fixed_offset_var<'a, 'tcx>(\n     var: HirId,\n ) -> Option<FixedOffsetVar> {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref method, _, ref args) = expr.kind;\n+        if let ExprKind::MethodCall(method, _, args) = expr.kind;\n         if method.ident.name == sym!(clone);\n         if args.len() == 1;\n         if let Some(arg) = args.get(0);\n@@ -900,7 +900,7 @@ fn get_indexed_assignments<'a, 'tcx>(\n         e: &Expr<'_>,\n         var: HirId,\n     ) -> Option<(FixedOffsetVar, FixedOffsetVar)> {\n-        if let ExprKind::Assign(ref lhs, ref rhs, _) = e.kind {\n+        if let ExprKind::Assign(lhs, rhs, _) = e.kind {\n             match (\n                 get_fixed_offset_var(cx, lhs, var),\n                 fetch_cloned_fixed_offset_var(cx, rhs, var),\n@@ -920,16 +920,14 @@ fn get_indexed_assignments<'a, 'tcx>(\n         }\n     }\n \n-    if let ExprKind::Block(ref b, _) = body.kind {\n-        let Block {\n-            ref stmts, ref expr, ..\n-        } = **b;\n+    if let ExprKind::Block(b, _) = body.kind {\n+        let Block { stmts, expr, .. } = *b;\n \n         stmts\n             .iter()\n             .map(|stmt| match stmt.kind {\n                 StmtKind::Local(..) | StmtKind::Item(..) => None,\n-                StmtKind::Expr(ref e) | StmtKind::Semi(ref e) => Some(get_assignment(cx, e, var)),\n+                StmtKind::Expr(e) | StmtKind::Semi(e) => Some(get_assignment(cx, e, var)),\n             })\n             .chain(expr.as_ref().into_iter().map(|e| Some(get_assignment(cx, &*e, var))))\n             .filter_map(|op| op)\n@@ -992,7 +990,7 @@ fn detect_manual_memcpy<'a, 'tcx>(\n \n             let print_limit = |end: &Expr<'_>, offset: Offset, var_name: &str| {\n                 if_chain! {\n-                    if let ExprKind::MethodCall(ref method, _, ref len_args) = end.kind;\n+                    if let ExprKind::MethodCall(method, _, len_args) = end.kind;\n                     if method.ident.name == sym!(len);\n                     if len_args.len() == 1;\n                     if let Some(arg) = len_args.get(0);"}]}