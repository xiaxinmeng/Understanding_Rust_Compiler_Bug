{"sha": "616373e6681822ae003390b2dd99ed7b801dd8c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxNjM3M2U2NjgxODIyYWUwMDMzOTBiMmRkOTllZDdiODAxZGQ4YzI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-22T01:40:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-22T01:40:00Z"}, "message": "Rollup merge of #67148 - Centril:ty-polish, r=estebank\n\n Refactor type & bounds parsing thoroughly\n\nPR is based on https://github.com/rust-lang/rust/pull/67131 with first one from this PR being ` extract parse_ty_tuple_or_parens`.\n\nAlso fixes #67146.\n\nr? @estebank", "tree": {"sha": "377afe7866ad67a5413b02e4ed187e2fc21b83e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/377afe7866ad67a5413b02e4ed187e2fc21b83e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/616373e6681822ae003390b2dd99ed7b801dd8c2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd/slwCRBK7hj4Ov3rIwAAdHIIAEQRGcIQ0ocl/qhahUZhVl1a\nfFJ+PPfzzctGNnKy08Rp7dCZ0jeArhlJmiEdxCSuxU1hlWjuFP5uwsP7xH68CSO6\n5QOIWnSfR4MNOmOKy+N4aoxAh/s56QTM9/7N9GvQAj7/TFF/QivGuXyGGY3Enyhe\n5auEWvq+BR57KZdeJzhlSGjDBQWsFVsQUhrPdim6LhA52CUnSFbjXUANaX2LsUaa\nukhcP06Y7pJYK7klkE/1WwkF6LQWo88kUV3j/I+scuFWGyxHpMh8v7M5ye1GFeID\n8J1CVfKzazT+9w9cBKHAC4WPFI0YM4Zzx/mgRXr47Rm4t2wafytAmpUjVqedMH0=\n=/PRy\n-----END PGP SIGNATURE-----\n", "payload": "tree 377afe7866ad67a5413b02e4ed187e2fc21b83e2\nparent 5535c253140bd0e48488fad43e60013b48ecd716\nparent db4818f3253254bafac707d58ec3d13def0e6f86\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1576978800 +0100\ncommitter GitHub <noreply@github.com> 1576978800 +0100\n\nRollup merge of #67148 - Centril:ty-polish, r=estebank\n\n Refactor type & bounds parsing thoroughly\n\nPR is based on https://github.com/rust-lang/rust/pull/67131 with first one from this PR being ` extract parse_ty_tuple_or_parens`.\n\nAlso fixes #67146.\n\nr? @estebank\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/616373e6681822ae003390b2dd99ed7b801dd8c2", "html_url": "https://github.com/rust-lang/rust/commit/616373e6681822ae003390b2dd99ed7b801dd8c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/616373e6681822ae003390b2dd99ed7b801dd8c2/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5535c253140bd0e48488fad43e60013b48ecd716", "url": "https://api.github.com/repos/rust-lang/rust/commits/5535c253140bd0e48488fad43e60013b48ecd716", "html_url": "https://github.com/rust-lang/rust/commit/5535c253140bd0e48488fad43e60013b48ecd716"}, {"sha": "db4818f3253254bafac707d58ec3d13def0e6f86", "url": "https://api.github.com/repos/rust-lang/rust/commits/db4818f3253254bafac707d58ec3d13def0e6f86", "html_url": "https://github.com/rust-lang/rust/commit/db4818f3253254bafac707d58ec3d13def0e6f86"}], "stats": {"total": 657, "additions": 371, "deletions": 286}, "files": [{"sha": "71c9e58f58fd7e579e7b7cd91aa9ec9deaaf0860", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=616373e6681822ae003390b2dd99ed7b801dd8c2", "patch": "@@ -90,6 +90,10 @@ impl<'a> Parser<'a> {\n         self.parse_expr_res(Restrictions::empty(), None)\n     }\n \n+    pub(super) fn parse_anon_const_expr(&mut self) -> PResult<'a, AnonConst> {\n+        self.parse_expr().map(|value| AnonConst { id: DUMMY_NODE_ID, value })\n+    }\n+\n     fn parse_expr_catch_underscore(&mut self) -> PResult<'a, P<Expr>> {\n         match self.parse_expr() {\n             Ok(expr) => Ok(expr),\n@@ -109,7 +113,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses a sequence of expressions bounded by parentheses.\n+    /// Parses a sequence of expressions delimited by parentheses.\n     fn parse_paren_expr_seq(&mut self) -> PResult<'a, Vec<P<Expr>>> {\n         self.parse_paren_comma_seq(|p| {\n             p.parse_expr_catch_underscore()\n@@ -955,10 +959,7 @@ impl<'a> Parser<'a> {\n             let first_expr = self.parse_expr()?;\n             if self.eat(&token::Semi) {\n                 // Repeating array syntax: `[ 0; 512 ]`\n-                let count = AnonConst {\n-                    id: DUMMY_NODE_ID,\n-                    value: self.parse_expr()?,\n-                };\n+                let count = self.parse_anon_const_expr()?;\n                 self.expect(close)?;\n                 ExprKind::Repeat(first_expr, count)\n             } else if self.eat(&token::Comma) {"}, {"sha": "ea9047d2d77ab9a8672977c93429d4ccdb37210a", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=616373e6681822ae003390b2dd99ed7b801dd8c2", "patch": "@@ -5,7 +5,7 @@ use crate::maybe_whole;\n \n use rustc_errors::{PResult, Applicability, DiagnosticBuilder, StashKey};\n use rustc_error_codes::*;\n-use syntax::ast::{self, DUMMY_NODE_ID, Ident, AttrVec, Attribute, AttrKind, AttrStyle, AnonConst};\n+use syntax::ast::{self, DUMMY_NODE_ID, Ident, AttrVec, Attribute, AttrKind, AttrStyle};\n use syntax::ast::{AssocItem, AssocItemKind, Item, ItemKind, UseTree, UseTreeKind};\n use syntax::ast::{PathSegment, IsAuto, Constness, IsAsync, Unsafety, Defaultness, Extern, StrLit};\n use syntax::ast::{Visibility, VisibilityKind, Mutability, FnHeader, ForeignItem, ForeignItemKind};\n@@ -1317,10 +1317,7 @@ impl<'a> Parser<'a> {\n         };\n \n         let disr_expr = if self.eat(&token::Eq) {\n-            Some(AnonConst {\n-                id: DUMMY_NODE_ID,\n-                value: self.parse_expr()?,\n-            })\n+            Some(self.parse_anon_const_expr()?)\n         } else {\n             None\n         };"}, {"sha": "58f3a5b3d60032f1f33733a1a241de5c872947eb", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 307, "deletions": 240, "changes": 547, "blob_url": "https://github.com/rust-lang/rust/blob/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=616373e6681822ae003390b2dd99ed7b801dd8c2", "patch": "@@ -8,7 +8,7 @@ use rustc_error_codes::*;\n use syntax::ptr::P;\n use syntax::ast::{self, Ty, TyKind, MutTy, BareFnTy, FunctionRetTy, GenericParam, Lifetime, Ident};\n use syntax::ast::{TraitBoundModifier, TraitObjectSyntax, GenericBound, GenericBounds, PolyTraitRef};\n-use syntax::ast::{Mutability, AnonConst, Mac};\n+use syntax::ast::{Mutability, Mac};\n use syntax::token::{self, Token};\n use syntax::struct_span_err;\n use syntax_pos::source_map::Span;\n@@ -73,78 +73,21 @@ impl<'a> Parser<'a> {\n \n         let lo = self.token.span;\n         let mut impl_dyn_multi = false;\n-        let kind = if self.eat(&token::OpenDelim(token::Paren)) {\n-            // `(TYPE)` is a parenthesized type.\n-            // `(TYPE,)` is a tuple with a single field of type TYPE.\n-            let mut ts = vec![];\n-            let mut last_comma = false;\n-            while self.token != token::CloseDelim(token::Paren) {\n-                ts.push(self.parse_ty()?);\n-                if self.eat(&token::Comma) {\n-                    last_comma = true;\n-                } else {\n-                    last_comma = false;\n-                    break;\n-                }\n-            }\n-            let trailing_plus = self.prev_token_kind == PrevTokenKind::Plus;\n-            self.expect(&token::CloseDelim(token::Paren))?;\n-\n-            if ts.len() == 1 && !last_comma {\n-                let ty = ts.into_iter().nth(0).unwrap().into_inner();\n-                let maybe_bounds = allow_plus && self.token.is_like_plus();\n-                match ty.kind {\n-                    // `(TY_BOUND_NOPAREN) + BOUND + ...`.\n-                    TyKind::Path(None, ref path) if maybe_bounds => {\n-                        self.parse_remaining_bounds(Vec::new(), path.clone(), lo, true)?\n-                    }\n-                    TyKind::TraitObject(ref bounds, TraitObjectSyntax::None)\n-                            if maybe_bounds && bounds.len() == 1 && !trailing_plus => {\n-                        let path = match bounds[0] {\n-                            GenericBound::Trait(ref pt, ..) => pt.trait_ref.path.clone(),\n-                            GenericBound::Outlives(..) => self.bug(\"unexpected lifetime bound\"),\n-                        };\n-                        self.parse_remaining_bounds(Vec::new(), path, lo, true)?\n-                    }\n-                    // `(TYPE)`\n-                    _ => TyKind::Paren(P(ty))\n-                }\n-            } else {\n-                TyKind::Tup(ts)\n-            }\n+        let kind = if self.check(&token::OpenDelim(token::Paren)) {\n+            self.parse_ty_tuple_or_parens(lo, allow_plus)?\n         } else if self.eat(&token::Not) {\n             // Never type `!`\n             TyKind::Never\n         } else if self.eat(&token::BinOp(token::Star)) {\n-            // Raw pointer\n-            TyKind::Ptr(self.parse_ptr()?)\n+            self.parse_ty_ptr()?\n         } else if self.eat(&token::OpenDelim(token::Bracket)) {\n-            // Array or slice\n-            let t = self.parse_ty()?;\n-            // Parse optional `; EXPR` in `[TYPE; EXPR]`\n-            let t = match self.maybe_parse_fixed_length_of_vec()? {\n-                None => TyKind::Slice(t),\n-                Some(length) => TyKind::Array(t, AnonConst {\n-                    id: ast::DUMMY_NODE_ID,\n-                    value: length,\n-                }),\n-            };\n-            self.expect(&token::CloseDelim(token::Bracket))?;\n-            t\n+            self.parse_array_or_slice_ty()?\n         } else if self.check(&token::BinOp(token::And)) || self.check(&token::AndAnd) {\n             // Reference\n             self.expect_and()?;\n             self.parse_borrowed_pointee()?\n         } else if self.eat_keyword_noexpect(kw::Typeof) {\n-            // `typeof(EXPR)`\n-            // In order to not be ambiguous, the type must be surrounded by parens.\n-            self.expect(&token::OpenDelim(token::Paren))?;\n-            let e = AnonConst {\n-                id: ast::DUMMY_NODE_ID,\n-                value: self.parse_expr()?,\n-            };\n-            self.expect(&token::CloseDelim(token::Paren))?;\n-            TyKind::Typeof(e)\n+            self.parse_typeof_ty()?\n         } else if self.eat_keyword(kw::Underscore) {\n             // A type to be inferred `_`\n             TyKind::Infer\n@@ -155,7 +98,6 @@ impl<'a> Parser<'a> {\n             // Function pointer type or bound list (trait object type) starting with a poly-trait.\n             //   `for<'lt> [unsafe] [extern \"ABI\"] fn (&'lt S) -> T`\n             //   `for<'lt> Trait1<'lt> + Trait2 + 'a`\n-            let lo = self.token.span;\n             let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n             if self.token_is_bare_fn_keyword() {\n                 self.parse_ty_bare_fn(lifetime_defs)?\n@@ -165,69 +107,33 @@ impl<'a> Parser<'a> {\n                 self.parse_remaining_bounds(lifetime_defs, path, lo, parse_plus)?\n             }\n         } else if self.eat_keyword(kw::Impl) {\n-            // Always parse bounds greedily for better error recovery.\n-            let bounds = self.parse_generic_bounds(None)?;\n-            impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n-            TyKind::ImplTrait(ast::DUMMY_NODE_ID, bounds)\n-        } else if self.check_keyword(kw::Dyn) &&\n-                  (self.token.span.rust_2018() ||\n-                   self.look_ahead(1, |t| t.can_begin_bound() &&\n-                                          !can_continue_type_after_non_fn_ident(t))) {\n-            self.bump(); // `dyn`\n-            // Always parse bounds greedily for better error recovery.\n-            let bounds = self.parse_generic_bounds(None)?;\n-            impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n-            TyKind::TraitObject(bounds, TraitObjectSyntax::Dyn)\n-        } else if self.check(&token::Question) ||\n-                  self.check_lifetime() && self.look_ahead(1, |t| t.is_like_plus()) {\n+            self.parse_impl_ty(&mut impl_dyn_multi)?\n+        } else if self.is_explicit_dyn_type() {\n+            self.parse_dyn_ty(&mut impl_dyn_multi)?\n+        } else if self.check(&token::Question)\n+            || self.check_lifetime() && self.look_ahead(1, |t| t.is_like_plus())\n+        {\n             // Bound list (trait object type)\n-            TyKind::TraitObject(self.parse_generic_bounds_common(allow_plus, None)?,\n-                                TraitObjectSyntax::None)\n+            let bounds = self.parse_generic_bounds_common(allow_plus, None)?;\n+            TyKind::TraitObject(bounds, TraitObjectSyntax::None)\n         } else if self.eat_lt() {\n             // Qualified path\n             let (qself, path) = self.parse_qpath(PathStyle::Type)?;\n             TyKind::Path(Some(qself), path)\n         } else if self.token.is_path_start() {\n-            // Simple path\n-            let path = self.parse_path(PathStyle::Type)?;\n-            if self.eat(&token::Not) {\n-                // Macro invocation in type position\n-                let args = self.parse_mac_args()?;\n-                let mac = Mac {\n-                    path,\n-                    args,\n-                    prior_type_ascription: self.last_type_ascription,\n-                };\n-                TyKind::Mac(mac)\n-            } else {\n-                // Just a type path or bound list (trait object type) starting with a trait.\n-                //   `Type`\n-                //   `Trait1 + Trait2 + 'a`\n-                if allow_plus && self.check_plus() {\n-                    self.parse_remaining_bounds(Vec::new(), path, lo, true)?\n-                } else {\n-                    TyKind::Path(None, path)\n-                }\n-            }\n+            self.parse_path_start_ty(lo, allow_plus)?\n         } else if self.eat(&token::DotDotDot) {\n             if allow_c_variadic {\n                 TyKind::CVarArgs\n             } else {\n                 // FIXME(Centril): Should we just allow `...` syntactically\n                 // anywhere in a type and use semantic restrictions instead?\n-                struct_span_err!(\n-                    self.sess.span_diagnostic,\n-                    lo.to(self.prev_span),\n-                    E0743,\n-                    \"C-variadic type `...` may not be nested inside another type\",\n-                )\n-                .emit();\n-\n+                self.error_illegal_c_varadic_ty(lo);\n                 TyKind::Err\n             }\n         } else {\n             let msg = format!(\"expected type, found {}\", self.this_token_descr());\n-            let mut err = self.fatal(&msg);\n+            let mut err = self.struct_span_err(self.token.span, &msg);\n             err.span_label(self.token.span, \"expected type\");\n             self.maybe_annotate_with_ascription(&mut err, true);\n             return Err(err);\n@@ -242,8 +148,48 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(ty, allow_qpath_recovery)\n     }\n \n-    fn parse_remaining_bounds(&mut self, generic_params: Vec<GenericParam>, path: ast::Path,\n-                              lo: Span, parse_plus: bool) -> PResult<'a, TyKind> {\n+    /// Parses either:\n+    /// - `(TYPE)`, a parenthesized type.\n+    /// - `(TYPE,)`, a tuple with a single field of type TYPE.\n+    fn parse_ty_tuple_or_parens(&mut self, lo: Span, allow_plus: bool) -> PResult<'a, TyKind> {\n+        let mut trailing_plus = false;\n+        let (ts, trailing) = self.parse_paren_comma_seq(|p| {\n+            let ty = p.parse_ty()?;\n+            trailing_plus = p.prev_token_kind == PrevTokenKind::Plus;\n+            Ok(ty)\n+        })?;\n+\n+        if ts.len() == 1 && !trailing {\n+            let ty = ts.into_iter().nth(0).unwrap().into_inner();\n+            let maybe_bounds = allow_plus && self.token.is_like_plus();\n+            match ty.kind {\n+                // `(TY_BOUND_NOPAREN) + BOUND + ...`.\n+                TyKind::Path(None, path) if maybe_bounds => {\n+                    self.parse_remaining_bounds(Vec::new(), path, lo, true)\n+                }\n+                TyKind::TraitObject(mut bounds, TraitObjectSyntax::None)\n+                if maybe_bounds && bounds.len() == 1 && !trailing_plus => {\n+                    let path = match bounds.remove(0) {\n+                        GenericBound::Trait(pt, ..) => pt.trait_ref.path,\n+                        GenericBound::Outlives(..) => self.bug(\"unexpected lifetime bound\"),\n+                    };\n+                    self.parse_remaining_bounds(Vec::new(), path, lo, true)\n+                }\n+                // `(TYPE)`\n+                _ => Ok(TyKind::Paren(P(ty)))\n+            }\n+        } else {\n+            Ok(TyKind::Tup(ts))\n+        }\n+    }\n+\n+    fn parse_remaining_bounds(\n+        &mut self,\n+        generic_params: Vec<GenericParam>,\n+        path: ast::Path,\n+        lo: Span,\n+        parse_plus: bool,\n+    ) -> PResult<'a, TyKind> {\n         let poly_trait_ref = PolyTraitRef::new(generic_params, path, lo.to(self.prev_span));\n         let mut bounds = vec![GenericBound::Trait(poly_trait_ref, TraitBoundModifier::None)];\n         if parse_plus {\n@@ -253,7 +199,8 @@ impl<'a> Parser<'a> {\n         Ok(TyKind::TraitObject(bounds, TraitObjectSyntax::None))\n     }\n \n-    fn parse_ptr(&mut self) -> PResult<'a, MutTy> {\n+    /// Parses a raw pointer type: `*[const | mut] $type`.\n+    fn parse_ty_ptr(&mut self) -> PResult<'a, TyKind> {\n         let mutbl = self.parse_const_or_mut().unwrap_or_else(|| {\n             let span = self.prev_span;\n             let msg = \"expected mut or const in raw pointer type\";\n@@ -263,23 +210,37 @@ impl<'a> Parser<'a> {\n                 .emit();\n             Mutability::Not\n         });\n-        let t = self.parse_ty_no_plus()?;\n-        Ok(MutTy { ty: t, mutbl })\n+        let ty = self.parse_ty_no_plus()?;\n+        Ok(TyKind::Ptr(MutTy { ty, mutbl }))\n     }\n \n-    fn maybe_parse_fixed_length_of_vec(&mut self) -> PResult<'a, Option<P<ast::Expr>>> {\n-        if self.eat(&token::Semi) {\n-            Ok(Some(self.parse_expr()?))\n+    /// Parses an array (`[TYPE; EXPR]`) or slice (`[TYPE]`) type.\n+    /// The opening `[` bracket is already eaten.\n+    fn parse_array_or_slice_ty(&mut self) -> PResult<'a, TyKind> {\n+        let elt_ty = self.parse_ty()?;\n+        let ty = if self.eat(&token::Semi) {\n+            TyKind::Array(elt_ty, self.parse_anon_const_expr()?)\n         } else {\n-            Ok(None)\n-        }\n+            TyKind::Slice(elt_ty)\n+        };\n+        self.expect(&token::CloseDelim(token::Bracket))?;\n+        Ok(ty)\n     }\n \n     fn parse_borrowed_pointee(&mut self) -> PResult<'a, TyKind> {\n         let opt_lifetime = if self.check_lifetime() { Some(self.expect_lifetime()) } else { None };\n         let mutbl = self.parse_mutability();\n         let ty = self.parse_ty_no_plus()?;\n-        return Ok(TyKind::Rptr(opt_lifetime, MutTy { ty, mutbl }));\n+        Ok(TyKind::Rptr(opt_lifetime, MutTy { ty, mutbl }))\n+    }\n+\n+    // Parses the `typeof(EXPR)`.\n+    // To avoid ambiguity, the type is surrounded by parenthesis.\n+    fn parse_typeof_ty(&mut self) -> PResult<'a, TyKind> {\n+        self.expect(&token::OpenDelim(token::Paren))?;\n+        let expr = self.parse_anon_const_expr()?;\n+        self.expect(&token::CloseDelim(token::Paren))?;\n+        Ok(TyKind::Typeof(expr))\n     }\n \n     /// Is the current token one of the keywords that signals a bare function type?\n@@ -289,20 +250,15 @@ impl<'a> Parser<'a> {\n             self.check_keyword(kw::Extern)\n     }\n \n-    /// Parses a `TyKind::BareFn` type.\n+    /// Parses a function pointer type (`TyKind::BareFn`).\n+    /// ```\n+    /// [unsafe] [extern \"ABI\"] fn (S) -> T\n+    ///  ^~~~~^          ^~~~^     ^~^    ^\n+    ///    |               |        |     |\n+    ///    |               |        |   Return type\n+    /// Function Style    ABI  Parameter types\n+    /// ```\n     fn parse_ty_bare_fn(&mut self, generic_params: Vec<GenericParam>) -> PResult<'a, TyKind> {\n-        /*\n-\n-        [unsafe] [extern \"ABI\"] fn (S) -> T\n-         ^~~~^           ^~~~^     ^~^    ^\n-           |               |        |     |\n-           |               |        |   Return type\n-           |               |      Argument types\n-           |               |\n-           |              ABI\n-        Function Style\n-        */\n-\n         let unsafety = self.parse_unsafety();\n         let ext = self.parse_extern()?;\n         self.expect_keyword(kw::Fn)?;\n@@ -319,130 +275,241 @@ impl<'a> Parser<'a> {\n         })))\n     }\n \n-    pub(super) fn parse_generic_bounds(&mut self,\n-                                  colon_span: Option<Span>) -> PResult<'a, GenericBounds> {\n+    /// Parses an `impl B0 + ... + Bn` type.\n+    fn parse_impl_ty(&mut self, impl_dyn_multi: &mut bool) -> PResult<'a, TyKind> {\n+        // Always parse bounds greedily for better error recovery.\n+        let bounds = self.parse_generic_bounds(None)?;\n+        *impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n+        Ok(TyKind::ImplTrait(ast::DUMMY_NODE_ID, bounds))\n+    }\n+\n+    /// Is a `dyn B0 + ... + Bn` type allowed here?\n+    fn is_explicit_dyn_type(&mut self) -> bool {\n+        self.check_keyword(kw::Dyn)\n+            && (self.token.span.rust_2018()\n+                || self.look_ahead(1, |t| {\n+                    t.can_begin_bound() && !can_continue_type_after_non_fn_ident(t)\n+                }))\n+    }\n+\n+    /// Parses a `dyn B0 + ... + Bn` type.\n+    ///\n+    /// Note that this does *not* parse bare trait objects.\n+    fn parse_dyn_ty(&mut self, impl_dyn_multi: &mut bool) -> PResult<'a, TyKind> {\n+        self.bump(); // `dyn`\n+        // Always parse bounds greedily for better error recovery.\n+        let bounds = self.parse_generic_bounds(None)?;\n+        *impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n+        Ok(TyKind::TraitObject(bounds, TraitObjectSyntax::Dyn))\n+    }\n+\n+    /// Parses a type starting with a path.\n+    ///\n+    /// This can be:\n+    /// 1. a type macro, `mac!(...)`,\n+    /// 2. a bare trait object, `B0 + ... + Bn`,\n+    /// 3. or a path, `path::to::MyType`.\n+    fn parse_path_start_ty(&mut self, lo: Span, allow_plus: bool) -> PResult<'a, TyKind> {\n+        // Simple path\n+        let path = self.parse_path(PathStyle::Type)?;\n+        if self.eat(&token::Not) {\n+            // Macro invocation in type position\n+            Ok(TyKind::Mac(Mac {\n+                path,\n+                args: self.parse_mac_args()?,\n+                prior_type_ascription: self.last_type_ascription,\n+            }))\n+        } else if allow_plus && self.check_plus() {\n+            // `Trait1 + Trait2 + 'a`\n+            self.parse_remaining_bounds(Vec::new(), path, lo, true)\n+        } else {\n+            // Just a type path.\n+            Ok(TyKind::Path(None, path))\n+        }\n+    }\n+\n+    fn error_illegal_c_varadic_ty(&self, lo: Span) {\n+        struct_span_err!(\n+            self.sess.span_diagnostic,\n+            lo.to(self.prev_span),\n+            E0743,\n+            \"C-variadic type `...` may not be nested inside another type\",\n+        )\n+        .emit();\n+    }\n+\n+    pub(super) fn parse_generic_bounds(\n+        &mut self,\n+        colon_span: Option<Span>,\n+    ) -> PResult<'a, GenericBounds> {\n         self.parse_generic_bounds_common(true, colon_span)\n     }\n \n     /// Parses bounds of a type parameter `BOUND + BOUND + ...`, possibly with trailing `+`.\n     ///\n-    /// ```\n-    /// BOUND = TY_BOUND | LT_BOUND\n-    /// LT_BOUND = LIFETIME (e.g., `'a`)\n-    /// TY_BOUND = TY_BOUND_NOPAREN | (TY_BOUND_NOPAREN)\n-    /// TY_BOUND_NOPAREN = [?] [for<LT_PARAM_DEFS>] SIMPLE_PATH (e.g., `?for<'a: 'b> m::Trait<'a>`)\n-    /// ```\n-    fn parse_generic_bounds_common(&mut self,\n-                                   allow_plus: bool,\n-                                   colon_span: Option<Span>) -> PResult<'a, GenericBounds> {\n+    /// See `parse_generic_bound` for the `BOUND` grammar.\n+    fn parse_generic_bounds_common(\n+        &mut self,\n+        allow_plus: bool,\n+        colon_span: Option<Span>,\n+    ) -> PResult<'a, GenericBounds> {\n         let mut bounds = Vec::new();\n         let mut negative_bounds = Vec::new();\n-        let mut last_plus_span = None;\n-        let mut was_negative = false;\n-        loop {\n-            // This needs to be synchronized with `TokenKind::can_begin_bound`.\n-            let is_bound_start = self.check_path() || self.check_lifetime() ||\n-                                 self.check(&token::Not) || // used for error reporting only\n-                                 self.check(&token::Question) ||\n-                                 self.check_keyword(kw::For) ||\n-                                 self.check(&token::OpenDelim(token::Paren));\n-            if is_bound_start {\n-                let lo = self.token.span;\n-                let has_parens = self.eat(&token::OpenDelim(token::Paren));\n-                let inner_lo = self.token.span;\n-                let is_negative = self.eat(&token::Not);\n-                let question = if self.eat(&token::Question) { Some(self.prev_span) } else { None };\n-                if self.token.is_lifetime() {\n-                    if let Some(question_span) = question {\n-                        self.span_err(question_span,\n-                                      \"`?` may only modify trait bounds, not lifetime bounds\");\n-                    }\n-                    bounds.push(GenericBound::Outlives(self.expect_lifetime()));\n-                    if has_parens {\n-                        let inner_span = inner_lo.to(self.prev_span);\n-                        self.expect(&token::CloseDelim(token::Paren))?;\n-                        let mut err = self.struct_span_err(\n-                            lo.to(self.prev_span),\n-                            \"parenthesized lifetime bounds are not supported\"\n-                        );\n-                        if let Ok(snippet) = self.span_to_snippet(inner_span) {\n-                            err.span_suggestion_short(\n-                                lo.to(self.prev_span),\n-                                \"remove the parentheses\",\n-                                snippet.to_owned(),\n-                                Applicability::MachineApplicable\n-                            );\n-                        }\n-                        err.emit();\n-                    }\n-                } else {\n-                    let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n-                    let path = self.parse_path(PathStyle::Type)?;\n-                    if has_parens {\n-                        self.expect(&token::CloseDelim(token::Paren))?;\n-                    }\n-                    let poly_span = lo.to(self.prev_span);\n-                    if is_negative {\n-                        was_negative = true;\n-                        if let Some(sp) = last_plus_span.or(colon_span) {\n-                            negative_bounds.push(sp.to(poly_span));\n-                        }\n-                    } else {\n-                        let poly_trait = PolyTraitRef::new(lifetime_defs, path, poly_span);\n-                        let modifier = if question.is_some() {\n-                            TraitBoundModifier::Maybe\n-                        } else {\n-                            TraitBoundModifier::None\n-                        };\n-                        bounds.push(GenericBound::Trait(poly_trait, modifier));\n-                    }\n-                }\n-            } else {\n-                break\n+        while self.can_begin_bound() {\n+            match self.parse_generic_bound()? {\n+                Ok(bound) => bounds.push(bound),\n+                Err(neg_sp) => negative_bounds.push(neg_sp),\n             }\n-\n             if !allow_plus || !self.eat_plus() {\n                 break\n-            } else {\n-                last_plus_span = Some(self.prev_span);\n             }\n         }\n \n-        if !negative_bounds.is_empty() || was_negative {\n-            let negative_bounds_len = negative_bounds.len();\n-            let last_span = negative_bounds.last().map(|sp| *sp);\n-            let mut err = self.struct_span_err(\n-                negative_bounds,\n-                \"negative trait bounds are not supported\",\n-            );\n-            if let Some(sp) = last_span {\n-                err.span_label(sp, \"negative trait bounds are not supported\");\n-            }\n-            if let Some(bound_list) = colon_span {\n-                let bound_list = bound_list.to(self.prev_span);\n-                let mut new_bound_list = String::new();\n-                if !bounds.is_empty() {\n-                    let mut snippets = bounds.iter().map(|bound| bound.span())\n-                        .map(|span| self.span_to_snippet(span));\n-                    while let Some(Ok(snippet)) = snippets.next() {\n-                        new_bound_list.push_str(\" + \");\n-                        new_bound_list.push_str(&snippet);\n-                    }\n-                    new_bound_list = new_bound_list.replacen(\" +\", \":\", 1);\n+        if !negative_bounds.is_empty() {\n+            self.error_negative_bounds(colon_span, &bounds, negative_bounds);\n+        }\n+\n+        Ok(bounds)\n+    }\n+\n+    /// Can the current token begin a bound?\n+    fn can_begin_bound(&mut self) -> bool {\n+        // This needs to be synchronized with `TokenKind::can_begin_bound`.\n+        self.check_path()\n+        || self.check_lifetime()\n+        || self.check(&token::Not) // Used for error reporting only.\n+        || self.check(&token::Question)\n+        || self.check_keyword(kw::For)\n+        || self.check(&token::OpenDelim(token::Paren))\n+    }\n+\n+    fn error_negative_bounds(\n+        &self,\n+        colon_span: Option<Span>,\n+        bounds: &[GenericBound],\n+        negative_bounds: Vec<Span>,\n+    ) {\n+        let negative_bounds_len = negative_bounds.len();\n+        let last_span = *negative_bounds.last().expect(\"no negative bounds, but still error?\");\n+        let mut err = self.struct_span_err(\n+            negative_bounds,\n+            \"negative bounds are not supported\",\n+        );\n+        err.span_label(last_span, \"negative bounds are not supported\");\n+        if let Some(bound_list) = colon_span {\n+            let bound_list = bound_list.to(self.prev_span);\n+            let mut new_bound_list = String::new();\n+            if !bounds.is_empty() {\n+                let mut snippets = bounds.iter().map(|bound| self.span_to_snippet(bound.span()));\n+                while let Some(Ok(snippet)) = snippets.next() {\n+                    new_bound_list.push_str(\" + \");\n+                    new_bound_list.push_str(&snippet);\n                 }\n-                err.span_suggestion_hidden(\n-                    bound_list,\n-                    &format!(\"remove the trait bound{}\", pluralize!(negative_bounds_len)),\n-                    new_bound_list,\n-                    Applicability::MachineApplicable,\n-                );\n+                new_bound_list = new_bound_list.replacen(\" +\", \":\", 1);\n             }\n-            err.emit();\n+            err.tool_only_span_suggestion(\n+                bound_list,\n+                &format!(\"remove the bound{}\", pluralize!(negative_bounds_len)),\n+                new_bound_list,\n+                Applicability::MachineApplicable,\n+            );\n         }\n+        err.emit();\n+    }\n \n-        return Ok(bounds);\n+    /// Parses a bound according to the grammar:\n+    /// ```\n+    /// BOUND = TY_BOUND | LT_BOUND\n+    /// ```\n+    fn parse_generic_bound(&mut self) -> PResult<'a, Result<GenericBound, Span>> {\n+        let anchor_lo = self.prev_span;\n+        let lo = self.token.span;\n+        let has_parens = self.eat(&token::OpenDelim(token::Paren));\n+        let inner_lo = self.token.span;\n+        let is_negative = self.eat(&token::Not);\n+        let question = self.eat(&token::Question).then_some(self.prev_span);\n+        let bound = if self.token.is_lifetime() {\n+            self.parse_generic_lt_bound(lo, inner_lo, has_parens, question)?\n+        } else {\n+            self.parse_generic_ty_bound(lo, has_parens, question)?\n+        };\n+        Ok(if is_negative {\n+            Err(anchor_lo.to(self.prev_span))\n+        } else {\n+            Ok(bound)\n+        })\n+    }\n+\n+    /// Parses a lifetime (\"outlives\") bound, e.g. `'a`, according to:\n+    /// ```\n+    /// LT_BOUND = LIFETIME\n+    /// ```\n+    fn parse_generic_lt_bound(\n+        &mut self,\n+        lo: Span,\n+        inner_lo: Span,\n+        has_parens: bool,\n+        question: Option<Span>,\n+    ) -> PResult<'a, GenericBound> {\n+        self.error_opt_out_lifetime(question);\n+        let bound = GenericBound::Outlives(self.expect_lifetime());\n+        if has_parens {\n+            // FIXME(Centril): Consider not erroring here and accepting `('lt)` instead,\n+            // possibly introducing `GenericBound::Paren(P<GenericBound>)`?\n+            self.recover_paren_lifetime(lo, inner_lo)?;\n+        }\n+        Ok(bound)\n+    }\n+\n+    fn error_opt_out_lifetime(&self, question: Option<Span>) {\n+        if let Some(span) = question {\n+            self.struct_span_err(span, \"`?` may only modify trait bounds, not lifetime bounds\")\n+                .emit();\n+        }\n+    }\n+\n+    /// Recover on `('lifetime)` with `(` already eaten.\n+    fn recover_paren_lifetime(&mut self, lo: Span, inner_lo: Span) -> PResult<'a, ()> {\n+        let inner_span = inner_lo.to(self.prev_span);\n+        self.expect(&token::CloseDelim(token::Paren))?;\n+        let mut err = self.struct_span_err(\n+            lo.to(self.prev_span),\n+            \"parenthesized lifetime bounds are not supported\"\n+        );\n+        if let Ok(snippet) = self.span_to_snippet(inner_span) {\n+            err.span_suggestion_short(\n+                lo.to(self.prev_span),\n+                \"remove the parentheses\",\n+                snippet.to_owned(),\n+                Applicability::MachineApplicable\n+            );\n+        }\n+        err.emit();\n+        Ok(())\n+    }\n+\n+    /// Parses a type bound according to:\n+    /// ```\n+    /// TY_BOUND = TY_BOUND_NOPAREN | (TY_BOUND_NOPAREN)\n+    /// TY_BOUND_NOPAREN = [?] [for<LT_PARAM_DEFS>] SIMPLE_PATH (e.g., `?for<'a: 'b> m::Trait<'a>`)\n+    /// ```\n+    fn parse_generic_ty_bound(\n+        &mut self,\n+        lo: Span,\n+        has_parens: bool,\n+        question: Option<Span>,\n+    ) -> PResult<'a, GenericBound> {\n+        let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n+        let path = self.parse_path(PathStyle::Type)?;\n+        if has_parens {\n+            self.expect(&token::CloseDelim(token::Paren))?;\n+        }\n+        let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n+        let modifier = question.map_or(TraitBoundModifier::None, |_| TraitBoundModifier::Maybe);\n+        Ok(GenericBound::Trait(poly_trait, modifier))\n     }\n \n+    /// Optionally parses `for<$generic_params>`.\n     pub(super) fn parse_late_bound_lifetime_defs(&mut self) -> PResult<'a, Vec<GenericParam>> {\n         if self.eat_keyword(kw::For) {\n             self.expect_lt()?;"}, {"sha": "4350d7e5b403bcabc727c7c816bfae23f248eada", "filename": "src/test/ui/issues/issue-58857.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Ftest%2Fui%2Fissues%2Fissue-58857.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Ftest%2Fui%2Fissues%2Fissue-58857.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58857.rs?ref=616373e6681822ae003390b2dd99ed7b801dd8c2", "patch": "@@ -2,6 +2,6 @@ struct Conj<A> {a : A}\n trait Valid {}\n \n impl<A: !Valid> Conj<A>{}\n-//~^ ERROR negative trait bounds are not supported\n+//~^ ERROR negative bounds are not supported\n \n fn main() {}"}, {"sha": "e2acec47e5abfcdb1d0ba621138295a6cddf927d", "filename": "src/test/ui/issues/issue-58857.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Ftest%2Fui%2Fissues%2Fissue-58857.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Ftest%2Fui%2Fissues%2Fissue-58857.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58857.stderr?ref=616373e6681822ae003390b2dd99ed7b801dd8c2", "patch": "@@ -1,10 +1,8 @@\n-error: negative trait bounds are not supported\n+error: negative bounds are not supported\n   --> $DIR/issue-58857.rs:4:7\n    |\n LL | impl<A: !Valid> Conj<A>{}\n-   |       ^^^^^^^^ negative trait bounds are not supported\n-   |\n-   = help: remove the trait bound\n+   |       ^^^^^^^^ negative bounds are not supported\n \n error: aborting due to previous error\n "}, {"sha": "ed885ae14356633e0043e1fd0fa7ed1ff9c5e622", "filename": "src/test/ui/parser/issue-33418.fixed", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Ftest%2Fui%2Fparser%2Fissue-33418.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Ftest%2Fui%2Fparser%2Fissue-33418.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-33418.fixed?ref=616373e6681822ae003390b2dd99ed7b801dd8c2", "patch": "@@ -1,15 +1,15 @@\n // run-rustfix\n \n trait Tr {}\n-//~^ ERROR negative trait bounds are not supported\n+//~^ ERROR negative bounds are not supported\n trait Tr2: SuperA {}\n-//~^ ERROR negative trait bounds are not supported\n+//~^ ERROR negative bounds are not supported\n trait Tr3: SuperB {}\n-//~^ ERROR negative trait bounds are not supported\n+//~^ ERROR negative bounds are not supported\n trait Tr4: SuperB + SuperD {}\n-//~^ ERROR negative trait bounds are not supported\n+//~^ ERROR negative bounds are not supported\n trait Tr5 {}\n-//~^ ERROR negative trait bounds are not supported\n+//~^ ERROR negative bounds are not supported\n \n trait SuperA {}\n trait SuperB {}"}, {"sha": "9934284abfbbeb11d9dd3b8b4e395d8e9ed6bbb4", "filename": "src/test/ui/parser/issue-33418.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Ftest%2Fui%2Fparser%2Fissue-33418.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Ftest%2Fui%2Fparser%2Fissue-33418.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-33418.rs?ref=616373e6681822ae003390b2dd99ed7b801dd8c2", "patch": "@@ -1,17 +1,17 @@\n // run-rustfix\n \n trait Tr: !SuperA {}\n-//~^ ERROR negative trait bounds are not supported\n+//~^ ERROR negative bounds are not supported\n trait Tr2: SuperA + !SuperB {}\n-//~^ ERROR negative trait bounds are not supported\n+//~^ ERROR negative bounds are not supported\n trait Tr3: !SuperA + SuperB {}\n-//~^ ERROR negative trait bounds are not supported\n+//~^ ERROR negative bounds are not supported\n trait Tr4: !SuperA + SuperB\n     + !SuperC + SuperD {}\n-//~^ ERROR negative trait bounds are not supported\n+//~^ ERROR negative bounds are not supported\n trait Tr5: !SuperA\n     + !SuperB {}\n-//~^ ERROR negative trait bounds are not supported\n+//~^ ERROR negative bounds are not supported\n \n trait SuperA {}\n trait SuperB {}"}, {"sha": "9a8733e89292e057cea0a79920a9eaf5e81f682e", "filename": "src/test/ui/parser/issue-33418.stderr", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Ftest%2Fui%2Fparser%2Fissue-33418.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Ftest%2Fui%2Fparser%2Fissue-33418.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-33418.stderr?ref=616373e6681822ae003390b2dd99ed7b801dd8c2", "patch": "@@ -1,46 +1,36 @@\n-error: negative trait bounds are not supported\n+error: negative bounds are not supported\n   --> $DIR/issue-33418.rs:3:9\n    |\n LL | trait Tr: !SuperA {}\n-   |         ^^^^^^^^^ negative trait bounds are not supported\n-   |\n-   = help: remove the trait bound\n+   |         ^^^^^^^^^ negative bounds are not supported\n \n-error: negative trait bounds are not supported\n+error: negative bounds are not supported\n   --> $DIR/issue-33418.rs:5:19\n    |\n LL | trait Tr2: SuperA + !SuperB {}\n-   |                   ^^^^^^^^^ negative trait bounds are not supported\n-   |\n-   = help: remove the trait bound\n+   |                   ^^^^^^^^^ negative bounds are not supported\n \n-error: negative trait bounds are not supported\n+error: negative bounds are not supported\n   --> $DIR/issue-33418.rs:7:10\n    |\n LL | trait Tr3: !SuperA + SuperB {}\n-   |          ^^^^^^^^^ negative trait bounds are not supported\n-   |\n-   = help: remove the trait bound\n+   |          ^^^^^^^^^ negative bounds are not supported\n \n-error: negative trait bounds are not supported\n+error: negative bounds are not supported\n   --> $DIR/issue-33418.rs:9:10\n    |\n LL | trait Tr4: !SuperA + SuperB\n    |          ^^^^^^^^^\n LL |     + !SuperC + SuperD {}\n-   |     ^^^^^^^^^ negative trait bounds are not supported\n-   |\n-   = help: remove the trait bounds\n+   |     ^^^^^^^^^ negative bounds are not supported\n \n-error: negative trait bounds are not supported\n+error: negative bounds are not supported\n   --> $DIR/issue-33418.rs:12:10\n    |\n LL | trait Tr5: !SuperA\n    |          ^^^^^^^^^\n LL |     + !SuperB {}\n-   |     ^^^^^^^^^ negative trait bounds are not supported\n-   |\n-   = help: remove the trait bounds\n+   |     ^^^^^^^^^ negative bounds are not supported\n \n error: aborting due to 5 previous errors\n "}, {"sha": "5a109ba7c6894f25600642ddefe2eef5117d39ef", "filename": "src/test/ui/parser/issue-67146-negative-outlives-bound-syntactic-fail.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Ftest%2Fui%2Fparser%2Fissue-67146-negative-outlives-bound-syntactic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Ftest%2Fui%2Fparser%2Fissue-67146-negative-outlives-bound-syntactic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-67146-negative-outlives-bound-syntactic-fail.rs?ref=616373e6681822ae003390b2dd99ed7b801dd8c2", "patch": "@@ -0,0 +1,12 @@\n+// In this regression test for #67146, we check that the\n+// negative outlives bound `!'a` is rejected by the parser.\n+// This regression was first introduced in PR #57364.\n+\n+fn main() {}\n+\n+fn f1<T: !'static>() {}\n+//~^ ERROR negative bounds are not supported\n+fn f2<'a, T: Ord + !'a>() {}\n+//~^ ERROR negative bounds are not supported\n+fn f3<'a, T: !'a + Ord>() {}\n+//~^ ERROR negative bounds are not supported"}, {"sha": "4dc06347304421eb3394b53cf0d29acf7bc11bba", "filename": "src/test/ui/parser/issue-67146-negative-outlives-bound-syntactic-fail.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Ftest%2Fui%2Fparser%2Fissue-67146-negative-outlives-bound-syntactic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Ftest%2Fui%2Fparser%2Fissue-67146-negative-outlives-bound-syntactic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-67146-negative-outlives-bound-syntactic-fail.stderr?ref=616373e6681822ae003390b2dd99ed7b801dd8c2", "patch": "@@ -0,0 +1,20 @@\n+error: negative bounds are not supported\n+  --> $DIR/issue-67146-negative-outlives-bound-syntactic-fail.rs:7:8\n+   |\n+LL | fn f1<T: !'static>() {}\n+   |        ^^^^^^^^^^ negative bounds are not supported\n+\n+error: negative bounds are not supported\n+  --> $DIR/issue-67146-negative-outlives-bound-syntactic-fail.rs:9:18\n+   |\n+LL | fn f2<'a, T: Ord + !'a>() {}\n+   |                  ^^^^^ negative bounds are not supported\n+\n+error: negative bounds are not supported\n+  --> $DIR/issue-67146-negative-outlives-bound-syntactic-fail.rs:11:12\n+   |\n+LL | fn f3<'a, T: !'a + Ord>() {}\n+   |            ^^^^^ negative bounds are not supported\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "648635f0c32fa34eea905318354ddb977136b4f9", "filename": "src/test/ui/type/ascription/issue-47666.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/616373e6681822ae003390b2dd99ed7b801dd8c2/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr?ref=616373e6681822ae003390b2dd99ed7b801dd8c2", "patch": "@@ -11,7 +11,7 @@ LL |     let _ = Option:Some(vec![0, 1]);\n    |\n    = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n    = note: for more information, see https://github.com/rust-lang/rust/issues/23416\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error: aborting due to previous error\n "}]}