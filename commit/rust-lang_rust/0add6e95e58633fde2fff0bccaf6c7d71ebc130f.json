{"sha": "0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "node_id": "C_kwDOAAsO6NoAKDBhZGQ2ZTk1ZTU4NjMzZmRlMmZmZjBiY2NhZjZjN2Q3MWViYzEzMGY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-12-19T17:02:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-19T17:02:40Z"}, "message": "Merge #11060\n\n11060: minor: Bump deps r=lnicola a=lnicola\n\n\n\nCo-authored-by: Lauren\u021biu Nicola <lnicola@dend.ro>", "tree": {"sha": "fbb7675fdc8992b829bf3c635127dd5f69ca0a55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbb7675fdc8992b829bf3c635127dd5f69ca0a55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhv2WwCRBK7hj4Ov3rIwAACtMIAJfBaf3Jizd03DkSRo13/GTL\nYqHQg3/tVSDjkFoSYJqgkadHKjBMPxHH7H/CSDmJMqCYBvAa0FSIXCswz28hwNjP\n9m/FzCKiZ23UeV+9rtOdUP2m6ugMvU9OSG7CafIeOEAYbjIwv5aPFjLdo8X4Wo+i\nj4fFiyuqIusx1+M2bcU6PKvE4/3E2+D/3ce5xLRlnwCnGbHXU1Eq3uMA4NzKmTdh\nl8PL5HQqeQ9P9COoBXN9EsSl+j6ZYnFvfjYDwqwh42W0nnUsmffKyCPwWTV3baT0\ne3tIvMi9lcvpqQ4V9hNLGpNAODsJZLbgvGfatDVeuhaIfK2u+7Mcgo5YbKlaMg4=\n=vTN2\n-----END PGP SIGNATURE-----\n", "payload": "tree fbb7675fdc8992b829bf3c635127dd5f69ca0a55\nparent 638cc3e59f09b20e6ca6965ab1f3936e2467c497\nparent c9ca77f641d3189949f2d1a6686bb5c8911e15b5\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1639933360 +0000\ncommitter GitHub <noreply@github.com> 1639933360 +0000\n\nMerge #11060\n\n11060: minor: Bump deps r=lnicola a=lnicola\n\n\n\nCo-authored-by: Lauren\u021biu Nicola <lnicola@dend.ro>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "html_url": "https://github.com/rust-lang/rust/commit/0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "638cc3e59f09b20e6ca6965ab1f3936e2467c497", "url": "https://api.github.com/repos/rust-lang/rust/commits/638cc3e59f09b20e6ca6965ab1f3936e2467c497", "html_url": "https://github.com/rust-lang/rust/commit/638cc3e59f09b20e6ca6965ab1f3936e2467c497"}, {"sha": "c9ca77f641d3189949f2d1a6686bb5c8911e15b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9ca77f641d3189949f2d1a6686bb5c8911e15b5", "html_url": "https://github.com/rust-lang/rust/commit/c9ca77f641d3189949f2d1a6686bb5c8911e15b5"}], "stats": {"total": 1287, "additions": 640, "deletions": 647}, "files": [{"sha": "cd4324cf3c4ffee2ed21f6bab684e389a91c3fce", "filename": "Cargo.lock", "status": "modified", "additions": 38, "deletions": 29, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -87,7 +87,7 @@ dependencies = [\n  \"cfg-if\",\n  \"libc\",\n  \"miniz_oxide\",\n- \"object\",\n+ \"object 0.27.1\",\n  \"rustc-demangle\",\n ]\n \n@@ -171,9 +171,9 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.74.0\"\n+version = \"0.75.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"09d8c85134e234bead3fb78e4abd3ca2bdc228e5897b7f0fcd5265c4f4294375\"\n+checksum = \"d54e3b5f9e3425e6b119ff07568d8d006bfa5a8d6f78a9cbc3530b1e962e316c\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -183,9 +183,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.74.0\"\n+version = \"0.75.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b08046b4a060d3fbf9df521a3aca331ff14d0a50c184b09a7b80edca1bf2aa79\"\n+checksum = \"2b79e5a1d04b79311e90c69356a2c62027853906a7e33b3e070b93c055fc3e8a\"\n dependencies = [\n  \"bitflags\",\n  \"chalk-derive\",\n@@ -194,9 +194,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-recursive\"\n-version = \"0.74.0\"\n+version = \"0.75.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a8d0190d6f86bdd3395fb4482879cda3e40a14a4c32241805301fb079fd7b62c\"\n+checksum = \"c39f59e975a6ffdee8eae3b396fc903fca18b8d1de674bb2aae4da643db07685\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -207,9 +207,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.74.0\"\n+version = \"0.75.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2bb39cbb1887edb2e12513ad811bea9a70faf4f98f4de794c5899c2c2e43e1b4\"\n+checksum = \"a5d2a1db6605aba70a58820bd80ac422b218913a510f1a40beef9efc5371ea1d\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -765,9 +765,9 @@ dependencies = [\n \n [[package]]\n name = \"itoa\"\n-version = \"0.4.8\"\n+version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b71991ff56294aa922b450139ee08b3bfc70982c6b2c7562771375cf73542dd4\"\n+checksum = \"1aab8fc367588b89dcee83ab0fd66b72b50b72fa1904d7095045ace2b0c81c35\"\n \n [[package]]\n name = \"jod-thread\"\n@@ -807,9 +807,9 @@ checksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.111\"\n+version = \"0.2.112\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8e167738f1866a7ec625567bae89ca0d44477232a4f7c52b1c7f2adc2c98804f\"\n+checksum = \"1b03d17f364a3a042d5e5d46b053bbbf82c92c9430c592dd4c064dc6ee997125\"\n \n [[package]]\n name = \"libloading\"\n@@ -1027,11 +1027,20 @@ dependencies = [\n  \"memchr\",\n ]\n \n+[[package]]\n+name = \"object\"\n+version = \"0.28.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7ce8b38d41f9f3618fc23f908faae61510f8d8ce2d99cbe910641e8f1971f084\"\n+dependencies = [\n+ \"memchr\",\n+]\n+\n [[package]]\n name = \"once_cell\"\n-version = \"1.8.0\"\n+version = \"1.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"692fcb63b64b1758029e0a96ee63e049ce8c5948587f2f7208df04625e5f6b56\"\n+checksum = \"da32515d9f6e6e489d7bc9d84c71b060db7247dc035bbe44eac88cf87486d8d5\"\n \n [[package]]\n name = \"oorandom\"\n@@ -1127,9 +1136,9 @@ checksum = \"8d31d11c69a6b52a174b42bdc0c30e5e11670f90788b2c471c31c1d17d449443\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.33\"\n+version = \"1.0.34\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fb37d2df5df740e582f28f8560cf425f52bb267d872fe58358eadb554909f07a\"\n+checksum = \"2f84e92c0f7c9d58328b85a78557813e4bd845130db68d7184635344399423b1\"\n dependencies = [\n  \"unicode-xid\",\n ]\n@@ -1139,7 +1148,7 @@ name = \"proc_macro_api\"\n version = \"0.0.0\"\n dependencies = [\n  \"memmap2\",\n- \"object\",\n+ \"object 0.28.1\",\n  \"paths\",\n  \"profile\",\n  \"serde\",\n@@ -1158,7 +1167,7 @@ dependencies = [\n  \"libloading\",\n  \"mbe\",\n  \"memmap2\",\n- \"object\",\n+ \"object 0.28.1\",\n  \"paths\",\n  \"proc_macro_api\",\n  \"proc_macro_test\",\n@@ -1302,9 +1311,9 @@ checksum = \"f497285884f3fcff424ffc933e56d7cbca511def0c9831a7f9b5f6153e3cc89b\"\n \n [[package]]\n name = \"rowan\"\n-version = \"0.15.1\"\n+version = \"0.15.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"104e4d36da6a2a0c9485ebf1b2dfc628036c7cc9b38bd1b14fa785f1f1bdf5f0\"\n+checksum = \"71ea8fec43656b71f8bf4a0351ab18604488ee13b0bf72cad2965f5bb2ca9dc6\"\n dependencies = [\n  \"countme\",\n  \"hashbrown\",\n@@ -1388,9 +1397,9 @@ checksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n \n [[package]]\n name = \"ryu\"\n-version = \"1.0.8\"\n+version = \"1.0.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b30e4c09749c107e83dd61baf9604198efc4542863c88af39dafcaca89c7c9f9\"\n+checksum = \"73b4b750c782965c211b42f022f59af1fbceabdd026623714f104152f1ec149f\"\n \n [[package]]\n name = \"salsa\"\n@@ -1453,18 +1462,18 @@ dependencies = [\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.131\"\n+version = \"1.0.132\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b4ad69dfbd3e45369132cc64e6748c2d65cdfb001a2b1c232d128b4ad60561c1\"\n+checksum = \"8b9875c23cf305cd1fd7eb77234cbb705f21ea6a72c637a5c6db5fe4b8e7f008\"\n dependencies = [\n  \"serde_derive\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.131\"\n+version = \"1.0.132\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b710a83c4e0dff6a3d511946b95274ad9ca9e5d3ae497b63fda866ac955358d2\"\n+checksum = \"ecc0db5cb2556c0e558887d9bbdcf6ac4471e83ff66cf696e5419024d1606276\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1473,9 +1482,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.72\"\n+version = \"1.0.73\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d0ffa0837f2dfa6fb90868c2b5468cad482e175f7dad97e7421951e663f2b527\"\n+checksum = \"bcbd0344bc6533bc7ec56df11d42fb70f1b912351c0825ccb7211b59d8af7cf5\"\n dependencies = [\n  \"indexmap\",\n  \"itoa\","}, {"sha": "91ff1713120088d74ce0c4563f8a0074a34243dd", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -247,7 +247,7 @@ impl HirDisplay for TypeParam {\n         let bounds = f.db.generic_predicates_for_param(self.id, None);\n         let substs = TyBuilder::type_params_subst(f.db, self.id.parent);\n         let predicates: Vec<_> =\n-            bounds.iter().cloned().map(|b| b.substitute(&Interner, &substs)).collect();\n+            bounds.iter().cloned().map(|b| b.substitute(Interner, &substs)).collect();\n         let krate = self.id.parent.krate(f.db).id;\n         let sized_trait =\n             f.db.lang_item(krate, SmolStr::new_inline(\"sized\"))"}, {"sha": "a80668f1fe5548c52ba29772d6ead7dd76c4cc1f", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 36, "deletions": 39, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -796,7 +796,7 @@ impl Field {\n             VariantDef::Variant(it) => it.parent.id.into(),\n         };\n         let substs = TyBuilder::type_params_subst(db, generic_def_id);\n-        let ty = db.field_types(var_id)[self.id].clone().substitute(&Interner, &substs);\n+        let ty = db.field_types(var_id)[self.id].clone().substitute(Interner, &substs);\n         Type::new(db, self.parent.module(db).id.krate(), var_id, ty)\n     }\n \n@@ -2136,7 +2136,7 @@ impl TypeParam {\n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n         let resolver = self.id.parent.resolver(db.upcast());\n         let krate = self.id.parent.module(db.upcast()).krate();\n-        let ty = TyKind::Placeholder(hir_ty::to_placeholder_idx(db, self.id)).intern(&Interner);\n+        let ty = TyKind::Placeholder(hir_ty::to_placeholder_idx(db, self.id)).intern(Interner);\n         Type::new_with_resolver_inner(db, krate, &resolver, ty)\n     }\n \n@@ -2159,7 +2159,7 @@ impl TypeParam {\n         let krate = self.id.parent.module(db.upcast()).krate();\n         let ty = params.get(local_idx)?.clone();\n         let subst = TyBuilder::type_params_subst(db, self.id.parent);\n-        let ty = ty.substitute(&Interner, &subst_prefix(&subst, local_idx));\n+        let ty = ty.substitute(Interner, &subst_prefix(&subst, local_idx));\n         Some(Type::new_with_resolver_inner(db, krate, &resolver, ty))\n     }\n }\n@@ -2381,31 +2381,31 @@ impl Type {\n     }\n \n     pub fn is_unit(&self) -> bool {\n-        matches!(self.ty.kind(&Interner), TyKind::Tuple(0, ..))\n+        matches!(self.ty.kind(Interner), TyKind::Tuple(0, ..))\n     }\n \n     pub fn is_bool(&self) -> bool {\n-        matches!(self.ty.kind(&Interner), TyKind::Scalar(Scalar::Bool))\n+        matches!(self.ty.kind(Interner), TyKind::Scalar(Scalar::Bool))\n     }\n \n     pub fn is_never(&self) -> bool {\n-        matches!(self.ty.kind(&Interner), TyKind::Never)\n+        matches!(self.ty.kind(Interner), TyKind::Never)\n     }\n \n     pub fn is_mutable_reference(&self) -> bool {\n-        matches!(self.ty.kind(&Interner), TyKind::Ref(hir_ty::Mutability::Mut, ..))\n+        matches!(self.ty.kind(Interner), TyKind::Ref(hir_ty::Mutability::Mut, ..))\n     }\n \n     pub fn is_reference(&self) -> bool {\n-        matches!(self.ty.kind(&Interner), TyKind::Ref(..))\n+        matches!(self.ty.kind(Interner), TyKind::Ref(..))\n     }\n \n     pub fn is_usize(&self) -> bool {\n-        matches!(self.ty.kind(&Interner), TyKind::Scalar(Scalar::Uint(UintTy::Usize)))\n+        matches!(self.ty.kind(Interner), TyKind::Scalar(Scalar::Uint(UintTy::Usize)))\n     }\n \n     pub fn remove_ref(&self) -> Option<Type> {\n-        match &self.ty.kind(&Interner) {\n+        match &self.ty.kind(Interner) {\n             TyKind::Ref(.., ty) => Some(self.derived(ty.clone())),\n             _ => None,\n         }\n@@ -2434,7 +2434,7 @@ impl Type {\n         };\n \n         let canonical_ty =\n-            Canonical { value: self.ty.clone(), binders: CanonicalVarKinds::empty(&Interner) };\n+            Canonical { value: self.ty.clone(), binders: CanonicalVarKinds::empty(Interner) };\n         method_resolution::implements_trait(\n             &canonical_ty,\n             db,\n@@ -2457,7 +2457,7 @@ impl Type {\n         };\n \n         let canonical_ty =\n-            Canonical { value: self.ty.clone(), binders: CanonicalVarKinds::empty(&Interner) };\n+            Canonical { value: self.ty.clone(), binders: CanonicalVarKinds::empty(Interner) };\n         method_resolution::implements_trait_unique(\n             &canonical_ty,\n             db,\n@@ -2474,8 +2474,8 @@ impl Type {\n             .build();\n \n         let goal = Canonical {\n-            value: hir_ty::InEnvironment::new(&self.env.env, trait_ref.cast(&Interner)),\n-            binders: CanonicalVarKinds::empty(&Interner),\n+            value: hir_ty::InEnvironment::new(&self.env.env, trait_ref.cast(Interner)),\n+            binders: CanonicalVarKinds::empty(Interner),\n         };\n \n         db.trait_solve(self.krate, goal).is_some()\n@@ -2497,9 +2497,9 @@ impl Type {\n                 AliasEq {\n                     alias: AliasTy::Projection(projection),\n                     ty: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0))\n-                        .intern(&Interner),\n+                        .intern(Interner),\n                 }\n-                .cast(&Interner),\n+                .cast(Interner),\n             ),\n             [TyVariableKind::General].into_iter(),\n         );\n@@ -2508,9 +2508,9 @@ impl Type {\n             Solution::Unique(s) => s\n                 .value\n                 .subst\n-                .as_slice(&Interner)\n+                .as_slice(Interner)\n                 .first()\n-                .map(|ty| self.derived(ty.assert_ty_ref(&Interner).clone())),\n+                .map(|ty| self.derived(ty.assert_ty_ref(Interner).clone())),\n             Solution::Ambig(_) => None,\n         }\n     }\n@@ -2532,15 +2532,15 @@ impl Type {\n     }\n \n     pub fn is_closure(&self) -> bool {\n-        matches!(&self.ty.kind(&Interner), TyKind::Closure { .. })\n+        matches!(&self.ty.kind(Interner), TyKind::Closure { .. })\n     }\n \n     pub fn is_fn(&self) -> bool {\n-        matches!(&self.ty.kind(&Interner), TyKind::FnDef(..) | TyKind::Function { .. })\n+        matches!(&self.ty.kind(Interner), TyKind::FnDef(..) | TyKind::Function { .. })\n     }\n \n     pub fn is_packed(&self, db: &dyn HirDatabase) -> bool {\n-        let adt_id = match *self.ty.kind(&Interner) {\n+        let adt_id = match *self.ty.kind(Interner) {\n             TyKind::Adt(hir_ty::AdtId(adt_id), ..) => adt_id,\n             _ => return false,\n         };\n@@ -2553,14 +2553,14 @@ impl Type {\n     }\n \n     pub fn is_raw_ptr(&self) -> bool {\n-        matches!(&self.ty.kind(&Interner), TyKind::Raw(..))\n+        matches!(&self.ty.kind(Interner), TyKind::Raw(..))\n     }\n \n     pub fn contains_unknown(&self) -> bool {\n         return go(&self.ty);\n \n         fn go(ty: &Ty) -> bool {\n-            match ty.kind(&Interner) {\n+            match ty.kind(Interner) {\n                 TyKind::Error => true,\n \n                 TyKind::Adt(_, substs)\n@@ -2569,7 +2569,7 @@ impl Type {\n                 | TyKind::OpaqueType(_, substs)\n                 | TyKind::FnDef(_, substs)\n                 | TyKind::Closure(_, substs) => {\n-                    substs.iter(&Interner).filter_map(|a| a.ty(&Interner)).any(go)\n+                    substs.iter(Interner).filter_map(|a| a.ty(Interner)).any(go)\n                 }\n \n                 TyKind::Array(_ty, len) if len.is_unknown() => true,\n@@ -2595,7 +2595,7 @@ impl Type {\n     }\n \n     pub fn fields(&self, db: &dyn HirDatabase) -> Vec<(Field, Type)> {\n-        let (variant_id, substs) = match self.ty.kind(&Interner) {\n+        let (variant_id, substs) = match self.ty.kind(Interner) {\n             TyKind::Adt(hir_ty::AdtId(AdtId::StructId(s)), substs) => ((*s).into(), substs),\n             TyKind::Adt(hir_ty::AdtId(AdtId::UnionId(u)), substs) => ((*u).into(), substs),\n             _ => return Vec::new(),\n@@ -2605,17 +2605,17 @@ impl Type {\n             .iter()\n             .map(|(local_id, ty)| {\n                 let def = Field { parent: variant_id.into(), id: local_id };\n-                let ty = ty.clone().substitute(&Interner, substs);\n+                let ty = ty.clone().substitute(Interner, substs);\n                 (def, self.derived(ty))\n             })\n             .collect()\n     }\n \n     pub fn tuple_fields(&self, _db: &dyn HirDatabase) -> Vec<Type> {\n-        if let TyKind::Tuple(_, substs) = &self.ty.kind(&Interner) {\n+        if let TyKind::Tuple(_, substs) = &self.ty.kind(Interner) {\n             substs\n-                .iter(&Interner)\n-                .map(|ty| self.derived(ty.assert_ty_ref(&Interner).clone()))\n+                .iter(Interner)\n+                .map(|ty| self.derived(ty.assert_ty_ref(Interner).clone()))\n                 .collect()\n         } else {\n             Vec::new()\n@@ -2678,8 +2678,8 @@ impl Type {\n             .strip_references()\n             .as_adt()\n             .into_iter()\n-            .flat_map(|(_, substs)| substs.iter(&Interner))\n-            .filter_map(|arg| arg.ty(&Interner).cloned())\n+            .flat_map(|(_, substs)| substs.iter(Interner))\n+            .filter_map(|arg| arg.ty(Interner).cloned())\n             .map(move |ty| self.derived(ty))\n     }\n \n@@ -2819,7 +2819,7 @@ impl Type {\n     pub fn env_traits<'a>(&'a self, db: &'a dyn HirDatabase) -> impl Iterator<Item = Trait> + 'a {\n         let _p = profile::span(\"env_traits\");\n         self.autoderef_(db)\n-            .filter(|ty| matches!(ty.kind(&Interner), TyKind::Placeholder(_)))\n+            .filter(|ty| matches!(ty.kind(Interner), TyKind::Placeholder(_)))\n             .flat_map(|ty| {\n                 self.env\n                     .traits_in_scope_from_clauses(ty)\n@@ -2857,7 +2857,7 @@ impl Type {\n             substs: &Substitution,\n             cb: &mut impl FnMut(Type),\n         ) {\n-            for ty in substs.iter(&Interner).filter_map(|a| a.ty(&Interner)) {\n+            for ty in substs.iter(Interner).filter_map(|a| a.ty(Interner)) {\n                 walk_type(db, &type_.derived(ty.clone()), cb);\n             }\n         }\n@@ -2872,11 +2872,8 @@ impl Type {\n                 if let WhereClause::Implemented(trait_ref) = pred.skip_binders() {\n                     cb(type_.clone());\n                     // skip the self type. it's likely the type we just got the bounds from\n-                    for ty in trait_ref\n-                        .substitution\n-                        .iter(&Interner)\n-                        .skip(1)\n-                        .filter_map(|a| a.ty(&Interner))\n+                    for ty in\n+                        trait_ref.substitution.iter(Interner).skip(1).filter_map(|a| a.ty(Interner))\n                     {\n                         walk_type(db, &type_.derived(ty.clone()), cb);\n                     }\n@@ -2886,7 +2883,7 @@ impl Type {\n \n         fn walk_type(db: &dyn HirDatabase, type_: &Type, cb: &mut impl FnMut(Type)) {\n             let ty = type_.ty.strip_references();\n-            match ty.kind(&Interner) {\n+            match ty.kind(Interner) {\n                 TyKind::Adt(_, substs) => {\n                     cb(type_.derived(ty.clone()));\n                     walk_substs(db, type_, substs, cb);"}, {"sha": "d27869450e5fe915097495c62ebc4ceb28cf07c3", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -821,7 +821,7 @@ impl<'db> SemanticsImpl<'db> {\n \n     fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n         let (func, subst) = self.analyze(call.syntax()).resolve_method_call(self.db, call)?;\n-        let ty = self.db.value_ty(func.into()).substitute(&Interner, &subst);\n+        let ty = self.db.value_ty(func.into()).substitute(Interner, &subst);\n         let resolver = self.analyze(call.syntax()).resolver;\n         let ty = Type::new_with_resolver(self.db, &resolver, ty)?;\n         let mut res = ty.as_callable(self.db)?;"}, {"sha": "4f987db651fda8c405da5453d92a948fb005b695", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -201,7 +201,7 @@ impl SourceAnalyzer {\n         let variant_data = variant.variant_data(db.upcast());\n         let field = FieldId { parent: variant, local_id: variant_data.field(&local_name)? };\n         let field_ty =\n-            db.field_types(variant).get(field.local_id)?.clone().substitute(&Interner, subst);\n+            db.field_types(variant).get(field.local_id)?.clone().substitute(Interner, subst);\n         Some((field.into(), local, Type::new_with_resolver(db, &self.resolver, field_ty)?))\n     }\n \n@@ -417,7 +417,7 @@ impl SourceAnalyzer {\n             .into_iter()\n             .map(|local_id| {\n                 let field = FieldId { parent: variant, local_id };\n-                let ty = field_types[local_id].clone().substitute(&Interner, substs);\n+                let ty = field_types[local_id].clone().substitute(Interner, substs);\n                 (field.into(), Type::new_with_resolver_inner(db, krate, &self.resolver, ty))\n             })\n             .collect()"}, {"sha": "a1a7063d48e0e419a709fd5999e4408e1a7eeac5", "filename": "crates/hir_ty/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2FCargo.toml?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -18,9 +18,9 @@ ena = \"0.14.0\"\n tracing = \"0.1\"\n rustc-hash = \"1.1.0\"\n scoped-tls = \"1\"\n-chalk-solve = { version = \"0.74\", default-features = false }\n-chalk-ir = \"0.74\"\n-chalk-recursive = { version = \"0.74\", default-features = false }\n+chalk-solve = { version = \"0.75\", default-features = false }\n+chalk-ir = \"0.75\"\n+chalk-recursive = { version = \"0.75\", default-features = false }\n la-arena = { version = \"0.3.0\", path = \"../../lib/arena\" }\n once_cell = { version = \"1.5.0\" }\n "}, {"sha": "6266554ecf671d31da58ed505a57508ce5af8f73", "filename": "crates/hir_ty/src/autoderef.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -122,7 +122,7 @@ pub(crate) fn deref(\n }\n \n fn builtin_deref(ty: &Ty) -> Option<&Ty> {\n-    match ty.kind(&Interner) {\n+    match ty.kind(Interner) {\n         TyKind::Ref(.., ty) => Some(ty),\n         TyKind::Raw(.., ty) => Some(ty),\n         _ => None,\n@@ -158,7 +158,7 @@ fn deref_by_trait(\n     let implements_goal = Canonical {\n         binders: ty.goal.binders.clone(),\n         value: InEnvironment {\n-            goal: trait_ref.cast(&Interner),\n+            goal: trait_ref.cast(Interner),\n             environment: ty.environment.clone(),\n         },\n     };\n@@ -171,18 +171,18 @@ fn deref_by_trait(\n         alias: AliasTy::Projection(projection),\n         ty: TyKind::BoundVar(BoundVar::new(\n             DebruijnIndex::INNERMOST,\n-            ty.goal.binders.len(&Interner),\n+            ty.goal.binders.len(Interner),\n         ))\n-        .intern(&Interner),\n+        .intern(Interner),\n     };\n \n-    let in_env = InEnvironment { goal: alias_eq.cast(&Interner), environment: ty.environment };\n+    let in_env = InEnvironment { goal: alias_eq.cast(Interner), environment: ty.environment };\n \n     let canonical = Canonical {\n         value: in_env,\n         binders: CanonicalVarKinds::from_iter(\n-            &Interner,\n-            ty.goal.binders.iter(&Interner).cloned().chain(Some(chalk_ir::WithKind::new(\n+            Interner,\n+            ty.goal.binders.iter(Interner).cloned().chain(Some(chalk_ir::WithKind::new(\n                 VariableKind::Ty(chalk_ir::TyVariableKind::General),\n                 chalk_ir::UniverseIndex::ROOT,\n             ))),\n@@ -209,8 +209,8 @@ fn deref_by_trait(\n             // assumptions will be broken. We would need to properly introduce\n             // new variables in that case\n \n-            for i in 1..binders.len(&Interner) {\n-                if subst.at(&Interner, i - 1).assert_ty_ref(&Interner).kind(&Interner)\n+            for i in 1..binders.len(Interner) {\n+                if subst.at(Interner, i - 1).assert_ty_ref(Interner).kind(Interner)\n                     != &TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, i - 1))\n                 {\n                     warn!(\"complex solution for derefing {:?}: {:?}, ignoring\", ty.goal, solution);\n@@ -220,10 +220,7 @@ fn deref_by_trait(\n             // FIXME: we remove lifetime variables here since they can confuse\n             // the method resolution code later\n             Some(fixup_lifetime_variables(Canonical {\n-                value: subst\n-                    .at(&Interner, subst.len(&Interner) - 1)\n-                    .assert_ty_ref(&Interner)\n-                    .clone(),\n+                value: subst.at(Interner, subst.len(Interner) - 1).assert_ty_ref(Interner).clone(),\n                 binders: binders.clone(),\n             }))\n         }\n@@ -240,25 +237,25 @@ fn fixup_lifetime_variables<T: Fold<Interner, Result = T> + HasInterner<Interner\n     // Removes lifetime variables from the Canonical, replacing them by static lifetimes.\n     let mut i = 0;\n     let subst = Substitution::from_iter(\n-        &Interner,\n-        c.binders.iter(&Interner).map(|vk| match vk.kind {\n+        Interner,\n+        c.binders.iter(Interner).map(|vk| match vk.kind {\n             VariableKind::Ty(_) => {\n                 let index = i;\n                 i += 1;\n-                BoundVar::new(DebruijnIndex::INNERMOST, index).to_ty(&Interner).cast(&Interner)\n+                BoundVar::new(DebruijnIndex::INNERMOST, index).to_ty(Interner).cast(Interner)\n             }\n-            VariableKind::Lifetime => static_lifetime().cast(&Interner),\n+            VariableKind::Lifetime => static_lifetime().cast(Interner),\n             VariableKind::Const(_) => unimplemented!(),\n         }),\n     );\n     let binders = CanonicalVarKinds::from_iter(\n-        &Interner,\n-        c.binders.iter(&Interner).filter(|vk| match vk.kind {\n+        Interner,\n+        c.binders.iter(Interner).filter(|vk| match vk.kind {\n             VariableKind::Ty(_) => true,\n             VariableKind::Lifetime => false,\n             VariableKind::Const(_) => true,\n         }),\n     );\n-    let value = subst.apply(c.value, &Interner);\n+    let value = subst.apply(c.value, Interner);\n     Canonical { binders, value }\n }"}, {"sha": "76e5efc0526b58cf69300d2d98be48129e7e9ccf", "filename": "crates/hir_ty/src/builder.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -33,12 +33,12 @@ impl<D> TyBuilder<D> {\n \n     fn build_internal(self) -> (D, Substitution) {\n         assert_eq!(self.vec.len(), self.param_count);\n-        let subst = Substitution::from_iter(&Interner, self.vec);\n+        let subst = Substitution::from_iter(Interner, self.vec);\n         (self.data, subst)\n     }\n \n     pub fn push(mut self, arg: impl CastTo<GenericArg>) -> Self {\n-        self.vec.push(arg.cast(&Interner));\n+        self.vec.push(arg.cast(Interner));\n         self\n     }\n \n@@ -49,56 +49,56 @@ impl<D> TyBuilder<D> {\n     pub fn fill_with_bound_vars(self, debruijn: DebruijnIndex, starting_from: usize) -> Self {\n         self.fill(\n             (starting_from..)\n-                .map(|idx| TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(&Interner)),\n+                .map(|idx| TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(Interner)),\n         )\n     }\n \n     pub fn fill_with_unknown(self) -> Self {\n-        self.fill(iter::repeat(TyKind::Error.intern(&Interner)))\n+        self.fill(iter::repeat(TyKind::Error.intern(Interner)))\n     }\n \n     pub fn fill(mut self, filler: impl Iterator<Item = impl CastTo<GenericArg>>) -> Self {\n-        self.vec.extend(filler.take(self.remaining()).casted(&Interner));\n+        self.vec.extend(filler.take(self.remaining()).casted(Interner));\n         assert_eq!(self.remaining(), 0);\n         self\n     }\n \n     pub fn use_parent_substs(mut self, parent_substs: &Substitution) -> Self {\n         assert!(self.vec.is_empty());\n-        assert!(parent_substs.len(&Interner) <= self.param_count);\n-        self.vec.extend(parent_substs.iter(&Interner).cloned());\n+        assert!(parent_substs.len(Interner) <= self.param_count);\n+        self.vec.extend(parent_substs.iter(Interner).cloned());\n         self\n     }\n }\n \n impl TyBuilder<()> {\n     pub fn unit() -> Ty {\n-        TyKind::Tuple(0, Substitution::empty(&Interner)).intern(&Interner)\n+        TyKind::Tuple(0, Substitution::empty(Interner)).intern(Interner)\n     }\n \n     pub fn fn_ptr(sig: CallableSig) -> Ty {\n-        TyKind::Function(sig.to_fn_ptr()).intern(&Interner)\n+        TyKind::Function(sig.to_fn_ptr()).intern(Interner)\n     }\n \n     pub fn builtin(builtin: BuiltinType) -> Ty {\n         match builtin {\n-            BuiltinType::Char => TyKind::Scalar(Scalar::Char).intern(&Interner),\n-            BuiltinType::Bool => TyKind::Scalar(Scalar::Bool).intern(&Interner),\n-            BuiltinType::Str => TyKind::Str.intern(&Interner),\n+            BuiltinType::Char => TyKind::Scalar(Scalar::Char).intern(Interner),\n+            BuiltinType::Bool => TyKind::Scalar(Scalar::Bool).intern(Interner),\n+            BuiltinType::Str => TyKind::Str.intern(Interner),\n             BuiltinType::Int(t) => {\n-                TyKind::Scalar(Scalar::Int(primitive::int_ty_from_builtin(t))).intern(&Interner)\n+                TyKind::Scalar(Scalar::Int(primitive::int_ty_from_builtin(t))).intern(Interner)\n             }\n             BuiltinType::Uint(t) => {\n-                TyKind::Scalar(Scalar::Uint(primitive::uint_ty_from_builtin(t))).intern(&Interner)\n+                TyKind::Scalar(Scalar::Uint(primitive::uint_ty_from_builtin(t))).intern(Interner)\n             }\n             BuiltinType::Float(t) => {\n-                TyKind::Scalar(Scalar::Float(primitive::float_ty_from_builtin(t))).intern(&Interner)\n+                TyKind::Scalar(Scalar::Float(primitive::float_ty_from_builtin(t))).intern(Interner)\n             }\n         }\n     }\n \n     pub fn slice(argument: Ty) -> Ty {\n-        TyKind::Slice(argument).intern(&Interner)\n+        TyKind::Slice(argument).intern(Interner)\n     }\n \n     pub fn type_params_subst(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> Substitution {\n@@ -134,20 +134,20 @@ impl TyBuilder<hir_def::AdtId> {\n         let defaults = db.generic_defaults(self.data.into());\n         for default_ty in defaults.iter().skip(self.vec.len()) {\n             if default_ty.skip_binders().is_unknown() {\n-                self.vec.push(fallback().cast(&Interner));\n+                self.vec.push(fallback().cast(Interner));\n             } else {\n                 // each default can depend on the previous parameters\n-                let subst_so_far = Substitution::from_iter(&Interner, self.vec.clone());\n+                let subst_so_far = Substitution::from_iter(Interner, self.vec.clone());\n                 self.vec\n-                    .push(default_ty.clone().substitute(&Interner, &subst_so_far).cast(&Interner));\n+                    .push(default_ty.clone().substitute(Interner, &subst_so_far).cast(Interner));\n             }\n         }\n         self\n     }\n \n     pub fn build(self) -> Ty {\n         let (adt, subst) = self.build_internal();\n-        TyKind::Adt(AdtId(adt), subst).intern(&Interner)\n+        TyKind::Adt(AdtId(adt), subst).intern(Interner)\n     }\n }\n \n@@ -159,7 +159,7 @@ impl TyBuilder<Tuple> {\n \n     pub fn build(self) -> Ty {\n         let (Tuple(size), subst) = self.build_internal();\n-        TyKind::Tuple(size, subst).intern(&Interner)\n+        TyKind::Tuple(size, subst).intern(Interner)\n     }\n }\n \n@@ -194,13 +194,13 @@ impl TyBuilder<TypeAliasId> {\n \n impl<T: HasInterner<Interner = Interner> + Fold<Interner>> TyBuilder<Binders<T>> {\n     fn subst_binders(b: Binders<T>) -> Self {\n-        let param_count = b.binders.len(&Interner);\n+        let param_count = b.binders.len(Interner);\n         TyBuilder::new(b, param_count)\n     }\n \n     pub fn build(self) -> <T as Fold<Interner>>::Result {\n         let (b, subst) = self.build_internal();\n-        b.substitute(&Interner, &subst)\n+        b.substitute(Interner, &subst)\n     }\n }\n "}, {"sha": "0a46aea950a283ade3a52f849b4f8c4b4cd014c9", "filename": "crates/hir_ty/src/chalk_db.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -61,7 +61,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     }\n     fn discriminant_type(&self, _ty: chalk_ir::Ty<Interner>) -> chalk_ir::Ty<Interner> {\n         // FIXME: keep track of this\n-        chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Uint(chalk_ir::UintTy::U32)).intern(&Interner)\n+        chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Uint(chalk_ir::UintTy::U32)).intern(Interner)\n     }\n     fn impl_datum(&self, impl_id: ImplId) -> Arc<ImplDatum> {\n         self.db.impl_datum(self.krate, impl_id)\n@@ -83,14 +83,14 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         debug!(\"impls_for_trait {:?}\", trait_id);\n         let trait_: hir_def::TraitId = from_chalk_trait_id(trait_id);\n \n-        let ty: Ty = parameters[0].assert_ty_ref(&Interner).clone();\n+        let ty: Ty = parameters[0].assert_ty_ref(Interner).clone();\n \n         fn binder_kind(\n             ty: &Ty,\n             binders: &CanonicalVarKinds<Interner>,\n         ) -> Option<chalk_ir::TyVariableKind> {\n-            if let TyKind::BoundVar(bv) = ty.kind(&Interner) {\n-                let binders = binders.as_slice(&Interner);\n+            if let TyKind::BoundVar(bv) = ty.kind(Interner) {\n+                let binders = binders.as_slice(Interner);\n                 if bv.debruijn == DebruijnIndex::INNERMOST {\n                     if let chalk_ir::VariableKind::Ty(tk) = binders[bv.index].kind {\n                         return Some(tk);\n@@ -173,8 +173,8 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         // We don't do coherence checking (yet)\n         unimplemented!()\n     }\n-    fn interner(&self) -> &Interner {\n-        &Interner\n+    fn interner(&self) -> Interner {\n+        Interner\n     }\n     fn well_known_trait_id(\n         &self,\n@@ -232,27 +232,27 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                         trait_id: to_chalk_trait_id(future_trait),\n                         // Self type as the first parameter.\n                         substitution: Substitution::from1(\n-                            &Interner,\n+                            Interner,\n                             TyKind::BoundVar(BoundVar {\n                                 debruijn: DebruijnIndex::INNERMOST,\n                                 index: 0,\n                             })\n-                            .intern(&Interner),\n+                            .intern(Interner),\n                         ),\n                     });\n                     let proj_bound = WhereClause::AliasEq(AliasEq {\n                         alias: AliasTy::Projection(ProjectionTy {\n                             associated_ty_id: to_assoc_type_id(future_output),\n                             // Self type as the first parameter.\n                             substitution: Substitution::from1(\n-                                &Interner,\n+                                Interner,\n                                 TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0))\n-                                    .intern(&Interner),\n+                                    .intern(Interner),\n                             ),\n                         }),\n                         // The parameter of the opaque type.\n                         ty: TyKind::BoundVar(BoundVar { debruijn: DebruijnIndex::ONE, index: 0 })\n-                            .intern(&Interner),\n+                            .intern(Interner),\n                     });\n                     let bound = OpaqueTyDatumBound {\n                         bounds: make_only_type_binders(\n@@ -283,7 +283,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n \n     fn hidden_opaque_type(&self, _id: chalk_ir::OpaqueTyId<Interner>) -> chalk_ir::Ty<Interner> {\n         // FIXME: actually provide the hidden type; it is relevant for auto traits\n-        TyKind::Error.intern(&Interner)\n+        TyKind::Error.intern(Interner)\n     }\n \n     fn is_object_safe(&self, _trait_id: chalk_ir::TraitId<Interner>) -> bool {\n@@ -304,13 +304,13 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         _closure_id: chalk_ir::ClosureId<Interner>,\n         substs: &chalk_ir::Substitution<Interner>,\n     ) -> chalk_ir::Binders<rust_ir::FnDefInputsAndOutputDatum<Interner>> {\n-        let sig_ty = substs.at(&Interner, 0).assert_ty_ref(&Interner).clone();\n+        let sig_ty = substs.at(Interner, 0).assert_ty_ref(Interner).clone();\n         let sig = &sig_ty.callable_sig(self.db).expect(\"first closure param should be fn ptr\");\n         let io = rust_ir::FnDefInputsAndOutputDatum {\n             argument_types: sig.params().to_vec(),\n             return_type: sig.ret().clone(),\n         };\n-        make_only_type_binders(0, io.shifted_in(&Interner))\n+        make_only_type_binders(0, io.shifted_in(Interner))\n     }\n     fn closure_upvars(\n         &self,\n@@ -325,7 +325,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         _closure_id: chalk_ir::ClosureId<Interner>,\n         _substs: &chalk_ir::Substitution<Interner>,\n     ) -> chalk_ir::Substitution<Interner> {\n-        Substitution::empty(&Interner)\n+        Substitution::empty(Interner)\n     }\n \n     fn trait_name(&self, trait_id: chalk_ir::TraitId<Interner>) -> String {\n@@ -409,7 +409,7 @@ pub(crate) fn associated_ty_data_query(\n     let ctx = crate::TyLoweringContext::new(db, &resolver)\n         .with_type_param_mode(crate::lower::TypeParamLoweringMode::Variable);\n     let self_ty =\n-        TyKind::BoundVar(BoundVar::new(crate::DebruijnIndex::INNERMOST, 0)).intern(&Interner);\n+        TyKind::BoundVar(BoundVar::new(crate::DebruijnIndex::INNERMOST, 0)).intern(Interner);\n     let mut bounds: Vec<_> = type_alias_data\n         .bounds\n         .iter()\n@@ -426,7 +426,7 @@ pub(crate) fn associated_ty_data_query(\n             let trait_bound =\n                 rust_ir::TraitBound { trait_id: sized_trait, args_no_self: Default::default() };\n             let inline_bound = rust_ir::InlineBound::TraitBound(trait_bound);\n-            chalk_ir::Binders::empty(&Interner, inline_bound)\n+            chalk_ir::Binders::empty(Interner, inline_bound)\n         });\n         bounds.extend(sized_bound);\n         bounds.shrink_to_fit();\n@@ -472,7 +472,7 @@ pub(crate) fn trait_datum_query(\n         lang_attr(db.upcast(), trait_).and_then(|name| well_known_trait_from_lang_attr(&name));\n     let trait_datum = TraitDatum {\n         id: trait_id,\n-        binders: make_only_type_binders(bound_vars.len(&Interner), trait_datum_bound),\n+        binders: make_only_type_binders(bound_vars.len(Interner), trait_datum_bound),\n         flags,\n         associated_ty_ids,\n         well_known,\n@@ -611,7 +611,7 @@ fn impl_def_datum(\n         .collect();\n     debug!(\"impl_datum: {:?}\", impl_datum_bound);\n     let impl_datum = ImplDatum {\n-        binders: make_only_type_binders(bound_vars.len(&Interner), impl_datum_bound),\n+        binders: make_only_type_binders(bound_vars.len(Interner), impl_datum_bound),\n         impl_type,\n         polarity,\n         associated_ty_value_ids,\n@@ -677,7 +677,7 @@ pub(crate) fn fn_def_datum_query(\n                 argument_types: sig.params().to_vec(),\n                 return_type: sig.ret().clone(),\n             }\n-            .shifted_in(&Interner),\n+            .shifted_in(Interner),\n         ),\n         where_clauses,\n     };\n@@ -693,7 +693,7 @@ pub(crate) fn fn_def_variance_query(db: &dyn HirDatabase, fn_def_id: FnDefId) ->\n     let callable_def: CallableDefId = from_chalk(db, fn_def_id);\n     let generic_params = generics(db.upcast(), callable_def.into());\n     Variances::from_iter(\n-        &Interner,\n+        Interner,\n         std::iter::repeat(chalk_ir::Variance::Invariant).take(generic_params.len()),\n     )\n }\n@@ -704,7 +704,7 @@ pub(crate) fn adt_variance_query(\n ) -> Variances {\n     let generic_params = generics(db.upcast(), adt_id.into());\n     Variances::from_iter(\n-        &Interner,\n+        Interner,\n         std::iter::repeat(chalk_ir::Variance::Invariant).take(generic_params.len()),\n     )\n }\n@@ -717,7 +717,7 @@ pub(super) fn convert_where_clauses(\n     let generic_predicates = db.generic_predicates(def);\n     let mut result = Vec::with_capacity(generic_predicates.len());\n     for pred in generic_predicates.iter() {\n-        result.push(pred.clone().substitute(&Interner, substs));\n+        result.push(pred.clone().substitute(Interner, substs));\n     }\n     result\n }\n@@ -729,30 +729,30 @@ pub(super) fn generic_predicate_to_inline_bound(\n ) -> Option<chalk_ir::Binders<rust_ir::InlineBound<Interner>>> {\n     // An InlineBound is like a GenericPredicate, except the self type is left out.\n     // We don't have a special type for this, but Chalk does.\n-    let self_ty_shifted_in = self_ty.clone().shifted_in_from(&Interner, DebruijnIndex::ONE);\n+    let self_ty_shifted_in = self_ty.clone().shifted_in_from(Interner, DebruijnIndex::ONE);\n     let (pred, binders) = pred.as_ref().into_value_and_skipped_binders();\n     match pred {\n         WhereClause::Implemented(trait_ref) => {\n-            if trait_ref.self_type_parameter(&Interner) != self_ty_shifted_in {\n+            if trait_ref.self_type_parameter(Interner) != self_ty_shifted_in {\n                 // we can only convert predicates back to type bounds if they\n                 // have the expected self type\n                 return None;\n             }\n-            let args_no_self = trait_ref.substitution.as_slice(&Interner)[1..]\n+            let args_no_self = trait_ref.substitution.as_slice(Interner)[1..]\n                 .iter()\n-                .map(|ty| ty.clone().cast(&Interner))\n+                .map(|ty| ty.clone().cast(Interner))\n                 .collect();\n             let trait_bound = rust_ir::TraitBound { trait_id: trait_ref.trait_id, args_no_self };\n             Some(chalk_ir::Binders::new(binders, rust_ir::InlineBound::TraitBound(trait_bound)))\n         }\n         WhereClause::AliasEq(AliasEq { alias: AliasTy::Projection(projection_ty), ty }) => {\n-            if projection_ty.self_type_parameter(&Interner) != self_ty_shifted_in {\n+            if projection_ty.self_type_parameter(Interner) != self_ty_shifted_in {\n                 return None;\n             }\n             let trait_ = projection_ty.trait_(db);\n-            let args_no_self = projection_ty.substitution.as_slice(&Interner)[1..]\n+            let args_no_self = projection_ty.substitution.as_slice(Interner)[1..]\n                 .iter()\n-                .map(|ty| ty.clone().cast(&Interner))\n+                .map(|ty| ty.clone().cast(Interner))\n                 .collect();\n             let alias_eq_bound = rust_ir::AliasEqBound {\n                 value: ty.clone(),"}, {"sha": "bd5aab1b3d59d8791d98eee5893319522261e9cf", "filename": "crates/hir_ty/src/chalk_ext.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -46,30 +46,30 @@ pub trait TyExt {\n \n impl TyExt for Ty {\n     fn is_unit(&self) -> bool {\n-        matches!(self.kind(&Interner), TyKind::Tuple(0, _))\n+        matches!(self.kind(Interner), TyKind::Tuple(0, _))\n     }\n \n     fn is_never(&self) -> bool {\n-        matches!(self.kind(&Interner), TyKind::Never)\n+        matches!(self.kind(Interner), TyKind::Never)\n     }\n \n     fn is_unknown(&self) -> bool {\n-        matches!(self.kind(&Interner), TyKind::Error)\n+        matches!(self.kind(Interner), TyKind::Error)\n     }\n \n     fn is_ty_var(&self) -> bool {\n-        matches!(self.kind(&Interner), TyKind::InferenceVar(_, _))\n+        matches!(self.kind(Interner), TyKind::InferenceVar(_, _))\n     }\n \n     fn as_adt(&self) -> Option<(hir_def::AdtId, &Substitution)> {\n-        match self.kind(&Interner) {\n+        match self.kind(Interner) {\n             TyKind::Adt(AdtId(adt), parameters) => Some((*adt, parameters)),\n             _ => None,\n         }\n     }\n \n     fn as_builtin(&self) -> Option<BuiltinType> {\n-        match self.kind(&Interner) {\n+        match self.kind(Interner) {\n             TyKind::Str => Some(BuiltinType::Str),\n             TyKind::Scalar(Scalar::Bool) => Some(BuiltinType::Bool),\n             TyKind::Scalar(Scalar::Char) => Some(BuiltinType::Char),\n@@ -98,7 +98,7 @@ impl TyExt for Ty {\n     }\n \n     fn as_tuple(&self) -> Option<&Substitution> {\n-        match self.kind(&Interner) {\n+        match self.kind(Interner) {\n             TyKind::Tuple(_, substs) => Some(substs),\n             _ => None,\n         }\n@@ -111,22 +111,22 @@ impl TyExt for Ty {\n         }\n     }\n     fn as_reference(&self) -> Option<(&Ty, Lifetime, Mutability)> {\n-        match self.kind(&Interner) {\n+        match self.kind(Interner) {\n             TyKind::Ref(mutability, lifetime, ty) => Some((ty, lifetime.clone(), *mutability)),\n             _ => None,\n         }\n     }\n \n     fn as_reference_or_ptr(&self) -> Option<(&Ty, Rawness, Mutability)> {\n-        match self.kind(&Interner) {\n+        match self.kind(Interner) {\n             TyKind::Ref(mutability, _, ty) => Some((ty, Rawness::Ref, *mutability)),\n             TyKind::Raw(mutability, ty) => Some((ty, Rawness::RawPtr, *mutability)),\n             _ => None,\n         }\n     }\n \n     fn as_generic_def(&self, db: &dyn HirDatabase) -> Option<GenericDefId> {\n-        match *self.kind(&Interner) {\n+        match *self.kind(Interner) {\n             TyKind::Adt(AdtId(adt), ..) => Some(adt.into()),\n             TyKind::FnDef(callable, ..) => {\n                 Some(db.lookup_intern_callable_def(callable.into()).into())\n@@ -138,30 +138,30 @@ impl TyExt for Ty {\n     }\n \n     fn callable_def(&self, db: &dyn HirDatabase) -> Option<CallableDefId> {\n-        match self.kind(&Interner) {\n+        match self.kind(Interner) {\n             &TyKind::FnDef(def, ..) => Some(db.lookup_intern_callable_def(def.into())),\n             _ => None,\n         }\n     }\n \n     fn callable_sig(&self, db: &dyn HirDatabase) -> Option<CallableSig> {\n-        match self.kind(&Interner) {\n+        match self.kind(Interner) {\n             TyKind::Function(fn_ptr) => Some(CallableSig::from_fn_ptr(fn_ptr)),\n             TyKind::FnDef(def, parameters) => {\n                 let callable_def = db.lookup_intern_callable_def((*def).into());\n                 let sig = db.callable_item_signature(callable_def);\n-                Some(sig.substitute(&Interner, &parameters))\n+                Some(sig.substitute(Interner, &parameters))\n             }\n             TyKind::Closure(.., substs) => {\n-                let sig_param = substs.at(&Interner, 0).assert_ty_ref(&Interner);\n+                let sig_param = substs.at(Interner, 0).assert_ty_ref(Interner);\n                 sig_param.callable_sig(db)\n             }\n             _ => None,\n         }\n     }\n \n     fn dyn_trait(&self) -> Option<TraitId> {\n-        let trait_ref = match self.kind(&Interner) {\n+        let trait_ref = match self.kind(Interner) {\n             TyKind::Dyn(dyn_ty) => dyn_ty.bounds.skip_binders().interned().get(0).and_then(|b| {\n                 match b.skip_binders() {\n                     WhereClause::Implemented(trait_ref) => Some(trait_ref),\n@@ -175,14 +175,14 @@ impl TyExt for Ty {\n \n     fn strip_references(&self) -> &Ty {\n         let mut t: &Ty = self;\n-        while let TyKind::Ref(_mutability, _lifetime, ty) = t.kind(&Interner) {\n+        while let TyKind::Ref(_mutability, _lifetime, ty) = t.kind(Interner) {\n             t = ty;\n         }\n         t\n     }\n \n     fn impl_trait_bounds(&self, db: &dyn HirDatabase) -> Option<Vec<QuantifiedWhereClause>> {\n-        match self.kind(&Interner) {\n+        match self.kind(Interner) {\n             TyKind::OpaqueType(opaque_ty_id, subst) => {\n                 match db.lookup_intern_impl_trait_id((*opaque_ty_id).into()) {\n                     ImplTraitId::AsyncBlockTypeImplTrait(def, _expr) => {\n@@ -195,10 +195,10 @@ impl TyExt for Ty {\n                             // Parameters will be walked outside, and projection predicate is not used.\n                             // So just provide the Future trait.\n                             let impl_bound = Binders::empty(\n-                                &Interner,\n+                                Interner,\n                                 WhereClause::Implemented(TraitRef {\n                                     trait_id: to_chalk_trait_id(future_trait),\n-                                    substitution: Substitution::empty(&Interner),\n+                                    substitution: Substitution::empty(Interner),\n                                 }),\n                             );\n                             Some(vec![impl_bound])\n@@ -211,7 +211,7 @@ impl TyExt for Ty {\n                             let data = (*it)\n                                 .as_ref()\n                                 .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                            data.substitute(&Interner, &subst).into_value_and_skipped_binders().0\n+                            data.substitute(Interner, &subst).into_value_and_skipped_binders().0\n                         })\n                     }\n                 }\n@@ -224,7 +224,7 @@ impl TyExt for Ty {\n                             let data = (*it)\n                                 .as_ref()\n                                 .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                            data.substitute(&Interner, &opaque_ty.substitution)\n+                            data.substitute(Interner, &opaque_ty.substitution)\n                         })\n                     }\n                     // It always has an parameter for Future::Output type.\n@@ -243,15 +243,15 @@ impl TyExt for Ty {\n                         let predicates = db\n                             .generic_predicates(id.parent)\n                             .iter()\n-                            .map(|pred| pred.clone().substitute(&Interner, &substs))\n+                            .map(|pred| pred.clone().substitute(Interner, &substs))\n                             .filter(|wc| match &wc.skip_binders() {\n                                 WhereClause::Implemented(tr) => {\n-                                    &tr.self_type_parameter(&Interner) == self\n+                                    &tr.self_type_parameter(Interner) == self\n                                 }\n                                 WhereClause::AliasEq(AliasEq {\n                                     alias: AliasTy::Projection(proj),\n                                     ty: _,\n-                                }) => &proj.self_type_parameter(&Interner) == self,\n+                                }) => &proj.self_type_parameter(Interner) == self,\n                                 _ => false,\n                             })\n                             .collect::<Vec<_>>();\n@@ -266,7 +266,7 @@ impl TyExt for Ty {\n     }\n \n     fn associated_type_parent_trait(&self, db: &dyn HirDatabase) -> Option<TraitId> {\n-        match self.kind(&Interner) {\n+        match self.kind(Interner) {\n             TyKind::AssociatedType(id, ..) => {\n                 match from_assoc_type_id(*id).lookup(db.upcast()).container {\n                     ItemContainerId::TraitId(trait_id) => Some(trait_id),\n@@ -287,7 +287,7 @@ impl TyExt for Ty {\n     }\n \n     fn equals_ctor(&self, other: &Ty) -> bool {\n-        match (self.kind(&Interner), other.kind(&Interner)) {\n+        match (self.kind(Interner), other.kind(Interner)) {\n             (TyKind::Adt(adt, ..), TyKind::Adt(adt2, ..)) => adt == adt2,\n             (TyKind::Slice(_), TyKind::Slice(_)) | (TyKind::Array(_, _), TyKind::Array(_, _)) => {\n                 true"}, {"sha": "a406ca22ca70be0753771d16d8b8ac79ff948836", "filename": "crates/hir_ty/src/consteval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fconsteval.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -18,7 +18,7 @@ pub trait ConstExt {\n \n impl ConstExt for Const {\n     fn is_unknown(&self) -> bool {\n-        match self.data(&Interner).value {\n+        match self.data(Interner).value {\n             // interned Unknown\n             chalk_ir::ConstValue::Concrete(chalk_ir::ConcreteConst {\n                 interned: ConstScalar::Unknown,\n@@ -49,10 +49,10 @@ pub fn eval_usize(expr: &Expr) -> Option<u64> {\n /// Interns a possibly-unknown target usize\n pub fn usize_const(value: Option<u64>) -> Const {\n     ConstData {\n-        ty: TyKind::Scalar(chalk_ir::Scalar::Uint(chalk_ir::UintTy::Usize)).intern(&Interner),\n+        ty: TyKind::Scalar(chalk_ir::Scalar::Uint(chalk_ir::UintTy::Usize)).intern(Interner),\n         value: ConstValue::Concrete(chalk_ir::ConcreteConst {\n             interned: value.map(ConstScalar::Usize).unwrap_or(ConstScalar::Unknown),\n         }),\n     }\n-    .intern(&Interner)\n+    .intern(Interner)\n }"}, {"sha": "d3a0100123764ba2320ba19f835b082a63c675c7", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -224,7 +224,7 @@ impl ExprValidator {\n                     Some(it) => it,\n                     None => return,\n                 };\n-                let sig = db.callable_item_signature(callee.into()).substitute(&Interner, &subst);\n+                let sig = db.callable_item_signature(callee.into()).substitute(Interner, &subst);\n \n                 (sig, args.len() + 1)\n             }\n@@ -389,7 +389,7 @@ impl ExprValidator {\n             _ => return,\n         };\n \n-        let (params, required) = match mismatch.expected.kind(&Interner) {\n+        let (params, required) = match mismatch.expected.kind(Interner) {\n             TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), parameters)\n                 if *enum_id == core_result_enum =>\n             {\n@@ -403,8 +403,7 @@ impl ExprValidator {\n             _ => return,\n         };\n \n-        if params.len(&Interner) > 0\n-            && params.at(&Interner, 0).ty(&Interner) == Some(&mismatch.actual)\n+        if params.len(Interner) > 0 && params.at(Interner, 0).ty(Interner) == Some(&mismatch.actual)\n         {\n             self.diagnostics\n                 .push(BodyValidationDiagnostic::MissingOkOrSomeInTailExpr { expr: id, required });\n@@ -520,8 +519,8 @@ fn check_missing_refs(\n         (None, Some((referenced_ty, _, mutability))) if referenced_ty == arg_ty => {\n             Some((arg, Mutability::from_mutable(matches!(mutability, chalk_ir::Mutability::Mut))))\n         }\n-        (None, Some((referenced_ty, _, mutability))) => match referenced_ty.kind(&Interner) {\n-            TyKind::Slice(subst) if matches!(arg_ty.kind(&Interner), TyKind::Array(arr_subst, _) if arr_subst == subst) => {\n+        (None, Some((referenced_ty, _, mutability))) => match referenced_ty.kind(Interner) {\n+            TyKind::Slice(subst) if matches!(arg_ty.kind(Interner), TyKind::Array(arr_subst, _) if arr_subst == subst) => {\n                 Some((\n                     arg,\n                     Mutability::from_mutable(matches!(mutability, chalk_ir::Mutability::Mut)),"}, {"sha": "b3cc83b34040d5f48c3dc8f7190d0c359e1eccb6", "filename": "crates/hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -130,7 +130,7 @@ impl<'a> PatCtxt<'a> {\n             }\n \n             hir_def::expr::Pat::Tuple { ref args, ellipsis } => {\n-                let arity = match *ty.kind(&Interner) {\n+                let arity = match *ty.kind(Interner) {\n                     TyKind::Tuple(arity, _) => arity,\n                     _ => panic!(\"unexpected type for tuple pattern: {:?}\", ty),\n                 };\n@@ -139,7 +139,7 @@ impl<'a> PatCtxt<'a> {\n             }\n \n             hir_def::expr::Pat::Bind { subpat, .. } => {\n-                if let TyKind::Ref(.., rty) = ty.kind(&Interner) {\n+                if let TyKind::Ref(.., rty) = ty.kind(Interner) {\n                     ty = rty;\n                 }\n                 PatKind::Binding { subpattern: self.lower_opt_pattern(subpat) }\n@@ -224,7 +224,7 @@ impl<'a> PatCtxt<'a> {\n         let kind = match self.infer.variant_resolution_for_pat(pat) {\n             Some(variant_id) => {\n                 if let VariantId::EnumVariantId(enum_variant) = variant_id {\n-                    let substs = match ty.kind(&Interner) {\n+                    let substs = match ty.kind(Interner) {\n                         TyKind::Adt(_, substs) | TyKind::FnDef(_, substs) => substs.clone(),\n                         TyKind::Error => {\n                             return PatKind::Wild;"}, {"sha": "eb7d5e5e482e4eea225b10297140e92a3ab3cdcc", "filename": "crates/hir_ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -85,7 +85,7 @@ impl IntRange {\n     #[inline]\n     fn is_integral(ty: &Ty) -> bool {\n         matches!(\n-            ty.kind(&Interner),\n+            ty.kind(Interner),\n             TyKind::Scalar(Scalar::Char | Scalar::Int(_) | Scalar::Uint(_) | Scalar::Bool)\n         )\n     }\n@@ -479,7 +479,7 @@ impl SplitWildcard {\n         // returned list of constructors.\n         // Invariant: this is empty if and only if the type is uninhabited (as determined by\n         // `cx.is_uninhabited()`).\n-        let all_ctors = match pcx.ty.kind(&Interner) {\n+        let all_ctors = match pcx.ty.kind(Interner) {\n             TyKind::Scalar(Scalar::Bool) => smallvec![make_range(0, 1, Scalar::Bool)],\n             // TyKind::Array(..) if ... => unhandled(),\n             TyKind::Array(..) | TyKind::Slice(..) => unhandled(),\n@@ -647,16 +647,16 @@ impl Fields {\n         let wildcard_from_ty = |ty: &Ty| cx.alloc_pat(Pat::wildcard_from_ty(ty.clone()));\n \n         let ret = match constructor {\n-            Single | Variant(_) => match ty.kind(&Interner) {\n+            Single | Variant(_) => match ty.kind(Interner) {\n                 TyKind::Tuple(_, substs) => {\n-                    let tys = substs.iter(&Interner).map(|ty| ty.assert_ty_ref(&Interner));\n+                    let tys = substs.iter(Interner).map(|ty| ty.assert_ty_ref(Interner));\n                     Fields::wildcards_from_tys(cx, tys.cloned())\n                 }\n                 TyKind::Ref(.., rty) => Fields::from_single_pattern(wildcard_from_ty(rty)),\n                 &TyKind::Adt(AdtId(adt), ref substs) => {\n                     if adt_is_box(adt, cx) {\n                         // Use T as the sub pattern type of Box<T>.\n-                        let subst_ty = substs.at(&Interner, 0).assert_ty_ref(&Interner);\n+                        let subst_ty = substs.at(Interner, 0).assert_ty_ref(Interner);\n                         Fields::from_single_pattern(wildcard_from_ty(subst_ty))\n                     } else {\n                         let variant_id = constructor.variant_id_for_adt(adt);\n@@ -671,7 +671,7 @@ impl Fields {\n                         let field_tys = || {\n                             field_ty_data\n                                 .iter()\n-                                .map(|(_, binders)| binders.clone().substitute(&Interner, substs))\n+                                .map(|(_, binders)| binders.clone().substitute(Interner, substs))\n                         };\n \n                         // In the following cases, we don't need to filter out any fields. This is\n@@ -725,7 +725,7 @@ impl Fields {\n         const UNHANDLED: PatKind = PatKind::Wild;\n \n         let pat = match ctor {\n-            Single | Variant(_) => match pcx.ty.kind(&Interner) {\n+            Single | Variant(_) => match pcx.ty.kind(Interner) {\n                 TyKind::Adt(..) | TyKind::Tuple(..) => {\n                     // We want the real indices here.\n                     let subpatterns = subpatterns_and_indices"}, {"sha": "43545708e5fe8236a1e2679a33769fe23e18fbaf", "filename": "crates/hir_ty/src/diagnostics/match_check/usefulness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -347,7 +347,7 @@ struct LiteralExpander;\n \n impl PatternFolder for LiteralExpander {\n     fn fold_pattern(&mut self, pat: &Pat) -> Pat {\n-        match (pat.ty.kind(&Interner), pat.kind.as_ref()) {\n+        match (pat.ty.kind(Interner), pat.kind.as_ref()) {\n             (_, PatKind::Binding { subpattern: Some(s), .. }) => s.fold_with(self),\n             _ => pat.super_fold_with(self),\n         }"}, {"sha": "2a18df253e6e7dd2a039034dbf4187f965a9e31c", "filename": "crates/hir_ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -82,7 +82,7 @@ fn walk_unsafe(\n             }\n         }\n         Expr::UnaryOp { expr, op: UnaryOp::Deref } => {\n-            if let TyKind::Raw(..) = &infer[*expr].kind(&Interner) {\n+            if let TyKind::Raw(..) = &infer[*expr].kind(Interner) {\n                 unsafe_exprs.push(UnsafeExpr { expr: current, inside_unsafe_block });\n             }\n         }"}, {"sha": "cd898a45d214f79c93a3cb0fd95924a92e75606c", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 39, "deletions": 41, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -274,11 +274,11 @@ impl HirDisplay for ProjectionTy {\n \n         let trait_ = f.db.trait_data(self.trait_(f.db));\n         write!(f, \"<\")?;\n-        self.self_type_parameter(&Interner).hir_fmt(f)?;\n+        self.self_type_parameter(Interner).hir_fmt(f)?;\n         write!(f, \" as {}\", trait_.name)?;\n-        if self.substitution.len(&Interner) > 1 {\n+        if self.substitution.len(Interner) > 1 {\n             write!(f, \"<\")?;\n-            f.write_joined(&self.substitution.as_slice(&Interner)[1..], \", \")?;\n+            f.write_joined(&self.substitution.as_slice(Interner)[1..], \", \")?;\n             write!(f, \">\")?;\n         }\n         write!(f, \">::{}\", f.db.type_alias_data(from_assoc_type_id(self.associated_ty_id)).name)?;\n@@ -292,7 +292,7 @@ impl HirDisplay for OpaqueTy {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n \n-        self.substitution.at(&Interner, 0).hir_fmt(f)\n+        self.substitution.at(Interner, 0).hir_fmt(f)\n     }\n }\n \n@@ -335,7 +335,7 @@ impl HirDisplay for Ty {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n \n-        match self.kind(&Interner) {\n+        match self.kind(Interner) {\n             TyKind::Never => write!(f, \"!\")?,\n             TyKind::Str => write!(f, \"str\")?,\n             TyKind::Scalar(Scalar::Bool) => write!(f, \"bool\")?,\n@@ -356,7 +356,7 @@ impl HirDisplay for Ty {\n                 write!(f, \"]\")?;\n             }\n             TyKind::Raw(m, t) | TyKind::Ref(m, _, t) => {\n-                if matches!(self.kind(&Interner), TyKind::Raw(..)) {\n+                if matches!(self.kind(Interner), TyKind::Raw(..)) {\n                     write!(\n                         f,\n                         \"*{}\",\n@@ -387,7 +387,7 @@ impl HirDisplay for Ty {\n                         }\n                     })\n                 };\n-                let (preds_to_print, has_impl_fn_pred) = match t.kind(&Interner) {\n+                let (preds_to_print, has_impl_fn_pred) = match t.kind(Interner) {\n                     TyKind::Dyn(dyn_ty) if dyn_ty.bounds.skip_binders().interned().len() > 1 => {\n                         let bounds = dyn_ty.bounds.skip_binders().interned();\n                         (bounds.len(), contains_impl_fn(bounds))\n@@ -406,7 +406,7 @@ impl HirDisplay for Ty {\n                             let data = (*datas)\n                                 .as_ref()\n                                 .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                            let bounds = data.substitute(&Interner, parameters);\n+                            let bounds = data.substitute(Interner, parameters);\n                             let mut len = bounds.skip_binders().len();\n \n                             // Don't count Sized but count when it absent\n@@ -456,13 +456,13 @@ impl HirDisplay for Ty {\n                 }\n             }\n             TyKind::Tuple(_, substs) => {\n-                if substs.len(&Interner) == 1 {\n+                if substs.len(Interner) == 1 {\n                     write!(f, \"(\")?;\n-                    substs.at(&Interner, 0).hir_fmt(f)?;\n+                    substs.at(Interner, 0).hir_fmt(f)?;\n                     write!(f, \",)\")?;\n                 } else {\n                     write!(f, \"(\")?;\n-                    f.write_joined(&*substs.as_slice(&Interner), \", \")?;\n+                    f.write_joined(&*substs.as_slice(Interner), \", \")?;\n                     write!(f, \")\")?;\n                 }\n             }\n@@ -472,7 +472,7 @@ impl HirDisplay for Ty {\n             }\n             TyKind::FnDef(def, parameters) => {\n                 let def = from_chalk(f.db, *def);\n-                let sig = f.db.callable_item_signature(def).substitute(&Interner, parameters);\n+                let sig = f.db.callable_item_signature(def).substitute(Interner, parameters);\n                 match def {\n                     CallableDefId::FunctionId(ff) => {\n                         write!(f, \"fn {}\", f.db.function_data(ff).name)?\n@@ -482,15 +482,15 @@ impl HirDisplay for Ty {\n                         write!(f, \"{}\", f.db.enum_data(e.parent).variants[e.local_id].name)?\n                     }\n                 };\n-                if parameters.len(&Interner) > 0 {\n+                if parameters.len(Interner) > 0 {\n                     let generics = generics(f.db.upcast(), def.into());\n                     let (parent_params, self_param, type_params, _impl_trait_params) =\n                         generics.provenance_split();\n                     let total_len = parent_params + self_param + type_params;\n                     // We print all params except implicit impl Trait params. Still a bit weird; should we leave out parent and self?\n                     if total_len > 0 {\n                         write!(f, \"<\")?;\n-                        f.write_joined(&parameters.as_slice(&Interner)[..total_len], \", \")?;\n+                        f.write_joined(&parameters.as_slice(Interner)[..total_len], \", \")?;\n                         write!(f, \">\")?;\n                     }\n                 }\n@@ -528,7 +528,7 @@ impl HirDisplay for Ty {\n                     }\n                 }\n \n-                if parameters.len(&Interner) > 0 {\n+                if parameters.len(Interner) > 0 {\n                     let parameters_to_write = if f.display_target.is_source_code()\n                         || f.omit_verbose_types()\n                     {\n@@ -537,35 +537,33 @@ impl HirDisplay for Ty {\n                             .map(|generic_def_id| f.db.generic_defaults(generic_def_id))\n                             .filter(|defaults| !defaults.is_empty())\n                         {\n-                            None => parameters.as_slice(&Interner),\n+                            None => parameters.as_slice(Interner),\n                             Some(default_parameters) => {\n                                 let mut default_from = 0;\n-                                for (i, parameter) in parameters.iter(&Interner).enumerate() {\n+                                for (i, parameter) in parameters.iter(Interner).enumerate() {\n                                     match (\n-                                        parameter.assert_ty_ref(&Interner).kind(&Interner),\n+                                        parameter.assert_ty_ref(Interner).kind(Interner),\n                                         default_parameters.get(i),\n                                     ) {\n                                         (&TyKind::Error, _) | (_, None) => {\n                                             default_from = i + 1;\n                                         }\n                                         (_, Some(default_parameter)) => {\n-                                            let actual_default =\n-                                                default_parameter.clone().substitute(\n-                                                    &Interner,\n-                                                    &subst_prefix(parameters, i),\n-                                                );\n-                                            if parameter.assert_ty_ref(&Interner) != &actual_default\n+                                            let actual_default = default_parameter\n+                                                .clone()\n+                                                .substitute(Interner, &subst_prefix(parameters, i));\n+                                            if parameter.assert_ty_ref(Interner) != &actual_default\n                                             {\n                                                 default_from = i + 1;\n                                             }\n                                         }\n                                     }\n                                 }\n-                                &parameters.as_slice(&Interner)[0..default_from]\n+                                &parameters.as_slice(Interner)[0..default_from]\n                             }\n                         }\n                     } else {\n-                        parameters.as_slice(&Interner)\n+                        parameters.as_slice(Interner)\n                     };\n                     if !parameters_to_write.is_empty() {\n                         write!(f, \"<\")?;\n@@ -586,9 +584,9 @@ impl HirDisplay for Ty {\n                 // Use placeholder associated types when the target is test (https://rust-lang.github.io/chalk/book/clauses/type_equality.html#placeholder-associated-types)\n                 if f.display_target.is_test() {\n                     write!(f, \"{}::{}\", trait_.name, type_alias_data.name)?;\n-                    if parameters.len(&Interner) > 0 {\n+                    if parameters.len(Interner) > 0 {\n                         write!(f, \"<\")?;\n-                        f.write_joined(&*parameters.as_slice(&Interner), \", \")?;\n+                        f.write_joined(&*parameters.as_slice(Interner), \", \")?;\n                         write!(f, \">\")?;\n                     }\n                 } else {\n@@ -613,7 +611,7 @@ impl HirDisplay for Ty {\n                         let data = (*datas)\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                        let bounds = data.substitute(&Interner, &parameters);\n+                        let bounds = data.substitute(Interner, &parameters);\n                         let krate = func.lookup(f.db.upcast()).module(f.db.upcast()).krate();\n                         write_bounds_like_dyn_trait_with_prefix(\n                             \"impl\",\n@@ -625,7 +623,7 @@ impl HirDisplay for Ty {\n                     }\n                     ImplTraitId::AsyncBlockTypeImplTrait(..) => {\n                         write!(f, \"impl Future<Output = \")?;\n-                        parameters.at(&Interner, 0).hir_fmt(f)?;\n+                        parameters.at(Interner, 0).hir_fmt(f)?;\n                         write!(f, \">\")?;\n                     }\n                 }\n@@ -636,7 +634,7 @@ impl HirDisplay for Ty {\n                         DisplaySourceCodeError::Closure,\n                     ));\n                 }\n-                let sig = substs.at(&Interner, 0).assert_ty_ref(&Interner).callable_sig(f.db);\n+                let sig = substs.at(Interner, 0).assert_ty_ref(Interner).callable_sig(f.db);\n                 if let Some(sig) = sig {\n                     if sig.params().is_empty() {\n                         write!(f, \"||\")?;\n@@ -667,15 +665,15 @@ impl HirDisplay for Ty {\n                         let bounds =\n                             f.db.generic_predicates(id.parent)\n                                 .iter()\n-                                .map(|pred| pred.clone().substitute(&Interner, &substs))\n+                                .map(|pred| pred.clone().substitute(Interner, &substs))\n                                 .filter(|wc| match &wc.skip_binders() {\n                                     WhereClause::Implemented(tr) => {\n-                                        &tr.self_type_parameter(&Interner) == self\n+                                        &tr.self_type_parameter(Interner) == self\n                                     }\n                                     WhereClause::AliasEq(AliasEq {\n                                         alias: AliasTy::Projection(proj),\n                                         ty: _,\n-                                    }) => &proj.self_type_parameter(&Interner) == self,\n+                                    }) => &proj.self_type_parameter(Interner) == self,\n                                     _ => false,\n                                 })\n                                 .collect::<Vec<_>>();\n@@ -708,7 +706,7 @@ impl HirDisplay for Ty {\n                         let data = (*datas)\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                        let bounds = data.substitute(&Interner, &opaque_ty.substitution);\n+                        let bounds = data.substitute(Interner, &opaque_ty.substitution);\n                         let krate = func.lookup(f.db.upcast()).module(f.db.upcast()).krate();\n                         write_bounds_like_dyn_trait_with_prefix(\n                             \"impl\",\n@@ -841,13 +839,13 @@ fn write_bounds_like_dyn_trait(\n                 // existential) here, which is the only thing that's\n                 // possible in actual Rust, and hence don't print it\n                 write!(f, \"{}\", f.db.trait_data(trait_).name)?;\n-                if let [_, params @ ..] = &*trait_ref.substitution.as_slice(&Interner) {\n+                if let [_, params @ ..] = &*trait_ref.substitution.as_slice(Interner) {\n                     if is_fn_trait {\n                         if let Some(args) =\n-                            params.first().and_then(|it| it.assert_ty_ref(&Interner).as_tuple())\n+                            params.first().and_then(|it| it.assert_ty_ref(Interner).as_tuple())\n                         {\n                             write!(f, \"(\")?;\n-                            f.write_joined(args.as_slice(&Interner), \", \")?;\n+                            f.write_joined(args.as_slice(Interner), \", \")?;\n                             write!(f, \")\")?;\n                         }\n                     } else if !params.is_empty() {\n@@ -906,16 +904,16 @@ fn fmt_trait_ref(tr: &TraitRef, f: &mut HirFormatter, use_as: bool) -> Result<()\n         return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n     }\n \n-    tr.self_type_parameter(&Interner).hir_fmt(f)?;\n+    tr.self_type_parameter(Interner).hir_fmt(f)?;\n     if use_as {\n         write!(f, \" as \")?;\n     } else {\n         write!(f, \": \")?;\n     }\n     write!(f, \"{}\", f.db.trait_data(tr.hir_trait_id()).name)?;\n-    if tr.substitution.len(&Interner) > 1 {\n+    if tr.substitution.len(Interner) > 1 {\n         write!(f, \"<\")?;\n-        f.write_joined(&tr.substitution.as_slice(&Interner)[1..], \", \")?;\n+        f.write_joined(&tr.substitution.as_slice(Interner)[1..], \", \")?;\n         write!(f, \">\")?;\n     }\n     Ok(())"}, {"sha": "1bc19323da972c36ed6edd7afb0fb5dcd8e9912e", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -140,9 +140,9 @@ struct InternedStandardTypes {\n impl Default for InternedStandardTypes {\n     fn default() -> Self {\n         InternedStandardTypes {\n-            unknown: TyKind::Error.intern(&Interner),\n-            bool_: TyKind::Scalar(Scalar::Bool).intern(&Interner),\n-            unit: TyKind::Tuple(0, Substitution::empty(&Interner)).intern(&Interner),\n+            unknown: TyKind::Error.intern(Interner),\n+            bool_: TyKind::Scalar(Scalar::Bool).intern(Interner),\n+            unit: TyKind::Tuple(0, Substitution::empty(Interner)).intern(Interner),\n         }\n     }\n }\n@@ -378,7 +378,7 @@ impl<'a> InferenceContext<'a> {\n             result: InferenceResult::default(),\n             table: unify::InferenceTable::new(db, trait_env.clone()),\n             trait_env,\n-            return_ty: TyKind::Error.intern(&Interner), // set in collect_fn_signature\n+            return_ty: TyKind::Error.intern(Interner), // set in collect_fn_signature\n             db,\n             owner,\n             body: db.body(owner),\n@@ -472,7 +472,7 @@ impl<'a> InferenceContext<'a> {\n \n     /// Replaces Ty::Unknown by a new type var, so we can maybe still infer it.\n     fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n-        match ty.kind(&Interner) {\n+        match ty.kind(Interner) {\n             TyKind::Error => self.table.new_type_var(),\n             TyKind::InferenceVar(..) => {\n                 let ty_resolved = self.resolve_ty_shallow(&ty);\n@@ -495,7 +495,7 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn push_obligation(&mut self, o: DomainGoal) {\n-        self.table.register_obligation(o.cast(&Interner));\n+        self.table.register_obligation(o.cast(Interner));\n     }\n \n     fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n@@ -535,8 +535,8 @@ impl<'a> InferenceContext<'a> {\n                     }),\n                     ty: ty.clone(),\n                 };\n-                self.push_obligation(trait_ref.cast(&Interner));\n-                self.push_obligation(alias_eq.cast(&Interner));\n+                self.push_obligation(trait_ref.cast(Interner));\n+                self.push_obligation(alias_eq.cast(Interner));\n                 ty\n             }\n             None => self.err_ty(),\n@@ -568,13 +568,13 @@ impl<'a> InferenceContext<'a> {\n                     ValueNs::EnumVariantId(var) => {\n                         let substs = ctx.substs_from_path(path, var.into(), true);\n                         let ty = self.db.ty(var.parent.into());\n-                        let ty = self.insert_type_vars(ty.substitute(&Interner, &substs));\n+                        let ty = self.insert_type_vars(ty.substitute(Interner, &substs));\n                         return (ty, Some(var.into()));\n                     }\n                     ValueNs::StructId(strukt) => {\n                         let substs = ctx.substs_from_path(path, strukt.into(), true);\n                         let ty = self.db.ty(strukt.into());\n-                        let ty = self.insert_type_vars(ty.substitute(&Interner, &substs));\n+                        let ty = self.insert_type_vars(ty.substitute(Interner, &substs));\n                         return (ty, Some(strukt.into()));\n                     }\n                     _ => return (self.err_ty(), None),\n@@ -592,25 +592,25 @@ impl<'a> InferenceContext<'a> {\n             TypeNs::AdtId(AdtId::StructId(strukt)) => {\n                 let substs = ctx.substs_from_path(path, strukt.into(), true);\n                 let ty = self.db.ty(strukt.into());\n-                let ty = self.insert_type_vars(ty.substitute(&Interner, &substs));\n+                let ty = self.insert_type_vars(ty.substitute(Interner, &substs));\n                 forbid_unresolved_segments((ty, Some(strukt.into())), unresolved)\n             }\n             TypeNs::AdtId(AdtId::UnionId(u)) => {\n                 let substs = ctx.substs_from_path(path, u.into(), true);\n                 let ty = self.db.ty(u.into());\n-                let ty = self.insert_type_vars(ty.substitute(&Interner, &substs));\n+                let ty = self.insert_type_vars(ty.substitute(Interner, &substs));\n                 forbid_unresolved_segments((ty, Some(u.into())), unresolved)\n             }\n             TypeNs::EnumVariantId(var) => {\n                 let substs = ctx.substs_from_path(path, var.into(), true);\n                 let ty = self.db.ty(var.parent.into());\n-                let ty = self.insert_type_vars(ty.substitute(&Interner, &substs));\n+                let ty = self.insert_type_vars(ty.substitute(Interner, &substs));\n                 forbid_unresolved_segments((ty, Some(var.into())), unresolved)\n             }\n             TypeNs::SelfType(impl_id) => {\n                 let generics = crate::utils::generics(self.db.upcast(), impl_id.into());\n                 let substs = generics.type_params_subst(self.db);\n-                let ty = self.db.impl_self_ty(impl_id).substitute(&Interner, &substs);\n+                let ty = self.db.impl_self_ty(impl_id).substitute(Interner, &substs);\n                 self.resolve_variant_on_alias(ty, unresolved, path)\n             }\n             TypeNs::TypeAliasId(it) => {\n@@ -641,7 +641,7 @@ impl<'a> InferenceContext<'a> {\n                 result\n             } else {\n                 // FIXME diagnostic\n-                (TyKind::Error.intern(&Interner), None)\n+                (TyKind::Error.intern(Interner), None)\n             }\n         }\n     }\n@@ -854,7 +854,7 @@ impl Expectation {\n     /// for examples of where this comes up,.\n     fn rvalue_hint(table: &mut unify::InferenceTable, ty: Ty) -> Self {\n         // FIXME: do struct_tail_without_normalization\n-        match table.resolve_ty_shallow(&ty).kind(&Interner) {\n+        match table.resolve_ty_shallow(&ty).kind(Interner) {\n             TyKind::Slice(_) | TyKind::Str | TyKind::Dyn(_) => Expectation::RValueLikeUnsized(ty),\n             _ => Expectation::has_type(ty),\n         }"}, {"sha": "3ead929098bcc25843d92fcd6b28c09ac0f07f16", "filename": "crates/hir_ty/src/infer/closure.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fclosure.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -28,9 +28,9 @@ impl InferenceContext<'_> {\n         let _ = self.coerce(Some(closure_expr), closure_ty, &expected_ty);\n \n         // Deduction based on the expected `dyn Fn` is done separately.\n-        if let TyKind::Dyn(dyn_ty) = expected_ty.kind(&Interner) {\n+        if let TyKind::Dyn(dyn_ty) = expected_ty.kind(Interner) {\n             if let Some(sig) = self.deduce_sig_from_dyn_ty(dyn_ty) {\n-                let expected_sig_ty = TyKind::Function(sig).intern(&Interner);\n+                let expected_sig_ty = TyKind::Function(sig).intern(Interner);\n \n                 self.unify(sig_ty, &expected_sig_ty);\n             }\n@@ -45,9 +45,9 @@ impl InferenceContext<'_> {\n                 .map(to_chalk_trait_id)\n                 .collect();\n \n-        let self_ty = TyKind::Error.intern(&Interner);\n-        let bounds = dyn_ty.bounds.clone().substitute(&Interner, &[self_ty.cast(&Interner)]);\n-        for bound in bounds.iter(&Interner) {\n+        let self_ty = TyKind::Error.intern(Interner);\n+        let bounds = dyn_ty.bounds.clone().substitute(Interner, &[self_ty.cast(Interner)]);\n+        for bound in bounds.iter(Interner) {\n             // NOTE(skip_binders): the extracted types are rebound by the returned `FnPointer`\n             if let WhereClause::AliasEq(AliasEq { alias: AliasTy::Projection(projection), ty }) =\n                 bound.skip_binders()\n@@ -58,20 +58,20 @@ impl InferenceContext<'_> {\n                 }\n \n                 // Skip `Self`, get the type argument.\n-                let arg = projection.substitution.as_slice(&Interner).get(1)?;\n-                if let Some(subst) = arg.ty(&Interner)?.as_tuple() {\n-                    let generic_args = subst.as_slice(&Interner);\n+                let arg = projection.substitution.as_slice(Interner).get(1)?;\n+                if let Some(subst) = arg.ty(Interner)?.as_tuple() {\n+                    let generic_args = subst.as_slice(Interner);\n                     let mut sig_tys = Vec::new();\n                     for arg in generic_args {\n-                        sig_tys.push(arg.ty(&Interner)?.clone());\n+                        sig_tys.push(arg.ty(Interner)?.clone());\n                     }\n                     sig_tys.push(ty.clone());\n \n                     cov_mark::hit!(dyn_fn_param_informs_call_site_closure_signature);\n                     return Some(FnPointer {\n-                        num_binders: bound.len(&Interner),\n+                        num_binders: bound.len(Interner),\n                         sig: FnSig { abi: (), safety: chalk_ir::Safety::Safe, variadic: false },\n-                        substitution: FnSubst(Substitution::from_iter(&Interner, sig_tys)),\n+                        substitution: FnSubst(Substitution::from_iter(Interner, sig_tys)),\n                     });\n                 }\n             }"}, {"sha": "bddb79c50159c27a968293ab71ae292132fc9a7e", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -71,7 +71,7 @@ impl CoerceMany {\n         // Special case: two function types. Try to coerce both to\n         // pointers to have a chance at getting a match. See\n         // https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src/librustc_typeck/check/coercion.rs#L877-L916\n-        let sig = match (self.expected_ty.kind(&Interner), expr_ty.kind(&Interner)) {\n+        let sig = match (self.expected_ty.kind(Interner), expr_ty.kind(Interner)) {\n             (TyKind::FnDef(..) | TyKind::Closure(..), TyKind::FnDef(..) | TyKind::Closure(..)) => {\n                 // FIXME: we're ignoring safety here. To be more correct, if we have one FnDef and one Closure,\n                 // we should be coercing the closure to a fn pointer of the safety of the FnDef\n@@ -83,7 +83,7 @@ impl CoerceMany {\n             _ => None,\n         };\n         if let Some(sig) = sig {\n-            let target_ty = TyKind::Function(sig.to_fn_ptr()).intern(&Interner);\n+            let target_ty = TyKind::Function(sig.to_fn_ptr()).intern(Interner);\n             let result1 = ctx.coerce_inner(self.expected_ty.clone(), &target_ty);\n             let result2 = ctx.coerce_inner(expr_ty.clone(), &target_ty);\n             if let (Ok(result1), Ok(result2)) = (result1, result2) {\n@@ -153,7 +153,7 @@ impl<'a> InferenceContext<'a> {\n             //     let _: Option<?T> = Some({ return; });\n             //\n             // here, we would coerce from `!` to `?T`.\n-            if let TyKind::InferenceVar(tv, TyVariableKind::General) = to_ty.kind(&Interner) {\n+            if let TyKind::InferenceVar(tv, TyVariableKind::General) = to_ty.kind(Interner) {\n                 self.table.set_diverging(*tv, true);\n             }\n             return success(simple(Adjust::NeverToAny)(to_ty.clone()), to_ty.clone(), vec![]);\n@@ -165,13 +165,13 @@ impl<'a> InferenceContext<'a> {\n         }\n \n         // Examine the supertype and consider auto-borrowing.\n-        match to_ty.kind(&Interner) {\n+        match to_ty.kind(Interner) {\n             TyKind::Raw(mt, _) => return self.coerce_ptr(from_ty, to_ty, *mt),\n             TyKind::Ref(mt, _, _) => return self.coerce_ref(from_ty, to_ty, *mt),\n             _ => {}\n         }\n \n-        match from_ty.kind(&Interner) {\n+        match from_ty.kind(Interner) {\n             TyKind::FnDef(..) => {\n                 // Function items are coercible to any closure\n                 // type; function pointers are not (that would\n@@ -209,7 +209,7 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn coerce_ptr(&mut self, from_ty: Ty, to_ty: &Ty, to_mt: Mutability) -> CoerceResult {\n-        let (is_ref, from_mt, from_inner) = match from_ty.kind(&Interner) {\n+        let (is_ref, from_mt, from_inner) = match from_ty.kind(Interner) {\n             TyKind::Ref(mt, _, ty) => (true, mt, ty),\n             TyKind::Raw(mt, ty) => (false, mt, ty),\n             _ => return self.unify_and(&from_ty, to_ty, identity),\n@@ -218,7 +218,7 @@ impl<'a> InferenceContext<'a> {\n         coerce_mutabilities(*from_mt, to_mt)?;\n \n         // Check that the types which they point at are compatible.\n-        let from_raw = TyKind::Raw(to_mt, from_inner.clone()).intern(&Interner);\n+        let from_raw = TyKind::Raw(to_mt, from_inner.clone()).intern(Interner);\n \n         // Although references and unsafe ptrs have the same\n         // representation, we still register an Adjust::DerefRef so that\n@@ -245,7 +245,7 @@ impl<'a> InferenceContext<'a> {\n     /// To match `A` with `B`, autoderef will be performed,\n     /// calling `deref`/`deref_mut` where necessary.\n     fn coerce_ref(&mut self, from_ty: Ty, to_ty: &Ty, to_mt: Mutability) -> CoerceResult {\n-        let from_mt = match from_ty.kind(&Interner) {\n+        let from_mt = match from_ty.kind(Interner) {\n             &TyKind::Ref(mt, _, _) => {\n                 coerce_mutabilities(mt, to_mt)?;\n                 mt\n@@ -303,7 +303,7 @@ impl<'a> InferenceContext<'a> {\n             // mutability [1], since it may be that we are coercing\n             // from `&mut T` to `&U`.\n             let lt = static_lifetime(); // FIXME: handle lifetimes correctly, see rustc\n-            let derefd_from_ty = TyKind::Ref(to_mt, lt, referent_ty).intern(&Interner);\n+            let derefd_from_ty = TyKind::Ref(to_mt, lt, referent_ty).intern(Interner);\n             match self.table.try_unify(&derefd_from_ty, to_ty) {\n                 Ok(result) => {\n                     found = Some(result.map(|()| derefd_from_ty));\n@@ -370,7 +370,7 @@ impl<'a> InferenceContext<'a> {\n \n     /// Attempts to coerce from the type of a Rust function item into a function pointer.\n     fn coerce_from_fn_item(&mut self, from_ty: Ty, to_ty: &Ty) -> CoerceResult {\n-        match to_ty.kind(&Interner) {\n+        match to_ty.kind(Interner) {\n             TyKind::Function(_) => {\n                 let from_sig = from_ty.callable_sig(self.db).expect(\"FnDef had no sig\");\n \n@@ -380,7 +380,7 @@ impl<'a> InferenceContext<'a> {\n                 // FIXME rustc normalizes assoc types in the sig here, not sure if necessary\n \n                 let from_sig = from_sig.to_fn_ptr();\n-                let from_fn_pointer = TyKind::Function(from_sig.clone()).intern(&Interner);\n+                let from_fn_pointer = TyKind::Function(from_sig.clone()).intern(Interner);\n                 let ok = self.coerce_from_safe_fn(\n                     from_fn_pointer.clone(),\n                     &from_sig,\n@@ -433,12 +433,12 @@ impl<'a> InferenceContext<'a> {\n         F: FnOnce(Ty) -> Vec<Adjustment>,\n         G: FnOnce(Ty) -> Vec<Adjustment>,\n     {\n-        if let TyKind::Function(to_fn_ptr) = to_ty.kind(&Interner) {\n+        if let TyKind::Function(to_fn_ptr) = to_ty.kind(Interner) {\n             if let (chalk_ir::Safety::Safe, chalk_ir::Safety::Unsafe) =\n                 (from_fn_ptr.sig.safety, to_fn_ptr.sig.safety)\n             {\n                 let from_unsafe =\n-                    TyKind::Function(safe_to_unsafe_fn_ty(from_fn_ptr.clone())).intern(&Interner);\n+                    TyKind::Function(safe_to_unsafe_fn_ty(from_fn_ptr.clone())).intern(Interner);\n                 return self.unify_and(&from_unsafe, to_ty, to_unsafe);\n             }\n         }\n@@ -453,7 +453,7 @@ impl<'a> InferenceContext<'a> {\n         from_substs: &Substitution,\n         to_ty: &Ty,\n     ) -> CoerceResult {\n-        match to_ty.kind(&Interner) {\n+        match to_ty.kind(Interner) {\n             // if from_substs is non-capturing (FIXME)\n             TyKind::Function(fn_ty) => {\n                 // We coerce the closure, which has fn type\n@@ -507,7 +507,7 @@ impl<'a> InferenceContext<'a> {\n         }\n \n         // Handle reborrows before trying to solve `Source: CoerceUnsized<Target>`.\n-        let reborrow = match (from_ty.kind(&Interner), to_ty.kind(&Interner)) {\n+        let reborrow = match (from_ty.kind(Interner), to_ty.kind(Interner)) {\n             (TyKind::Ref(from_mt, _, from_inner), &TyKind::Ref(to_mt, _, _)) => {\n                 coerce_mutabilities(*from_mt, to_mt)?;\n \n@@ -516,7 +516,7 @@ impl<'a> InferenceContext<'a> {\n                     Adjustment { kind: Adjust::Deref(None), target: from_inner.clone() },\n                     Adjustment {\n                         kind: Adjust::Borrow(AutoBorrow::Ref(to_mt)),\n-                        target: TyKind::Ref(to_mt, lt, from_inner.clone()).intern(&Interner),\n+                        target: TyKind::Ref(to_mt, lt, from_inner.clone()).intern(Interner),\n                     },\n                 ))\n             }\n@@ -527,7 +527,7 @@ impl<'a> InferenceContext<'a> {\n                     Adjustment { kind: Adjust::Deref(None), target: from_inner.clone() },\n                     Adjustment {\n                         kind: Adjust::Borrow(AutoBorrow::RawPtr(to_mt)),\n-                        target: TyKind::Raw(to_mt, from_inner.clone()).intern(&Interner),\n+                        target: TyKind::Raw(to_mt, from_inner.clone()).intern(Interner),\n                     },\n                 ))\n             }\n@@ -553,7 +553,7 @@ impl<'a> InferenceContext<'a> {\n         };\n \n         let goal: InEnvironment<DomainGoal> =\n-            InEnvironment::new(&self.trait_env.env, coerce_unsized_tref.cast(&Interner));\n+            InEnvironment::new(&self.trait_env.env, coerce_unsized_tref.cast(Interner));\n \n         let canonicalized = self.canonicalize(goal);\n \n@@ -563,7 +563,7 @@ impl<'a> InferenceContext<'a> {\n         // Need to find out in what cases this is necessary\n         let solution = self\n             .db\n-            .trait_solve(krate, canonicalized.value.clone().cast(&Interner))\n+            .trait_solve(krate, canonicalized.value.clone().cast(Interner))\n             .ok_or(TypeError)?;\n \n         match solution {\n@@ -593,15 +593,15 @@ impl<'a> InferenceContext<'a> {\n }\n \n fn coerce_closure_fn_ty(closure_substs: &Substitution, safety: chalk_ir::Safety) -> Ty {\n-    let closure_sig = closure_substs.at(&Interner, 0).assert_ty_ref(&Interner).clone();\n-    match closure_sig.kind(&Interner) {\n+    let closure_sig = closure_substs.at(Interner, 0).assert_ty_ref(Interner).clone();\n+    match closure_sig.kind(Interner) {\n         TyKind::Function(fn_ty) => TyKind::Function(FnPointer {\n             num_binders: fn_ty.num_binders,\n             sig: FnSig { safety, ..fn_ty.sig },\n             substitution: fn_ty.substitution.clone(),\n         })\n-        .intern(&Interner),\n-        _ => TyKind::Error.intern(&Interner),\n+        .intern(Interner),\n+        _ => TyKind::Error.intern(Interner),\n     }\n }\n "}, {"sha": "a892a680d7e4408f42a9e8f456acefdfef8ed8a5", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -105,11 +105,11 @@ impl<'a> InferenceContext<'a> {\n \n         let trait_env = self.trait_env.env.clone();\n         let obligation = InEnvironment {\n-            goal: projection.trait_ref(self.db).cast(&Interner),\n+            goal: projection.trait_ref(self.db).cast(Interner),\n             environment: trait_env,\n         };\n         let canonical = self.canonicalize(obligation.clone());\n-        if self.db.trait_solve(krate, canonical.value.cast(&Interner)).is_some() {\n+        if self.db.trait_solve(krate, canonical.value.cast(Interner)).is_some() {\n             self.push_obligation(obligation.goal);\n             let return_ty = self.table.normalize_projection_ty(projection);\n             Some((arg_tys, return_ty))\n@@ -135,7 +135,7 @@ impl<'a> InferenceContext<'a> {\n                 // if let is desugared to match, so this is always simple if\n                 self.infer_expr(\n                     condition,\n-                    &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(&Interner)),\n+                    &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(Interner)),\n                 );\n \n                 let condition_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n@@ -201,8 +201,8 @@ impl<'a> InferenceContext<'a> {\n                 let inner_ty = self.infer_expr(*body, &Expectation::none());\n                 let impl_trait_id = crate::ImplTraitId::AsyncBlockTypeImplTrait(self.owner, *body);\n                 let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n-                TyKind::OpaqueType(opaque_ty_id, Substitution::from1(&Interner, inner_ty))\n-                    .intern(&Interner)\n+                TyKind::OpaqueType(opaque_ty_id, Substitution::from1(Interner, inner_ty))\n+                    .intern(Interner)\n             }\n             Expr::Loop { body, label } => {\n                 self.breakables.push(BreakableContext {\n@@ -218,7 +218,7 @@ impl<'a> InferenceContext<'a> {\n                     self.diverges = Diverges::Maybe;\n                     ctxt.coerce.complete()\n                 } else {\n-                    TyKind::Never.intern(&Interner)\n+                    TyKind::Never.intern(Interner)\n                 }\n             }\n             Expr::While { condition, body, label } => {\n@@ -230,7 +230,7 @@ impl<'a> InferenceContext<'a> {\n                 // while let is desugared to a match loop, so this is always simple while\n                 self.infer_expr(\n                     *condition,\n-                    &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(&Interner)),\n+                    &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(Interner)),\n                 );\n                 self.infer_expr(*body, &Expectation::has_type(TyBuilder::unit()));\n                 let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n@@ -281,14 +281,14 @@ impl<'a> InferenceContext<'a> {\n                     num_binders: 0,\n                     sig: FnSig { abi: (), safety: chalk_ir::Safety::Safe, variadic: false },\n                     substitution: FnSubst(\n-                        Substitution::from_iter(&Interner, sig_tys.clone()).shifted_in(&Interner),\n+                        Substitution::from_iter(Interner, sig_tys.clone()).shifted_in(Interner),\n                     ),\n                 })\n-                .intern(&Interner);\n+                .intern(Interner);\n                 let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n                 let closure_ty =\n-                    TyKind::Closure(closure_id, Substitution::from1(&Interner, sig_ty.clone()))\n-                        .intern(&Interner);\n+                    TyKind::Closure(closure_id, Substitution::from1(Interner, sig_ty.clone()))\n+                        .intern(Interner);\n \n                 // Eagerly try to relate the closure type with the expected\n                 // type, otherwise we often won't have enough information to\n@@ -363,7 +363,7 @@ impl<'a> InferenceContext<'a> {\n                 let expected = expected.adjust_for_branches(&mut self.table);\n \n                 let result_ty = if arms.is_empty() {\n-                    TyKind::Never.intern(&Interner)\n+                    TyKind::Never.intern(Interner)\n                 } else {\n                     match &expected {\n                         Expectation::HasType(ty) => ty.clone(),\n@@ -383,7 +383,7 @@ impl<'a> InferenceContext<'a> {\n                             self.infer_expr(\n                                 guard_expr,\n                                 &Expectation::has_type(\n-                                    TyKind::Scalar(Scalar::Bool).intern(&Interner),\n+                                    TyKind::Scalar(Scalar::Bool).intern(Interner),\n                                 ),\n                             );\n                         }\n@@ -408,7 +408,7 @@ impl<'a> InferenceContext<'a> {\n                 let resolver = resolver_for_expr(self.db.upcast(), self.owner, tgt_expr);\n                 self.infer_path(&resolver, p, tgt_expr.into()).unwrap_or_else(|| self.err_ty())\n             }\n-            Expr::Continue { .. } => TyKind::Never.intern(&Interner),\n+            Expr::Continue { .. } => TyKind::Never.intern(Interner),\n             Expr::Break { expr, label } => {\n                 let mut coerce = match find_breakable(&mut self.breakables, label.as_ref()) {\n                     Some(ctxt) => {\n@@ -439,7 +439,7 @@ impl<'a> InferenceContext<'a> {\n                     });\n                 };\n \n-                TyKind::Never.intern(&Interner)\n+                TyKind::Never.intern(Interner)\n             }\n             Expr::Return { expr } => {\n                 if let Some(expr) = expr {\n@@ -448,14 +448,14 @@ impl<'a> InferenceContext<'a> {\n                     let unit = TyBuilder::unit();\n                     let _ = self.coerce(Some(tgt_expr), &unit, &self.return_ty.clone());\n                 }\n-                TyKind::Never.intern(&Interner)\n+                TyKind::Never.intern(Interner)\n             }\n             Expr::Yield { expr } => {\n                 // FIXME: track yield type for coercion\n                 if let Some(expr) = expr {\n                     self.infer_expr(*expr, &Expectation::none());\n                 }\n-                TyKind::Never.intern(&Interner)\n+                TyKind::Never.intern(Interner)\n             }\n             Expr::RecordLit { path, fields, spread } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_deref(), false);\n@@ -470,7 +470,7 @@ impl<'a> InferenceContext<'a> {\n                 let substs = ty\n                     .as_adt()\n                     .map(|(_, s)| s.clone())\n-                    .unwrap_or_else(|| Substitution::empty(&Interner));\n+                    .unwrap_or_else(|| Substitution::empty(Interner));\n                 let field_types = def_id.map(|it| self.db.field_types(it)).unwrap_or_default();\n                 let variant_data = def_id.map(|it| it.variant_data(self.db.upcast()));\n                 for field in fields.iter() {\n@@ -485,7 +485,7 @@ impl<'a> InferenceContext<'a> {\n                             }\n                         });\n                     let field_ty = field_def.map_or(self.err_ty(), |it| {\n-                        field_types[it.local_id].clone().substitute(&Interner, &substs)\n+                        field_types[it.local_id].clone().substitute(Interner, &substs)\n                     });\n                     self.infer_expr_coerce(field.expr, &Expectation::has_type(field_ty));\n                 }\n@@ -519,13 +519,13 @@ impl<'a> InferenceContext<'a> {\n                     };\n                     match canonicalized\n                         .decanonicalize_ty(&mut self.table, derefed_ty)\n-                        .kind(&Interner)\n+                        .kind(Interner)\n                     {\n                         TyKind::Tuple(_, substs) => name.as_tuple_index().and_then(|idx| {\n                             substs\n-                                .as_slice(&Interner)\n+                                .as_slice(Interner)\n                                 .get(idx)\n-                                .map(|a| a.assert_ty_ref(&Interner))\n+                                .map(|a| a.assert_ty_ref(Interner))\n                                 .cloned()\n                         }),\n                         TyKind::Adt(AdtId(hir_def::AdtId::StructId(s)), parameters) => {\n@@ -536,7 +536,7 @@ impl<'a> InferenceContext<'a> {\n                                 Some(\n                                     self.db.field_types((*s).into())[field.local_id]\n                                         .clone()\n-                                        .substitute(&Interner, &parameters),\n+                                        .substitute(Interner, &parameters),\n                                 )\n                             } else {\n                                 None\n@@ -550,7 +550,7 @@ impl<'a> InferenceContext<'a> {\n                                 Some(\n                                     self.db.field_types((*u).into())[field.local_id]\n                                         .clone()\n-                                        .substitute(&Interner, &parameters),\n+                                        .substitute(Interner, &parameters),\n                                 )\n                             } else {\n                                 None\n@@ -608,7 +608,7 @@ impl<'a> InferenceContext<'a> {\n                     Rawness::RawPtr => TyKind::Raw(mutability, inner_ty),\n                     Rawness::Ref => TyKind::Ref(mutability, static_lifetime(), inner_ty),\n                 }\n-                .intern(&Interner)\n+                .intern(Interner)\n             }\n             Expr::Box { expr } => {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n@@ -645,7 +645,7 @@ impl<'a> InferenceContext<'a> {\n                         None => self.err_ty(),\n                     },\n                     UnaryOp::Neg => {\n-                        match inner_ty.kind(&Interner) {\n+                        match inner_ty.kind(Interner) {\n                             // Fast path for builtins\n                             TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_) | Scalar::Float(_))\n                             | TyKind::InferenceVar(\n@@ -658,7 +658,7 @@ impl<'a> InferenceContext<'a> {\n                         }\n                     }\n                     UnaryOp::Not => {\n-                        match inner_ty.kind(&Interner) {\n+                        match inner_ty.kind(Interner) {\n                             // Fast path for builtins\n                             TyKind::Scalar(Scalar::Bool | Scalar::Int(_) | Scalar::Uint(_))\n                             | TyKind::InferenceVar(_, TyVariableKind::Integer) => inner_ty,\n@@ -756,11 +756,11 @@ impl<'a> InferenceContext<'a> {\n                 let mut tys = match expected\n                     .only_has_type(&mut self.table)\n                     .as_ref()\n-                    .map(|t| t.kind(&Interner))\n+                    .map(|t| t.kind(Interner))\n                 {\n                     Some(TyKind::Tuple(_, substs)) => substs\n-                        .iter(&Interner)\n-                        .map(|a| a.assert_ty_ref(&Interner).clone())\n+                        .iter(Interner)\n+                        .map(|a| a.assert_ty_ref(Interner).clone())\n                         .chain(repeat_with(|| self.table.new_type_var()))\n                         .take(exprs.len())\n                         .collect::<Vec<_>>(),\n@@ -771,11 +771,11 @@ impl<'a> InferenceContext<'a> {\n                     self.infer_expr_coerce(*expr, &Expectation::has_type(ty.clone()));\n                 }\n \n-                TyKind::Tuple(tys.len(), Substitution::from_iter(&Interner, tys)).intern(&Interner)\n+                TyKind::Tuple(tys.len(), Substitution::from_iter(Interner, tys)).intern(Interner)\n             }\n             Expr::Array(array) => {\n                 let elem_ty =\n-                    match expected.to_option(&mut self.table).as_ref().map(|t| t.kind(&Interner)) {\n+                    match expected.to_option(&mut self.table).as_ref().map(|t| t.kind(Interner)) {\n                         Some(TyKind::Array(st, _) | TyKind::Slice(st)) => st.clone(),\n                         _ => self.table.new_type_var(),\n                     };\n@@ -795,7 +795,7 @@ impl<'a> InferenceContext<'a> {\n                         self.infer_expr(\n                             repeat,\n                             &Expectation::has_type(\n-                                TyKind::Scalar(Scalar::Uint(UintTy::Usize)).intern(&Interner),\n+                                TyKind::Scalar(Scalar::Uint(UintTy::Usize)).intern(Interner),\n                             ),\n                         );\n \n@@ -804,41 +804,41 @@ impl<'a> InferenceContext<'a> {\n                     }\n                 };\n \n-                TyKind::Array(coerce.complete(), consteval::usize_const(len)).intern(&Interner)\n+                TyKind::Array(coerce.complete(), consteval::usize_const(len)).intern(Interner)\n             }\n             Expr::Literal(lit) => match lit {\n-                Literal::Bool(..) => TyKind::Scalar(Scalar::Bool).intern(&Interner),\n+                Literal::Bool(..) => TyKind::Scalar(Scalar::Bool).intern(Interner),\n                 Literal::String(..) => {\n-                    TyKind::Ref(Mutability::Not, static_lifetime(), TyKind::Str.intern(&Interner))\n-                        .intern(&Interner)\n+                    TyKind::Ref(Mutability::Not, static_lifetime(), TyKind::Str.intern(Interner))\n+                        .intern(Interner)\n                 }\n                 Literal::ByteString(bs) => {\n-                    let byte_type = TyKind::Scalar(Scalar::Uint(UintTy::U8)).intern(&Interner);\n+                    let byte_type = TyKind::Scalar(Scalar::Uint(UintTy::U8)).intern(Interner);\n \n                     let len = consteval::usize_const(Some(bs.len() as u64));\n \n-                    let array_type = TyKind::Array(byte_type, len).intern(&Interner);\n-                    TyKind::Ref(Mutability::Not, static_lifetime(), array_type).intern(&Interner)\n+                    let array_type = TyKind::Array(byte_type, len).intern(Interner);\n+                    TyKind::Ref(Mutability::Not, static_lifetime(), array_type).intern(Interner)\n                 }\n-                Literal::Char(..) => TyKind::Scalar(Scalar::Char).intern(&Interner),\n+                Literal::Char(..) => TyKind::Scalar(Scalar::Char).intern(Interner),\n                 Literal::Int(_v, ty) => match ty {\n                     Some(int_ty) => {\n                         TyKind::Scalar(Scalar::Int(primitive::int_ty_from_builtin(*int_ty)))\n-                            .intern(&Interner)\n+                            .intern(Interner)\n                     }\n                     None => self.table.new_integer_var(),\n                 },\n                 Literal::Uint(_v, ty) => match ty {\n                     Some(int_ty) => {\n                         TyKind::Scalar(Scalar::Uint(primitive::uint_ty_from_builtin(*int_ty)))\n-                            .intern(&Interner)\n+                            .intern(Interner)\n                     }\n                     None => self.table.new_integer_var(),\n                 },\n                 Literal::Float(_v, ty) => match ty {\n                     Some(float_ty) => {\n                         TyKind::Scalar(Scalar::Float(primitive::float_ty_from_builtin(*float_ty)))\n-                            .intern(&Interner)\n+                            .intern(Interner)\n                     }\n                     None => self.table.new_float_var(),\n                 },\n@@ -880,7 +880,7 @@ impl<'a> InferenceContext<'a> {\n             .build();\n         self.write_method_resolution(tgt_expr, func, subst.clone());\n \n-        let method_ty = self.db.value_ty(func.into()).substitute(&Interner, &subst);\n+        let method_ty = self.db.value_ty(func.into()).substitute(Interner, &subst);\n         self.register_obligations_for_call(&method_ty);\n \n         self.infer_expr_coerce(rhs, &Expectation::has_type(rhs_ty.clone()));\n@@ -934,7 +934,7 @@ impl<'a> InferenceContext<'a> {\n                     if let Some(expr) = else_branch {\n                         self.infer_expr_coerce(\n                             *expr,\n-                            &Expectation::has_type(Ty::new(&Interner, TyKind::Never)),\n+                            &Expectation::has_type(Ty::new(Interner, TyKind::Never)),\n                         );\n                     }\n \n@@ -1003,11 +1003,11 @@ impl<'a> InferenceContext<'a> {\n             }\n             None => (\n                 receiver_ty,\n-                Binders::empty(&Interner, self.err_ty()),\n-                Substitution::empty(&Interner),\n+                Binders::empty(Interner, self.err_ty()),\n+                Substitution::empty(Interner),\n             ),\n         };\n-        let method_ty = method_ty.substitute(&Interner, &substs);\n+        let method_ty = method_ty.substitute(Interner, &substs);\n         self.register_obligations_for_call(&method_ty);\n         let (formal_receiver_ty, param_tys, ret_ty) = match method_ty.callable_sig(self.db) {\n             Some(sig) => {\n@@ -1038,12 +1038,12 @@ impl<'a> InferenceContext<'a> {\n             self.table.fudge_inference(|table| {\n                 if table.try_unify(&expected_ty, &output).is_ok() {\n                     table.resolve_with_fallback(inputs, &|var, kind, _, _| match kind {\n-                        chalk_ir::VariableKind::Ty(tk) => var.to_ty(&Interner, tk).cast(&Interner),\n+                        chalk_ir::VariableKind::Ty(tk) => var.to_ty(Interner, tk).cast(Interner),\n                         chalk_ir::VariableKind::Lifetime => {\n-                            var.to_lifetime(&Interner).cast(&Interner)\n+                            var.to_lifetime(Interner).cast(Interner)\n                         }\n                         chalk_ir::VariableKind::Const(ty) => {\n-                            var.to_const(&Interner, ty).cast(&Interner)\n+                            var.to_const(Interner, ty).cast(Interner)\n                         }\n                     })\n                 } else {\n@@ -1148,21 +1148,21 @@ impl<'a> InferenceContext<'a> {\n             substs.push(self.table.new_type_var());\n         }\n         assert_eq!(substs.len(), total_len);\n-        Substitution::from_iter(&Interner, substs)\n+        Substitution::from_iter(Interner, substs)\n     }\n \n     fn register_obligations_for_call(&mut self, callable_ty: &Ty) {\n         let callable_ty = self.resolve_ty_shallow(callable_ty);\n-        if let TyKind::FnDef(fn_def, parameters) = callable_ty.kind(&Interner) {\n+        if let TyKind::FnDef(fn_def, parameters) = callable_ty.kind(Interner) {\n             let def: CallableDefId = from_chalk(self.db, *fn_def);\n             let generic_predicates = self.db.generic_predicates(def.into());\n             for predicate in generic_predicates.iter() {\n                 let (predicate, binders) = predicate\n                     .clone()\n-                    .substitute(&Interner, parameters)\n+                    .substitute(Interner, parameters)\n                     .into_value_and_skipped_binders();\n-                always!(binders.len(&Interner) == 0); // quantified where clauses not yet handled\n-                self.push_obligation(predicate.cast(&Interner));\n+                always!(binders.len(Interner) == 0); // quantified where clauses not yet handled\n+                self.push_obligation(predicate.cast(Interner));\n             }\n             // add obligation for trait implementation, if this is a trait method\n             match def {\n@@ -1175,7 +1175,7 @@ impl<'a> InferenceContext<'a> {\n                         );\n                         self.push_obligation(\n                             TraitRef { trait_id: to_chalk_trait_id(trait_), substitution: substs }\n-                                .cast(&Interner),\n+                                .cast(Interner),\n                         );\n                     }\n                 }\n@@ -1189,17 +1189,17 @@ impl<'a> InferenceContext<'a> {\n         let rhs_ty = self.resolve_ty_shallow(&rhs_ty);\n         match op {\n             BinaryOp::LogicOp(_) | BinaryOp::CmpOp(_) => {\n-                Some(TyKind::Scalar(Scalar::Bool).intern(&Interner))\n+                Some(TyKind::Scalar(Scalar::Bool).intern(Interner))\n             }\n             BinaryOp::Assignment { .. } => Some(TyBuilder::unit()),\n             BinaryOp::ArithOp(ArithOp::Shl | ArithOp::Shr) => {\n                 // all integer combinations are valid here\n                 if matches!(\n-                    lhs_ty.kind(&Interner),\n+                    lhs_ty.kind(Interner),\n                     TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_))\n                         | TyKind::InferenceVar(_, TyVariableKind::Integer)\n                 ) && matches!(\n-                    rhs_ty.kind(&Interner),\n+                    rhs_ty.kind(Interner),\n                     TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_))\n                         | TyKind::InferenceVar(_, TyVariableKind::Integer)\n                 ) {\n@@ -1208,7 +1208,7 @@ impl<'a> InferenceContext<'a> {\n                     None\n                 }\n             }\n-            BinaryOp::ArithOp(_) => match (lhs_ty.kind(&Interner), rhs_ty.kind(&Interner)) {\n+            BinaryOp::ArithOp(_) => match (lhs_ty.kind(Interner), rhs_ty.kind(Interner)) {\n                 // (int, int) | (uint, uint) | (float, float)\n                 (TyKind::Scalar(Scalar::Int(_)), TyKind::Scalar(Scalar::Int(_)))\n                 | (TyKind::Scalar(Scalar::Uint(_)), TyKind::Scalar(Scalar::Uint(_)))\n@@ -1251,11 +1251,11 @@ impl<'a> InferenceContext<'a> {\n \n     fn builtin_binary_op_rhs_expectation(&mut self, op: BinaryOp, lhs_ty: Ty) -> Option<Ty> {\n         Some(match op {\n-            BinaryOp::LogicOp(..) => TyKind::Scalar(Scalar::Bool).intern(&Interner),\n+            BinaryOp::LogicOp(..) => TyKind::Scalar(Scalar::Bool).intern(Interner),\n             BinaryOp::Assignment { op: None } => lhs_ty,\n             BinaryOp::CmpOp(CmpOp::Eq { .. }) => match self\n                 .resolve_ty_shallow(&lhs_ty)\n-                .kind(&Interner)\n+                .kind(Interner)\n             {\n                 TyKind::Scalar(_) | TyKind::Str => lhs_ty,\n                 TyKind::InferenceVar(_, TyVariableKind::Integer | TyVariableKind::Float) => lhs_ty,\n@@ -1264,7 +1264,7 @@ impl<'a> InferenceContext<'a> {\n             BinaryOp::ArithOp(ArithOp::Shl | ArithOp::Shr) => return None,\n             BinaryOp::CmpOp(CmpOp::Ord { .. })\n             | BinaryOp::Assignment { op: Some(_) }\n-            | BinaryOp::ArithOp(_) => match self.resolve_ty_shallow(&lhs_ty).kind(&Interner) {\n+            | BinaryOp::ArithOp(_) => match self.resolve_ty_shallow(&lhs_ty).kind(Interner) {\n                 TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_) | Scalar::Float(_)) => lhs_ty,\n                 TyKind::InferenceVar(_, TyVariableKind::Integer | TyVariableKind::Float) => lhs_ty,\n                 _ => return None,"}, {"sha": "64e72abf0f3fd483d3fc1cbd939698e3b538ded3", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -35,7 +35,7 @@ impl<'a> InferenceContext<'a> {\n         self.unify(&ty, expected);\n \n         let substs =\n-            ty.as_adt().map(|(_, s)| s.clone()).unwrap_or_else(|| Substitution::empty(&Interner));\n+            ty.as_adt().map(|(_, s)| s.clone()).unwrap_or_else(|| Substitution::empty(Interner));\n \n         let field_tys = def.map(|it| self.db.field_types(it)).unwrap_or_default();\n         let (pre, post) = match ellipsis {\n@@ -51,7 +51,7 @@ impl<'a> InferenceContext<'a> {\n                 .as_ref()\n                 .and_then(|d| d.field(&Name::new_tuple_field(i)))\n                 .map_or(self.err_ty(), |field| {\n-                    field_tys[field].clone().substitute(&Interner, &substs)\n+                    field_tys[field].clone().substitute(Interner, &substs)\n                 });\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat, &expected_ty, default_bm);\n@@ -77,13 +77,13 @@ impl<'a> InferenceContext<'a> {\n         self.unify(&ty, expected);\n \n         let substs =\n-            ty.as_adt().map(|(_, s)| s.clone()).unwrap_or_else(|| Substitution::empty(&Interner));\n+            ty.as_adt().map(|(_, s)| s.clone()).unwrap_or_else(|| Substitution::empty(Interner));\n \n         let field_tys = def.map(|it| self.db.field_types(it)).unwrap_or_default();\n         for subpat in subpats {\n             let matching_field = var_data.as_ref().and_then(|it| it.field(&subpat.name));\n             let expected_ty = matching_field.map_or(self.err_ty(), |field| {\n-                field_tys[field].clone().substitute(&Interner, &substs)\n+                field_tys[field].clone().substitute(Interner, &substs)\n             });\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat.pat, &expected_ty, default_bm);\n@@ -134,7 +134,7 @@ impl<'a> InferenceContext<'a> {\n         let ty = match &body[pat] {\n             Pat::Tuple { args, ellipsis } => {\n                 let expectations = match expected.as_tuple() {\n-                    Some(parameters) => &*parameters.as_slice(&Interner),\n+                    Some(parameters) => &*parameters.as_slice(Interner),\n                     _ => &[],\n                 };\n \n@@ -146,16 +146,16 @@ impl<'a> InferenceContext<'a> {\n                 };\n                 let err_ty = self.err_ty();\n                 let mut expectations_iter =\n-                    expectations.iter().map(|a| a.assert_ty_ref(&Interner)).chain(repeat(&err_ty));\n+                    expectations.iter().map(|a| a.assert_ty_ref(Interner)).chain(repeat(&err_ty));\n                 let mut infer_pat = |(&pat, ty)| self.infer_pat(pat, ty, default_bm);\n \n                 let mut inner_tys = Vec::with_capacity(n_uncovered_patterns + args.len());\n                 inner_tys.extend(pre.iter().zip(expectations_iter.by_ref()).map(&mut infer_pat));\n                 inner_tys.extend(expectations_iter.by_ref().take(n_uncovered_patterns).cloned());\n                 inner_tys.extend(post.iter().zip(expectations_iter).map(infer_pat));\n \n-                TyKind::Tuple(inner_tys.len(), Substitution::from_iter(&Interner, inner_tys))\n-                    .intern(&Interner)\n+                TyKind::Tuple(inner_tys.len(), Substitution::from_iter(Interner, inner_tys))\n+                    .intern(Interner)\n             }\n             Pat::Or(pats) => {\n                 if let Some((first_pat, rest)) = pats.split_first() {\n@@ -180,7 +180,7 @@ impl<'a> InferenceContext<'a> {\n                     _ => self.result.standard_types.unknown.clone(),\n                 };\n                 let subty = self.infer_pat(*pat, &expectation, default_bm);\n-                TyKind::Ref(mutability, static_lifetime(), subty).intern(&Interner)\n+                TyKind::Ref(mutability, static_lifetime(), subty).intern(Interner)\n             }\n             Pat::TupleStruct { path: p, args: subpats, ellipsis } => self.infer_tuple_struct_pat(\n                 p.as_deref(),\n@@ -213,15 +213,15 @@ impl<'a> InferenceContext<'a> {\n                 let bound_ty = match mode {\n                     BindingMode::Ref(mutability) => {\n                         TyKind::Ref(mutability, static_lifetime(), inner_ty.clone())\n-                            .intern(&Interner)\n+                            .intern(Interner)\n                     }\n                     BindingMode::Move => inner_ty.clone(),\n                 };\n                 self.write_pat_ty(pat, bound_ty);\n                 return inner_ty;\n             }\n             Pat::Slice { prefix, slice, suffix } => {\n-                let elem_ty = match expected.kind(&Interner) {\n+                let elem_ty = match expected.kind(Interner) {\n                     TyKind::Array(st, _) | TyKind::Slice(st) => st.clone(),\n                     _ => self.err_ty(),\n                 };\n@@ -230,11 +230,11 @@ impl<'a> InferenceContext<'a> {\n                     self.infer_pat(pat_id, &elem_ty, default_bm);\n                 }\n \n-                let pat_ty = match expected.kind(&Interner) {\n+                let pat_ty = match expected.kind(Interner) {\n                     TyKind::Array(_, const_) => TyKind::Array(elem_ty, const_.clone()),\n                     _ => TyKind::Slice(elem_ty),\n                 }\n-                .intern(&Interner);\n+                .intern(Interner);\n                 if let &Some(slice_pat_id) = slice {\n                     self.infer_pat(slice_pat_id, &pat_ty, default_bm);\n                 }\n@@ -251,8 +251,8 @@ impl<'a> InferenceContext<'a> {\n                 Some(box_adt) => {\n                     let (inner_ty, alloc_ty) = match expected.as_adt() {\n                         Some((adt, subst)) if adt == box_adt => (\n-                            subst.at(&Interner, 0).assert_ty_ref(&Interner).clone(),\n-                            subst.as_slice(&Interner).get(1).and_then(|a| a.ty(&Interner).cloned()),\n+                            subst.at(Interner, 0).assert_ty_ref(Interner).clone(),\n+                            subst.as_slice(Interner).get(1).and_then(|a| a.ty(Interner).cloned()),\n                         ),\n                         _ => (self.result.standard_types.unknown.clone(), None),\n                     };"}, {"sha": "c33a697f05af40b9606c533604d0ae4c2f409152", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -83,9 +83,9 @@ impl<'a> InferenceContext<'a> {\n             ValueNs::ImplSelf(impl_id) => {\n                 let generics = crate::utils::generics(self.db.upcast(), impl_id.into());\n                 let substs = generics.type_params_subst(self.db);\n-                let ty = self.db.impl_self_ty(impl_id).substitute(&Interner, &substs);\n+                let ty = self.db.impl_self_ty(impl_id).substitute(Interner, &substs);\n                 if let Some((AdtId::StructId(struct_id), substs)) = ty.as_adt() {\n-                    let ty = self.db.value_ty(struct_id.into()).substitute(&Interner, &substs);\n+                    let ty = self.db.value_ty(struct_id.into()).substitute(Interner, &substs);\n                     return Some(ty);\n                 } else {\n                     // FIXME: diagnostic, invalid Self reference\n@@ -95,12 +95,12 @@ impl<'a> InferenceContext<'a> {\n             ValueNs::GenericParam(it) => return Some(self.db.const_param_ty(it)),\n         };\n \n-        let parent_substs = self_subst.unwrap_or_else(|| Substitution::empty(&Interner));\n+        let parent_substs = self_subst.unwrap_or_else(|| Substitution::empty(Interner));\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         let substs = ctx.substs_from_path(path, typable, true);\n         let ty = TyBuilder::value_ty(self.db, typable)\n             .use_parent_substs(&parent_substs)\n-            .fill(substs.as_slice(&Interner)[parent_substs.len(&Interner)..].iter().cloned())\n+            .fill(substs.as_slice(Interner)[parent_substs.len(Interner)..].iter().cloned())\n             .build();\n         Some(ty)\n     }\n@@ -144,7 +144,7 @@ impl<'a> InferenceContext<'a> {\n                     remaining_segments_for_ty,\n                     true,\n                 );\n-                if let TyKind::Error = ty.kind(&Interner) {\n+                if let TyKind::Error = ty.kind(Interner) {\n                     return None;\n                 }\n \n@@ -209,7 +209,7 @@ impl<'a> InferenceContext<'a> {\n         name: &Name,\n         id: ExprOrPatId,\n     ) -> Option<(ValueNs, Option<Substitution>)> {\n-        if let TyKind::Error = ty.kind(&Interner) {\n+        if let TyKind::Error = ty.kind(Interner) {\n             return None;\n         }\n \n@@ -246,7 +246,7 @@ impl<'a> InferenceContext<'a> {\n                             .fill(iter::repeat_with(|| self.table.new_type_var()))\n                             .build();\n                         let impl_self_ty =\n-                            self.db.impl_self_ty(impl_id).substitute(&Interner, &impl_substs);\n+                            self.db.impl_self_ty(impl_id).substitute(Interner, &impl_substs);\n                         self.unify(&impl_self_ty, &ty);\n                         Some(impl_substs)\n                     }\n@@ -256,7 +256,7 @@ impl<'a> InferenceContext<'a> {\n                             .push(ty.clone())\n                             .fill(std::iter::repeat_with(|| self.table.new_type_var()))\n                             .build();\n-                        self.push_obligation(trait_ref.clone().cast(&Interner));\n+                        self.push_obligation(trait_ref.clone().cast(Interner));\n                         Some(trait_ref.substitution)\n                     }\n                     ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => None,"}, {"sha": "bb7cdb677e3792ed92e00ffb4d9f352188d18252", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 65, "deletions": 66, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -44,10 +44,10 @@ impl<T: HasInterner<Interner = Interner>> Canonicalized<T> {\n     /// this method is wrong and shouldn't exist\n     pub(super) fn decanonicalize_ty(&self, table: &mut InferenceTable, ty: Canonical<Ty>) -> Ty {\n         let mut vars = self.free_vars.clone();\n-        while ty.binders.len(&Interner) > vars.len() {\n-            vars.push(table.new_type_var().cast(&Interner));\n+        while ty.binders.len(Interner) > vars.len() {\n+            vars.push(table.new_type_var().cast(Interner));\n         }\n-        chalk_ir::Substitute::apply(&vars, ty.value, &Interner)\n+        chalk_ir::Substitute::apply(&vars, ty.value, Interner)\n     }\n \n     pub(super) fn apply_solution(\n@@ -57,25 +57,25 @@ impl<T: HasInterner<Interner = Interner>> Canonicalized<T> {\n     ) {\n         // the solution may contain new variables, which we need to convert to new inference vars\n         let new_vars = Substitution::from_iter(\n-            &Interner,\n-            solution.binders.iter(&Interner).map(|k| match k.kind {\n-                VariableKind::Ty(TyVariableKind::General) => ctx.new_type_var().cast(&Interner),\n-                VariableKind::Ty(TyVariableKind::Integer) => ctx.new_integer_var().cast(&Interner),\n-                VariableKind::Ty(TyVariableKind::Float) => ctx.new_float_var().cast(&Interner),\n+            Interner,\n+            solution.binders.iter(Interner).map(|k| match k.kind {\n+                VariableKind::Ty(TyVariableKind::General) => ctx.new_type_var().cast(Interner),\n+                VariableKind::Ty(TyVariableKind::Integer) => ctx.new_integer_var().cast(Interner),\n+                VariableKind::Ty(TyVariableKind::Float) => ctx.new_float_var().cast(Interner),\n                 // Chalk can sometimes return new lifetime variables. We just use the static lifetime everywhere\n-                VariableKind::Lifetime => static_lifetime().cast(&Interner),\n+                VariableKind::Lifetime => static_lifetime().cast(Interner),\n                 _ => panic!(\"const variable in solution\"),\n             }),\n         );\n-        for (i, v) in solution.value.iter(&Interner).enumerate() {\n+        for (i, v) in solution.value.iter(Interner).enumerate() {\n             let var = self.free_vars[i].clone();\n-            if let Some(ty) = v.ty(&Interner) {\n+            if let Some(ty) = v.ty(Interner) {\n                 // eagerly replace projections in the type; we may be getting types\n                 // e.g. from where clauses where this hasn't happened yet\n-                let ty = ctx.normalize_associated_types_in(new_vars.apply(ty.clone(), &Interner));\n-                ctx.unify(var.assert_ty_ref(&Interner), &ty);\n+                let ty = ctx.normalize_associated_types_in(new_vars.apply(ty.clone(), Interner));\n+                ctx.unify(var.assert_ty_ref(Interner), &ty);\n             } else {\n-                let _ = ctx.try_unify(&var, &new_vars.apply(v.clone(), &Interner));\n+                let _ = ctx.try_unify(&var, &new_vars.apply(v.clone(), Interner));\n             }\n         }\n     }\n@@ -96,39 +96,39 @@ pub(crate) fn unify(\n ) -> Option<Substitution> {\n     let mut table = InferenceTable::new(db, env);\n     let vars = Substitution::from_iter(\n-        &Interner,\n+        Interner,\n         tys.binders\n-            .iter(&Interner)\n+            .iter(Interner)\n             // we always use type vars here because we want everything to\n             // fallback to Unknown in the end (kind of hacky, as below)\n             .map(|_| table.new_type_var()),\n     );\n-    let ty1_with_vars = vars.apply(tys.value.0.clone(), &Interner);\n-    let ty2_with_vars = vars.apply(tys.value.1.clone(), &Interner);\n+    let ty1_with_vars = vars.apply(tys.value.0.clone(), Interner);\n+    let ty2_with_vars = vars.apply(tys.value.1.clone(), Interner);\n     if !table.unify(&ty1_with_vars, &ty2_with_vars) {\n         return None;\n     }\n     // default any type vars that weren't unified back to their original bound vars\n     // (kind of hacky)\n     let find_var = |iv| {\n-        vars.iter(&Interner).position(|v| match v.interned() {\n-            chalk_ir::GenericArgData::Ty(ty) => ty.inference_var(&Interner),\n-            chalk_ir::GenericArgData::Lifetime(lt) => lt.inference_var(&Interner),\n-            chalk_ir::GenericArgData::Const(c) => c.inference_var(&Interner),\n+        vars.iter(Interner).position(|v| match v.interned() {\n+            chalk_ir::GenericArgData::Ty(ty) => ty.inference_var(Interner),\n+            chalk_ir::GenericArgData::Lifetime(lt) => lt.inference_var(Interner),\n+            chalk_ir::GenericArgData::Const(c) => c.inference_var(Interner),\n         } == Some(iv))\n     };\n     let fallback = |iv, kind, default, binder| match kind {\n         chalk_ir::VariableKind::Ty(_ty_kind) => find_var(iv)\n-            .map_or(default, |i| BoundVar::new(binder, i).to_ty(&Interner).cast(&Interner)),\n+            .map_or(default, |i| BoundVar::new(binder, i).to_ty(Interner).cast(Interner)),\n         chalk_ir::VariableKind::Lifetime => find_var(iv)\n-            .map_or(default, |i| BoundVar::new(binder, i).to_lifetime(&Interner).cast(&Interner)),\n+            .map_or(default, |i| BoundVar::new(binder, i).to_lifetime(Interner).cast(Interner)),\n         chalk_ir::VariableKind::Const(ty) => find_var(iv)\n-            .map_or(default, |i| BoundVar::new(binder, i).to_const(&Interner, ty).cast(&Interner)),\n+            .map_or(default, |i| BoundVar::new(binder, i).to_const(Interner, ty).cast(Interner)),\n     };\n     Some(Substitution::from_iter(\n-        &Interner,\n-        vars.iter(&Interner)\n-            .map(|v| table.resolve_with_fallback(v.assert_ty_ref(&Interner).clone(), &fallback)),\n+        Interner,\n+        vars.iter(Interner)\n+            .map(|v| table.resolve_with_fallback(v.assert_ty_ref(Interner).clone(), &fallback)),\n     ))\n }\n \n@@ -200,7 +200,7 @@ impl<'a> InferenceTable<'a> {\n             TyVariableKind::Integer => TyKind::Scalar(Scalar::Int(IntTy::I32)),\n             TyVariableKind::Float => TyKind::Scalar(Scalar::Float(FloatTy::F64)),\n         }\n-        .intern(&Interner)\n+        .intern(Interner)\n     }\n \n     pub(super) fn canonicalize<T: Fold<Interner> + HasInterner<Interner = Interner>>(\n@@ -210,11 +210,11 @@ impl<'a> InferenceTable<'a> {\n     where\n         T::Result: HasInterner<Interner = Interner>,\n     {\n-        let result = self.var_unification_table.canonicalize(&Interner, t);\n+        let result = self.var_unification_table.canonicalize(Interner, t);\n         let free_vars = result\n             .free_vars\n             .into_iter()\n-            .map(|free_var| free_var.to_generic_arg(&Interner))\n+            .map(|free_var| free_var.to_generic_arg(Interner))\n             .collect();\n         Canonicalized { value: result.quantified, free_vars }\n     }\n@@ -228,7 +228,7 @@ impl<'a> InferenceTable<'a> {\n     pub(super) fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n         fold_tys(\n             ty,\n-            |ty, _| match ty.kind(&Interner) {\n+            |ty, _| match ty.kind(Interner) {\n                 TyKind::Alias(AliasTy::Projection(proj_ty)) => {\n                     self.normalize_projection_ty(proj_ty.clone())\n                 }\n@@ -241,7 +241,7 @@ impl<'a> InferenceTable<'a> {\n     pub(super) fn normalize_projection_ty(&mut self, proj_ty: ProjectionTy) -> Ty {\n         let var = self.new_type_var();\n         let alias_eq = AliasEq { alias: AliasTy::Projection(proj_ty), ty: var.clone() };\n-        let obligation = alias_eq.cast(&Interner);\n+        let obligation = alias_eq.cast(Interner);\n         self.register_obligation(obligation);\n         var\n     }\n@@ -259,7 +259,7 @@ impl<'a> InferenceTable<'a> {\n         self.extend_type_variable_table(var.index() as usize);\n         assert_eq!(var.index() as usize, self.type_variable_table.len() - 1);\n         self.type_variable_table[var.index() as usize].diverging = diverging;\n-        var.to_ty_with_kind(&Interner, kind)\n+        var.to_ty_with_kind(Interner, kind)\n     }\n \n     pub(crate) fn new_type_var(&mut self) -> Ty {\n@@ -280,12 +280,12 @@ impl<'a> InferenceTable<'a> {\n \n     pub(crate) fn new_const_var(&mut self, ty: Ty) -> Const {\n         let var = self.var_unification_table.new_variable(UniverseIndex::ROOT);\n-        var.to_const(&Interner, ty)\n+        var.to_const(Interner, ty)\n     }\n \n     pub(crate) fn new_lifetime_var(&mut self) -> Lifetime {\n         let var = self.var_unification_table.new_variable(UniverseIndex::ROOT);\n-        var.to_lifetime(&Interner)\n+        var.to_lifetime(Interner)\n     }\n \n     pub(crate) fn resolve_with_fallback<T>(\n@@ -336,7 +336,7 @@ impl<'a> InferenceTable<'a> {\n     /// caller needs to deal with them.\n     pub(crate) fn try_unify<T: Zip<Interner>>(&mut self, t1: &T, t2: &T) -> InferResult<()> {\n         match self.var_unification_table.relate(\n-            &Interner,\n+            Interner,\n             &self.db,\n             &self.trait_env.env,\n             chalk_ir::Variance::Invariant,\n@@ -351,7 +351,7 @@ impl<'a> InferenceTable<'a> {\n     /// If `ty` is a type variable with known type, returns that type;\n     /// otherwise, return ty.\n     pub(crate) fn resolve_ty_shallow(&mut self, ty: &Ty) -> Ty {\n-        self.var_unification_table.normalize_ty_shallow(&Interner, ty).unwrap_or_else(|| ty.clone())\n+        self.var_unification_table.normalize_ty_shallow(Interner, ty).unwrap_or_else(|| ty.clone())\n     }\n \n     pub(crate) fn snapshot(&mut self) -> InferenceTableSnapshot {\n@@ -395,7 +395,7 @@ impl<'a> InferenceTable<'a> {\n                 let uncanonical = chalk_ir::Substitute::apply(\n                     &canonicalized.free_vars,\n                     canonicalized.value.value,\n-                    &Interner,\n+                    Interner,\n                 );\n                 self.register_obligation_in_env(uncanonical);\n             }\n@@ -411,15 +411,15 @@ impl<'a> InferenceTable<'a> {\n             table: &'a mut InferenceTable<'b>,\n             highest_known_var: InferenceVar,\n         }\n-        impl<'a, 'b> Folder<'static, Interner> for VarFudger<'a, 'b> {\n+        impl<'a, 'b> Folder<Interner> for VarFudger<'a, 'b> {\n             type Error = NoSolution;\n \n-            fn as_dyn(&mut self) -> &mut dyn Folder<'static, Interner, Error = Self::Error> {\n+            fn as_dyn(&mut self) -> &mut dyn Folder<Interner, Error = Self::Error> {\n                 self\n             }\n \n-            fn interner(&self) -> &'static Interner {\n-                &Interner\n+            fn interner(&self) -> Interner {\n+                Interner\n             }\n \n             fn fold_inference_ty(\n@@ -429,7 +429,7 @@ impl<'a> InferenceTable<'a> {\n                 _outer_binder: chalk_ir::DebruijnIndex,\n             ) -> chalk_ir::Fallible<chalk_ir::Ty<Interner>> {\n                 Ok(if var < self.highest_known_var {\n-                    var.to_ty(&Interner, kind)\n+                    var.to_ty(Interner, kind)\n                 } else {\n                     self.table.new_type_var()\n                 })\n@@ -441,7 +441,7 @@ impl<'a> InferenceTable<'a> {\n                 _outer_binder: chalk_ir::DebruijnIndex,\n             ) -> chalk_ir::Fallible<chalk_ir::Lifetime<Interner>> {\n                 Ok(if var < self.highest_known_var {\n-                    var.to_lifetime(&Interner)\n+                    var.to_lifetime(Interner)\n                 } else {\n                     self.table.new_lifetime_var()\n                 })\n@@ -454,16 +454,15 @@ impl<'a> InferenceTable<'a> {\n                 _outer_binder: chalk_ir::DebruijnIndex,\n             ) -> chalk_ir::Fallible<chalk_ir::Const<Interner>> {\n                 Ok(if var < self.highest_known_var {\n-                    var.to_const(&Interner, ty)\n+                    var.to_const(Interner, ty)\n                 } else {\n                     self.table.new_const_var(ty)\n                 })\n             }\n         }\n \n         let snapshot = self.snapshot();\n-        let highest_known_var =\n-            self.new_type_var().inference_var(&Interner).expect(\"inference_var\");\n+        let highest_known_var = self.new_type_var().inference_var(Interner).expect(\"inference_var\");\n         let result = f(self);\n         self.rollback_to(snapshot);\n         result\n@@ -477,10 +476,10 @@ impl<'a> InferenceTable<'a> {\n     /// again -- it'll give the same result as last time.\n     fn check_changed(&mut self, canonicalized: &Canonicalized<InEnvironment<Goal>>) -> bool {\n         canonicalized.free_vars.iter().any(|var| {\n-            let iv = match var.data(&Interner) {\n-                chalk_ir::GenericArgData::Ty(ty) => ty.inference_var(&Interner),\n-                chalk_ir::GenericArgData::Lifetime(lt) => lt.inference_var(&Interner),\n-                chalk_ir::GenericArgData::Const(c) => c.inference_var(&Interner),\n+            let iv = match var.data(Interner) {\n+                chalk_ir::GenericArgData::Ty(ty) => ty.inference_var(Interner),\n+                chalk_ir::GenericArgData::Lifetime(lt) => lt.inference_var(Interner),\n+                chalk_ir::GenericArgData::Const(c) => c.inference_var(Interner),\n             }\n             .expect(\"free var is not inference var\");\n             if self.var_unification_table.probe_var(iv).is_some() {\n@@ -549,18 +548,18 @@ mod resolve {\n         pub(super) var_stack: &'a mut Vec<InferenceVar>,\n         pub(super) fallback: F,\n     }\n-    impl<'a, 'b, 'i, F> Folder<'i, Interner> for Resolver<'a, 'b, F>\n+    impl<'a, 'b, 'i, F> Folder<Interner> for Resolver<'a, 'b, F>\n     where\n         F: Fn(InferenceVar, VariableKind, GenericArg, DebruijnIndex) -> GenericArg + 'i,\n     {\n         type Error = NoSolution;\n \n-        fn as_dyn(&mut self) -> &mut dyn Folder<'i, Interner, Error = Self::Error> {\n+        fn as_dyn(&mut self) -> &mut dyn Folder<Interner, Error = Self::Error> {\n             self\n         }\n \n-        fn interner(&self) -> &'i Interner {\n-            &Interner\n+        fn interner(&self) -> Interner {\n+            Interner\n         }\n \n         fn fold_inference_ty(\n@@ -572,9 +571,9 @@ mod resolve {\n             let var = self.table.var_unification_table.inference_var_root(var);\n             if self.var_stack.contains(&var) {\n                 // recursive type\n-                let default = self.table.fallback_value(var, kind).cast(&Interner);\n+                let default = self.table.fallback_value(var, kind).cast(Interner);\n                 return Ok((self.fallback)(var, VariableKind::Ty(kind), default, outer_binder)\n-                    .assert_ty_ref(&Interner)\n+                    .assert_ty_ref(Interner)\n                     .clone());\n             }\n             let result = if let Some(known_ty) = self.table.var_unification_table.probe_var(var) {\n@@ -583,11 +582,11 @@ mod resolve {\n                 let result =\n                     known_ty.fold_with(self, outer_binder).expect(\"fold failed unexpectedly\");\n                 self.var_stack.pop();\n-                result.assert_ty_ref(&Interner).clone()\n+                result.assert_ty_ref(Interner).clone()\n             } else {\n-                let default = self.table.fallback_value(var, kind).cast(&Interner);\n+                let default = self.table.fallback_value(var, kind).cast(Interner);\n                 (self.fallback)(var, VariableKind::Ty(kind), default, outer_binder)\n-                    .assert_ty_ref(&Interner)\n+                    .assert_ty_ref(Interner)\n                     .clone()\n             };\n             Ok(result)\n@@ -604,12 +603,12 @@ mod resolve {\n                 ty: ty.clone(),\n                 value: ConstValue::Concrete(ConcreteConst { interned: ConstScalar::Unknown }),\n             }\n-            .intern(&Interner)\n-            .cast(&Interner);\n+            .intern(Interner)\n+            .cast(Interner);\n             if self.var_stack.contains(&var) {\n                 // recursive\n                 return Ok((self.fallback)(var, VariableKind::Const(ty), default, outer_binder)\n-                    .assert_const_ref(&Interner)\n+                    .assert_const_ref(Interner)\n                     .clone());\n             }\n             let result = if let Some(known_ty) = self.table.var_unification_table.probe_var(var) {\n@@ -618,10 +617,10 @@ mod resolve {\n                 let result =\n                     known_ty.fold_with(self, outer_binder).expect(\"fold failed unexpectedly\");\n                 self.var_stack.pop();\n-                result.assert_const_ref(&Interner).clone()\n+                result.assert_const_ref(Interner).clone()\n             } else {\n                 (self.fallback)(var, VariableKind::Const(ty), default, outer_binder)\n-                    .assert_const_ref(&Interner)\n+                    .assert_const_ref(Interner)\n                     .clone()\n             };\n             Ok(result)"}, {"sha": "07197d8a190e47d5c9592298ef18a87b008b18af", "filename": "crates/hir_ty/src/interner.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finterner.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -124,54 +124,54 @@ impl chalk_ir::interner::Interner for Interner {\n     }\n \n     fn debug_ty(ty: &chalk_ir::Ty<Interner>, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"{:?}\", ty.data(&Interner)))\n+        Some(write!(fmt, \"{:?}\", ty.data(Interner)))\n     }\n \n     fn debug_lifetime(\n         lifetime: &chalk_ir::Lifetime<Interner>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"{:?}\", lifetime.data(&Interner)))\n+        Some(write!(fmt, \"{:?}\", lifetime.data(Interner)))\n     }\n \n     fn debug_generic_arg(\n         parameter: &GenericArg,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"{:?}\", parameter.data(&Interner).inner_debug()))\n+        Some(write!(fmt, \"{:?}\", parameter.data(Interner).inner_debug()))\n     }\n \n     fn debug_goal(goal: &Goal<Interner>, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n-        let goal_data = goal.data(&Interner);\n+        let goal_data = goal.data(Interner);\n         Some(write!(fmt, \"{:?}\", goal_data))\n     }\n \n     fn debug_goals(\n         goals: &chalk_ir::Goals<Interner>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"{:?}\", goals.debug(&Interner)))\n+        Some(write!(fmt, \"{:?}\", goals.debug(Interner)))\n     }\n \n     fn debug_program_clause_implication(\n         pci: &chalk_ir::ProgramClauseImplication<Interner>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"{:?}\", pci.debug(&Interner)))\n+        Some(write!(fmt, \"{:?}\", pci.debug(Interner)))\n     }\n \n     fn debug_substitution(\n         substitution: &chalk_ir::Substitution<Interner>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"{:?}\", substitution.debug(&Interner)))\n+        Some(write!(fmt, \"{:?}\", substitution.debug(Interner)))\n     }\n \n     fn debug_separator_trait_ref(\n         separator_trait_ref: &chalk_ir::SeparatorTraitRef<Interner>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"{:?}\", separator_trait_ref.debug(&Interner)))\n+        Some(write!(fmt, \"{:?}\", separator_trait_ref.debug(Interner)))\n     }\n \n     fn debug_fn_def_id(\n@@ -184,75 +184,75 @@ impl chalk_ir::interner::Interner for Interner {\n         constant: &chalk_ir::Const<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"{:?}\", constant.data(&Interner)))\n+        Some(write!(fmt, \"{:?}\", constant.data(Interner)))\n     }\n     fn debug_variable_kinds(\n         variable_kinds: &chalk_ir::VariableKinds<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"{:?}\", variable_kinds.as_slice(&Interner)))\n+        Some(write!(fmt, \"{:?}\", variable_kinds.as_slice(Interner)))\n     }\n     fn debug_variable_kinds_with_angles(\n         variable_kinds: &chalk_ir::VariableKinds<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"{:?}\", variable_kinds.inner_debug(&Interner)))\n+        Some(write!(fmt, \"{:?}\", variable_kinds.inner_debug(Interner)))\n     }\n     fn debug_canonical_var_kinds(\n         canonical_var_kinds: &chalk_ir::CanonicalVarKinds<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"{:?}\", canonical_var_kinds.as_slice(&Interner)))\n+        Some(write!(fmt, \"{:?}\", canonical_var_kinds.as_slice(Interner)))\n     }\n     fn debug_program_clause(\n         clause: &chalk_ir::ProgramClause<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"{:?}\", clause.data(&Interner)))\n+        Some(write!(fmt, \"{:?}\", clause.data(Interner)))\n     }\n     fn debug_program_clauses(\n         clauses: &chalk_ir::ProgramClauses<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"{:?}\", clauses.as_slice(&Interner)))\n+        Some(write!(fmt, \"{:?}\", clauses.as_slice(Interner)))\n     }\n     fn debug_quantified_where_clauses(\n         clauses: &chalk_ir::QuantifiedWhereClauses<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"{:?}\", clauses.as_slice(&Interner)))\n+        Some(write!(fmt, \"{:?}\", clauses.as_slice(Interner)))\n     }\n \n-    fn intern_ty(&self, kind: chalk_ir::TyKind<Self>) -> Self::InternedType {\n+    fn intern_ty(self, kind: chalk_ir::TyKind<Self>) -> Self::InternedType {\n         let flags = kind.compute_flags(self);\n         Interned::new(InternedWrapper(chalk_ir::TyData { kind, flags }))\n     }\n \n-    fn ty_data<'a>(&self, ty: &'a Self::InternedType) -> &'a chalk_ir::TyData<Self> {\n+    fn ty_data<'a>(self, ty: &'a Self::InternedType) -> &'a chalk_ir::TyData<Self> {\n         &ty.0\n     }\n \n-    fn intern_lifetime(&self, lifetime: chalk_ir::LifetimeData<Self>) -> Self::InternedLifetime {\n+    fn intern_lifetime(self, lifetime: chalk_ir::LifetimeData<Self>) -> Self::InternedLifetime {\n         Interned::new(InternedWrapper(lifetime))\n     }\n \n     fn lifetime_data<'a>(\n-        &self,\n+        self,\n         lifetime: &'a Self::InternedLifetime,\n     ) -> &'a chalk_ir::LifetimeData<Self> {\n         &lifetime.0\n     }\n \n-    fn intern_const(&self, constant: chalk_ir::ConstData<Self>) -> Self::InternedConst {\n+    fn intern_const(self, constant: chalk_ir::ConstData<Self>) -> Self::InternedConst {\n         Interned::new(InternedWrapper(constant))\n     }\n \n-    fn const_data<'a>(&self, constant: &'a Self::InternedConst) -> &'a chalk_ir::ConstData<Self> {\n+    fn const_data<'a>(self, constant: &'a Self::InternedConst) -> &'a chalk_ir::ConstData<Self> {\n         &constant.0\n     }\n \n     fn const_eq(\n-        &self,\n+        self,\n         _ty: &Self::InternedType,\n         c1: &Self::InternedConcreteConst,\n         c2: &Self::InternedConcreteConst,\n@@ -266,131 +266,131 @@ impl chalk_ir::interner::Interner for Interner {\n     }\n \n     fn intern_generic_arg(\n-        &self,\n+        self,\n         parameter: chalk_ir::GenericArgData<Self>,\n     ) -> Self::InternedGenericArg {\n         parameter\n     }\n \n     fn generic_arg_data<'a>(\n-        &self,\n+        self,\n         parameter: &'a Self::InternedGenericArg,\n     ) -> &'a chalk_ir::GenericArgData<Self> {\n         parameter\n     }\n \n-    fn intern_goal(&self, goal: GoalData<Self>) -> Self::InternedGoal {\n+    fn intern_goal(self, goal: GoalData<Self>) -> Self::InternedGoal {\n         Arc::new(goal)\n     }\n \n     fn intern_goals<E>(\n-        &self,\n+        self,\n         data: impl IntoIterator<Item = Result<Goal<Self>, E>>,\n     ) -> Result<Self::InternedGoals, E> {\n         data.into_iter().collect()\n     }\n \n-    fn goal_data<'a>(&self, goal: &'a Self::InternedGoal) -> &'a GoalData<Self> {\n+    fn goal_data<'a>(self, goal: &'a Self::InternedGoal) -> &'a GoalData<Self> {\n         goal\n     }\n \n-    fn goals_data<'a>(&self, goals: &'a Self::InternedGoals) -> &'a [Goal<Interner>] {\n+    fn goals_data<'a>(self, goals: &'a Self::InternedGoals) -> &'a [Goal<Interner>] {\n         goals\n     }\n \n     fn intern_substitution<E>(\n-        &self,\n+        self,\n         data: impl IntoIterator<Item = Result<GenericArg, E>>,\n     ) -> Result<Self::InternedSubstitution, E> {\n         Ok(Interned::new(InternedWrapper(data.into_iter().collect::<Result<_, _>>()?)))\n     }\n \n     fn substitution_data<'a>(\n-        &self,\n+        self,\n         substitution: &'a Self::InternedSubstitution,\n     ) -> &'a [GenericArg] {\n         &substitution.as_ref().0\n     }\n \n     fn intern_program_clause(\n-        &self,\n+        self,\n         data: chalk_ir::ProgramClauseData<Self>,\n     ) -> Self::InternedProgramClause {\n         data\n     }\n \n     fn program_clause_data<'a>(\n-        &self,\n+        self,\n         clause: &'a Self::InternedProgramClause,\n     ) -> &'a chalk_ir::ProgramClauseData<Self> {\n         clause\n     }\n \n     fn intern_program_clauses<E>(\n-        &self,\n+        self,\n         data: impl IntoIterator<Item = Result<chalk_ir::ProgramClause<Self>, E>>,\n     ) -> Result<Self::InternedProgramClauses, E> {\n         Ok(Interned::new(InternedWrapper(data.into_iter().collect::<Result<_, _>>()?)))\n     }\n \n     fn program_clauses_data<'a>(\n-        &self,\n+        self,\n         clauses: &'a Self::InternedProgramClauses,\n     ) -> &'a [chalk_ir::ProgramClause<Self>] {\n         clauses\n     }\n \n     fn intern_quantified_where_clauses<E>(\n-        &self,\n+        self,\n         data: impl IntoIterator<Item = Result<chalk_ir::QuantifiedWhereClause<Self>, E>>,\n     ) -> Result<Self::InternedQuantifiedWhereClauses, E> {\n         Ok(Interned::new(InternedWrapper(data.into_iter().collect::<Result<_, _>>()?)))\n     }\n \n     fn quantified_where_clauses_data<'a>(\n-        &self,\n+        self,\n         clauses: &'a Self::InternedQuantifiedWhereClauses,\n     ) -> &'a [chalk_ir::QuantifiedWhereClause<Self>] {\n         clauses\n     }\n \n     fn intern_generic_arg_kinds<E>(\n-        &self,\n+        self,\n         data: impl IntoIterator<Item = Result<chalk_ir::VariableKind<Self>, E>>,\n     ) -> Result<Self::InternedVariableKinds, E> {\n         Ok(Interned::new(InternedWrapper(data.into_iter().collect::<Result<_, _>>()?)))\n     }\n \n     fn variable_kinds_data<'a>(\n-        &self,\n+        self,\n         parameter_kinds: &'a Self::InternedVariableKinds,\n     ) -> &'a [chalk_ir::VariableKind<Self>] {\n         &parameter_kinds.as_ref().0\n     }\n \n     fn intern_canonical_var_kinds<E>(\n-        &self,\n+        self,\n         data: impl IntoIterator<Item = Result<chalk_ir::CanonicalVarKind<Self>, E>>,\n     ) -> Result<Self::InternedCanonicalVarKinds, E> {\n         Ok(Interned::new(InternedWrapper(data.into_iter().collect::<Result<_, _>>()?)))\n     }\n \n     fn canonical_var_kinds_data<'a>(\n-        &self,\n+        self,\n         canonical_var_kinds: &'a Self::InternedCanonicalVarKinds,\n     ) -> &'a [chalk_ir::CanonicalVarKind<Self>] {\n         canonical_var_kinds\n     }\n \n     fn intern_constraints<E>(\n-        &self,\n+        self,\n         data: impl IntoIterator<Item = Result<chalk_ir::InEnvironment<chalk_ir::Constraint<Self>>, E>>,\n     ) -> Result<Self::InternedConstraints, E> {\n         data.into_iter().collect()\n     }\n \n     fn constraints_data<'a>(\n-        &self,\n+        self,\n         constraints: &'a Self::InternedConstraints,\n     ) -> &'a [chalk_ir::InEnvironment<chalk_ir::Constraint<Self>>] {\n         constraints\n@@ -409,14 +409,14 @@ impl chalk_ir::interner::Interner for Interner {\n     }\n \n     fn intern_variances<E>(\n-        &self,\n+        self,\n         data: impl IntoIterator<Item = Result<chalk_ir::Variance, E>>,\n     ) -> Result<Self::InternedVariances, E> {\n         Ok(Interned::new(InternedWrapper(data.into_iter().collect::<Result<_, _>>()?)))\n     }\n \n     fn variances_data<'a>(\n-        &self,\n+        self,\n         variances: &'a Self::InternedVariances,\n     ) -> &'a [chalk_ir::Variance] {\n         variances"}, {"sha": "1950820a37272a363a698933ff6d3354f2c43500", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -123,8 +123,8 @@ pub type WhereClause = chalk_ir::WhereClause<Interner>;\n // FIXME: get rid of this\n pub fn subst_prefix(s: &Substitution, n: usize) -> Substitution {\n     Substitution::from_iter(\n-        &Interner,\n-        s.as_slice(&Interner)[..std::cmp::min(s.len(&Interner), n)].iter().cloned(),\n+        Interner,\n+        s.as_slice(Interner)[..std::cmp::min(s.len(Interner), n)].iter().cloned(),\n     )\n }\n \n@@ -137,7 +137,7 @@ pub(crate) fn wrap_empty_binders<T>(value: T) -> Binders<T>\n where\n     T: Fold<Interner, Result = T> + HasInterner<Interner = Interner>,\n {\n-    Binders::empty(&Interner, value.shifted_in_from(&Interner, DebruijnIndex::ONE))\n+    Binders::empty(Interner, value.shifted_in_from(Interner, DebruijnIndex::ONE))\n }\n \n pub(crate) fn make_only_type_binders<T: HasInterner<Interner = Interner>>(\n@@ -146,7 +146,7 @@ pub(crate) fn make_only_type_binders<T: HasInterner<Interner = Interner>>(\n ) -> Binders<T> {\n     Binders::new(\n         VariableKinds::from_iter(\n-            &Interner,\n+            Interner,\n             std::iter::repeat(chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General))\n                 .take(num_vars),\n         ),\n@@ -165,7 +165,7 @@ pub fn make_canonical<T: HasInterner<Interner = Interner>>(\n             chalk_ir::UniverseIndex::ROOT,\n         )\n     });\n-    Canonical { value, binders: chalk_ir::CanonicalVarKinds::from_iter(&Interner, kinds) }\n+    Canonical { value, binders: chalk_ir::CanonicalVarKinds::from_iter(Interner, kinds) }\n }\n \n // FIXME: get rid of this, just replace it by FnPointer\n@@ -199,12 +199,12 @@ impl CallableSig {\n             params_and_return: fn_ptr\n                 .substitution\n                 .clone()\n-                .shifted_out_to(&Interner, DebruijnIndex::ONE)\n+                .shifted_out_to(Interner, DebruijnIndex::ONE)\n                 .expect(\"unexpected lifetime vars in fn ptr\")\n                 .0\n-                .as_slice(&Interner)\n+                .as_slice(Interner)\n                 .iter()\n-                .map(|arg| arg.assert_ty_ref(&Interner).clone())\n+                .map(|arg| arg.assert_ty_ref(Interner).clone())\n                 .collect(),\n             is_varargs: fn_ptr.sig.variadic,\n             legacy_const_generics_indices: Arc::new([]),\n@@ -220,7 +220,7 @@ impl CallableSig {\n             num_binders: 0,\n             sig: FnSig { abi: (), safety: Safety::Safe, variadic: self.is_varargs },\n             substitution: FnSubst(Substitution::from_iter(\n-                &Interner,\n+                Interner,\n                 self.params_and_return.iter().cloned(),\n             )),\n         }\n@@ -238,14 +238,11 @@ impl CallableSig {\n impl Fold<Interner> for CallableSig {\n     type Result = CallableSig;\n \n-    fn fold_with<'i, E>(\n+    fn fold_with<E>(\n         self,\n-        folder: &mut dyn chalk_ir::fold::Folder<'i, Interner, Error = E>,\n+        folder: &mut dyn chalk_ir::fold::Folder<Interner, Error = E>,\n         outer_binder: DebruijnIndex,\n-    ) -> Result<Self::Result, E>\n-    where\n-        Interner: 'i,\n-    {\n+    ) -> Result<Self::Result, E> {\n         let vec = self.params_and_return.to_vec();\n         let folded = vec.fold_with(folder, outer_binder)?;\n         Ok(CallableSig {\n@@ -275,18 +272,18 @@ pub(crate) struct ReturnTypeImplTrait {\n }\n \n pub fn static_lifetime() -> Lifetime {\n-    LifetimeData::Static.intern(&Interner)\n+    LifetimeData::Static.intern(Interner)\n }\n \n pub fn dummy_usize_const() -> Const {\n-    let usize_ty = chalk_ir::TyKind::Scalar(Scalar::Uint(UintTy::Usize)).intern(&Interner);\n+    let usize_ty = chalk_ir::TyKind::Scalar(Scalar::Uint(UintTy::Usize)).intern(Interner);\n     chalk_ir::ConstData {\n         ty: usize_ty,\n         value: chalk_ir::ConstValue::Concrete(chalk_ir::ConcreteConst {\n             interned: ConstScalar::Unknown,\n         }),\n     }\n-    .intern(&Interner)\n+    .intern(Interner)\n }\n \n pub(crate) fn fold_free_vars<T: HasInterner<Interner = Interner> + Fold<Interner>>(\n@@ -295,15 +292,15 @@ pub(crate) fn fold_free_vars<T: HasInterner<Interner = Interner> + Fold<Interner\n ) -> T::Result {\n     use chalk_ir::{fold::Folder, Fallible};\n     struct FreeVarFolder<F>(F);\n-    impl<'i, F: FnMut(BoundVar, DebruijnIndex) -> Ty + 'i> Folder<'i, Interner> for FreeVarFolder<F> {\n+    impl<'i, F: FnMut(BoundVar, DebruijnIndex) -> Ty + 'i> Folder<Interner> for FreeVarFolder<F> {\n         type Error = NoSolution;\n \n-        fn as_dyn(&mut self) -> &mut dyn Folder<'i, Interner, Error = Self::Error> {\n+        fn as_dyn(&mut self) -> &mut dyn Folder<Interner, Error = Self::Error> {\n             self\n         }\n \n-        fn interner(&self) -> &'i Interner {\n-            &Interner\n+        fn interner(&self) -> Interner {\n+            Interner\n         }\n \n         fn fold_free_var_ty(\n@@ -327,15 +324,15 @@ pub(crate) fn fold_tys<T: HasInterner<Interner = Interner> + Fold<Interner>>(\n         Fallible,\n     };\n     struct TyFolder<F>(F);\n-    impl<'i, F: FnMut(Ty, DebruijnIndex) -> Ty + 'i> Folder<'i, Interner> for TyFolder<F> {\n+    impl<'i, F: FnMut(Ty, DebruijnIndex) -> Ty + 'i> Folder<Interner> for TyFolder<F> {\n         type Error = NoSolution;\n \n-        fn as_dyn(&mut self) -> &mut dyn Folder<'i, Interner, Error = Self::Error> {\n+        fn as_dyn(&mut self) -> &mut dyn Folder<Interner, Error = Self::Error> {\n             self\n         }\n \n-        fn interner(&self) -> &'i Interner {\n-            &Interner\n+        fn interner(&self) -> Interner {\n+            Interner\n         }\n \n         fn fold_ty(&mut self, ty: Ty, outer_binder: DebruijnIndex) -> Fallible<Ty> {\n@@ -361,22 +358,22 @@ where\n     struct ErrorReplacer {\n         vars: usize,\n     }\n-    impl<'i> Folder<'i, Interner> for ErrorReplacer {\n+    impl<'i> Folder<Interner> for ErrorReplacer {\n         type Error = NoSolution;\n \n-        fn as_dyn(&mut self) -> &mut dyn Folder<'i, Interner, Error = Self::Error> {\n+        fn as_dyn(&mut self) -> &mut dyn Folder<Interner, Error = Self::Error> {\n             self\n         }\n \n-        fn interner(&self) -> &'i Interner {\n-            &Interner\n+        fn interner(&self) -> Interner {\n+            Interner\n         }\n \n         fn fold_ty(&mut self, ty: Ty, outer_binder: DebruijnIndex) -> Fallible<Ty> {\n-            if let TyKind::Error = ty.kind(&Interner) {\n+            if let TyKind::Error = ty.kind(Interner) {\n                 let index = self.vars;\n                 self.vars += 1;\n-                Ok(TyKind::BoundVar(BoundVar::new(outer_binder, index)).intern(&Interner))\n+                Ok(TyKind::BoundVar(BoundVar::new(outer_binder, index)).intern(Interner))\n             } else {\n                 let ty = ty.super_fold_with(self.as_dyn(), outer_binder)?;\n                 Ok(ty)\n@@ -394,7 +391,7 @@ where\n                 // won't contain the whole thing, which would not be very helpful\n                 Err(NoSolution)\n             } else {\n-                Ok(TyKind::Error.intern(&Interner))\n+                Ok(TyKind::Error.intern(Interner))\n             }\n         }\n \n@@ -408,7 +405,7 @@ where\n                 // won't contain the whole thing, which would not be very helpful\n                 Err(NoSolution)\n             } else {\n-                Ok(TyKind::Error.intern(&Interner))\n+                Ok(TyKind::Error.intern(Interner))\n             }\n         }\n \n@@ -473,5 +470,5 @@ where\n             chalk_ir::UniverseIndex::ROOT,\n         )\n     });\n-    Canonical { value, binders: chalk_ir::CanonicalVarKinds::from_iter(&Interner, kinds) }\n+    Canonical { value, binders: chalk_ir::CanonicalVarKinds::from_iter(Interner, kinds) }\n }"}, {"sha": "a22d15dd81b6da609551340c7e50317448c5a834", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 73, "deletions": 77, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -166,11 +166,11 @@ impl<'a> TyLoweringContext<'a> {\n     pub fn lower_ty_ext(&self, type_ref: &TypeRef) -> (Ty, Option<TypeNs>) {\n         let mut res = None;\n         let ty = match type_ref {\n-            TypeRef::Never => TyKind::Never.intern(&Interner),\n+            TypeRef::Never => TyKind::Never.intern(Interner),\n             TypeRef::Tuple(inner) => {\n                 let inner_tys = inner.iter().map(|tr| self.lower_ty(tr));\n-                TyKind::Tuple(inner_tys.len(), Substitution::from_iter(&Interner, inner_tys))\n-                    .intern(&Interner)\n+                TyKind::Tuple(inner_tys.len(), Substitution::from_iter(Interner, inner_tys))\n+                    .intern(Interner)\n             }\n             TypeRef::Path(path) => {\n                 let (ty, res_) = self.lower_path(path);\n@@ -179,48 +179,48 @@ impl<'a> TyLoweringContext<'a> {\n             }\n             TypeRef::RawPtr(inner, mutability) => {\n                 let inner_ty = self.lower_ty(inner);\n-                TyKind::Raw(lower_to_chalk_mutability(*mutability), inner_ty).intern(&Interner)\n+                TyKind::Raw(lower_to_chalk_mutability(*mutability), inner_ty).intern(Interner)\n             }\n             TypeRef::Array(inner, len) => {\n                 let inner_ty = self.lower_ty(inner);\n \n                 let const_len = consteval::usize_const(len.as_usize());\n \n-                TyKind::Array(inner_ty, const_len).intern(&Interner)\n+                TyKind::Array(inner_ty, const_len).intern(Interner)\n             }\n             TypeRef::Slice(inner) => {\n                 let inner_ty = self.lower_ty(inner);\n-                TyKind::Slice(inner_ty).intern(&Interner)\n+                TyKind::Slice(inner_ty).intern(Interner)\n             }\n             TypeRef::Reference(inner, _, mutability) => {\n                 let inner_ty = self.lower_ty(inner);\n                 let lifetime = static_lifetime();\n                 TyKind::Ref(lower_to_chalk_mutability(*mutability), lifetime, inner_ty)\n-                    .intern(&Interner)\n+                    .intern(Interner)\n             }\n-            TypeRef::Placeholder => TyKind::Error.intern(&Interner),\n+            TypeRef::Placeholder => TyKind::Error.intern(Interner),\n             TypeRef::Fn(params, is_varargs) => {\n                 let substs = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n-                    Substitution::from_iter(&Interner, params.iter().map(|tr| ctx.lower_ty(tr)))\n+                    Substitution::from_iter(Interner, params.iter().map(|tr| ctx.lower_ty(tr)))\n                 });\n                 TyKind::Function(FnPointer {\n                     num_binders: 0, // FIXME lower `for<'a> fn()` correctly\n                     sig: FnSig { abi: (), safety: Safety::Safe, variadic: *is_varargs },\n                     substitution: FnSubst(substs),\n                 })\n-                .intern(&Interner)\n+                .intern(Interner)\n             }\n             TypeRef::DynTrait(bounds) => {\n                 let self_ty =\n-                    TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)).intern(&Interner);\n+                    TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)).intern(Interner);\n                 let bounds = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n                     QuantifiedWhereClauses::from_iter(\n-                        &Interner,\n+                        Interner,\n                         bounds.iter().flat_map(|b| ctx.lower_type_bound(b, self_ty.clone(), false)),\n                     )\n                 });\n                 let bounds = crate::make_only_type_binders(1, bounds);\n-                TyKind::Dyn(DynTy { bounds, lifetime: static_lifetime() }).intern(&Interner)\n+                TyKind::Dyn(DynTy { bounds, lifetime: static_lifetime() }).intern(Interner)\n             }\n             TypeRef::ImplTrait(bounds) => {\n                 match self.impl_trait_mode {\n@@ -258,7 +258,7 @@ impl<'a> TyLoweringContext<'a> {\n                         let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n                         let generics = generics(self.db.upcast(), func.into());\n                         let parameters = generics.bound_vars_subst(self.in_binders);\n-                        TyKind::OpaqueType(opaque_ty_id, parameters).intern(&Interner)\n+                        TyKind::OpaqueType(opaque_ty_id, parameters).intern(Interner)\n                     }\n                     ImplTraitLoweringMode::Param => {\n                         let idx = self.impl_trait_counter.get();\n@@ -275,9 +275,9 @@ impl<'a> TyLoweringContext<'a> {\n                                 .map_or(TyKind::Error, |(id, _)| {\n                                     TyKind::Placeholder(to_placeholder_idx(self.db, id))\n                                 });\n-                            param.intern(&Interner)\n+                            param.intern(Interner)\n                         } else {\n-                            TyKind::Error.intern(&Interner)\n+                            TyKind::Error.intern(Interner)\n                         }\n                     }\n                     ImplTraitLoweringMode::Variable => {\n@@ -295,11 +295,11 @@ impl<'a> TyLoweringContext<'a> {\n                             self.in_binders,\n                             idx as usize + parent_params + self_params + list_params,\n                         ))\n-                        .intern(&Interner)\n+                        .intern(Interner)\n                     }\n                     ImplTraitLoweringMode::Disallowed => {\n                         // FIXME: report error\n-                        TyKind::Error.intern(&Interner)\n+                        TyKind::Error.intern(Interner)\n                     }\n                 }\n             }\n@@ -343,9 +343,9 @@ impl<'a> TyLoweringContext<'a> {\n                 if recursion_start {\n                     *self.expander.borrow_mut() = None;\n                 }\n-                ty.unwrap_or_else(|| TyKind::Error.intern(&Interner))\n+                ty.unwrap_or_else(|| TyKind::Error.intern(Interner))\n             }\n-            TypeRef::Error => TyKind::Error.intern(&Interner),\n+            TypeRef::Error => TyKind::Error.intern(Interner),\n         };\n         (ty, res)\n     }\n@@ -391,7 +391,7 @@ impl<'a> TyLoweringContext<'a> {\n             }\n             _ => {\n                 // FIXME report error (ambiguous associated type)\n-                (TyKind::Error.intern(&Interner), None)\n+                (TyKind::Error.intern(Interner), None)\n             }\n         }\n     }\n@@ -421,18 +421,18 @@ impl<'a> TyLoweringContext<'a> {\n                                     associated_ty_id: to_assoc_type_id(associated_ty),\n                                     substitution: trait_ref.substitution,\n                                 }))\n-                                .intern(&Interner)\n+                                .intern(Interner)\n                             }\n                             None => {\n                                 // FIXME: report error (associated type not found)\n-                                TyKind::Error.intern(&Interner)\n+                                TyKind::Error.intern(Interner)\n                             }\n                         }\n                     }\n                     0 => {\n                         let self_ty = Some(\n                             TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0))\n-                                .intern(&Interner),\n+                                .intern(Interner),\n                         );\n                         let trait_ref = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n                             ctx.lower_trait_ref_from_resolved_path(\n@@ -445,19 +445,19 @@ impl<'a> TyLoweringContext<'a> {\n                             bounds: crate::make_only_type_binders(\n                                 1,\n                                 QuantifiedWhereClauses::from_iter(\n-                                    &Interner,\n+                                    Interner,\n                                     Some(crate::wrap_empty_binders(WhereClause::Implemented(\n                                         trait_ref,\n                                     ))),\n                                 ),\n                             ),\n                             lifetime: static_lifetime(),\n                         };\n-                        TyKind::Dyn(dyn_ty).intern(&Interner)\n+                        TyKind::Dyn(dyn_ty).intern(Interner)\n                     }\n                     _ => {\n                         // FIXME report error (ambiguous associated type)\n-                        TyKind::Error.intern(&Interner)\n+                        TyKind::Error.intern(Interner)\n                     }\n                 };\n                 return (ty, None);\n@@ -476,23 +476,23 @@ impl<'a> TyLoweringContext<'a> {\n                         TyKind::BoundVar(BoundVar::new(self.in_binders, idx))\n                     }\n                 }\n-                .intern(&Interner)\n+                .intern(Interner)\n             }\n             TypeNs::SelfType(impl_id) => {\n                 let generics = generics(self.db.upcast(), impl_id.into());\n                 let substs = match self.type_param_mode {\n                     TypeParamLoweringMode::Placeholder => generics.type_params_subst(self.db),\n                     TypeParamLoweringMode::Variable => generics.bound_vars_subst(self.in_binders),\n                 };\n-                self.db.impl_self_ty(impl_id).substitute(&Interner, &substs)\n+                self.db.impl_self_ty(impl_id).substitute(Interner, &substs)\n             }\n             TypeNs::AdtSelfType(adt) => {\n                 let generics = generics(self.db.upcast(), adt.into());\n                 let substs = match self.type_param_mode {\n                     TypeParamLoweringMode::Placeholder => generics.type_params_subst(self.db),\n                     TypeParamLoweringMode::Variable => generics.bound_vars_subst(self.in_binders),\n                 };\n-                self.db.ty(adt.into()).substitute(&Interner, &substs)\n+                self.db.ty(adt.into()).substitute(Interner, &substs)\n             }\n \n             TypeNs::AdtId(it) => self.lower_path_inner(resolved_segment, it.into(), infer_args),\n@@ -503,7 +503,7 @@ impl<'a> TyLoweringContext<'a> {\n                 self.lower_path_inner(resolved_segment, it.into(), infer_args)\n             }\n             // FIXME: report error\n-            TypeNs::EnumVariantId(_) => return (TyKind::Error.intern(&Interner), None),\n+            TypeNs::EnumVariantId(_) => return (TyKind::Error.intern(Interner), None),\n         };\n         self.lower_ty_relative_path(ty, Some(resolution), remaining_segments)\n     }\n@@ -517,7 +517,7 @@ impl<'a> TyLoweringContext<'a> {\n         let (resolution, remaining_index) =\n             match self.resolver.resolve_path_in_type_ns(self.db.upcast(), path.mod_path()) {\n                 Some(it) => it,\n-                None => return (TyKind::Error.intern(&Interner), None),\n+                None => return (TyKind::Error.intern(Interner), None),\n             };\n         let (resolved_segment, remaining_segments) = match remaining_index {\n             None => (\n@@ -548,30 +548,30 @@ impl<'a> TyLoweringContext<'a> {\n                                     ),\n                                 );\n                                 let s = generics.type_params_subst(self.db);\n-                                s.apply(t.substitution.clone(), &Interner)\n+                                s.apply(t.substitution.clone(), Interner)\n                             }\n                             TypeParamLoweringMode::Variable => t.substitution.clone(),\n                         };\n                         // We need to shift in the bound vars, since\n                         // associated_type_shorthand_candidates does not do that\n-                        let substs = substs.shifted_in_from(&Interner, self.in_binders);\n+                        let substs = substs.shifted_in_from(Interner, self.in_binders);\n                         // FIXME handle type parameters on the segment\n                         Some(\n                             TyKind::Alias(AliasTy::Projection(ProjectionTy {\n                                 associated_ty_id: to_assoc_type_id(associated_ty),\n                                 substitution: substs,\n                             }))\n-                            .intern(&Interner),\n+                            .intern(Interner),\n                         )\n                     } else {\n                         None\n                     }\n                 },\n             );\n \n-            ty.unwrap_or_else(|| TyKind::Error.intern(&Interner))\n+            ty.unwrap_or_else(|| TyKind::Error.intern(Interner))\n         } else {\n-            TyKind::Error.intern(&Interner)\n+            TyKind::Error.intern(Interner)\n         }\n     }\n \n@@ -587,7 +587,7 @@ impl<'a> TyLoweringContext<'a> {\n             TyDefId::TypeAliasId(it) => Some(it.into()),\n         };\n         let substs = self.substs_from_path_segment(segment, generic_def, infer_args, None);\n-        self.db.ty(typeable).substitute(&Interner, &substs)\n+        self.db.ty(typeable).substitute(Interner, &substs)\n     }\n \n     /// Collect generic arguments from a path into a `Substs`. See also\n@@ -640,13 +640,13 @@ impl<'a> TyLoweringContext<'a> {\n             def_generics.map_or((0, 0, 0, 0), |g| g.provenance_split());\n         let total_len = parent_params + self_params + type_params + impl_trait_params;\n \n-        substs.extend(iter::repeat(TyKind::Error.intern(&Interner)).take(parent_params));\n+        substs.extend(iter::repeat(TyKind::Error.intern(Interner)).take(parent_params));\n \n         let fill_self_params = || {\n             substs.extend(\n                 explicit_self_ty\n                     .into_iter()\n-                    .chain(iter::repeat(TyKind::Error.intern(&Interner)))\n+                    .chain(iter::repeat(TyKind::Error.intern(Interner)))\n                     .take(self_params),\n             )\n         };\n@@ -690,20 +690,20 @@ impl<'a> TyLoweringContext<'a> {\n \n                 for default_ty in defaults.iter().skip(substs.len()) {\n                     // each default can depend on the previous parameters\n-                    let substs_so_far = Substitution::from_iter(&Interner, substs.clone());\n-                    substs.push(default_ty.clone().substitute(&Interner, &substs_so_far));\n+                    let substs_so_far = Substitution::from_iter(Interner, substs.clone());\n+                    substs.push(default_ty.clone().substitute(Interner, &substs_so_far));\n                 }\n             }\n         }\n \n         // add placeholders for args that were not provided\n         // FIXME: emit diagnostics in contexts where this is not allowed\n         for _ in substs.len()..total_len {\n-            substs.push(TyKind::Error.intern(&Interner));\n+            substs.push(TyKind::Error.intern(Interner));\n         }\n         assert_eq!(substs.len(), total_len);\n \n-        Substitution::from_iter(&Interner, substs)\n+        Substitution::from_iter(Interner, substs)\n     }\n \n     fn lower_trait_ref_from_path(\n@@ -770,7 +770,7 @@ impl<'a> TyLoweringContext<'a> {\n                                 TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, idx))\n                             }\n                         }\n-                        .intern(&Interner)\n+                        .intern(Interner)\n                     }\n                 };\n                 self.lower_type_bound(bound, self_ty, ignore_bindings)\n@@ -869,7 +869,7 @@ impl<'a> TyLoweringContext<'a> {\n                 for bound in &binding.bounds {\n                     preds.extend(self.lower_type_bound(\n                         bound,\n-                        TyKind::Alias(AliasTy::Projection(projection_ty.clone())).intern(&Interner),\n+                        TyKind::Alias(AliasTy::Projection(projection_ty.clone())).intern(Interner),\n                         false,\n                     ));\n                 }\n@@ -883,8 +883,7 @@ impl<'a> TyLoweringContext<'a> {\n         func: FunctionId,\n     ) -> ReturnTypeImplTrait {\n         cov_mark::hit!(lower_rpit);\n-        let self_ty =\n-            TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)).intern(&Interner);\n+        let self_ty = TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)).intern(Interner);\n         let predicates = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n             let mut predicates: Vec<_> = bounds\n                 .iter()\n@@ -900,7 +899,7 @@ impl<'a> TyLoweringContext<'a> {\n                 let sized_clause = sized_trait.map(|trait_id| {\n                     let clause = WhereClause::Implemented(TraitRef {\n                         trait_id,\n-                        substitution: Substitution::from1(&Interner, self_ty.clone()),\n+                        substitution: Substitution::from1(Interner, self_ty.clone()),\n                     });\n                     crate::wrap_empty_binders(clause)\n                 });\n@@ -974,7 +973,7 @@ fn named_associated_type_shorthand_candidates<R>(\n                 // FIXME: how to correctly handle higher-ranked bounds here?\n                 WhereClause::Implemented(tr) => search(\n                     tr.clone()\n-                        .shifted_out_to(&Interner, DebruijnIndex::ONE)\n+                        .shifted_out_to(Interner, DebruijnIndex::ONE)\n                         .expect(\"FIXME unexpected higher-ranked trait bound\"),\n                 ),\n                 _ => None,\n@@ -1117,11 +1116,10 @@ pub(crate) fn trait_environment_query(\n     for pred in resolver.where_predicates_in_scope() {\n         for pred in ctx.lower_where_predicate(pred, false) {\n             if let WhereClause::Implemented(tr) = &pred.skip_binders() {\n-                traits_in_scope\n-                    .push((tr.self_type_parameter(&Interner).clone(), tr.hir_trait_id()));\n+                traits_in_scope.push((tr.self_type_parameter(Interner).clone(), tr.hir_trait_id()));\n             }\n-            let program_clause: chalk_ir::ProgramClause<Interner> = pred.cast(&Interner);\n-            clauses.push(program_clause.into_from_env_clause(&Interner));\n+            let program_clause: chalk_ir::ProgramClause<Interner> = pred.cast(Interner);\n+            clauses.push(program_clause.into_from_env_clause(Interner));\n         }\n     }\n \n@@ -1143,22 +1141,22 @@ pub(crate) fn trait_environment_query(\n         let substs = TyBuilder::type_params_subst(db, trait_id);\n         let trait_ref = TraitRef { trait_id: to_chalk_trait_id(trait_id), substitution: substs };\n         let pred = WhereClause::Implemented(trait_ref);\n-        let program_clause: chalk_ir::ProgramClause<Interner> = pred.cast(&Interner);\n-        clauses.push(program_clause.into_from_env_clause(&Interner));\n+        let program_clause: chalk_ir::ProgramClause<Interner> = pred.cast(Interner);\n+        clauses.push(program_clause.into_from_env_clause(Interner));\n     }\n \n     let subst = generics(db.upcast(), def).type_params_subst(db);\n     let explicitly_unsized_tys = ctx.unsized_types.into_inner();\n     let implicitly_sized_clauses =\n         implicitly_sized_clauses(db, def, &explicitly_unsized_tys, &subst, &resolver).map(|pred| {\n-            let program_clause: chalk_ir::ProgramClause<Interner> = pred.cast(&Interner);\n-            program_clause.into_from_env_clause(&Interner)\n+            let program_clause: chalk_ir::ProgramClause<Interner> = pred.cast(Interner);\n+            program_clause.into_from_env_clause(Interner)\n         });\n     clauses.extend(implicitly_sized_clauses);\n \n     let krate = def.module(db.upcast()).krate();\n \n-    let env = chalk_ir::Environment::new(&Interner).add_clauses(&Interner, clauses);\n+    let env = chalk_ir::Environment::new(Interner).add_clauses(Interner, clauses);\n \n     Arc::new(TraitEnvironment { krate, traits_from_clauses: traits_in_scope, env })\n }\n@@ -1197,7 +1195,7 @@ fn implicitly_sized_clauses<'a>(\n     resolver: &Resolver,\n ) -> impl Iterator<Item = WhereClause> + 'a {\n     let is_trait_def = matches!(def, GenericDefId::TraitId(..));\n-    let generic_args = &substitution.as_slice(&Interner)[is_trait_def as usize..];\n+    let generic_args = &substitution.as_slice(Interner)[is_trait_def as usize..];\n     let sized_trait = resolver\n         .krate()\n         .and_then(|krate| db.lang_item(krate, SmolStr::new_inline(\"sized\")))\n@@ -1206,12 +1204,12 @@ fn implicitly_sized_clauses<'a>(\n     sized_trait.into_iter().flat_map(move |sized_trait| {\n         let implicitly_sized_tys = generic_args\n             .iter()\n-            .filter_map(|generic_arg| generic_arg.ty(&Interner))\n+            .filter_map(|generic_arg| generic_arg.ty(Interner))\n             .filter(move |&self_ty| !explicitly_unsized_tys.contains(self_ty));\n         implicitly_sized_tys.map(move |self_ty| {\n             WhereClause::Implemented(TraitRef {\n                 trait_id: sized_trait,\n-                substitution: Substitution::from1(&Interner, self_ty.clone()),\n+                substitution: Substitution::from1(Interner, self_ty.clone()),\n             })\n         })\n     })\n@@ -1232,17 +1230,17 @@ pub(crate) fn generic_defaults_query(\n         .enumerate()\n         .map(|(idx, (_, p))| {\n             let mut ty =\n-                p.default.as_ref().map_or(TyKind::Error.intern(&Interner), |t| ctx.lower_ty(t));\n+                p.default.as_ref().map_or(TyKind::Error.intern(Interner), |t| ctx.lower_ty(t));\n \n             // Each default can only refer to previous parameters.\n             ty = crate::fold_free_vars(ty, |bound, binders| {\n                 if bound.index >= idx && bound.debruijn == DebruijnIndex::INNERMOST {\n                     // type variable default referring to parameter coming\n                     // after it. This is forbidden (FIXME: report\n                     // diagnostic)\n-                    TyKind::Error.intern(&Interner)\n+                    TyKind::Error.intern(Interner)\n                 } else {\n-                    bound.shifted_in_from(binders).to_ty(&Interner)\n+                    bound.shifted_in_from(binders).to_ty(Interner)\n                 }\n             });\n \n@@ -1265,7 +1263,7 @@ pub(crate) fn generic_defaults_recover(\n         .iter()\n         .enumerate()\n         .map(|(idx, _)| {\n-            let ty = TyKind::Error.intern(&Interner);\n+            let ty = TyKind::Error.intern(Interner);\n \n             crate::make_only_type_binders(idx, ty)\n         })\n@@ -1300,7 +1298,7 @@ fn type_for_fn(db: &dyn HirDatabase, def: FunctionId) -> Binders<Ty> {\n     let substs = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n     make_binders(\n         &generics,\n-        TyKind::FnDef(CallableDefId::FunctionId(def).to_chalk(db), substs).intern(&Interner),\n+        TyKind::FnDef(CallableDefId::FunctionId(def).to_chalk(db), substs).intern(Interner),\n     )\n }\n \n@@ -1321,7 +1319,7 @@ fn type_for_static(db: &dyn HirDatabase, def: StaticId) -> Binders<Ty> {\n     let resolver = def.resolver(db.upcast());\n     let ctx = TyLoweringContext::new(db, &resolver);\n \n-    Binders::empty(&Interner, ctx.lower_ty(&data.type_ref))\n+    Binders::empty(Interner, ctx.lower_ty(&data.type_ref))\n }\n \n fn fn_sig_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> PolyFnSig {\n@@ -1345,7 +1343,7 @@ fn type_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> Binders<T\n     let substs = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n     make_binders(\n         &generics,\n-        TyKind::FnDef(CallableDefId::StructId(def).to_chalk(db), substs).intern(&Interner),\n+        TyKind::FnDef(CallableDefId::StructId(def).to_chalk(db), substs).intern(Interner),\n     )\n }\n \n@@ -1372,7 +1370,7 @@ fn type_for_enum_variant_constructor(db: &dyn HirDatabase, def: EnumVariantId) -\n     let substs = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n     make_binders(\n         &generics,\n-        TyKind::FnDef(CallableDefId::EnumVariantId(def).to_chalk(db), substs).intern(&Interner),\n+        TyKind::FnDef(CallableDefId::EnumVariantId(def).to_chalk(db), substs).intern(Interner),\n     )\n }\n \n@@ -1389,7 +1387,7 @@ fn type_for_type_alias(db: &dyn HirDatabase, t: TypeAliasId) -> Binders<Ty> {\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     if db.type_alias_data(t).is_extern {\n-        Binders::empty(&Interner, TyKind::Foreign(crate::to_foreign_def_id(t)).intern(&Interner))\n+        Binders::empty(Interner, TyKind::Foreign(crate::to_foreign_def_id(t)).intern(Interner))\n     } else {\n         let type_ref = &db.type_alias_data(t).type_ref;\n         let inner = ctx.lower_ty(type_ref.as_deref().unwrap_or(&TypeRef::Error));\n@@ -1452,21 +1450,19 @@ impl_from!(FunctionId, StructId, UnionId, EnumVariantId, ConstId, StaticId for V\n /// namespace.\n pub(crate) fn ty_query(db: &dyn HirDatabase, def: TyDefId) -> Binders<Ty> {\n     match def {\n-        TyDefId::BuiltinType(it) => Binders::empty(&Interner, TyBuilder::builtin(it)),\n+        TyDefId::BuiltinType(it) => Binders::empty(Interner, TyBuilder::builtin(it)),\n         TyDefId::AdtId(it) => type_for_adt(db, it),\n         TyDefId::TypeAliasId(it) => type_for_type_alias(db, it),\n     }\n }\n \n pub(crate) fn ty_recover(db: &dyn HirDatabase, _cycle: &[String], def: &TyDefId) -> Binders<Ty> {\n     let generics = match *def {\n-        TyDefId::BuiltinType(_) => {\n-            return Binders::empty(&Interner, TyKind::Error.intern(&Interner))\n-        }\n+        TyDefId::BuiltinType(_) => return Binders::empty(Interner, TyKind::Error.intern(Interner)),\n         TyDefId::AdtId(it) => generics(db.upcast(), it.into()),\n         TyDefId::TypeAliasId(it) => generics(db.upcast(), it.into()),\n     };\n-    make_binders(&generics, TyKind::Error.intern(&Interner))\n+    make_binders(&generics, TyKind::Error.intern(Interner))\n }\n \n pub(crate) fn value_ty_query(db: &dyn HirDatabase, def: ValueTyDefId) -> Binders<Ty> {\n@@ -1509,7 +1505,7 @@ pub(crate) fn impl_self_ty_recover(\n     impl_id: &ImplId,\n ) -> Binders<Ty> {\n     let generics = generics(db.upcast(), (*impl_id).into());\n-    make_binders(&generics, TyKind::Error.intern(&Interner))\n+    make_binders(&generics, TyKind::Error.intern(Interner))\n }\n \n pub(crate) fn impl_trait_query(db: &dyn HirDatabase, impl_id: ImplId) -> Option<Binders<TraitRef>> {"}, {"sha": "cb6b6ec39fb25188868a51ae11c4f9e53ea249a1", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -54,7 +54,7 @@ impl TyFingerprint {\n     /// an `impl S`, but not `impl &S`. Hence, this will return `None` for\n     /// reference types and such.\n     pub fn for_inherent_impl(ty: &Ty) -> Option<TyFingerprint> {\n-        let fp = match ty.kind(&Interner) {\n+        let fp = match ty.kind(Interner) {\n             TyKind::Str => TyFingerprint::Str,\n             TyKind::Never => TyFingerprint::Never,\n             TyKind::Slice(..) => TyFingerprint::Slice,\n@@ -71,7 +71,7 @@ impl TyFingerprint {\n \n     /// Creates a TyFingerprint for looking up a trait impl.\n     pub fn for_trait_impl(ty: &Ty) -> Option<TyFingerprint> {\n-        let fp = match ty.kind(&Interner) {\n+        let fp = match ty.kind(Interner) {\n             TyKind::Str => TyFingerprint::Str,\n             TyKind::Never => TyFingerprint::Never,\n             TyKind::Slice(..) => TyFingerprint::Slice,\n@@ -83,7 +83,7 @@ impl TyFingerprint {\n             TyKind::Dyn(_) => ty.dyn_trait().map(TyFingerprint::Dyn)?,\n             TyKind::Ref(_, _, ty) => return TyFingerprint::for_trait_impl(ty),\n             TyKind::Tuple(_, subst) => {\n-                let first_ty = subst.interned().get(0).map(|arg| arg.assert_ty_ref(&Interner));\n+                let first_ty = subst.interned().get(0).map(|arg| arg.assert_ty_ref(Interner));\n                 match first_ty {\n                     Some(ty) => return TyFingerprint::for_trait_impl(ty),\n                     None => TyFingerprint::Unit,\n@@ -96,7 +96,7 @@ impl TyFingerprint {\n             | TyKind::Generator(..)\n             | TyKind::GeneratorWitness(..) => TyFingerprint::Unnameable,\n             TyKind::Function(fn_ptr) => {\n-                TyFingerprint::Function(fn_ptr.substitution.0.len(&Interner) as u32)\n+                TyFingerprint::Function(fn_ptr.substitution.0.len(Interner) as u32)\n             }\n             TyKind::Alias(_)\n             | TyKind::Placeholder(_)\n@@ -384,7 +384,7 @@ pub fn def_crates(\n \n     let mod_to_crate_ids = |module: ModuleId| Some(iter::once(module.krate()).collect());\n \n-    let lang_item_targets = match ty.kind(&Interner) {\n+    let lang_item_targets = match ty.kind(Interner) {\n         TyKind::Adt(AdtId(def_id), _) => {\n             return mod_to_crate_ids(def_id.module(db.upcast()));\n         }\n@@ -603,7 +603,7 @@ fn iterate_method_candidates_with_autoref(\n     let refed = Canonical {\n         binders: receiver_ty.binders.clone(),\n         value: TyKind::Ref(Mutability::Not, static_lifetime(), receiver_ty.value.clone())\n-            .intern(&Interner),\n+            .intern(Interner),\n     };\n \n     iterate_method_candidates_by_receiver(\n@@ -620,7 +620,7 @@ fn iterate_method_candidates_with_autoref(\n \n     let ref_muted = Canonical {\n         binders: receiver_ty.binders,\n-        value: TyKind::Ref(Mutability::Mut, static_lifetime(), receiver_ty.value).intern(&Interner),\n+        value: TyKind::Ref(Mutability::Mut, static_lifetime(), receiver_ty.value).intern(Interner),\n     };\n \n     iterate_method_candidates_by_receiver(\n@@ -712,11 +712,11 @@ fn iterate_trait_method_candidates(\n     receiver_ty: Option<&Canonical<Ty>>,\n     callback: &mut dyn FnMut(&Canonical<Ty>, AssocItemId) -> ControlFlow<()>,\n ) -> ControlFlow<()> {\n-    let receiver_is_array = matches!(self_ty.value.kind(&Interner), chalk_ir::TyKind::Array(..));\n+    let receiver_is_array = matches!(self_ty.value.kind(Interner), chalk_ir::TyKind::Array(..));\n     // if ty is `dyn Trait`, the trait doesn't need to be in scope\n     let inherent_trait =\n         self_ty.value.dyn_trait().into_iter().flat_map(|t| all_super_traits(db.upcast(), t));\n-    let env_traits = matches!(self_ty.value.kind(&Interner), TyKind::Placeholder(_))\n+    let env_traits = matches!(self_ty.value.kind(Interner), TyKind::Placeholder(_))\n         // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n         .then(|| {\n             env.traits_in_scope_from_clauses(self_ty.value.clone())\n@@ -754,7 +754,7 @@ fn iterate_trait_method_candidates(\n             }\n             if !known_implemented {\n                 let goal = generic_implements_goal(db, env.clone(), t, self_ty.clone());\n-                if db.trait_solve(krate, goal.cast(&Interner)).is_none() {\n+                if db.trait_solve(krate, goal.cast(Interner)).is_none() {\n                     continue 'traits;\n                 }\n             }\n@@ -773,12 +773,12 @@ fn filter_inherent_impls_for_self_ty<'i>(\n     // inherent methods on arrays are fingerprinted as [T; {unknown}], so we must also consider them when\n     // resolving a method call on an array with a known len\n     let array_impls = {\n-        match self_ty.kind(&Interner) {\n+        match self_ty.kind(Interner) {\n             TyKind::Array(parameters, array_len) if !array_len.is_unknown() => {\n                 let unknown_array_len_ty =\n                     TyKind::Array(parameters.clone(), consteval::usize_const(None));\n \n-                Some(impls.for_self_ty(&unknown_array_len_ty.intern(&Interner)))\n+                Some(impls.for_self_ty(&unknown_array_len_ty.intern(Interner)))\n             }\n             _ => None,\n         }\n@@ -890,7 +890,7 @@ pub fn resolve_indexing_op(\n     let deref_chain = autoderef_method_receiver(db, krate, ty);\n     for ty in deref_chain {\n         let goal = generic_implements_goal(db, env.clone(), index_trait, ty.clone());\n-        if db.trait_solve(krate, goal.cast(&Interner)).is_some() {\n+        if db.trait_solve(krate, goal.cast(Interner)).is_some() {\n             return Some(ty);\n         }\n     }\n@@ -905,7 +905,7 @@ fn is_transformed_receiver_ty_equal(transformed_receiver_ty: &Ty, receiver_ty: &\n     // a transformed receiver may be considered equal (and a valid method call candidate) if it is an array\n     // with an unknown (i.e. generic) length, and the receiver is an array with the same item type but a known len,\n     // this allows inherent methods on arrays to be considered valid resolution candidates\n-    match (transformed_receiver_ty.kind(&Interner), receiver_ty.kind(&Interner)) {\n+    match (transformed_receiver_ty.kind(Interner), receiver_ty.kind(Interner)) {\n         (\n             TyKind::Array(transformed_array_ty, transformed_array_len),\n             TyKind::Array(receiver_array_ty, receiver_array_len),\n@@ -974,21 +974,21 @@ pub(crate) fn inherent_impl_substs(\n ) -> Option<Substitution> {\n     // we create a var for each type parameter of the impl; we need to keep in\n     // mind here that `self_ty` might have vars of its own\n-    let self_ty_vars = self_ty.binders.len(&Interner);\n+    let self_ty_vars = self_ty.binders.len(Interner);\n     let vars = TyBuilder::subst_for_def(db, impl_id)\n         .fill_with_bound_vars(DebruijnIndex::INNERMOST, self_ty_vars)\n         .build();\n-    let self_ty_with_vars = db.impl_self_ty(impl_id).substitute(&Interner, &vars);\n+    let self_ty_with_vars = db.impl_self_ty(impl_id).substitute(Interner, &vars);\n     let mut kinds = self_ty.binders.interned().to_vec();\n     kinds.extend(\n         iter::repeat(chalk_ir::WithKind::new(\n             chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n             UniverseIndex::ROOT,\n         ))\n-        .take(vars.len(&Interner)),\n+        .take(vars.len(Interner)),\n     );\n     let tys = Canonical {\n-        binders: CanonicalVarKinds::from_iter(&Interner, kinds),\n+        binders: CanonicalVarKinds::from_iter(Interner, kinds),\n         value: (self_ty_with_vars, self_ty.value.clone()),\n     };\n     let substs = super::infer::unify(db, env, &tys)?;\n@@ -998,7 +998,7 @@ pub(crate) fn inherent_impl_substs(\n     // Unknown, and in that case we want the result to contain Unknown in those\n     // places again.\n     let suffix =\n-        Substitution::from_iter(&Interner, substs.iter(&Interner).cloned().skip(self_ty_vars));\n+        Substitution::from_iter(Interner, substs.iter(Interner).cloned().skip(self_ty_vars));\n     Some(fallback_bound_vars(suffix, self_ty_vars))\n }\n \n@@ -1007,9 +1007,9 @@ pub(crate) fn inherent_impl_substs(\n fn fallback_bound_vars(s: Substitution, num_vars_to_keep: usize) -> Substitution {\n     crate::fold_free_vars(s, |bound, binders| {\n         if bound.index >= num_vars_to_keep && bound.debruijn == DebruijnIndex::INNERMOST {\n-            TyKind::Error.intern(&Interner)\n+            TyKind::Error.intern(Interner)\n         } else {\n-            bound.shifted_in_from(binders).to_ty(&Interner)\n+            bound.shifted_in_from(binders).to_ty(Interner)\n         }\n     })\n }\n@@ -1036,7 +1036,7 @@ fn transform_receiver_ty(\n         ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => unreachable!(),\n     };\n     let sig = db.callable_item_signature(function_id.into());\n-    Some(sig.map(|s| s.params()[0].clone()).substitute(&Interner, &substs))\n+    Some(sig.map(|s| s.params()[0].clone()).substitute(Interner, &substs))\n }\n \n pub fn implements_trait(\n@@ -1047,7 +1047,7 @@ pub fn implements_trait(\n     trait_: TraitId,\n ) -> bool {\n     let goal = generic_implements_goal(db, env, trait_, ty.clone());\n-    let solution = db.trait_solve(krate, goal.cast(&Interner));\n+    let solution = db.trait_solve(krate, goal.cast(Interner));\n \n     solution.is_some()\n }\n@@ -1060,7 +1060,7 @@ pub fn implements_trait_unique(\n     trait_: TraitId,\n ) -> bool {\n     let goal = generic_implements_goal(db, env, trait_, ty.clone());\n-    let solution = db.trait_solve(krate, goal.cast(&Interner));\n+    let solution = db.trait_solve(krate, goal.cast(Interner));\n \n     matches!(solution, Some(crate::Solution::Unique(_)))\n }\n@@ -1083,11 +1083,11 @@ fn generic_implements_goal(\n             chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n             UniverseIndex::ROOT,\n         ))\n-        .take(trait_ref.substitution.len(&Interner) - 1),\n+        .take(trait_ref.substitution.len(Interner) - 1),\n     );\n-    let obligation = trait_ref.cast(&Interner);\n+    let obligation = trait_ref.cast(Interner);\n     Canonical {\n-        binders: CanonicalVarKinds::from_iter(&Interner, kinds),\n+        binders: CanonicalVarKinds::from_iter(Interner, kinds),\n         value: InEnvironment::new(&env.env, obligation),\n     }\n }\n@@ -1099,11 +1099,10 @@ fn autoderef_method_receiver(\n ) -> Vec<Canonical<Ty>> {\n     let mut deref_chain: Vec<_> = autoderef::autoderef(db, Some(krate), ty).collect();\n     // As a last step, we can do array unsizing (that's the only unsizing that rustc does for method receivers!)\n-    if let Some(TyKind::Array(parameters, _)) =\n-        deref_chain.last().map(|ty| ty.value.kind(&Interner))\n+    if let Some(TyKind::Array(parameters, _)) = deref_chain.last().map(|ty| ty.value.kind(Interner))\n     {\n         let kinds = deref_chain.last().unwrap().binders.clone();\n-        let unsized_ty = TyKind::Slice(parameters.clone()).intern(&Interner);\n+        let unsized_ty = TyKind::Slice(parameters.clone()).intern(Interner);\n         deref_chain.push(Canonical { value: unsized_ty, binders: kinds })\n     }\n     deref_chain"}, {"sha": "2045cf7bdfecb405866b0e8a470244ff1fe17b50", "filename": "crates/hir_ty/src/tls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftls.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -64,7 +64,7 @@ impl DebugContext<'_> {\n             _ => panic!(\"associated type not in trait\"),\n         };\n         let trait_data = self.0.trait_data(trait_);\n-        let params = projection_ty.substitution.as_slice(&Interner);\n+        let params = projection_ty.substitution.as_slice(Interner);\n         write!(fmt, \"<{:?} as {}\", &params[0], trait_data.name,)?;\n         if params.len() > 1 {\n             write!("}, {"sha": "71b711024bbf9e5cb81c760e368f92b0ea2a8f13", "filename": "crates/hir_ty/src/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -51,7 +51,7 @@ impl TraitEnvironment {\n         TraitEnvironment {\n             krate,\n             traits_from_clauses: Vec::new(),\n-            env: chalk_ir::Environment::new(&Interner),\n+            env: chalk_ir::Environment::new(Interner),\n         }\n     }\n \n@@ -71,7 +71,7 @@ pub(crate) fn trait_solve_query(\n     krate: CrateId,\n     goal: Canonical<InEnvironment<Goal>>,\n ) -> Option<Solution> {\n-    let _p = profile::span(\"trait_solve_query\").detail(|| match &goal.value.goal.data(&Interner) {\n+    let _p = profile::span(\"trait_solve_query\").detail(|| match &goal.value.goal.data(Interner) {\n         GoalData::DomainGoal(DomainGoal::Holds(WhereClause::Implemented(it))) => {\n             db.trait_data(it.hir_trait_id()).name.to_string()\n         }\n@@ -83,9 +83,9 @@ pub(crate) fn trait_solve_query(\n     if let GoalData::DomainGoal(DomainGoal::Holds(WhereClause::AliasEq(AliasEq {\n         alias: AliasTy::Projection(projection_ty),\n         ..\n-    }))) = &goal.value.goal.data(&Interner)\n+    }))) = &goal.value.goal.data(Interner)\n     {\n-        if let TyKind::BoundVar(_) = projection_ty.self_type_parameter(&Interner).kind(&Interner) {\n+        if let TyKind::BoundVar(_) = projection_ty.self_type_parameter(Interner).kind(Interner) {\n             // Hack: don't ask Chalk to normalize with an unknown self type, it'll say that's impossible\n             return Some(Solution::Ambig(Guidance::Unknown));\n         }"}, {"sha": "4e16cabdfcd8004eebc09db9326d928d5e8509d1", "filename": "crates/hir_ty/src/utils.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Futils.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -90,13 +90,13 @@ fn direct_super_trait_refs(db: &dyn HirDatabase, trait_ref: &TraitRef) -> Vec<Tr\n                 // FIXME: how to correctly handle higher-ranked bounds here?\n                 WhereClause::Implemented(tr) => Some(\n                     tr.clone()\n-                        .shifted_out_to(&Interner, DebruijnIndex::ONE)\n+                        .shifted_out_to(Interner, DebruijnIndex::ONE)\n                         .expect(\"FIXME unexpected higher-ranked trait bound\"),\n                 ),\n                 _ => None,\n             })\n         })\n-        .map(|pred| pred.substitute(&Interner, &trait_ref.substitution))\n+        .map(|pred| pred.substitute(Interner, &trait_ref.substitution))\n         .collect()\n }\n \n@@ -270,19 +270,19 @@ impl Generics {\n     /// Returns a Substitution that replaces each parameter by a bound variable.\n     pub(crate) fn bound_vars_subst(&self, debruijn: DebruijnIndex) -> Substitution {\n         Substitution::from_iter(\n-            &Interner,\n+            Interner,\n             self.iter()\n                 .enumerate()\n-                .map(|(idx, _)| TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(&Interner)),\n+                .map(|(idx, _)| TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(Interner)),\n         )\n     }\n \n     /// Returns a Substitution that replaces each parameter by itself (i.e. `Ty::Param`).\n     pub(crate) fn type_params_subst(&self, db: &dyn HirDatabase) -> Substitution {\n         Substitution::from_iter(\n-            &Interner,\n+            Interner,\n             self.iter().map(|(id, _)| {\n-                TyKind::Placeholder(crate::to_placeholder_idx(db, id)).intern(&Interner)\n+                TyKind::Placeholder(crate::to_placeholder_idx(db, id)).intern(Interner)\n             }),\n         )\n     }"}, {"sha": "c476894552e6c879e2a1d18841ad5e594bf2bac3", "filename": "crates/hir_ty/src/walk.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fhir_ty%2Fsrc%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fwalk.rs?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -16,14 +16,14 @@ pub trait TypeWalk {\n \n impl TypeWalk for Ty {\n     fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        match self.kind(&Interner) {\n+        match self.kind(Interner) {\n             TyKind::Alias(AliasTy::Projection(p_ty)) => {\n-                for t in p_ty.substitution.iter(&Interner) {\n+                for t in p_ty.substitution.iter(Interner) {\n                     t.walk(f);\n                 }\n             }\n             TyKind::Alias(AliasTy::Opaque(o_ty)) => {\n-                for t in o_ty.substitution.iter(&Interner) {\n+                for t in o_ty.substitution.iter(Interner) {\n                     t.walk(f);\n                 }\n             }\n@@ -94,7 +94,7 @@ impl TypeWalk for GenericArg {\n \n impl TypeWalk for Substitution {\n     fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        for t in self.iter(&Interner) {\n+        for t in self.iter(Interner) {\n             t.walk(f);\n         }\n     }"}, {"sha": "9dd0ca9044d7a41e73e2c7a58e74972ffa4cbadc", "filename": "crates/proc_macro_api/Cargo.toml", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fproc_macro_api%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fproc_macro_api%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2FCargo.toml?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -10,6 +10,13 @@ rust-version = \"1.56\"\n doctest = false\n \n [dependencies]\n+object = { version = \"0.28\", default-features = false, features = [\n+    \"std\",\n+    \"read_core\",\n+    \"elf\",\n+    \"macho\",\n+    \"pe\",\n+] }\n serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = { version = \"1.0\", features = [\"unbounded_depth\"] }\n tracing = \"0.1\"\n@@ -22,8 +29,3 @@ stdx = { path = \"../stdx\", version = \"0.0.0\" }\n profile = { path = \"../profile\", version = \"0.0.0\" }\n # Intentionally *not* depend on anything salsa-related\n # base_db = { path = \"../base_db\", version = \"0.0.0\" }\n-\n-[dependencies.object]\n-version = \"0.27\"\n-default-features = false\n-features = [\"std\", \"read_core\", \"elf\", \"macho\", \"pe\"]"}, {"sha": "6877bca5983e3c946015a1e5e9f36b14587dcb1c", "filename": "crates/proc_macro_srv/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fproc_macro_srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0add6e95e58633fde2fff0bccaf6c7d71ebc130f/crates%2Fproc_macro_srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2FCargo.toml?ref=0add6e95e58633fde2fff0bccaf6c7d71ebc130f", "patch": "@@ -10,7 +10,7 @@ rust-version = \"1.56\"\n doctest = false\n \n [dependencies]\n-object = { version = \"0.27\", default-features = false, features = [\n+object = { version = \"0.28\", default-features = false, features = [\n     \"std\",\n     \"read_core\",\n     \"elf\","}]}