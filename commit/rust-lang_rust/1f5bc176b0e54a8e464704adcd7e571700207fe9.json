{"sha": "1f5bc176b0e54a8e464704adcd7e571700207fe9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmNWJjMTc2YjBlNTRhOGU0NjQ3MDRhZGNkN2U1NzE3MDAyMDdmZTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-19T19:14:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-19T19:14:04Z"}, "message": "Auto merge of #80104 - Nadrieril:usefulness-merging, r=varkor\n\nImprove and fix diagnostics of exhaustiveness checking\n\nPrimarily, this fixes https://github.com/rust-lang/rust/issues/56379. This also fixes incorrect interactions between or-patterns and slice patterns that I discovered while working on #56379. Those two examples show the incorrect diagnostics:\n\n```rust\nmatch &[][..] {\n    [true] => {}\n    [true // detected as unreachable but that's not true\n        | false, ..] => {}\n    _ => {}\n}\nmatch (true, None) {\n    (true, Some(_)) => {}\n    (false, Some(true)) => {}\n    (true | false, None | Some(true // should be detected as unreachable\n                               | false)) => {}\n}\n```\n\nI did not measure any perf impact. However, I suspect that [`616ba9f`](https://github.com/rust-lang/rust/pull/80104/commits/616ba9f9f7f5845777a36e1a41a515e6c33a8776) should have a negative impact on large or-patterns. I'll see what the perf run says; I have optimization ideas up my sleeve if needed.\n\nEDIT: I initially had a noticeable perf impact that I thought unavoidable. I then proceeded to avoid it x)\n\nr? `@varkor`\n`@rustbot` label +A-exhaustiveness-checking", "tree": {"sha": "702ff2b7019b8ed901de779f1125419b4693343e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/702ff2b7019b8ed901de779f1125419b4693343e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f5bc176b0e54a8e464704adcd7e571700207fe9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f5bc176b0e54a8e464704adcd7e571700207fe9", "html_url": "https://github.com/rust-lang/rust/commit/1f5bc176b0e54a8e464704adcd7e571700207fe9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f5bc176b0e54a8e464704adcd7e571700207fe9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b6b06a03a00a7c9f156bff130b72e90b79e1127", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b6b06a03a00a7c9f156bff130b72e90b79e1127", "html_url": "https://github.com/rust-lang/rust/commit/1b6b06a03a00a7c9f156bff130b72e90b79e1127"}, {"sha": "cefcadbe9278cf30175e93309cdd5f1da6714869", "url": "https://api.github.com/repos/rust-lang/rust/commits/cefcadbe9278cf30175e93309cdd5f1da6714869", "html_url": "https://github.com/rust-lang/rust/commit/cefcadbe9278cf30175e93309cdd5f1da6714869"}], "stats": {"total": 425, "additions": 286, "deletions": 139}, "files": [{"sha": "db817b378f97c2aa77e68a2b393cc5ef0fc30494", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f5bc176b0e54a8e464704adcd7e571700207fe9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f5bc176b0e54a8e464704adcd7e571700207fe9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=1f5bc176b0e54a8e464704adcd7e571700207fe9", "patch": "@@ -433,7 +433,7 @@ fn report_arm_reachability<'p, 'tcx>(\n             Useful(unreachables) if unreachables.is_empty() => {}\n             // The arm is reachable, but contains unreachable subpatterns (from or-patterns).\n             Useful(unreachables) => {\n-                let mut unreachables: Vec<_> = unreachables.iter().flatten().copied().collect();\n+                let mut unreachables: Vec<_> = unreachables.iter().collect();\n                 // Emit lints in the order in which they occur in the file.\n                 unreachables.sort_unstable();\n                 for span in unreachables {"}, {"sha": "0ecc034ac0ba9336c7fd23ec7c75172e33faf9b8", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 184, "deletions": 113, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/1f5bc176b0e54a8e464704adcd7e571700207fe9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f5bc176b0e54a8e464704adcd7e571700207fe9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=1f5bc176b0e54a8e464704adcd7e571700207fe9", "patch": "@@ -311,7 +311,6 @@ use super::{Pat, PatKind};\n use super::{PatternFoldable, PatternFolder};\n \n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::OnceCell;\n \n use rustc_arena::TypedArena;\n@@ -626,11 +625,82 @@ impl<'p, 'tcx> FromIterator<PatStack<'p, 'tcx>> for Matrix<'p, 'tcx> {\n     }\n }\n \n+/// Represents a set of `Span`s closed under the containment relation. That is, if a `Span` is\n+/// contained in the set then all `Span`s contained in it are also implicitly contained in the set.\n+/// In particular this means that when intersecting two sets, taking the intersection of some span\n+/// and one of its subspans returns the subspan, whereas a simple `HashSet` would have returned an\n+/// empty intersection.\n+/// It is assumed that two spans don't overlap without one being contained in the other; in other\n+/// words, that the inclusion structure forms a tree and not a DAG.\n+/// Intersection is not very efficient. It compares everything pairwise. If needed it could be made\n+/// faster by sorting the `Span`s and merging cleverly.\n+#[derive(Debug, Clone, Default)]\n+pub(crate) struct SpanSet {\n+    /// The minimal set of `Span`s required to represent the whole set. If A and B are `Span`s in\n+    /// the `SpanSet`, and A is a descendant of B, then only B will be in `root_spans`.\n+    /// Invariant: the spans are disjoint.\n+    root_spans: Vec<Span>,\n+}\n+\n+impl SpanSet {\n+    /// Creates an empty set.\n+    fn new() -> Self {\n+        Self::default()\n+    }\n+\n+    /// Tests whether the set is empty.\n+    pub(crate) fn is_empty(&self) -> bool {\n+        self.root_spans.is_empty()\n+    }\n+\n+    /// Iterate over the disjoint list of spans at the roots of this set.\n+    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = Span> + Captures<'a> {\n+        self.root_spans.iter().copied()\n+    }\n+\n+    /// Tests whether the set contains a given Span.\n+    fn contains(&self, span: Span) -> bool {\n+        self.iter().any(|root_span| root_span.contains(span))\n+    }\n+\n+    /// Add a span to the set if we know the span has no intersection in this set.\n+    fn push_nonintersecting(&mut self, new_span: Span) {\n+        self.root_spans.push(new_span);\n+    }\n+\n+    fn intersection_mut(&mut self, other: &Self) {\n+        if self.is_empty() || other.is_empty() {\n+            *self = Self::new();\n+            return;\n+        }\n+        // Those that were in `self` but not contained in `other`\n+        let mut leftover = SpanSet::new();\n+        // We keep the elements in `self` that are also in `other`.\n+        self.root_spans.retain(|span| {\n+            let retain = other.contains(*span);\n+            if !retain {\n+                leftover.root_spans.push(*span);\n+            }\n+            retain\n+        });\n+        // We keep the elements in `other` that are also in the original `self`. You might think\n+        // this is not needed because `self` already contains the intersection. But those aren't\n+        // just sets of things. If `self = [a]`, `other = [b]` and `a` contains `b`, then `b`\n+        // belongs in the intersection but we didn't catch it in the filtering above. We look at\n+        // `leftover` instead of the full original `self` to avoid duplicates.\n+        for span in other.iter() {\n+            if leftover.contains(span) {\n+                self.root_spans.push(span);\n+            }\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n crate enum Usefulness<'tcx> {\n-    /// Carries, for each column in the matrix, a set of sub-branches that have been found to be\n-    /// unreachable. Used only in the presence of or-patterns, otherwise it stays empty.\n-    Useful(Vec<FxHashSet<Span>>),\n+    /// Pontentially carries a set of sub-branches that have been found to be unreachable. Used\n+    /// only in the presence of or-patterns, otherwise it stays empty.\n+    Useful(SpanSet),\n     /// Carries a list of witnesses of non-exhaustiveness.\n     UsefulWithWitness(Vec<Witness<'tcx>>),\n     NotUseful,\n@@ -640,14 +710,97 @@ impl<'tcx> Usefulness<'tcx> {\n     fn new_useful(preference: WitnessPreference) -> Self {\n         match preference {\n             ConstructWitness => UsefulWithWitness(vec![Witness(vec![])]),\n-            LeaveOutWitness => Useful(vec![]),\n+            LeaveOutWitness => Useful(Default::default()),\n         }\n     }\n \n-    fn is_useful(&self) -> bool {\n-        !matches!(*self, NotUseful)\n+    /// When trying several branches and each returns a `Usefulness`, we need to combine the\n+    /// results together.\n+    fn merge(usefulnesses: impl Iterator<Item = Self>) -> Self {\n+        // If we have detected some unreachable sub-branches, we only want to keep them when they\n+        // were unreachable in _all_ branches. Eg. in the following, the last `true` is unreachable\n+        // in the second branch of the first or-pattern, but not otherwise. Therefore we don't want\n+        // to lint that it is unreachable.\n+        // ```\n+        // match (true, true) {\n+        //     (true, true) => {}\n+        //     (false | true, false | true) => {}\n+        // }\n+        // ```\n+        // Here however we _do_ want to lint that the last `false` is unreachable. So we don't want\n+        // to intersect the spans that come directly from the or-pattern, since each branch of the\n+        // or-pattern brings a new disjoint pattern.\n+        // ```\n+        // match None {\n+        //     Some(false) => {}\n+        //     None | Some(true | false) => {}\n+        // }\n+        // ```\n+\n+        // Is `None` when no branch was useful. Will often be `Some(Spanset::new())` because the\n+        // sets are only non-empty in the presence of or-patterns.\n+        let mut unreachables: Option<SpanSet> = None;\n+        // Witnesses of usefulness, if any.\n+        let mut witnesses = Vec::new();\n+\n+        for u in usefulnesses {\n+            match u {\n+                Useful(spans) if spans.is_empty() => {\n+                    // Once we reach the empty set, more intersections won't change the result.\n+                    return Useful(SpanSet::new());\n+                }\n+                Useful(spans) => {\n+                    if let Some(unreachables) = &mut unreachables {\n+                        if !unreachables.is_empty() {\n+                            unreachables.intersection_mut(&spans);\n+                        }\n+                        if unreachables.is_empty() {\n+                            return Useful(SpanSet::new());\n+                        }\n+                    } else {\n+                        unreachables = Some(spans);\n+                    }\n+                }\n+                NotUseful => {}\n+                UsefulWithWitness(wits) => {\n+                    witnesses.extend(wits);\n+                }\n+            }\n+        }\n+\n+        if !witnesses.is_empty() {\n+            UsefulWithWitness(witnesses)\n+        } else if let Some(unreachables) = unreachables {\n+            Useful(unreachables)\n+        } else {\n+            NotUseful\n+        }\n     }\n \n+    /// After calculating the usefulness for a branch of an or-pattern, call this to make this\n+    /// usefulness mergeable with those from the other branches.\n+    fn unsplit_or_pat(self, this_span: Span, or_pat_spans: &[Span]) -> Self {\n+        match self {\n+            Useful(mut spans) => {\n+                // We register the spans of the other branches of this or-pattern as being\n+                // unreachable from this one. This ensures that intersecting together the sets of\n+                // spans returns what we want.\n+                // Until we optimize `SpanSet` however, intersecting this entails a number of\n+                // comparisons quadratic in the number of branches.\n+                for &span in or_pat_spans {\n+                    if span != this_span {\n+                        spans.push_nonintersecting(span);\n+                    }\n+                }\n+                Useful(spans)\n+            }\n+            x => x,\n+        }\n+    }\n+\n+    /// After calculating usefulness after a specialization, call this to recontruct a usefulness\n+    /// that makes sense for the matrix pre-specialization. This new usefulness can then be merged\n+    /// with the results of specializing with the other constructors.\n     fn apply_constructor<'p>(\n         self,\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n@@ -677,23 +830,6 @@ impl<'tcx> Usefulness<'tcx> {\n                 };\n                 UsefulWithWitness(new_witnesses)\n             }\n-            Useful(mut unreachables) => {\n-                if !unreachables.is_empty() {\n-                    // When we apply a constructor, there are `arity` columns of the matrix that\n-                    // corresponded to its arguments. All the unreachables found in these columns\n-                    // will, after `apply`, come from the first column. So we take the union of all\n-                    // the corresponding sets and put them in the first column.\n-                    // Note that `arity` may be 0, in which case we just push a new empty set.\n-                    let len = unreachables.len();\n-                    let arity = ctor_wild_subpatterns.len();\n-                    let mut unioned = FxHashSet::default();\n-                    for set in unreachables.drain((len - arity)..) {\n-                        unioned.extend(set)\n-                    }\n-                    unreachables.push(unioned);\n-                }\n-                Useful(unreachables)\n-            }\n             x => x,\n         }\n     }\n@@ -829,112 +965,47 @@ fn is_useful<'p, 'tcx>(\n \n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n+    // FIXME(Nadrieril): Hack to work around type normalization issues (see #72476).\n+    let ty = matrix.heads().next().map(|r| r.ty).unwrap_or(v.head().ty);\n+    let pcx = PatCtxt { cx, matrix, ty, span: v.head().span, is_top_level };\n+\n+    debug!(\"is_useful_expand_first_col: ty={:#?}, expanding {:#?}\", pcx.ty, v.head());\n+\n     // If the first pattern is an or-pattern, expand it.\n-    if let Some(vs) = v.expand_or_pat() {\n+    let ret = if let Some(vs) = v.expand_or_pat() {\n+        let subspans: Vec<_> = vs.iter().map(|v| v.head().span).collect();\n         // We expand the or pattern, trying each of its branches in turn and keeping careful track\n         // of possible unreachable sub-branches.\n-        //\n-        // If two branches have detected some unreachable sub-branches, we need to be careful. If\n-        // they were detected in columns that are not the current one, we want to keep only the\n-        // sub-branches that were unreachable in _all_ branches. Eg. in the following, the last\n-        // `true` is unreachable in the second branch of the first or-pattern, but not otherwise.\n-        // Therefore we don't want to lint that it is unreachable.\n-        //\n-        // ```\n-        // match (true, true) {\n-        //     (true, true) => {}\n-        //     (false | true, false | true) => {}\n-        // }\n-        // ```\n-        // If however the sub-branches come from the current column, they come from the inside of\n-        // the current or-pattern, and we want to keep them all. Eg. in the following, we _do_ want\n-        // to lint that the last `false` is unreachable.\n-        // ```\n-        // match None {\n-        //     Some(false) => {}\n-        //     None | Some(true | false) => {}\n-        // }\n-        // ```\n-\n         let mut matrix = matrix.clone();\n-        // We keep track of sub-branches separately depending on whether they come from this column\n-        // or from others.\n-        let mut unreachables_this_column: FxHashSet<Span> = FxHashSet::default();\n-        let mut unreachables_other_columns: Vec<FxHashSet<Span>> = Vec::default();\n-        // Whether at least one branch is reachable.\n-        let mut any_is_useful = false;\n-\n-        for v in vs {\n-            let res = is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n-            match res {\n-                Useful(unreachables) => {\n-                    if let Some((this_column, other_columns)) = unreachables.split_last() {\n-                        // We keep the union of unreachables found in the first column.\n-                        unreachables_this_column.extend(this_column);\n-                        // We keep the intersection of unreachables found in other columns.\n-                        if unreachables_other_columns.is_empty() {\n-                            unreachables_other_columns = other_columns.to_vec();\n-                        } else {\n-                            unreachables_other_columns = unreachables_other_columns\n-                                .into_iter()\n-                                .zip(other_columns)\n-                                .map(|(x, y)| x.intersection(&y).copied().collect())\n-                                .collect();\n-                        }\n-                    }\n-                    any_is_useful = true;\n-                }\n-                NotUseful => {\n-                    unreachables_this_column.insert(v.head().span);\n-                }\n-                UsefulWithWitness(_) => bug!(\n-                    \"encountered or-pat in the expansion of `_` during exhaustiveness checking\"\n-                ),\n-            }\n-\n+        let usefulnesses = vs.into_iter().map(|v| {\n+            let v_span = v.head().span;\n+            let usefulness =\n+                is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n             // If pattern has a guard don't add it to the matrix.\n             if !is_under_guard {\n                 // We push the already-seen patterns into the matrix in order to detect redundant\n                 // branches like `Some(_) | Some(0)`.\n                 matrix.push(v);\n             }\n-        }\n-\n-        return if any_is_useful {\n-            let mut unreachables = if unreachables_other_columns.is_empty() {\n-                let n_columns = v.len();\n-                (0..n_columns - 1).map(|_| FxHashSet::default()).collect()\n-            } else {\n-                unreachables_other_columns\n-            };\n-            unreachables.push(unreachables_this_column);\n-            Useful(unreachables)\n-        } else {\n-            NotUseful\n-        };\n-    }\n-\n-    // FIXME(Nadrieril): Hack to work around type normalization issues (see #72476).\n-    let ty = matrix.heads().next().map(|r| r.ty).unwrap_or(v.head().ty);\n-    let pcx = PatCtxt { cx, matrix, ty, span: v.head().span, is_top_level };\n-\n-    debug!(\"is_useful_expand_first_col: ty={:#?}, expanding {:#?}\", pcx.ty, v.head());\n-\n-    let ret = v\n-        .head_ctor(cx)\n-        .split(pcx, Some(hir_id))\n-        .into_iter()\n-        .map(|ctor| {\n+            usefulness.unsplit_or_pat(v_span, &subspans)\n+        });\n+        Usefulness::merge(usefulnesses)\n+    } else {\n+        // We split the head constructor of `v`.\n+        let ctors = v.head_ctor(cx).split(pcx, Some(hir_id));\n+        // For each constructor, we compute whether there's a value that starts with it that would\n+        // witness the usefulness of `v`.\n+        let usefulnesses = ctors.into_iter().map(|ctor| {\n             // We cache the result of `Fields::wildcards` because it is used a lot.\n             let ctor_wild_subpatterns = Fields::wildcards(pcx, &ctor);\n             let matrix = pcx.matrix.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns);\n             let v = v.pop_head_constructor(&ctor_wild_subpatterns);\n             let usefulness =\n                 is_useful(pcx.cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n             usefulness.apply_constructor(pcx, &ctor, &ctor_wild_subpatterns)\n-        })\n-        .find(|result| result.is_useful())\n-        .unwrap_or(NotUseful);\n+        });\n+        Usefulness::merge(usefulnesses)\n+    };\n     debug!(\"is_useful::returns({:#?}, {:#?}) = {:?}\", matrix, v, ret);\n     ret\n }"}, {"sha": "184ffa85c40e28b56beade40e73710bc7d598d5d", "filename": "src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1f5bc176b0e54a8e464704adcd7e571700207fe9/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f5bc176b0e54a8e464704adcd7e571700207fe9/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs?ref=1f5bc176b0e54a8e464704adcd7e571700207fe9", "patch": "@@ -64,6 +64,35 @@ fn main() {\n             | 2, ..] => {}\n         _ => {}\n     }\n+    match &[][..] {\n+        [true] => {}\n+        [true | false, ..] => {}\n+        _ => {}\n+    }\n+    match &[][..] {\n+        [false] => {}\n+        [true, ..] => {}\n+        [true //~ ERROR unreachable\n+            | false, ..] => {}\n+        _ => {}\n+    }\n+    match (true, None) {\n+        (true, Some(_)) => {}\n+        (false, Some(true)) => {}\n+        (true | false, None | Some(true //~ ERROR unreachable\n+                                   | false)) => {}\n+    }\n+    macro_rules! t_or_f {\n+        () => {\n+            (true // FIXME: should be unreachable\n+                        | false)\n+        };\n+    }\n+    match (true, None) {\n+        (true, Some(_)) => {}\n+        (false, Some(true)) => {}\n+        (true | false, None | Some(t_or_f!())) => {}\n+    }\n     match Some(0) {\n         Some(0) => {}\n         Some(0 //~ ERROR unreachable"}, {"sha": "8b1003b5514a680b91ed77a1793205c610d9c10d", "filename": "src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.stderr", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1f5bc176b0e54a8e464704adcd7e571700207fe9/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f5bc176b0e54a8e464704adcd7e571700207fe9/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr?ref=1f5bc176b0e54a8e464704adcd7e571700207fe9", "patch": "@@ -95,28 +95,40 @@ LL |         [1\n    |          ^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:69:14\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:75:10\n+   |\n+LL |         [true\n+   |          ^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:82:36\n+   |\n+LL |         (true | false, None | Some(true\n+   |                                    ^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:98:14\n    |\n LL |         Some(0\n    |              ^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:88:19\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:117:19\n    |\n LL |                 | false) => {}\n    |                   ^^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:96:15\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:125:15\n    |\n LL |             | true) => {}\n    |               ^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:102:15\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:131:15\n    |\n LL |             | true,\n    |               ^^^^\n \n-error: aborting due to 19 previous errors\n+error: aborting due to 21 previous errors\n "}, {"sha": "d2b72a86b74ccc7cea9081ee70a05be08696d79f", "filename": "src/test/ui/pattern/usefulness/issue-15129.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f5bc176b0e54a8e464704adcd7e571700207fe9/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-15129.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f5bc176b0e54a8e464704adcd7e571700207fe9/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-15129.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-15129.rs?ref=1f5bc176b0e54a8e464704adcd7e571700207fe9", "patch": "@@ -1,17 +1,17 @@\n pub enum T {\n     T1(()),\n-    T2(())\n+    T2(()),\n }\n \n pub enum V {\n     V1(isize),\n-    V2(bool)\n+    V2(bool),\n }\n \n fn main() {\n     match (T::T1(()), V::V2(true)) {\n-    //~^ ERROR non-exhaustive patterns: `(T1(()), V2(_))` not covered\n+        //~^ ERROR non-exhaustive patterns: `(T1(()), V2(_))` and `(T2(()), V1(_))` not covered\n         (T::T1(()), V::V1(i)) => (),\n-        (T::T2(()), V::V2(b)) => ()\n+        (T::T2(()), V::V2(b)) => (),\n     }\n }"}, {"sha": "79a77240937ac7803fe7096ed662a099d70ee1bf", "filename": "src/test/ui/pattern/usefulness/issue-15129.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f5bc176b0e54a8e464704adcd7e571700207fe9/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-15129.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f5bc176b0e54a8e464704adcd7e571700207fe9/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-15129.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-15129.stderr?ref=1f5bc176b0e54a8e464704adcd7e571700207fe9", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `(T1(()), V2(_))` not covered\n+error[E0004]: non-exhaustive patterns: `(T1(()), V2(_))` and `(T2(()), V1(_))` not covered\n   --> $DIR/issue-15129.rs:12:11\n    |\n LL |     match (T::T1(()), V::V2(true)) {\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `(T1(()), V2(_))` not covered\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `(T1(()), V2(_))` and `(T2(()), V1(_))` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(T, V)`"}, {"sha": "d27beaeffd637ae08b6a5bdc415071f4fcfb2bed", "filename": "src/test/ui/pattern/usefulness/issue-2111.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1f5bc176b0e54a8e464704adcd7e571700207fe9/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-2111.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f5bc176b0e54a8e464704adcd7e571700207fe9/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-2111.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-2111.rs?ref=1f5bc176b0e54a8e464704adcd7e571700207fe9", "patch": "@@ -1,12 +1,11 @@\n fn foo(a: Option<usize>, b: Option<usize>) {\n-  match (a,b) {\n-  //~^ ERROR: non-exhaustive patterns: `(None, None)` not covered\n-    (Some(a), Some(b)) if a == b => { }\n-    (Some(_), None) |\n-    (None, Some(_)) => { }\n-  }\n+    match (a, b) {\n+        //~^ ERROR: non-exhaustive patterns: `(None, None)` and `(Some(_), Some(_))` not covered\n+        (Some(a), Some(b)) if a == b => {}\n+        (Some(_), None) | (None, Some(_)) => {}\n+    }\n }\n \n fn main() {\n-  foo(None, None);\n+    foo(None, None);\n }"}, {"sha": "60d9b8514b7fbfe9115b84a0e56611b19af8a516", "filename": "src/test/ui/pattern/usefulness/issue-2111.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f5bc176b0e54a8e464704adcd7e571700207fe9/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-2111.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f5bc176b0e54a8e464704adcd7e571700207fe9/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-2111.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-2111.stderr?ref=1f5bc176b0e54a8e464704adcd7e571700207fe9", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `(None, None)` not covered\n-  --> $DIR/issue-2111.rs:2:9\n+error[E0004]: non-exhaustive patterns: `(None, None)` and `(Some(_), Some(_))` not covered\n+  --> $DIR/issue-2111.rs:2:11\n    |\n-LL |   match (a,b) {\n-   |         ^^^^^ pattern `(None, None)` not covered\n+LL |     match (a, b) {\n+   |           ^^^^^^ patterns `(None, None)` and `(Some(_), Some(_))` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(Option<usize>, Option<usize>)`"}, {"sha": "9bccccca9c2b63609d9071ad6928386c5df4d73f", "filename": "src/test/ui/pattern/usefulness/issue-56379.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1f5bc176b0e54a8e464704adcd7e571700207fe9/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f5bc176b0e54a8e464704adcd7e571700207fe9/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.rs?ref=1f5bc176b0e54a8e464704adcd7e571700207fe9", "patch": "@@ -0,0 +1,14 @@\n+enum Foo {\n+    A(bool),\n+    B(bool),\n+    C(bool),\n+}\n+\n+fn main() {\n+    match Foo::A(true) {\n+        //~^ ERROR non-exhaustive patterns: `A(false)`, `B(false)` and `C(false)` not covered\n+        Foo::A(true) => {}\n+        Foo::B(true) => {}\n+        Foo::C(true) => {}\n+    }\n+}"}, {"sha": "6a231b868c8c457f045c5d8a6d03f6290b3e105b", "filename": "src/test/ui/pattern/usefulness/issue-56379.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1f5bc176b0e54a8e464704adcd7e571700207fe9/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f5bc176b0e54a8e464704adcd7e571700207fe9/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.stderr?ref=1f5bc176b0e54a8e464704adcd7e571700207fe9", "patch": "@@ -0,0 +1,22 @@\n+error[E0004]: non-exhaustive patterns: `A(false)`, `B(false)` and `C(false)` not covered\n+  --> $DIR/issue-56379.rs:8:11\n+   |\n+LL | / enum Foo {\n+LL | |     A(bool),\n+   | |     - not covered\n+LL | |     B(bool),\n+   | |     - not covered\n+LL | |     C(bool),\n+   | |     - not covered\n+LL | | }\n+   | |_- `Foo` defined here\n+...\n+LL |       match Foo::A(true) {\n+   |             ^^^^^^^^^^^^ patterns `A(false)`, `B(false)` and `C(false)` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `Foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "4ff12aa2ff5e23d8d7bd98604bd1ba7d75e93c1d", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f5bc176b0e54a8e464704adcd7e571700207fe9/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f5bc176b0e54a8e464704adcd7e571700207fe9/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs?ref=1f5bc176b0e54a8e464704adcd7e571700207fe9", "patch": "@@ -15,7 +15,7 @@ fn main() {\n                       //  and `(_, _, 5_i32..=i32::MAX)` not covered\n       (_, _, 4) => {}\n     }\n-    match (T::A, T::A) { //~ ERROR non-exhaustive patterns: `(A, A)` not covered\n+    match (T::A, T::A) { //~ ERROR non-exhaustive patterns: `(A, A)` and `(B, B)` not covered\n       (T::A, T::B) => {}\n       (T::B, T::A) => {}\n     }"}, {"sha": "c953cd314406e2c3fb72bccc1e7a09760ff8f7e3", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f5bc176b0e54a8e464704adcd7e571700207fe9/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f5bc176b0e54a8e464704adcd7e571700207fe9/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr?ref=1f5bc176b0e54a8e464704adcd7e571700207fe9", "patch": "@@ -45,11 +45,11 @@ LL |     match (2, 3, 4) {\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(i32, i32, i32)`\n \n-error[E0004]: non-exhaustive patterns: `(A, A)` not covered\n+error[E0004]: non-exhaustive patterns: `(A, A)` and `(B, B)` not covered\n   --> $DIR/non-exhaustive-match.rs:18:11\n    |\n LL |     match (T::A, T::A) {\n-   |           ^^^^^^^^^^^^ pattern `(A, A)` not covered\n+   |           ^^^^^^^^^^^^ patterns `(A, A)` and `(B, B)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(T, T)`"}]}