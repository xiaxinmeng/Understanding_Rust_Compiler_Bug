{"sha": "b60f245b9542142ed01318a7ab5b46fc2ffb283e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2MGYyNDViOTU0MjE0MmVkMDEzMThhN2FiNWI0NmZjMmZmYjI4M2U=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-17T20:57:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-17T20:57:34Z"}, "message": "Rollup merge of #63667 - petrochenkov:deriveholders, r=matthewjasper\n\nresolve: Properly integrate derives and `macro_rules` scopes\n\nSo,\n```rust\n#[derive(A, B)]\nstruct S;\n\nm!();\n```\nturns into something like\n```rust\nstruct S;\n\nA_placeholder!( struct S; );\n\nB_placeholder!( struct S; );\n\nm!();\n```\nduring expansion.\n\nAnd for `m!()` its \"`macro_rules` scope\" (aka \"legacy scope\") should point to the `B_placeholder` call rather than to the derive container `#[derive(A, B)]`.\n\n`fn build_reduced_graph` now makes sure the legacy scope points to the right thing.\n(It's still a mystery for me why this worked before https://github.com/rust-lang/rust/pull/63535.)\n\nUnfortunately, placeholders from derives are currently treated separately from placeholders from other macros and need to be passed as `extra_placeholders` rather than a part of the AST fragment.\nThat's fixable, but I wanted to keep this PR more minimal to close the regression faster.\n\nFixes https://github.com/rust-lang/rust/issues/63651\nr? @matthewjasper", "tree": {"sha": "05a20d770b913b29a9309978f7ac5711994b7fc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05a20d770b913b29a9309978f7ac5711994b7fc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b60f245b9542142ed01318a7ab5b46fc2ffb283e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdWGo+CRBK7hj4Ov3rIwAAdHIIAGnsOtdXdv9/3acW73ZaXivc\n1UoyC4934HqpmGo9hH3k01tm+cOniTM469PQ8Y7LwxFMM1bn5QS61AIs2TVTMM0g\nMnwsu6fBmuDIh1bBKow63Cmv5o8oaoAGtF4kQY06Ndmzq0gJZY7wcuxovjhhvTqo\nUrtG2wC6N9nKtO1EV+VKpfLKbWhoigqGFhCXmErwQZbCNriWnw46dUh/PCk4wAAb\niTFjscRRP3wfKnndjYM2rLDBy2pd9kzDHRqeRgTeboX+nkeEd/EteaxOKN6OOiTA\nHaXK1DVrnFuqc3kp7PmVn6tp2WsthgAnoAQ2AOLk14/JQ4A8NxtKHXvezoFlIII=\n=zbfA\n-----END PGP SIGNATURE-----\n", "payload": "tree 05a20d770b913b29a9309978f7ac5711994b7fc1\nparent a00b4f1401d12415d50653a0d4126e1c79151127\nparent 1064d41c96047650897be96190e018be9bbd818a\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1566075454 +0200\ncommitter GitHub <noreply@github.com> 1566075454 +0200\n\nRollup merge of #63667 - petrochenkov:deriveholders, r=matthewjasper\n\nresolve: Properly integrate derives and `macro_rules` scopes\n\nSo,\n```rust\n#[derive(A, B)]\nstruct S;\n\nm!();\n```\nturns into something like\n```rust\nstruct S;\n\nA_placeholder!( struct S; );\n\nB_placeholder!( struct S; );\n\nm!();\n```\nduring expansion.\n\nAnd for `m!()` its \"`macro_rules` scope\" (aka \"legacy scope\") should point to the `B_placeholder` call rather than to the derive container `#[derive(A, B)]`.\n\n`fn build_reduced_graph` now makes sure the legacy scope points to the right thing.\n(It's still a mystery for me why this worked before https://github.com/rust-lang/rust/pull/63535.)\n\nUnfortunately, placeholders from derives are currently treated separately from placeholders from other macros and need to be passed as `extra_placeholders` rather than a part of the AST fragment.\nThat's fixable, but I wanted to keep this PR more minimal to close the regression faster.\n\nFixes https://github.com/rust-lang/rust/issues/63651\nr? @matthewjasper\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b60f245b9542142ed01318a7ab5b46fc2ffb283e", "html_url": "https://github.com/rust-lang/rust/commit/b60f245b9542142ed01318a7ab5b46fc2ffb283e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b60f245b9542142ed01318a7ab5b46fc2ffb283e/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a00b4f1401d12415d50653a0d4126e1c79151127", "url": "https://api.github.com/repos/rust-lang/rust/commits/a00b4f1401d12415d50653a0d4126e1c79151127", "html_url": "https://github.com/rust-lang/rust/commit/a00b4f1401d12415d50653a0d4126e1c79151127"}, {"sha": "1064d41c96047650897be96190e018be9bbd818a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1064d41c96047650897be96190e018be9bbd818a", "html_url": "https://github.com/rust-lang/rust/commit/1064d41c96047650897be96190e018be9bbd818a"}], "stats": {"total": 129, "additions": 82, "deletions": 47}, "files": [{"sha": "d725afa40521253843e70072e0abf35324f22f9b", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b60f245b9542142ed01318a7ab5b46fc2ffb283e/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60f245b9542142ed01318a7ab5b46fc2ffb283e/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=b60f245b9542142ed01318a7ab5b46fc2ffb283e", "patch": "@@ -74,7 +74,7 @@ impl<'a> DefCollector<'a> {\n         })\n     }\n \n-    fn visit_macro_invoc(&mut self, id: NodeId) {\n+    pub fn visit_macro_invoc(&mut self, id: NodeId) {\n         self.definitions.set_invocation_parent(id.placeholder_to_expn_id(), self.parent_def);\n     }\n }"}, {"sha": "42428456b6eec39de4c2640a129c0428714a18c4", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b60f245b9542142ed01318a7ab5b46fc2ffb283e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60f245b9542142ed01318a7ab5b46fc2ffb283e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b60f245b9542142ed01318a7ab5b46fc2ffb283e", "patch": "@@ -160,12 +160,25 @@ impl<'a> Resolver<'a> {\n         Some(ext)\n     }\n \n+    // FIXME: `extra_placeholders` should be included into the `fragment` as regular placeholders.\n     crate fn build_reduced_graph(\n-        &mut self, fragment: &AstFragment, parent_scope: ParentScope<'a>\n+        &mut self,\n+        fragment: &AstFragment,\n+        extra_placeholders: &[NodeId],\n+        parent_scope: ParentScope<'a>,\n     ) -> LegacyScope<'a> {\n-        fragment.visit_with(&mut DefCollector::new(&mut self.definitions, parent_scope.expansion));\n+        let mut def_collector = DefCollector::new(&mut self.definitions, parent_scope.expansion);\n+        fragment.visit_with(&mut def_collector);\n+        for placeholder in extra_placeholders {\n+            def_collector.visit_macro_invoc(*placeholder);\n+        }\n+\n         let mut visitor = BuildReducedGraphVisitor { r: self, parent_scope };\n         fragment.visit_with(&mut visitor);\n+        for placeholder in extra_placeholders {\n+            visitor.parent_scope.legacy = visitor.visit_invoc(*placeholder);\n+        }\n+\n         visitor.parent_scope.legacy\n     }\n \n@@ -871,7 +884,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     /// Builds the reduced graph for a single item in an external crate.\n-    fn build_reduced_graph_for_external_crate_res(&mut self, child: Export<ast::NodeId>) {\n+    fn build_reduced_graph_for_external_crate_res(&mut self, child: Export<NodeId>) {\n         let parent = self.parent_scope.module;\n         let Export { ident, res, vis, span } = child;\n         // FIXME: We shouldn't create the gensym here, it should come from metadata,\n@@ -1060,10 +1073,10 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         false\n     }\n \n-    fn visit_invoc(&mut self, id: ast::NodeId) -> LegacyScope<'a> {\n+    fn visit_invoc(&mut self, id: NodeId) -> LegacyScope<'a> {\n         let invoc_id = id.placeholder_to_expn_id();\n \n-        self.parent_scope.module.unresolved_invocations.borrow_mut().insert(invoc_id);\n+        self.parent_scope.module.unexpanded_invocations.borrow_mut().insert(invoc_id);\n \n         let old_parent_scope = self.r.invocation_parent_scopes.insert(invoc_id, self.parent_scope);\n         assert!(old_parent_scope.is_none(), \"invocation data is reset for an invocation\");"}, {"sha": "2dd0ad13c526d80b4d653db5df3e474b69a94d01", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b60f245b9542142ed01318a7ab5b46fc2ffb283e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60f245b9542142ed01318a7ab5b46fc2ffb283e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b60f245b9542142ed01318a7ab5b46fc2ffb283e", "patch": "@@ -448,7 +448,7 @@ pub struct ModuleData<'a> {\n     populate_on_access: Cell<bool>,\n \n     // Macro invocations that can expand into items in this module.\n-    unresolved_invocations: RefCell<FxHashSet<ExpnId>>,\n+    unexpanded_invocations: RefCell<FxHashSet<ExpnId>>,\n \n     no_implicit_prelude: bool,\n \n@@ -478,7 +478,7 @@ impl<'a> ModuleData<'a> {\n             normal_ancestor_id,\n             lazy_resolutions: Default::default(),\n             populate_on_access: Cell::new(!normal_ancestor_id.is_local()),\n-            unresolved_invocations: Default::default(),\n+            unexpanded_invocations: Default::default(),\n             no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new(Vec::new()),"}, {"sha": "01ad67252a387886f630a7e01ed12f14ad33bd15", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b60f245b9542142ed01318a7ab5b46fc2ffb283e/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60f245b9542142ed01318a7ab5b46fc2ffb283e/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=b60f245b9542142ed01318a7ab5b46fc2ffb283e", "patch": "@@ -10,7 +10,7 @@ use crate::resolve_imports::ImportResolver;\n use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc::middle::stability;\n use rustc::{ty, lint, span_bug};\n-use syntax::ast::{self, Ident};\n+use syntax::ast::{self, NodeId, Ident};\n use syntax::attr::StabilityLevel;\n use syntax::edition::Edition;\n use syntax::ext::base::{self, Indeterminate, SpecialDerives};\n@@ -26,7 +26,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use std::{mem, ptr};\n use rustc_data_structures::sync::Lrc;\n \n-type Res = def::Res<ast::NodeId>;\n+type Res = def::Res<NodeId>;\n \n /// Binding produced by a `macro_rules` item.\n /// Not modularized, can shadow previous legacy bindings, etc.\n@@ -91,11 +91,11 @@ fn fast_print_path(path: &ast::Path) -> Symbol {\n }\n \n impl<'a> base::Resolver for Resolver<'a> {\n-    fn next_node_id(&mut self) -> ast::NodeId {\n+    fn next_node_id(&mut self) -> NodeId {\n         self.session.next_node_id()\n     }\n \n-    fn get_module_scope(&mut self, id: ast::NodeId) -> ExpnId {\n+    fn get_module_scope(&mut self, id: NodeId) -> ExpnId {\n         let expn_id = ExpnId::fresh(Some(ExpnData::default(\n             ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, self.session.edition()\n         )));\n@@ -115,23 +115,18 @@ impl<'a> base::Resolver for Resolver<'a> {\n         });\n     }\n \n+    // FIXME: `extra_placeholders` should be included into the `fragment` as regular placeholders.\n     fn visit_ast_fragment_with_placeholders(\n-        &mut self, expansion: ExpnId, fragment: &AstFragment, derives: &[ExpnId]\n+        &mut self, expansion: ExpnId, fragment: &AstFragment, extra_placeholders: &[NodeId]\n     ) {\n-        // Fill in some data for derives if the fragment is from a derive container.\n+        // Integrate the new AST fragment into all the definition and module structures.\n         // We are inside the `expansion` now, but other parent scope components are still the same.\n         let parent_scope = ParentScope { expansion, ..self.invocation_parent_scopes[&expansion] };\n-        let parent_def = self.definitions.invocation_parent(expansion);\n-        self.invocation_parent_scopes.extend(derives.iter().map(|&derive| (derive, parent_scope)));\n-        for &derive_invoc_id in derives {\n-            self.definitions.set_invocation_parent(derive_invoc_id, parent_def);\n-        }\n-        parent_scope.module.unresolved_invocations.borrow_mut().remove(&expansion);\n-        parent_scope.module.unresolved_invocations.borrow_mut().extend(derives);\n-\n-        // Integrate the new AST fragment into all the definition and module structures.\n-        let output_legacy_scope = self.build_reduced_graph(fragment, parent_scope);\n+        let output_legacy_scope =\n+            self.build_reduced_graph(fragment, extra_placeholders, parent_scope);\n         self.output_legacy_scopes.insert(expansion, output_legacy_scope);\n+\n+        parent_scope.module.unexpanded_invocations.borrow_mut().remove(&expansion);\n     }\n \n     fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension) {\n@@ -485,7 +480,7 @@ impl<'a> Resolver<'a> {\n                 Scope::MacroUsePrelude => match this.macro_use_prelude.get(&ident.name).cloned() {\n                     Some(binding) => Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE)),\n                     None => Err(Determinacy::determined(\n-                        this.graph_root.unresolved_invocations.borrow().is_empty()\n+                        this.graph_root.unexpanded_invocations.borrow().is_empty()\n                     ))\n                 }\n                 Scope::BuiltinAttrs => if is_builtin_attr_name(ident.name) {\n@@ -508,7 +503,7 @@ impl<'a> Resolver<'a> {\n                 Scope::ExternPrelude => match this.extern_prelude_get(ident, !record_used) {\n                     Some(binding) => Ok((binding, Flags::PRELUDE)),\n                     None => Err(Determinacy::determined(\n-                        this.graph_root.unresolved_invocations.borrow().is_empty()\n+                        this.graph_root.unexpanded_invocations.borrow().is_empty()\n                     )),\n                 }\n                 Scope::ToolPrelude => if KNOWN_TOOLS.contains(&ident.name) {"}, {"sha": "fd222a132a3f8589c53df38bff1849c8edb759e5", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b60f245b9542142ed01318a7ab5b46fc2ffb283e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60f245b9542142ed01318a7ab5b46fc2ffb283e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=b60f245b9542142ed01318a7ab5b46fc2ffb283e", "patch": "@@ -202,7 +202,7 @@ impl<'a> Resolver<'a> {\n                     Err((Determined, Weak::No))\n                 } else if let Some(binding) = self.extern_prelude_get(ident, !record_used) {\n                     Ok(binding)\n-                } else if !self.graph_root.unresolved_invocations.borrow().is_empty() {\n+                } else if !self.graph_root.unexpanded_invocations.borrow().is_empty() {\n                     // Macro-expanded `extern crate` items can add names to extern prelude.\n                     Err((Undetermined, Weak::No))\n                 } else {\n@@ -348,7 +348,7 @@ impl<'a> Resolver<'a> {\n         // progress, we have to ignore those potential unresolved invocations from other modules\n         // and prohibit access to macro-expanded `macro_export` macros instead (unless restricted\n         // shadowing is enabled, see `macro_expanded_macro_export_errors`).\n-        let unexpanded_macros = !module.unresolved_invocations.borrow().is_empty();\n+        let unexpanded_macros = !module.unexpanded_invocations.borrow().is_empty();\n         if let Some(binding) = resolution.binding {\n             if !unexpanded_macros || ns == MacroNS || restricted_shadowing {\n                 return check_usable(self, binding);"}, {"sha": "b0a4a6af9839c4fd91e6f33541b241c3f313593c", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b60f245b9542142ed01318a7ab5b46fc2ffb283e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60f245b9542142ed01318a7ab5b46fc2ffb283e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=b60f245b9542142ed01318a7ab5b46fc2ffb283e", "patch": "@@ -1,4 +1,4 @@\n-use crate::ast::{self, Attribute, Name, PatKind};\n+use crate::ast::{self, NodeId, Attribute, Name, PatKind};\n use crate::attr::{HasAttrs, Stability, Deprecation};\n use crate::source_map::SourceMap;\n use crate::edition::Edition;\n@@ -671,13 +671,13 @@ bitflags::bitflags! {\n }\n \n pub trait Resolver {\n-    fn next_node_id(&mut self) -> ast::NodeId;\n+    fn next_node_id(&mut self) -> NodeId;\n \n-    fn get_module_scope(&mut self, id: ast::NodeId) -> ExpnId;\n+    fn get_module_scope(&mut self, id: NodeId) -> ExpnId;\n \n     fn resolve_dollar_crates(&mut self);\n     fn visit_ast_fragment_with_placeholders(&mut self, expn_id: ExpnId, fragment: &AstFragment,\n-                                            derives: &[ExpnId]);\n+                                            extra_placeholders: &[NodeId]);\n     fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension);\n \n     fn resolve_imports(&mut self);"}, {"sha": "c1d52c9745529125ddcfed00d900d8bd5d65731c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b60f245b9542142ed01318a7ab5b46fc2ffb283e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60f245b9542142ed01318a7ab5b46fc2ffb283e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b60f245b9542142ed01318a7ab5b46fc2ffb283e", "patch": "@@ -291,7 +291,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         // Unresolved macros produce dummy outputs as a recovery measure.\n         invocations.reverse();\n         let mut expanded_fragments = Vec::new();\n-        let mut derives: FxHashMap<ExpnId, Vec<_>> = FxHashMap::default();\n+        let mut all_derive_placeholders: FxHashMap<ExpnId, Vec<_>> = FxHashMap::default();\n         let mut undetermined_invocations = Vec::new();\n         let (mut progress, mut force) = (false, !self.monotonic);\n         loop {\n@@ -347,13 +347,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n                 let mut item = self.fully_configure(item);\n                 item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n-                let derives = derives.entry(invoc.expansion_data.id).or_default();\n+                let derive_placeholders =\n+                    all_derive_placeholders.entry(invoc.expansion_data.id).or_default();\n \n-                derives.reserve(traits.len());\n+                derive_placeholders.reserve(traits.len());\n                 invocations.reserve(traits.len());\n                 for path in traits {\n                     let expn_id = ExpnId::fresh(None);\n-                    derives.push(expn_id);\n+                    derive_placeholders.push(NodeId::placeholder_from_expn_id(expn_id));\n                     invocations.push(Invocation {\n                         kind: InvocationKind::Derive { path, item: item.clone() },\n                         fragment_kind: invoc.fragment_kind,\n@@ -365,7 +366,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n                 let fragment = invoc.fragment_kind\n                     .expect_from_annotatables(::std::iter::once(item));\n-                self.collect_invocations(fragment, derives)\n+                self.collect_invocations(fragment, derive_placeholders)\n             } else {\n                 unreachable!()\n             };\n@@ -384,10 +385,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         // Finally incorporate all the expanded macros into the input AST fragment.\n         let mut placeholder_expander = PlaceholderExpander::new(self.cx, self.monotonic);\n         while let Some(expanded_fragments) = expanded_fragments.pop() {\n-            for (mark, expanded_fragment) in expanded_fragments.into_iter().rev() {\n-                let derives = derives.remove(&mark).unwrap_or_else(Vec::new);\n-                placeholder_expander.add(NodeId::placeholder_from_expn_id(mark),\n-                                         expanded_fragment, derives);\n+            for (expn_id, expanded_fragment) in expanded_fragments.into_iter().rev() {\n+                let derive_placeholders =\n+                    all_derive_placeholders.remove(&expn_id).unwrap_or_else(Vec::new);\n+                placeholder_expander.add(NodeId::placeholder_from_expn_id(expn_id),\n+                                         expanded_fragment, derive_placeholders);\n             }\n         }\n         fragment_with_placeholders.mut_visit_with(&mut placeholder_expander);\n@@ -404,7 +406,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     /// them with \"placeholders\" - dummy macro invocations with specially crafted `NodeId`s.\n     /// Then call into resolver that builds a skeleton (\"reduced graph\") of the fragment and\n     /// prepares data for resolving paths of macro invocations.\n-    fn collect_invocations(&mut self, mut fragment: AstFragment, derives: &[ExpnId])\n+    fn collect_invocations(&mut self, mut fragment: AstFragment, extra_placeholders: &[NodeId])\n                            -> (AstFragment, Vec<Invocation>) {\n         // Resolve `$crate`s in the fragment for pretty-printing.\n         self.cx.resolver.resolve_dollar_crates();\n@@ -423,9 +425,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             collector.invocations\n         };\n \n+        // FIXME: Merge `extra_placeholders` into the `fragment` as regular placeholders.\n         if self.monotonic {\n             self.cx.resolver.visit_ast_fragment_with_placeholders(\n-                self.cx.current_expansion.id, &fragment, derives);\n+                self.cx.current_expansion.id, &fragment, extra_placeholders);\n         }\n \n         (fragment, invocations)"}, {"sha": "d800cfedcfb4b27796b7a01f34ba3081479f0a2e", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b60f245b9542142ed01318a7ab5b46fc2ffb283e/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60f245b9542142ed01318a7ab5b46fc2ffb283e/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=b60f245b9542142ed01318a7ab5b46fc2ffb283e", "patch": "@@ -2,7 +2,6 @@ use crate::ast::{self, NodeId};\n use crate::source_map::{DUMMY_SP, dummy_spanned};\n use crate::ext::base::ExtCtxt;\n use crate::ext::expand::{AstFragment, AstFragmentKind};\n-use crate::ext::hygiene::ExpnId;\n use crate::tokenstream::TokenStream;\n use crate::mut_visit::*;\n use crate::ptr::P;\n@@ -86,11 +85,11 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n         }\n     }\n \n-    pub fn add(&mut self, id: ast::NodeId, mut fragment: AstFragment, derives: Vec<ExpnId>) {\n+    pub fn add(&mut self, id: ast::NodeId, mut fragment: AstFragment, placeholders: Vec<NodeId>) {\n         fragment.mut_visit_with(self);\n         if let AstFragment::Items(mut items) = fragment {\n-            for derive in derives {\n-                match self.remove(NodeId::placeholder_from_expn_id(derive)) {\n+            for placeholder in placeholders {\n+                match self.remove(placeholder) {\n                     AstFragment::Items(derived_items) => items.extend(derived_items),\n                     _ => unreachable!(),\n                 }"}, {"sha": "d4b67d6b0b07c419a2a72ef63aec4ef7a348473e", "filename": "src/test/ui/proc-macro/auxiliary/gen-macro-rules.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b60f245b9542142ed01318a7ab5b46fc2ffb283e/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fgen-macro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60f245b9542142ed01318a7ab5b46fc2ffb283e/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fgen-macro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fgen-macro-rules.rs?ref=b60f245b9542142ed01318a7ab5b46fc2ffb283e", "patch": "@@ -0,0 +1,12 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(repro)]\n+pub fn proc_macro_hack_expr(_input: TokenStream) -> TokenStream {\n+    \"macro_rules! m {()=>{}}\".parse().unwrap()\n+}"}, {"sha": "13ad27f9372521acd2dfe32f864efd04526ec21e", "filename": "src/test/ui/proc-macro/gen-macro-rules.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b60f245b9542142ed01318a7ab5b46fc2ffb283e/src%2Ftest%2Fui%2Fproc-macro%2Fgen-macro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60f245b9542142ed01318a7ab5b46fc2ffb283e/src%2Ftest%2Fui%2Fproc-macro%2Fgen-macro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgen-macro-rules.rs?ref=b60f245b9542142ed01318a7ab5b46fc2ffb283e", "patch": "@@ -0,0 +1,13 @@\n+// Derive macros can generate `macro_rules` items, regression test for issue #63651.\n+\n+// check-pass\n+// aux-build:gen-macro-rules.rs\n+\n+extern crate gen_macro_rules as repro;\n+\n+#[derive(repro::repro)]\n+pub struct S;\n+\n+m!(); // OK\n+\n+fn main() {}"}]}