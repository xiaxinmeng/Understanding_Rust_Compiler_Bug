{"sha": "e7e22b47ad25f03c9a085f0b99346cab201847db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3ZTIyYjQ3YWQyNWYwM2M5YTA4NWYwYjk5MzQ2Y2FiMjAxODQ3ZGI=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-04-25T21:15:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-25T21:15:10Z"}, "message": "Rollup merge of #84235 - klensy:styled-buffer, r=lcnr\n\nrefactor StyledBuffer\n\nRefactors StyledBuffer `text` and `styles` fields content into StyledChar and touches some other stuff.", "tree": {"sha": "8706296b6a48bc25cd69de2f973f8c96cb31867a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8706296b6a48bc25cd69de2f973f8c96cb31867a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7e22b47ad25f03c9a085f0b99346cab201847db", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJghdvfCRBK7hj4Ov3rIwAA2psIAGMLpqIzjVbg+RzEvRTEA8JR\nwg120ZOR80G3SA8Tp+NiKIxVbCS4AfVYJSAXVvq1wlSR/KgPg4ktWgmPEIgJFWlP\nl+S7nH/VoQ5aXpQeH+93lGxbqFT9tqobKBEUWmrhcSh1mlqzxzz6EFW7M/Z/yGL4\nxIjuzefVl1yX/9YlCTBojl4fPY/W4NKHgMaylNRdUo1ptaET+tiiXSVM38QgXP4R\nAtDWF/m2fkhPRlcwVeZ5Y8XkpMTeLgGc2lQ6uR87u/XGmUtSgWqjDJmtigG0TiFP\nFgGUuvm9++cQ3T2oH+j0qPyJcm4fmy91OBbZ1zghFVq8O4qn0vGGGgum9YOHFoc=\n=nztS\n-----END PGP SIGNATURE-----\n", "payload": "tree 8706296b6a48bc25cd69de2f973f8c96cb31867a\nparent e7ed7e835494219eeab314ace8beef40b695ce30\nparent 8ebd811b32de96c0e9e4208703465016da3d8764\nauthor Dylan DPC <dylan.dpc@gmail.com> 1619385310 +0200\ncommitter GitHub <noreply@github.com> 1619385310 +0200\n\nRollup merge of #84235 - klensy:styled-buffer, r=lcnr\n\nrefactor StyledBuffer\n\nRefactors StyledBuffer `text` and `styles` fields content into StyledChar and touches some other stuff.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7e22b47ad25f03c9a085f0b99346cab201847db", "html_url": "https://github.com/rust-lang/rust/commit/e7e22b47ad25f03c9a085f0b99346cab201847db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7e22b47ad25f03c9a085f0b99346cab201847db/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7ed7e835494219eeab314ace8beef40b695ce30", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7ed7e835494219eeab314ace8beef40b695ce30", "html_url": "https://github.com/rust-lang/rust/commit/e7ed7e835494219eeab314ace8beef40b695ce30"}, {"sha": "8ebd811b32de96c0e9e4208703465016da3d8764", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ebd811b32de96c0e9e4208703465016da3d8764", "html_url": "https://github.com/rust-lang/rust/commit/8ebd811b32de96c0e9e4208703465016da3d8764"}], "stats": {"total": 90, "additions": 55, "deletions": 35}, "files": [{"sha": "e262d95bb70f251bc4caf76bbaf7f823d9b5c084", "filename": "compiler/rustc_errors/src/styled_buffer.rs", "status": "modified", "additions": 55, "deletions": 35, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e7e22b47ad25f03c9a085f0b99346cab201847db/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e22b47ad25f03c9a085f0b99346cab201847db/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs?ref=e7e22b47ad25f03c9a085f0b99346cab201847db", "patch": "@@ -1,39 +1,52 @@\n // Code for creating styled buffers\n \n use crate::snippet::{Style, StyledString};\n-use std::iter;\n \n #[derive(Debug)]\n pub struct StyledBuffer {\n-    text: Vec<Vec<char>>,\n-    styles: Vec<Vec<Style>>,\n+    lines: Vec<Vec<StyledChar>>,\n+}\n+\n+#[derive(Debug, Clone)]\n+struct StyledChar {\n+    chr: char,\n+    style: Style,\n+}\n+\n+impl StyledChar {\n+    const SPACE: Self = StyledChar::new(' ', Style::NoStyle);\n+\n+    const fn new(chr: char, style: Style) -> Self {\n+        StyledChar { chr, style }\n+    }\n }\n \n impl StyledBuffer {\n     pub fn new() -> StyledBuffer {\n-        StyledBuffer { text: vec![], styles: vec![] }\n+        StyledBuffer { lines: vec![] }\n     }\n \n+    /// Returns content of `StyledBuffer` splitted by lines and line styles\n     pub fn render(&self) -> Vec<Vec<StyledString>> {\n         // Tabs are assumed to have been replaced by spaces in calling code.\n-        debug_assert!(self.text.iter().all(|r| !r.contains(&'\\t')));\n+        debug_assert!(self.lines.iter().all(|r| !r.iter().any(|sc| sc.chr == '\\t')));\n \n         let mut output: Vec<Vec<StyledString>> = vec![];\n         let mut styled_vec: Vec<StyledString> = vec![];\n \n-        for (row, row_style) in iter::zip(&self.text, &self.styles) {\n+        for styled_line in &self.lines {\n             let mut current_style = Style::NoStyle;\n             let mut current_text = String::new();\n \n-            for (&c, &s) in iter::zip(row, row_style) {\n-                if s != current_style {\n+            for sc in styled_line {\n+                if sc.style != current_style {\n                     if !current_text.is_empty() {\n                         styled_vec.push(StyledString { text: current_text, style: current_style });\n                     }\n-                    current_style = s;\n+                    current_style = sc.style;\n                     current_text = String::new();\n                 }\n-                current_text.push(c);\n+                current_text.push(sc.chr);\n             }\n             if !current_text.is_empty() {\n                 styled_vec.push(StyledString { text: current_text, style: current_style });\n@@ -49,29 +62,25 @@ impl StyledBuffer {\n     }\n \n     fn ensure_lines(&mut self, line: usize) {\n-        while line >= self.text.len() {\n-            self.text.push(vec![]);\n-            self.styles.push(vec![]);\n+        if line >= self.lines.len() {\n+            self.lines.resize(line + 1, Vec::new());\n         }\n     }\n \n+    /// Sets `chr` with `style` for given `line`, `col`.\n+    /// If `line` does not exist in our buffer, adds empty lines up to the given\n+    /// and fills the last line with unstyled whitespace.\n     pub fn putc(&mut self, line: usize, col: usize, chr: char, style: Style) {\n         self.ensure_lines(line);\n-        if col < self.text[line].len() {\n-            self.text[line][col] = chr;\n-            self.styles[line][col] = style;\n-        } else {\n-            let mut i = self.text[line].len();\n-            while i < col {\n-                self.text[line].push(' ');\n-                self.styles[line].push(Style::NoStyle);\n-                i += 1;\n-            }\n-            self.text[line].push(chr);\n-            self.styles[line].push(style);\n+        if col >= self.lines[line].len() {\n+            self.lines[line].resize(col + 1, StyledChar::SPACE);\n         }\n+        self.lines[line][col] = StyledChar::new(chr, style);\n     }\n \n+    /// Sets `string` with `style` for given `line`, starting from `col`.\n+    /// If `line` does not exist in our buffer, adds empty lines up to the given\n+    /// and fills the last line with unstyled whitespace.\n     pub fn puts(&mut self, line: usize, col: usize, string: &str, style: Style) {\n         let mut n = col;\n         for c in string.chars() {\n@@ -80,32 +89,40 @@ impl StyledBuffer {\n         }\n     }\n \n+    /// For given `line` inserts `string` with `style` before old content of that line,\n+    /// adding lines if needed\n     pub fn prepend(&mut self, line: usize, string: &str, style: Style) {\n         self.ensure_lines(line);\n         let string_len = string.chars().count();\n \n-        // Push the old content over to make room for new content\n-        for _ in 0..string_len {\n-            self.styles[line].insert(0, Style::NoStyle);\n-            self.text[line].insert(0, ' ');\n+        if !self.lines[line].is_empty() {\n+            // Push the old content over to make room for new content\n+            for _ in 0..string_len {\n+                self.lines[line].insert(0, StyledChar::SPACE);\n+            }\n         }\n \n         self.puts(line, 0, string, style);\n     }\n \n+    /// For given `line` inserts `string` with `style` after old content of that line,\n+    /// adding lines if needed\n     pub fn append(&mut self, line: usize, string: &str, style: Style) {\n-        if line >= self.text.len() {\n+        if line >= self.lines.len() {\n             self.puts(line, 0, string, style);\n         } else {\n-            let col = self.text[line].len();\n+            let col = self.lines[line].len();\n             self.puts(line, col, string, style);\n         }\n     }\n \n     pub fn num_lines(&self) -> usize {\n-        self.text.len()\n+        self.lines.len()\n     }\n \n+    /// Set `style` for `line`, `col_start..col_end` range if:\n+    /// 1. That line and column range exist in `StyledBuffer`\n+    /// 2. `overwrite` is `true` or existing style is `Style::NoStyle` or `Style::Quotation`\n     pub fn set_style_range(\n         &mut self,\n         line: usize,\n@@ -119,10 +136,13 @@ impl StyledBuffer {\n         }\n     }\n \n+    /// Set `style` for `line`, `col` if:\n+    /// 1. That line and column exist in `StyledBuffer`\n+    /// 2. `overwrite` is `true` or existing style is `Style::NoStyle` or `Style::Quotation`\n     pub fn set_style(&mut self, line: usize, col: usize, style: Style, overwrite: bool) {\n-        if let Some(ref mut line) = self.styles.get_mut(line) {\n-            if let Some(s) = line.get_mut(col) {\n-                if *s == Style::NoStyle || *s == Style::Quotation || overwrite {\n+        if let Some(ref mut line) = self.lines.get_mut(line) {\n+            if let Some(StyledChar { style: s, .. }) = line.get_mut(col) {\n+                if overwrite || *s == Style::NoStyle || *s == Style::Quotation {\n                     *s = style;\n                 }\n             }"}]}