{"sha": "f81b1fcf8c9fccfb9c2465ee19317328e4dfe5b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4MWIxZmNmOGM5ZmNjZmI5YzI0NjVlZTE5MzE3MzI4ZTRkZmU1YjE=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-18T20:01:28Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-20T13:37:49Z"}, "message": "TRPL edits: method syntax", "tree": {"sha": "7700c9c1908666f44d13184b437ac3c381943614", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7700c9c1908666f44d13184b437ac3c381943614"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f81b1fcf8c9fccfb9c2465ee19317328e4dfe5b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f81b1fcf8c9fccfb9c2465ee19317328e4dfe5b1", "html_url": "https://github.com/rust-lang/rust/commit/f81b1fcf8c9fccfb9c2465ee19317328e4dfe5b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f81b1fcf8c9fccfb9c2465ee19317328e4dfe5b1/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f43c5782cb252ba800d44a17b5c184aedffb6c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f43c5782cb252ba800d44a17b5c184aedffb6c7", "html_url": "https://github.com/rust-lang/rust/commit/7f43c5782cb252ba800d44a17b5c184aedffb6c7"}], "stats": {"total": 71, "additions": 35, "deletions": 36}, "files": [{"sha": "5853f3d679c5f5231f185af1d1d940eed1a30c70", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f81b1fcf8c9fccfb9c2465ee19317328e4dfe5b1/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/f81b1fcf8c9fccfb9c2465ee19317328e4dfe5b1/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=f81b1fcf8c9fccfb9c2465ee19317328e4dfe5b1", "patch": "@@ -3,27 +3,26 @@\n Functions are great, but if you want to call a bunch of them on some data, it\n can be awkward. Consider this code:\n \n-```{rust,ignore}\n+```rust,ignore\n baz(bar(foo)));\n ```\n \n-We would read this left-to right, and so we see \"baz bar foo.\" But this isn't the\n-order that the functions would get called in, that's inside-out: \"foo bar baz.\"\n-Wouldn't it be nice if we could do this instead?\n+We would read this left-to right, and so we see \u2018baz bar foo\u2019. But this isn\u2019t the\n+order that the functions would get called in, that\u2019s inside-out: \u2018foo bar baz\u2019.\n+Wouldn\u2019t it be nice if we could do this instead?\n \n-```{rust,ignore}\n+```rust,ignore\n foo.bar().baz();\n ```\n \n Luckily, as you may have guessed with the leading question, you can! Rust provides\n-the ability to use this *method call syntax* via the `impl` keyword.\n+the ability to use this \u2018method call syntax\u2019 via the `impl` keyword.\n \n ## Method calls\n \n-Here's how it works:\n+Here\u2019s how it works:\n \n-```{rust}\n-# #![feature(core)]\n+```rust\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -44,15 +43,23 @@ fn main() {\n \n This will print `12.566371`.\n \n-We've made a struct that represents a circle. We then write an `impl` block,\n-and inside it, define a method, `area`. Methods take a  special first\n-parameter, of which there are three variants: `self`, `&self`, and `&mut self`.\n-You can think of this first parameter as being the `foo` in `foo.bar()`. The three\n-variants correspond to the three kinds of things `foo` could be: `self` if it's\n-just a value on the stack, `&self` if it's a reference, and `&mut self` if it's\n-a mutable reference. We should default to using `&self`, as you should prefer\n-borrowing over taking ownership, as well as taking immutable references\n-over mutable ones. Here's an example of all three variants:\n+\n+\n+We\u2019ve made a struct that represents a circle. We then write an `impl` block,\n+and inside it, define a method, `area`.\n+\n+Methods take a  special first parameter, of which there are three variants:\n+`self`, `&self`, and `&mut self`. You can think of this first parameter as\n+being the `foo` in `foo.bar()`. The three variants correspond to the three\n+kinds of things `foo` could be: `self` if it\u2019s just a value on the stack,\n+`&self` if it\u2019s a reference, and `&mut self` if it\u2019s a mutable reference.\n+Because we took the `&self` parameter to `area`, we can use it just like any\n+other parameter. Because we know it\u2019s a `Circle`, we can access the `radius`\n+just like we would with any other struct. \n+\n+We should default to using `&self`, as you should prefer borrowing over taking\n+ownership, as well as taking immutable references over mutable ones. Here\u2019s an\n+example of all three variants:\n \n ```rust\n struct Circle {\n@@ -76,20 +83,13 @@ impl Circle {\n }\n ```\n \n-Finally, as you may remember, the value of the area of a circle is `\u03c0*r\u00b2`.\n-Because we took the `&self` parameter to `area`, we can use it just like any\n-other parameter. Because we know it's a `Circle`, we can access the `radius`\n-just like we would with any other struct. An import of \u03c0 and some\n-multiplications later, and we have our area.\n-\n ## Chaining method calls\n \n So, now we know how to call a method, such as `foo.bar()`. But what about our\n-original example, `foo.bar().baz()`? This is called 'method chaining', and we\n+original example, `foo.bar().baz()`? This is called \u2018method chaining\u2019, and we\n can do it by returning `self`.\n \n ```\n-# #![feature(core)]\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -124,13 +124,13 @@ fn grow(&self) -> Circle {\n # Circle } }\n ```\n \n-We just say we're returning a `Circle`. With this method, we can grow a new\n+We just say we\u2019re returning a `Circle`. With this method, we can grow a new\n circle to any arbitrary size.\n \n ## Static methods\n \n-You can also define methods that do not take a `self` parameter. Here's a\n-pattern that's very common in Rust code:\n+You can also define methods that do not take a `self` parameter. Here\u2019s a\n+pattern that\u2019s very common in Rust code:\n \n ```\n struct Circle {\n@@ -154,20 +154,19 @@ fn main() {\n }\n ```\n \n-This *static method* builds a new `Circle` for us. Note that static methods\n+This \u2018static method\u2019 builds a new `Circle` for us. Note that static methods\n are called with the `Struct::method()` syntax, rather than the `ref.method()`\n syntax.\n \n ## Builder Pattern\n \n-Let's say that we want our users to be able to create Circles, but we will\n+Let\u2019s say that we want our users to be able to create Circles, but we will\n allow them to only set the properties they care about. Otherwise, the `x`\n-and `y` attributes will be `0.0`, and the `radius` will be `1.0`. Rust doesn't\n+and `y` attributes will be `0.0`, and the `radius` will be `1.0`. Rust doesn\u2019t\n have method overloading, named arguments, or variable arguments. We employ\n the builder pattern instead. It looks like this:\n \n ```\n-# #![feature(core)]\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -224,9 +223,9 @@ fn main() {\n }\n ```\n \n-What we've done here is make another struct, `CircleBuilder`. We've defined our\n-builder methods on it. We've also defined our `area()` method on `Circle`. We\n+What we\u2019ve done here is make another struct, `CircleBuilder`. We\u2019ve defined our\n+builder methods on it. We\u2019ve also defined our `area()` method on `Circle`. We\n also made one more method on `CircleBuilder`: `finalize()`. This method creates\n-our final `Circle` from the builder. Now, we've used the type system to enforce\n+our final `Circle` from the builder. Now, we\u2019ve used the type system to enforce\n our concerns: we can use the methods on `CircleBuilder` to constrain making\n `Circle`s in any way we choose."}]}