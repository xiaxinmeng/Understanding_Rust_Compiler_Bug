{"sha": "49c1b07a9e09af5d01150c53b50676a5bc2e402d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5YzFiMDdhOWUwOWFmNWQwMTE1MGM1M2I1MDY3NmE1YmMyZTQwMmQ=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-10-18T19:01:36Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-02-19T16:51:49Z"}, "message": "Decouple QueryContext from DepContext.", "tree": {"sha": "d42049e3ba37ae29387b0b5e04e7d43534e90c09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d42049e3ba37ae29387b0b5e04e7d43534e90c09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49c1b07a9e09af5d01150c53b50676a5bc2e402d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49c1b07a9e09af5d01150c53b50676a5bc2e402d", "html_url": "https://github.com/rust-lang/rust/commit/49c1b07a9e09af5d01150c53b50676a5bc2e402d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49c1b07a9e09af5d01150c53b50676a5bc2e402d/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f048830231380011badb15eee30eb1655485d62", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f048830231380011badb15eee30eb1655485d62", "html_url": "https://github.com/rust-lang/rust/commit/6f048830231380011badb15eee30eb1655485d62"}], "stats": {"total": 140, "additions": 87, "deletions": 53}, "files": [{"sha": "ea889549e43da46a77b6cb8c9aa80af828a566d0", "filename": "compiler/rustc_middle/src/ty/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c1b07a9e09af5d01150c53b50676a5bc2e402d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c1b07a9e09af5d01150c53b50676a5bc2e402d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs?ref=49c1b07a9e09af5d01150c53b50676a5bc2e402d", "patch": "@@ -48,7 +48,7 @@ impl QueryContext for TyCtxt<'tcx> {\n         &self,\n         token: QueryJobId<Self::DepKind>,\n         diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n-        compute: impl FnOnce(Self) -> R,\n+        compute: impl FnOnce() -> R,\n     ) -> R {\n         // The `TyCtxt` stored in TLS has the same global interner lifetime\n         // as `self`, so we use `with_related_context` to relate the 'tcx lifetimes\n@@ -65,7 +65,7 @@ impl QueryContext for TyCtxt<'tcx> {\n \n             // Use the `ImplicitCtxt` while we execute the query.\n             tls::enter_context(&new_icx, |_| {\n-                rustc_data_structures::stack::ensure_sufficient_stack(|| compute(*self))\n+                rustc_data_structures::stack::ensure_sufficient_stack(compute)\n             })\n         })\n     }"}, {"sha": "9b0810e03f741c83fbe27658eba67c0210df3460", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/49c1b07a9e09af5d01150c53b50676a5bc2e402d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c1b07a9e09af5d01150c53b50676a5bc2e402d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=49c1b07a9e09af5d01150c53b50676a5bc2e402d", "patch": "@@ -23,7 +23,7 @@ use super::debug::EdgeFilter;\n use super::prev::PreviousDepGraph;\n use super::query::DepGraphQuery;\n use super::serialized::SerializedDepNodeIndex;\n-use super::{DepContext, DepKind, DepNode, WorkProductId};\n+use super::{DepContext, DepKind, DepNode, HasDepContext, WorkProductId};\n \n #[derive(Clone)]\n pub struct DepGraph<K: DepKind> {\n@@ -235,7 +235,7 @@ impl<K: DepKind> DepGraph<K> {\n     ///   `arg` parameter.\n     ///\n     /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/incremental-compilation.html\n-    pub fn with_task<Ctxt: DepContext<DepKind = K>, A, R>(\n+    pub fn with_task<Ctxt: HasDepContext<DepKind = K>, A, R>(\n         &self,\n         key: DepNode<K>,\n         cx: Ctxt,\n@@ -261,7 +261,7 @@ impl<K: DepKind> DepGraph<K> {\n         )\n     }\n \n-    fn with_task_impl<Ctxt: DepContext<DepKind = K>, A, R>(\n+    fn with_task_impl<Ctxt: HasDepContext<DepKind = K>, A, R>(\n         &self,\n         key: DepNode<K>,\n         cx: Ctxt,\n@@ -271,14 +271,15 @@ impl<K: DepKind> DepGraph<K> {\n         hash_result: impl FnOnce(&mut Ctxt::StableHashingContext, &R) -> Option<Fingerprint>,\n     ) -> (R, DepNodeIndex) {\n         if let Some(ref data) = self.data {\n+            let dcx = cx.dep_context();\n             let task_deps = create_task(key).map(Lock::new);\n             let result = K::with_deps(task_deps.as_ref(), || task(cx, arg));\n             let edges = task_deps.map_or_else(|| smallvec![], |lock| lock.into_inner().reads);\n \n-            let mut hcx = cx.create_stable_hashing_context();\n+            let mut hcx = dcx.create_stable_hashing_context();\n             let current_fingerprint = hash_result(&mut hcx, &result);\n \n-            let print_status = cfg!(debug_assertions) && cx.debug_dep_tasks();\n+            let print_status = cfg!(debug_assertions) && dcx.debug_dep_tasks();\n \n             // Intern the new `DepNode`.\n             let dep_node_index = if let Some(prev_index) = data.previous.node_to_index_opt(&key) {\n@@ -408,7 +409,7 @@ impl<K: DepKind> DepGraph<K> {\n \n     /// Executes something within an \"eval-always\" task which is a task\n     /// that runs whenever anything changes.\n-    pub fn with_eval_always_task<Ctxt: DepContext<DepKind = K>, A, R>(\n+    pub fn with_eval_always_task<Ctxt: HasDepContext<DepKind = K>, A, R>(\n         &self,\n         key: DepNode<K>,\n         cx: Ctxt,"}, {"sha": "db192d1cfe77a5fbc6979881a26b327a85911495", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/49c1b07a9e09af5d01150c53b50676a5bc2e402d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c1b07a9e09af5d01150c53b50676a5bc2e402d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=49c1b07a9e09af5d01150c53b50676a5bc2e402d", "patch": "@@ -63,6 +63,27 @@ pub trait DepContext: Copy {\n     fn profiler(&self) -> &SelfProfilerRef;\n }\n \n+pub trait HasDepContext: Copy {\n+    type DepKind: self::DepKind;\n+    type StableHashingContext;\n+    type DepContext: self::DepContext<\n+        DepKind = Self::DepKind,\n+        StableHashingContext = Self::StableHashingContext,\n+    >;\n+\n+    fn dep_context(&self) -> &Self::DepContext;\n+}\n+\n+impl<T: DepContext> HasDepContext for T {\n+    type DepKind = T::DepKind;\n+    type StableHashingContext = T::StableHashingContext;\n+    type DepContext = Self;\n+\n+    fn dep_context(&self) -> &Self::DepContext {\n+        self\n+    }\n+}\n+\n /// Describe the different families of dependency nodes.\n pub trait DepKind: Copy + fmt::Debug + Eq + Hash {\n     const NULL: Self;"}, {"sha": "3873b47d4d40b881f524111e660b84069c13a44d", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c1b07a9e09af5d01150c53b50676a5bc2e402d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c1b07a9e09af5d01150c53b50676a5bc2e402d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=49c1b07a9e09af5d01150c53b50676a5bc2e402d", "patch": "@@ -33,9 +33,9 @@ pub(crate) struct QueryVtable<CTX: QueryContext, K, V> {\n }\n \n impl<CTX: QueryContext, K, V> QueryVtable<CTX, K, V> {\n-    pub(crate) fn to_dep_node(&self, tcx: CTX, key: &K) -> DepNode<CTX::DepKind>\n+    pub(crate) fn to_dep_node(&self, tcx: CTX::DepContext, key: &K) -> DepNode<CTX::DepKind>\n     where\n-        K: crate::dep_graph::DepNodeParams<CTX>,\n+        K: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n     {\n         DepNode::construct(tcx, self.dep_kind, key)\n     }"}, {"sha": "0ecc2694a79062497052571ba2cbec6efef0219e", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/49c1b07a9e09af5d01150c53b50676a5bc2e402d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c1b07a9e09af5d01150c53b50676a5bc2e402d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=49c1b07a9e09af5d01150c53b50676a5bc2e402d", "patch": "@@ -10,7 +10,8 @@ use std::num::NonZeroU32;\n \n #[cfg(parallel_compiler)]\n use {\n-    super::QueryContext,\n+    crate::dep_graph::DepContext,\n+    crate::query::QueryContext,\n     parking_lot::{Condvar, Mutex},\n     rustc_data_structures::fx::FxHashSet,\n     rustc_data_structures::stable_hasher::{HashStable, StableHasher},\n@@ -432,7 +433,7 @@ where\n {\n     // Deterministically pick an entry point\n     // FIXME: Sort this instead\n-    let mut hcx = tcx.create_stable_hashing_context();\n+    let mut hcx = tcx.dep_context().create_stable_hashing_context();\n     queries\n         .iter()\n         .min_by_key(|v| {"}, {"sha": "2d678035d4d517cfda419e03fc8b52f5510288ec", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c1b07a9e09af5d01150c53b50676a5bc2e402d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c1b07a9e09af5d01150c53b50676a5bc2e402d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=49c1b07a9e09af5d01150c53b50676a5bc2e402d", "patch": "@@ -14,7 +14,7 @@ pub use self::caches::{\n mod config;\n pub use self::config::{QueryAccessors, QueryConfig, QueryDescription};\n \n-use crate::dep_graph::DepContext;\n+use crate::dep_graph::HasDepContext;\n use crate::query::job::QueryMap;\n \n use rustc_data_structures::stable_hasher::HashStable;\n@@ -23,7 +23,7 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n use rustc_span::def_id::DefId;\n \n-pub trait QueryContext: DepContext {\n+pub trait QueryContext: HasDepContext {\n     type Query: Clone + HashStable<Self::StableHashingContext>;\n \n     fn incremental_verify_ich(&self) -> bool;\n@@ -44,6 +44,6 @@ pub trait QueryContext: DepContext {\n         &self,\n         token: QueryJobId<Self::DepKind>,\n         diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n-        compute: impl FnOnce(Self) -> R,\n+        compute: impl FnOnce() -> R,\n     ) -> R;\n }"}, {"sha": "89f1e6511e319788b4e28fb80c8274b82dec0e7a", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 49, "deletions": 38, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/49c1b07a9e09af5d01150c53b50676a5bc2e402d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c1b07a9e09af5d01150c53b50676a5bc2e402d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=49c1b07a9e09af5d01150c53b50676a5bc2e402d", "patch": "@@ -2,7 +2,7 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::{DepKind, DepNode};\n+use crate::dep_graph::{DepContext, DepKind, DepNode};\n use crate::dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n use crate::query::caches::QueryCache;\n use crate::query::config::{QueryDescription, QueryVtable, QueryVtableExt};\n@@ -204,7 +204,7 @@ where\n                         // in another thread has completed. Record how long we wait in the\n                         // self-profiler.\n                         let _query_blocked_prof_timer = if cfg!(parallel_compiler) {\n-                            Some(tcx.profiler().query_blocked())\n+                            Some(tcx.dep_context().profiler().query_blocked())\n                         } else {\n                             None\n                         };\n@@ -266,8 +266,8 @@ where\n             let cached = cache\n                 .cache\n                 .lookup(cache, &key, |value, index| {\n-                    if unlikely!(tcx.profiler().enabled()) {\n-                        tcx.profiler().query_cache_hit(index.into());\n+                    if unlikely!(tcx.dep_context().profiler().enabled()) {\n+                        tcx.dep_context().profiler().query_cache_hit(index.into());\n                     }\n                     #[cfg(debug_assertions)]\n                     {\n@@ -395,7 +395,7 @@ pub fn try_get_cached<'a, CTX, C, R, OnHit>(\n ) -> Result<R, QueryLookup>\n where\n     C: QueryCache,\n-    CTX: QueryContext,\n+    CTX: DepContext,\n     OnHit: FnOnce(&C::Stored) -> R,\n {\n     cache.cache.lookup(cache, &key, |value, index| {\n@@ -422,7 +422,7 @@ fn try_execute_query<CTX, C>(\n ) -> C::Stored\n where\n     C: QueryCache,\n-    C::Key: crate::dep_graph::DepNodeParams<CTX>,\n+    C::Key: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n     let job = match JobOwner::<'_, CTX::DepKind, CTX::Query, C>::try_start(\n@@ -432,46 +432,51 @@ where\n         TryGetJob::Cycle(result) => return result,\n         #[cfg(parallel_compiler)]\n         TryGetJob::JobCompleted((v, index)) => {\n-            tcx.dep_graph().read_index(index);\n+            tcx.dep_context().dep_graph().read_index(index);\n             return v;\n         }\n     };\n \n     // Fast path for when incr. comp. is off. `to_dep_node` is\n     // expensive for some `DepKind`s.\n-    if !tcx.dep_graph().is_fully_enabled() {\n+    if !tcx.dep_context().dep_graph().is_fully_enabled() {\n         let null_dep_node = DepNode::new_no_params(DepKind::NULL);\n         return force_query_with_job(tcx, key, job, null_dep_node, query).0;\n     }\n \n     if query.anon {\n-        let prof_timer = tcx.profiler().query_provider();\n+        let prof_timer = tcx.dep_context().profiler().query_provider();\n \n         let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n-            tcx.start_query(job.id, diagnostics, |tcx| {\n-                tcx.dep_graph().with_anon_task(query.dep_kind, || query.compute(tcx, key))\n+            tcx.start_query(job.id, diagnostics, || {\n+                tcx.dep_context()\n+                    .dep_graph()\n+                    .with_anon_task(query.dep_kind, || query.compute(tcx, key))\n             })\n         });\n \n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n-        tcx.dep_graph().read_index(dep_node_index);\n+        tcx.dep_context().dep_graph().read_index(dep_node_index);\n \n         if unlikely!(!diagnostics.is_empty()) {\n-            tcx.store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n+            tcx.dep_context().store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n         }\n \n         return job.complete(result, dep_node_index);\n     }\n \n-    let dep_node = query.to_dep_node(tcx, &key);\n+    let dep_node = query.to_dep_node(*tcx.dep_context(), &key);\n \n     if !query.eval_always {\n         // The diagnostics for this query will be\n         // promoted to the current session during\n         // `try_mark_green()`, so we can ignore them here.\n-        let loaded = tcx.start_query(job.id, None, |tcx| {\n-            let marked = tcx.dep_graph().try_mark_green_and_read(tcx, &dep_node);\n+        let loaded = tcx.start_query(job.id, None, || {\n+            let marked = tcx\n+                .dep_context()\n+                .dep_graph()\n+                .try_mark_green_and_read(*tcx.dep_context(), &dep_node);\n             marked.map(|(prev_dep_node_index, dep_node_index)| {\n                 (\n                     load_from_disk_and_cache_in_memory(\n@@ -492,7 +497,7 @@ where\n     }\n \n     let (result, dep_node_index) = force_query_with_job(tcx, key, job, dep_node, query);\n-    tcx.dep_graph().read_index(dep_node_index);\n+    tcx.dep_context().dep_graph().read_index(dep_node_index);\n     result\n }\n \n@@ -510,11 +515,11 @@ where\n     // Note this function can be called concurrently from the same query\n     // We must ensure that this is handled correctly.\n \n-    debug_assert!(tcx.dep_graph().is_green(dep_node));\n+    debug_assert!(tcx.dep_context().dep_graph().is_green(dep_node));\n \n     // First we try to load the result from the on-disk cache.\n     let result = if query.cache_on_disk(tcx, &key, None) {\n-        let prof_timer = tcx.profiler().incr_cache_loading();\n+        let prof_timer = tcx.dep_context().profiler().incr_cache_loading();\n         let result = query.try_load_from_disk(tcx, prev_dep_node_index);\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -536,10 +541,10 @@ where\n     } else {\n         // We could not load a result from the on-disk cache, so\n         // recompute.\n-        let prof_timer = tcx.profiler().query_provider();\n+        let prof_timer = tcx.dep_context().profiler().query_provider();\n \n         // The dep-graph for this computation is already in-place.\n-        let result = tcx.dep_graph().with_ignore(|| query.compute(tcx, key));\n+        let result = tcx.dep_context().dep_graph().with_ignore(|| query.compute(tcx, key));\n \n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -549,7 +554,7 @@ where\n     // If `-Zincremental-verify-ich` is specified, re-hash results from\n     // the cache and make sure that they have the expected fingerprint.\n     if unlikely!(tcx.incremental_verify_ich()) {\n-        incremental_verify_ich(tcx, &result, dep_node, dep_node_index, query);\n+        incremental_verify_ich(*tcx.dep_context(), &result, dep_node, dep_node_index, query);\n     }\n \n     result\n@@ -558,7 +563,7 @@ where\n #[inline(never)]\n #[cold]\n fn incremental_verify_ich<CTX, K, V: Debug>(\n-    tcx: CTX,\n+    tcx: CTX::DepContext,\n     result: &V,\n     dep_node: &DepNode<CTX::DepKind>,\n     dep_node_index: DepNodeIndex,\n@@ -601,36 +606,42 @@ where\n     // 2. Two distinct query keys get mapped to the same `DepNode`\n     //    (see for example #48923).\n     assert!(\n-        !tcx.dep_graph().dep_node_exists(&dep_node),\n+        !tcx.dep_context().dep_graph().dep_node_exists(&dep_node),\n         \"forcing query with already existing `DepNode`\\n\\\n                  - query-key: {:?}\\n\\\n                  - dep-node: {:?}\",\n         key,\n         dep_node\n     );\n \n-    let prof_timer = tcx.profiler().query_provider();\n+    let prof_timer = tcx.dep_context().profiler().query_provider();\n \n     let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n-        tcx.start_query(job.id, diagnostics, |tcx| {\n+        tcx.start_query(job.id, diagnostics, || {\n             if query.eval_always {\n-                tcx.dep_graph().with_eval_always_task(\n+                tcx.dep_context().dep_graph().with_eval_always_task(\n                     dep_node,\n                     tcx,\n                     key,\n                     query.compute,\n                     query.hash_result,\n                 )\n             } else {\n-                tcx.dep_graph().with_task(dep_node, tcx, key, query.compute, query.hash_result)\n+                tcx.dep_context().dep_graph().with_task(\n+                    dep_node,\n+                    tcx,\n+                    key,\n+                    query.compute,\n+                    query.hash_result,\n+                )\n             }\n         })\n     });\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n     if unlikely!(!diagnostics.is_empty()) && dep_node.kind != DepKind::NULL {\n-        tcx.store_diagnostics(dep_node_index, diagnostics);\n+        tcx.dep_context().store_diagnostics(dep_node_index, diagnostics);\n     }\n \n     let result = job.complete(result, dep_node_index);\n@@ -651,7 +662,7 @@ fn get_query_impl<CTX, C>(\n where\n     CTX: QueryContext,\n     C: QueryCache,\n-    C::Key: crate::dep_graph::DepNodeParams<CTX>,\n+    C::Key: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n {\n     try_execute_query(tcx, state, cache, span, key, lookup, query)\n }\n@@ -665,9 +676,9 @@ where\n ///\n /// Note: The optimization is only available during incr. comp.\n #[inline(never)]\n-fn ensure_must_run<CTX, K, V>(tcx: CTX, key: &K, query: &QueryVtable<CTX, K, V>) -> bool\n+fn ensure_must_run<CTX, K, V>(tcx: CTX::DepContext, key: &K, query: &QueryVtable<CTX, K, V>) -> bool\n where\n-    K: crate::dep_graph::DepNodeParams<CTX>,\n+    K: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n     if query.eval_always {\n@@ -707,14 +718,14 @@ fn force_query_impl<CTX, C>(\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n ) where\n     C: QueryCache,\n-    C::Key: crate::dep_graph::DepNodeParams<CTX>,\n+    C::Key: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n     // We may be concurrently trying both execute and force a query.\n     // Ensure that only one of them runs the query.\n     let cached = cache.cache.lookup(cache, &key, |_, index| {\n-        if unlikely!(tcx.profiler().enabled()) {\n-            tcx.profiler().query_cache_hit(index.into());\n+        if unlikely!(tcx.dep_context().profiler().enabled()) {\n+            tcx.dep_context().profiler().query_cache_hit(index.into());\n         }\n         #[cfg(debug_assertions)]\n         {\n@@ -752,12 +763,12 @@ pub fn get_query<Q, CTX>(\n ) -> Option<Q::Stored>\n where\n     Q: QueryDescription<CTX>,\n-    Q::Key: crate::dep_graph::DepNodeParams<CTX>,\n+    Q::Key: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n     let query = &Q::VTABLE;\n     if let QueryMode::Ensure = mode {\n-        if !ensure_must_run(tcx, &key, query) {\n+        if !ensure_must_run(*tcx.dep_context(), &key, query) {\n             return None;\n         }\n     }\n@@ -771,7 +782,7 @@ where\n pub fn force_query<Q, CTX>(tcx: CTX, key: Q::Key, span: Span, dep_node: DepNode<CTX::DepKind>)\n where\n     Q: QueryDescription<CTX>,\n-    Q::Key: crate::dep_graph::DepNodeParams<CTX>,\n+    Q::Key: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n     force_query_impl(tcx, Q::query_state(tcx), Q::query_cache(tcx), key, span, dep_node, &Q::VTABLE)"}]}