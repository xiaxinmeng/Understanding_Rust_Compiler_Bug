{"sha": "cd9069ca734fe89fe446c16dc821e54b973506f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkOTA2OWNhNzM0ZmU4OWZlNDQ2YzE2ZGM4MjFlNTRiOTczNTA2ZjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-22T18:06:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-22T18:06:35Z"}, "message": "auto merge of #10583 : alexcrichton/rust/privacy-reexport, r=pcwalton\n\nI added a test case which does not compile today, and required changes on\r\nprivacy's side of things to get right. Additionally, this moves a good bit of\r\nlogic which did not belong in reachability into privacy.\r\n\r\nAll of reachability should solely be responsible for determining what the\r\nreachable surface area of a crate is given the exported surface area (where the\r\nexported surface area is that which is usable by external crates).\r\n\r\nPrivacy will now correctly figure out what's exported by deeply looking\r\nthrough reexports. Previously if a module were reexported under another name,\r\nnothing in the module would actually get exported in the executable. I also\r\nconsolidated the phases of privacy to be clearer about what's an input to what.\r\nThe privacy checking pass no longer uses the notion of an \"all public\" path, and\r\nthe embargo visitor is no longer an input to the checking pass.\r\n\r\nCurrently the embargo visitor is built as a saturating analysis because it's\r\nunknown what portions of the AST are going to get re-exported.\r\n\r\nThis also cracks down on exported methods from impl blocks and trait blocks. If you implement a private trait, none of the symbols are exported, and if you have an impl for a private type none of the symbols are exported either. On the other hand, if you implement a public trait for a private type, the symbols are still exported. I'm unclear on whether this last part is correct, but librustc will fail to link unless it's in place.", "tree": {"sha": "a9790b0cbc22fd1dd535bd6105a8e7913e93ee9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9790b0cbc22fd1dd535bd6105a8e7913e93ee9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd9069ca734fe89fe446c16dc821e54b973506f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd9069ca734fe89fe446c16dc821e54b973506f5", "html_url": "https://github.com/rust-lang/rust/commit/cd9069ca734fe89fe446c16dc821e54b973506f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd9069ca734fe89fe446c16dc821e54b973506f5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3cb24b1fe3fd0e31cccf8ca3c53470f747bae0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3cb24b1fe3fd0e31cccf8ca3c53470f747bae0c", "html_url": "https://github.com/rust-lang/rust/commit/d3cb24b1fe3fd0e31cccf8ca3c53470f747bae0c"}, {"sha": "93a0dec2029f5c0658478187984eddf3afcc84b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/93a0dec2029f5c0658478187984eddf3afcc84b3", "html_url": "https://github.com/rust-lang/rust/commit/93a0dec2029f5c0658478187984eddf3afcc84b3"}], "stats": {"total": 845, "additions": 450, "deletions": 395}, "files": [{"sha": "e3d5c93ea7cceb5d0ddfcdf89365d52e3d0e634a", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 397, "deletions": 356, "changes": 753, "blob_url": "https://github.com/rust-lang/rust/blob/cd9069ca734fe89fe446c16dc821e54b973506f5/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9069ca734fe89fe446c16dc821e54b973506f5/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=cd9069ca734fe89fe446c16dc821e54b973506f5", "patch": "@@ -22,7 +22,7 @@ use middle::typeck::{method_static, method_object};\n \n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{is_local, def_id_of_def};\n+use syntax::ast_util::{is_local, def_id_of_def, local_def};\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token;\n@@ -35,15 +35,16 @@ type Context<'self> = (&'self method_map, &'self resolve::ExportMap2);\n /// A set of AST nodes exported by the crate.\n pub type ExportedItems = HashSet<ast::NodeId>;\n \n-// This visitor is used to determine the parent of all nodes in question when it\n-// comes to privacy. This is used to determine later on if a usage is actually\n-// valid or not.\n-struct ParentVisitor<'self> {\n-    parents: &'self mut HashMap<ast::NodeId, ast::NodeId>,\n+////////////////////////////////////////////////////////////////////////////////\n+/// The parent visitor, used to determine what's the parent of what (node-wise)\n+////////////////////////////////////////////////////////////////////////////////\n+\n+struct ParentVisitor {\n+    parents: HashMap<ast::NodeId, ast::NodeId>,\n     curparent: ast::NodeId,\n }\n \n-impl<'self> Visitor<()> for ParentVisitor<'self> {\n+impl Visitor<()> for ParentVisitor {\n     fn visit_item(&mut self, item: @ast::item, _: ()) {\n         self.parents.insert(item.id, self.curparent);\n \n@@ -138,34 +139,37 @@ impl<'self> Visitor<()> for ParentVisitor<'self> {\n     }\n }\n \n-// This visitor is used to determine which items of the ast are embargoed,\n-// otherwise known as not exported.\n+////////////////////////////////////////////////////////////////////////////////\n+/// The embargo visitor, used to determine the exports of the ast\n+////////////////////////////////////////////////////////////////////////////////\n+\n struct EmbargoVisitor<'self> {\n     tcx: ty::ctxt,\n-    // A set of all nodes in the ast which can be considered \"publicly\n-    // exported\" in the sense that they are accessible from anywhere\n-    // in any hierarchy. They are public items whose ancestors are all\n-    // public.\n-    path_all_public_items: &'self mut ExportedItems,\n-    // A set of all nodes in the ast that can be reached via a public\n-    // path. This includes everything in `path_all_public_items` as\n-    // well as re-exported private nodes (`pub use`ing a private\n-    // path).\n-    exported_items: &'self mut ExportedItems,\n     exp_map2: &'self resolve::ExportMap2,\n-    path_all_public: bool,\n-}\n \n-impl<'self> EmbargoVisitor<'self> {\n-    fn add_path_all_public_item(&mut self, id: ast::NodeId) {\n-        self.path_all_public_items.insert(id);\n-        self.exported_items.insert(id);\n-    }\n+    // This flag is an indicator of whether the previous item in the\n+    // hierarchical chain was exported or not. This is the indicator of whether\n+    // children should be exported as well. Note that this can flip from false\n+    // to true if a reexported module is entered (or an action similar).\n+    prev_exported: bool,\n+\n+    // This is a list of all exported items in the AST. An exported item is any\n+    // function/method/item which is usable by external crates. This essentially\n+    // means that the result is \"public all the way down\", but the \"path down\"\n+    // may jump across private boundaries through reexport statements.\n+    exported_items: ExportedItems,\n+\n+    // This sets contains all the destination nodes which are publicly\n+    // re-exported. This is *not* a set of all reexported nodes, only a set of\n+    // all nodes which are reexported *and* reachable from external crates. This\n+    // means that the destination of the reexport is exported, and hence the\n+    // destination must also be exported.\n+    reexports: HashSet<ast::NodeId>,\n }\n \n impl<'self> Visitor<()> for EmbargoVisitor<'self> {\n     fn visit_item(&mut self, item: @ast::item, _: ()) {\n-        let orig_all_pub = self.path_all_public;\n+        let orig_all_pub = self.prev_exported;\n         match item.node {\n             // impls/extern blocks do not break the \"public chain\" because they\n             // cannot have visibility qualifiers on them anyway\n@@ -174,67 +178,99 @@ impl<'self> Visitor<()> for EmbargoVisitor<'self> {\n             // Private by default, hence we only retain the \"public chain\" if\n             // `pub` is explicitly listed.\n             _ => {\n-                self.path_all_public = orig_all_pub && item.vis == ast::public;\n+                self.prev_exported =\n+                    (orig_all_pub && item.vis == ast::public) ||\n+                     self.reexports.contains(&item.id);\n             }\n         }\n \n-        if self.path_all_public {\n-            self.add_path_all_public_item(item.id);\n-        }\n+        let public_first = self.prev_exported &&\n+                           self.exported_items.insert(item.id);\n \n         match item.node {\n             // Enum variants inherit from their parent, so if the enum is\n             // public all variants are public unless they're explicitly priv\n-            ast::item_enum(ref def, _) if self.path_all_public => {\n+            ast::item_enum(ref def, _) if public_first => {\n                 for variant in def.variants.iter() {\n                     if variant.node.vis != ast::private {\n-                        self.add_path_all_public_item(variant.node.id);\n+                        self.exported_items.insert(variant.node.id);\n                     }\n                 }\n             }\n \n-            // Methods which are public at the source are totally public.\n-            ast::item_impl(_, None, _, ref methods) => {\n-                for method in methods.iter() {\n-                    let public = match method.explicit_self.node {\n-                        ast::sty_static => self.path_all_public,\n-                        _ => true,\n-                    } && method.vis == ast::public;\n-                    if public {\n-                        self.add_path_all_public_item(method.id);\n+            // Implementations are a little tricky to determine what's exported\n+            // out of them. Here's a few cases which are currently defined:\n+            //\n+            // * Impls for private types do not need to export their methods\n+            //   (either public or private methods)\n+            //\n+            // * Impls for public types only have public methods exported\n+            //\n+            // * Public trait impls for public types must have all methods\n+            //   exported.\n+            //\n+            // * Private trait impls for public types can be ignored\n+            //\n+            // * Public trait impls for private types have their methods\n+            //   exported. I'm not entirely certain that this is the correct\n+            //   thing to do, but I have seen use cases of where this will cause\n+            //   undefined symbols at linkage time if this case is not handled.\n+            //\n+            // * Private trait impls for private types can be completely ignored\n+            ast::item_impl(_, _, ref ty, ref methods) => {\n+                let public_ty = match ty.node {\n+                    ast::ty_path(_, _, id) => {\n+                        match self.tcx.def_map.get_copy(&id) {\n+                            ast::DefPrimTy(*) => true,\n+                            def => {\n+                                let did = def_id_of_def(def);\n+                                !is_local(did) ||\n+                                 self.exported_items.contains(&did.node)\n+                            }\n+                        }\n+                    }\n+                    _ => true,\n+                };\n+                let tr = ty::impl_trait_ref(self.tcx, local_def(item.id));\n+                let public_trait = do tr.map_default(false) |tr| {\n+                    !is_local(tr.def_id) ||\n+                     self.exported_items.contains(&tr.def_id.node)\n+                };\n+\n+                if public_ty || public_trait {\n+                    for method in methods.iter() {\n+                        let meth_public = match method.explicit_self.node {\n+                            ast::sty_static => public_ty,\n+                            _ => true,\n+                        } && method.vis == ast::public;\n+                        if meth_public || public_trait {\n+                            self.exported_items.insert(method.id);\n+                        }\n                     }\n                 }\n             }\n \n-            // Trait implementation methods are all completely public\n-            ast::item_impl(_, Some(*), _, ref methods) => {\n-                for method in methods.iter() {\n-                    debug!(\"exporting: {}\", method.id);\n-                    self.add_path_all_public_item(method.id);\n-                }\n-            }\n-\n-            // Default methods on traits are all public so long as the trait is\n-            // public\n-            ast::item_trait(_, _, ref methods) if self.path_all_public => {\n+            // Default methods on traits are all public so long as the trait\n+            // is public\n+            ast::item_trait(_, _, ref methods) if public_first => {\n                 for method in methods.iter() {\n                     match *method {\n                         ast::provided(ref m) => {\n                             debug!(\"provided {}\", m.id);\n-                            self.add_path_all_public_item(m.id);\n+                            self.exported_items.insert(m.id);\n                         }\n                         ast::required(ref m) => {\n                             debug!(\"required {}\", m.id);\n-                            self.add_path_all_public_item(m.id);\n+                            self.exported_items.insert(m.id);\n                         }\n                     }\n                 }\n             }\n \n             // Struct constructors are public if the struct is all public.\n-            ast::item_struct(ref def, _) if self.path_all_public => {\n+            ast::item_struct(ref def, _) if public_first => {\n                 match def.ctor_id {\n-                    Some(id) => { self.add_path_all_public_item(id); }\n+                    Some(id) => { self.exported_items.insert(id); }\n                     None => {}\n                 }\n             }\n@@ -244,44 +280,40 @@ impl<'self> Visitor<()> for EmbargoVisitor<'self> {\n \n         visit::walk_item(self, item, ());\n \n-        self.path_all_public = orig_all_pub;\n+        self.prev_exported = orig_all_pub;\n     }\n \n     fn visit_foreign_item(&mut self, a: @ast::foreign_item, _: ()) {\n-        if self.path_all_public && a.vis == ast::public {\n-            self.add_path_all_public_item(a.id);\n+        if self.prev_exported && a.vis == ast::public {\n+            self.exported_items.insert(a.id);\n         }\n     }\n \n-    fn visit_mod(&mut self, m: &ast::_mod, sp: Span, id: ast::NodeId, _: ()) {\n+    fn visit_mod(&mut self, m: &ast::_mod, _sp: Span, id: ast::NodeId, _: ()) {\n         // This code is here instead of in visit_item so that the\n         // crate module gets processed as well.\n-        if self.path_all_public {\n-            match self.exp_map2.find(&id) {\n-                Some(exports) => {\n-                    for export in exports.iter() {\n-                        if is_local(export.def_id) && export.reexport {\n-                            self.exported_items.insert(export.def_id.node);\n-                        }\n-                    }\n+        if self.prev_exported {\n+            assert!(self.exp_map2.contains_key(&id), \"wut {:?}\", id);\n+            for export in self.exp_map2.get(&id).iter() {\n+                if is_local(export.def_id) && export.reexport {\n+                    self.reexports.insert(export.def_id.node);\n                 }\n-                None => self.tcx.sess.span_bug(sp, \"missing exp_map2 entry \\\n-                                               for module\"),\n             }\n         }\n         visit::walk_mod(self, m, ())\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+/// The privacy visitor, where privacy checks take place (violations reported)\n+////////////////////////////////////////////////////////////////////////////////\n+\n struct PrivacyVisitor<'self> {\n     tcx: ty::ctxt,\n     curitem: ast::NodeId,\n     in_fn: bool,\n-\n-    // See comments on the same field in `EmbargoVisitor`.\n-    path_all_public_items: &'self ExportedItems,\n     method_map: &'self method_map,\n-    parents: &'self HashMap<ast::NodeId, ast::NodeId>,\n+    parents: HashMap<ast::NodeId, ast::NodeId>,\n     external_exports: resolve::ExternalExports,\n     last_private_map: resolve::LastPrivateMap,\n }\n@@ -339,9 +371,6 @@ impl<'self> PrivacyVisitor<'self> {\n                     ExternallyDenied\n                 }\n             };\n-        } else if self.path_all_public_items.contains(&did.node) {\n-            debug!(\"privacy - exported item {}\", self.nodestr(did.node));\n-            return Allowable;\n         }\n \n         debug!(\"privacy - local {:?} not public all the way down\", did);\n@@ -357,8 +386,36 @@ impl<'self> PrivacyVisitor<'self> {\n         loop {\n             debug!(\"privacy - examining {}\", self.nodestr(closest_private_id));\n             let vis = match self.tcx.items.find(&closest_private_id) {\n+                // If this item is a method, then we know for sure that it's an\n+                // actual method and not a static method. The reason for this is\n+                // that these cases are only hit in the ExprMethodCall\n+                // expression, and ExprCall will have its path checked later\n+                // (the path of the trait/impl) if it's a static method.\n+                //\n+                // With this information, then we can completely ignore all\n+                // trait methods. The privacy violation would be if the trait\n+                // couldn't get imported, not if the method couldn't be used\n+                // (all trait methods are public).\n+                //\n+                // However, if this is an impl method, then we dictate this\n+                // decision solely based on the privacy of the method\n+                // invocation.\n+                // FIXME(#10573) is this the right behavior? Why not consider\n+                //               where the method was defined?\n+                Some(&ast_map::node_method(ref m, imp, _)) => {\n+                    match ty::impl_trait_ref(self.tcx, imp) {\n+                        Some(*) => return Allowable,\n+                        _ if m.vis == ast::public => return Allowable,\n+                        _ => m.vis\n+                    }\n+                }\n+                Some(&ast_map::node_trait_method(*)) => {\n+                    return Allowable;\n+                }\n+\n+                // This is not a method call, extract the visibility as one\n+                // would normally look at it\n                 Some(&ast_map::node_item(it, _)) => it.vis,\n-                Some(&ast_map::node_method(ref m, _, _)) => m.vis,\n                 Some(&ast_map::node_foreign_item(_, _, v, _)) => v,\n                 Some(&ast_map::node_variant(ref v, _, _)) => {\n                     // sadly enum variants still inherit visibility, so only\n@@ -369,11 +426,14 @@ impl<'self> PrivacyVisitor<'self> {\n                 _ => ast::public,\n             };\n             if vis != ast::public { break }\n+            // if we've reached the root, then everything was allowable and this\n+            // access is public.\n+            if closest_private_id == ast::CRATE_NODE_ID { return Allowable }\n             closest_private_id = *self.parents.get(&closest_private_id);\n \n-            // If we reached the top, then we should have been public all the\n-            // way down in the first place...\n-            assert!(closest_private_id != ast::DUMMY_NODE_ID);\n+            // If we reached the top, then we were public all the way down and\n+            // we can allow this access.\n+            if closest_private_id == ast::DUMMY_NODE_ID { return Allowable }\n         }\n         debug!(\"privacy - closest priv {}\", self.nodestr(closest_private_id));\n         if self.private_accessible(closest_private_id) {\n@@ -530,53 +590,226 @@ impl<'self> PrivacyVisitor<'self> {\n             method_static(method_id) => {\n                 self.check_static_method(span, method_id, &ident)\n             }\n-            method_param(method_param {\n-                trait_id: trait_id,\n-                method_num: method_num,\n-                 _\n-            }) |\n-            method_object(method_object {\n-                trait_id: trait_id,\n-                method_num: method_num,\n-                 _\n-            }) => {\n-                if !self.ensure_public(span, trait_id, None, \"source trait\") {\n-                    return\n-                }\n-                match self.tcx.items.find(&trait_id.node) {\n-                    Some(&ast_map::node_item(item, _)) => {\n-                        match item.node {\n-                            ast::item_trait(_, _, ref methods) => {\n-                                match methods[method_num] {\n-                                    ast::provided(ref method) => {\n-                                        let def = ast::DefId {\n-                                            node: method.id,\n-                                            crate: trait_id.crate,\n-                                        };\n-                                        self.ensure_public(span, def, None,\n-                                                  format!(\"method `{}`\",\n-                                                          token::ident_to_str(\n-                                                              &method.ident)));\n-                                    }\n-                                    ast::required(_) => {\n-                                        // Required methods can't be private.\n-                                    }\n+            // Trait methods are always all public. The only controlling factor\n+            // is whether the trait itself is accessible or not.\n+            method_param(method_param { trait_id: trait_id, _ }) |\n+            method_object(method_object { trait_id: trait_id, _ }) => {\n+                self.ensure_public(span, trait_id, None, \"source trait\");\n+            }\n+        }\n+    }\n+}\n+\n+impl<'self> Visitor<()> for PrivacyVisitor<'self> {\n+    fn visit_item(&mut self, item: @ast::item, _: ()) {\n+        // Do not check privacy inside items with the resolve_unexported\n+        // attribute. This is used for the test runner.\n+        if attr::contains_name(item.attrs, \"!resolve_unexported\") {\n+            return;\n+        }\n+\n+        let orig_curitem = util::replace(&mut self.curitem, item.id);\n+        visit::walk_item(self, item, ());\n+        self.curitem = orig_curitem;\n+    }\n+\n+    fn visit_expr(&mut self, expr: @ast::Expr, _: ()) {\n+        match expr.node {\n+            ast::ExprField(base, ident, _) => {\n+                // Method calls are now a special syntactic form,\n+                // so `a.b` should always be a field.\n+                assert!(!self.method_map.contains_key(&expr.id));\n+\n+                // With type_autoderef, make sure we don't\n+                // allow pointers to violate privacy\n+                let t = ty::type_autoderef(self.tcx,\n+                                           ty::expr_ty(self.tcx, base));\n+                match ty::get(t).sty {\n+                    ty::ty_struct(id, _) => self.check_field(expr.span, id, ident),\n+                    _ => {}\n+                }\n+            }\n+            ast::ExprMethodCall(_, base, ident, _, _, _) => {\n+                // see above\n+                let t = ty::type_autoderef(self.tcx,\n+                                           ty::expr_ty(self.tcx, base));\n+                match ty::get(t).sty {\n+                    ty::ty_enum(_, _) | ty::ty_struct(_, _) => {\n+                        let entry = match self.method_map.find(&expr.id) {\n+                            None => {\n+                                self.tcx.sess.span_bug(expr.span,\n+                                                       \"method call not in \\\n+                                                        method map\");\n+                            }\n+                            Some(entry) => entry\n+                        };\n+                        debug!(\"(privacy checking) checking impl method\");\n+                        self.check_method(expr.span, &entry.origin, ident);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            ast::ExprPath(ref path) => {\n+                self.check_path(expr.span, expr.id, path);\n+            }\n+            ast::ExprStruct(_, ref fields, _) => {\n+                match ty::get(ty::expr_ty(self.tcx, expr)).sty {\n+                    ty::ty_struct(id, _) => {\n+                        for field in (*fields).iter() {\n+                            self.check_field(expr.span, id, field.ident.node);\n+                        }\n+                    }\n+                    ty::ty_enum(_, _) => {\n+                        match self.tcx.def_map.get_copy(&expr.id) {\n+                            ast::DefVariant(_, variant_id, _) => {\n+                                for field in fields.iter() {\n+                                    self.check_field(expr.span, variant_id,\n+                                                     field.ident.node);\n+                                }\n+                            }\n+                            _ => self.tcx.sess.span_bug(expr.span,\n+                                                        \"resolve didn't \\\n+                                                         map enum struct \\\n+                                                         constructor to a \\\n+                                                         variant def\"),\n+                        }\n+                    }\n+                    _ => self.tcx.sess.span_bug(expr.span, \"struct expr \\\n+                                                            didn't have \\\n+                                                            struct type?!\"),\n+                }\n+            }\n+            ast::ExprUnary(_, ast::UnDeref, operand) => {\n+                // In *e, we need to check that if e's type is an\n+                // enum type t, then t's first variant is public or\n+                // privileged. (We can assume it has only one variant\n+                // since typeck already happened.)\n+                match ty::get(ty::expr_ty(self.tcx, operand)).sty {\n+                    ty::ty_enum(id, _) => {\n+                        self.check_variant(expr.span, id);\n+                    }\n+                    _ => { /* No check needed */ }\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        visit::walk_expr(self, expr, ());\n+    }\n+\n+    fn visit_ty(&mut self, t: &ast::Ty, _: ()) {\n+        match t.node {\n+            ast::ty_path(ref path, _, id) => self.check_path(t.span, id, path),\n+            _ => {}\n+        }\n+        visit::walk_ty(self, t, ());\n+    }\n+\n+    fn visit_view_item(&mut self, a: &ast::view_item, _: ()) {\n+        match a.node {\n+            ast::view_item_extern_mod(*) => {}\n+            ast::view_item_use(ref uses) => {\n+                for vpath in uses.iter() {\n+                    match vpath.node {\n+                        ast::view_path_simple(_, ref path, id) |\n+                        ast::view_path_glob(ref path, id) => {\n+                            debug!(\"privacy - glob/simple {}\", id);\n+                            self.check_path(vpath.span, id, path);\n+                        }\n+                        ast::view_path_list(_, ref list, _) => {\n+                            for pid in list.iter() {\n+                                debug!(\"privacy - list {}\", pid.node.id);\n+                                let seg = ast::PathSegment {\n+                                    identifier: pid.node.name,\n+                                    lifetimes: opt_vec::Empty,\n+                                    types: opt_vec::Empty,\n+                                };\n+                                let segs = ~[seg];\n+                                let path = ast::Path {\n+                                    global: false,\n+                                    span: pid.span,\n+                                    segments: segs,\n+                                };\n+                                self.check_path(pid.span, pid.node.id, &path);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_pat(&mut self, pattern: @ast::Pat, _: ()) {\n+        match pattern.node {\n+            ast::PatStruct(_, ref fields, _) => {\n+                match ty::get(ty::pat_ty(self.tcx, pattern)).sty {\n+                    ty::ty_struct(id, _) => {\n+                        for field in fields.iter() {\n+                            self.check_field(pattern.span, id, field.ident);\n+                        }\n+                    }\n+                    ty::ty_enum(_, _) => {\n+                        match self.tcx.def_map.find(&pattern.id) {\n+                            Some(&ast::DefVariant(_, variant_id, _)) => {\n+                                for field in fields.iter() {\n+                                    self.check_field(pattern.span, variant_id,\n+                                                     field.ident);\n                                 }\n                             }\n-                            _ => self.tcx.sess.span_bug(span, \"trait wasn't \\\n-                                                               actually a trait?!\"),\n+                            _ => self.tcx.sess.span_bug(pattern.span,\n+                                                        \"resolve didn't \\\n+                                                         map enum struct \\\n+                                                         pattern to a \\\n+                                                         variant def\"),\n                         }\n                     }\n-                    Some(_) => self.tcx.sess.span_bug(span, \"trait wasn't an \\\n-                                                             item?!\"),\n-                    None => self.tcx.sess.span_bug(span, \"trait item wasn't \\\n-                                                          found in the AST \\\n-                                                          map?!\"),\n+                    _ => self.tcx.sess.span_bug(pattern.span,\n+                                                \"struct pattern didn't have \\\n+                                                 struct type?!\"),\n                 }\n             }\n+            _ => {}\n         }\n+\n+        visit::walk_pat(self, pattern, ());\n     }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+/// The privacy sanity check visitor, ensures unnecessary visibility isn't here\n+////////////////////////////////////////////////////////////////////////////////\n+\n+struct SanePrivacyVisitor {\n+    tcx: ty::ctxt,\n+    in_fn: bool,\n+}\n \n+impl Visitor<()> for SanePrivacyVisitor {\n+    fn visit_item(&mut self, item: @ast::item, _: ()) {\n+        if self.in_fn {\n+            self.check_all_inherited(item);\n+        } else {\n+            self.check_sane_privacy(item);\n+        }\n+\n+        let orig_in_fn = util::replace(&mut self.in_fn, match item.node {\n+            ast::item_mod(*) => false, // modules turn privacy back on\n+            _ => self.in_fn,           // otherwise we inherit\n+        });\n+        visit::walk_item(self, item, ());\n+        self.in_fn = orig_in_fn;\n+    }\n+\n+    fn visit_fn(&mut self, fk: &visit::fn_kind, fd: &ast::fn_decl,\n+                b: &ast::Block, s: Span, n: ast::NodeId, _: ()) {\n+        // This catches both functions and methods\n+        let orig_in_fn = util::replace(&mut self.in_fn, true);\n+        visit::walk_fn(self, fk, fd, b, s, n, ());\n+        self.in_fn = orig_in_fn;\n+    }\n+}\n+\n+impl SanePrivacyVisitor {\n     /// Validates all of the visibility qualifers placed on the item given. This\n     /// ensures that there are no extraneous qualifiers that don't actually do\n     /// anything. In theory these qualifiers wouldn't parse, but that may happen\n@@ -749,249 +982,57 @@ impl<'self> PrivacyVisitor<'self> {\n     }\n }\n \n-impl<'self> Visitor<()> for PrivacyVisitor<'self> {\n-    fn visit_item(&mut self, item: @ast::item, _: ()) {\n-        // Do not check privacy inside items with the resolve_unexported\n-        // attribute. This is used for the test runner.\n-        if attr::contains_name(item.attrs, \"!resolve_unexported\") {\n-            return;\n-        }\n-\n-        // Disallow unnecessary visibility qualifiers\n-        if self.in_fn {\n-            self.check_all_inherited(item);\n-        } else {\n-            self.check_sane_privacy(item);\n-        }\n-\n-        let orig_curitem = util::replace(&mut self.curitem, item.id);\n-        let orig_in_fn = util::replace(&mut self.in_fn, match item.node {\n-            ast::item_mod(*) => false, // modules turn privacy back on\n-            _ => self.in_fn,           // otherwise we inherit\n-        });\n-        visit::walk_item(self, item, ());\n-        self.curitem = orig_curitem;\n-        self.in_fn = orig_in_fn;\n-    }\n-\n-    fn visit_fn(&mut self, fk: &visit::fn_kind, fd: &ast::fn_decl,\n-                b: &ast::Block, s: Span, n: ast::NodeId, _: ()) {\n-        // This catches both functions and methods\n-        let orig_in_fn = util::replace(&mut self.in_fn, true);\n-        visit::walk_fn(self, fk, fd, b, s, n, ());\n-        self.in_fn = orig_in_fn;\n-    }\n-\n-    fn visit_expr(&mut self, expr: @ast::Expr, _: ()) {\n-        match expr.node {\n-            ast::ExprField(base, ident, _) => {\n-                // Method calls are now a special syntactic form,\n-                // so `a.b` should always be a field.\n-                assert!(!self.method_map.contains_key(&expr.id));\n-\n-                // With type_autoderef, make sure we don't\n-                // allow pointers to violate privacy\n-                let t = ty::type_autoderef(self.tcx,\n-                                           ty::expr_ty(self.tcx, base));\n-                match ty::get(t).sty {\n-                    ty::ty_struct(id, _) => self.check_field(expr.span, id, ident),\n-                    _ => {}\n-                }\n-            }\n-            ast::ExprMethodCall(_, base, ident, _, _, _) => {\n-                // see above\n-                let t = ty::type_autoderef(self.tcx,\n-                                           ty::expr_ty(self.tcx, base));\n-                match ty::get(t).sty {\n-                    ty::ty_enum(_, _) | ty::ty_struct(_, _) => {\n-                        let entry = match self.method_map.find(&expr.id) {\n-                            None => {\n-                                self.tcx.sess.span_bug(expr.span,\n-                                                       \"method call not in \\\n-                                                        method map\");\n-                            }\n-                            Some(entry) => entry\n-                        };\n-                        debug!(\"(privacy checking) checking impl method\");\n-                        self.check_method(expr.span, &entry.origin, ident);\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            ast::ExprPath(ref path) => {\n-                self.check_path(expr.span, expr.id, path);\n-            }\n-            ast::ExprStruct(_, ref fields, _) => {\n-                match ty::get(ty::expr_ty(self.tcx, expr)).sty {\n-                    ty::ty_struct(id, _) => {\n-                        for field in (*fields).iter() {\n-                            self.check_field(expr.span, id, field.ident.node);\n-                        }\n-                    }\n-                    ty::ty_enum(_, _) => {\n-                        match self.tcx.def_map.get_copy(&expr.id) {\n-                            ast::DefVariant(_, variant_id, _) => {\n-                                for field in fields.iter() {\n-                                    self.check_field(expr.span, variant_id,\n-                                                     field.ident.node);\n-                                }\n-                            }\n-                            _ => self.tcx.sess.span_bug(expr.span,\n-                                                        \"resolve didn't \\\n-                                                         map enum struct \\\n-                                                         constructor to a \\\n-                                                         variant def\"),\n-                        }\n-                    }\n-                    _ => self.tcx.sess.span_bug(expr.span, \"struct expr \\\n-                                                            didn't have \\\n-                                                            struct type?!\"),\n-                }\n-            }\n-            ast::ExprUnary(_, ast::UnDeref, operand) => {\n-                // In *e, we need to check that if e's type is an\n-                // enum type t, then t's first variant is public or\n-                // privileged. (We can assume it has only one variant\n-                // since typeck already happened.)\n-                match ty::get(ty::expr_ty(self.tcx, operand)).sty {\n-                    ty::ty_enum(id, _) => {\n-                        self.check_variant(expr.span, id);\n-                    }\n-                    _ => { /* No check needed */ }\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        visit::walk_expr(self, expr, ());\n-    }\n-\n-    fn visit_ty(&mut self, t: &ast::Ty, _: ()) {\n-        match t.node {\n-            ast::ty_path(ref path, _, id) => self.check_path(t.span, id, path),\n-            _ => {}\n-        }\n-        visit::walk_ty(self, t, ());\n-    }\n-\n-    fn visit_view_item(&mut self, a: &ast::view_item, _: ()) {\n-        match a.node {\n-            ast::view_item_extern_mod(*) => {}\n-            ast::view_item_use(ref uses) => {\n-                for vpath in uses.iter() {\n-                    match vpath.node {\n-                        ast::view_path_simple(_, ref path, id) |\n-                        ast::view_path_glob(ref path, id) => {\n-                            debug!(\"privacy - glob/simple {}\", id);\n-                            self.check_path(vpath.span, id, path);\n-                        }\n-                        ast::view_path_list(_, ref list, _) => {\n-                            for pid in list.iter() {\n-                                debug!(\"privacy - list {}\", pid.node.id);\n-                                let seg = ast::PathSegment {\n-                                    identifier: pid.node.name,\n-                                    lifetimes: opt_vec::Empty,\n-                                    types: opt_vec::Empty,\n-                                };\n-                                let segs = ~[seg];\n-                                let path = ast::Path {\n-                                    global: false,\n-                                    span: pid.span,\n-                                    segments: segs,\n-                                };\n-                                self.check_path(pid.span, pid.node.id, &path);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn visit_pat(&mut self, pattern: @ast::Pat, _: ()) {\n-        match pattern.node {\n-            ast::PatStruct(_, ref fields, _) => {\n-                match ty::get(ty::pat_ty(self.tcx, pattern)).sty {\n-                    ty::ty_struct(id, _) => {\n-                        for field in fields.iter() {\n-                            self.check_field(pattern.span, id, field.ident);\n-                        }\n-                    }\n-                    ty::ty_enum(_, _) => {\n-                        match self.tcx.def_map.find(&pattern.id) {\n-                            Some(&ast::DefVariant(_, variant_id, _)) => {\n-                                for field in fields.iter() {\n-                                    self.check_field(pattern.span, variant_id,\n-                                                     field.ident);\n-                                }\n-                            }\n-                            _ => self.tcx.sess.span_bug(pattern.span,\n-                                                        \"resolve didn't \\\n-                                                         map enum struct \\\n-                                                         pattern to a \\\n-                                                         variant def\"),\n-                        }\n-                    }\n-                    _ => self.tcx.sess.span_bug(pattern.span,\n-                                                \"struct pattern didn't have \\\n-                                                 struct type?!\"),\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        visit::walk_pat(self, pattern, ());\n-    }\n-}\n-\n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: &method_map,\n                    exp_map2: &resolve::ExportMap2,\n                    external_exports: resolve::ExternalExports,\n                    last_private_map: resolve::LastPrivateMap,\n                    crate: &ast::Crate) -> ExportedItems {\n-    let mut parents = HashMap::new();\n-    let mut path_all_public_items = HashSet::new();\n-    let mut exported_items = HashSet::new();\n-\n-    // First, figure out who everyone's parent is\n-    {\n-        let mut visitor = ParentVisitor {\n-            parents: &mut parents,\n-            curparent: ast::DUMMY_NODE_ID,\n-        };\n-        visit::walk_crate(&mut visitor, crate, ());\n-    }\n-\n-    // Next, build up the list of all exported items from this crate\n-    {\n-        let mut visitor = EmbargoVisitor {\n-            tcx: tcx,\n-            path_all_public_items: &mut path_all_public_items,\n-            exported_items: &mut exported_items,\n-            exp_map2: exp_map2,\n-            path_all_public: true, // start out as public\n-        };\n-        // Initialize the exported items with resolve's id for the \"root crate\"\n-        // to resolve references to `super` leading to the root and such.\n-        visitor.add_path_all_public_item(ast::CRATE_NODE_ID);\n-        visit::walk_crate(&mut visitor, crate, ());\n-    }\n-\n-    // And then actually check the privacy of everything.\n-    {\n-        let mut visitor = PrivacyVisitor {\n-            curitem: ast::DUMMY_NODE_ID,\n-            in_fn: false,\n-            tcx: tcx,\n-            path_all_public_items: &path_all_public_items,\n-            parents: &parents,\n-            method_map: method_map,\n-            external_exports: external_exports,\n-            last_private_map: last_private_map,\n-        };\n+    // Figure out who everyone's parent is\n+    let mut visitor = ParentVisitor {\n+        parents: HashMap::new(),\n+        curparent: ast::DUMMY_NODE_ID,\n+    };\n+    visit::walk_crate(&mut visitor, crate, ());\n+\n+    // Use the parent map to check the privacy of everything\n+    let mut visitor = PrivacyVisitor {\n+        curitem: ast::DUMMY_NODE_ID,\n+        in_fn: false,\n+        tcx: tcx,\n+        parents: visitor.parents,\n+        method_map: method_map,\n+        external_exports: external_exports,\n+        last_private_map: last_private_map,\n+    };\n+    visit::walk_crate(&mut visitor, crate, ());\n+\n+    // Sanity check to make sure that all privacy usage and controls are\n+    // reasonable.\n+    let mut visitor = SanePrivacyVisitor {\n+        in_fn: false,\n+        tcx: tcx,\n+    };\n+    visit::walk_crate(&mut visitor, crate, ());\n+\n+    tcx.sess.abort_if_errors();\n+\n+    // Build up a set of all exported items in the AST. This is a set of all\n+    // items which are reachable from external crates based on visibility.\n+    let mut visitor = EmbargoVisitor {\n+        tcx: tcx,\n+        exported_items: HashSet::new(),\n+        reexports: HashSet::new(),\n+        exp_map2: exp_map2,\n+        prev_exported: true,\n+    };\n+    loop {\n+        let before = visitor.exported_items.len();\n         visit::walk_crate(&mut visitor, crate, ());\n+        if before == visitor.exported_items.len() {\n+            break\n+        }\n     }\n \n-    return exported_items;\n+    return visitor.exported_items;\n }"}, {"sha": "02ac4c52084be002d43c0d1ac7f2d59642fe5f7c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 39, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cd9069ca734fe89fe446c16dc821e54b973506f5/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9069ca734fe89fe446c16dc821e54b973506f5/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=cd9069ca734fe89fe446c16dc821e54b973506f5", "patch": "@@ -22,7 +22,7 @@ use middle::privacy;\n use std::hashmap::HashSet;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{def_id_of_def, is_local, local_def};\n+use syntax::ast_util::{def_id_of_def, is_local};\n use syntax::attr;\n use syntax::parse::token;\n use syntax::visit::Visitor;\n@@ -310,47 +310,13 @@ impl ReachableContext {\n                         }\n                     }\n \n-                    // Implementations of exported structs/enums need to get\n-                    // added to the worklist (as all their methods should be\n-                    // accessible)\n-                    ast::item_struct(*) | ast::item_enum(*) => {\n-                        let def = local_def(item.id);\n-                        let impls = match self.tcx.inherent_impls.find(&def) {\n-                            Some(&impls) => impls,\n-                            None => return\n-                        };\n-                        for imp in impls.iter() {\n-                            if is_local(imp.did) {\n-                                self.worklist.push(imp.did.node);\n-                            }\n-                        }\n-                    }\n-\n-                    // Propagate through this impl\n-                    ast::item_impl(_, _, _, ref methods) => {\n-                        for method in methods.iter() {\n-                            self.worklist.push(method.id);\n-                        }\n-                    }\n-\n-                    // Default methods of exported traits need to all be\n-                    // accessible.\n-                    ast::item_trait(_, _, ref methods) => {\n-                        for method in methods.iter() {\n-                            match *method {\n-                                ast::required(*) => {}\n-                                ast::provided(ref method) => {\n-                                    self.worklist.push(method.id);\n-                                }\n-                            }\n-                        }\n-                    }\n-\n                     // These are normal, nothing reachable about these\n                     // inherently and their children are already in the\n-                    // worklist\n+                    // worklist, as determined by the privacy pass\n                     ast::item_static(*) | ast::item_ty(*) |\n-                        ast::item_mod(*) | ast::item_foreign_mod(*) => {}\n+                    ast::item_mod(*) | ast::item_foreign_mod(*) |\n+                    ast::item_impl(*) | ast::item_trait(*) |\n+                    ast::item_struct(*) | ast::item_enum(*) => {}\n \n                     _ => {\n                         self.tcx.sess.span_bug(item.span,"}, {"sha": "7e0f7f3abfe227d3ff88188f997c5d51ba3ef797", "filename": "src/test/auxiliary/privacy_reexport.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cd9069ca734fe89fe446c16dc821e54b973506f5/src%2Ftest%2Fauxiliary%2Fprivacy_reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9069ca734fe89fe446c16dc821e54b973506f5/src%2Ftest%2Fauxiliary%2Fprivacy_reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fprivacy_reexport.rs?ref=cd9069ca734fe89fe446c16dc821e54b973506f5", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use bar = foo;\n+\n+mod foo {\n+    pub fn frob() {}\n+}"}, {"sha": "10c27adde22eaefc8209eb9ee40595f245b46d22", "filename": "src/test/compile-fail/lint-missing-doc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd9069ca734fe89fe446c16dc821e54b973506f5/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9069ca734fe89fe446c16dc821e54b973506f5/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs?ref=cd9069ca734fe89fe446c16dc821e54b973506f5", "patch": "@@ -57,6 +57,11 @@ pub trait C { //~ ERROR: missing documentation\n #[allow(missing_doc)] pub trait D {}\n \n impl Foo {\n+    pub fn foo() {}\n+    fn bar() {}\n+}\n+\n+impl PubFoo {\n     pub fn foo() {} //~ ERROR: missing documentation\n     /// dox\n     pub fn foo1() {}"}, {"sha": "a2f8e78590f376a5c58e8fc72bfcb88fc531ef4f", "filename": "src/test/compile-fail/privacy1.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cd9069ca734fe89fe446c16dc821e54b973506f5/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9069ca734fe89fe446c16dc821e54b973506f5/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs?ref=cd9069ca734fe89fe446c16dc821e54b973506f5", "patch": "@@ -31,6 +31,12 @@ mod bar {\n         fn bar2(&self) {}\n     }\n \n+    trait B {\n+        fn foo() -> Self;\n+    }\n+\n+    impl B for int { fn foo() -> int { 3 } }\n+\n     pub enum Enum {\n         priv Priv,\n         Pub\n@@ -108,6 +114,10 @@ mod foo {\n         ::bar::baz::A.bar2();   //~ ERROR: struct `A` is inaccessible\n                                 //~^ ERROR: method `bar2` is private\n                                 //~^^ NOTE: module `baz` is private\n+\n+        let _: int =\n+        ::bar::B::foo();        //~ ERROR: method `foo` is inaccessible\n+                                //~^ NOTE: trait `B` is private\n         ::lol();\n \n         ::bar::Priv; //~ ERROR: variant `Priv` is private"}, {"sha": "eedc47ca0ad70065063fbbe9b2e9f54442ec0f9a", "filename": "src/test/run-pass/privacy-reexport.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd9069ca734fe89fe446c16dc821e54b973506f5/src%2Ftest%2Frun-pass%2Fprivacy-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9069ca734fe89fe446c16dc821e54b973506f5/src%2Ftest%2Frun-pass%2Fprivacy-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprivacy-reexport.rs?ref=cd9069ca734fe89fe446c16dc821e54b973506f5", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast\n+// aux-build:privacy_reexport.rs\n+\n+extern mod privacy_reexport;\n+\n+fn main() {\n+    privacy_reexport::bar::frob();\n+}"}]}