{"sha": "42eb4efb5b58d1e91787eed0c23cc26157908474", "node_id": "C_kwDOAAsO6NoAKDQyZWI0ZWZiNWI1OGQxZTkxNzg3ZWVkMGMyM2NjMjYxNTc5MDg0NzQ", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-23T13:37:52Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-23T14:28:03Z"}, "message": "Cleanup", "tree": {"sha": "44d3883f97e653fa4b167f15755cf3a33684499d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44d3883f97e653fa4b167f15755cf3a33684499d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42eb4efb5b58d1e91787eed0c23cc26157908474", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42eb4efb5b58d1e91787eed0c23cc26157908474", "html_url": "https://github.com/rust-lang/rust/commit/42eb4efb5b58d1e91787eed0c23cc26157908474", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42eb4efb5b58d1e91787eed0c23cc26157908474/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "075fe761f393c0445bc375175eaa52164bbdc728", "url": "https://api.github.com/repos/rust-lang/rust/commits/075fe761f393c0445bc375175eaa52164bbdc728", "html_url": "https://github.com/rust-lang/rust/commit/075fe761f393c0445bc375175eaa52164bbdc728"}], "stats": {"total": 318, "additions": 145, "deletions": 173}, "files": [{"sha": "9170ec3a66bacc6af2fd9e35922d4b63a9528c65", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42eb4efb5b58d1e91787eed0c23cc26157908474/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/42eb4efb5b58d1e91787eed0c23cc26157908474/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=42eb4efb5b58d1e91787eed0c23cc26157908474", "patch": "@@ -645,6 +645,7 @@ dependencies = [\n name = \"ide_db\"\n version = \"0.0.0\"\n dependencies = [\n+ \"arrayvec\",\n  \"base_db\",\n  \"cov-mark\",\n  \"either\","}, {"sha": "ef86572fe5ac5ce2fab18b1703190bab90a7c9a6", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42eb4efb5b58d1e91787eed0c23cc26157908474/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb4efb5b58d1e91787eed0c23cc26157908474/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=42eb4efb5b58d1e91787eed0c23cc26157908474", "patch": "@@ -547,6 +547,7 @@ fn inner_attributes(\n     Some((attrs, docs))\n }\n \n+#[derive(Debug)]\n pub struct AttrSourceMap {\n     attrs: Vec<InFile<ast::Attr>>,\n     doc_comments: Vec<InFile<ast::Comment>>,\n@@ -599,6 +600,7 @@ impl AttrSourceMap {\n }\n \n /// A struct to map text ranges from [`Documentation`] back to TextRanges in the syntax tree.\n+#[derive(Debug)]\n pub struct DocsRangeMap {\n     source_map: AttrSourceMap,\n     // (docstring-line-range, attr_index, attr-string-range)"}, {"sha": "9acea114d6e7b1f51f2aa5beb732d37a08888fc2", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42eb4efb5b58d1e91787eed0c23cc26157908474/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb4efb5b58d1e91787eed0c23cc26157908474/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=42eb4efb5b58d1e91787eed0c23cc26157908474", "patch": "@@ -64,7 +64,7 @@ pub(crate) fn goto_definition(\n                 }\n             }\n             Some(\n-                Definition::from_node(&sema, &token)\n+                Definition::from_token(&sema, &token)\n                     .into_iter()\n                     .flat_map(|def| {\n                         try_find_trait_item_definition(sema.db, &def)"}, {"sha": "4e57484c78cc980ecd2f4aa6e5ecbca911933809", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 67, "deletions": 121, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/42eb4efb5b58d1e91787eed0c23cc26157908474/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb4efb5b58d1e91787eed0c23cc26157908474/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=42eb4efb5b58d1e91787eed0c23cc26157908474", "patch": "@@ -1,4 +1,4 @@\n-use std::{collections::HashSet, ops::ControlFlow};\n+use std::iter;\n \n use either::Either;\n use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, Semantics, TypeInfo};\n@@ -15,7 +15,7 @@ use itertools::Itertools;\n use stdx::format_to;\n use syntax::{\n     algo, ast, display::fn_as_proc_macro_label, match_ast, AstNode, Direction, SyntaxKind::*,\n-    SyntaxNode, SyntaxToken, TextRange, TextSize, T,\n+    SyntaxNode, SyntaxToken, T,\n };\n \n use crate::{\n@@ -99,7 +99,7 @@ pub(crate) fn hover(\n     FileRange { file_id, range }: FileRange,\n     config: &HoverConfig,\n ) -> Option<RangeInfo<HoverResult>> {\n-    let sema = hir::Semantics::new(db);\n+    let sema = &hir::Semantics::new(db);\n     let file = sema.parse(file_id).syntax().clone();\n \n     if !range.is_empty() {\n@@ -114,145 +114,82 @@ pub(crate) fn hover(\n         _ => 1,\n     })?;\n \n-    let mut seen = HashSet::default();\n+    let descended = sema.descend_into_macros_many(original_token.clone());\n \n-    let mut fallback = None;\n-    // attributes, require special machinery as they are mere ident tokens\n-\n-    let descend_macros = sema.descend_into_macros_many(original_token.clone());\n-\n-    for token in &descend_macros {\n-        if token.kind() != COMMENT {\n-            if let Some(attr) = token.ancestors().find_map(ast::Attr::cast) {\n-                // lints\n-                if let Some(res) = try_hover_for_lint(&attr, &token) {\n-                    return Some(res);\n-                }\n-            }\n-        }\n-    }\n-\n-    descend_macros\n-        .iter()\n-        .filter_map(|token| match token.parent() {\n-            Some(node) => {\n-                match find_hover_result(\n-                    &sema,\n-                    file_id,\n-                    offset,\n-                    config,\n-                    &original_token,\n-                    token,\n-                    &node,\n-                    &mut seen,\n-                ) {\n-                    Some(res) => match res {\n-                        ControlFlow::Break(inner) => Some(inner),\n-                        ControlFlow::Continue(_) => {\n-                            if fallback.is_none() {\n-                                // FIXME we're only taking the first fallback into account that's not `None`\n-                                fallback = hover_for_keyword(&sema, config, &token)\n-                                    .or(type_hover(&sema, config, &token));\n-                            }\n-                            None\n-                        }\n-                    },\n-                    None => None,\n-                }\n-            }\n-            None => None,\n-        })\n-        // reduce all descends into a single `RangeInfo`\n-        // that spans from the earliest start to the latest end (fishy/FIXME),\n-        // concatenates all `Markup`s with `\\n---\\n`,\n-        // and accumulates all actions into its `actions` vector.\n-        .reduce(|mut acc, RangeInfo { range, mut info }| {\n-            let start = acc.range.start().min(range.start());\n-            let end = acc.range.end().max(range.end());\n-\n-            acc.range = TextRange::new(start, end);\n-            acc.info.actions.append(&mut info.actions);\n-            acc.info.markup = Markup::from(format!(\"{}\\n---\\n{}\", acc.info.markup, info.markup));\n-            acc\n-        })\n-        .or(fallback)\n-}\n-\n-fn find_hover_result(\n-    sema: &Semantics<RootDatabase>,\n-    file_id: FileId,\n-    offset: TextSize,\n-    config: &HoverConfig,\n-    original_token: &SyntaxToken,\n-    token: &SyntaxToken,\n-    node: &SyntaxNode,\n-    seen: &mut HashSet<Definition>,\n-) -> Option<ControlFlow<RangeInfo<HoverResult>>> {\n-    let mut range_override = None;\n-\n-    // intra-doc links and attributes are special cased\n-    // so don't add them to the `seen` duplicate check\n-    let mut add_to_seen_definitions = true;\n-\n-    let definition = Definition::from_node(sema, token).into_iter().next().or_else(|| {\n+    // FIXME handle doc attributes? TokenMap currently doesn't work with comments\n+    if original_token.kind() == COMMENT {\n+        let relative_comment_offset = offset - original_token.text_range().start();\n         // intra-doc links\n-        // FIXME: move comment + attribute special cases somewhere else to simplify control flow,\n-        // hopefully simplifying the return type of this function in the process\n-        // (the `Break`/`Continue` distinction is needed to decide whether to use fallback hovers)\n-        //\n-        // FIXME: hovering the intra doc link to `Foo` not working:\n-        //\n-        // #[identity]\n-        // trait Foo {\n-        //    /// [`Foo`]\n-        // fn foo() {}\n-        if token.kind() == COMMENT {\n-            add_to_seen_definitions = false;\n-            cov_mark::hit!(no_highlight_on_comment_hover);\n-            let (attributes, def) = doc_attributes(sema, node)?;\n+        cov_mark::hit!(no_highlight_on_comment_hover);\n+        return descended.iter().find_map(|t| {\n+            match t.kind() {\n+                COMMENT => (),\n+                TOKEN_TREE => {}\n+                _ => return None,\n+            }\n+            let node = t.parent()?;\n+            let absolute_comment_offset = t.text_range().start() + relative_comment_offset;\n+            let (attributes, def) = doc_attributes(sema, &node)?;\n             let (docs, doc_mapping) = attributes.docs_with_rangemap(sema.db)?;\n             let (idl_range, link, ns) = extract_definitions_from_docs(&docs).into_iter().find_map(\n                 |(range, link, ns)| {\n                     let mapped = doc_mapping.map(range)?;\n-                    (mapped.file_id == file_id.into() && mapped.value.contains(offset))\n-                        .then(|| (mapped.value, link, ns))\n+                    (mapped.file_id == file_id.into()\n+                        && mapped.value.contains(absolute_comment_offset))\n+                    .then(|| (mapped.value, link, ns))\n                 },\n             )?;\n-            range_override = Some(idl_range);\n-            Some(match resolve_doc_path_for_def(sema.db, def, &link, ns)? {\n+            let def = match resolve_doc_path_for_def(sema.db, def, &link, ns)? {\n                 Either::Left(it) => Definition::ModuleDef(it),\n                 Either::Right(it) => Definition::Macro(it),\n-            })\n-        } else {\n-            None\n-        }\n-    });\n+            };\n+            let res = hover_for_definition(sema, file_id, def, &node, config)?;\n+            Some(RangeInfo::new(idl_range, res))\n+        });\n+    }\n \n-    if let Some(definition) = definition {\n-        // skip duplicates\n-        if seen.contains(&definition) {\n-            return None;\n-        }\n-        if add_to_seen_definitions {\n-            seen.insert(definition);\n+    // attributes, require special machinery as they are mere ident tokens\n+\n+    // FIXME: Definition should include known lints and the like instead of having this special case here\n+    if let res @ Some(_) = descended.iter().find_map(|token| {\n+        let attr = token.ancestors().find_map(ast::Attr::cast)?;\n+        try_hover_for_lint(&attr, &token)\n+    }) {\n+        return res;\n+    }\n+\n+    let result = descended\n+        .iter()\n+        .filter_map(|token| {\n+            let node = token.parent()?;\n+            let defs = Definition::from_token(sema, token);\n+            Some(defs.into_iter().zip(iter::once(node).cycle()))\n+        })\n+        .flatten()\n+        .unique_by(|&(def, _)| def)\n+        .filter_map(|(def, node)| hover_for_definition(sema, file_id, def, &node, config))\n+        .reduce(|mut acc, HoverResult { markup, actions }| {\n+            acc.actions.extend(actions);\n+            acc.markup = Markup::from(format!(\"{}\\n---\\n{}\", acc.markup, markup));\n+            acc\n+        });\n+    if result.is_none() {\n+        // fallbacks, show keywords or types\n+        if let res @ Some(_) = hover_for_keyword(sema, config, &original_token) {\n+            return res;\n         }\n-        if let Some(res) = hover_for_definition(sema, file_id, definition, &node, config) {\n-            let range = range_override.unwrap_or_else(|| original_token.text_range());\n-            return Some(ControlFlow::Break(RangeInfo::new(range, res)));\n+        if let res @ Some(_) = descended.iter().find_map(|token| type_hover(sema, config, token)) {\n+            return res;\n         }\n     }\n-\n-    Some(ControlFlow::Continue(()))\n+    result.map(|res| RangeInfo::new(original_token.text_range(), res))\n }\n \n fn type_hover(\n     sema: &Semantics<RootDatabase>,\n     config: &HoverConfig,\n     token: &SyntaxToken,\n ) -> Option<RangeInfo<HoverResult>> {\n-    if token.kind() == COMMENT {\n-        return None;\n-    }\n     let node = token\n         .ancestors()\n         .take_while(|it| !ast::Item::can_cast(it.kind()))\n@@ -3626,6 +3563,15 @@ fn main() {\n                 ```rust\n                 f: &i32\n                 ```\n+                ---\n+\n+                ```rust\n+                test::S\n+                ```\n+\n+                ```rust\n+                f: i32\n+                ```\n             \"#]],\n         );\n     }"}, {"sha": "cdaff0ce3977a7706f7b8b4f1cfbba60f229fd99", "filename": "crates/ide_db/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42eb4efb5b58d1e91787eed0c23cc26157908474/crates%2Fide_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/42eb4efb5b58d1e91787eed0c23cc26157908474/crates%2Fide_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2FCargo.toml?ref=42eb4efb5b58d1e91787eed0c23cc26157908474", "patch": "@@ -17,6 +17,7 @@ rustc-hash = \"1.1.0\"\n once_cell = \"1.3.1\"\n either = \"1.6.1\"\n itertools = \"0.10.0\"\n+arrayvec = \"0.7\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n syntax = { path = \"../syntax\", version = \"0.0.0\" }"}, {"sha": "effa694aaed6b2f7fa2fa474c490a4453ff322d6", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 63, "deletions": 51, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/42eb4efb5b58d1e91787eed0c23cc26157908474/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb4efb5b58d1e91787eed0c23cc26157908474/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=42eb4efb5b58d1e91787eed0c23cc26157908474", "patch": "@@ -5,13 +5,14 @@\n \n // FIXME: this badly needs rename/rewrite (matklad, 2020-02-06).\n \n+use arrayvec::ArrayVec;\n use hir::{\n     Field, GenericParam, HasVisibility, Impl, Label, Local, MacroDef, Module, ModuleDef, Name,\n     PathResolution, Semantics, Visibility,\n };\n use syntax::{\n     ast::{self, AstNode},\n-    match_ast, SyntaxKind, SyntaxToken,\n+    match_ast, SyntaxKind, SyntaxNode, SyntaxToken,\n };\n \n use crate::{helpers::try_resolve_derive_input_at, RootDatabase};\n@@ -29,60 +30,71 @@ pub enum Definition {\n }\n \n impl Definition {\n-    pub fn from_node(sema: &Semantics<RootDatabase>, token: &SyntaxToken) -> Vec<Definition> {\n-        let node = if let Some(x) = token.parent() {\n-            x\n-        } else {\n-            return vec![];\n+    pub fn from_token(\n+        sema: &Semantics<RootDatabase>,\n+        token: &SyntaxToken,\n+    ) -> ArrayVec<Definition, 2> {\n+        let parent = match token.parent() {\n+            Some(parent) => parent,\n+            None => return Default::default(),\n         };\n-        if token.kind() != SyntaxKind::COMMENT {\n-            if let Some(attr) = token.ancestors().find_map(ast::Attr::cast) {\n-                // derives\n-                let def = try_resolve_derive_input_at(&sema, &attr, &token).map(Definition::Macro);\n-                if let Some(def) = def {\n-                    return vec![def];\n-                }\n-            }\n+        let attr = parent\n+            .ancestors()\n+            .find_map(ast::TokenTree::cast)\n+            .and_then(|tt| tt.parent_meta())\n+            .and_then(|meta| meta.parent_attr());\n+        if let Some(attr) = attr {\n+            try_resolve_derive_input_at(&sema, &attr, &token)\n+                .map(Definition::Macro)\n+                .into_iter()\n+                .collect()\n+        } else {\n+            Self::from_node(sema, &parent)\n         }\n-        match_ast! {\n-            match node {\n-                ast::Name(name) => {\n-                    let class = if let Some(x) = NameClass::classify(&sema, &name) {\n-                        x\n-                    } else {\n-                        return vec![];\n-                    };\n-                    match class {\n-                        NameClass::Definition(it) | NameClass::ConstReference(it) => vec![it],\n-                        NameClass::PatFieldShorthand { local_def, field_ref } => vec![Definition::Local(local_def), Definition::Field(field_ref)],\n-                    }\n-                },\n-                ast::NameRef(name_ref) => {\n-                    let class = if let Some(x) = NameRefClass::classify(sema, &name_ref) {\n-                        x\n-                    } else {\n-                        return vec![];\n-                    };\n-                    match class {\n-                        NameRefClass::Definition(def) => vec![def],\n-                        NameRefClass::FieldShorthand { local_ref, field_ref } => {\n-                            vec![Definition::Field(field_ref), Definition::Local(local_ref)]\n+    }\n+\n+    pub fn from_node(sema: &Semantics<RootDatabase>, node: &SyntaxNode) -> ArrayVec<Definition, 2> {\n+        let mut res = ArrayVec::new();\n+        (|| {\n+            match_ast! {\n+                match node {\n+                    ast::Name(name) => {\n+                        match NameClass::classify(&sema, &name)? {\n+                            NameClass::Definition(it) | NameClass::ConstReference(it) => res.push(it),\n+                            NameClass::PatFieldShorthand { local_def, field_ref } => {\n+                                res.push(Definition::Local(local_def));\n+                                res.push(Definition::Field(field_ref));\n+                            }\n                         }\n-                    }\n-                },\n-                ast::Lifetime(lifetime) => {\n-                    (if let Some(x) = NameClass::classify_lifetime(&sema, &lifetime) {\n-                        NameClass::defined(x)\n-                    } else {\n-                        NameRefClass::classify_lifetime(&sema, &lifetime).and_then(|class| match class {\n-                            NameRefClass::Definition(it) => Some(it),\n-                            _ => None,\n-                        })\n-                    }).into_iter().collect()\n-                },\n-                _ => vec![],\n+                    },\n+                    ast::NameRef(name_ref) => {\n+                        match NameRefClass::classify(sema, &name_ref)? {\n+                            NameRefClass::Definition(it) => res.push(it),\n+                            NameRefClass::FieldShorthand { local_ref, field_ref } => {\n+                                res.push(Definition::Local(local_ref));\n+                                res.push(Definition::Field(field_ref));\n+                            }\n+                        }\n+                    },\n+                    ast::Lifetime(lifetime) => {\n+                        let def = if let Some(x) = NameClass::classify_lifetime(&sema, &lifetime) {\n+                            NameClass::defined(x)\n+                        } else {\n+                            NameRefClass::classify_lifetime(&sema, &lifetime).and_then(|class| match class {\n+                                NameRefClass::Definition(it) => Some(it),\n+                                _ => None,\n+                            })\n+                        };\n+                        if let Some(def) = def {\n+                            res.push(def);\n+                        }\n+                    },\n+                    _ => (),\n+                }\n             }\n-        }\n+            Some(())\n+        })();\n+        res\n     }\n \n     pub fn module(&self, db: &RootDatabase) -> Option<Module> {"}, {"sha": "40704067022ad9c81ea86d671dc7aef488bbce6b", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/42eb4efb5b58d1e91787eed0c23cc26157908474/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb4efb5b58d1e91787eed0c23cc26157908474/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=42eb4efb5b58d1e91787eed0c23cc26157908474", "patch": "@@ -796,6 +796,16 @@ impl ast::TokenTree {\n             .into_token()\n             .filter(|it| matches!(it.kind(), T!['}'] | T![')'] | T![']']))\n     }\n+\n+    pub fn parent_meta(&self) -> Option<ast::Meta> {\n+        self.syntax().parent().and_then(ast::Meta::cast)\n+    }\n+}\n+\n+impl ast::Meta {\n+    pub fn parent_attr(&self) -> Option<ast::Attr> {\n+        self.syntax().parent().and_then(ast::Attr::cast)\n+    }\n }\n \n impl ast::GenericParamList {"}]}