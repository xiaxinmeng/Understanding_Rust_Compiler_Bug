{"sha": "b6f0f300d572cc8e6a1cc8ab9aad101dcf20efac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2ZjBmMzAwZDU3MmNjOGU2YTFjYzhhYjlhYWQxMDFkY2YyMGVmYWM=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-12-21T15:47:32Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-12-25T02:29:01Z"}, "message": "std: modernize net_url\n\nThis switches over to using structs and send_maps for\nquery string parsing.", "tree": {"sha": "459129dae1094c318c339c15364e97b686a52e2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/459129dae1094c318c339c15364e97b686a52e2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6f0f300d572cc8e6a1cc8ab9aad101dcf20efac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6f0f300d572cc8e6a1cc8ab9aad101dcf20efac", "html_url": "https://github.com/rust-lang/rust/commit/b6f0f300d572cc8e6a1cc8ab9aad101dcf20efac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6f0f300d572cc8e6a1cc8ab9aad101dcf20efac/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03b5fcabbd34c9ceb8466bfbca2cf6ca4cd36731", "url": "https://api.github.com/repos/rust-lang/rust/commits/03b5fcabbd34c9ceb8466bfbca2cf6ca4cd36731", "html_url": "https://github.com/rust-lang/rust/commit/03b5fcabbd34c9ceb8466bfbca2cf6ca4cd36731"}], "stats": {"total": 680, "additions": 316, "deletions": 364}, "files": [{"sha": "a6ba728ccbb07670d1edb337b0b71a6a0e2898f4", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 316, "deletions": 364, "changes": 680, "blob_url": "https://github.com/rust-lang/rust/blob/b6f0f300d572cc8e6a1cc8ab9aad101dcf20efac/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6f0f300d572cc8e6a1cc8ab9aad101dcf20efac/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=b6f0f300d572cc8e6a1cc8ab9aad101dcf20efac", "patch": "@@ -11,15 +11,10 @@\n //! Types/fns concerning URLs (see RFC 3986)\n #[forbid(deprecated_mode)];\n \n-use core::cmp::Eq;\n-use map::HashMap;\n-use io::{Reader, ReaderUtil};\n-use dvec::DVec;\n-use from_str::FromStr;\n-use result::{Err, Ok};\n-use to_str::ToStr;\n-use to_bytes::IterBytes;\n+use io::ReaderUtil;\n+use send_map::linear::LinearMap;\n \n+#[deriving_eq]\n struct Url {\n     scheme: ~str,\n     user: Option<UserInfo>,\n@@ -30,23 +25,40 @@ struct Url {\n     fragment: Option<~str>\n }\n \n-type UserInfo = {\n+#[deriving_eq]\n+struct UserInfo {\n     user: ~str,\n     pass: Option<~str>\n-};\n+}\n \n pub type Query = ~[(~str, ~str)];\n \n-pub pure fn Url(scheme: ~str, user: Option<UserInfo>, host: ~str,\n-       port: Option<~str>, path: ~str, query: Query,\n-       fragment: Option<~str>) -> Url {\n-    Url { scheme: move scheme, user: move user, host: move host,\n-         port: move port, path: move path, query: move query,\n-         fragment: move fragment }\n+pub impl Url {\n+    static pure fn new(\n+        scheme: ~str,\n+        user: Option<UserInfo>,\n+        host: ~str,\n+        port: Option<~str>,\n+        path: ~str,\n+        query: Query,\n+        fragment: Option<~str>\n+    ) -> Url {\n+        Url {\n+            scheme: scheme,\n+            user: user,\n+            host: host,\n+            port: port,\n+            path: path,\n+            query: query,\n+            fragment: fragment,\n+        }\n+    }\n }\n \n-pure fn UserInfo(user: ~str, pass: Option<~str>) -> UserInfo {\n-    {user: move user, pass: move pass}\n+pub impl UserInfo {\n+    static pure fn new(user: ~str, pass: Option<~str>) -> UserInfo {\n+        UserInfo { user: user, pass: pass }\n+    }\n }\n \n fn encode_inner(s: &str, full_url: bool) -> ~str {\n@@ -95,7 +107,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n  * This function is compliant with RFC 3986.\n  */\n pub pure fn encode(s: &str) -> ~str {\n-    // unsafe only because encode_inner does (string) IO\n+    // FIXME(#3722): unsafe only because encode_inner does (string) IO\n     unsafe {encode_inner(s, true)}\n }\n \n@@ -107,7 +119,7 @@ pub pure fn encode(s: &str) -> ~str {\n  */\n \n pub pure fn encode_component(s: &str) -> ~str {\n-    // unsafe only because encode_inner does (string) IO\n+    // FIXME(#3722): unsafe only because encode_inner does (string) IO\n     unsafe {encode_inner(s, false)}\n }\n \n@@ -152,18 +164,18 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n /**\n  * Decode a string encoded with percent encoding.\n  *\n- * This will only decode escape sequences generated by encode_uri.\n+ * This will only decode escape sequences generated by encode.\n  */\n pub pure fn decode(s: &str) -> ~str {\n-    // unsafe only because decode_inner does (string) IO\n+    // FIXME(#3722): unsafe only because decode_inner does (string) IO\n     unsafe {decode_inner(s, true)}\n }\n \n /**\n  * Decode a string encoded with percent encoding.\n  */\n pub pure fn decode_component(s: &str) -> ~str {\n-    // unsafe only because decode_inner does (string) IO\n+    // FIXME(#3722): unsafe only because decode_inner does (string) IO\n     unsafe {decode_inner(s, false)}\n }\n \n@@ -189,12 +201,12 @@ fn encode_plus(s: &str) -> ~str {\n /**\n  * Encode a hashmap to the 'application/x-www-form-urlencoded' media type.\n  */\n-pub fn encode_form_urlencoded(m: HashMap<~str, @DVec<@~str>>) -> ~str {\n+pub fn encode_form_urlencoded(m: &LinearMap<~str, ~[~str]>) -> ~str {\n     let mut out = ~\"\";\n     let mut first = true;\n \n     for m.each |key, values| {\n-        let key = encode_plus(key);\n+        let key = encode_plus(*key);\n \n         for (*values).each |value| {\n             if first {\n@@ -204,7 +216,7 @@ pub fn encode_form_urlencoded(m: HashMap<~str, @DVec<@~str>>) -> ~str {\n                 first = false;\n             }\n \n-            out += fmt!(\"%s=%s\", key, encode_plus(**value));\n+            out += fmt!(\"%s=%s\", key, encode_plus(*value));\n         }\n     }\n \n@@ -215,62 +227,60 @@ pub fn encode_form_urlencoded(m: HashMap<~str, @DVec<@~str>>) -> ~str {\n  * Decode a string encoded with the 'application/x-www-form-urlencoded' media\n  * type into a hashmap.\n  */\n-pub fn decode_form_urlencoded(s: ~[u8]) ->\n-    map::HashMap<~str, @dvec::DVec<@~str>> {\n+pub fn decode_form_urlencoded(\n+    s: &[u8]\n+) -> send_map::linear::LinearMap<~str, ~[~str]> {\n     do io::with_bytes_reader(s) |rdr| {\n-        let m = HashMap();\n+        let mut m = LinearMap();\n         let mut key = ~\"\";\n         let mut value = ~\"\";\n         let mut parsing_key = true;\n \n         while !rdr.eof() {\n             match rdr.read_char() {\n-              '&' | ';' => {\n-                if key != ~\"\" && value != ~\"\" {\n-                    let values = match m.find(key) {\n-                      Some(values) => values,\n-                      None => {\n-                        let values = @DVec();\n+                '&' | ';' => {\n+                    if key != ~\"\" && value != ~\"\" {\n+                        let mut values = match m.pop(&key) {\n+                            Some(move values) => values,\n+                            None => ~[],\n+                        };\n+\n+                        values.push(value);\n                         m.insert(key, values);\n-                        values\n-                      }\n-                    };\n-                    (*values).push(@value)\n+                    }\n+\n+                    parsing_key = true;\n+                    key = ~\"\";\n+                    value = ~\"\";\n                 }\n+                '=' => parsing_key = false,\n+                ch => {\n+                    let ch = match ch {\n+                        '%' => {\n+                            let bytes = rdr.read_bytes(2u);\n+                            uint::parse_bytes(bytes, 16u).get() as char\n+                        }\n+                        '+' => ' ',\n+                        ch => ch\n+                    };\n \n-                parsing_key = true;\n-                key = ~\"\";\n-                value = ~\"\";\n-              }\n-              '=' => parsing_key = false,\n-              ch => {\n-                let ch = match ch {\n-                  '%' => {\n-                    uint::parse_bytes(rdr.read_bytes(2u), 16u).get() as char\n-                  }\n-                  '+' => ' ',\n-                  ch => ch\n-                };\n-\n-                if parsing_key {\n-                    str::push_char(&mut key, ch)\n-                } else {\n-                    str::push_char(&mut value, ch)\n+                    if parsing_key {\n+                        str::push_char(&mut key, ch)\n+                    } else {\n+                        str::push_char(&mut value, ch)\n+                    }\n                 }\n-              }\n             }\n         }\n \n         if key != ~\"\" && value != ~\"\" {\n-            let values = match m.find(key) {\n-              Some(values) => values,\n-              None => {\n-                let values = @DVec();\n-                m.insert(key, values);\n-                values\n-              }\n+            let mut values = match m.pop(&key) {\n+                Some(move values) => values,\n+                None => ~[],\n             };\n-            (*values).push(@value)\n+\n+            values.push(value);\n+            m.insert(key, values);\n         }\n \n         m\n@@ -282,9 +292,10 @@ pure fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n     let len = str::len(s);\n     let mut index = len;\n     let mut mat = 0;\n+    // FIXME(#3722): unsafe only because decode_inner does (string) IO\n     unsafe {\n         do io::with_str_reader(s) |rdr| {\n-            let mut ch : char;\n+            let mut ch;\n             while !rdr.eof() {\n                 ch = rdr.read_byte() as char;\n                 if ch == c {\n@@ -307,107 +318,88 @@ pure fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n pure fn userinfo_from_str(uinfo: &str) -> UserInfo {\n     let (user, p) = split_char_first(uinfo, ':');\n     let pass = if str::len(p) == 0 {\n-        option::None\n+        None\n     } else {\n-        option::Some(p)\n+        Some(p)\n     };\n-    return UserInfo(user, pass);\n+    return UserInfo::new(user, pass);\n }\n \n-pure fn userinfo_to_str(userinfo: UserInfo) -> ~str {\n-    if option::is_some(&userinfo.pass) {\n-        return str::concat(~[copy userinfo.user, ~\":\",\n-                          option::unwrap(copy userinfo.pass),\n-                          ~\"@\"]);\n-    } else {\n-        return str::concat(~[copy userinfo.user, ~\"@\"]);\n+pure fn userinfo_to_str(userinfo: &UserInfo) -> ~str {\n+    match userinfo.pass {\n+        Some(ref pass) => fmt!(\"%s:%s@\", userinfo.user, *pass),\n+        None => fmt!(\"%s@\", userinfo.user),\n     }\n }\n \n-impl UserInfo : Eq {\n-    pure fn eq(&self, other: &UserInfo) -> bool {\n-        (*self).user == (*other).user && (*self).pass == (*other).pass\n-    }\n-    pure fn ne(&self, other: &UserInfo) -> bool { !(*self).eq(other) }\n-}\n-\n pure fn query_from_str(rawquery: &str) -> Query {\n     let mut query: Query = ~[];\n     if str::len(rawquery) != 0 {\n         for str::split_char(rawquery, '&').each |p| {\n             let (k, v) = split_char_first(*p, '=');\n+            // FIXME(#3722): unsafe only because decode_inner does (string) IO\n             unsafe {query.push((decode_component(k), decode_component(v)));}\n         };\n     }\n     return query;\n }\n \n-pub pure fn query_to_str(query: Query) -> ~str {\n+pub pure fn query_to_str(query: &Query) -> ~str unsafe {\n+    // FIXME(#3722): unsafe only because decode_inner does (string) IO\n     let mut strvec = ~[];\n     for query.each |kv| {\n-        let (k, v) = copy *kv;\n-        // This is really safe...\n-        unsafe {\n-          strvec += ~[fmt!(\"%s=%s\",\n-                           encode_component(k), encode_component(v))];\n+        match kv {\n+            &(ref k, ref v) => {\n+                strvec.push(fmt!(\"%s=%s\",\n+                    encode_component(*k),\n+                    encode_component(*v))\n+                );\n+            }\n         }\n-    };\n+    }\n     return str::connect(strvec, ~\"&\");\n }\n \n // returns the scheme and the rest of the url, or a parsing error\n-pub pure fn get_scheme(rawurl: &str) -> result::Result<(~str, ~str), @~str> {\n+pub pure fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n     for str::each_chari(rawurl) |i,c| {\n         match c {\n           'A' .. 'Z' | 'a' .. 'z' => loop,\n           '0' .. '9' | '+' | '-' | '.' => {\n             if i == 0 {\n-                return result::Err(@~\"url: Scheme must begin with a letter.\");\n+                return Err(~\"url: Scheme must begin with a letter.\");\n             }\n             loop;\n           }\n           ':' => {\n             if i == 0 {\n-                return result::Err(@~\"url: Scheme cannot be empty.\");\n+                return Err(~\"url: Scheme cannot be empty.\");\n             } else {\n-                return result::Ok((rawurl.slice(0,i),\n+                return Ok((rawurl.slice(0,i),\n                                 rawurl.slice(i+1,str::len(rawurl))));\n             }\n           }\n           _ => {\n-            return result::Err(@~\"url: Invalid character in scheme.\");\n+            return Err(~\"url: Invalid character in scheme.\");\n           }\n         }\n     };\n-    return result::Err(@~\"url: Scheme must be terminated with a colon.\");\n+    return Err(~\"url: Scheme must be terminated with a colon.\");\n }\n \n+#[deriving_eq]\n enum Input {\n     Digit, // all digits\n     Hex, // digits and letters a-f\n     Unreserved // all other legal characters\n }\n \n-impl Input : Eq {\n-    pure fn eq(&self, other: &Input) -> bool {\n-        match ((*self), (*other)) {\n-            (Digit, Digit) => true,\n-            (Hex, Hex) => true,\n-            (Unreserved, Unreserved) => true,\n-            (Digit, _) => false,\n-            (Hex, _) => false,\n-            (Unreserved, _) => false\n-        }\n-    }\n-    pure fn ne(&self, other: &Input) -> bool { !(*self).eq(other) }\n-}\n-\n // returns userinfo, host, port, and unparsed part, or an error\n pure fn get_authority(rawurl: &str) ->\n-    result::Result<(Option<UserInfo>, ~str, Option<~str>, ~str), @~str> {\n+    Result<(Option<UserInfo>, ~str, Option<~str>, ~str), ~str> {\n     if !str::starts_with(rawurl, ~\"//\") {\n         // there is no authority.\n-        return result::Ok((option::None, ~\"\", option::None, rawurl.to_str()));\n+        return Ok((None, ~\"\", None, rawurl.to_str()));\n     }\n \n     enum State {\n@@ -419,16 +411,16 @@ pure fn get_authority(rawurl: &str) ->\n         InPort // are in port\n     }\n \n-    let len = str::len(rawurl);\n-    let mut st : State = Start;\n-    let mut in : Input = Digit; // most restricted, start here.\n+    let len = rawurl.len();\n+    let mut st = Start;\n+    let mut in = Digit; // most restricted, start here.\n \n-    let mut userinfo : Option<UserInfo> = option::None;\n-    let mut host : ~str = ~\"\";\n-    let mut port : option::Option<~str> = option::None;\n+    let mut userinfo = None;\n+    let mut host = ~\"\";\n+    let mut port = None;\n \n     let mut colon_count = 0;\n-    let mut pos : uint = 0, begin : uint = 2, end : uint = len;\n+    let mut pos = 0, begin = 2, end = len;\n \n     for str::each_chari(rawurl) |i,c| {\n         if i < 2 { loop; } // ignore the leading //\n@@ -449,7 +441,7 @@ pure fn get_authority(rawurl: &str) ->\n             // separators, don't change anything\n           }\n           _ => {\n-            return result::Err(@~\"Illegal character in authority\");\n+            return Err(~\"Illegal character in authority\");\n           }\n         }\n \n@@ -465,22 +457,22 @@ pure fn get_authority(rawurl: &str) ->\n               PassHostPort => {\n                 // multiple colons means ipv6 address.\n                 if in == Unreserved {\n-                    return result::Err(\n-                        @~\"Illegal characters in IPv6 address.\");\n+                    return Err(\n+                        ~\"Illegal characters in IPv6 address.\");\n                 }\n                 st = Ip6Host;\n               }\n               InHost => {\n                 pos = i;\n                 // can't be sure whether this is an ipv6 address or a port\n                 if in == Unreserved {\n-                    return result::Err(@~\"Illegal characters in authority.\");\n+                    return Err(~\"Illegal characters in authority.\");\n                 }\n                 st = Ip6Port;\n               }\n               Ip6Port => {\n                 if in == Unreserved {\n-                    return result::Err(@~\"Illegal characters in authority.\");\n+                    return Err(~\"Illegal characters in authority.\");\n                 }\n                 st = Ip6Host;\n               }\n@@ -492,7 +484,7 @@ pure fn get_authority(rawurl: &str) ->\n                 }\n               }\n               _ => {\n-                return result::Err(@~\"Invalid ':' in authority.\");\n+                return Err(~\"Invalid ':' in authority.\");\n               }\n             }\n             in = Digit; // reset input class\n@@ -504,19 +496,17 @@ pure fn get_authority(rawurl: &str) ->\n             match st {\n               Start => {\n                 let user = str::slice(rawurl, begin, i);\n-                userinfo = option::Some({user : user,\n-                                         pass: option::None});\n+                userinfo = Some(UserInfo::new(user, None));\n                 st = InHost;\n               }\n               PassHostPort => {\n                 let user = str::slice(rawurl, begin, pos);\n                 let pass = str::slice(rawurl, pos+1, i);\n-                userinfo = option::Some({user: user,\n-                                         pass: option::Some(pass)});\n+                userinfo = Some(UserInfo::new(user, Some(pass)));\n                 st = InHost;\n               }\n               _ => {\n-                return result::Err(@~\"Invalid '@' in authority.\");\n+                return Err(~\"Invalid '@' in authority.\");\n               }\n             }\n             begin = i+1;\n@@ -549,31 +539,31 @@ pure fn get_authority(rawurl: &str) ->\n       }\n       PassHostPort | Ip6Port => {\n         if in != Digit {\n-            return result::Err(@~\"Non-digit characters in port.\");\n+            return Err(~\"Non-digit characters in port.\");\n         }\n         host = str::slice(rawurl, begin, pos);\n-        port = option::Some(str::slice(rawurl, pos+1, end));\n+        port = Some(str::slice(rawurl, pos+1, end));\n       }\n       Ip6Host | InHost => {\n         host = str::slice(rawurl, begin, end);\n       }\n       InPort => {\n         if in != Digit {\n-            return result::Err(@~\"Non-digit characters in port.\");\n+            return Err(~\"Non-digit characters in port.\");\n         }\n-        port = option::Some(str::slice(rawurl, pos+1, end));\n+        port = Some(str::slice(rawurl, pos+1, end));\n       }\n     }\n \n     let rest = if host_is_end_plus_one() { ~\"\" }\n     else { str::slice(rawurl, end, len) };\n-    return result::Ok((userinfo, host, port, rest));\n+    return Ok((userinfo, host, port, rest));\n }\n \n \n // returns the path and unparsed part of url, or an error\n-pure fn get_path(rawurl: &str, authority : bool) ->\n-    result::Result<(~str, ~str), @~str> {\n+pure fn get_path(rawurl: &str, authority: bool) ->\n+    Result<(~str, ~str), ~str> {\n     let len = str::len(rawurl);\n     let mut end = len;\n     for str::each_chari(rawurl) |i,c| {\n@@ -587,39 +577,39 @@ pure fn get_path(rawurl: &str, authority : bool) ->\n             end = i;\n             break;\n           }\n-          _ => return result::Err(@~\"Invalid character in path.\")\n+          _ => return Err(~\"Invalid character in path.\")\n         }\n     }\n \n     if authority {\n         if end != 0 && !str::starts_with(rawurl, ~\"/\") {\n-            return result::Err(@~\"Non-empty path must begin with\\\n+            return Err(~\"Non-empty path must begin with\\\n                                '/' in presence of authority.\");\n         }\n     }\n \n-    return result::Ok((decode_component(str::slice(rawurl, 0, end)),\n+    return Ok((decode_component(str::slice(rawurl, 0, end)),\n                     str::slice(rawurl, end, len)));\n }\n \n // returns the parsed query and the fragment, if present\n pure fn get_query_fragment(rawurl: &str) ->\n-    result::Result<(Query, Option<~str>), @~str> {\n+    Result<(Query, Option<~str>), ~str> {\n     if !str::starts_with(rawurl, ~\"?\") {\n         if str::starts_with(rawurl, ~\"#\") {\n             let f = decode_component(str::slice(rawurl,\n                                                 1,\n                                                 str::len(rawurl)));\n-            return result::Ok((~[], option::Some(f)));\n+            return Ok((~[], Some(f)));\n         } else {\n-            return result::Ok((~[], option::None));\n+            return Ok((~[], None));\n         }\n     }\n     let (q, r) = split_char_first(str::slice(rawurl, 1,\n                                              str::len(rawurl)), '#');\n     let f = if str::len(r) != 0 {\n-        option::Some(decode_component(r)) } else { option::None };\n-    return result::Ok((query_from_str(q), f));\n+        Some(decode_component(r)) } else { None };\n+    return Ok((query_from_str(q), f));\n }\n \n /**\n@@ -635,41 +625,36 @@ pure fn get_query_fragment(rawurl: &str) ->\n  *\n  */\n \n-pub pure fn from_str(rawurl: &str) -> result::Result<Url, ~str> {\n+pub pure fn from_str(rawurl: &str) -> Result<Url, ~str> {\n     // scheme\n-    let mut schm = get_scheme(rawurl);\n-    if result::is_err(&schm) {\n-        return result::Err(copy *result::get_err(&schm));\n-    }\n-    let (scheme, rest) = schm.get();\n+    let (scheme, rest) = match get_scheme(rawurl) {\n+        Ok(val) => val,\n+        Err(e) => return Err(e),\n+    };\n \n     // authority\n-    let mut auth = get_authority(rest);\n-    if result::is_err(&auth) {\n-        return result::Err(copy *result::get_err(&auth));\n-    }\n-    let (userinfo, host, port, rest) = auth.get();\n+    let (userinfo, host, port, rest) = match get_authority(rest) {\n+        Ok(val) => val,\n+        Err(e) => return Err(e),\n+    };\n \n     // path\n     let has_authority = if host == ~\"\" { false } else { true };\n-    let mut pth = get_path(rest, has_authority);\n-    if result::is_err(&pth) {\n-        return result::Err(copy *result::get_err(&pth));\n-    }\n-    let (path, rest) = pth.get();\n+    let (path, rest) = match get_path(rest, has_authority) {\n+        Ok(val) => val,\n+        Err(e) => return Err(e),\n+    };\n \n     // query and fragment\n-    let mut qry = get_query_fragment(rest);\n-    if result::is_err(&qry) {\n-        return result::Err(copy *result::get_err(&qry));\n-    }\n-    let (query, fragment) = qry.get();\n+    let (query, fragment) = match get_query_fragment(rest) {\n+        Ok(val) => val,\n+        Err(e) => return Err(e),\n+    };\n \n-    return result::Ok(Url(scheme, userinfo, host,\n-                       port, path, query, fragment));\n+    Ok(Url::new(scheme, userinfo, host, port, path, query, fragment))\n }\n \n-impl Url : FromStr {\n+impl Url: from_str::FromStr {\n     static pure fn from_str(s: &str) -> Option<Url> {\n         match from_str(s) {\n             Ok(move url) => Some(url),\n@@ -693,63 +678,41 @@ impl Url : FromStr {\n  * result in just \"http://somehost.com\".\n  *\n  */\n-pub pure fn to_str(url: Url) -> ~str {\n-    let user = if url.user.is_some() {\n-      userinfo_to_str(option::unwrap(copy url.user))\n-    } else {\n-       ~\"\"\n+pub pure fn to_str(url: &Url) -> ~str {\n+    let user = match url.user {\n+        Some(ref user) => userinfo_to_str(user),\n+        None => ~\"\",\n     };\n-    let authority = if str::len(url.host) != 0 {\n-        str::concat(~[~\"//\", user, copy url.host])\n-    } else {\n+\n+    let authority = if url.host.is_empty() {\n         ~\"\"\n+    } else {\n+        fmt!(\"//%s%s\", user, url.host)\n     };\n-    let query = if url.query.len() == 0 {\n+\n+    let query = if url.query.is_empty() {\n         ~\"\"\n     } else {\n-        str::concat(~[~\"?\", query_to_str(url.query)])\n+        fmt!(\"?%s\", query_to_str(&url.query))\n     };\n-    // ugh, this really is safe\n-    let fragment = if url.fragment.is_some() unsafe {\n-        str::concat(~[~\"#\", encode_component(\n-            option::unwrap(copy url.fragment))])\n-    } else {\n-        ~\"\"\n+\n+    let fragment = match url.fragment {\n+        Some(ref fragment) => fmt!(\"#%s\", encode_component(*fragment)),\n+        None => ~\"\",\n     };\n \n-    return str::concat(~[copy url.scheme,\n-                      ~\":\",\n-                      authority,\n-                      copy url.path,\n-                      query,\n-                      fragment]);\n+    fmt!(\"%s:%s%s%s%s\", url.scheme, authority, url.path, query, fragment)\n }\n \n impl Url: to_str::ToStr {\n     pub pure fn to_str() -> ~str {\n-        to_str(self)\n+        to_str(&self)\n     }\n }\n \n-impl Url : Eq {\n-    pure fn eq(&self, other: &Url) -> bool {\n-        (*self).scheme == (*other).scheme\n-            && (*self).user == (*other).user\n-            && (*self).host == (*other).host\n-            && (*self).port == (*other).port\n-            && (*self).path == (*other).path\n-            && (*self).query == (*other).query\n-            && (*self).fragment == (*other).fragment\n-    }\n-\n-    pure fn ne(&self, other: &Url) -> bool {\n-        !(*self).eq(other)\n-    }\n-}\n-\n-impl Url: IterBytes {\n+impl Url: to_bytes::IterBytes {\n     pure fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        unsafe { self.to_str() }.iter_bytes(lsb0, f)\n+        self.to_str().iter_bytes(lsb0, f)\n     }\n }\n \n@@ -769,203 +732,191 @@ mod tests {\n \n     #[test]\n     fn test_get_authority() {\n-        let (u, h, p, r) = result::unwrap(get_authority(\n-            ~\"//user:pass@rust-lang.org/something\"));\n-        assert u == option::Some({user: ~\"user\",\n-                                  pass: option::Some(~\"pass\")});\n+        let (u, h, p, r) = get_authority(\n+            \"//user:pass@rust-lang.org/something\").unwrap();\n+        assert u == Some(UserInfo::new(~\"user\", Some(~\"pass\")));\n         assert h == ~\"rust-lang.org\";\n         assert p.is_none();\n         assert r == ~\"/something\";\n \n-        let (u, h, p, r) = result::unwrap(get_authority(\n-            ~\"//rust-lang.org:8000?something\"));\n+        let (u, h, p, r) = get_authority(\n+            \"//rust-lang.org:8000?something\").unwrap();\n         assert u.is_none();\n         assert h == ~\"rust-lang.org\";\n-        assert p == option::Some(~\"8000\");\n+        assert p == Some(~\"8000\");\n         assert r == ~\"?something\";\n \n-        let (u, h, p, r) = result::unwrap(get_authority(\n-            ~\"//rust-lang.org#blah\"));\n+        let (u, h, p, r) = get_authority(\n+            \"//rust-lang.org#blah\").unwrap();\n         assert u.is_none();\n         assert h == ~\"rust-lang.org\";\n         assert p.is_none();\n         assert r == ~\"#blah\";\n \n         // ipv6 tests\n-        let (_, h, _, _) = result::unwrap(get_authority(\n-            ~\"//2001:0db8:85a3:0042:0000:8a2e:0370:7334#blah\"));\n+        let (_, h, _, _) = get_authority(\n+            \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334#blah\").unwrap();\n         assert h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\";\n \n-        let (_, h, p, _) = result::unwrap(get_authority(\n-            ~\"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"));\n+        let (_, h, p, _) = get_authority(\n+            \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\").unwrap();\n         assert h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\";\n-        assert p == option::Some(~\"8000\");\n+        assert p == Some(~\"8000\");\n \n-        let (u, h, p, _) = result::unwrap(get_authority(\n-            ~\"//us:p@2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"));\n-        assert u == option::Some({user: ~\"us\", pass : option::Some(~\"p\")});\n+        let (u, h, p, _) = get_authority(\n+            \"//us:p@2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"\n+        ).unwrap();\n+        assert u == Some(UserInfo::new(~\"us\", Some(~\"p\")));\n         assert h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\";\n-        assert p == option::Some(~\"8000\");\n+        assert p == Some(~\"8000\");\n \n         // invalid authorities;\n-        assert result::is_err(&get_authority(\n-            ~\"//user:pass@rust-lang:something\"));\n-        assert result::is_err(&get_authority(\n-            ~\"//user@rust-lang:something:/path\"));\n-        assert result::is_err(&get_authority(\n-            ~\"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:800a\"));\n-        assert result::is_err(&get_authority(\n-            ~\"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000:00\"));\n+        assert get_authority(\"//user:pass@rust-lang:something\").is_err();\n+        assert get_authority(\"//user@rust-lang:something:/path\").is_err();\n+        assert get_authority(\n+            \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:800a\").is_err();\n+        assert get_authority(\n+            \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000:00\").is_err();\n \n         // these parse as empty, because they don't start with '//'\n-        let (_, h, _, _) = result::unwrap(\n-            get_authority(~\"user:pass@rust-lang\"));\n+        let (_, h, _, _) = get_authority(~\"user:pass@rust-lang\").unwrap();\n         assert h == ~\"\";\n-        let (_, h, _, _) = result::unwrap(\n-            get_authority(~\"rust-lang.org\"));\n+        let (_, h, _, _) = get_authority(~\"rust-lang.org\").unwrap();\n         assert h == ~\"\";\n-\n     }\n \n     #[test]\n     fn test_get_path() {\n-        let (p, r) = result::unwrap(get_path(\n-            ~\"/something+%20orother\", true));\n+        let (p, r) = get_path(\"/something+%20orother\", true).unwrap();\n         assert p == ~\"/something+ orother\";\n         assert r == ~\"\";\n-        let (p, r) = result::unwrap(get_path(\n-            ~\"test@email.com#fragment\", false));\n+        let (p, r) = get_path(\"test@email.com#fragment\", false).unwrap();\n         assert p == ~\"test@email.com\";\n         assert r == ~\"#fragment\";\n-        let (p, r) = result::unwrap(get_path(~\"/gen/:addr=?q=v\", false));\n+        let (p, r) = get_path(~\"/gen/:addr=?q=v\", false).unwrap();\n         assert p == ~\"/gen/:addr=\";\n         assert r == ~\"?q=v\";\n \n         //failure cases\n-        assert result::is_err(&get_path(~\"something?q\", true));\n-\n+        assert get_path(~\"something?q\", true).is_err();\n     }\n \n     #[test]\n     fn test_url_parse() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";\n \n         let up = from_str(url);\n-        let u = result::unwrap(up);\n+        let u = up.unwrap();\n         assert u.scheme == ~\"http\";\n-        assert option::unwrap(copy u.user).user == ~\"user\";\n-        assert option::unwrap(copy option::unwrap(copy u.user).pass)\n-            == ~\"pass\";\n+        let userinfo = u.user.get_ref();\n+        assert userinfo.user == ~\"user\";\n+        assert userinfo.pass.get_ref() == &~\"pass\";\n         assert u.host == ~\"rust-lang.org\";\n         assert u.path == ~\"/doc\";\n-        assert u.query.find(|kv| kv.first() == ~\"s\").get().second() == ~\"v\";\n-        assert option::unwrap(copy u.fragment) == ~\"something\";\n+        assert u.query == ~[(~\"s\", ~\"v\")];\n+        assert u.fragment.get_ref() == &~\"something\";\n     }\n \n     #[test]\n     fn test_url_parse_host_slash() {\n         let urlstr = ~\"http://0.42.42.42/\";\n-        let url = from_str(urlstr).get();\n-        debug!(\"url: %?\", url);\n+        let url = from_str(urlstr).unwrap();\n         assert url.host == ~\"0.42.42.42\";\n         assert url.path == ~\"/\";\n     }\n \n     #[test]\n     fn test_url_with_underscores() {\n         let urlstr = ~\"http://dotcom.com/file_name.html\";\n-        let url = from_str(urlstr).get();\n-        debug!(\"url: %?\", url);\n+        let url = from_str(urlstr).unwrap();\n         assert url.path == ~\"/file_name.html\";\n     }\n \n     #[test]\n     fn test_url_with_dashes() {\n         let urlstr = ~\"http://dotcom.com/file-name.html\";\n-        let url = from_str(urlstr).get();\n-        debug!(\"url: %?\", url);\n+        let url = from_str(urlstr).unwrap();\n         assert url.path == ~\"/file-name.html\";\n     }\n \n     #[test]\n     fn test_no_scheme() {\n-        assert result::is_err(&get_scheme(~\"noschemehere.html\"));\n+        assert get_scheme(\"noschemehere.html\").is_err();\n     }\n \n     #[test]\n     fn test_invalid_scheme_errors() {\n-        assert result::is_err(&from_str(~\"99://something\"));\n-        assert result::is_err(&from_str(~\"://something\"));\n+        assert from_str(\"99://something\").is_err();\n+        assert from_str(\"://something\").is_err();\n     }\n \n     #[test]\n     fn test_full_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";\n-        assert to_str(result::unwrap(from_str(url))) == url;\n+        assert from_str(url).unwrap().to_str() == url;\n     }\n \n     #[test]\n     fn test_userless_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org/doc?s=v#something\";\n-        assert to_str(result::unwrap(from_str(url))) == url;\n+        assert from_str(url).unwrap().to_str() == url;\n     }\n \n     #[test]\n     fn test_queryless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc#something\";\n-        assert to_str(result::unwrap(from_str(url))) == url;\n+        assert from_str(url).unwrap().to_str() == url;\n     }\n \n     #[test]\n     fn test_empty_query_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?#something\";\n         let should_be = ~\"http://user:pass@rust-lang.org/doc#something\";\n-        assert to_str(result::unwrap(from_str(url))) == should_be;\n+        assert from_str(url).unwrap().to_str() == should_be;\n     }\n \n     #[test]\n     fn test_fragmentless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?q=v\";\n-        assert to_str(result::unwrap(from_str(url))) == url;\n+        assert from_str(url).unwrap().to_str() == url;\n     }\n \n     #[test]\n     fn test_minimal_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org/doc\";\n-        assert to_str(result::unwrap(from_str(url))) == url;\n+        assert from_str(url).unwrap().to_str() == url;\n     }\n \n     #[test]\n     fn test_scheme_host_only_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org\";\n-        assert to_str(result::unwrap(from_str(url))) == url;\n+        assert from_str(url).unwrap().to_str() == url;\n     }\n \n     #[test]\n     fn test_pathless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org?q=v#something\";\n-        assert to_str(result::unwrap(from_str(url))) == url;\n+        assert from_str(url).unwrap().to_str() == url;\n     }\n \n     #[test]\n     fn test_scheme_host_fragment_only_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org#something\";\n-        assert to_str(result::unwrap(from_str(url))) == url;\n+        assert from_str(url).unwrap().to_str() == url;\n     }\n \n     #[test]\n     fn test_url_component_encoding() {\n         let url = ~\"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\";\n-        let u = result::unwrap(from_str(url));\n+        let u = from_str(url).unwrap();\n         assert u.path == ~\"/doc uments\";\n-        assert u.query.find(|kv| kv.first() == ~\"ba%d \")\n-            .get().second() == ~\"#&+\";\n+        assert u.query == ~[(~\"ba%d \", ~\"#&+\")];\n     }\n \n     #[test]\n     fn test_url_without_authority() {\n         let url = ~\"mailto:test@email.com\";\n-        assert to_str(result::unwrap(from_str(url))) == url;\n+        assert from_str(url).unwrap().to_str() == url;\n     }\n \n     #[test]\n@@ -998,113 +949,114 @@ mod tests {\n \n     #[test]\n     fn test_encode_component() {\n-        assert encode_component(~\"\") == ~\"\";\n-        assert encode_component(~\"http://example.com\") ==\n+        assert encode_component(\"\") == ~\"\";\n+        assert encode_component(\"http://example.com\") ==\n             ~\"http%3A%2F%2Fexample.com\";\n-        assert encode_component(~\"foo bar% baz\") == ~\"foo%20bar%25%20baz\";\n-        assert encode_component(~\" \") == ~\"%20\";\n-        assert encode_component(~\"!\") == ~\"%21\";\n-        assert encode_component(~\"#\") == ~\"%23\";\n-        assert encode_component(~\"$\") == ~\"%24\";\n-        assert encode_component(~\"%\") == ~\"%25\";\n-        assert encode_component(~\"&\") == ~\"%26\";\n-        assert encode_component(~\"'\") == ~\"%27\";\n-        assert encode_component(~\"(\") == ~\"%28\";\n-        assert encode_component(~\")\") == ~\"%29\";\n-        assert encode_component(~\"*\") == ~\"%2A\";\n-        assert encode_component(~\"+\") == ~\"%2B\";\n-        assert encode_component(~\",\") == ~\"%2C\";\n-        assert encode_component(~\"/\") == ~\"%2F\";\n-        assert encode_component(~\":\") == ~\"%3A\";\n-        assert encode_component(~\";\") == ~\"%3B\";\n-        assert encode_component(~\"=\") == ~\"%3D\";\n-        assert encode_component(~\"?\") == ~\"%3F\";\n-        assert encode_component(~\"@\") == ~\"%40\";\n-        assert encode_component(~\"[\") == ~\"%5B\";\n-        assert encode_component(~\"]\") == ~\"%5D\";\n+        assert encode_component(\"foo bar% baz\") == ~\"foo%20bar%25%20baz\";\n+        assert encode_component(\" \") == ~\"%20\";\n+        assert encode_component(\"!\") == ~\"%21\";\n+        assert encode_component(\"#\") == ~\"%23\";\n+        assert encode_component(\"$\") == ~\"%24\";\n+        assert encode_component(\"%\") == ~\"%25\";\n+        assert encode_component(\"&\") == ~\"%26\";\n+        assert encode_component(\"'\") == ~\"%27\";\n+        assert encode_component(\"(\") == ~\"%28\";\n+        assert encode_component(\")\") == ~\"%29\";\n+        assert encode_component(\"*\") == ~\"%2A\";\n+        assert encode_component(\"+\") == ~\"%2B\";\n+        assert encode_component(\",\") == ~\"%2C\";\n+        assert encode_component(\"/\") == ~\"%2F\";\n+        assert encode_component(\":\") == ~\"%3A\";\n+        assert encode_component(\";\") == ~\"%3B\";\n+        assert encode_component(\"=\") == ~\"%3D\";\n+        assert encode_component(\"?\") == ~\"%3F\";\n+        assert encode_component(\"@\") == ~\"%40\";\n+        assert encode_component(\"[\") == ~\"%5B\";\n+        assert encode_component(\"]\") == ~\"%5D\";\n     }\n \n     #[test]\n     fn test_decode() {\n-        assert decode(~\"\") == ~\"\";\n-        assert decode(~\"abc/def 123\") == ~\"abc/def 123\";\n-        assert decode(~\"abc%2Fdef%20123\") == ~\"abc%2Fdef 123\";\n-        assert decode(~\"%20\") == ~\" \";\n-        assert decode(~\"%21\") == ~\"%21\";\n-        assert decode(~\"%22\") == ~\"%22\";\n-        assert decode(~\"%23\") == ~\"%23\";\n-        assert decode(~\"%24\") == ~\"%24\";\n-        assert decode(~\"%25\") == ~\"%\";\n-        assert decode(~\"%26\") == ~\"%26\";\n-        assert decode(~\"%27\") == ~\"'\";\n-        assert decode(~\"%28\") == ~\"%28\";\n-        assert decode(~\"%29\") == ~\"%29\";\n-        assert decode(~\"%2A\") == ~\"%2A\";\n-        assert decode(~\"%2B\") == ~\"%2B\";\n-        assert decode(~\"%2C\") == ~\"%2C\";\n-        assert decode(~\"%2F\") == ~\"%2F\";\n-        assert decode(~\"%3A\") == ~\"%3A\";\n-        assert decode(~\"%3B\") == ~\"%3B\";\n-        assert decode(~\"%3D\") == ~\"%3D\";\n-        assert decode(~\"%3F\") == ~\"%3F\";\n-        assert decode(~\"%40\") == ~\"%40\";\n-        assert decode(~\"%5B\") == ~\"%5B\";\n-        assert decode(~\"%5D\") == ~\"%5D\";\n+        assert decode(\"\") == ~\"\";\n+        assert decode(\"abc/def 123\") == ~\"abc/def 123\";\n+        assert decode(\"abc%2Fdef%20123\") == ~\"abc%2Fdef 123\";\n+        assert decode(\"%20\") == ~\" \";\n+        assert decode(\"%21\") == ~\"%21\";\n+        assert decode(\"%22\") == ~\"%22\";\n+        assert decode(\"%23\") == ~\"%23\";\n+        assert decode(\"%24\") == ~\"%24\";\n+        assert decode(\"%25\") == ~\"%\";\n+        assert decode(\"%26\") == ~\"%26\";\n+        assert decode(\"%27\") == ~\"'\";\n+        assert decode(\"%28\") == ~\"%28\";\n+        assert decode(\"%29\") == ~\"%29\";\n+        assert decode(\"%2A\") == ~\"%2A\";\n+        assert decode(\"%2B\") == ~\"%2B\";\n+        assert decode(\"%2C\") == ~\"%2C\";\n+        assert decode(\"%2F\") == ~\"%2F\";\n+        assert decode(\"%3A\") == ~\"%3A\";\n+        assert decode(\"%3B\") == ~\"%3B\";\n+        assert decode(\"%3D\") == ~\"%3D\";\n+        assert decode(\"%3F\") == ~\"%3F\";\n+        assert decode(\"%40\") == ~\"%40\";\n+        assert decode(\"%5B\") == ~\"%5B\";\n+        assert decode(\"%5D\") == ~\"%5D\";\n     }\n \n     #[test]\n     fn test_decode_component() {\n-        assert decode_component(~\"\") == ~\"\";\n-        assert decode_component(~\"abc/def 123\") == ~\"abc/def 123\";\n-        assert decode_component(~\"abc%2Fdef%20123\") == ~\"abc/def 123\";\n-        assert decode_component(~\"%20\") == ~\" \";\n-        assert decode_component(~\"%21\") == ~\"!\";\n-        assert decode_component(~\"%22\") == ~\"\\\"\";\n-        assert decode_component(~\"%23\") == ~\"#\";\n-        assert decode_component(~\"%24\") == ~\"$\";\n-        assert decode_component(~\"%25\") == ~\"%\";\n-        assert decode_component(~\"%26\") == ~\"&\";\n-        assert decode_component(~\"%27\") == ~\"'\";\n-        assert decode_component(~\"%28\") == ~\"(\";\n-        assert decode_component(~\"%29\") == ~\")\";\n-        assert decode_component(~\"%2A\") == ~\"*\";\n-        assert decode_component(~\"%2B\") == ~\"+\";\n-        assert decode_component(~\"%2C\") == ~\",\";\n-        assert decode_component(~\"%2F\") == ~\"/\";\n-        assert decode_component(~\"%3A\") == ~\":\";\n-        assert decode_component(~\"%3B\") == ~\";\";\n-        assert decode_component(~\"%3D\") == ~\"=\";\n-        assert decode_component(~\"%3F\") == ~\"?\";\n-        assert decode_component(~\"%40\") == ~\"@\";\n-        assert decode_component(~\"%5B\") == ~\"[\";\n-        assert decode_component(~\"%5D\") == ~\"]\";\n+        assert decode_component(\"\") == ~\"\";\n+        assert decode_component(\"abc/def 123\") == ~\"abc/def 123\";\n+        assert decode_component(\"abc%2Fdef%20123\") == ~\"abc/def 123\";\n+        assert decode_component(\"%20\") == ~\" \";\n+        assert decode_component(\"%21\") == ~\"!\";\n+        assert decode_component(\"%22\") == ~\"\\\"\";\n+        assert decode_component(\"%23\") == ~\"#\";\n+        assert decode_component(\"%24\") == ~\"$\";\n+        assert decode_component(\"%25\") == ~\"%\";\n+        assert decode_component(\"%26\") == ~\"&\";\n+        assert decode_component(\"%27\") == ~\"'\";\n+        assert decode_component(\"%28\") == ~\"(\";\n+        assert decode_component(\"%29\") == ~\")\";\n+        assert decode_component(\"%2A\") == ~\"*\";\n+        assert decode_component(\"%2B\") == ~\"+\";\n+        assert decode_component(\"%2C\") == ~\",\";\n+        assert decode_component(\"%2F\") == ~\"/\";\n+        assert decode_component(\"%3A\") == ~\":\";\n+        assert decode_component(\"%3B\") == ~\";\";\n+        assert decode_component(\"%3D\") == ~\"=\";\n+        assert decode_component(\"%3F\") == ~\"?\";\n+        assert decode_component(\"%40\") == ~\"@\";\n+        assert decode_component(\"%5B\") == ~\"[\";\n+        assert decode_component(\"%5D\") == ~\"]\";\n     }\n \n     #[test]\n     fn test_encode_form_urlencoded() {\n-        let m = HashMap();\n-        assert encode_form_urlencoded(m) == ~\"\";\n+        let mut m = LinearMap();\n+        assert encode_form_urlencoded(&m) == ~\"\";\n \n-        m.insert(~\"\", @DVec());\n-        m.insert(~\"foo\", @DVec());\n-        assert encode_form_urlencoded(m) == ~\"\";\n+        m.insert(~\"\", ~[]);\n+        m.insert(~\"foo\", ~[]);\n+        assert encode_form_urlencoded(&m) == ~\"\";\n \n-        let m = HashMap();\n-        m.insert(~\"foo\", @dvec::from_vec(~[@~\"bar\", @~\"123\"]));\n-        assert encode_form_urlencoded(m) == ~\"foo=bar&foo=123\";\n+        let mut m = LinearMap();\n+        m.insert(~\"foo\", ~[~\"bar\", ~\"123\"]);\n+        assert encode_form_urlencoded(&m) == ~\"foo=bar&foo=123\";\n \n-        let m = HashMap();\n-        m.insert(~\"foo bar\", @dvec::from_vec(~[@~\"abc\", @~\"12 = 34\"]));\n-        assert encode_form_urlencoded(m) == ~\"foo+bar=abc&foo+bar=12+%3D+34\";\n+        let mut m = LinearMap();\n+        m.insert(~\"foo bar\", ~[~\"abc\", ~\"12 = 34\"]);\n+        assert encode_form_urlencoded(&m) == ~\"foo+bar=abc&foo+bar=12+%3D+34\";\n     }\n \n     #[test]\n     fn test_decode_form_urlencoded() {\n-        assert decode_form_urlencoded(~[]).size() == 0;\n+        assert decode_form_urlencoded(~[]).len() == 0;\n \n-        let s = str::to_bytes(~\"a=1&foo+bar=abc&foo+bar=12+%3D+34\");\n-        assert decode_form_urlencoded(s).size() == 2;\n+        let s = str::to_bytes(\"a=1&foo+bar=abc&foo+bar=12+%3D+34\");\n+        let form = decode_form_urlencoded(s);\n+        assert form.len() == 2;\n+        assert form.get_ref(&~\"a\") == &~[~\"1\"];\n+        assert form.get_ref(&~\"foo bar\") == &~[~\"abc\", ~\"12 = 34\"];\n     }\n-\n }\n-"}]}