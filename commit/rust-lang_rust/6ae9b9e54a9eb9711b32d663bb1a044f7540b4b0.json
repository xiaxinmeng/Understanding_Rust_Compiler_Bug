{"sha": "6ae9b9e54a9eb9711b32d663bb1a044f7540b4b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZTliOWU1NGE5ZWI5NzExYjMyZDY2M2JiMWEwNDRmNzU0MGI0YjA=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-05T06:00:50Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-13T22:03:45Z"}, "message": "libcore: use unboxed closures in the fields of `MutSplits`", "tree": {"sha": "d5c35dd00d8a94203101b92a685417193d449cbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5c35dd00d8a94203101b92a685417193d449cbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ae9b9e54a9eb9711b32d663bb1a044f7540b4b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ae9b9e54a9eb9711b32d663bb1a044f7540b4b0", "html_url": "https://github.com/rust-lang/rust/commit/6ae9b9e54a9eb9711b32d663bb1a044f7540b4b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ae9b9e54a9eb9711b32d663bb1a044f7540b4b0/comments", "author": null, "committer": null, "parents": [{"sha": "43cf7b4e457ad42aa44ad06469d6587ddb67eb2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/43cf7b4e457ad42aa44ad06469d6587ddb67eb2e", "html_url": "https://github.com/rust-lang/rust/commit/43cf7b4e457ad42aa44ad06469d6587ddb67eb2e"}], "stats": {"total": 31, "additions": 20, "deletions": 11}, "files": [{"sha": "cfdb406f711ef87af95625584fee430811662db0", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6ae9b9e54a9eb9711b32d663bb1a044f7540b4b0/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae9b9e54a9eb9711b32d663bb1a044f7540b4b0/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=6ae9b9e54a9eb9711b32d663bb1a044f7540b4b0", "patch": "@@ -319,20 +319,23 @@ pub trait SlicePrelude<T> for Sized? {\n     /// Returns an iterator over mutable subslices separated by elements that\n     /// match `pred`.  The matched element is not contained in the subslices.\n     #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn split_mut<'a>(&'a mut self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T>;\n+    fn split_mut<'a, P>(&'a mut self, pred: P) -> MutSplits<'a, T, P> where\n+        P: FnMut(&T) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n     #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn splitn_mut<'a>(&'a mut self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>>;\n+    fn splitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> SplitsN<MutSplits<'a, T, P>> where\n+        P: FnMut(&T) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n     #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn rsplitn_mut<'a>(&'a mut self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>>;\n+    fn rsplitn_mut<'a, P>(&'a mut self,  n: uint, pred: P) -> SplitsN<MutSplits<'a, T, P>> where\n+        P: FnMut(&T) -> bool;\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n     /// The chunks are mutable and do not overlap. If `chunk_size` does\n@@ -644,12 +647,14 @@ impl<T> SlicePrelude<T> for [T] {\n     }\n \n     #[inline]\n-    fn split_mut<'a>(&'a mut self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T> {\n+    fn split_mut<'a, P>(&'a mut self, pred: P) -> MutSplits<'a, T, P> where P: FnMut(&T) -> bool {\n         MutSplits { v: self, pred: pred, finished: false }\n     }\n \n     #[inline]\n-    fn splitn_mut<'a>(&'a mut self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>> {\n+    fn splitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> SplitsN<MutSplits<'a, T, P>> where\n+        P: FnMut(&T) -> bool\n+    {\n         SplitsN {\n             iter: self.split_mut(pred),\n             count: n,\n@@ -658,7 +663,9 @@ impl<T> SlicePrelude<T> for [T] {\n     }\n \n     #[inline]\n-    fn rsplitn_mut<'a>(&'a mut self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>> {\n+    fn rsplitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> SplitsN<MutSplits<'a, T, P>> where\n+        P: FnMut(&T) -> bool,\n+    {\n         SplitsN {\n             iter: self.split_mut(pred),\n             count: n,\n@@ -1337,13 +1344,13 @@ impl<'a, T, P> SplitsIter<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bo\n /// An iterator over the subslices of the vector which are separated\n /// by elements that match `pred`.\n #[experimental = \"needs review\"]\n-pub struct MutSplits<'a, T:'a> {\n+pub struct MutSplits<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     v: &'a mut [T],\n-    pred: |t: &T|: 'a -> bool,\n+    pred: P,\n     finished: bool\n }\n \n-impl<'a, T> SplitsIter<&'a mut [T]> for MutSplits<'a, T> {\n+impl<'a, T, P> SplitsIter<&'a mut [T]> for MutSplits<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn finish(&mut self) -> Option<&'a mut [T]> {\n         if self.finished {\n@@ -1356,7 +1363,7 @@ impl<'a, T> SplitsIter<&'a mut [T]> for MutSplits<'a, T> {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n+impl<'a, T, P> Iterator<&'a mut [T]> for MutSplits<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n         if self.finished { return None; }\n@@ -1389,7 +1396,9 @@ impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n+impl<'a, T, P> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T, P> where\n+    P: FnMut(&T) -> bool,\n+{\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n         if self.finished { return None; }"}]}