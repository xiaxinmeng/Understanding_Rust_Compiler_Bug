{"sha": "ec518a0069e41e8dee1da672de2de9fec7c0f9d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNTE4YTAwNjllNDFlOGRlZTFkYTY3MmRlMmRlOWZlYzdjMGY5ZDA=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-12T19:26:01Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:02:48Z"}, "message": "Remove EarlyExitLabel, it only has one variant and is as such useless", "tree": {"sha": "673f79096845b9365e3b6353f3b4a83ace30c4b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/673f79096845b9365e3b6353f3b4a83ace30c4b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec518a0069e41e8dee1da672de2de9fec7c0f9d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec518a0069e41e8dee1da672de2de9fec7c0f9d0", "html_url": "https://github.com/rust-lang/rust/commit/ec518a0069e41e8dee1da672de2de9fec7c0f9d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec518a0069e41e8dee1da672de2de9fec7c0f9d0/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a36f88feb972d02a9f656f898e114c287fa60a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a36f88feb972d02a9f656f898e114c287fa60a1", "html_url": "https://github.com/rust-lang/rust/commit/5a36f88feb972d02a9f656f898e114c287fa60a1"}], "stats": {"total": 41, "additions": 15, "deletions": 26}, "files": [{"sha": "b349580b37801d4174893bc61c1a0cbb7e0a880b", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ec518a0069e41e8dee1da672de2de9fec7c0f9d0/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec518a0069e41e8dee1da672de2de9fec7c0f9d0/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=ec518a0069e41e8dee1da672de2de9fec7c0f9d0", "patch": "@@ -114,8 +114,6 @@\n //! code for `expr` itself is responsible for freeing any other byproducts\n //! that may be in play.\n \n-use self::EarlyExitLabel::*;\n-\n use llvm::{BasicBlockRef, ValueRef};\n use base::{self, Lifetime};\n use common;\n@@ -138,11 +136,6 @@ pub struct CustomScopeIndex {\n     index: usize\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n-enum EarlyExitLabel {\n-    UnwindExit(UnwindKind),\n-}\n-\n #[derive(Copy, Clone, Debug)]\n enum UnwindKind {\n     LandingPad,\n@@ -151,7 +144,7 @@ enum UnwindKind {\n \n #[derive(Copy, Clone)]\n struct CachedEarlyExit {\n-    label: EarlyExitLabel,\n+    label: UnwindKind,\n     cleanup_block: BasicBlockRef,\n     last_cleanup: usize,\n }\n@@ -325,9 +318,8 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             };\n \n             // Generate the cleanup block and branch to it.\n-            let label = UnwindExit(val);\n-            let cleanup_llbb = self.trans_cleanups_to_exit_scope(label);\n-            label.branch(&pad_bcx, cleanup_llbb);\n+            let cleanup_llbb = self.trans_cleanups_to_exit_scope(val);\n+            val.branch(&pad_bcx, cleanup_llbb);\n             pad_bcx.llbb()\n         };\n \n@@ -392,7 +384,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     /// breaks. The return value would be the first basic block in that sequence\n     /// (`Cleanup(AST 24)`). The caller could then branch to `Cleanup(AST 24)`\n     /// and it will perform all cleanups and finally branch to the `break_blk`.\n-    fn trans_cleanups_to_exit_scope(&'blk self, label: EarlyExitLabel) -> BasicBlockRef {\n+    fn trans_cleanups_to_exit_scope(&'blk self, label: UnwindKind) -> BasicBlockRef {\n         debug!(\"trans_cleanups_to_exit_scope label={:?} scopes={}\", label, self.scopes_len());\n \n         let orig_scopes_len = self.scopes_len();\n@@ -410,13 +402,10 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n         // (Presuming that there are no cached exits)\n         loop {\n             if self.scopes_len() == 0 {\n-                let val = match label {\n-                    UnwindExit(val) => val,\n-                };\n                 // Generate a block that will resume unwinding to the\n                 // calling function\n                 let bcx = self.build_new_block(\"resume\");\n-                match val {\n+                match label {\n                     UnwindKind::LandingPad => {\n                         let addr = self.landingpad_alloca.get().unwrap();\n                         let lp = bcx.load(addr);\n@@ -519,15 +508,15 @@ impl<'tcx> CleanupScope<'tcx> {\n     }\n \n     fn cached_early_exit(&self,\n-                         label: EarlyExitLabel)\n+                         label: UnwindKind)\n                          -> Option<(BasicBlockRef, usize)> {\n         self.cached_early_exits.iter().rev().\n             find(|e| e.label == label).\n             map(|e| (e.cleanup_block, e.last_cleanup))\n     }\n \n     fn add_cached_early_exit(&mut self,\n-                             label: EarlyExitLabel,\n+                             label: UnwindKind,\n                              blk: BasicBlockRef,\n                              last_cleanup: usize) {\n         self.cached_early_exits.push(\n@@ -548,15 +537,15 @@ impl<'tcx> CleanupScope<'tcx> {\n     }\n }\n \n-impl EarlyExitLabel {\n+impl UnwindKind {\n     /// Generates a branch going from `from_bcx` to `to_llbb` where `self` is\n     /// the exit label attached to the start of `from_bcx`.\n     ///\n     /// Transitions from an exit label to other exit labels depend on the type\n     /// of label. For example with MSVC exceptions unwind exit labels will use\n     /// the `cleanupret` instruction instead of the `br` instruction.\n     fn branch(&self, from_bcx: &BlockAndBuilder, to_llbb: BasicBlockRef) {\n-        if let UnwindExit(UnwindKind::CleanupPad(pad)) = *self {\n+        if let UnwindKind::CleanupPad(pad) = *self {\n             from_bcx.cleanup_ret(pad, Some(to_llbb));\n         } else {\n             from_bcx.br(to_llbb);\n@@ -574,14 +563,14 @@ impl EarlyExitLabel {\n     ///\n     /// Returns a new label which will can be used to cache `bcx` in the list of\n     /// early exits.\n-    fn start(&self, bcx: &BlockAndBuilder) -> EarlyExitLabel {\n+    fn start(&self, bcx: &BlockAndBuilder) -> UnwindKind {\n         match *self {\n-            UnwindExit(UnwindKind::CleanupPad(..)) => {\n+            UnwindKind::CleanupPad(..) => {\n                 let pad = bcx.cleanup_pad(None, &[]);\n                 bcx.set_funclet(Funclet::msvc(pad));\n-                UnwindExit(UnwindKind::CleanupPad(pad))\n+                UnwindKind::CleanupPad(pad)\n             }\n-            UnwindExit(UnwindKind::LandingPad) => {\n+            UnwindKind::LandingPad => {\n                 bcx.set_funclet(Funclet::gnu());\n                 *self\n             }\n@@ -590,8 +579,8 @@ impl EarlyExitLabel {\n }\n \n impl PartialEq for UnwindKind {\n-    fn eq(&self, val: &UnwindKind) -> bool {\n-        match (*self, *val) {\n+    fn eq(&self, label: &UnwindKind) -> bool {\n+        match (*self, *label) {\n             (UnwindKind::LandingPad, UnwindKind::LandingPad) |\n             (UnwindKind::CleanupPad(..), UnwindKind::CleanupPad(..)) => true,\n             _ => false,"}]}