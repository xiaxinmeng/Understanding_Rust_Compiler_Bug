{"sha": "1eb6adf47579e3c56b38ba6cce7676e8d2d5beb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlYjZhZGY0NzU3OWUzYzU2YjM4YmE2Y2NlNzY3NmU4ZDJkNWJlYjA=", "commit": {"author": {"name": "Eduardo Broto", "email": "ebroto@tutanota.com", "date": "2020-05-18T19:03:37Z"}, "committer": {"name": "Eduardo Broto", "email": "ebroto@tutanota.com", "date": "2020-05-21T12:11:11Z"}, "message": "Adapt `cargo dev new_lint` to create tests for cargo lints", "tree": {"sha": "102fc1aeec76bc72bc75c3c10ff4e9569f0a0cbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/102fc1aeec76bc72bc75c3c10ff4e9569f0a0cbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1eb6adf47579e3c56b38ba6cce7676e8d2d5beb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1eb6adf47579e3c56b38ba6cce7676e8d2d5beb0", "html_url": "https://github.com/rust-lang/rust/commit/1eb6adf47579e3c56b38ba6cce7676e8d2d5beb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1eb6adf47579e3c56b38ba6cce7676e8d2d5beb0/comments", "author": {"login": "ebroto", "id": 816908, "node_id": "MDQ6VXNlcjgxNjkwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/816908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebroto", "html_url": "https://github.com/ebroto", "followers_url": "https://api.github.com/users/ebroto/followers", "following_url": "https://api.github.com/users/ebroto/following{/other_user}", "gists_url": "https://api.github.com/users/ebroto/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebroto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebroto/subscriptions", "organizations_url": "https://api.github.com/users/ebroto/orgs", "repos_url": "https://api.github.com/users/ebroto/repos", "events_url": "https://api.github.com/users/ebroto/events{/privacy}", "received_events_url": "https://api.github.com/users/ebroto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ebroto", "id": 816908, "node_id": "MDQ6VXNlcjgxNjkwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/816908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebroto", "html_url": "https://github.com/ebroto", "followers_url": "https://api.github.com/users/ebroto/followers", "following_url": "https://api.github.com/users/ebroto/following{/other_user}", "gists_url": "https://api.github.com/users/ebroto/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebroto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebroto/subscriptions", "organizations_url": "https://api.github.com/users/ebroto/orgs", "repos_url": "https://api.github.com/users/ebroto/repos", "events_url": "https://api.github.com/users/ebroto/events{/privacy}", "received_events_url": "https://api.github.com/users/ebroto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a0eccbd8a719af00b027b0ea85c576d9cbed750", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a0eccbd8a719af00b027b0ea85c576d9cbed750", "html_url": "https://github.com/rust-lang/rust/commit/7a0eccbd8a719af00b027b0ea85c576d9cbed750"}], "stats": {"total": 178, "additions": 105, "deletions": 73}, "files": [{"sha": "843beaf32387764ae9d5cab17b7e5cdf3fc640c6", "filename": "clippy_dev/src/new_lint.rs", "status": "modified", "additions": 105, "deletions": 73, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/1eb6adf47579e3c56b38ba6cce7676e8d2d5beb0/clippy_dev%2Fsrc%2Fnew_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eb6adf47579e3c56b38ba6cce7676e8d2d5beb0/clippy_dev%2Fsrc%2Fnew_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fnew_lint.rs?ref=1eb6adf47579e3c56b38ba6cce7676e8d2d5beb0", "patch": "@@ -1,91 +1,110 @@\n use crate::clippy_project_root;\n-use std::fs::{File, OpenOptions};\n-use std::io;\n+use std::fs::{self, OpenOptions};\n use std::io::prelude::*;\n-use std::io::ErrorKind;\n-use std::path::Path;\n+use std::io::{self, ErrorKind};\n+use std::path::{Path, PathBuf};\n+\n+struct LintData<'a> {\n+    pass: &'a str,\n+    name: &'a str,\n+    category: &'a str,\n+    project_root: PathBuf,\n+}\n+\n+trait Context {\n+    fn context<C: AsRef<str>>(self, text: C) -> Self;\n+}\n \n-/// Creates files required to implement and test a new lint and runs `update_lints`.\n+impl<T> Context for io::Result<T> {\n+    fn context<C: AsRef<str>>(self, text: C) -> Self {\n+        match self {\n+            Err(e) => {\n+                let message = format!(\"{}: {}\", text.as_ref(), e);\n+                Err(io::Error::new(ErrorKind::Other, message))\n+            },\n+            ok => ok,\n+        }\n+    }\n+}\n+\n+/// Creates the files required to implement and test a new lint and runs `update_lints`.\n ///\n /// # Errors\n ///\n-/// This function errors, if the files couldn't be created\n-pub fn create(pass: Option<&str>, lint_name: Option<&str>, category: Option<&str>) -> Result<(), io::Error> {\n-    let pass = pass.expect(\"`pass` argument is validated by clap\");\n-    let lint_name = lint_name.expect(\"`name` argument is validated by clap\");\n-    let category = category.expect(\"`category` argument is validated by clap\");\n-\n-    match open_files(lint_name) {\n-        Ok((mut test_file, mut lint_file)) => {\n-            let (pass_type, pass_lifetimes, pass_import, context_import) = match pass {\n-                \"early\" => (\"EarlyLintPass\", \"\", \"use rustc_ast::ast::*;\", \"EarlyContext\"),\n-                \"late\" => (\"LateLintPass\", \"<'_, '_>\", \"use rustc_hir::*;\", \"LateContext\"),\n-                _ => {\n-                    unreachable!(\"`pass_type` should only ever be `early` or `late`!\");\n-                },\n-            };\n-\n-            let camel_case_name = to_camel_case(lint_name);\n-\n-            if let Err(e) = test_file.write_all(get_test_file_contents(lint_name).as_bytes()) {\n-                return Err(io::Error::new(\n-                    ErrorKind::Other,\n-                    format!(\"Could not write to test file: {}\", e),\n-                ));\n-            };\n-\n-            if let Err(e) = lint_file.write_all(\n-                get_lint_file_contents(\n-                    pass_type,\n-                    pass_lifetimes,\n-                    lint_name,\n-                    &camel_case_name,\n-                    category,\n-                    pass_import,\n-                    context_import,\n-                )\n-                .as_bytes(),\n-            ) {\n-                return Err(io::Error::new(\n-                    ErrorKind::Other,\n-                    format!(\"Could not write to lint file: {}\", e),\n-                ));\n-            }\n-            Ok(())\n+/// This function errors out if the files couldn't be created or written to.\n+pub fn create(pass: Option<&str>, lint_name: Option<&str>, category: Option<&str>) -> io::Result<()> {\n+    let lint = LintData {\n+        pass: pass.expect(\"`pass` argument is validated by clap\"),\n+        name: lint_name.expect(\"`name` argument is validated by clap\"),\n+        category: category.expect(\"`category` argument is validated by clap\"),\n+        project_root: clippy_project_root(),\n+    };\n+\n+    create_lint(&lint).context(\"Unable to create lint implementation\")?;\n+    create_test(&lint).context(\"Unable to create a test for the new lint\")\n+}\n+\n+fn create_lint(lint: &LintData) -> io::Result<()> {\n+    let (pass_type, pass_lifetimes, pass_import, context_import) = match lint.pass {\n+        \"early\" => (\"EarlyLintPass\", \"\", \"use rustc_ast::ast::*;\", \"EarlyContext\"),\n+        \"late\" => (\"LateLintPass\", \"<'_, '_>\", \"use rustc_hir::*;\", \"LateContext\"),\n+        _ => {\n+            unreachable!(\"`pass_type` should only ever be `early` or `late`!\");\n         },\n-        Err(e) => Err(io::Error::new(\n-            ErrorKind::Other,\n-            format!(\"Unable to create lint: {}\", e),\n-        )),\n-    }\n+    };\n+\n+    let camel_case_name = to_camel_case(lint.name);\n+    let lint_contents = get_lint_file_contents(\n+        pass_type,\n+        pass_lifetimes,\n+        lint.name,\n+        &camel_case_name,\n+        lint.category,\n+        pass_import,\n+        context_import,\n+    );\n+\n+    let lint_path = format!(\"clippy_lints/src/{}.rs\", lint.name);\n+    write_file(lint.project_root.join(&lint_path), lint_contents.as_bytes())\n }\n \n-fn open_files(lint_name: &str) -> Result<(File, File), io::Error> {\n-    let project_root = clippy_project_root();\n+fn create_test(lint: &LintData) -> io::Result<()> {\n+    fn create_project_layout<P: Into<PathBuf>>(lint_name: &str, location: P, case: &str, hint: &str) -> io::Result<()> {\n+        let mut path = location.into().join(case);\n+        fs::create_dir(&path)?;\n+        write_file(path.join(\"Cargo.toml\"), get_manifest_contents(lint_name, hint))?;\n \n-    let test_file_path = project_root.join(\"tests\").join(\"ui\").join(format!(\"{}.rs\", lint_name));\n-    let lint_file_path = project_root\n-        .join(\"clippy_lints\")\n-        .join(\"src\")\n-        .join(format!(\"{}.rs\", lint_name));\n+        path.push(\"src\");\n+        fs::create_dir(&path)?;\n+        write_file(path.join(\"main.rs\"), get_test_file_contents(lint_name))?;\n \n-    if Path::new(&test_file_path).exists() {\n-        return Err(io::Error::new(\n-            ErrorKind::AlreadyExists,\n-            format!(\"test file {:?} already exists\", test_file_path),\n-        ));\n+        Ok(())\n     }\n-    if Path::new(&lint_file_path).exists() {\n-        return Err(io::Error::new(\n-            ErrorKind::AlreadyExists,\n-            format!(\"lint file {:?} already exists\", lint_file_path),\n-        ));\n+\n+    if lint.category == \"cargo\" {\n+        let relative_test_dir = format!(\"tests/ui-cargo/{}\", lint.name);\n+        let test_dir = lint.project_root.join(relative_test_dir);\n+        fs::create_dir(&test_dir)?;\n+\n+        create_project_layout(lint.name, &test_dir, \"fail\", \"Content that triggers the lint goes here\")?;\n+        create_project_layout(lint.name, &test_dir, \"pass\", \"This file should not trigger the lint\")\n+    } else {\n+        let test_path = format!(\"tests/ui/{}.rs\", lint.name);\n+        let test_contents = get_test_file_contents(lint.name);\n+        write_file(lint.project_root.join(test_path), test_contents)\n     }\n+}\n \n-    let test_file = OpenOptions::new().write(true).create_new(true).open(test_file_path)?;\n-    let lint_file = OpenOptions::new().write(true).create_new(true).open(lint_file_path)?;\n+fn write_file<P: AsRef<Path>, C: AsRef<[u8]>>(path: P, contents: C) -> io::Result<()> {\n+    fn inner(path: &Path, contents: &[u8]) -> io::Result<()> {\n+        OpenOptions::new()\n+            .write(true)\n+            .create_new(true)\n+            .open(path)?\n+            .write_all(contents)\n+    }\n \n-    Ok((test_file, lint_file))\n+    inner(path.as_ref(), contents.as_ref()).context(format!(\"writing to file: {}\", path.as_ref().display()))\n }\n \n fn to_camel_case(name: &str) -> String {\n@@ -112,6 +131,19 @@ fn main() {{\n     )\n }\n \n+fn get_manifest_contents(lint_name: &str, hint: &str) -> String {\n+    format!(\n+        r#\"\n+# {}\n+\n+[package]\n+name = \"{}\"\n+version = \"0.1.0\"\n+\"#,\n+        hint, lint_name\n+    )\n+}\n+\n fn get_lint_file_contents(\n     pass_type: &str,\n     pass_lifetimes: &str,"}]}