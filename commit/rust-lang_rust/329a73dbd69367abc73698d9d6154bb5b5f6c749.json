{"sha": "329a73dbd69367abc73698d9d6154bb5b5f6c749", "node_id": "C_kwDOAAsO6NoAKDMyOWE3M2RiZDY5MzY3YWJjNzM2OThkOWQ2MTU0YmI1YjVmNmM3NDk", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-05-03T05:58:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-03T05:58:57Z"}, "message": "Rollup merge of #96587 - bjorn3:refactor_backend_write, r=michaelwoerister\n\nRefactor the WriteBackendMethods and ExtraBackendMethods traits\n\nThe new interface is slightly less confusing and is easier to implement for non-LLVM backends.", "tree": {"sha": "b2e5d4eb20aa361068d84b60ca2a3c754ae3c7e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2e5d4eb20aa361068d84b60ca2a3c754ae3c7e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/329a73dbd69367abc73698d9d6154bb5b5f6c749", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJicMShCRBK7hj4Ov3rIwAAsEkIAI4YmenrNT3GRMjqBtrnVB+G\nhSFssKww/LYmF91kkznK/EzC+HE8TCRi42lZUSZEfVXNsWad8EETq+/hjJ4mAYP0\njM1x1cgBUSuXxPMQWvC0QQK+aiRTqA/zmUdzfDstHLWyvm4Hxk3NBWWjJhF6DaC7\nLV1kxROKfHT2sBdlJY6Fo3iB3/nQiRgpuH7b+Y1cJSQ1kI4e+NJ6QAoLFhpoQBuE\nYD0YRXSvroFepVSpjdawNQ8vv6wtINbtlx8D5wlny6oWc+c/YGcdQFj4i5Hlomjo\nG+unhpvI28pUuI0d2e4iJCDtTyKvQa0VJZzXRnOf9qyaNvBnZawWfCNyN8J4iPs=\n=Ejqf\n-----END PGP SIGNATURE-----\n", "payload": "tree b2e5d4eb20aa361068d84b60ca2a3c754ae3c7e6\nparent 27d7615bb4f20cd3546bf98d7ad2f812d5dc4e3c\nparent 78c65a52db0016f489862ecea92a09ad66a2b960\nauthor Yuki Okushi <jtitor@2k36.org> 1651557537 +0900\ncommitter GitHub <noreply@github.com> 1651557537 +0900\n\nRollup merge of #96587 - bjorn3:refactor_backend_write, r=michaelwoerister\n\nRefactor the WriteBackendMethods and ExtraBackendMethods traits\n\nThe new interface is slightly less confusing and is easier to implement for non-LLVM backends.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/329a73dbd69367abc73698d9d6154bb5b5f6c749", "html_url": "https://github.com/rust-lang/rust/commit/329a73dbd69367abc73698d9d6154bb5b5f6c749", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/329a73dbd69367abc73698d9d6154bb5b5f6c749/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27d7615bb4f20cd3546bf98d7ad2f812d5dc4e3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/27d7615bb4f20cd3546bf98d7ad2f812d5dc4e3c", "html_url": "https://github.com/rust-lang/rust/commit/27d7615bb4f20cd3546bf98d7ad2f812d5dc4e3c"}, {"sha": "78c65a52db0016f489862ecea92a09ad66a2b960", "url": "https://api.github.com/repos/rust-lang/rust/commits/78c65a52db0016f489862ecea92a09ad66a2b960", "html_url": "https://github.com/rust-lang/rust/commit/78c65a52db0016f489862ecea92a09ad66a2b960"}], "stats": {"total": 119, "additions": 48, "deletions": 71}, "files": [{"sha": "58996a9db78ad4e0dfbd315ea85af833e7137413", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/329a73dbd69367abc73698d9d6154bb5b5f6c749/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329a73dbd69367abc73698d9d6154bb5b5f6c749/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=329a73dbd69367abc73698d9d6154bb5b5f6c749", "patch": "@@ -139,14 +139,12 @@ impl CodegenBackend for GccCodegenBackend {\n }\n \n impl ExtraBackendMethods for GccCodegenBackend {\n-    fn new_metadata<'tcx>(&self, _tcx: TyCtxt<'tcx>, _mod_name: &str) -> Self::Module {\n-        GccContext {\n+    fn codegen_allocator<'tcx>(&self, tcx: TyCtxt<'tcx>, module_name: &str, kind: AllocatorKind, has_alloc_error_handler: bool) -> Self::Module {\n+        let mut mods = GccContext {\n             context: Context::default(),\n-        }\n-    }\n-\n-    fn codegen_allocator<'tcx>(&self, tcx: TyCtxt<'tcx>, mods: &mut Self::Module, module_name: &str, kind: AllocatorKind, has_alloc_error_handler: bool) {\n-        unsafe { allocator::codegen(tcx, mods, module_name, kind, has_alloc_error_handler) }\n+        };\n+        unsafe { allocator::codegen(tcx, &mut mods, module_name, kind, has_alloc_error_handler); }\n+        mods\n     }\n \n     fn compile_codegen_unit<'tcx>(&self, tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (ModuleCodegen<Self::Module>, u64) {\n@@ -213,7 +211,7 @@ impl WriteBackendMethods for GccCodegenBackend {\n                     unimplemented!();\n                 }\n             };\n-        Ok(LtoModuleCodegen::Fat { module: Some(module), _serialized_bitcode: vec![] })\n+        Ok(LtoModuleCodegen::Fat { module, _serialized_bitcode: vec![] })\n     }\n \n     fn run_thin_lto(_cgcx: &CodegenContext<Self>, _modules: Vec<(String, Self::ThinBuffer)>, _cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>) -> Result<(Vec<LtoModuleCodegen<Self>>, Vec<WorkProduct>), FatalError> {\n@@ -229,7 +227,12 @@ impl WriteBackendMethods for GccCodegenBackend {\n         Ok(())\n     }\n \n-    unsafe fn optimize_thin(_cgcx: &CodegenContext<Self>, _thin: &mut ThinModule<Self>) -> Result<ModuleCodegen<Self::Module>, FatalError> {\n+    fn optimize_fat(_cgcx: &CodegenContext<Self>, _module: &mut ModuleCodegen<Self::Module>) -> Result<(), FatalError> {\n+        // TODO(antoyo)\n+        Ok(())\n+    }\n+\n+    unsafe fn optimize_thin(_cgcx: &CodegenContext<Self>, _thin: ThinModule<Self>) -> Result<ModuleCodegen<Self::Module>, FatalError> {\n         unimplemented!();\n     }\n \n@@ -245,11 +248,6 @@ impl WriteBackendMethods for GccCodegenBackend {\n         unimplemented!();\n     }\n \n-    fn run_lto_pass_manager(_cgcx: &CodegenContext<Self>, _module: &ModuleCodegen<Self::Module>, _config: &ModuleConfig, _thin: bool) -> Result<(), FatalError> {\n-        // TODO(antoyo)\n-        Ok(())\n-    }\n-\n     fn run_link(cgcx: &CodegenContext<Self>, diag_handler: &Handler, modules: Vec<ModuleCodegen<Self::Module>>) -> Result<ModuleCodegen<Self::Module>, FatalError> {\n         back::write::link(cgcx, diag_handler, modules)\n     }"}, {"sha": "b5b2a27d2378da7bd7271d263739726253aa7cc4", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/329a73dbd69367abc73698d9d6154bb5b5f6c749/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329a73dbd69367abc73698d9d6154bb5b5f6c749/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=329a73dbd69367abc73698d9d6154bb5b5f6c749", "patch": "@@ -6,9 +6,7 @@ use crate::llvm::{self, build_string, False, True};\n use crate::{llvm_util, LlvmCodegenBackend, ModuleLlvm};\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule, ThinShared};\n use rustc_codegen_ssa::back::symbol_export;\n-use rustc_codegen_ssa::back::write::{\n-    CodegenContext, FatLTOInput, ModuleConfig, TargetMachineFactoryConfig,\n-};\n+use rustc_codegen_ssa::back::write::{CodegenContext, FatLTOInput, TargetMachineFactoryConfig};\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::{looks_like_rust_object_file, ModuleCodegen, ModuleKind};\n use rustc_data_structures::fx::FxHashMap;\n@@ -353,7 +351,7 @@ fn fat_lto(\n         }\n     }\n \n-    Ok(LtoModuleCodegen::Fat { module: Some(module), _serialized_bitcode: serialized_bitcode })\n+    Ok(LtoModuleCodegen::Fat { module, _serialized_bitcode: serialized_bitcode })\n }\n \n crate struct Linker<'a>(&'a mut llvm::Linker<'a>);\n@@ -578,11 +576,11 @@ fn thin_lto(\n pub(crate) fn run_pass_manager(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     diag_handler: &Handler,\n-    module: &ModuleCodegen<ModuleLlvm>,\n-    config: &ModuleConfig,\n+    module: &mut ModuleCodegen<ModuleLlvm>,\n     thin: bool,\n ) -> Result<(), FatalError> {\n     let _timer = cgcx.prof.extra_verbose_generic_activity(\"LLVM_lto_optimize\", &*module.name);\n+    let config = cgcx.config(module.kind);\n \n     // Now we have one massive module inside of llmod. Time to run the\n     // LTO-specific optimization passes that LLVM provides.\n@@ -726,7 +724,7 @@ impl Drop for ThinBuffer {\n }\n \n pub unsafe fn optimize_thin_module(\n-    thin_module: &mut ThinModule<LlvmCodegenBackend>,\n+    thin_module: ThinModule<LlvmCodegenBackend>,\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n ) -> Result<ModuleCodegen<ModuleLlvm>, FatalError> {\n     let diag_handler = cgcx.create_diag_handler();\n@@ -743,7 +741,7 @@ pub unsafe fn optimize_thin_module(\n     // that LLVM Context and Module.\n     let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n     let llmod_raw = parse_module(llcx, module_name, thin_module.data(), &diag_handler)? as *const _;\n-    let module = ModuleCodegen {\n+    let mut module = ModuleCodegen {\n         module_llvm: ModuleLlvm { llmod_raw, llcx, tm },\n         name: thin_module.name().to_string(),\n         kind: ModuleKind::Regular,\n@@ -859,8 +857,7 @@ pub unsafe fn optimize_thin_module(\n         // little differently.\n         {\n             info!(\"running thin lto passes over {}\", module.name);\n-            let config = cgcx.config(module.kind);\n-            run_pass_manager(cgcx, &diag_handler, &module, config, true)?;\n+            run_pass_manager(cgcx, &diag_handler, &mut module, true)?;\n             save_temp_bitcode(cgcx, &module, \"thin-lto-after-pm\");\n         }\n     }"}, {"sha": "b0359239569549b460d26dadca79c0e0396a65c2", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/329a73dbd69367abc73698d9d6154bb5b5f6c749/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329a73dbd69367abc73698d9d6154bb5b5f6c749/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=329a73dbd69367abc73698d9d6154bb5b5f6c749", "patch": "@@ -104,19 +104,18 @@ impl Drop for TimeTraceProfiler {\n }\n \n impl ExtraBackendMethods for LlvmCodegenBackend {\n-    fn new_metadata(&self, tcx: TyCtxt<'_>, mod_name: &str) -> ModuleLlvm {\n-        ModuleLlvm::new_metadata(tcx, mod_name)\n-    }\n-\n     fn codegen_allocator<'tcx>(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        module_llvm: &mut ModuleLlvm,\n         module_name: &str,\n         kind: AllocatorKind,\n         has_alloc_error_handler: bool,\n-    ) {\n-        unsafe { allocator::codegen(tcx, module_llvm, module_name, kind, has_alloc_error_handler) }\n+    ) -> ModuleLlvm {\n+        let mut module_llvm = ModuleLlvm::new_metadata(tcx, module_name);\n+        unsafe {\n+            allocator::codegen(tcx, &mut module_llvm, module_name, kind, has_alloc_error_handler);\n+        }\n+        module_llvm\n     }\n     fn compile_codegen_unit(\n         &self,\n@@ -210,9 +209,16 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n     ) -> Result<(), FatalError> {\n         back::write::optimize(cgcx, diag_handler, module, config)\n     }\n+    fn optimize_fat(\n+        cgcx: &CodegenContext<Self>,\n+        module: &mut ModuleCodegen<Self::Module>,\n+    ) -> Result<(), FatalError> {\n+        let diag_handler = cgcx.create_diag_handler();\n+        back::lto::run_pass_manager(cgcx, &diag_handler, module, false)\n+    }\n     unsafe fn optimize_thin(\n         cgcx: &CodegenContext<Self>,\n-        thin: &mut ThinModule<Self>,\n+        thin: ThinModule<Self>,\n     ) -> Result<ModuleCodegen<Self::Module>, FatalError> {\n         back::lto::optimize_thin_module(thin, cgcx)\n     }\n@@ -230,15 +236,6 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n     fn serialize_module(module: ModuleCodegen<Self::Module>) -> (String, Self::ModuleBuffer) {\n         (module.name, back::lto::ModuleBuffer::new(module.module_llvm.llmod()))\n     }\n-    fn run_lto_pass_manager(\n-        cgcx: &CodegenContext<Self>,\n-        module: &ModuleCodegen<Self::Module>,\n-        config: &ModuleConfig,\n-        thin: bool,\n-    ) -> Result<(), FatalError> {\n-        let diag_handler = cgcx.create_diag_handler();\n-        back::lto::run_pass_manager(cgcx, &diag_handler, module, config, thin)\n-    }\n }\n \n unsafe impl Send for LlvmCodegenBackend {} // Llvm is on a per-thread basis"}, {"sha": "cb6244050df24a61601af1f26eb80ae6d595279f", "filename": "compiler/rustc_codegen_ssa/src/back/lto.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/329a73dbd69367abc73698d9d6154bb5b5f6c749/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329a73dbd69367abc73698d9d6154bb5b5f6c749/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs?ref=329a73dbd69367abc73698d9d6154bb5b5f6c749", "patch": "@@ -42,7 +42,7 @@ pub struct ThinShared<B: WriteBackendMethods> {\n \n pub enum LtoModuleCodegen<B: WriteBackendMethods> {\n     Fat {\n-        module: Option<ModuleCodegen<B::Module>>,\n+        module: ModuleCodegen<B::Module>,\n         _serialized_bitcode: Vec<SerializedModule<B::ModuleBuffer>>,\n     },\n \n@@ -64,19 +64,15 @@ impl<B: WriteBackendMethods> LtoModuleCodegen<B> {\n     /// It's intended that the module returned is immediately code generated and\n     /// dropped, and then this LTO module is dropped.\n     pub unsafe fn optimize(\n-        &mut self,\n+        self,\n         cgcx: &CodegenContext<B>,\n     ) -> Result<ModuleCodegen<B::Module>, FatalError> {\n-        match *self {\n-            LtoModuleCodegen::Fat { ref mut module, .. } => {\n-                let module = module.take().unwrap();\n-                {\n-                    let config = cgcx.config(module.kind);\n-                    B::run_lto_pass_manager(cgcx, &module, config, false)?;\n-                }\n+        match self {\n+            LtoModuleCodegen::Fat { mut module, .. } => {\n+                B::optimize_fat(cgcx, &mut module)?;\n                 Ok(module)\n             }\n-            LtoModuleCodegen::Thin(ref mut thin) => B::optimize_thin(cgcx, thin),\n+            LtoModuleCodegen::Thin(thin) => B::optimize_thin(cgcx, thin),\n         }\n     }\n "}, {"sha": "88293dec01cac7051acb1990000a578b13ba45a6", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329a73dbd69367abc73698d9d6154bb5b5f6c749/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329a73dbd69367abc73698d9d6154bb5b5f6c749/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=329a73dbd69367abc73698d9d6154bb5b5f6c749", "patch": "@@ -889,7 +889,7 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n \n fn execute_lto_work_item<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n-    mut module: lto::LtoModuleCodegen<B>,\n+    module: lto::LtoModuleCodegen<B>,\n     module_config: &ModuleConfig,\n ) -> Result<WorkItemResult<B>, FatalError> {\n     let module = unsafe { module.optimize(cgcx)? };"}, {"sha": "5bc95614c197c32b2a4a48b3110cce816ad72e00", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/329a73dbd69367abc73698d9d6154bb5b5f6c749/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329a73dbd69367abc73698d9d6154bb5b5f6c749/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=329a73dbd69367abc73698d9d6154bb5b5f6c749", "patch": "@@ -575,15 +575,8 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     } else if let Some(kind) = tcx.allocator_kind(()) {\n         let llmod_id =\n             cgu_name_builder.build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"allocator\")).to_string();\n-        let mut module_llvm = backend.new_metadata(tcx, &llmod_id);\n-        tcx.sess.time(\"write_allocator_module\", || {\n-            backend.codegen_allocator(\n-                tcx,\n-                &mut module_llvm,\n-                &llmod_id,\n-                kind,\n-                tcx.lang_items().oom().is_some(),\n-            )\n+        let module_llvm = tcx.sess.time(\"write_allocator_module\", || {\n+            backend.codegen_allocator(tcx, &llmod_id, kind, tcx.lang_items().oom().is_some())\n         });\n \n         Some(ModuleCodegen { name: llmod_id, module_llvm, kind: ModuleKind::Allocator })"}, {"sha": "1e53c73d1bb4ac5b4fe5b0a04de7c4b5f66050ab", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/329a73dbd69367abc73698d9d6154bb5b5f6c749/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329a73dbd69367abc73698d9d6154bb5b5f6c749/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=329a73dbd69367abc73698d9d6154bb5b5f6c749", "patch": "@@ -114,15 +114,13 @@ pub trait CodegenBackend {\n }\n \n pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Send + Sync {\n-    fn new_metadata(&self, sess: TyCtxt<'_>, mod_name: &str) -> Self::Module;\n     fn codegen_allocator<'tcx>(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        module_llvm: &mut Self::Module,\n         module_name: &str,\n         kind: AllocatorKind,\n         has_alloc_error_handler: bool,\n-    );\n+    ) -> Self::Module;\n     /// This generates the codegen unit and returns it along with\n     /// a `u64` giving an estimate of the unit's processing cost.\n     fn compile_codegen_unit("}, {"sha": "e54ec34f1ce3716c38aec565c47951a3444c0244", "filename": "compiler/rustc_codegen_ssa/src/traits/write.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/329a73dbd69367abc73698d9d6154bb5b5f6c749/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329a73dbd69367abc73698d9d6154bb5b5f6c749/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs?ref=329a73dbd69367abc73698d9d6154bb5b5f6c749", "patch": "@@ -41,9 +41,13 @@ pub trait WriteBackendMethods: 'static + Sized + Clone {\n         module: &ModuleCodegen<Self::Module>,\n         config: &ModuleConfig,\n     ) -> Result<(), FatalError>;\n+    fn optimize_fat(\n+        cgcx: &CodegenContext<Self>,\n+        llmod: &mut ModuleCodegen<Self::Module>,\n+    ) -> Result<(), FatalError>;\n     unsafe fn optimize_thin(\n         cgcx: &CodegenContext<Self>,\n-        thin: &mut ThinModule<Self>,\n+        thin: ThinModule<Self>,\n     ) -> Result<ModuleCodegen<Self::Module>, FatalError>;\n     unsafe fn codegen(\n         cgcx: &CodegenContext<Self>,\n@@ -53,12 +57,6 @@ pub trait WriteBackendMethods: 'static + Sized + Clone {\n     ) -> Result<CompiledModule, FatalError>;\n     fn prepare_thin(module: ModuleCodegen<Self::Module>) -> (String, Self::ThinBuffer);\n     fn serialize_module(module: ModuleCodegen<Self::Module>) -> (String, Self::ModuleBuffer);\n-    fn run_lto_pass_manager(\n-        cgcx: &CodegenContext<Self>,\n-        llmod: &ModuleCodegen<Self::Module>,\n-        config: &ModuleConfig,\n-        thin: bool,\n-    ) -> Result<(), FatalError>;\n }\n \n pub trait ThinBufferMethods: Send + Sync {"}]}