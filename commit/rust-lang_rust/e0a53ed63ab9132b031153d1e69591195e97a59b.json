{"sha": "e0a53ed63ab9132b031153d1e69591195e97a59b", "node_id": "C_kwDOAAsO6NoAKGUwYTUzZWQ2M2FiOTEzMmIwMzExNTNkMWU2OTU5MTE5NWU5N2E1OWI", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2022-05-08T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2022-05-11T07:38:28Z"}, "message": "Use `fcntl(fd, F_GETFD)` to detect if standard streams are open\n\nIn the previous implementation, if the standard streams were open,\nbut the RLIMIT_NOFILE value was below three, the poll would fail\nwith EINVAL:\n\n> ERRORS: EINVAL The nfds value exceeds the RLIMIT_NOFILE value.\n\nSwitch to the existing fcntl based implementation to avoid the issue.", "tree": {"sha": "258f3b659e190a416232be6156c4fa1a5e9d686b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/258f3b659e190a416232be6156c4fa1a5e9d686b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0a53ed63ab9132b031153d1e69591195e97a59b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0a53ed63ab9132b031153d1e69591195e97a59b", "html_url": "https://github.com/rust-lang/rust/commit/e0a53ed63ab9132b031153d1e69591195e97a59b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0a53ed63ab9132b031153d1e69591195e97a59b/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b862b438dbffb959ef4e9643148ecd05b8da4d8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b862b438dbffb959ef4e9643148ecd05b8da4d8a", "html_url": "https://github.com/rust-lang/rust/commit/b862b438dbffb959ef4e9643148ecd05b8da4d8a"}], "stats": {"total": 83, "additions": 52, "deletions": 31}, "files": [{"sha": "d823e51afa23837769578d03e97c0de96d25d078", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 6, "deletions": 31, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e0a53ed63ab9132b031153d1e69591195e97a59b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0a53ed63ab9132b031153d1e69591195e97a59b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=e0a53ed63ab9132b031153d1e69591195e97a59b", "patch": "@@ -67,48 +67,23 @@ pub unsafe fn init(argc: isize, argv: *const *const u8) {\n     args::init(argc, argv);\n \n     unsafe fn sanitize_standard_fds() {\n-        #[cfg(not(miri))]\n-        // The standard fds are always available in Miri.\n         cfg_if::cfg_if! {\n             if #[cfg(not(any(\n+                // The standard fds are always available in Miri.\n+                miri,\n                 target_os = \"emscripten\",\n                 target_os = \"fuchsia\",\n                 target_os = \"vxworks\",\n-                // The poll on Darwin doesn't set POLLNVAL for closed fds.\n-                target_os = \"macos\",\n-                target_os = \"ios\",\n-                target_os = \"redox\",\n                 target_os = \"l4re\",\n             )))] {\n-                use crate::sys::os::errno;\n-                let pfds: &mut [_] = &mut [\n-                    libc::pollfd { fd: 0, events: 0, revents: 0 },\n-                    libc::pollfd { fd: 1, events: 0, revents: 0 },\n-                    libc::pollfd { fd: 2, events: 0, revents: 0 },\n-                ];\n-                while libc::poll(pfds.as_mut_ptr(), 3, 0) == -1 {\n-                    if errno() == libc::EINTR {\n-                        continue;\n-                    }\n-                    libc::abort();\n-                }\n-                for pfd in pfds {\n-                    if pfd.revents & libc::POLLNVAL == 0 {\n-                        continue;\n-                    }\n-                    if libc::open(\"/dev/null\\0\".as_ptr().cast(), libc::O_RDWR, 0) == -1 {\n-                        // If the stream is closed but we failed to reopen it, abort the\n-                        // process. Otherwise we wouldn't preserve the safety of\n-                        // operations on the corresponding Rust object Stdin, Stdout, or\n-                        // Stderr.\n-                        libc::abort();\n-                    }\n-                }\n-            } else if #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"redox\"))] {\n                 use crate::sys::os::errno;\n                 for fd in 0..3 {\n                     if libc::fcntl(fd, libc::F_GETFD) == -1 && errno() == libc::EBADF {\n                         if libc::open(\"/dev/null\\0\".as_ptr().cast(), libc::O_RDWR, 0) == -1 {\n+                            // If the stream is closed but we failed to reopen it, abort the\n+                            // process. Otherwise we wouldn't preserve the safety of\n+                            // operations on the corresponding Rust object Stdin, Stdout, or\n+                            // Stderr.\n                             libc::abort();\n                         }\n                     }"}, {"sha": "549135a46cf1019b4ae42b608994b5d5ede69938", "filename": "src/test/ui/process/nofile-limit.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e0a53ed63ab9132b031153d1e69591195e97a59b/src%2Ftest%2Fui%2Fprocess%2Fnofile-limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0a53ed63ab9132b031153d1e69591195e97a59b/src%2Ftest%2Fui%2Fprocess%2Fnofile-limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprocess%2Fnofile-limit.rs?ref=e0a53ed63ab9132b031153d1e69591195e97a59b", "patch": "@@ -0,0 +1,46 @@\n+// Check that statically linked binary executes successfully\n+// with RLIMIT_NOFILE resource lowered to zero. Regression\n+// test for issue #96621.\n+//\n+// run-pass\n+// dont-check-compiler-stderr\n+// only-linux\n+// no-prefer-dynamic\n+// compile-flags: -Ctarget-feature=+crt-static -Crpath=no\n+#![feature(exit_status_error)]\n+#![feature(rustc_private)]\n+extern crate libc;\n+\n+use std::os::unix::process::CommandExt;\n+use std::process::Command;\n+\n+fn main() {\n+    let mut args = std::env::args();\n+    let this = args.next().unwrap();\n+    match args.next().as_deref() {\n+        None => {\n+            let mut cmd = Command::new(this);\n+            cmd.arg(\"Ok!\");\n+            unsafe {\n+                cmd.pre_exec(|| {\n+                    let rlim = libc::rlimit {\n+                        rlim_cur: 0,\n+                        rlim_max: 0,\n+                    };\n+                    if libc::setrlimit(libc::RLIMIT_NOFILE, &rlim) == -1 {\n+                        Err(std::io::Error::last_os_error())\n+                    } else {\n+                        Ok(())\n+                    }\n+                })\n+            };\n+            let output = cmd.output().unwrap();\n+            println!(\"{:?}\", output);\n+            output.status.exit_ok().unwrap();\n+            assert!(output.stdout.starts_with(b\"Ok!\"));\n+        }\n+        Some(word) => {\n+            println!(\"{}\", word);\n+        }\n+    }\n+}"}]}