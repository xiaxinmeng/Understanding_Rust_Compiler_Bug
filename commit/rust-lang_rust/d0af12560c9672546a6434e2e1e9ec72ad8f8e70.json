{"sha": "d0af12560c9672546a6434e2e1e9ec72ad8f8e70", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwYWYxMjU2MGM5NjcyNTQ2YTY0MzRlMmUxZTllYzcyYWQ4ZjhlNzA=", "commit": {"author": {"name": "Leonora Tindall", "email": "nora@nora.codes", "date": "2020-09-01T16:44:32Z"}, "committer": {"name": "Leonora Tindall", "email": "nora@nora.codes", "date": "2020-09-01T21:02:09Z"}, "message": "Rename and expose LoopState as ControlFlow", "tree": {"sha": "4f70d06493ab685d496280f760130b634c55159e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f70d06493ab685d496280f760130b634c55159e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0af12560c9672546a6434e2e1e9ec72ad8f8e70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0af12560c9672546a6434e2e1e9ec72ad8f8e70", "html_url": "https://github.com/rust-lang/rust/commit/d0af12560c9672546a6434e2e1e9ec72ad8f8e70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0af12560c9672546a6434e2e1e9ec72ad8f8e70/comments", "author": {"login": "NoraCodes", "id": 3290365, "node_id": "MDQ6VXNlcjMyOTAzNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/3290365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/NoraCodes", "html_url": "https://github.com/NoraCodes", "followers_url": "https://api.github.com/users/NoraCodes/followers", "following_url": "https://api.github.com/users/NoraCodes/following{/other_user}", "gists_url": "https://api.github.com/users/NoraCodes/gists{/gist_id}", "starred_url": "https://api.github.com/users/NoraCodes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/NoraCodes/subscriptions", "organizations_url": "https://api.github.com/users/NoraCodes/orgs", "repos_url": "https://api.github.com/users/NoraCodes/repos", "events_url": "https://api.github.com/users/NoraCodes/events{/privacy}", "received_events_url": "https://api.github.com/users/NoraCodes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "NoraCodes", "id": 3290365, "node_id": "MDQ6VXNlcjMyOTAzNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/3290365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/NoraCodes", "html_url": "https://github.com/NoraCodes", "followers_url": "https://api.github.com/users/NoraCodes/followers", "following_url": "https://api.github.com/users/NoraCodes/following{/other_user}", "gists_url": "https://api.github.com/users/NoraCodes/gists{/gist_id}", "starred_url": "https://api.github.com/users/NoraCodes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/NoraCodes/subscriptions", "organizations_url": "https://api.github.com/users/NoraCodes/orgs", "repos_url": "https://api.github.com/users/NoraCodes/repos", "events_url": "https://api.github.com/users/NoraCodes/events{/privacy}", "received_events_url": "https://api.github.com/users/NoraCodes/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb9e7c357e26bf41c47661720e46f4498de32b83", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb9e7c357e26bf41c47661720e46f4498de32b83", "html_url": "https://github.com/rust-lang/rust/commit/eb9e7c357e26bf41c47661720e46f4498de32b83"}], "stats": {"total": 212, "additions": 113, "deletions": 99}, "files": [{"sha": "e1ad8211a0309fecf96d450104bb86b806350396", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d0af12560c9672546a6434e2e1e9ec72ad8f8e70/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0af12560c9672546a6434e2e1e9ec72ad8f8e70/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=d0af12560c9672546a6434e2e1e9ec72ad8f8e70", "patch": "@@ -1,9 +1,9 @@\n use crate::cmp;\n use crate::fmt;\n use crate::intrinsics;\n-use crate::ops::{Add, AddAssign, Try};\n+use crate::ops::{Add, AddAssign, Try, ControlFlow};\n \n-use super::{from_fn, LoopState};\n+use super::from_fn;\n use super::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator, TrustedLen};\n \n mod chain;\n@@ -1164,10 +1164,10 @@ where\n         #[inline]\n         fn find<T, B>(\n             f: &mut impl FnMut(T) -> Option<B>,\n-        ) -> impl FnMut((), T) -> LoopState<(), B> + '_ {\n+        ) -> impl FnMut((), T) -> ControlFlow<(), B> + '_ {\n             move |(), x| match f(x) {\n-                Some(x) => LoopState::Break(x),\n-                None => LoopState::Continue(()),\n+                Some(x) => ControlFlow::Break(x),\n+                None => ControlFlow::Continue(()),\n             }\n         }\n \n@@ -1864,13 +1864,13 @@ where\n             flag: &'a mut bool,\n             p: &'a mut impl FnMut(&T) -> bool,\n             mut fold: impl FnMut(Acc, T) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> + 'a {\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<Acc, R> + 'a {\n             move |acc, x| {\n                 if p(&x) {\n-                    LoopState::from_try(fold(acc, x))\n+                    ControlFlow::from_try(fold(acc, x))\n                 } else {\n                     *flag = true;\n-                    LoopState::Break(Try::from_ok(acc))\n+                    ControlFlow::Break(Try::from_ok(acc))\n                 }\n             }\n         }\n@@ -1963,8 +1963,8 @@ where\n     {\n         let Self { iter, predicate } = self;\n         iter.try_fold(init, |acc, x| match predicate(x) {\n-            Some(item) => LoopState::from_try(fold(acc, item)),\n-            None => LoopState::Break(Try::from_ok(acc)),\n+            Some(item) => ControlFlow::from_try(fold(acc, item)),\n+            None => ControlFlow::Break(Try::from_ok(acc)),\n         })\n         .into_try()\n     }\n@@ -2135,11 +2135,11 @@ where\n         fn check<T, Acc, R: Try<Ok = Acc>>(\n             mut n: usize,\n             mut fold: impl FnMut(Acc, T) -> R,\n-        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> {\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<Acc, R> {\n             move |acc, x| {\n                 n -= 1;\n                 let r = fold(acc, x);\n-                if n == 0 { LoopState::Break(r) } else { LoopState::from_try(r) }\n+                if n == 0 { ControlFlow::Break(r) } else { ControlFlow::from_try(r) }\n             }\n         }\n \n@@ -2246,11 +2246,11 @@ where\n         fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n             n: &'a mut usize,\n             mut fold: impl FnMut(Acc, T) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> + 'a {\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<Acc, R> + 'a {\n             move |acc, x| {\n                 *n -= 1;\n                 let r = fold(acc, x);\n-                if *n == 0 { LoopState::Break(r) } else { LoopState::from_try(r) }\n+                if *n == 0 { ControlFlow::Break(r) } else { ControlFlow::from_try(r) }\n             }\n         }\n \n@@ -2414,10 +2414,10 @@ where\n             state: &'a mut St,\n             f: &'a mut impl FnMut(&mut St, T) -> Option<B>,\n             mut fold: impl FnMut(Acc, B) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> + 'a {\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<Acc, R> + 'a {\n             move |acc, x| match f(state, x) {\n-                None => LoopState::Break(Try::from_ok(acc)),\n-                Some(x) => LoopState::from_try(fold(acc, x)),\n+                None => ControlFlow::Break(Try::from_ok(acc)),\n+                Some(x) => ControlFlow::from_try(fold(acc, x)),\n             }\n         }\n \n@@ -2638,10 +2638,10 @@ where\n         let error = &mut *self.error;\n         self.iter\n             .try_fold(init, |acc, x| match x {\n-                Ok(x) => LoopState::from_try(f(acc, x)),\n+                Ok(x) => ControlFlow::from_try(f(acc, x)),\n                 Err(e) => {\n                     *error = Err(e);\n-                    LoopState::Break(Try::from_ok(acc))\n+                    ControlFlow::Break(Try::from_ok(acc))\n                 }\n             })\n             .into_try()"}, {"sha": "51cb725a8e6b58014102163bf1e57f1745430e29", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d0af12560c9672546a6434e2e1e9ec72ad8f8e70/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0af12560c9672546a6434e2e1e9ec72ad8f8e70/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=d0af12560c9672546a6434e2e1e9ec72ad8f8e70", "patch": "@@ -308,8 +308,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::ops::Try;\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::traits::Iterator;\n \n@@ -368,56 +366,3 @@ mod range;\n mod sources;\n mod traits;\n \n-/// Used to make try_fold closures more like normal loops\n-#[derive(PartialEq)]\n-enum LoopState<C, B> {\n-    Continue(C),\n-    Break(B),\n-}\n-\n-impl<C, B> Try for LoopState<C, B> {\n-    type Ok = C;\n-    type Error = B;\n-    #[inline]\n-    fn into_result(self) -> Result<Self::Ok, Self::Error> {\n-        match self {\n-            LoopState::Continue(y) => Ok(y),\n-            LoopState::Break(x) => Err(x),\n-        }\n-    }\n-    #[inline]\n-    fn from_error(v: Self::Error) -> Self {\n-        LoopState::Break(v)\n-    }\n-    #[inline]\n-    fn from_ok(v: Self::Ok) -> Self {\n-        LoopState::Continue(v)\n-    }\n-}\n-\n-impl<C, B> LoopState<C, B> {\n-    #[inline]\n-    fn break_value(self) -> Option<B> {\n-        match self {\n-            LoopState::Continue(..) => None,\n-            LoopState::Break(x) => Some(x),\n-        }\n-    }\n-}\n-\n-impl<R: Try> LoopState<R::Ok, R> {\n-    #[inline]\n-    fn from_try(r: R) -> Self {\n-        match Try::into_result(r) {\n-            Ok(v) => LoopState::Continue(v),\n-            Err(v) => LoopState::Break(Try::from_error(v)),\n-        }\n-    }\n-    #[inline]\n-    fn into_try(self) -> R {\n-        match self {\n-            LoopState::Continue(v) => Try::from_ok(v),\n-            LoopState::Break(v) => v,\n-        }\n-    }\n-}"}, {"sha": "3872fd4b6775b10f5aab9828d7b64fdfafeb89f0", "filename": "library/core/src/iter/traits/double_ended.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d0af12560c9672546a6434e2e1e9ec72ad8f8e70/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0af12560c9672546a6434e2e1e9ec72ad8f8e70/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=d0af12560c9672546a6434e2e1e9ec72ad8f8e70", "patch": "@@ -1,5 +1,4 @@\n-use crate::iter::LoopState;\n-use crate::ops::Try;\n+use crate::ops::{Try, ControlFlow};\n \n /// An iterator able to yield elements from both ends.\n ///\n@@ -309,9 +308,9 @@ pub trait DoubleEndedIterator: Iterator {\n         #[inline]\n         fn check<T>(\n             mut predicate: impl FnMut(&T) -> bool,\n-        ) -> impl FnMut((), T) -> LoopState<(), T> {\n+        ) -> impl FnMut((), T) -> ControlFlow<(), T> {\n             move |(), x| {\n-                if predicate(&x) { LoopState::Break(x) } else { LoopState::Continue(()) }\n+                if predicate(&x) { ControlFlow::Break(x) } else { ControlFlow::Continue(()) }\n             }\n         }\n "}, {"sha": "31d9ff69e7f5f79c5f296417e1b90eec05ad3ad8", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d0af12560c9672546a6434e2e1e9ec72ad8f8e70/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0af12560c9672546a6434e2e1e9ec72ad8f8e70/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=d0af12560c9672546a6434e2e1e9ec72ad8f8e70", "patch": "@@ -3,9 +3,8 @@\n // can't split that into multiple files.\n \n use crate::cmp::{self, Ordering};\n-use crate::ops::{Add, Try};\n+use crate::ops::{Add, Try, ControlFlow};\n \n-use super::super::LoopState;\n use super::super::TrustedRandomAccess;\n use super::super::{Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\n use super::super::{FlatMap, Flatten};\n@@ -2088,12 +2087,12 @@ pub trait Iterator {\n         F: FnMut(Self::Item) -> bool,\n     {\n         #[inline]\n-        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> LoopState<(), ()> {\n+        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> ControlFlow<(), ()> {\n             move |(), x| {\n-                if f(x) { LoopState::Continue(()) } else { LoopState::Break(()) }\n+                if f(x) { ControlFlow::Continue(()) } else { ControlFlow::Break(()) }\n             }\n         }\n-        self.try_fold((), check(f)) == LoopState::Continue(())\n+        self.try_fold((), check(f)) == ControlFlow::Continue(())\n     }\n \n     /// Tests if any element of the iterator matches a predicate.\n@@ -2141,13 +2140,13 @@ pub trait Iterator {\n         F: FnMut(Self::Item) -> bool,\n     {\n         #[inline]\n-        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> LoopState<(), ()> {\n+        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> ControlFlow<(), ()> {\n             move |(), x| {\n-                if f(x) { LoopState::Break(()) } else { LoopState::Continue(()) }\n+                if f(x) { ControlFlow::Break(()) } else { ControlFlow::Continue(()) }\n             }\n         }\n \n-        self.try_fold((), check(f)) == LoopState::Break(())\n+        self.try_fold((), check(f)) == ControlFlow::Break(())\n     }\n \n     /// Searches for an element of an iterator that satisfies a predicate.\n@@ -2203,9 +2202,9 @@ pub trait Iterator {\n         #[inline]\n         fn check<T>(\n             mut predicate: impl FnMut(&T) -> bool,\n-        ) -> impl FnMut((), T) -> LoopState<(), T> {\n+        ) -> impl FnMut((), T) -> ControlFlow<(), T> {\n             move |(), x| {\n-                if predicate(&x) { LoopState::Break(x) } else { LoopState::Continue(()) }\n+                if predicate(&x) { ControlFlow::Break(x) } else { ControlFlow::Continue(()) }\n             }\n         }\n \n@@ -2235,10 +2234,10 @@ pub trait Iterator {\n         F: FnMut(Self::Item) -> Option<B>,\n     {\n         #[inline]\n-        fn check<T, B>(mut f: impl FnMut(T) -> Option<B>) -> impl FnMut((), T) -> LoopState<(), B> {\n+        fn check<T, B>(mut f: impl FnMut(T) -> Option<B>) -> impl FnMut((), T) -> ControlFlow<(), B> {\n             move |(), x| match f(x) {\n-                Some(x) => LoopState::Break(x),\n-                None => LoopState::Continue(()),\n+                Some(x) => ControlFlow::Break(x),\n+                None => ControlFlow::Continue(()),\n             }\n         }\n \n@@ -2274,15 +2273,15 @@ pub trait Iterator {\n         R: Try<Ok = bool>,\n     {\n         #[inline]\n-        fn check<F, T, R>(mut f: F) -> impl FnMut((), T) -> LoopState<(), Result<T, R::Error>>\n+        fn check<F, T, R>(mut f: F) -> impl FnMut((), T) -> ControlFlow<(), Result<T, R::Error>>\n         where\n             F: FnMut(&T) -> R,\n             R: Try<Ok = bool>,\n         {\n             move |(), x| match f(&x).into_result() {\n-                Ok(false) => LoopState::Continue(()),\n-                Ok(true) => LoopState::Break(Ok(x)),\n-                Err(x) => LoopState::Break(Err(x)),\n+                Ok(false) => ControlFlow::Continue(()),\n+                Ok(true) => ControlFlow::Break(Ok(x)),\n+                Err(x) => ControlFlow::Break(Err(x)),\n             }\n         }\n \n@@ -2352,10 +2351,10 @@ pub trait Iterator {\n         #[inline]\n         fn check<T>(\n             mut predicate: impl FnMut(T) -> bool,\n-        ) -> impl FnMut(usize, T) -> LoopState<usize, usize> {\n+        ) -> impl FnMut(usize, T) -> ControlFlow<usize, usize> {\n             // The addition might panic on overflow\n             move |i, x| {\n-                if predicate(x) { LoopState::Break(i) } else { LoopState::Continue(Add::add(i, 1)) }\n+                if predicate(x) { ControlFlow::Break(i) } else { ControlFlow::Continue(Add::add(i, 1)) }\n             }\n         }\n \n@@ -2411,10 +2410,10 @@ pub trait Iterator {\n         #[inline]\n         fn check<T>(\n             mut predicate: impl FnMut(T) -> bool,\n-        ) -> impl FnMut(usize, T) -> LoopState<usize, usize> {\n+        ) -> impl FnMut(usize, T) -> ControlFlow<usize, usize> {\n             move |i, x| {\n                 let i = i - 1;\n-                if predicate(x) { LoopState::Break(i) } else { LoopState::Continue(i) }\n+                if predicate(x) { ControlFlow::Break(i) } else { ControlFlow::Continue(i) }\n             }\n         }\n "}, {"sha": "a0ed955768567ba2af3aa7cb6a751c184f59ce72", "filename": "library/core/src/ops/control_flow.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/d0af12560c9672546a6434e2e1e9ec72ad8f8e70/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0af12560c9672546a6434e2e1e9ec72ad8f8e70/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs?ref=d0af12560c9672546a6434e2e1e9ec72ad8f8e70", "patch": "@@ -0,0 +1,67 @@\n+use crate::ops::Try;\n+\n+/// Used to make try_fold closures more like normal loops\n+#[unstable(feature=\"control_flow_enum\", reason=\"new API\", issue=\"75744\")]\n+#[derive(Debug, Clone, Copy, PartialEq)]\n+pub enum ControlFlow<C, B> {\n+    /// Continue in the loop, using the given value for the next iteration\n+    Continue(C),\n+    /// Exit the loop, yielding the given value\n+    Break(B),\n+}\n+\n+#[unstable(feature=\"control_flow_enum\", reason=\"new API\", issue=\"75744\")]\n+impl<C, B> Try for ControlFlow<C, B> {\n+    type Ok = C;\n+    type Error = B;\n+    #[inline]\n+    fn into_result(self) -> Result<Self::Ok, Self::Error> {\n+        match self {\n+            ControlFlow::Continue(y) => Ok(y),\n+            ControlFlow::Break(x) => Err(x),\n+        }\n+    }\n+    #[inline]\n+    fn from_error(v: Self::Error) -> Self {\n+        ControlFlow::Break(v)\n+    }\n+    #[inline]\n+    fn from_ok(v: Self::Ok) -> Self {\n+        ControlFlow::Continue(v)\n+    }\n+}\n+\n+impl<C, B> ControlFlow<C, B> {\n+    /// Converts the `ControlFlow` into an `Option` which is `Some` if the\n+    /// `ControlFlow` was `Break` and `None` otherwise.\n+    #[inline]\n+    #[unstable(feature=\"control_flow_enum\", reason=\"new API\", issue=\"75744\")]\n+    pub fn break_value(self) -> Option<B> {\n+        match self {\n+            ControlFlow::Continue(..) => None,\n+            ControlFlow::Break(x) => Some(x),\n+        }\n+    }\n+}\n+\n+impl<R: Try> ControlFlow<R::Ok, R> {\n+    /// Create a `ControlFlow` from any type implementing `Try`.\n+    #[unstable(feature=\"control_flow_enum\", reason=\"new API\", issue=\"75744\")]\n+    #[inline]\n+    pub fn from_try(r: R) -> Self {\n+        match Try::into_result(r) {\n+            Ok(v) => ControlFlow::Continue(v),\n+            Err(v) => ControlFlow::Break(Try::from_error(v)),\n+        }\n+    }\n+\n+    /// Convert a `ControlFlow` into any type implementing `Try`;\n+    #[unstable(feature=\"control_flow_enum\", reason=\"new API\", issue=\"75744\")]\n+    #[inline]\n+    pub fn into_try(self) -> R {\n+        match self {\n+            ControlFlow::Continue(v) => Try::from_ok(v),\n+            ControlFlow::Break(v) => v,\n+        }\n+    }\n+}"}, {"sha": "befc644054fb2479f0ae8187b187339eab2b034c", "filename": "library/core/src/ops/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0af12560c9672546a6434e2e1e9ec72ad8f8e70/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0af12560c9672546a6434e2e1e9ec72ad8f8e70/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fmod.rs?ref=d0af12560c9672546a6434e2e1e9ec72ad8f8e70", "patch": "@@ -148,6 +148,7 @@ mod index;\n mod range;\n mod r#try;\n mod unsize;\n+mod control_flow;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::arith::{Add, Div, Mul, Neg, Rem, Sub};\n@@ -191,3 +192,6 @@ pub use self::unsize::CoerceUnsized;\n \n #[unstable(feature = \"dispatch_from_dyn\", issue = \"none\")]\n pub use self::unsize::DispatchFromDyn;\n+\n+#[unstable(feature=\"control_flow_enum\", reason=\"new API\", issue=\"75744\")]\n+pub use self::control_flow::ControlFlow;"}]}