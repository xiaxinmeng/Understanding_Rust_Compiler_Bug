{"sha": "221670b5bc02a9056e3cc278222296f8b3da00de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyMTY3MGI1YmMwMmE5MDU2ZTNjYzI3ODIyMjI5NmY4YjNkYTAwZGU=", "commit": {"author": {"name": "Scott Lawrence", "email": "bytbox@gmail.com", "date": "2014-01-28T05:53:01Z"}, "committer": {"name": "Scott Lawrence", "email": "bytbox@gmail.com", "date": "2014-01-29T14:15:42Z"}, "message": "Removing usage of the do keyword from documentation", "tree": {"sha": "d0975701139f42e800046648c0c30b287afa0156", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0975701139f42e800046648c0c30b287afa0156"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/221670b5bc02a9056e3cc278222296f8b3da00de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/221670b5bc02a9056e3cc278222296f8b3da00de", "html_url": "https://github.com/rust-lang/rust/commit/221670b5bc02a9056e3cc278222296f8b3da00de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/221670b5bc02a9056e3cc278222296f8b3da00de/comments", "author": {"login": "bytbox", "id": 160033, "node_id": "MDQ6VXNlcjE2MDAzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/160033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bytbox", "html_url": "https://github.com/bytbox", "followers_url": "https://api.github.com/users/bytbox/followers", "following_url": "https://api.github.com/users/bytbox/following{/other_user}", "gists_url": "https://api.github.com/users/bytbox/gists{/gist_id}", "starred_url": "https://api.github.com/users/bytbox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bytbox/subscriptions", "organizations_url": "https://api.github.com/users/bytbox/orgs", "repos_url": "https://api.github.com/users/bytbox/repos", "events_url": "https://api.github.com/users/bytbox/events{/privacy}", "received_events_url": "https://api.github.com/users/bytbox/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bytbox", "id": 160033, "node_id": "MDQ6VXNlcjE2MDAzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/160033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bytbox", "html_url": "https://github.com/bytbox", "followers_url": "https://api.github.com/users/bytbox/followers", "following_url": "https://api.github.com/users/bytbox/following{/other_user}", "gists_url": "https://api.github.com/users/bytbox/gists{/gist_id}", "starred_url": "https://api.github.com/users/bytbox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bytbox/subscriptions", "organizations_url": "https://api.github.com/users/bytbox/orgs", "repos_url": "https://api.github.com/users/bytbox/repos", "events_url": "https://api.github.com/users/bytbox/events{/privacy}", "received_events_url": "https://api.github.com/users/bytbox/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "733d1dde936d93e7aae4b1ab0084c4f203413bc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/733d1dde936d93e7aae4b1ab0084c4f203413bc1", "html_url": "https://github.com/rust-lang/rust/commit/733d1dde936d93e7aae4b1ab0084c4f203413bc1"}], "stats": {"total": 155, "additions": 38, "deletions": 117}, "files": [{"sha": "d97de7799024cbacb5e6ba8811e87bc9003f1349", "filename": "doc/guide-conditions.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221670b5bc02a9056e3cc278222296f8b3da00de/doc%2Fguide-conditions.md", "raw_url": "https://github.com/rust-lang/rust/raw/221670b5bc02a9056e3cc278222296f8b3da00de/doc%2Fguide-conditions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-conditions.md?ref=221670b5bc02a9056e3cc278222296f8b3da00de", "patch": "@@ -261,15 +261,15 @@ use std::task;\n fn main() {\n \n     // Isolate failure within a subtask.\n-    let result = do task::try {\n+    let result = task::try(proc() {\n \n         // The protected logic.\n         let pairs = read_int_pairs();\n         for &(a,b) in pairs.iter() {\n             println!(\"{:4.4d}, {:4.4d}\", a, b);\n         }\n \n-    };\n+    });\n     if result.is_err() {\n             println!(\"parsing failed\");\n     }"}, {"sha": "19696b42a3747e7ff156c52611a355ae9263fe21", "filename": "doc/guide-pointers.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/221670b5bc02a9056e3cc278222296f8b3da00de/doc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/221670b5bc02a9056e3cc278222296f8b3da00de/doc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-pointers.md?ref=221670b5bc02a9056e3cc278222296f8b3da00de", "patch": "@@ -221,9 +221,9 @@ struct Point {\n \n fn main() {\n     let a = Point { x: 10, y: 20 };\n-    do spawn {\n+    spawn(proc() {\n         println!(\"{}\", a.x);\n-    }\n+    });\n }\n ~~~\n \n@@ -238,9 +238,9 @@ struct Point {\n \n fn main() {\n     let a = ~Point { x: 10, y: 20 };\n-    do spawn {\n+    spawn(proc() {\n         println!(\"{}\", a.x);\n-    }\n+    });\n }\n ~~~\n "}, {"sha": "b6a54b042e96acf77887d2a8305ae22929730467", "filename": "doc/guide-runtime.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221670b5bc02a9056e3cc278222296f8b3da00de/doc%2Fguide-runtime.md", "raw_url": "https://github.com/rust-lang/rust/raw/221670b5bc02a9056e3cc278222296f8b3da00de/doc%2Fguide-runtime.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-runtime.md?ref=221670b5bc02a9056e3cc278222296f8b3da00de", "patch": "@@ -236,9 +236,9 @@ extern mod green;\n \n #[start]\n fn start(argc: int, argv: **u8) -> int {\n-    do green::start(argc, argv) {\n+    green::start(argc, argv, proc() {\n         main();\n-    }\n+    })\n }\n \n fn main() {}"}, {"sha": "c3bdbe3a3ee8992126abee557864b10b84052caa", "filename": "doc/guide-tasks.md", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/221670b5bc02a9056e3cc278222296f8b3da00de/doc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/221670b5bc02a9056e3cc278222296f8b3da00de/doc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-tasks.md?ref=221670b5bc02a9056e3cc278222296f8b3da00de", "patch": "@@ -77,11 +77,6 @@ spawn(print_message);\n \n // Print something more profound in a different task using a lambda expression\n spawn(proc() println!(\"I am also running in a different task!\") );\n-\n-// The canonical way to spawn is using `do` notation\n-do spawn {\n-    println!(\"I too am running in a different task!\");\n-}\n ~~~~\n \n In Rust, there is nothing special about creating tasks: a task is not a\n@@ -103,10 +98,10 @@ an environment that it carries across tasks.\n // Generate some state locally\n let child_task_number = generate_task_number();\n \n-do spawn {\n+spawn(proc() {\n     // Capture it in the remote task\n     println!(\"I am child number {}\", child_task_number);\n-}\n+});\n ~~~\n \n ## Communication\n@@ -132,10 +127,10 @@ concurrently:\n \n let (port, chan): (Port<int>, Chan<int>) = Chan::new();\n \n-do spawn || {\n+spawn(proc() {\n     let result = some_expensive_computation();\n     chan.send(result);\n-}\n+});\n \n some_other_expensive_computation();\n let result = port.recv();\n@@ -160,10 +155,10 @@ spawns the child task.\n # use std::task::spawn;\n # fn some_expensive_computation() -> int { 42 }\n # let (port, chan) = Chan::new();\n-do spawn || {\n+spawn(proc() {\n     let result = some_expensive_computation();\n     chan.send(result);\n-}\n+});\n ~~~~\n \n Notice that the creation of the task closure transfers `chan` to the child\n@@ -195,15 +190,15 @@ of tasks? The following program is ill-typed:\n # fn some_expensive_computation() -> int { 42 }\n let (port, chan) = Chan::new();\n \n-do spawn {\n+spawn(proc() {\n     chan.send(some_expensive_computation());\n-}\n+});\n \n // ERROR! The previous spawn statement already owns the channel,\n // so the compiler will not allow it to be captured again\n-do spawn {\n+spawn(proc() {\n     chan.send(some_expensive_computation());\n-}\n+});\n ~~~\n \n Instead we can use a `SharedChan`, a type that allows a single\n@@ -217,9 +212,9 @@ let (port, chan) = SharedChan::new();\n for init_val in range(0u, 3) {\n     // Create a new channel handle to distribute to the child task\n     let child_chan = chan.clone();\n-    do spawn {\n+    spawn(proc() {\n         child_chan.send(some_expensive_computation(init_val));\n-    }\n+    });\n }\n \n let result = port.recv() + port.recv() + port.recv();\n@@ -247,9 +242,9 @@ might look like the example below.\n // Create a vector of ports, one for each child task\n let ports = vec::from_fn(3, |init_val| {\n     let (port, chan) = Chan::new();\n-    do spawn {\n+    spawn(proc() {\n         chan.send(some_expensive_computation(init_val));\n-    }\n+    });\n     port\n });\n \n@@ -296,7 +291,7 @@ fn partial_sum(start: uint) -> f64 {\n }\n \n fn main() {\n-    let mut futures = vec::from_fn(1000, |ind| do extra::future::Future::spawn { partial_sum(ind) });\n+    let mut futures = vec::from_fn(1000, |ind| extra::future::Future::spawn( proc() { partial_sum(ind) }));\n \n     let mut final_res = 0f64;\n     for ft in futures.mut_iter()  {\n@@ -339,11 +334,11 @@ fn main() {\n         let (port, chan)  = Chan::new();\n         chan.send(numbers_arc.clone());\n \n-        do spawn {\n+        spawn(proc() {\n             let local_arc : Arc<~[f64]> = port.recv();\n             let task_numbers = local_arc.get();\n             println!(\"{}-norm = {}\", num, pnorm(task_numbers, num));\n-        }\n+        });\n     }\n }\n ~~~\n@@ -417,13 +412,13 @@ termination with an error).\n # use std::task;\n # fn some_condition() -> bool { false }\n # fn calculate_result() -> int { 0 }\n-let result: Result<int, ()> = do task::try {\n+let result: Result<int, ()> = task::try(proc() {\n     if some_condition() {\n         calculate_result()\n     } else {\n         fail!(\"oops!\");\n     }\n-};\n+});\n assert!(result.is_err());\n ~~~\n \n@@ -502,9 +497,9 @@ Here is the code for the parent task:\n \n let (from_child, to_child) = DuplexStream::new();\n \n-do spawn {\n+spawn(proc() {\n     stringifier(&to_child);\n-};\n+});\n \n from_child.send(22);\n assert!(from_child.recv() == ~\"22\");"}, {"sha": "1dd312febb7188030e7437326b1e68334d4039ba", "filename": "doc/rust.md", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/221670b5bc02a9056e3cc278222296f8b3da00de/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/221670b5bc02a9056e3cc278222296f8b3da00de/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=221670b5bc02a9056e3cc278222296f8b3da00de", "patch": "@@ -2751,52 +2751,6 @@ but must enclose it.\n \n A `loop` expression is only permitted in the body of a loop.\n \n-### Do expressions\n-\n-~~~~ {.ebnf .gram}\n-do_expr : \"do\" expr [ '|' ident_list '|' ] ? '{' block '}' ;\n-~~~~\n-\n-A _do expression_ provides a more-familiar block syntax\n-for invoking a function and passing it a newly-created a procedure.\n-\n-The optional `ident_list` and `block` provided in a `do` expression are parsed\n-as though they constitute a procedure expression;\n-if the `ident_list` is missing, an empty `ident_list` is implied.\n-\n-The procedure expression is then provided as a _trailing argument_\n-to the outermost [call](#call-expressions) or\n-[method call](#method-call-expressions) expression\n-in the `expr` following `do`.\n-If the `expr` is a [path expression](#path-expressions), it is parsed as though it is a call expression.\n-If the `expr` is a [field expression](#field-expressions), it is parsed as though it is a method call expression.\n-\n-In this example, both calls to `f` are equivalent:\n-\n-~~~~\n-# fn f(f: proc(int)) { }\n-# fn g(i: int) { }\n-\n-f(proc(j) { g(j) });\n-\n-do f |j| {\n-    g(j);\n-}\n-~~~~\n-\n-In this example, both calls to the (binary) function `k` are equivalent:\n-\n-~~~~\n-# fn k(x:int, f: proc(int)) { }\n-# fn l(i: int) { }\n-\n-k(3, proc(j) { l(j) });\n-\n-do k(3) |j| {\n-   l(j);\n-}\n-~~~~\n-\n ### For expressions\n \n ~~~~ {.ebnf .gram}"}, {"sha": "9304badb1c6e68402300d39657e04a0b59a5bded", "filename": "doc/tutorial.md", "status": "modified", "additions": 9, "deletions": 37, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/221670b5bc02a9056e3cc278222296f8b3da00de/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/221670b5bc02a9056e3cc278222296f8b3da00de/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=221670b5bc02a9056e3cc278222296f8b3da00de", "patch": "@@ -1796,48 +1796,20 @@ call_it(proc(n) {\n });\n ~~~~\n \n-This is such a useful pattern that Rust has a special form of function\n-call for these functions.\n-\n-~~~~\n-# fn call_it(op: proc(v: int)) { }\n-do call_it() |n| {\n-    println!(\"{}\", n);\n-}\n-~~~~\n-\n-The call is prefixed with the keyword `do` and, instead of writing the\n-final procedure inside the argument list, it appears outside of the\n-parentheses, where it looks more like a typical block of\n-code.\n-\n-`do` is a convenient way to create tasks with the `task::spawn`\n-function.  `spawn` has the signature `spawn(fn: proc())`. In other\n-words, it is a function that takes an owned closure that takes no\n-arguments.\n-\n-~~~~\n-use std::task::spawn;\n-\n-do spawn() || {\n-    debug!(\"I'm a task, whatever\");\n-}\n-~~~~\n-\n-Look at all those bars and parentheses -- that's two empty argument\n-lists back to back. Since that is so unsightly, empty argument lists\n-may be omitted from `do` expressions.\n+A practical example of this pattern is found when using the `spawn` function,\n+which starts a new task.\n \n ~~~~\n use std::task::spawn;\n-\n-do spawn {\n-   debug!(\"Kablam!\");\n-}\n+spawn(proc() {\n+    debug!(\"I'm a new task\")\n+});\n ~~~~\n \n-If you want to see the output of `debug!` statements, you will need to turn on `debug!` logging.\n-To enable `debug!` logging, set the RUST_LOG environment variable to the name of your crate, which, for a file named `foo.rs`, will be `foo` (e.g., with bash, `export RUST_LOG=foo`).\n+If you want to see the output of `debug!` statements, you will need to turn on\n+`debug!` logging.  To enable `debug!` logging, set the RUST_LOG environment\n+variable to the name of your crate, which, for a file named `foo.rs`, will be\n+`foo` (e.g., with bash, `export RUST_LOG=foo`).\n \n # Methods\n "}]}