{"sha": "da9606247d5ddd0edebafaffd0367c541fbaee7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhOTYwNjI0N2Q1ZGRkMGVkZWJhZmFmZmQwMzY3YzU0MWZiYWVlN2U=", "commit": {"author": {"name": "Stuart Pernsteiner", "email": "spernsteiner@mozilla.com", "date": "2014-07-21T23:42:34Z"}, "committer": {"name": "Stuart Pernsteiner", "email": "spernsteiner@mozilla.com", "date": "2014-09-05T16:18:57Z"}, "message": "translate into multiple llvm contexts\n\nRotate between compilation units while translating.  The \"worker threads\"\ncommit added support for multiple compilation units, but only translated into\none, leaving the rest empty.  With this commit, `trans` rotates between various\ncompilation units while translating, using a simple stragtegy: upon entering a\nmodule, switch to translating into whichever compilation unit currently\ncontains the fewest LLVM instructions.\n\nMost of the actual changes here involve getting symbol linkage right, so that\nitems translated into different compilation units will link together properly\nat the end.", "tree": {"sha": "dc24ae23f92b8045e617b635268f835449fac8f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc24ae23f92b8045e617b635268f835449fac8f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da9606247d5ddd0edebafaffd0367c541fbaee7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da9606247d5ddd0edebafaffd0367c541fbaee7e", "html_url": "https://github.com/rust-lang/rust/commit/da9606247d5ddd0edebafaffd0367c541fbaee7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da9606247d5ddd0edebafaffd0367c541fbaee7e/comments", "author": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e7bc0f808d9ad874010ac610ad796d07127c458", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e7bc0f808d9ad874010ac610ad796d07127c458", "html_url": "https://github.com/rust-lang/rust/commit/2e7bc0f808d9ad874010ac610ad796d07127c458"}], "stats": {"total": 199, "additions": 149, "deletions": 50}, "files": [{"sha": "81f76a82a546c04df32669a06cfab315887a98fe", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/da9606247d5ddd0edebafaffd0367c541fbaee7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9606247d5ddd0edebafaffd0367c541fbaee7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=da9606247d5ddd0edebafaffd0367c541fbaee7e", "patch": "@@ -2124,8 +2124,17 @@ impl<'a> Visitor<()> for TransItemVisitor<'a> {\n     }\n }\n \n+pub fn update_linkage(ccx: &CrateContext, llval: ValueRef, id: ast::NodeId) {\n+    if ccx.reachable().contains(&id) || ccx.sess().opts.cg.codegen_units > 1 {\n+        llvm::SetLinkage(llval, llvm::ExternalLinkage);\n+    } else {\n+        llvm::SetLinkage(llval, llvm::InternalLinkage);\n+    }\n+}\n+\n pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     let _icx = push_ctxt(\"trans_item\");\n+\n     match item.node {\n       ast::ItemFn(ref decl, _fn_style, abi, ref generics, ref body) => {\n         if !generics.is_type_parameterized() {\n@@ -2148,6 +2157,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                          item.id,\n                          item.attrs.as_slice());\n             }\n+            update_linkage(ccx, llfn, item.id);\n         }\n \n         // Be sure to travel more than just one layer deep to catch nested\n@@ -2163,7 +2173,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                          item.id);\n       }\n       ast::ItemMod(ref m) => {\n-        trans_mod(ccx, m);\n+        trans_mod(&ccx.rotate(), m);\n       }\n       ast::ItemEnum(ref enum_definition, _) => {\n         enum_variant_size_lint(ccx, enum_definition, item.span, item.id);\n@@ -2173,6 +2183,10 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n           let mut v = TransItemVisitor{ ccx: ccx };\n           v.visit_expr(&**expr, ());\n           consts::trans_const(ccx, m, item.id);\n+\n+          let g = get_item_val(ccx, item.id);\n+          update_linkage(ccx, g, item.id);\n+\n           // Do static_assert checking. It can't really be done much earlier\n           // because we need to get the value of the bool out of LLVM\n           if attr::contains_name(item.attrs.as_slice(), \"static_assert\") {\n@@ -2221,10 +2235,6 @@ fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: String, node_id: ast::N\n                       llfn: ValueRef) {\n     ccx.item_symbols().borrow_mut().insert(node_id, sym);\n \n-    if !ccx.reachable().contains(&node_id) {\n-        llvm::SetLinkage(llfn, llvm::InternalLinkage);\n-    }\n-\n     // The stack exhaustion lang item shouldn't have a split stack because\n     // otherwise it would continue to be exhausted (bad), and both it and the\n     // eh_personality functions need to be externally linkable.\n@@ -2592,7 +2602,6 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n         None => {}\n     }\n \n-    let mut foreign = false;\n     let item = ccx.tcx().map.get(id);\n     let val = match item {\n         ast_map::NodeItem(i) => {\n@@ -2620,10 +2629,6 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                             llvm::LLVMAddGlobal(ccx.llmod(), llty, buf)\n                         });\n \n-                        if !ccx.reachable().contains(&id) {\n-                            llvm::SetLinkage(g, llvm::InternalLinkage);\n-                        }\n-\n                         // Apply the `unnamed_addr` attribute if\n                         // requested\n                         if !ast_util::static_has_significant_address(\n@@ -2714,8 +2719,6 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n         }\n \n         ast_map::NodeForeignItem(ni) => {\n-            foreign = true;\n-\n             match ni.node {\n                 ast::ForeignItemFn(..) => {\n                     let abi = ccx.tcx().map.get_foreign_abi(id);\n@@ -2787,12 +2790,14 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n         }\n     };\n \n-    // foreign items (extern fns and extern statics) don't have internal\n-    // linkage b/c that doesn't quite make sense. Otherwise items can\n-    // have internal linkage if they're not reachable.\n-    if !foreign && !ccx.reachable().contains(&id) {\n-        llvm::SetLinkage(val, llvm::InternalLinkage);\n-    }\n+    // All LLVM globals and functions are initially created as external-linkage\n+    // declarations.  If `trans_item`/`trans_fn` later turns the declaration\n+    // into a definition, it adjusts the linkage then (using `update_linkage`).\n+    //\n+    // The exception is foreign items, which have their linkage set inside the\n+    // call to `foreign::register_*` above.  We don't touch the linkage after\n+    // that (`foreign::trans_foreign_mod` doesn't adjust the linkage like the\n+    // other item translation functions do).\n \n     ccx.item_vals().borrow_mut().insert(id, val);\n     val\n@@ -2815,7 +2820,8 @@ pub fn p2i(ccx: &CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::EncodeInlinedItem<'r>)\n+pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r SharedCrateContext,\n+                                      ie: encoder::EncodeInlinedItem<'r>)\n     -> encoder::EncodeParams<'r> {\n         encoder::EncodeParams {\n             diag: cx.sess().diagnostic(),\n@@ -2830,7 +2836,7 @@ pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::EncodeI\n         }\n }\n \n-pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n+pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n     use flate;\n \n     let any_library = cx.sess().crate_types.borrow().iter().any(|ty| {\n@@ -2905,7 +2911,7 @@ pub fn trans_crate(krate: ast::Crate,\n                                              link_meta.clone(),\n                                              reachable);\n \n-    let metadata = {\n+    {\n         let ccx = shared_ccx.get_ccx(0);\n \n         // First, verify intrinsics.\n@@ -2916,15 +2922,17 @@ pub fn trans_crate(krate: ast::Crate,\n             let _icx = push_ctxt(\"text\");\n             trans_mod(&ccx, &krate.module);\n         }\n+    }\n \n+    for ccx in shared_ccx.iter() {\n         glue::emit_tydescs(&ccx);\n         if ccx.sess().opts.debuginfo != NoDebugInfo {\n             debuginfo::finalize(&ccx);\n         }\n+    }\n \n-        // Translate the metadata.\n-        write_metadata(&ccx, &krate)\n-    };\n+    // Translate the metadata.\n+    let metadata = write_metadata(&shared_ccx, &krate);\n \n     if shared_ccx.sess().trans_stats() {\n         let stats = shared_ccx.stats();"}, {"sha": "322a6a3cc909eb1272a1d29e4618926b046c5388", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da9606247d5ddd0edebafaffd0367c541fbaee7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9606247d5ddd0edebafaffd0367c541fbaee7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=da9606247d5ddd0edebafaffd0367c541fbaee7e", "patch": "@@ -50,6 +50,7 @@ impl<'a> Builder<'a> {\n                                                 .n_llvm_insns\n                                                 .get() + 1);\n         }\n+        self.ccx.count_llvm_insn();\n         if self.ccx.sess().count_llvm_insns() {\n             base::with_insn_ctxt(|v| {\n                 let mut h = self.ccx.stats().llvm_insns.borrow_mut();"}, {"sha": "bd5132ea4273660ea8f128ecb07e76b8c1957b5d", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/da9606247d5ddd0edebafaffd0367c541fbaee7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9606247d5ddd0edebafaffd0367c541fbaee7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=da9606247d5ddd0edebafaffd0367c541fbaee7e", "patch": "@@ -692,6 +692,15 @@ pub fn trans_const(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n         // constant's initializer to determine its LLVM type.\n         let v = ccx.const_values().borrow().get_copy(&id);\n         llvm::LLVMSetInitializer(g, v);\n+\n+        // `get_item_val` left `g` with external linkage, but we just set an\n+        // initializer for it.  But we don't know yet if `g` should really be\n+        // defined in this compilation unit, so we set its linkage to\n+        // `AvailableExternallyLinkage`.  (It's still a definition, but acts\n+        // like a declaration for most purposes.)  If `g` really should be\n+        // declared here, then `trans_item` will fix up the linkage later on.\n+        llvm::SetLinkage(g, llvm::AvailableExternallyLinkage);\n+\n         if m != ast::MutMutable {\n             llvm::LLVMSetGlobalConstant(g, True);\n         }"}, {"sha": "4184c49b9050863f94ee9b855e54556028557106", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/da9606247d5ddd0edebafaffd0367c541fbaee7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9606247d5ddd0edebafaffd0367c541fbaee7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=da9606247d5ddd0edebafaffd0367c541fbaee7e", "patch": "@@ -141,6 +141,11 @@ pub struct LocalCrateContext {\n     eh_personality: RefCell<Option<ValueRef>>,\n \n     intrinsics: RefCell<HashMap<&'static str, ValueRef>>,\n+\n+    /// Number of LLVM instructions translated into this `LocalCrateContext`.\n+    /// This is used to perform some basic load-balancing to keep all LLVM\n+    /// contexts around the same size.\n+    n_llvm_insns: Cell<uint>,\n }\n \n pub struct CrateContext<'a> {\n@@ -261,6 +266,18 @@ impl SharedCrateContext {\n         }\n     }\n \n+    fn get_smallest_ccx<'a>(&'a self) -> CrateContext<'a> {\n+        let local_ccx =\n+            self.local_ccxs\n+                .iter()\n+                .min_by(|&local_ccx| local_ccx.n_llvm_insns.get())\n+                .unwrap();\n+        CrateContext {\n+            shared: self,\n+            local: local_ccx,\n+        }\n+    }\n+\n \n     pub fn metadata_llmod(&self) -> ModuleRef {\n         self.metadata_llmod\n@@ -364,6 +381,7 @@ impl LocalCrateContext {\n                 dbg_cx: dbg_cx,\n                 eh_personality: RefCell::new(None),\n                 intrinsics: RefCell::new(HashMap::new()),\n+                n_llvm_insns: Cell::new(0u),\n             };\n \n             local_ccx.int_type = Type::int(&local_ccx.dummy_ccx(shared));\n@@ -415,6 +433,12 @@ impl<'b> CrateContext<'b> {\n     }\n \n \n+    /// Get a (possibly) different `CrateContext` from the same\n+    /// `SharedCrateContext`.\n+    pub fn rotate(&self) -> CrateContext<'b> {\n+        self.shared.get_smallest_ccx()\n+    }\n+\n     pub fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n         &self.shared.tcx\n     }\n@@ -467,14 +491,6 @@ impl<'b> CrateContext<'b> {\n         self.local.llcx\n     }\n \n-    pub fn metadata_llmod(&self) -> ModuleRef {\n-        self.shared.metadata_llmod\n-    }\n-\n-    pub fn metadata_llcx(&self) -> ContextRef {\n-        self.shared.metadata_llcx\n-    }\n-\n     pub fn td<'a>(&'a self) -> &'a TargetData {\n         &self.local.td\n     }\n@@ -619,6 +635,10 @@ impl<'b> CrateContext<'b> {\n     fn intrinsics<'a>(&'a self) -> &'a RefCell<HashMap<&'static str, ValueRef>> {\n         &self.local.intrinsics\n     }\n+\n+    pub fn count_llvm_insn(&self) {\n+        self.local.n_llvm_insns.set(self.local.n_llvm_insns.get() + 1);\n+    }\n }\n \n fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {"}, {"sha": "61c27292a3767c33c02b3d2840d734e1da93bd54", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/da9606247d5ddd0edebafaffd0367c541fbaee7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9606247d5ddd0edebafaffd0367c541fbaee7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=da9606247d5ddd0edebafaffd0367c541fbaee7e", "patch": "@@ -817,13 +817,28 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n             trans_def_fn_unadjusted(bcx, ref_expr, def)\n         }\n         def::DefStatic(did, _) => {\n+            // There are three things that may happen here:\n+            //  1) If the static item is defined in this crate, it will be\n+            //     translated using `get_item_val`, and we return a pointer to\n+            //     the result.\n+            //  2) If the static item is defined in another crate, but is\n+            //     marked inlineable, then it will be inlined into this crate\n+            //     and then translated with `get_item_val`.  Again, we return a\n+            //     pointer to the result.\n+            //  3) If the static item is defined in another crate and is not\n+            //     marked inlineable, then we add (or reuse) a declaration of\n+            //     an external global, and return a pointer to that.\n             let const_ty = expr_ty(bcx, ref_expr);\n \n             fn get_did(ccx: &CrateContext, did: ast::DefId)\n                        -> ast::DefId {\n                 if did.krate != ast::LOCAL_CRATE {\n+                    // Case 2 or 3.  Which one we're in is determined by\n+                    // whether the DefId produced by `maybe_instantiate_inline`\n+                    // is in the LOCAL_CRATE or not.\n                     inline::maybe_instantiate_inline(ccx, did)\n                 } else {\n+                    // Case 1.\n                     did\n                 }\n             }\n@@ -832,13 +847,17 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n                        -> ValueRef {\n                 // For external constants, we don't inline.\n                 if did.krate == ast::LOCAL_CRATE {\n+                    // Case 1 or 2.  (The inlining in case 2 produces a new\n+                    // DefId in LOCAL_CRATE.)\n+\n                     // The LLVM global has the type of its initializer,\n                     // which may not be equal to the enum's type for\n                     // non-C-like enums.\n                     let val = base::get_item_val(bcx.ccx(), did.node);\n                     let pty = type_of::type_of(bcx.ccx(), const_ty).ptr_to();\n                     PointerCast(bcx, val, pty)\n                 } else {\n+                    // Case 3.\n                     match bcx.ccx().extern_const_values().borrow().find(&did) {\n                         None => {}  // Continue.\n                         Some(llval) => {"}, {"sha": "8ed45f89c29e48dcc00577dcc1bbd085f6e64355", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da9606247d5ddd0edebafaffd0367c541fbaee7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9606247d5ddd0edebafaffd0367c541fbaee7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=da9606247d5ddd0edebafaffd0367c541fbaee7e", "patch": "@@ -159,11 +159,18 @@ pub fn register_static(ccx: &CrateContext,\n                 }\n             };\n             unsafe {\n+                // Declare a symbol `foo` with the desired linkage.\n                 let g1 = ident.get().with_c_str(|buf| {\n                     llvm::LLVMAddGlobal(ccx.llmod(), llty2.to_ref(), buf)\n                 });\n                 llvm::SetLinkage(g1, linkage);\n \n+                // Declare an internal global `extern_with_linkage_foo` which\n+                // is initialized with the address of `foo`.  If `foo` is\n+                // discarded during linking (for example, if `foo` has weak\n+                // linkage and there are no definitions), then\n+                // `extern_with_linkage_foo` will instead be initialized to\n+                // zero.\n                 let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n                 real_name.push_str(ident.get());\n                 let g2 = real_name.with_c_str(|buf| {\n@@ -175,6 +182,7 @@ pub fn register_static(ccx: &CrateContext,\n             }\n         }\n         None => unsafe {\n+            // Generate an external declaration.\n             ident.get().with_c_str(|buf| {\n                 llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(), buf)\n             })\n@@ -490,6 +498,10 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n                         register_foreign_item_fn(ccx, abi, ty,\n                                                  lname.get().as_slice(),\n                                                  Some(foreign_item.span));\n+                        // Unlike for other items, we shouldn't call\n+                        // `base::update_linkage` here.  Foreign items have\n+                        // special linkage requirements, which are handled\n+                        // inside `foreign::register_*`.\n                     }\n                 }\n             }"}, {"sha": "0713b2b535c07d077011adee70dc50a89332e36e", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 47, "deletions": 18, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/da9606247d5ddd0edebafaffd0367c541fbaee7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9606247d5ddd0edebafaffd0367c541fbaee7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=da9606247d5ddd0edebafaffd0367c541fbaee7e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{AvailableExternallyLinkage, SetLinkage};\n+use llvm::{AvailableExternallyLinkage, InternalLinkage, SetLinkage};\n use metadata::csearch;\n use middle::astencode;\n use middle::trans::base::{push_ctxt, trans_item, get_item_val, trans_fn};\n@@ -53,26 +53,52 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n             trans_item(ccx, &*item);\n \n-            // We're bringing an external global into this crate, but we don't\n-            // want to create two copies of the global. If we do this, then if\n-            // you take the address of the global in two separate crates you get\n-            // two different addresses. This is bad for things like conditions,\n-            // but it could possibly have other adverse side effects. We still\n-            // want to achieve the optimizations related to this global,\n-            // however, so we use the available_externally linkage which llvm\n-            // provides\n-            match item.node {\n+            let linkage = match item.node {\n+                ast::ItemFn(_, _, _, ref generics, _) => {\n+                    if generics.is_type_parameterized() {\n+                        // Generics have no symbol, so they can't be given any\n+                        // linkage.\n+                        None\n+                    } else {\n+                        if ccx.sess().opts.cg.codegen_units == 1 {\n+                            // We could use AvailableExternallyLinkage here,\n+                            // but InternalLinkage allows LLVM to optimize more\n+                            // aggressively (at the cost of sometimes\n+                            // duplicating code).\n+                            Some(InternalLinkage)\n+                        } else {\n+                            // With multiple compilation units, duplicated code\n+                            // is more of a problem.  Also, `codegen_units > 1`\n+                            // means the user is okay with losing some\n+                            // performance.\n+                            Some(AvailableExternallyLinkage)\n+                        }\n+                    }\n+                }\n                 ast::ItemStatic(_, mutbl, _) => {\n-                    let g = get_item_val(ccx, item.id);\n-                    // see the comment in get_item_val() as to why this check is\n-                    // performed here.\n-                    if ast_util::static_has_significant_address(\n-                            mutbl,\n-                            item.attrs.as_slice()) {\n-                        SetLinkage(g, AvailableExternallyLinkage);\n+                    if !ast_util::static_has_significant_address(mutbl, item.attrs.as_slice()) {\n+                        // Inlined static items use internal linkage when\n+                        // possible, so that LLVM will coalesce globals with\n+                        // identical initializers.  (It only does this for\n+                        // globals with unnamed_addr and either internal or\n+                        // private linkage.)\n+                        Some(InternalLinkage)\n+                    } else {\n+                        // The address is significant, so we can't create an\n+                        // internal copy of the static.  (The copy would have a\n+                        // different address from the original.)\n+                        Some(AvailableExternallyLinkage)\n                     }\n                 }\n-                _ => {}\n+                _ => unreachable!(),\n+            };\n+\n+            match linkage {\n+                Some(linkage) => {\n+                    let g = get_item_val(ccx, item.id);\n+                    SetLinkage(g, linkage);\n+                }\n+                None => {}\n             }\n \n             local_def(item.id)\n@@ -147,6 +173,9 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n                                  &param_substs::empty(),\n                                  mth.id,\n                                  []);\n+                        // Use InternalLinkage so LLVM can optimize more\n+                        // aggressively.\n+                        SetLinkage(llfn, InternalLinkage);\n                     }\n                     local_def(mth.id)\n                 }"}, {"sha": "92d8db0e4eafaff0d250302a5753c3fefb8c516d", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da9606247d5ddd0edebafaffd0367c541fbaee7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da9606247d5ddd0edebafaffd0367c541fbaee7e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=da9606247d5ddd0edebafaffd0367c541fbaee7e", "patch": "@@ -85,6 +85,7 @@ pub fn trans_impl(ccx: &CrateContext,\n                              &param_substs::empty(),\n                              method.id,\n                              []);\n+                    update_linkage(ccx, llfn, method.id);\n                 }\n                 let mut v = TransItemVisitor {\n                     ccx: ccx,"}]}