{"sha": "2f0e07730088b7656c244030f360406758f788ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMGUwNzczMDA4OGI3NjU2YzI0NDAzMGYzNjA0MDY3NThmNzg4ZWE=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-02-06T17:33:59Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-03-08T07:34:17Z"}, "message": "Report tcx errors with the span of the currently evaluating statement", "tree": {"sha": "89709339baf13a5e24e1e08b478f24f324ccb239", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89709339baf13a5e24e1e08b478f24f324ccb239"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f0e07730088b7656c244030f360406758f788ea", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlqg53kACgkQpp+NIls6\n19mkew/+Mk4ghMuiw08K8I0MkpcwLu57vLlJY3sjhgZlzNzEzIo6hrRNoyiZVlmJ\nGoUoCZmj6ZA+jAJ0f/x1/9noZB1UEUiWXv8uAfdYenBv7AME/GDNjQcMj5qbG9C4\nu3DG7lkQHbAtmxAIVmoMNfqzXVmixQmaHOI5ibReofDeYh5OK1Qifo5nTWEnpNtU\nPJJNgZvL0H7DmC2ReZNYPSpwYg5Y4sKGjgpwsxLz8eWjybsnc4iERj0ye14fsWKx\nBE6yhAWcK78yAdGVypDcrnQAPdUvl6LKJCI39Gojc5ABFJeCZuKdUjRVUA3UuWNN\nntxxbD/eMZ+kOfj6SF0iFRUADTWH46PPAu8VH5PCu+Tu+0lrbxmhc1I7zavEV8D8\nohvlVDVYMzcowO0QXAN88iR4YIMng5xkj81SPnIJHsqRViKva0mlti+Igtb2RUHV\nmZ3h8nM5mwE9iEpNcTfNSL5iJAewPUU9f5KwQ7iScY9wussCgdx6ZCAqCzOSVXAB\nkJtwwQ8E8QVU9/ZhoNxgL+V2N+cZvsNJe1Zqg3rJWRYM/r0T4x7yYTUuFXJH6ywv\ng2gyLq0x9DJKjWAunnEXAkxOHq+WjqXjbRu4Fy08vLIT2Ve/TSAvXdW73Pzng3Er\nP6wa9Ph67hxekynqQB2K1yryt7sOVDN0L46WPB9SBCOuhnpkQPU=\n=1cRQ\n-----END PGP SIGNATURE-----", "payload": "tree 89709339baf13a5e24e1e08b478f24f324ccb239\nparent 1e653aa96b392a04ed489eadc4cd040bc2859b4b\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1517938439 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1520494457 +0100\n\nReport tcx errors with the span of the currently evaluating statement\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f0e07730088b7656c244030f360406758f788ea", "html_url": "https://github.com/rust-lang/rust/commit/2f0e07730088b7656c244030f360406758f788ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f0e07730088b7656c244030f360406758f788ea/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e653aa96b392a04ed489eadc4cd040bc2859b4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e653aa96b392a04ed489eadc4cd040bc2859b4b", "html_url": "https://github.com/rust-lang/rust/commit/1e653aa96b392a04ed489eadc4cd040bc2859b4b"}], "stats": {"total": 106, "additions": 41, "deletions": 65}, "files": [{"sha": "ee5874be9d70ae997be6885fd7fda95489002de3", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f0e07730088b7656c244030f360406758f788ea/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0e07730088b7656c244030f360406758f788ea/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=2f0e07730088b7656c244030f360406758f788ea", "patch": "@@ -24,7 +24,7 @@ pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n ) -> EvalResult<'tcx, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>> {\n     debug!(\"mk_borrowck_eval_cx: {:?}\", instance);\n     let param_env = tcx.param_env(instance.def_id());\n-    let mut ecx = EvalContext::new(tcx, param_env, CompileTimeEvaluator, (), span);\n+    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeEvaluator, ());\n     // insert a stack frame so any queries have the correct substs\n     ecx.push_stack_frame(\n         instance,\n@@ -43,7 +43,7 @@ pub fn mk_eval_cx<'a, 'tcx>(\n ) -> EvalResult<'tcx, EvalContext<'a, 'tcx, 'tcx, CompileTimeEvaluator>> {\n     debug!(\"mk_eval_cx: {:?}, {:?}\", instance, param_env);\n     let span = tcx.def_span(instance.def_id());\n-    let mut ecx = EvalContext::new(tcx, param_env, CompileTimeEvaluator, (), span);\n+    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeEvaluator, ());\n     let mir = ecx.load_mir(instance.def)?;\n     // insert a stack frame so any queries have the correct substs\n     ecx.push_stack_frame(\n@@ -96,8 +96,9 @@ fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     debug!(\"eval_body: {:?}, {:?}\", cid, param_env);\n     // we start out with the best span we have\n     // and try improving it down the road when more information is available\n-    let mut span = tcx.def_span(cid.instance.def_id());\n-    let mut ecx = EvalContext::new(tcx, param_env, CompileTimeEvaluator, (), mir.map(|mir| mir.span).unwrap_or(span));\n+    let span = tcx.def_span(cid.instance.def_id());\n+    let mut span = mir.map(|mir| mir.span).unwrap_or(span);\n+    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeEvaluator, ());\n     let res = (|| {\n         let mut mir = match mir {\n             Some(mir) => mir,"}, {"sha": "f46d5631060837155cdc67f9a05210065989e9cd", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 17, "deletions": 45, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2f0e07730088b7656c244030f360406758f788ea/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0e07730088b7656c244030f360406758f788ea/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=2f0e07730088b7656c244030f360406758f788ea", "patch": "@@ -5,13 +5,13 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::middle::const_val::{ConstVal, ErrKind};\n use rustc::mir;\n-use rustc::traits::Reveal;\n use rustc::ty::layout::{self, Size, Align, HasDataLayout, LayoutOf, TyLayout};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::maps::TyCtxtAt;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::middle::const_val::FrameInfo;\n-use syntax::codemap::{self, DUMMY_SP, Span};\n+use syntax::codemap::{self, Span};\n use syntax::ast::Mutability;\n use rustc::mir::interpret::{\n     GlobalId, Value, Pointer, PrimVal, PrimValKind,\n@@ -27,7 +27,7 @@ pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     pub machine: M,\n \n     /// The results of the type checker, from rustc.\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n \n     /// Bounds in scope for polymorphic evaluations.\n     pub param_env: ty::ParamEnv<'tcx>,\n@@ -45,11 +45,6 @@ pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// This prevents infinite loops and huge computations from freezing up const eval.\n     /// Remove once halting problem is solved.\n     pub(crate) steps_remaining: usize,\n-\n-    /// The span that is used if no more stack frames are available\n-    ///\n-    /// This happens after successful evaluation when the result is inspected\n-    root_span: codemap::Span,\n }\n \n /// A stack frame.\n@@ -154,15 +149,15 @@ impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> layout::HasTyCtxt<'tcx> for &'a EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n-        self.tcx\n+        *self.tcx\n     }\n }\n \n impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> layout::HasTyCtxt<'tcx>\n     for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n     fn tcx<'d>(&'d self) -> TyCtxt<'d, 'tcx, 'tcx> {\n-        self.tcx\n+        *self.tcx\n     }\n }\n \n@@ -187,11 +182,10 @@ impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf<Ty<'tcx>>\n \n impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn new(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         machine: M,\n         memory_data: M::MemoryData,\n-        root_span: codemap::Span,\n     ) -> Self {\n         EvalContext {\n             machine,\n@@ -201,7 +195,6 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             stack: Vec::new(),\n             stack_limit: tcx.sess.const_eval_stack_frame_limit.get(),\n             steps_remaining: tcx.sess.const_eval_step_limit.get(),\n-            root_span,\n         }\n     }\n \n@@ -255,15 +248,15 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     pub(super) fn resolve(&self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n         let substs = self.tcx.trans_apply_param_substs(self.substs(), &substs);\n         ty::Instance::resolve(\n-            self.tcx,\n+            *self.tcx,\n             self.param_env,\n             def_id,\n             substs,\n         ).ok_or(EvalErrorKind::TypeckError.into()) // turn error prop into a panic to expose associated type in const issue\n     }\n \n     pub(super) fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_sized(self.tcx.at(DUMMY_SP), self.param_env)\n+        ty.is_sized(self.tcx, self.param_env)\n     }\n \n     pub fn load_mir(\n@@ -290,7 +283,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         // miri doesn't care about lifetimes, and will choke on some crazy ones\n         // let's simply get rid of them\n         let without_lifetimes = self.tcx.erase_regions(&ty);\n-        let substituted = without_lifetimes.subst(self.tcx, substs);\n+        let substituted = without_lifetimes.subst(*self.tcx, substs);\n         let substituted = self.tcx.fully_normalize_monormophic_ty(&substituted);\n         substituted\n     }\n@@ -725,7 +718,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                             ty::TyClosure(def_id, substs) => {\n                                 let substs = self.tcx.trans_apply_param_substs(self.substs(), &substs);\n                                 let instance = ty::Instance::resolve_closure(\n-                                    self.tcx,\n+                                    *self.tcx,\n                                     def_id,\n                                     substs,\n                                     ty::ClosureKind::FnOnce,\n@@ -748,8 +741,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let place = self.eval_place(place)?;\n                 let discr_val = self.read_discriminant_value(place, ty)?;\n                 if let ty::TyAdt(adt_def, _) = ty.sty {\n-                    trace!(\"Read discriminant {}, valid discriminants {:?}\", discr_val, adt_def.discriminants(self.tcx).collect::<Vec<_>>());\n-                    if adt_def.discriminants(self.tcx).all(|v| {\n+                    trace!(\"Read discriminant {}, valid discriminants {:?}\", discr_val, adt_def.discriminants(*self.tcx).collect::<Vec<_>>());\n+                    if adt_def.discriminants(*self.tcx).all(|v| {\n                         discr_val != v.val\n                     })\n                     {\n@@ -797,7 +790,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     pub fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, ValTy<'tcx>> {\n         use rustc::mir::Operand::*;\n-        let ty = self.monomorphize(op.ty(self.mir(), self.tcx), self.substs());\n+        let ty = self.monomorphize(op.ty(self.mir(), *self.tcx), self.substs());\n         match *op {\n             // FIXME: do some more logic on `move` to invalidate the old location\n             Copy(ref place) |\n@@ -905,7 +898,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             }\n             layout::Variants::Tagged { .. } => {\n                 let discr_val = dest_ty.ty_adt_def().unwrap()\n-                    .discriminant_for_variant(self.tcx, variant_index)\n+                    .discriminant_for_variant(*self.tcx, variant_index)\n                     .val;\n \n                 let (discr_dest, discr) = self.place_field(dest, mir::Field::new(0), layout)?;\n@@ -1412,7 +1405,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             }\n             (_, &ty::TyDynamic(ref data, _)) => {\n                 let trait_ref = data.principal().unwrap().with_self_ty(\n-                    self.tcx,\n+                    *self.tcx,\n                     src_pointee_ty,\n                 );\n                 let trait_ref = self.tcx.erase_regions(&trait_ref);\n@@ -1601,18 +1594,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             };\n             frames.push(FrameInfo { span, location });\n         }\n-        let span = if let Some(frame) = self.stack().last() {\n-            let bb = &frame.mir.basic_blocks()[frame.block];\n-            if let Some(stmt) = bb.statements.get(frame.stmt) {\n-                stmt.source_info.span\n-            } else {\n-                bb.terminator().source_info.span\n-            }\n-        } else {\n-            self.root_span\n-        };\n         trace!(\"generate stacktrace: {:#?}, {:?}\", frames, explicit_span);\n-        (frames, span)\n+        (frames, self.tcx.span)\n     }\n \n     pub fn report(&self, e: &mut EvalError, as_err: bool, explicit_span: Option<Span>) {\n@@ -1660,7 +1643,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             });\n             trace!(\"reporting const eval failure at {:?}\", span);\n             let mut err = if as_err {\n-                ::rustc::middle::const_val::struct_error(self.tcx, span, \"constant evaluation error\")\n+                ::rustc::middle::const_val::struct_error(*self.tcx, span, \"constant evaluation error\")\n             } else {\n                 let node_id = self\n                     .stack()\n@@ -1722,14 +1705,3 @@ impl<'mir, 'tcx> Frame<'mir, 'tcx> {\n         return Ok(old);\n     }\n }\n-\n-// TODO(solson): Upstream these methods into rustc::ty::layout.\n-\n-pub fn resolve_drop_in_place<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    ty: Ty<'tcx>,\n-) -> ty::Instance<'tcx> {\n-    let def_id = tcx.require_lang_item(::rustc::middle::lang_items::DropInPlaceFnLangItem);\n-    let substs = tcx.intern_substs(&[ty.into()]);\n-    ty::Instance::resolve(tcx, ty::ParamEnv::empty(Reveal::All), def_id, substs).unwrap()\n-}"}, {"sha": "7dceacabb292f28ebfea2b8b56b202715ee7e674", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f0e07730088b7656c244030f360406758f788ea/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0e07730088b7656c244030f360406758f788ea/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=2f0e07730088b7656c244030f360406758f788ea", "patch": "@@ -2,7 +2,8 @@ use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian, BigEndian};\n use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n use std::{ptr, io};\n \n-use rustc::ty::{Instance, TyCtxt};\n+use rustc::ty::Instance;\n+use rustc::ty::maps::TyCtxtAt;\n use rustc::ty::layout::{self, Align, TargetDataLayout};\n use syntax::ast::Mutability;\n \n@@ -51,11 +52,11 @@ pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// The current stack frame.  Used to check accesses against locks.\n     pub cur_frame: usize,\n \n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, data: M::MemoryData) -> Self {\n+    pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>, data: M::MemoryData) -> Self {\n         Memory {\n             data,\n             alloc_kind: HashMap::new(),"}, {"sha": "d27de3ef6bfc4e4c900ffeef81ea4cfed3b49239", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f0e07730088b7656c244030f360406758f788ea/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0e07730088b7656c244030f360406758f788ea/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=2f0e07730088b7656c244030f360406758f788ea", "patch": "@@ -209,7 +209,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                         extra: PlaceExtra::None,\n                     }\n                 } else {\n-                    let instance = ty::Instance::mono(self.tcx, static_.def_id);\n+                    let instance = ty::Instance::mono(*self.tcx, static_.def_id);\n                     let cid = GlobalId {\n                         instance,\n                         promoted: None\n@@ -445,7 +445,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n     pub fn place_ty(&self, place: &mir::Place<'tcx>) -> Ty<'tcx> {\n         self.monomorphize(\n-            place.ty(self.mir(), self.tcx).to_ty(self.tcx),\n+            place.ty(self.mir(), *self.tcx).to_ty(*self.tcx),\n             self.substs(),\n         )\n     }"}, {"sha": "54fd364d3f820452b3d91f9ae77a7e46ffbaa551", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f0e07730088b7656c244030f360406758f788ea/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0e07730088b7656c244030f360406758f788ea/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=2f0e07730088b7656c244030f360406758f788ea", "patch": "@@ -51,6 +51,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         // Some statements (e.g. box) push new stack frames.  We have to record the stack frame number\n         // *before* executing the statement.\n         let frame_idx = self.cur_frame();\n+        self.tcx.span = stmt.source_info.span;\n+        self.memory.tcx.span = stmt.source_info.span;\n \n         match stmt.kind {\n             Assign(ref place, ref rvalue) => self.eval_rvalue_into_place(rvalue, place)?,\n@@ -99,6 +101,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n     fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<'tcx> {\n         trace!(\"{:?}\", terminator.kind);\n+        self.tcx.span = terminator.source_info.span;\n+        self.memory.tcx.span = terminator.source_info.span;\n         self.eval_terminator(terminator)?;\n         if !self.stack.is_empty() {\n             trace!(\"// {:?}\", self.frame().block);"}, {"sha": "51dee0aaff47ca59f17f60af2b0beece6398dbe9", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f0e07730088b7656c244030f360406758f788ea/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0e07730088b7656c244030f360406758f788ea/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=2f0e07730088b7656c244030f360406758f788ea", "patch": "@@ -5,8 +5,7 @@ use syntax::codemap::Span;\n use syntax::abi::Abi;\n \n use rustc::mir::interpret::{EvalResult, PrimVal, Value};\n-use super::{EvalContext, eval_context,\n-            Place, Machine, ValTy};\n+use super::{EvalContext, Place, Machine, ValTy};\n \n use rustc_data_structures::indexed_vec::Idx;\n use interpret::memory::HasMemory;\n@@ -72,10 +71,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     ty::TyFnPtr(sig) => {\n                         let fn_ptr = self.value_to_primval(func)?.to_ptr()?;\n                         let instance = self.memory.get_fn(fn_ptr)?;\n-                        let instance_ty = instance.ty(self.tcx);\n+                        let instance_ty = instance.ty(*self.tcx);\n                         match instance_ty.sty {\n                             ty::TyFnDef(..) => {\n-                                let real_sig = instance_ty.fn_sig(self.tcx);\n+                                let real_sig = instance_ty.fn_sig(*self.tcx);\n                                 let sig = self.tcx.erase_late_bound_regions_and_normalize(&sig);\n                                 let real_sig = self.tcx.erase_late_bound_regions_and_normalize(&real_sig);\n                                 if !self.check_sig_compat(sig, real_sig)? {\n@@ -88,7 +87,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     }\n                     ty::TyFnDef(def_id, substs) => (\n                         self.resolve(def_id, substs)?,\n-                        func.ty.fn_sig(self.tcx),\n+                        func.ty.fn_sig(*self.tcx),\n                     ),\n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func.ty);\n@@ -117,7 +116,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let ty = self.tcx.trans_apply_param_substs(self.substs(), &ty);\n                 trace!(\"TerminatorKind::drop: {:?}, type {}\", location, ty);\n \n-                let instance = eval_context::resolve_drop_in_place(self.tcx, ty);\n+                let instance = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);\n                 self.drop_place(\n                     place,\n                     instance,"}, {"sha": "c67cf1c84bf0b25a6e5491e2b795c46d9fa69ecf", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f0e07730088b7656c244030f360406758f788ea/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0e07730088b7656c244030f360406758f788ea/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=2f0e07730088b7656c244030f360406758f788ea", "patch": "@@ -3,8 +3,7 @@ use rustc::ty::layout::{Size, Align, LayoutOf};\n use syntax::ast::Mutability;\n \n use rustc::mir::interpret::{PrimVal, Value, MemoryPointer, EvalResult};\n-use super::{EvalContext, eval_context,\n-            Machine};\n+use super::{EvalContext, Machine};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n@@ -34,7 +33,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             None,\n         )?;\n \n-        let drop = eval_context::resolve_drop_in_place(self.tcx, ty);\n+        let drop = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);\n         let drop = self.memory.create_fn_alloc(drop);\n         self.memory.write_ptr_sized_unsigned(vtable, ptr_align, PrimVal::Ptr(drop))?;\n "}, {"sha": "f98074bc554bbc857b364bb2108db676fd19cc33", "filename": "src/test/ui/infinite-recursion-const-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f0e07730088b7656c244030f360406758f788ea/src%2Ftest%2Fui%2Finfinite-recursion-const-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0e07730088b7656c244030f360406758f788ea/src%2Ftest%2Fui%2Finfinite-recursion-const-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite-recursion-const-fn.rs?ref=2f0e07730088b7656c244030f360406758f788ea", "patch": "@@ -11,8 +11,8 @@\n //https://github.com/rust-lang/rust/issues/31364\n \n #![feature(const_fn)]\n-const fn a() -> usize { b() }\n-const fn b() -> usize { a() } //~ ERROR constant evaluation error\n+const fn a() -> usize { b() } //~ ERROR constant evaluation error\n+const fn b() -> usize { a() }\n const ARR: [i32; a()] = [5; 6];\n \n fn main(){}"}]}