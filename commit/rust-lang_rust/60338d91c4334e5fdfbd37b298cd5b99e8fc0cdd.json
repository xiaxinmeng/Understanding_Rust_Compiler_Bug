{"sha": "60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwMzM4ZDkxYzQzMzRlNWZkZmJkMzdiMjk4Y2Q1Yjk5ZThmYzBjZGQ=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-11-27T19:43:55Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-07T04:53:00Z"}, "message": "libstd: remove unnecessary `as_slice()` calls", "tree": {"sha": "1bf5a10a9bb871ab6dc851c4f9b31ec1d852e4cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bf5a10a9bb871ab6dc851c4f9b31ec1d852e4cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "html_url": "https://github.com/rust-lang/rust/commit/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/comments", "author": null, "committer": null, "parents": [{"sha": "09f7713dd45c3a0b37073115575697c256238b18", "url": "https://api.github.com/repos/rust-lang/rust/commits/09f7713dd45c3a0b37073115575697c256238b18", "html_url": "https://github.com/rust-lang/rust/commit/09f7713dd45c3a0b37073115575697c256238b18"}], "stats": {"total": 239, "additions": 118, "deletions": 121}, "files": [{"sha": "f31c694098f402cdf61a7d0202931fa0b97a5c85", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "patch": "@@ -677,8 +677,8 @@ mod tests {\n         assert_eq!(test.to_ascii(), b);\n         assert_eq!(\"( ;\".to_ascii(), b);\n         let v = vec![40u8, 32u8, 59u8];\n-        assert_eq!(v.as_slice().to_ascii(), b);\n-        assert_eq!(\"( ;\".to_string().as_slice().to_ascii(), b);\n+        assert_eq!(v.to_ascii(), b);\n+        assert_eq!(\"( ;\".to_string().to_ascii(), b);\n \n         assert_eq!(\"abCDef&?#\".to_ascii().to_lowercase().into_string(), \"abcdef&?#\".to_string());\n         assert_eq!(\"abCDef&?#\".to_ascii().to_uppercase().into_string(), \"ABCDEF&?#\".to_string());\n@@ -780,7 +780,7 @@ mod tests {\n         while i <= 500 {\n             let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n                         else { i };\n-            assert_eq!((from_u32(i).unwrap()).to_string().as_slice().to_ascii_upper(),\n+            assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_upper(),\n                        (from_u32(upper).unwrap()).to_string())\n             i += 1;\n         }\n@@ -796,7 +796,7 @@ mod tests {\n         while i <= 500 {\n             let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n                         else { i };\n-            assert_eq!((from_u32(i).unwrap()).to_string().as_slice().to_ascii_lower(),\n+            assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_lower(),\n                        (from_u32(lower).unwrap()).to_string())\n             i += 1;\n         }\n@@ -850,7 +850,7 @@ mod tests {\n             let c = i;\n             let lower = if 'A' as u32 <= c && c <= 'Z' as u32 { c + 'a' as u32 - 'A' as u32 }\n                         else { c };\n-            assert!((from_u32(i).unwrap()).to_string().as_slice().eq_ignore_ascii_case(\n+            assert!((from_u32(i).unwrap()).to_string().eq_ignore_ascii_case(\n                     (from_u32(lower).unwrap()).to_string().as_slice()));\n             i += 1;\n         }"}, {"sha": "1fb6279d004b53f551e0fa2e4d63ecc50e5408e4", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "patch": "@@ -1546,7 +1546,7 @@ mod test_map {\n \n             DROP_VECTOR.with(|v| {\n                 for i in range(0u, 200) {\n-                    assert_eq!(v.borrow().as_slice()[i], 0);\n+                    assert_eq!(v.borrow()[i], 0);\n                 }\n             });\n \n@@ -1558,7 +1558,7 @@ mod test_map {\n \n             DROP_VECTOR.with(|v| {\n                 for i in range(0u, 200) {\n-                    assert_eq!(v.borrow().as_slice()[i], 1);\n+                    assert_eq!(v.borrow()[i], 1);\n                 }\n             });\n \n@@ -1569,27 +1569,27 @@ mod test_map {\n                 assert!(v.is_some());\n \n                 DROP_VECTOR.with(|v| {\n-                    assert_eq!(v.borrow().as_slice()[i], 1);\n-                    assert_eq!(v.borrow().as_slice()[i+100], 1);\n+                    assert_eq!(v.borrow()[i], 1);\n+                    assert_eq!(v.borrow()[i+100], 1);\n                 });\n             }\n \n             DROP_VECTOR.with(|v| {\n                 for i in range(0u, 50) {\n-                    assert_eq!(v.borrow().as_slice()[i], 0);\n-                    assert_eq!(v.borrow().as_slice()[i+100], 0);\n+                    assert_eq!(v.borrow()[i], 0);\n+                    assert_eq!(v.borrow()[i+100], 0);\n                 }\n \n                 for i in range(50u, 100) {\n-                    assert_eq!(v.borrow().as_slice()[i], 1);\n-                    assert_eq!(v.borrow().as_slice()[i+100], 1);\n+                    assert_eq!(v.borrow()[i], 1);\n+                    assert_eq!(v.borrow()[i+100], 1);\n                 }\n             });\n         }\n \n         DROP_VECTOR.with(|v| {\n             for i in range(0u, 200) {\n-                assert_eq!(v.borrow().as_slice()[i], 0);\n+                assert_eq!(v.borrow()[i], 0);\n             }\n         });\n     }\n@@ -1605,7 +1605,7 @@ mod test_map {\n \n             DROP_VECTOR.with(|v| {\n                 for i in range(0u, 200) {\n-                    assert_eq!(v.borrow().as_slice()[i], 0);\n+                    assert_eq!(v.borrow()[i], 0);\n                 }\n             });\n \n@@ -1617,7 +1617,7 @@ mod test_map {\n \n             DROP_VECTOR.with(|v| {\n                 for i in range(0u, 200) {\n-                    assert_eq!(v.borrow().as_slice()[i], 1);\n+                    assert_eq!(v.borrow()[i], 1);\n                 }\n             });\n \n@@ -1632,19 +1632,19 @@ mod test_map {\n \n             DROP_VECTOR.with(|v| {\n                 for i in range(0u, 200) {\n-                    assert_eq!(v.borrow().as_slice()[i], 1);\n+                    assert_eq!(v.borrow()[i], 1);\n                 }\n             });\n \n             for _ in half {}\n \n             DROP_VECTOR.with(|v| {\n                 let nk = range(0u, 100).filter(|&i| {\n-                    v.borrow().as_slice()[i] == 1\n+                    v.borrow()[i] == 1\n                 }).count();\n \n                 let nv = range(0u, 100).filter(|&i| {\n-                    v.borrow().as_slice()[i+100] == 1\n+                    v.borrow()[i+100] == 1\n                 }).count();\n \n                 assert_eq!(nk, 50);\n@@ -1654,7 +1654,7 @@ mod test_map {\n \n         DROP_VECTOR.with(|v| {\n             for i in range(0u, 200) {\n-                assert_eq!(v.borrow().as_slice()[i], 0);\n+                assert_eq!(v.borrow()[i], 0);\n             }\n         });\n     }"}, {"sha": "9c9f23369e562bb18e366ad8b331520a7e5313e8", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "patch": "@@ -827,7 +827,7 @@ mod test_set {\n         };\n \n         let v = hs.into_iter().collect::<Vec<char>>();\n-        assert!(['a', 'b'][] == v.as_slice() || ['b', 'a'][] == v.as_slice());\n+        assert!(['a', 'b'] == v || ['b', 'a'] == v);\n     }\n \n     #[test]"}, {"sha": "6ed0498b0ccd142e92e876293d9578e962b4aafc", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "patch": "@@ -449,30 +449,30 @@ mod test {\n         let nread = reader.read(&mut buf);\n         assert_eq!(Ok(3), nread);\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n \n         let mut buf = [0, 0];\n         let nread = reader.read(&mut buf);\n         assert_eq!(Ok(2), nread);\n         let b: &[_] = &[0, 1];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n \n         let mut buf = [0];\n         let nread = reader.read(&mut buf);\n         assert_eq!(Ok(1), nread);\n         let b: &[_] = &[2];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n \n         let mut buf = [0, 0, 0];\n         let nread = reader.read(&mut buf);\n         assert_eq!(Ok(1), nread);\n         let b: &[_] = &[3, 0, 0];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n \n         let nread = reader.read(&mut buf);\n         assert_eq!(Ok(1), nread);\n         let b: &[_] = &[4, 0, 0];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n \n         assert!(reader.read(&mut buf).is_err());\n     }"}, {"sha": "c91769ed5035e3ee06792d39a8bb0aa8d8d0fe19", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "patch": "@@ -176,28 +176,28 @@ mod test {\n \n         assert_eq!(Ok(3), reader.read(&mut buf));\n         let a: &[u8] = &[1,2,3];\n-        assert_eq!(a, buf.as_slice());\n+        assert_eq!(a, buf);\n \n         assert_eq!(Ok(3), reader.read(&mut buf));\n         let a: &[u8] = &[4,5,6];\n-        assert_eq!(a, buf.as_slice());\n+        assert_eq!(a, buf);\n \n         assert_eq!(Ok(2), reader.read(&mut buf));\n         let a: &[u8] = &[7,8,6];\n-        assert_eq!(a, buf.as_slice());\n+        assert_eq!(a, buf);\n \n         match reader.read(buf.as_mut_slice()) {\n             Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, io::EndOfFile),\n         }\n-        assert_eq!(a, buf.as_slice());\n+        assert_eq!(a, buf);\n \n         // Ensure it continues to panic in the same way.\n         match reader.read(buf.as_mut_slice()) {\n             Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, io::EndOfFile),\n         }\n-        assert_eq!(a, buf.as_slice());\n+        assert_eq!(a, buf);\n     }\n \n     #[test]"}, {"sha": "4c7f768f7d3452c8d9b10bce37338b6163a70267", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "patch": "@@ -837,7 +837,7 @@ mod test {\n     macro_rules! error( ($e:expr, $s:expr) => (\n         match $e {\n             Ok(_) => panic!(\"Unexpected success. Should've been: {}\", $s),\n-            Err(ref err) => assert!(err.to_string().as_slice().contains($s.as_slice()),\n+            Err(ref err) => assert!(err.to_string().contains($s.as_slice()),\n                                     format!(\"`{}` did not contain `{}`\", err, $s))\n         }\n     ) )\n@@ -995,7 +995,7 @@ mod test {\n         }\n         check!(unlink(filename));\n         let read_str = str::from_utf8(&read_mem).unwrap();\n-        assert!(read_str.as_slice() == final_msg.as_slice());\n+        assert!(read_str == final_msg);\n     }\n \n     #[test]\n@@ -1103,7 +1103,7 @@ mod test {\n             let f = dir.join(format!(\"{}.txt\", n));\n             let mut w = check!(File::create(&f));\n             let msg_str = format!(\"{}{}\", prefix, n.to_string());\n-            let msg = msg_str.as_slice().as_bytes();\n+            let msg = msg_str.as_bytes();\n             check!(w.write(msg));\n         }\n         let files = check!(readdir(dir));"}, {"sha": "c48f487c95cf72e1edf82ad75ebb47b2a0e9c121", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "patch": "@@ -444,7 +444,7 @@ mod test {\n             assert_eq!(writer.write(&[10]).unwrap_err().kind, io::EndOfFile);\n         }\n         let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n     }\n \n     #[test]\n@@ -473,7 +473,7 @@ mod test {\n \n         }\n         let b: &[_] = &[1, 3, 2, 0, 0, 0, 0, 4];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n     }\n \n     #[test]\n@@ -498,12 +498,12 @@ mod test {\n         assert_eq!(reader.read(&mut buf), Ok(1));\n         assert_eq!(reader.tell(), Ok(1));\n         let b: &[_] = &[0];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n         let mut buf = [0, ..4];\n         assert_eq!(reader.read(&mut buf), Ok(4));\n         assert_eq!(reader.tell(), Ok(5));\n         let b: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n         assert_eq!(reader.read(&mut buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n         assert_eq!(buf[0..3], b);\n@@ -551,12 +551,12 @@ mod test {\n         assert_eq!(reader.read(&mut buf), Ok(1));\n         assert_eq!(reader.tell(), Ok(1));\n         let b: &[_] = &[0];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n         let mut buf = [0, ..4];\n         assert_eq!(reader.read(&mut buf), Ok(4));\n         assert_eq!(reader.tell(), Ok(5));\n         let b: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n         assert_eq!(reader.read(&mut buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n         assert_eq!(buf[0..3], b);\n@@ -652,15 +652,15 @@ mod test {\n         let mut buf = [0, ..3];\n         assert!(r.read_at_least(buf.len(), &mut buf).is_ok());\n         let b: &[_] = &[1, 2, 3];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n         assert!(r.read_at_least(0, buf[mut ..0]).is_ok());\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n         assert!(r.read_at_least(buf.len(), &mut buf).is_ok());\n         let b: &[_] = &[4, 5, 6];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n         assert!(r.read_at_least(buf.len(), &mut buf).is_err());\n         let b: &[_] = &[7, 8, 6];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(buf, b);\n     }\n \n     fn do_bench_mem_writer(b: &mut Bencher, times: uint, len: uint) {\n@@ -757,7 +757,7 @@ mod test {\n                 for _i in range(0u, 10) {\n                     let mut buf = [0 as u8, .. 10];\n                     rdr.read(&mut buf).unwrap();\n-                    assert_eq!(buf.as_slice(), [5, .. 10].as_slice());\n+                    assert_eq!(buf, [5, .. 10]);\n                 }\n             }\n         });"}, {"sha": "5a56636ffa41c6824a9c7664cd8bd6c7c798b754", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "patch": "@@ -238,8 +238,8 @@ use os;\n use boxed::Box;\n use result::{Ok, Err, Result};\n use sys;\n-use slice::{AsSlice, SlicePrelude};\n-use str::{Str, StrPrelude};\n+use slice::SlicePrelude;\n+use str::StrPrelude;\n use str;\n use string::String;\n use uint;\n@@ -316,7 +316,7 @@ impl IoError {\n     pub fn from_errno(errno: uint, detail: bool) -> IoError {\n         let mut err = sys::decode_error(errno as i32);\n         if detail && err.kind == OtherIoError {\n-            err.detail = Some(os::error_string(errno).as_slice().chars()\n+            err.detail = Some(os::error_string(errno).chars()\n                                  .map(|c| c.to_lowercase()).collect())\n         }\n         err"}, {"sha": "53c672b4302d48e599b577946ca19cf32716825d", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "patch": "@@ -236,8 +236,8 @@ impl Command {\n                 // if the env is currently just inheriting from the parent's,\n                 // materialize the parent's env into a hashtable.\n                 self.env = Some(os::env_as_bytes().into_iter()\n-                                   .map(|(k, v)| (EnvKey(k.as_slice().to_c_str()),\n-                                                  v.as_slice().to_c_str()))\n+                                   .map(|(k, v)| (EnvKey(k.to_c_str()),\n+                                                  v.to_c_str()))\n                                    .collect());\n                 self.env.as_mut().unwrap()\n             }\n@@ -973,7 +973,7 @@ mod tests {\n \n         let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n         let parent_dir = os::getcwd().unwrap();\n-        let child_dir = Path::new(output.as_slice().trim());\n+        let child_dir = Path::new(output.trim());\n \n         let parent_stat = parent_dir.stat().unwrap();\n         let child_stat = child_dir.stat().unwrap();\n@@ -991,7 +991,7 @@ mod tests {\n         let prog = pwd_cmd().cwd(&parent_dir).spawn().unwrap();\n \n         let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n-        let child_dir = Path::new(output.as_slice().trim());\n+        let child_dir = Path::new(output.trim());\n \n         let parent_stat = parent_dir.stat().unwrap();\n         let child_stat = child_dir.stat().unwrap();\n@@ -1031,8 +1031,7 @@ mod tests {\n         for &(ref k, ref v) in r.iter() {\n             // don't check windows magical empty-named variables\n             assert!(k.is_empty() ||\n-                    output.as_slice()\n-                          .contains(format!(\"{}={}\", *k, *v).as_slice()),\n+                    output.contains(format!(\"{}={}\", *k, *v).as_slice()),\n                     \"output doesn't contain `{}={}`\\n{}\",\n                     k, v, output);\n         }\n@@ -1050,12 +1049,10 @@ mod tests {\n         for &(ref k, ref v) in r.iter() {\n             // don't check android RANDOM variables\n             if *k != \"RANDOM\".to_string() {\n-                assert!(output.as_slice()\n-                              .contains(format!(\"{}={}\",\n+                assert!(output..contains(format!(\"{}={}\",\n                                                 *k,\n                                                 *v).as_slice()) ||\n-                        output.as_slice()\n-                              .contains(format!(\"{}=\\'{}\\'\",\n+                        output..contains(format!(\"{}=\\'{}\\'\",\n                                                 *k,\n                                                 *v).as_slice()));\n             }\n@@ -1084,7 +1081,7 @@ mod tests {\n         let result = prog.wait_with_output().unwrap();\n         let output = String::from_utf8_lossy(result.output.as_slice()).into_string();\n \n-        assert!(output.as_slice().contains(\"RUN_TEST_NEW_ENV=123\"),\n+        assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n     }\n \n@@ -1094,7 +1091,7 @@ mod tests {\n         let result = prog.wait_with_output().unwrap();\n         let output = String::from_utf8_lossy(result.output.as_slice()).into_string();\n \n-        assert!(output.as_slice().contains(\"RUN_TEST_NEW_ENV=123\"),\n+        assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n     }\n "}, {"sha": "89d5b7a8acd92c782add30e6586ba045b9c64359", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "patch": "@@ -542,6 +542,6 @@ mod tests {\n             panic!(\"my special message\");\n         });\n         let s = r.read_to_string().unwrap();\n-        assert!(s.as_slice().contains(\"my special message\"));\n+        assert!(s.contains(\"my special message\"));\n     }\n }"}, {"sha": "3faf7c89e63b253b05ac4ad437a70d3366911cfc", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "patch": "@@ -313,7 +313,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n         fn env_convert(input: Vec<Vec<u8>>) -> Vec<(Vec<u8>, Vec<u8>)> {\n             let mut pairs = Vec::new();\n             for p in input.iter() {\n-                let mut it = p.as_slice().splitn(1, |b| *b == b'=');\n+                let mut it = p.splitn(1, |b| *b == b'=');\n                 let key = it.next().unwrap().to_vec();\n                 let default: &[u8] = &[];\n                 let val = it.next().unwrap_or(default).to_vec();\n@@ -2066,7 +2066,7 @@ mod tests {\n     #[cfg(unix)]\n     fn join_paths_unix() {\n         fn test_eq(input: &[&str], output: &str) -> bool {\n-            join_paths(input).unwrap().as_slice() == output.as_bytes()\n+            join_paths(input).unwrap() == output.as_bytes()\n         }\n \n         assert!(test_eq(&[], \"\"));\n@@ -2081,7 +2081,7 @@ mod tests {\n     #[cfg(windows)]\n     fn join_paths_windows() {\n         fn test_eq(input: &[&str], output: &str) -> bool {\n-            join_paths(input).unwrap().as_slice() == output.as_bytes()\n+            join_paths(input).unwrap() == output.as_bytes()\n         }\n \n         assert!(test_eq(&[], \"\"));"}, {"sha": "86d55727a5a62301d33fb82e19ff39bce00b0198", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "patch": "@@ -941,6 +941,6 @@ mod tests {\n \n         let input = r\"\\foo\\bar\\baz\";\n         let path: WindowsPath = WindowsPath::new(input.to_c_str());\n-        assert_eq!(path.as_str().unwrap(), input.as_slice());\n+        assert_eq!(path.as_str().unwrap(), input);\n     }\n }"}, {"sha": "e76d2ed169dedbc6ae032834b49d51fd588dda9d", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "patch": "@@ -131,7 +131,7 @@ impl GenericPathUnsafe for Path {\n     unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {\n         let filename = filename.container_as_bytes();\n         match self.sepidx {\n-            None if b\"..\" == self.repr.as_slice() => {\n+            None if b\"..\" == self.repr => {\n                 let mut v = Vec::with_capacity(3 + filename.len());\n                 v.push_all(dot_dot_static);\n                 v.push(SEP_BYTE);\n@@ -158,7 +158,7 @@ impl GenericPathUnsafe for Path {\n                 self.repr = Path::normalize(v.as_slice());\n             }\n         }\n-        self.sepidx = self.repr.as_slice().rposition_elem(&SEP_BYTE);\n+        self.sepidx = self.repr.rposition_elem(&SEP_BYTE);\n     }\n \n     unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) {\n@@ -174,7 +174,7 @@ impl GenericPathUnsafe for Path {\n                 // FIXME: this is slow\n                 self.repr = Path::normalize(v.as_slice());\n             }\n-            self.sepidx = self.repr.as_slice().rposition_elem(&SEP_BYTE);\n+            self.sepidx = self.repr.rposition_elem(&SEP_BYTE);\n         }\n     }\n }\n@@ -191,7 +191,7 @@ impl GenericPath for Path {\n \n     fn dirname<'a>(&'a self) -> &'a [u8] {\n         match self.sepidx {\n-            None if b\"..\" == self.repr.as_slice() => self.repr.as_slice(),\n+            None if b\"..\" == self.repr => self.repr.as_slice(),\n             None => dot_static,\n             Some(0) => self.repr[..1],\n             Some(idx) if self.repr[idx+1..] == b\"..\" => self.repr.as_slice(),\n@@ -201,8 +201,8 @@ impl GenericPath for Path {\n \n     fn filename<'a>(&'a self) -> Option<&'a [u8]> {\n         match self.sepidx {\n-            None if b\".\" == self.repr.as_slice() ||\n-                b\"..\" == self.repr.as_slice() => None,\n+            None if b\".\" == self.repr ||\n+                b\"..\" == self.repr => None,\n             None => Some(self.repr.as_slice()),\n             Some(idx) if self.repr[idx+1..] == b\"..\" => None,\n             Some(0) if self.repr[1..].is_empty() => None,\n@@ -212,20 +212,20 @@ impl GenericPath for Path {\n \n     fn pop(&mut self) -> bool {\n         match self.sepidx {\n-            None if b\".\" == self.repr.as_slice() => false,\n+            None if b\".\" == self.repr => false,\n             None => {\n                 self.repr = vec![b'.'];\n                 self.sepidx = None;\n                 true\n             }\n-            Some(0) if b\"/\" == self.repr.as_slice() => false,\n+            Some(0) if b\"/\" == self.repr => false,\n             Some(idx) => {\n                 if idx == 0 {\n                     self.repr.truncate(idx+1);\n                 } else {\n                     self.repr.truncate(idx);\n                 }\n-                self.sepidx = self.repr.as_slice().rposition_elem(&SEP_BYTE);\n+                self.sepidx = self.repr.rposition_elem(&SEP_BYTE);\n                 true\n             }\n         }\n@@ -250,7 +250,7 @@ impl GenericPath for Path {\n         } else {\n             let mut ita = self.components();\n             let mut itb = other.components();\n-            if b\".\" == self.repr.as_slice() {\n+            if b\".\" == self.repr {\n                 return match itb.next() {\n                     None => true,\n                     Some(b) => b != b\"..\"\n@@ -305,7 +305,7 @@ impl GenericPath for Path {\n                     }\n                 }\n             }\n-            Some(Path::new(comps.as_slice().connect_vec(&SEP_BYTE)))\n+            Some(Path::new(comps.connect_vec(&SEP_BYTE)))\n         }\n     }\n \n@@ -406,7 +406,7 @@ impl Path {\n \n // None result means the byte vector didn't need normalizing\n fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<Vec<&'a [u8]>> {\n-    if is_abs && v.as_slice().is_empty() {\n+    if is_abs && v.is_empty() {\n         return None;\n     }\n     let mut comps: Vec<&'a [u8]> = vec![];\n@@ -495,8 +495,8 @@ mod tests {\n         t!(s: Path::new(\"foo/../../..\"), \"../..\");\n         t!(s: Path::new(\"foo/../../bar\"), \"../bar\");\n \n-        assert_eq!(Path::new(b\"foo/bar\").into_vec().as_slice(), b\"foo/bar\");\n-        assert_eq!(Path::new(b\"/foo/../../bar\").into_vec().as_slice(),\n+        assert_eq!(Path::new(b\"foo/bar\").into_vec(), b\"foo/bar\");\n+        assert_eq!(Path::new(b\"/foo/../../bar\").into_vec(),\n                    b\"/bar\");\n \n         let p = Path::new(b\"foo/bar\\x80\");\n@@ -536,7 +536,7 @@ mod tests {\n             ($path:expr, $disp:ident, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n-                    assert!(path.$disp().to_string().as_slice() == $exp);\n+                    assert!(path.$disp().to_string() == $exp);\n                 }\n             )\n         )\n@@ -579,9 +579,9 @@ mod tests {\n                 {\n                     let path = Path::new($path);\n                     let f = format!(\"{}\", path.display());\n-                    assert!(f.as_slice() == $exp);\n+                    assert!(f == $exp);\n                     let f = format!(\"{}\", path.filename_display());\n-                    assert!(f.as_slice() == $expf);\n+                    assert!(f == $expf);\n                 }\n             )\n         )\n@@ -1179,7 +1179,7 @@ mod tests {\n                     let path = Path::new($arg);\n                     let comps = path.components().collect::<Vec<&[u8]>>();\n                     let exp: &[&[u8]] = &[$($exp),*];\n-                    assert_eq!(comps.as_slice(), exp);\n+                    assert_eq!(comps, exp);\n                     let comps = path.components().rev().collect::<Vec<&[u8]>>();\n                     let exp = exp.iter().rev().map(|&x|x).collect::<Vec<&[u8]>>();\n                     assert_eq!(comps, exp)\n@@ -1211,7 +1211,7 @@ mod tests {\n                     let path = Path::new($arg);\n                     let comps = path.str_components().collect::<Vec<Option<&str>>>();\n                     let exp: &[Option<&str>] = &$exp;\n-                    assert_eq!(comps.as_slice(), exp);\n+                    assert_eq!(comps, exp);\n                     let comps = path.str_components().rev().collect::<Vec<Option<&str>>>();\n                     let exp = exp.iter().rev().map(|&x|x).collect::<Vec<Option<&str>>>();\n                     assert_eq!(comps, exp);"}, {"sha": "366e3125c65878aa283ecf28d0844658775a60b0", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "patch": "@@ -181,7 +181,7 @@ impl GenericPathUnsafe for Path {\n     unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {\n         let filename = filename.container_as_str().unwrap();\n         match self.sepidx_or_prefix_len() {\n-            None if \"..\" == self.repr.as_slice() => {\n+            None if \"..\" == self.repr => {\n                 let mut s = String::with_capacity(3 + filename.len());\n                 s.push_str(\"..\");\n                 s.push(SEP);\n@@ -191,22 +191,22 @@ impl GenericPathUnsafe for Path {\n             None => {\n                 self.update_normalized(filename);\n             }\n-            Some((_,idxa,end)) if self.repr.as_slice().slice(idxa,end) == \"..\" => {\n+            Some((_,idxa,end)) if self.repr.slice(idxa,end) == \"..\" => {\n                 let mut s = String::with_capacity(end + 1 + filename.len());\n-                s.push_str(self.repr.as_slice().slice_to(end));\n+                s.push_str(self.repr.slice_to(end));\n                 s.push(SEP);\n                 s.push_str(filename);\n                 self.update_normalized(s);\n             }\n             Some((idxb,idxa,_)) if self.prefix == Some(DiskPrefix) && idxa == self.prefix_len() => {\n                 let mut s = String::with_capacity(idxb + filename.len());\n-                s.push_str(self.repr.as_slice().slice_to(idxb));\n+                s.push_str(self.repr.slice_to(idxb));\n                 s.push_str(filename);\n                 self.update_normalized(s);\n             }\n             Some((idxb,_,_)) => {\n                 let mut s = String::with_capacity(idxb + 1 + filename.len());\n-                s.push_str(self.repr.as_slice().slice_to(idxb));\n+                s.push_str(self.repr.slice_to(idxb));\n                 s.push(SEP);\n                 s.push_str(filename);\n                 self.update_normalized(s);\n@@ -355,21 +355,21 @@ impl GenericPath for Path {\n     /// Always returns a `Some` value.\n     fn dirname_str<'a>(&'a self) -> Option<&'a str> {\n         Some(match self.sepidx_or_prefix_len() {\n-            None if \"..\" == self.repr.as_slice() => self.repr.as_slice(),\n+            None if \"..\" == self.repr => self.repr.as_slice(),\n             None => \".\",\n-            Some((_,idxa,end)) if self.repr.as_slice().slice(idxa, end) == \"..\" => {\n+            Some((_,idxa,end)) if self.repr.slice(idxa, end) == \"..\" => {\n                 self.repr.as_slice()\n             }\n-            Some((idxb,_,end)) if self.repr.as_slice().slice(idxb, end) == \"\\\\\" => {\n+            Some((idxb,_,end)) if self.repr.slice(idxb, end) == \"\\\\\" => {\n                 self.repr.as_slice()\n             }\n-            Some((0,idxa,_)) => self.repr.as_slice().slice_to(idxa),\n+            Some((0,idxa,_)) => self.repr.slice_to(idxa),\n             Some((idxb,idxa,_)) => {\n                 match self.prefix {\n                     Some(DiskPrefix) | Some(VerbatimDiskPrefix) if idxb == self.prefix_len() => {\n-                        self.repr.as_slice().slice_to(idxa)\n+                        self.repr.slice_to(idxa)\n                     }\n-                    _ => self.repr.as_slice().slice_to(idxb)\n+                    _ => self.repr.slice_to(idxb)\n                 }\n             }\n         })\n@@ -414,14 +414,14 @@ impl GenericPath for Path {\n     #[inline]\n     fn pop(&mut self) -> bool {\n         match self.sepidx_or_prefix_len() {\n-            None if \".\" == self.repr.as_slice() => false,\n+            None if \".\" == self.repr => false,\n             None => {\n                 self.repr = String::from_str(\".\");\n                 self.sepidx = None;\n                 true\n             }\n             Some((idxb,idxa,end)) if idxb == idxa && idxb == end => false,\n-            Some((idxb,_,end)) if self.repr.as_slice().slice(idxb, end) == \"\\\\\" => false,\n+            Some((idxb,_,end)) if self.repr.slice(idxb, end) == \"\\\\\" => false,\n             Some((idxb,idxa,_)) => {\n                 let trunc = match self.prefix {\n                     Some(DiskPrefix) | Some(VerbatimDiskPrefix) | None => {\n@@ -441,15 +441,15 @@ impl GenericPath for Path {\n         if self.prefix.is_some() {\n             Some(Path::new(match self.prefix {\n                 Some(DiskPrefix) if self.is_absolute() => {\n-                    self.repr.as_slice().slice_to(self.prefix_len()+1)\n+                    self.repr.slice_to(self.prefix_len()+1)\n                 }\n                 Some(VerbatimDiskPrefix) => {\n-                    self.repr.as_slice().slice_to(self.prefix_len()+1)\n+                    self.repr.slice_to(self.prefix_len()+1)\n                 }\n-                _ => self.repr.as_slice().slice_to(self.prefix_len())\n+                _ => self.repr.slice_to(self.prefix_len())\n             }))\n         } else if is_vol_relative(self) {\n-            Some(Path::new(self.repr.as_slice().slice_to(1)))\n+            Some(Path::new(self.repr.slice_to(1)))\n         } else {\n             None\n         }\n@@ -468,7 +468,7 @@ impl GenericPath for Path {\n     fn is_absolute(&self) -> bool {\n         match self.prefix {\n             Some(DiskPrefix) => {\n-                let rest = self.repr.as_slice().slice_from(self.prefix_len());\n+                let rest = self.repr.slice_from(self.prefix_len());\n                 rest.len() > 0 && rest.as_bytes()[0] == SEP_BYTE\n             }\n             Some(_) => true,\n@@ -490,7 +490,7 @@ impl GenericPath for Path {\n         } else {\n             let mut ita = self.str_components().map(|x|x.unwrap());\n             let mut itb = other.str_components().map(|x|x.unwrap());\n-            if \".\" == self.repr.as_slice() {\n+            if \".\" == self.repr {\n                 return itb.next() != Some(\"..\");\n             }\n             loop {\n@@ -826,7 +826,7 @@ impl Path {\n \n     fn update_sepidx(&mut self) {\n         let s = if self.has_nonsemantic_trailing_slash() {\n-                    self.repr.as_slice().slice_to(self.repr.len()-1)\n+                    self.repr.slice_to(self.repr.len()-1)\n                 } else { self.repr.as_slice() };\n         let idx = s.rfind(if !prefix_is_verbatim(self.prefix) { is_sep }\n                           else { is_sep_verbatim });\n@@ -922,7 +922,7 @@ pub fn make_non_verbatim(path: &Path) -> Option<Path> {\n     }\n     // now ensure normalization didn't change anything\n     if repr.slice_from(path.prefix_len()) ==\n-        new_path.repr.as_slice().slice_from(new_path.prefix_len()) {\n+        new_path.repr.slice_from(new_path.prefix_len()) {\n         Some(new_path)\n     } else {\n         None\n@@ -1232,8 +1232,8 @@ mod tests {\n         t!(s: Path::new(\"foo\\\\..\\\\..\\\\..\"), \"..\\\\..\");\n         t!(s: Path::new(\"foo\\\\..\\\\..\\\\bar\"), \"..\\\\bar\");\n \n-        assert_eq!(Path::new(b\"foo\\\\bar\").into_vec().as_slice(), b\"foo\\\\bar\");\n-        assert_eq!(Path::new(b\"\\\\foo\\\\..\\\\..\\\\bar\").into_vec().as_slice(), b\"\\\\bar\");\n+        assert_eq!(Path::new(b\"foo\\\\bar\").into_vec(), b\"foo\\\\bar\");\n+        assert_eq!(Path::new(b\"\\\\foo\\\\..\\\\..\\\\bar\").into_vec(), b\"\\\\bar\");\n \n         t!(s: Path::new(\"\\\\\\\\a\"), \"\\\\a\");\n         t!(s: Path::new(\"\\\\\\\\a\\\\\"), \"\\\\a\");\n@@ -1340,9 +1340,9 @@ mod tests {\n                 {\n                     let path = Path::new($path);\n                     let f = format!(\"{}\", path.display());\n-                    assert_eq!(f.as_slice(), $exp);\n+                    assert_eq!(f, $exp);\n                     let f = format!(\"{}\", path.filename_display());\n-                    assert_eq!(f.as_slice(), $expf);\n+                    assert_eq!(f, $expf);\n                 }\n             )\n         )\n@@ -2245,7 +2245,7 @@ mod tests {\n                     let comps = path.str_components().map(|x|x.unwrap())\n                                 .collect::<Vec<&str>>();\n                     let exp: &[&str] = &$exp;\n-                    assert_eq!(comps.as_slice(), exp);\n+                    assert_eq!(comps, exp);\n                     let comps = path.str_components().rev().map(|x|x.unwrap())\n                                 .collect::<Vec<&str>>();\n                     let exp = exp.iter().rev().map(|&x|x).collect::<Vec<&str>>();\n@@ -2302,7 +2302,7 @@ mod tests {\n                     let path = Path::new($path);\n                     let comps = path.components().collect::<Vec<&[u8]>>();\n                     let exp: &[&[u8]] = &$exp;\n-                    assert_eq!(comps.as_slice(), exp);\n+                    assert_eq!(comps, exp);\n                     let comps = path.components().rev().collect::<Vec<&[u8]>>();\n                     let exp = exp.iter().rev().map(|&x|x).collect::<Vec<&[u8]>>();\n                     assert_eq!(comps, exp);"}, {"sha": "c8030b026d19c2425271c78a14b4b44237ead3ae", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "patch": "@@ -529,7 +529,7 @@ mod test {\n         let mut one = [1i];\n         r.shuffle(&mut one);\n         let b: &[_] = &[1];\n-        assert_eq!(one.as_slice(), b);\n+        assert_eq!(one, b);\n \n         let mut two = [1i, 2];\n         r.shuffle(&mut two);\n@@ -538,7 +538,7 @@ mod test {\n         let mut x = [1i, 1, 1];\n         r.shuffle(&mut x);\n         let b: &[_] = &[1, 1, 1];\n-        assert_eq!(x.as_slice(), b);\n+        assert_eq!(x, b);\n     }\n \n     #[test]\n@@ -548,7 +548,7 @@ mod test {\n         let mut v = [1i, 1, 1];\n         r.shuffle(&mut v);\n         let b: &[_] = &[1, 1, 1];\n-        assert_eq!(v.as_slice(), b);\n+        assert_eq!(v, b);\n         assert_eq!(r.gen_range(0u, 1u), 0u);\n     }\n "}, {"sha": "16779a80185bc8c8aababbfd1ae82368c69ed225", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "patch": "@@ -376,8 +376,8 @@ pub fn readlink(p: &Path) -> IoResult<Path> {\n                                   libc::VOLUME_NAME_DOS)\n     });\n     let ret = match ret {\n-        Some(ref s) if s.as_slice().starts_with(r\"\\\\?\\\") => { // \"\n-            Ok(Path::new(s.as_slice().slice_from(4)))\n+        Some(ref s) if s.starts_with(r\"\\\\?\\\") => { // \"\n+            Ok(Path::new(s.slice_from(4)))\n         }\n         Some(s) => Ok(Path::new(s)),\n         None => Err(super::last_error()),"}, {"sha": "2af5e4890e849600fb7167d66a6adea0d05cc598", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "patch": "@@ -223,7 +223,7 @@ impl Process {\n \n             with_envp(cfg.env(), |envp| {\n                 with_dirp(cfg.cwd(), |dirp| {\n-                    let mut cmd_str: Vec<u16> = cmd_str.as_slice().utf16_units().collect();\n+                    let mut cmd_str: Vec<u16> = cmd_str.utf16_units().collect();\n                     cmd_str.push(0);\n                     let created = CreateProcessW(ptr::null(),\n                                                  cmd_str.as_mut_ptr(),\n@@ -433,7 +433,7 @@ fn with_envp<K, V, T>(env: Option<&collections::HashMap<K, V>>,\n                 let kv = format!(\"{}={}\",\n                                  pair.ref0().container_as_str().unwrap(),\n                                  pair.ref1().container_as_str().unwrap());\n-                blk.extend(kv.as_slice().utf16_units());\n+                blk.extend(kv.utf16_units());\n                 blk.push(0);\n             }\n "}, {"sha": "51679bb2003fc8e3a42b27b0a536e62ff3d4dae9", "filename": "src/libstd/sys/windows/tty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "patch": "@@ -113,7 +113,7 @@ impl TTY {\n     pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let utf16 = match from_utf8(buf) {\n             Some(utf8) => {\n-                utf8.as_slice().utf16_units().collect::<Vec<u16>>()\n+                utf8.utf16_units().collect::<Vec<u16>>()\n             }\n             None => return Err(invalid_encoding()),\n         };"}, {"sha": "c433dfa08f4f62d5c408907caa5d72a46307bc48", "filename": "src/libstd/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "patch": "@@ -54,7 +54,7 @@ use result::Result;\n use rustrt::local::Local;\n use rustrt::task::Task;\n use rustrt::task;\n-use str::{Str, SendStr};\n+use str::SendStr;\n use string::{String, ToString};\n use sync::Future;\n \n@@ -242,7 +242,7 @@ pub fn name() -> Option<String> {\n \n     let task = Local::borrow(None::<Task>);\n     match task.name {\n-        Some(ref name) => Some(name.as_slice().to_string()),\n+        Some(ref name) => Some(name.to_string()),\n         None => None\n     }\n }"}]}