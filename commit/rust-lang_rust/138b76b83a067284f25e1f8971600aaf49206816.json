{"sha": "138b76b83a067284f25e1f8971600aaf49206816", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzOGI3NmI4M2EwNjcyODRmMjVlMWY4OTcxNjAwYWFmNDkyMDY4MTY=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-11-02T06:27:11Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-11-03T13:20:37Z"}, "message": "Separate string->integer implementation in strconv", "tree": {"sha": "665ec1e0cd002e3e7e87c64bb8e5fd96da3ea7ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/665ec1e0cd002e3e7e87c64bb8e5fd96da3ea7ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/138b76b83a067284f25e1f8971600aaf49206816", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/138b76b83a067284f25e1f8971600aaf49206816", "html_url": "https://github.com/rust-lang/rust/commit/138b76b83a067284f25e1f8971600aaf49206816", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/138b76b83a067284f25e1f8971600aaf49206816/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3327ecca422046699315122345c6c050ab73804b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3327ecca422046699315122345c6c050ab73804b", "html_url": "https://github.com/rust-lang/rust/commit/3327ecca422046699315122345c6c050ab73804b"}], "stats": {"total": 327, "additions": 138, "deletions": 189}, "files": [{"sha": "fa8f7c9ad939c1851c1b52940a2ca6f20b689720", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/138b76b83a067284f25e1f8971600aaf49206816/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138b76b83a067284f25e1f8971600aaf49206816/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=138b76b83a067284f25e1f8971600aaf49206816", "patch": "@@ -36,7 +36,7 @@ use std::io::extensions::u64_from_be_bytes;\n use std::io;\n use std::collections::hashmap::HashMap;\n use std::rc::Rc;\n-use std::u64;\n+use std::str;\n use rbml::reader;\n use rbml;\n use serialize::Decodable;\n@@ -215,7 +215,9 @@ fn each_reexport(d: rbml::Doc, f: |rbml::Doc| -> bool) -> bool {\n \n fn variant_disr_val(d: rbml::Doc) -> Option<ty::Disr> {\n     reader::maybe_get_doc(d, tag_disr_val).and_then(|val_doc| {\n-        reader::with_doc_data(val_doc, |data| u64::parse_bytes(data, 10u))\n+        reader::with_doc_data(val_doc, |data| {\n+            str::from_utf8(data).and_then(from_str)\n+        })\n     })\n }\n "}, {"sha": "6e7a6dfa0944898a46eecda2a23785eb5fdc95ae", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/138b76b83a067284f25e1f8971600aaf49206816/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138b76b83a067284f25e1f8971600aaf49206816/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=138b76b83a067284f25e1f8971600aaf49206816", "patch": "@@ -23,7 +23,6 @@ use middle::ty;\n use std::rc::Rc;\n use std::str;\n use std::string::String;\n-use std::uint;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast::*;\n@@ -615,12 +614,12 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     let crate_part = buf[0u..colon_idx];\n     let def_part = buf[colon_idx + 1u..len];\n \n-    let crate_num = match uint::parse_bytes(crate_part, 10u) {\n+    let crate_num = match str::from_utf8(crate_part).and_then(from_str::<uint>) {\n        Some(cn) => cn as ast::CrateNum,\n        None => panic!(\"internal error: parse_def_id: crate number expected, found {}\",\n                      crate_part)\n     };\n-    let def_num = match uint::parse_bytes(def_part, 10u) {\n+    let def_num = match str::from_utf8(def_part).and_then(from_str::<uint>) {\n        Some(dn) => dn as ast::NodeId,\n        None => panic!(\"internal error: parse_def_id: id expected, found {}\",\n                      def_part)"}, {"sha": "87c28c9362c639b1cea3114ca59e7d21ed30c1e2", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/138b76b83a067284f25e1f8971600aaf49206816/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138b76b83a067284f25e1f8971600aaf49206816/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=138b76b83a067284f25e1f8971600aaf49206816", "patch": "@@ -361,7 +361,7 @@ pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n #[inline]\n pub fn from_str_hex(num: &str) -> Option<f32> {\n     strconv::from_str_common(num, 16u, true, true, true,\n-                             strconv::ExpBin, false, false)\n+                             strconv::ExpBin, false)\n }\n \n impl FromStr for f32 {\n@@ -393,7 +393,7 @@ impl FromStr for f32 {\n     #[inline]\n     fn from_str(val: &str) -> Option<f32> {\n         strconv::from_str_common(val, 10u, true, true, true,\n-                                 strconv::ExpDec, false, false)\n+                                 strconv::ExpDec, false)\n     }\n }\n \n@@ -418,7 +418,7 @@ impl num::FromStrRadix for f32 {\n     #[inline]\n     fn from_str_radix(val: &str, rdx: uint) -> Option<f32> {\n         strconv::from_str_common(val, rdx, true, true, false,\n-                                 strconv::ExpNone, false, false)\n+                                 strconv::ExpNone, false)\n     }\n }\n "}, {"sha": "907c860f6a39fa0e63737304a46f38c80525c787", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/138b76b83a067284f25e1f8971600aaf49206816/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138b76b83a067284f25e1f8971600aaf49206816/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=138b76b83a067284f25e1f8971600aaf49206816", "patch": "@@ -369,7 +369,7 @@ pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n #[inline]\n pub fn from_str_hex(num: &str) -> Option<f64> {\n     strconv::from_str_common(num, 16u, true, true, true,\n-                             strconv::ExpBin, false, false)\n+                             strconv::ExpBin, false)\n }\n \n impl FromStr for f64 {\n@@ -401,7 +401,7 @@ impl FromStr for f64 {\n     #[inline]\n     fn from_str(val: &str) -> Option<f64> {\n         strconv::from_str_common(val, 10u, true, true, true,\n-                                 strconv::ExpDec, false, false)\n+                                 strconv::ExpDec, false)\n     }\n }\n \n@@ -426,7 +426,7 @@ impl num::FromStrRadix for f64 {\n     #[inline]\n     fn from_str_radix(val: &str, rdx: uint) -> Option<f64> {\n         strconv::from_str_common(val, rdx, true, true, false,\n-                                 strconv::ExpNone, false, false)\n+                                 strconv::ExpNone, false)\n     }\n }\n "}, {"sha": "9ae146c840ae884b96e31139013061888bed6a54", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 35, "deletions": 59, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/138b76b83a067284f25e1f8971600aaf49206816/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138b76b83a067284f25e1f8971600aaf49206816/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=138b76b83a067284f25e1f8971600aaf49206816", "patch": "@@ -14,50 +14,26 @@\n \n macro_rules! int_module (($T:ty) => (\n \n-// String conversion functions and impl str -> num\n-\n-/// Parse a byte slice as a number in the given base\n-///\n-/// Yields an `Option` because `buf` may or may not actually be parseable.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// let num = std::i64::parse_bytes([49,50,51,52,53,54,55,56,57], 10);\n-/// assert!(num == Some(123456789));\n-/// ```\n-#[inline]\n-#[experimental = \"might need to return Result\"]\n-pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<$T> {\n-    strconv::from_str_bytes_common(buf, radix, true, false, false,\n-                               strconv::ExpNone, false, false)\n-}\n-\n #[experimental = \"might need to return Result\"]\n impl FromStr for $T {\n     #[inline]\n     fn from_str(s: &str) -> Option<$T> {\n-        strconv::from_str_common(s, 10u, true, false, false,\n-                             strconv::ExpNone, false, false)\n+        strconv::from_str_radix_int(s, 10)\n     }\n }\n \n #[experimental = \"might need to return Result\"]\n impl FromStrRadix for $T {\n     #[inline]\n     fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n-        strconv::from_str_common(s, radix, true, false, false,\n-                             strconv::ExpNone, false, false)\n+        strconv::from_str_radix_int(s, radix)\n     }\n }\n \n #[cfg(test)]\n mod tests {\n     use prelude::*;\n-    use super::*;\n-\n-    use i32;\n-    use str::StrSlice;\n+    use num::FromStrRadix;\n \n     #[test]\n     fn test_from_str() {\n@@ -73,33 +49,33 @@ mod tests {\n         assert_eq!(from_str::<i32>(\"-123456789\"), Some(-123456789 as i32));\n         assert_eq!(from_str::<$T>(\"-00100\"), Some(-100 as $T));\n \n-        assert!(from_str::<$T>(\" \").is_none());\n-        assert!(from_str::<$T>(\"x\").is_none());\n+        assert_eq!(from_str::<$T>(\"\"), None);\n+        assert_eq!(from_str::<$T>(\" \"), None);\n+        assert_eq!(from_str::<$T>(\"x\"), None);\n     }\n \n     #[test]\n-    fn test_parse_bytes() {\n-        use str::StrSlice;\n-        assert_eq!(parse_bytes(\"123\".as_bytes(), 10u), Some(123 as $T));\n-        assert_eq!(parse_bytes(\"1001\".as_bytes(), 2u), Some(9 as $T));\n-        assert_eq!(parse_bytes(\"123\".as_bytes(), 8u), Some(83 as $T));\n-        assert_eq!(i32::parse_bytes(\"123\".as_bytes(), 16u), Some(291 as i32));\n-        assert_eq!(i32::parse_bytes(\"ffff\".as_bytes(), 16u), Some(65535 as i32));\n-        assert_eq!(i32::parse_bytes(\"FFFF\".as_bytes(), 16u), Some(65535 as i32));\n-        assert_eq!(parse_bytes(\"z\".as_bytes(), 36u), Some(35 as $T));\n-        assert_eq!(parse_bytes(\"Z\".as_bytes(), 36u), Some(35 as $T));\n-\n-        assert_eq!(parse_bytes(\"-123\".as_bytes(), 10u), Some(-123 as $T));\n-        assert_eq!(parse_bytes(\"-1001\".as_bytes(), 2u), Some(-9 as $T));\n-        assert_eq!(parse_bytes(\"-123\".as_bytes(), 8u), Some(-83 as $T));\n-        assert_eq!(i32::parse_bytes(\"-123\".as_bytes(), 16u), Some(-291 as i32));\n-        assert_eq!(i32::parse_bytes(\"-ffff\".as_bytes(), 16u), Some(-65535 as i32));\n-        assert_eq!(i32::parse_bytes(\"-FFFF\".as_bytes(), 16u), Some(-65535 as i32));\n-        assert_eq!(parse_bytes(\"-z\".as_bytes(), 36u), Some(-35 as $T));\n-        assert_eq!(parse_bytes(\"-Z\".as_bytes(), 36u), Some(-35 as $T));\n-\n-        assert!(parse_bytes(\"Z\".as_bytes(), 35u).is_none());\n-        assert!(parse_bytes(\"-9\".as_bytes(), 2u).is_none());\n+    fn test_from_str_radix() {\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Some(123 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Some(9 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Some(83 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Some(291 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Some(65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"FFFF\", 16), Some(65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Some(35 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 36), Some(35 as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 10), Some(-123 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-1001\", 2), Some(-9 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 8), Some(-83 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 16), Some(-291 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-ffff\", 16), Some(-65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-FFFF\", 16), Some(-65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-z\", 36), Some(-35 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-Z\", 36), Some(-35 as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 35), None::<$T>);\n+        assert_eq!(FromStrRadix::from_str_radix(\"-9\", 2), None::<$T>);\n     }\n \n     #[test]\n@@ -133,35 +109,35 @@ mod tests {\n     fn test_int_from_str_overflow() {\n         let mut i8_val: i8 = 127_i8;\n         assert_eq!(from_str::<i8>(\"127\"), Some(i8_val));\n-        assert!(from_str::<i8>(\"128\").is_none());\n+        assert_eq!(from_str::<i8>(\"128\"), None);\n \n         i8_val += 1 as i8;\n         assert_eq!(from_str::<i8>(\"-128\"), Some(i8_val));\n-        assert!(from_str::<i8>(\"-129\").is_none());\n+        assert_eq!(from_str::<i8>(\"-129\"), None);\n \n         let mut i16_val: i16 = 32_767_i16;\n         assert_eq!(from_str::<i16>(\"32767\"), Some(i16_val));\n-        assert!(from_str::<i16>(\"32768\").is_none());\n+        assert_eq!(from_str::<i16>(\"32768\"), None);\n \n         i16_val += 1 as i16;\n         assert_eq!(from_str::<i16>(\"-32768\"), Some(i16_val));\n-        assert!(from_str::<i16>(\"-32769\").is_none());\n+        assert_eq!(from_str::<i16>(\"-32769\"), None);\n \n         let mut i32_val: i32 = 2_147_483_647_i32;\n         assert_eq!(from_str::<i32>(\"2147483647\"), Some(i32_val));\n-        assert!(from_str::<i32>(\"2147483648\").is_none());\n+        assert_eq!(from_str::<i32>(\"2147483648\"), None);\n \n         i32_val += 1 as i32;\n         assert_eq!(from_str::<i32>(\"-2147483648\"), Some(i32_val));\n-        assert!(from_str::<i32>(\"-2147483649\").is_none());\n+        assert_eq!(from_str::<i32>(\"-2147483649\"), None);\n \n         let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n         assert_eq!(from_str::<i64>(\"9223372036854775807\"), Some(i64_val));\n-        assert!(from_str::<i64>(\"9223372036854775808\").is_none());\n+        assert_eq!(from_str::<i64>(\"9223372036854775808\"), None);\n \n         i64_val += 1 as i64;\n         assert_eq!(from_str::<i64>(\"-9223372036854775808\"), Some(i64_val));\n-        assert!(from_str::<i64>(\"-9223372036854775809\").is_none());\n+        assert_eq!(from_str::<i64>(\"-9223372036854775809\"), None);\n     }\n }\n "}, {"sha": "1e70a0e571cf99cab870549ef76c66ee8261f647", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 67, "deletions": 68, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/138b76b83a067284f25e1f8971600aaf49206816/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138b76b83a067284f25e1f8971600aaf49206816/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=138b76b83a067284f25e1f8971600aaf49206816", "patch": "@@ -13,15 +13,18 @@\n #![allow(missing_docs)]\n \n use char;\n+use char::Char;\n use clone::Clone;\n-use num::{NumCast, Zero, One, cast, Int};\n+use from_str::from_str;\n+use iter::Iterator;\n+use num::{NumCast, Zero, One, cast, Int, Bounded};\n use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n use num;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use option::{None, Option, Some};\n use slice::{ImmutableSlice, MutableSlice, CloneableVector};\n use std::cmp::{PartialOrd, PartialEq};\n-use str::StrSlice;\n+use str::{Str, StrSlice};\n use string::String;\n use vec::Vec;\n \n@@ -106,35 +109,11 @@ macro_rules! impl_NumStrConv_Floating (($t:ty) => (\n     }\n ))\n \n-macro_rules! impl_NumStrConv_Integer (($t:ty) => (\n-    impl NumStrConv for $t {\n-        #[inline] fn nan()      -> Option<$t> { None }\n-        #[inline] fn inf()      -> Option<$t> { None }\n-        #[inline] fn neg_inf()  -> Option<$t> { None }\n-        #[inline] fn neg_zero() -> Option<$t> { None }\n-\n-        #[inline] fn round_to_zero(&self)   -> $t { *self }\n-        #[inline] fn fractional_part(&self) -> $t {     0 }\n-    }\n-))\n-\n // FIXME: #4955\n // Replace by two generic impls for traits 'Integral' and 'Floating'\n impl_NumStrConv_Floating!(f32)\n impl_NumStrConv_Floating!(f64)\n \n-impl_NumStrConv_Integer!(int)\n-impl_NumStrConv_Integer!(i8)\n-impl_NumStrConv_Integer!(i16)\n-impl_NumStrConv_Integer!(i32)\n-impl_NumStrConv_Integer!(i64)\n-\n-impl_NumStrConv_Integer!(uint)\n-impl_NumStrConv_Integer!(u8)\n-impl_NumStrConv_Integer!(u16)\n-impl_NumStrConv_Integer!(u32)\n-impl_NumStrConv_Integer!(u64)\n-\n \n // Special value strings as [u8] consts.\n static INF_BUF:     [u8, ..3] = [b'i', b'n', b'f'];\n@@ -526,8 +505,6 @@ static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n  *                  `FFp128`. The exponent string itself is always base 10.\n  *                  Can conflict with `radix`, see Failure.\n  * - `empty_zero` - Whether to accept an empty `buf` as a 0 or not.\n- * - `ignore_underscores` - Whether all underscores within the string should\n- *                          be ignored.\n  *\n  * # Return value\n  * Returns `Some(n)` if `buf` parses to a number n without overflowing, and\n@@ -548,7 +525,6 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+\n                                     NumStrConv+Clone>(\n         buf: &[u8], radix: uint, negative: bool, fractional: bool,\n         special: bool, exponent: ExponentFormat, empty_zero: bool,\n-        ignore_underscores: bool\n         ) -> Option<T> {\n     match exponent {\n         ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n@@ -646,7 +622,6 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+\n                 last_accum = accum.clone();\n             }\n             None => match c {\n-                '_' if ignore_underscores => {}\n                 'e' | 'E' | 'p' | 'P' => {\n                     exp_found = true;\n                     break;                       // start of exponent\n@@ -690,7 +665,6 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+\n                     last_accum = accum.clone();\n                 }\n                 None => match c {\n-                    '_' if ignore_underscores => {}\n                     'e' | 'E' | 'p' | 'P' => {\n                         exp_found = true;\n                         break;                   // start of exponent\n@@ -726,9 +700,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+\n \n         // parse remaining bytes as decimal integer,\n         // skipping the exponent char\n-        let exp: Option<int> = from_str_bytes_common(\n-            buf[i+1..len], 10, true, false, false, ExpNone, false,\n-            ignore_underscores);\n+        let exp = from_str::<int>(String::from_utf8_lossy(buf[i+1..len]).as_slice());\n \n         match exp {\n             Some(exp_pow) => {\n@@ -754,57 +726,84 @@ pub fn from_str_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+Mul<T,T>\n                               Sub<T,T>+Neg<T>+Add<T,T>+NumStrConv+Clone>(\n         buf: &str, radix: uint, negative: bool, fractional: bool,\n         special: bool, exponent: ExponentFormat, empty_zero: bool,\n-        ignore_underscores: bool\n         ) -> Option<T> {\n     from_str_bytes_common(buf.as_bytes(), radix, negative,\n-                          fractional, special, exponent, empty_zero,\n-                          ignore_underscores)\n+                          fractional, special, exponent, empty_zero)\n+}\n+\n+pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n+    fn cast<T: Int>(x: uint) -> T {\n+        num::cast(x).unwrap()\n+    }\n+\n+    let _0: T = num::zero();\n+    let _1: T = num::one();\n+    let is_signed = _0 > Bounded::min_value();\n+\n+    let (is_negative, src) =  match src.slice_shift_char() {\n+        (Some('-'), src) if is_signed => (true, src),\n+        (Some(_), _) => (false, src),\n+        (None, _) => return None,\n+    };\n+\n+    let mut xs = src.chars().map(|c| {\n+        c.to_digit(radix).map(cast)\n+    });\n+    let radix = cast(radix);\n+    let mut result = _0;\n+\n+    if is_negative {\n+        for x in xs {\n+            let x = match x {\n+                Some(x) => x,\n+                None => return None,\n+            };\n+            result = match result.checked_mul(&radix) {\n+                Some(result) => result,\n+                None => return None,\n+            };\n+            result = match result.checked_sub(&x) {\n+                Some(result) => result,\n+                None => return None,\n+            };\n+        }\n+    } else {\n+        for x in xs {\n+            let x = match x {\n+                Some(x) => x,\n+                None => return None,\n+            };\n+            result = match result.checked_mul(&radix) {\n+                Some(result) => result,\n+                None => return None,\n+            };\n+            result = match result.checked_add(&x) {\n+                Some(result) => result,\n+                None => return None,\n+            };\n+        }\n+    }\n+\n+    Some(result)\n }\n \n #[cfg(test)]\n mod test {\n     use super::*;\n     use option::*;\n \n-    #[test]\n-    fn from_str_ignore_underscores() {\n-        let s : Option<u8> = from_str_common(\"__1__\", 2, false, false, false,\n-                                             ExpNone, false, true);\n-        assert_eq!(s, Some(1u8));\n-\n-        let n : Option<u8> = from_str_common(\"__1__\", 2, false, false, false,\n-                                             ExpNone, false, false);\n-        assert_eq!(n, None);\n-\n-        let f : Option<f32> = from_str_common(\"_1_._5_e_1_\", 10, false, true, false,\n-                                              ExpDec, false, true);\n-        assert_eq!(f, Some(1.5e1f32));\n-    }\n-\n-    #[test]\n-    fn from_str_issue5770() {\n-        // try to parse 0b1_1111_1111 = 511 as a u8. Caused problems\n-        // since 255*2+1 == 255 (mod 256) so the overflow wasn't\n-        // detected.\n-        let n : Option<u8> = from_str_common(\"111111111\", 2, false, false, false,\n-                                             ExpNone, false, false);\n-        assert_eq!(n, None);\n-    }\n-\n     #[test]\n     fn from_str_issue7588() {\n-        let u : Option<u8> = from_str_common(\"1000\", 10, false, false, false,\n-                                            ExpNone, false, false);\n+        let u : Option<u8> = from_str_radix_int(\"1000\", 10);\n         assert_eq!(u, None);\n-        let s : Option<i16> = from_str_common(\"80000\", 10, false, false, false,\n-                                             ExpNone, false, false);\n+        let s : Option<i16> = from_str_radix_int(\"80000\", 10);\n         assert_eq!(s, None);\n         let f : Option<f32> = from_str_common(\n             \"10000000000000000000000000000000000000000\", 10, false, false, false,\n-            ExpNone, false, false);\n+            ExpNone, false);\n         assert_eq!(f, NumStrConv::inf())\n         let fe : Option<f32> = from_str_common(\"1e40\", 10, false, false, false,\n-                                            ExpDec, false, false);\n+                                            ExpDec, false);\n         assert_eq!(fe, NumStrConv::inf())\n     }\n }"}, {"sha": "aa8e58bab0286a9b3cc5561d7d28b85e7e98329a", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 23, "deletions": 48, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/138b76b83a067284f25e1f8971600aaf49206816/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138b76b83a067284f25e1f8971600aaf49206816/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=138b76b83a067284f25e1f8971600aaf49206816", "patch": "@@ -15,40 +15,19 @@\n \n macro_rules! uint_module (($T:ty) => (\n \n-// String conversion functions and impl str -> num\n-\n-/// Parse a byte slice as a number in the given base\n-///\n-/// Yields an `Option` because `buf` may or may not actually be parseable.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// let num = std::uint::parse_bytes([49,50,51,52,53,54,55,56,57], 10);\n-/// assert!(num == Some(123456789));\n-/// ```\n-#[inline]\n-#[experimental = \"might need to return Result\"]\n-pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<$T> {\n-    strconv::from_str_bytes_common(buf, radix, false, false, false,\n-                                   strconv::ExpNone, false, false)\n-}\n-\n #[experimental = \"might need to return Result\"]\n impl FromStr for $T {\n     #[inline]\n     fn from_str(s: &str) -> Option<$T> {\n-        strconv::from_str_common(s, 10u, false, false, false,\n-                                 strconv::ExpNone, false, false)\n+        strconv::from_str_radix_int(s, 10)\n     }\n }\n \n #[experimental = \"might need to return Result\"]\n impl FromStrRadix for $T {\n     #[inline]\n     fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n-        strconv::from_str_common(s, radix, false, false, false,\n-                                 strconv::ExpNone, false, false)\n+        strconv::from_str_radix_int(s, radix)\n     }\n }\n \n@@ -85,10 +64,7 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n-    use super::*;\n-\n-    use str::StrSlice;\n-    use u16;\n+    use num::FromStrRadix;\n \n     #[test]\n     pub fn test_from_str() {\n@@ -98,23 +74,22 @@ mod tests {\n         assert_eq!(from_str::<u32>(\"123456789\"), Some(123456789 as u32));\n         assert_eq!(from_str::<$T>(\"00100\"), Some(100u as $T));\n \n-        assert!(from_str::<$T>(\"\").is_none());\n-        assert!(from_str::<$T>(\" \").is_none());\n-        assert!(from_str::<$T>(\"x\").is_none());\n+        assert_eq!(from_str::<$T>(\"\"), None);\n+        assert_eq!(from_str::<$T>(\" \"), None);\n+        assert_eq!(from_str::<$T>(\"x\"), None);\n     }\n \n     #[test]\n     pub fn test_parse_bytes() {\n-        use str::StrSlice;\n-        assert_eq!(parse_bytes(\"123\".as_bytes(), 10u), Some(123u as $T));\n-        assert_eq!(parse_bytes(\"1001\".as_bytes(), 2u), Some(9u as $T));\n-        assert_eq!(parse_bytes(\"123\".as_bytes(), 8u), Some(83u as $T));\n-        assert_eq!(u16::parse_bytes(\"123\".as_bytes(), 16u), Some(291u as u16));\n-        assert_eq!(u16::parse_bytes(\"ffff\".as_bytes(), 16u), Some(65535u as u16));\n-        assert_eq!(parse_bytes(\"z\".as_bytes(), 36u), Some(35u as $T));\n-\n-        assert!(parse_bytes(\"Z\".as_bytes(), 10u).is_none());\n-        assert!(parse_bytes(\"_\".as_bytes(), 2u).is_none());\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Some(123u as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Some(9u as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Some(83u as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Some(291u as u16));\n+        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Some(65535u as u16));\n+        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Some(35u as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 10), None::<$T>);\n+        assert_eq!(FromStrRadix::from_str_radix(\"_\", 2), None::<$T>);\n     }\n \n     #[test]\n@@ -148,35 +123,35 @@ mod tests {\n     fn test_uint_from_str_overflow() {\n         let mut u8_val: u8 = 255_u8;\n         assert_eq!(from_str::<u8>(\"255\"), Some(u8_val));\n-        assert!(from_str::<u8>(\"256\").is_none());\n+        assert_eq!(from_str::<u8>(\"256\"), None);\n \n         u8_val += 1 as u8;\n         assert_eq!(from_str::<u8>(\"0\"), Some(u8_val));\n-        assert!(from_str::<u8>(\"-1\").is_none());\n+        assert_eq!(from_str::<u8>(\"-1\"), None);\n \n         let mut u16_val: u16 = 65_535_u16;\n         assert_eq!(from_str::<u16>(\"65535\"), Some(u16_val));\n-        assert!(from_str::<u16>(\"65536\").is_none());\n+        assert_eq!(from_str::<u16>(\"65536\"), None);\n \n         u16_val += 1 as u16;\n         assert_eq!(from_str::<u16>(\"0\"), Some(u16_val));\n-        assert!(from_str::<u16>(\"-1\").is_none());\n+        assert_eq!(from_str::<u16>(\"-1\"), None);\n \n         let mut u32_val: u32 = 4_294_967_295_u32;\n         assert_eq!(from_str::<u32>(\"4294967295\"), Some(u32_val));\n-        assert!(from_str::<u32>(\"4294967296\").is_none());\n+        assert_eq!(from_str::<u32>(\"4294967296\"), None);\n \n         u32_val += 1 as u32;\n         assert_eq!(from_str::<u32>(\"0\"), Some(u32_val));\n-        assert!(from_str::<u32>(\"-1\").is_none());\n+        assert_eq!(from_str::<u32>(\"-1\"), None);\n \n         let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n         assert_eq!(from_str::<u64>(\"18446744073709551615\"), Some(u64_val));\n-        assert!(from_str::<u64>(\"18446744073709551616\").is_none());\n+        assert_eq!(from_str::<u64>(\"18446744073709551616\"), None);\n \n         u64_val += 1 as u64;\n         assert_eq!(from_str::<u64>(\"0\"), Some(u64_val));\n-        assert!(from_str::<u64>(\"-1\").is_none());\n+        assert_eq!(from_str::<u64>(\"-1\"), None);\n     }\n }\n "}, {"sha": "7fa13d6074d43129835958260163b6f96be36e20", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/138b76b83a067284f25e1f8971600aaf49206816/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138b76b83a067284f25e1f8971600aaf49206816/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=138b76b83a067284f25e1f8971600aaf49206816", "patch": "@@ -24,7 +24,6 @@ extern crate time;\n use std::os;\n use std::result::{Ok, Err};\n use std::task;\n-use std::uint;\n \n fn fib(n: int) -> int {\n     fn pfib(tx: &Sender<int>, n: int) {\n@@ -102,8 +101,7 @@ fn main() {\n     if opts.stress {\n         stress(2);\n     } else {\n-        let max = uint::parse_bytes(args[1].as_bytes(), 10u).unwrap() as\n-            int;\n+        let max = from_str::<uint>(args[1].as_slice()).unwrap() as int;\n \n         let num_trials = 10;\n "}]}