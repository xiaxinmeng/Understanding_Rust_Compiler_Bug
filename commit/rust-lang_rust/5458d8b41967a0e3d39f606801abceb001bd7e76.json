{"sha": "5458d8b41967a0e3d39f606801abceb001bd7e76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0NThkOGI0MTk2N2EwZTNkMzlmNjA2ODAxYWJjZWIwMDFiZDdlNzY=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-05-14T06:01:57Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-05-14T06:01:57Z"}, "message": "rewrite fuzzy `on_unimplemented` matching to avoid ICEs", "tree": {"sha": "35c8b33485c9275a6d982270ee7c251587ab710b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35c8b33485c9275a6d982270ee7c251587ab710b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5458d8b41967a0e3d39f606801abceb001bd7e76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5458d8b41967a0e3d39f606801abceb001bd7e76", "html_url": "https://github.com/rust-lang/rust/commit/5458d8b41967a0e3d39f606801abceb001bd7e76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5458d8b41967a0e3d39f606801abceb001bd7e76/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0f5ef51bf6f89089406dc82f49c2c24c8936e75", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0f5ef51bf6f89089406dc82f49c2c24c8936e75", "html_url": "https://github.com/rust-lang/rust/commit/f0f5ef51bf6f89089406dc82f49c2c24c8936e75"}], "stats": {"total": 278, "additions": 33, "deletions": 245}, "files": [{"sha": "df8cfd73192f266973441a4c71611f15d48263ce", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 33, "deletions": 181, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/5458d8b41967a0e3d39f606801abceb001bd7e76/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5458d8b41967a0e3d39f606801abceb001bd7e76/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=5458d8b41967a0e3d39f606801abceb001bd7e76", "patch": "@@ -26,11 +26,11 @@ use super::{\n \n use fmt_macros::{Parser, Piece, Position};\n use hir::def_id::DefId;\n-use infer::{InferCtxt, TypeOrigin};\n-use ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, Ty, TyCtxt, TypeFoldable, TypeVariants};\n+use infer::{InferCtxt};\n+use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n-use ty::subst::{self, ParamSpace, Subst};\n+use ty::subst::{self, Subst};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n use std::cmp;\n@@ -61,128 +61,6 @@ impl<'a, 'gcx, 'tcx> TraitErrorKey<'tcx> {\n     }\n }\n \n-// Enum used to differentiate the \"big\" and \"little\" weights.\n-enum Weight {\n-    Coarse,\n-    Precise,\n-}\n-\n-trait AssociatedWeight {\n-    fn get_weight(&self) -> (u32, u32);\n-}\n-\n-impl<'a> AssociatedWeight for TypeVariants<'a> {\n-    // Left number is for \"global\"/\"big\" weight and right number is for better precision.\n-    fn get_weight(&self) -> (u32, u32) {\n-        match *self {\n-            TypeVariants::TyBool => (1, 1),\n-            TypeVariants::TyChar => (1, 2),\n-            TypeVariants::TyStr => (1, 3),\n-\n-            TypeVariants::TyInt(_) => (2, 1),\n-            TypeVariants::TyUint(_) => (2, 2),\n-            TypeVariants::TyFloat(_) => (2, 3),\n-            TypeVariants::TyRawPtr(_) => (2, 4),\n-\n-            TypeVariants::TyEnum(_, _) => (3, 1),\n-            TypeVariants::TyStruct(_, _) => (3, 2),\n-            TypeVariants::TyBox(_) => (3, 3),\n-            TypeVariants::TyTuple(_) => (3, 4),\n-\n-            TypeVariants::TyArray(_, _) => (4, 1),\n-            TypeVariants::TySlice(_) => (4, 2),\n-\n-            TypeVariants::TyRef(_, _) => (5, 1),\n-            TypeVariants::TyFnDef(_, _, _) => (5, 2),\n-            TypeVariants::TyFnPtr(_) => (5, 3),\n-\n-            TypeVariants::TyTrait(_) => (6, 1),\n-\n-            TypeVariants::TyClosure(_, _) => (7, 1),\n-\n-            TypeVariants::TyProjection(_) => (8, 1),\n-            TypeVariants::TyParam(_) => (8, 2),\n-            TypeVariants::TyInfer(_) => (8, 3),\n-\n-            TypeVariants::TyError => (9, 1),\n-        }\n-    }\n-}\n-\n-// The \"closer\" the types are, the lesser the weight.\n-fn get_weight_diff(a: &ty::TypeVariants, b: &TypeVariants, weight: Weight) -> u32 {\n-    let (w1, w2) = match weight {\n-        Weight::Coarse => (a.get_weight().0, b.get_weight().0),\n-        Weight::Precise => (a.get_weight().1, b.get_weight().1),\n-    };\n-    if w1 < w2 {\n-        w2 - w1\n-    } else {\n-        w1 - w2\n-    }\n-}\n-\n-// Once we have \"globally matching\" types, we need to run another filter on them.\n-//\n-// In the function `get_best_matching_type`, we got the types which might fit the\n-// most to the type we're looking for. This second filter now intends to get (if\n-// possible) the type which fits the most.\n-//\n-// For example, the trait expects an `usize` and here you have `u32` and `i32`.\n-// Obviously, the \"correct\" one is `u32`.\n-fn filter_matching_types<'tcx>(weights: &[(usize, u32)],\n-                               imps: &[(DefId, subst::Substs<'tcx>)],\n-                               trait_types: &[ty::Ty<'tcx>])\n-                               -> usize {\n-    let matching_weight = weights[0].1;\n-    let iter = weights.iter().filter(|&&(_, weight)| weight == matching_weight);\n-    let mut filtered_weights = vec!();\n-\n-    for &(pos, _) in iter {\n-        let mut weight = 0;\n-        for (type_to_compare, original_type) in imps[pos].1\n-                                                         .types\n-                                                         .get_slice(ParamSpace::TypeSpace)\n-                                                         .iter()\n-                                                         .zip(trait_types.iter()) {\n-            weight += get_weight_diff(&type_to_compare.sty, &original_type.sty, Weight::Precise);\n-        }\n-        filtered_weights.push((pos, weight));\n-    }\n-    filtered_weights.sort_by(|a, b| a.1.cmp(&b.1));\n-    filtered_weights[0].0\n-}\n-\n-// Here, we run the \"big\" filter. Little example:\n-//\n-// We receive a `String`, an `u32` and an `i32`.\n-// The trait expected an `usize`.\n-// From human point of view, it's easy to determine that `String` doesn't correspond to\n-// the expected type at all whereas `u32` and `i32` could.\n-//\n-// This first filter intends to only keep the types which match the most.\n-fn get_best_matching_type<'tcx>(imps: &[(DefId, subst::Substs<'tcx>)],\n-                                trait_types: &[ty::Ty<'tcx>]) -> usize {\n-    let mut weights = vec!();\n-    for (pos, imp) in imps.iter().enumerate() {\n-        let mut weight = 0;\n-        for (type_to_compare, original_type) in imp.1\n-                                                   .types\n-                                                   .get_slice(ParamSpace::TypeSpace)\n-                                                   .iter()\n-                                                   .zip(trait_types.iter()) {\n-            weight += get_weight_diff(&type_to_compare.sty, &original_type.sty, Weight::Coarse);\n-        }\n-        weights.push((pos, weight));\n-    }\n-    weights.sort_by(|a, b| a.1.cmp(&b.1));\n-    if weights[0].1 == weights[1].1 {\n-        filter_matching_types(&weights, &imps, trait_types)\n-    } else {\n-        weights[0].0\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_fulfillment_errors(&self, errors: &Vec<FulfillmentError<'tcx>>) {\n         for error in errors {\n@@ -272,72 +150,46 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         substs\n     }\n \n-    fn get_current_failing_impl(&self,\n-                                trait_ref: &TraitRef<'tcx>,\n-                                obligation: &PredicateObligation<'tcx>)\n-                                -> Option<(DefId, subst::Substs<'tcx>)> {\n-        let simp = fast_reject::simplify_type(self.tcx,\n-                                              trait_ref.self_ty(),\n-                                              true);\n-        let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id);\n-\n-        match simp {\n-            Some(_) => {\n-                let mut matching_impls = Vec::new();\n-                trait_def.for_each_impl(self.tcx, |def_id| {\n-                    let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n-                    let substs = self.impl_substs(def_id, obligation.clone());\n-                    let imp = imp.subst(self.tcx, &substs);\n-\n-                    if self.eq_types(true,\n-                                      TypeOrigin::Misc(obligation.cause.span),\n-                                      trait_ref.self_ty(),\n-                                      imp.self_ty()).is_ok() {\n-                        matching_impls.push((def_id, imp.substs.clone()));\n-                    }\n-                });\n-                if matching_impls.len() == 0 {\n-                    None\n-                } else if matching_impls.len() == 1 {\n-                    Some(matching_impls[0].clone())\n-                } else {\n-                    let end = trait_ref.input_types().len() - 1;\n-                    // we need to determine which type is the good one!\n-                    Some(matching_impls[get_best_matching_type(&matching_impls,\n-                                                               &trait_ref.input_types()[0..end])]\n-                                                              .clone())\n+    fn impl_with_self_type_of(&self,\n+                              trait_ref: ty::PolyTraitRef<'tcx>,\n+                              obligation: &PredicateObligation<'tcx>)\n+                              -> Option<DefId>\n+    {\n+        let tcx = self.tcx;\n+        let mut result = None;\n+        let mut ambiguous = false;\n+\n+        let trait_self_ty = tcx.erase_late_bound_regions(&trait_ref).self_ty();\n+\n+        self.tcx.lookup_trait_def(trait_ref.def_id())\n+            .for_each_relevant_impl(self.tcx, trait_self_ty, |def_id| {\n+                let impl_self_ty = tcx\n+                    .impl_trait_ref(def_id)\n+                    .unwrap()\n+                    .self_ty()\n+                    .subst(tcx, &self.impl_substs(def_id, obligation.clone()));\n+\n+                if let Ok(..) = self.can_equate(&trait_self_ty, &impl_self_ty) {\n+                    ambiguous = result.is_some();\n+                    result = Some(def_id);\n                 }\n-            },\n-            None => None,\n-        }\n-    }\n+            });\n \n-    fn find_attr(&self,\n-                 def_id: DefId,\n-                 attr_name: &str)\n-                 -> Option<ast::Attribute> {\n-        for item in self.tcx.get_attrs(def_id).iter() {\n-            if item.check_name(attr_name) {\n-                return Some(item.clone());\n+        match result {\n+            Some(def_id) if !ambiguous && tcx.has_attr(def_id, \"rustc_on_unimplemented\") => {\n+                result\n             }\n+            _ => None\n         }\n-        None\n     }\n \n     fn on_unimplemented_note(&self,\n                              trait_ref: ty::PolyTraitRef<'tcx>,\n                              obligation: &PredicateObligation<'tcx>) -> Option<String> {\n+        let def_id = self.impl_with_self_type_of(trait_ref, obligation)\n+            .unwrap_or(trait_ref.def_id());\n         let trait_ref = trait_ref.skip_binder();\n-        let def_id = match self.get_current_failing_impl(trait_ref, obligation) {\n-            Some((def_id, _)) => {\n-                if let Some(_) = self.find_attr(def_id, \"rustc_on_unimplemented\") {\n-                    def_id\n-                } else {\n-                    trait_ref.def_id\n-                }\n-            },\n-            None => trait_ref.def_id,\n-        };\n+\n         let span = obligation.cause.span;\n         let mut report = None;\n         for item in self.tcx.get_attrs(def_id).iter() {"}, {"sha": "1a5b5ff206ad0de73445c8057ff7663f094fb593", "filename": "src/test/compile-fail/on_unimplemented.rs", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f0f5ef51bf6f89089406dc82f49c2c24c8936e75/src%2Ftest%2Fcompile-fail%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f5ef51bf6f89089406dc82f49c2c24c8936e75/src%2Ftest%2Fcompile-fail%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon_unimplemented.rs?ref=f0f5ef51bf6f89089406dc82f49c2c24c8936e75", "patch": "@@ -1,64 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test if the on_unimplemented message override works\n-\n-#![feature(on_unimplemented)]\n-#![feature(rustc_attrs)]\n-\n-#[rustc_on_unimplemented = \"invalid\"]\n-trait Index<Idx: ?Sized> {\n-    type Output: ?Sized;\n-    fn index(&self, index: Idx) -> &Self::Output;\n-}\n-\n-#[rustc_on_unimplemented = \"a isize is required to index into a slice\"]\n-impl Index<isize> for [i32] {\n-    type Output = i32;\n-    fn index(&self, index: isize) -> &i32 {\n-        &self[index as usize]\n-    }\n-}\n-\n-#[rustc_on_unimplemented = \"a usize is required to index into a slice\"]\n-impl Index<usize> for [i32] {\n-    type Output = i32;\n-    fn index(&self, index: usize) -> &i32 {\n-        &self[index]\n-    }\n-}\n-\n-trait Foo<A, B> {\n-    fn f(&self, a: &A, b: &B);\n-}\n-\n-#[rustc_on_unimplemented = \"two i32 Foo trait takes\"]\n-impl Foo<i32, i32> for [i32] {\n-    fn f(&self, a: &i32, b: &i32) {}\n-}\n-\n-#[rustc_on_unimplemented = \"two u32 Foo trait takes\"]\n-impl Foo<u32, u32> for [i32] {\n-    fn f(&self, a: &u32, b: &u32) {}\n-}\n-\n-#[rustc_error]\n-fn main() {\n-    Index::<u32>::index(&[1, 2, 3] as &[i32], 2u32); //~ ERROR E0277\n-                                                     //~| NOTE a usize is required\n-                                                     //~| NOTE required by\n-    Index::<i32>::index(&[1, 2, 3] as &[i32], 2i32); //~ ERROR E0277\n-                                                     //~| NOTE a isize is required\n-                                                     //~| NOTE required by\n-\n-    Foo::<usize, usize>::f(&[1, 2, 3] as &[i32], &2usize, &2usize); //~ ERROR E0277\n-                                                                    //~| NOTE two u32 Foo trait\n-                                                                    //~| NOTE required by\n-}"}]}