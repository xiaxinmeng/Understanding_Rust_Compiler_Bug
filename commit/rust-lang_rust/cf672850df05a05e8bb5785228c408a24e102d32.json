{"sha": "cf672850df05a05e8bb5785228c408a24e102d32", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmNjcyODUwZGYwNWEwNWU4YmI1Nzg1MjI4YzQwOGEyNGUxMDJkMzI=", "commit": {"author": {"name": "Stuart Pernsteiner", "email": "spernsteiner@mozilla.com", "date": "2014-07-17T17:52:52Z"}, "committer": {"name": "Stuart Pernsteiner", "email": "spernsteiner@mozilla.com", "date": "2014-09-05T16:18:55Z"}, "message": "run optimization and codegen on worker threads\n\nRefactor the code in `llvm::back` that invokes LLVM optimization and codegen\npasses so that it can be called from worker threads.  (Previously, it used\n`&Session` extensively, and `Session` is not `Share`.)  The new code can handle\nmultiple compilation units, by compiling each unit to `crate.0.o`, `crate.1.o`,\netc., and linking together all the `crate.N.o` files into a single `crate.o`\nusing `ld -r`.  The later linking steps can then be run unchanged.\n\nThe new code preserves the behavior of `--emit`/`-o` when building a single\ncompilation unit.  With multiple compilation units, the `--emit=asm/ir/bc`\noptions produce multiple files, so combinations like `--emit=ir -o foo.ll` will\nnot actually produce `foo.ll` (they instead produce several `foo.N.ll` files).\n\nThe new code supports `-Z lto` only when using a single compilation unit.\nCompiling with multiple compilation units and `-Z lto` will produce an error.\n(I can't think of any good reason to do such a thing.)  Linking with `-Z lto`\nagainst a library that was built as multiple compilation units will also fail,\nbecause the rlib does not contain a `crate.bytecode.deflate` file.  This could\nbe supported in the future by linking together the `crate.N.bc` files produced\nwhen compiling the library into a single `crate.bc`, or by making the LTO code\nsupport multiple `crate.N.bytecode.deflate` files.", "tree": {"sha": "77fcfd17136b3d8a12d29a7e1ce880f10120a5b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77fcfd17136b3d8a12d29a7e1ce880f10120a5b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf672850df05a05e8bb5785228c408a24e102d32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf672850df05a05e8bb5785228c408a24e102d32", "html_url": "https://github.com/rust-lang/rust/commit/cf672850df05a05e8bb5785228c408a24e102d32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf672850df05a05e8bb5785228c408a24e102d32/comments", "author": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758", "url": "https://api.github.com/repos/rust-lang/rust/commits/e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758", "html_url": "https://github.com/rust-lang/rust/commit/e29aa1430bb45d18a5d3fcc5f3b7d20e99a57758"}], "stats": {"total": 1058, "additions": 773, "deletions": 285}, "files": [{"sha": "32671722ba72872bbeaabe397ec5c193cd45ecfe", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cf672850df05a05e8bb5785228c408a24e102d32/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf672850df05a05e8bb5785228c408a24e102d32/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=cf672850df05a05e8bb5785228c408a24e102d32", "patch": "@@ -1577,10 +1577,6 @@ fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n \n // codegen tests (vs. clang)\n \n-fn make_o_name(config: &Config, testfile: &Path) -> Path {\n-    output_base_name(config, testfile).with_extension(\"o\")\n-}\n-\n fn append_suffix_to_stem(p: &Path, suffix: &str) -> Path {\n     if suffix.len() == 0 {\n         (*p).clone()\n@@ -1596,14 +1592,13 @@ fn compile_test_and_save_bitcode(config: &Config, props: &TestProps,\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let link_args = vec!(\"-L\".to_string(),\n                          aux_dir.as_str().unwrap().to_string());\n-    let llvm_args = vec!(\"--emit=obj\".to_string(),\n-                         \"--crate-type=lib\".to_string(),\n-                         \"-C\".to_string(),\n-                         \"save-temps\".to_string());\n+    let llvm_args = vec!(\"--emit=bc,obj\".to_string(),\n+                         \"--crate-type=lib\".to_string());\n     let args = make_compile_args(config,\n                                  props,\n                                  link_args.append(llvm_args.as_slice()),\n-                                 |a, b| ThisFile(make_o_name(a, b)), testfile);\n+                                 |a, b| ThisDirectory(output_base_name(a, b).dir_path()),\n+                                 testfile);\n     compose_and_run_compiler(config, props, testfile, args, None)\n }\n "}, {"sha": "5adf8b653813d4b83e8706149b9748cd34a9df32", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 46, "deletions": 41, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/cf672850df05a05e8bb5785228c408a24e102d32/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf672850df05a05e8bb5785228c408a24e102d32/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=cf672850df05a05e8bb5785228c408a24e102d32", "patch": "@@ -662,51 +662,56 @@ fn link_rlib<'a>(sess: &'a Session,\n             ab.add_file(&metadata).unwrap();\n             remove(sess, &metadata);\n \n-            // For LTO purposes, the bytecode of this library is also inserted\n-            // into the archive.\n-            //\n-            // Note that we make sure that the bytecode filename in the archive\n-            // is never exactly 16 bytes long by adding a 16 byte extension to\n-            // it. This is to work around a bug in LLDB that would cause it to\n-            // crash if the name of a file in an archive was exactly 16 bytes.\n-            let bc_filename = obj_filename.with_extension(\"bc\");\n-            let bc_deflated_filename = obj_filename.with_extension(\"bytecode.deflate\");\n-\n-            let bc_data = match fs::File::open(&bc_filename).read_to_end() {\n-                Ok(buffer) => buffer,\n-                Err(e) => sess.fatal(format!(\"failed to read bytecode: {}\",\n-                                             e).as_slice())\n-            };\n+            if sess.opts.cg.codegen_units == 1 {\n+                // For LTO purposes, the bytecode of this library is also\n+                // inserted into the archive.  We currently do this only when\n+                // codegen_units == 1, so we don't have to deal with multiple\n+                // bitcode files per crate.\n+                //\n+                // Note that we make sure that the bytecode filename in the\n+                // archive is never exactly 16 bytes long by adding a 16 byte\n+                // extension to it. This is to work around a bug in LLDB that\n+                // would cause it to crash if the name of a file in an archive\n+                // was exactly 16 bytes.\n+                let bc_filename = obj_filename.with_extension(\"bc\");\n+                let bc_deflated_filename = obj_filename.with_extension(\"bytecode.deflate\");\n+\n+                let bc_data = match fs::File::open(&bc_filename).read_to_end() {\n+                    Ok(buffer) => buffer,\n+                    Err(e) => sess.fatal(format!(\"failed to read bytecode: {}\",\n+                                                 e).as_slice())\n+                };\n \n-            let bc_data_deflated = match flate::deflate_bytes(bc_data.as_slice()) {\n-                Some(compressed) => compressed,\n-                None => sess.fatal(format!(\"failed to compress bytecode from {}\",\n-                                           bc_filename.display()).as_slice())\n-            };\n+                let bc_data_deflated = match flate::deflate_bytes(bc_data.as_slice()) {\n+                    Some(compressed) => compressed,\n+                    None => sess.fatal(format!(\"failed to compress bytecode from {}\",\n+                                               bc_filename.display()).as_slice())\n+                };\n \n-            let mut bc_file_deflated = match fs::File::create(&bc_deflated_filename) {\n-                Ok(file) => file,\n-                Err(e) => {\n-                    sess.fatal(format!(\"failed to create compressed bytecode \\\n-                                        file: {}\", e).as_slice())\n-                }\n-            };\n+                let mut bc_file_deflated = match fs::File::create(&bc_deflated_filename) {\n+                    Ok(file) => file,\n+                    Err(e) => {\n+                        sess.fatal(format!(\"failed to create compressed bytecode \\\n+                                            file: {}\", e).as_slice())\n+                    }\n+                };\n \n-            match write_rlib_bytecode_object_v1(&mut bc_file_deflated,\n-                                                bc_data_deflated.as_slice()) {\n-                Ok(()) => {}\n-                Err(e) => {\n-                    sess.err(format!(\"failed to write compressed bytecode: \\\n-                                      {}\", e).as_slice());\n-                    sess.abort_if_errors()\n-                }\n-            };\n+                match write_rlib_bytecode_object_v1(&mut bc_file_deflated,\n+                                                    bc_data_deflated.as_slice()) {\n+                    Ok(()) => {}\n+                    Err(e) => {\n+                        sess.err(format!(\"failed to write compressed bytecode: \\\n+                                          {}\", e).as_slice());\n+                        sess.abort_if_errors()\n+                    }\n+                };\n \n-            ab.add_file(&bc_deflated_filename).unwrap();\n-            remove(sess, &bc_deflated_filename);\n-            if !sess.opts.cg.save_temps &&\n-               !sess.opts.output_types.contains(&OutputTypeBitcode) {\n-                remove(sess, &bc_filename);\n+                ab.add_file(&bc_deflated_filename).unwrap();\n+                remove(sess, &bc_deflated_filename);\n+                if !sess.opts.cg.save_temps &&\n+                   !sess.opts.output_types.contains(&OutputTypeBitcode) {\n+                    remove(sess, &bc_filename);\n+                }\n             }\n         }\n "}, {"sha": "d7f183faa0192c553afe7036c5013e43df429db2", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cf672850df05a05e8bb5785228c408a24e102d32/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf672850df05a05e8bb5785228c408a24e102d32/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=cf672850df05a05e8bb5785228c408a24e102d32", "patch": "@@ -67,7 +67,14 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                                   archive.read(format!(\"{}.bytecode.deflate\",\n                                                        file).as_slice())\n                               });\n-        let bc_encoded = bc_encoded.expect(\"missing compressed bytecode in archive!\");\n+        let bc_encoded = match bc_encoded {\n+            Some(data) => data,\n+            None => {\n+                sess.fatal(format!(\"missing compressed bytecode in {} \\\n+                                    (perhaps it was compiled with -C codegen-units > 1)\",\n+                                   path.display()).as_slice());\n+            },\n+        };\n         let bc_extractor = if is_versioned_bytecode_format(bc_encoded) {\n             |_| {\n                 // Read the version\n@@ -120,7 +127,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n                                                     ptr as *const libc::c_char,\n                                                     bc_decoded.len() as libc::size_t) {\n-                write::llvm_err(sess,\n+                write::llvm_err(sess.diagnostic().handler(),\n                                 format!(\"failed to load bc of `{}`\",\n                                         name.as_slice()));\n             }"}, {"sha": "076338ccef84f7a7dc1617a15148dd8cd6d458af", "filename": "src/librustc/back/write.rs", "status": "modified", "additions": 636, "deletions": 206, "changes": 842, "blob_url": "https://github.com/rust-lang/rust/blob/cf672850df05a05e8bb5785228c408a24e102d32/src%2Flibrustc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf672850df05a05e8bb5785228c408a24e102d32/src%2Flibrustc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fwrite.rs?ref=cf672850df05a05e8bb5785228c408a24e102d32", "patch": "@@ -9,20 +9,27 @@\n // except according to those terms.\n \n use back::lto;\n-use back::link::get_cc_prog;\n-use driver::driver::{CrateTranslation, OutputFilenames};\n+use back::link::{get_cc_prog, remove};\n+use driver::driver::{CrateTranslation, ModuleTranslation, OutputFilenames};\n use driver::config::NoDebugInfo;\n use driver::session::Session;\n use driver::config;\n use llvm;\n use llvm::{ModuleRef, TargetMachineRef, PassManagerRef};\n use util::common::time;\n use syntax::abi;\n+use syntax::codemap;\n+use syntax::diagnostic;\n+use syntax::diagnostic::{Emitter, Handler, Level, mk_handler};\n \n use std::c_str::{ToCStr, CString};\n use std::io::Command;\n+use std::io::fs;\n+use std::iter::Unfold;\n use std::ptr;\n use std::str;\n+use std::sync::{Arc, Mutex};\n+use std::task::TaskBuilder;\n use libc::{c_uint, c_int};\n \n \n@@ -36,23 +43,23 @@ pub enum OutputType {\n }\n \n \n-pub fn llvm_err(sess: &Session, msg: String) -> ! {\n+pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n         if cstr == ptr::null() {\n-            sess.fatal(msg.as_slice());\n+            handler.fatal(msg.as_slice());\n         } else {\n             let err = CString::new(cstr, true);\n             let err = String::from_utf8_lossy(err.as_bytes());\n-            sess.fatal(format!(\"{}: {}\",\n-                               msg.as_slice(),\n-                               err.as_slice()).as_slice());\n+            handler.fatal(format!(\"{}: {}\",\n+                                  msg.as_slice(),\n+                                  err.as_slice()).as_slice());\n         }\n     }\n }\n \n pub fn write_output_file(\n-        sess: &Session,\n+        handler: &diagnostic::Handler,\n         target: llvm::TargetMachineRef,\n         pm: llvm::PassManagerRef,\n         m: ModuleRef,\n@@ -63,13 +70,74 @@ pub fn write_output_file(\n             let result = llvm::LLVMRustWriteOutputFile(\n                     target, pm, m, output, file_type);\n             if !result {\n-                llvm_err(sess, \"could not write output\".to_string());\n+                llvm_err(handler, \"could not write output\".to_string());\n             }\n         })\n     }\n }\n \n \n+struct Diagnostic {\n+    msg: String,\n+    code: Option<String>,\n+    lvl: Level,\n+}\n+\n+// We use an Arc instead of just returning a list of diagnostics from the\n+// child task because we need to make sure that the messages are seen even\n+// if the child task fails (for example, when `fatal` is called).\n+#[deriving(Clone)]\n+struct SharedEmitter {\n+    buffer: Arc<Mutex<Vec<Diagnostic>>>,\n+}\n+\n+impl SharedEmitter {\n+    fn new() -> SharedEmitter {\n+        SharedEmitter {\n+            buffer: Arc::new(Mutex::new(Vec::new())),\n+        }\n+    }\n+\n+    fn dump(&mut self, handler: &Handler) {\n+        let mut buffer = self.buffer.lock();\n+        for diag in buffer.iter() {\n+            match diag.code {\n+                Some(ref code) => {\n+                    handler.emit_with_code(None,\n+                                           diag.msg.as_slice(),\n+                                           code.as_slice(),\n+                                           diag.lvl);\n+                },\n+                None => {\n+                    handler.emit(None,\n+                                 diag.msg.as_slice(),\n+                                 diag.lvl);\n+                },\n+            }\n+        }\n+        buffer.clear();\n+    }\n+}\n+\n+impl Emitter for SharedEmitter {\n+    fn emit(&mut self, cmsp: Option<(&codemap::CodeMap, codemap::Span)>,\n+            msg: &str, code: Option<&str>, lvl: Level) {\n+        assert!(cmsp.is_none(), \"SharedEmitter doesn't support spans\");\n+\n+        self.buffer.lock().push(Diagnostic {\n+            msg: msg.to_string(),\n+            code: code.map(|s| s.to_string()),\n+            lvl: lvl,\n+        });\n+    }\n+\n+    fn custom_emit(&mut self, _cm: &codemap::CodeMap,\n+                   _sp: diagnostic::RenderSpan, _msg: &str, _lvl: Level) {\n+        fail!(\"SharedEmitter doesn't support custom_emit\");\n+    }\n+}\n+\n+\n // On android, we by default compile for armv7 processors. This enables\n // things like double word CAS instructions (rather than emulating them)\n // which are *far* more efficient. This is obviously undesirable in some\n@@ -98,77 +166,68 @@ fn target_feature<'a>(sess: &'a Session) -> &'a str {\n     }\n }\n \n-pub fn run_passes(sess: &Session,\n-                  trans: &CrateTranslation,\n-                  output_types: &[OutputType],\n-                  output: &OutputFilenames) {\n-    let llmod = trans.module;\n-    let llcx = trans.context;\n-    unsafe {\n-        configure_llvm(sess);\n+fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n+    match optimize {\n+      config::No => llvm::CodeGenLevelNone,\n+      config::Less => llvm::CodeGenLevelLess,\n+      config::Default => llvm::CodeGenLevelDefault,\n+      config::Aggressive => llvm::CodeGenLevelAggressive,\n+    }\n+}\n \n-        if sess.opts.cg.save_temps {\n-            output.with_extension(\"no-opt.bc\").with_c_str(|buf| {\n-                llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-            })\n+fn create_target_machine(sess: &Session) -> TargetMachineRef {\n+    let reloc_model = match sess.opts.cg.relocation_model.as_slice() {\n+        \"pic\" => llvm::RelocPIC,\n+        \"static\" => llvm::RelocStatic,\n+        \"default\" => llvm::RelocDefault,\n+        \"dynamic-no-pic\" => llvm::RelocDynamicNoPic,\n+        _ => {\n+            sess.err(format!(\"{} is not a valid relocation mode\",\n+                             sess.opts\n+                                 .cg\n+                                 .relocation_model).as_slice());\n+            sess.abort_if_errors();\n+            unreachable!();\n         }\n+    };\n \n-        let opt_level = match sess.opts.optimize {\n-          config::No => llvm::CodeGenLevelNone,\n-          config::Less => llvm::CodeGenLevelLess,\n-          config::Default => llvm::CodeGenLevelDefault,\n-          config::Aggressive => llvm::CodeGenLevelAggressive,\n-        };\n-        let use_softfp = sess.opts.cg.soft_float;\n-\n-        // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a parameter.\n-        // FIXME: #11954: mac64 unwinding may not work with fp elim\n-        let no_fp_elim = (sess.opts.debuginfo != NoDebugInfo) ||\n-                         (sess.targ_cfg.os == abi::OsMacos &&\n-                          sess.targ_cfg.arch == abi::X86_64);\n-\n-        // OSX has -dead_strip, which doesn't rely on ffunction_sections\n-        // FIXME(#13846) this should be enabled for windows\n-        let ffunction_sections = sess.targ_cfg.os != abi::OsMacos &&\n-                                 sess.targ_cfg.os != abi::OsWindows;\n-        let fdata_sections = ffunction_sections;\n-\n-        let reloc_model = match sess.opts.cg.relocation_model.as_slice() {\n-            \"pic\" => llvm::RelocPIC,\n-            \"static\" => llvm::RelocStatic,\n-            \"default\" => llvm::RelocDefault,\n-            \"dynamic-no-pic\" => llvm::RelocDynamicNoPic,\n-            _ => {\n-                sess.err(format!(\"{} is not a valid relocation mode\",\n-                                 sess.opts\n-                                     .cg\n-                                     .relocation_model).as_slice());\n-                sess.abort_if_errors();\n-                return;\n-            }\n-        };\n-\n-        let code_model = match sess.opts.cg.code_model.as_slice() {\n-            \"default\" => llvm::CodeModelDefault,\n-            \"small\" => llvm::CodeModelSmall,\n-            \"kernel\" => llvm::CodeModelKernel,\n-            \"medium\" => llvm::CodeModelMedium,\n-            \"large\" => llvm::CodeModelLarge,\n-            _ => {\n-                sess.err(format!(\"{} is not a valid code model\",\n-                                 sess.opts\n-                                     .cg\n-                                     .code_model).as_slice());\n-                sess.abort_if_errors();\n-                return;\n-            }\n-        };\n+    let opt_level = get_llvm_opt_level(sess.opts.optimize);\n+    let use_softfp = sess.opts.cg.soft_float;\n+\n+    // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a parameter.\n+    // FIXME: #11954: mac64 unwinding may not work with fp elim\n+    let no_fp_elim = (sess.opts.debuginfo != NoDebugInfo) ||\n+                     (sess.targ_cfg.os == abi::OsMacos &&\n+                      sess.targ_cfg.arch == abi::X86_64);\n+\n+    // OSX has -dead_strip, which doesn't rely on ffunction_sections\n+    // FIXME(#13846) this should be enabled for windows\n+    let ffunction_sections = sess.targ_cfg.os != abi::OsMacos &&\n+                             sess.targ_cfg.os != abi::OsWindows;\n+    let fdata_sections = ffunction_sections;\n+\n+    let code_model = match sess.opts.cg.code_model.as_slice() {\n+        \"default\" => llvm::CodeModelDefault,\n+        \"small\" => llvm::CodeModelSmall,\n+        \"kernel\" => llvm::CodeModelKernel,\n+        \"medium\" => llvm::CodeModelMedium,\n+        \"large\" => llvm::CodeModelLarge,\n+        _ => {\n+            sess.err(format!(\"{} is not a valid code model\",\n+                             sess.opts\n+                                 .cg\n+                                 .code_model).as_slice());\n+            sess.abort_if_errors();\n+            unreachable!();\n+        }\n+    };\n \n-        let tm = sess.targ_cfg\n-                     .target_strs\n-                     .target_triple\n-                     .as_slice()\n-                     .with_c_str(|t| {\n+    unsafe {\n+        sess.targ_cfg\n+             .target_strs\n+             .target_triple\n+             .as_slice()\n+             .with_c_str(|t| {\n             sess.opts.cg.target_cpu.as_slice().with_c_str(|cpu| {\n                 target_feature(sess).with_c_str(|features| {\n                     llvm::LLVMRustCreateTargetMachine(\n@@ -184,160 +243,531 @@ pub fn run_passes(sess: &Session,\n                     )\n                 })\n             })\n-        });\n+        })\n+    }\n+}\n \n-        // Create the two optimizing pass managers. These mirror what clang\n-        // does, and are by populated by LLVM's default PassManagerBuilder.\n-        // Each manager has a different set of passes, but they also share\n-        // some common passes.\n-        let fpm = llvm::LLVMCreateFunctionPassManagerForModule(llmod);\n-        let mpm = llvm::LLVMCreatePassManager();\n-\n-        // If we're verifying or linting, add them to the function pass\n-        // manager.\n-        let addpass = |pass: &str| {\n-            pass.as_slice().with_c_str(|s| llvm::LLVMRustAddPass(fpm, s))\n-        };\n-        if !sess.no_verify() { assert!(addpass(\"verify\")); }\n \n-        if !sess.opts.cg.no_prepopulate_passes {\n-            llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n-            llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n-            populate_llvm_passes(fpm, mpm, llmod, opt_level,\n-                                 trans.no_builtins);\n+/// Module-specific configuration for `optimize_and_codegen`.\n+#[deriving(Clone)]\n+struct ModuleConfig {\n+    /// LLVM TargetMachine to use for codegen.\n+    tm: TargetMachineRef,\n+    /// Names of additional optimization passes to run.\n+    passes: Vec<String>,\n+    /// Some(level) to optimize at a certain level, or None to run\n+    /// absolutely no optimizations (used for the metadata module).\n+    opt_level: Option<llvm::CodeGenOptLevel>,\n+\n+    // Flags indicating which outputs to produce.\n+    emit_no_opt_bc: bool,\n+    emit_bc: bool,\n+    emit_lto_bc: bool,\n+    emit_ir: bool,\n+    emit_asm: bool,\n+    emit_obj: bool,\n+\n+    // Miscellaneous flags.  These are mostly copied from command-line\n+    // options.\n+    no_verify: bool,\n+    no_prepopulate_passes: bool,\n+    no_builtins: bool,\n+    time_passes: bool,\n+}\n+\n+impl ModuleConfig {\n+    fn new(tm: TargetMachineRef, passes: Vec<String>) -> ModuleConfig {\n+        ModuleConfig {\n+            tm: tm,\n+            passes: passes,\n+            opt_level: None,\n+\n+            emit_no_opt_bc: false,\n+            emit_bc: false,\n+            emit_lto_bc: false,\n+            emit_ir: false,\n+            emit_asm: false,\n+            emit_obj: false,\n+\n+            no_verify: false,\n+            no_prepopulate_passes: false,\n+            no_builtins: false,\n+            time_passes: false,\n         }\n+    }\n \n-        for pass in sess.opts.cg.passes.iter() {\n-            pass.as_slice().with_c_str(|s| {\n-                if !llvm::LLVMRustAddPass(mpm, s) {\n-                    sess.warn(format!(\"unknown pass {}, ignoring\",\n-                                      *pass).as_slice());\n-                }\n-            })\n+    fn set_flags(&mut self, sess: &Session, trans: &CrateTranslation) {\n+        self.no_verify = sess.no_verify();\n+        self.no_prepopulate_passes = sess.opts.cg.no_prepopulate_passes;\n+        self.no_builtins = trans.no_builtins;\n+        self.time_passes = sess.time_passes();\n+    }\n+}\n+\n+/// Additional resources used by optimize_and_codegen (not module specific)\n+struct CodegenContext<'a> {\n+    // Extra resources used for LTO: (sess, reachable).  This will be `None`\n+    // when running in a worker thread.\n+    lto_ctxt: Option<(&'a Session, &'a [String])>,\n+    // Handler to use for diagnostics produced during codegen.\n+    handler: &'a Handler,\n+}\n+\n+impl<'a> CodegenContext<'a> {\n+    fn new(handler: &'a Handler) -> CodegenContext<'a> {\n+        CodegenContext {\n+            lto_ctxt: None,\n+            handler: handler,\n         }\n+    }\n \n-        // Finally, run the actual optimization passes\n-        time(sess.time_passes(), \"llvm function passes\", (), |()|\n-             llvm::LLVMRustRunFunctionPassManager(fpm, llmod));\n-        time(sess.time_passes(), \"llvm module passes\", (), |()|\n-             llvm::LLVMRunPassManager(mpm, llmod));\n-\n-        // Deallocate managers that we're now done with\n-        llvm::LLVMDisposePassManager(fpm);\n-        llvm::LLVMDisposePassManager(mpm);\n-\n-        // Emit the bytecode if we're either saving our temporaries or\n-        // emitting an rlib. Whenever an rlib is created, the bytecode is\n-        // inserted into the archive in order to allow LTO against it.\n-        if sess.opts.cg.save_temps ||\n-           (sess.crate_types.borrow().contains(&config::CrateTypeRlib) &&\n-            sess.opts.output_types.contains(&OutputTypeExe)) {\n-            output.temp_path(OutputTypeBitcode).with_c_str(|buf| {\n-                llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-            })\n+    fn new_with_session(sess: &'a Session, reachable: &'a [String]) -> CodegenContext<'a> {\n+        CodegenContext {\n+            lto_ctxt: Some((sess, reachable)),\n+            handler: sess.diagnostic().handler(),\n         }\n+    }\n+}\n \n-        if sess.lto() {\n-            time(sess.time_passes(), \"all lto passes\", (), |()|\n-                 lto::run(sess, llmod, tm, trans.reachable.as_slice()));\n+// Unsafe due to LLVM calls.\n+unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n+                               mtrans: ModuleTranslation,\n+                               config: ModuleConfig,\n+                               name_extra: String,\n+                               output_names: OutputFilenames) {\n+    let ModuleTranslation { llmod, llcx } = mtrans;\n+    let tm = config.tm;\n+\n+    if config.emit_no_opt_bc {\n+        let ext = format!(\"{}.no-opt.bc\", name_extra);\n+        output_names.with_extension(ext.as_slice()).with_c_str(|buf| {\n+            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n+        })\n+    }\n \n-            if sess.opts.cg.save_temps {\n-                output.with_extension(\"lto.bc\").with_c_str(|buf| {\n-                    llvm::LLVMWriteBitcodeToFile(llmod, buf);\n+    match config.opt_level {\n+        Some(opt_level) => {\n+            // Create the two optimizing pass managers. These mirror what clang\n+            // does, and are by populated by LLVM's default PassManagerBuilder.\n+            // Each manager has a different set of passes, but they also share\n+            // some common passes.\n+            let fpm = llvm::LLVMCreateFunctionPassManagerForModule(llmod);\n+            let mpm = llvm::LLVMCreatePassManager();\n+\n+            // If we're verifying or linting, add them to the function pass\n+            // manager.\n+            let addpass = |pass: &str| {\n+                pass.as_slice().with_c_str(|s| llvm::LLVMRustAddPass(fpm, s))\n+            };\n+            if !config.no_verify { assert!(addpass(\"verify\")); }\n+\n+            if !config.no_prepopulate_passes {\n+                llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n+                llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n+                populate_llvm_passes(fpm, mpm, llmod, opt_level,\n+                                     config.no_builtins);\n+            }\n+\n+            for pass in config.passes.iter() {\n+                pass.as_slice().with_c_str(|s| {\n+                    if !llvm::LLVMRustAddPass(mpm, s) {\n+                        cgcx.handler.warn(format!(\"unknown pass {}, ignoring\",\n+                                                  *pass).as_slice());\n+                    }\n                 })\n             }\n-        }\n \n-        // A codegen-specific pass manager is used to generate object\n-        // files for an LLVM module.\n-        //\n-        // Apparently each of these pass managers is a one-shot kind of\n-        // thing, so we create a new one for each type of output. The\n-        // pass manager passed to the closure should be ensured to not\n-        // escape the closure itself, and the manager should only be\n-        // used once.\n-        fn with_codegen(tm: TargetMachineRef, llmod: ModuleRef,\n-                        no_builtins: bool, f: |PassManagerRef|) {\n-            unsafe {\n-                let cpm = llvm::LLVMCreatePassManager();\n-                llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n-                llvm::LLVMRustAddLibraryInfo(cpm, llmod, no_builtins);\n-                f(cpm);\n-                llvm::LLVMDisposePassManager(cpm);\n+            // Finally, run the actual optimization passes\n+            time(config.time_passes, \"llvm function passes\", (), |()|\n+                 llvm::LLVMRustRunFunctionPassManager(fpm, llmod));\n+            time(config.time_passes, \"llvm module passes\", (), |()|\n+                 llvm::LLVMRunPassManager(mpm, llmod));\n+\n+            // Deallocate managers that we're now done with\n+            llvm::LLVMDisposePassManager(fpm);\n+            llvm::LLVMDisposePassManager(mpm);\n+\n+            match cgcx.lto_ctxt {\n+                Some((sess, reachable)) if sess.lto() =>  {\n+                    time(sess.time_passes(), \"all lto passes\", (), |()|\n+                         lto::run(sess, llmod, tm, reachable));\n+\n+                    if config.emit_lto_bc {\n+                        let name = format!(\"{}.lto.bc\", name_extra);\n+                        output_names.with_extension(name.as_slice()).with_c_str(|buf| {\n+                            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n+                        })\n+                    }\n+                },\n+                _ => {},\n             }\n+        },\n+        None => {},\n+    }\n+\n+    // A codegen-specific pass manager is used to generate object\n+    // files for an LLVM module.\n+    //\n+    // Apparently each of these pass managers is a one-shot kind of\n+    // thing, so we create a new one for each type of output. The\n+    // pass manager passed to the closure should be ensured to not\n+    // escape the closure itself, and the manager should only be\n+    // used once.\n+    unsafe fn with_codegen(tm: TargetMachineRef, llmod: ModuleRef,\n+                    no_builtins: bool, f: |PassManagerRef|) {\n+        let cpm = llvm::LLVMCreatePassManager();\n+        llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n+        llvm::LLVMRustAddLibraryInfo(cpm, llmod, no_builtins);\n+        f(cpm);\n+        llvm::LLVMDisposePassManager(cpm);\n+    }\n+\n+    if config.emit_bc {\n+        let ext = format!(\"{}.bc\", name_extra);\n+        output_names.with_extension(ext.as_slice()).with_c_str(|buf| {\n+            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n+        })\n+    }\n+\n+    time(config.time_passes, \"codegen passes\", (), |()| {\n+        if config.emit_ir {\n+            let ext = format!(\"{}.ll\", name_extra);\n+            output_names.with_extension(ext.as_slice()).with_c_str(|output| {\n+                with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                    llvm::LLVMRustPrintModule(cpm, llmod, output);\n+                })\n+            })\n         }\n \n-        let mut object_file = None;\n-        let mut needs_metadata = false;\n-        for output_type in output_types.iter() {\n-            let path = output.path(*output_type);\n-            match *output_type {\n-                OutputTypeBitcode => {\n-                    path.with_c_str(|buf| {\n-                        llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                    })\n-                }\n-                OutputTypeLlvmAssembly => {\n-                    path.with_c_str(|output| {\n-                        with_codegen(tm, llmod, trans.no_builtins, |cpm| {\n-                            llvm::LLVMRustPrintModule(cpm, llmod, output);\n-                        })\n-                    })\n-                }\n-                OutputTypeAssembly => {\n-                    // If we're not using the LLVM assembler, this function\n-                    // could be invoked specially with output_type_assembly,\n-                    // so in this case we still want the metadata object\n-                    // file.\n-                    let ty = OutputTypeAssembly;\n-                    let path = if sess.opts.output_types.contains(&ty) {\n-                       path\n-                    } else {\n-                        needs_metadata = true;\n-                        output.temp_path(OutputTypeAssembly)\n-                    };\n-                    with_codegen(tm, llmod, trans.no_builtins, |cpm| {\n-                        write_output_file(sess, tm, cpm, llmod, &path,\n-                                        llvm::AssemblyFile);\n-                    });\n-                }\n-                OutputTypeObject => {\n-                    object_file = Some(path);\n-                }\n-                OutputTypeExe => {\n-                    object_file = Some(output.temp_path(OutputTypeObject));\n-                    needs_metadata = true;\n+        if config.emit_asm {\n+            let path = output_names.with_extension(format!(\"{}.s\", name_extra).as_slice());\n+            with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::AssemblyFile);\n+            });\n+        }\n+\n+        if config.emit_obj {\n+            let path = output_names.with_extension(format!(\"{}.o\", name_extra).as_slice());\n+            with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::ObjectFile);\n+            });\n+        }\n+    });\n+\n+    llvm::LLVMDisposeModule(llmod);\n+    llvm::LLVMContextDispose(llcx);\n+    llvm::LLVMRustDisposeTargetMachine(tm);\n+}\n+\n+pub fn run_passes(sess: &Session,\n+                  trans: &CrateTranslation,\n+                  output_types: &[OutputType],\n+                  crate_output: &OutputFilenames) {\n+    // It's possible that we have `codegen_units > 1` but only one item in\n+    // `trans.modules`.  We could theoretically proceed and do LTO in that\n+    // case, but it would be confusing to have the validity of\n+    // `-Z lto -C codegen-units=2` depend on details of the crate being\n+    // compiled, so we complain regardless.\n+    if sess.lto() && sess.opts.cg.codegen_units > 1 {\n+        // This case is impossible to handle because LTO expects to be able\n+        // to combine the entire crate and all its dependencies into a\n+        // single compilation unit, but each codegen unit is in a separate\n+        // LLVM context, so they can't easily be combined.\n+        sess.fatal(\"can't perform LTO when using multiple codegen units\");\n+    }\n+\n+    unsafe {\n+        configure_llvm(sess);\n+    }\n+\n+    let tm = create_target_machine(sess);\n+\n+    // Figure out what we actually need to build.\n+\n+    let mut modules_config = ModuleConfig::new(tm, sess.opts.cg.passes.clone());\n+    let mut metadata_config = ModuleConfig::new(tm, vec!());\n+\n+    modules_config.opt_level = Some(get_llvm_opt_level(sess.opts.optimize));\n+\n+    // Save all versions of the bytecode if we're saving our temporaries.\n+    if sess.opts.cg.save_temps {\n+        modules_config.emit_no_opt_bc = true;\n+        modules_config.emit_bc = true;\n+        modules_config.emit_lto_bc = true;\n+        metadata_config.emit_bc = true;\n+    }\n+\n+    // Emit a bitcode file for the crate if we're emitting an rlib.\n+    // Whenever an rlib is created, the bitcode is inserted into the\n+    // archive in order to allow LTO against it.\n+    let needs_crate_bitcode =\n+            sess.crate_types.borrow().contains(&config::CrateTypeRlib) &&\n+            sess.opts.output_types.contains(&OutputTypeExe) &&\n+            sess.opts.cg.codegen_units == 1;\n+    if needs_crate_bitcode {\n+        modules_config.emit_bc = true;\n+    }\n+\n+    for output_type in output_types.iter() {\n+        match *output_type {\n+            OutputTypeBitcode => { modules_config.emit_bc = true; },\n+            OutputTypeLlvmAssembly => { modules_config.emit_ir = true; },\n+            OutputTypeAssembly => {\n+                modules_config.emit_asm = true;\n+                // If we're not using the LLVM assembler, this function\n+                // could be invoked specially with output_type_assembly, so\n+                // in this case we still want the metadata object file.\n+                if !sess.opts.output_types.contains(&OutputTypeAssembly) {\n+                    metadata_config.emit_obj = true;\n                 }\n+            },\n+            OutputTypeObject => { modules_config.emit_obj = true; },\n+            OutputTypeExe => {\n+                modules_config.emit_obj = true;\n+                metadata_config.emit_obj = true;\n+            },\n+        }\n+    }\n+\n+    modules_config.set_flags(sess, trans);\n+    metadata_config.set_flags(sess, trans);\n+\n+\n+    // Populate a buffer with a list of codegen tasks.  Items are processed in\n+    // LIFO order, just because it's a tiny bit simpler that way.  (The order\n+    // doesn't actually matter.)\n+    let mut work_items = Vec::with_capacity(1 + trans.modules.len());\n+\n+    {\n+        let work = build_work_item(sess,\n+                                   trans.metadata_module,\n+                                   metadata_config.clone(),\n+                                   crate_output.clone(),\n+                                   \"metadata\".to_string());\n+        work_items.push(work);\n+    }\n+\n+    for (index, mtrans) in trans.modules.iter().enumerate() {\n+        let work = build_work_item(sess,\n+                                   *mtrans,\n+                                   modules_config.clone(),\n+                                   crate_output.clone(),\n+                                   format!(\"{}\", index));\n+        work_items.push(work);\n+    }\n+\n+    // Process the work items, optionally using worker threads.\n+    if sess.opts.cg.codegen_units == 1 {\n+        run_work_singlethreaded(sess, trans.reachable.as_slice(), work_items);\n+\n+        if needs_crate_bitcode {\n+            // The only bitcode file produced (aside from metadata) was\n+            // \"crate.0.bc\".  Rename to \"crate.bc\" since that's what\n+            // `link_rlib` expects to find.\n+            fs::copy(&crate_output.with_extension(\"0.bc\"),\n+                     &crate_output.temp_path(OutputTypeBitcode)).unwrap();\n+        }\n+    } else {\n+        run_work_multithreaded(sess, work_items, sess.opts.cg.codegen_units);\n+\n+        assert!(!needs_crate_bitcode,\n+               \"can't produce a crate bitcode file from multiple compilation units\");\n+    }\n+\n+    // All codegen is finished.\n+    unsafe {\n+        llvm::LLVMRustDisposeTargetMachine(tm);\n+    }\n+\n+    // Produce final compile outputs.\n+\n+    let copy_if_one_unit = |ext: &str, output_type: OutputType| {\n+        // Three cases:\n+        if sess.opts.cg.codegen_units == 1 {\n+            // 1) Only one codegen unit.  In this case it's no difficulty\n+            //    to copy `foo.0.x` to `foo.x`.\n+            fs::copy(&crate_output.with_extension(ext),\n+                     &crate_output.path(output_type)).unwrap();\n+        } else {\n+            if crate_output.single_output_file.is_some() {\n+                // 2) Multiple codegen units, with `-o some_name`.  We have\n+                //    no good solution for this case, so warn the user.\n+                sess.warn(format!(\"ignoring specified output filename \\\n+                                   because multiple .{} files were produced\",\n+                                  ext).as_slice());\n+            } else {\n+                // 3) Multiple codegen units, but no `-o some_name`.  We\n+                //    just leave the `foo.0.x` files in place.\n+                // (We don't have to do any work in this case.)\n             }\n         }\n+    };\n+\n+    let link_obj = |output_path: &Path| {\n+        let mut cmd = Command::new(\"ld\");\n+\n+        for index in range(0, trans.modules.len()) {\n+            cmd.arg(crate_output.with_extension(format!(\"{}.o\", index).as_slice()));\n+        }\n+\n+        cmd.arg(\"-r\").arg(\"-o\").arg(output_path);\n+        cmd.stdin(::std::io::process::Ignored)\n+           .stdout(::std::io::process::InheritFd(1))\n+           .stderr(::std::io::process::InheritFd(2));\n+        cmd.status().unwrap();\n+    };\n \n-        time(sess.time_passes(), \"codegen passes\", (), |()| {\n-            match object_file {\n-                Some(ref path) => {\n-                    with_codegen(tm, llmod, trans.no_builtins, |cpm| {\n-                        write_output_file(sess, tm, cpm, llmod, path,\n-                                        llvm::ObjectFile);\n-                    });\n+    // Flag to indicate whether the user explicitly requested bitcode.\n+    // Otherwise, we produced it only as a temporary output, and will need\n+    // to get rid of it.\n+    // FIXME: Since we don't support LTO anyway, maybe we can avoid\n+    // producing the temporary .0.bc's in the first place?\n+    let mut save_bitcode = false;\n+    for output_type in output_types.iter() {\n+        match *output_type {\n+            OutputTypeBitcode => {\n+                save_bitcode = true;\n+                copy_if_one_unit(\"0.bc\", OutputTypeBitcode);\n+            },\n+            OutputTypeLlvmAssembly => { copy_if_one_unit(\"0.ll\", OutputTypeLlvmAssembly); },\n+            OutputTypeAssembly => { copy_if_one_unit(\"0.s\", OutputTypeAssembly); },\n+            OutputTypeObject => { link_obj(&crate_output.path(OutputTypeObject)); },\n+            OutputTypeExe => {\n+                // If OutputTypeObject is already in the list, then\n+                // `crate.o` will be handled by the OutputTypeObject case.\n+                // Otherwise, we need to create the temporary object so we\n+                // can run the linker.\n+                if !sess.opts.output_types.contains(&OutputTypeObject) {\n+                    link_obj(&crate_output.temp_path(OutputTypeObject));\n                 }\n-                None => {}\n+            },\n+        }\n+    }\n+    let save_bitcode = save_bitcode;\n+\n+    // Clean up unwanted temporary files.\n+\n+    // We create the following files by default:\n+    //  - crate.0.bc\n+    //  - crate.0.o\n+    //  - crate.metadata.bc\n+    //  - crate.metadata.o\n+    //  - crate.o (linked from crate.##.o)\n+    //  - crate.bc (copied from crate.0.bc, or an empty bitcode file)\n+    // We may create additional files if requested by the user (through\n+    // `-C save-temps` or `--emit=` flags).\n+\n+    if !sess.opts.cg.save_temps {\n+        // Remove the temporary .0.o objects.  If the user didn't\n+        // explicitly request bitcode (with --emit=bc), we must remove\n+        // .0.bc as well.  (We don't touch the crate.bc that may have been\n+        // produced earlier.)\n+        for i in range(0, trans.modules.len()) {\n+            if modules_config.emit_obj {\n+                let ext = format!(\"{}.o\", i);\n+                remove(sess, &crate_output.with_extension(ext.as_slice()));\n             }\n-            if needs_metadata {\n-                with_codegen(tm, trans.metadata_module,\n-                             trans.no_builtins, |cpm| {\n-                    let out = output.temp_path(OutputTypeObject)\n-                                    .with_extension(\"metadata.o\");\n-                    write_output_file(sess, tm, cpm,\n-                                    trans.metadata_module, &out,\n-                                    llvm::ObjectFile);\n-                })\n+\n+            if modules_config.emit_bc && !save_bitcode {\n+                let ext = format!(\"{}.bc\", i);\n+                remove(sess, &crate_output.with_extension(ext.as_slice()));\n+            }\n+        }\n+\n+        if metadata_config.emit_bc && !save_bitcode {\n+            remove(sess, &crate_output.with_extension(\"metadata.bc\"));\n+        }\n+    }\n+\n+    // We leave the following files around by default:\n+    //  - crate.o\n+    //  - crate.metadata.o\n+    //  - crate.bc\n+    // These are used in linking steps and will be cleaned up afterward.\n+\n+    // FIXME: time_llvm_passes support - does this use a global context or\n+    // something?\n+    //if sess.time_llvm_passes() { llvm::LLVMRustPrintPassTimings(); }\n+}\n+\n+type WorkItem = proc(&CodegenContext):Send;\n+\n+fn build_work_item(sess: &Session,\n+                   mtrans: ModuleTranslation,\n+                   config: ModuleConfig,\n+                   output_names: OutputFilenames,\n+                   name_extra: String) -> WorkItem {\n+    let mut config = config;\n+    config.tm = create_target_machine(sess);\n+\n+    proc(cgcx) unsafe {\n+        optimize_and_codegen(cgcx, mtrans, config, name_extra, output_names);\n+    }\n+}\n+\n+fn run_work_singlethreaded(sess: &Session,\n+                           reachable: &[String],\n+                           work_items: Vec<WorkItem>) {\n+    let cgcx = CodegenContext::new_with_session(sess, reachable);\n+    let mut work_items = work_items;\n+\n+    // Since we're running single-threaded, we can pass the session to\n+    // the proc, allowing `optimize_and_codegen` to perform LTO.\n+    for work in Unfold::new((), |_| work_items.pop()) {\n+        work(&cgcx);\n+    }\n+}\n+\n+fn run_work_multithreaded(sess: &Session,\n+                          work_items: Vec<WorkItem>,\n+                          num_workers: uint) {\n+    // Run some workers to process the work items.\n+    let work_items_arc = Arc::new(Mutex::new(work_items));\n+    let mut diag_emitter = SharedEmitter::new();\n+    let mut futures = Vec::with_capacity(num_workers);\n+\n+    for i in range(0, num_workers) {\n+        let work_items_arc = work_items_arc.clone();\n+        let diag_emitter = diag_emitter.clone();\n+\n+        let future = TaskBuilder::new().named(format!(\"codegen-{}\", i)).try_future(proc() {\n+            let diag_handler = mk_handler(box diag_emitter);\n+\n+            // Must construct cgcx inside the proc because it has non-Send\n+            // fields.\n+            let cgcx = CodegenContext::new(&diag_handler);\n+\n+            loop {\n+                // Avoid holding the lock for the entire duration of the match.\n+                let maybe_work = work_items_arc.lock().pop();\n+                match maybe_work {\n+                    Some(work) => {\n+                        work(&cgcx);\n+\n+                        // Make sure to fail the worker so the main thread can\n+                        // tell that there were errors.\n+                        cgcx.handler.abort_if_errors();\n+                    }\n+                    None => break,\n+                }\n             }\n         });\n+        futures.push(future);\n+    }\n \n-        llvm::LLVMRustDisposeTargetMachine(tm);\n-        llvm::LLVMDisposeModule(trans.metadata_module);\n-        llvm::LLVMDisposeModule(llmod);\n-        llvm::LLVMContextDispose(llcx);\n-        if sess.time_llvm_passes() { llvm::LLVMRustPrintPassTimings(); }\n+    let mut failed = false;\n+    for future in futures.move_iter() {\n+        match future.unwrap() {\n+            Ok(()) => {},\n+            Err(_) => {\n+                failed = true;\n+            },\n+        }\n+        // Display any new diagnostics.\n+        diag_emitter.dump(sess.diagnostic().handler());\n+    }\n+    if failed {\n+        sess.fatal(\"aborting due to worker thread failure\");\n     }\n }\n "}, {"sha": "3e3a88ceffd67f1810d4458fe55424f856febc1a", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf672850df05a05e8bb5785228c408a24e102d32/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf672850df05a05e8bb5785228c408a24e102d32/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=cf672850df05a05e8bb5785228c408a24e102d32", "patch": "@@ -303,6 +303,13 @@ macro_rules! cgoptions(\n             }\n         }\n \n+        fn parse_uint(slot: &mut uint, v: Option<&str>) -> bool {\n+            use std::from_str::FromStr;\n+            match v.and_then(FromStr::from_str) {\n+                Some(i) => { *slot = i; true },\n+                None => false\n+            }\n+        }\n     }\n ) )\n \n@@ -347,6 +354,8 @@ cgoptions!(\n          \"metadata to mangle symbol names with\"),\n     extra_filename: String = (\"\".to_string(), parse_string,\n          \"extra data to put in each output filename\"),\n+    codegen_units: uint = (1, parse_uint,\n+        \"divide crate into N units to optimize in parallel\"),\n )\n \n pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions"}, {"sha": "09bf69bff4cdd5ee5ef8d5b69e1057faec1ef8dd", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf672850df05a05e8bb5785228c408a24e102d32/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf672850df05a05e8bb5785228c408a24e102d32/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=cf672850df05a05e8bb5785228c408a24e102d32", "patch": "@@ -442,11 +442,14 @@ pub fn phase_save_analysis(sess: &Session,\n          middle::save::process_crate(sess, krate, analysis, odir));\n }\n \n+pub struct ModuleTranslation {\n+    pub llcx: ContextRef,\n+    pub llmod: ModuleRef,\n+}\n+\n pub struct CrateTranslation {\n-    pub context: ContextRef,\n-    pub module: ModuleRef,\n-    pub metadata_context: ContextRef,\n-    pub metadata_module: ModuleRef,\n+    pub modules: Vec<ModuleTranslation>,\n+    pub metadata_module: ModuleTranslation,\n     pub link: LinkMeta,\n     pub metadata: Vec<u8>,\n     pub reachable: Vec<String>,\n@@ -681,6 +684,7 @@ pub fn collect_crate_metadata(session: &Session,\n     session.opts.cg.metadata.clone()\n }\n \n+#[deriving(Clone)]\n pub struct OutputFilenames {\n     pub out_directory: Path,\n     pub out_filestem: String,"}, {"sha": "d56fb31fb20dcc82c9e2c6614a9d8111bdf036b9", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cf672850df05a05e8bb5785228c408a24e102d32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf672850df05a05e8bb5785228c408a24e102d32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=cf672850df05a05e8bb5785228c408a24e102d32", "patch": "@@ -29,7 +29,7 @@ use back::link::{mangle_exported_name};\n use back::{link, abi};\n use driver::config;\n use driver::config::{NoDebugInfo, FullDebugInfo};\n-use driver::driver::{CrateAnalysis, CrateTranslation};\n+use driver::driver::{CrateAnalysis, CrateTranslation, ModuleTranslation};\n use driver::session::Session;\n use lint;\n use llvm::{BasicBlockRef, ModuleRef, ValueRef, Vector, get_param};\n@@ -47,8 +47,8 @@ use middle::trans::builder::{Builder, noname};\n use middle::trans::callee;\n use middle::trans::cleanup::{CleanupMethods, ScopeId};\n use middle::trans::cleanup;\n-use middle::trans::common::{Block, C_bool, C_bytes, C_i32, C_integral, C_nil};\n-use middle::trans::common::{C_null, C_struct, C_u64, C_u8, C_uint, C_undef};\n+use middle::trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_integral, C_nil};\n+use middle::trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_uint, C_undef};\n use middle::trans::common::{CrateContext, ExternMap, FunctionContext};\n use middle::trans::common::{NodeInfo, Result, SubstP, monomorphize_type};\n use middle::trans::common::{node_id_type, param_substs, return_type_is_void};\n@@ -2852,8 +2852,8 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n                              cx.sess().fatal(\"failed to compress metadata\")\n                          }\n                      }.as_slice());\n-    let llmeta = C_bytes(cx, compressed.as_slice());\n-    let llconst = C_struct(cx, [llmeta], false);\n+    let llmeta = C_bytes_in_context(cx.metadata_llcx(), compressed.as_slice());\n+    let llconst = C_struct_in_context(cx.metadata_llcx(), [llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}\",\n                        cx.link_meta().crate_name,\n                        cx.link_meta().crate_hash);\n@@ -2896,8 +2896,7 @@ pub fn trans_crate(krate: ast::Crate,\n \n     let link_meta = link::build_link_meta(&tcx.sess, &krate, name);\n \n-    // Multiple compilation units won't be supported until a later commit.\n-    let codegen_units = 1;\n+    let codegen_units = tcx.sess.opts.cg.codegen_units;\n     let shared_ccx = SharedCrateContext::new(link_meta.crate_name.as_slice(),\n                                              codegen_units,\n                                              tcx,\n@@ -2957,8 +2956,9 @@ pub fn trans_crate(krate: ast::Crate,\n         }\n     }\n \n-    let llcx = shared_ccx.get_ccx(0).llcx();\n-    let llmod = shared_ccx.get_ccx(0).llmod();\n+    let modules = shared_ccx.iter()\n+        .map(|ccx| ModuleTranslation { llcx: ccx.llcx(), llmod: ccx.llmod() })\n+        .collect();\n \n     let mut reachable: Vec<String> = shared_ccx.reachable().iter().filter_map(|id| {\n         shared_ccx.item_symbols().borrow().find(id).map(|s| s.to_string())\n@@ -2988,20 +2988,22 @@ pub fn trans_crate(krate: ast::Crate,\n     // referenced from rt/rust_try.ll\n     reachable.push(\"rust_eh_personality_catch\".to_string());\n \n-    let metadata_module = shared_ccx.metadata_llmod();\n-    let metadata_context = shared_ccx.metadata_llcx();\n+    let metadata_module = ModuleTranslation {\n+        llcx: shared_ccx.metadata_llcx(),\n+        llmod: shared_ccx.metadata_llmod(),\n+    };\n     let formats = shared_ccx.tcx().dependency_formats.borrow().clone();\n     let no_builtins = attr::contains_name(krate.attrs.as_slice(), \"no_builtins\");\n \n-    (shared_ccx.take_tcx(), CrateTranslation {\n-        context: llcx,\n-        module: llmod,\n-        link: link_meta,\n+    let translation = CrateTranslation {\n+        modules: modules,\n         metadata_module: metadata_module,\n-        metadata_context: metadata_context,\n+        link: link_meta,\n         metadata: metadata,\n         reachable: reachable,\n         crate_formats: formats,\n         no_builtins: no_builtins,\n-    })\n+    };\n+\n+    (shared_ccx.take_tcx(), translation)\n }"}, {"sha": "4ea60a4e128ad608b9053178fb501575e4260b04", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cf672850df05a05e8bb5785228c408a24e102d32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf672850df05a05e8bb5785228c408a24e102d32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=cf672850df05a05e8bb5785228c408a24e102d32", "patch": "@@ -14,7 +14,7 @@\n \n use driver::session::Session;\n use llvm;\n-use llvm::{ValueRef, BasicBlockRef, BuilderRef};\n+use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef};\n use llvm::{True, False, Bool};\n use middle::def;\n use middle::freevars;\n@@ -669,9 +669,13 @@ pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n     }\n }\n \n-pub fn C_struct(ccx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {\n+pub fn C_struct(cx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {\n+    C_struct_in_context(cx.llcx(), elts, packed)\n+}\n+\n+pub fn C_struct_in_context(llcx: ContextRef, elts: &[ValueRef], packed: bool) -> ValueRef {\n     unsafe {\n-        llvm::LLVMConstStructInContext(ccx.llcx(),\n+        llvm::LLVMConstStructInContext(llcx,\n                                        elts.as_ptr(), elts.len() as c_uint,\n                                        packed as Bool)\n     }\n@@ -689,10 +693,14 @@ pub fn C_array(ty: Type, elts: &[ValueRef]) -> ValueRef {\n     }\n }\n \n-pub fn C_bytes(ccx: &CrateContext, bytes: &[u8]) -> ValueRef {\n+pub fn C_bytes(cx: &CrateContext, bytes: &[u8]) -> ValueRef {\n+    C_bytes_in_context(cx.llcx(), bytes)\n+}\n+\n+pub fn C_bytes_in_context(llcx: ContextRef, bytes: &[u8]) -> ValueRef {\n     unsafe {\n         let ptr = bytes.as_ptr() as *const c_char;\n-        return llvm::LLVMConstStringInContext(ccx.llcx(), ptr, bytes.len() as c_uint, True);\n+        return llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True);\n     }\n }\n "}, {"sha": "a25070e89ee059d958ef5a45ace098e9ef784679", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cf672850df05a05e8bb5785228c408a24e102d32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf672850df05a05e8bb5785228c408a24e102d32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=cf672850df05a05e8bb5785228c408a24e102d32", "patch": "@@ -148,6 +148,27 @@ pub struct CrateContext<'a> {\n     local: &'a LocalCrateContext,\n }\n \n+pub struct CrateContextIterator<'a> {\n+    shared: &'a SharedCrateContext,\n+    index: uint,\n+}\n+\n+impl<'a> Iterator<CrateContext<'a>> for CrateContextIterator<'a> {\n+    fn next(&mut self) -> Option<CrateContext<'a>> {\n+        if self.index >= self.shared.local_ccxs.len() {\n+            return None;\n+        }\n+\n+        let index = self.index;\n+        self.index += 1;\n+\n+        Some(CrateContext {\n+            shared: self.shared,\n+            local: &self.shared.local_ccxs[index],\n+        })\n+    }\n+}\n+\n unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {\n     let llcx = llvm::LLVMContextCreate();\n     let llmod = mod_name.with_c_str(|buf| {\n@@ -226,6 +247,13 @@ impl SharedCrateContext {\n         shared_ccx\n     }\n \n+    pub fn iter<'a>(&'a self) -> CrateContextIterator<'a> {\n+        CrateContextIterator {\n+            shared: self,\n+            index: 0,\n+        }\n+    }\n+\n     pub fn get_ccx<'a>(&'a self, index: uint) -> CrateContext<'a> {\n         CrateContext {\n             shared: self,"}, {"sha": "ceb29ddcf8fe5e0ab2f094b88fdcbf94df034c1b", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf672850df05a05e8bb5785228c408a24e102d32/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf672850df05a05e8bb5785228c408a24e102d32/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=cf672850df05a05e8bb5785228c408a24e102d32", "patch": "@@ -331,7 +331,7 @@ pub enum AsmDialect {\n     AD_Intel = 1\n }\n \n-#[deriving(PartialEq)]\n+#[deriving(PartialEq, Clone)]\n #[repr(C)]\n pub enum CodeGenOptLevel {\n     CodeGenLevelNone = 0,"}]}