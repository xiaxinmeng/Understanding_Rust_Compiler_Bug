{"sha": "dff7d51fcc8e5bb69d45db4f177fb15fab48b781", "node_id": "C_kwDOAAsO6NoAKGRmZjdkNTFmY2M4ZTViYjY5ZDQ1ZGI0ZjE3N2ZiMTVmYWI0OGI3ODE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-13T05:44:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-13T05:44:18Z"}, "message": "Rollup merge of #93936 - bjorn3:simplifications2, r=cjgillot\n\nCouple of driver cleanups\n\n* Remove the `RustcDefaultCalls` struct, which hasn't been necessary since the introduction of `rustc_interface`.\n* Move the `setup_callbacks` call around for a tiny code deduplication.\n* Remove the `SPAN_DEBUG` global as it isn't actually necessary.", "tree": {"sha": "4bf49d6c49fa144db5a6fb8138773882ed426876", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bf49d6c49fa144db5a6fb8138773882ed426876"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dff7d51fcc8e5bb69d45db4f177fb15fab48b781", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiCJqzCRBK7hj4Ov3rIwAA0fwIAIWKIDZQaa3EEEJQdUMIbzJ+\n5jxW88el74GrQwukuJCmlSDBfun7Ux6tV5LMK6/q9A3NW88l1vBimJm7Exft0VjK\nUAfmW6jzRDnmbkejvJK/VJt7CbhdQan/PLPgiDmKhSL6/WxQ4kxtAxYLa7KXI5w0\nWyL/NXZbK30+L+biKtelMUwIeGsuSomziR8WIDA3FiusiR5MLWp9j1148QT5ZnTP\n0VFFVIVxvjzbP6m2/VX6SLfTHukWKAGmtAaT1nk+Y3TkvV1rezOBBCzNWi6eoidN\nlY9kimsNA5L2Wnep7X8m9tE44LPaW6kKLcnMPfSVNbqbwuJ6fpz1Yuo0qyUWG9A=\n=aU1n\n-----END PGP SIGNATURE-----\n", "payload": "tree 4bf49d6c49fa144db5a6fb8138773882ed426876\nparent 2b7f3ee89de5ca407da4526a4438bdf453cf34e6\nparent f45ba82370f580fba0f1486f745607d7d30ef330\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1644731058 +0100\ncommitter GitHub <noreply@github.com> 1644731058 +0100\n\nRollup merge of #93936 - bjorn3:simplifications2, r=cjgillot\n\nCouple of driver cleanups\n\n* Remove the `RustcDefaultCalls` struct, which hasn't been necessary since the introduction of `rustc_interface`.\n* Move the `setup_callbacks` call around for a tiny code deduplication.\n* Remove the `SPAN_DEBUG` global as it isn't actually necessary.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dff7d51fcc8e5bb69d45db4f177fb15fab48b781", "html_url": "https://github.com/rust-lang/rust/commit/dff7d51fcc8e5bb69d45db4f177fb15fab48b781", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dff7d51fcc8e5bb69d45db4f177fb15fab48b781/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b7f3ee89de5ca407da4526a4438bdf453cf34e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b7f3ee89de5ca407da4526a4438bdf453cf34e6", "html_url": "https://github.com/rust-lang/rust/commit/2b7f3ee89de5ca407da4526a4438bdf453cf34e6"}, {"sha": "f45ba82370f580fba0f1486f745607d7d30ef330", "url": "https://api.github.com/repos/rust-lang/rust/commits/f45ba82370f580fba0f1486f745607d7d30ef330", "html_url": "https://github.com/rust-lang/rust/commit/f45ba82370f580fba0f1486f745607d7d30ef330"}], "stats": {"total": 357, "additions": 158, "deletions": 199}, "files": [{"sha": "7eeae66d709e9baeab17dfa5d5b36295fe90dcf8", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 138, "deletions": 151, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/dff7d51fcc8e5bb69d45db4f177fb15fab48b781/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff7d51fcc8e5bb69d45db4f177fb15fab48b781/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=dff7d51fcc8e5bb69d45db4f177fb15fab48b781", "patch": "@@ -263,7 +263,7 @@ fn run_compiler(\n                         describe_lints(compiler.session(), &lint_store, registered_lints);\n                         return;\n                     }\n-                    let should_stop = RustcDefaultCalls::print_crate_info(\n+                    let should_stop = print_crate_info(\n                         &***compiler.codegen_backend(),\n                         compiler.session(),\n                         None,\n@@ -292,7 +292,7 @@ fn run_compiler(\n \n     interface::run_compiler(config, |compiler| {\n         let sess = compiler.session();\n-        let should_stop = RustcDefaultCalls::print_crate_info(\n+        let should_stop = print_crate_info(\n             &***compiler.codegen_backend(),\n             sess,\n             Some(compiler.input()),\n@@ -301,13 +301,9 @@ fn run_compiler(\n             compiler.temps_dir(),\n         )\n         .and_then(|| {\n-            RustcDefaultCalls::list_metadata(\n-                sess,\n-                &*compiler.codegen_backend().metadata_loader(),\n-                compiler.input(),\n-            )\n+            list_metadata(sess, &*compiler.codegen_backend().metadata_loader(), compiler.input())\n         })\n-        .and_then(|| RustcDefaultCalls::try_process_rlink(sess, compiler));\n+        .and_then(|| try_process_rlink(sess, compiler));\n \n         if should_stop == Compilation::Stop {\n             return sess.compile_status();\n@@ -512,10 +508,6 @@ impl Compilation {\n     }\n }\n \n-/// CompilerCalls instance for a regular rustc build.\n-#[derive(Copy, Clone)]\n-pub struct RustcDefaultCalls;\n-\n fn handle_explain(registry: Registry, code: &str, output: ErrorOutputType) {\n     let upper_cased_code = code.to_ascii_uppercase();\n     let normalised = if upper_cased_code.starts_with('E') {\n@@ -588,162 +580,157 @@ fn show_content_with_pager(content: &str) {\n     }\n }\n \n-impl RustcDefaultCalls {\n-    pub fn try_process_rlink(sess: &Session, compiler: &interface::Compiler) -> Compilation {\n-        if sess.opts.debugging_opts.link_only {\n-            if let Input::File(file) = compiler.input() {\n-                // FIXME: #![crate_type] and #![crate_name] support not implemented yet\n-                sess.init_crate_types(collect_crate_types(sess, &[]));\n-                let outputs = compiler.build_output_filenames(sess, &[]);\n-                let rlink_data = fs::read(file).unwrap_or_else(|err| {\n-                    sess.fatal(&format!(\"failed to read rlink file: {}\", err));\n-                });\n-                let mut decoder = rustc_serialize::opaque::Decoder::new(&rlink_data, 0);\n-                let codegen_results: CodegenResults =\n-                    rustc_serialize::Decodable::decode(&mut decoder);\n-                let result = compiler.codegen_backend().link(sess, codegen_results, &outputs);\n-                abort_on_err(result, sess);\n-            } else {\n-                sess.fatal(\"rlink must be a file\")\n-            }\n-            Compilation::Stop\n+pub fn try_process_rlink(sess: &Session, compiler: &interface::Compiler) -> Compilation {\n+    if sess.opts.debugging_opts.link_only {\n+        if let Input::File(file) = compiler.input() {\n+            // FIXME: #![crate_type] and #![crate_name] support not implemented yet\n+            sess.init_crate_types(collect_crate_types(sess, &[]));\n+            let outputs = compiler.build_output_filenames(sess, &[]);\n+            let rlink_data = fs::read(file).unwrap_or_else(|err| {\n+                sess.fatal(&format!(\"failed to read rlink file: {}\", err));\n+            });\n+            let mut decoder = rustc_serialize::opaque::Decoder::new(&rlink_data, 0);\n+            let codegen_results: CodegenResults = rustc_serialize::Decodable::decode(&mut decoder);\n+            let result = compiler.codegen_backend().link(sess, codegen_results, &outputs);\n+            abort_on_err(result, sess);\n         } else {\n-            Compilation::Continue\n+            sess.fatal(\"rlink must be a file\")\n         }\n+        Compilation::Stop\n+    } else {\n+        Compilation::Continue\n     }\n+}\n \n-    pub fn list_metadata(\n-        sess: &Session,\n-        metadata_loader: &dyn MetadataLoader,\n-        input: &Input,\n-    ) -> Compilation {\n-        if sess.opts.debugging_opts.ls {\n-            match *input {\n-                Input::File(ref ifile) => {\n-                    let path = &(*ifile);\n-                    let mut v = Vec::new();\n-                    locator::list_file_metadata(&sess.target, path, metadata_loader, &mut v)\n-                        .unwrap();\n-                    println!(\"{}\", String::from_utf8(v).unwrap());\n-                }\n-                Input::Str { .. } => {\n-                    early_error(ErrorOutputType::default(), \"cannot list metadata for stdin\");\n-                }\n+pub fn list_metadata(\n+    sess: &Session,\n+    metadata_loader: &dyn MetadataLoader,\n+    input: &Input,\n+) -> Compilation {\n+    if sess.opts.debugging_opts.ls {\n+        match *input {\n+            Input::File(ref ifile) => {\n+                let path = &(*ifile);\n+                let mut v = Vec::new();\n+                locator::list_file_metadata(&sess.target, path, metadata_loader, &mut v).unwrap();\n+                println!(\"{}\", String::from_utf8(v).unwrap());\n+            }\n+            Input::Str { .. } => {\n+                early_error(ErrorOutputType::default(), \"cannot list metadata for stdin\");\n             }\n-            return Compilation::Stop;\n         }\n-\n-        Compilation::Continue\n+        return Compilation::Stop;\n     }\n \n-    fn print_crate_info(\n-        codegen_backend: &dyn CodegenBackend,\n-        sess: &Session,\n-        input: Option<&Input>,\n-        odir: &Option<PathBuf>,\n-        ofile: &Option<PathBuf>,\n-        temps_dir: &Option<PathBuf>,\n-    ) -> Compilation {\n-        use rustc_session::config::PrintRequest::*;\n-        // NativeStaticLibs and LinkArgs are special - printed during linking\n-        // (empty iterator returns true)\n-        if sess.opts.prints.iter().all(|&p| p == NativeStaticLibs || p == LinkArgs) {\n-            return Compilation::Continue;\n-        }\n+    Compilation::Continue\n+}\n \n-        let attrs = match input {\n-            None => None,\n-            Some(input) => {\n-                let result = parse_crate_attrs(sess, input);\n-                match result {\n-                    Ok(attrs) => Some(attrs),\n-                    Err(mut parse_error) => {\n-                        parse_error.emit();\n-                        return Compilation::Stop;\n-                    }\n+fn print_crate_info(\n+    codegen_backend: &dyn CodegenBackend,\n+    sess: &Session,\n+    input: Option<&Input>,\n+    odir: &Option<PathBuf>,\n+    ofile: &Option<PathBuf>,\n+    temps_dir: &Option<PathBuf>,\n+) -> Compilation {\n+    use rustc_session::config::PrintRequest::*;\n+    // NativeStaticLibs and LinkArgs are special - printed during linking\n+    // (empty iterator returns true)\n+    if sess.opts.prints.iter().all(|&p| p == NativeStaticLibs || p == LinkArgs) {\n+        return Compilation::Continue;\n+    }\n+\n+    let attrs = match input {\n+        None => None,\n+        Some(input) => {\n+            let result = parse_crate_attrs(sess, input);\n+            match result {\n+                Ok(attrs) => Some(attrs),\n+                Err(mut parse_error) => {\n+                    parse_error.emit();\n+                    return Compilation::Stop;\n                 }\n             }\n-        };\n-        for req in &sess.opts.prints {\n-            match *req {\n-                TargetList => {\n-                    let mut targets =\n-                        rustc_target::spec::TARGETS.iter().copied().collect::<Vec<_>>();\n-                    targets.sort_unstable();\n-                    println!(\"{}\", targets.join(\"\\n\"));\n-                }\n-                Sysroot => println!(\"{}\", sess.sysroot.display()),\n-                TargetLibdir => println!(\"{}\", sess.target_tlib_path.dir.display()),\n-                TargetSpec => println!(\"{}\", sess.target.to_json().pretty()),\n-                FileNames | CrateName => {\n-                    let input = input.unwrap_or_else(|| {\n-                        early_error(ErrorOutputType::default(), \"no input file provided\")\n-                    });\n-                    let attrs = attrs.as_ref().unwrap();\n-                    let t_outputs = rustc_interface::util::build_output_filenames(\n-                        input, odir, ofile, temps_dir, attrs, sess,\n-                    );\n-                    let id = rustc_session::output::find_crate_name(sess, attrs, input);\n-                    if *req == PrintRequest::CrateName {\n-                        println!(\"{}\", id);\n-                        continue;\n-                    }\n-                    let crate_types = collect_crate_types(sess, attrs);\n-                    for &style in &crate_types {\n-                        let fname =\n-                            rustc_session::output::filename_for_input(sess, style, &id, &t_outputs);\n-                        println!(\"{}\", fname.file_name().unwrap().to_string_lossy());\n-                    }\n+        }\n+    };\n+    for req in &sess.opts.prints {\n+        match *req {\n+            TargetList => {\n+                let mut targets = rustc_target::spec::TARGETS.iter().copied().collect::<Vec<_>>();\n+                targets.sort_unstable();\n+                println!(\"{}\", targets.join(\"\\n\"));\n+            }\n+            Sysroot => println!(\"{}\", sess.sysroot.display()),\n+            TargetLibdir => println!(\"{}\", sess.target_tlib_path.dir.display()),\n+            TargetSpec => println!(\"{}\", sess.target.to_json().pretty()),\n+            FileNames | CrateName => {\n+                let input = input.unwrap_or_else(|| {\n+                    early_error(ErrorOutputType::default(), \"no input file provided\")\n+                });\n+                let attrs = attrs.as_ref().unwrap();\n+                let t_outputs = rustc_interface::util::build_output_filenames(\n+                    input, odir, ofile, temps_dir, attrs, sess,\n+                );\n+                let id = rustc_session::output::find_crate_name(sess, attrs, input);\n+                if *req == PrintRequest::CrateName {\n+                    println!(\"{}\", id);\n+                    continue;\n                 }\n-                Cfg => {\n-                    let mut cfgs = sess\n-                        .parse_sess\n-                        .config\n-                        .iter()\n-                        .filter_map(|&(name, value)| {\n-                            // Note that crt-static is a specially recognized cfg\n-                            // directive that's printed out here as part of\n-                            // rust-lang/rust#37406, but in general the\n-                            // `target_feature` cfg is gated under\n-                            // rust-lang/rust#29717. For now this is just\n-                            // specifically allowing the crt-static cfg and that's\n-                            // it, this is intended to get into Cargo and then go\n-                            // through to build scripts.\n-                            if (name != sym::target_feature || value != Some(sym::crt_dash_static))\n-                                && !sess.is_nightly_build()\n-                                && find_gated_cfg(|cfg_sym| cfg_sym == name).is_some()\n-                            {\n-                                return None;\n-                            }\n-\n-                            if let Some(value) = value {\n-                                Some(format!(\"{}=\\\"{}\\\"\", name, value))\n-                            } else {\n-                                Some(name.to_string())\n-                            }\n-                        })\n-                        .collect::<Vec<String>>();\n-\n-                    cfgs.sort();\n-                    for cfg in cfgs {\n-                        println!(\"{}\", cfg);\n-                    }\n+                let crate_types = collect_crate_types(sess, attrs);\n+                for &style in &crate_types {\n+                    let fname =\n+                        rustc_session::output::filename_for_input(sess, style, &id, &t_outputs);\n+                    println!(\"{}\", fname.file_name().unwrap().to_string_lossy());\n                 }\n-                RelocationModels\n-                | CodeModels\n-                | TlsModels\n-                | TargetCPUs\n-                | StackProtectorStrategies\n-                | TargetFeatures => {\n-                    codegen_backend.print(*req, sess);\n+            }\n+            Cfg => {\n+                let mut cfgs = sess\n+                    .parse_sess\n+                    .config\n+                    .iter()\n+                    .filter_map(|&(name, value)| {\n+                        // Note that crt-static is a specially recognized cfg\n+                        // directive that's printed out here as part of\n+                        // rust-lang/rust#37406, but in general the\n+                        // `target_feature` cfg is gated under\n+                        // rust-lang/rust#29717. For now this is just\n+                        // specifically allowing the crt-static cfg and that's\n+                        // it, this is intended to get into Cargo and then go\n+                        // through to build scripts.\n+                        if (name != sym::target_feature || value != Some(sym::crt_dash_static))\n+                            && !sess.is_nightly_build()\n+                            && find_gated_cfg(|cfg_sym| cfg_sym == name).is_some()\n+                        {\n+                            return None;\n+                        }\n+\n+                        if let Some(value) = value {\n+                            Some(format!(\"{}=\\\"{}\\\"\", name, value))\n+                        } else {\n+                            Some(name.to_string())\n+                        }\n+                    })\n+                    .collect::<Vec<String>>();\n+\n+                cfgs.sort();\n+                for cfg in cfgs {\n+                    println!(\"{}\", cfg);\n                 }\n-                // Any output here interferes with Cargo's parsing of other printed output\n-                NativeStaticLibs => {}\n-                LinkArgs => {}\n             }\n+            RelocationModels\n+            | CodeModels\n+            | TlsModels\n+            | TargetCPUs\n+            | StackProtectorStrategies\n+            | TargetFeatures => {\n+                codegen_backend.print(*req, sess);\n+            }\n+            // Any output here interferes with Cargo's parsing of other printed output\n+            NativeStaticLibs => {}\n+            LinkArgs => {}\n         }\n-        Compilation::Stop\n     }\n+    Compilation::Stop\n }\n \n /// Prints version information"}, {"sha": "a18e2d1d638879fd264bb87775703e8d390546e7", "filename": "compiler/rustc_interface/src/callbacks.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dff7d51fcc8e5bb69d45db4f177fb15fab48b781/compiler%2Frustc_interface%2Fsrc%2Fcallbacks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff7d51fcc8e5bb69d45db4f177fb15fab48b781/compiler%2Frustc_interface%2Fsrc%2Fcallbacks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fcallbacks.rs?ref=dff7d51fcc8e5bb69d45db4f177fb15fab48b781", "patch": "@@ -4,7 +4,7 @@\n //! `rustc_data_structures::AtomicRef` type, which allows us to setup a global\n //! static which can then be set in this file at program startup.\n //!\n-//! See `SPAN_DEBUG` for an example of how to set things up.\n+//! See `SPAN_TRACK` for an example of how to set things up.\n //!\n //! The functions in this file should fall back to the default set in their\n //! origin crate when the `TyCtxt` is not present in TLS.\n@@ -13,18 +13,6 @@ use rustc_errors::{Diagnostic, TRACK_DIAGNOSTICS};\n use rustc_middle::ty::tls;\n use std::fmt;\n \n-/// This is a callback from `rustc_ast` as it cannot access the implicit state\n-/// in `rustc_middle` otherwise.\n-fn span_debug(span: rustc_span::Span, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-    tls::with_opt(|tcx| {\n-        if let Some(tcx) = tcx {\n-            rustc_span::debug_with_source_map(span, f, tcx.sess.source_map())\n-        } else {\n-            rustc_span::default_span_debug(span, f)\n-        }\n-    })\n-}\n-\n fn track_span_parent(def_id: rustc_span::def_id::LocalDefId) {\n     tls::with_opt(|tcx| {\n         if let Some(tcx) = tcx {\n@@ -65,7 +53,6 @@ fn def_id_debug(def_id: rustc_hir::def_id::DefId, f: &mut fmt::Formatter<'_>) ->\n /// Sets up the callbacks in prior crates which we want to refer to the\n /// TyCtxt in.\n pub fn setup_callbacks() {\n-    rustc_span::SPAN_DEBUG.swap(&(span_debug as fn(_, &mut fmt::Formatter<'_>) -> _));\n     rustc_span::SPAN_TRACK.swap(&(track_span_parent as fn(_)));\n     rustc_hir::def_id::DEF_ID_DEBUG.swap(&(def_id_debug as fn(_, &mut fmt::Formatter<'_>) -> _));\n     TRACK_DIAGNOSTICS.swap(&(track_diagnostic as fn(&_)));"}, {"sha": "8bd24487b7843dc05ce28bf820e568ab37917288", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dff7d51fcc8e5bb69d45db4f177fb15fab48b781/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff7d51fcc8e5bb69d45db4f177fb15fab48b781/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=dff7d51fcc8e5bb69d45db4f177fb15fab48b781", "patch": "@@ -186,6 +186,8 @@ pub struct Config {\n }\n \n pub fn create_compiler_and_run<R>(config: Config, f: impl FnOnce(&Compiler) -> R) -> R {\n+    crate::callbacks::setup_callbacks();\n+\n     let registry = &config.registry;\n     let (mut sess, codegen_backend) = util::create_session(\n         config.opts,\n@@ -238,7 +240,7 @@ pub fn create_compiler_and_run<R>(config: Config, f: impl FnOnce(&Compiler) -> R\n pub fn run_compiler<R: Send>(mut config: Config, f: impl FnOnce(&Compiler) -> R + Send) -> R {\n     tracing::trace!(\"run_compiler\");\n     let stderr = config.stderr.take();\n-    util::setup_callbacks_and_run_in_thread_pool_with_globals(\n+    util::run_in_thread_pool_with_globals(\n         config.opts.edition,\n         config.opts.debugging_opts.threads,\n         &stderr,"}, {"sha": "dcad3036cc24d3af834d54eb4d927a89a63b0aa8", "filename": "compiler/rustc_interface/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dff7d51fcc8e5bb69d45db4f177fb15fab48b781/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff7d51fcc8e5bb69d45db4f177fb15fab48b781/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Flib.rs?ref=dff7d51fcc8e5bb69d45db4f177fb15fab48b781", "patch": "@@ -15,6 +15,7 @@ mod proc_macro_decls;\n mod queries;\n pub mod util;\n \n+pub use callbacks::setup_callbacks;\n pub use interface::{run_compiler, Config};\n pub use passes::{DEFAULT_EXTERN_QUERY_PROVIDERS, DEFAULT_QUERY_PROVIDERS};\n pub use queries::Queries;"}, {"sha": "d206f2644e02a4ae3ac757b1594e8e87f2427f17", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dff7d51fcc8e5bb69d45db4f177fb15fab48b781/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff7d51fcc8e5bb69d45db4f177fb15fab48b781/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=dff7d51fcc8e5bb69d45db4f177fb15fab48b781", "patch": "@@ -128,7 +128,7 @@ fn scoped_thread<F: FnOnce() -> R + Send, R: Send>(cfg: thread::Builder, f: F) -\n }\n \n #[cfg(not(parallel_compiler))]\n-pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n+pub fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n     edition: Edition,\n     _threads: usize,\n     stderr: &Option<Arc<Mutex<Vec<u8>>>>,\n@@ -140,8 +140,6 @@ pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Se\n         cfg = cfg.stack_size(size);\n     }\n \n-    crate::callbacks::setup_callbacks();\n-\n     let main_handler = move || {\n         rustc_span::create_session_globals_then(edition, || {\n             io::set_output_capture(stderr.clone());\n@@ -176,14 +174,12 @@ unsafe fn handle_deadlock() {\n }\n \n #[cfg(parallel_compiler)]\n-pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n+pub fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n     edition: Edition,\n     threads: usize,\n     stderr: &Option<Arc<Mutex<Vec<u8>>>>,\n     f: F,\n ) -> R {\n-    crate::callbacks::setup_callbacks();\n-\n     let mut config = rayon::ThreadPoolBuilder::new()\n         .thread_name(|_| \"rustc\".to_string())\n         .acquire_thread_handler(jobserver::acquire_thread)"}, {"sha": "3ce9f852c3d0fd9b68ddfb46e9c1ebeabdb387cc", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/dff7d51fcc8e5bb69d45db4f177fb15fab48b781/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff7d51fcc8e5bb69d45db4f177fb15fab48b781/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=dff7d51fcc8e5bb69d45db4f177fb15fab48b781", "patch": "@@ -1013,37 +1013,25 @@ pub fn with_source_map<T, F: FnOnce() -> T>(source_map: Lrc<SourceMap>, f: F) ->\n     f()\n }\n \n-pub fn debug_with_source_map(\n-    span: Span,\n-    f: &mut fmt::Formatter<'_>,\n-    source_map: &SourceMap,\n-) -> fmt::Result {\n-    write!(f, \"{} ({:?})\", source_map.span_to_diagnostic_string(span), span.ctxt())\n-}\n-\n-pub fn default_span_debug(span: Span, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-    with_session_globals(|session_globals| {\n-        if let Some(source_map) = &*session_globals.source_map.borrow() {\n-            debug_with_source_map(span, f, source_map)\n-        } else {\n-            f.debug_struct(\"Span\")\n-                .field(\"lo\", &span.lo())\n-                .field(\"hi\", &span.hi())\n-                .field(\"ctxt\", &span.ctxt())\n-                .finish()\n-        }\n-    })\n-}\n-\n impl fmt::Debug for Span {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        (*SPAN_DEBUG)(*self, f)\n+        with_session_globals(|session_globals| {\n+            if let Some(source_map) = &*session_globals.source_map.borrow() {\n+                write!(f, \"{} ({:?})\", source_map.span_to_diagnostic_string(*self), self.ctxt())\n+            } else {\n+                f.debug_struct(\"Span\")\n+                    .field(\"lo\", &self.lo())\n+                    .field(\"hi\", &self.hi())\n+                    .field(\"ctxt\", &self.ctxt())\n+                    .finish()\n+            }\n+        })\n     }\n }\n \n impl fmt::Debug for SpanData {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        (*SPAN_DEBUG)(Span::new(self.lo, self.hi, self.ctxt, self.parent), f)\n+        fmt::Debug::fmt(&Span::new(self.lo, self.hi, self.ctxt, self.parent), f)\n     }\n }\n \n@@ -2003,8 +1991,6 @@ pub struct FileLines {\n     pub lines: Vec<LineInfo>,\n }\n \n-pub static SPAN_DEBUG: AtomicRef<fn(Span, &mut fmt::Formatter<'_>) -> fmt::Result> =\n-    AtomicRef::new(&(default_span_debug as fn(_, &mut fmt::Formatter<'_>) -> _));\n pub static SPAN_TRACK: AtomicRef<fn(LocalDefId)> = AtomicRef::new(&((|_| {}) as fn(_)));\n \n // _____________________________________________________________________________"}, {"sha": "c3205165040172f787c56af28b3f168e99cfa7b9", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dff7d51fcc8e5bb69d45db4f177fb15fab48b781/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff7d51fcc8e5bb69d45db4f177fb15fab48b781/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=dff7d51fcc8e5bb69d45db4f177fb15fab48b781", "patch": "@@ -688,7 +688,7 @@ fn main_args(at_args: &[String]) -> MainResult {\n         Ok(opts) => opts,\n         Err(code) => return if code == 0 { Ok(()) } else { Err(ErrorReported) },\n     };\n-    rustc_interface::util::setup_callbacks_and_run_in_thread_pool_with_globals(\n+    rustc_interface::util::run_in_thread_pool_with_globals(\n         options.edition,\n         1, // this runs single-threaded, even in a parallel compiler\n         &None,"}]}