{"sha": "1b3846359a084f62eaab74390134011ed9e6cd48", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiMzg0NjM1OWEwODRmNjJlYWFiNzQzOTAxMzQwMTFlZDllNmNkNDg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-10-19T11:48:02Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-10-19T11:48:02Z"}, "message": "do all the same edits with Arc", "tree": {"sha": "c3c87775a974acc6690a59d684eac2141ec0c32f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3c87775a974acc6690a59d684eac2141ec0c32f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b3846359a084f62eaab74390134011ed9e6cd48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b3846359a084f62eaab74390134011ed9e6cd48", "html_url": "https://github.com/rust-lang/rust/commit/1b3846359a084f62eaab74390134011ed9e6cd48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b3846359a084f62eaab74390134011ed9e6cd48/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52a31f7a00095d99a1f56542f093b92d78ba1be3", "url": "https://api.github.com/repos/rust-lang/rust/commits/52a31f7a00095d99a1f56542f093b92d78ba1be3", "html_url": "https://github.com/rust-lang/rust/commit/52a31f7a00095d99a1f56542f093b92d78ba1be3"}], "stats": {"total": 116, "additions": 65, "deletions": 51}, "files": [{"sha": "69f8f71197c1f24e826d62c71a2c1f179350c92a", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 65, "deletions": 51, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/1b3846359a084f62eaab74390134011ed9e6cd48/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b3846359a084f62eaab74390134011ed9e6cd48/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=1b3846359a084f62eaab74390134011ed9e6cd48", "patch": "@@ -45,10 +45,10 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n ///\n /// The type `Arc<T>` provides shared ownership of a value of type `T`,\n /// allocated in the heap. Invoking [`clone`][clone] on `Arc` produces\n-/// a new `Arc` instance, which points to the same value on the heap as the\n+/// a new `Arc` instance, which points to the same allocation on the heap as the\n /// source `Arc`, while increasing a reference count. When the last `Arc`\n-/// pointer to a given value is destroyed, the pointed-to value is also\n-/// destroyed.\n+/// pointer to a given allocation is destroyed, the value stored in that allocation (often\n+/// referred to as \"inner value\") is also dropped.\n ///\n /// Shared references in Rust disallow mutation by default, and `Arc` is no\n /// exception: you cannot generally obtain a mutable reference to something\n@@ -61,7 +61,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// Unlike [`Rc<T>`], `Arc<T>` uses atomic operations for its reference\n /// counting. This means that it is thread-safe. The disadvantage is that\n /// atomic operations are more expensive than ordinary memory accesses. If you\n-/// are not sharing reference-counted values between threads, consider using\n+/// are not sharing reference-counted allocations between threads, consider using\n /// [`Rc<T>`] for lower overhead. [`Rc<T>`] is a safe default, because the\n /// compiler will catch any attempt to send an [`Rc<T>`] between threads.\n /// However, a library might choose `Arc<T>` in order to give library consumers\n@@ -85,8 +85,10 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n ///\n /// The [`downgrade`][downgrade] method can be used to create a non-owning\n /// [`Weak`][weak] pointer. A [`Weak`][weak] pointer can be [`upgrade`][upgrade]d\n-/// to an `Arc`, but this will return [`None`] if the value has already been\n-/// dropped.\n+/// to an `Arc`, but this will return [`None`] if the value stored in the allocation has\n+/// already been dropped. In other words, `Weak` pointers do not keep the value\n+/// inside the allocation alive; however, they *do* keep the allocation\n+/// (the backing store for the value) alive.\n ///\n /// A cycle between `Arc` pointers will never be deallocated. For this reason,\n /// [`Weak`][weak] is used to break cycles. For example, a tree could have\n@@ -121,8 +123,8 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// Arc::downgrade(&my_arc);\n /// ```\n ///\n-/// [`Weak<T>`][weak] does not auto-dereference to `T`, because the value may have\n-/// already been destroyed.\n+/// [`Weak<T>`][weak] does not auto-dereference to `T`, because the inner value may have\n+/// already been dropped.\n ///\n /// [arc]: struct.Arc.html\n /// [weak]: struct.Weak.html\n@@ -221,17 +223,18 @@ impl<T: ?Sized> Arc<T> {\n }\n \n /// `Weak` is a version of [`Arc`] that holds a non-owning reference to the\n-/// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n+/// managed allocation. The allocation is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Arc`]`<T>>`.\n ///\n /// Since a `Weak` reference does not count towards ownership, it will not\n-/// prevent the inner value from being dropped, and `Weak` itself makes no\n-/// guarantees about the value still being present and may return [`None`]\n-/// when [`upgrade`]d.\n+/// prevent the value stored in the allocation from being dropped, and `Weak` itself makes no\n+/// guarantees about the value still being present. Thus it may return [`None`]\n+/// when [`upgrade`]d. Note however that a `Weak` reference *does* prevent the allocation\n+/// itself (the backing store) from being deallocated.\n ///\n-/// A `Weak` pointer is useful for keeping a temporary reference to the value\n-/// within [`Arc`] without extending its lifetime. It is also used to prevent\n-/// circular references between [`Arc`] pointers, since mutual owning references\n+/// A `Weak` pointer is useful for keeping a temporary reference to the allocation\n+/// managed by [`Arc`] without preventing its inner value from being dropped. It is also used to\n+/// prevent circular references between [`Arc`] pointers, since mutual owning references\n /// would never allow either [`Arc`] to be dropped. For example, a tree could\n /// have strong [`Arc`] pointers from parent nodes to children, and `Weak`\n /// pointers from children back to their parents.\n@@ -345,7 +348,7 @@ impl<T> Arc<T> {\n         unsafe { Pin::new_unchecked(Arc::new(data)) }\n     }\n \n-    /// Returns the contained value, if the `Arc` has exactly one strong reference.\n+    /// Returns the inner value, if the `Arc` has exactly one strong reference.\n     ///\n     /// Otherwise, an [`Err`][result] is returned with the same `Arc` that was\n     /// passed in.\n@@ -426,7 +429,7 @@ impl<T> Arc<mem::MaybeUninit<T>> {\n     /// # Safety\n     ///\n     /// As with [`MaybeUninit::assume_init`],\n-    /// it is up to the caller to guarantee that the value\n+    /// it is up to the caller to guarantee that the inner value\n     /// really is in an initialized state.\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n@@ -465,7 +468,7 @@ impl<T> Arc<[mem::MaybeUninit<T>]> {\n     /// # Safety\n     ///\n     /// As with [`MaybeUninit::assume_init`],\n-    /// it is up to the caller to guarantee that the value\n+    /// it is up to the caller to guarantee that the inner value\n     /// really is in an initialized state.\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n@@ -584,7 +587,7 @@ impl<T: ?Sized> Arc<T> {\n         unsafe { NonNull::new_unchecked(Arc::into_raw(this) as *mut _) }\n     }\n \n-    /// Creates a new [`Weak`][weak] pointer to this value.\n+    /// Creates a new [`Weak`][weak] pointer to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     ///\n@@ -628,7 +631,7 @@ impl<T: ?Sized> Arc<T> {\n         }\n     }\n \n-    /// Gets the number of [`Weak`][weak] pointers to this value.\n+    /// Gets the number of [`Weak`][weak] pointers to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     ///\n@@ -659,7 +662,7 @@ impl<T: ?Sized> Arc<T> {\n         if cnt == usize::MAX { 0 } else { cnt - 1 }\n     }\n \n-    /// Gets the number of strong (`Arc`) pointers to this value.\n+    /// Gets the number of strong (`Arc`) pointers to this allocation.\n     ///\n     /// # Safety\n     ///\n@@ -710,8 +713,8 @@ impl<T: ?Sized> Arc<T> {\n \n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-    /// Returns `true` if the two `Arc`s point to the same value (not\n-    /// just values that compare as equal).\n+    /// Returns `true` if the two `Arc`s point to the same allocation\n+    /// (in a vein similar to [`ptr::eq`]).\n     ///\n     /// # Examples\n     ///\n@@ -725,14 +728,16 @@ impl<T: ?Sized> Arc<T> {\n     /// assert!(Arc::ptr_eq(&five, &same_five));\n     /// assert!(!Arc::ptr_eq(&five, &other_five));\n     /// ```\n+    ///\n+    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n         this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n }\n \n impl<T: ?Sized> Arc<T> {\n     /// Allocates an `ArcInner<T>` with sufficient space for\n-    /// a possibly-unsized value where the value has the layout provided.\n+    /// a possibly-unsized inner value where the value has the layout provided.\n     ///\n     /// The function `mem_to_arcinner` is called with the data pointer\n     /// and must return back a (potentially fat)-pointer for the `ArcInner<T>`.\n@@ -761,7 +766,7 @@ impl<T: ?Sized> Arc<T> {\n         inner\n     }\n \n-    /// Allocates an `ArcInner<T>` with sufficient space for an unsized value.\n+    /// Allocates an `ArcInner<T>` with sufficient space for an unsized inner value.\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n         // Allocate for the `ArcInner<T>` using the given value.\n         Self::allocate_for_layout(\n@@ -903,7 +908,7 @@ impl<T: Copy> ArcFromSlice<T> for Arc<[T]> {\n impl<T: ?Sized> Clone for Arc<T> {\n     /// Makes a clone of the `Arc` pointer.\n     ///\n-    /// This creates another pointer to the same inner value, increasing the\n+    /// This creates another pointer to the same allocation, increasing the\n     /// strong reference count.\n     ///\n     /// # Examples\n@@ -965,15 +970,19 @@ impl<T: ?Sized> Receiver for Arc<T> {}\n impl<T: Clone> Arc<T> {\n     /// Makes a mutable reference into the given `Arc`.\n     ///\n-    /// If there are other `Arc` or [`Weak`][weak] pointers to the same value,\n-    /// then `make_mut` will invoke [`clone`][clone] on the inner value to\n-    /// ensure unique ownership. This is also referred to as clone-on-write.\n+    /// If there are other `Arc` or [`Weak`][weak] pointers to the same allocation,\n+    /// then `make_mut` will create a new allocation and invoke [`clone`][clone] on the inner value\n+    /// to ensure unique ownership. This is also referred to as clone-on-write.\n+    ///\n+    /// Note that this differs from the behavior of [`Rc::make_mut`] which disassociates\n+    /// any remaining `Weak` pointers.\n     ///\n     /// See also [`get_mut`][get_mut], which will fail rather than cloning.\n     ///\n     /// [weak]: struct.Weak.html\n     /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n     /// [get_mut]: struct.Arc.html#method.get_mut\n+    /// [`Rc::make_mut`]: ../rc/struct.Rc.html#method.make_mut\n     ///\n     /// # Examples\n     ///\n@@ -988,7 +997,7 @@ impl<T: Clone> Arc<T> {\n     /// *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n     /// *Arc::make_mut(&mut other_data) *= 2;   // Won't clone anything\n     ///\n-    /// // Now `data` and `other_data` point to different values.\n+    /// // Now `data` and `other_data` point to different allocations.\n     /// assert_eq!(*data, 8);\n     /// assert_eq!(*other_data, 12);\n     /// ```\n@@ -1048,14 +1057,14 @@ impl<T: Clone> Arc<T> {\n }\n \n impl<T: ?Sized> Arc<T> {\n-    /// Returns a mutable reference to the inner value, if there are\n-    /// no other `Arc` or [`Weak`][weak] pointers to the same value.\n+    /// Returns a mutable reference into the given `Arc`, if there are\n+    /// no other `Arc` or [`Weak`][weak] pointers to the same allocation.\n     ///\n     /// Returns [`None`][option] otherwise, because it is not safe to\n     /// mutate a shared value.\n     ///\n     /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n-    /// the inner value when it's shared.\n+    /// the inner value when there are other pointers.\n     ///\n     /// [weak]: struct.Weak.html\n     /// [option]: ../../std/option/enum.Option.html\n@@ -1091,7 +1100,7 @@ impl<T: ?Sized> Arc<T> {\n         }\n     }\n \n-    /// Returns a mutable reference to the inner value,\n+    /// Returns a mutable reference into the given `Arc`,\n     /// without any check.\n     ///\n     /// See also [`get_mut`], which is safe and does appropriate checks.\n@@ -1100,7 +1109,7 @@ impl<T: ?Sized> Arc<T> {\n     ///\n     /// # Safety\n     ///\n-    /// Any other `Arc` or [`Weak`] pointers to the same value must not be dereferenced\n+    /// Any other `Arc` or [`Weak`] pointers to the same allocation must not be dereferenced\n     /// for the duration of the returned borrow.\n     /// This is trivially the case if no such pointers exist,\n     /// for example immediately after `Arc::new`.\n@@ -1424,10 +1433,10 @@ impl<T> Weak<T> {\n }\n \n impl<T: ?Sized> Weak<T> {\n-    /// Attempts to upgrade the `Weak` pointer to an [`Arc`], extending\n-    /// the lifetime of the value if successful.\n+    /// Attempts to upgrade the `Weak` pointer to an [`Arc`], delaying\n+    /// dropping of the inner value if successful.\n     ///\n-    /// Returns [`None`] if the value has since been dropped.\n+    /// Returns [`None`] if the inner value has since been dropped.\n     ///\n     /// [`Arc`]: struct.Arc.html\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n@@ -1482,7 +1491,7 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Gets the number of strong (`Arc`) pointers pointing to this value.\n+    /// Gets the number of strong (`Arc`) pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0.\n     ///\n@@ -1497,17 +1506,17 @@ impl<T: ?Sized> Weak<T> {\n     }\n \n     /// Gets an approximation of the number of `Weak` pointers pointing to this\n-    /// value.\n+    /// allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0. If not,\n     /// the returned value is at least 1, since `self` still points to the\n-    /// value.\n+    /// allocation.\n     ///\n     /// # Accuracy\n     ///\n     /// Due to implementation details, the returned value can be off by 1 in\n     /// either direction when other threads are manipulating any `Arc`s or\n-    /// `Weak`s pointing to the same value.\n+    /// `Weak`s pointing to the same allocation.\n     ///\n     /// [`Weak::new`]: #method.new\n     #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n@@ -1548,14 +1557,14 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns `true` if the two `Weak`s point to the same value (not just\n-    /// values that compare as equal), or if both don't point to any value\n+    /// Returns `true` if the two `Weak`s point to the same allocation (similar to\n+    /// [`ptr::eq`]), or if both don't point to any allocation\n     /// (because they were created with `Weak::new()`).\n     ///\n     /// # Notes\n     ///\n     /// Since this compares pointers it means that `Weak::new()` will equal each\n-    /// other, even though they don't point to any value.\n+    /// other, even though they don't point to any allocation.\n     ///\n     /// # Examples\n     ///\n@@ -1587,6 +1596,8 @@ impl<T: ?Sized> Weak<T> {\n     /// let third = Arc::downgrade(&third_rc);\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n+    ///\n+    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n     #[inline]\n     #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n@@ -1596,7 +1607,7 @@ impl<T: ?Sized> Weak<T> {\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak` pointer that points to the same value.\n+    /// Makes a clone of the `Weak` pointer that points to the same allocation.\n     ///\n     /// # Examples\n     ///\n@@ -1726,6 +1737,8 @@ impl<T: ?Sized + PartialEq> ArcEqIdent<T> for Arc<T> {\n /// store large values, that are slow to clone, but also heavy to check for equality, causing this\n /// cost to pay off more easily. It's also more likely to have two `Arc` clones, that point to\n /// the same value, than two `&T`s.\n+///\n+/// We can only do this when `T: Eq` as a `PartialEq` might be deliberately irreflexive.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> ArcEqIdent<T> for Arc<T> {\n     #[inline]\n@@ -1743,10 +1756,11 @@ impl<T: ?Sized + Eq> ArcEqIdent<T> for Arc<T> {\n impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n     /// Equality for two `Arc`s.\n     ///\n-    /// Two `Arc`s are equal if their inner values are equal.\n+    /// Two `Arc`s are equal if their inner values are equal, even if they are\n+    /// stored in different allocation.\n     ///\n-    /// If `T` also implements `Eq`, two `Arc`s that point to the same value are\n-    /// always equal.\n+    /// If `T` also implements `Eq` (implying reflexivity of equality),\n+    /// two `Arc`s that point to the same allocation are always equal.\n     ///\n     /// # Examples\n     ///\n@@ -1766,8 +1780,8 @@ impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n     ///\n     /// Two `Arc`s are unequal if their inner values are unequal.\n     ///\n-    /// If `T` also implements `Eq`, two `Arc`s that point to the same value are\n-    /// never unequal.\n+    /// If `T` also implements `Eq` (implying reflexivity of equality),\n+    /// two `Arc`s that point to the same value are never unequal.\n     ///\n     /// # Examples\n     ///"}]}