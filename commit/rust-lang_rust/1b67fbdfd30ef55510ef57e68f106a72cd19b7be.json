{"sha": "1b67fbdfd30ef55510ef57e68f106a72cd19b7be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiNjdmYmRmZDMwZWY1NTUxMGVmNTdlNjhmMTA2YTcyY2QxOWI3YmU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-01T22:29:38Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-01T22:29:38Z"}, "message": "More tweaks to comment preservation rules.", "tree": {"sha": "d621816cfe4e46c023aeb57dcf17563c554af69a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d621816cfe4e46c023aeb57dcf17563c554af69a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b67fbdfd30ef55510ef57e68f106a72cd19b7be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b67fbdfd30ef55510ef57e68f106a72cd19b7be", "html_url": "https://github.com/rust-lang/rust/commit/1b67fbdfd30ef55510ef57e68f106a72cd19b7be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b67fbdfd30ef55510ef57e68f106a72cd19b7be/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "198f6a247ed367e401e8f82657b22c064deed2a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/198f6a247ed367e401e8f82657b22c064deed2a0", "html_url": "https://github.com/rust-lang/rust/commit/198f6a247ed367e401e8f82657b22c064deed2a0"}], "stats": {"total": 168, "additions": 98, "deletions": 70}, "files": [{"sha": "d6af09c90ced922fa778b4e0f153dbf1ff71d6cf", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 98, "deletions": 70, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/1b67fbdfd30ef55510ef57e68f106a72cd19b7be/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b67fbdfd30ef55510ef57e68f106a72cd19b7be/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=1b67fbdfd30ef55510ef57e68f106a72cd19b7be", "patch": "@@ -13,9 +13,6 @@ import pp;\n \n import pp::printer;\n import pp::break_offset;\n-import pp::box;\n-import pp::cbox;\n-import pp::ibox;\n import pp::word;\n import pp::huge_word;\n import pp::zero_word;\n@@ -25,7 +22,6 @@ import pp::hardbreak;\n import pp::breaks;\n import pp::consistent;\n import pp::inconsistent;\n-import pp::end;\n import pp::eof;\n \n const uint indent_unit = 4u;\n@@ -40,13 +36,16 @@ type ps = @rec(pp::printer s,\n                option::t[codemap] cm,\n                option::t[vec[lexer::cmnt]] comments,\n                mutable uint cur_cmnt,\n+               mutable vec[pp::breaks] boxes,\n                mode mode);\n \n fn rust_printer(io::writer writer) -> ps {\n+    let vec[pp::breaks] boxes = [];\n     ret @rec(s=pp::mk_printer(writer, default_columns),\n              cm=option::none[codemap],\n              comments=option::none[vec[lexer::cmnt]],\n              mutable cur_cmnt=0u,\n+             mutable boxes = boxes,\n              mode=mo_untyped);\n }\n \n@@ -60,11 +59,13 @@ fn to_str[T](&T t, fn(&ps s, &T s) f) -> str {\n \n fn print_file(session sess, ast::_mod _mod, str filename, io::writer out,\n               mode mode) {\n+    let vec[pp::breaks] boxes = [];\n     auto cmnts = lexer::gather_comments(sess, filename);\n     auto s = @rec(s=pp::mk_printer(out, default_columns),\n                   cm=option::some[codemap](sess.get_codemap()),\n                   comments=option::some[vec[lexer::cmnt]](cmnts),\n                   mutable cur_cmnt=0u,\n+                  mutable boxes = boxes,\n                   mode=mode);\n     print_mod(s, _mod);\n     eof(s.s);\n@@ -89,15 +90,36 @@ fn block_to_str(&ast::block blk) -> str {\n     auto s = rust_printer(writer.get_writer());\n \n     // containing cbox, will be closed by print-block at }\n-    cbox(s.s, indent_unit);\n+    cbox(s, indent_unit);\n \n     // head-ibox, will be closed by print-block after {\n-    ibox(s.s, 0u);\n+    ibox(s, 0u);\n     print_block(s, blk);\n     eof(s.s);\n     ret writer.get_str();\n }\n \n+fn ibox(&ps s, uint u) {\n+    vec::push(s.boxes, pp::inconsistent);\n+    pp::ibox(s.s, u);\n+}\n+\n+fn cbox(&ps s, uint u) {\n+    vec::push(s.boxes, pp::consistent);\n+    pp::cbox(s.s, u);\n+}\n+\n+fn box(&ps s, uint u, pp::breaks b) {\n+    vec::push(s.boxes, b);\n+    pp::box(s.s, u, b);\n+}\n+\n+fn end(&ps s) {\n+    vec::pop(s.boxes);\n+    pp::end(s.s);\n+}\n+\n+\n fn word_nbsp(&ps s, str w) {\n     word(s.s, w);\n     word(s.s, \" \");\n@@ -118,39 +140,39 @@ fn pclose(&ps s) {\n \n fn head(&ps s, str w) {\n     // outer-box is consistent\n-    cbox(s.s, indent_unit);\n+    cbox(s, indent_unit);\n     // head-box is inconsistent\n-    ibox(s.s, str::char_len(w) + 1u);\n+    ibox(s, str::char_len(w) + 1u);\n     // keyword that starts the head\n     word_nbsp(s, w);\n }\n \n fn bopen(&ps s) {\n     word(s.s, \"{\");\n-    end(s.s); // close the head-box\n+    end(s); // close the head-box\n }\n \n fn bclose(&ps s, common::span span) {\n     maybe_print_comment(s, span.hi);\n     break_offset(s.s, 1u, -(indent_unit as int));\n     word(s.s, \"}\");\n-    end(s.s); // close the outer-box\n+    end(s); // close the outer-box\n }\n \n fn commasep[IN](&ps s, breaks b, vec[IN] elts, fn(&ps, &IN) op) {\n-    box(s.s, 0u, b);\n+    box(s, 0u, b);\n     auto first = true;\n     for (IN elt in elts) {\n         if (first) {first = false;}\n         else {word_space(s, \",\");}\n         op(s, elt);\n     }\n-    end(s.s);\n+    end(s);\n }\n \n fn commasep_cmnt[IN](&ps s, breaks b, vec[IN] elts, fn(&ps, &IN) op,\n                      fn(&IN) -> common::span get_span) {\n-    box(s.s, 0u, b);\n+    box(s, 0u, b);\n     auto len = vec::len[IN](elts);\n     auto i = 0u;\n     for (IN elt in elts) {\n@@ -163,7 +185,7 @@ fn commasep_cmnt[IN](&ps s, breaks b, vec[IN] elts, fn(&ps, &IN) op,\n             space(s.s);\n         }\n     }\n-    end(s.s);\n+    end(s);\n }\n \n fn commasep_exprs(&ps s, breaks b, vec[@ast::expr] exprs) {\n@@ -189,7 +211,7 @@ fn print_boxed_type(&ps s, &@ast::ty ty) { print_type(s, *ty); }\n fn print_type(&ps s, &ast::ty ty) {\n \n     maybe_print_comment(s, ty.span.lo);\n-    ibox(s.s, 0u);\n+    ibox(s, 0u);\n     alt (ty.node) {\n         case (ast::ty_nil) {word(s.s, \"()\");}\n         case (ast::ty_bool) {word(s.s, \"bool\");}\n@@ -222,11 +244,11 @@ fn print_type(&ps s, &ast::ty ty) {\n             word(s.s, \"rec\");\n             popen(s);\n             fn print_field(&ps s, &ast::ty_field f) {\n-                cbox(s.s, indent_unit);\n+                cbox(s, indent_unit);\n                 print_mt(s, f.mt);\n                 space(s.s);\n                 word(s.s, f.ident);\n-                end(s.s);\n+                end(s);\n             }\n             fn get_span(&ast::ty_field f) -> common::span {\n               // Try to reconstruct the span for this field\n@@ -244,11 +266,11 @@ fn print_type(&ps s, &ast::ty ty) {\n             bopen(s);\n             for (ast::ty_method m in methods) {\n                 hardbreak(s.s);\n-                cbox(s.s, indent_unit);\n+                cbox(s, indent_unit);\n                 print_ty_fn(s, m.proto, option::some[str](m.ident),\n                             m.inputs, m.output, m.cf);\n                 word(s.s, \";\");\n-                end(s.s);\n+                end(s);\n             }\n             bclose(s, ty.span);\n         }\n@@ -259,7 +281,7 @@ fn print_type(&ps s, &ast::ty ty) {\n             print_path(s, path);\n         }\n     }\n-    end(s.s);\n+    end(s);\n }\n \n fn print_item(&ps s, &@ast::item item) {\n@@ -272,11 +294,11 @@ fn print_item(&ps s, &@ast::item item) {\n             print_type(s, *ty);\n             space(s.s);\n             word_space(s, id);\n-            end(s.s); // end the head-ibox\n+            end(s); // end the head-ibox\n             word_space(s, \"=\");\n             print_expr(s, expr);\n             word(s.s, \";\");\n-            end(s.s); // end the outer cbox\n+            end(s); // end the outer cbox\n         }\n         case (ast::item_fn(?name,?_fn,?typarams,_,_)) {\n             print_fn(s, _fn.decl, _fn.proto, name, typarams);\n@@ -303,7 +325,7 @@ fn print_item(&ps s, &@ast::item item) {\n             word_nbsp(s, id);\n             bopen(s);\n             for (@ast::native_item item in nmod.items) {\n-                ibox(s.s, indent_unit);\n+                ibox(s, indent_unit);\n                 maybe_print_comment(s, item.span.lo);\n                 alt (item.node) {\n                     case (ast::native_item_ty(?id,_)) {\n@@ -313,7 +335,7 @@ fn print_item(&ps s, &@ast::item item) {\n                     case (ast::native_item_fn(?id,?lname,?decl,\n                                              ?typarams,_,_)) {\n                         print_fn(s, decl, ast::proto_fn, id, typarams);\n-                        end(s.s); // end head-ibox\n+                        end(s); // end head-ibox\n                         alt (lname) {\n                             case (option::none[str]) {}\n                             case (option::some[str](?ss)) {\n@@ -323,22 +345,22 @@ fn print_item(&ps s, &@ast::item item) {\n                     }\n                 }\n                 word(s.s, \";\");\n-                end(s.s);\n+                end(s);\n             }\n             bclose(s, item.span);\n         }\n         case (ast::item_ty(?id,?ty,?params,_,_)) {\n-            ibox(s.s, indent_unit);\n-            ibox(s.s, 0u);\n+            ibox(s, indent_unit);\n+            ibox(s, 0u);\n             word_nbsp(s, \"type\");\n             word(s.s, id);\n             print_type_params(s, params);\n-            end(s.s); // end the inner ibox\n+            end(s); // end the inner ibox\n             space(s.s);\n             word_space(s, \"=\");\n             print_type(s, *ty);\n             word(s.s, \";\");\n-            end(s.s); // end the outer ibox\n+            end(s); // end the outer ibox\n             break_offset(s.s, 0u, 0);\n         }\n         case (ast::item_tag(?id,?variants,?params,_,_)) {\n@@ -371,11 +393,11 @@ fn print_item(&ps s, &@ast::item item) {\n             print_type_params(s, params);\n             popen(s);\n             fn print_field(&ps s, &ast::obj_field field) {\n-                ibox(s.s, indent_unit);\n+                ibox(s, indent_unit);\n                 print_type(s, *field.ty);\n                 space(s.s);\n                 word(s.s, field.ident);\n-                end(s.s);\n+                end(s);\n             }\n             fn get_span(&ast::obj_field f) -> common::span {ret f.ty.span;}\n             auto f = print_field;\n@@ -474,7 +496,7 @@ fn print_literal(&ps s, &@ast::lit lit) {\n \n fn print_expr(&ps s, &@ast::expr expr) {\n     maybe_print_comment(s, expr.span.lo);\n-    ibox(s.s, indent_unit);\n+    ibox(s, indent_unit);\n \n     alt (s.mode) {\n         case (mo_untyped) { /* no-op */ }\n@@ -483,21 +505,21 @@ fn print_expr(&ps s, &@ast::expr expr) {\n \n     alt (expr.node) {\n         case (ast::expr_vec(?exprs,?mut,_)) {\n-            ibox(s.s, indent_unit);\n+            ibox(s, indent_unit);\n             word(s.s, \"[\");\n             if (mut == ast::mut) {\n                 word_nbsp(s, \"mutable\");\n             }\n             commasep_exprs(s, inconsistent, exprs);\n             word(s.s, \"]\");\n-            end(s.s);\n+            end(s);\n         }\n         case (ast::expr_tup(?exprs,_)) {\n             fn printElt(&ps s, &ast::elt elt) {\n-                ibox(s.s, indent_unit);\n+                ibox(s, indent_unit);\n                 if (elt.mut == ast::mut) {word_nbsp(s, \"mutable\");}\n                 print_expr(s, elt.expr);\n-                end(s.s);\n+                end(s);\n             }\n             fn get_span(&ast::elt elt) -> common::span {ret elt.expr.span;}\n             word(s.s, \"tup\");\n@@ -509,12 +531,12 @@ fn print_expr(&ps s, &@ast::expr expr) {\n         }\n         case (ast::expr_rec(?fields,?wth,_)) {\n             fn print_field(&ps s, &ast::field field) {\n-                ibox(s.s, indent_unit);\n+                ibox(s, indent_unit);\n                 if (field.node.mut == ast::mut) {word_nbsp(s, \"mutable\");}\n                 word(s.s, field.node.ident);\n                 word(s.s, \"=\");\n                 print_expr(s, field.node.expr);\n-                end(s.s);\n+                end(s);\n             }\n             fn get_span(&ast::field field) -> common::span {\n                 ret field.span;\n@@ -527,10 +549,10 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             alt (wth) {\n                 case (option::some[@ast::expr](?expr)) {\n                     if (vec::len[ast::field](fields) > 0u) {space(s.s);}\n-                    ibox(s.s, indent_unit);\n+                    ibox(s, indent_unit);\n                     word_space(s, \"with\");\n                     print_expr(s, expr);\n-                    end(s.s);\n+                    end(s);\n                 }\n                 case (_) {}\n             }\n@@ -603,8 +625,8 @@ fn print_expr(&ps s, &@ast::expr expr) {\n                         alt (_else.node) {\n                             // \"another else-if\"\n                             case (ast::expr_if(?i,?t,?e,_)) {\n-                                cbox(s.s, indent_unit-1u);\n-                                ibox(s.s, 0u);\n+                                cbox(s, indent_unit-1u);\n+                                ibox(s, 0u);\n                                 word(s.s, \" else if \");\n                                 popen(s);\n                                 print_expr(s, i);\n@@ -615,8 +637,8 @@ fn print_expr(&ps s, &@ast::expr expr) {\n                             }\n                             // \"final else\"\n                             case (ast::expr_block(?b, _)) {\n-                                cbox(s.s, indent_unit-1u);\n-                                ibox(s.s, 0u);\n+                                cbox(s, indent_unit-1u);\n+                                ibox(s, 0u);\n                                 word(s.s, \" else \");\n                                 print_block(s, b);\n                             }\n@@ -687,10 +709,10 @@ fn print_expr(&ps s, &@ast::expr expr) {\n         }\n         case (ast::expr_block(?block,_)) {\n             // containing cbox, will be closed by print-block at }\n-            cbox(s.s, indent_unit);\n+            cbox(s, indent_unit);\n \n             // head-box, will be closed by print-block after {\n-            ibox(s.s, 0u);\n+            ibox(s, 0u);\n             print_block(s, block);\n         }\n         case (ast::expr_move(?lhs,?rhs,_)) {\n@@ -831,15 +853,15 @@ fn print_expr(&ps s, &@ast::expr expr) {\n         }\n     }\n \n-    end(s.s);\n+    end(s);\n }\n \n fn print_decl(&ps s, &@ast::decl decl) {\n     maybe_print_comment(s, decl.span.lo);\n     alt (decl.node) {\n         case (ast::decl_local(?loc)) {\n             space(s.s);\n-            ibox(s.s, indent_unit);\n+            ibox(s, indent_unit);\n             alt (loc.ty) {\n                 case (option::some[@ast::ty](?ty)) {\n                     word_nbsp(s, \"let\");\n@@ -879,7 +901,7 @@ fn print_decl(&ps s, &@ast::decl decl) {\n                 }\n                 case (_) {}\n             }\n-            end(s.s);\n+            end(s);\n         }\n         case (ast::decl_item(?item)) {\n             print_item(s, item);\n@@ -953,12 +975,12 @@ fn print_fn(&ps s, ast::fn_decl decl, ast::proto proto, str name,\n     print_type_params(s, typarams);\n     popen(s);\n     fn print_arg(&ps s, &ast::arg x) {\n-        ibox(s.s, indent_unit);\n+        ibox(s, indent_unit);\n         if (x.mode == ast::alias) {word(s.s, \"&\");}\n         print_type(s, *x.ty);\n         space(s.s);\n         word(s.s, x.ident);\n-        end(s.s);\n+        end(s);\n     }\n     auto f = print_arg;\n     commasep[ast::arg](s, inconsistent, decl.inputs, f);\n@@ -993,11 +1015,11 @@ fn print_view_item(&ps s, &@ast::view_item item) {\n             if (vec::len[@ast::meta_item](mta) > 0u) {\n                 popen(s);\n                 fn print_meta(&ps s, &@ast::meta_item item) {\n-                    ibox(s.s, indent_unit);\n+                    ibox(s, indent_unit);\n                     word_space(s, item.node.name);\n                     word_space(s, \"=\");\n                     print_string(s, item.node.value);\n-                    end(s.s);\n+                    end(s);\n                 }\n                 auto f = print_meta;\n                 commasep[@ast::meta_item](s, consistent, mta, f);\n@@ -1033,8 +1055,8 @@ fn print_view_item(&ps s, &@ast::view_item item) {\n         }\n     }\n     word(s.s, \";\");\n-    end(s.s); // end inner head-block\n-    end(s.s); // end outer head-block\n+    end(s); // end inner head-block\n+    end(s); // end outer head-block\n }\n \n // FIXME: The fact that this builds up the table anew for every call is\n@@ -1101,7 +1123,7 @@ fn print_string(&ps s, &str st) {\n fn print_ty_fn(&ps s, &ast::proto proto, &option::t[str] id,\n                &vec[ast::ty_arg] inputs, &@ast::ty output,\n                &ast::controlflow cf) {\n-    ibox(s.s, indent_unit);\n+    ibox(s, indent_unit);\n     if (proto == ast::proto_fn) {word(s.s, \"fn\");}\n     else {word(s.s, \"iter\");}\n     alt (id) {\n@@ -1119,7 +1141,7 @@ fn print_ty_fn(&ps s, &ast::proto proto, &option::t[str] id,\n     maybe_print_comment(s, output.span.lo);\n     if (output.node != ast::ty_nil) {\n         space(s.s);\n-        ibox(s.s, indent_unit);\n+        ibox(s, indent_unit);\n         word_space(s, \"->\");\n         alt (cf) {\n             case (ast::return) {\n@@ -1129,9 +1151,9 @@ fn print_ty_fn(&ps s, &ast::proto proto, &option::t[str] id,\n                 word_nbsp(s, \"!\");\n             }\n         }\n-        end(s.s);\n+        end(s);\n     }\n-    end(s.s);\n+    end(s);\n }\n \n fn next_comment(&ps s) -> option::t[lexer::cmnt] {\n@@ -1146,15 +1168,10 @@ fn next_comment(&ps s) -> option::t[lexer::cmnt] {\n }\n \n fn maybe_print_comment(&ps s, uint pos) {\n-    auto first = true;\n     while (true) {\n         alt (next_comment(s)) {\n             case (option::some[lexer::cmnt](?cmnt)) {\n                 if (cmnt.pos < pos) {\n-                    if (first) {\n-                        first = false;\n-                        break_offset(s.s, 0u, 0);\n-                    }\n                     print_comment(s, cmnt);\n                     s.cur_cmnt += 1u;\n                 } else { break; }\n@@ -1178,7 +1195,8 @@ fn maybe_print_trailing_comment(&ps s, common::span span) {\n \n             auto span_line = codemap::lookup_pos(cm, span.hi);\n             auto comment_line = codemap::lookup_pos(cm, cmnt.pos);\n-            if (span_line.line == comment_line.line) {\n+            if (span.hi < cmnt.pos &&\n+                span_line.line == comment_line.line) {\n                 word(s.s, \" \");\n                 print_comment(s, cmnt);\n                 s.cur_cmnt += 1u;\n@@ -1200,6 +1218,12 @@ fn print_remaining_comments(&ps s) {\n     }\n }\n \n+fn in_cbox(&ps s) -> bool {\n+    auto len = vec::len(s.boxes);\n+    if (len == 0u) { ret false; }\n+    ret s.boxes.(len-1u) == pp::consistent;\n+}\n+\n fn print_comment(&ps s, lexer::cmnt cmnt) {\n     alt (cmnt.style) {\n         case (lexer::mixed) {\n@@ -1208,24 +1232,28 @@ fn print_comment(&ps s, lexer::cmnt cmnt) {\n             word(s.s, cmnt.lines.(0));\n             zerobreak(s.s);\n         }\n+\n         case (lexer::isolated) {\n             hardbreak(s.s);\n+            ibox(s, 0u);\n             for (str line in cmnt.lines) {\n-                zero_word(s.s, line);\n+                word(s.s, line);\n                 hardbreak(s.s);\n             }\n+            end(s);\n         }\n+\n         case (lexer::trailing) {\n             if (vec::len(cmnt.lines) == 1u) {\n-                zero_word(s.s, cmnt.lines.(0));\n+                word(s.s, cmnt.lines.(0));\n                 hardbreak(s.s);\n             } else {\n-                ibox(s.s, 0u);\n+                ibox(s, 0u);\n                 for (str line in cmnt.lines) {\n-                    zero_word(s.s, line);\n+                    word(s.s, line);\n                     hardbreak(s.s);\n                 }\n-                end(s.s);\n+                end(s);\n             }\n         }\n     }"}]}