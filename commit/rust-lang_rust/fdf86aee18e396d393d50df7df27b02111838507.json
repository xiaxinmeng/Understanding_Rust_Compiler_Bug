{"sha": "fdf86aee18e396d393d50df7df27b02111838507", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkZjg2YWVlMThlMzk2ZDM5M2Q1MGRmN2RmMjdiMDIxMTE4Mzg1MDc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-23T16:46:56Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-23T16:46:56Z"}, "message": "Nicer API", "tree": {"sha": "88cd35c526a926eb8c8a8645243209759a7bb7f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88cd35c526a926eb8c8a8645243209759a7bb7f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdf86aee18e396d393d50df7df27b02111838507", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdf86aee18e396d393d50df7df27b02111838507", "html_url": "https://github.com/rust-lang/rust/commit/fdf86aee18e396d393d50df7df27b02111838507", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdf86aee18e396d393d50df7df27b02111838507/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3486b47e5c4f71479cc3c876da1fd1dcbfcab257", "url": "https://api.github.com/repos/rust-lang/rust/commits/3486b47e5c4f71479cc3c876da1fd1dcbfcab257", "html_url": "https://github.com/rust-lang/rust/commit/3486b47e5c4f71479cc3c876da1fd1dcbfcab257"}], "stats": {"total": 148, "additions": 75, "deletions": 73}, "files": [{"sha": "6c13e62bb0862cc08fc09608f072ab23a5f7a36b", "filename": "crates/ra_db/src/fixture.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fdf86aee18e396d393d50df7df27b02111838507/crates%2Fra_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdf86aee18e396d393d50df7df27b02111838507/crates%2Fra_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Ffixture.rs?ref=fdf86aee18e396d393d50df7df27b02111838507", "patch": "@@ -61,7 +61,7 @@ use std::{str::FromStr, sync::Arc};\n \n use ra_cfg::CfgOptions;\n use rustc_hash::FxHashMap;\n-use test_utils::{extract_offset, parse_fixture, FixtureEntry, CURSOR_MARKER};\n+use test_utils::{extract_offset, Fixture, CURSOR_MARKER};\n use vfs::{file_set::FileSet, VfsPath};\n \n use crate::{\n@@ -107,9 +107,9 @@ fn with_files(\n     db: &mut dyn SourceDatabaseExt,\n     fixture: &str,\n ) -> (Option<FilePosition>, Vec<FileId>) {\n-    let mut files = Vec::new();\n-    let fixture = parse_fixture(fixture);\n+    let fixture = Fixture::parse(fixture);\n \n+    let mut files = Vec::new();\n     let mut crate_graph = CrateGraph::default();\n     let mut crates = FxHashMap::default();\n     let mut crate_deps = Vec::new();\n@@ -201,8 +201,8 @@ struct FileMeta {\n     env: Env,\n }\n \n-impl From<&FixtureEntry> for ParsedMeta {\n-    fn from(f: &FixtureEntry) -> Self {\n+impl From<&Fixture> for ParsedMeta {\n+    fn from(f: &Fixture) -> Self {\n         Self::File(FileMeta {\n             path: f.path.to_owned(),\n             krate: f.crate_name.to_owned(),"}, {"sha": "f15990158101161ae96a8d2ad3f6d9eae8adf334", "filename": "crates/ra_ide/src/mock_analysis.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fdf86aee18e396d393d50df7df27b02111838507/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdf86aee18e396d393d50df7df27b02111838507/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs?ref=fdf86aee18e396d393d50df7df27b02111838507", "patch": "@@ -3,7 +3,7 @@ use std::{str::FromStr, sync::Arc};\n \n use ra_cfg::CfgOptions;\n use ra_db::{CrateName, Env, FileSet, SourceRoot, VfsPath};\n-use test_utils::{extract_offset, extract_range, parse_fixture, FixtureEntry, CURSOR_MARKER};\n+use test_utils::{extract_offset, extract_range, Fixture, CURSOR_MARKER};\n \n use crate::{\n     Analysis, AnalysisChange, AnalysisHost, CrateGraph, Edition, FileId, FilePosition, FileRange,\n@@ -12,7 +12,7 @@ use crate::{\n #[derive(Debug)]\n enum MockFileData {\n     Plain { path: String, content: String },\n-    Fixture(FixtureEntry),\n+    Fixture(Fixture),\n }\n \n impl MockFileData {\n@@ -60,8 +60,8 @@ impl MockFileData {\n     }\n }\n \n-impl From<FixtureEntry> for MockFileData {\n-    fn from(fixture: FixtureEntry) -> Self {\n+impl From<Fixture> for MockFileData {\n+    fn from(fixture: Fixture) -> Self {\n         Self::Fixture(fixture)\n     }\n }\n@@ -89,7 +89,7 @@ impl MockAnalysis {\n     /// ```\n     pub fn with_files(fixture: &str) -> MockAnalysis {\n         let mut res = MockAnalysis::new();\n-        for entry in parse_fixture(fixture) {\n+        for entry in Fixture::parse(fixture) {\n             res.add_file_fixture(entry);\n         }\n         res\n@@ -100,7 +100,7 @@ impl MockAnalysis {\n     pub fn with_files_and_position(fixture: &str) -> (MockAnalysis, FilePosition) {\n         let mut position = None;\n         let mut res = MockAnalysis::new();\n-        for entry in parse_fixture(fixture) {\n+        for entry in Fixture::parse(fixture) {\n             if entry.text.contains(CURSOR_MARKER) {\n                 assert!(position.is_none(), \"only one marker (<|>) per fixture is allowed\");\n                 position = Some(res.add_file_fixture_with_position(entry));\n@@ -112,13 +112,13 @@ impl MockAnalysis {\n         (res, position)\n     }\n \n-    pub fn add_file_fixture(&mut self, fixture: FixtureEntry) -> FileId {\n+    pub fn add_file_fixture(&mut self, fixture: Fixture) -> FileId {\n         let file_id = self.next_id();\n         self.files.push(MockFileData::from(fixture));\n         file_id\n     }\n \n-    pub fn add_file_fixture_with_position(&mut self, mut fixture: FixtureEntry) -> FilePosition {\n+    pub fn add_file_fixture_with_position(&mut self, mut fixture: Fixture) -> FilePosition {\n         let (offset, text) = extract_offset(&fixture.text);\n         fixture.text = text;\n         let file_id = self.next_id();"}, {"sha": "2a51bb559ec0dfab0ba913384ca006b0871e404f", "filename": "crates/test_utils/src/fixture.rs", "status": "modified", "additions": 61, "deletions": 59, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/fdf86aee18e396d393d50df7df27b02111838507/crates%2Ftest_utils%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdf86aee18e396d393d50df7df27b02111838507/crates%2Ftest_utils%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Ffixture.rs?ref=fdf86aee18e396d393d50df7df27b02111838507", "patch": "@@ -3,7 +3,7 @@ use rustc_hash::FxHashMap;\n use stdx::split1;\n \n #[derive(Debug, Eq, PartialEq)]\n-pub struct FixtureEntry {\n+pub struct Fixture {\n     pub path: String,\n     pub text: String,\n     pub crate_name: Option<String>,\n@@ -13,19 +13,20 @@ pub struct FixtureEntry {\n     pub env: FxHashMap<String, String>,\n }\n \n-/// Parses text which looks like this:\n-///\n-///  ```not_rust\n-///  //- some meta\n-///  line 1\n-///  line 2\n-///  // - other meta\n-///  ```\n-pub fn parse_fixture(ra_fixture: &str) -> Vec<FixtureEntry> {\n-    let fixture = indent_first_line(ra_fixture);\n-    let margin = fixture_margin(&fixture);\n-\n-    let mut lines = fixture\n+impl Fixture {\n+    /// Parses text which looks like this:\n+    ///\n+    ///  ```not_rust\n+    ///  //- some meta\n+    ///  line 1\n+    ///  line 2\n+    ///  // - other meta\n+    ///  ```\n+    pub fn parse(ra_fixture: &str) -> Vec<Fixture> {\n+        let fixture = indent_first_line(ra_fixture);\n+        let margin = fixture_margin(&fixture);\n+\n+        let mut lines = fixture\n         .split('\\n') // don't use `.lines` to not drop `\\r\\n`\n         .enumerate()\n         .filter_map(|(ix, line)| {\n@@ -48,58 +49,59 @@ The offending line: {:?}\"#,\n             }\n         });\n \n-    let mut res: Vec<FixtureEntry> = Vec::new();\n-    for line in lines.by_ref() {\n-        if line.starts_with(\"//-\") {\n-            let meta = line[\"//-\".len()..].trim().to_string();\n-            let meta = parse_meta(&meta);\n-            res.push(meta)\n-        } else if let Some(entry) = res.last_mut() {\n-            entry.text.push_str(line);\n-            entry.text.push('\\n');\n+        let mut res: Vec<Fixture> = Vec::new();\n+        for line in lines.by_ref() {\n+            if line.starts_with(\"//-\") {\n+                let meta = line[\"//-\".len()..].trim().to_string();\n+                let meta = Fixture::parse_single(&meta);\n+                res.push(meta)\n+            } else if let Some(entry) = res.last_mut() {\n+                entry.text.push_str(line);\n+                entry.text.push('\\n');\n+            }\n         }\n+        res\n     }\n-    res\n-}\n \n-//- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b env:OUTDIR=path/to,OTHER=foo\n-fn parse_meta(meta: &str) -> FixtureEntry {\n-    let components = meta.split_ascii_whitespace().collect::<Vec<_>>();\n-\n-    let path = components[0].to_string();\n-    assert!(path.starts_with(\"/\"));\n-\n-    let mut krate = None;\n-    let mut deps = Vec::new();\n-    let mut edition = None;\n-    let mut cfg = CfgOptions::default();\n-    let mut env = FxHashMap::default();\n-    for component in components[1..].iter() {\n-        let (key, value) = split1(component, ':').unwrap();\n-        match key {\n-            \"crate\" => krate = Some(value.to_string()),\n-            \"deps\" => deps = value.split(',').map(|it| it.to_string()).collect(),\n-            \"edition\" => edition = Some(value.to_string()),\n-            \"cfg\" => {\n-                for key in value.split(',') {\n-                    match split1(key, '=') {\n-                        None => cfg.insert_atom(key.into()),\n-                        Some((k, v)) => cfg.insert_key_value(k.into(), v.into()),\n+    //- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b env:OUTDIR=path/to,OTHER=foo\n+    fn parse_single(meta: &str) -> Fixture {\n+        let components = meta.split_ascii_whitespace().collect::<Vec<_>>();\n+\n+        let path = components[0].to_string();\n+        assert!(path.starts_with(\"/\"));\n+\n+        let mut krate = None;\n+        let mut deps = Vec::new();\n+        let mut edition = None;\n+        let mut cfg = CfgOptions::default();\n+        let mut env = FxHashMap::default();\n+        for component in components[1..].iter() {\n+            let (key, value) = split1(component, ':').unwrap();\n+            match key {\n+                \"crate\" => krate = Some(value.to_string()),\n+                \"deps\" => deps = value.split(',').map(|it| it.to_string()).collect(),\n+                \"edition\" => edition = Some(value.to_string()),\n+                \"cfg\" => {\n+                    for key in value.split(',') {\n+                        match split1(key, '=') {\n+                            None => cfg.insert_atom(key.into()),\n+                            Some((k, v)) => cfg.insert_key_value(k.into(), v.into()),\n+                        }\n                     }\n                 }\n-            }\n-            \"env\" => {\n-                for key in value.split(',') {\n-                    if let Some((k, v)) = split1(key, '=') {\n-                        env.insert(k.into(), v.into());\n+                \"env\" => {\n+                    for key in value.split(',') {\n+                        if let Some((k, v)) = split1(key, '=') {\n+                            env.insert(k.into(), v.into());\n+                        }\n                     }\n                 }\n+                _ => panic!(\"bad component: {:?}\", component),\n             }\n-            _ => panic!(\"bad component: {:?}\", component),\n         }\n-    }\n \n-    FixtureEntry { path, text: String::new(), crate_name: krate, deps, edition, cfg, env }\n+        Fixture { path, text: String::new(), crate_name: krate, deps, edition, cfg, env }\n+    }\n }\n \n /// Adjusts the indentation of the first line to the minimum indentation of the rest of the lines.\n@@ -170,8 +172,8 @@ fn parse_fixture_can_handle_dedented_first_line() {\n                    struct Bar;\n \";\n     assert_eq!(\n-        parse_fixture(fixture),\n-        parse_fixture(\n+        Fixture::parse(fixture),\n+        Fixture::parse(\n             \"//- /lib.rs\n mod foo;\n //- /foo.rs\n@@ -183,7 +185,7 @@ struct Bar;\n \n #[test]\n fn parse_fixture_gets_full_meta() {\n-    let parsed = parse_fixture(\n+    let parsed = Fixture::parse(\n         r\"\n     //- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b,atom env:OUTDIR=path/to,OTHER=foo\n     mod m;"}, {"sha": "316f3d50174c52cef493ead62dc21fa6a4964760", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdf86aee18e396d393d50df7df27b02111838507/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdf86aee18e396d393d50df7df27b02111838507/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=fdf86aee18e396d393d50df7df27b02111838507", "patch": "@@ -22,7 +22,7 @@ pub use difference::Changeset as __Changeset;\n pub use ra_cfg::CfgOptions;\n pub use rustc_hash::FxHashMap;\n \n-pub use crate::fixture::{parse_fixture, FixtureEntry};\n+pub use crate::fixture::Fixture;\n \n pub const CURSOR_MARKER: &str = \"<|>\";\n "}]}