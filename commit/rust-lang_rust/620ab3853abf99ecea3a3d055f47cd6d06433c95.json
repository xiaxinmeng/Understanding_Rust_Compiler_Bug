{"sha": "620ab3853abf99ecea3a3d055f47cd6d06433c95", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyMGFiMzg1M2FiZjk5ZWNlYTNhM2QwNTVmNDdjZDZkMDY0MzNjOTU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-18T04:08:48Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-24T21:21:58Z"}, "message": "Test fixes and merge conflicts", "tree": {"sha": "61f35d294ededfa57258fee32e83b54f7f2e0536", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61f35d294ededfa57258fee32e83b54f7f2e0536"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/620ab3853abf99ecea3a3d055f47cd6d06433c95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/620ab3853abf99ecea3a3d055f47cd6d06433c95", "html_url": "https://github.com/rust-lang/rust/commit/620ab3853abf99ecea3a3d055f47cd6d06433c95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/620ab3853abf99ecea3a3d055f47cd6d06433c95/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "279c35182050889cba42e4adb1438a7f640fdabd", "url": "https://api.github.com/repos/rust-lang/rust/commits/279c35182050889cba42e4adb1438a7f640fdabd", "html_url": "https://github.com/rust-lang/rust/commit/279c35182050889cba42e4adb1438a7f640fdabd"}], "stats": {"total": 306, "additions": 158, "deletions": 148}, "files": [{"sha": "056d967ae6ca8ad3b9de23ca0b6ad4f6a2e1cc67", "filename": "doc/tutorial-conditions.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/620ab3853abf99ecea3a3d055f47cd6d06433c95/doc%2Ftutorial-conditions.md", "raw_url": "https://github.com/rust-lang/rust/raw/620ab3853abf99ecea3a3d055f47cd6d06433c95/doc%2Ftutorial-conditions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-conditions.md?ref=620ab3853abf99ecea3a3d055f47cd6d06433c95", "patch": "@@ -43,7 +43,7 @@ $ ./example numbers.txt\n \n An example program that does this task reads like this:\n \n-~~~~\n+~~~~{.xfail-test}\n # #[allow(unused_imports)];\n extern mod extra;\n use extra::fileinput::FileInput;\n@@ -430,7 +430,7 @@ To trap a condition, use `Condition::trap` in some caller of the site that calls\n For example, this version of the program traps the `malformed_line` condition\n and replaces bad input lines with the pair `(-1,-1)`:\n \n-~~~~\n+~~~~{.xfail-test}\n # #[allow(unused_imports)];\n extern mod extra;\n use extra::fileinput::FileInput;\n@@ -507,7 +507,7 @@ In the example program, the first form of the `malformed_line` API implicitly as\n This assumption may not be correct; some callers may wish to skip malformed lines, for example.\n Changing the condition's return type from `(int,int)` to `Option<(int,int)>` will suffice to support this type of recovery:\n \n-~~~~\n+~~~~{.xfail-test}\n # #[allow(unused_imports)];\n extern mod extra;\n use extra::fileinput::FileInput;\n@@ -594,7 +594,7 @@ until all relevant combinations encountered in practice are encoded.\n In the example, suppose a third possible recovery form arose: reusing the previous value read.\n This can be encoded in the handler API by introducing a helper type: `enum MalformedLineFix`.\n \n-~~~~\n+~~~~{.xfail-test}\n # #[allow(unused_imports)];\n extern mod extra;\n use extra::fileinput::FileInput;\n@@ -720,7 +720,7 @@ task <unnamed> failed at 'called `Option::unwrap()` on a `None` value', .../libs\n To make the program robust -- or at least flexible -- in the face of this potential failure,\n a second condition and a helper function will suffice:\n \n-~~~~\n+~~~~{.xfail-test}\n # #[allow(unused_imports)];\n extern mod extra;\n use extra::fileinput::FileInput;"}, {"sha": "4983a5af3e5abc04d93f005f4d87436d08b9b016", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/620ab3853abf99ecea3a3d055f47cd6d06433c95/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/620ab3853abf99ecea3a3d055f47cd6d06433c95/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=620ab3853abf99ecea3a3d055f47cd6d06433c95", "patch": "@@ -69,7 +69,6 @@ calling the `spawn` function with a closure argument. `spawn` executes the\n closure in the new task.\n \n ~~~~\n-# use std::io::println;\n # use std::task::spawn;\n \n // Print something profound in a different task using a named function"}, {"sha": "f9f110c122b28673e207abda2199f3b0266af26b", "filename": "doc/tutorial.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/620ab3853abf99ecea3a3d055f47cd6d06433c95/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/620ab3853abf99ecea3a3d055f47cd6d06433c95/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=620ab3853abf99ecea3a3d055f47cd6d06433c95", "patch": "@@ -2907,12 +2907,12 @@ you just have to import it with an `use` statement.\n For example, it re-exports `println` which is defined in `std::io::println`:\n \n ~~~\n-use puts = std::io::println;\n+use puts = std::rt::io::stdio::println;\n \n fn main() {\n     println(\"println is imported per default.\");\n     puts(\"Doesn't hinder you from importing it under an different name yourself.\");\n-    ::std::io::println(\"Or from not using the automatic import.\");\n+    ::std::rt::io::stdio::println(\"Or from not using the automatic import.\");\n }\n ~~~\n "}, {"sha": "1f32c6a0a35efd97c2caa117bc45dc4a2375c2d3", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=620ab3853abf99ecea3a3d055f47cd6d06433c95", "patch": "@@ -189,6 +189,8 @@ pub fn env() -> ~[(~str,~str)] {\n         #[cfg(windows)]\n         unsafe fn get_env_pairs() -> ~[~str] {\n             #[fixed_stack_segment]; #[inline(never)];\n+            use c_str;\n+            use str::StrSlice;\n \n             use libc::funcs::extra::kernel32::{\n                 GetEnvironmentStringsA,\n@@ -201,7 +203,7 @@ pub fn env() -> ~[(~str,~str)] {\n             }\n             let mut result = ~[];\n             do c_str::from_c_multistring(ch as *libc::c_char, None) |cstr| {\n-                result.push(cstr.as_str().to_owned());\n+                result.push(cstr.as_str().unwrap().to_owned());\n             };\n             FreeEnvironmentStringsA(ch);\n             result"}, {"sha": "ba819df071a97d5e37862fd8b5124ad113b039ef", "filename": "src/libstd/rt/io/native/file.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs?ref=620ab3853abf99ecea3a3d055f47cd6d06433c95", "patch": "@@ -17,9 +17,18 @@ use os;\n use prelude::*;\n use super::super::*;\n \n-fn raise_error() {\n+#[cfg(windows)]\n+fn get_err(errno: i32) -> (IoErrorKind, &'static str) {\n+    match errno {\n+        libc::EOF => (EndOfFile, \"end of file\"),\n+        _ => (OtherIoError, \"unknown error\"),\n+    }\n+}\n+\n+#[cfg(not(windows))]\n+fn get_err(errno: i32) -> (IoErrorKind, &'static str) {\n     // XXX: this should probably be a bit more descriptive...\n-    let (kind, desc) = match os::errno() as i32 {\n+    match errno {\n         libc::EOF => (EndOfFile, \"end of file\"),\n \n         // These two constants can have the same value on some systems, but\n@@ -28,8 +37,11 @@ fn raise_error() {\n             (ResourceUnavailable, \"resource temporarily unavailable\"),\n \n         _ => (OtherIoError, \"unknown error\"),\n-    };\n+    }\n+}\n \n+fn raise_error() {\n+    let (kind, desc) = get_err(os::errno() as i32);\n     io_error::cond.raise(IoError {\n         kind: kind,\n         desc: desc,"}, {"sha": "27cf9781c9c3cda643d001843693a26488c42443", "filename": "src/libstd/rt/io/net/addrinfo.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibstd%2Frt%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibstd%2Frt%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Faddrinfo.rs?ref=620ab3853abf99ecea3a3d055f47cd6d06433c95", "patch": "@@ -91,8 +91,11 @@ pub fn get_host_addresses(host: &str) -> Option<~[IpAddr]> {\n /// # Failure\n ///\n /// On failure, this will raise on the `io_error` condition.\n-pub fn lookup(hostname: Option<&str>, servname: Option<&str>,\n-              hint: Option<Hint>) -> Option<~[Info]> {\n+///\n+/// XXX: this is not public because the `Hint` structure is not ready for public\n+///      consumption just yet.\n+fn lookup(hostname: Option<&str>, servname: Option<&str>,\n+          hint: Option<Hint>) -> Option<~[Info]> {\n     do with_local_io |io| {\n         match io.get_host_addresses(hostname, servname, hint) {\n             Ok(i) => Some(i),"}, {"sha": "070985fb0a5cf79a9ac36454fdab630f74ccf67d", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=620ab3853abf99ecea3a3d055f47cd6d06433c95", "patch": "@@ -72,16 +72,22 @@ pub fn default_sched_threads() -> uint {\n pub fn dumb_println(args: &fmt::Arguments) {\n     use rt::io::native::stdio::stderr;\n     use rt::io::{Writer, io_error, ResourceUnavailable};\n+    use rt::task::Task;\n+    use rt::local::Local;\n \n     let mut out = stderr();\n-    let mut again = true;\n-    do io_error::cond.trap(|e| {\n-        again = e.kind == ResourceUnavailable;\n-    }).inside {\n-        while again {\n-            again = false;\n-            fmt::writeln(&mut out as &mut Writer, args);\n+    if Local::exists(None::<Task>) {\n+        let mut again = true;\n+        do io_error::cond.trap(|e| {\n+            again = e.kind == ResourceUnavailable;\n+        }).inside {\n+            while again {\n+                again = false;\n+                fmt::writeln(&mut out as &mut Writer, args);\n+            }\n         }\n+    } else {\n+        fmt::writeln(&mut out as &mut Writer, args);\n     }\n }\n "}, {"sha": "a1593d5c8db73efa44583ae751549bf40101f59c", "filename": "src/libstd/rt/uv/addrinfo.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs?ref=620ab3853abf99ecea3a3d055f47cd6d06433c95", "patch": "@@ -73,13 +73,14 @@ impl GetAddrInfoRequest {\n             cb(req, addrinfo, err)\n         };\n \n-        let hint = hints.map(|hint| unsafe {\n+        let hint = hints.map(|hint| {\n             let mut flags = 0;\n             do each_ai_flag |cval, aival| {\n                 if hint.flags & (aival as uint) != 0 {\n                     flags |= cval as i32;\n                 }\n             }\n+            /* XXX: do we really want to support these?\n             let socktype = match hint.socktype {\n                 Some(ai::Stream) => uvll::rust_SOCK_STREAM(),\n                 Some(ai::Datagram) => uvll::rust_SOCK_DGRAM(),\n@@ -91,6 +92,9 @@ impl GetAddrInfoRequest {\n                 Some(ai::TCP) => uvll::rust_IPPROTO_TCP(),\n                 _ => 0,\n             };\n+            */\n+            let socktype = 0;\n+            let protocol = 0;\n \n             uvll::addrinfo {\n                 ai_flags: flags,\n@@ -167,7 +171,8 @@ impl GetAddrInfoRequest {\n     }\n }\n \n-fn each_ai_flag(f: &fn(c_int, ai::Flag)) {\n+fn each_ai_flag(_f: &fn(c_int, ai::Flag)) {\n+    /* XXX: do we really want to support these?\n     unsafe {\n         f(uvll::rust_AI_ADDRCONFIG(), ai::AddrConfig);\n         f(uvll::rust_AI_ALL(), ai::All);\n@@ -177,6 +182,7 @@ fn each_ai_flag(f: &fn(c_int, ai::Flag)) {\n         f(uvll::rust_AI_PASSIVE(), ai::Passive);\n         f(uvll::rust_AI_V4MAPPED(), ai::V4Mapped);\n     }\n+    */\n }\n \n // Traverse the addrinfo linked list, producing a vector of Rust socket addresses\n@@ -197,6 +203,7 @@ pub fn accum_addrinfo(addr: &net::UvAddrInfo) -> ~[ai::Info] {\n                 }\n             }\n \n+            /* XXX: do we really want to support these\n             let protocol = match (*addr).ai_protocol {\n                 p if p == uvll::rust_IPPROTO_UDP() => Some(ai::UDP),\n                 p if p == uvll::rust_IPPROTO_TCP() => Some(ai::TCP),\n@@ -208,6 +215,9 @@ pub fn accum_addrinfo(addr: &net::UvAddrInfo) -> ~[ai::Info] {\n                 p if p == uvll::rust_SOCK_RAW() => Some(ai::Raw),\n                 _ => None,\n             };\n+            */\n+            let protocol = None;\n+            let socktype = None;\n \n             addrs.push(ai::Info {\n                 address: rustaddr,"}, {"sha": "88bb28d3763f09c6c173e867a37971623e670655", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=620ab3853abf99ecea3a3d055f47cd6d06433c95", "patch": "@@ -336,6 +336,13 @@ pub fn status_to_maybe_uv_error(status: c_int) -> Option<UvError>\n /// The uv buffer type\n pub type Buf = uvll::uv_buf_t;\n \n+pub fn empty_buf() -> Buf {\n+    uvll::uv_buf_t {\n+        base: null(),\n+        len: 0,\n+    }\n+}\n+\n /// Borrow a slice to a Buf\n pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n     let data = vec::raw::to_ptr(v);"}, {"sha": "77de8348c14613a7a0aa09167a7d4adea3bb8426", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=620ab3853abf99ecea3a3d055f47cd6d06433c95", "patch": "@@ -14,7 +14,7 @@ use rt::uv::uvll;\n use rt::uv::uvll::*;\n use rt::uv::{AllocCallback, ConnectionCallback, ReadCallback, UdpReceiveCallback, UdpSendCallback};\n use rt::uv::{Loop, Watcher, Request, UvError, Buf, NativeHandle,\n-             status_to_maybe_uv_error, vec_to_uv_buf};\n+             status_to_maybe_uv_error, empty_buf};\n use rt::io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n use vec;\n use str;\n@@ -119,23 +119,17 @@ impl Watcher for StreamWatcher { }\n \n impl StreamWatcher {\n     pub fn read_start(&mut self, alloc: AllocCallback, cb: ReadCallback) {\n-        {\n-            let data = self.get_watcher_data();\n-            data.alloc_cb = Some(alloc);\n-            data.read_cb = Some(cb);\n-        }\n-\n-        let ret = unsafe { uvll::read_start(self.native_handle(), alloc_cb, read_cb) };\n-\n-        if ret != 0 {\n-            // uvll::read_start failed, so read_cb will not be called.\n-            // Call it manually for scheduling.\n-            call_read_cb(self.native_handle(), ret as ssize_t);\n-        }\n-\n-        fn call_read_cb(stream: *uvll::uv_stream_t, errno: ssize_t) {\n-            #[fixed_stack_segment]; #[inline(never)];\n-            read_cb(stream, errno, vec_to_uv_buf(~[]));\n+        unsafe {\n+            match uvll::read_start(self.native_handle(), alloc_cb, read_cb) {\n+                0 => {\n+                    let data = self.get_watcher_data();\n+                    data.alloc_cb = Some(alloc);\n+                    data.read_cb = Some(cb);\n+                }\n+                n => {\n+                    cb(*self, 0, empty_buf(), Some(UvError(n)))\n+                }\n+            }\n         }\n \n         extern fn alloc_cb(stream: *uvll::uv_stream_t, suggested_size: size_t) -> Buf {\n@@ -163,16 +157,21 @@ impl StreamWatcher {\n     }\n \n     pub fn write(&mut self, buf: Buf, cb: ConnectionCallback) {\n-        {\n-            let data = self.get_watcher_data();\n-            assert!(data.write_cb.is_none());\n-            data.write_cb = Some(cb);\n-        }\n-\n         let req = WriteRequest::new();\n-        unsafe {\n-        assert_eq!(0, uvll::write(req.native_handle(), self.native_handle(), [buf], write_cb));\n-        }\n+        return unsafe {\n+            match uvll::write(req.native_handle(), self.native_handle(),\n+                              [buf], write_cb) {\n+                0 => {\n+                    let data = self.get_watcher_data();\n+                    assert!(data.write_cb.is_none());\n+                    data.write_cb = Some(cb);\n+                }\n+                n => {\n+                    req.delete();\n+                    cb(*self, Some(UvError(n)))\n+                }\n+            }\n+        };\n \n         extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n             let write_request: WriteRequest = NativeHandle::from_native_handle(req);"}, {"sha": "f12b1bce9e67d91e6a19442348d930540c6c4852", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=620ab3853abf99ecea3a3d055f47cd6d06433c95", "patch": "@@ -229,7 +229,7 @@ impl EventLoop for UvEventLoop {\n         }\n     }\n \n-    fn remote_callback(&mut self, f: ~fn()) -> ~RemoteCallback{\n+    fn remote_callback(&mut self, f: ~fn()) -> ~RemoteCallback {\n         ~UvRemoteCallback::new(self.uvio.uv_loop(), f) as ~RemoteCallback\n     }\n "}, {"sha": "f3e14dc314b70eaaca9634cbfb2ad8d3e0b8b2c0", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=620ab3853abf99ecea3a3d055f47cd6d06433c95", "patch": "@@ -1146,17 +1146,18 @@ extern {\n                                height: *c_int) -> c_int;\n     fn rust_uv_guess_handle(fd: c_int) -> uv_handle_type;\n \n+    // XXX: see comments in addrinfo.rs\n     // These should all really be constants...\n-    #[rust_stack] pub fn rust_SOCK_STREAM() -> c_int;\n-    #[rust_stack] pub fn rust_SOCK_DGRAM() -> c_int;\n-    #[rust_stack] pub fn rust_SOCK_RAW() -> c_int;\n-    #[rust_stack] pub fn rust_IPPROTO_UDP() -> c_int;\n-    #[rust_stack] pub fn rust_IPPROTO_TCP() -> c_int;\n-    #[rust_stack] pub fn rust_AI_ADDRCONFIG() -> c_int;\n-    #[rust_stack] pub fn rust_AI_ALL() -> c_int;\n-    #[rust_stack] pub fn rust_AI_CANONNAME() -> c_int;\n-    #[rust_stack] pub fn rust_AI_NUMERICHOST() -> c_int;\n-    #[rust_stack] pub fn rust_AI_NUMERICSERV() -> c_int;\n-    #[rust_stack] pub fn rust_AI_PASSIVE() -> c_int;\n-    #[rust_stack] pub fn rust_AI_V4MAPPED() -> c_int;\n+    //#[rust_stack] pub fn rust_SOCK_STREAM() -> c_int;\n+    //#[rust_stack] pub fn rust_SOCK_DGRAM() -> c_int;\n+    //#[rust_stack] pub fn rust_SOCK_RAW() -> c_int;\n+    //#[rust_stack] pub fn rust_IPPROTO_UDP() -> c_int;\n+    //#[rust_stack] pub fn rust_IPPROTO_TCP() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_ADDRCONFIG() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_ALL() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_CANONNAME() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_NUMERICHOST() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_NUMERICSERV() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_PASSIVE() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_V4MAPPED() -> c_int;\n }"}, {"sha": "d5f8e82b90fc5d7f91e5183d5d84c1016a6770b0", "filename": "src/libstd/run.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=620ab3853abf99ecea3a3d055f47cd6d06433c95", "patch": "@@ -19,6 +19,7 @@ use libc;\n use prelude::*;\n use rt::io::native::process;\n use rt::io;\n+use rt::io::extensions::ReaderUtil;\n use task;\n \n /**\n@@ -189,18 +190,6 @@ impl Process {\n         let output = Cell::new(self.inner.take_output());\n         let error = Cell::new(self.inner.take_error());\n \n-        fn read_everything(r: &mut io::Reader) -> ~[u8] {\n-            let mut ret = ~[];\n-            let mut buf = [0, ..1024];\n-            loop {\n-                match r.read(buf) {\n-                    Some(n) => { ret.push_all(buf.slice_to(n)); }\n-                    None => break\n-                }\n-            }\n-            return ret;\n-        }\n-\n         // Spawn two entire schedulers to read both stdout and sterr\n         // in parallel so we don't deadlock while blocking on one\n         // or the other. FIXME (#2625): Surely there's a much more\n@@ -210,13 +199,13 @@ impl Process {\n         let ch_clone = ch.clone();\n         do task::spawn_sched(task::SingleThreaded) {\n             match error.take() {\n-                Some(ref mut e) => ch.send((2, read_everything(*e))),\n+                Some(ref mut e) => ch.send((2, e.read_to_end())),\n                 None => ch.send((2, ~[]))\n             }\n         }\n         do task::spawn_sched(task::SingleThreaded) {\n             match output.take() {\n-                Some(ref mut e) => ch_clone.send((1, read_everything(*e))),\n+                Some(ref mut e) => ch_clone.send((1, e.read_to_end())),\n                 None => ch_clone.send((1, ~[]))\n             }\n         }"}, {"sha": "119a74cccd6d505a2a965ea948571682a0fcd2e4", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=620ab3853abf99ecea3a3d055f47cd6d06433c95", "patch": "@@ -129,6 +129,7 @@ pub fn expand_include_bin(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                                       file.display(), e.desc));\n         }\n         None => {\n+            let bytes = at_vec::to_managed_move(bytes);\n             base::MRExpr(cx.expr_lit(sp, ast::lit_binary(bytes)))\n         }\n     }"}, {"sha": "55fa09c38183de1decea25c8d615e4e0889c387c", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=620ab3853abf99ecea3a3d055f47cd6d06433c95", "patch": "@@ -638,19 +638,6 @@ rust_uv_pipe_init(uv_loop_t *loop, uv_pipe_t* p, int ipc) {\n   return uv_pipe_init(loop, p, ipc);\n }\n \n-extern \"C\" int rust_SOCK_STREAM()  { return SOCK_STREAM; }\n-extern \"C\" int rust_SOCK_DGRAM()  { return SOCK_DGRAM; }\n-extern \"C\" int rust_SOCK_RAW()  { return SOCK_RAW; }\n-extern \"C\" int rust_IPPROTO_UDP()  { return IPPROTO_UDP; }\n-extern \"C\" int rust_IPPROTO_TCP()  { return IPPROTO_TCP; }\n-extern \"C\" int rust_AI_ADDRCONFIG()  { return AI_ADDRCONFIG; }\n-extern \"C\" int rust_AI_ALL()  { return AI_ALL; }\n-extern \"C\" int rust_AI_CANONNAME()  { return AI_CANONNAME; }\n-extern \"C\" int rust_AI_NUMERICHOST()  { return AI_NUMERICHOST; }\n-extern \"C\" int rust_AI_NUMERICSERV()  { return AI_NUMERICSERV; }\n-extern \"C\" int rust_AI_PASSIVE()  { return AI_PASSIVE; }\n-extern \"C\" int rust_AI_V4MAPPED()  { return AI_V4MAPPED; }\n-\n extern \"C\" int\n rust_uv_pipe_open(uv_pipe_t *pipe, int file) {\n     return uv_pipe_open(pipe, file);"}, {"sha": "203f2e4d5f2b4833e7188a37ab61aa95a5e83d29", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=620ab3853abf99ecea3a3d055f47cd6d06433c95", "patch": "@@ -199,18 +199,6 @@ bufrelease\n bufnew\n rust_take_dlerror_lock\n rust_drop_dlerror_lock\n-rust_SOCK_STREAM\n-rust_SOCK_DGRAM\n-rust_SOCK_RAW\n-rust_IPPROTO_UDP\n-rust_IPPROTO_TCP\n-rust_AI_ADDRCONFIG\n-rust_AI_ALL\n-rust_AI_CANONNAME\n-rust_AI_NUMERICHOST\n-rust_AI_NUMERICSERV\n-rust_AI_PASSIVE\n-rust_AI_V4MAPPED\n rust_uv_pipe_open\n rust_uv_pipe_bind\n rust_uv_pipe_connect"}, {"sha": "52f068b8b1cdd13600440ded3f050365c4b23262", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=620ab3853abf99ecea3a3d055f47cd6d06433c95", "patch": "@@ -111,6 +111,7 @@ fn acid(ch: char, prob: u32) -> AminoAcids {\n }\n \n fn main() {\n+    use std::rt::io::file::FileInfo;\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n         // alioth tests k-nucleotide with this data at 25,000,000\n@@ -122,7 +123,7 @@ fn main() {\n     };\n \n     let writer = if os::getenv(\"RUST_BENCH\").is_some() {\n-        let file = \"./shootout-fasta.data\".open_writer(io::CreateOrTruncate);\n+        let file = Path::new(\"./shootout-fasta.data\").open_writer(io::CreateOrTruncate);\n         @mut file as @mut io::Writer\n     } else {\n         @mut io::stdout() as @mut io::Writer"}, {"sha": "cfc78e1615ec072da0fe76873ad3fbb2e95c66b2", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=620ab3853abf99ecea3a3d055f47cd6d06433c95", "patch": "@@ -20,6 +20,7 @@ use std::comm;\n use std::hashmap::HashMap;\n use std::option;\n use std::os;\n+use std::rt::io;\n use std::str;\n use std::task;\n use std::util;\n@@ -193,48 +194,48 @@ fn main() {\n    let mut proc_mode = false;\n \n    loop {\n-      let line = match rdr.read_line() {\n-          Some(ln) => ln, None => break,\n-      };\n-      let line = line.trim().to_owned();\n-\n-      if line.len() == 0u { continue; }\n-\n-      match (line[0] as char, proc_mode) {\n-\n-         // start processing if this is the one\n-         ('>', false) => {\n-            match line.slice_from(1).find_str(\"THREE\") {\n-               option::Some(_) => { proc_mode = true; }\n-               option::None    => { }\n-            }\n-         }\n-\n-         // break our processing\n-         ('>', true) => { break; }\n-\n-         // process the sequence for k-mers\n-         (_, true) => {\n-            let line_bytes = line.as_bytes();\n-\n-           for (ii, _sz) in sizes.iter().enumerate() {\n-               let lb = line_bytes.to_owned();\n-               to_child[ii].send(lb);\n-            }\n-         }\n-\n-         // whatever\n-         _ => { }\n-      }\n+       let line = match io::ignore_io_error(|| rdr.read_line()) {\n+           Some(ln) => ln, None => break,\n+       };\n+       let line = line.trim().to_owned();\n+\n+       if line.len() == 0u { continue; }\n+\n+       match (line[0] as char, proc_mode) {\n+\n+           // start processing if this is the one\n+           ('>', false) => {\n+               match line.slice_from(1).find_str(\"THREE\") {\n+                   option::Some(_) => { proc_mode = true; }\n+                   option::None    => { }\n+               }\n+           }\n+\n+           // break our processing\n+           ('>', true) => { break; }\n+\n+           // process the sequence for k-mers\n+           (_, true) => {\n+               let line_bytes = line.as_bytes();\n+\n+               for (ii, _sz) in sizes.iter().enumerate() {\n+                   let lb = line_bytes.to_owned();\n+                   to_child[ii].send(lb);\n+               }\n+           }\n+\n+           // whatever\n+           _ => { }\n+       }\n    }\n \n    // finish...\n-    for (ii, _sz) in sizes.iter().enumerate() {\n-      to_child[ii].send(~[]);\n+   for (ii, _sz) in sizes.iter().enumerate() {\n+       to_child[ii].send(~[]);\n    }\n \n    // now fetch and print result messages\n-    for (ii, _sz) in sizes.iter().enumerate() {\n-      println(from_child[ii].recv());\n+   for (ii, _sz) in sizes.iter().enumerate() {\n+       println(from_child[ii].recv());\n    }\n }"}, {"sha": "d4f4a46af38b123d85118fbc7e0b58e61a7d9434", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/620ab3853abf99ecea3a3d055f47cd6d06433c95/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=620ab3853abf99ecea3a3d055f47cd6d06433c95", "patch": "@@ -15,6 +15,8 @@\n extern mod extra;\n \n use std::rt::io;\n+use std::rt::io::stdio::StdReader;\n+use std::rt::io::buffered::BufferedReader;\n use std::os;\n use std::uint;\n use std::unstable::intrinsics::cttz16;\n@@ -66,12 +68,14 @@ impl Sudoku {\n         return true;\n     }\n \n-    pub fn read(reader: @mut io::Reader) -> Sudoku {\n-        assert!(reader.read_line() == ~\"9,9\"); /* assert first line is exactly \"9,9\" */\n+    pub fn read(mut reader: BufferedReader<StdReader>) -> Sudoku {\n+        assert!(reader.read_line().unwrap() == ~\"9,9\"); /* assert first line is exactly \"9,9\" */\n \n         let mut g = vec::from_fn(10u, { |_i| ~[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8] });\n-        while !reader.eof() {\n-            let line = reader.read_line();\n+        loop {\n+            let line = match reader.read_line() {\n+                Some(ln) => ln, None => break\n+            };\n             let comps: ~[&str] = line.trim().split_iter(',').collect();\n \n             if comps.len() == 3u {\n@@ -88,11 +92,11 @@ impl Sudoku {\n \n     pub fn write(&self, writer: @mut io::Writer) {\n         for row in range(0u8, 9u8) {\n-            writer.write_str(format!(\"{}\", self.grid[row][0] as uint));\n+            write!(writer, \"{}\", self.grid[row][0]);\n             for col in range(1u8, 9u8) {\n-                writer.write_str(format!(\" {}\", self.grid[row][col] as uint));\n+                write!(writer, \" {}\", self.grid[row][col]);\n             }\n-            writer.write_char('\\n');\n+            write!(writer, \"\\n\");\n          }\n     }\n \n@@ -277,7 +281,7 @@ fn main() {\n     let mut sudoku = if use_default {\n         Sudoku::from_vec(&DEFAULT_SUDOKU)\n     } else {\n-        Sudoku::read(@mut io::stdin() as @mut io::Reader)\n+        Sudoku::read(BufferedReader::new(io::stdin()))\n     };\n     sudoku.solve();\n     sudoku.write(@mut io::stdout() as @mut io::Writer);"}]}