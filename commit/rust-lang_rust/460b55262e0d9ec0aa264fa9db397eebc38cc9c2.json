{"sha": "460b55262e0d9ec0aa264fa9db397eebc38cc9c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2MGI1NTI2MmUwZDllYzBhYTI2NGZhOWRiMzk3ZWViYzM4Y2M5YzI=", "commit": {"author": {"name": "Chris Morgan", "email": "me@chrismorgan.info", "date": "2014-05-14T14:15:30Z"}, "committer": {"name": "Chris Morgan", "email": "me@chrismorgan.info", "date": "2014-05-14T14:15:30Z"}, "message": "Reinstate HashMap.mangle().\n\nThis was removed when the Robin Hood hash map came along, but it is a\nuseful thing to have.\n\nThe comment is taken directly from what was there before (e.g. in 0.9)\nbut with appropriate language changes (like `StrBuf` instead of `~str`).", "tree": {"sha": "983e39befeec4eec0ff5cf173891d8eb59b32ec9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/983e39befeec4eec0ff5cf173891d8eb59b32ec9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/460b55262e0d9ec0aa264fa9db397eebc38cc9c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/460b55262e0d9ec0aa264fa9db397eebc38cc9c2", "html_url": "https://github.com/rust-lang/rust/commit/460b55262e0d9ec0aa264fa9db397eebc38cc9c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/460b55262e0d9ec0aa264fa9db397eebc38cc9c2/comments", "author": {"login": "chris-morgan", "id": 392868, "node_id": "MDQ6VXNlcjM5Mjg2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/392868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chris-morgan", "html_url": "https://github.com/chris-morgan", "followers_url": "https://api.github.com/users/chris-morgan/followers", "following_url": "https://api.github.com/users/chris-morgan/following{/other_user}", "gists_url": "https://api.github.com/users/chris-morgan/gists{/gist_id}", "starred_url": "https://api.github.com/users/chris-morgan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chris-morgan/subscriptions", "organizations_url": "https://api.github.com/users/chris-morgan/orgs", "repos_url": "https://api.github.com/users/chris-morgan/repos", "events_url": "https://api.github.com/users/chris-morgan/events{/privacy}", "received_events_url": "https://api.github.com/users/chris-morgan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chris-morgan", "id": 392868, "node_id": "MDQ6VXNlcjM5Mjg2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/392868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chris-morgan", "html_url": "https://github.com/chris-morgan", "followers_url": "https://api.github.com/users/chris-morgan/followers", "following_url": "https://api.github.com/users/chris-morgan/following{/other_user}", "gists_url": "https://api.github.com/users/chris-morgan/gists{/gist_id}", "starred_url": "https://api.github.com/users/chris-morgan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chris-morgan/subscriptions", "organizations_url": "https://api.github.com/users/chris-morgan/orgs", "repos_url": "https://api.github.com/users/chris-morgan/repos", "events_url": "https://api.github.com/users/chris-morgan/events{/privacy}", "received_events_url": "https://api.github.com/users/chris-morgan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9906813c8102c9c9e6ff2316a96e7a0e3f70af9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9906813c8102c9c9e6ff2316a96e7a0e3f70af9", "html_url": "https://github.com/rust-lang/rust/commit/d9906813c8102c9c9e6ff2316a96e7a0e3f70af9"}], "stats": {"total": 78, "additions": 57, "deletions": 21}, "files": [{"sha": "44312e0eeaf3aceb596bbe9d2b3938d67bb6dbd4", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 57, "deletions": 21, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/460b55262e0d9ec0aa264fa9db397eebc38cc9c2/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/460b55262e0d9ec0aa264fa9db397eebc38cc9c2/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=460b55262e0d9ec0aa264fa9db397eebc38cc9c2", "patch": "@@ -1239,31 +1239,14 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Return the value corresponding to the key in the map, or insert\n     /// and return the value if it doesn't exist.\n     pub fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a mut V {\n-        let hash = self.make_hash(&k);\n-        match self.search_hashed(&hash, &k) {\n-            Some(idx) => {\n-                let (_, v_ref) = self.table.read_mut(&idx);\n-                v_ref\n-            },\n-            None => self.insert_hashed(hash, k, v)\n-        }\n+        self.mangle(k, v, |_k, a| a, |_k, _v, _a| ())\n     }\n \n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n     pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: |&K| -> V)\n                                -> &'a mut V {\n-        let hash = self.make_hash(&k);\n-        match self.search_hashed(&hash, &k) {\n-            Some(idx) => {\n-                let (_, v_ref) = self.table.read_mut(&idx);\n-                v_ref\n-            },\n-            None => {\n-                let v = f(&k);\n-                self.insert_hashed(hash, k, v)\n-            }\n-        }\n+        self.mangle(k, (), |k, _a| f(k), |_k, _v, _a| ())\n     }\n \n     /// Insert a key-value pair into the map if the key is not already present.\n@@ -1275,12 +1258,65 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n                                  v: V,\n                                  f: |&K, &mut V|)\n                                  -> &'a mut V {\n+        self.mangle(k, v, |_k, a| a, |k, v, _a| f(k, v))\n+    }\n+\n+    /// Modify and return the value corresponding to the key in the map, or\n+    /// insert and return a new value if it doesn't exist.\n+    ///\n+    /// This method allows for all insertion behaviours of a hashmap;\n+    /// see methods like `insert`, `find_or_insert` and\n+    /// `insert_or_update_with` for less general and more friendly\n+    /// variations of this.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use collections::HashMap;\n+    ///\n+    /// // map some strings to vectors of strings\n+    /// let mut map = HashMap::<StrBuf, Vec<StrBuf>>::new();\n+    /// map.insert(StrBuf::from_str(\"a key\"), vec![StrBuf::from_str(\"value\")]);\n+    /// map.insert(StrBuf::from_str(\"z key\"), vec![StrBuf::from_str(\"value\")]);\n+    ///\n+    /// let new = vec![StrBuf::from_str(\"a key\"),\n+    ///                StrBuf::from_str(\"b key\"),\n+    ///                StrBuf::from_str(\"z key\")];\n+    /// for k in new.move_iter() {\n+    ///     map.mangle(k, StrBuf::from_str(\"new value\"),\n+    ///                // if the key doesn't exist in the map yet, add it in\n+    ///                // the obvious way.\n+    ///                |_k, v| vec![v],\n+    ///                // if the key does exist either prepend or append this\n+    ///                // new value based on the first letter of the key.\n+    ///                |key, already, new| {\n+    ///                    if key.as_slice().starts_with(\"z\") {\n+    ///                        already.unshift(new);\n+    ///                    } else {\n+    ///                        already.push(new);\n+    ///                    }\n+    ///                });\n+    /// }\n+    ///\n+    /// for (k, v) in map.iter() {\n+    ///     println!(\"{} -> {:?}\", *k, *v);\n+    /// }\n+    /// ```\n+    pub fn mangle<'a, A>(&'a mut self,\n+                         k: K,\n+                         a: A,\n+                         not_found: |&K, A| -> V,\n+                         found: |&K, &mut V, A|)\n+                        -> &'a mut V {\n         let hash = self.make_hash(&k);\n         match self.search_hashed(&hash, &k) {\n-            None      => self.insert_hashed(hash, k, v),\n+            None => {\n+                let v = not_found(&k, a);\n+                self.insert_hashed(hash, k, v)\n+            },\n             Some(idx) => {\n                 let (_, v_ref) = self.table.read_mut(&idx);\n-                f(&k, v_ref);\n+                found(&k, v_ref, a);\n                 v_ref\n             }\n         }"}]}