{"sha": "e6a6df5daad01472e93f19802b0ce25f7a9b020c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2YTZkZjVkYWFkMDE0NzJlOTNmMTk4MDJiMGNlMjVmN2E5YjAyMGM=", "commit": {"author": {"name": "Mara", "email": "m-ou.se@m-ou.se", "date": "2021-03-05T09:57:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-05T09:57:14Z"}, "message": "Rollup merge of #80723 - rylev:noop-lint-pass, r=estebank\n\nImplement NOOP_METHOD_CALL lint\n\nImplements the beginnings of https://github.com/rust-lang/lang-team/issues/67 - a lint for detecting noop method calls (e.g, calling `<&T as Clone>::clone()` when `T: !Clone`).\n\nThis PR does not fully realize the vision and has a few limitations that need to be addressed either before merging or in subsequent PRs:\n* [ ] No UFCS support\n* [ ] The warning message is pretty plain\n* [ ] Doesn't work for `ToOwned`\n\nThe implementation uses [`Instance::resolve`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/instance/struct.Instance.html#method.resolve) which is normally later in the compiler. It seems that there are some invariants that this function relies on that we try our best to respect. For instance, it expects substitutions to have happened, which haven't yet performed, but we check first for `needs_subst` to ensure we're dealing with a monomorphic type.\n\nThank you to ```@davidtwco,``` ```@Aaron1011,``` and ```@wesleywiser``` for helping me at various points through out this PR \u2764\ufe0f.", "tree": {"sha": "f2dac9a65dfa7eb1586bfc799dfba67c931a3776", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2dac9a65dfa7eb1586bfc799dfba67c931a3776"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6a6df5daad01472e93f19802b0ce25f7a9b020c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgQgB7CRBK7hj4Ov3rIwAAdHIIAKoa92rV7OKFqQjyhMO5oWoC\nGzdu/gNBoEc+8oM1YfClDawCCyjXrUBp/nJ+/XQE+05DrYcIRWy2b6fbi1PUBg63\nzHPXQbXmjossj0kB8L8FkVbhLJPs+URY+N5Hvff4F9MZU+ieebPi2AfWF4rFKiUK\nLyFf34ip5ew/10qirPjrWsFyKaMPIqBXoiMuioE+YeLrFsOeclexBI2vGFiQoB9/\njHmhdpXan9RiHFsM/RzhiE+MAnP1Hd7sF+ICwyi2wL/gg1MDfXu8YflPVT7BMQ9v\novCkASGJLOC8IuBWBkPqVrXquB4IKN0cYOJP7j4/WvVNl8TE05GtWDvEL3XihOY=\n=OoDl\n-----END PGP SIGNATURE-----\n", "payload": "tree f2dac9a65dfa7eb1586bfc799dfba67c931a3776\nparent a0d66b54fb3acc2125972b88ff543a2c04d14af5\nparent 25637b228d68e9bdf2d3ce1ba421cbd115fcb81e\nauthor Mara <m-ou.se@m-ou.se> 1614938234 +0100\ncommitter GitHub <noreply@github.com> 1614938234 +0100\n\nRollup merge of #80723 - rylev:noop-lint-pass, r=estebank\n\nImplement NOOP_METHOD_CALL lint\n\nImplements the beginnings of https://github.com/rust-lang/lang-team/issues/67 - a lint for detecting noop method calls (e.g, calling `<&T as Clone>::clone()` when `T: !Clone`).\n\nThis PR does not fully realize the vision and has a few limitations that need to be addressed either before merging or in subsequent PRs:\n* [ ] No UFCS support\n* [ ] The warning message is pretty plain\n* [ ] Doesn't work for `ToOwned`\n\nThe implementation uses [`Instance::resolve`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/instance/struct.Instance.html#method.resolve) which is normally later in the compiler. It seems that there are some invariants that this function relies on that we try our best to respect. For instance, it expects substitutions to have happened, which haven't yet performed, but we check first for `needs_subst` to ensure we're dealing with a monomorphic type.\n\nThank you to ```@davidtwco,``` ```@Aaron1011,``` and ```@wesleywiser``` for helping me at various points through out this PR \u2764\ufe0f.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6a6df5daad01472e93f19802b0ce25f7a9b020c", "html_url": "https://github.com/rust-lang/rust/commit/e6a6df5daad01472e93f19802b0ce25f7a9b020c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6a6df5daad01472e93f19802b0ce25f7a9b020c/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0d66b54fb3acc2125972b88ff543a2c04d14af5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0d66b54fb3acc2125972b88ff543a2c04d14af5", "html_url": "https://github.com/rust-lang/rust/commit/a0d66b54fb3acc2125972b88ff543a2c04d14af5"}, {"sha": "25637b228d68e9bdf2d3ce1ba421cbd115fcb81e", "url": "https://api.github.com/repos/rust-lang/rust/commits/25637b228d68e9bdf2d3ce1ba421cbd115fcb81e", "html_url": "https://github.com/rust-lang/rust/commit/25637b228d68e9bdf2d3ce1ba421cbd115fcb81e"}], "stats": {"total": 262, "additions": 240, "deletions": 22}, "files": [{"sha": "5f21046b05e475e9e3934faa2a671d927ee99383", "filename": "compiler/rustc_codegen_ssa/src/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath.rs?ref=e6a6df5daad01472e93f19802b0ce25f7a9b020c", "patch": "@@ -24,7 +24,7 @@ pub fn get_rpath_flags(config: &mut RPathConfig<'_>) -> Vec<String> {\n \n     debug!(\"preparing the RPATH!\");\n \n-    let libs = config.used_crates.clone();\n+    let libs = config.used_crates;\n     let libs = libs.iter().filter_map(|&(_, ref l)| l.option()).collect::<Vec<_>>();\n     let rpaths = get_rpaths(config, &libs);\n     let mut flags = rpaths_to_flags(&rpaths);"}, {"sha": "9e61c83fda3a565823fcbb41f919c4341e8ddae1", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=e6a6df5daad01472e93f19802b0ce25f7a9b020c", "patch": "@@ -57,6 +57,7 @@ mod methods;\n mod non_ascii_idents;\n mod non_fmt_panic;\n mod nonstandard_style;\n+mod noop_method_call;\n mod passes;\n mod redundant_semicolon;\n mod traits;\n@@ -81,6 +82,7 @@ use methods::*;\n use non_ascii_idents::*;\n use non_fmt_panic::NonPanicFmt;\n use nonstandard_style::*;\n+use noop_method_call::*;\n use redundant_semicolon::*;\n use traits::*;\n use types::*;\n@@ -168,6 +170,7 @@ macro_rules! late_lint_passes {\n                 DropTraitConstraints: DropTraitConstraints,\n                 TemporaryCStringAsPtr: TemporaryCStringAsPtr,\n                 NonPanicFmt: NonPanicFmt,\n+                NoopMethodCall: NoopMethodCall,\n             ]\n         );\n     };"}, {"sha": "479cc00199f6adb33e54dc76fa47caf4cedb66f3", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=e6a6df5daad01472e93f19802b0ce25f7a9b020c", "patch": "@@ -0,0 +1,111 @@\n+use crate::context::LintContext;\n+use crate::rustc_middle::ty::TypeFoldable;\n+use crate::LateContext;\n+use crate::LateLintPass;\n+use rustc_hir::def::DefKind;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_middle::ty;\n+use rustc_span::symbol::sym;\n+\n+declare_lint! {\n+    /// The `noop_method_call` lint detects specific calls to noop methods\n+    /// such as a calling `<&T as Clone>::clone` where `T: !Clone`.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// # #![allow(unused)]\n+    /// #![warn(noop_method_call)]\n+    /// struct Foo;\n+    /// let foo = &Foo;\n+    /// let clone: &Foo = foo.clone();\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Some method calls are noops meaning that they do nothing. Usually such methods\n+    /// are the result of blanket implementations that happen to create some method invocations\n+    /// that end up not doing anything. For instance, `Clone` is implemented on all `&T`, but\n+    /// calling `clone` on a `&T` where `T` does not implement clone, actually doesn't do anything\n+    /// as references are copy. This lint detects these calls and warns the user about them.\n+    pub NOOP_METHOD_CALL,\n+    Allow,\n+    \"detects the use of well-known noop methods\"\n+}\n+\n+declare_lint_pass!(NoopMethodCall => [NOOP_METHOD_CALL]);\n+\n+impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        // We only care about method calls.\n+        let (call, elements) = match expr.kind {\n+            ExprKind::MethodCall(call, _, elements, _) => (call, elements),\n+            _ => return,\n+        };\n+        // We only care about method calls corresponding to the `Clone`, `Deref` and `Borrow`\n+        // traits and ignore any other method call.\n+        let (trait_id, did) = match cx.typeck_results().type_dependent_def(expr.hir_id) {\n+            // Verify we are dealing with a method/associated function.\n+            Some((DefKind::AssocFn, did)) => match cx.tcx.trait_of_item(did) {\n+                // Check that we're dealing with a trait method for one of the traits we care about.\n+                Some(trait_id)\n+                    if [sym::Clone, sym::Deref, sym::Borrow]\n+                        .iter()\n+                        .any(|s| cx.tcx.is_diagnostic_item(*s, trait_id)) =>\n+                {\n+                    (trait_id, did)\n+                }\n+                _ => return,\n+            },\n+            _ => return,\n+        };\n+        let substs = cx.typeck_results().node_substs(expr.hir_id);\n+        if substs.needs_subst() {\n+            // We can't resolve on types that require monomorphization, so we don't handle them if\n+            // we need to perfom substitution.\n+            return;\n+        }\n+        let param_env = cx.tcx.param_env(trait_id);\n+        // Resolve the trait method instance.\n+        let i = match ty::Instance::resolve(cx.tcx, param_env, did, substs) {\n+            Ok(Some(i)) => i,\n+            _ => return,\n+        };\n+        // (Re)check that it implements the noop diagnostic.\n+        for s in [sym::noop_method_clone, sym::noop_method_deref, sym::noop_method_borrow].iter() {\n+            if cx.tcx.is_diagnostic_item(*s, i.def_id()) {\n+                let method = &call.ident.name;\n+                let receiver = &elements[0];\n+                let receiver_ty = cx.typeck_results().expr_ty(receiver);\n+                let expr_ty = cx.typeck_results().expr_ty_adjusted(expr);\n+                if receiver_ty != expr_ty {\n+                    // This lint will only trigger if the receiver type and resulting expression \\\n+                    // type are the same, implying that the method call is unnecessary.\n+                    return;\n+                }\n+                let expr_span = expr.span;\n+                let note = format!(\n+                    \"the type `{:?}` which `{}` is being called on is the same as \\\n+                     the type returned from `{}`, so the method call does not do \\\n+                     anything and can be removed\",\n+                    receiver_ty, method, method,\n+                );\n+\n+                let span = expr_span.with_lo(receiver.span.hi());\n+                cx.struct_span_lint(NOOP_METHOD_CALL, span, |lint| {\n+                    let method = &call.ident.name;\n+                    let message = format!(\n+                        \"call to `.{}()` on a reference in this situation does nothing\",\n+                        &method,\n+                    );\n+                    lint.build(&message)\n+                        .span_label(span, \"unnecessary method call\")\n+                        .note(&note)\n+                        .emit()\n+                });\n+            }\n+        }\n+    }\n+}"}, {"sha": "f19cc99844926a0d0ce821c8698c2d503695fa26", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=e6a6df5daad01472e93f19802b0ce25f7a9b020c", "patch": "@@ -12,7 +12,6 @@ use rustc_target::spec::abi;\n \n use std::borrow::Cow;\n use std::fmt;\n-use std::ops::Deref;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, TypeFoldable)]\n pub struct ExpectedFound<T> {\n@@ -548,7 +547,6 @@ impl<T> Trait<T> for X {\n             TargetFeatureCast(def_id) => {\n                 let attrs = self.get_attrs(*def_id);\n                 let target_spans = attrs\n-                    .deref()\n                     .iter()\n                     .filter(|attr| attr.has_name(sym::target_feature))\n                     .map(|attr| attr.span);"}, {"sha": "e423e449746fc54f23754814fcbd1ee2bae86cc0", "filename": "compiler/rustc_mir/src/borrow_check/invalidation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs?ref=e6a6df5daad01472e93f19802b0ce25f7a9b020c", "patch": "@@ -165,7 +165,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 self.consume_operand(location, value);\n \n                 // Invalidate all borrows of local places\n-                let borrow_set = self.borrow_set.clone();\n+                let borrow_set = self.borrow_set;\n                 let resume = self.location_table.start_index(resume.start_location());\n                 for (i, data) in borrow_set.iter_enumerated() {\n                     if borrow_of_local_data(data.borrowed_place) {\n@@ -177,7 +177,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             }\n             TerminatorKind::Resume | TerminatorKind::Return | TerminatorKind::GeneratorDrop => {\n                 // Invalidate all borrows of local places\n-                let borrow_set = self.borrow_set.clone();\n+                let borrow_set = self.borrow_set;\n                 let start = self.location_table.start_index(location);\n                 for (i, data) in borrow_set.iter_enumerated() {\n                     if borrow_of_local_data(data.borrowed_place) {\n@@ -369,15 +369,15 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n         );\n         let tcx = self.tcx;\n         let body = self.body;\n-        let borrow_set = self.borrow_set.clone();\n+        let borrow_set = self.borrow_set;\n         let indices = self.borrow_set.indices();\n         each_borrow_involving_path(\n             self,\n             tcx,\n             body,\n             location,\n             (sd, place),\n-            &borrow_set.clone(),\n+            borrow_set,\n             indices,\n             |this, borrow_index, borrow| {\n                 match (rw, borrow.kind) {"}, {"sha": "4db7debee7e8f64c8aca6769d0f8a3968ebfbe32", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=e6a6df5daad01472e93f19802b0ce25f7a9b020c", "patch": "@@ -51,7 +51,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             PatKind::Constant { value } => Test {\n                 span: match_pair.pattern.span,\n-                kind: TestKind::Eq { value, ty: match_pair.pattern.ty.clone() },\n+                kind: TestKind::Eq { value, ty: match_pair.pattern.ty },\n             },\n \n             PatKind::Range(range) => {"}, {"sha": "cd47b714db5ae85fd48b8970579ac6bbc9fbf231", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=e6a6df5daad01472e93f19802b0ce25f7a9b020c", "patch": "@@ -129,6 +129,7 @@ symbols! {\n         BTreeMap,\n         BTreeSet,\n         BinaryHeap,\n+        Borrow,\n         C,\n         CString,\n         Center,\n@@ -141,6 +142,7 @@ symbols! {\n         Decodable,\n         Decoder,\n         Default,\n+        Deref,\n         Encodable,\n         Encoder,\n         Eq,\n@@ -789,6 +791,9 @@ symbols! {\n         none_error,\n         nontemporal_store,\n         nontrapping_dash_fptoint: \"nontrapping-fptoint\",\n+        noop_method_borrow,\n+        noop_method_clone,\n+        noop_method_deref,\n         noreturn,\n         nostack,\n         not,"}, {"sha": "a3faf4cb7d4c19d1f2eb457087368fbcbfd56618", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=e6a6df5daad01472e93f19802b0ce25f7a9b020c", "patch": "@@ -819,7 +819,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 sig.decl\n                     .inputs\n                     .iter()\n-                    .map(|arg| match arg.clone().kind {\n+                    .map(|arg| match arg.kind {\n                         hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n                             Some(arg.span),\n                             vec![(\"_\".to_owned(), \"_\".to_owned()); tys.len()],"}, {"sha": "b7275bac19048f701feeae31fb0f31654a51bf7a", "filename": "compiler/rustc_traits/src/chalk/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs?ref=e6a6df5daad01472e93f19802b0ce25f7a9b020c", "patch": "@@ -165,7 +165,7 @@ crate fn evaluate_goal<'tcx>(\n                         // let's just ignore that\n                         let sol = Canonical {\n                             max_universe: ty::UniverseIndex::from_usize(0),\n-                            variables: obligation.variables.clone(),\n+                            variables: obligation.variables,\n                             value: QueryResponse {\n                                 var_values: CanonicalVarValues { var_values: IndexVec::new() }\n                                     .make_identity(tcx),"}, {"sha": "6ef63bcbbbf2171bc750a3a34cf1d51694e6b0e9", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=e6a6df5daad01472e93f19802b0ce25f7a9b020c", "patch": "@@ -465,7 +465,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let expected_arg_tys = self.expected_inputs_for_expected_output(\n             call_expr.span,\n             expected,\n-            fn_sig.output().clone(),\n+            fn_sig.output(),\n             fn_sig.inputs(),\n         );\n "}, {"sha": "48740e533da8ea196155929cc884a9698e7aa2a2", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a6df5daad01472e93f19802b0ce25f7a9b020c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=e6a6df5daad01472e93f19802b0ce25f7a9b020c", "patch": "@@ -711,7 +711,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         });\n \n         let ret_ty = ret_coercion.borrow().expected_ty();\n-        let return_expr_ty = self.check_expr_with_hint(return_expr, ret_ty.clone());\n+        let return_expr_ty = self.check_expr_with_hint(return_expr, ret_ty);\n         ret_coercion.borrow_mut().coerce(\n             self,\n             &self.cause(return_expr.span, ObligationCauseCode::ReturnValue(return_expr.hir_id)),"}, {"sha": "e636e490e1bf4d02ce7dbb4fb59c57388b480764", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6a6df5daad01472e93f19802b0ce25f7a9b020c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a6df5daad01472e93f19802b0ce25f7a9b020c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=e6a6df5daad01472e93f19802b0ce25f7a9b020c", "patch": "@@ -1801,11 +1801,11 @@ fn test_occupied_entry_key() {\n     let key = \"hello there\";\n     let value = \"value goes here\";\n     assert!(a.is_empty());\n-    a.insert(key.clone(), value.clone());\n+    a.insert(key, value);\n     assert_eq!(a.len(), 1);\n     assert_eq!(a[key], value);\n \n-    match a.entry(key.clone()) {\n+    match a.entry(key) {\n         Vacant(_) => panic!(),\n         Occupied(e) => assert_eq!(key, *e.key()),\n     }\n@@ -1821,11 +1821,11 @@ fn test_vacant_entry_key() {\n     let value = \"value goes here\";\n \n     assert!(a.is_empty());\n-    match a.entry(key.clone()) {\n+    match a.entry(key) {\n         Occupied(_) => panic!(),\n         Vacant(e) => {\n             assert_eq!(key, *e.key());\n-            e.insert(value.clone());\n+            e.insert(value);\n         }\n     }\n     assert_eq!(a.len(), 1);"}, {"sha": "f28be20aaa1e6309d72be3a403a055a546707c18", "filename": "library/core/src/borrow.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6a6df5daad01472e93f19802b0ce25f7a9b020c/library%2Fcore%2Fsrc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a6df5daad01472e93f19802b0ce25f7a9b020c/library%2Fcore%2Fsrc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fborrow.rs?ref=e6a6df5daad01472e93f19802b0ce25f7a9b020c", "patch": "@@ -153,6 +153,7 @@\n /// [`HashMap<K, V>`]: ../../std/collections/struct.HashMap.html\n /// [`String`]: ../../std/string/struct.String.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_diagnostic_item = \"Borrow\"]\n pub trait Borrow<Borrowed: ?Sized> {\n     /// Immutably borrows from an owned value.\n     ///\n@@ -205,6 +206,7 @@ pub trait BorrowMut<Borrowed: ?Sized>: Borrow<Borrowed> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Borrow<T> for T {\n+    #[rustc_diagnostic_item = \"noop_method_borrow\"]\n     fn borrow(&self) -> &T {\n         self\n     }"}, {"sha": "51a2dc03de3186668e51f942acd9cd841a0b3017", "filename": "library/core/src/clone.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6a6df5daad01472e93f19802b0ce25f7a9b020c/library%2Fcore%2Fsrc%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a6df5daad01472e93f19802b0ce25f7a9b020c/library%2Fcore%2Fsrc%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fclone.rs?ref=e6a6df5daad01472e93f19802b0ce25f7a9b020c", "patch": "@@ -104,12 +104,14 @@\n /// [impls]: #implementors\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"clone\"]\n+#[rustc_diagnostic_item = \"Clone\"]\n pub trait Clone: Sized {\n     /// Returns a copy of the value.\n     ///\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![allow(noop_method_call)]\n     /// let hello = \"Hello\"; // &str implements Clone\n     ///\n     /// assert_eq!(\"Hello\", hello.clone());\n@@ -221,6 +223,7 @@ mod impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<T: ?Sized> Clone for &T {\n         #[inline]\n+        #[rustc_diagnostic_item = \"noop_method_clone\"]\n         fn clone(&self) -> Self {\n             *self\n         }"}, {"sha": "10e3ce67448c8d717dc28484ca6d5867516f7ffb", "filename": "library/core/src/ops/deref.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6a6df5daad01472e93f19802b0ce25f7a9b020c/library%2Fcore%2Fsrc%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a6df5daad01472e93f19802b0ce25f7a9b020c/library%2Fcore%2Fsrc%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fderef.rs?ref=e6a6df5daad01472e93f19802b0ce25f7a9b020c", "patch": "@@ -60,6 +60,7 @@\n #[doc(alias = \"*\")]\n #[doc(alias = \"&*\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_diagnostic_item = \"Deref\"]\n pub trait Deref {\n     /// The resulting type after dereferencing.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -78,6 +79,7 @@ pub trait Deref {\n impl<T: ?Sized> Deref for &T {\n     type Target = T;\n \n+    #[rustc_diagnostic_item = \"noop_method_deref\"]\n     fn deref(&self) -> &T {\n         *self\n     }"}, {"sha": "b336c03b5adbe04464d72376f78e9bb122d34fbf", "filename": "library/core/tests/iter/adapters/intersperse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6a6df5daad01472e93f19802b0ce25f7a9b020c/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fintersperse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a6df5daad01472e93f19802b0ce25f7a9b020c/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fintersperse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fintersperse.rs?ref=e6a6df5daad01472e93f19802b0ce25f7a9b020c", "patch": "@@ -9,7 +9,7 @@ fn test_intersperse() {\n     assert_eq!(v, vec![1]);\n \n     let xs = [\"a\", \"\", \"b\", \"c\"];\n-    let v: Vec<&str> = xs.iter().map(|x| x.clone()).intersperse(\", \").collect();\n+    let v: Vec<&str> = xs.iter().map(|x| *x).intersperse(\", \").collect();\n     let text: String = v.concat();\n     assert_eq!(text, \"a, , b, c\".to_string());\n \n@@ -24,7 +24,7 @@ fn test_intersperse_size_hint() {\n     assert_eq!(iter.size_hint(), (0, Some(0)));\n \n     let xs = [\"a\", \"\", \"b\", \"c\"];\n-    let mut iter = xs.iter().map(|x| x.clone()).intersperse(\", \");\n+    let mut iter = xs.iter().map(|x| *x).intersperse(\", \");\n     assert_eq!(iter.size_hint(), (7, Some(7)));\n \n     assert_eq!(iter.next(), Some(\"a\"));"}, {"sha": "819be14222752e1eb5724713361f22e504d90798", "filename": "library/std/src/collections/hash/map/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6a6df5daad01472e93f19802b0ce25f7a9b020c/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a6df5daad01472e93f19802b0ce25f7a9b020c/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs?ref=e6a6df5daad01472e93f19802b0ce25f7a9b020c", "patch": "@@ -774,11 +774,11 @@ fn test_occupied_entry_key() {\n     let key = \"hello there\";\n     let value = \"value goes here\";\n     assert!(a.is_empty());\n-    a.insert(key.clone(), value.clone());\n+    a.insert(key, value);\n     assert_eq!(a.len(), 1);\n     assert_eq!(a[key], value);\n \n-    match a.entry(key.clone()) {\n+    match a.entry(key) {\n         Vacant(_) => panic!(),\n         Occupied(e) => assert_eq!(key, *e.key()),\n     }\n@@ -793,11 +793,11 @@ fn test_vacant_entry_key() {\n     let value = \"value goes here\";\n \n     assert!(a.is_empty());\n-    match a.entry(key.clone()) {\n+    match a.entry(key) {\n         Occupied(_) => panic!(),\n         Vacant(e) => {\n             assert_eq!(key, *e.key());\n-            e.insert(value.clone());\n+            e.insert(value);\n         }\n     }\n     assert_eq!(a.len(), 1);"}, {"sha": "9870c813572e36d15c6935adfe8f742f778d7368", "filename": "src/test/ui/lint/noop-method-call.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e6a6df5daad01472e93f19802b0ce25f7a9b020c/src%2Ftest%2Fui%2Flint%2Fnoop-method-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a6df5daad01472e93f19802b0ce25f7a9b020c/src%2Ftest%2Fui%2Flint%2Fnoop-method-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fnoop-method-call.rs?ref=e6a6df5daad01472e93f19802b0ce25f7a9b020c", "patch": "@@ -0,0 +1,54 @@\n+// check-pass\n+\n+#![allow(unused)]\n+#![warn(noop_method_call)]\n+\n+use std::borrow::Borrow;\n+use std::ops::Deref;\n+\n+struct PlainType<T>(T);\n+\n+#[derive(Clone)]\n+struct CloneType<T>(T);\n+\n+fn main() {\n+    let non_clone_type_ref = &PlainType(1u32);\n+    let non_clone_type_ref_clone: &PlainType<u32> = non_clone_type_ref.clone();\n+    //~^ WARNING call to `.clone()` on a reference in this situation does nothing\n+\n+    let clone_type_ref = &CloneType(1u32);\n+    let clone_type_ref_clone: CloneType<u32> = clone_type_ref.clone();\n+\n+    // Calling clone on a double reference doesn't warn since the method call itself\n+    // peels the outer reference off\n+    let clone_type_ref = &&CloneType(1u32);\n+    let clone_type_ref_clone: &CloneType<u32> = clone_type_ref.clone();\n+\n+    let non_deref_type = &PlainType(1u32);\n+    let non_deref_type_deref: &PlainType<u32> = non_deref_type.deref();\n+    //~^ WARNING call to `.deref()` on a reference in this situation does nothing\n+\n+    // Dereferencing a &&T does not warn since it has collapsed the double reference\n+    let non_deref_type = &&PlainType(1u32);\n+    let non_deref_type_deref: &PlainType<u32> = non_deref_type.deref();\n+\n+    let non_borrow_type = &PlainType(1u32);\n+    let non_borrow_type_borrow: &PlainType<u32> = non_borrow_type.borrow();\n+    //~^ WARNING call to `.borrow()` on a reference in this situation does nothing\n+\n+    // Borrowing a &&T does not warn since it has collapsed the double reference\n+    let non_borrow_type = &&PlainType(1u32);\n+    let non_borrow_type_borrow: &PlainType<u32> = non_borrow_type.borrow();\n+\n+    let xs = [\"a\", \"b\", \"c\"];\n+    let _v: Vec<&str> = xs.iter().map(|x| x.clone()).collect(); // ok, but could use `*x` instead\n+}\n+\n+fn generic<T>(non_clone_type: &PlainType<T>) {\n+    non_clone_type.clone();\n+}\n+\n+fn non_generic(non_clone_type: &PlainType<u32>) {\n+    non_clone_type.clone();\n+    //~^ WARNING call to `.clone()` on a reference in this situation does nothing\n+}"}, {"sha": "7f6f96bf1d142218d4e923ec25fe6d79bed6da81", "filename": "src/test/ui/lint/noop-method-call.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e6a6df5daad01472e93f19802b0ce25f7a9b020c/src%2Ftest%2Fui%2Flint%2Fnoop-method-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6a6df5daad01472e93f19802b0ce25f7a9b020c/src%2Ftest%2Fui%2Flint%2Fnoop-method-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fnoop-method-call.stderr?ref=e6a6df5daad01472e93f19802b0ce25f7a9b020c", "patch": "@@ -0,0 +1,39 @@\n+warning: call to `.clone()` on a reference in this situation does nothing\n+  --> $DIR/noop-method-call.rs:16:71\n+   |\n+LL |     let non_clone_type_ref_clone: &PlainType<u32> = non_clone_type_ref.clone();\n+   |                                                                       ^^^^^^^^ unnecessary method call\n+   |\n+note: the lint level is defined here\n+  --> $DIR/noop-method-call.rs:4:9\n+   |\n+LL | #![warn(noop_method_call)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: the type `&PlainType<u32>` which `clone` is being called on is the same as the type returned from `clone`, so the method call does not do anything and can be removed\n+\n+warning: call to `.deref()` on a reference in this situation does nothing\n+  --> $DIR/noop-method-call.rs:28:63\n+   |\n+LL |     let non_deref_type_deref: &PlainType<u32> = non_deref_type.deref();\n+   |                                                               ^^^^^^^^ unnecessary method call\n+   |\n+   = note: the type `&PlainType<u32>` which `deref` is being called on is the same as the type returned from `deref`, so the method call does not do anything and can be removed\n+\n+warning: call to `.borrow()` on a reference in this situation does nothing\n+  --> $DIR/noop-method-call.rs:36:66\n+   |\n+LL |     let non_borrow_type_borrow: &PlainType<u32> = non_borrow_type.borrow();\n+   |                                                                  ^^^^^^^^^ unnecessary method call\n+   |\n+   = note: the type `&PlainType<u32>` which `borrow` is being called on is the same as the type returned from `borrow`, so the method call does not do anything and can be removed\n+\n+warning: call to `.clone()` on a reference in this situation does nothing\n+  --> $DIR/noop-method-call.rs:52:19\n+   |\n+LL |     non_clone_type.clone();\n+   |                   ^^^^^^^^ unnecessary method call\n+   |\n+   = note: the type `&PlainType<u32>` which `clone` is being called on is the same as the type returned from `clone`, so the method call does not do anything and can be removed\n+\n+warning: 4 warnings emitted\n+"}, {"sha": "510d91d0d462487ee91e4cbfc18739f919b0448d", "filename": "src/test/ui/underscore-imports/hygiene-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6a6df5daad01472e93f19802b0ce25f7a9b020c/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a6df5daad01472e93f19802b0ce25f7a9b020c/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene-2.rs?ref=e6a6df5daad01472e93f19802b0ce25f7a9b020c", "patch": "@@ -29,5 +29,6 @@ m!(y);\n \n fn main() {\n     use crate::y::*;\n+    #[allow(noop_method_call)]\n     (&()).deref();\n }"}]}