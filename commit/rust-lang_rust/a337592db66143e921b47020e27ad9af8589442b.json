{"sha": "a337592db66143e921b47020e27ad9af8589442b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMzc1OTJkYjY2MTQzZTkyMWI0NzAyMGUyN2FkOWFmODU4OTQ0MmI=", "commit": {"author": {"name": "Edward Wang", "email": "edward.yu.wang@gmail.com", "date": "2014-03-07T09:26:06Z"}, "committer": {"name": "Edward Wang", "email": "edward.yu.wang@gmail.com", "date": "2014-03-07T19:09:12Z"}, "message": "Index cross-mod type definition and implementation properly in rustdoc\n\nA structure's definition and implementation may be cross-module. If the\nimplementing module is parsed before defining module, the fully\nqualified name of the structure won't be present for the implementation\nto use when being indexed. So caches such 'orphan' implementation and\nindexes it at the end of crate parsing.\n\nCloses #10284.", "tree": {"sha": "85a0ac990d848f0efefdb1f0a3cdefba9415ed3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85a0ac990d848f0efefdb1f0a3cdefba9415ed3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a337592db66143e921b47020e27ad9af8589442b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a337592db66143e921b47020e27ad9af8589442b", "html_url": "https://github.com/rust-lang/rust/commit/a337592db66143e921b47020e27ad9af8589442b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a337592db66143e921b47020e27ad9af8589442b/comments", "author": {"login": "edwardw", "id": 454049, "node_id": "MDQ6VXNlcjQ1NDA0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/454049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwardw", "html_url": "https://github.com/edwardw", "followers_url": "https://api.github.com/users/edwardw/followers", "following_url": "https://api.github.com/users/edwardw/following{/other_user}", "gists_url": "https://api.github.com/users/edwardw/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwardw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwardw/subscriptions", "organizations_url": "https://api.github.com/users/edwardw/orgs", "repos_url": "https://api.github.com/users/edwardw/repos", "events_url": "https://api.github.com/users/edwardw/events{/privacy}", "received_events_url": "https://api.github.com/users/edwardw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwardw", "id": 454049, "node_id": "MDQ6VXNlcjQ1NDA0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/454049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwardw", "html_url": "https://github.com/edwardw", "followers_url": "https://api.github.com/users/edwardw/followers", "following_url": "https://api.github.com/users/edwardw/following{/other_user}", "gists_url": "https://api.github.com/users/edwardw/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwardw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwardw/subscriptions", "organizations_url": "https://api.github.com/users/edwardw/orgs", "repos_url": "https://api.github.com/users/edwardw/repos", "events_url": "https://api.github.com/users/edwardw/events{/privacy}", "received_events_url": "https://api.github.com/users/edwardw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33768c46ec980a911284d77804e5e45ead6530eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/33768c46ec980a911284d77804e5e45ead6530eb", "html_url": "https://github.com/rust-lang/rust/commit/33768c46ec980a911284d77804e5e45ead6530eb"}], "stats": {"total": 61, "additions": 51, "deletions": 10}, "files": [{"sha": "e985de4d2f5789862e36b1d60c3d708f6599a81b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 51, "deletions": 10, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a337592db66143e921b47020e27ad9af8589442b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a337592db66143e921b47020e27ad9af8589442b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=a337592db66143e921b47020e27ad9af8589442b", "patch": "@@ -39,6 +39,7 @@ use std::io;\n use std::io::{fs, File, BufferedWriter};\n use std::str;\n use std::vec;\n+use std::vec_ng::Vec;\n use collections::{HashMap, HashSet};\n \n use sync::Arc;\n@@ -160,6 +161,13 @@ pub struct Cache {\n     priv search_index: ~[IndexItem],\n     priv privmod: bool,\n     priv public_items: NodeSet,\n+\n+    // In rare case where a structure is defined in one module but implemented\n+    // in another, if the implementing module is parsed before defining module,\n+    // then the fully qualified name of the structure isn't presented in `paths`\n+    // yet when its implementation methods are being indexed. Caches such methods\n+    // and their parent id here and indexes them at the end of crate parsing.\n+    priv orphan_methods: Vec<(ast::NodeId, clean::Item)>,\n }\n \n /// Helper struct to render all source code to HTML pages\n@@ -249,10 +257,31 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n             extern_locations: HashMap::new(),\n             privmod: false,\n             public_items: public_items,\n+            orphan_methods: Vec::new(),\n         }\n     });\n     cache.stack.push(krate.name.clone());\n     krate = cache.fold_crate(krate);\n+    {\n+        // Attach all orphan methods to the type's definition if the type\n+        // has since been learned.\n+        let Cache { search_index: ref mut index,\n+                    orphan_methods: ref meths, paths: ref paths, ..} = cache;\n+        for &(ref pid, ref item) in meths.iter() {\n+            match paths.find(pid) {\n+                Some(&(ref fqp, _)) => {\n+                    index.push(IndexItem {\n+                        ty: shortty(item),\n+                        name: item.name.clone().unwrap(),\n+                        path: fqp.slice_to(fqp.len() - 1).connect(\"::\"),\n+                        desc: shorter(item.doc_value()).to_owned(),\n+                        parent: Some(*pid),\n+                    });\n+                },\n+                None => {}\n+            }\n+        };\n+    }\n \n     // Add all the static files\n     let mut dst = cx.dst.join(krate.name.as_slice());\n@@ -527,26 +556,33 @@ impl DocFolder for Cache {\n                     clean::TyMethodItem(..) |\n                     clean::StructFieldItem(..) |\n                     clean::VariantItem(..) => {\n-                        Some((Some(*self.parent_stack.last().unwrap()),\n-                              self.stack.slice_to(self.stack.len() - 1)))\n+                        (Some(*self.parent_stack.last().unwrap()),\n+                         Some(self.stack.slice_to(self.stack.len() - 1)))\n \n                     }\n                     clean::MethodItem(..) => {\n                         if self.parent_stack.len() == 0 {\n-                            None\n+                            (None, None)\n                         } else {\n                             let last = self.parent_stack.last().unwrap();\n-                            let amt = match self.paths.find(last) {\n-                                Some(&(_, \"trait\")) => self.stack.len() - 1,\n-                                Some(..) | None => self.stack.len(),\n+                            let path = match self.paths.find(last) {\n+                                Some(&(_, \"trait\")) =>\n+                                    Some(self.stack.slice_to(self.stack.len() - 1)),\n+                                // The current stack not necessarily has correlation for\n+                                // where the type was defined. On the other hand,\n+                                // `paths` always has the right information if present.\n+                                Some(&(ref fqp, \"struct\")) | Some(&(ref fqp, \"enum\")) =>\n+                                    Some(fqp.slice_to(fqp.len() - 1)),\n+                                Some(..) => Some(self.stack.as_slice()),\n+                                None => None\n                             };\n-                            Some((Some(*last), self.stack.slice_to(amt)))\n+                            (Some(*last), path)\n                         }\n                     }\n-                    _ => Some((None, self.stack.as_slice()))\n+                    _ => (None, Some(self.stack.as_slice()))\n                 };\n                 match parent {\n-                    Some((parent, path)) if !self.privmod => {\n+                    (parent, Some(path)) if !self.privmod => {\n                         self.search_index.push(IndexItem {\n                             ty: shortty(&item),\n                             name: s.to_owned(),\n@@ -555,7 +591,12 @@ impl DocFolder for Cache {\n                             parent: parent,\n                         });\n                     }\n-                    Some(..) | None => {}\n+                    (Some(parent), None) if !self.privmod => {\n+                        // We have a parent, but we don't know where they're\n+                        // defined yet. Wait for later to index this item.\n+                        self.orphan_methods.push((parent, item.clone()))\n+                    }\n+                    _ => {}\n                 }\n             }\n             None => {}"}]}