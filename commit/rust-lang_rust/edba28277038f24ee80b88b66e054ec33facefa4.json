{"sha": "edba28277038f24ee80b88b66e054ec33facefa4", "node_id": "C_kwDOAAsO6NoAKGVkYmEyODI3NzAzOGYyNGVlODBiODhiNjZlMDU0ZWMzM2ZhY2VmYTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-17T08:06:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-17T08:06:53Z"}, "message": "Auto merge of #95655 - kckeiks:create-hir-crate-items-query, r=cjgillot\n\nRefactor HIR item-like traversal (part 1)\n\nIssue  #95004\n\n- Create hir_crate_items query which traverses tcx.hir_crate(()).owners to return a hir::ModuleItems\n- use tcx.hir_crate_items in tcx.hir().items() to return an iterator of hir::ItemId\n- use tcx.hir_crate_items to introduce a tcx.hir().par_items(impl Fn(hir::ItemId)) to traverse all items in parallel;\n\nSigned-off-by: Miguel Guarniz <mi9uel9@gmail.com>\n\ncc `@cjgillot`", "tree": {"sha": "66aa0b39634acf3f80162389109c7d01e741f6e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66aa0b39634acf3f80162389109c7d01e741f6e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edba28277038f24ee80b88b66e054ec33facefa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edba28277038f24ee80b88b66e054ec33facefa4", "html_url": "https://github.com/rust-lang/rust/commit/edba28277038f24ee80b88b66e054ec33facefa4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edba28277038f24ee80b88b66e054ec33facefa4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac8b11810f4a0def3596ee401feb9ef00015b555", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac8b11810f4a0def3596ee401feb9ef00015b555", "html_url": "https://github.com/rust-lang/rust/commit/ac8b11810f4a0def3596ee401feb9ef00015b555"}, {"sha": "88108bd5d9832a9286b899dc7c8916a9bd104711", "url": "https://api.github.com/repos/rust-lang/rust/commits/88108bd5d9832a9286b899dc7c8916a9bd104711", "html_url": "https://github.com/rust-lang/rust/commit/88108bd5d9832a9286b899dc7c8916a9bd104711"}], "stats": {"total": 853, "additions": 433, "deletions": 420}, "files": [{"sha": "96dd00ec5cff193210506e64b99e8a60fb285981", "filename": "compiler/rustc_hir/src/target.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs?ref=edba28277038f24ee80b88b66e054ec33facefa4", "patch": "@@ -7,6 +7,7 @@\n use crate::hir;\n use crate::{Item, ItemKind, TraitItem, TraitItemKind};\n \n+use crate::def::DefKind;\n use std::fmt::{self, Display};\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -130,6 +131,30 @@ impl Target {\n         }\n     }\n \n+    // FIXME: For now, should only be used with def_kinds from ItemIds\n+    pub fn from_def_kind(def_kind: DefKind) -> Target {\n+        match def_kind {\n+            DefKind::ExternCrate => Target::ExternCrate,\n+            DefKind::Use => Target::Use,\n+            DefKind::Static(..) => Target::Static,\n+            DefKind::Const => Target::Const,\n+            DefKind::Fn => Target::Fn,\n+            DefKind::Macro(..) => Target::MacroDef,\n+            DefKind::Mod => Target::Mod,\n+            DefKind::ForeignMod => Target::ForeignMod,\n+            DefKind::GlobalAsm => Target::GlobalAsm,\n+            DefKind::TyAlias => Target::TyAlias,\n+            DefKind::OpaqueTy => Target::OpaqueTy,\n+            DefKind::Enum => Target::Enum,\n+            DefKind::Struct => Target::Struct,\n+            DefKind::Union => Target::Union,\n+            DefKind::Trait => Target::Trait,\n+            DefKind::TraitAlias => Target::TraitAlias,\n+            DefKind::Impl => Target::Impl,\n+            _ => panic!(\"impossible case reached\"),\n+        }\n+    }\n+\n     pub fn from_trait_item(trait_item: &TraitItem<'_>) -> Target {\n         match trait_item.kind {\n             TraitItemKind::Const(..) => Target::AssocConst,"}, {"sha": "aaf24636598b9c98a95574ee7def5b42fd869768", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=edba28277038f24ee80b88b66e054ec33facefa4", "patch": "@@ -24,7 +24,6 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::Node as HirNode;\n use rustc_hir::{ImplItemKind, ItemKind as HirItem, TraitItemKind};\n use rustc_middle::dep_graph::{label_strs, DepNode, DepNodeExt};\n@@ -147,7 +146,24 @@ pub fn check_dirty_clean_annotations(tcx: TyCtxt<'_>) {\n \n     tcx.dep_graph.with_ignore(|| {\n         let mut dirty_clean_visitor = DirtyCleanVisitor { tcx, checked_attrs: Default::default() };\n-        tcx.hir().visit_all_item_likes(&mut dirty_clean_visitor);\n+\n+        let crate_items = tcx.hir_crate_items(());\n+\n+        for id in crate_items.items() {\n+            dirty_clean_visitor.check_item(id.def_id);\n+        }\n+\n+        for id in crate_items.trait_items() {\n+            dirty_clean_visitor.check_item(id.def_id);\n+        }\n+\n+        for id in crate_items.impl_items() {\n+            dirty_clean_visitor.check_item(id.def_id);\n+        }\n+\n+        for id in crate_items.foreign_items() {\n+            dirty_clean_visitor.check_item(id.def_id);\n+        }\n \n         let mut all_attrs = FindAllAttrs { tcx, found_attrs: vec![] };\n         tcx.hir().walk_attributes(&mut all_attrs);\n@@ -365,7 +381,8 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n         }\n     }\n \n-    fn check_item(&mut self, item_id: LocalDefId, item_span: Span) {\n+    fn check_item(&mut self, item_id: LocalDefId) {\n+        let item_span = self.tcx.def_span(item_id.to_def_id());\n         let def_path_hash = self.tcx.def_path_hash(item_id.to_def_id());\n         for attr in self.tcx.get_attrs(item_id.to_def_id()).iter() {\n             let Some(assertion) = self.assertion_maybe(item_id, attr) else {\n@@ -388,24 +405,6 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n     }\n }\n \n-impl<'tcx> ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'tcx> {\n-    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        self.check_item(item.def_id, item.span);\n-    }\n-\n-    fn visit_trait_item(&mut self, item: &hir::TraitItem<'_>) {\n-        self.check_item(item.def_id, item.span);\n-    }\n-\n-    fn visit_impl_item(&mut self, item: &hir::ImplItem<'_>) {\n-        self.check_item(item.def_id, item.span);\n-    }\n-\n-    fn visit_foreign_item(&mut self, item: &hir::ForeignItem<'_>) {\n-        self.check_item(item.def_id, item.span);\n-    }\n-}\n-\n /// Given a `#[rustc_clean]` attribute, scan for a `cfg=\"foo\"` attribute and check whether we have\n /// a cfg flag called `foo`.\n fn check_config(tcx: TyCtxt<'_>, attr: &Attribute) -> bool {"}, {"sha": "5371c513d29819102df2d4cb9af3e6d8e6238024", "filename": "compiler/rustc_interface/src/proc_macro_decls.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs?ref=edba28277038f24ee80b88b66e054ec33facefa4", "patch": "@@ -1,35 +1,25 @@\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n \n fn proc_macro_decls_static(tcx: TyCtxt<'_>, (): ()) -> Option<LocalDefId> {\n     let mut finder = Finder { tcx, decls: None };\n-    tcx.hir().visit_all_item_likes(&mut finder);\n \n-    finder.decls.map(|id| tcx.hir().local_def_id(id))\n-}\n-\n-struct Finder<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    decls: Option<hir::HirId>,\n-}\n-\n-impl<'v> ItemLikeVisitor<'v> for Finder<'_> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let attrs = self.tcx.hir().attrs(item.hir_id());\n-        if self.tcx.sess.contains_name(attrs, sym::rustc_proc_macro_decls) {\n-            self.decls = Some(item.hir_id());\n+    for id in tcx.hir().items() {\n+        let attrs = finder.tcx.hir().attrs(id.hir_id());\n+        if finder.tcx.sess.contains_name(attrs, sym::rustc_proc_macro_decls) {\n+            finder.decls = Some(id.def_id);\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {}\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {}\n+    finder.decls\n+}\n \n-    fn visit_foreign_item(&mut self, _foreign_item: &hir::ForeignItem<'_>) {}\n+struct Finder<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    decls: Option<hir::def_id::LocalDefId>,\n }\n \n pub(crate) fn provide(providers: &mut Providers) {"}, {"sha": "97fcbeb4ccc59962f6517c9da9973a4023b66835", "filename": "compiler/rustc_metadata/src/foreign_modules.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs?ref=edba28277038f24ee80b88b66e054ec33facefa4", "patch": "@@ -1,29 +1,19 @@\n use rustc_hir as hir;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_hir::def::DefKind;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::cstore::ForeignModule;\n \n crate fn collect(tcx: TyCtxt<'_>) -> Vec<ForeignModule> {\n-    let mut collector = Collector { modules: Vec::new() };\n-    tcx.hir().visit_all_item_likes(&mut collector);\n-    collector.modules\n-}\n-\n-struct Collector {\n-    modules: Vec<ForeignModule>,\n-}\n-\n-impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n-    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n-        let hir::ItemKind::ForeignMod { items, .. } = it.kind else {\n-            return;\n-        };\n-\n-        let foreign_items = items.iter().map(|it| it.id.def_id.to_def_id()).collect();\n-        self.modules.push(ForeignModule { foreign_items, def_id: it.def_id.to_def_id() });\n+    let mut modules = Vec::new();\n+    for id in tcx.hir().items() {\n+        if !matches!(tcx.hir().def_kind(id.def_id), DefKind::ForeignMod) {\n+            continue;\n+        }\n+        let item = tcx.hir().item(id);\n+        if let hir::ItemKind::ForeignMod { items, .. } = item.kind {\n+            let foreign_items = items.iter().map(|it| it.id.def_id.to_def_id()).collect();\n+            modules.push(ForeignModule { foreign_items, def_id: id.def_id.to_def_id() });\n+        }\n     }\n-\n-    fn visit_trait_item(&mut self, _it: &'tcx hir::TraitItem<'tcx>) {}\n-    fn visit_impl_item(&mut self, _it: &'tcx hir::ImplItem<'tcx>) {}\n-    fn visit_foreign_item(&mut self, _it: &'tcx hir::ForeignItem<'tcx>) {}\n+    modules\n }"}, {"sha": "43b6ecee794cd73cfca5a74488638e72f085616b", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=edba28277038f24ee80b88b66e054ec33facefa4", "patch": "@@ -3,7 +3,7 @@ use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_hir::def::DefKind;\n use rustc_middle::ty::{List, ParamEnv, ParamEnvAnd, Ty, TyCtxt};\n use rustc_session::cstore::{DllCallingConvention, DllImport, NativeLib};\n use rustc_session::parse::feature_err;\n@@ -15,7 +15,9 @@ use rustc_target::spec::abi::Abi;\n \n crate fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLib> {\n     let mut collector = Collector { tcx, libs: Vec::new() };\n-    tcx.hir().visit_all_item_likes(&mut collector);\n+    for id in tcx.hir().items() {\n+        collector.process_item(id);\n+    }\n     collector.process_command_line();\n     collector.libs\n }\n@@ -32,8 +34,13 @@ struct Collector<'tcx> {\n     libs: Vec<NativeLib>,\n }\n \n-impl<'tcx> ItemLikeVisitor<'tcx> for Collector<'tcx> {\n-    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n+impl<'tcx> Collector<'tcx> {\n+    fn process_item(&mut self, id: rustc_hir::ItemId) {\n+        if !matches!(self.tcx.hir().def_kind(id.def_id), DefKind::ForeignMod) {\n+            return;\n+        }\n+\n+        let it = self.tcx.hir().item(id);\n         let hir::ItemKind::ForeignMod { abi, items: foreign_mod_items } = it.kind else {\n             return;\n         };\n@@ -252,12 +259,6 @@ impl<'tcx> ItemLikeVisitor<'tcx> for Collector<'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _it: &'tcx hir::TraitItem<'tcx>) {}\n-    fn visit_impl_item(&mut self, _it: &'tcx hir::ImplItem<'tcx>) {}\n-    fn visit_foreign_item(&mut self, _it: &'tcx hir::ForeignItem<'tcx>) {}\n-}\n-\n-impl Collector<'_> {\n     fn register_native_lib(&mut self, span: Option<Span>, lib: NativeLib) {\n         if lib.name.as_ref().map_or(false, |&s| s == kw::Empty) {\n             match span {"}, {"sha": "6a8d4e037544c6d8e77d1fe0aaa08c448b01e2f0", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 20, "deletions": 38, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=edba28277038f24ee80b88b66e054ec33facefa4", "patch": "@@ -1787,10 +1787,27 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         debug!(\"EncodeContext::encode_traits_and_impls()\");\n         empty_proc_macro!(self);\n         let tcx = self.tcx;\n-        let mut visitor = ImplsVisitor { tcx, impls: FxHashMap::default() };\n-        tcx.hir().visit_all_item_likes(&mut visitor);\n+        let mut fx_hash_map: FxHashMap<DefId, Vec<(DefIndex, Option<SimplifiedType>)>> =\n+            FxHashMap::default();\n \n-        let mut all_impls: Vec<_> = visitor.impls.into_iter().collect();\n+        for id in tcx.hir().items() {\n+            if matches!(tcx.hir().def_kind(id.def_id), DefKind::Impl) {\n+                if let Some(trait_ref) = tcx.impl_trait_ref(id.def_id.to_def_id()) {\n+                    let simplified_self_ty = fast_reject::simplify_type(\n+                        self.tcx,\n+                        trait_ref.self_ty(),\n+                        TreatParams::AsPlaceholders,\n+                    );\n+\n+                    fx_hash_map\n+                        .entry(trait_ref.def_id)\n+                        .or_default()\n+                        .push((id.def_id.local_def_index, simplified_self_ty));\n+                }\n+            }\n+        }\n+\n+        let mut all_impls: Vec<_> = fx_hash_map.into_iter().collect();\n \n         // Bring everything into deterministic order for hashing\n         all_impls.sort_by_cached_key(|&(trait_def_id, _)| tcx.def_path_hash(trait_def_id));\n@@ -2053,41 +2070,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n }\n \n-struct ImplsVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    impls: FxHashMap<DefId, Vec<(DefIndex, Option<SimplifiedType>)>>,\n-}\n-\n-impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplsVisitor<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        match item.kind {\n-            hir::ItemKind::Impl(..) => {\n-                if let Some(trait_ref) = self.tcx.impl_trait_ref(item.def_id.to_def_id()) {\n-                    let simplified_self_ty = fast_reject::simplify_type(\n-                        self.tcx,\n-                        trait_ref.self_ty(),\n-                        TreatParams::AsPlaceholders,\n-                    );\n-\n-                    self.impls\n-                        .entry(trait_ref.def_id)\n-                        .or_default()\n-                        .push((item.def_id.local_def_index, simplified_self_ty));\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, _trait_item: &'v hir::TraitItem<'v>) {}\n-\n-    fn visit_impl_item(&mut self, _impl_item: &'v hir::ImplItem<'v>) {\n-        // handled in `visit_item` above\n-    }\n-\n-    fn visit_foreign_item(&mut self, _foreign_item: &'v hir::ForeignItem<'v>) {}\n-}\n-\n /// Used to prefetch queries which will be needed later by metadata encoding.\n /// Only a subset of the queries are actually prefetched to keep this code smaller.\n fn prefetch_mir(tcx: TyCtxt<'_>) {"}, {"sha": "d74759e31a2d907514c87232a8ed1344c4b4d75f", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 75, "deletions": 14, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=edba28277038f24ee80b88b66e054ec33facefa4", "patch": "@@ -18,7 +18,6 @@ use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n-use std::collections::VecDeque;\n \n fn fn_decl<'hir>(node: Node<'hir>) -> Option<&'hir FnDecl<'hir>> {\n     match node {\n@@ -159,12 +158,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn items(self) -> impl Iterator<Item = &'hir Item<'hir>> + 'hir {\n-        let krate = self.krate();\n-        krate.owners.iter().filter_map(|owner| match owner.as_owner()?.node() {\n-            OwnerNode::Item(item) => Some(item),\n-            _ => None,\n-        })\n+    pub fn items(self) -> impl Iterator<Item = ItemId> + 'hir {\n+        self.tcx.hir_crate_items(()).items.iter().copied()\n+    }\n+\n+    pub fn par_for_each_item(self, f: impl Fn(ItemId) + Sync + Send) {\n+        par_for_each_in(&self.tcx.hir_crate_items(()).items[..], |id| f(*id));\n     }\n \n     pub fn def_key(self, def_id: LocalDefId) -> DefKey {\n@@ -675,13 +674,9 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn for_each_module(self, f: impl Fn(LocalDefId)) {\n-        let mut queue = VecDeque::new();\n-        queue.push_back(CRATE_DEF_ID);\n-\n-        while let Some(id) = queue.pop_front() {\n-            f(id);\n-            let items = self.tcx.hir_module_items(id);\n-            queue.extend(items.submodules.iter().copied())\n+        let crate_items = self.tcx.hir_crate_items(());\n+        for module in crate_items.submodules.iter() {\n+            f(*module)\n         }\n     }\n \n@@ -1308,3 +1303,69 @@ pub(super) fn hir_module_items(tcx: TyCtxt<'_>, module_id: LocalDefId) -> Module\n         }\n     }\n }\n+\n+pub(crate) fn hir_crate_items(tcx: TyCtxt<'_>, _: ()) -> ModuleItems {\n+    let mut collector = CrateCollector {\n+        tcx,\n+        submodules: Vec::default(),\n+        items: Vec::default(),\n+        trait_items: Vec::default(),\n+        impl_items: Vec::default(),\n+        foreign_items: Vec::default(),\n+    };\n+\n+    tcx.hir().walk_toplevel_module(&mut collector);\n+\n+    let CrateCollector { submodules, items, trait_items, impl_items, foreign_items, .. } =\n+        collector;\n+\n+    return ModuleItems {\n+        submodules: submodules.into_boxed_slice(),\n+        items: items.into_boxed_slice(),\n+        trait_items: trait_items.into_boxed_slice(),\n+        impl_items: impl_items.into_boxed_slice(),\n+        foreign_items: foreign_items.into_boxed_slice(),\n+    };\n+\n+    struct CrateCollector<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        submodules: Vec<LocalDefId>,\n+        items: Vec<ItemId>,\n+        trait_items: Vec<TraitItemId>,\n+        impl_items: Vec<ImplItemId>,\n+        foreign_items: Vec<ForeignItemId>,\n+    }\n+\n+    impl<'hir> Visitor<'hir> for CrateCollector<'hir> {\n+        type NestedFilter = nested_filter::All;\n+\n+        fn nested_visit_map(&mut self) -> Self::Map {\n+            self.tcx.hir()\n+        }\n+\n+        fn visit_item(&mut self, item: &'hir Item<'hir>) {\n+            self.items.push(item.item_id());\n+            intravisit::walk_item(self, item)\n+        }\n+\n+        fn visit_mod(&mut self, m: &'hir Mod<'hir>, _s: Span, n: HirId) {\n+            self.submodules.push(n.owner);\n+            intravisit::walk_mod(self, m, n);\n+        }\n+\n+        fn visit_foreign_item(&mut self, item: &'hir ForeignItem<'hir>) {\n+            self.foreign_items.push(item.foreign_item_id());\n+            intravisit::walk_foreign_item(self, item)\n+        }\n+\n+        fn visit_trait_item(&mut self, item: &'hir TraitItem<'hir>) {\n+            self.trait_items.push(item.trait_item_id());\n+            intravisit::walk_trait_item(self, item)\n+        }\n+\n+        fn visit_impl_item(&mut self, item: &'hir ImplItem<'hir>) {\n+            self.impl_items.push(item.impl_item_id());\n+            intravisit::walk_impl_item(self, item)\n+        }\n+    }\n+}"}, {"sha": "f18067145dd4a377a2aefd64f88d51b83fdcbded", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=edba28277038f24ee80b88b66e054ec33facefa4", "patch": "@@ -45,6 +45,24 @@ pub struct ModuleItems {\n     foreign_items: Box<[ForeignItemId]>,\n }\n \n+impl ModuleItems {\n+    pub fn items(&self) -> impl Iterator<Item = ItemId> + '_ {\n+        self.items.iter().copied()\n+    }\n+\n+    pub fn trait_items(&self) -> impl Iterator<Item = TraitItemId> + '_ {\n+        self.trait_items.iter().copied()\n+    }\n+\n+    pub fn impl_items(&self) -> impl Iterator<Item = ImplItemId> + '_ {\n+        self.impl_items.iter().copied()\n+    }\n+\n+    pub fn foreign_items(&self) -> impl Iterator<Item = ForeignItemId> + '_ {\n+        self.foreign_items.iter().copied()\n+    }\n+}\n+\n impl<'tcx> TyCtxt<'tcx> {\n     #[inline(always)]\n     pub fn hir(self) -> map::Map<'tcx> {\n@@ -68,6 +86,7 @@ pub fn provide(providers: &mut Providers) {\n         hir.get_module_parent_node(hir.local_def_id_to_hir_id(id))\n     };\n     providers.hir_crate = |tcx, ()| tcx.untracked_crate;\n+    providers.hir_crate_items = map::hir_crate_items;\n     providers.crate_hash = map::crate_hash;\n     providers.hir_module_items = map::hir_module_items;\n     providers.hir_owner = |tcx, id| {"}, {"sha": "999cb9f30b8aa642fbc8e17c80f6cc8c2fab0c97", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=edba28277038f24ee80b88b66e054ec33facefa4", "patch": "@@ -45,6 +45,13 @@ rustc_queries! {\n         desc { \"get the crate HIR\" }\n     }\n \n+    /// All items in the crate.\n+    query hir_crate_items(_: ()) -> rustc_middle::hir::ModuleItems {\n+        storage(ArenaCacheSelector<'tcx>)\n+        eval_always\n+        desc { \"get HIR crate items\" }\n+    }\n+\n     /// The items in a module.\n     ///\n     /// This can be conveniently accessed by `tcx.hir().visit_item_likes_in_module`."}, {"sha": "cac46ba25fe6bc3db7397e12a3e5bd7f5c07d4b0", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=edba28277038f24ee80b88b66e054ec33facefa4", "patch": "@@ -8,7 +8,6 @@ use rustc_hir as hir;\n use rustc_hir::def::{self, CtorKind, DefKind, Namespace};\n use rustc_hir::def_id::{DefId, DefIdSet, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::{DefPathData, DefPathDataName, DisambiguatedDefPathData};\n-use rustc_hir::ItemKind;\n use rustc_session::config::TrimmedDefPaths;\n use rustc_session::cstore::{ExternCrate, ExternCrateSource};\n use rustc_span::symbol::{kw, Ident, Symbol};\n@@ -2678,8 +2677,13 @@ define_print_and_forward_display! {\n fn for_each_def(tcx: TyCtxt<'_>, mut collect_fn: impl for<'b> FnMut(&'b Ident, Namespace, DefId)) {\n     // Iterate all local crate items no matter where they are defined.\n     let hir = tcx.hir();\n-    for item in hir.items() {\n-        if item.ident.name.as_str().is_empty() || matches!(item.kind, ItemKind::Use(_, _)) {\n+    for id in hir.items() {\n+        if matches!(hir.def_kind(id.def_id), DefKind::Use) {\n+            continue;\n+        }\n+\n+        let item = hir.item(id);\n+        if item.ident.name == kw::Empty {\n             continue;\n         }\n "}, {"sha": "0e0a4fbc2155641b87a080983c72fae181044db1", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 55, "deletions": 60, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=edba28277038f24ee80b88b66e054ec33facefa4", "patch": "@@ -181,8 +181,8 @@\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{par_iter, MTLock, MTRef, ParallelIterator};\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::bit_set::GrowableBitSet;\n use rustc_middle::mir::interpret::{AllocId, ConstValue};\n@@ -327,11 +327,19 @@ fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<\n \n         debug!(\"collect_roots: entry_fn = {:?}\", entry_fn);\n \n-        let mut visitor = RootCollector { tcx, mode, entry_fn, output: &mut roots };\n+        let mut collector = RootCollector { tcx, mode, entry_fn, output: &mut roots };\n \n-        tcx.hir().visit_all_item_likes(&mut visitor);\n+        let crate_items = tcx.hir_crate_items(());\n \n-        visitor.push_extra_entry_roots();\n+        for id in crate_items.items() {\n+            collector.process_item(id);\n+        }\n+\n+        for id in crate_items.impl_items() {\n+            collector.process_impl_item(id);\n+        }\n+\n+        collector.push_extra_entry_roots();\n     }\n \n     // We can only codegen items that are instantiable - items all of\n@@ -1159,87 +1167,74 @@ struct RootCollector<'a, 'tcx> {\n     entry_fn: Option<(DefId, EntryFnType)>,\n }\n \n-impl<'v> ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n-    fn visit_item(&mut self, item: &'v hir::Item<'v>) {\n-        match item.kind {\n-            hir::ItemKind::ExternCrate(..)\n-            | hir::ItemKind::Use(..)\n-            | hir::ItemKind::Macro(..)\n-            | hir::ItemKind::ForeignMod { .. }\n-            | hir::ItemKind::TyAlias(..)\n-            | hir::ItemKind::Trait(..)\n-            | hir::ItemKind::TraitAlias(..)\n-            | hir::ItemKind::OpaqueTy(..)\n-            | hir::ItemKind::Mod(..) => {\n-                // Nothing to do, just keep recursing.\n-            }\n-\n-            hir::ItemKind::Impl { .. } => {\n-                if self.mode == MonoItemCollectionMode::Eager {\n-                    create_mono_items_for_default_impls(self.tcx, item, self.output);\n-                }\n-            }\n-\n-            hir::ItemKind::Enum(_, ref generics)\n-            | hir::ItemKind::Struct(_, ref generics)\n-            | hir::ItemKind::Union(_, ref generics) => {\n-                if generics.params.is_empty() {\n-                    if self.mode == MonoItemCollectionMode::Eager {\n-                        debug!(\n-                            \"RootCollector: ADT drop-glue for {}\",\n-                            self.tcx.def_path_str(item.def_id.to_def_id())\n-                        );\n-\n-                        let ty = Instance::new(item.def_id.to_def_id(), InternalSubsts::empty())\n-                            .ty(self.tcx, ty::ParamEnv::reveal_all());\n-                        visit_drop_use(self.tcx, ty, true, DUMMY_SP, self.output);\n+impl<'v> RootCollector<'_, 'v> {\n+    fn process_item(&mut self, id: hir::ItemId) {\n+        match self.tcx.hir().def_kind(id.def_id) {\n+            DefKind::Enum | DefKind::Struct | DefKind::Union => {\n+                let item = self.tcx.hir().item(id);\n+                match item.kind {\n+                    hir::ItemKind::Enum(_, ref generics)\n+                    | hir::ItemKind::Struct(_, ref generics)\n+                    | hir::ItemKind::Union(_, ref generics) => {\n+                        if generics.params.is_empty() {\n+                            if self.mode == MonoItemCollectionMode::Eager {\n+                                debug!(\n+                                    \"RootCollector: ADT drop-glue for {}\",\n+                                    self.tcx.def_path_str(item.def_id.to_def_id())\n+                                );\n+\n+                                let ty =\n+                                    Instance::new(item.def_id.to_def_id(), InternalSubsts::empty())\n+                                        .ty(self.tcx, ty::ParamEnv::reveal_all());\n+                                visit_drop_use(self.tcx, ty, true, DUMMY_SP, self.output);\n+                            }\n+                        }\n                     }\n+                    _ => bug!(),\n                 }\n             }\n-            hir::ItemKind::GlobalAsm(..) => {\n+            DefKind::GlobalAsm => {\n                 debug!(\n                     \"RootCollector: ItemKind::GlobalAsm({})\",\n-                    self.tcx.def_path_str(item.def_id.to_def_id())\n+                    self.tcx.def_path_str(id.def_id.to_def_id())\n                 );\n-                self.output.push(dummy_spanned(MonoItem::GlobalAsm(item.item_id())));\n+                self.output.push(dummy_spanned(MonoItem::GlobalAsm(id)));\n             }\n-            hir::ItemKind::Static(..) => {\n+            DefKind::Static(..) => {\n                 debug!(\n                     \"RootCollector: ItemKind::Static({})\",\n-                    self.tcx.def_path_str(item.def_id.to_def_id())\n+                    self.tcx.def_path_str(id.def_id.to_def_id())\n                 );\n-                self.output.push(dummy_spanned(MonoItem::Static(item.def_id.to_def_id())));\n+                self.output.push(dummy_spanned(MonoItem::Static(id.def_id.to_def_id())));\n             }\n-            hir::ItemKind::Const(..) => {\n+            DefKind::Const => {\n                 // const items only generate mono items if they are\n                 // actually used somewhere. Just declaring them is insufficient.\n \n                 // but even just declaring them must collect the items they refer to\n-                if let Ok(val) = self.tcx.const_eval_poly(item.def_id.to_def_id()) {\n+                if let Ok(val) = self.tcx.const_eval_poly(id.def_id.to_def_id()) {\n                     collect_const_value(self.tcx, val, &mut self.output);\n                 }\n             }\n-            hir::ItemKind::Fn(..) => {\n-                self.push_if_root(item.def_id);\n+            DefKind::Impl => {\n+                if self.mode == MonoItemCollectionMode::Eager {\n+                    let item = self.tcx.hir().item(id);\n+                    create_mono_items_for_default_impls(self.tcx, item, self.output);\n+                }\n+            }\n+            DefKind::Fn => {\n+                self.push_if_root(id.def_id);\n             }\n+            _ => {}\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _: &'v hir::TraitItem<'v>) {\n-        // Even if there's a default body with no explicit generics,\n-        // it's still generic over some `Self: Trait`, so not a root.\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'v hir::ImplItem<'v>) {\n-        if let hir::ImplItemKind::Fn(hir::FnSig { .. }, _) = ii.kind {\n-            self.push_if_root(ii.def_id);\n+    fn process_impl_item(&mut self, id: hir::ImplItemId) {\n+        if matches!(self.tcx.hir().def_kind(id.def_id), DefKind::AssocFn) {\n+            self.push_if_root(id.def_id);\n         }\n     }\n \n-    fn visit_foreign_item(&mut self, _foreign_item: &'v hir::ForeignItem<'v>) {}\n-}\n-\n-impl<'v> RootCollector<'_, 'v> {\n     fn is_root(&self, def_id: LocalDefId) -> bool {\n         !item_requires_monomorphization(self.tcx, def_id)\n             && match self.mode {"}, {"sha": "18d9bdf8e1792d7b86d6442bbc9e72fc07b6e954", "filename": "compiler/rustc_passes/src/lang_items.rs", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs?ref=edba28277038f24ee80b88b66e054ec33facefa4", "patch": "@@ -12,8 +12,8 @@ use crate::weak_lang_items;\n \n use rustc_errors::{pluralize, struct_span_err};\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::lang_items::{extract, GenericRequirement, ITEM_REFS};\n use rustc_hir::{HirId, LangItem, LanguageItems, Target};\n use rustc_middle::ty::TyCtxt;\n@@ -27,28 +27,6 @@ struct LanguageItemCollector<'tcx> {\n     tcx: TyCtxt<'tcx>,\n }\n \n-impl<'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        self.check_for_lang(Target::from_item(item), item.hir_id());\n-\n-        if let hir::ItemKind::Enum(def, ..) = &item.kind {\n-            for variant in def.variants {\n-                self.check_for_lang(Target::Variant, variant.id);\n-            }\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem<'_>) {\n-        self.check_for_lang(Target::from_trait_item(trait_item), trait_item.hir_id())\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem<'_>) {\n-        self.check_for_lang(target_from_impl_item(self.tcx, impl_item), impl_item.hir_id())\n-    }\n-\n-    fn visit_foreign_item(&mut self, _: &hir::ForeignItem<'_>) {}\n-}\n-\n impl<'tcx> LanguageItemCollector<'tcx> {\n     fn new(tcx: TyCtxt<'tcx>) -> LanguageItemCollector<'tcx> {\n         LanguageItemCollector { tcx, items: LanguageItems::new() }\n@@ -259,7 +237,32 @@ fn get_lang_items(tcx: TyCtxt<'_>, (): ()) -> LanguageItems {\n     }\n \n     // Collect lang items in this crate.\n-    tcx.hir().visit_all_item_likes(&mut collector);\n+    let crate_items = tcx.hir_crate_items(());\n+\n+    for id in crate_items.items() {\n+        collector.check_for_lang(Target::from_def_kind(tcx.hir().def_kind(id.def_id)), id.hir_id());\n+\n+        if matches!(tcx.hir().def_kind(id.def_id), DefKind::Enum) {\n+            let item = tcx.hir().item(id);\n+            if let hir::ItemKind::Enum(def, ..) = &item.kind {\n+                for variant in def.variants {\n+                    collector.check_for_lang(Target::Variant, variant.id);\n+                }\n+            }\n+        }\n+    }\n+\n+    // FIXME: avoid calling trait_item() when possible\n+    for id in crate_items.trait_items() {\n+        let item = tcx.hir().trait_item(id);\n+        collector.check_for_lang(Target::from_trait_item(item), item.hir_id())\n+    }\n+\n+    // FIXME: avoid calling impl_item() when possible\n+    for id in crate_items.impl_items() {\n+        let item = tcx.hir().impl_item(id);\n+        collector.check_for_lang(target_from_impl_item(tcx, item), item.hir_id())\n+    }\n \n     // Extract out the found lang items.\n     let LanguageItemCollector { mut items, .. } = collector;"}, {"sha": "5411946343b74c7d2cc4f2f9e7a0761a09650cd8", "filename": "compiler/rustc_passes/src/weak_lang_items.rs", "status": "modified", "additions": 21, "deletions": 35, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs?ref=edba28277038f24ee80b88b66e054ec33facefa4", "patch": "@@ -2,20 +2,11 @@\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n-use rustc_hir as hir;\n-use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::lang_items::{self, LangItem};\n use rustc_hir::weak_lang_items::WEAK_ITEMS_REFS;\n use rustc_middle::middle::lang_items::required;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::CrateType;\n-use rustc_span::symbol::Symbol;\n-use rustc_span::Span;\n-\n-struct Context<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    items: &'a mut lang_items::LanguageItems,\n-}\n \n /// Checks the crate for usage of weak lang items, returning a vector of all the\n /// language items required by this crate, but not defined yet.\n@@ -30,10 +21,28 @@ pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>, items: &mut lang_items::LanguageItem\n         items.missing.push(LangItem::EhCatchTypeinfo);\n     }\n \n-    {\n-        let mut cx = Context { tcx, items };\n-        tcx.hir().visit_all_item_likes(&mut cx.as_deep_visitor());\n+    let crate_items = tcx.hir_crate_items(());\n+    for id in crate_items.foreign_items() {\n+        let attrs = tcx.hir().attrs(id.hir_id());\n+        if let Some((lang_item, _)) = lang_items::extract(attrs) {\n+            if let Some(&item) = WEAK_ITEMS_REFS.get(&lang_item) {\n+                if items.require(item).is_err() {\n+                    items.missing.push(item);\n+                }\n+            } else {\n+                let span = tcx.def_span(id.def_id);\n+                struct_span_err!(\n+                    tcx.sess,\n+                    span,\n+                    E0264,\n+                    \"unknown external lang item: `{}`\",\n+                    lang_item\n+                )\n+                .emit();\n+            }\n+        }\n     }\n+\n     verify(tcx, items);\n }\n \n@@ -80,26 +89,3 @@ fn verify<'tcx>(tcx: TyCtxt<'tcx>, items: &lang_items::LanguageItems) {\n         }\n     }\n }\n-\n-impl<'a, 'tcx> Context<'a, 'tcx> {\n-    fn register(&mut self, name: Symbol, span: Span) {\n-        if let Some(&item) = WEAK_ITEMS_REFS.get(&name) {\n-            if self.items.require(item).is_err() {\n-                self.items.missing.push(item);\n-            }\n-        } else {\n-            struct_span_err!(self.tcx.sess, span, E0264, \"unknown external lang item: `{}`\", name)\n-                .emit();\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n-    fn visit_foreign_item(&mut self, i: &hir::ForeignItem<'_>) {\n-        let attrs = self.tcx.hir().attrs(i.hir_id());\n-        if let Some((lang_item, _)) = lang_items::extract(attrs) {\n-            self.register(lang_item, i.span);\n-        }\n-        intravisit::walk_foreign_item(self, i)\n-    }\n-}"}, {"sha": "37d1cffa2a52b9e1f6cc482a1208df1c52a53b4f", "filename": "compiler/rustc_symbol_mangling/src/test.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs?ref=edba28277038f24ee80b88b66e054ec33facefa4", "patch": "@@ -4,7 +4,6 @@\n //! def-path. This is used for unit testing the code that generates\n //! paths etc in all kinds of annoying scenarios.\n \n-use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{subst::InternalSubsts, Instance, TyCtxt};\n@@ -22,8 +21,24 @@ pub fn report_symbol_names(tcx: TyCtxt<'_>) {\n     }\n \n     tcx.dep_graph.with_ignore(|| {\n-        let mut visitor = SymbolNamesTest { tcx };\n-        tcx.hir().visit_all_item_likes(&mut visitor);\n+        let mut symbol_names = SymbolNamesTest { tcx };\n+        let crate_items = tcx.hir_crate_items(());\n+\n+        for id in crate_items.items() {\n+            symbol_names.process_attrs(id.def_id);\n+        }\n+\n+        for id in crate_items.trait_items() {\n+            symbol_names.process_attrs(id.def_id);\n+        }\n+\n+        for id in crate_items.impl_items() {\n+            symbol_names.process_attrs(id.def_id);\n+        }\n+\n+        for id in crate_items.foreign_items() {\n+            symbol_names.process_attrs(id.def_id);\n+        }\n     })\n }\n \n@@ -58,21 +73,3 @@ impl SymbolNamesTest<'_> {\n         }\n     }\n }\n-\n-impl<'tcx> hir::itemlikevisit::ItemLikeVisitor<'tcx> for SymbolNamesTest<'tcx> {\n-    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        self.process_attrs(item.def_id);\n-    }\n-\n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n-        self.process_attrs(trait_item.def_id);\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n-        self.process_attrs(impl_item.def_id);\n-    }\n-\n-    fn visit_foreign_item(&mut self, foreign_item: &'tcx hir::ForeignItem<'tcx>) {\n-        self.process_attrs(foreign_item.def_id);\n-    }\n-}"}, {"sha": "4f792fa25a12b88e7f2600d452e580061e9ff264", "filename": "compiler/rustc_typeck/src/check_unused.rs", "status": "modified", "additions": 46, "deletions": 72, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs?ref=edba28277038f24ee80b88b66e054ec33facefa4", "patch": "@@ -1,72 +1,58 @@\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::lint;\n use rustc_span::{Span, Symbol};\n \n pub fn check_crate(tcx: TyCtxt<'_>) {\n-    let mut used_trait_imports = FxHashSet::default();\n+    let mut used_trait_imports: FxHashSet<LocalDefId> = FxHashSet::default();\n+\n     for item_def_id in tcx.hir().body_owners() {\n         let imports = tcx.used_trait_imports(item_def_id);\n         debug!(\"GatherVisitor: item_def_id={:?} with imports {:#?}\", item_def_id, imports);\n         used_trait_imports.extend(imports.iter());\n     }\n \n-    let mut visitor = CheckVisitor { tcx, used_trait_imports };\n-    tcx.hir().visit_all_item_likes(&mut visitor);\n-\n-    unused_crates_lint(tcx);\n-}\n-\n-impl<'tcx> ItemLikeVisitor<'_> for CheckVisitor<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        if item.vis.node.is_pub() || item.span.is_dummy() {\n-            return;\n-        }\n-        if let hir::ItemKind::Use(path, _) = item.kind {\n-            self.check_import(item.item_id(), path.span);\n+    for id in tcx.hir().items() {\n+        if matches!(tcx.hir().def_kind(id.def_id), DefKind::Use) {\n+            let item = tcx.hir().item(id);\n+            if item.vis.node.is_pub() || item.span.is_dummy() {\n+                continue;\n+            }\n+            if let hir::ItemKind::Use(path, _) = item.kind {\n+                check_import(tcx, &mut used_trait_imports, item.item_id(), path.span);\n+            }\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {}\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {}\n-\n-    fn visit_foreign_item(&mut self, _foreign_item: &hir::ForeignItem<'_>) {}\n+    unused_crates_lint(tcx);\n }\n \n-struct CheckVisitor<'tcx> {\n+fn check_import<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    used_trait_imports: FxHashSet<LocalDefId>,\n-}\n-\n-impl<'tcx> CheckVisitor<'tcx> {\n-    fn check_import(&self, item_id: hir::ItemId, span: Span) {\n-        if !self.tcx.maybe_unused_trait_import(item_id.def_id) {\n-            return;\n-        }\n-\n-        if self.used_trait_imports.contains(&item_id.def_id) {\n-            return;\n-        }\n+    used_trait_imports: &mut FxHashSet<LocalDefId>,\n+    item_id: hir::ItemId,\n+    span: Span,\n+) {\n+    if !tcx.maybe_unused_trait_import(item_id.def_id) {\n+        return;\n+    }\n \n-        self.tcx.struct_span_lint_hir(\n-            lint::builtin::UNUSED_IMPORTS,\n-            item_id.hir_id(),\n-            span,\n-            |lint| {\n-                let msg = if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                    format!(\"unused import: `{}`\", snippet)\n-                } else {\n-                    \"unused import\".to_owned()\n-                };\n-                lint.build(&msg).emit();\n-            },\n-        );\n+    if used_trait_imports.contains(&item_id.def_id) {\n+        return;\n     }\n+\n+    tcx.struct_span_lint_hir(lint::builtin::UNUSED_IMPORTS, item_id.hir_id(), span, |lint| {\n+        let msg = if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(span) {\n+            format!(\"unused import: `{}`\", snippet)\n+        } else {\n+            \"unused import\".to_owned()\n+        };\n+        lint.build(&msg).emit();\n+    });\n }\n \n fn unused_crates_lint(tcx: TyCtxt<'_>) {\n@@ -110,9 +96,20 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n \n     // Collect all the extern crates (in a reliable order).\n     let mut crates_to_lint = vec![];\n-    tcx.hir().visit_all_item_likes(&mut CollectExternCrateVisitor {\n-        crates_to_lint: &mut crates_to_lint,\n-    });\n+\n+    for id in tcx.hir().items() {\n+        if matches!(tcx.hir().def_kind(id.def_id), DefKind::ExternCrate) {\n+            let item = tcx.hir().item(id);\n+            if let hir::ItemKind::ExternCrate(orig_name) = item.kind {\n+                crates_to_lint.push(ExternCrateToLint {\n+                    def_id: item.def_id.to_def_id(),\n+                    span: item.span,\n+                    orig_name,\n+                    warn_if_unused: !item.ident.as_str().starts_with('_'),\n+                });\n+            }\n+        }\n+    }\n \n     let extern_prelude = &tcx.resolutions(()).extern_prelude;\n \n@@ -193,10 +190,6 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n     }\n }\n \n-struct CollectExternCrateVisitor<'a> {\n-    crates_to_lint: &'a mut Vec<ExternCrateToLint>,\n-}\n-\n struct ExternCrateToLint {\n     /// `DefId` of the extern crate\n     def_id: DefId,\n@@ -213,22 +206,3 @@ struct ExternCrateToLint {\n     /// about it going unused (but we should still emit idiom lints).\n     warn_if_unused: bool,\n }\n-\n-impl<'a, 'v> ItemLikeVisitor<'v> for CollectExternCrateVisitor<'a> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        if let hir::ItemKind::ExternCrate(orig_name) = item.kind {\n-            self.crates_to_lint.push(ExternCrateToLint {\n-                def_id: item.def_id.to_def_id(),\n-                span: item.span,\n-                orig_name,\n-                warn_if_unused: !item.ident.as_str().starts_with('_'),\n-            });\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {}\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {}\n-\n-    fn visit_foreign_item(&mut self, _foreign_item: &hir::ForeignItem<'_>) {}\n-}"}, {"sha": "6f842c6e71a5b5aaf399f55a6a240f90f3e40cb8", "filename": "compiler/rustc_typeck/src/outlives/implicit_infer.rs", "status": "modified", "additions": 42, "deletions": 67, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edba28277038f24ee80b88b66e054ec33facefa4/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=edba28277038f24ee80b88b66e054ec33facefa4", "patch": "@@ -1,7 +1,6 @@\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::Span;\n@@ -29,81 +28,57 @@ pub fn infer_predicates<'tcx>(\n     while predicates_added {\n         predicates_added = false;\n \n-        let mut visitor = InferVisitor {\n-            tcx,\n-            global_inferred_outlives: &mut global_inferred_outlives,\n-            predicates_added: &mut predicates_added,\n-            explicit_map,\n-        };\n-\n         // Visit all the crates and infer predicates\n-        tcx.hir().visit_all_item_likes(&mut visitor);\n-    }\n+        for id in tcx.hir().items() {\n+            let item_did = id.def_id;\n \n-    global_inferred_outlives\n-}\n+            debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n \n-pub struct InferVisitor<'cx, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    global_inferred_outlives: &'cx mut FxHashMap<DefId, RequiredPredicates<'tcx>>,\n-    predicates_added: &'cx mut bool,\n-    explicit_map: &'cx mut ExplicitPredicatesMap<'tcx>,\n-}\n-\n-impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let item_did = item.def_id;\n-\n-        debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n+            let mut item_required_predicates = RequiredPredicates::default();\n+            match tcx.hir().def_kind(item_did) {\n+                DefKind::Union | DefKind::Enum | DefKind::Struct => {\n+                    let adt_def = tcx.adt_def(item_did.to_def_id());\n \n-        let mut item_required_predicates = RequiredPredicates::default();\n-        match item.kind {\n-            hir::ItemKind::Union(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Struct(..) => {\n-                let adt_def = self.tcx.adt_def(item_did.to_def_id());\n-\n-                // Iterate over all fields in item_did\n-                for field_def in adt_def.all_fields() {\n-                    // Calculating the predicate requirements necessary\n-                    // for item_did.\n-                    //\n-                    // For field of type &'a T (reference) or Adt\n-                    // (struct/enum/union) there will be outlive\n-                    // requirements for adt_def.\n-                    let field_ty = self.tcx.type_of(field_def.did);\n-                    let field_span = self.tcx.def_span(field_def.did);\n-                    insert_required_predicates_to_be_wf(\n-                        self.tcx,\n-                        field_ty,\n-                        field_span,\n-                        self.global_inferred_outlives,\n-                        &mut item_required_predicates,\n-                        &mut self.explicit_map,\n-                    );\n+                    // Iterate over all fields in item_did\n+                    for field_def in adt_def.all_fields() {\n+                        // Calculating the predicate requirements necessary\n+                        // for item_did.\n+                        //\n+                        // For field of type &'a T (reference) or Adt\n+                        // (struct/enum/union) there will be outlive\n+                        // requirements for adt_def.\n+                        let field_ty = tcx.type_of(field_def.did);\n+                        let field_span = tcx.def_span(field_def.did);\n+                        insert_required_predicates_to_be_wf(\n+                            tcx,\n+                            field_ty,\n+                            field_span,\n+                            &mut global_inferred_outlives,\n+                            &mut item_required_predicates,\n+                            explicit_map,\n+                        );\n+                    }\n                 }\n-            }\n \n-            _ => {}\n-        };\n+                _ => {}\n+            };\n \n-        // If new predicates were added (`local_predicate_map` has more\n-        // predicates than the `global_inferred_outlives`), the new predicates\n-        // might result in implied predicates for their parent types.\n-        // Therefore mark `predicates_added` as true and which will ensure\n-        // we walk the crates again and re-calculate predicates for all\n-        // items.\n-        let item_predicates_len: usize =\n-            self.global_inferred_outlives.get(&item_did.to_def_id()).map_or(0, |p| p.len());\n-        if item_required_predicates.len() > item_predicates_len {\n-            *self.predicates_added = true;\n-            self.global_inferred_outlives.insert(item_did.to_def_id(), item_required_predicates);\n+            // If new predicates were added (`local_predicate_map` has more\n+            // predicates than the `global_inferred_outlives`), the new predicates\n+            // might result in implied predicates for their parent types.\n+            // Therefore mark `predicates_added` as true and which will ensure\n+            // we walk the crates again and re-calculate predicates for all\n+            // items.\n+            let item_predicates_len: usize =\n+                global_inferred_outlives.get(&item_did.to_def_id()).map_or(0, |p| p.len());\n+            if item_required_predicates.len() > item_predicates_len {\n+                predicates_added = true;\n+                global_inferred_outlives.insert(item_did.to_def_id(), item_required_predicates);\n+            }\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &'tcx hir::TraitItem<'tcx>) {}\n-\n-    fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem<'tcx>) {}\n-\n-    fn visit_foreign_item(&mut self, _foreign_item: &'tcx hir::ForeignItem<'tcx>) {}\n+    global_inferred_outlives\n }\n \n fn insert_required_predicates_to_be_wf<'tcx>("}, {"sha": "a01e2f2db3afb2ee9c52ff3e6645c37ebaef4fe6", "filename": "src/tools/clippy/clippy_lints/src/same_name_method.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/edba28277038f24ee80b88b66e054ec33facefa4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edba28277038f24ee80b88b66e054ec33facefa4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs?ref=edba28277038f24ee80b88b66e054ec33facefa4", "patch": "@@ -50,7 +50,12 @@ impl<'tcx> LateLintPass<'tcx> for SameNameMethod {\n     fn check_crate_post(&mut self, cx: &LateContext<'tcx>) {\n         let mut map = FxHashMap::<Res, ExistingName>::default();\n \n-        for item in cx.tcx.hir().items() {\n+        for id in cx.tcx.hir().items() {\n+            if !matches!(cx.tcx.hir().def_kind(id.def_id), DefKind::Impl) {\n+                continue;\n+            }\n+\n+            let item = cx.tcx.hir().item(id);\n             if let ItemKind::Impl(Impl {\n                 items,\n                 of_trait,"}, {"sha": "cf06eb32e0c7fc041738d367cd6e6c19a4c31b85", "filename": "src/tools/clippy/tests/ui/same_name_method.stderr", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/edba28277038f24ee80b88b66e054ec33facefa4/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsame_name_method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/edba28277038f24ee80b88b66e054ec33facefa4/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsame_name_method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsame_name_method.stderr?ref=edba28277038f24ee80b88b66e054ec33facefa4", "patch": "@@ -11,6 +11,19 @@ note: existing `foo` defined here\n LL |             fn foo() {}\n    |             ^^^^^^^^^^^\n \n+error: method's name is the same as an existing method in a trait\n+  --> $DIR/same_name_method.rs:34:13\n+   |\n+LL |             fn clone() {}\n+   |             ^^^^^^^^^^^^^\n+   |\n+note: existing `clone` defined here\n+  --> $DIR/same_name_method.rs:30:18\n+   |\n+LL |         #[derive(Clone)]\n+   |                  ^^^^^\n+   = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n error: method's name is the same as an existing method in a trait\n   --> $DIR/same_name_method.rs:44:13\n    |\n@@ -47,18 +60,5 @@ note: existing `foo` defined here\n LL |         impl T1 for S {}\n    |         ^^^^^^^^^^^^^^^^\n \n-error: method's name is the same as an existing method in a trait\n-  --> $DIR/same_name_method.rs:34:13\n-   |\n-LL |             fn clone() {}\n-   |             ^^^^^^^^^^^^^\n-   |\n-note: existing `clone` defined here\n-  --> $DIR/same_name_method.rs:30:18\n-   |\n-LL |         #[derive(Clone)]\n-   |                  ^^^^^\n-   = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n error: aborting due to 5 previous errors\n "}]}